"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/onnxruntime-web";
exports.ids = ["vendor-chunks/onnxruntime-web"];
exports.modules = {

/***/ "(ssr)/./node_modules/onnxruntime-web/dist/ort.node.min.mjs?066d":
/*!************************************************************!*\
  !*** ./node_modules/onnxruntime-web/dist/ort.node.min.mjs ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "static/media/ort.node.min.15602dd5.mjs";

/***/ }),

/***/ "(ssr)/./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs?5952":
/*!*********************************************************************!*\
  !*** ./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "static/media/ort.webgpu.bundle.min.686e719e.mjs";

/***/ }),

/***/ "(ssr)/./node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm":
/*!****************************************************************************!*\
  !*** ./node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "static/media/ort-wasm-simd-threaded.jsep.da7a4538.wasm";

/***/ }),

/***/ "(ssr)/./node_modules/onnxruntime-web/dist/ort.node.min.mjs?1960":
/*!************************************************************!*\
  !*** ./node_modules/onnxruntime-web/dist/ort.node.min.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InferenceSession: () => (/* reexport safe */ onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.InferenceSession),\n/* harmony export */   TRACE: () => (/* reexport safe */ onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.TRACE),\n/* harmony export */   TRACE_FUNC_BEGIN: () => (/* reexport safe */ onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.TRACE_FUNC_BEGIN),\n/* harmony export */   TRACE_FUNC_END: () => (/* reexport safe */ onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.TRACE_FUNC_END),\n/* harmony export */   Tensor: () => (/* reexport safe */ onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.Tensor),\n/* harmony export */   \"default\": () => (/* binding */ Cr),\n/* harmony export */   env: () => (/* reexport safe */ onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env),\n/* harmony export */   registerBackend: () => (/* reexport safe */ onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.registerBackend)\n/* harmony export */ });\n/* harmony import */ var module__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! module */ \"module\");\n/* harmony import */ var onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! onnxruntime-common */ \"(ssr)/./node_modules/onnxruntime-common/dist/esm/index.js\");\n/*!\n * ONNX Runtime Web v1.21.0-dev.20250114-228dd16893\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */ \nconst require = (0,module__WEBPACK_IMPORTED_MODULE_0__.createRequire)(\"file:///Users/amityadav/Desktop/Text-Behind%20Image/node_modules/onnxruntime-web/dist/ort.node.min.mjs\");\nvar ue = Object.defineProperty;\nvar pt = Object.getOwnPropertyDescriptor;\nvar mt = Object.getOwnPropertyNames;\nvar gt = Object.prototype.hasOwnProperty;\nvar ce = ((e)=>typeof require < \"u\" ? require : typeof Proxy < \"u\" ? new Proxy(e, {\n        get: (t, n)=>(typeof require < \"u\" ? require : t)[n]\n    }) : e)(function(e) {\n    if (typeof require < \"u\") return require.apply(this, arguments);\n    throw Error('Dynamic require of \"' + e + '\" is not supported');\n});\nvar A = (e, t)=>()=>(e && (t = e(e = 0)), t);\nvar bt = (e, t)=>{\n    for(var n in t)ue(e, n, {\n        get: t[n],\n        enumerable: !0\n    });\n}, yt = (e, t, n, s)=>{\n    if (t && typeof t == \"object\" || typeof t == \"function\") for (let r of mt(t))!gt.call(e, r) && r !== n && ue(e, r, {\n        get: ()=>t[r],\n        enumerable: !(s = pt(t, r)) || s.enumerable\n    });\n    return e;\n};\nvar wt = (e)=>yt(ue({}, \"__esModule\", {\n        value: !0\n    }), e);\nvar U, Q = A(()=>{\n    \"use strict\";\n    U = !!(typeof process < \"u\" && process.versions && process.versions.node);\n});\nvar Pe, ht, k, xe, Te, St, Et, Ot, vt, Le, Ie, le = A(()=>{\n    \"use strict\";\n    Q();\n    Pe = U || typeof location > \"u\" ? void 0 : location.origin, ht = ()=>{\n        if (!U) return \"file:///Users/amityadav/Desktop/Text-Behind%20Image/node_modules/onnxruntime-web/dist/ort.node.min.mjs\"?.startsWith(\"file:\") ? new URL(/* asset import */ new __webpack_require__.U(__webpack_require__(/*! ort.node.min.mjs */ \"(ssr)/./node_modules/onnxruntime-web/dist/ort.node.min.mjs?066d\")).href, Pe).href : \"file:///Users/amityadav/Desktop/Text-Behind%20Image/node_modules/onnxruntime-web/dist/ort.node.min.mjs\";\n    }, k = ht(), xe = ()=>{\n        if (k && !k.startsWith(\"blob:\")) return k.substring(0, k.lastIndexOf(\"/\") + 1);\n    }, Te = (e, t)=>{\n        try {\n            let n = t ?? k;\n            return (n ? new URL(e, n) : new URL(e)).origin === Pe;\n        } catch  {\n            return !1;\n        }\n    }, St = (e, t)=>{\n        let n = t ?? k;\n        try {\n            return (n ? new URL(e, n) : new URL(e)).href;\n        } catch  {\n            return;\n        }\n    }, Et = (e, t)=>`${t ?? \"./\"}${e}`, Ot = async (e)=>{\n        let n = await (await fetch(e, {\n            credentials: \"same-origin\"\n        })).blob();\n        return URL.createObjectURL(n);\n    }, vt = async (e)=>(await import(/*webpackIgnore:true*/ e)).default, Le = void 0, Ie = async (e, t, n)=>{\n        if (!e && !t && Le && k && Te(k)) return [\n            void 0,\n            Le\n        ];\n        {\n            let s = \"ort-wasm-simd-threaded.mjs\", r = e ?? St(s, t), i = !U && n && r && !Te(r, t), o = i ? await Ot(r) : r ?? Et(s, t);\n            return [\n                i ? o : void 0,\n                await vt(o)\n            ];\n        }\n    };\n});\nvar fe, de, ee, _e, Tt, Lt, Ae, S, j = A(()=>{\n    \"use strict\";\n    le();\n    de = !1, ee = !1, _e = !1, Tt = ()=>{\n        if (typeof SharedArrayBuffer > \"u\") return !1;\n        try {\n            return typeof MessageChannel < \"u\" && new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)), WebAssembly.validate(new Uint8Array([\n                0,\n                97,\n                115,\n                109,\n                1,\n                0,\n                0,\n                0,\n                1,\n                4,\n                1,\n                96,\n                0,\n                0,\n                3,\n                2,\n                1,\n                0,\n                5,\n                4,\n                1,\n                3,\n                1,\n                1,\n                10,\n                11,\n                1,\n                9,\n                0,\n                65,\n                0,\n                254,\n                16,\n                2,\n                0,\n                26,\n                11\n            ]));\n        } catch  {\n            return !1;\n        }\n    }, Lt = ()=>{\n        try {\n            return WebAssembly.validate(new Uint8Array([\n                0,\n                97,\n                115,\n                109,\n                1,\n                0,\n                0,\n                0,\n                1,\n                4,\n                1,\n                96,\n                0,\n                0,\n                3,\n                2,\n                1,\n                0,\n                10,\n                30,\n                1,\n                28,\n                0,\n                65,\n                0,\n                253,\n                15,\n                253,\n                12,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                253,\n                186,\n                1,\n                26,\n                11\n            ]));\n        } catch  {\n            return !1;\n        }\n    }, Ae = async (e)=>{\n        if (de) return Promise.resolve();\n        if (ee) throw new Error(\"multiple calls to 'initializeWebAssembly()' detected.\");\n        if (_e) throw new Error(\"previous call to 'initializeWebAssembly()' failed.\");\n        ee = !0;\n        let t = e.initTimeout, n = e.numThreads;\n        if (!Lt()) throw new Error(\"WebAssembly SIMD is not supported in the current environment.\");\n        let s = Tt();\n        n > 1 && !s && (typeof self < \"u\" && !self.crossOriginIsolated && console.warn(\"env.wasm.numThreads is set to \" + n + \", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info.\"), console.warn(\"WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading.\"), e.numThreads = n = 1);\n        let r = e.wasmPaths, i = typeof r == \"string\" ? r : void 0, o = r?.mjs, a = o?.href ?? o, c = r?.wasm, d = c?.href ?? c, w = e.wasmBinary, [l, u] = await Ie(a, i, n > 1), b = !1, v = [];\n        if (t > 0 && v.push(new Promise((f)=>{\n            setTimeout(()=>{\n                b = !0, f();\n            }, t);\n        })), v.push(new Promise((f, y)=>{\n            let P = {\n                numThreads: n\n            };\n            if (w) P.wasmBinary = w;\n            else if (d || i) P.locateFile = (p)=>d ?? i + p;\n            else if (a && a.indexOf(\"blob:\") !== 0) P.locateFile = (p)=>new URL(p, a).href;\n            else if (l) {\n                let p = xe();\n                p && (P.locateFile = (h)=>p + h);\n            }\n            u(P).then((p)=>{\n                ee = !1, de = !0, fe = p, f(), l && URL.revokeObjectURL(l);\n            }, (p)=>{\n                ee = !1, _e = !0, y(p);\n            });\n        })), await Promise.race(v), b) throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`);\n    }, S = ()=>{\n        if (de && fe) return fe;\n        throw new Error(\"WebAssembly is not initialized yet.\");\n    };\n});\nvar E, G, g, te = A(()=>{\n    \"use strict\";\n    j();\n    E = (e, t)=>{\n        let n = S(), s = n.lengthBytesUTF8(e) + 1, r = n._malloc(s);\n        return n.stringToUTF8(e, r, s), t.push(r), r;\n    }, G = (e, t, n, s)=>{\n        if (typeof e == \"object\" && e !== null) {\n            if (n.has(e)) throw new Error(\"Circular reference in options\");\n            n.add(e);\n        }\n        Object.entries(e).forEach(([r, i])=>{\n            let o = t ? t + r : r;\n            if (typeof i == \"object\") G(i, o + \".\", n, s);\n            else if (typeof i == \"string\" || typeof i == \"number\") s(o, i.toString());\n            else if (typeof i == \"boolean\") s(o, i ? \"1\" : \"0\");\n            else throw new Error(`Can't handle extra config type: ${typeof i}`);\n        });\n    }, g = (e)=>{\n        let t = S(), n = t.stackSave();\n        try {\n            let s = t.PTR_SIZE, r = t.stackAlloc(2 * s);\n            t._OrtGetLastError(r, r + s);\n            let i = Number(t.getValue(r, s === 4 ? \"i32\" : \"i64\")), o = t.getValue(r + s, \"*\"), a = o ? t.UTF8ToString(o) : \"\";\n            throw new Error(`${e} ERROR_CODE: ${i}, ERROR_MESSAGE: ${a}`);\n        } finally{\n            t.stackRestore(n);\n        }\n    };\n});\nvar Ce, Be = A(()=>{\n    \"use strict\";\n    j();\n    te();\n    Ce = (e)=>{\n        let t = S(), n = 0, s = [], r = e || {};\n        try {\n            if (e?.logSeverityLevel === void 0) r.logSeverityLevel = 2;\n            else if (typeof e.logSeverityLevel != \"number\" || !Number.isInteger(e.logSeverityLevel) || e.logSeverityLevel < 0 || e.logSeverityLevel > 4) throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);\n            if (e?.logVerbosityLevel === void 0) r.logVerbosityLevel = 0;\n            else if (typeof e.logVerbosityLevel != \"number\" || !Number.isInteger(e.logVerbosityLevel)) throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);\n            e?.terminate === void 0 && (r.terminate = !1);\n            let i = 0;\n            return e?.tag !== void 0 && (i = E(e.tag, s)), n = t._OrtCreateRunOptions(r.logSeverityLevel, r.logVerbosityLevel, !!r.terminate, i), n === 0 && g(\"Can't create run options.\"), e?.extra !== void 0 && G(e.extra, \"\", new WeakSet, (o, a)=>{\n                let c = E(o, s), d = E(a, s);\n                t._OrtAddRunConfigEntry(n, c, d) !== 0 && g(`Can't set a run config entry: ${o} - ${a}.`);\n            }), [\n                n,\n                s\n            ];\n        } catch (i) {\n            throw n !== 0 && t._OrtReleaseRunOptions(n), s.forEach((o)=>t._free(o)), i;\n        }\n    };\n});\nvar Pt, xt, It, _t, Me, Ue = A(()=>{\n    \"use strict\";\n    j();\n    te();\n    Pt = (e)=>{\n        switch(e){\n            case \"disabled\":\n                return 0;\n            case \"basic\":\n                return 1;\n            case \"extended\":\n                return 2;\n            case \"all\":\n                return 99;\n            default:\n                throw new Error(`unsupported graph optimization level: ${e}`);\n        }\n    }, xt = (e)=>{\n        switch(e){\n            case \"sequential\":\n                return 0;\n            case \"parallel\":\n                return 1;\n            default:\n                throw new Error(`unsupported execution mode: ${e}`);\n        }\n    }, It = (e)=>{\n        e.extra || (e.extra = {}), e.extra.session || (e.extra.session = {});\n        let t = e.extra.session;\n        t.use_ort_model_bytes_directly || (t.use_ort_model_bytes_directly = \"1\"), e.executionProviders && e.executionProviders.some((n)=>(typeof n == \"string\" ? n : n.name) === \"webgpu\") && (e.enableMemPattern = !1);\n    }, _t = (e, t, n)=>{\n        for (let s of t){\n            let r = typeof s == \"string\" ? s : s.name;\n            switch(r){\n                case \"webnn\":\n                    if (r = \"WEBNN\", typeof s != \"string\") {\n                        let a = s?.deviceType;\n                        if (a) {\n                            let c = E(\"deviceType\", n), d = E(a, n);\n                            S()._OrtAddSessionConfigEntry(e, c, d) !== 0 && g(`Can't set a session config entry: 'deviceType' - ${a}.`);\n                        }\n                    }\n                    break;\n                case \"webgpu\":\n                    if (r = \"JS\", typeof s != \"string\") {\n                        let o = s;\n                        if (o?.preferredLayout) {\n                            if (o.preferredLayout !== \"NCHW\" && o.preferredLayout !== \"NHWC\") throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${o.preferredLayout}`);\n                            let a = E(\"preferredLayout\", n), c = E(o.preferredLayout, n);\n                            S()._OrtAddSessionConfigEntry(e, a, c) !== 0 && g(`Can't set a session config entry: 'preferredLayout' - ${o.preferredLayout}.`);\n                        }\n                    }\n                    break;\n                case \"wasm\":\n                case \"cpu\":\n                    continue;\n                default:\n                    throw new Error(`not supported execution provider: ${r}`);\n            }\n            let i = E(r, n);\n            S()._OrtAppendExecutionProvider(e, i) !== 0 && g(`Can't append execution provider: ${r}.`);\n        }\n    }, Me = (e)=>{\n        let t = S(), n = 0, s = [], r = e || {};\n        It(r);\n        try {\n            let i = Pt(r.graphOptimizationLevel ?? \"all\"), o = xt(r.executionMode ?? \"sequential\"), a = typeof r.logId == \"string\" ? E(r.logId, s) : 0, c = r.logSeverityLevel ?? 2;\n            if (!Number.isInteger(c) || c < 0 || c > 4) throw new Error(`log serverity level is not valid: ${c}`);\n            let d = r.logVerbosityLevel ?? 0;\n            if (!Number.isInteger(d) || d < 0 || d > 4) throw new Error(`log verbosity level is not valid: ${d}`);\n            let w = typeof r.optimizedModelFilePath == \"string\" ? E(r.optimizedModelFilePath, s) : 0;\n            if (n = t._OrtCreateSessionOptions(i, !!r.enableCpuMemArena, !!r.enableMemPattern, o, !!r.enableProfiling, 0, a, c, d, w), n === 0 && g(\"Can't create session options.\"), r.executionProviders && _t(n, r.executionProviders, s), r.enableGraphCapture !== void 0) {\n                if (typeof r.enableGraphCapture != \"boolean\") throw new Error(`enableGraphCapture must be a boolean value: ${r.enableGraphCapture}`);\n                let l = E(\"enableGraphCapture\", s), u = E(r.enableGraphCapture.toString(), s);\n                t._OrtAddSessionConfigEntry(n, l, u) !== 0 && g(`Can't set a session config entry: 'enableGraphCapture' - ${r.enableGraphCapture}.`);\n            }\n            if (r.freeDimensionOverrides) for (let [l, u] of Object.entries(r.freeDimensionOverrides)){\n                if (typeof l != \"string\") throw new Error(`free dimension override name must be a string: ${l}`);\n                if (typeof u != \"number\" || !Number.isInteger(u) || u < 0) throw new Error(`free dimension override value must be a non-negative integer: ${u}`);\n                let b = E(l, s);\n                t._OrtAddFreeDimensionOverride(n, b, u) !== 0 && g(`Can't set a free dimension override: ${l} - ${u}.`);\n            }\n            return r.extra !== void 0 && G(r.extra, \"\", new WeakSet, (l, u)=>{\n                let b = E(l, s), v = E(u, s);\n                t._OrtAddSessionConfigEntry(n, b, v) !== 0 && g(`Can't set a session config entry: ${l} - ${u}.`);\n            }), [\n                n,\n                s\n            ];\n        } catch (i) {\n            throw n !== 0 && t._OrtReleaseSessionOptions(n) !== 0 && g(\"Can't release session options.\"), s.forEach((o)=>t._free(o)), i;\n        }\n    };\n});\nvar H, ke, V, De, We, re, ne, Fe, pe = A(()=>{\n    \"use strict\";\n    H = (e)=>{\n        switch(e){\n            case \"int8\":\n                return 3;\n            case \"uint8\":\n                return 2;\n            case \"bool\":\n                return 9;\n            case \"int16\":\n                return 5;\n            case \"uint16\":\n                return 4;\n            case \"int32\":\n                return 6;\n            case \"uint32\":\n                return 12;\n            case \"float16\":\n                return 10;\n            case \"float32\":\n                return 1;\n            case \"float64\":\n                return 11;\n            case \"string\":\n                return 8;\n            case \"int64\":\n                return 7;\n            case \"uint64\":\n                return 13;\n            case \"int4\":\n                return 22;\n            case \"uint4\":\n                return 21;\n            default:\n                throw new Error(`unsupported data type: ${e}`);\n        }\n    }, ke = (e)=>{\n        switch(e){\n            case 3:\n                return \"int8\";\n            case 2:\n                return \"uint8\";\n            case 9:\n                return \"bool\";\n            case 5:\n                return \"int16\";\n            case 4:\n                return \"uint16\";\n            case 6:\n                return \"int32\";\n            case 12:\n                return \"uint32\";\n            case 10:\n                return \"float16\";\n            case 1:\n                return \"float32\";\n            case 11:\n                return \"float64\";\n            case 8:\n                return \"string\";\n            case 7:\n                return \"int64\";\n            case 13:\n                return \"uint64\";\n            case 22:\n                return \"int4\";\n            case 21:\n                return \"uint4\";\n            default:\n                throw new Error(`unsupported data type: ${e}`);\n        }\n    }, V = (e, t)=>{\n        let n = [\n            -1,\n            4,\n            1,\n            1,\n            2,\n            2,\n            4,\n            8,\n            -1,\n            1,\n            2,\n            8,\n            4,\n            8,\n            -1,\n            -1,\n            -1,\n            -1,\n            -1,\n            -1,\n            -1,\n            .5,\n            .5\n        ][e], s = typeof t == \"number\" ? t : t.reduce((r, i)=>r * i, 1);\n        return n > 0 ? Math.ceil(s * n) : void 0;\n    }, De = (e)=>{\n        switch(e){\n            case \"float16\":\n                return typeof Float16Array < \"u\" && Float16Array.from ? Float16Array : Uint16Array;\n            case \"float32\":\n                return Float32Array;\n            case \"uint8\":\n                return Uint8Array;\n            case \"int8\":\n                return Int8Array;\n            case \"uint16\":\n                return Uint16Array;\n            case \"int16\":\n                return Int16Array;\n            case \"int32\":\n                return Int32Array;\n            case \"bool\":\n                return Uint8Array;\n            case \"float64\":\n                return Float64Array;\n            case \"uint32\":\n                return Uint32Array;\n            case \"int64\":\n                return BigInt64Array;\n            case \"uint64\":\n                return BigUint64Array;\n            default:\n                throw new Error(`unsupported type: ${e}`);\n        }\n    }, We = (e)=>{\n        switch(e){\n            case \"verbose\":\n                return 0;\n            case \"info\":\n                return 1;\n            case \"warning\":\n                return 2;\n            case \"error\":\n                return 3;\n            case \"fatal\":\n                return 4;\n            default:\n                throw new Error(`unsupported logging level: ${e}`);\n        }\n    }, re = (e)=>e === \"float32\" || e === \"float16\" || e === \"int32\" || e === \"int64\" || e === \"uint32\" || e === \"uint8\" || e === \"bool\" || e === \"uint4\" || e === \"int4\", ne = (e)=>e === \"float32\" || e === \"float16\" || e === \"int32\" || e === \"int64\" || e === \"uint32\" || e === \"uint64\" || e === \"int8\" || e === \"uint8\" || e === \"bool\" || e === \"uint4\" || e === \"int4\", Fe = (e)=>{\n        switch(e){\n            case \"none\":\n                return 0;\n            case \"cpu\":\n                return 1;\n            case \"cpu-pinned\":\n                return 2;\n            case \"texture\":\n                return 3;\n            case \"gpu-buffer\":\n                return 4;\n            case \"ml-tensor\":\n                return 5;\n            default:\n                throw new Error(`unsupported data location: ${e}`);\n        }\n    };\n});\nvar q, me = A(()=>{\n    \"use strict\";\n    Q();\n    q = async (e)=>{\n        if (typeof e == \"string\") if (U) try {\n            let { readFile: t } = ce(\"node:fs/promises\");\n            return new Uint8Array(await t(e));\n        } catch (t) {\n            if (t.code === \"ERR_FS_FILE_TOO_LARGE\") {\n                let { createReadStream: n } = ce(\"node:fs\"), s = n(e), r = [];\n                for await (let i of s)r.push(i);\n                return new Uint8Array(Buffer.concat(r));\n            }\n            throw t;\n        }\n        else {\n            let t = await fetch(e);\n            if (!t.ok) throw new Error(`failed to load external data file: ${e}`);\n            let n = t.headers.get(\"Content-Length\"), s = n ? parseInt(n, 10) : 0;\n            if (s < 1073741824) return new Uint8Array(await t.arrayBuffer());\n            {\n                if (!t.body) throw new Error(`failed to load external data file: ${e}, no response body.`);\n                let r = t.body.getReader(), i;\n                try {\n                    i = new ArrayBuffer(s);\n                } catch (a) {\n                    if (a instanceof RangeError) {\n                        let c = Math.ceil(s / 65536);\n                        i = new WebAssembly.Memory({\n                            initial: c,\n                            maximum: c\n                        }).buffer;\n                    } else throw a;\n                }\n                let o = 0;\n                for(;;){\n                    let { done: a, value: c } = await r.read();\n                    if (a) break;\n                    let d = c.byteLength;\n                    new Uint8Array(i, o, d).set(c), o += d;\n                }\n                return new Uint8Array(i, 0, s);\n            }\n        }\n        else return e instanceof Blob ? new Uint8Array(await e.arrayBuffer()) : e instanceof Uint8Array ? e : new Uint8Array(e);\n    };\n});\nvar At, Ne, je, $, Ct, ge, $e, ze, Re, Ge, He, Ve = A(()=>{\n    \"use strict\";\n    Be();\n    Ue();\n    pe();\n    j();\n    te();\n    me();\n    At = (e, t)=>{\n        S()._OrtInit(e, t) !== 0 && g(\"Can't initialize onnxruntime.\");\n    }, Ne = async (e)=>{\n        At(e.wasm.numThreads, We(e.logLevel));\n    }, je = async (e, t)=>{}, $ = new Map, Ct = (e)=>{\n        let t = S(), n = t.stackSave();\n        try {\n            let s = t.PTR_SIZE, r = t.stackAlloc(2 * s);\n            t._OrtGetInputOutputCount(e, r, r + s) !== 0 && g(\"Can't get session input/output count.\");\n            let o = s === 4 ? \"i32\" : \"i64\";\n            return [\n                Number(t.getValue(r, o)),\n                Number(t.getValue(r + s, o))\n            ];\n        } finally{\n            t.stackRestore(n);\n        }\n    }, ge = (e)=>{\n        let t = S(), n = t._malloc(e.byteLength);\n        if (n === 0) throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);\n        return t.HEAPU8.set(e, n), [\n            n,\n            e.byteLength\n        ];\n    }, $e = async (e, t)=>{\n        let n, s, r = S();\n        Array.isArray(e) ? [n, s] = e : e.buffer === r.HEAPU8.buffer ? [n, s] = [\n            e.byteOffset,\n            e.byteLength\n        ] : [n, s] = ge(e);\n        let i = 0, o = 0, a = 0, c = [], d = [], w = [];\n        try {\n            if ([o, c] = Me(t), t?.externalData && r.mountExternalData) {\n                let p = [];\n                for (let h of t.externalData){\n                    let x = typeof h == \"string\" ? h : h.path;\n                    p.push(q(typeof h == \"string\" ? h : h.data).then((M)=>{\n                        r.mountExternalData(x, M);\n                    }));\n                }\n                await Promise.all(p);\n            }\n            for (let p of t?.executionProviders ?? [])if ((typeof p == \"string\" ? p : p.name) === \"webnn\") {\n                if (r.shouldTransferToMLTensor = !1, typeof p != \"string\") {\n                    let x = p, M = x?.context, J = x?.gpuDevice, Y = x?.deviceType, X = x?.powerPreference;\n                    M ? r.currentContext = M : J ? r.currentContext = await r.jsepCreateMLContext(J) : r.currentContext = await r.jsepCreateMLContext({\n                        deviceType: Y,\n                        powerPreference: X\n                    });\n                } else r.currentContext = await r.jsepCreateMLContext();\n                break;\n            }\n            i = await r._OrtCreateSession(n, s, o), i === 0 && g(\"Can't create a session.\"), r.jsepOnCreateSession?.(), r.currentContext && (r.jsepRegisterMLContext(i, r.currentContext), r.currentContext = void 0, r.shouldTransferToMLTensor = !0);\n            let [l, u] = Ct(i), b = !!t?.enableGraphCapture, v = [], f = [], y = [];\n            for(let p = 0; p < l; p++){\n                let h = r._OrtGetInputName(i, p);\n                h === 0 && g(\"Can't get an input name.\"), d.push(h), v.push(r.UTF8ToString(h));\n            }\n            for(let p = 0; p < u; p++){\n                let h = r._OrtGetOutputName(i, p);\n                h === 0 && g(\"Can't get an output name.\"), w.push(h);\n                let x = r.UTF8ToString(h);\n                f.push(x);\n            }\n            let P = null;\n            return $.set(i, [\n                i,\n                d,\n                w,\n                P,\n                b,\n                !1\n            ]), [\n                i,\n                v,\n                f\n            ];\n        } catch (l) {\n            throw d.forEach((u)=>r._OrtFree(u)), w.forEach((u)=>r._OrtFree(u)), a !== 0 && r._OrtReleaseBinding(a) !== 0 && g(\"Can't release IO binding.\"), i !== 0 && r._OrtReleaseSession(i) !== 0 && g(\"Can't release session.\"), l;\n        } finally{\n            r._free(n), o !== 0 && r._OrtReleaseSessionOptions(o) !== 0 && g(\"Can't release session options.\"), c.forEach((l)=>r._free(l)), r.unmountExternalData?.();\n        }\n    }, ze = (e)=>{\n        let t = S(), n = $.get(e);\n        if (!n) throw new Error(`cannot release session. invalid session id: ${e}`);\n        let [s, r, i, o, a] = n;\n        o && (a && t._OrtClearBoundOutputs(o.handle) !== 0 && g(\"Can't clear bound outputs.\"), t._OrtReleaseBinding(o.handle) !== 0 && g(\"Can't release IO binding.\")), t.jsepOnReleaseSession?.(e), r.forEach((c)=>t._OrtFree(c)), i.forEach((c)=>t._OrtFree(c)), t._OrtReleaseSession(s) !== 0 && g(\"Can't release session.\"), $.delete(e);\n    }, Re = (e, t, n, s, r, i = !1)=>{\n        if (!e) {\n            t.push(0);\n            return;\n        }\n        let o = S(), a = o.PTR_SIZE, c = e[0], d = e[1], w = e[3], l, u;\n        if (c === \"string\" && (w === \"gpu-buffer\" || w === \"ml-tensor\")) throw new Error(\"String tensor is not supported on GPU.\");\n        if (i && w !== \"gpu-buffer\") throw new Error(`External buffer must be provided for input/output index ${r} when enableGraphCapture is true.`);\n        if (w === \"gpu-buffer\") {\n            let f = e[2].gpuBuffer;\n            u = V(H(c), d);\n            let y = o.jsepRegisterBuffer;\n            if (!y) throw new Error('Tensor location \"gpu-buffer\" is not supported without using WebGPU.');\n            l = y(s, r, f, u);\n        } else if (w === \"ml-tensor\") {\n            let f = e[2].mlTensor;\n            u = V(H(c), d);\n            let y = o.jsepRegisterMLTensor;\n            if (!y) throw new Error('Tensor location \"ml-tensor\" is not supported without using WebNN.');\n            l = y(f, H(c), d);\n        } else {\n            let f = e[2];\n            if (Array.isArray(f)) {\n                u = a * f.length, l = o._malloc(u), n.push(l);\n                for(let y = 0; y < f.length; y++){\n                    if (typeof f[y] != \"string\") throw new TypeError(`tensor data at index ${y} is not a string`);\n                    o.setValue(l + y * a, E(f[y], n), \"*\");\n                }\n            } else u = f.byteLength, l = o._malloc(u), n.push(l), o.HEAPU8.set(new Uint8Array(f.buffer, f.byteOffset, u), l);\n        }\n        let b = o.stackSave(), v = o.stackAlloc(4 * d.length);\n        try {\n            d.forEach((y, P)=>o.setValue(v + P * a, y, a === 4 ? \"i32\" : \"i64\"));\n            let f = o._OrtCreateTensor(H(c), l, u, v, d.length, Fe(w));\n            f === 0 && g(`Can't create tensor for input/output. session=${s}, index=${r}.`), t.push(f);\n        } finally{\n            o.stackRestore(b);\n        }\n    }, Ge = async (e, t, n, s, r, i)=>{\n        let o = S(), a = o.PTR_SIZE, c = $.get(e);\n        if (!c) throw new Error(`cannot run inference. invalid session id: ${e}`);\n        let d = c[0], w = c[1], l = c[2], u = c[3], b = c[4], v = c[5], f = t.length, y = s.length, P = 0, p = [], h = [], x = [], M = [], J = o.stackSave(), Y = o.stackAlloc(f * a), X = o.stackAlloc(f * a), ie = o.stackAlloc(y * a), Se = o.stackAlloc(y * a);\n        try {\n            o.jsepOnRunStart?.(d), [P, p] = Ce(i);\n            for(let m = 0; m < f; m++)Re(n[m], h, M, e, t[m], b);\n            for(let m = 0; m < y; m++)Re(r[m], x, M, e, f + s[m], b);\n            for(let m = 0; m < f; m++)o.setValue(Y + m * a, h[m], \"*\"), o.setValue(X + m * a, w[t[m]], \"*\");\n            for(let m = 0; m < y; m++)o.setValue(ie + m * a, x[m], \"*\"), o.setValue(Se + m * a, l[s[m]], \"*\");\n            let C;\n            C = await o._OrtRun(d, X, Y, f, Se, y, ie, P), C !== 0 && g(\"failed to call OrtRun().\");\n            let R = [];\n            for(let m = 0; m < y; m++){\n                let N = Number(o.getValue(ie + m * a, \"*\"));\n                if (N === x[m]) {\n                    R.push(r[m]);\n                    continue;\n                }\n                let Ee = o.stackSave(), B = o.stackAlloc(4 * a), z = !1, T, I = 0;\n                try {\n                    o._OrtGetTensorData(N, B, B + a, B + 2 * a, B + 3 * a) !== 0 && g(`Can't access output tensor data on index ${m}.`);\n                    let ae = a === 4 ? \"i32\" : \"i64\", Z = Number(o.getValue(B, ae));\n                    I = o.getValue(B + a, \"*\");\n                    let Oe = o.getValue(B + a * 2, \"*\"), lt = Number(o.getValue(B + a * 3, ae)), D = [];\n                    for(let L = 0; L < lt; L++)D.push(Number(o.getValue(Oe + L * a, ae)));\n                    o._OrtFree(Oe) !== 0 && g(\"Can't free memory for tensor dims.\");\n                    let W = D.reduce((L, O)=>L * O, 1);\n                    T = ke(Z);\n                    let K = u?.outputPreferredLocations[s[m]];\n                    if (T === \"string\") {\n                        if (K === \"gpu-buffer\" || K === \"ml-tensor\") throw new Error(\"String tensor is not supported on GPU.\");\n                        let L = [];\n                        for(let O = 0; O < W; O++){\n                            let F = o.getValue(I + O * a, \"*\"), ft = o.getValue(I + (O + 1) * a, \"*\"), dt = O === W - 1 ? void 0 : ft - F;\n                            L.push(o.UTF8ToString(F, dt));\n                        }\n                        R.push([\n                            T,\n                            D,\n                            L,\n                            \"cpu\"\n                        ]);\n                    } else if (K === \"gpu-buffer\" && W > 0) {\n                        let L = o.jsepGetBuffer;\n                        if (!L) throw new Error('preferredLocation \"gpu-buffer\" is not supported without using WebGPU.');\n                        let O = L(I), F = V(Z, W);\n                        if (F === void 0 || !re(T)) throw new Error(`Unsupported data type: ${T}`);\n                        z = !0, R.push([\n                            T,\n                            D,\n                            {\n                                gpuBuffer: O,\n                                download: o.jsepCreateDownloader(O, F, T),\n                                dispose: ()=>{\n                                    o._OrtReleaseTensor(N) !== 0 && g(\"Can't release tensor.\");\n                                }\n                            },\n                            \"gpu-buffer\"\n                        ]);\n                    } else if (K === \"ml-tensor\" && W > 0) {\n                        let L = o.jsepEnsureTensor;\n                        if (!L) throw new Error('preferredLocation \"ml-tensor\" is not supported without using WebNN.');\n                        if (V(Z, W) === void 0 || !ne(T)) throw new Error(`Unsupported data type: ${T}`);\n                        let F = await L(I, Z, D, !1);\n                        z = !0, R.push([\n                            T,\n                            D,\n                            {\n                                mlTensor: F,\n                                download: o.jsepCreateMLTensorDownloader(I, T),\n                                dispose: ()=>{\n                                    o.jsepReleaseTensorId(I), o._OrtReleaseTensor(N);\n                                }\n                            },\n                            \"ml-tensor\"\n                        ]);\n                    } else {\n                        let L = De(T), O = new L(W);\n                        new Uint8Array(O.buffer, O.byteOffset, O.byteLength).set(o.HEAPU8.subarray(I, I + O.byteLength)), R.push([\n                            T,\n                            D,\n                            O,\n                            \"cpu\"\n                        ]);\n                    }\n                } finally{\n                    o.stackRestore(Ee), T === \"string\" && I && o._free(I), z || o._OrtReleaseTensor(N);\n                }\n            }\n            return u && !b && (o._OrtClearBoundOutputs(u.handle) !== 0 && g(\"Can't clear bound outputs.\"), $.set(e, [\n                d,\n                w,\n                l,\n                u,\n                b,\n                !1\n            ])), R;\n        } finally{\n            o.stackRestore(J), h.forEach((C)=>o._OrtReleaseTensor(C)), x.forEach((C)=>o._OrtReleaseTensor(C)), M.forEach((C)=>o._free(C)), P !== 0 && o._OrtReleaseRunOptions(P), p.forEach((C)=>o._free(C));\n        }\n    }, He = (e)=>{\n        let t = S(), n = $.get(e);\n        if (!n) throw new Error(\"invalid session id\");\n        let s = n[0], r = t._OrtEndProfiling(s);\n        r === 0 && g(\"Can't get an profile file name.\"), t._OrtFree(r);\n    };\n});\n\nvar be, qe, Je, Ye, Xe, Ze, Ke, Qe, et, tt, we = A(()=>{\n    \"use strict\";\n    Ve();\n    j();\n    le();\n    be = !1, qe = !1, Je = !1, Ye = async ()=>{\n        if (!qe) {\n            if (be) throw new Error(\"multiple calls to 'initWasm()' detected.\");\n            if (Je) throw new Error(\"previous call to 'initWasm()' failed.\");\n            be = !0;\n            try {\n                await Ae(onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env.wasm), await Ne(onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env), qe = !0;\n            } catch (e) {\n                throw Je = !0, e;\n            } finally{\n                be = !1;\n            }\n        }\n    }, Xe = async (e)=>{\n        await je(onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env, e);\n    }, Ze = async (e)=>ge(e), Ke = async (e, t)=>$e(e, t), Qe = async (e)=>{\n        ze(e);\n    }, et = async (e, t, n, s, r, i)=>Ge(e, t, n, s, r, i), tt = async (e)=>{\n        He(e);\n    };\n});\n\nvar ot, Mt, oe, st = A(()=>{\n    \"use strict\";\n    we();\n    pe();\n    Q();\n    me();\n    ot = (e, t)=>{\n        switch(e.location){\n            case \"cpu\":\n                return [\n                    e.type,\n                    e.dims,\n                    e.data,\n                    \"cpu\"\n                ];\n            case \"gpu-buffer\":\n                return [\n                    e.type,\n                    e.dims,\n                    {\n                        gpuBuffer: e.gpuBuffer\n                    },\n                    \"gpu-buffer\"\n                ];\n            case \"ml-tensor\":\n                return [\n                    e.type,\n                    e.dims,\n                    {\n                        mlTensor: e.mlTensor\n                    },\n                    \"ml-tensor\"\n                ];\n            default:\n                throw new Error(`invalid data location: ${e.location} for ${t()}`);\n        }\n    }, Mt = (e)=>{\n        switch(e[3]){\n            case \"cpu\":\n                return new onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.Tensor(e[0], e[2], e[1]);\n            case \"gpu-buffer\":\n                {\n                    let t = e[0];\n                    if (!re(t)) throw new Error(`not supported data type: ${t} for deserializing GPU tensor`);\n                    let { gpuBuffer: n, download: s, dispose: r } = e[2];\n                    return onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.Tensor.fromGpuBuffer(n, {\n                        dataType: t,\n                        dims: e[1],\n                        download: s,\n                        dispose: r\n                    });\n                }\n            case \"ml-tensor\":\n                {\n                    let t = e[0];\n                    if (!ne(t)) throw new Error(`not supported data type: ${t} for deserializing MLTensor tensor`);\n                    let { mlTensor: n, download: s, dispose: r } = e[2];\n                    return onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.Tensor.fromMLTensor(n, {\n                        dataType: t,\n                        dims: e[1],\n                        download: s,\n                        dispose: r\n                    });\n                }\n            default:\n                throw new Error(`invalid data location: ${e[3]}`);\n        }\n    }, oe = class {\n        async fetchModelAndCopyToWasmMemory(t) {\n            return Ze(await q(t));\n        }\n        async loadModel(t, n) {\n            (0,onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.TRACE_FUNC_BEGIN)();\n            let s;\n            typeof t == \"string\" ? U ? s = await q(t) : s = await this.fetchModelAndCopyToWasmMemory(t) : s = t, [this.sessionId, this.inputNames, this.outputNames] = await Ke(s, n), (0,onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.TRACE_FUNC_END)();\n        }\n        async dispose() {\n            return Qe(this.sessionId);\n        }\n        async run(t, n, s) {\n            (0,onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.TRACE_FUNC_BEGIN)();\n            let r = [], i = [];\n            Object.entries(t).forEach((u)=>{\n                let b = u[0], v = u[1], f = this.inputNames.indexOf(b);\n                if (f === -1) throw new Error(`invalid input '${b}'`);\n                r.push(v), i.push(f);\n            });\n            let o = [], a = [];\n            Object.entries(n).forEach((u)=>{\n                let b = u[0], v = u[1], f = this.outputNames.indexOf(b);\n                if (f === -1) throw new Error(`invalid output '${b}'`);\n                o.push(v), a.push(f);\n            });\n            let c = r.map((u, b)=>ot(u, ()=>`input \"${this.inputNames[i[b]]}\"`)), d = o.map((u, b)=>u ? ot(u, ()=>`output \"${this.outputNames[a[b]]}\"`) : null), w = await et(this.sessionId, i, c, a, d, s), l = {};\n            for(let u = 0; u < w.length; u++)l[this.outputNames[a[u]]] = o[u] ?? Mt(w[u]);\n            return (0,onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.TRACE_FUNC_END)(), l;\n        }\n        startProfiling() {}\n        endProfiling() {\n            tt(this.sessionId);\n        }\n    };\n});\nvar at = {};\nbt(at, {\n    OnnxruntimeWebAssemblyBackend: ()=>se,\n    initializeFlags: ()=>it,\n    wasmBackend: ()=>Ut\n});\n\nvar it, se, Ut, ut = A(()=>{\n    \"use strict\";\n    we();\n    st();\n    it = ()=>{\n        if ((typeof onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env.wasm.initTimeout != \"number\" || onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env.wasm.initTimeout < 0) && (onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env.wasm.initTimeout = 0), onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env.wasm.simd === !1 && console.warn('Deprecated property \"env.wasm.simd\" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'), typeof onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env.wasm.proxy != \"boolean\" && (onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env.wasm.proxy = !1), typeof onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env.wasm.trace != \"boolean\" && (onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env.wasm.trace = !1), typeof onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env.wasm.numThreads != \"number\" || !Number.isInteger(onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env.wasm.numThreads) || onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env.wasm.numThreads <= 0) if (typeof self < \"u\" && !self.crossOriginIsolated) onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env.wasm.numThreads = 1;\n        else {\n            let e = typeof navigator > \"u\" ? ce(\"node:os\").cpus().length : navigator.hardwareConcurrency;\n            onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env.wasm.numThreads = Math.min(4, Math.ceil((e || 1) / 2));\n        }\n    }, se = class {\n        async init(t) {\n            it(), await Ye(), await Xe(t);\n        }\n        async createInferenceSessionHandler(t, n) {\n            let s = new oe;\n            return await s.loadModel(t, n), Promise.resolve(s);\n        }\n    }, Ut = new se;\n});\n\n\n\nvar ve = \"1.21.0-dev.20250114-228dd16893\";\nvar Cr = onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__;\n{\n    let e = (ut(), wt(at)).wasmBackend;\n    (0,onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.registerBackend)(\"cpu\", e, 10), (0,onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.registerBackend)(\"wasm\", e, 10);\n}Object.defineProperty(onnxruntime_common__WEBPACK_IMPORTED_MODULE_1__.env.versions, \"web\", {\n    value: ve,\n    enumerable: !0\n});\n //# sourceMappingURL=ort.node.min.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL2Rpc3Qvb3J0Lm5vZGUubWluLm1qcz8xOTYwIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTs7OztDQUlDLEdBQ2lDO0FBQUEsTUFBTUMsVUFBUUQscURBQWFBLENBQUMsd0dBQWU7QUFDN0UsSUFBSUcsS0FBR0MsT0FBT0MsY0FBYztBQUFDLElBQUlDLEtBQUdGLE9BQU9HLHdCQUF3QjtBQUFDLElBQUlDLEtBQUdKLE9BQU9LLG1CQUFtQjtBQUFDLElBQUlDLEtBQUdOLE9BQU9PLFNBQVMsQ0FBQ0MsY0FBYztBQUFDLElBQUlDLEtBQUcsQ0FBQ0MsQ0FBQUEsSUFBRyxPQUFPYixVQUFRLE1BQUlBLFVBQVEsT0FBT2MsUUFBTSxNQUFJLElBQUlBLE1BQU1ELEdBQUU7UUFBQ0UsS0FBSSxDQUFDQyxHQUFFQyxJQUFJLENBQUMsT0FBT2pCLFVBQVEsTUFBSUEsVUFBUWdCLENBQUFBLENBQUUsQ0FBQ0MsRUFBRTtJQUFBLEtBQUdKLENBQUFBLEVBQUcsU0FBU0EsQ0FBQztJQUFFLElBQUcsT0FBT2IsVUFBUSxLQUFJLE9BQU9BLFFBQVFrQixLQUFLLENBQUMsSUFBSSxFQUFDQztJQUFXLE1BQU1DLE1BQU0seUJBQXVCUCxJQUFFO0FBQXFCO0FBQUcsSUFBSVEsSUFBRSxDQUFDUixHQUFFRyxJQUFJLElBQUtILENBQUFBLEtBQUlHLENBQUFBLElBQUVILEVBQUVBLElBQUUsRUFBQyxHQUFHRyxDQUFBQTtBQUFHLElBQUlNLEtBQUcsQ0FBQ1QsR0FBRUc7SUFBSyxJQUFJLElBQUlDLEtBQUtELEVBQUVkLEdBQUdXLEdBQUVJLEdBQUU7UUFBQ0YsS0FBSUMsQ0FBQyxDQUFDQyxFQUFFO1FBQUNNLFlBQVcsQ0FBQztJQUFDO0FBQUUsR0FBRUMsS0FBRyxDQUFDWCxHQUFFRyxHQUFFQyxHQUFFUTtJQUFLLElBQUdULEtBQUcsT0FBT0EsS0FBRyxZQUFVLE9BQU9BLEtBQUcsWUFBVyxLQUFJLElBQUlV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QUFFQyxJQUFHQyxJQUFHQyxJQUFHQyxJQUFHQyxJQUFHQyxLQUFHNUosRUFBRTtJQUFLO0lBQWFvSixJQUFFNUosQ0FBQUE7UUFBSSxPQUFPQTtZQUFHLEtBQUk7Z0JBQU8sT0FBTztZQUFFLEtBQUk7Z0JBQVEsT0FBTztZQUFFLEtBQUk7Z0JBQU8sT0FBTztZQUFFLEtBQUk7Z0JBQVEsT0FBTztZQUFFLEtBQUk7Z0JBQVMsT0FBTztZQUFFLEtBQUk7Z0JBQVEsT0FBTztZQUFFLEtBQUk7Z0JBQVMsT0FBTztZQUFHLEtBQUk7Z0JBQVUsT0FBTztZQUFHLEtBQUk7Z0JBQVUsT0FBTztZQUFFLEtBQUk7Z0JBQVUsT0FBTztZQUFHLEtBQUk7Z0JBQVMsT0FBTztZQUFFLEtBQUk7Z0JBQVEsT0FBTztZQUFFLEtBQUk7Z0JBQVMsT0FBTztZQUFHLEtBQUk7Z0JBQU8sT0FBTztZQUFHLEtBQUk7Z0JBQVEsT0FBTztZQUFHO2dCQUFRLE1BQU0sSUFBSU8sTUFBTSxDQUFDLHVCQUF1QixFQUFFUCxFQUFFLENBQUM7UUFBQztJQUFDLEdBQUU2SixLQUFHN0osQ0FBQUE7UUFBSSxPQUFPQTtZQUFHLEtBQUs7Z0JBQUUsT0FBTTtZQUFPLEtBQUs7Z0JBQUUsT0FBTTtZQUFRLEtBQUs7Z0JBQUUsT0FBTTtZQUFPLEtBQUs7Z0JBQUUsT0FBTTtZQUFRLEtBQUs7Z0JBQUUsT0FBTTtZQUFTLEtBQUs7Z0JBQUUsT0FBTTtZQUFRLEtBQUs7Z0JBQUcsT0FBTTtZQUFTLEtBQUs7Z0JBQUcsT0FBTTtZQUFVLEtBQUs7Z0JBQUUsT0FBTTtZQUFVLEtBQUs7Z0JBQUcsT0FBTTtZQUFVLEtBQUs7Z0JBQUUsT0FBTTtZQUFTLEtBQUs7Z0JBQUUsT0FBTTtZQUFRLEtBQUs7Z0JBQUcsT0FBTTtZQUFTLEtBQUs7Z0JBQUcsT0FBTTtZQUFPLEtBQUs7Z0JBQUcsT0FBTTtZQUFRO2dCQUFRLE1BQU0sSUFBSU8sTUFBTSxDQUFDLHVCQUF1QixFQUFFUCxFQUFFLENBQUM7UUFBQztJQUFDLEdBQUU4SixJQUFFLENBQUM5SixHQUFFRztR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LEtBQUt1TCxHQUFHLENBQUMsR0FBRXZMLEtBQUtDLElBQUksQ0FBQyxDQUFDdkssS0FBRyxLQUFHO1FBQUc7SUFBQyxHQUFFZ1YsS0FBRztRQUFNLE1BQU1jLEtBQUszVixDQUFDLEVBQUM7WUFBQytVLE1BQUssTUFBTXBDLE1BQUssTUFBTUMsR0FBRzVTO1FBQUU7UUFBQyxNQUFNNFYsOEJBQThCNVYsQ0FBQyxFQUFDQyxDQUFDLEVBQUM7WUFBQyxJQUFJUSxJQUFFLElBQUlrVDtZQUFHLE9BQU8sTUFBTWxULEVBQUUwVCxTQUFTLENBQUNuVSxHQUFFQyxJQUFHNEQsUUFBUUMsT0FBTyxDQUFDckQ7UUFBRTtJQUFDLEdBQUV3VSxLQUFHLElBQUlKO0FBQUU7QUFBbUM7QUFBc0M7QUFBZ0U7QUFBQSxJQUFJb0IsS0FBRztBQUFpQyxJQUFJQyxLQUFHTCwrQ0FBRUE7QUFBQztJQUFDLElBQUloVyxJQUFFLENBQUNzVixNQUFLdlUsR0FBRytULEdBQUUsRUFBR0ssV0FBVztJQUFDZSxtRUFBRUEsQ0FBQyxPQUFNbFcsR0FBRSxLQUFJa1csbUVBQUVBLENBQUMsUUFBT2xXLEdBQUU7QUFBRyxDQUFDVixPQUFPQyxjQUFjLENBQUM0VyxtREFBRUEsQ0FBQy9VLFFBQVEsRUFBQyxPQUFNO0lBQUNKLE9BQU1vVjtJQUFHMVYsWUFBVyxDQUFDO0FBQUM7QUFBeUIsQ0FDL2t0Qix5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZXh0LWJlaGluZC1pbWFnZS8uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS13ZWIvZGlzdC9vcnQubm9kZS5taW4ubWpzP2Q3ZTgiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBPTk5YIFJ1bnRpbWUgV2ViIHYxLjIxLjAtZGV2LjIwMjUwMTE0LTIyOGRkMTY4OTNcbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5pbXBvcnR7Y3JlYXRlUmVxdWlyZX1mcm9tXCJtb2R1bGVcIjtjb25zdCByZXF1aXJlPWNyZWF0ZVJlcXVpcmUoaW1wb3J0Lm1ldGEudXJsKTtcbnZhciB1ZT1PYmplY3QuZGVmaW5lUHJvcGVydHk7dmFyIHB0PU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7dmFyIG10PU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO3ZhciBndD1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O3ZhciBjZT0oZT0+dHlwZW9mIHJlcXVpcmU8XCJ1XCI/cmVxdWlyZTp0eXBlb2YgUHJveHk8XCJ1XCI/bmV3IFByb3h5KGUse2dldDoodCxuKT0+KHR5cGVvZiByZXF1aXJlPFwidVwiP3JlcXVpcmU6dClbbl19KTplKShmdW5jdGlvbihlKXtpZih0eXBlb2YgcmVxdWlyZTxcInVcIilyZXR1cm4gcmVxdWlyZS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dGhyb3cgRXJyb3IoJ0R5bmFtaWMgcmVxdWlyZSBvZiBcIicrZSsnXCIgaXMgbm90IHN1cHBvcnRlZCcpfSk7dmFyIEE9KGUsdCk9PigpPT4oZSYmKHQ9ZShlPTApKSx0KTt2YXIgYnQ9KGUsdCk9Pntmb3IodmFyIG4gaW4gdCl1ZShlLG4se2dldDp0W25dLGVudW1lcmFibGU6ITB9KX0seXQ9KGUsdCxuLHMpPT57aWYodCYmdHlwZW9mIHQ9PVwib2JqZWN0XCJ8fHR5cGVvZiB0PT1cImZ1bmN0aW9uXCIpZm9yKGxldCByIG9mIG10KHQpKSFndC5jYWxsKGUscikmJnIhPT1uJiZ1ZShlLHIse2dldDooKT0+dFtyXSxlbnVtZXJhYmxlOiEocz1wdCh0LHIpKXx8cy5lbnVtZXJhYmxlfSk7cmV0dXJuIGV9O3ZhciB3dD1lPT55dCh1ZSh7fSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlKTt2YXIgVSxRPUEoKCk9PntcInVzZSBzdHJpY3RcIjtVPSEhKHR5cGVvZiBwcm9jZXNzPFwidVwiJiZwcm9jZXNzLnZlcnNpb25zJiZwcm9jZXNzLnZlcnNpb25zLm5vZGUpfSk7dmFyIFBlLGh0LGsseGUsVGUsU3QsRXQsT3QsdnQsTGUsSWUsbGU9QSgoKT0+e1widXNlIHN0cmljdFwiO1EoKTtQZT1VfHx0eXBlb2YgbG9jYXRpb24+XCJ1XCI/dm9pZCAwOmxvY2F0aW9uLm9yaWdpbixodD0oKT0+e2lmKCFVKXJldHVybiBpbXBvcnQubWV0YS51cmw/LnN0YXJ0c1dpdGgoXCJmaWxlOlwiKT9uZXcgVVJMKG5ldyBVUkwoXCJvcnQubm9kZS5taW4ubWpzXCIsaW1wb3J0Lm1ldGEudXJsKS5ocmVmLFBlKS5ocmVmOmltcG9ydC5tZXRhLnVybH0saz1odCgpLHhlPSgpPT57aWYoayYmIWsuc3RhcnRzV2l0aChcImJsb2I6XCIpKXJldHVybiBrLnN1YnN0cmluZygwLGsubGFzdEluZGV4T2YoXCIvXCIpKzEpfSxUZT0oZSx0KT0+e3RyeXtsZXQgbj10Pz9rO3JldHVybihuP25ldyBVUkwoZSxuKTpuZXcgVVJMKGUpKS5vcmlnaW49PT1QZX1jYXRjaHtyZXR1cm4hMX19LFN0PShlLHQpPT57bGV0IG49dD8/azt0cnl7cmV0dXJuKG4/bmV3IFVSTChlLG4pOm5ldyBVUkwoZSkpLmhyZWZ9Y2F0Y2h7cmV0dXJufX0sRXQ9KGUsdCk9PmAke3Q/P1wiLi9cIn0ke2V9YCxPdD1hc3luYyBlPT57bGV0IG49YXdhaXQoYXdhaXQgZmV0Y2goZSx7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkpLmJsb2IoKTtyZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChuKX0sdnQ9YXN5bmMgZT0+KGF3YWl0IGltcG9ydCgvKndlYnBhY2tJZ25vcmU6dHJ1ZSovZSkpLmRlZmF1bHQsTGU9dm9pZCAwLEllPWFzeW5jKGUsdCxuKT0+e2lmKCFlJiYhdCYmTGUmJmsmJlRlKGspKXJldHVyblt2b2lkIDAsTGVdO3tsZXQgcz1cIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQubWpzXCIscj1lPz9TdChzLHQpLGk9IVUmJm4mJnImJiFUZShyLHQpLG89aT9hd2FpdCBPdChyKTpyPz9FdChzLHQpO3JldHVybltpP286dm9pZCAwLGF3YWl0IHZ0KG8pXX19fSk7dmFyIGZlLGRlLGVlLF9lLFR0LEx0LEFlLFMsaj1BKCgpPT57XCJ1c2Ugc3RyaWN0XCI7bGUoKTtkZT0hMSxlZT0hMSxfZT0hMSxUdD0oKT0+e2lmKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlcj5cInVcIilyZXR1cm4hMTt0cnl7cmV0dXJuIHR5cGVvZiBNZXNzYWdlQ2hhbm5lbDxcInVcIiYmbmV3IE1lc3NhZ2VDaGFubmVsKCkucG9ydDEucG9zdE1lc3NhZ2UobmV3IFNoYXJlZEFycmF5QnVmZmVyKDEpKSxXZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw0LDEsOTYsMCwwLDMsMiwxLDAsNSw0LDEsMywxLDEsMTAsMTEsMSw5LDAsNjUsMCwyNTQsMTYsMiwwLDI2LDExXSkpfWNhdGNoe3JldHVybiExfX0sTHQ9KCk9Pnt0cnl7cmV0dXJuIFdlYkFzc2VtYmx5LnZhbGlkYXRlKG5ldyBVaW50OEFycmF5KFswLDk3LDExNSwxMDksMSwwLDAsMCwxLDQsMSw5NiwwLDAsMywyLDEsMCwxMCwzMCwxLDI4LDAsNjUsMCwyNTMsMTUsMjUzLDEyLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMjUzLDE4NiwxLDI2LDExXSkpfWNhdGNoe3JldHVybiExfX0sQWU9YXN5bmMgZT0+e2lmKGRlKXJldHVybiBQcm9taXNlLnJlc29sdmUoKTtpZihlZSl0aHJvdyBuZXcgRXJyb3IoXCJtdWx0aXBsZSBjYWxscyB0byAnaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KCknIGRldGVjdGVkLlwiKTtpZihfZSl0aHJvdyBuZXcgRXJyb3IoXCJwcmV2aW91cyBjYWxsIHRvICdpbml0aWFsaXplV2ViQXNzZW1ibHkoKScgZmFpbGVkLlwiKTtlZT0hMDtsZXQgdD1lLmluaXRUaW1lb3V0LG49ZS5udW1UaHJlYWRzO2lmKCFMdCgpKXRocm93IG5ldyBFcnJvcihcIldlYkFzc2VtYmx5IFNJTUQgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC5cIik7bGV0IHM9VHQoKTtuPjEmJiFzJiYodHlwZW9mIHNlbGY8XCJ1XCImJiFzZWxmLmNyb3NzT3JpZ2luSXNvbGF0ZWQmJmNvbnNvbGUud2FybihcImVudi53YXNtLm51bVRocmVhZHMgaXMgc2V0IHRvIFwiK24rXCIsIGJ1dCB0aGlzIHdpbGwgbm90IHdvcmsgdW5sZXNzIHlvdSBlbmFibGUgY3Jvc3NPcmlnaW5Jc29sYXRlZCBtb2RlLiBTZWUgaHR0cHM6Ly93ZWIuZGV2L2Nyb3NzLW9yaWdpbi1pc29sYXRpb24tZ3VpZGUvIGZvciBtb3JlIGluZm8uXCIpLGNvbnNvbGUud2FybihcIldlYkFzc2VtYmx5IG11bHRpLXRocmVhZGluZyBpcyBub3Qgc3VwcG9ydGVkIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50LiBGYWxsaW5nIGJhY2sgdG8gc2luZ2xlLXRocmVhZGluZy5cIiksZS5udW1UaHJlYWRzPW49MSk7bGV0IHI9ZS53YXNtUGF0aHMsaT10eXBlb2Ygcj09XCJzdHJpbmdcIj9yOnZvaWQgMCxvPXI/Lm1qcyxhPW8/LmhyZWY/P28sYz1yPy53YXNtLGQ9Yz8uaHJlZj8/Yyx3PWUud2FzbUJpbmFyeSxbbCx1XT1hd2FpdCBJZShhLGksbj4xKSxiPSExLHY9W107aWYodD4wJiZ2LnB1c2gobmV3IFByb21pc2UoZj0+e3NldFRpbWVvdXQoKCk9PntiPSEwLGYoKX0sdCl9KSksdi5wdXNoKG5ldyBQcm9taXNlKChmLHkpPT57bGV0IFA9e251bVRocmVhZHM6bn07aWYodylQLndhc21CaW5hcnk9dztlbHNlIGlmKGR8fGkpUC5sb2NhdGVGaWxlPXA9PmQ/P2krcDtlbHNlIGlmKGEmJmEuaW5kZXhPZihcImJsb2I6XCIpIT09MClQLmxvY2F0ZUZpbGU9cD0+bmV3IFVSTChwLGEpLmhyZWY7ZWxzZSBpZihsKXtsZXQgcD14ZSgpO3AmJihQLmxvY2F0ZUZpbGU9aD0+cCtoKX11KFApLnRoZW4ocD0+e2VlPSExLGRlPSEwLGZlPXAsZigpLGwmJlVSTC5yZXZva2VPYmplY3RVUkwobCl9LHA9PntlZT0hMSxfZT0hMCx5KHApfSl9KSksYXdhaXQgUHJvbWlzZS5yYWNlKHYpLGIpdGhyb3cgbmV3IEVycm9yKGBXZWJBc3NlbWJseSBiYWNrZW5kIGluaXRpYWxpemluZyBmYWlsZWQgZHVlIHRvIHRpbWVvdXQ6ICR7dH1tc2ApfSxTPSgpPT57aWYoZGUmJmZlKXJldHVybiBmZTt0aHJvdyBuZXcgRXJyb3IoXCJXZWJBc3NlbWJseSBpcyBub3QgaW5pdGlhbGl6ZWQgeWV0LlwiKX19KTt2YXIgRSxHLGcsdGU9QSgoKT0+e1widXNlIHN0cmljdFwiO2ooKTtFPShlLHQpPT57bGV0IG49UygpLHM9bi5sZW5ndGhCeXRlc1VURjgoZSkrMSxyPW4uX21hbGxvYyhzKTtyZXR1cm4gbi5zdHJpbmdUb1VURjgoZSxyLHMpLHQucHVzaChyKSxyfSxHPShlLHQsbixzKT0+e2lmKHR5cGVvZiBlPT1cIm9iamVjdFwiJiZlIT09bnVsbCl7aWYobi5oYXMoZSkpdGhyb3cgbmV3IEVycm9yKFwiQ2lyY3VsYXIgcmVmZXJlbmNlIGluIG9wdGlvbnNcIik7bi5hZGQoZSl9T2JqZWN0LmVudHJpZXMoZSkuZm9yRWFjaCgoW3IsaV0pPT57bGV0IG89dD90K3I6cjtpZih0eXBlb2YgaT09XCJvYmplY3RcIilHKGksbytcIi5cIixuLHMpO2Vsc2UgaWYodHlwZW9mIGk9PVwic3RyaW5nXCJ8fHR5cGVvZiBpPT1cIm51bWJlclwiKXMobyxpLnRvU3RyaW5nKCkpO2Vsc2UgaWYodHlwZW9mIGk9PVwiYm9vbGVhblwiKXMobyxpP1wiMVwiOlwiMFwiKTtlbHNlIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgaGFuZGxlIGV4dHJhIGNvbmZpZyB0eXBlOiAke3R5cGVvZiBpfWApfSl9LGc9ZT0+e2xldCB0PVMoKSxuPXQuc3RhY2tTYXZlKCk7dHJ5e2xldCBzPXQuUFRSX1NJWkUscj10LnN0YWNrQWxsb2MoMipzKTt0Ll9PcnRHZXRMYXN0RXJyb3IocixyK3MpO2xldCBpPU51bWJlcih0LmdldFZhbHVlKHIscz09PTQ/XCJpMzJcIjpcImk2NFwiKSksbz10LmdldFZhbHVlKHIrcyxcIipcIiksYT1vP3QuVVRGOFRvU3RyaW5nKG8pOlwiXCI7dGhyb3cgbmV3IEVycm9yKGAke2V9IEVSUk9SX0NPREU6ICR7aX0sIEVSUk9SX01FU1NBR0U6ICR7YX1gKX1maW5hbGx5e3Quc3RhY2tSZXN0b3JlKG4pfX19KTt2YXIgQ2UsQmU9QSgoKT0+e1widXNlIHN0cmljdFwiO2ooKTt0ZSgpO0NlPWU9PntsZXQgdD1TKCksbj0wLHM9W10scj1lfHx7fTt0cnl7aWYoZT8ubG9nU2V2ZXJpdHlMZXZlbD09PXZvaWQgMClyLmxvZ1NldmVyaXR5TGV2ZWw9MjtlbHNlIGlmKHR5cGVvZiBlLmxvZ1NldmVyaXR5TGV2ZWwhPVwibnVtYmVyXCJ8fCFOdW1iZXIuaXNJbnRlZ2VyKGUubG9nU2V2ZXJpdHlMZXZlbCl8fGUubG9nU2V2ZXJpdHlMZXZlbDwwfHxlLmxvZ1NldmVyaXR5TGV2ZWw+NCl0aHJvdyBuZXcgRXJyb3IoYGxvZyBzZXJ2ZXJpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke2UubG9nU2V2ZXJpdHlMZXZlbH1gKTtpZihlPy5sb2dWZXJib3NpdHlMZXZlbD09PXZvaWQgMClyLmxvZ1ZlcmJvc2l0eUxldmVsPTA7ZWxzZSBpZih0eXBlb2YgZS5sb2dWZXJib3NpdHlMZXZlbCE9XCJudW1iZXJcInx8IU51bWJlci5pc0ludGVnZXIoZS5sb2dWZXJib3NpdHlMZXZlbCkpdGhyb3cgbmV3IEVycm9yKGBsb2cgdmVyYm9zaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtlLmxvZ1ZlcmJvc2l0eUxldmVsfWApO2U/LnRlcm1pbmF0ZT09PXZvaWQgMCYmKHIudGVybWluYXRlPSExKTtsZXQgaT0wO3JldHVybiBlPy50YWchPT12b2lkIDAmJihpPUUoZS50YWcscykpLG49dC5fT3J0Q3JlYXRlUnVuT3B0aW9ucyhyLmxvZ1NldmVyaXR5TGV2ZWwsci5sb2dWZXJib3NpdHlMZXZlbCwhIXIudGVybWluYXRlLGkpLG49PT0wJiZnKFwiQ2FuJ3QgY3JlYXRlIHJ1biBvcHRpb25zLlwiKSxlPy5leHRyYSE9PXZvaWQgMCYmRyhlLmV4dHJhLFwiXCIsbmV3IFdlYWtTZXQsKG8sYSk9PntsZXQgYz1FKG8scyksZD1FKGEscyk7dC5fT3J0QWRkUnVuQ29uZmlnRW50cnkobixjLGQpIT09MCYmZyhgQ2FuJ3Qgc2V0IGEgcnVuIGNvbmZpZyBlbnRyeTogJHtvfSAtICR7YX0uYCl9KSxbbixzXX1jYXRjaChpKXt0aHJvdyBuIT09MCYmdC5fT3J0UmVsZWFzZVJ1bk9wdGlvbnMobikscy5mb3JFYWNoKG89PnQuX2ZyZWUobykpLGl9fX0pO3ZhciBQdCx4dCxJdCxfdCxNZSxVZT1BKCgpPT57XCJ1c2Ugc3RyaWN0XCI7aigpO3RlKCk7UHQ9ZT0+e3N3aXRjaChlKXtjYXNlXCJkaXNhYmxlZFwiOnJldHVybiAwO2Nhc2VcImJhc2ljXCI6cmV0dXJuIDE7Y2FzZVwiZXh0ZW5kZWRcIjpyZXR1cm4gMjtjYXNlXCJhbGxcIjpyZXR1cm4gOTk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGdyYXBoIG9wdGltaXphdGlvbiBsZXZlbDogJHtlfWApfX0seHQ9ZT0+e3N3aXRjaChlKXtjYXNlXCJzZXF1ZW50aWFsXCI6cmV0dXJuIDA7Y2FzZVwicGFyYWxsZWxcIjpyZXR1cm4gMTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZXhlY3V0aW9uIG1vZGU6ICR7ZX1gKX19LEl0PWU9PntlLmV4dHJhfHwoZS5leHRyYT17fSksZS5leHRyYS5zZXNzaW9ufHwoZS5leHRyYS5zZXNzaW9uPXt9KTtsZXQgdD1lLmV4dHJhLnNlc3Npb247dC51c2Vfb3J0X21vZGVsX2J5dGVzX2RpcmVjdGx5fHwodC51c2Vfb3J0X21vZGVsX2J5dGVzX2RpcmVjdGx5PVwiMVwiKSxlLmV4ZWN1dGlvblByb3ZpZGVycyYmZS5leGVjdXRpb25Qcm92aWRlcnMuc29tZShuPT4odHlwZW9mIG49PVwic3RyaW5nXCI/bjpuLm5hbWUpPT09XCJ3ZWJncHVcIikmJihlLmVuYWJsZU1lbVBhdHRlcm49ITEpfSxfdD0oZSx0LG4pPT57Zm9yKGxldCBzIG9mIHQpe2xldCByPXR5cGVvZiBzPT1cInN0cmluZ1wiP3M6cy5uYW1lO3N3aXRjaChyKXtjYXNlXCJ3ZWJublwiOmlmKHI9XCJXRUJOTlwiLHR5cGVvZiBzIT1cInN0cmluZ1wiKXtsZXQgYT1zPy5kZXZpY2VUeXBlO2lmKGEpe2xldCBjPUUoXCJkZXZpY2VUeXBlXCIsbiksZD1FKGEsbik7UygpLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkoZSxjLGQpIT09MCYmZyhgQ2FuJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6ICdkZXZpY2VUeXBlJyAtICR7YX0uYCl9fWJyZWFrO2Nhc2VcIndlYmdwdVwiOmlmKHI9XCJKU1wiLHR5cGVvZiBzIT1cInN0cmluZ1wiKXtsZXQgbz1zO2lmKG8/LnByZWZlcnJlZExheW91dCl7aWYoby5wcmVmZXJyZWRMYXlvdXQhPT1cIk5DSFdcIiYmby5wcmVmZXJyZWRMYXlvdXQhPT1cIk5IV0NcIil0aHJvdyBuZXcgRXJyb3IoYHByZWZlcnJlZExheW91dCBtdXN0IGJlIGVpdGhlciAnTkNIVycgb3IgJ05IV0MnOiAke28ucHJlZmVycmVkTGF5b3V0fWApO2xldCBhPUUoXCJwcmVmZXJyZWRMYXlvdXRcIixuKSxjPUUoby5wcmVmZXJyZWRMYXlvdXQsbik7UygpLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkoZSxhLGMpIT09MCYmZyhgQ2FuJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6ICdwcmVmZXJyZWRMYXlvdXQnIC0gJHtvLnByZWZlcnJlZExheW91dH0uYCl9fWJyZWFrO2Nhc2VcIndhc21cIjpjYXNlXCJjcHVcIjpjb250aW51ZTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBleGVjdXRpb24gcHJvdmlkZXI6ICR7cn1gKX1sZXQgaT1FKHIsbik7UygpLl9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlcihlLGkpIT09MCYmZyhgQ2FuJ3QgYXBwZW5kIGV4ZWN1dGlvbiBwcm92aWRlcjogJHtyfS5gKX19LE1lPWU9PntsZXQgdD1TKCksbj0wLHM9W10scj1lfHx7fTtJdChyKTt0cnl7bGV0IGk9UHQoci5ncmFwaE9wdGltaXphdGlvbkxldmVsPz9cImFsbFwiKSxvPXh0KHIuZXhlY3V0aW9uTW9kZT8/XCJzZXF1ZW50aWFsXCIpLGE9dHlwZW9mIHIubG9nSWQ9PVwic3RyaW5nXCI/RShyLmxvZ0lkLHMpOjAsYz1yLmxvZ1NldmVyaXR5TGV2ZWw/PzI7aWYoIU51bWJlci5pc0ludGVnZXIoYyl8fGM8MHx8Yz40KXRocm93IG5ldyBFcnJvcihgbG9nIHNlcnZlcml0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7Y31gKTtsZXQgZD1yLmxvZ1ZlcmJvc2l0eUxldmVsPz8wO2lmKCFOdW1iZXIuaXNJbnRlZ2VyKGQpfHxkPDB8fGQ+NCl0aHJvdyBuZXcgRXJyb3IoYGxvZyB2ZXJib3NpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke2R9YCk7bGV0IHc9dHlwZW9mIHIub3B0aW1pemVkTW9kZWxGaWxlUGF0aD09XCJzdHJpbmdcIj9FKHIub3B0aW1pemVkTW9kZWxGaWxlUGF0aCxzKTowO2lmKG49dC5fT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnMoaSwhIXIuZW5hYmxlQ3B1TWVtQXJlbmEsISFyLmVuYWJsZU1lbVBhdHRlcm4sbywhIXIuZW5hYmxlUHJvZmlsaW5nLDAsYSxjLGQsdyksbj09PTAmJmcoXCJDYW4ndCBjcmVhdGUgc2Vzc2lvbiBvcHRpb25zLlwiKSxyLmV4ZWN1dGlvblByb3ZpZGVycyYmX3QobixyLmV4ZWN1dGlvblByb3ZpZGVycyxzKSxyLmVuYWJsZUdyYXBoQ2FwdHVyZSE9PXZvaWQgMCl7aWYodHlwZW9mIHIuZW5hYmxlR3JhcGhDYXB0dXJlIT1cImJvb2xlYW5cIil0aHJvdyBuZXcgRXJyb3IoYGVuYWJsZUdyYXBoQ2FwdHVyZSBtdXN0IGJlIGEgYm9vbGVhbiB2YWx1ZTogJHtyLmVuYWJsZUdyYXBoQ2FwdHVyZX1gKTtsZXQgbD1FKFwiZW5hYmxlR3JhcGhDYXB0dXJlXCIscyksdT1FKHIuZW5hYmxlR3JhcGhDYXB0dXJlLnRvU3RyaW5nKCkscyk7dC5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KG4sbCx1KSE9PTAmJmcoYENhbid0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAnZW5hYmxlR3JhcGhDYXB0dXJlJyAtICR7ci5lbmFibGVHcmFwaENhcHR1cmV9LmApfWlmKHIuZnJlZURpbWVuc2lvbk92ZXJyaWRlcylmb3IobGV0W2wsdV1vZiBPYmplY3QuZW50cmllcyhyLmZyZWVEaW1lbnNpb25PdmVycmlkZXMpKXtpZih0eXBlb2YgbCE9XCJzdHJpbmdcIil0aHJvdyBuZXcgRXJyb3IoYGZyZWUgZGltZW5zaW9uIG92ZXJyaWRlIG5hbWUgbXVzdCBiZSBhIHN0cmluZzogJHtsfWApO2lmKHR5cGVvZiB1IT1cIm51bWJlclwifHwhTnVtYmVyLmlzSW50ZWdlcih1KXx8dTwwKXRocm93IG5ldyBFcnJvcihgZnJlZSBkaW1lbnNpb24gb3ZlcnJpZGUgdmFsdWUgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyOiAke3V9YCk7bGV0IGI9RShsLHMpO3QuX09ydEFkZEZyZWVEaW1lbnNpb25PdmVycmlkZShuLGIsdSkhPT0wJiZnKGBDYW4ndCBzZXQgYSBmcmVlIGRpbWVuc2lvbiBvdmVycmlkZTogJHtsfSAtICR7dX0uYCl9cmV0dXJuIHIuZXh0cmEhPT12b2lkIDAmJkcoci5leHRyYSxcIlwiLG5ldyBXZWFrU2V0LChsLHUpPT57bGV0IGI9RShsLHMpLHY9RSh1LHMpO3QuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeShuLGIsdikhPT0wJiZnKGBDYW4ndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogJHtsfSAtICR7dX0uYCl9KSxbbixzXX1jYXRjaChpKXt0aHJvdyBuIT09MCYmdC5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zKG4pIT09MCYmZyhcIkNhbid0IHJlbGVhc2Ugc2Vzc2lvbiBvcHRpb25zLlwiKSxzLmZvckVhY2gobz0+dC5fZnJlZShvKSksaX19fSk7dmFyIEgsa2UsVixEZSxXZSxyZSxuZSxGZSxwZT1BKCgpPT57XCJ1c2Ugc3RyaWN0XCI7SD1lPT57c3dpdGNoKGUpe2Nhc2VcImludDhcIjpyZXR1cm4gMztjYXNlXCJ1aW50OFwiOnJldHVybiAyO2Nhc2VcImJvb2xcIjpyZXR1cm4gOTtjYXNlXCJpbnQxNlwiOnJldHVybiA1O2Nhc2VcInVpbnQxNlwiOnJldHVybiA0O2Nhc2VcImludDMyXCI6cmV0dXJuIDY7Y2FzZVwidWludDMyXCI6cmV0dXJuIDEyO2Nhc2VcImZsb2F0MTZcIjpyZXR1cm4gMTA7Y2FzZVwiZmxvYXQzMlwiOnJldHVybiAxO2Nhc2VcImZsb2F0NjRcIjpyZXR1cm4gMTE7Y2FzZVwic3RyaW5nXCI6cmV0dXJuIDg7Y2FzZVwiaW50NjRcIjpyZXR1cm4gNztjYXNlXCJ1aW50NjRcIjpyZXR1cm4gMTM7Y2FzZVwiaW50NFwiOnJldHVybiAyMjtjYXNlXCJ1aW50NFwiOnJldHVybiAyMTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2V9YCl9fSxrZT1lPT57c3dpdGNoKGUpe2Nhc2UgMzpyZXR1cm5cImludDhcIjtjYXNlIDI6cmV0dXJuXCJ1aW50OFwiO2Nhc2UgOTpyZXR1cm5cImJvb2xcIjtjYXNlIDU6cmV0dXJuXCJpbnQxNlwiO2Nhc2UgNDpyZXR1cm5cInVpbnQxNlwiO2Nhc2UgNjpyZXR1cm5cImludDMyXCI7Y2FzZSAxMjpyZXR1cm5cInVpbnQzMlwiO2Nhc2UgMTA6cmV0dXJuXCJmbG9hdDE2XCI7Y2FzZSAxOnJldHVyblwiZmxvYXQzMlwiO2Nhc2UgMTE6cmV0dXJuXCJmbG9hdDY0XCI7Y2FzZSA4OnJldHVyblwic3RyaW5nXCI7Y2FzZSA3OnJldHVyblwiaW50NjRcIjtjYXNlIDEzOnJldHVyblwidWludDY0XCI7Y2FzZSAyMjpyZXR1cm5cImludDRcIjtjYXNlIDIxOnJldHVyblwidWludDRcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2V9YCl9fSxWPShlLHQpPT57bGV0IG49Wy0xLDQsMSwxLDIsMiw0LDgsLTEsMSwyLDgsNCw4LC0xLC0xLC0xLC0xLC0xLC0xLC0xLC41LC41XVtlXSxzPXR5cGVvZiB0PT1cIm51bWJlclwiP3Q6dC5yZWR1Y2UoKHIsaSk9PnIqaSwxKTtyZXR1cm4gbj4wP01hdGguY2VpbChzKm4pOnZvaWQgMH0sRGU9ZT0+e3N3aXRjaChlKXtjYXNlXCJmbG9hdDE2XCI6cmV0dXJuIHR5cGVvZiBGbG9hdDE2QXJyYXk8XCJ1XCImJkZsb2F0MTZBcnJheS5mcm9tP0Zsb2F0MTZBcnJheTpVaW50MTZBcnJheTtjYXNlXCJmbG9hdDMyXCI6cmV0dXJuIEZsb2F0MzJBcnJheTtjYXNlXCJ1aW50OFwiOnJldHVybiBVaW50OEFycmF5O2Nhc2VcImludDhcIjpyZXR1cm4gSW50OEFycmF5O2Nhc2VcInVpbnQxNlwiOnJldHVybiBVaW50MTZBcnJheTtjYXNlXCJpbnQxNlwiOnJldHVybiBJbnQxNkFycmF5O2Nhc2VcImludDMyXCI6cmV0dXJuIEludDMyQXJyYXk7Y2FzZVwiYm9vbFwiOnJldHVybiBVaW50OEFycmF5O2Nhc2VcImZsb2F0NjRcIjpyZXR1cm4gRmxvYXQ2NEFycmF5O2Nhc2VcInVpbnQzMlwiOnJldHVybiBVaW50MzJBcnJheTtjYXNlXCJpbnQ2NFwiOnJldHVybiBCaWdJbnQ2NEFycmF5O2Nhc2VcInVpbnQ2NFwiOnJldHVybiBCaWdVaW50NjRBcnJheTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZTogJHtlfWApfX0sV2U9ZT0+e3N3aXRjaChlKXtjYXNlXCJ2ZXJib3NlXCI6cmV0dXJuIDA7Y2FzZVwiaW5mb1wiOnJldHVybiAxO2Nhc2VcIndhcm5pbmdcIjpyZXR1cm4gMjtjYXNlXCJlcnJvclwiOnJldHVybiAzO2Nhc2VcImZhdGFsXCI6cmV0dXJuIDQ7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGxvZ2dpbmcgbGV2ZWw6ICR7ZX1gKX19LHJlPWU9PmU9PT1cImZsb2F0MzJcInx8ZT09PVwiZmxvYXQxNlwifHxlPT09XCJpbnQzMlwifHxlPT09XCJpbnQ2NFwifHxlPT09XCJ1aW50MzJcInx8ZT09PVwidWludDhcInx8ZT09PVwiYm9vbFwifHxlPT09XCJ1aW50NFwifHxlPT09XCJpbnQ0XCIsbmU9ZT0+ZT09PVwiZmxvYXQzMlwifHxlPT09XCJmbG9hdDE2XCJ8fGU9PT1cImludDMyXCJ8fGU9PT1cImludDY0XCJ8fGU9PT1cInVpbnQzMlwifHxlPT09XCJ1aW50NjRcInx8ZT09PVwiaW50OFwifHxlPT09XCJ1aW50OFwifHxlPT09XCJib29sXCJ8fGU9PT1cInVpbnQ0XCJ8fGU9PT1cImludDRcIixGZT1lPT57c3dpdGNoKGUpe2Nhc2VcIm5vbmVcIjpyZXR1cm4gMDtjYXNlXCJjcHVcIjpyZXR1cm4gMTtjYXNlXCJjcHUtcGlubmVkXCI6cmV0dXJuIDI7Y2FzZVwidGV4dHVyZVwiOnJldHVybiAzO2Nhc2VcImdwdS1idWZmZXJcIjpyZXR1cm4gNDtjYXNlXCJtbC10ZW5zb3JcIjpyZXR1cm4gNTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSBsb2NhdGlvbjogJHtlfWApfX19KTt2YXIgcSxtZT1BKCgpPT57XCJ1c2Ugc3RyaWN0XCI7USgpO3E9YXN5bmMgZT0+e2lmKHR5cGVvZiBlPT1cInN0cmluZ1wiKWlmKFUpdHJ5e2xldHtyZWFkRmlsZTp0fT1jZShcIm5vZGU6ZnMvcHJvbWlzZXNcIik7cmV0dXJuIG5ldyBVaW50OEFycmF5KGF3YWl0IHQoZSkpfWNhdGNoKHQpe2lmKHQuY29kZT09PVwiRVJSX0ZTX0ZJTEVfVE9PX0xBUkdFXCIpe2xldHtjcmVhdGVSZWFkU3RyZWFtOm59PWNlKFwibm9kZTpmc1wiKSxzPW4oZSkscj1bXTtmb3IgYXdhaXQobGV0IGkgb2YgcylyLnB1c2goaSk7cmV0dXJuIG5ldyBVaW50OEFycmF5KEJ1ZmZlci5jb25jYXQocikpfXRocm93IHR9ZWxzZXtsZXQgdD1hd2FpdCBmZXRjaChlKTtpZighdC5vayl0aHJvdyBuZXcgRXJyb3IoYGZhaWxlZCB0byBsb2FkIGV4dGVybmFsIGRhdGEgZmlsZTogJHtlfWApO2xldCBuPXQuaGVhZGVycy5nZXQoXCJDb250ZW50LUxlbmd0aFwiKSxzPW4/cGFyc2VJbnQobiwxMCk6MDtpZihzPDEwNzM3NDE4MjQpcmV0dXJuIG5ldyBVaW50OEFycmF5KGF3YWl0IHQuYXJyYXlCdWZmZXIoKSk7e2lmKCF0LmJvZHkpdGhyb3cgbmV3IEVycm9yKGBmYWlsZWQgdG8gbG9hZCBleHRlcm5hbCBkYXRhIGZpbGU6ICR7ZX0sIG5vIHJlc3BvbnNlIGJvZHkuYCk7bGV0IHI9dC5ib2R5LmdldFJlYWRlcigpLGk7dHJ5e2k9bmV3IEFycmF5QnVmZmVyKHMpfWNhdGNoKGEpe2lmKGEgaW5zdGFuY2VvZiBSYW5nZUVycm9yKXtsZXQgYz1NYXRoLmNlaWwocy82NTUzNik7aT1uZXcgV2ViQXNzZW1ibHkuTWVtb3J5KHtpbml0aWFsOmMsbWF4aW11bTpjfSkuYnVmZmVyfWVsc2UgdGhyb3cgYX1sZXQgbz0wO2Zvcig7Oyl7bGV0e2RvbmU6YSx2YWx1ZTpjfT1hd2FpdCByLnJlYWQoKTtpZihhKWJyZWFrO2xldCBkPWMuYnl0ZUxlbmd0aDtuZXcgVWludDhBcnJheShpLG8sZCkuc2V0KGMpLG8rPWR9cmV0dXJuIG5ldyBVaW50OEFycmF5KGksMCxzKX19ZWxzZSByZXR1cm4gZSBpbnN0YW5jZW9mIEJsb2I/bmV3IFVpbnQ4QXJyYXkoYXdhaXQgZS5hcnJheUJ1ZmZlcigpKTplIGluc3RhbmNlb2YgVWludDhBcnJheT9lOm5ldyBVaW50OEFycmF5KGUpfX0pO3ZhciBBdCxOZSxqZSwkLEN0LGdlLCRlLHplLFJlLEdlLEhlLFZlPUEoKCk9PntcInVzZSBzdHJpY3RcIjtCZSgpO1VlKCk7cGUoKTtqKCk7dGUoKTttZSgpO0F0PShlLHQpPT57UygpLl9PcnRJbml0KGUsdCkhPT0wJiZnKFwiQ2FuJ3QgaW5pdGlhbGl6ZSBvbm54cnVudGltZS5cIil9LE5lPWFzeW5jIGU9PntBdChlLndhc20ubnVtVGhyZWFkcyxXZShlLmxvZ0xldmVsKSl9LGplPWFzeW5jKGUsdCk9Pnt9LCQ9bmV3IE1hcCxDdD1lPT57bGV0IHQ9UygpLG49dC5zdGFja1NhdmUoKTt0cnl7bGV0IHM9dC5QVFJfU0laRSxyPXQuc3RhY2tBbGxvYygyKnMpO3QuX09ydEdldElucHV0T3V0cHV0Q291bnQoZSxyLHIrcykhPT0wJiZnKFwiQ2FuJ3QgZ2V0IHNlc3Npb24gaW5wdXQvb3V0cHV0IGNvdW50LlwiKTtsZXQgbz1zPT09ND9cImkzMlwiOlwiaTY0XCI7cmV0dXJuW051bWJlcih0LmdldFZhbHVlKHIsbykpLE51bWJlcih0LmdldFZhbHVlKHIrcyxvKSldfWZpbmFsbHl7dC5zdGFja1Jlc3RvcmUobil9fSxnZT1lPT57bGV0IHQ9UygpLG49dC5fbWFsbG9jKGUuYnl0ZUxlbmd0aCk7aWYobj09PTApdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBjcmVhdGUgYSBzZXNzaW9uLiBmYWlsZWQgdG8gYWxsb2NhdGUgYSBidWZmZXIgb2Ygc2l6ZSAke2UuYnl0ZUxlbmd0aH0uYCk7cmV0dXJuIHQuSEVBUFU4LnNldChlLG4pLFtuLGUuYnl0ZUxlbmd0aF19LCRlPWFzeW5jKGUsdCk9PntsZXQgbixzLHI9UygpO0FycmF5LmlzQXJyYXkoZSk/W24sc109ZTplLmJ1ZmZlcj09PXIuSEVBUFU4LmJ1ZmZlcj9bbixzXT1bZS5ieXRlT2Zmc2V0LGUuYnl0ZUxlbmd0aF06W24sc109Z2UoZSk7bGV0IGk9MCxvPTAsYT0wLGM9W10sZD1bXSx3PVtdO3RyeXtpZihbbyxjXT1NZSh0KSx0Py5leHRlcm5hbERhdGEmJnIubW91bnRFeHRlcm5hbERhdGEpe2xldCBwPVtdO2ZvcihsZXQgaCBvZiB0LmV4dGVybmFsRGF0YSl7bGV0IHg9dHlwZW9mIGg9PVwic3RyaW5nXCI/aDpoLnBhdGg7cC5wdXNoKHEodHlwZW9mIGg9PVwic3RyaW5nXCI/aDpoLmRhdGEpLnRoZW4oTT0+e3IubW91bnRFeHRlcm5hbERhdGEoeCxNKX0pKX1hd2FpdCBQcm9taXNlLmFsbChwKX1mb3IobGV0IHAgb2YgdD8uZXhlY3V0aW9uUHJvdmlkZXJzPz9bXSlpZigodHlwZW9mIHA9PVwic3RyaW5nXCI/cDpwLm5hbWUpPT09XCJ3ZWJublwiKXtpZihyLnNob3VsZFRyYW5zZmVyVG9NTFRlbnNvcj0hMSx0eXBlb2YgcCE9XCJzdHJpbmdcIil7bGV0IHg9cCxNPXg/LmNvbnRleHQsSj14Py5ncHVEZXZpY2UsWT14Py5kZXZpY2VUeXBlLFg9eD8ucG93ZXJQcmVmZXJlbmNlO00/ci5jdXJyZW50Q29udGV4dD1NOko/ci5jdXJyZW50Q29udGV4dD1hd2FpdCByLmpzZXBDcmVhdGVNTENvbnRleHQoSik6ci5jdXJyZW50Q29udGV4dD1hd2FpdCByLmpzZXBDcmVhdGVNTENvbnRleHQoe2RldmljZVR5cGU6WSxwb3dlclByZWZlcmVuY2U6WH0pfWVsc2Ugci5jdXJyZW50Q29udGV4dD1hd2FpdCByLmpzZXBDcmVhdGVNTENvbnRleHQoKTticmVha31pPWF3YWl0IHIuX09ydENyZWF0ZVNlc3Npb24obixzLG8pLGk9PT0wJiZnKFwiQ2FuJ3QgY3JlYXRlIGEgc2Vzc2lvbi5cIiksci5qc2VwT25DcmVhdGVTZXNzaW9uPy4oKSxyLmN1cnJlbnRDb250ZXh0JiYoci5qc2VwUmVnaXN0ZXJNTENvbnRleHQoaSxyLmN1cnJlbnRDb250ZXh0KSxyLmN1cnJlbnRDb250ZXh0PXZvaWQgMCxyLnNob3VsZFRyYW5zZmVyVG9NTFRlbnNvcj0hMCk7bGV0W2wsdV09Q3QoaSksYj0hIXQ/LmVuYWJsZUdyYXBoQ2FwdHVyZSx2PVtdLGY9W10seT1bXTtmb3IobGV0IHA9MDtwPGw7cCsrKXtsZXQgaD1yLl9PcnRHZXRJbnB1dE5hbWUoaSxwKTtoPT09MCYmZyhcIkNhbid0IGdldCBhbiBpbnB1dCBuYW1lLlwiKSxkLnB1c2goaCksdi5wdXNoKHIuVVRGOFRvU3RyaW5nKGgpKX1mb3IobGV0IHA9MDtwPHU7cCsrKXtsZXQgaD1yLl9PcnRHZXRPdXRwdXROYW1lKGkscCk7aD09PTAmJmcoXCJDYW4ndCBnZXQgYW4gb3V0cHV0IG5hbWUuXCIpLHcucHVzaChoKTtsZXQgeD1yLlVURjhUb1N0cmluZyhoKTtmLnB1c2goeCl9bGV0IFA9bnVsbDtyZXR1cm4gJC5zZXQoaSxbaSxkLHcsUCxiLCExXSksW2ksdixmXX1jYXRjaChsKXt0aHJvdyBkLmZvckVhY2godT0+ci5fT3J0RnJlZSh1KSksdy5mb3JFYWNoKHU9PnIuX09ydEZyZWUodSkpLGEhPT0wJiZyLl9PcnRSZWxlYXNlQmluZGluZyhhKSE9PTAmJmcoXCJDYW4ndCByZWxlYXNlIElPIGJpbmRpbmcuXCIpLGkhPT0wJiZyLl9PcnRSZWxlYXNlU2Vzc2lvbihpKSE9PTAmJmcoXCJDYW4ndCByZWxlYXNlIHNlc3Npb24uXCIpLGx9ZmluYWxseXtyLl9mcmVlKG4pLG8hPT0wJiZyLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnMobykhPT0wJiZnKFwiQ2FuJ3QgcmVsZWFzZSBzZXNzaW9uIG9wdGlvbnMuXCIpLGMuZm9yRWFjaChsPT5yLl9mcmVlKGwpKSxyLnVubW91bnRFeHRlcm5hbERhdGE/LigpfX0semU9ZT0+e2xldCB0PVMoKSxuPSQuZ2V0KGUpO2lmKCFuKXRocm93IG5ldyBFcnJvcihgY2Fubm90IHJlbGVhc2Ugc2Vzc2lvbi4gaW52YWxpZCBzZXNzaW9uIGlkOiAke2V9YCk7bGV0W3MscixpLG8sYV09bjtvJiYoYSYmdC5fT3J0Q2xlYXJCb3VuZE91dHB1dHMoby5oYW5kbGUpIT09MCYmZyhcIkNhbid0IGNsZWFyIGJvdW5kIG91dHB1dHMuXCIpLHQuX09ydFJlbGVhc2VCaW5kaW5nKG8uaGFuZGxlKSE9PTAmJmcoXCJDYW4ndCByZWxlYXNlIElPIGJpbmRpbmcuXCIpKSx0LmpzZXBPblJlbGVhc2VTZXNzaW9uPy4oZSksci5mb3JFYWNoKGM9PnQuX09ydEZyZWUoYykpLGkuZm9yRWFjaChjPT50Ll9PcnRGcmVlKGMpKSx0Ll9PcnRSZWxlYXNlU2Vzc2lvbihzKSE9PTAmJmcoXCJDYW4ndCByZWxlYXNlIHNlc3Npb24uXCIpLCQuZGVsZXRlKGUpfSxSZT0oZSx0LG4scyxyLGk9ITEpPT57aWYoIWUpe3QucHVzaCgwKTtyZXR1cm59bGV0IG89UygpLGE9by5QVFJfU0laRSxjPWVbMF0sZD1lWzFdLHc9ZVszXSxsLHU7aWYoYz09PVwic3RyaW5nXCImJih3PT09XCJncHUtYnVmZmVyXCJ8fHc9PT1cIm1sLXRlbnNvclwiKSl0aHJvdyBuZXcgRXJyb3IoXCJTdHJpbmcgdGVuc29yIGlzIG5vdCBzdXBwb3J0ZWQgb24gR1BVLlwiKTtpZihpJiZ3IT09XCJncHUtYnVmZmVyXCIpdGhyb3cgbmV3IEVycm9yKGBFeHRlcm5hbCBidWZmZXIgbXVzdCBiZSBwcm92aWRlZCBmb3IgaW5wdXQvb3V0cHV0IGluZGV4ICR7cn0gd2hlbiBlbmFibGVHcmFwaENhcHR1cmUgaXMgdHJ1ZS5gKTtpZih3PT09XCJncHUtYnVmZmVyXCIpe2xldCBmPWVbMl0uZ3B1QnVmZmVyO3U9VihIKGMpLGQpO2xldCB5PW8uanNlcFJlZ2lzdGVyQnVmZmVyO2lmKCF5KXRocm93IG5ldyBFcnJvcignVGVuc29yIGxvY2F0aW9uIFwiZ3B1LWJ1ZmZlclwiIGlzIG5vdCBzdXBwb3J0ZWQgd2l0aG91dCB1c2luZyBXZWJHUFUuJyk7bD15KHMscixmLHUpfWVsc2UgaWYodz09PVwibWwtdGVuc29yXCIpe2xldCBmPWVbMl0ubWxUZW5zb3I7dT1WKEgoYyksZCk7bGV0IHk9by5qc2VwUmVnaXN0ZXJNTFRlbnNvcjtpZigheSl0aHJvdyBuZXcgRXJyb3IoJ1RlbnNvciBsb2NhdGlvbiBcIm1sLXRlbnNvclwiIGlzIG5vdCBzdXBwb3J0ZWQgd2l0aG91dCB1c2luZyBXZWJOTi4nKTtsPXkoZixIKGMpLGQpfWVsc2V7bGV0IGY9ZVsyXTtpZihBcnJheS5pc0FycmF5KGYpKXt1PWEqZi5sZW5ndGgsbD1vLl9tYWxsb2ModSksbi5wdXNoKGwpO2ZvcihsZXQgeT0wO3k8Zi5sZW5ndGg7eSsrKXtpZih0eXBlb2YgZlt5XSE9XCJzdHJpbmdcIil0aHJvdyBuZXcgVHlwZUVycm9yKGB0ZW5zb3IgZGF0YSBhdCBpbmRleCAke3l9IGlzIG5vdCBhIHN0cmluZ2ApO28uc2V0VmFsdWUobCt5KmEsRShmW3ldLG4pLFwiKlwiKX19ZWxzZSB1PWYuYnl0ZUxlbmd0aCxsPW8uX21hbGxvYyh1KSxuLnB1c2gobCksby5IRUFQVTguc2V0KG5ldyBVaW50OEFycmF5KGYuYnVmZmVyLGYuYnl0ZU9mZnNldCx1KSxsKX1sZXQgYj1vLnN0YWNrU2F2ZSgpLHY9by5zdGFja0FsbG9jKDQqZC5sZW5ndGgpO3RyeXtkLmZvckVhY2goKHksUCk9Pm8uc2V0VmFsdWUoditQKmEseSxhPT09ND9cImkzMlwiOlwiaTY0XCIpKTtsZXQgZj1vLl9PcnRDcmVhdGVUZW5zb3IoSChjKSxsLHUsdixkLmxlbmd0aCxGZSh3KSk7Zj09PTAmJmcoYENhbid0IGNyZWF0ZSB0ZW5zb3IgZm9yIGlucHV0L291dHB1dC4gc2Vzc2lvbj0ke3N9LCBpbmRleD0ke3J9LmApLHQucHVzaChmKX1maW5hbGx5e28uc3RhY2tSZXN0b3JlKGIpfX0sR2U9YXN5bmMoZSx0LG4scyxyLGkpPT57bGV0IG89UygpLGE9by5QVFJfU0laRSxjPSQuZ2V0KGUpO2lmKCFjKXRocm93IG5ldyBFcnJvcihgY2Fubm90IHJ1biBpbmZlcmVuY2UuIGludmFsaWQgc2Vzc2lvbiBpZDogJHtlfWApO2xldCBkPWNbMF0sdz1jWzFdLGw9Y1syXSx1PWNbM10sYj1jWzRdLHY9Y1s1XSxmPXQubGVuZ3RoLHk9cy5sZW5ndGgsUD0wLHA9W10saD1bXSx4PVtdLE09W10sSj1vLnN0YWNrU2F2ZSgpLFk9by5zdGFja0FsbG9jKGYqYSksWD1vLnN0YWNrQWxsb2MoZiphKSxpZT1vLnN0YWNrQWxsb2MoeSphKSxTZT1vLnN0YWNrQWxsb2MoeSphKTt0cnl7by5qc2VwT25SdW5TdGFydD8uKGQpLFtQLHBdPUNlKGkpO2ZvcihsZXQgbT0wO208ZjttKyspUmUoblttXSxoLE0sZSx0W21dLGIpO2ZvcihsZXQgbT0wO208eTttKyspUmUoclttXSx4LE0sZSxmK3NbbV0sYik7Zm9yKGxldCBtPTA7bTxmO20rKylvLnNldFZhbHVlKFkrbSphLGhbbV0sXCIqXCIpLG8uc2V0VmFsdWUoWCttKmEsd1t0W21dXSxcIipcIik7Zm9yKGxldCBtPTA7bTx5O20rKylvLnNldFZhbHVlKGllK20qYSx4W21dLFwiKlwiKSxvLnNldFZhbHVlKFNlK20qYSxsW3NbbV1dLFwiKlwiKTtsZXQgQztDPWF3YWl0IG8uX09ydFJ1bihkLFgsWSxmLFNlLHksaWUsUCksQyE9PTAmJmcoXCJmYWlsZWQgdG8gY2FsbCBPcnRSdW4oKS5cIik7bGV0IFI9W107Zm9yKGxldCBtPTA7bTx5O20rKyl7bGV0IE49TnVtYmVyKG8uZ2V0VmFsdWUoaWUrbSphLFwiKlwiKSk7aWYoTj09PXhbbV0pe1IucHVzaChyW21dKTtjb250aW51ZX1sZXQgRWU9by5zdGFja1NhdmUoKSxCPW8uc3RhY2tBbGxvYyg0KmEpLHo9ITEsVCxJPTA7dHJ5e28uX09ydEdldFRlbnNvckRhdGEoTixCLEIrYSxCKzIqYSxCKzMqYSkhPT0wJiZnKGBDYW4ndCBhY2Nlc3Mgb3V0cHV0IHRlbnNvciBkYXRhIG9uIGluZGV4ICR7bX0uYCk7bGV0IGFlPWE9PT00P1wiaTMyXCI6XCJpNjRcIixaPU51bWJlcihvLmdldFZhbHVlKEIsYWUpKTtJPW8uZ2V0VmFsdWUoQithLFwiKlwiKTtsZXQgT2U9by5nZXRWYWx1ZShCK2EqMixcIipcIiksbHQ9TnVtYmVyKG8uZ2V0VmFsdWUoQithKjMsYWUpKSxEPVtdO2ZvcihsZXQgTD0wO0w8bHQ7TCsrKUQucHVzaChOdW1iZXIoby5nZXRWYWx1ZShPZStMKmEsYWUpKSk7by5fT3J0RnJlZShPZSkhPT0wJiZnKFwiQ2FuJ3QgZnJlZSBtZW1vcnkgZm9yIHRlbnNvciBkaW1zLlwiKTtsZXQgVz1ELnJlZHVjZSgoTCxPKT0+TCpPLDEpO1Q9a2UoWik7bGV0IEs9dT8ub3V0cHV0UHJlZmVycmVkTG9jYXRpb25zW3NbbV1dO2lmKFQ9PT1cInN0cmluZ1wiKXtpZihLPT09XCJncHUtYnVmZmVyXCJ8fEs9PT1cIm1sLXRlbnNvclwiKXRocm93IG5ldyBFcnJvcihcIlN0cmluZyB0ZW5zb3IgaXMgbm90IHN1cHBvcnRlZCBvbiBHUFUuXCIpO2xldCBMPVtdO2ZvcihsZXQgTz0wO088VztPKyspe2xldCBGPW8uZ2V0VmFsdWUoSStPKmEsXCIqXCIpLGZ0PW8uZ2V0VmFsdWUoSSsoTysxKSphLFwiKlwiKSxkdD1PPT09Vy0xP3ZvaWQgMDpmdC1GO0wucHVzaChvLlVURjhUb1N0cmluZyhGLGR0KSl9Ui5wdXNoKFtULEQsTCxcImNwdVwiXSl9ZWxzZSBpZihLPT09XCJncHUtYnVmZmVyXCImJlc+MCl7bGV0IEw9by5qc2VwR2V0QnVmZmVyO2lmKCFMKXRocm93IG5ldyBFcnJvcigncHJlZmVycmVkTG9jYXRpb24gXCJncHUtYnVmZmVyXCIgaXMgbm90IHN1cHBvcnRlZCB3aXRob3V0IHVzaW5nIFdlYkdQVS4nKTtsZXQgTz1MKEkpLEY9VihaLFcpO2lmKEY9PT12b2lkIDB8fCFyZShUKSl0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtUfWApO3o9ITAsUi5wdXNoKFtULEQse2dwdUJ1ZmZlcjpPLGRvd25sb2FkOm8uanNlcENyZWF0ZURvd25sb2FkZXIoTyxGLFQpLGRpc3Bvc2U6KCk9PntvLl9PcnRSZWxlYXNlVGVuc29yKE4pIT09MCYmZyhcIkNhbid0IHJlbGVhc2UgdGVuc29yLlwiKX19LFwiZ3B1LWJ1ZmZlclwiXSl9ZWxzZSBpZihLPT09XCJtbC10ZW5zb3JcIiYmVz4wKXtsZXQgTD1vLmpzZXBFbnN1cmVUZW5zb3I7aWYoIUwpdGhyb3cgbmV3IEVycm9yKCdwcmVmZXJyZWRMb2NhdGlvbiBcIm1sLXRlbnNvclwiIGlzIG5vdCBzdXBwb3J0ZWQgd2l0aG91dCB1c2luZyBXZWJOTi4nKTtpZihWKFosVyk9PT12b2lkIDB8fCFuZShUKSl0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtUfWApO2xldCBGPWF3YWl0IEwoSSxaLEQsITEpO3o9ITAsUi5wdXNoKFtULEQse21sVGVuc29yOkYsZG93bmxvYWQ6by5qc2VwQ3JlYXRlTUxUZW5zb3JEb3dubG9hZGVyKEksVCksZGlzcG9zZTooKT0+e28uanNlcFJlbGVhc2VUZW5zb3JJZChJKSxvLl9PcnRSZWxlYXNlVGVuc29yKE4pfX0sXCJtbC10ZW5zb3JcIl0pfWVsc2V7bGV0IEw9RGUoVCksTz1uZXcgTChXKTtuZXcgVWludDhBcnJheShPLmJ1ZmZlcixPLmJ5dGVPZmZzZXQsTy5ieXRlTGVuZ3RoKS5zZXQoby5IRUFQVTguc3ViYXJyYXkoSSxJK08uYnl0ZUxlbmd0aCkpLFIucHVzaChbVCxELE8sXCJjcHVcIl0pfX1maW5hbGx5e28uc3RhY2tSZXN0b3JlKEVlKSxUPT09XCJzdHJpbmdcIiYmSSYmby5fZnJlZShJKSx6fHxvLl9PcnRSZWxlYXNlVGVuc29yKE4pfX1yZXR1cm4gdSYmIWImJihvLl9PcnRDbGVhckJvdW5kT3V0cHV0cyh1LmhhbmRsZSkhPT0wJiZnKFwiQ2FuJ3QgY2xlYXIgYm91bmQgb3V0cHV0cy5cIiksJC5zZXQoZSxbZCx3LGwsdSxiLCExXSkpLFJ9ZmluYWxseXtvLnN0YWNrUmVzdG9yZShKKSxoLmZvckVhY2goQz0+by5fT3J0UmVsZWFzZVRlbnNvcihDKSkseC5mb3JFYWNoKEM9Pm8uX09ydFJlbGVhc2VUZW5zb3IoQykpLE0uZm9yRWFjaChDPT5vLl9mcmVlKEMpKSxQIT09MCYmby5fT3J0UmVsZWFzZVJ1bk9wdGlvbnMoUCkscC5mb3JFYWNoKEM9Pm8uX2ZyZWUoQykpfX0sSGU9ZT0+e2xldCB0PVMoKSxuPSQuZ2V0KGUpO2lmKCFuKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgc2Vzc2lvbiBpZFwiKTtsZXQgcz1uWzBdLHI9dC5fT3J0RW5kUHJvZmlsaW5nKHMpO3I9PT0wJiZnKFwiQ2FuJ3QgZ2V0IGFuIHByb2ZpbGUgZmlsZSBuYW1lLlwiKSx0Ll9PcnRGcmVlKHIpfX0pO2ltcG9ydHtlbnYgYXMgeWV9ZnJvbVwib25ueHJ1bnRpbWUtY29tbW9uXCI7dmFyIGJlLHFlLEplLFllLFhlLFplLEtlLFFlLGV0LHR0LHdlPUEoKCk9PntcInVzZSBzdHJpY3RcIjtWZSgpO2ooKTtsZSgpO2JlPSExLHFlPSExLEplPSExLFllPWFzeW5jKCk9PntpZighcWUpe2lmKGJlKXRocm93IG5ldyBFcnJvcihcIm11bHRpcGxlIGNhbGxzIHRvICdpbml0V2FzbSgpJyBkZXRlY3RlZC5cIik7aWYoSmUpdGhyb3cgbmV3IEVycm9yKFwicHJldmlvdXMgY2FsbCB0byAnaW5pdFdhc20oKScgZmFpbGVkLlwiKTtiZT0hMDt0cnl7YXdhaXQgQWUoeWUud2FzbSksYXdhaXQgTmUoeWUpLHFlPSEwfWNhdGNoKGUpe3Rocm93IEplPSEwLGV9ZmluYWxseXtiZT0hMX19fSxYZT1hc3luYyBlPT57YXdhaXQgamUoeWUsZSl9LFplPWFzeW5jIGU9PmdlKGUpLEtlPWFzeW5jKGUsdCk9PiRlKGUsdCksUWU9YXN5bmMgZT0+e3plKGUpfSxldD1hc3luYyhlLHQsbixzLHIsaSk9PkdlKGUsdCxuLHMscixpKSx0dD1hc3luYyBlPT57SGUoZSl9fSk7aW1wb3J0e1RlbnNvciBhcyBoZSxUUkFDRV9GVU5DX0JFR0lOIGFzIHJ0LFRSQUNFX0ZVTkNfRU5EIGFzIG50fWZyb21cIm9ubnhydW50aW1lLWNvbW1vblwiO3ZhciBvdCxNdCxvZSxzdD1BKCgpPT57XCJ1c2Ugc3RyaWN0XCI7d2UoKTtwZSgpO1EoKTttZSgpO290PShlLHQpPT57c3dpdGNoKGUubG9jYXRpb24pe2Nhc2VcImNwdVwiOnJldHVybltlLnR5cGUsZS5kaW1zLGUuZGF0YSxcImNwdVwiXTtjYXNlXCJncHUtYnVmZmVyXCI6cmV0dXJuW2UudHlwZSxlLmRpbXMse2dwdUJ1ZmZlcjplLmdwdUJ1ZmZlcn0sXCJncHUtYnVmZmVyXCJdO2Nhc2VcIm1sLXRlbnNvclwiOnJldHVybltlLnR5cGUsZS5kaW1zLHttbFRlbnNvcjplLm1sVGVuc29yfSxcIm1sLXRlbnNvclwiXTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkYXRhIGxvY2F0aW9uOiAke2UubG9jYXRpb259IGZvciAke3QoKX1gKX19LE10PWU9Pntzd2l0Y2goZVszXSl7Y2FzZVwiY3B1XCI6cmV0dXJuIG5ldyBoZShlWzBdLGVbMl0sZVsxXSk7Y2FzZVwiZ3B1LWJ1ZmZlclwiOntsZXQgdD1lWzBdO2lmKCFyZSh0KSl0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgZGF0YSB0eXBlOiAke3R9IGZvciBkZXNlcmlhbGl6aW5nIEdQVSB0ZW5zb3JgKTtsZXR7Z3B1QnVmZmVyOm4sZG93bmxvYWQ6cyxkaXNwb3NlOnJ9PWVbMl07cmV0dXJuIGhlLmZyb21HcHVCdWZmZXIobix7ZGF0YVR5cGU6dCxkaW1zOmVbMV0sZG93bmxvYWQ6cyxkaXNwb3NlOnJ9KX1jYXNlXCJtbC10ZW5zb3JcIjp7bGV0IHQ9ZVswXTtpZighbmUodCkpdGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIGRhdGEgdHlwZTogJHt0fSBmb3IgZGVzZXJpYWxpemluZyBNTFRlbnNvciB0ZW5zb3JgKTtsZXR7bWxUZW5zb3I6bixkb3dubG9hZDpzLGRpc3Bvc2U6cn09ZVsyXTtyZXR1cm4gaGUuZnJvbU1MVGVuc29yKG4se2RhdGFUeXBlOnQsZGltczplWzFdLGRvd25sb2FkOnMsZGlzcG9zZTpyfSl9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGF0YSBsb2NhdGlvbjogJHtlWzNdfWApfX0sb2U9Y2xhc3N7YXN5bmMgZmV0Y2hNb2RlbEFuZENvcHlUb1dhc21NZW1vcnkodCl7cmV0dXJuIFplKGF3YWl0IHEodCkpfWFzeW5jIGxvYWRNb2RlbCh0LG4pe3J0KCk7bGV0IHM7dHlwZW9mIHQ9PVwic3RyaW5nXCI/VT9zPWF3YWl0IHEodCk6cz1hd2FpdCB0aGlzLmZldGNoTW9kZWxBbmRDb3B5VG9XYXNtTWVtb3J5KHQpOnM9dCxbdGhpcy5zZXNzaW9uSWQsdGhpcy5pbnB1dE5hbWVzLHRoaXMub3V0cHV0TmFtZXNdPWF3YWl0IEtlKHMsbiksbnQoKX1hc3luYyBkaXNwb3NlKCl7cmV0dXJuIFFlKHRoaXMuc2Vzc2lvbklkKX1hc3luYyBydW4odCxuLHMpe3J0KCk7bGV0IHI9W10saT1bXTtPYmplY3QuZW50cmllcyh0KS5mb3JFYWNoKHU9PntsZXQgYj11WzBdLHY9dVsxXSxmPXRoaXMuaW5wdXROYW1lcy5pbmRleE9mKGIpO2lmKGY9PT0tMSl0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5wdXQgJyR7Yn0nYCk7ci5wdXNoKHYpLGkucHVzaChmKX0pO2xldCBvPVtdLGE9W107T2JqZWN0LmVudHJpZXMobikuZm9yRWFjaCh1PT57bGV0IGI9dVswXSx2PXVbMV0sZj10aGlzLm91dHB1dE5hbWVzLmluZGV4T2YoYik7aWYoZj09PS0xKXRocm93IG5ldyBFcnJvcihgaW52YWxpZCBvdXRwdXQgJyR7Yn0nYCk7by5wdXNoKHYpLGEucHVzaChmKX0pO2xldCBjPXIubWFwKCh1LGIpPT5vdCh1LCgpPT5gaW5wdXQgXCIke3RoaXMuaW5wdXROYW1lc1tpW2JdXX1cImApKSxkPW8ubWFwKCh1LGIpPT51P290KHUsKCk9PmBvdXRwdXQgXCIke3RoaXMub3V0cHV0TmFtZXNbYVtiXV19XCJgKTpudWxsKSx3PWF3YWl0IGV0KHRoaXMuc2Vzc2lvbklkLGksYyxhLGQscyksbD17fTtmb3IobGV0IHU9MDt1PHcubGVuZ3RoO3UrKylsW3RoaXMub3V0cHV0TmFtZXNbYVt1XV1dPW9bdV0/P010KHdbdV0pO3JldHVybiBudCgpLGx9c3RhcnRQcm9maWxpbmcoKXt9ZW5kUHJvZmlsaW5nKCl7dHQodGhpcy5zZXNzaW9uSWQpfX19KTt2YXIgYXQ9e307YnQoYXQse09ubnhydW50aW1lV2ViQXNzZW1ibHlCYWNrZW5kOigpPT5zZSxpbml0aWFsaXplRmxhZ3M6KCk9Pml0LHdhc21CYWNrZW5kOigpPT5VdH0pO2ltcG9ydHtlbnYgYXMgX31mcm9tXCJvbm54cnVudGltZS1jb21tb25cIjt2YXIgaXQsc2UsVXQsdXQ9QSgoKT0+e1widXNlIHN0cmljdFwiO3dlKCk7c3QoKTtpdD0oKT0+e2lmKCh0eXBlb2YgXy53YXNtLmluaXRUaW1lb3V0IT1cIm51bWJlclwifHxfLndhc20uaW5pdFRpbWVvdXQ8MCkmJihfLndhc20uaW5pdFRpbWVvdXQ9MCksXy53YXNtLnNpbWQ9PT0hMSYmY29uc29sZS53YXJuKCdEZXByZWNhdGVkIHByb3BlcnR5IFwiZW52Lndhc20uc2ltZFwiIGlzIHNldCB0byBmYWxzZS4gbm9uLVNJTUQgYnVpbGQgaXMgbm8gbG9uZ2VyIHByb3ZpZGVkLCBhbmQgdGhpcyBzZXR0aW5nIHdpbGwgYmUgaWdub3JlZC4nKSx0eXBlb2YgXy53YXNtLnByb3h5IT1cImJvb2xlYW5cIiYmKF8ud2FzbS5wcm94eT0hMSksdHlwZW9mIF8ud2FzbS50cmFjZSE9XCJib29sZWFuXCImJihfLndhc20udHJhY2U9ITEpLHR5cGVvZiBfLndhc20ubnVtVGhyZWFkcyE9XCJudW1iZXJcInx8IU51bWJlci5pc0ludGVnZXIoXy53YXNtLm51bVRocmVhZHMpfHxfLndhc20ubnVtVGhyZWFkczw9MClpZih0eXBlb2Ygc2VsZjxcInVcIiYmIXNlbGYuY3Jvc3NPcmlnaW5Jc29sYXRlZClfLndhc20ubnVtVGhyZWFkcz0xO2Vsc2V7bGV0IGU9dHlwZW9mIG5hdmlnYXRvcj5cInVcIj9jZShcIm5vZGU6b3NcIikuY3B1cygpLmxlbmd0aDpuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeTtfLndhc20ubnVtVGhyZWFkcz1NYXRoLm1pbig0LE1hdGguY2VpbCgoZXx8MSkvMikpfX0sc2U9Y2xhc3N7YXN5bmMgaW5pdCh0KXtpdCgpLGF3YWl0IFllKCksYXdhaXQgWGUodCl9YXN5bmMgY3JlYXRlSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIodCxuKXtsZXQgcz1uZXcgb2U7cmV0dXJuIGF3YWl0IHMubG9hZE1vZGVsKHQsbiksUHJvbWlzZS5yZXNvbHZlKHMpfX0sVXQ9bmV3IHNlfSk7ZXhwb3J0KmZyb21cIm9ubnhydW50aW1lLWNvbW1vblwiO2ltcG9ydCphcyBrdCBmcm9tXCJvbm54cnVudGltZS1jb21tb25cIjtpbXBvcnR7cmVnaXN0ZXJCYWNrZW5kIGFzIGN0LGVudiBhcyBEdH1mcm9tXCJvbm54cnVudGltZS1jb21tb25cIjt2YXIgdmU9XCIxLjIxLjAtZGV2LjIwMjUwMTE0LTIyOGRkMTY4OTNcIjt2YXIgQ3I9a3Q7e2xldCBlPSh1dCgpLHd0KGF0KSkud2FzbUJhY2tlbmQ7Y3QoXCJjcHVcIixlLDEwKSxjdChcIndhc21cIixlLDEwKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoRHQudmVyc2lvbnMsXCJ3ZWJcIix7dmFsdWU6dmUsZW51bWVyYWJsZTohMH0pO2V4cG9ydHtDciBhcyBkZWZhdWx0fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9ydC5ub2RlLm1pbi5tanMubWFwXG4iXSwibmFtZXMiOlsiY3JlYXRlUmVxdWlyZSIsInJlcXVpcmUiLCJ1cmwiLCJ1ZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwicHQiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJtdCIsImdldE93blByb3BlcnR5TmFtZXMiLCJndCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2UiLCJlIiwiUHJveHkiLCJnZXQiLCJ0IiwibiIsImFwcGx5IiwiYXJndW1lbnRzIiwiRXJyb3IiLCJBIiwiYnQiLCJlbnVtZXJhYmxlIiwieXQiLCJzIiwiciIsImNhbGwiLCJ3dCIsInZhbHVlIiwiVSIsIlEiLCJwcm9jZXNzIiwidmVyc2lvbnMiLCJub2RlIiwiUGUiLCJodCIsImsiLCJ4ZSIsIlRlIiwiU3QiLCJFdCIsIk90IiwidnQiLCJMZSIsIkllIiwibGUiLCJsb2NhdGlvbiIsIm9yaWdpbiIsInN0YXJ0c1dpdGgiLCJVUkwiLCJocmVmIiwic3Vic3RyaW5nIiwibGFzdEluZGV4T2YiLCJmZXRjaCIsImNyZWRlbnRpYWxzIiwiYmxvYiIsImNyZWF0ZU9iamVjdFVSTCIsImRlZmF1bHQiLCJpIiwibyIsImZlIiwiZGUiLCJlZSIsIl9lIiwiVHQiLCJMdCIsIkFlIiwiUyIsImoiLCJTaGFyZWRBcnJheUJ1ZmZlciIsIk1lc3NhZ2VDaGFubmVsIiwicG9ydDEiLCJwb3N0TWVzc2FnZSIsIldlYkFzc2VtYmx5IiwidmFsaWRhdGUiLCJVaW50OEFycmF5IiwiUHJvbWlzZSIsInJlc29sdmUiLCJpbml0VGltZW91dCIsIm51bVRocmVhZHMiLCJzZWxmIiwiY3Jvc3NPcmlnaW5Jc29sYXRlZCIsImNvbnNvbGUiLCJ3YXJuIiwid2FzbVBhdGhzIiwibWpzIiwiYSIsImMiLCJ3YXNtIiwiZCIsInciLCJ3YXNtQmluYXJ5IiwibCIsInUiLCJiIiwidiIsInB1c2giLCJmIiwic2V0VGltZW91dCIsInkiLCJQIiwibG9jYXRlRmlsZSIsInAiLCJpbmRleE9mIiwiaCIsInRoZW4iLCJyZXZva2VPYmplY3RVUkwiLCJyYWNlIiwiRSIsIkciLCJnIiwidGUiLCJsZW5ndGhCeXRlc1VURjgiLCJfbWFsbG9jIiwic3RyaW5nVG9VVEY4IiwiaGFzIiwiYWRkIiwiZW50cmllcyIsImZvckVhY2giLCJ0b1N0cmluZyIsInN0YWNrU2F2ZSIsIlBUUl9TSVpFIiwic3RhY2tBbGxvYyIsIl9PcnRHZXRMYXN0RXJyb3IiLCJOdW1iZXIiLCJnZXRWYWx1ZSIsIlVURjhUb1N0cmluZyIsInN0YWNrUmVzdG9yZSIsIkNlIiwiQmUiLCJsb2dTZXZlcml0eUxldmVsIiwiaXNJbnRlZ2VyIiwibG9nVmVyYm9zaXR5TGV2ZWwiLCJ0ZXJtaW5hdGUiLCJ0YWciLCJfT3J0Q3JlYXRlUnVuT3B0aW9ucyIsImV4dHJhIiwiV2Vha1NldCIsIl9PcnRBZGRSdW5Db25maWdFbnRyeSIsIl9PcnRSZWxlYXNlUnVuT3B0aW9ucyIsIl9mcmVlIiwiUHQiLCJ4dCIsIkl0IiwiX3QiLCJNZSIsIlVlIiwic2Vzc2lvbiIsInVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHkiLCJleGVjdXRpb25Qcm92aWRlcnMiLCJzb21lIiwibmFtZSIsImVuYWJsZU1lbVBhdHRlcm4iLCJkZXZpY2VUeXBlIiwiX09ydEFkZFNlc3Npb25Db25maWdFbnRyeSIsInByZWZlcnJlZExheW91dCIsIl9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlciIsImdyYXBoT3B0aW1pemF0aW9uTGV2ZWwiLCJleGVjdXRpb25Nb2RlIiwibG9nSWQiLCJvcHRpbWl6ZWRNb2RlbEZpbGVQYXRoIiwiX09ydENyZWF0ZVNlc3Npb25PcHRpb25zIiwiZW5hYmxlQ3B1TWVtQXJlbmEiLCJlbmFibGVQcm9maWxpbmciLCJlbmFibGVHcmFwaENhcHR1cmUiLCJmcmVlRGltZW5zaW9uT3ZlcnJpZGVzIiwiX09ydEFkZEZyZWVEaW1lbnNpb25PdmVycmlkZSIsIl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnMiLCJIIiwia2UiLCJWIiwiRGUiLCJXZSIsInJlIiwibmUiLCJGZSIsInBlIiwicmVkdWNlIiwiTWF0aCIsImNlaWwiLCJGbG9hdDE2QXJyYXkiLCJmcm9tIiwiVWludDE2QXJyYXkiLCJGbG9hdDMyQXJyYXkiLCJJbnQ4QXJyYXkiLCJJbnQxNkFycmF5IiwiSW50MzJBcnJheSIsIkZsb2F0NjRBcnJheSIsIlVpbnQzMkFycmF5IiwiQmlnSW50NjRBcnJheSIsIkJpZ1VpbnQ2NEFycmF5IiwicSIsIm1lIiwicmVhZEZpbGUiLCJjb2RlIiwiY3JlYXRlUmVhZFN0cmVhbSIsIkJ1ZmZlciIsImNvbmNhdCIsIm9rIiwiaGVhZGVycyIsInBhcnNlSW50IiwiYXJyYXlCdWZmZXIiLCJib2R5IiwiZ2V0UmVhZGVyIiwiQXJyYXlCdWZmZXIiLCJSYW5nZUVycm9yIiwiTWVtb3J5IiwiaW5pdGlhbCIsIm1heGltdW0iLCJidWZmZXIiLCJkb25lIiwicmVhZCIsImJ5dGVMZW5ndGgiLCJzZXQiLCJCbG9iIiwiQXQiLCJOZSIsImplIiwiJCIsIkN0IiwiZ2UiLCIkZSIsInplIiwiUmUiLCJHZSIsIkhlIiwiVmUiLCJfT3J0SW5pdCIsImxvZ0xldmVsIiwiTWFwIiwiX09ydEdldElucHV0T3V0cHV0Q291bnQiLCJIRUFQVTgiLCJBcnJheSIsImlzQXJyYXkiLCJieXRlT2Zmc2V0IiwiZXh0ZXJuYWxEYXRhIiwibW91bnRFeHRlcm5hbERhdGEiLCJ4IiwicGF0aCIsImRhdGEiLCJNIiwiYWxsIiwic2hvdWxkVHJhbnNmZXJUb01MVGVuc29yIiwiY29udGV4dCIsIkoiLCJncHVEZXZpY2UiLCJZIiwiWCIsInBvd2VyUHJlZmVyZW5jZSIsImN1cnJlbnRDb250ZXh0IiwianNlcENyZWF0ZU1MQ29udGV4dCIsIl9PcnRDcmVhdGVTZXNzaW9uIiwianNlcE9uQ3JlYXRlU2Vzc2lvbiIsImpzZXBSZWdpc3Rlck1MQ29udGV4dCIsIl9PcnRHZXRJbnB1dE5hbWUiLCJfT3J0R2V0T3V0cHV0TmFtZSIsIl9PcnRGcmVlIiwiX09ydFJlbGVhc2VCaW5kaW5nIiwiX09ydFJlbGVhc2VTZXNzaW9uIiwidW5tb3VudEV4dGVybmFsRGF0YSIsIl9PcnRDbGVhckJvdW5kT3V0cHV0cyIsImhhbmRsZSIsImpzZXBPblJlbGVhc2VTZXNzaW9uIiwiZGVsZXRlIiwiZ3B1QnVmZmVyIiwianNlcFJlZ2lzdGVyQnVmZmVyIiwibWxUZW5zb3IiLCJqc2VwUmVnaXN0ZXJNTFRlbnNvciIsImxlbmd0aCIsIlR5cGVFcnJvciIsInNldFZhbHVlIiwiX09ydENyZWF0ZVRlbnNvciIsImllIiwiU2UiLCJqc2VwT25SdW5TdGFydCIsIm0iLCJDIiwiX09ydFJ1biIsIlIiLCJOIiwiRWUiLCJCIiwieiIsIlQiLCJJIiwiX09ydEdldFRlbnNvckRhdGEiLCJhZSIsIloiLCJPZSIsImx0IiwiRCIsIkwiLCJXIiwiTyIsIksiLCJvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnMiLCJGIiwiZnQiLCJkdCIsImpzZXBHZXRCdWZmZXIiLCJkb3dubG9hZCIsImpzZXBDcmVhdGVEb3dubG9hZGVyIiwiZGlzcG9zZSIsIl9PcnRSZWxlYXNlVGVuc29yIiwianNlcEVuc3VyZVRlbnNvciIsImpzZXBDcmVhdGVNTFRlbnNvckRvd25sb2FkZXIiLCJqc2VwUmVsZWFzZVRlbnNvcklkIiwic3ViYXJyYXkiLCJfT3J0RW5kUHJvZmlsaW5nIiwiZW52IiwieWUiLCJiZSIsInFlIiwiSmUiLCJZZSIsIlhlIiwiWmUiLCJLZSIsIlFlIiwiZXQiLCJ0dCIsIndlIiwiVGVuc29yIiwiaGUiLCJUUkFDRV9GVU5DX0JFR0lOIiwicnQiLCJUUkFDRV9GVU5DX0VORCIsIm50Iiwib3QiLCJNdCIsIm9lIiwic3QiLCJ0eXBlIiwiZGltcyIsImZyb21HcHVCdWZmZXIiLCJkYXRhVHlwZSIsImZyb21NTFRlbnNvciIsImZldGNoTW9kZWxBbmRDb3B5VG9XYXNtTWVtb3J5IiwibG9hZE1vZGVsIiwic2Vzc2lvbklkIiwiaW5wdXROYW1lcyIsIm91dHB1dE5hbWVzIiwicnVuIiwibWFwIiwic3RhcnRQcm9maWxpbmciLCJlbmRQcm9maWxpbmciLCJhdCIsIk9ubnhydW50aW1lV2ViQXNzZW1ibHlCYWNrZW5kIiwic2UiLCJpbml0aWFsaXplRmxhZ3MiLCJpdCIsIndhc21CYWNrZW5kIiwiVXQiLCJfIiwidXQiLCJzaW1kIiwicHJveHkiLCJ0cmFjZSIsIm5hdmlnYXRvciIsImNwdXMiLCJoYXJkd2FyZUNvbmN1cnJlbmN5IiwibWluIiwiaW5pdCIsImNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyIiwia3QiLCJyZWdpc3RlckJhY2tlbmQiLCJjdCIsIkR0IiwidmUiLCJDciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/onnxruntime-web/dist/ort.node.min.mjs?1960\n");

/***/ }),

/***/ "(ssr)/./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs?ee0f":
/*!*********************************************************************!*\
  !*** ./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InferenceSession: () => (/* binding */ Fp),\n/* harmony export */   TRACE: () => (/* binding */ wr),\n/* harmony export */   TRACE_FUNC_BEGIN: () => (/* binding */ Ue),\n/* harmony export */   TRACE_FUNC_END: () => (/* binding */ De),\n/* harmony export */   Tensor: () => (/* binding */ He),\n/* harmony export */   \"default\": () => (/* binding */ $1),\n/* harmony export */   env: () => (/* binding */ ve),\n/* harmony export */   registerBackend: () => (/* binding */ St)\n/* harmony export */ });\n/*!\n * ONNX Runtime Web v1.21.0-dev.20250114-228dd16893\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */ var Un = Object.defineProperty;\nvar Vp = Object.getOwnPropertyDescriptor;\nvar Wp = Object.getOwnPropertyNames;\nvar Lp = Object.prototype.hasOwnProperty;\nvar Nn = ((e1)=>typeof require < \"u\" ? require : typeof Proxy < \"u\" ? new Proxy(e1, {\n        get: (t, r)=>(typeof require < \"u\" ? require : t)[r]\n    }) : e1)(function(e1) {\n    if (typeof require < \"u\") return require.apply(this, arguments);\n    throw Error('Dynamic require of \"' + e1 + '\" is not supported');\n});\nvar U = (e1, t)=>()=>(e1 && (t = e1(e1 = 0)), t);\nvar Ft = (e1, t)=>{\n    for(var r in t)Un(e1, r, {\n        get: t[r],\n        enumerable: !0\n    });\n}, Gp = (e1, t, r, n)=>{\n    if (t && typeof t == \"object\" || typeof t == \"function\") for (let o of Wp(t))!Lp.call(e1, o) && o !== r && Un(e1, o, {\n        get: ()=>t[o],\n        enumerable: !(n = Vp(t, o)) || n.enumerable\n    });\n    return e1;\n};\nvar br = (e1)=>Gp(Un({}, \"__esModule\", {\n        value: !0\n    }), e1);\nvar yr, xt, St, Hp, Ji, Vn = U(()=>{\n    \"use strict\";\n    yr = new Map, xt = [], St = (e1, t, r)=>{\n        if (t && typeof t.init == \"function\" && typeof t.createInferenceSessionHandler == \"function\") {\n            let n = yr.get(e1);\n            if (n === void 0) yr.set(e1, {\n                backend: t,\n                priority: r\n            });\n            else {\n                if (n.priority > r) return;\n                if (n.priority === r && n.backend !== t) throw new Error(`cannot register backend \"${e1}\" using priority ${r}`);\n            }\n            if (r >= 0) {\n                let o = xt.indexOf(e1);\n                o !== -1 && xt.splice(o, 1);\n                for(let i = 0; i < xt.length; i++)if (yr.get(xt[i]).priority <= r) {\n                    xt.splice(i, 0, e1);\n                    return;\n                }\n                xt.push(e1);\n            }\n            return;\n        }\n        throw new TypeError(\"not a valid backend\");\n    }, Hp = async (e1)=>{\n        let t = yr.get(e1);\n        if (!t) return \"backend not found.\";\n        if (t.initialized) return t.backend;\n        if (t.aborted) return t.error;\n        {\n            let r = !!t.initPromise;\n            try {\n                return r || (t.initPromise = t.backend.init(e1)), await t.initPromise, t.initialized = !0, t.backend;\n            } catch (n) {\n                return r || (t.error = `${n}`, t.aborted = !0), t.error;\n            } finally{\n                delete t.initPromise;\n            }\n        }\n    }, Ji = async (e1)=>{\n        let t = e1.executionProviders || [], r = t.map((l)=>typeof l == \"string\" ? l : l.name), n = r.length === 0 ? xt : r, o, i = [], a = new Set;\n        for (let l of n){\n            let p = await Hp(l);\n            typeof p == \"string\" ? i.push({\n                name: l,\n                err: p\n            }) : (o || (o = p), o === p && a.add(l));\n        }\n        if (!o) throw new Error(`no available backend found. ERR: ${i.map((l)=>`[${l.name}] ${l.err}`).join(\", \")}`);\n        for (let { name: l, err: p } of i)r.includes(l) && console.warn(`removing requested execution provider \"${l}\" from session options because it is not available: ${p}`);\n        let d = t.filter((l)=>a.has(typeof l == \"string\" ? l : l.name));\n        return [\n            o,\n            new Proxy(e1, {\n                get: (l, p)=>p === \"executionProviders\" ? d : Reflect.get(l, p)\n            })\n        ];\n    };\n});\nvar ea = U(()=>{\n    \"use strict\";\n    Vn();\n});\nvar ta, ra = U(()=>{\n    \"use strict\";\n    ta = \"1.21.0-dev.20241212-1f88284f96\";\n});\nvar na, Re, Wn = U(()=>{\n    \"use strict\";\n    ra();\n    na = \"warning\", Re = {\n        wasm: {},\n        webgl: {},\n        webgpu: {},\n        versions: {\n            common: ta\n        },\n        set logLevel (e){\n            if (e !== void 0) {\n                if (typeof e != \"string\" || [\n                    \"verbose\",\n                    \"info\",\n                    \"warning\",\n                    \"error\",\n                    \"fatal\"\n                ].indexOf(e) === -1) throw new Error(`Unsupported logging level: ${e}`);\n                na = e;\n            }\n        },\n        get logLevel () {\n            return na;\n        }\n    };\n    Object.defineProperty(Re, \"logLevel\", {\n        enumerable: !0\n    });\n});\nvar ve, oa = U(()=>{\n    \"use strict\";\n    Wn();\n    ve = Re;\n});\nvar ia, aa, sa = U(()=>{\n    \"use strict\";\n    ia = (e1, t)=>{\n        let r = typeof document < \"u\" ? document.createElement(\"canvas\") : new OffscreenCanvas(1, 1);\n        r.width = e1.dims[3], r.height = e1.dims[2];\n        let n = r.getContext(\"2d\");\n        if (n != null) {\n            let o, i;\n            t?.tensorLayout !== void 0 && t.tensorLayout === \"NHWC\" ? (o = e1.dims[2], i = e1.dims[3]) : (o = e1.dims[3], i = e1.dims[2]);\n            let a = t?.format !== void 0 ? t.format : \"RGB\", d = t?.norm, l, p;\n            d === void 0 || d.mean === void 0 ? l = [\n                255,\n                255,\n                255,\n                255\n            ] : typeof d.mean == \"number\" ? l = [\n                d.mean,\n                d.mean,\n                d.mean,\n                d.mean\n            ] : (l = [\n                d.mean[0],\n                d.mean[1],\n                d.mean[2],\n                0\n            ], d.mean[3] !== void 0 && (l[3] = d.mean[3])), d === void 0 || d.bias === void 0 ? p = [\n                0,\n                0,\n                0,\n                0\n            ] : typeof d.bias == \"number\" ? p = [\n                d.bias,\n                d.bias,\n                d.bias,\n                d.bias\n            ] : (p = [\n                d.bias[0],\n                d.bias[1],\n                d.bias[2],\n                0\n            ], d.bias[3] !== void 0 && (p[3] = d.bias[3]));\n            let m = i * o, u = 0, h = m, _ = m * 2, y = -1;\n            a === \"RGBA\" ? (u = 0, h = m, _ = m * 2, y = m * 3) : a === \"RGB\" ? (u = 0, h = m, _ = m * 2) : a === \"RBG\" && (u = 0, _ = m, h = m * 2);\n            for(let g = 0; g < i; g++)for(let x = 0; x < o; x++){\n                let $ = (e1.data[u++] - p[0]) * l[0], v = (e1.data[h++] - p[1]) * l[1], S = (e1.data[_++] - p[2]) * l[2], T = y === -1 ? 255 : (e1.data[y++] - p[3]) * l[3];\n                n.fillStyle = \"rgba(\" + $ + \",\" + v + \",\" + S + \",\" + T + \")\", n.fillRect(x, g, 1, 1);\n            }\n            if (\"toDataURL\" in r) return r.toDataURL();\n            throw new Error(\"toDataURL is not supported\");\n        } else throw new Error(\"Can not access image data\");\n    }, aa = (e1, t)=>{\n        let r = typeof document < \"u\" ? document.createElement(\"canvas\").getContext(\"2d\") : new OffscreenCanvas(1, 1).getContext(\"2d\"), n;\n        if (r != null) {\n            let o, i, a;\n            t?.tensorLayout !== void 0 && t.tensorLayout === \"NHWC\" ? (o = e1.dims[2], i = e1.dims[1], a = e1.dims[3]) : (o = e1.dims[3], i = e1.dims[2], a = e1.dims[1]);\n            let d = t !== void 0 && t.format !== void 0 ? t.format : \"RGB\", l = t?.norm, p, m;\n            l === void 0 || l.mean === void 0 ? p = [\n                255,\n                255,\n                255,\n                255\n            ] : typeof l.mean == \"number\" ? p = [\n                l.mean,\n                l.mean,\n                l.mean,\n                l.mean\n            ] : (p = [\n                l.mean[0],\n                l.mean[1],\n                l.mean[2],\n                255\n            ], l.mean[3] !== void 0 && (p[3] = l.mean[3])), l === void 0 || l.bias === void 0 ? m = [\n                0,\n                0,\n                0,\n                0\n            ] : typeof l.bias == \"number\" ? m = [\n                l.bias,\n                l.bias,\n                l.bias,\n                l.bias\n            ] : (m = [\n                l.bias[0],\n                l.bias[1],\n                l.bias[2],\n                0\n            ], l.bias[3] !== void 0 && (m[3] = l.bias[3]));\n            let u = i * o;\n            if (t !== void 0 && (t.format !== void 0 && a === 4 && t.format !== \"RGBA\" || a === 3 && t.format !== \"RGB\" && t.format !== \"BGR\")) throw new Error(\"Tensor format doesn't match input tensor dims\");\n            let h = 4, _ = 0, y = 1, g = 2, x = 3, $ = 0, v = u, S = u * 2, T = -1;\n            d === \"RGBA\" ? ($ = 0, v = u, S = u * 2, T = u * 3) : d === \"RGB\" ? ($ = 0, v = u, S = u * 2) : d === \"RBG\" && ($ = 0, S = u, v = u * 2), n = r.createImageData(o, i);\n            for(let A = 0; A < i * o; _ += h, y += h, g += h, x += h, A++)n.data[_] = (e1.data[$++] - m[0]) * p[0], n.data[y] = (e1.data[v++] - m[1]) * p[1], n.data[g] = (e1.data[S++] - m[2]) * p[2], n.data[x] = T === -1 ? 255 : (e1.data[T++] - m[3]) * p[3];\n        } else throw new Error(\"Can not access image data\");\n        return n;\n    };\n});\nvar Ln, ua, da, la, ca, pa, ma = U(()=>{\n    \"use strict\";\n    _r();\n    Ln = (e1, t)=>{\n        if (e1 === void 0) throw new Error(\"Image buffer must be defined\");\n        if (t.height === void 0 || t.width === void 0) throw new Error(\"Image height and width must be defined\");\n        if (t.tensorLayout === \"NHWC\") throw new Error(\"NHWC Tensor layout is not supported yet\");\n        let { height: r, width: n } = t, o = t.norm ?? {\n            mean: 255,\n            bias: 0\n        }, i, a;\n        typeof o.mean == \"number\" ? i = [\n            o.mean,\n            o.mean,\n            o.mean,\n            o.mean\n        ] : i = [\n            o.mean[0],\n            o.mean[1],\n            o.mean[2],\n            o.mean[3] ?? 255\n        ], typeof o.bias == \"number\" ? a = [\n            o.bias,\n            o.bias,\n            o.bias,\n            o.bias\n        ] : a = [\n            o.bias[0],\n            o.bias[1],\n            o.bias[2],\n            o.bias[3] ?? 0\n        ];\n        let d = t.format !== void 0 ? t.format : \"RGBA\", l = t.tensorFormat !== void 0 && t.tensorFormat !== void 0 ? t.tensorFormat : \"RGB\", p = r * n, m = l === \"RGBA\" ? new Float32Array(p * 4) : new Float32Array(p * 3), u = 4, h = 0, _ = 1, y = 2, g = 3, x = 0, $ = p, v = p * 2, S = -1;\n        d === \"RGB\" && (u = 3, h = 0, _ = 1, y = 2, g = -1), l === \"RGBA\" ? S = p * 3 : l === \"RBG\" ? (x = 0, v = p, $ = p * 2) : l === \"BGR\" && (v = 0, $ = p, x = p * 2);\n        for(let A = 0; A < p; A++, h += u, y += u, _ += u, g += u)m[x++] = (e1[h] + a[0]) / i[0], m[$++] = (e1[_] + a[1]) / i[1], m[v++] = (e1[y] + a[2]) / i[2], S !== -1 && g !== -1 && (m[S++] = (e1[g] + a[3]) / i[3]);\n        return l === \"RGBA\" ? new ze(\"float32\", m, [\n            1,\n            4,\n            r,\n            n\n        ]) : new ze(\"float32\", m, [\n            1,\n            3,\n            r,\n            n\n        ]);\n    }, ua = async (e1, t)=>{\n        let r = typeof HTMLImageElement < \"u\" && e1 instanceof HTMLImageElement, n = typeof ImageData < \"u\" && e1 instanceof ImageData, o = typeof ImageBitmap < \"u\" && e1 instanceof ImageBitmap, i = typeof e1 == \"string\", a, d = t ?? {}, l = ()=>{\n            if (typeof document < \"u\") return document.createElement(\"canvas\");\n            if (typeof OffscreenCanvas < \"u\") return new OffscreenCanvas(1, 1);\n            throw new Error(\"Canvas is not supported\");\n        }, p = (m)=>typeof HTMLCanvasElement < \"u\" && m instanceof HTMLCanvasElement || m instanceof OffscreenCanvas ? m.getContext(\"2d\") : null;\n        if (r) {\n            let m = l();\n            m.width = e1.width, m.height = e1.height;\n            let u = p(m);\n            if (u != null) {\n                let h = e1.height, _ = e1.width;\n                if (t !== void 0 && t.resizedHeight !== void 0 && t.resizedWidth !== void 0 && (h = t.resizedHeight, _ = t.resizedWidth), t !== void 0) {\n                    if (d = t, t.tensorFormat !== void 0) throw new Error(\"Image input config format must be RGBA for HTMLImageElement\");\n                    d.tensorFormat = \"RGBA\", d.height = h, d.width = _;\n                } else d.tensorFormat = \"RGBA\", d.height = h, d.width = _;\n                u.drawImage(e1, 0, 0), a = u.getImageData(0, 0, _, h).data;\n            } else throw new Error(\"Can not access image data\");\n        } else if (n) {\n            let m, u;\n            if (t !== void 0 && t.resizedWidth !== void 0 && t.resizedHeight !== void 0 ? (m = t.resizedHeight, u = t.resizedWidth) : (m = e1.height, u = e1.width), t !== void 0 && (d = t), d.format = \"RGBA\", d.height = m, d.width = u, t !== void 0) {\n                let h = l();\n                h.width = u, h.height = m;\n                let _ = p(h);\n                if (_ != null) _.putImageData(e1, 0, 0), a = _.getImageData(0, 0, u, m).data;\n                else throw new Error(\"Can not access image data\");\n            } else a = e1.data;\n        } else if (o) {\n            if (t === void 0) throw new Error(\"Please provide image config with format for Imagebitmap\");\n            let m = l();\n            m.width = e1.width, m.height = e1.height;\n            let u = p(m);\n            if (u != null) {\n                let h = e1.height, _ = e1.width;\n                return u.drawImage(e1, 0, 0, _, h), a = u.getImageData(0, 0, _, h).data, d.height = h, d.width = _, Ln(a, d);\n            } else throw new Error(\"Can not access image data\");\n        } else {\n            if (i) return new Promise((m, u)=>{\n                let h = l(), _ = p(h);\n                if (!e1 || !_) return u();\n                let y = new Image;\n                y.crossOrigin = \"Anonymous\", y.src = e1, y.onload = ()=>{\n                    h.width = y.width, h.height = y.height, _.drawImage(y, 0, 0, h.width, h.height);\n                    let g = _.getImageData(0, 0, h.width, h.height);\n                    d.height = h.height, d.width = h.width, m(Ln(g.data, d));\n                };\n            });\n            throw new Error(\"Input data provided is not supported - aborted tensor creation\");\n        }\n        if (a !== void 0) return Ln(a, d);\n        throw new Error(\"Input data provided is not supported - aborted tensor creation\");\n    }, da = (e1, t)=>{\n        let { width: r, height: n, download: o, dispose: i } = t, a = [\n            1,\n            n,\n            r,\n            4\n        ];\n        return new ze({\n            location: \"texture\",\n            type: \"float32\",\n            texture: e1,\n            dims: a,\n            download: o,\n            dispose: i\n        });\n    }, la = (e1, t)=>{\n        let { dataType: r, dims: n, download: o, dispose: i } = t;\n        return new ze({\n            location: \"gpu-buffer\",\n            type: r ?? \"float32\",\n            gpuBuffer: e1,\n            dims: n,\n            download: o,\n            dispose: i\n        });\n    }, ca = (e1, t)=>{\n        let { dataType: r, dims: n, download: o, dispose: i } = t;\n        return new ze({\n            location: \"ml-tensor\",\n            type: r ?? \"float32\",\n            mlTensor: e1,\n            dims: n,\n            download: o,\n            dispose: i\n        });\n    }, pa = (e1, t, r)=>new ze({\n            location: \"cpu-pinned\",\n            type: e1,\n            data: t,\n            dims: r ?? [\n                t.length\n            ]\n        });\n});\nvar Tt, qt, fa, ha, ga = U(()=>{\n    \"use strict\";\n    Tt = new Map([\n        [\n            \"float32\",\n            Float32Array\n        ],\n        [\n            \"uint8\",\n            Uint8Array\n        ],\n        [\n            \"int8\",\n            Int8Array\n        ],\n        [\n            \"uint16\",\n            Uint16Array\n        ],\n        [\n            \"int16\",\n            Int16Array\n        ],\n        [\n            \"int32\",\n            Int32Array\n        ],\n        [\n            \"bool\",\n            Uint8Array\n        ],\n        [\n            \"float64\",\n            Float64Array\n        ],\n        [\n            \"uint32\",\n            Uint32Array\n        ],\n        [\n            \"int4\",\n            Uint8Array\n        ],\n        [\n            \"uint4\",\n            Uint8Array\n        ]\n    ]), qt = new Map([\n        [\n            Float32Array,\n            \"float32\"\n        ],\n        [\n            Uint8Array,\n            \"uint8\"\n        ],\n        [\n            Int8Array,\n            \"int8\"\n        ],\n        [\n            Uint16Array,\n            \"uint16\"\n        ],\n        [\n            Int16Array,\n            \"int16\"\n        ],\n        [\n            Int32Array,\n            \"int32\"\n        ],\n        [\n            Float64Array,\n            \"float64\"\n        ],\n        [\n            Uint32Array,\n            \"uint32\"\n        ]\n    ]), fa = !1, ha = ()=>{\n        if (!fa) {\n            fa = !0;\n            let e1 = typeof BigInt64Array < \"u\" && BigInt64Array.from, t = typeof BigUint64Array < \"u\" && BigUint64Array.from, r = typeof Float16Array < \"u\" && Float16Array.from;\n            e1 && (Tt.set(\"int64\", BigInt64Array), qt.set(BigInt64Array, \"int64\")), t && (Tt.set(\"uint64\", BigUint64Array), qt.set(BigUint64Array, \"uint64\")), r ? (Tt.set(\"float16\", Float16Array), qt.set(Float16Array, \"float16\")) : Tt.set(\"float16\", Uint16Array);\n        }\n    };\n});\nvar ba, ya, _a = U(()=>{\n    \"use strict\";\n    _r();\n    ba = (e1)=>{\n        let t = 1;\n        for(let r = 0; r < e1.length; r++){\n            let n = e1[r];\n            if (typeof n != \"number\" || !Number.isSafeInteger(n)) throw new TypeError(`dims[${r}] must be an integer, got: ${n}`);\n            if (n < 0) throw new RangeError(`dims[${r}] must be a non-negative integer, got: ${n}`);\n            t *= n;\n        }\n        return t;\n    }, ya = (e1, t)=>{\n        switch(e1.location){\n            case \"cpu\":\n                return new ze(e1.type, e1.data, t);\n            case \"cpu-pinned\":\n                return new ze({\n                    location: \"cpu-pinned\",\n                    data: e1.data,\n                    type: e1.type,\n                    dims: t\n                });\n            case \"texture\":\n                return new ze({\n                    location: \"texture\",\n                    texture: e1.texture,\n                    type: e1.type,\n                    dims: t\n                });\n            case \"gpu-buffer\":\n                return new ze({\n                    location: \"gpu-buffer\",\n                    gpuBuffer: e1.gpuBuffer,\n                    type: e1.type,\n                    dims: t\n                });\n            case \"ml-tensor\":\n                return new ze({\n                    location: \"ml-tensor\",\n                    mlTensor: e1.mlTensor,\n                    type: e1.type,\n                    dims: t\n                });\n            default:\n                throw new Error(`tensorReshape: tensor location ${e1.location} is not supported`);\n        }\n    };\n});\nvar ze, _r = U(()=>{\n    \"use strict\";\n    sa();\n    ma();\n    ga();\n    _a();\n    ze = class {\n        constructor(t, r, n){\n            ha();\n            let o, i;\n            if (typeof t == \"object\" && \"location\" in t) switch(this.dataLocation = t.location, o = t.type, i = t.dims, t.location){\n                case \"cpu-pinned\":\n                    {\n                        let d = Tt.get(o);\n                        if (!d) throw new TypeError(`unsupported type \"${o}\" to create tensor from pinned buffer`);\n                        if (!(t.data instanceof d)) throw new TypeError(`buffer should be of type ${d.name}`);\n                        this.cpuData = t.data;\n                        break;\n                    }\n                case \"texture\":\n                    {\n                        if (o !== \"float32\") throw new TypeError(`unsupported type \"${o}\" to create tensor from texture`);\n                        this.gpuTextureData = t.texture, this.downloader = t.download, this.disposer = t.dispose;\n                        break;\n                    }\n                case \"gpu-buffer\":\n                    {\n                        if (o !== \"float32\" && o !== \"float16\" && o !== \"int32\" && o !== \"int64\" && o !== \"uint32\" && o !== \"uint8\" && o !== \"bool\" && o !== \"uint4\" && o !== \"int4\") throw new TypeError(`unsupported type \"${o}\" to create tensor from gpu buffer`);\n                        this.gpuBufferData = t.gpuBuffer, this.downloader = t.download, this.disposer = t.dispose;\n                        break;\n                    }\n                case \"ml-tensor\":\n                    {\n                        if (o !== \"float32\" && o !== \"float16\" && o !== \"int32\" && o !== \"int64\" && o !== \"uint32\" && o !== \"uint64\" && o !== \"int8\" && o !== \"uint8\" && o !== \"bool\" && o !== \"uint4\" && o !== \"int4\") throw new TypeError(`unsupported type \"${o}\" to create tensor from MLTensor`);\n                        this.mlTensorData = t.mlTensor, this.downloader = t.download, this.disposer = t.dispose;\n                        break;\n                    }\n                default:\n                    throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`);\n            }\n            else {\n                let d, l;\n                if (typeof t == \"string\") if (o = t, l = n, t === \"string\") {\n                    if (!Array.isArray(r)) throw new TypeError(\"A string tensor's data must be a string array.\");\n                    d = r;\n                } else {\n                    let p = Tt.get(t);\n                    if (p === void 0) throw new TypeError(`Unsupported tensor type: ${t}.`);\n                    if (Array.isArray(r)) {\n                        if (t === \"float16\" && p === Uint16Array || t === \"uint4\" || t === \"int4\") throw new TypeError(`Creating a ${t} tensor from number array is not supported. Please use ${p.name} as data.`);\n                        t === \"uint64\" || t === \"int64\" ? d = p.from(r, BigInt) : d = p.from(r);\n                    } else if (r instanceof p) d = r;\n                    else if (r instanceof Uint8ClampedArray) if (t === \"uint8\") d = Uint8Array.from(r);\n                    else throw new TypeError(\"A Uint8ClampedArray tensor's data must be type of uint8\");\n                    else throw new TypeError(`A ${o} tensor's data must be type of ${p}`);\n                }\n                else if (l = r, Array.isArray(t)) {\n                    if (t.length === 0) throw new TypeError(\"Tensor type cannot be inferred from an empty array.\");\n                    let p = typeof t[0];\n                    if (p === \"string\") o = \"string\", d = t;\n                    else if (p === \"boolean\") o = \"bool\", d = Uint8Array.from(t);\n                    else throw new TypeError(`Invalid element type of data array: ${p}.`);\n                } else if (t instanceof Uint8ClampedArray) o = \"uint8\", d = Uint8Array.from(t);\n                else {\n                    let p = qt.get(t.constructor);\n                    if (p === void 0) throw new TypeError(`Unsupported type for tensor data: ${t.constructor}.`);\n                    o = p, d = t;\n                }\n                if (l === void 0) l = [\n                    d.length\n                ];\n                else if (!Array.isArray(l)) throw new TypeError(\"A tensor's dims must be a number array\");\n                i = l, this.cpuData = d, this.dataLocation = \"cpu\";\n            }\n            let a = ba(i);\n            if (this.cpuData && a !== this.cpuData.length && !((o === \"uint4\" || o === \"int4\") && Math.ceil(a / 2) === this.cpuData.length)) throw new Error(`Tensor's size(${a}) does not match data length(${this.cpuData.length}).`);\n            this.type = o, this.dims = i, this.size = a;\n        }\n        static async fromImage(t, r) {\n            return ua(t, r);\n        }\n        static fromTexture(t, r) {\n            return da(t, r);\n        }\n        static fromGpuBuffer(t, r) {\n            return la(t, r);\n        }\n        static fromMLTensor(t, r) {\n            return ca(t, r);\n        }\n        static fromPinnedBuffer(t, r, n) {\n            return pa(t, r, n);\n        }\n        toDataURL(t) {\n            return ia(this, t);\n        }\n        toImageData(t) {\n            return aa(this, t);\n        }\n        get data() {\n            if (this.ensureValid(), !this.cpuData) throw new Error(\"The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.\");\n            return this.cpuData;\n        }\n        get location() {\n            return this.dataLocation;\n        }\n        get texture() {\n            if (this.ensureValid(), !this.gpuTextureData) throw new Error(\"The data is not stored as a WebGL texture.\");\n            return this.gpuTextureData;\n        }\n        get gpuBuffer() {\n            if (this.ensureValid(), !this.gpuBufferData) throw new Error(\"The data is not stored as a WebGPU buffer.\");\n            return this.gpuBufferData;\n        }\n        get mlTensor() {\n            if (this.ensureValid(), !this.mlTensorData) throw new Error(\"The data is not stored as a WebNN MLTensor.\");\n            return this.mlTensorData;\n        }\n        async getData(t) {\n            switch(this.ensureValid(), this.dataLocation){\n                case \"cpu\":\n                case \"cpu-pinned\":\n                    return this.data;\n                case \"texture\":\n                case \"gpu-buffer\":\n                case \"ml-tensor\":\n                    {\n                        if (!this.downloader) throw new Error(\"The current tensor is not created with a specified data downloader.\");\n                        if (this.isDownloading) throw new Error(\"The current tensor is being downloaded.\");\n                        try {\n                            this.isDownloading = !0;\n                            let r = await this.downloader();\n                            return this.downloader = void 0, this.dataLocation = \"cpu\", this.cpuData = r, t && this.disposer && (this.disposer(), this.disposer = void 0), r;\n                        } finally{\n                            this.isDownloading = !1;\n                        }\n                    }\n                default:\n                    throw new Error(`cannot get data from location: ${this.dataLocation}`);\n            }\n        }\n        dispose() {\n            if (this.isDownloading) throw new Error(\"The current tensor is being downloaded.\");\n            this.disposer && (this.disposer(), this.disposer = void 0), this.cpuData = void 0, this.gpuTextureData = void 0, this.gpuBufferData = void 0, this.mlTensorData = void 0, this.downloader = void 0, this.isDownloading = void 0, this.dataLocation = \"none\";\n        }\n        ensureValid() {\n            if (this.dataLocation === \"none\") throw new Error(\"The tensor is disposed.\");\n        }\n        reshape(t) {\n            if (this.ensureValid(), this.downloader || this.disposer) throw new Error(\"Cannot reshape a tensor that owns GPU resource.\");\n            return ya(this, t);\n        }\n    };\n});\nvar He, Gn = U(()=>{\n    \"use strict\";\n    _r();\n    He = ze;\n});\nvar wr, wa, Ue, De, Hn = U(()=>{\n    \"use strict\";\n    Wn();\n    wr = (e1, t)=>{\n        (typeof Re.trace > \"u\" ? !Re.wasm.trace : !Re.trace) || console.timeStamp(`${e1}::ORT::${t}`);\n    }, wa = (e1, t)=>{\n        let r = new Error().stack?.split(/\\r\\n|\\r|\\n/g) || [], n = !1;\n        for(let o = 0; o < r.length; o++){\n            if (n && !r[o].includes(\"TRACE_FUNC\")) {\n                let i = `FUNC_${e1}::${r[o].trim().split(\" \")[1]}`;\n                t && (i += `::${t}`), wr(\"CPU\", i);\n                return;\n            }\n            r[o].includes(\"TRACE_FUNC\") && (n = !0);\n        }\n    }, Ue = (e1)=>{\n        (typeof Re.trace > \"u\" ? !Re.wasm.trace : !Re.trace) || wa(\"BEGIN\", e1);\n    }, De = (e1)=>{\n        (typeof Re.trace > \"u\" ? !Re.wasm.trace : !Re.trace) || wa(\"END\", e1);\n    };\n});\nvar vr, va = U(()=>{\n    \"use strict\";\n    Vn();\n    Gn();\n    Hn();\n    vr = class e1 {\n        constructor(t){\n            this.handler = t;\n        }\n        async run(t, r, n) {\n            Ue();\n            let o = {}, i = {};\n            if (typeof t != \"object\" || t === null || t instanceof He || Array.isArray(t)) throw new TypeError(\"'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.\");\n            let a = !0;\n            if (typeof r == \"object\") {\n                if (r === null) throw new TypeError(\"Unexpected argument[1]: cannot be null.\");\n                if (r instanceof He) throw new TypeError(\"'fetches' cannot be a Tensor\");\n                if (Array.isArray(r)) {\n                    if (r.length === 0) throw new TypeError(\"'fetches' cannot be an empty array.\");\n                    a = !1;\n                    for (let p of r){\n                        if (typeof p != \"string\") throw new TypeError(\"'fetches' must be a string array or an object.\");\n                        if (this.outputNames.indexOf(p) === -1) throw new RangeError(`'fetches' contains invalid output name: ${p}.`);\n                        o[p] = null;\n                    }\n                    if (typeof n == \"object\" && n !== null) i = n;\n                    else if (typeof n < \"u\") throw new TypeError(\"'options' must be an object.\");\n                } else {\n                    let p = !1, m = Object.getOwnPropertyNames(r);\n                    for (let u of this.outputNames)if (m.indexOf(u) !== -1) {\n                        let h = r[u];\n                        (h === null || h instanceof He) && (p = !0, a = !1, o[u] = h);\n                    }\n                    if (p) {\n                        if (typeof n == \"object\" && n !== null) i = n;\n                        else if (typeof n < \"u\") throw new TypeError(\"'options' must be an object.\");\n                    } else i = r;\n                }\n            } else if (typeof r < \"u\") throw new TypeError(\"Unexpected argument[1]: must be 'fetches' or 'options'.\");\n            for (let p of this.inputNames)if (typeof t[p] > \"u\") throw new Error(`input '${p}' is missing in 'feeds'.`);\n            if (a) for (let p of this.outputNames)o[p] = null;\n            let d = await this.handler.run(t, o, i), l = {};\n            for(let p in d)if (Object.hasOwnProperty.call(d, p)) {\n                let m = d[p];\n                m instanceof He ? l[p] = m : l[p] = new He(m.type, m.data, m.dims);\n            }\n            return De(), l;\n        }\n        async release() {\n            return this.handler.dispose();\n        }\n        static async create(t, r, n, o) {\n            Ue();\n            let i, a = {};\n            if (typeof t == \"string\") {\n                if (i = t, typeof r == \"object\" && r !== null) a = r;\n                else if (typeof r < \"u\") throw new TypeError(\"'options' must be an object.\");\n            } else if (t instanceof Uint8Array) {\n                if (i = t, typeof r == \"object\" && r !== null) a = r;\n                else if (typeof r < \"u\") throw new TypeError(\"'options' must be an object.\");\n            } else if (t instanceof ArrayBuffer || typeof SharedArrayBuffer < \"u\" && t instanceof SharedArrayBuffer) {\n                let m = t, u = 0, h = t.byteLength;\n                if (typeof r == \"object\" && r !== null) a = r;\n                else if (typeof r == \"number\") {\n                    if (u = r, !Number.isSafeInteger(u)) throw new RangeError(\"'byteOffset' must be an integer.\");\n                    if (u < 0 || u >= m.byteLength) throw new RangeError(`'byteOffset' is out of range [0, ${m.byteLength}).`);\n                    if (h = t.byteLength - u, typeof n == \"number\") {\n                        if (h = n, !Number.isSafeInteger(h)) throw new RangeError(\"'byteLength' must be an integer.\");\n                        if (h <= 0 || u + h > m.byteLength) throw new RangeError(`'byteLength' is out of range (0, ${m.byteLength - u}].`);\n                        if (typeof o == \"object\" && o !== null) a = o;\n                        else if (typeof o < \"u\") throw new TypeError(\"'options' must be an object.\");\n                    } else if (typeof n < \"u\") throw new TypeError(\"'byteLength' must be a number.\");\n                } else if (typeof r < \"u\") throw new TypeError(\"'options' must be an object.\");\n                i = new Uint8Array(m, u, h);\n            } else throw new TypeError(\"Unexpected argument[0]: must be 'path' or 'buffer'.\");\n            let [d, l] = await Ji(a), p = await d.createInferenceSessionHandler(i, l);\n            return De(), new e1(p);\n        }\n        startProfiling() {\n            this.handler.startProfiling();\n        }\n        endProfiling() {\n            this.handler.endProfiling();\n        }\n        get inputNames() {\n            return this.handler.inputNames;\n        }\n        get outputNames() {\n            return this.handler.outputNames;\n        }\n    };\n});\nvar Fp, $a = U(()=>{\n    \"use strict\";\n    va();\n    Fp = vr;\n});\nvar xa = U(()=>{\n    \"use strict\";\n});\nvar Sa = U(()=>{\n    \"use strict\";\n});\nvar Ta = U(()=>{\n    \"use strict\";\n});\nvar Ia = U(()=>{\n    \"use strict\";\n});\nvar Fn = {};\nFt(Fn, {\n    InferenceSession: ()=>Fp,\n    TRACE: ()=>wr,\n    TRACE_FUNC_BEGIN: ()=>Ue,\n    TRACE_FUNC_END: ()=>De,\n    Tensor: ()=>He,\n    env: ()=>ve,\n    registerBackend: ()=>St\n});\nvar We = U(()=>{\n    \"use strict\";\n    ea();\n    oa();\n    $a();\n    Gn();\n    xa();\n    Sa();\n    Hn();\n    Ta();\n    Ia();\n});\nvar $r = U(()=>{\n    \"use strict\";\n});\nvar Ea = {};\nFt(Ea, {\n    default: ()=>qp\n});\nvar Aa, ka, qp, Pa = U(()=>{\n    \"use strict\";\n    qn();\n    gt();\n    xr();\n    Aa = \"ort-wasm-proxy-worker\", ka = globalThis.self?.name === Aa;\n    ka && (self.onmessage = (e1)=>{\n        let { type: t, in: r } = e1.data;\n        try {\n            switch(t){\n                case \"init-wasm\":\n                    Sr(r.wasm).then(()=>{\n                        Tr(r).then(()=>{\n                            postMessage({\n                                type: t\n                            });\n                        }, (n)=>{\n                            postMessage({\n                                type: t,\n                                err: n\n                            });\n                        });\n                    }, (n)=>{\n                        postMessage({\n                            type: t,\n                            err: n\n                        });\n                    });\n                    break;\n                case \"init-ep\":\n                    {\n                        let { epName: n, env: o } = r;\n                        Ir(o, n).then(()=>{\n                            postMessage({\n                                type: t\n                            });\n                        }, (i)=>{\n                            postMessage({\n                                type: t,\n                                err: i\n                            });\n                        });\n                        break;\n                    }\n                case \"copy-from\":\n                    {\n                        let { buffer: n } = r, o = Kt(n);\n                        postMessage({\n                            type: t,\n                            out: o\n                        });\n                        break;\n                    }\n                case \"create\":\n                    {\n                        let { model: n, options: o } = r;\n                        Cr(n, o).then((i)=>{\n                            postMessage({\n                                type: t,\n                                out: i\n                            });\n                        }, (i)=>{\n                            postMessage({\n                                type: t,\n                                err: i\n                            });\n                        });\n                        break;\n                    }\n                case \"release\":\n                    Ar(r), postMessage({\n                        type: t\n                    });\n                    break;\n                case \"run\":\n                    {\n                        let { sessionId: n, inputIndices: o, inputs: i, outputIndices: a, options: d } = r;\n                        kr(n, o, i, a, new Array(a.length).fill(null), d).then((l)=>{\n                            l.some((p)=>p[3] !== \"cpu\") ? postMessage({\n                                type: t,\n                                err: \"Proxy does not support non-cpu tensor location.\"\n                            }) : postMessage({\n                                type: t,\n                                out: l\n                            }, Pr([\n                                ...i,\n                                ...l\n                            ]));\n                        }, (l)=>{\n                            postMessage({\n                                type: t,\n                                err: l\n                            });\n                        });\n                        break;\n                    }\n                case \"end-profiling\":\n                    Er(r), postMessage({\n                        type: t\n                    });\n                    break;\n                default:\n            }\n        } catch (n) {\n            postMessage({\n                type: t,\n                err: n\n            });\n        }\n    });\n    qp = ka ? null : (e1)=>new Worker(e1 ?? Ne, {\n            type: \"module\",\n            name: Aa\n        });\n});\nvar Oa = {};\nFt(Oa, {\n    default: ()=>Kp\n});\nvar Kn, za, Kp, Da = U(()=>{\n    \"use strict\";\n    za = (Kn = \"file:///Users/amityadav/Desktop/Text-Behind%20Image/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs\", async function(e1 = {}) {\n        function t() {\n            return se.buffer != J.buffer && ye(), J;\n        }\n        function r() {\n            return se.buffer != J.buffer && ye(), ne;\n        }\n        function n() {\n            return se.buffer != J.buffer && ye(), be;\n        }\n        function o() {\n            return se.buffer != J.buffer && ye(), Oe;\n        }\n        function i() {\n            return se.buffer != J.buffer && ye(), $e;\n        }\n        function a() {\n            return se.buffer != J.buffer && ye(), le;\n        }\n        function d() {\n            return se.buffer != J.buffer && ye(), W;\n        }\n        function l() {\n            return se.buffer != J.buffer && ye(), Ge;\n        }\n        var p, m, u = Object.assign({}, e1), h = new Promise((s, c)=>{\n            p = s, m = c;\n        }), _ = \"undefined\" == \"object\", y = typeof importScripts == \"function\", g = y && self.name == \"em-pthread\";\n        u.mountExternalData = (s, c)=>{\n            s.startsWith(\"./\") && (s = s.substring(2)), (u.Fb || (u.Fb = new Map)).set(s, c);\n        }, u.unmountExternalData = ()=>{\n            delete u.Fb;\n        };\n        var x = globalThis.SharedArrayBuffer ?? new WebAssembly.Memory({\n            initial: 0,\n            maximum: 0,\n            shared: !0\n        }).buffer.constructor;\n        let $ = ()=>{\n            let s = (f, b, w)=>(...I)=>{\n                    let O = Xe, B = b?.();\n                    I = f(...I);\n                    let L = b?.();\n                    return B !== L && (f = L, w(B), b = w = null), Xe != O ? new Promise((H, X)=>{\n                        En = {\n                            resolve: H,\n                            reject: X\n                        };\n                    }) : I;\n                }, c = (f)=>async (...b)=>{\n                    try {\n                        if (u.Gb) throw Error(\"Session already started\");\n                        let w = u.Gb = {\n                            hc: b[0],\n                            errors: []\n                        }, I = await f(...b);\n                        if (u.Gb !== w) throw Error(\"Session mismatch\");\n                        u.Hb?.flush();\n                        let O = w.errors;\n                        if (0 < O.length) {\n                            let B = await Promise.all(O);\n                            if (B = B.filter((L)=>L), 0 < B.length) throw Error(B.join(`\n`));\n                        }\n                        return I;\n                    } finally{\n                        u.Gb = null;\n                    }\n                };\n            u._OrtCreateSession = s(u._OrtCreateSession, ()=>u._OrtCreateSession, (f)=>u._OrtCreateSession = f), u._OrtRun = c(s(u._OrtRun, ()=>u._OrtRun, (f)=>u._OrtRun = f)), u._OrtRunWithBinding = c(s(u._OrtRunWithBinding, ()=>u._OrtRunWithBinding, (f)=>u._OrtRunWithBinding = f)), u._OrtBindInput = s(u._OrtBindInput, ()=>u._OrtBindInput, (f)=>u._OrtBindInput = f), $ = void 0;\n        };\n        u.jsepInit = (s, c)=>{\n            if ($?.(), s === \"webgpu\") {\n                [u.Hb, u.Vb, u.Zb, u.Ob, u.Yb, u.kb, u.$b, u.cc, u.Wb, u.Xb, u.ac] = c;\n                let f = u.Hb;\n                u.jsepRegisterBuffer = (b, w, I, O)=>f.registerBuffer(b, w, I, O), u.jsepGetBuffer = (b)=>f.getBuffer(b), u.jsepCreateDownloader = (b, w, I)=>f.createDownloader(b, w, I), u.jsepOnCreateSession = (b)=>{\n                    f.onCreateSession(b);\n                }, u.jsepOnReleaseSession = (b)=>{\n                    f.onReleaseSession(b);\n                }, u.jsepOnRunStart = (b)=>f.onRunStart(b), u.dc = (b, w)=>{\n                    f.upload(b, w);\n                };\n            } else if (s === \"webnn\") {\n                [u.Hb, u.bc, u.Pb, u.jsepEnsureTensor, u.ec, u.jsepDownloadTensor] = c, u.jsepReleaseTensorId = u.Pb;\n                let f = u.Hb;\n                u.jsepOnRunStart = (b)=>f.onRunStart(b), u.jsepRegisterMLContext = (b, w)=>{\n                    f.registerMLContext(b, w);\n                }, u.jsepOnReleaseSession = (b)=>{\n                    f.onReleaseSession(b);\n                }, u.jsepCreateMLTensorDownloader = (b, w)=>f.createMLTensorDownloader(b, w), u.jsepRegisterMLTensor = (b, w, I)=>f.registerMLTensor(b, w, I), u.jsepCreateMLContext = (b)=>f.createMLContext(b), u.jsepRegisterMLConstant = (b, w, I, O, B)=>f.registerMLConstant(b, w, I, O, B, u.Fb);\n            }\n        };\n        var v, S, T = Object.assign({}, u), A = \"./this.program\", k = (s, c)=>{\n            throw c;\n        }, P = \"\";\n        (_ || y) && (y ? P = self.location.href : typeof document < \"u\" && document.currentScript && (P = document.currentScript.src), Kn && (P = Kn), P = P.startsWith(\"blob:\") ? \"\" : P.substr(0, P.replace(/[?#].*/, \"\").lastIndexOf(\"/\") + 1), y && (S = (s)=>{\n            var c = new XMLHttpRequest;\n            return c.open(\"GET\", s, !1), c.responseType = \"arraybuffer\", c.send(null), new Uint8Array(c.response);\n        }), v = (s, c, f)=>{\n            var b = new XMLHttpRequest;\n            b.open(\"GET\", s, !0), b.responseType = \"arraybuffer\", b.onload = ()=>{\n                b.status == 200 || b.status == 0 && b.response ? c(b.response) : f();\n            }, b.onerror = f, b.send(null);\n        });\n        var D, R = console.log.bind(console), G = console.error.bind(console), K = R, j = G;\n        if (Object.assign(u, T), T = null, g) {\n            let s = function(c) {\n                try {\n                    var f = c.data, b = f.cmd;\n                    if (b === \"load\") {\n                        let w = [];\n                        self.onmessage = (I)=>w.push(I), self.startWorker = ()=>{\n                            postMessage({\n                                cmd: \"loaded\"\n                            });\n                            for (let I of w)s(I);\n                            self.onmessage = s;\n                        };\n                        for (let I of f.handlers)u[I] && !u[I].proxy || (u[I] = (...O)=>{\n                            postMessage({\n                                Nb: \"callHandler\",\n                                pc: I,\n                                args: O\n                            });\n                        }, I == \"print\" && (K = u[I]), I == \"printErr\" && (j = u[I]));\n                        se = f.wasmMemory, ye(), V(f.wasmModule);\n                    } else if (b === \"run\") {\n                        Dn(f.pthread_ptr, 0, 0, 1, 0, 0), An(f.pthread_ptr), xc(), Ho(), Q || (Wi(), Q = !0);\n                        try {\n                            Sc(f.start_routine, f.arg);\n                        } catch (w) {\n                            if (w != \"unwind\") throw w;\n                        }\n                    } else b === \"cancel\" ? Mt() && hr(-1) : f.target !== \"setimmediate\" && (b === \"checkMailbox\" ? Q && ir() : b && (j(`worker: received unknown command ${b}`), j(f)));\n                } catch (w) {\n                    throw Li(), w;\n                }\n            };\n            var wg = s, V, Q = !1;\n            j = function(...c) {\n                c = c.join(\" \"), console.error(c);\n            }, self.alert = function(...c) {\n                postMessage({\n                    Nb: \"alert\",\n                    text: c.join(\" \"),\n                    rc: Mt()\n                });\n            }, u.instantiateWasm = (c, f)=>new Promise((b)=>{\n                    V = (w)=>{\n                        w = new WebAssembly.Instance(w, No()), f(w), b();\n                    };\n                }), self.onunhandledrejection = (c)=>{\n                throw c.reason || c;\n            }, self.onmessage = s;\n        }\n        u.wasmBinary && (D = u.wasmBinary);\n        var se, Y, ee, J, ne, be, Oe, $e, le, W, q, he, Ge, we = !1;\n        function ye() {\n            var s = se.buffer;\n            u.HEAP8 = J = new Int8Array(s), u.HEAP16 = be = new Int16Array(s), u.HEAPU8 = ne = new Uint8Array(s), u.HEAPU16 = Oe = new Uint16Array(s), u.HEAP32 = $e = new Int32Array(s), u.HEAPU32 = le = new Uint32Array(s), u.HEAPF32 = W = new Float32Array(s), u.HEAPF64 = Ge = new Float64Array(s), u.HEAP64 = q = new BigInt64Array(s), u.HEAPU64 = he = new BigUint64Array(s);\n        }\n        if (!g) {\n            if (!((se = new WebAssembly.Memory({\n                initial: 256,\n                maximum: 65536,\n                shared: !0\n            })).buffer instanceof x)) throw j(\"requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag\"), Error(\"bad memory\");\n            ye();\n        }\n        var Ye = [], Lt = [], fn = [], Gt = 0, hn = null, Ht = null;\n        function Do() {\n            if (--Gt == 0 && (hn !== null && (clearInterval(hn), hn = null), Ht)) {\n                var s = Ht;\n                Ht = null, s();\n            }\n        }\n        function ct(s) {\n            throw j(s = \"Aborted(\" + s + \")\"), we = !0, ee = 1, s = new WebAssembly.RuntimeError(s + \". Build with -sASSERTIONS for more info.\"), m(s), s;\n        }\n        var gn, Bo = (s)=>s.startsWith(\"data:application/octet-stream;base64,\"), Mo = (s)=>s.startsWith(\"file://\");\n        function Ro(s) {\n            if (s == gn && D) return new Uint8Array(D);\n            if (S) return S(s);\n            throw \"both async and sync fetching of the wasm failed\";\n        }\n        function Uo(s, c, f) {\n            return (function(b) {\n                if (!D && (_ || y)) {\n                    if (typeof fetch == \"function\" && !Mo(b)) return fetch(b, {\n                        credentials: \"same-origin\"\n                    }).then((w)=>{\n                        if (!w.ok) throw `failed to load wasm binary file at '${b}'`;\n                        return w.arrayBuffer();\n                    }).catch(()=>Ro(b));\n                    if (v) return new Promise((w, I)=>{\n                        v(b, (O)=>w(new Uint8Array(O)), I);\n                    });\n                }\n                return Promise.resolve().then(()=>Ro(b));\n            })(s).then((b)=>WebAssembly.instantiate(b, c)).then(f, (b)=>{\n                j(`failed to asynchronously prepare wasm: ${b}`), ct(b);\n            });\n        }\n        function No() {\n            return {\n                a: {\n                    O: $c,\n                    Aa: vc,\n                    b: Ic,\n                    aa: jo,\n                    B: Qo,\n                    qa: Xo,\n                    Y: ei,\n                    _: ti,\n                    ra: ri,\n                    oa: ni,\n                    ha: oi,\n                    na: ii,\n                    L: ai,\n                    Z: si,\n                    W: ui,\n                    pa: di,\n                    X: li,\n                    va: Cc,\n                    F: kc,\n                    Q: Ec,\n                    P: zc,\n                    E: Dc,\n                    u: Bc,\n                    q: Mc,\n                    G: Rc,\n                    A: Hc,\n                    R: Fc,\n                    ua: qc,\n                    ka: Kc,\n                    U: jc,\n                    ba: Yc,\n                    H: Zc,\n                    ja: An,\n                    ta: Qc,\n                    t: Xc,\n                    Ba: Jc,\n                    x: rp,\n                    n: np,\n                    l: ip,\n                    c: In,\n                    o: ap,\n                    j: dp,\n                    w: lp,\n                    p: cp,\n                    f: pp,\n                    s: mp,\n                    m: fp,\n                    e: hp,\n                    k: gp,\n                    i: bp,\n                    h: yp,\n                    d: _p,\n                    ea: wp,\n                    fa: vp,\n                    ga: $p,\n                    ca: Si,\n                    da: Ti,\n                    T: xp,\n                    g: Sp,\n                    D: Tp,\n                    I: Ip,\n                    M: Cp,\n                    y: Ap,\n                    sa: kp,\n                    V: Ep,\n                    v: Ci,\n                    z: Pp,\n                    N: zp,\n                    S: Op,\n                    za: Dp,\n                    ya: Bp,\n                    la: Ei,\n                    ma: Pi,\n                    $: vn,\n                    C: zi,\n                    K: Oi,\n                    ia: Di,\n                    J: Bi,\n                    a: se,\n                    xa: wn,\n                    wa: Ui,\n                    r: Up\n                }\n            };\n        }\n        var bn = {\n            913700: (s, c, f, b, w)=>{\n                if (u === void 0 || !u.Fb) return 1;\n                if ((s = Ce(Number(s >>> 0))).startsWith(\"./\") && (s = s.substring(2)), !(s = u.Fb.get(s))) return 2;\n                if (c = Number(c >>> 0), f = Number(f >>> 0), b = Number(b >>> 0), c + f > s.byteLength) return 3;\n                try {\n                    let I = s.subarray(c, c + f);\n                    switch(w){\n                        case 0:\n                            r().set(I, b >>> 0);\n                            break;\n                        case 1:\n                            u.dc(b, I);\n                            break;\n                        default:\n                            return 4;\n                    }\n                    return 0;\n                } catch  {\n                    return 4;\n                }\n            },\n            914415: (s, c, f)=>{\n                u.ec(s, r().subarray(c >>> 0, c + f >>> 0));\n            },\n            914478: ()=>u.bc(),\n            914519: (s)=>{\n                u.Pb(s);\n            },\n            914555: ()=>{\n                u.Wb();\n            },\n            914586: ()=>{\n                u.Xb();\n            },\n            914615: ()=>{\n                u.ac();\n            },\n            914640: (s)=>u.Vb(s),\n            914673: (s)=>u.Zb(s),\n            914705: (s, c, f)=>{\n                u.Ob(Number(s), Number(c), Number(f), !0);\n            },\n            914768: (s, c, f)=>{\n                u.Ob(Number(s), Number(c), Number(f));\n            },\n            914825: ()=>typeof wasmOffsetConverter < \"u\",\n            914882: (s)=>{\n                u.kb(\"Abs\", s, void 0);\n            },\n            914933: (s)=>{\n                u.kb(\"Neg\", s, void 0);\n            },\n            914984: (s)=>{\n                u.kb(\"Floor\", s, void 0);\n            },\n            915037: (s)=>{\n                u.kb(\"Ceil\", s, void 0);\n            },\n            915089: (s)=>{\n                u.kb(\"Reciprocal\", s, void 0);\n            },\n            915147: (s)=>{\n                u.kb(\"Sqrt\", s, void 0);\n            },\n            915199: (s)=>{\n                u.kb(\"Exp\", s, void 0);\n            },\n            915250: (s)=>{\n                u.kb(\"Erf\", s, void 0);\n            },\n            915301: (s)=>{\n                u.kb(\"Sigmoid\", s, void 0);\n            },\n            915356: (s, c, f)=>{\n                u.kb(\"HardSigmoid\", s, {\n                    alpha: c,\n                    beta: f\n                });\n            },\n            915435: (s)=>{\n                u.kb(\"Log\", s, void 0);\n            },\n            915486: (s)=>{\n                u.kb(\"Sin\", s, void 0);\n            },\n            915537: (s)=>{\n                u.kb(\"Cos\", s, void 0);\n            },\n            915588: (s)=>{\n                u.kb(\"Tan\", s, void 0);\n            },\n            915639: (s)=>{\n                u.kb(\"Asin\", s, void 0);\n            },\n            915691: (s)=>{\n                u.kb(\"Acos\", s, void 0);\n            },\n            915743: (s)=>{\n                u.kb(\"Atan\", s, void 0);\n            },\n            915795: (s)=>{\n                u.kb(\"Sinh\", s, void 0);\n            },\n            915847: (s)=>{\n                u.kb(\"Cosh\", s, void 0);\n            },\n            915899: (s)=>{\n                u.kb(\"Asinh\", s, void 0);\n            },\n            915952: (s)=>{\n                u.kb(\"Acosh\", s, void 0);\n            },\n            916005: (s)=>{\n                u.kb(\"Atanh\", s, void 0);\n            },\n            916058: (s)=>{\n                u.kb(\"Tanh\", s, void 0);\n            },\n            916110: (s)=>{\n                u.kb(\"Not\", s, void 0);\n            },\n            916161: (s, c, f)=>{\n                u.kb(\"Clip\", s, {\n                    min: c,\n                    max: f\n                });\n            },\n            916230: (s)=>{\n                u.kb(\"Clip\", s, void 0);\n            },\n            916282: (s, c)=>{\n                u.kb(\"Elu\", s, {\n                    alpha: c\n                });\n            },\n            916340: (s)=>{\n                u.kb(\"Gelu\", s, void 0);\n            },\n            916392: (s)=>{\n                u.kb(\"Relu\", s, void 0);\n            },\n            916444: (s, c)=>{\n                u.kb(\"LeakyRelu\", s, {\n                    alpha: c\n                });\n            },\n            916508: (s, c)=>{\n                u.kb(\"ThresholdedRelu\", s, {\n                    alpha: c\n                });\n            },\n            916578: (s, c)=>{\n                u.kb(\"Cast\", s, {\n                    to: c\n                });\n            },\n            916636: (s)=>{\n                u.kb(\"Add\", s, void 0);\n            },\n            916687: (s)=>{\n                u.kb(\"Sub\", s, void 0);\n            },\n            916738: (s)=>{\n                u.kb(\"Mul\", s, void 0);\n            },\n            916789: (s)=>{\n                u.kb(\"Div\", s, void 0);\n            },\n            916840: (s)=>{\n                u.kb(\"Pow\", s, void 0);\n            },\n            916891: (s)=>{\n                u.kb(\"Equal\", s, void 0);\n            },\n            916944: (s)=>{\n                u.kb(\"Greater\", s, void 0);\n            },\n            916999: (s)=>{\n                u.kb(\"GreaterOrEqual\", s, void 0);\n            },\n            917061: (s)=>{\n                u.kb(\"Less\", s, void 0);\n            },\n            917113: (s)=>{\n                u.kb(\"LessOrEqual\", s, void 0);\n            },\n            917172: (s, c, f, b, w)=>{\n                u.kb(\"ReduceMean\", s, {\n                    keepDims: !!c,\n                    noopWithEmptyAxes: !!f,\n                    axes: b ? Array.from(i().subarray(Number(b) >>> 0, Number(w) >>> 0)) : []\n                });\n            },\n            917347: (s, c, f, b, w)=>{\n                u.kb(\"ReduceMax\", s, {\n                    keepDims: !!c,\n                    noopWithEmptyAxes: !!f,\n                    axes: b ? Array.from(i().subarray(Number(b) >>> 0, Number(w) >>> 0)) : []\n                });\n            },\n            917521: (s, c, f, b, w)=>{\n                u.kb(\"ReduceMin\", s, {\n                    keepDims: !!c,\n                    noopWithEmptyAxes: !!f,\n                    axes: b ? Array.from(i().subarray(Number(b) >>> 0, Number(w) >>> 0)) : []\n                });\n            },\n            917695: (s, c, f, b, w)=>{\n                u.kb(\"ReduceProd\", s, {\n                    keepDims: !!c,\n                    noopWithEmptyAxes: !!f,\n                    axes: b ? Array.from(i().subarray(Number(b) >>> 0, Number(w) >>> 0)) : []\n                });\n            },\n            917870: (s, c, f, b, w)=>{\n                u.kb(\"ReduceSum\", s, {\n                    keepDims: !!c,\n                    noopWithEmptyAxes: !!f,\n                    axes: b ? Array.from(i().subarray(Number(b) >>> 0, Number(w) >>> 0)) : []\n                });\n            },\n            918044: (s, c, f, b, w)=>{\n                u.kb(\"ReduceL1\", s, {\n                    keepDims: !!c,\n                    noopWithEmptyAxes: !!f,\n                    axes: b ? Array.from(i().subarray(Number(b) >>> 0, Number(w) >>> 0)) : []\n                });\n            },\n            918217: (s, c, f, b, w)=>{\n                u.kb(\"ReduceL2\", s, {\n                    keepDims: !!c,\n                    noopWithEmptyAxes: !!f,\n                    axes: b ? Array.from(i().subarray(Number(b) >>> 0, Number(w) >>> 0)) : []\n                });\n            },\n            918390: (s, c, f, b, w)=>{\n                u.kb(\"ReduceLogSum\", s, {\n                    keepDims: !!c,\n                    noopWithEmptyAxes: !!f,\n                    axes: b ? Array.from(i().subarray(Number(b) >>> 0, Number(w) >>> 0)) : []\n                });\n            },\n            918567: (s, c, f, b, w)=>{\n                u.kb(\"ReduceSumSquare\", s, {\n                    keepDims: !!c,\n                    noopWithEmptyAxes: !!f,\n                    axes: b ? Array.from(i().subarray(Number(b) >>> 0, Number(w) >>> 0)) : []\n                });\n            },\n            918747: (s, c, f, b, w)=>{\n                u.kb(\"ReduceLogSumExp\", s, {\n                    keepDims: !!c,\n                    noopWithEmptyAxes: !!f,\n                    axes: b ? Array.from(i().subarray(Number(b) >>> 0, Number(w) >>> 0)) : []\n                });\n            },\n            918927: (s)=>{\n                u.kb(\"Where\", s, void 0);\n            },\n            918980: (s, c, f)=>{\n                u.kb(\"Transpose\", s, {\n                    perm: c ? Array.from(i().subarray(Number(c) >>> 0, Number(f) >>> 0)) : []\n                });\n            },\n            919104: (s, c, f, b)=>{\n                u.kb(\"DepthToSpace\", s, {\n                    blocksize: c,\n                    mode: Ce(f),\n                    format: b ? \"NHWC\" : \"NCHW\"\n                });\n            },\n            919237: (s, c, f, b)=>{\n                u.kb(\"DepthToSpace\", s, {\n                    blocksize: c,\n                    mode: Ce(f),\n                    format: b ? \"NHWC\" : \"NCHW\"\n                });\n            },\n            919370: (s, c, f, b, w, I, O, B, L, H, X, ce, ge, z, de)=>{\n                u.kb(\"ConvTranspose\", s, {\n                    format: L ? \"NHWC\" : \"NCHW\",\n                    autoPad: c,\n                    dilations: [\n                        f\n                    ],\n                    group: b,\n                    kernelShape: [\n                        w\n                    ],\n                    pads: [\n                        I,\n                        O\n                    ],\n                    strides: [\n                        B\n                    ],\n                    wIsConst: ()=>!!t()[H >>> 0],\n                    outputPadding: X ? Array.from(i().subarray(Number(X) >>> 0, Number(ce) >>> 0)) : [],\n                    outputShape: ge ? Array.from(i().subarray(Number(ge) >>> 0, Number(z) >>> 0)) : [],\n                    activation: Ce(de)\n                });\n            },\n            919803: (s, c, f, b, w, I, O, B, L, H, X, ce, ge, z)=>{\n                u.kb(\"ConvTranspose\", s, {\n                    format: B ? \"NHWC\" : \"NCHW\",\n                    autoPad: c,\n                    dilations: Array.from(i().subarray(Number(f) >>> 0, 2 + (Number(f) >>> 0) >>> 0)),\n                    group: b,\n                    kernelShape: Array.from(i().subarray(Number(w) >>> 0, 2 + (Number(w) >>> 0) >>> 0)),\n                    pads: Array.from(i().subarray(Number(I) >>> 0, 4 + (Number(I) >>> 0) >>> 0)),\n                    strides: Array.from(i().subarray(Number(O) >>> 0, 2 + (Number(O) >>> 0) >>> 0)),\n                    wIsConst: ()=>!!t()[L >>> 0],\n                    outputPadding: H ? Array.from(i().subarray(Number(H) >>> 0, Number(X) >>> 0)) : [],\n                    outputShape: ce ? Array.from(i().subarray(Number(ce) >>> 0, Number(ge) >>> 0)) : [],\n                    activation: Ce(z)\n                });\n            },\n            920464: (s, c, f, b, w, I, O, B, L, H, X, ce, ge, z, de)=>{\n                u.kb(\"ConvTranspose\", s, {\n                    format: L ? \"NHWC\" : \"NCHW\",\n                    autoPad: c,\n                    dilations: [\n                        f\n                    ],\n                    group: b,\n                    kernelShape: [\n                        w\n                    ],\n                    pads: [\n                        I,\n                        O\n                    ],\n                    strides: [\n                        B\n                    ],\n                    wIsConst: ()=>!!t()[H >>> 0],\n                    outputPadding: X ? Array.from(i().subarray(Number(X) >>> 0, Number(ce) >>> 0)) : [],\n                    outputShape: ge ? Array.from(i().subarray(Number(ge) >>> 0, Number(z) >>> 0)) : [],\n                    activation: Ce(de)\n                });\n            },\n            920897: (s, c, f, b, w, I, O, B, L, H, X, ce, ge, z)=>{\n                u.kb(\"ConvTranspose\", s, {\n                    format: B ? \"NHWC\" : \"NCHW\",\n                    autoPad: c,\n                    dilations: Array.from(i().subarray(Number(f) >>> 0, 2 + (Number(f) >>> 0) >>> 0)),\n                    group: b,\n                    kernelShape: Array.from(i().subarray(Number(w) >>> 0, 2 + (Number(w) >>> 0) >>> 0)),\n                    pads: Array.from(i().subarray(Number(I) >>> 0, 4 + (Number(I) >>> 0) >>> 0)),\n                    strides: Array.from(i().subarray(Number(O) >>> 0, 2 + (Number(O) >>> 0) >>> 0)),\n                    wIsConst: ()=>!!t()[L >>> 0],\n                    outputPadding: H ? Array.from(i().subarray(Number(H) >>> 0, Number(X) >>> 0)) : [],\n                    outputShape: ce ? Array.from(i().subarray(Number(ce) >>> 0, Number(ge) >>> 0)) : [],\n                    activation: Ce(z)\n                });\n            },\n            921558: (s, c)=>{\n                u.kb(\"GlobalAveragePool\", s, {\n                    format: c ? \"NHWC\" : \"NCHW\"\n                });\n            },\n            921649: (s, c, f, b, w, I, O, B, L, H, X, ce, ge, z)=>{\n                u.kb(\"AveragePool\", s, {\n                    format: z ? \"NHWC\" : \"NCHW\",\n                    auto_pad: c,\n                    ceil_mode: f,\n                    count_include_pad: b,\n                    storage_order: w,\n                    dilations: I ? Array.from(i().subarray(Number(I) >>> 0, Number(O) >>> 0)) : [],\n                    kernel_shape: B ? Array.from(i().subarray(Number(B) >>> 0, Number(L) >>> 0)) : [],\n                    pads: H ? Array.from(i().subarray(Number(H) >>> 0, Number(X) >>> 0)) : [],\n                    strides: ce ? Array.from(i().subarray(Number(ce) >>> 0, Number(ge) >>> 0)) : []\n                });\n            },\n            922128: (s, c)=>{\n                u.kb(\"GlobalAveragePool\", s, {\n                    format: c ? \"NHWC\" : \"NCHW\"\n                });\n            },\n            922219: (s, c, f, b, w, I, O, B, L, H, X, ce, ge, z)=>{\n                u.kb(\"AveragePool\", s, {\n                    format: z ? \"NHWC\" : \"NCHW\",\n                    auto_pad: c,\n                    ceil_mode: f,\n                    count_include_pad: b,\n                    storage_order: w,\n                    dilations: I ? Array.from(i().subarray(Number(I) >>> 0, Number(O) >>> 0)) : [],\n                    kernel_shape: B ? Array.from(i().subarray(Number(B) >>> 0, Number(L) >>> 0)) : [],\n                    pads: H ? Array.from(i().subarray(Number(H) >>> 0, Number(X) >>> 0)) : [],\n                    strides: ce ? Array.from(i().subarray(Number(ce) >>> 0, Number(ge) >>> 0)) : []\n                });\n            },\n            922698: (s, c)=>{\n                u.kb(\"GlobalMaxPool\", s, {\n                    format: c ? \"NHWC\" : \"NCHW\"\n                });\n            },\n            922785: (s, c, f, b, w, I, O, B, L, H, X, ce, ge, z)=>{\n                u.kb(\"MaxPool\", s, {\n                    format: z ? \"NHWC\" : \"NCHW\",\n                    auto_pad: c,\n                    ceil_mode: f,\n                    count_include_pad: b,\n                    storage_order: w,\n                    dilations: I ? Array.from(i().subarray(Number(I) >>> 0, Number(O) >>> 0)) : [],\n                    kernel_shape: B ? Array.from(i().subarray(Number(B) >>> 0, Number(L) >>> 0)) : [],\n                    pads: H ? Array.from(i().subarray(Number(H) >>> 0, Number(X) >>> 0)) : [],\n                    strides: ce ? Array.from(i().subarray(Number(ce) >>> 0, Number(ge) >>> 0)) : []\n                });\n            },\n            923260: (s, c)=>{\n                u.kb(\"GlobalMaxPool\", s, {\n                    format: c ? \"NHWC\" : \"NCHW\"\n                });\n            },\n            923347: (s, c, f, b, w, I, O, B, L, H, X, ce, ge, z)=>{\n                u.kb(\"MaxPool\", s, {\n                    format: z ? \"NHWC\" : \"NCHW\",\n                    auto_pad: c,\n                    ceil_mode: f,\n                    count_include_pad: b,\n                    storage_order: w,\n                    dilations: I ? Array.from(i().subarray(Number(I) >>> 0, Number(O) >>> 0)) : [],\n                    kernel_shape: B ? Array.from(i().subarray(Number(B) >>> 0, Number(L) >>> 0)) : [],\n                    pads: H ? Array.from(i().subarray(Number(H) >>> 0, Number(X) >>> 0)) : [],\n                    strides: ce ? Array.from(i().subarray(Number(ce) >>> 0, Number(ge) >>> 0)) : []\n                });\n            },\n            923822: (s, c, f, b, w)=>{\n                u.kb(\"Gemm\", s, {\n                    alpha: c,\n                    beta: f,\n                    transA: b,\n                    transB: w\n                });\n            },\n            923926: (s)=>{\n                u.kb(\"MatMul\", s, void 0);\n            },\n            923980: (s, c, f, b)=>{\n                u.kb(\"ArgMax\", s, {\n                    keepDims: !!c,\n                    selectLastIndex: !!f,\n                    axis: b\n                });\n            },\n            924088: (s, c, f, b)=>{\n                u.kb(\"ArgMin\", s, {\n                    keepDims: !!c,\n                    selectLastIndex: !!f,\n                    axis: b\n                });\n            },\n            924196: (s, c)=>{\n                u.kb(\"Softmax\", s, {\n                    axis: c\n                });\n            },\n            924259: (s, c)=>{\n                u.kb(\"Concat\", s, {\n                    axis: c\n                });\n            },\n            924319: (s, c, f, b, w)=>{\n                u.kb(\"Split\", s, {\n                    axis: c,\n                    numOutputs: f,\n                    splitSizes: b ? Array.from(i().subarray(Number(b) >>> 0, Number(w) >>> 0)) : []\n                });\n            },\n            924475: (s)=>{\n                u.kb(\"Expand\", s, void 0);\n            },\n            924529: (s, c)=>{\n                u.kb(\"Gather\", s, {\n                    axis: Number(c)\n                });\n            },\n            924600: (s, c)=>{\n                u.kb(\"GatherElements\", s, {\n                    axis: Number(c)\n                });\n            },\n            924679: (s, c)=>{\n                u.kb(\"GatherND\", s, {\n                    batch_dims: Number(c)\n                });\n            },\n            924758: (s, c, f, b, w, I, O, B, L, H, X)=>{\n                u.kb(\"Resize\", s, {\n                    antialias: c,\n                    axes: f ? Array.from(i().subarray(Number(f) >>> 0, Number(b) >>> 0)) : [],\n                    coordinateTransformMode: Ce(w),\n                    cubicCoeffA: I,\n                    excludeOutside: O,\n                    extrapolationValue: B,\n                    keepAspectRatioPolicy: Ce(L),\n                    mode: Ce(H),\n                    nearestMode: Ce(X)\n                });\n            },\n            925120: (s, c, f, b, w, I, O)=>{\n                u.kb(\"Slice\", s, {\n                    starts: c ? Array.from(i().subarray(Number(c) >>> 0, Number(f) >>> 0)) : [],\n                    ends: b ? Array.from(i().subarray(Number(b) >>> 0, Number(w) >>> 0)) : [],\n                    axes: I ? Array.from(i().subarray(Number(I) >>> 0, Number(O) >>> 0)) : []\n                });\n            },\n            925384: (s)=>{\n                u.kb(\"Tile\", s, void 0);\n            },\n            925436: (s, c, f)=>{\n                u.kb(\"InstanceNormalization\", s, {\n                    epsilon: c,\n                    format: f ? \"NHWC\" : \"NCHW\"\n                });\n            },\n            925550: (s, c, f)=>{\n                u.kb(\"InstanceNormalization\", s, {\n                    epsilon: c,\n                    format: f ? \"NHWC\" : \"NCHW\"\n                });\n            },\n            925664: (s)=>{\n                u.kb(\"Range\", s, void 0);\n            },\n            925717: (s, c)=>{\n                u.kb(\"Einsum\", s, {\n                    equation: Ce(c)\n                });\n            },\n            925798: (s, c, f, b, w)=>{\n                u.kb(\"Pad\", s, {\n                    mode: c,\n                    value: f,\n                    pads: b ? Array.from(i().subarray(Number(b) >>> 0, Number(w) >>> 0)) : []\n                });\n            },\n            925941: (s, c, f, b, w, I)=>{\n                u.kb(\"BatchNormalization\", s, {\n                    epsilon: c,\n                    momentum: f,\n                    spatial: !!w,\n                    trainingMode: !!b,\n                    format: I ? \"NHWC\" : \"NCHW\"\n                });\n            },\n            926110: (s, c, f, b, w, I)=>{\n                u.kb(\"BatchNormalization\", s, {\n                    epsilon: c,\n                    momentum: f,\n                    spatial: !!w,\n                    trainingMode: !!b,\n                    format: I ? \"NHWC\" : \"NCHW\"\n                });\n            },\n            926279: (s, c, f)=>{\n                u.kb(\"CumSum\", s, {\n                    exclusive: Number(c),\n                    reverse: Number(f)\n                });\n            },\n            926376: (s, c, f)=>{\n                u.kb(\"DequantizeLinear\", s, {\n                    axis: c,\n                    blockSize: f\n                });\n            },\n            926466: (s, c, f, b, w)=>{\n                u.kb(\"GridSample\", s, {\n                    align_corners: c,\n                    mode: Ce(f),\n                    padding_mode: Ce(b),\n                    format: w ? \"NHWC\" : \"NCHW\"\n                });\n            },\n            926636: (s, c, f, b, w)=>{\n                u.kb(\"GridSample\", s, {\n                    align_corners: c,\n                    mode: Ce(f),\n                    padding_mode: Ce(b),\n                    format: w ? \"NHWC\" : \"NCHW\"\n                });\n            },\n            926806: (s, c, f, b, w, I, O, B, L)=>{\n                u.kb(\"Attention\", s, {\n                    numHeads: c,\n                    isUnidirectional: f,\n                    maskFilterValue: b,\n                    scale: w,\n                    doRotary: I,\n                    qkvHiddenSizes: O ? Array.from(i().subarray(Number(B) >>> 0, Number(B) + O >>> 0)) : [],\n                    pastPresentShareBuffer: !!L\n                });\n            },\n            927078: (s)=>{\n                u.kb(\"BiasAdd\", s, void 0);\n            },\n            927133: (s)=>{\n                u.kb(\"BiasSplitGelu\", s, void 0);\n            },\n            927194: (s)=>{\n                u.kb(\"FastGelu\", s, void 0);\n            },\n            927250: (s, c, f, b, w, I, O, B, L, H, X, ce, ge, z, de, Te)=>{\n                u.kb(\"Conv\", s, {\n                    format: ce ? \"NHWC\" : \"NCHW\",\n                    auto_pad: c,\n                    dilations: f ? Array.from(i().subarray(Number(f) >>> 0, Number(b) >>> 0)) : [],\n                    group: w,\n                    kernel_shape: I ? Array.from(i().subarray(Number(I) >>> 0, Number(O) >>> 0)) : [],\n                    pads: B ? Array.from(i().subarray(Number(B) >>> 0, Number(L) >>> 0)) : [],\n                    strides: H ? Array.from(i().subarray(Number(H) >>> 0, Number(X) >>> 0)) : [],\n                    w_is_const: ()=>!!t()[Number(ge) >>> 0],\n                    activation: Ce(z),\n                    activation_params: de ? Array.from(d().subarray(Number(de) >>> 0, Number(Te) >>> 0)) : []\n                });\n            },\n            927834: (s)=>{\n                u.kb(\"Gelu\", s, void 0);\n            },\n            927886: (s, c, f, b, w, I, O, B, L)=>{\n                u.kb(\"GroupQueryAttention\", s, {\n                    numHeads: c,\n                    kvNumHeads: f,\n                    scale: b,\n                    softcap: w,\n                    doRotary: I,\n                    rotaryInterleaved: O,\n                    smoothSoftmax: B,\n                    localWindowSize: L\n                });\n            },\n            928103: (s, c, f, b)=>{\n                u.kb(\"LayerNormalization\", s, {\n                    axis: c,\n                    epsilon: f,\n                    simplified: !!b\n                });\n            },\n            928214: (s, c, f, b)=>{\n                u.kb(\"LayerNormalization\", s, {\n                    axis: c,\n                    epsilon: f,\n                    simplified: !!b\n                });\n            },\n            928325: (s, c, f, b, w, I)=>{\n                u.kb(\"MatMulNBits\", s, {\n                    k: c,\n                    n: f,\n                    accuracyLevel: b,\n                    bits: w,\n                    blockSize: I\n                });\n            },\n            928452: (s, c, f, b, w, I)=>{\n                u.kb(\"MultiHeadAttention\", s, {\n                    numHeads: c,\n                    isUnidirectional: f,\n                    maskFilterValue: b,\n                    scale: w,\n                    doRotary: I\n                });\n            },\n            928611: (s, c)=>{\n                u.kb(\"QuickGelu\", s, {\n                    alpha: c\n                });\n            },\n            928675: (s, c, f, b, w)=>{\n                u.kb(\"RotaryEmbedding\", s, {\n                    interleaved: !!c,\n                    numHeads: f,\n                    rotaryEmbeddingDim: b,\n                    scale: w\n                });\n            },\n            928814: (s, c, f)=>{\n                u.kb(\"SkipLayerNormalization\", s, {\n                    epsilon: c,\n                    simplified: !!f\n                });\n            },\n            928916: (s, c, f)=>{\n                u.kb(\"SkipLayerNormalization\", s, {\n                    epsilon: c,\n                    simplified: !!f\n                });\n            },\n            929018: (s, c, f, b)=>{\n                u.kb(\"GatherBlockQuantized\", s, {\n                    gatherAxis: c,\n                    quantizeAxis: f,\n                    blockSize: b\n                });\n            },\n            929139: (s)=>{\n                u.$b(s);\n            },\n            929173: (s, c)=>u.cc(Number(s), Number(c), u.Gb.hc, u.Gb.errors)\n        };\n        function vc(s, c, f) {\n            return _i(async ()=>{\n                await u.Yb(Number(s), Number(c), Number(f));\n            });\n        }\n        function $c() {\n            return typeof wasmOffsetConverter < \"u\";\n        }\n        function yn(s) {\n            this.name = \"ExitStatus\", this.message = `Program terminated with exit(${s})`, this.status = s;\n        }\n        var _n = (s)=>{\n            s.terminate(), s.onmessage = ()=>{};\n        }, Vo = (s)=>{\n            pt.length == 0 && (qo(), Fo(pt[0]));\n            var c = pt.pop();\n            if (!c) return 6;\n            vt.push(c), Ze[s.Bb] = c, c.Bb = s.Bb;\n            var f = {\n                cmd: \"run\",\n                start_routine: s.ic,\n                arg: s.Rb,\n                pthread_ptr: s.Bb\n            };\n            return c.postMessage(f, s.nc), 0;\n        }, wt = 0, xe = (s, c, ...f)=>{\n            for(var b = 2 * f.length, w = Rn(), I = Mn(8 * b), O = I >>> 3, B = 0; B < f.length; B++){\n                var L = f[B];\n                typeof L == \"bigint\" ? (q[O + 2 * B] = 1n, q[O + 2 * B + 1] = L) : (q[O + 2 * B] = 0n, l()[O + 2 * B + 1 >>> 0] = L);\n            }\n            return s = Gi(s, 0, b, I, c), gr(w), s;\n        };\n        function wn(s) {\n            if (g) return xe(0, 1, s);\n            if (ee = s, !(0 < wt)) {\n                for (var c of vt)_n(c);\n                for (c of pt)_n(c);\n                pt = [], vt = [], Ze = [], we = !0;\n            }\n            k(s, new yn(s));\n        }\n        function Wo(s) {\n            if (g) return xe(1, 0, s);\n            vn(s);\n        }\n        var vn = (s)=>{\n            if (ee = s, g) throw Wo(s), \"unwind\";\n            wn(s);\n        }, pt = [], vt = [], Lo = [], Ze = {}, Go = (s)=>{\n            var c = s.Bb;\n            delete Ze[c], pt.push(s), vt.splice(vt.indexOf(s), 1), s.Bb = 0, Bn(c);\n        };\n        function Ho() {\n            Lo.forEach((s)=>s());\n        }\n        var Fo = (s)=>new Promise((c)=>{\n                s.onmessage = (w)=>{\n                    var I = (w = w.data).cmd;\n                    if (w.targetThread && w.targetThread != Mt()) {\n                        var O = Ze[w.targetThread];\n                        O ? O.postMessage(w, w.transferList) : j(`Internal error! Worker sent a message \"${I}\" to target pthread ${w.targetThread}, but that thread no longer exists!`);\n                    } else I === \"checkMailbox\" ? ir() : I === \"spawnThread\" ? Vo(w) : I === \"cleanupThread\" ? Go(Ze[w.thread]) : I === \"killThread\" ? (w = w.thread, I = Ze[w], delete Ze[w], _n(I), Bn(w), vt.splice(vt.indexOf(I), 1), I.Bb = 0) : I === \"cancelThread\" ? Ze[w.thread].postMessage({\n                        cmd: \"cancel\"\n                    }) : I === \"loaded\" ? (s.loaded = !0, c(s)) : I === \"alert\" ? alert(`Thread ${w.threadId}: ${w.text}`) : w.target === \"setimmediate\" ? s.postMessage(w) : I === \"callHandler\" ? u[w.handler](...w.args) : I && j(`worker sent an unknown command ${I}`);\n                }, s.onerror = (w)=>{\n                    throw j(`worker sent an error! ${w.filename}:${w.lineno}: ${w.message}`), w;\n                };\n                var f, b = [];\n                for (f of [])u.hasOwnProperty(f) && b.push(f);\n                s.postMessage({\n                    cmd: \"load\",\n                    handlers: b,\n                    wasmMemory: se,\n                    wasmModule: Y\n                });\n            });\n        function qo() {\n            var s = new Worker(\"file:///Users/amityadav/Desktop/Text-Behind%20Image/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs\".startsWith(\"file:\") ? /* asset import */ new __webpack_require__.U(__webpack_require__(/*! ort.webgpu.bundle.min.mjs */ \"(ssr)/./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs?5952\")) : new URL(\"file:///Users/amityadav/Desktop/Text-Behind%20Image/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs\"), {\n                type: \"module\",\n                workerData: \"em-pthread\",\n                name: \"em-pthread\"\n            });\n            pt.push(s);\n        }\n        var or = (s)=>{\n            for(; 0 < s.length;)s.shift()(u);\n        }, xc = ()=>{\n            var s = Mt(), c = a()[s + 52 >>> 2 >>> 0];\n            s = a()[s + 56 >>> 2 >>> 0], Fi(c, c - s), gr(c);\n        }, Sc = (s, c)=>{\n            wt = 0, s = qi(s, c), 0 < wt ? ee = s : hr(s);\n        };\n        class Tc {\n            constructor(c){\n                this.Kb = c - 24;\n            }\n        }\n        function Ic(s, c, f) {\n            var b = new Tc(s >>>= 0);\n            throw c >>>= 0, f >>>= 0, a()[b.Kb + 16 >>> 2 >>> 0] = 0, a()[b.Kb + 4 >>> 2 >>> 0] = c, a()[b.Kb + 8 >>> 2 >>> 0] = f, s;\n        }\n        function Ko(s, c, f, b) {\n            return g ? xe(2, 1, s, c, f, b) : jo(s, c, f, b);\n        }\n        function jo(s, c, f, b) {\n            if (s >>>= 0, c >>>= 0, f >>>= 0, b >>>= 0, x === void 0) return j(\"Current environment does not support SharedArrayBuffer, pthreads are not available!\"), 6;\n            var w = [];\n            return g && w.length === 0 ? Ko(s, c, f, b) : (s = {\n                ic: f,\n                Bb: s,\n                Rb: b,\n                nc: w\n            }, g ? (s.Nb = \"spawnThread\", postMessage(s, w), 0) : Vo(s));\n        }\n        var Yo = typeof TextDecoder < \"u\" ? new TextDecoder(\"utf8\") : void 0, Zo = (s, c, f)=>{\n            var b = (c >>>= 0) + f;\n            for(f = c; s[f] && !(f >= b);)++f;\n            if (16 < f - c && s.buffer && Yo) return Yo.decode(s.buffer instanceof x ? s.slice(c, f) : s.subarray(c, f));\n            for(b = \"\"; c < f;){\n                var w = s[c++];\n                if (128 & w) {\n                    var I = 63 & s[c++];\n                    if ((224 & w) == 192) b += String.fromCharCode((31 & w) << 6 | I);\n                    else {\n                        var O = 63 & s[c++];\n                        65536 > (w = (240 & w) == 224 ? (15 & w) << 12 | I << 6 | O : (7 & w) << 18 | I << 12 | O << 6 | 63 & s[c++]) ? b += String.fromCharCode(w) : (w -= 65536, b += String.fromCharCode(55296 | w >> 10, 56320 | 1023 & w));\n                    }\n                } else b += String.fromCharCode(w);\n            }\n            return b;\n        }, Ce = (s, c)=>(s >>>= 0) ? Zo(r(), s, c) : \"\";\n        function Qo(s, c, f) {\n            return g ? xe(3, 1, s, c, f) : 0;\n        }\n        function Xo(s, c) {\n            if (g) return xe(4, 1, s, c);\n        }\n        var $n = (s)=>{\n            for(var c = 0, f = 0; f < s.length; ++f){\n                var b = s.charCodeAt(f);\n                127 >= b ? c++ : 2047 >= b ? c += 2 : 55296 <= b && 57343 >= b ? (c += 4, ++f) : c += 3;\n            }\n            return c;\n        }, Jo = (s, c, f, b)=>{\n            if (!(0 < b)) return 0;\n            var w = f >>>= 0;\n            b = f + b - 1;\n            for(var I = 0; I < s.length; ++I){\n                var O = s.charCodeAt(I);\n                if (55296 <= O && 57343 >= O && (O = 65536 + ((1023 & O) << 10) | 1023 & s.charCodeAt(++I)), 127 >= O) {\n                    if (f >= b) break;\n                    c[f++ >>> 0] = O;\n                } else {\n                    if (2047 >= O) {\n                        if (f + 1 >= b) break;\n                        c[f++ >>> 0] = 192 | O >> 6;\n                    } else {\n                        if (65535 >= O) {\n                            if (f + 2 >= b) break;\n                            c[f++ >>> 0] = 224 | O >> 12;\n                        } else {\n                            if (f + 3 >= b) break;\n                            c[f++ >>> 0] = 240 | O >> 18, c[f++ >>> 0] = 128 | O >> 12 & 63;\n                        }\n                        c[f++ >>> 0] = 128 | O >> 6 & 63;\n                    }\n                    c[f++ >>> 0] = 128 | 63 & O;\n                }\n            }\n            return c[f >>> 0] = 0, f - w;\n        }, Ot = (s, c, f)=>Jo(s, r(), c, f);\n        function ei(s, c) {\n            if (g) return xe(5, 1, s, c);\n        }\n        function ti(s, c, f) {\n            if (g) return xe(6, 1, s, c, f);\n        }\n        function ri(s, c, f) {\n            return g ? xe(7, 1, s, c, f) : 0;\n        }\n        function ni(s, c) {\n            if (g) return xe(8, 1, s, c);\n        }\n        function oi(s, c, f) {\n            if (g) return xe(9, 1, s, c, f);\n        }\n        function ii(s, c, f, b) {\n            if (g) return xe(10, 1, s, c, f, b);\n        }\n        function ai(s, c, f, b) {\n            if (g) return xe(11, 1, s, c, f, b);\n        }\n        function si(s, c, f, b) {\n            if (g) return xe(12, 1, s, c, f, b);\n        }\n        function ui(s) {\n            if (g) return xe(13, 1, s);\n        }\n        function di(s, c) {\n            if (g) return xe(14, 1, s, c);\n        }\n        function li(s, c, f) {\n            if (g) return xe(15, 1, s, c, f);\n        }\n        var ci, mt, Cc = ()=>{\n            ct(\"\");\n        }, Qe = (s)=>{\n            for(var c = \"\"; r()[s >>> 0];)c += ci[r()[s++ >>> 0]];\n            return c;\n        }, xn = {}, Sn = {}, Ac = {};\n        function st(s, c, f = {}) {\n            if (!(\"argPackAdvance\" in c)) throw new TypeError(\"registerType registeredInstance requires argPackAdvance\");\n            return function(b, w, I = {}) {\n                var O = w.name;\n                if (!b) throw new mt(`type \"${O}\" must have a positive integer typeid pointer`);\n                if (Sn.hasOwnProperty(b)) {\n                    if (I.Tb) return;\n                    throw new mt(`Cannot register type '${O}' twice`);\n                }\n                Sn[b] = w, delete Ac[b], xn.hasOwnProperty(b) && (w = xn[b], delete xn[b], w.forEach((B)=>B()));\n            }(s, c, f);\n        }\n        var pi = (s, c, f)=>{\n            switch(c){\n                case 1:\n                    return f ? (b)=>t()[b >>> 0] : (b)=>r()[b >>> 0];\n                case 2:\n                    return f ? (b)=>n()[b >>> 1 >>> 0] : (b)=>o()[b >>> 1 >>> 0];\n                case 4:\n                    return f ? (b)=>i()[b >>> 2 >>> 0] : (b)=>a()[b >>> 2 >>> 0];\n                case 8:\n                    return f ? (b)=>q[b >>> 3] : (b)=>he[b >>> 3];\n                default:\n                    throw new TypeError(`invalid integer width (${c}): ${s}`);\n            }\n        };\n        function kc(s, c, f) {\n            f >>>= 0, st(s >>>= 0, {\n                name: c = Qe(c >>> 0),\n                fromWireType: (b)=>b,\n                toWireType: function(b, w) {\n                    if (typeof w != \"bigint\" && typeof w != \"number\") throw w = w === null ? \"null\" : (b = typeof w) == \"object\" || b === \"array\" || b === \"function\" ? w.toString() : \"\" + w, new TypeError(`Cannot convert \"${w}\" to ${this.name}`);\n                    return typeof w == \"number\" && (w = BigInt(w)), w;\n                },\n                argPackAdvance: ft,\n                readValueFromPointer: pi(c, f, c.indexOf(\"u\") == -1),\n                Eb: null\n            });\n        }\n        var ft = 8;\n        function Ec(s, c, f, b) {\n            st(s >>>= 0, {\n                name: c = Qe(c >>> 0),\n                fromWireType: function(w) {\n                    return !!w;\n                },\n                toWireType: function(w, I) {\n                    return I ? f : b;\n                },\n                argPackAdvance: ft,\n                readValueFromPointer: function(w) {\n                    return this.fromWireType(r()[w >>> 0]);\n                },\n                Eb: null\n            });\n        }\n        var Tn = [], ut = [];\n        function In(s) {\n            9 < (s >>>= 0) && --ut[s + 1] == 0 && (ut[s] = void 0, Tn.push(s));\n        }\n        var Me = (s)=>{\n            if (!s) throw new mt(\"Cannot use deleted val. handle = \" + s);\n            return ut[s];\n        }, Ve = (s)=>{\n            switch(s){\n                case void 0:\n                    return 2;\n                case null:\n                    return 4;\n                case !0:\n                    return 6;\n                case !1:\n                    return 8;\n                default:\n                    let c = Tn.pop() || ut.length;\n                    return ut[c] = s, ut[c + 1] = 1, c;\n            }\n        };\n        function Cn(s) {\n            return this.fromWireType(a()[s >>> 2 >>> 0]);\n        }\n        var Pc = {\n            name: \"emscripten::val\",\n            fromWireType: (s)=>{\n                var c = Me(s);\n                return In(s), c;\n            },\n            toWireType: (s, c)=>Ve(c),\n            argPackAdvance: ft,\n            readValueFromPointer: Cn,\n            Eb: null\n        };\n        function zc(s) {\n            return st(s >>> 0, Pc);\n        }\n        var Oc = (s, c)=>{\n            switch(c){\n                case 4:\n                    return function(f) {\n                        return this.fromWireType(d()[f >>> 2 >>> 0]);\n                    };\n                case 8:\n                    return function(f) {\n                        return this.fromWireType(l()[f >>> 3 >>> 0]);\n                    };\n                default:\n                    throw new TypeError(`invalid float width (${c}): ${s}`);\n            }\n        };\n        function Dc(s, c, f) {\n            f >>>= 0, st(s >>>= 0, {\n                name: c = Qe(c >>> 0),\n                fromWireType: (b)=>b,\n                toWireType: (b, w)=>w,\n                argPackAdvance: ft,\n                readValueFromPointer: Oc(c, f),\n                Eb: null\n            });\n        }\n        function Bc(s, c, f, b, w) {\n            if (s >>>= 0, f >>>= 0, c = Qe(c >>> 0), w === -1 && (w = 4294967295), w = (B)=>B, b === 0) {\n                var I = 32 - 8 * f;\n                w = (B)=>B << I >>> I;\n            }\n            var O = c.includes(\"unsigned\") ? function(B, L) {\n                return L >>> 0;\n            } : function(B, L) {\n                return L;\n            };\n            st(s, {\n                name: c,\n                fromWireType: w,\n                toWireType: O,\n                argPackAdvance: ft,\n                readValueFromPointer: pi(c, f, b !== 0),\n                Eb: null\n            });\n        }\n        function Mc(s, c, f) {\n            function b(I) {\n                var O = a()[I >>> 2 >>> 0];\n                return I = a()[I + 4 >>> 2 >>> 0], new w(t().buffer, I, O);\n            }\n            var w = [\n                Int8Array,\n                Uint8Array,\n                Int16Array,\n                Uint16Array,\n                Int32Array,\n                Uint32Array,\n                Float32Array,\n                Float64Array,\n                BigInt64Array,\n                BigUint64Array\n            ][c];\n            st(s >>>= 0, {\n                name: f = Qe(f >>> 0),\n                fromWireType: b,\n                argPackAdvance: ft,\n                readValueFromPointer: b\n            }, {\n                Tb: !0\n            });\n        }\n        function Rc(s, c) {\n            s >>>= 0;\n            var f = (c = Qe(c >>> 0)) === \"std::string\";\n            st(s, {\n                name: c,\n                fromWireType: function(b) {\n                    var w = a()[b >>> 2 >>> 0], I = b + 4;\n                    if (f) for(var O = I, B = 0; B <= w; ++B){\n                        var L = I + B;\n                        if (B == w || r()[L >>> 0] == 0) {\n                            if (O = Ce(O, L - O), H === void 0) var H = O;\n                            else H += String.fromCharCode(0), H += O;\n                            O = L + 1;\n                        }\n                    }\n                    else {\n                        for(H = Array(w), B = 0; B < w; ++B)H[B] = String.fromCharCode(r()[I + B >>> 0]);\n                        H = H.join(\"\");\n                    }\n                    return Je(b), H;\n                },\n                toWireType: function(b, w) {\n                    w instanceof ArrayBuffer && (w = new Uint8Array(w));\n                    var I = typeof w == \"string\";\n                    if (!(I || w instanceof Uint8Array || w instanceof Uint8ClampedArray || w instanceof Int8Array)) throw new mt(\"Cannot pass non-string to std::string\");\n                    var O = f && I ? $n(w) : w.length, B = fr(4 + O + 1), L = B + 4;\n                    if (a()[B >>> 2 >>> 0] = O, f && I) Ot(w, L, O + 1);\n                    else if (I) for(I = 0; I < O; ++I){\n                        var H = w.charCodeAt(I);\n                        if (255 < H) throw Je(L), new mt(\"String has UTF-16 code units that do not fit in 8 bits\");\n                        r()[L + I >>> 0] = H;\n                    }\n                    else for(I = 0; I < O; ++I)r()[L + I >>> 0] = w[I];\n                    return b !== null && b.push(Je, B), B;\n                },\n                argPackAdvance: ft,\n                readValueFromPointer: Cn,\n                Eb (b) {\n                    Je(b);\n                }\n            });\n        }\n        var mi = typeof TextDecoder < \"u\" ? new TextDecoder(\"utf-16le\") : void 0, Uc = (s, c)=>{\n            for(var f = s >> 1, b = f + c / 2; !(f >= b) && o()[f >>> 0];)++f;\n            if (32 < (f <<= 1) - s && mi) return mi.decode(r().slice(s, f));\n            for(f = \"\", b = 0; !(b >= c / 2); ++b){\n                var w = n()[s + 2 * b >>> 1 >>> 0];\n                if (w == 0) break;\n                f += String.fromCharCode(w);\n            }\n            return f;\n        }, Nc = (s, c, f)=>{\n            if (f ??= 2147483647, 2 > f) return 0;\n            var b = c;\n            f = (f -= 2) < 2 * s.length ? f / 2 : s.length;\n            for(var w = 0; w < f; ++w){\n                var I = s.charCodeAt(w);\n                n()[c >>> 1 >>> 0] = I, c += 2;\n            }\n            return n()[c >>> 1 >>> 0] = 0, c - b;\n        }, Vc = (s)=>2 * s.length, Wc = (s, c)=>{\n            for(var f = 0, b = \"\"; !(f >= c / 4);){\n                var w = i()[s + 4 * f >>> 2 >>> 0];\n                if (w == 0) break;\n                ++f, 65536 <= w ? (w -= 65536, b += String.fromCharCode(55296 | w >> 10, 56320 | 1023 & w)) : b += String.fromCharCode(w);\n            }\n            return b;\n        }, Lc = (s, c, f)=>{\n            if (c >>>= 0, f ??= 2147483647, 4 > f) return 0;\n            var b = c;\n            f = b + f - 4;\n            for(var w = 0; w < s.length; ++w){\n                var I = s.charCodeAt(w);\n                if (55296 <= I && 57343 >= I && (I = 65536 + ((1023 & I) << 10) | 1023 & s.charCodeAt(++w)), i()[c >>> 2 >>> 0] = I, (c += 4) + 4 > f) break;\n            }\n            return i()[c >>> 2 >>> 0] = 0, c - b;\n        }, Gc = (s)=>{\n            for(var c = 0, f = 0; f < s.length; ++f){\n                var b = s.charCodeAt(f);\n                55296 <= b && 57343 >= b && ++f, c += 4;\n            }\n            return c;\n        };\n        function Hc(s, c, f) {\n            if (s >>>= 0, c >>>= 0, f = Qe(f >>>= 0), c === 2) var b = Uc, w = Nc, I = Vc, O = (B)=>o()[B >>> 1 >>> 0];\n            else c === 4 && (b = Wc, w = Lc, I = Gc, O = (B)=>a()[B >>> 2 >>> 0]);\n            st(s, {\n                name: f,\n                fromWireType: (B)=>{\n                    for(var L, H = a()[B >>> 2 >>> 0], X = B + 4, ce = 0; ce <= H; ++ce){\n                        var ge = B + 4 + ce * c;\n                        ce != H && O(ge) != 0 || (X = b(X, ge - X), L === void 0 ? L = X : (L += String.fromCharCode(0), L += X), X = ge + c);\n                    }\n                    return Je(B), L;\n                },\n                toWireType: (B, L)=>{\n                    if (typeof L != \"string\") throw new mt(`Cannot pass non-string to C++ string type ${f}`);\n                    var H = I(L), X = fr(4 + H + c);\n                    return a()[X >>> 2 >>> 0] = H / c, w(L, X + 4, H + c), B !== null && B.push(Je, X), X;\n                },\n                argPackAdvance: ft,\n                readValueFromPointer: Cn,\n                Eb (B) {\n                    Je(B);\n                }\n            });\n        }\n        function Fc(s, c) {\n            st(s >>>= 0, {\n                Ub: !0,\n                name: c = Qe(c >>> 0),\n                argPackAdvance: 0,\n                fromWireType: ()=>{},\n                toWireType: ()=>{}\n            });\n        }\n        var qc = ()=>1;\n        function Kc(s) {\n            Dn(s >>> 0, !y, 1, !_, 131072, !1), Ho();\n        }\n        var fi = (s)=>{\n            if (!we) try {\n                if (s(), !(0 < wt)) try {\n                    g ? hr(ee) : vn(ee);\n                } catch (c) {\n                    c instanceof yn || c == \"unwind\" || k(1, c);\n                }\n            } catch (c) {\n                c instanceof yn || c == \"unwind\" || k(1, c);\n            }\n        };\n        function An(s) {\n            s >>>= 0, typeof Atomics.oc == \"function\" && (Atomics.oc(i(), s >>> 2, s).value.then(ir), s += 128, Atomics.store(i(), s >>> 2, 1));\n        }\n        var ir = ()=>{\n            var s = Mt();\n            s && (An(s), fi(Hi));\n        };\n        function jc(s, c) {\n            (s >>>= 0) == c >>> 0 ? setTimeout(ir) : g ? postMessage({\n                targetThread: s,\n                cmd: \"checkMailbox\"\n            }) : (s = Ze[s]) && s.postMessage({\n                cmd: \"checkMailbox\"\n            });\n        }\n        var kn = [];\n        function Yc(s, c, f, b, w) {\n            for(c >>>= 0, b /= 2, kn.length = b, f = w >>> 0 >>> 3, w = 0; w < b; w++)kn[w] = q[f + 2 * w] ? q[f + 2 * w + 1] : l()[f + 2 * w + 1 >>> 0];\n            return (c ? bn[c] : Np[s])(...kn);\n        }\n        function Zc(s) {\n            s >>>= 0, g ? postMessage({\n                cmd: \"cleanupThread\",\n                thread: s\n            }) : Go(Ze[s]);\n        }\n        function Qc(s) {}\n        var ar = (s, c)=>{\n            var f = Sn[s];\n            if (f === void 0) throw s = Vi(s), f = Qe(s), Je(s), new mt(`${c} has unknown type ${f}`);\n            return f;\n        }, hi = (s, c, f)=>{\n            var b = [];\n            return s = s.toWireType(b, f), b.length && (a()[c >>> 2 >>> 0] = Ve(b)), s;\n        };\n        function Xc(s, c, f) {\n            return c >>>= 0, f >>>= 0, s = Me(s >>> 0), c = ar(c, \"emval::as\"), hi(c, f, s);\n        }\n        function Jc(s, c) {\n            return c >>>= 0, s = Me(s >>> 0), (c = ar(c, \"emval::as\")).toWireType(null, s);\n        }\n        var sr = (s)=>{\n            try {\n                s();\n            } catch (c) {\n                ct(c);\n            }\n        }, ht = 0, Xe = null, gi = 0, ur = [], bi = {}, yi = {}, ep = 0, En = null, tp = [];\n        function _i(s) {\n            return function(c) {\n                if (!we) {\n                    if (ht === 0) {\n                        var f = !1, b = !1;\n                        c((w = 0)=>{\n                            if (!we && (gi = w, f = !0, b)) {\n                                ht = 2, sr(()=>Yi(Xe)), typeof Browser < \"u\" && Browser.Lb.Sb && Browser.Lb.resume(), w = !1;\n                                try {\n                                    var I = function() {\n                                        var L = i()[Xe + 8 >>> 2 >>> 0];\n                                        return L = Z[yi[L]], --wt, L();\n                                    }();\n                                } catch (L) {\n                                    I = L, w = !0;\n                                }\n                                var O = !1;\n                                if (!Xe) {\n                                    var B = En;\n                                    B && (En = null, (w ? B.reject : B.resolve)(I), O = !0);\n                                }\n                                if (w && !O) throw I;\n                            }\n                        }), b = !0, f || (ht = 1, Xe = function() {\n                            var w = fr(65548), I = w + 12;\n                            a()[w >>> 2 >>> 0] = I, a()[w + 4 >>> 2 >>> 0] = I + 65536, I = ur[0];\n                            var O = bi[I];\n                            return O === void 0 && (O = ep++, bi[I] = O, yi[O] = I), I = O, i()[w + 8 >>> 2 >>> 0] = I, w;\n                        }(), typeof Browser < \"u\" && Browser.Lb.Sb && Browser.Lb.pause(), sr(()=>Ki(Xe)));\n                    } else ht === 2 ? (ht = 0, sr(Zi), Je(Xe), Xe = null, tp.forEach(fi)) : ct(`invalid state: ${ht}`);\n                    return gi;\n                }\n            }((c)=>{\n                s().then(c);\n            });\n        }\n        function rp(s) {\n            return s >>>= 0, _i(()=>(s = Me(s)).then(Ve));\n        }\n        var dr = [];\n        function np(s, c, f, b) {\n            return f >>>= 0, b >>>= 0, (s = dr[s >>> 0])(null, c = Me(c >>> 0), f, b);\n        }\n        var op = {}, lr = (s)=>{\n            var c = op[s];\n            return c === void 0 ? Qe(s) : c;\n        };\n        function ip(s, c, f, b, w) {\n            return f >>>= 0, b >>>= 0, w >>>= 0, (s = dr[s >>> 0])(c = Me(c >>> 0), c[f = lr(f)], b, w);\n        }\n        var wi = ()=>typeof globalThis == \"object\" ? globalThis : Function(\"return this\")();\n        function ap(s) {\n            return (s >>>= 0) == 0 ? Ve(wi()) : (s = lr(s), Ve(wi()[s]));\n        }\n        var sp = (s)=>{\n            var c = dr.length;\n            return dr.push(s), c;\n        }, up = (s, c)=>{\n            for(var f = Array(s), b = 0; b < s; ++b)f[b] = ar(a()[c + 4 * b >>> 2 >>> 0], \"parameter \" + b);\n            return f;\n        }, vi = (s, c)=>Object.defineProperty(c, \"name\", {\n                value: s\n            });\n        function dp(s, c, f) {\n            var b = (c = up(s, c >>> 0)).shift();\n            s--;\n            var w = `return function (obj, func, destructorsRef, args) {\n`, I = 0, O = [];\n            f === 0 && O.push(\"obj\");\n            for(var B = [\n                \"retType\"\n            ], L = [\n                b\n            ], H = 0; H < s; ++H)O.push(\"arg\" + H), B.push(\"argType\" + H), L.push(c[H]), w += `  var arg${H} = argType${H}.readValueFromPointer(args${I ? \"+\" + I : \"\"});\n`, I += c[H].argPackAdvance;\n            return w += `  var rv = ${f === 1 ? \"new func\" : \"func.call\"}(${O.join(\", \")});\n`, b.Ub || (B.push(\"emval_returnValue\"), L.push(hi), w += `  return emval_returnValue(retType, destructorsRef, rv);\n`), B.push(w + `};\n`), s = (function(X) {\n                var ce = Function;\n                if (!(ce instanceof Function)) throw new TypeError(`new_ called with constructor type ${typeof ce} which is not a function`);\n                var ge = vi(ce.name || \"unknownFunctionName\", function() {});\n                return ge.prototype = ce.prototype, ge = new ge, (X = ce.apply(ge, X)) instanceof Object ? X : ge;\n            })(B)(...L), f = `methodCaller<(${c.map((X)=>X.name).join(\", \")}) => ${b.name}>`, sp(vi(f, s));\n        }\n        function lp(s) {\n            return s = lr(s >>> 0), Ve(u[s]);\n        }\n        function cp(s, c) {\n            return c >>>= 0, s = Me(s >>> 0), c = Me(c), Ve(s[c]);\n        }\n        function pp(s) {\n            9 < (s >>>= 0) && (ut[s + 1] += 1);\n        }\n        function mp() {\n            return Ve([]);\n        }\n        function fp(s) {\n            s = Me(s >>> 0);\n            for(var c = Array(s.length), f = 0; f < s.length; f++)c[f] = s[f];\n            return Ve(c);\n        }\n        function hp(s) {\n            return Ve(lr(s >>> 0));\n        }\n        function gp() {\n            return Ve({});\n        }\n        function bp(s) {\n            for(var c = Me(s >>>= 0); c.length;){\n                var f = c.pop();\n                c.pop()(f);\n            }\n            In(s);\n        }\n        function yp(s, c, f) {\n            c >>>= 0, f >>>= 0, s = Me(s >>> 0), c = Me(c), f = Me(f), s[c] = f;\n        }\n        function _p(s, c) {\n            return c >>>= 0, s = (s = ar(s >>> 0, \"_emval_take_value\")).readValueFromPointer(c), Ve(s);\n        }\n        function wp(s, c) {\n            s = -9007199254740992 > s || 9007199254740992 < s ? NaN : Number(s), c >>>= 0, s = new Date(1e3 * s), i()[c >>> 2 >>> 0] = s.getUTCSeconds(), i()[c + 4 >>> 2 >>> 0] = s.getUTCMinutes(), i()[c + 8 >>> 2 >>> 0] = s.getUTCHours(), i()[c + 12 >>> 2 >>> 0] = s.getUTCDate(), i()[c + 16 >>> 2 >>> 0] = s.getUTCMonth(), i()[c + 20 >>> 2 >>> 0] = s.getUTCFullYear() - 1900, i()[c + 24 >>> 2 >>> 0] = s.getUTCDay(), s = (s.getTime() - Date.UTC(s.getUTCFullYear(), 0, 1, 0, 0, 0, 0)) / 864e5 | 0, i()[c + 28 >>> 2 >>> 0] = s;\n        }\n        var Dt = (s)=>s % 4 == 0 && (s % 100 != 0 || s % 400 == 0), $i = [\n            0,\n            31,\n            60,\n            91,\n            121,\n            152,\n            182,\n            213,\n            244,\n            274,\n            305,\n            335\n        ], xi = [\n            0,\n            31,\n            59,\n            90,\n            120,\n            151,\n            181,\n            212,\n            243,\n            273,\n            304,\n            334\n        ];\n        function vp(s, c) {\n            s = -9007199254740992 > s || 9007199254740992 < s ? NaN : Number(s), c >>>= 0, s = new Date(1e3 * s), i()[c >>> 2 >>> 0] = s.getSeconds(), i()[c + 4 >>> 2 >>> 0] = s.getMinutes(), i()[c + 8 >>> 2 >>> 0] = s.getHours(), i()[c + 12 >>> 2 >>> 0] = s.getDate(), i()[c + 16 >>> 2 >>> 0] = s.getMonth(), i()[c + 20 >>> 2 >>> 0] = s.getFullYear() - 1900, i()[c + 24 >>> 2 >>> 0] = s.getDay();\n            var f = (Dt(s.getFullYear()) ? $i : xi)[s.getMonth()] + s.getDate() - 1 | 0;\n            i()[c + 28 >>> 2 >>> 0] = f, i()[c + 36 >>> 2 >>> 0] = -60 * s.getTimezoneOffset(), f = new Date(s.getFullYear(), 6, 1).getTimezoneOffset();\n            var b = new Date(s.getFullYear(), 0, 1).getTimezoneOffset();\n            s = 0 | (f != b && s.getTimezoneOffset() == Math.min(b, f)), i()[c + 32 >>> 2 >>> 0] = s;\n        }\n        function $p(s) {\n            s >>>= 0;\n            var c = new Date(i()[s + 20 >>> 2 >>> 0] + 1900, i()[s + 16 >>> 2 >>> 0], i()[s + 12 >>> 2 >>> 0], i()[s + 8 >>> 2 >>> 0], i()[s + 4 >>> 2 >>> 0], i()[s >>> 2 >>> 0], 0), f = i()[s + 32 >>> 2 >>> 0], b = c.getTimezoneOffset(), w = new Date(c.getFullYear(), 6, 1).getTimezoneOffset(), I = new Date(c.getFullYear(), 0, 1).getTimezoneOffset(), O = Math.min(I, w);\n            return 0 > f ? i()[s + 32 >>> 2 >>> 0] = +(w != I && O == b) : 0 < f != (O == b) && (w = Math.max(I, w), c.setTime(c.getTime() + 6e4 * ((0 < f ? O : w) - b))), i()[s + 24 >>> 2 >>> 0] = c.getDay(), f = (Dt(c.getFullYear()) ? $i : xi)[c.getMonth()] + c.getDate() - 1 | 0, i()[s + 28 >>> 2 >>> 0] = f, i()[s >>> 2 >>> 0] = c.getSeconds(), i()[s + 4 >>> 2 >>> 0] = c.getMinutes(), i()[s + 8 >>> 2 >>> 0] = c.getHours(), i()[s + 12 >>> 2 >>> 0] = c.getDate(), i()[s + 16 >>> 2 >>> 0] = c.getMonth(), i()[s + 20 >>> 2 >>> 0] = c.getYear(), s = c.getTime(), BigInt(isNaN(s) ? -1 : s / 1e3);\n        }\n        function Si(s, c, f, b, w, I, O) {\n            return g ? xe(16, 1, s, c, f, b, w, I, O) : -52;\n        }\n        function Ti(s, c, f, b, w, I) {\n            if (g) return xe(17, 1, s, c, f, b, w, I);\n        }\n        function xp(s, c, f, b) {\n            s >>>= 0, c >>>= 0, f >>>= 0, b >>>= 0;\n            var w = new Date().getFullYear(), I = new Date(w, 0, 1), O = new Date(w, 6, 1);\n            w = I.getTimezoneOffset();\n            var B = O.getTimezoneOffset(), L = Math.max(w, B);\n            a()[s >>> 2 >>> 0] = 60 * L, i()[c >>> 2 >>> 0] = +(w != B), I = (s = (H)=>H.toLocaleTimeString(void 0, {\n                    hour12: !1,\n                    timeZoneName: \"short\"\n                }).split(\" \")[1])(I), O = s(O), B < w ? (Ot(I, f, 17), Ot(O, b, 17)) : (Ot(I, b, 17), Ot(O, f, 17));\n        }\n        var Pn = [], Ii = (s, c)=>{\n            Pn.length = 0;\n            for(var f; f = r()[s++ >>> 0];){\n                var b = f != 105;\n                c += (b &= f != 112) && c % 8 ? 4 : 0, Pn.push(f == 112 ? a()[c >>> 2 >>> 0] : f == 106 ? q[c >>> 3] : f == 105 ? i()[c >>> 2 >>> 0] : l()[c >>> 3 >>> 0]), c += b ? 8 : 4;\n            }\n            return Pn;\n        };\n        function Sp(s, c, f) {\n            return s >>>= 0, c = Ii(c >>> 0, f >>> 0), bn[s](...c);\n        }\n        function Tp(s, c, f) {\n            return s >>>= 0, c = Ii(c >>> 0, f >>> 0), bn[s](...c);\n        }\n        var Ip = ()=>{}, Cp = ()=>Date.now();\n        function Ap(s, c) {\n            return j(Ce(s >>> 0, c >>> 0));\n        }\n        var Ci, kp = ()=>{\n            throw wt += 1, \"unwind\";\n        };\n        function Ep() {\n            return 4294901760;\n        }\n        Ci = ()=>performance.timeOrigin + performance.now();\n        var Pp = ()=>navigator.hardwareConcurrency;\n        function zp() {\n            return ct(\"Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER\"), 0;\n        }\n        function Op(s) {\n            s >>>= 0;\n            var c = r().length;\n            if (s <= c || 4294901760 < s) return !1;\n            for(var f = 1; 4 >= f; f *= 2){\n                var b = c * (1 + .2 / f);\n                b = Math.min(b, s + 100663296);\n                var w = Math;\n                b = Math.max(s, b);\n                e: {\n                    w = (w.min.call(w, 4294901760, b + (65536 - b % 65536) % 65536) - se.buffer.byteLength + 65535) / 65536;\n                    try {\n                        se.grow(w), ye();\n                        var I = 1;\n                        break e;\n                    } catch  {}\n                    I = void 0;\n                }\n                if (I) return !0;\n            }\n            return !1;\n        }\n        var cr = ()=>(ct(\"Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER\"), 0), Bt = {}, Ai = (s)=>{\n            s.forEach((c)=>{\n                var f = cr();\n                f && (Bt[f] = c);\n            });\n        };\n        function Dp() {\n            var s = Error().stack.toString().split(`\n`);\n            return s[0] == \"Error\" && s.shift(), Ai(s), Bt.Qb = cr(), Bt.fc = s, Bt.Qb;\n        }\n        function Bp(s, c, f) {\n            if (s >>>= 0, c >>>= 0, Bt.Qb == s) var b = Bt.fc;\n            else (b = Error().stack.toString().split(`\n`))[0] == \"Error\" && b.shift(), Ai(b);\n            for(var w = 3; b[w] && cr() != s;)++w;\n            for(s = 0; s < f && b[s + w]; ++s)i()[c + 4 * s >>> 2 >>> 0] = cr();\n            return s;\n        }\n        var zn, On = {}, ki = ()=>{\n            if (!zn) {\n                var s, c = {\n                    USER: \"web_user\",\n                    LOGNAME: \"web_user\",\n                    PATH: \"/\",\n                    PWD: \"/\",\n                    HOME: \"/home/web_user\",\n                    LANG: (typeof navigator == \"object\" && navigator.languages && navigator.languages[0] || \"C\").replace(\"-\", \"_\") + \".UTF-8\",\n                    _: A || \"./this.program\"\n                };\n                for(s in On)On[s] === void 0 ? delete c[s] : c[s] = On[s];\n                var f = [];\n                for(s in c)f.push(`${s}=${c[s]}`);\n                zn = f;\n            }\n            return zn;\n        };\n        function Ei(s, c) {\n            if (g) return xe(18, 1, s, c);\n            s >>>= 0, c >>>= 0;\n            var f = 0;\n            return ki().forEach((b, w)=>{\n                var I = c + f;\n                for(w = a()[s + 4 * w >>> 2 >>> 0] = I, I = 0; I < b.length; ++I)t()[w++ >>> 0] = b.charCodeAt(I);\n                t()[w >>> 0] = 0, f += b.length + 1;\n            }), 0;\n        }\n        function Pi(s, c) {\n            if (g) return xe(19, 1, s, c);\n            s >>>= 0, c >>>= 0;\n            var f = ki();\n            a()[s >>> 2 >>> 0] = f.length;\n            var b = 0;\n            return f.forEach((w)=>b += w.length + 1), a()[c >>> 2 >>> 0] = b, 0;\n        }\n        function zi(s) {\n            return g ? xe(20, 1, s) : 52;\n        }\n        function Oi(s, c, f, b) {\n            return g ? xe(21, 1, s, c, f, b) : 52;\n        }\n        function Di(s, c, f, b) {\n            return g ? xe(22, 1, s, c, f, b) : 70;\n        }\n        var Mp = [\n            null,\n            [],\n            []\n        ];\n        function Bi(s, c, f, b) {\n            if (g) return xe(23, 1, s, c, f, b);\n            c >>>= 0, f >>>= 0, b >>>= 0;\n            for(var w = 0, I = 0; I < f; I++){\n                var O = a()[c >>> 2 >>> 0], B = a()[c + 4 >>> 2 >>> 0];\n                c += 8;\n                for(var L = 0; L < B; L++){\n                    var H = r()[O + L >>> 0], X = Mp[s];\n                    H === 0 || H === 10 ? ((s === 1 ? K : j)(Zo(X, 0)), X.length = 0) : X.push(H);\n                }\n                w += B;\n            }\n            return a()[b >>> 2 >>> 0] = w, 0;\n        }\n        var Mi = [\n            31,\n            29,\n            31,\n            30,\n            31,\n            30,\n            31,\n            31,\n            30,\n            31,\n            30,\n            31\n        ], Ri = [\n            31,\n            28,\n            31,\n            30,\n            31,\n            30,\n            31,\n            31,\n            30,\n            31,\n            30,\n            31\n        ], Rp = (s, c)=>{\n            t().set(s, c >>> 0);\n        };\n        function Ui(s, c, f, b) {\n            function w(z, de, Te) {\n                for(z = typeof z == \"number\" ? z.toString() : z || \"\"; z.length < de;)z = Te[0] + z;\n                return z;\n            }\n            function I(z, de) {\n                return w(z, de, \"0\");\n            }\n            function O(z, de) {\n                function Te(Xi) {\n                    return 0 > Xi ? -1 : 0 < Xi ? 1 : 0;\n                }\n                var $t;\n                return ($t = Te(z.getFullYear() - de.getFullYear())) === 0 && ($t = Te(z.getMonth() - de.getMonth())) === 0 && ($t = Te(z.getDate() - de.getDate())), $t;\n            }\n            function B(z) {\n                switch(z.getDay()){\n                    case 0:\n                        return new Date(z.getFullYear() - 1, 11, 29);\n                    case 1:\n                        return z;\n                    case 2:\n                        return new Date(z.getFullYear(), 0, 3);\n                    case 3:\n                        return new Date(z.getFullYear(), 0, 2);\n                    case 4:\n                        return new Date(z.getFullYear(), 0, 1);\n                    case 5:\n                        return new Date(z.getFullYear() - 1, 11, 31);\n                    case 6:\n                        return new Date(z.getFullYear() - 1, 11, 30);\n                }\n            }\n            function L(z) {\n                var de = z.Cb;\n                for(z = new Date(new Date(z.Db + 1900, 0, 1).getTime()); 0 < de;){\n                    var Te = z.getMonth(), $t = (Dt(z.getFullYear()) ? Mi : Ri)[Te];\n                    if (!(de > $t - z.getDate())) {\n                        z.setDate(z.getDate() + de);\n                        break;\n                    }\n                    de -= $t - z.getDate() + 1, z.setDate(1), 11 > Te ? z.setMonth(Te + 1) : (z.setMonth(0), z.setFullYear(z.getFullYear() + 1));\n                }\n                return Te = new Date(z.getFullYear() + 1, 0, 4), de = B(new Date(z.getFullYear(), 0, 4)), Te = B(Te), 0 >= O(de, z) ? 0 >= O(Te, z) ? z.getFullYear() + 1 : z.getFullYear() : z.getFullYear() - 1;\n            }\n            s >>>= 0, c >>>= 0, f >>>= 0, b >>>= 0;\n            var H = a()[b + 40 >>> 2 >>> 0];\n            for(var X in b = {\n                lc: i()[b >>> 2 >>> 0],\n                kc: i()[b + 4 >>> 2 >>> 0],\n                Ib: i()[b + 8 >>> 2 >>> 0],\n                Mb: i()[b + 12 >>> 2 >>> 0],\n                Jb: i()[b + 16 >>> 2 >>> 0],\n                Db: i()[b + 20 >>> 2 >>> 0],\n                vb: i()[b + 24 >>> 2 >>> 0],\n                Cb: i()[b + 28 >>> 2 >>> 0],\n                sc: i()[b + 32 >>> 2 >>> 0],\n                jc: i()[b + 36 >>> 2 >>> 0],\n                mc: H ? Ce(H) : \"\"\n            }, f = Ce(f), H = {\n                \"%c\": \"%a %b %d %H:%M:%S %Y\",\n                \"%D\": \"%m/%d/%y\",\n                \"%F\": \"%Y-%m-%d\",\n                \"%h\": \"%b\",\n                \"%r\": \"%I:%M:%S %p\",\n                \"%R\": \"%H:%M\",\n                \"%T\": \"%H:%M:%S\",\n                \"%x\": \"%m/%d/%y\",\n                \"%X\": \"%H:%M:%S\",\n                \"%Ec\": \"%c\",\n                \"%EC\": \"%C\",\n                \"%Ex\": \"%m/%d/%y\",\n                \"%EX\": \"%H:%M:%S\",\n                \"%Ey\": \"%y\",\n                \"%EY\": \"%Y\",\n                \"%Od\": \"%d\",\n                \"%Oe\": \"%e\",\n                \"%OH\": \"%H\",\n                \"%OI\": \"%I\",\n                \"%Om\": \"%m\",\n                \"%OM\": \"%M\",\n                \"%OS\": \"%S\",\n                \"%Ou\": \"%u\",\n                \"%OU\": \"%U\",\n                \"%OV\": \"%V\",\n                \"%Ow\": \"%w\",\n                \"%OW\": \"%W\",\n                \"%Oy\": \"%y\"\n            })f = f.replace(new RegExp(X, \"g\"), H[X]);\n            var ce = \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"), ge = \"January February March April May June July August September October November December\".split(\" \");\n            for(X in H = {\n                \"%a\": (z)=>ce[z.vb].substring(0, 3),\n                \"%A\": (z)=>ce[z.vb],\n                \"%b\": (z)=>ge[z.Jb].substring(0, 3),\n                \"%B\": (z)=>ge[z.Jb],\n                \"%C\": (z)=>I((z.Db + 1900) / 100 | 0, 2),\n                \"%d\": (z)=>I(z.Mb, 2),\n                \"%e\": (z)=>w(z.Mb, 2, \" \"),\n                \"%g\": (z)=>L(z).toString().substring(2),\n                \"%G\": L,\n                \"%H\": (z)=>I(z.Ib, 2),\n                \"%I\": (z)=>((z = z.Ib) == 0 ? z = 12 : 12 < z && (z -= 12), I(z, 2)),\n                \"%j\": (z)=>{\n                    for(var de = 0, Te = 0; Te <= z.Jb - 1; de += (Dt(z.Db + 1900) ? Mi : Ri)[Te++]);\n                    return I(z.Mb + de, 3);\n                },\n                \"%m\": (z)=>I(z.Jb + 1, 2),\n                \"%M\": (z)=>I(z.kc, 2),\n                \"%n\": ()=>`\n`,\n                \"%p\": (z)=>0 <= z.Ib && 12 > z.Ib ? \"AM\" : \"PM\",\n                \"%S\": (z)=>I(z.lc, 2),\n                \"%t\": ()=>\"\t\",\n                \"%u\": (z)=>z.vb || 7,\n                \"%U\": (z)=>I(Math.floor((z.Cb + 7 - z.vb) / 7), 2),\n                \"%V\": (z)=>{\n                    var de = Math.floor((z.Cb + 7 - (z.vb + 6) % 7) / 7);\n                    if (2 >= (z.vb + 371 - z.Cb - 2) % 7 && de++, de) de == 53 && ((Te = (z.vb + 371 - z.Cb) % 7) == 4 || Te == 3 && Dt(z.Db) || (de = 1));\n                    else {\n                        de = 52;\n                        var Te = (z.vb + 7 - z.Cb - 1) % 7;\n                        (Te == 4 || Te == 5 && Dt(z.Db % 400 - 1)) && de++;\n                    }\n                    return I(de, 2);\n                },\n                \"%w\": (z)=>z.vb,\n                \"%W\": (z)=>I(Math.floor((z.Cb + 7 - (z.vb + 6) % 7) / 7), 2),\n                \"%y\": (z)=>(z.Db + 1900).toString().substring(2),\n                \"%Y\": (z)=>z.Db + 1900,\n                \"%z\": (z)=>{\n                    var de = 0 <= (z = z.jc);\n                    return z = Math.abs(z) / 60, (de ? \"+\" : \"-\") + (\"0000\" + (z / 60 * 100 + z % 60)).slice(-4);\n                },\n                \"%Z\": (z)=>z.mc,\n                \"%%\": ()=>\"%\"\n            }, f = f.replace(/%%/g, \"\\x00\\x00\"), H)f.includes(X) && (f = f.replace(new RegExp(X, \"g\"), H[X](b)));\n            return X = function(z) {\n                var de = Array($n(z) + 1);\n                return Jo(z, de, 0, de.length), de;\n            }(f = f.replace(/\\0\\0/g, \"%\")), X.length > c ? 0 : (Rp(X, s), X.length - 1);\n        }\n        function Up(s, c, f, b) {\n            return Ui(s >>> 0, c >>> 0, f >>> 0, b >>> 0);\n        }\n        g || function() {\n            for(var s = u.numThreads - 1; s--;)qo();\n            Ye.unshift(()=>{\n                Gt++, function(c) {\n                    g ? c() : Promise.all(pt.map(Fo)).then(c);\n                }(()=>Do());\n            });\n        }();\n        for(var Ni = Array(256), pr = 0; 256 > pr; ++pr)Ni[pr] = String.fromCharCode(pr);\n        ci = Ni, mt = u.BindingError = class extends Error {\n            constructor(s){\n                super(s), this.name = \"BindingError\";\n            }\n        }, u.InternalError = class extends Error {\n            constructor(s){\n                super(s), this.name = \"InternalError\";\n            }\n        }, ut.push(0, 1, void 0, 1, null, 1, !0, 1, !1, 1), u.count_emval_handles = ()=>ut.length / 2 - 5 - Tn.length;\n        var Np = [\n            wn,\n            Wo,\n            Ko,\n            Qo,\n            Xo,\n            ei,\n            ti,\n            ri,\n            ni,\n            oi,\n            ii,\n            ai,\n            si,\n            ui,\n            di,\n            li,\n            Si,\n            Ti,\n            Ei,\n            Pi,\n            zi,\n            Oi,\n            Di,\n            Bi\n        ], Z = function() {\n            function s(f, b) {\n                return Z = f.exports, Z = function() {\n                    var w = Z, I = {};\n                    for (let [O, B] of Object.entries(w))I[O] = typeof B == \"function\" ? (...L)=>{\n                        ur.push(O);\n                        try {\n                            return B(...L);\n                        } finally{\n                            we || (ur.pop(), Xe && ht === 1 && ur.length === 0 && (ht = 0, wt += 1, sr(ji), typeof Fibers < \"u\" && Fibers.tc()));\n                        }\n                    } : B;\n                    return I;\n                }(), Z = function() {\n                    var w = Z, I = (B)=>(L)=>B(L) >>> 0, O = (B)=>()=>B() >>> 0;\n                    return (w = Object.assign({}, w)).Da = I(w.Da), w.gb = O(w.gb), w.ib = I(w.ib), w.emscripten_main_runtime_thread_id = O(w.emscripten_main_runtime_thread_id), w.tb = I(w.tb), w.ub = O(w.ub), w;\n                }(), Lo.push(Z.jb), Lt.unshift(Z.Ca), Y = b, Do(), Z;\n            }\n            var c = No();\n            if (Gt++, u.instantiateWasm) try {\n                return u.instantiateWasm(c, s);\n            } catch (f) {\n                j(`Module.instantiateWasm callback failed with error: ${f}`), m(f);\n            }\n            return gn ||= u.locateFile ? Bo(\"ort-wasm-simd-threaded.jsep.wasm\") ? \"ort-wasm-simd-threaded.jsep.wasm\" : u.locateFile ? u.locateFile(\"ort-wasm-simd-threaded.jsep.wasm\", P) : P + \"ort-wasm-simd-threaded.jsep.wasm\" : /* asset import */ new __webpack_require__.U(__webpack_require__(/*! ort-wasm-simd-threaded.jsep.wasm */ \"(ssr)/./node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm\")).href, (function(f, b) {\n                var w = gn;\n                return D || typeof WebAssembly.instantiateStreaming != \"function\" || Bo(w) || Mo(w) || typeof fetch != \"function\" ? Uo(w, f, b) : fetch(w, {\n                    credentials: \"same-origin\"\n                }).then((I)=>WebAssembly.instantiateStreaming(I, f).then(b, function(O) {\n                        return j(`wasm streaming compile failed: ${O}`), j(\"falling back to ArrayBuffer instantiation\"), Uo(w, f, b);\n                    }));\n            })(c, function(f) {\n                s(f.instance, f.module);\n            }).catch(m), {};\n        }(), Vi = (s)=>(Vi = Z.Da)(s), Wi = ()=>(Wi = Z.Ea)();\n        u._OrtInit = (s, c)=>(u._OrtInit = Z.Fa)(s, c), u._OrtGetLastError = (s, c)=>(u._OrtGetLastError = Z.Ga)(s, c), u._OrtCreateSessionOptions = (s, c, f, b, w, I, O, B, L, H)=>(u._OrtCreateSessionOptions = Z.Ha)(s, c, f, b, w, I, O, B, L, H), u._OrtAppendExecutionProvider = (s, c)=>(u._OrtAppendExecutionProvider = Z.Ia)(s, c), u._OrtAddFreeDimensionOverride = (s, c, f)=>(u._OrtAddFreeDimensionOverride = Z.Ja)(s, c, f), u._OrtAddSessionConfigEntry = (s, c, f)=>(u._OrtAddSessionConfigEntry = Z.Ka)(s, c, f), u._OrtReleaseSessionOptions = (s)=>(u._OrtReleaseSessionOptions = Z.La)(s), u._OrtCreateSession = (s, c, f)=>(u._OrtCreateSession = Z.Ma)(s, c, f), u._OrtReleaseSession = (s)=>(u._OrtReleaseSession = Z.Na)(s), u._OrtGetInputOutputCount = (s, c, f)=>(u._OrtGetInputOutputCount = Z.Oa)(s, c, f), u._OrtGetInputName = (s, c)=>(u._OrtGetInputName = Z.Pa)(s, c), u._OrtGetOutputName = (s, c)=>(u._OrtGetOutputName = Z.Qa)(s, c), u._OrtFree = (s)=>(u._OrtFree = Z.Ra)(s), u._OrtCreateTensor = (s, c, f, b, w, I)=>(u._OrtCreateTensor = Z.Sa)(s, c, f, b, w, I), u._OrtGetTensorData = (s, c, f, b, w)=>(u._OrtGetTensorData = Z.Ta)(s, c, f, b, w), u._OrtReleaseTensor = (s)=>(u._OrtReleaseTensor = Z.Ua)(s), u._OrtCreateRunOptions = (s, c, f, b)=>(u._OrtCreateRunOptions = Z.Va)(s, c, f, b), u._OrtAddRunConfigEntry = (s, c, f)=>(u._OrtAddRunConfigEntry = Z.Wa)(s, c, f), u._OrtReleaseRunOptions = (s)=>(u._OrtReleaseRunOptions = Z.Xa)(s), u._OrtCreateBinding = (s)=>(u._OrtCreateBinding = Z.Ya)(s), u._OrtBindInput = (s, c, f)=>(u._OrtBindInput = Z.Za)(s, c, f), u._OrtBindOutput = (s, c, f, b)=>(u._OrtBindOutput = Z._a)(s, c, f, b), u._OrtClearBoundOutputs = (s)=>(u._OrtClearBoundOutputs = Z.$a)(s), u._OrtReleaseBinding = (s)=>(u._OrtReleaseBinding = Z.ab)(s), u._OrtRunWithBinding = (s, c, f, b, w)=>(u._OrtRunWithBinding = Z.bb)(s, c, f, b, w), u._OrtRun = (s, c, f, b, w, I, O, B)=>(u._OrtRun = Z.cb)(s, c, f, b, w, I, O, B), u._OrtEndProfiling = (s)=>(u._OrtEndProfiling = Z.db)(s), u._JsepOutput = (s, c, f)=>(u._JsepOutput = Z.eb)(s, c, f), u._JsepGetNodeName = (s)=>(u._JsepGetNodeName = Z.fb)(s);\n        var mr, Mt = ()=>(Mt = Z.gb)(), Je = u._free = (s)=>(Je = u._free = Z.hb)(s), fr = u._malloc = (s)=>(fr = u._malloc = Z.ib)(s), Dn = (s, c, f, b, w, I)=>(Dn = Z.lb)(s, c, f, b, w, I), Li = ()=>(Li = Z.mb)(), Gi = (s, c, f, b, w)=>(Gi = Z.nb)(s, c, f, b, w), Bn = (s)=>(Bn = Z.ob)(s), hr = (s)=>(hr = Z.pb)(s), Hi = ()=>(Hi = Z.qb)(), Fi = (s, c)=>(Fi = Z.rb)(s, c), gr = (s)=>(gr = Z.sb)(s), Mn = (s)=>(Mn = Z.tb)(s), Rn = ()=>(Rn = Z.ub)(), qi = u.dynCall_ii = (s, c)=>(qi = u.dynCall_ii = Z.wb)(s, c), Ki = (s)=>(Ki = Z.xb)(s), ji = ()=>(ji = Z.yb)(), Yi = (s)=>(Yi = Z.zb)(s), Zi = ()=>(Zi = Z.Ab)();\n        function Qi() {\n            0 < Gt || (g ? (p(u), g || or(Lt), startWorker(u)) : (or(Ye), 0 < Gt || mr || (mr = !0, u.calledRun = !0, we || (g || or(Lt), p(u), g || or(fn)))));\n        }\n        return u.___start_em_js = 929301, u.___stop_em_js = 929547, u.stackSave = ()=>Rn(), u.stackRestore = (s)=>gr(s), u.stackAlloc = (s)=>Mn(s), u.setValue = function(s, c, f = \"i8\") {\n            switch(f.endsWith(\"*\") && (f = \"*\"), f){\n                case \"i1\":\n                case \"i8\":\n                    t()[s >>> 0] = c;\n                    break;\n                case \"i16\":\n                    n()[s >>> 1 >>> 0] = c;\n                    break;\n                case \"i32\":\n                    i()[s >>> 2 >>> 0] = c;\n                    break;\n                case \"i64\":\n                    q[s >>> 3] = BigInt(c);\n                    break;\n                case \"float\":\n                    d()[s >>> 2 >>> 0] = c;\n                    break;\n                case \"double\":\n                    l()[s >>> 3 >>> 0] = c;\n                    break;\n                case \"*\":\n                    a()[s >>> 2 >>> 0] = c;\n                    break;\n                default:\n                    ct(`invalid type for setValue: ${f}`);\n            }\n        }, u.getValue = function(s, c = \"i8\") {\n            switch(c.endsWith(\"*\") && (c = \"*\"), c){\n                case \"i1\":\n                case \"i8\":\n                    return t()[s >>> 0];\n                case \"i16\":\n                    return n()[s >>> 1 >>> 0];\n                case \"i32\":\n                    return i()[s >>> 2 >>> 0];\n                case \"i64\":\n                    return q[s >>> 3];\n                case \"float\":\n                    return d()[s >>> 2 >>> 0];\n                case \"double\":\n                    return l()[s >>> 3 >>> 0];\n                case \"*\":\n                    return a()[s >>> 2 >>> 0];\n                default:\n                    ct(`invalid type for getValue: ${c}`);\n            }\n        }, u.UTF8ToString = Ce, u.stringToUTF8 = Ot, u.lengthBytesUTF8 = $n, Ht = function s() {\n            mr || Qi(), mr || (Ht = s);\n        }, Qi(), u.PTR_SIZE = 4, h;\n    }), Kp = za;\n    globalThis.self?.name === \"em-pthread\" && za();\n});\nvar Ra, jp, Ne, Ua, jn, Yp, Zp, Na, Qp, Ba, Va, Ma, Wa, xr = U(()=>{\n    \"use strict\";\n    $r();\n    Ra =  false || typeof location > \"u\" ? void 0 : location.origin, jp = ()=>{\n        if (true) return \"file:///Users/amityadav/Desktop/Text-Behind%20Image/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs\"?.startsWith(\"file:\") ? new URL(/* asset import */ new __webpack_require__.U(__webpack_require__(/*! ort.webgpu.bundle.min.mjs */ \"(ssr)/./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs?5952\")).href, Ra).href : \"file:///Users/amityadav/Desktop/Text-Behind%20Image/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs\";\n    }, Ne = jp(), Ua = ()=>{\n        if (Ne && !Ne.startsWith(\"blob:\")) return Ne.substring(0, Ne.lastIndexOf(\"/\") + 1);\n    }, jn = (e1, t)=>{\n        try {\n            let r = t ?? Ne;\n            return (r ? new URL(e1, r) : new URL(e1)).origin === Ra;\n        } catch  {\n            return !1;\n        }\n    }, Yp = (e1, t)=>{\n        let r = t ?? Ne;\n        try {\n            return (r ? new URL(e1, r) : new URL(e1)).href;\n        } catch  {\n            return;\n        }\n    }, Zp = (e1, t)=>`${t ?? \"./\"}${e1}`, Na = async (e1)=>{\n        let r = await (await fetch(e1, {\n            credentials: \"same-origin\"\n        })).blob();\n        return URL.createObjectURL(r);\n    }, Qp = async (e1)=>(await import(/*webpackIgnore:true*/ e1)).default, Ba = (Pa(), br(Ea)).default, Va = async ()=>{\n        if (!Ne) throw new Error(\"Failed to load proxy worker: cannot determine the script source URL.\");\n        if (jn(Ne)) return [\n            void 0,\n            Ba()\n        ];\n        let e1 = await Na(Ne);\n        return [\n            e1,\n            Ba(e1)\n        ];\n    }, Ma = (Da(), br(Oa)).default, Wa = async (e1, t, r)=>{\n        if (!e1 && !t && Ma && Ne && jn(Ne)) return [\n            void 0,\n            Ma\n        ];\n        {\n            let n = \"ort-wasm-simd-threaded.jsep.mjs\", o = e1 ?? Yp(n, t), i =  true && r && o && !jn(o, t), a = i ? await Na(o) : o ?? Zp(n, t);\n            return [\n                i ? a : void 0,\n                await Qp(a)\n            ];\n        }\n    };\n});\nvar Yn, Zn, zr, La, Xp, Jp, Sr, Ie, gt = U(()=>{\n    \"use strict\";\n    xr();\n    Zn = !1, zr = !1, La = !1, Xp = ()=>{\n        if (typeof SharedArrayBuffer > \"u\") return !1;\n        try {\n            return typeof MessageChannel < \"u\" && new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)), WebAssembly.validate(new Uint8Array([\n                0,\n                97,\n                115,\n                109,\n                1,\n                0,\n                0,\n                0,\n                1,\n                4,\n                1,\n                96,\n                0,\n                0,\n                3,\n                2,\n                1,\n                0,\n                5,\n                4,\n                1,\n                3,\n                1,\n                1,\n                10,\n                11,\n                1,\n                9,\n                0,\n                65,\n                0,\n                254,\n                16,\n                2,\n                0,\n                26,\n                11\n            ]));\n        } catch  {\n            return !1;\n        }\n    }, Jp = ()=>{\n        try {\n            return WebAssembly.validate(new Uint8Array([\n                0,\n                97,\n                115,\n                109,\n                1,\n                0,\n                0,\n                0,\n                1,\n                4,\n                1,\n                96,\n                0,\n                0,\n                3,\n                2,\n                1,\n                0,\n                10,\n                30,\n                1,\n                28,\n                0,\n                65,\n                0,\n                253,\n                15,\n                253,\n                12,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                253,\n                186,\n                1,\n                26,\n                11\n            ]));\n        } catch  {\n            return !1;\n        }\n    }, Sr = async (e1)=>{\n        if (Zn) return Promise.resolve();\n        if (zr) throw new Error(\"multiple calls to 'initializeWebAssembly()' detected.\");\n        if (La) throw new Error(\"previous call to 'initializeWebAssembly()' failed.\");\n        zr = !0;\n        let t = e1.initTimeout, r = e1.numThreads;\n        if (!Jp()) throw new Error(\"WebAssembly SIMD is not supported in the current environment.\");\n        let n = Xp();\n        r > 1 && !n && (typeof self < \"u\" && !self.crossOriginIsolated && console.warn(\"env.wasm.numThreads is set to \" + r + \", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info.\"), console.warn(\"WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading.\"), e1.numThreads = r = 1);\n        let o = e1.wasmPaths, i = typeof o == \"string\" ? o : void 0, a = o?.mjs, d = a?.href ?? a, l = o?.wasm, p = l?.href ?? l, m = e1.wasmBinary, [u, h] = await Wa(d, i, r > 1), _ = !1, y = [];\n        if (t > 0 && y.push(new Promise((g)=>{\n            setTimeout(()=>{\n                _ = !0, g();\n            }, t);\n        })), y.push(new Promise((g, x)=>{\n            let $ = {\n                numThreads: r\n            };\n            if (m) $.wasmBinary = m;\n            else if (p || i) $.locateFile = (v)=>p ?? i + v;\n            else if (d && d.indexOf(\"blob:\") !== 0) $.locateFile = (v)=>new URL(v, d).href;\n            else if (u) {\n                let v = Ua();\n                v && ($.locateFile = (S)=>v + S);\n            }\n            h($).then((v)=>{\n                zr = !1, Zn = !0, Yn = v, g(), u && URL.revokeObjectURL(u);\n            }, (v)=>{\n                zr = !1, La = !0, x(v);\n            });\n        })), await Promise.race(y), _) throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`);\n    }, Ie = ()=>{\n        if (Zn && Yn) return Yn;\n        throw new Error(\"WebAssembly is not initialized yet.\");\n    };\n});\nvar ke, jt, pe, Or = U(()=>{\n    \"use strict\";\n    gt();\n    ke = (e1, t)=>{\n        let r = Ie(), n = r.lengthBytesUTF8(e1) + 1, o = r._malloc(n);\n        return r.stringToUTF8(e1, o, n), t.push(o), o;\n    }, jt = (e1, t, r, n)=>{\n        if (typeof e1 == \"object\" && e1 !== null) {\n            if (r.has(e1)) throw new Error(\"Circular reference in options\");\n            r.add(e1);\n        }\n        Object.entries(e1).forEach(([o, i])=>{\n            let a = t ? t + o : o;\n            if (typeof i == \"object\") jt(i, a + \".\", r, n);\n            else if (typeof i == \"string\" || typeof i == \"number\") n(a, i.toString());\n            else if (typeof i == \"boolean\") n(a, i ? \"1\" : \"0\");\n            else throw new Error(`Can't handle extra config type: ${typeof i}`);\n        });\n    }, pe = (e1)=>{\n        let t = Ie(), r = t.stackSave();\n        try {\n            let n = t.PTR_SIZE, o = t.stackAlloc(2 * n);\n            t._OrtGetLastError(o, o + n);\n            let i = Number(t.getValue(o, n === 4 ? \"i32\" : \"i64\")), a = t.getValue(o + n, \"*\"), d = a ? t.UTF8ToString(a) : \"\";\n            throw new Error(`${e1} ERROR_CODE: ${i}, ERROR_MESSAGE: ${d}`);\n        } finally{\n            t.stackRestore(r);\n        }\n    };\n});\nvar Ga, Ha = U(()=>{\n    \"use strict\";\n    gt();\n    Or();\n    Ga = (e1)=>{\n        let t = Ie(), r = 0, n = [], o = e1 || {};\n        try {\n            if (e1?.logSeverityLevel === void 0) o.logSeverityLevel = 2;\n            else if (typeof e1.logSeverityLevel != \"number\" || !Number.isInteger(e1.logSeverityLevel) || e1.logSeverityLevel < 0 || e1.logSeverityLevel > 4) throw new Error(`log serverity level is not valid: ${e1.logSeverityLevel}`);\n            if (e1?.logVerbosityLevel === void 0) o.logVerbosityLevel = 0;\n            else if (typeof e1.logVerbosityLevel != \"number\" || !Number.isInteger(e1.logVerbosityLevel)) throw new Error(`log verbosity level is not valid: ${e1.logVerbosityLevel}`);\n            e1?.terminate === void 0 && (o.terminate = !1);\n            let i = 0;\n            return e1?.tag !== void 0 && (i = ke(e1.tag, n)), r = t._OrtCreateRunOptions(o.logSeverityLevel, o.logVerbosityLevel, !!o.terminate, i), r === 0 && pe(\"Can't create run options.\"), e1?.extra !== void 0 && jt(e1.extra, \"\", new WeakSet, (a, d)=>{\n                let l = ke(a, n), p = ke(d, n);\n                t._OrtAddRunConfigEntry(r, l, p) !== 0 && pe(`Can't set a run config entry: ${a} - ${d}.`);\n            }), [\n                r,\n                n\n            ];\n        } catch (i) {\n            throw r !== 0 && t._OrtReleaseRunOptions(r), n.forEach((a)=>t._free(a)), i;\n        }\n    };\n});\nvar em, tm, rm, nm, Fa, qa = U(()=>{\n    \"use strict\";\n    gt();\n    Or();\n    em = (e1)=>{\n        switch(e1){\n            case \"disabled\":\n                return 0;\n            case \"basic\":\n                return 1;\n            case \"extended\":\n                return 2;\n            case \"all\":\n                return 99;\n            default:\n                throw new Error(`unsupported graph optimization level: ${e1}`);\n        }\n    }, tm = (e1)=>{\n        switch(e1){\n            case \"sequential\":\n                return 0;\n            case \"parallel\":\n                return 1;\n            default:\n                throw new Error(`unsupported execution mode: ${e1}`);\n        }\n    }, rm = (e1)=>{\n        e1.extra || (e1.extra = {}), e1.extra.session || (e1.extra.session = {});\n        let t = e1.extra.session;\n        t.use_ort_model_bytes_directly || (t.use_ort_model_bytes_directly = \"1\"), e1.executionProviders && e1.executionProviders.some((r)=>(typeof r == \"string\" ? r : r.name) === \"webgpu\") && (e1.enableMemPattern = !1);\n    }, nm = (e1, t, r)=>{\n        for (let n of t){\n            let o = typeof n == \"string\" ? n : n.name;\n            switch(o){\n                case \"webnn\":\n                    if (o = \"WEBNN\", typeof n != \"string\") {\n                        let d = n?.deviceType;\n                        if (d) {\n                            let l = ke(\"deviceType\", r), p = ke(d, r);\n                            Ie()._OrtAddSessionConfigEntry(e1, l, p) !== 0 && pe(`Can't set a session config entry: 'deviceType' - ${d}.`);\n                        }\n                    }\n                    break;\n                case \"webgpu\":\n                    if (o = \"JS\", typeof n != \"string\") {\n                        let a = n;\n                        if (a?.preferredLayout) {\n                            if (a.preferredLayout !== \"NCHW\" && a.preferredLayout !== \"NHWC\") throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${a.preferredLayout}`);\n                            let d = ke(\"preferredLayout\", r), l = ke(a.preferredLayout, r);\n                            Ie()._OrtAddSessionConfigEntry(e1, d, l) !== 0 && pe(`Can't set a session config entry: 'preferredLayout' - ${a.preferredLayout}.`);\n                        }\n                    }\n                    break;\n                case \"wasm\":\n                case \"cpu\":\n                    continue;\n                default:\n                    throw new Error(`not supported execution provider: ${o}`);\n            }\n            let i = ke(o, r);\n            Ie()._OrtAppendExecutionProvider(e1, i) !== 0 && pe(`Can't append execution provider: ${o}.`);\n        }\n    }, Fa = (e1)=>{\n        let t = Ie(), r = 0, n = [], o = e1 || {};\n        rm(o);\n        try {\n            let i = em(o.graphOptimizationLevel ?? \"all\"), a = tm(o.executionMode ?? \"sequential\"), d = typeof o.logId == \"string\" ? ke(o.logId, n) : 0, l = o.logSeverityLevel ?? 2;\n            if (!Number.isInteger(l) || l < 0 || l > 4) throw new Error(`log serverity level is not valid: ${l}`);\n            let p = o.logVerbosityLevel ?? 0;\n            if (!Number.isInteger(p) || p < 0 || p > 4) throw new Error(`log verbosity level is not valid: ${p}`);\n            let m = typeof o.optimizedModelFilePath == \"string\" ? ke(o.optimizedModelFilePath, n) : 0;\n            if (r = t._OrtCreateSessionOptions(i, !!o.enableCpuMemArena, !!o.enableMemPattern, a, !!o.enableProfiling, 0, d, l, p, m), r === 0 && pe(\"Can't create session options.\"), o.executionProviders && nm(r, o.executionProviders, n), o.enableGraphCapture !== void 0) {\n                if (typeof o.enableGraphCapture != \"boolean\") throw new Error(`enableGraphCapture must be a boolean value: ${o.enableGraphCapture}`);\n                let u = ke(\"enableGraphCapture\", n), h = ke(o.enableGraphCapture.toString(), n);\n                t._OrtAddSessionConfigEntry(r, u, h) !== 0 && pe(`Can't set a session config entry: 'enableGraphCapture' - ${o.enableGraphCapture}.`);\n            }\n            if (o.freeDimensionOverrides) for (let [u, h] of Object.entries(o.freeDimensionOverrides)){\n                if (typeof u != \"string\") throw new Error(`free dimension override name must be a string: ${u}`);\n                if (typeof h != \"number\" || !Number.isInteger(h) || h < 0) throw new Error(`free dimension override value must be a non-negative integer: ${h}`);\n                let _ = ke(u, n);\n                t._OrtAddFreeDimensionOverride(r, _, h) !== 0 && pe(`Can't set a free dimension override: ${u} - ${h}.`);\n            }\n            return o.extra !== void 0 && jt(o.extra, \"\", new WeakSet, (u, h)=>{\n                let _ = ke(u, n), y = ke(h, n);\n                t._OrtAddSessionConfigEntry(r, _, y) !== 0 && pe(`Can't set a session config entry: ${u} - ${h}.`);\n            }), [\n                r,\n                n\n            ];\n        } catch (i) {\n            throw r !== 0 && t._OrtReleaseSessionOptions(r) !== 0 && pe(\"Can't release session options.\"), n.forEach((a)=>t._free(a)), i;\n        }\n    };\n});\nvar Yt, bt, Ct, Dr, Zt, Br, Mr, Qn, te = U(()=>{\n    \"use strict\";\n    Yt = (e1)=>{\n        switch(e1){\n            case \"int8\":\n                return 3;\n            case \"uint8\":\n                return 2;\n            case \"bool\":\n                return 9;\n            case \"int16\":\n                return 5;\n            case \"uint16\":\n                return 4;\n            case \"int32\":\n                return 6;\n            case \"uint32\":\n                return 12;\n            case \"float16\":\n                return 10;\n            case \"float32\":\n                return 1;\n            case \"float64\":\n                return 11;\n            case \"string\":\n                return 8;\n            case \"int64\":\n                return 7;\n            case \"uint64\":\n                return 13;\n            case \"int4\":\n                return 22;\n            case \"uint4\":\n                return 21;\n            default:\n                throw new Error(`unsupported data type: ${e1}`);\n        }\n    }, bt = (e1)=>{\n        switch(e1){\n            case 3:\n                return \"int8\";\n            case 2:\n                return \"uint8\";\n            case 9:\n                return \"bool\";\n            case 5:\n                return \"int16\";\n            case 4:\n                return \"uint16\";\n            case 6:\n                return \"int32\";\n            case 12:\n                return \"uint32\";\n            case 10:\n                return \"float16\";\n            case 1:\n                return \"float32\";\n            case 11:\n                return \"float64\";\n            case 8:\n                return \"string\";\n            case 7:\n                return \"int64\";\n            case 13:\n                return \"uint64\";\n            case 22:\n                return \"int4\";\n            case 21:\n                return \"uint4\";\n            default:\n                throw new Error(`unsupported data type: ${e1}`);\n        }\n    }, Ct = (e1, t)=>{\n        let r = [\n            -1,\n            4,\n            1,\n            1,\n            2,\n            2,\n            4,\n            8,\n            -1,\n            1,\n            2,\n            8,\n            4,\n            8,\n            -1,\n            -1,\n            -1,\n            -1,\n            -1,\n            -1,\n            -1,\n            .5,\n            .5\n        ][e1], n = typeof t == \"number\" ? t : t.reduce((o, i)=>o * i, 1);\n        return r > 0 ? Math.ceil(n * r) : void 0;\n    }, Dr = (e1)=>{\n        switch(e1){\n            case \"float16\":\n                return typeof Float16Array < \"u\" && Float16Array.from ? Float16Array : Uint16Array;\n            case \"float32\":\n                return Float32Array;\n            case \"uint8\":\n                return Uint8Array;\n            case \"int8\":\n                return Int8Array;\n            case \"uint16\":\n                return Uint16Array;\n            case \"int16\":\n                return Int16Array;\n            case \"int32\":\n                return Int32Array;\n            case \"bool\":\n                return Uint8Array;\n            case \"float64\":\n                return Float64Array;\n            case \"uint32\":\n                return Uint32Array;\n            case \"int64\":\n                return BigInt64Array;\n            case \"uint64\":\n                return BigUint64Array;\n            default:\n                throw new Error(`unsupported type: ${e1}`);\n        }\n    }, Zt = (e1)=>{\n        switch(e1){\n            case \"verbose\":\n                return 0;\n            case \"info\":\n                return 1;\n            case \"warning\":\n                return 2;\n            case \"error\":\n                return 3;\n            case \"fatal\":\n                return 4;\n            default:\n                throw new Error(`unsupported logging level: ${e1}`);\n        }\n    }, Br = (e1)=>e1 === \"float32\" || e1 === \"float16\" || e1 === \"int32\" || e1 === \"int64\" || e1 === \"uint32\" || e1 === \"uint8\" || e1 === \"bool\" || e1 === \"uint4\" || e1 === \"int4\", Mr = (e1)=>e1 === \"float32\" || e1 === \"float16\" || e1 === \"int32\" || e1 === \"int64\" || e1 === \"uint32\" || e1 === \"uint64\" || e1 === \"int8\" || e1 === \"uint8\" || e1 === \"bool\" || e1 === \"uint4\" || e1 === \"int4\", Qn = (e1)=>{\n        switch(e1){\n            case \"none\":\n                return 0;\n            case \"cpu\":\n                return 1;\n            case \"cpu-pinned\":\n                return 2;\n            case \"texture\":\n                return 3;\n            case \"gpu-buffer\":\n                return 4;\n            case \"ml-tensor\":\n                return 5;\n            default:\n                throw new Error(`unsupported data location: ${e1}`);\n        }\n    };\n});\nvar Qt, Xn = U(()=>{\n    \"use strict\";\n    $r();\n    Qt = async (e1)=>{\n        if (typeof e1 == \"string\") if (false) {}\n        else {\n            let t = await fetch(e1);\n            if (!t.ok) throw new Error(`failed to load external data file: ${e1}`);\n            let r = t.headers.get(\"Content-Length\"), n = r ? parseInt(r, 10) : 0;\n            if (n < 1073741824) return new Uint8Array(await t.arrayBuffer());\n            {\n                if (!t.body) throw new Error(`failed to load external data file: ${e1}, no response body.`);\n                let o = t.body.getReader(), i;\n                try {\n                    i = new ArrayBuffer(n);\n                } catch (d) {\n                    if (d instanceof RangeError) {\n                        let l = Math.ceil(n / 65536);\n                        i = new WebAssembly.Memory({\n                            initial: l,\n                            maximum: l\n                        }).buffer;\n                    } else throw d;\n                }\n                let a = 0;\n                for(;;){\n                    let { done: d, value: l } = await o.read();\n                    if (d) break;\n                    let p = l.byteLength;\n                    new Uint8Array(i, a, p).set(l), a += p;\n                }\n                return new Uint8Array(i, 0, n);\n            }\n        }\n        else return e1 instanceof Blob ? new Uint8Array(await e1.arrayBuffer()) : e1 instanceof Uint8Array ? e1 : new Uint8Array(e1);\n    };\n});\nvar om, im, Ka, ja, Rr, am, ue, et = U(()=>{\n    \"use strict\";\n    te();\n    om = [\n        \"V\",\n        \"I\",\n        \"W\",\n        \"E\",\n        \"F\"\n    ], im = (e1, t)=>{\n        console.log(`[${om[e1]},${new Date().toISOString()}]${t}`);\n    }, Rr = (e1, t)=>{\n        Ka = e1, ja = t;\n    }, am = (e1, t)=>{\n        let r = Zt(e1), n = Zt(Ka);\n        r >= n && im(r, typeof t == \"function\" ? t() : t);\n    }, ue = (...e1)=>{\n        ja && am(...e1);\n    };\n});\nvar Ur, Jn = U(()=>{\n    \"use strict\";\n    te();\n    Ur = (e1, t)=>new (Dr(t))(e1);\n});\nvar Nr = U(()=>{\n    \"use strict\";\n});\nvar Ya, eo, to, sm, um, Za, no, ro, Xa, Ja = U(()=>{\n    \"use strict\";\n    et();\n    Nr();\n    Ya = new Map([\n        [\n            64,\n            250\n        ],\n        [\n            128,\n            200\n        ],\n        [\n            256,\n            200\n        ],\n        [\n            512,\n            200\n        ],\n        [\n            2048,\n            230\n        ],\n        [\n            4096,\n            200\n        ],\n        [\n            8192,\n            50\n        ],\n        [\n            16384,\n            50\n        ],\n        [\n            32768,\n            50\n        ],\n        [\n            65536,\n            50\n        ],\n        [\n            131072,\n            50\n        ],\n        [\n            262144,\n            50\n        ],\n        [\n            524288,\n            50\n        ],\n        [\n            1048576,\n            50\n        ],\n        [\n            2097152,\n            30\n        ],\n        [\n            4194304,\n            20\n        ],\n        [\n            8388608,\n            10\n        ],\n        [\n            12582912,\n            10\n        ],\n        [\n            16777216,\n            10\n        ],\n        [\n            26214400,\n            15\n        ],\n        [\n            33554432,\n            22\n        ],\n        [\n            44236800,\n            2\n        ],\n        [\n            58982400,\n            6\n        ],\n        [\n            67108864,\n            6\n        ],\n        [\n            134217728,\n            6\n        ],\n        [\n            167772160,\n            6\n        ]\n    ]), eo = [], to = (e1)=>Math.ceil(Number(e1) / 16) * 16, sm = (e1)=>{\n        for(let t = 0; t < eo.length; t++){\n            let r = eo[t];\n            if (e1 <= r) return r;\n        }\n        return Math.ceil(e1 / 16) * 16;\n    }, um = 1, Za = ()=>um++, no = async (e1, t, r, n)=>{\n        let o = to(r), i = e1.device.createBuffer({\n            size: o,\n            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n        });\n        try {\n            let a = e1.getCommandEncoder();\n            e1.endComputePass(), a.copyBufferToBuffer(t, 0, i, 0, o), e1.flush(), await i.mapAsync(GPUMapMode.READ);\n            let d = i.getMappedRange();\n            if (n) {\n                let l = n();\n                return l.set(new Uint8Array(d, 0, r)), l;\n            } else return new Uint8Array(d.slice(0, r));\n        } finally{\n            i.destroy();\n        }\n    }, ro = class {\n        constructor(t){\n            this.backend = t;\n            this.storageCache = new Map, this.freeBuffers = new Map, this.freeUniformBuffers = new Map, this.buffersPending = [], this.capturedPendingBuffers = new Map;\n            for (let [r] of Ya)eo.push(r), this.freeBuffers.set(r, []), this.freeUniformBuffers.set(r, []);\n            this.sessionCount = 0;\n        }\n        upload(t, r) {\n            let n = r.buffer, o = r.byteOffset, i = r.byteLength, a = to(i), d = this.storageCache.get(t);\n            if (!d) throw new Error(\"gpu data for uploading does not exist\");\n            if (Number(d.originalSize) !== i) throw new Error(`inconsistent data size. gpu data size=${d.originalSize}, data size=${i}`);\n            let l = this.backend.device.createBuffer({\n                mappedAtCreation: !0,\n                size: a,\n                usage: GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC\n            }), p = l.getMappedRange();\n            new Uint8Array(p).set(new Uint8Array(n, o, i)), l.unmap();\n            let m = this.backend.device.createCommandEncoder();\n            m.copyBufferToBuffer(l, 0, d.gpuData.buffer, 0, a), this.backend.device.queue.submit([\n                m.finish()\n            ]), l.destroy(), ue(\"verbose\", ()=>`[WebGPU] GpuDataManager.upload(id=${t})`);\n        }\n        memcpy(t, r) {\n            let n = this.storageCache.get(t);\n            if (!n) throw new Error(\"source gpu data for memcpy does not exist\");\n            let o = this.storageCache.get(r);\n            if (!o) throw new Error(\"destination gpu data for memcpy does not exist\");\n            if (n.originalSize !== o.originalSize) throw new Error(\"inconsistent source and destination gpu data size\");\n            let i = to(n.originalSize), a = this.backend.getCommandEncoder();\n            this.backend.endComputePass(), a.copyBufferToBuffer(n.gpuData.buffer, 0, o.gpuData.buffer, 0, i);\n        }\n        registerExternalBuffer(t, r, n) {\n            let o;\n            if (n) {\n                if (o = n[0], t === n[1]) return ue(\"verbose\", ()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${o}, buffer is the same, skip.`), o;\n                if (this.backend.capturedCommandList.has(this.backend.currentSessionId)) throw new Error(`Registering a different external buffer under graph capture mode is not supported yet.\n             Please use the previous external buffer!`);\n            } else o = Za();\n            return this.storageCache.set(o, {\n                gpuData: {\n                    id: o,\n                    type: 0,\n                    buffer: t\n                },\n                originalSize: r\n            }), ue(\"verbose\", ()=>`[WebGPU] GpuDataManager.registerExternalBuffer(size=${r}) => id=${o}, registered.`), o;\n        }\n        unregisterExternalBuffer(t) {\n            t !== void 0 && (this.storageCache.delete(t), ue(\"verbose\", ()=>`[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=${t}`));\n        }\n        create(t, r = GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST) {\n            let n = sm(t), o, i = (r & GPUBufferUsage.STORAGE) === GPUBufferUsage.STORAGE, a = (r & GPUBufferUsage.UNIFORM) === GPUBufferUsage.UNIFORM;\n            if (i || a) {\n                let p = (i ? this.freeBuffers : this.freeUniformBuffers).get(n);\n                p ? p.length > 0 ? o = p.pop() : o = this.backend.device.createBuffer({\n                    size: n,\n                    usage: r\n                }) : o = this.backend.device.createBuffer({\n                    size: n,\n                    usage: r\n                });\n            } else o = this.backend.device.createBuffer({\n                size: n,\n                usage: r\n            });\n            let d = {\n                id: Za(),\n                type: 0,\n                buffer: o\n            };\n            return this.storageCache.set(d.id, {\n                gpuData: d,\n                originalSize: Number(t)\n            }), ue(\"verbose\", ()=>`[WebGPU] GpuDataManager.create(size=${t}) => id=${d.id}`), d;\n        }\n        get(t) {\n            return this.storageCache.get(t)?.gpuData;\n        }\n        release(t) {\n            let r = typeof t == \"bigint\" ? Number(t) : t, n = this.storageCache.get(r);\n            if (!n) {\n                if (this.storageCache.size === 0) return 0;\n                throw new Error(\"releasing data does not exist\");\n            }\n            return ue(\"verbose\", ()=>`[WebGPU] GpuDataManager.release(id=${r}), gpuDataId=${n.gpuData.id}`), this.storageCache.delete(r), this.buffersPending.push(n.gpuData.buffer), n.originalSize;\n        }\n        async download(t, r) {\n            let n = this.storageCache.get(Number(t));\n            if (!n) throw new Error(\"data does not exist\");\n            await no(this.backend, n.gpuData.buffer, n.originalSize, r);\n        }\n        refreshPendingBuffers() {\n            if (this.buffersPending.length !== 0) if (this.backend.sessionStatus === \"default\") {\n                for (let t of this.buffersPending){\n                    let r = Ya.get(t.size);\n                    if ((t.usage & GPUBufferUsage.STORAGE) === GPUBufferUsage.STORAGE) {\n                        let n = this.freeBuffers.get(t.size) || [];\n                        r === void 0 || n.length >= r ? t.destroy() : n.push(t);\n                    } else if ((t.usage & GPUBufferUsage.UNIFORM) === GPUBufferUsage.UNIFORM) {\n                        let n = this.freeUniformBuffers.get(t.size) || [];\n                        r === void 0 || n.length >= r ? t.destroy() : n.push(t);\n                    } else t.destroy();\n                }\n                this.buffersPending = [];\n            } else {\n                let t = this.capturedPendingBuffers.get(this.backend.currentSessionId);\n                t || (t = [], this.capturedPendingBuffers.set(this.backend.currentSessionId, t));\n                for (let r of this.buffersPending)t.push(r);\n                this.buffersPending = [];\n            }\n        }\n        dispose() {\n            this.freeBuffers.forEach((t)=>{\n                t.forEach((r)=>{\n                    r.destroy();\n                });\n            }), this.freeUniformBuffers.forEach((t)=>{\n                t.forEach((r)=>{\n                    r.destroy();\n                });\n            }), this.storageCache.forEach((t)=>{\n                t.gpuData.buffer.destroy();\n            }), this.capturedPendingBuffers.forEach((t)=>{\n                t.forEach((r)=>{\n                    r.destroy();\n                });\n            }), this.storageCache = new Map, this.freeBuffers = new Map, this.freeUniformBuffers = new Map, this.capturedPendingBuffers = new Map;\n        }\n        onCreateSession() {\n            this.sessionCount += 1;\n        }\n        onReleaseSession(t) {\n            let r = this.capturedPendingBuffers.get(t);\n            r && (r.forEach((n)=>{\n                n.destroy();\n            }), this.capturedPendingBuffers.delete(t)), this.sessionCount -= 1, this.sessionCount === 0 && (ue(\"warning\", ()=>\"[WebGPU] Clearing webgpu buffer cache\"), this.storageCache.forEach((n)=>{\n                n.gpuData.buffer.destroy();\n            }), this.storageCache = new Map);\n        }\n    }, Xa = (...e1)=>new ro(...e1);\n});\nvar oo, re, Se = U(()=>{\n    \"use strict\";\n    oo = class {\n        constructor(t){\n            Object.assign(this, t);\n        }\n        get cacheKey() {\n            return this.key || (this.key = Object.getOwnPropertyNames(this).sort().map((t)=>`${this[t]}`).join(\";\")), this.key;\n        }\n    }, re = (e1)=>new oo(e1);\n});\nvar io, tt, C, At, Vr, es, ts, oe = U(()=>{\n    \"use strict\";\n    io = class {\n        static calcMatMulShape(t, r) {\n            return t[1] !== r[0] ? void 0 : [\n                t[0],\n                r[1]\n            ];\n        }\n    }, tt = class {\n        static calcShape(t, r, n = !1) {\n            let o = t.length, i = r.length;\n            if (o === 0) return r;\n            if (i === 0) return t;\n            let a = Math.max(t.length, r.length), d = new Array(a);\n            if (n) {\n                if (o < 2 || i < 2) return;\n                let l = io.calcMatMulShape([\n                    t[o - 2],\n                    t[o - 1]\n                ], [\n                    r[i - 2],\n                    r[i - 1]\n                ]);\n                if (l === void 0) return;\n                [d[a - 2], d[a - 1]] = l;\n            }\n            for(let l = n ? 3 : 1; l <= a; l++){\n                let p = o - l < 0 ? 1 : t[o - l], m = i - l < 0 ? 1 : r[i - l];\n                if (p !== m && p > 1 && m > 1) return;\n                let u = Math.max(p, m);\n                if (p && m) d[a - l] = Math.max(p, m);\n                else {\n                    if (u > 1) return;\n                    d[a - l] = 0;\n                }\n            }\n            return d;\n        }\n        static isValidBroadcast(t, r) {\n            let n = t.length, o = r.length;\n            if (n > o) return !1;\n            for(let i = 1; i <= n; i++)if (t[n - i] !== 1 && t[n - i] !== r[o - i]) return !1;\n            return !0;\n        }\n    }, C = class e1 {\n        static size(t) {\n            return e1.getSizeFromDimensionRange(t, 0, t.length);\n        }\n        static convertShape(t, r = 4) {\n            let n = t.length;\n            if (n === 0) return [];\n            let o = new Array(n), i = n - 1;\n            for(; i >= 0;){\n                if (t[i] % r === 0) {\n                    o[i] = t[i] / r;\n                    break;\n                }\n                if (r % t[i] !== 0) throw new Error(\"cannot convert shape\");\n                o[i] = 1, r /= t[i], i--;\n            }\n            for(i--; i >= 0; i--)o[i] = t[i];\n            return o;\n        }\n        static sizeFromDimension(t, r) {\n            if (r < 0 || r > t.length) throw new Error(`invalid dimension of ${r} for sizeFromDimension as Tensor has ${t.length} dimensions.`);\n            return e1.getSizeFromDimensionRange(t, r, t.length);\n        }\n        static sizeToDimension(t, r) {\n            if (r < 0 || r > t.length) throw new Error(`invalid dimension of ${r} for sizeToDimension as Tensor has ${t.length} dimensions.`);\n            return e1.getSizeFromDimensionRange(t, 0, r);\n        }\n        static getSizeFromDimensionRange(t, r, n) {\n            let o = 1;\n            for(let i = r; i < n; i++){\n                if (t[i] < 0) throw new Error(\"cannot get valid size from specified dimension range. Most likely the range contains negative values in them.\");\n                o *= Number(t[i]);\n            }\n            return o;\n        }\n        static computeStrides(t) {\n            let r = t.length;\n            if (r === 0) return [];\n            if (r === 1) return [\n                1\n            ];\n            let n = new Array(r);\n            n[r - 1] = 1, n[r - 2] = t[r - 1];\n            for(let o = r - 3; o >= 0; --o)n[o] = n[o + 1] * t[o + 1];\n            return n;\n        }\n        static normalizeAxis(t, r) {\n            if (t < -r && t >= r) throw new Error(\"unsupported axis for this operation.\");\n            return t < 0 ? t + r : t;\n        }\n        static normalizeAxes(t, r) {\n            return t.map((n)=>this.normalizeAxis(n, r ?? t.length));\n        }\n        static sortBasedOnPerm(t, r) {\n            return r ? r.map((n)=>t[n]) : t.slice().reverse();\n        }\n        static padShape(t, r) {\n            let n = t.length;\n            return t.map((o, i)=>o + r[i] + r[i + n]);\n        }\n        static areEqual(t, r) {\n            return t.length !== r.length ? !1 : t.every((n, o)=>n === r[o]);\n        }\n    }, At = class e1 {\n        static adjustPoolAttributes(t, r, n, o, i, a) {\n            if (!t && n.length !== r.length - 2) throw new Error(\"length of specified kernel shapes should be 2 less than length of input dimensions\");\n            if (t) for(let d = 0; d < r.length - 2; d++)d >= n.length ? n.push(r[d + 2]) : n[d] = r[d + 2];\n            for(let d = 0; d < n.length; d++)if (d < o.length) {\n                if (o[d] < 0) throw new Error(\"strides should be greater than or equal to 1\");\n            } else o.push(1);\n            for(let d = 0; d < n.length; d++)if (d < i.length) {\n                if (i[d] < 0) throw new Error(\"dilations should be greater than or equal to 1\");\n            } else i.push(1);\n            for(let d = 0; d < n.length * 2; d++)if (d < a.length) {\n                if (a[d] < 0) throw new Error(\"pad should be greater than or equal to 1\");\n            } else a.push(0);\n            for(let d = 0; d < n.length; d++){\n                if (n[d] <= 0) throw new Error(\"kernel shapes need to be greater than 0\");\n                if (a[d] >= n[d] || a[d + n.length] >= n[d]) throw new Error(\"pads should be smaller than kernel\");\n            }\n        }\n        static adjustPadsBasedOnAutoPad(t, r, n, o, i, a, d) {\n            if (d) {\n                if (i.length !== 2 * (t.length - 2)) throw new Error(\"length of pads should be twice the length of data dimensions\");\n                if (r.length !== t.length - 2) throw new Error(\"length of strides should be the length of data dimensions\");\n                if (o.length !== t.length - 2) throw new Error(\"length of kernel shapes should be the length of data dimensions\");\n                for(let l = 0; l < t.length - 2; l++)e1.adjustPadAndReturnShape(t[l + (a ? 1 : 2)], r[l], n[l], o[l], i, l, l + t.length - 2, d);\n            }\n        }\n        static computePoolOutputShape(t, r, n, o, i, a, d) {\n            if (r.length <= 0) throw new Error(\"input shape must be of size greater than 0\");\n            let l = [\n                r[0],\n                r[1]\n            ];\n            return e1.computeShapeHelper(t, r, l, n, o, i, a, d), l;\n        }\n        static computeConvOutputShape(t, r, n, o, i, a, d) {\n            if (t.length <= 0 || r.length <= 0) throw new Error(\"invalid input tensor dims or invalid filter tensor dims\");\n            let l = [\n                t[0],\n                r[0]\n            ];\n            return e1.computeShapeHelper(!1, t, l, n, o, i, a, d), l;\n        }\n        static computeShapeHelper(t, r, n, o, i, a, d, l) {\n            if (t) for(let p = 0; p < r.length - 2; p++)n.push(1);\n            else for(let p = 0; p < r.length - 2; p++)n.push(e1.adjustPadAndReturnShape(r[p + 2], o[p], i[p], a[p], d, p, p + r.length - 2, l));\n        }\n        static adjustPadAndReturnShape(t, r, n, o, i, a, d, l) {\n            let p = n * (o - 1) + 1;\n            if (l && l !== \"NOTSET\") switch(l){\n                case \"VALID\":\n                    return i[a] = 0, i[d] = 0, Math.floor((t - p) / r + 1);\n                case \"SAME_LOWER\":\n                case \"SAME_UPPER\":\n                    if (n !== 1) throw new Error(\"Dilation not supported for SAME_UPPER or SAME_LOWER\");\n                    {\n                        let u = ((t + r - 1) / r - 1) * r + o - t;\n                        return i[a] = Math.floor(l === \"SAME_LOWER\" ? (u + 1) / 2 : u / 2), i[d] = u - i[a], Math.floor((t + u - o) / r + 1);\n                    }\n                default:\n                    throw new Error(\"Unsupported AutoPad type\");\n            }\n            else return Math.floor((t + i[a] + i[d] - p) / r + 1);\n        }\n    }, Vr = class {\n        static getShapeOfGemmResult(t, r, n, o, i) {\n            if (t.length !== 2 || n.length !== 2) throw new Error(\"shape need to be of size 2\");\n            let a, d, l;\n            r ? (a = t[1], d = t[0]) : (a = t[0], d = t[1]);\n            let p = -1;\n            if (o ? (l = n[0], p = 1) : (l = n[1], p = 0), n[p] !== d) throw new Error(\"dimension mismatch\");\n            if (a <= 0 || l <= 0 || d <= 0) throw new Error(\"invalid shape specified\");\n            if (i && !tt.isValidBroadcast(i, [\n                a,\n                l\n            ])) throw new Error(\"gemm: invalid bias shape for broadcast\");\n            return [\n                a,\n                l,\n                d\n            ];\n        }\n    }, es = -34028234663852886e22, ts = 34028234663852886e22;\n});\nvar kt, so, _e, Ee, N, me, uo, Et, Fe, F, Wr, E, M, rs, Lr, ao, ns, ae = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    kt = 64, so = (e1, t)=>{\n        if (t === 3) throw new Error(\"vec3 has same alignment as vec4, use vec4 instead\");\n        switch(Number(e1)){\n            case 10:\n                return t > 1 ? `vec${t}<f16>` : \"f16\";\n            case 1:\n                return t > 1 ? `vec${t}<f32>` : \"f32\";\n            case 6:\n                return t > 1 ? `vec${t}<i32>` : \"i32\";\n            case 12:\n                return t > 1 ? `vec${t}<u32>` : \"u32\";\n            case 7:\n                if (t > 1) throw new Error(\"currently not supported vecX of uint64 yet\");\n                return [\n                    \"vec2<u32>\",\n                    \"i32\"\n                ];\n            case 13:\n                if (t > 1) throw new Error(\"currently not supported vecX of uint64 yet\");\n                return [\n                    \"vec2<u32>\",\n                    \"u32\"\n                ];\n            case 9:\n                if (t !== 4) throw new Error(\"bool must be vec4\");\n                return [\n                    \"u32\",\n                    \"vec4<bool>\"\n                ];\n            case 22:\n                return \"i32\";\n            case 21:\n                return \"u32\";\n            default:\n                throw new Error(`Unknown data type: ${e1}`);\n        }\n    }, _e = (e1, t = 1)=>{\n        let r = so(e1, t);\n        return typeof r == \"string\" ? r : r[0];\n    }, Ee = (e1, t = 1)=>{\n        let r = so(e1, t);\n        return typeof r == \"string\" ? r : r[1];\n    }, N = (...e1)=>{\n        let t = [];\n        return e1.forEach((r)=>{\n            r.length !== 0 && t.push({\n                type: 12,\n                data: r\n            }, {\n                type: 12,\n                data: C.computeStrides(r)\n            });\n        }), t;\n    }, me = (e1)=>e1 % 4 === 0 ? 4 : e1 % 2 === 0 ? 2 : 1, uo = (e1 = \"f32\", t, r = \"0\")=>!t || t === 1 ? `${e1}(${r})` : `vec${t}<${e1}>(${r})`, Et = (e1, t, r)=>e1 === \"f32\" ? r : t === 1 ? `f32(${r})` : `vec${t}<f32>(${r})`, Fe = (e1, t)=>t === 4 ? `(${e1}.x + ${e1}.y + ${e1}.z + ${e1}.w)` : t === 2 ? `(${e1}.x + ${e1}.y)` : t === 3 ? `(${e1}.x + ${e1}.y + ${e1}.z)` : e1, F = (e1, t, r, n)=>e1.startsWith(\"uniforms.\") && r > 4 ? typeof t == \"string\" ? n === \"f16\" ? `${e1}[(${t}) / 8][(${t}) % 8 / 4][(${t}) % 8 % 4]` : `${e1}[(${t}) / 4][(${t}) % 4]` : n === \"f16\" ? `${e1}[${Math.floor(t / 8)}][${Math.floor(t % 8 / 4)}][${t % 8 % 4}]` : `${e1}[${Math.floor(t / 4)}][${t % 4}]` : r > 1 ? `${e1}[${t}]` : e1, Wr = (e1, t, r, n, o)=>{\n        let i = typeof r == \"number\", a = i ? r : r.length, d = [\n            ...new Array(a).keys()\n        ], l = a < 2 ? \"u32\" : a <= 4 ? `vec${a}<u32>` : `array<u32, ${a}>`, p = so(t, o), m = typeof p == \"string\" ? p : p[1], u = typeof p == \"string\" ? p : p[0], h = {\n            indices: l,\n            value: m,\n            storage: u,\n            tensor: t\n        }, _ = (W)=>typeof W == \"string\" ? W : `${W}u`, y = {\n            offsetToIndices: !1,\n            indicesToOffset: !1,\n            broadcastedIndicesToOffset: !1,\n            set: !1,\n            setByIndices: !1,\n            get: !1,\n            getByIndices: !1\n        }, g = i ? \"uniforms.\" : \"\", x = `${g}${e1}_shape`, $ = `${g}${e1}_strides`, v = \"\";\n        for(let W = 0; W < a - 1; W++)v += `\n    let dim${W} = current / ${F($, W, a)};\n    let rest${W} = current % ${F($, W, a)};\n    indices[${W}] = dim${W};\n    current = rest${W};\n    `;\n        v += `indices[${a - 1}] = current;`;\n        let S = a < 2 ? \"\" : `\n  fn o2i_${e1}(offset: u32) -> ${h.indices} {\n    var indices: ${h.indices};\n    var current = offset;\n    ${v}\n    return indices;\n  }`, T = (W)=>(y.offsetToIndices = !0, a < 2 ? W : `o2i_${e1}(${W})`), A = [];\n        if (a >= 2) for(let W = a - 1; W >= 0; W--)A.push(`${F($, W, a)} * (indices[${W}])`);\n        let k = a < 2 ? \"\" : `\n  fn i2o_${e1}(indices: ${h.indices}) -> u32 {\n    return ${A.join(\"+\")};\n  }`, P = (W)=>(y.indicesToOffset = !0, a < 2 ? W : `i2o_${e1}(${W})`), D = (...W)=>a === 0 ? \"0u\" : `${h.indices}(${W.map(_).join(\",\")})`, R = (W, q)=>a < 2 ? `${W}` : `${F(W, q, a)}`, G = (W, q, he)=>a < 2 ? `${W}=${he};` : `${F(W, q, a)}=${he};`, K = {}, j = (W, q)=>{\n            y.broadcastedIndicesToOffset = !0;\n            let he = `${q.name}broadcastedIndicesTo${e1}Offset`;\n            if (he in K) return `${he}(${W})`;\n            let Ge = [];\n            for(let we = a - 1; we >= 0; we--){\n                let ye = q.indicesGet(\"outputIndices\", we + q.rank - a);\n                Ge.push(`${R($, we)} * (${ye} % ${R(x, we)})`);\n            }\n            return K[he] = `fn ${he}(outputIndices: ${q.type.indices}) -> u32 {\n             return ${Ge.length > 0 ? Ge.join(\"+\") : \"0u\"};\n           }`, `${he}(${W})`;\n        }, V = (W, q)=>(()=>{\n                if (h.storage === h.value) return `${e1}[${W}]=${q};`;\n                if (h.storage === \"vec2<u32>\" && h.value === \"i32\") return `${e1}[${W}]=vec2<u32>(u32(${q}), select(0u, 0xFFFFFFFFu, ${q} < 0));`;\n                if (h.storage === \"vec2<u32>\" && h.value === \"u32\") return `${e1}[${W}]=vec2<u32>(u32(${q}), 0u);`;\n                if (h.storage === \"u32\" && h.value === \"vec4<bool>\") return `${e1}[${W}]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(${q}));`;\n                throw new Error(`not supported combination of storage type ${h.storage} and value type ${h.value} yet`);\n            })(), Q = (W)=>(()=>{\n                if (h.storage === h.value) return `${e1}[${W}]`;\n                if (h.storage === \"vec2<u32>\" && h.value === \"i32\") return `i32(${e1}[${W}].x)`;\n                if (h.storage === \"vec2<u32>\" && h.value === \"u32\") return `u32(${e1}[${W}].x)`;\n                if (h.storage === \"u32\" && h.value === \"vec4<bool>\") return `vec4<bool>(bool(${e1}[${W}] & 0xFFu), bool(${e1}[${W}] & 0xFF00u), bool(${e1}[${W}] & 0xFF0000u), bool(${e1}[${W}] & 0xFF000000u))`;\n                throw new Error(`not supported combination of storage type ${h.storage} and value type ${h.value} yet`);\n            })(), se = a < 2 ? \"\" : `\n  fn get_${e1}ByIndices(indices: ${h.indices}) -> ${m} {\n    return ${Q(`i2o_${e1}(indices)`)};\n  }`, Y = a < 2 ? \"\" : (()=>{\n            let W = d.map((he)=>`d${he}: u32`).join(\", \"), q = d.map((he)=>`d${he}`).join(\", \");\n            return `\n  fn get_${e1}(${W}) -> ${m} {\n    return get_${e1}ByIndices(${D(q)});\n  }`;\n        })(), ee = (...W)=>{\n            if (W.length !== a) throw new Error(`indices length must be ${a}`);\n            let q = W.map(_).join(\",\");\n            return a === 0 ? Q(\"0u\") : a === 1 ? Q(q[0]) : (y.get = !0, y.getByIndices = !0, y.indicesToOffset = !0, `get_${e1}(${q})`);\n        }, J = (W)=>a < 2 ? Q(W) : (y.getByIndices = !0, y.indicesToOffset = !0, `get_${e1}ByIndices(${W})`), ne = a < 2 ? \"\" : `\n  fn set_${e1}ByIndices(indices: ${h.indices}, value: ${m}) {\n    ${V(`i2o_${e1}(indices)`, \"value\")}\n  }`, be = a < 2 ? \"\" : (()=>{\n            let W = d.map((he)=>`d${he}: u32`).join(\", \"), q = d.map((he)=>`d${he}`).join(\", \");\n            return `\n  fn set_${e1}(${W}, value: ${m}) {\n    set_${e1}ByIndices(${D(q)}, value);\n  }`;\n        })();\n        return {\n            impl: ()=>{\n                let W = [], q = !1;\n                return y.offsetToIndices && (W.push(S), q = !0), y.indicesToOffset && (W.push(k), q = !0), y.broadcastedIndicesToOffset && (Object.values(K).forEach((he)=>W.push(he)), q = !0), y.set && (W.push(be), q = !0), y.setByIndices && (W.push(ne), q = !0), y.get && (W.push(Y), q = !0), y.getByIndices && (W.push(se), q = !0), !i && q && W.unshift(`const ${x} = ${h.indices}(${r.join(\",\")});`, `const ${$} = ${h.indices}(${C.computeStrides(r).join(\",\")});`), W.join(`\n`);\n            },\n            type: h,\n            offsetToIndices: T,\n            indicesToOffset: P,\n            broadcastedIndicesToOffset: j,\n            indices: D,\n            indicesGet: R,\n            indicesSet: G,\n            set: (...W)=>{\n                if (W.length !== a + 1) throw new Error(`indices length must be ${a}`);\n                let q = W[a];\n                if (typeof q != \"string\") throw new Error(\"value must be string\");\n                let he = W.slice(0, a).map(_).join(\",\");\n                return a === 0 ? V(\"0u\", q) : a === 1 ? V(he[0], q) : (y.set = !0, y.setByIndices = !0, y.indicesToOffset = !0, `set_${e1}(${he}, ${q})`);\n            },\n            setByOffset: V,\n            setByIndices: (W, q)=>a < 2 ? V(W, q) : (y.setByIndices = !0, y.indicesToOffset = !0, `set_${e1}ByIndices(${W}, ${q});`),\n            get: ee,\n            getByOffset: Q,\n            getByIndices: J,\n            usage: n,\n            name: e1,\n            strides: $,\n            shape: x,\n            rank: a\n        };\n    }, E = (e1, t, r, n = 1)=>Wr(e1, t, r, \"input\", n), M = (e1, t, r, n = 1)=>Wr(e1, t, r, \"output\", n), rs = (e1, t, r)=>Wr(e1, t, r, \"atomicOutput\", 1), Lr = (e1, t, r, n = 1)=>Wr(e1, t, r, \"internal\", n), ao = class {\n        constructor(t, r){\n            this.normalizedDispatchGroup = t;\n            this.limits = r;\n            this.internalVariables = [];\n            this.variables = [];\n            this.uniforms = [];\n            this.variableIndex = 0;\n        }\n        guardAgainstOutOfBoundsWorkgroupSizes(t) {\n            return `if (global_idx >= ${typeof t == \"number\" ? `${t}u` : t}) { return; }`;\n        }\n        mainStart(t = kt) {\n            let r = typeof t == \"number\" ? t : t[0], n = typeof t == \"number\" ? 1 : t[1], o = typeof t == \"number\" ? 1 : t[2];\n            if (r > this.limits.maxComputeWorkgroupSizeX || n > this.limits.maxComputeWorkgroupSizeY || o > this.limits.maxComputeWorkgroupSizeZ) throw new Error(`workgroup size [${r}, ${n}, ${o}] exceeds the maximum workgroup size [${this.limits.maxComputeWorkgroupSizeX}, ${this.limits.maxComputeWorkgroupSizeY}, ${this.limits.maxComputeWorkgroupSizeZ}].`);\n            if (r * n * o > this.limits.maxComputeInvocationsPerWorkgroup) throw new Error(`workgroup size [${r}, ${n}, ${o}] exceeds the maximum workgroup invocations ${this.limits.maxComputeInvocationsPerWorkgroup}.`);\n            let i = this.normalizedDispatchGroup[1] === 1 && this.normalizedDispatchGroup[2] === 1, a = i ? `@builtin(global_invocation_id) global_id : vec3<u32>,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(local_invocation_index) local_idx : u32,\n    @builtin(local_invocation_id) local_id : vec3<u32>` : `@builtin(global_invocation_id) global_id : vec3<u32>,\n                                             @builtin(local_invocation_id) local_id : vec3<u32>,\n    @builtin(local_invocation_index) local_idx : u32,\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\n    @builtin(num_workgroups) num_workgroups : vec3<u32>`, d = i ? `let global_idx = global_id.x;\n         let workgroup_index = workgroup_id.x;` : `let workgroup_index = workgroup_id.z * num_workgroups[0] * num_workgroups[1] +\n             workgroup_id.y * num_workgroups[0] + workgroup_id.x;\n         let global_idx = workgroup_index * ${r * n * o}u + local_idx;`;\n            return `@compute @workgroup_size(${r}, ${n}, ${o})\n  fn main(${a}) {\n    ${d}\n  `;\n        }\n        appendVariableUniforms(t) {\n            t.rank !== 0 && (t.shape.startsWith(\"uniforms.\") && this.uniforms.push({\n                name: t.shape.replace(\"uniforms.\", \"\"),\n                type: \"u32\",\n                length: t.rank\n            }), t.strides.startsWith(\"uniforms.\") && this.uniforms.push({\n                name: t.strides.replace(\"uniforms.\", \"\"),\n                type: \"u32\",\n                length: t.rank\n            }));\n        }\n        declareVariable(t, r) {\n            if (t.usage === \"internal\") throw new Error(\"cannot use internal variable with declareVariable(). use registerInternalVariables() instead.\");\n            this.variables.push(t), this.appendVariableUniforms(t);\n            let n = t.usage === \"input\" ? \"read\" : \"read_write\", o = t.usage === \"atomicOutput\" ? \"atomic<i32>\" : t.type.storage;\n            return `@group(0) @binding(${r}) var<storage, ${n}> ${t.name}: array<${o}>;`;\n        }\n        declareVariables(...t) {\n            return t.map((r)=>this.declareVariable(r, this.variableIndex++)).join(`\n`);\n        }\n        registerInternalVariable(t) {\n            if (t.usage !== \"internal\") throw new Error(\"cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.\");\n            this.internalVariables.push(t), this.appendVariableUniforms(t);\n        }\n        registerInternalVariables(...t) {\n            return t.forEach((r)=>this.registerInternalVariable(r)), this;\n        }\n        registerUniform(t, r, n = 1) {\n            return this.uniforms.push({\n                name: t,\n                type: r,\n                length: n\n            }), this;\n        }\n        registerUniforms(t) {\n            return this.uniforms = this.uniforms.concat(t), this;\n        }\n        uniformDeclaration() {\n            if (this.uniforms.length === 0) return \"\";\n            let t = [];\n            for (let { name: r, type: n, length: o } of this.uniforms)if (o && o > 4) n === \"f16\" ? t.push(`@align(16) ${r}:array<mat2x4<${n}>, ${Math.ceil(o / 8)}>`) : t.push(`${r}:array<vec4<${n}>, ${Math.ceil(o / 4)}>`);\n            else {\n                let i = o == null || o === 1 ? n : `vec${o}<${n}>`;\n                t.push(`${r}:${i}`);\n            }\n            return `\n      struct Uniforms { ${t.join(\", \")} };\n      @group(0) @binding(${this.variableIndex}) var<uniform> uniforms: Uniforms;`;\n        }\n        get additionalImplementations() {\n            return this.uniformDeclaration() + this.variables.map((t)=>t.impl()).join(`\n`) + this.internalVariables.map((t)=>t.impl()).join(`\n`);\n        }\n        get variablesInfo() {\n            if (this.uniforms.length === 0) return;\n            let t = (r)=>[\n                    12,\n                    10,\n                    1,\n                    6\n                ][[\n                    \"u32\",\n                    \"f16\",\n                    \"f32\",\n                    \"i32\"\n                ].indexOf(r)];\n            return this.uniforms.map((r)=>[\n                    t(r.type),\n                    r.length ?? 1\n                ]);\n        }\n    }, ns = (e1, t)=>new ao(e1, t);\n});\nvar dm, os, lm, cm, pm, mm, Pe, is, as, dt = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    dm = (e1, t)=>{\n        if (!e1 || e1.length !== 1) throw new Error(\"Transpose requires 1 input.\");\n        if (t.length !== 0 && t.length !== e1[0].dims.length) throw new Error(`perm size ${t.length} does not match input rank ${e1[0].dims.length}`);\n    }, os = (e1, t)=>t.length !== 0 ? t : [\n            ...new Array(e1).keys()\n        ].reverse(), lm = (e1, t)=>C.sortBasedOnPerm(e1, os(e1.length, t)), cm = (e1, t, r, n)=>{\n        let o = `fn perm(i: ${n.type.indices}) -> ${r.type.indices} {\n    var a: ${r.type.indices};`;\n        for(let i = 0; i < t; ++i)o += `a[${e1[i]}]=i[${i}];`;\n        return o += \"return a;}\";\n    }, pm = (e1, t)=>{\n        let r = [], n = [];\n        for(let o = 0; o < e1.length; ++o)e1[o] !== 1 && r.push(e1[o]), e1[t[o]] !== 1 && n.push(t[o]);\n        return {\n            newShape: r,\n            newPerm: n\n        };\n    }, mm = (e1, t)=>{\n        let r = 0;\n        for(let n = 0; n < e1.length; ++n)if (t[e1[n]] !== 1) {\n            if (e1[n] < r) return !1;\n            r = e1[n];\n        }\n        return !0;\n    }, Pe = (e1, t)=>{\n        let r = e1.dataType, n = e1.dims.length, o = os(n, t), i = lm(e1.dims, o), a = e1.dims, d = i, l = n < 2 || mm(o, e1.dims), p;\n        if (l) return p = (g)=>{\n            let x = E(\"input\", r, a, 4), $ = M(\"output\", r, d, 4);\n            return `\n  ${g.registerUniform(\"output_size\", \"u32\").declareVariables(x, $)}\n  ${g.mainStart()}\n    ${g.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n    output[global_idx] = input[global_idx];\n  }`;\n        }, {\n            name: \"TransposeCopy\",\n            shaderCache: {\n                inputDependencies: [\n                    \"type\"\n                ]\n            },\n            getRunData: ()=>{\n                let g = C.size(i);\n                return {\n                    outputs: [\n                        {\n                            dims: i,\n                            dataType: e1.dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(g / 64 / 4)\n                    },\n                    programUniforms: [\n                        {\n                            type: 12,\n                            data: Math.ceil(g / 4)\n                        }\n                    ]\n                };\n            },\n            getShaderSource: p\n        };\n        let { newShape: m, newPerm: u } = pm(e1.dims, o), h = C.areEqual(u, [\n            2,\n            3,\n            1\n        ]), _ = C.areEqual(u, [\n            3,\n            1,\n            2\n        ]);\n        if (m.length === 2 || h || _) {\n            a = h ? [\n                m[0],\n                m[1] * m[2]\n            ] : _ ? [\n                m[0] * m[1],\n                m[2]\n            ] : m, d = [\n                a[1],\n                a[0]\n            ];\n            let g = 16;\n            return p = (x)=>{\n                let $ = E(\"a\", r, a.length), v = M(\"output\", r, d.length);\n                return `\n  ${x.registerUniform(\"output_size\", \"u32\").declareVariables($, v)}\n  var<workgroup> tile : array<array<${v.type.value}, ${g + 1}>, ${g}>;\n  ${x.mainStart([\n                    g,\n                    g,\n                    1\n                ])}\n    let stride = (uniforms.output_shape[1] - 1) / ${g} + 1;\n    let workgroup_id_x = workgroup_index % stride;\n    let workgroup_id_y = workgroup_index / stride;\n    let input_col = workgroup_id_y * ${g}u + local_id.x;\n    let input_row = workgroup_id_x * ${g}u + local_id.y;\n    if (input_row < uniforms.a_shape[0] && input_col < uniforms.a_shape[1]) {\n      tile[local_id.y][local_id.x] = ${$.getByIndices(`${$.type.indices}(input_row, input_col)`)};\n    }\n    workgroupBarrier();\n\n    let output_col = workgroup_id_x * ${g}u + local_id.x;\n    let output_row = workgroup_id_y * ${g}u + local_id.y;\n    if (output_row < uniforms.output_shape[0] && output_col < uniforms.output_shape[1]) {\n      ${v.setByIndices(`${v.type.indices}(output_row, output_col)`, \"tile[local_id.x][local_id.y]\")}\n    }\n  }`;\n            }, {\n                name: \"TransposeShared\",\n                shaderCache: {\n                    inputDependencies: [\n                        \"type\"\n                    ]\n                },\n                getRunData: ()=>{\n                    let x = C.size(i);\n                    return {\n                        outputs: [\n                            {\n                                dims: i,\n                                dataType: e1.dataType\n                            }\n                        ],\n                        dispatchGroup: {\n                            x: Math.ceil(d[1] / g),\n                            y: Math.ceil(d[0] / g)\n                        },\n                        programUniforms: [\n                            {\n                                type: 12,\n                                data: x\n                            },\n                            ...N(a, d)\n                        ]\n                    };\n                },\n                getShaderSource: p\n            };\n        }\n        return p = (g)=>{\n            let x = E(\"a\", r, a.length), $ = M(\"output\", r, d.length);\n            return `\n  ${g.registerUniform(\"output_size\", \"u32\").declareVariables(x, $)}\n\n  ${cm(o, n, x, $)}\n\n  ${g.mainStart()}\n    ${g.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n\n    let indices = ${$.offsetToIndices(\"global_idx\")};\n    let aIndices = perm(indices);\n\n    ${$.setByOffset(\"global_idx\", x.getByIndices(\"aIndices\"))}\n  }`;\n        }, {\n            name: \"Transpose\",\n            shaderCache: {\n                hint: `${t}`,\n                inputDependencies: [\n                    \"rank\"\n                ]\n            },\n            getRunData: ()=>{\n                let g = C.size(i);\n                return {\n                    outputs: [\n                        {\n                            dims: i,\n                            dataType: e1.dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(g / 64)\n                    },\n                    programUniforms: [\n                        {\n                            type: 12,\n                            data: g\n                        },\n                        ...N(a, d)\n                    ]\n                };\n            },\n            getShaderSource: p\n        };\n    }, is = (e1, t)=>{\n        dm(e1.inputs, t.perm), e1.compute(Pe(e1.inputs[0], t.perm));\n    }, as = (e1)=>re({\n            perm: e1.perm\n        });\n});\nvar fm, hm, gm, bm, ym, _m, wm, vm, $m, xm, rt, ss, us, ds, ls, cs, ps, ms, fs, hs, gs, bs = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    ae();\n    Gr();\n    dt();\n    fm = {\n        max: \"select(bestValue, candidate, candidate > bestValue)\",\n        min: \"select(bestValue, candidate, candidate < bestValue)\",\n        mean: \"bestValue + candidate\",\n        sum: \"bestValue + candidate\",\n        prod: \"bestValue * candidate\",\n        sumSquare: \"bestValue + candidate * candidate\",\n        logSumExp: \"bestValue + exp(candidate)\",\n        l1: \"bestValue + abs(candidate)\",\n        l2: \"bestValue + candidate * candidate\",\n        logSum: \"bestValue + candidate\"\n    }, hm = {\n        max: \"select(bestValue, candidate, candidate > bestValue)\",\n        min: \"select(bestValue, candidate, candidate < bestValue)\",\n        mean: \"bestValue + candidate\",\n        sum: \"bestValue + candidate\",\n        prod: \"bestValue * candidate\",\n        sumSquare: \"bestValue + candidate\",\n        logSumExp: \"bestValue + candidate\",\n        l1: \"bestValue + candidate\",\n        l2: \"bestValue + candidate\",\n        logSum: \"bestValue + candidate\"\n    }, gm = {\n        max: \"_A[offset]\",\n        min: \"_A[offset]\",\n        mean: \"0\",\n        sum: \"0\",\n        prod: \"1\",\n        sumSquare: \"0\",\n        logSumExp: \"0\",\n        l1: \"0\",\n        l2: \"0\",\n        logSum: \"0\"\n    }, bm = {\n        max: \"bestValue\",\n        min: \"bestValue\",\n        sum: \"bestValue\",\n        prod: \"bestValue\",\n        sumSquare: \"bestValue\",\n        logSumExp: \"log(bestValue)\",\n        l1: \"bestValue\",\n        l2: \"sqrt(bestValue)\",\n        logSum: \"log(bestValue)\"\n    }, ym = (e1, t)=>{\n        let r = [];\n        for(let n = t - e1; n < t; ++n)r.push(n);\n        return r;\n    }, _m = (e1, t)=>{\n        let r = [], n = e1.length;\n        for(let i = 0; i < n; i++)t.indexOf(i) === -1 && r.push(e1[i]);\n        let o = t.map((i)=>e1[i]);\n        return [\n            r,\n            o\n        ];\n    }, wm = (e1, t)=>{\n        let r = e1.length + t.length, n = [], o = 0;\n        for(let i = 0; i < r; i++)t.indexOf(i) === -1 ? n.push(e1[o++]) : n.push(1);\n        return n;\n    }, vm = (e1, t)=>{\n        for(let r = 0; r < e1.length; ++r)if (e1[e1.length - r - 1] !== t - 1 - r) return !1;\n        return !0;\n    }, $m = (e1, t)=>{\n        let r = [];\n        if (!vm(e1, t)) {\n            for(let n = 0; n < t; ++n)e1.indexOf(n) === -1 && r.push(n);\n            e1.forEach((n)=>r.push(n));\n        }\n        return r;\n    }, xm = (e1, t, r, n, o, i, a)=>{\n        let d = r[0].dims, l = C.size(i), p = C.size(a), m = E(\"_A\", r[0].dataType, d), u = M(\"output\", o, i), h = 64;\n        l === 1 && (h = 256);\n        let _ = `\n          var<workgroup> aBestValues : array<f32, ${h}>;\n       `, y = (g)=>`\n        ${g.registerUniform(\"reduceSize\", \"u32\").declareVariables(m, u)}\n        ${_}\n        fn DIV_CEIL(a : u32, b : u32) -> u32 {\n          return ((a - 1u) / b + 1u);\n         }\n         ${g.mainStart(h)}\n\n          let outputIndex = global_idx / ${h};\n          let offset = outputIndex * uniforms.reduceSize;\n\n          var bestValue = f32(${gm[n]});\n          let Length = uniforms.reduceSize;\n          for (var k = local_idx; k < Length; k = k + ${h}) {\n           let candidate = f32(${m.getByOffset(\"offset + k\")});\n           bestValue = ${fm[n]};\n          }\n          aBestValues[local_idx] = bestValue;\n          workgroupBarrier();\n\n         var reduceSize = min(Length, ${h}u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (local_idx < currentSize) {\n            let candidate = aBestValues[local_idx + interval];\n            bestValue = ${hm[n]};\n            aBestValues[local_idx] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (local_idx == 0u) {\n          ${u.setByOffset(\"outputIndex\", `${n === \"mean\" ? `${u.type.storage}(bestValue / f32(uniforms.reduceSize))` : `${u.type.storage}(${bm[n]})`}`)};\n         }\n        }`;\n        return {\n            name: e1,\n            shaderCache: {\n                hint: `${t};${h}`,\n                inputDependencies: [\n                    \"type\"\n                ]\n            },\n            getShaderSource: y,\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: i,\n                            dataType: o\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: l\n                    },\n                    programUniforms: [\n                        {\n                            type: 12,\n                            data: p\n                        }\n                    ]\n                })\n        };\n    }, rt = (e1, t, r, n)=>{\n        let o = e1.inputs.length === 1 ? r : lo(e1.inputs, r), i = o.axes;\n        i.length === 0 && !o.noopWithEmptyAxes && (i = e1.inputs[0].dims.map((_, y)=>y));\n        let a = C.normalizeAxes(i, e1.inputs[0].dims.length), d = a, l = e1.inputs[0], p = $m(d, e1.inputs[0].dims.length);\n        p.length > 0 && (l = e1.compute(Pe(e1.inputs[0], p), {\n            inputs: [\n                0\n            ],\n            outputs: [\n                -1\n            ]\n        })[0], d = ym(d.length, l.dims.length));\n        let [m, u] = _m(l.dims, d), h = m;\n        o.keepDims && (h = wm(m, a)), e1.compute(xm(t, o.cacheKey, [\n            l\n        ], n, e1.inputs[0].dataType, h, u), {\n            inputs: [\n                l\n            ]\n        });\n    }, ss = (e1, t)=>{\n        rt(e1, \"ReduceMeanShared\", t, \"mean\");\n    }, us = (e1, t)=>{\n        rt(e1, \"ReduceL1Shared\", t, \"l1\");\n    }, ds = (e1, t)=>{\n        rt(e1, \"ReduceL2Shared\", t, \"l2\");\n    }, ls = (e1, t)=>{\n        rt(e1, \"ReduceLogSumExpShared\", t, \"logSumExp\");\n    }, cs = (e1, t)=>{\n        rt(e1, \"ReduceMaxShared\", t, \"max\");\n    }, ps = (e1, t)=>{\n        rt(e1, \"ReduceMinShared\", t, \"min\");\n    }, ms = (e1, t)=>{\n        rt(e1, \"ReduceProdShared\", t, \"prod\");\n    }, fs = (e1, t)=>{\n        rt(e1, \"ReduceSumShared\", t, \"sum\");\n    }, hs = (e1, t)=>{\n        rt(e1, \"ReduceSumSquareShared\", t, \"sumSquare\");\n    }, gs = (e1, t)=>{\n        rt(e1, \"ReduceLogSumShared\", t, \"logSum\");\n    };\n});\nvar nt, Sm, Hr, lo, ot, Tm, Im, Cm, Am, km, Em, Pm, zm, Om, Dm, it, ys, _s, ws, vs, $s, xs, Ss, Ts, Is, Cs, Gr = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    bs();\n    nt = (e1)=>{\n        if (!e1 || e1.length === 0 || e1.length > 2) throw new Error(\"Reduce op requires 1 or 2 inputs.\");\n        if (e1.length === 2 && e1[1].dims.length !== 1) throw new Error(\"Invalid axes input dims.\");\n    }, Sm = (e1)=>[\n            \"\",\n            \"\",\n            `var value = ${e1.getByIndices(\"input_indices\")};`,\n            \"\"\n        ], Hr = (e1, t, r, n, o, i, a = !1, d = !1)=>{\n        let l = [], p = r[0].dims, m = p.length, u = C.normalizeAxes(o, m), h = !d && u.length === 0;\n        p.forEach((x, $)=>{\n            h || u.indexOf($) >= 0 ? a && l.push(1) : l.push(x);\n        });\n        let _ = l.length, y = C.size(l);\n        return {\n            name: e1,\n            shaderCache: t,\n            getShaderSource: (x)=>{\n                let $ = [], v = E(\"_A\", r[0].dataType, m), S = M(\"output\", i, _), T = n(v, S, u), A = T[2];\n                for(let k = 0, P = 0; k < m; k++)h || u.indexOf(k) >= 0 ? (a && P++, A = `for(var j${k}: u32 = 0; j${k} < ${p[k]}; j${k}++) {\n                  ${T[2].includes(\"last_index\") ? `let last_index = j${k};` : \"\"}\n                  ${v.indicesSet(\"input_indices\", k, `j${k}`)}\n                  ${A}\n                }`) : ($.push(`${v.indicesSet(\"input_indices\", k, S.indicesGet(\"output_indices\", P))};`), P++);\n                return `\n\n        ${x.registerUniform(\"output_size\", \"u32\").declareVariables(v, S)}\n\n        ${x.mainStart()}\n          ${x.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n          var input_indices: ${v.type.indices};\n          let output_indices = ${S.offsetToIndices(\"global_idx\")};\n\n          ${$.join(`\n`)}\n          ${T[0]}       // init ops for reduce max/min\n          ${T[1]}\n          ${A}\n          ${T[3]}\n          ${T.length === 4 ? S.setByOffset(\"global_idx\", \"value\") : T.slice(4).join(`\n`)}\n        }`;\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: l,\n                            dataType: i\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(y / 64)\n                    },\n                    programUniforms: [\n                        {\n                            type: 12,\n                            data: y\n                        },\n                        ...N(p, l)\n                    ]\n                })\n        };\n    }, lo = (e1, t)=>{\n        let r = [];\n        return e1[1].dims[0] > 0 && e1[1].getBigInt64Array().forEach((n)=>r.push(Number(n))), re({\n            axes: r,\n            keepDims: t.keepDims,\n            noopWithEmptyAxes: t.noopWithEmptyAxes\n        });\n    }, ot = (e1, t, r, n)=>{\n        let o = e1.inputs, i = o.length === 1 ? r : lo(o, r);\n        e1.compute(Hr(t, {\n            hint: i.cacheKey,\n            inputDependencies: [\n                \"rank\"\n            ]\n        }, [\n            o[0]\n        ], i.noopWithEmptyAxes && i.axes.length === 0 ? Sm : n, i.axes, o[0].dataType, i.keepDims, i.noopWithEmptyAxes), {\n            inputs: [\n                0\n            ]\n        });\n    }, Tm = (e1, t)=>{\n        nt(e1.inputs), ot(e1, \"ReduceLogSum\", t, (n, o)=>[\n                `var value = ${o.type.storage}(0);`,\n                \"\",\n                `value += ${n.getByIndices(\"input_indices\")};`,\n                \"value = log(value);\"\n            ]);\n    }, Im = (e1, t)=>{\n        nt(e1.inputs), ot(e1, \"ReduceL1\", t, (n, o)=>[\n                `var value = ${o.type.storage}(0);`,\n                \"\",\n                `value += abs(${n.getByIndices(\"input_indices\")});`,\n                \"\"\n            ]);\n    }, Cm = (e1, t)=>{\n        nt(e1.inputs), ot(e1, \"ReduceL2\", t, (n, o)=>[\n                `var t = ${o.type.value}(0); var value = ${o.type.value}(0);`,\n                \"\",\n                `t = ${n.getByIndices(\"input_indices\")}; value += (t * t);`,\n                \"value = sqrt(value);\"\n            ]);\n    }, Am = (e1, t)=>{\n        nt(e1.inputs), ot(e1, \"ReduceLogSumExp\", t, (n, o)=>[\n                `var value = ${o.type.storage}(0);`,\n                \"\",\n                `value += exp(${n.getByIndices(\"input_indices\")});`,\n                \"value = log(value);\"\n            ]);\n    }, km = (e1, t)=>{\n        nt(e1.inputs), ot(e1, \"ReduceMax\", t, (n, o, i)=>{\n            let a = [];\n            for(let d = 0; d < n.rank; d++)(i.indexOf(d) >= 0 || i.length === 0) && a.push(n.indicesSet(\"input_indices\", d, 0));\n            return [\n                `${a.join(`\n`)}`,\n                `var value = ${n.getByIndices(\"input_indices\")};`,\n                `value = max(value, ${n.getByIndices(\"input_indices\")});`,\n                \"\"\n            ];\n        });\n    }, Em = (e1, t)=>{\n        nt(e1.inputs), ot(e1, \"ReduceMean\", t, (n, o, i)=>{\n            let a = 1;\n            for(let d = 0; d < n.rank; d++)(i.indexOf(d) >= 0 || i.length === 0) && (a *= e1.inputs[0].dims[d]);\n            return [\n                \"var sum = f32(0);\",\n                \"\",\n                `sum += f32(${n.getByIndices(\"input_indices\")});`,\n                `let value = ${o.type.value}(sum / ${a});`\n            ];\n        });\n    }, Pm = (e1, t)=>{\n        nt(e1.inputs), ot(e1, \"ReduceMin\", t, (n, o, i)=>{\n            let a = [];\n            for(let d = 0; d < n.rank; d++)(i.indexOf(d) >= 0 || i.length === 0) && a.push(`input_indices[${d}] = 0;`);\n            return [\n                `${a.join(`\n`)}`,\n                `var value = ${n.getByIndices(\"input_indices\")};`,\n                `value = min(value, ${n.getByIndices(\"input_indices\")});`,\n                \"\"\n            ];\n        });\n    }, zm = (e1, t)=>{\n        nt(e1.inputs), ot(e1, \"ReduceProd\", t, (n, o)=>[\n                `var value = ${o.type.storage}(1);`,\n                \"\",\n                `value *= ${n.getByIndices(\"input_indices\")};`,\n                \"\"\n            ]);\n    }, Om = (e1, t)=>{\n        nt(e1.inputs), ot(e1, \"ReduceSum\", t, (n, o)=>[\n                `var value = ${o.type.storage}(0);`,\n                \"\",\n                `value += ${n.getByIndices(\"input_indices\")};`,\n                \"\"\n            ]);\n    }, Dm = (e1, t)=>{\n        nt(e1.inputs), ot(e1, \"ReduceSumSquare\", t, (n, o)=>[\n                `var t = ${o.type.value}(0); var value = ${o.type.value}(0);`,\n                \"\",\n                `t = ${n.getByIndices(\"input_indices\")}; value += t * t;`,\n                \"\"\n            ]);\n    }, it = (e1, t, r)=>{\n        if (t.length === 0) return r;\n        let n = 1, o = 1;\n        for(let i = 0; i < t.length; i++)t.indexOf(i) === -1 ? n *= e1[i] : o *= e1[i];\n        return o < 32 && n > 1024;\n    }, ys = (e1, t)=>{\n        it(e1.inputs[0].dims, t.axes, t.noopWithEmptyAxes) ? Em(e1, t) : ss(e1, t);\n    }, _s = (e1, t)=>{\n        it(e1.inputs[0].dims, t.axes, t.noopWithEmptyAxes) ? Im(e1, t) : us(e1, t);\n    }, ws = (e1, t)=>{\n        it(e1.inputs[0].dims, t.axes, t.noopWithEmptyAxes) ? Cm(e1, t) : ds(e1, t);\n    }, vs = (e1, t)=>{\n        it(e1.inputs[0].dims, t.axes, t.noopWithEmptyAxes) ? Am(e1, t) : ls(e1, t);\n    }, $s = (e1, t)=>{\n        it(e1.inputs[0].dims, t.axes, t.noopWithEmptyAxes) ? km(e1, t) : cs(e1, t);\n    }, xs = (e1, t)=>{\n        it(e1.inputs[0].dims, t.axes, t.noopWithEmptyAxes) ? Pm(e1, t) : ps(e1, t);\n    }, Ss = (e1, t)=>{\n        it(e1.inputs[0].dims, t.axes, t.noopWithEmptyAxes) ? zm(e1, t) : ms(e1, t);\n    }, Ts = (e1, t)=>{\n        it(e1.inputs[0].dims, t.axes, t.noopWithEmptyAxes) ? Om(e1, t) : fs(e1, t);\n    }, Is = (e1, t)=>{\n        it(e1.inputs[0].dims, t.axes, t.noopWithEmptyAxes) ? Dm(e1, t) : hs(e1, t);\n    }, Cs = (e1, t)=>{\n        it(e1.inputs[0].dims, t.axes, t.noopWithEmptyAxes) ? Tm(e1, t) : gs(e1, t);\n    };\n});\nvar As, ks, Es, co, Ps = U(()=>{\n    \"use strict\";\n    te();\n    Se();\n    Gr();\n    As = (e1)=>{\n        if (!e1 || e1.length === 0 || e1.length > 2) throw new Error(\"ArgMinMaxOp op requires 1 or 2 inputs.\");\n        if (e1[0].dataType !== 1) throw new Error(\"Invalid input type.\");\n    }, ks = (e1, t)=>{\n        As(e1.inputs);\n        let r = (n, o, i)=>{\n            let a = [];\n            for(let d = 0; d < n.rank; d++)(i.indexOf(d) >= 0 || i.length === 0) && a.push(`input_indices[${d}] = 0;`);\n            return [\n                `${a.join(`\n`)}`,\n                `var value = ${n.getByIndices(\"input_indices\")};\nvar best_index : i32 = 0;`,\n                `if (${n.getByIndices(\"input_indices\")} ${t.selectLastIndex > 0 ? \"<=\" : \"<\"} value) {\n         value = ${n.getByIndices(\"input_indices\")};\n         best_index = i32(last_index);\n       }`,\n                \"\",\n                o.setByOffset(\"global_idx\", \"best_index\")\n            ];\n        };\n        e1.compute(Hr(\"ArgMin\", {\n            hint: t.cacheKey,\n            inputDependencies: [\n                \"rank\"\n            ]\n        }, [\n            e1.inputs[0]\n        ], r, [\n            t.axis\n        ], 7, t.keepDims), {\n            inputs: [\n                0\n            ]\n        });\n    }, Es = (e1, t)=>{\n        As(e1.inputs);\n        let r = (n, o, i)=>{\n            let a = [];\n            for(let d = 0; d < n.rank; d++)(i.indexOf(d) >= 0 || i.length === 0) && a.push(`input_indices[${d}] = 0;`);\n            return [\n                `${a.join(`\n`)}`,\n                `var value = ${n.getByIndices(\"input_indices\")};\nvar best_index : i32 = 0;`,\n                `if (${n.getByIndices(\"input_indices\")} ${t.selectLastIndex > 0 ? \">=\" : \">\"} value) {\n         value = ${n.getByIndices(\"input_indices\")};\n         best_index = i32(last_index);\n       }`,\n                \"\",\n                o.setByOffset(\"global_idx\", \"best_index\")\n            ];\n        };\n        e1.compute(Hr(\"argMax\", {\n            hint: t.cacheKey,\n            inputDependencies: [\n                \"rank\"\n            ]\n        }, [\n            e1.inputs[0]\n        ], r, [\n            t.axis\n        ], 7, t.keepDims), {\n            inputs: [\n                0\n            ]\n        });\n    }, co = (e1)=>re(e1);\n});\nvar Bm, po, Mm, Rm, Um, Rt, Nm, zs, Fr = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Nr();\n    ae();\n    Bm = (e1, t)=>{\n        let r = e1[0], n = e1[1], o = e1[2], i = e1[3], a = e1[4], d = e1[5];\n        if (a && d) throw new Error(\"Attention cannot have both past and attention_bias\");\n        if (r.dims.length !== 3) throw new Error('Input \"input\" must have 3 dimensions');\n        let l = r.dims[0], p = r.dims[1], m = r.dims[2];\n        if (o.dims.length !== 1) throw new Error('Input \"bias\" is expected to have 1 dimensions');\n        if (n.dims.length !== 2) throw new Error('Input \"weights\" is expected to have 2 dimensions');\n        if (n.dims[0] !== m) throw new Error(\"Input 1 dimension 0 should have same length as dimension 2 of input 0\");\n        if (o.dims[0] !== n.dims[1]) throw new Error('Input \"bias\" dimension 0 should have same length as dimension 1 of input \"weights\"');\n        let u = o.dims[0] / 3, h = u, _ = h;\n        if (t.qkvHiddenSizes.length > 0) {\n            if (t.qkvHiddenSizes.length !== 3) throw new Error(\"qkv_hidden_sizes attribute should have 3 elements\");\n            for (let S of t.qkvHiddenSizes)if (S % t.numHeads !== 0) throw new Error(\"qkv_hidden_sizes should be divisible by num_heads\");\n            u = t.qkvHiddenSizes[0], h = t.qkvHiddenSizes[1], _ = t.qkvHiddenSizes[2];\n        }\n        let y = p;\n        if (u !== h) throw new Error(\"qkv_hidden_sizes first element should be same as the second\");\n        if (o.dims[0] !== u + h + _) throw new Error('Input \"bias\" dimension 0 should have same length as sum of Q/K/V hidden sizes');\n        let g = 0;\n        if (a) {\n            if (h !== _) throw new Error('Input \"past\" expect k_hidden_size == v_hidden_size');\n            if (a.dims.length !== 5) throw new Error('Input \"past\" must have 5 dimensions');\n            if (a.dims[0] !== 2) throw new Error('Input \"past\" first dimension must be 2');\n            if (a.dims[1] !== l) throw new Error('Input \"past\" second dimension must be batch_size');\n            if (a.dims[2] !== t.numHeads) throw new Error('Input \"past\" third dimension must be num_heads');\n            if (a.dims[4] !== h / t.numHeads) throw new Error('Input \"past\" fifth dimension must be k_hidden_size / num_heads');\n            t.pastPresentShareBuffer || (g = a.dims[3]);\n        }\n        let x = y + g, $ = -1, v = 0;\n        if (i) throw new Error(\"Mask not supported\");\n        if (a) throw new Error(\"past is not supported\");\n        if (d) {\n            if (d.dims.length !== 4) throw new Error('Input \"attention_bias\" must have 4 dimensions');\n            if (d.dims[0] !== l || d.dims[1] !== t.numHeads || d.dims[2] !== p || d.dims[3] !== x) throw new Error('Expect \"attention_bias\" shape (batch_size, num_heads, sequence_length, total_sequence_length)');\n        }\n        return {\n            batchSize: l,\n            sequenceLength: p,\n            pastSequenceLength: g,\n            kvSequenceLength: y,\n            totalSequenceLength: x,\n            maxSequenceLength: $,\n            inputHiddenSize: m,\n            hiddenSize: u,\n            vHiddenSize: _,\n            headSize: Math.floor(u / t.numHeads),\n            vHeadSize: Math.floor(_ / t.numHeads),\n            numHeads: t.numHeads,\n            isUnidirectional: !1,\n            pastPresentShareBuffer: !1,\n            maskFilterValue: t.maskFilterValue,\n            maskType: v,\n            scale: t.scale,\n            broadcastResPosBias: !1,\n            passPastInKv: !1,\n            qkvFormat: 1\n        };\n    }, po = (e1, t, r)=>t && e1 ? `\n      let total_sequence_length_input = u32(${t.getByOffset(\"0\")});\n      let present_sequence_length = max(total_sequence_length_input, uniforms.past_sequence_length);\n      let is_subsequent_prompt: bool = sequence_length > 1 && sequence_length != total_sequence_length_input;\n      let is_first_prompt: bool = is_subsequent_prompt == false && sequence_length == total_sequence_length_input;\n      total_sequence_length = u32(${e1?.getByOffset(\"batchIdx\")}) + 1;\n      var past_sequence_length: u32 = 0;\n      if (is_first_prompt == false) {\n        past_sequence_length = total_sequence_length - sequence_length;\n      }\n       ` : `\n    ${r ? \"let past_sequence_length = uniforms.past_sequence_length\" : \"\"};\n    let present_sequence_length = total_sequence_length;\n    `, Mm = (e1, t, r, n, o, i, a, d)=>{\n        let l = me(a ? 1 : i), p = 64, m = i / l;\n        m < p && (p = 32);\n        let u = Math.ceil(i / l / p), h = [\n            {\n                type: 12,\n                data: t\n            },\n            {\n                type: 12,\n                data: r\n            },\n            {\n                type: 12,\n                data: n\n            },\n            {\n                type: 12,\n                data: o\n            },\n            {\n                type: 12,\n                data: m\n            },\n            {\n                type: 12,\n                data: u\n            }\n        ], _ = _e(e1.dataType, l), y = Ee(1, l), g = [\n            \"type\"\n        ];\n        a && g.push(\"type\"), d && g.push(\"type\");\n        let x = ($)=>{\n            let v = M(\"x\", e1.dataType, e1.dims, l), S = [\n                v\n            ], T = a ? E(\"seq_lens\", a.dataType, a.dims) : void 0;\n            T && S.push(T);\n            let A = d ? E(\"total_sequence_length_input\", d.dataType, d.dims) : void 0;\n            A && S.push(A);\n            let k = Ee(e1.dataType), P = [\n                {\n                    name: \"batch_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"num_heads\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"past_sequence_length\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"sequence_length\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"total_sequence_length\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"elements_per_thread\",\n                    type: \"u32\"\n                }\n            ];\n            return `\n  var<workgroup> thread_max: array<f32, ${p}>;\n  var<workgroup> thread_sum: array<f32, ${p}>;\n  ${$.registerUniforms(P).declareVariables(...S)}\n  ${$.mainStart([\n                p,\n                1,\n                1\n            ])}\n    let batchIdx = workgroup_id.z / uniforms.num_heads;\n    let headIdx = workgroup_id.z % uniforms.num_heads;\n    let sequence_length = uniforms.sequence_length;\n    var total_sequence_length = uniforms.total_sequence_length;\n    ${po(T, A, !1)}\n    let local_offset = local_idx * uniforms.elements_per_thread;\n    let offset = (global_idx / ${p}) * uniforms.total_sequence_length + local_offset;\n    let seq_causal_length = ${a ? \"u32(past_sequence_length + workgroup_id.y + 1)\" : \"total_sequence_length\"};\n    var thread_max_vector = ${y}(-3.402823e+38f);\n    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n      thread_max_vector = max(${y}(x[offset + i]), thread_max_vector);\n    }\n    thread_max[local_idx] = ${(()=>{\n                switch(l){\n                    case 1:\n                        return \"thread_max_vector\";\n                    case 2:\n                        return \"max(thread_max_vector.x, thread_max_vector.y)\";\n                    case 4:\n                        return \"max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))\";\n                    default:\n                        throw new Error(`Unsupported components: ${l}`);\n                }\n            })()};\n    workgroupBarrier();\n\n    var max_value =  f32(-3.402823e+38f);\n    for (var i = 0u; i < ${p}; i++) {\n      max_value = max(thread_max[i], max_value);\n    }\n\n    var sum_vector = ${y}(0);\n    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n      sum_vector += exp(${y}(x[offset + i]) - max_value);\n    }\n    thread_sum[local_idx] = ${(()=>{\n                switch(l){\n                    case 1:\n                        return \"sum_vector\";\n                    case 2:\n                        return \"sum_vector.x + sum_vector.y\";\n                    case 4:\n                        return \"sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w\";\n                    default:\n                        throw new Error(`Unsupported components: ${l}`);\n                }\n            })()};\n    workgroupBarrier();\n\n    var sum: f32 = 0;\n    for (var i = 0u; i < ${p}; i++) {\n      sum += thread_sum[i];\n    }\n\n    if (sum == 0) {\n      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n        x[offset + i] = ${v.type.value}(${k}(1.0) / ${k}(seq_causal_length));\n      }\n    } else {\n      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\n        var f32input = ${y}(x[offset + i]);\n        x[offset + i] = ${v.type.value}(exp(f32input - max_value) / sum);\n      }\n    }\n      ${a ? `\n        for (var total_seq_id: u32 = seq_causal_length; total_seq_id + local_offset < uniforms.total_sequence_length; total_seq_id++) {\n          x[offset + total_seq_id] = ${v.type.value}(${k}(0));\n        }` : \"\"};\n  }`;\n        };\n        return {\n            name: \"AttentionProbsSoftmax\",\n            shaderCache: {\n                hint: `${p};${_};${l}`,\n                inputDependencies: g\n            },\n            getShaderSource: x,\n            getRunData: ()=>({\n                    outputs: [],\n                    dispatchGroup: {\n                        x: Math.ceil(i / p),\n                        y: o,\n                        z: t * r\n                    },\n                    programUniforms: h\n                })\n        };\n    }, Rm = (e1, t, r, n, o, i, a, d, l)=>{\n        let p = a + i.kvSequenceLength, m = [\n            i.batchSize,\n            i.numHeads,\n            i.sequenceLength,\n            p\n        ], u = e1 > 1 && n, h = i.kvNumHeads ? i.kvNumHeads : i.numHeads, _ = u ? [\n            i.batchSize,\n            h,\n            p,\n            i.headSize\n        ] : void 0, y = i.nReps ? i.nReps : 1, g = i.scale === 0 ? 1 / Math.sqrt(i.headSize) : i.scale, x = me(i.headSize), $ = i.headSize / x, v = 12, S = {\n            x: Math.ceil(p / v),\n            y: Math.ceil(i.sequenceLength / v),\n            z: i.batchSize * i.numHeads\n        }, T = [\n            {\n                type: 12,\n                data: i.sequenceLength\n            },\n            {\n                type: 12,\n                data: $\n            },\n            {\n                type: 12,\n                data: p\n            },\n            {\n                type: 12,\n                data: i.numHeads\n            },\n            {\n                type: 12,\n                data: i.headSize\n            },\n            {\n                type: 1,\n                data: g\n            },\n            {\n                type: 12,\n                data: a\n            },\n            {\n                type: 12,\n                data: i.kvSequenceLength\n            },\n            {\n                type: 12,\n                data: y\n            }\n        ], A = u && n && C.size(n.dims) > 0, k = [\n            \"type\",\n            \"type\"\n        ];\n        A && k.push(\"type\"), o && k.push(\"type\"), d && k.push(\"type\"), l && k.push(\"type\");\n        let P = [\n            {\n                dims: m,\n                dataType: t.dataType,\n                gpuDataType: 0\n            }\n        ];\n        u && P.push({\n            dims: _,\n            dataType: t.dataType,\n            gpuDataType: 0\n        });\n        let D = (R)=>{\n            let G = E(\"q\", t.dataType, t.dims, x), K = E(\"key\", r.dataType, r.dims, x), j = [\n                G,\n                K\n            ];\n            if (A) {\n                let ne = E(\"past_key\", n.dataType, n.dims, x);\n                j.push(ne);\n            }\n            o && j.push(E(\"attention_bias\", o.dataType, o.dims));\n            let V = d ? E(\"seq_lens\", d.dataType, d.dims) : void 0;\n            V && j.push(V);\n            let Q = l ? E(\"total_sequence_length_input\", l.dataType, l.dims) : void 0;\n            Q && j.push(Q);\n            let se = M(\"output\", t.dataType, m), Y = [\n                se\n            ];\n            u && Y.push(M(\"present_key\", t.dataType, _, x));\n            let ee = Ee(1, x), J = [\n                {\n                    name: \"M\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"K\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"N\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"num_heads\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"head_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"alpha\",\n                    type: \"f32\"\n                },\n                {\n                    name: \"past_sequence_length\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"kv_sequence_length\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"n_reps\",\n                    type: \"u32\"\n                }\n            ];\n            return `\n  const TILE_SIZE = ${v}u;\n\n  var<workgroup> tileQ: array<${G.type.storage}, ${v * v}>;\n  var<workgroup> tileK: array<${G.type.storage}, ${v * v}>;\n  ${R.registerUniforms(J).declareVariables(...j, ...Y)}\n  ${R.mainStart([\n                v,\n                v,\n                1\n            ])}\n    // x holds the N and y holds the M\n    let headIdx = workgroup_id.z % uniforms.num_heads;\n    let kvHeadIdx = ${y === 1 ? \"headIdx\" : \"headIdx / uniforms.n_reps\"};\n    let kv_num_heads = ${y === 1 ? \"uniforms.num_heads\" : \"uniforms.num_heads / uniforms.n_reps\"};\n    let batchIdx = workgroup_id.z / uniforms.num_heads;\n    let m = workgroup_id.y * TILE_SIZE;\n    let n = workgroup_id.x * TILE_SIZE;\n    let sequence_length = uniforms.M;\n    var total_sequence_length = uniforms.N;\n    ${po(V, Q, !0)}\n    let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx;\n    let qOffset = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;\n    ${A && u ? \"let pastKeyOffset = absKvHeadIdx * uniforms.past_sequence_length * uniforms.K;\" : \"\"};\n    let kOffset = absKvHeadIdx * uniforms.kv_sequence_length * uniforms.K;\n    ${u ? \"let presentKeyOffset = absKvHeadIdx * uniforms.N * uniforms.K;\" : \"\"}\n    var value = ${ee}(0);\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];\n      }\n      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {\n        var idx = TILE_SIZE * local_id.y + local_id.x;\n      ${(()=>A && u ? `\n              if (n + local_id.y < past_sequence_length) {\n                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];\n              } else if (n + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {\n                tileK[idx] = key[kOffset + (n + local_id.y - past_sequence_length) * uniforms.K + w + local_id.x];\n              }` : `\n          if (n + local_id.y < uniforms.kv_sequence_length) {\n            tileK[idx] = key[kOffset + (n + local_id.y) * uniforms.K + w + local_id.x];\n          }`)()}\n      ${u ? `if (n + local_id.y < present_sequence_length) {\n        present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];\n      }` : \"\"}\n      }\n      workgroupBarrier();\n\n      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {\n          value += ${ee}(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);\n      }\n\n      workgroupBarrier();\n    }\n\n    if (global_id.y < uniforms.M && global_id.x < total_sequence_length) {\n      let headOffset = workgroup_id.z * uniforms.M * uniforms.N;\n      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;\n      var sum: f32 = ${(()=>{\n                switch(x){\n                    case 1:\n                        return \"value\";\n                    case 2:\n                        return \"value.x + value.y\";\n                    case 4:\n                        return \"value.x + value.y + value.z + value.w\";\n                    default:\n                        throw new Error(`Unsupported components: ${x}`);\n                }\n            })()};\n        output[outputIdx] = ${se.type.value} (sum * uniforms.alpha) + ${o ? \"attention_bias[outputIdx]\" : \"0.0\"};\n    }\n  }`;\n        };\n        return {\n            name: \"AttentionProbs\",\n            shaderCache: {\n                hint: `${x};${o !== void 0};${n !== void 0};${e1}`,\n                inputDependencies: k\n            },\n            getRunData: ()=>({\n                    outputs: P,\n                    dispatchGroup: S,\n                    programUniforms: T\n                }),\n            getShaderSource: D\n        };\n    }, Um = (e1, t, r, n, o, i, a = void 0, d = void 0)=>{\n        let l = i + o.kvSequenceLength, p = o.nReps ? o.nReps : 1, m = o.vHiddenSize * p, u = e1 > 1 && n, h = o.kvNumHeads ? o.kvNumHeads : o.numHeads, _ = u ? [\n            o.batchSize,\n            h,\n            l,\n            o.headSize\n        ] : void 0, y = [\n            o.batchSize,\n            o.sequenceLength,\n            m\n        ], g = 12, x = {\n            x: Math.ceil(o.vHeadSize / g),\n            y: Math.ceil(o.sequenceLength / g),\n            z: o.batchSize * o.numHeads\n        }, $ = [\n            {\n                type: 12,\n                data: o.sequenceLength\n            },\n            {\n                type: 12,\n                data: l\n            },\n            {\n                type: 12,\n                data: o.vHeadSize\n            },\n            {\n                type: 12,\n                data: o.numHeads\n            },\n            {\n                type: 12,\n                data: o.headSize\n            },\n            {\n                type: 12,\n                data: m\n            },\n            {\n                type: 12,\n                data: i\n            },\n            {\n                type: 12,\n                data: o.kvSequenceLength\n            },\n            {\n                type: 12,\n                data: p\n            }\n        ], v = u && n && C.size(n.dims) > 0, S = [\n            \"type\",\n            \"type\"\n        ];\n        v && S.push(\"type\"), a && S.push(\"type\"), d && S.push(\"type\");\n        let T = [\n            {\n                dims: y,\n                dataType: t.dataType,\n                gpuDataType: 0\n            }\n        ];\n        u && T.push({\n            dims: _,\n            dataType: t.dataType,\n            gpuDataType: 0\n        });\n        let A = (k)=>{\n            let P = E(\"probs\", t.dataType, t.dims), D = E(\"v\", r.dataType, r.dims), R = [\n                P,\n                D\n            ];\n            v && R.push(E(\"past_value\", n.dataType, n.dims));\n            let G = a ? E(\"seq_lens\", a.dataType, a.dims) : void 0;\n            a && R.push(G);\n            let K = d ? E(\"total_sequence_length_input\", d.dataType, d.dims) : void 0;\n            d && R.push(K);\n            let V = [\n                M(\"output\", t.dataType, y)\n            ];\n            u && V.push(M(\"present_value\", t.dataType, _));\n            let Q = [\n                {\n                    name: \"M\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"K\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"N\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"num_heads\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"head_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"v_hidden_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"past_sequence_length\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"kv_sequence_length\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"n_reps\",\n                    type: \"u32\"\n                }\n            ];\n            return `\n  const TILE_SIZE = ${g}u;\n  var<workgroup> tileQ: array<${P.type.value}, ${g * g}>;\n  var<workgroup> tileV: array<${P.type.value}, ${g * g}>;\n  ${k.registerUniforms(Q).declareVariables(...R, ...V)}\n  ${k.mainStart([\n                g,\n                g,\n                1\n            ])}\n   let headIdx = workgroup_id.z % uniforms.num_heads;\n   let batchIdx = workgroup_id.z / uniforms.num_heads;\n   let kvHeadIdx = ${p === 1 ? \"headIdx\" : \"headIdx / uniforms.n_reps\"};\n   let kv_num_heads = ${p === 1 ? \"uniforms.num_heads\" : \"uniforms.num_heads / uniforms.n_reps\"};\n   let m = global_id.y;\n   let n = global_id.x;\n   let sequence_length = uniforms.M;\n   var total_sequence_length = uniforms.K;\n   ${po(G, K, !0)}\n   let offsetA = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;\n   let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx; // kvHeadIdx is relative to the batch\n   ${v && u ? \"let pastValueOffset = absKvHeadIdx * uniforms.N * uniforms.past_sequence_length + n;\" : \"\"};\n   let vOffset = absKvHeadIdx * uniforms.N * uniforms.kv_sequence_length + n;\n   ${u ? \"let presentValueOffset = absKvHeadIdx * uniforms.N * uniforms.K + n;\" : \"\"}\n   var value = ${P.type.storage}(0);\n   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (m < uniforms.M && w + local_id.x < uniforms.K) {\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];\n      }\n      if (n < uniforms.N && w + local_id.y < uniforms.K) {\n        var idx = TILE_SIZE * local_id.y + local_id.x;\n        ${(()=>v && u ? `\n        if (w + local_id.y < past_sequence_length) {\n          tileV[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];\n        } else if (w + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {\n          tileV[idx] = v[vOffset + (w + local_id.y - past_sequence_length) * uniforms.N];\n        }\n      ` : `\n            if (w + local_id.y < uniforms.kv_sequence_length) {\n              tileV[idx] = v[vOffset + (w + local_id.y) * uniforms.N];\n            }`)()}\n        ${u ? `\n            if (w + local_id.y < present_sequence_length) {\n          present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileV[idx];\n        }` : \"\"}\n      }\n     workgroupBarrier();\n     for (var k: u32 = 0u; k < TILE_SIZE && w+k < total_sequence_length; k++) {\n       value += tileQ[TILE_SIZE * local_id.y + k] * tileV[TILE_SIZE * k + local_id.x];\n     }\n     workgroupBarrier();\n   }\n\n   // we need to transpose output from BNSH_v to BSND_v\n   if (m < uniforms.M && n < uniforms.N) {\n     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size\n       + headIdx * uniforms.N + n;\n     output[outputIdx] = value;\n   }\n  }`;\n        };\n        return {\n            name: \"AttentionScore\",\n            shaderCache: {\n                hint: `${n !== void 0};${e1}`,\n                inputDependencies: S\n            },\n            getRunData: ()=>({\n                    outputs: T,\n                    dispatchGroup: x,\n                    programUniforms: $\n                }),\n            getShaderSource: A\n        };\n    }, Rt = (e1, t, r, n, o, i, a, d, l, p, m = void 0, u = void 0)=>{\n        let h = Math.min(e1.outputCount, 1 + (a ? 1 : 0) + (d ? 1 : 0)), _ = h > 1 ? p.pastSequenceLength : 0, y = _ + p.kvSequenceLength, g = l && C.size(l.dims) > 0 ? l : void 0, x = [\n            t,\n            r\n        ];\n        h > 1 && a && C.size(a.dims) > 0 && x.push(a), g && x.push(g), m && x.push(m), u && x.push(u);\n        let $ = e1.compute(Rm(h, t, r, a, g, p, _, m, u), {\n            inputs: x,\n            outputs: h > 1 ? [\n                -1,\n                1\n            ] : [\n                -1\n            ]\n        })[0];\n        e1.compute(Mm($, p.batchSize, p.numHeads, _, p.sequenceLength, y, m, u), {\n            inputs: m && u ? [\n                $,\n                m,\n                u\n            ] : [\n                $\n            ],\n            outputs: []\n        });\n        let v = [\n            $,\n            n\n        ];\n        h > 1 && d && C.size(d.dims) > 0 && v.push(d), m && v.push(m), u && v.push(u), e1.compute(Um(h, $, n, d, p, _, m, u), {\n            inputs: v,\n            outputs: h > 1 ? [\n                0,\n                2\n            ] : [\n                0\n            ]\n        });\n    }, Nm = (e1, t)=>{\n        let r = [\n            t.batchSize,\n            t.numHeads,\n            t.sequenceLength,\n            t.headSize\n        ], n = t.sequenceLength, o = t.inputHiddenSize, i = t.headSize, a = 12, d = {\n            x: Math.ceil(t.headSize / a),\n            y: Math.ceil(t.sequenceLength / a),\n            z: t.batchSize * t.numHeads\n        }, l = [\n            e1.inputs[0],\n            e1.inputs[1],\n            e1.inputs[2]\n        ], p = [\n            {\n                type: 12,\n                data: n\n            },\n            {\n                type: 12,\n                data: o\n            },\n            {\n                type: 12,\n                data: i\n            },\n            {\n                type: 12,\n                data: t.numHeads\n            },\n            {\n                type: 12,\n                data: t.headSize\n            },\n            {\n                type: 12,\n                data: t.hiddenSize\n            },\n            {\n                type: 12,\n                data: t.hiddenSize + t.hiddenSize + t.vHiddenSize\n            }\n        ], m = (u)=>{\n            let h = M(\"output_q\", l[0].dataType, r), _ = M(\"output_k\", l[0].dataType, r), y = M(\"output_v\", l[0].dataType, r), g = E(\"input\", l[0].dataType, l[0].dims), x = E(\"weight\", l[1].dataType, l[1].dims), $ = E(\"bias\", l[2].dataType, l[2].dims), v = g.type.storage, S = [\n                {\n                    name: \"M\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"K\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"N\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"num_heads\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"head_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"hidden_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"ldb\",\n                    type: \"u32\"\n                }\n            ];\n            return `\n  const TILE_SIZE = ${a}u;\n  var<workgroup> tileInput: array<${v}, ${a * a}>;\n  var<workgroup> tileWeightQ: array<${v}, ${a * a}>;\n  var<workgroup> tileWeightK: array<${v}, ${a * a}>;\n  var<workgroup> tileWeightV: array<${v}, ${a * a}>;\n  ${u.registerUniforms(S).declareVariables(g, x, $, h, _, y)}\n  ${u.mainStart([\n                a,\n                a,\n                1\n            ])}\n    let batchIndex = workgroup_id.z / uniforms.num_heads;\n    let headNumber = workgroup_id.z % uniforms.num_heads;\n    let m = global_id.y;\n    let n = global_id.x;\n\n    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;\n    let biasOffsetQ = headNumber * uniforms.head_size;\n    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;\n    let biasOffsetV = uniforms.hidden_size + biasOffsetK;\n\n    var valueQ = ${v}(0);\n    var valueK = ${v}(0);\n    var valueV = ${v}(0);\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\n      if (m < uniforms.M && w + local_id.x < uniforms.K) {\n        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];\n      }\n      if (n < uniforms.N && w + local_id.y < uniforms.K) {\n        let offset = n + (w + local_id.y) * uniforms.ldb;\n        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];\n        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];\n        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];\n      }\n      workgroupBarrier();\n      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {\n        let inputTileOffset = TILE_SIZE * local_id.y + k;\n        let weightTileOffset = TILE_SIZE * k + local_id.x;\n        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];\n        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];\n        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];\n      }\n\n      workgroupBarrier();\n    }\n\n    let headOffset = (m * uniforms.N + n) % uniforms.head_size;\n    valueQ += bias[headOffset + biasOffsetQ];\n    valueK += bias[headOffset + biasOffsetK];\n    valueV += bias[headOffset + biasOffsetV];\n\n    let offset = workgroup_id.z * uniforms.M * uniforms.N;\n    if (m < uniforms.M && n < uniforms.N) {\n      let outputIdx = offset + m * uniforms.N + n;\n      output_q[outputIdx] = valueQ;\n      output_k[outputIdx] = valueK;\n      output_v[outputIdx] = valueV;\n    }\n  }`;\n        };\n        return e1.compute({\n            name: \"AttentionPrepare\",\n            shaderCache: {\n                inputDependencies: [\n                    \"type\",\n                    \"type\",\n                    \"type\"\n                ]\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: r,\n                            dataType: e1.inputs[0].dataType,\n                            gpuDataType: 0\n                        },\n                        {\n                            dims: r,\n                            dataType: e1.inputs[0].dataType,\n                            gpuDataType: 0\n                        },\n                        {\n                            dims: r,\n                            dataType: e1.inputs[0].dataType,\n                            gpuDataType: 0\n                        }\n                    ],\n                    dispatchGroup: d,\n                    programUniforms: p\n                }),\n            getShaderSource: m\n        }, {\n            inputs: l,\n            outputs: [\n                -1,\n                -1,\n                -1\n            ]\n        });\n    }, zs = (e1, t)=>{\n        let r = Bm(e1.inputs, t), [n, o, i] = Nm(e1, r);\n        return Rt(e1, n, o, i, e1.inputs[4], void 0, void 0, void 0, e1.inputs[5], r);\n    };\n});\nvar Vm, Wm, Lm, Os, Ds = U(()=>{\n    \"use strict\";\n    We();\n    te();\n    oe();\n    Se();\n    ae();\n    Vm = (e1, t)=>{\n        if (!e1 || e1.length !== 5) throw new Error(\"BatchNormalization requires 5 inputs\");\n        let r = (n, o, i)=>{\n            let a = o.length;\n            if (a !== n.length) throw new Error(`${i}: num dimensions != ${a}`);\n            o.forEach((d, l)=>{\n                if (d !== n[l]) throw new Error(`${i}: dim[${l}] do not match`);\n            });\n        };\n        if (e1[0].dims.length > 1) {\n            let n = t.format === \"NHWC\" ? t.spatial ? e1[0].dims.slice(-1) : e1[0].dims.slice(-1).concat(e1[0].dims.slice(1, e1[0].dims.length - 1)) : e1[0].dims.slice(1, t.spatial ? 2 : void 0);\n            r(e1[1].dims, n, \"Invalid input scale\"), r(e1[2].dims, n, \"Invalid input B\"), r(e1[3].dims, n, \"Invalid input mean\"), r(e1[4].dims, n, \"Invalid input var\");\n        } else r(e1[1].dims, [\n            1\n        ], \"Invalid input scale\"), r(e1[2].dims, [\n            1\n        ], \"Invalid input B\"), r(e1[3].dims, [\n            1\n        ], \"Invalid input mean\"), r(e1[4].dims, [\n            1\n        ], \"Invalid input var\");\n    }, Wm = (e1, t)=>{\n        let { epsilon: r, spatial: n, format: o } = t, i = e1[0].dims, a = n ? me(i[i.length - 1]) : 1, d = o === \"NHWC\" && i.length > 1 ? a : 1, l = C.size(i) / a, p = n, m = p ? i.length : i, u = E(\"x\", e1[0].dataType, e1[0].dims, a), h = E(\"scale\", e1[1].dataType, e1[1].dims, d), _ = E(\"bias\", e1[2].dataType, e1[2].dims, d), y = E(\"inputMean\", e1[3].dataType, e1[3].dims, d), g = E(\"inputVar\", e1[4].dataType, e1[4].dims, d), x = M(\"y\", e1[0].dataType, m, a), $ = ()=>{\n            let S = \"\";\n            if (n) S = `let cOffset = ${i.length === 1 ? \"0u\" : o === \"NHWC\" ? `outputIndices[${i.length - 1}] / ${a}` : \"outputIndices[1]\"};`;\n            else if (o === \"NCHW\") S = `\n            ${x.indicesSet(\"outputIndices\", \"0\", \"0\")}\n            let cOffset = ${x.indicesToOffset(\"outputIndices\")};`;\n            else {\n                S = `var cIndices = ${h.type.indices}(0);\n                       cIndices[0] = outputIndices[${i.length - 1}];`;\n                for(let T = 1; T < h.rank; T++)S += `cIndices[${T}] = outputIndices[${T}];`;\n                S += `let cOffset = ${h.indicesToOffset(\"cIndices\")};`;\n            }\n            return S;\n        }, v = (S)=>`\n  const epsilon = ${r};\n  ${S.registerUniform(\"outputSize\", \"u32\").declareVariables(u, h, _, y, g, x)}\n  ${S.mainStart()}\n  ${S.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n    var outputIndices = ${x.offsetToIndices(`global_idx * ${a}`)};\n    ${$()}\n    let scale = ${h.getByOffset(\"cOffset\")};\n    let bias = ${_.getByOffset(\"cOffset\")};\n    let inputMean = ${y.getByOffset(\"cOffset\")};\n    let inputVar = ${g.getByOffset(\"cOffset\")};\n    let x = ${u.getByOffset(\"global_idx\")};\n    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;\n    ${x.setByOffset(\"global_idx\", \"value\")}\n  }`;\n        return {\n            name: \"BatchNormalization\",\n            shaderCache: {\n                hint: `${t.epsilon}_${t.format}_${n}_${a}`,\n                inputDependencies: p ? [\n                    \"rank\",\n                    \"type\",\n                    \"type\",\n                    \"type\",\n                    \"type\"\n                ] : void 0\n            },\n            getShaderSource: v,\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: e1[0].dims,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(l / 64)\n                    },\n                    programUniforms: p ? [\n                        {\n                            type: 12,\n                            data: l\n                        },\n                        ...N(i)\n                    ] : [\n                        {\n                            type: 12,\n                            data: l\n                        }\n                    ]\n                })\n        };\n    }, Lm = (e1)=>re(e1), Os = (e1, t)=>{\n        let { inputs: r, outputCount: n } = e1, o = Lm({\n            ...t,\n            outputCount: n\n        });\n        if (ve.webgpu.validateInputContent && Vm(r, o), t.trainingMode) throw new Error(\"BatchNormalization trainingMode is not supported yet.\");\n        e1.compute(Wm(r, o));\n    };\n});\nvar Gm, Hm, Bs, Ms = U(()=>{\n    \"use strict\";\n    oe();\n    ae();\n    Gm = (e1)=>{\n        if (e1[0].dims.length !== 3) throw new Error(\"input should have 3 dimensions\");\n        if (![\n            320,\n            640,\n            1280\n        ].includes(e1[0].dims[2])) throw new Error(\"number of channels should be 320, 640 or 1280\");\n        if (e1[1].dims.length !== 1) throw new Error(\"bias is expected to have 1 dimensions\");\n        if (e1[0].dims[2] !== e1[1].dims[0]) throw new Error(\"last dimension of input and bias are not the same\");\n    }, Hm = (e1)=>{\n        let t = e1[0].dims, r = e1[0].dims[2], n = C.size(t) / 4, o = e1[0].dataType, i = E(\"input\", o, t, 4), a = E(\"bias\", o, [\n            r\n        ], 4), d = E(\"residual\", o, t, 4), l = M(\"output\", o, t, 4);\n        return {\n            name: \"BiasAdd\",\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: t,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(n / 64)\n                    }\n                }),\n            getShaderSource: (m)=>`\n  const channels = ${r}u / 4;\n  ${m.declareVariables(i, a, d, l)}\n\n  ${m.mainStart()}\n    ${m.guardAgainstOutOfBoundsWorkgroupSizes(n)}\n    let value = ${i.getByOffset(\"global_idx\")}\n      + ${a.getByOffset(\"global_idx % channels\")} + ${d.getByOffset(\"global_idx\")};\n    ${l.setByOffset(\"global_idx\", \"value\")}\n  }`\n        };\n    }, Bs = (e1)=>{\n        Gm(e1.inputs), e1.compute(Hm(e1.inputs));\n    };\n});\nvar Fm, fe, Rs, Us, Ns, Vs, Ws, Ls, Gs, Hs, Fs, qm, qs, Ks, js, Ys, Xt, Zs, qr, Qs, Xs, Js, eu, tu, ru, nu, ou, iu, au, su, uu, du, lu, cu, pu, mu, fu, mo, fo, hu, gu, bu, Km, jm, yu, Kr = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    Fm = (e1, t, r, n, o, i, a)=>{\n        let d = Math.ceil(t / 4), l = \"\";\n        typeof o == \"string\" ? l = `${o}(a)` : l = o(\"a\");\n        let p = E(\"inputData\", r, [\n            d\n        ], 4), m = M(\"outputData\", n, [\n            d\n        ], 4), u = [\n            {\n                name: \"vec_size\",\n                type: \"u32\"\n            }\n        ];\n        return a && u.push(...a), `\n      ${e1.registerUniforms(u).declareVariables(p, m)}\n\n  ${i ?? \"\"}\n\n  ${e1.mainStart()}\n    ${e1.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.vec_size\")}\n\n    let a = ${p.getByOffset(\"global_idx\")};\n    ${m.setByOffset(\"global_idx\", l)}\n  }`;\n    }, fe = (e1, t, r, n, o, i = e1.dataType, a, d)=>{\n        let l = [\n            {\n                type: 12,\n                data: Math.ceil(C.size(e1.dims) / 4)\n            }\n        ];\n        return a && l.push(...a), {\n            name: t,\n            shaderCache: {\n                hint: o,\n                inputDependencies: [\n                    \"type\"\n                ]\n            },\n            getShaderSource: (p)=>Fm(p, C.size(e1.dims), e1.dataType, i, r, n, d),\n            getRunData: (p)=>({\n                    outputs: [\n                        {\n                            dims: e1.dims,\n                            dataType: i\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(C.size(p[0].dims) / 64 / 4)\n                    },\n                    programUniforms: l\n                })\n        };\n    }, Rs = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Abs\", \"abs\"));\n    }, Us = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Acos\", \"acos\"));\n    }, Ns = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Acosh\", \"acosh\"));\n    }, Vs = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Asin\", \"asin\"));\n    }, Ws = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Asinh\", \"asinh\"));\n    }, Ls = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Atan\", \"atan\"));\n    }, Gs = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Atanh\", \"atanh\"));\n    }, Hs = (e1)=>re(e1), Fs = (e1, t)=>{\n        let r;\n        switch(t.to){\n            case 10:\n                r = \"vec4<f16>\";\n                break;\n            case 1:\n                r = \"vec4<f32>\";\n                break;\n            case 12:\n                r = \"vec4<u32>\";\n                break;\n            case 6:\n                r = \"vec4<i32>\";\n                break;\n            case 9:\n                r = \"vec4<bool>\";\n                break;\n            default:\n                throw new RangeError(`not supported type (specified in attribute 'to' from 'Cast' operator): ${t.to}`);\n        }\n        e1.compute(fe(e1.inputs[0], \"Cast\", r, void 0, t.cacheKey, t.to));\n    }, qm = (e1)=>{\n        let t, r, n = e1.length >= 2 && e1[1].data !== 0, o = e1.length >= 3 && e1[2].data !== 0;\n        switch(e1[0].dataType){\n            case 1:\n                t = n ? e1[1].getFloat32Array()[0] : -34028234663852886e22, r = o ? e1[2].getFloat32Array()[0] : 34028234663852886e22;\n                break;\n            case 10:\n                t = n ? e1[1].getUint16Array()[0] : 64511, r = o ? e1[2].getUint16Array()[0] : 31743;\n                break;\n            default:\n                throw new Error(\"Unsupport data type\");\n        }\n        return re({\n            min: t,\n            max: r\n        });\n    }, qs = (e1, t)=>{\n        let r = t || qm(e1.inputs), n = Ee(e1.inputs[0].dataType);\n        e1.compute(fe(e1.inputs[0], \"Clip\", (o)=>`clamp(${o}, vec4<${n}>(uniforms.min), vec4<${n}>(uniforms.max))`, void 0, r.cacheKey, void 0, [\n            {\n                type: e1.inputs[0].dataType,\n                data: r.min\n            },\n            {\n                type: e1.inputs[0].dataType,\n                data: r.max\n            }\n        ], [\n            {\n                name: \"min\",\n                type: n\n            },\n            {\n                name: \"max\",\n                type: n\n            }\n        ]), {\n            inputs: [\n                0\n            ]\n        });\n    }, Ks = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Ceil\", \"ceil\"));\n    }, js = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Cos\", \"cos\"));\n    }, Ys = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Cosh\", \"cosh\"));\n    }, Xt = (e1)=>re(e1), Zs = (e1, t)=>{\n        let r = Ee(e1.inputs[0].dataType);\n        e1.compute(fe(e1.inputs[0], \"Elu\", (n)=>`elu_vf32(${n})`, `\n  const elu_alpha_ = ${r}(${t.alpha});\n\n  fn elu_f32(a: ${r}) -> ${r} {\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\n  }\n\n  fn elu_vf32(v: vec4<${r}>) -> vec4<${r}> {\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\n  }`, t.cacheKey));\n    }, qr = (e1 = \"f32\")=>`\nconst r0: ${e1} = 0.3275911;\nconst r1: ${e1} = 0.254829592;\nconst r2: ${e1} = -0.284496736;\nconst r3: ${e1} = 1.421413741;\nconst r4: ${e1} = -1.453152027;\nconst r5: ${e1} = 1.061405429;\n\nfn erf_vf32(v: vec4<${e1}>) -> vec4<${e1}> {\n  let absv = abs(v);\n  let x = 1.0 / (1.0 + r0 * absv);\n  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\n}`, Qs = (e1)=>{\n        let t = Ee(e1.inputs[0].dataType);\n        e1.compute(fe(e1.inputs[0], \"Erf\", (r)=>`erf_vf32(${r})`, qr(t)));\n    }, Xs = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Exp\", \"exp\"));\n    }, Js = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Floor\", \"floor\"));\n    }, eu = (e1)=>{\n        let t = Ee(e1.inputs[0].dataType);\n        e1.compute(fe(e1.inputs[0], \"Gelu\", (r)=>`0.5 * ${r} * (1.0 + erf_vf32(${r} * 0.7071067811865475))`, qr(t)));\n    }, tu = (e1, t)=>{\n        let r = Ee(e1.inputs[0].dataType);\n        e1.compute(fe(e1.inputs[0], \"LeakyRelu\", (n)=>`select(leaky_relu_alpha_ * ${n}, ${n}, ${n} >= vec4<${r}>(0.0))`, `const leaky_relu_alpha_ = ${r}(${t.alpha});`, t.cacheKey));\n    }, ru = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Not\", (t)=>`!${t}`));\n    }, nu = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Neg\", (t)=>`-${t}`));\n    }, ou = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Reciprocal\", (t)=>`1.0/${t}`));\n    }, iu = (e1)=>{\n        let t = Ee(e1.inputs[0].dataType);\n        e1.compute(fe(e1.inputs[0], \"Relu\", (r)=>`select(vec4<${t}>(0.0), ${r}, ${r} > vec4<${t}>(0.0))`));\n    }, au = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Sigmoid\", (t)=>`(1.0 / (1.0 + exp(-${t})))`));\n    }, su = (e1)=>re(e1), uu = (e1, t)=>{\n        let r = Ee(e1.inputs[0].dataType);\n        e1.compute(fe(e1.inputs[0], \"HardSigmoid\", (n)=>`max(vec4<${r}>(0.0), min(vec4<${r}>(1.0), ${t.alpha} * ${n} + vec4<${r}>(${t.beta})))`, void 0, t.cacheKey));\n    }, du = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Sin\", \"sin\"));\n    }, lu = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Sinh\", \"sinh\"));\n    }, cu = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Sqrt\", \"sqrt\"));\n    }, pu = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Tan\", \"tan\"));\n    }, mu = (e1)=>`sign(${e1}) * (1 - exp(-2 * abs(${e1}))) / (1 + exp(-2 * abs(${e1})))`, fu = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Tanh\", mu));\n    }, mo = (e1 = \"f32\")=>`\nconst fast_gelu_a: ${e1} = 0.5;\nconst fast_gelu_b: ${e1} = 0.7978845608028654;\nconst fast_gelu_c: ${e1} = 0.035677408136300125;\n\nfn tanh_v(v: vec4<${e1}>) -> vec4<${e1}> {\n  return ${mu(\"v\")};\n}\n`, fo = (e1)=>`(fast_gelu_a + fast_gelu_a * tanh_v(${e1} * (fast_gelu_c * ${e1} * ${e1} + fast_gelu_b))) * ${e1}`, hu = (e1)=>{\n        let t = Ee(e1.inputs[0].dataType);\n        e1.compute(fe(e1.inputs[0], \"FastGelu\", fo, mo(t), void 0, e1.inputs[0].dataType));\n    }, gu = (e1, t)=>{\n        let r = Ee(e1.inputs[0].dataType);\n        return e1.compute(fe(e1.inputs[0], \"ThresholdedRelu\", (n)=>`select(vec4<${r}>(0.0), ${n}, ${n} > thresholded_relu_alpha_)`, `const thresholded_relu_alpha_ = vec4<${r}>(${t.alpha});`, t.cacheKey)), 0;\n    }, bu = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Log\", \"log\"));\n    }, Km = (e1, t)=>`\nconst alpha = vec4<${e1}>(${t});\nconst one = ${e1}(1.0);\nconst zero = ${e1}(0.0);\n\nfn quick_gelu_impl(x: vec4<${e1}>) -> vec4<${e1}> {\n  let v = x *alpha;\n  var x1 : vec4<${e1}>;\n  for (var i = 0; i < 4; i = i + 1) {\n    if (v[i] >= zero) {\n      x1[i] = one / (one + exp(-v[i]));\n    } else {\n      x1[i] = one - one / (one + exp(v[i]));\n    }\n  }\n  return x * x1;\n}\n`, jm = (e1)=>`quick_gelu_impl(${e1})`, yu = (e1, t)=>{\n        let r = Ee(e1.inputs[0].dataType);\n        e1.compute(fe(e1.inputs[0], \"QuickGelu\", jm, Km(r, t.alpha), t.cacheKey, e1.inputs[0].dataType));\n    };\n});\nvar Ym, Zm, wu, vu = U(()=>{\n    \"use strict\";\n    oe();\n    ae();\n    Kr();\n    Ym = (e1)=>{\n        if (e1[0].dims.length !== 3) throw new Error(\"input should have 3 dimensions\");\n        if (![\n            2560,\n            5120,\n            10240\n        ].includes(e1[0].dims[2])) throw new Error(\"hidden state should be 2560, 5120 or 10240\");\n        if (e1[1].dims.length !== 1) throw new Error(\"bias is expected to have 1 dimensions\");\n        if (e1[0].dims[2] !== e1[1].dims[0]) throw new Error(\"last dimension of input and bias are not the same\");\n    }, Zm = (e1)=>{\n        let t = e1[0].dims.slice();\n        t[2] = t[2] / 2;\n        let r = E(\"input\", e1[0].dataType, e1[0].dims, 4), n = E(\"bias\", e1[0].dataType, [\n            e1[0].dims[2]\n        ], 4), o = M(\"output\", e1[0].dataType, t, 4), i = C.size(t) / 4, a = _e(e1[0].dataType);\n        return {\n            name: \"BiasSplitGelu\",\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: t,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(i / 64)\n                    }\n                }),\n            getShaderSource: (l)=>`\n  const M_SQRT2 = sqrt(2.0);\n  const halfChannels = ${e1[0].dims[2] / 4 / 2}u;\n\n  ${l.declareVariables(r, n, o)}\n\n  ${qr(a)}\n\n  ${l.mainStart()}\n    ${l.guardAgainstOutOfBoundsWorkgroupSizes(i)}\n    let biasIdx = global_idx % halfChannels;\n    let batchIndex = global_idx / halfChannels;\n    let inputOffset = biasIdx + batchIndex * halfChannels * 2;\n    let valueLeft = input[inputOffset] + bias[biasIdx];\n    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];\n    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);\n\n    ${o.setByOffset(\"global_idx\", \"valueLeft * geluRight\")}\n  }`\n        };\n    }, wu = (e1)=>{\n        Ym(e1.inputs), e1.compute(Zm(e1.inputs));\n    };\n});\nvar Qm, Xm, at, $u, xu, Su, Tu, Iu, Cu, Au, ku, Eu, Pu, zu = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    ae();\n    Qm = (e1, t, r, n, o, i, a, d, l, p, m, u)=>{\n        let h, _;\n        typeof d == \"string\" ? h = _ = (v, S)=>`${d}((${v}),(${S}))` : typeof d == \"function\" ? h = _ = d : (h = d.scalar, _ = d.vector);\n        let y = M(\"outputData\", m, n.length, 4), g = E(\"aData\", l, t.length, 4), x = E(\"bData\", p, r.length, 4), $;\n        if (o) if (i) {\n            let v = C.size(t) === 1, S = C.size(r) === 1, T = t.length > 0 && t[t.length - 1] % 4 === 0, A = r.length > 0 && r[r.length - 1] % 4 === 0;\n            v || S ? $ = y.setByOffset(\"global_idx\", _(v ? `${g.type.value}(${g.getByOffset(\"0\")}.x)` : g.getByOffset(\"global_idx\"), S ? `${x.type.value}(${x.getByOffset(\"0\")}.x)` : x.getByOffset(\"global_idx\"))) : $ = `\n            let outputIndices = ${y.offsetToIndices(\"global_idx * 4u\")};\n            let offsetA = ${g.broadcastedIndicesToOffset(\"outputIndices\", y)};\n            let offsetB = ${x.broadcastedIndicesToOffset(\"outputIndices\", y)};\n            ${y.setByOffset(\"global_idx\", _(a || T ? g.getByOffset(\"offsetA / 4u\") : `${g.type.value}(${g.getByOffset(\"offsetA / 4u\")}[offsetA % 4u])`, a || A ? x.getByOffset(\"offsetB / 4u\") : `${x.type.value}(${x.getByOffset(\"offsetB / 4u\")}[offsetB % 4u])`))}\n          `;\n        } else $ = y.setByOffset(\"global_idx\", _(g.getByOffset(\"global_idx\"), x.getByOffset(\"global_idx\")));\n        else {\n            if (!i) throw new Error(\"no necessary to use scalar implementation for element-wise binary op implementation.\");\n            let v = (S, T, A = \"\")=>{\n                let k = `aData[indexA${T}][componentA${T}]`, P = `bData[indexB${T}][componentB${T}]`;\n                return `\n            let outputIndices${T} = ${y.offsetToIndices(`global_idx * 4u + ${T}u`)};\n            let offsetA${T} = ${g.broadcastedIndicesToOffset(`outputIndices${T}`, y)};\n            let offsetB${T} = ${x.broadcastedIndicesToOffset(`outputIndices${T}`, y)};\n            let indexA${T} = offsetA${T} / 4u;\n            let indexB${T} = offsetB${T} / 4u;\n            let componentA${T} = offsetA${T} % 4u;\n            let componentB${T} = offsetB${T} % 4u;\n            ${S}[${T}] = ${A}(${h(k, P)});\n          `;\n            };\n            m === 9 ? $ = `\n            var data = vec4<u32>(0);\n            ${v(\"data\", 0, \"u32\")}\n            ${v(\"data\", 1, \"u32\")}\n            ${v(\"data\", 2, \"u32\")}\n            ${v(\"data\", 3, \"u32\")}\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));` : $ = `\n            ${v(\"outputData[global_idx]\", 0)}\n            ${v(\"outputData[global_idx]\", 1)}\n            ${v(\"outputData[global_idx]\", 2)}\n            ${v(\"outputData[global_idx]\", 3)}\n          `;\n        }\n        return `\n        ${e1.registerUniform(\"vec_size\", \"u32\").declareVariables(g, x, y)}\n\n        ${u ?? \"\"}\n\n        ${e1.mainStart()}\n        ${e1.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.vec_size\")}\n        ${$}\n      }`;\n    }, Xm = (e1, t, r, n, o, i, a = r.dataType)=>{\n        let d = r.dims.map((g)=>Number(g) ?? 1), l = n.dims.map((g)=>Number(g) ?? 1), p = !C.areEqual(d, l), m = d, u = C.size(d), h = !1, _ = !1, y = [\n            p\n        ];\n        if (p) {\n            let g = tt.calcShape(d, l, !1);\n            if (!g) throw new Error(\"Can't perform binary op on the given tensors\");\n            m = g.slice(), u = C.size(m);\n            let x = C.size(d) === 1, $ = C.size(l) === 1, v = d.length > 0 && d[d.length - 1] % 4 === 0, S = l.length > 0 && l[l.length - 1] % 4 === 0;\n            y.push(x), y.push($), y.push(v), y.push(S);\n            let T = 1;\n            for(let A = 1; A < m.length; A++){\n                let k = d[d.length - A], P = l[l.length - A];\n                if (k === P) T *= k;\n                else break;\n            }\n            T % 4 === 0 ? (_ = !0, h = !0) : (x || $ || v || S) && (h = !0);\n        } else h = !0;\n        return y.push(h), {\n            name: e1,\n            shaderCache: {\n                hint: t + y.map((g)=>g.toString()).join(\"_\"),\n                inputDependencies: [\n                    \"rank\",\n                    \"rank\"\n                ]\n            },\n            getShaderSource: (g)=>Qm(g, d, l, m, h, p, _, o, r.dataType, n.dataType, a, i),\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: m,\n                            dataType: a\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(u / 64 / 4)\n                    },\n                    programUniforms: [\n                        {\n                            type: 12,\n                            data: Math.ceil(C.size(m) / 4)\n                        },\n                        ...N(d, l, m)\n                    ]\n                })\n        };\n    }, at = (e1, t, r, n, o, i)=>{\n        e1.compute(Xm(t, o ?? \"\", e1.inputs[0], e1.inputs[1], r, n, i));\n    }, $u = (e1)=>{\n        at(e1, \"Add\", (t, r)=>`${t}+${r}`);\n    }, xu = (e1)=>{\n        at(e1, \"Div\", (t, r)=>`${t}/${r}`);\n    }, Su = (e1)=>{\n        at(e1, \"Equal\", {\n            scalar: (t, r)=>`u32(${t}==${r})`,\n            vector: (t, r)=>`vec4<u32>(${t}==${r})`\n        }, void 0, void 0, 9);\n    }, Tu = (e1)=>{\n        at(e1, \"Mul\", (t, r)=>`${t}*${r}`);\n    }, Iu = (e1)=>{\n        let t = E(\"input\", e1.inputs[0].dataType, e1.inputs[0].dims).type.value;\n        at(e1, \"Pow\", {\n            scalar: (n, o)=>`pow_custom(${n},${o})`,\n            vector: (n, o)=>`pow_vector_custom(${n},${o})`\n        }, `\n    fn pow_custom(a : ${t}, b : ${t}) -> ${t} {\n      if (b == ${t}(0.0)) {\n        return ${t}(1.0);\n      } else if (a < ${t}(0.0) && f32(b) != floor(f32(b))) {\n        return ${t}(pow(f32(a), f32(b))); // NaN\n      }\n      return select(sign(a), ${t}(1.0), round(f32(abs(b) % ${t}(2.0))) != 1.0) * ${t}(${t === \"i32\" ? \"round\" : \"\"}(pow(f32(abs(a)), f32(b))));\n    }\n    fn pow_vector_custom(a : vec4<${t}>, b : vec4<${t}>) -> vec4<${t}> {\n      // TODO: implement vectorized pow\n      return vec4<${t}>(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));\n    }\n      `);\n    }, Cu = (e1)=>{\n        at(e1, \"Sub\", (t, r)=>`${t}-${r}`);\n    }, Au = (e1)=>{\n        at(e1, \"Greater\", {\n            scalar: (t, r)=>`u32(${t}>${r})`,\n            vector: (t, r)=>`vec4<u32>(${t}>${r})`\n        }, void 0, void 0, 9);\n    }, ku = (e1)=>{\n        at(e1, \"Less\", {\n            scalar: (t, r)=>`u32(${t}<${r})`,\n            vector: (t, r)=>`vec4<u32>(${t}<${r})`\n        }, void 0, void 0, 9);\n    }, Eu = (e1)=>{\n        at(e1, \"GreaterOrEqual\", {\n            scalar: (t, r)=>`u32(${t}>=${r})`,\n            vector: (t, r)=>`vec4<u32>(${t}>=${r})`\n        }, void 0, void 0, 9);\n    }, Pu = (e1)=>{\n        at(e1, \"LessOrEqual\", {\n            scalar: (t, r)=>`u32(${t}<=${r})`,\n            vector: (t, r)=>`vec4<u32>(${t}<=${r})`\n        }, void 0, void 0, 9);\n    };\n});\nvar ef, tf, rf, nf, Ou, Du, Bu = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    ef = (e1, t)=>{\n        if (!e1 || e1.length < 1) throw new Error(\"too few inputs\");\n        let r = 0, n = e1[r], o = n.dataType, i = n.dims.length;\n        e1.forEach((a, d)=>{\n            if (d !== r) {\n                if (a.dataType !== o) throw new Error(\"input tensors should be one type\");\n                if (a.dims.length !== i) throw new Error(\"input tensors should have the same shape\");\n                a.dims.forEach((l, p)=>{\n                    if (p !== t && l !== n.dims[p]) throw new Error(\"non concat dimensions must match\");\n                });\n            }\n        });\n    }, tf = (e1, t)=>`\n  fn calculateInputIndex(index: u32) -> u32 {\n    let sizeInConcatAxis = array<u32, ${e1}u>(${t});\n    for (var i: u32 = 0u; i < ${e1}; i += 1u ) {\n      if (index < sizeInConcatAxis[i]) {\n        return i;\n      }\n    }\n    return ${e1}u;\n  }`, rf = (e1, t)=>{\n        let r = e1.length, n = [];\n        for(let o = 0; o < r; ++o){\n            let i = t.setByOffset(\"global_idx\", e1[o].getByIndices(\"indices\"));\n            r === 1 ? n.push(i) : o === 0 ? n.push(`if (inputIndex == ${o}u) { ${i} }`) : o === r - 1 ? n.push(`else { ${i} }`) : n.push(`else if (inputIndex == ${o}) { ${i} }`);\n        }\n        return n.join(`\n`);\n    }, nf = (e1, t, r, n)=>{\n        let o = C.size(r), i = new Array(e1.length), a = new Array(e1.length), d = 0, l = [], p = [], m = [\n            {\n                type: 12,\n                data: o\n            }\n        ];\n        for(let g = 0; g < e1.length; ++g)d += e1[g].dims[t], i[g] = d, p.push(e1[g].dims.length), a[g] = E(`input${g}`, n, p[g]), l.push(\"rank\"), m.push({\n            type: 12,\n            data: i[g]\n        });\n        for(let g = 0; g < e1.length; ++g)m.push(...N(e1[g].dims));\n        m.push(...N(r));\n        let u = M(\"output\", n, r.length), h = u.indicesGet(\"indices\", t), _ = Array.from(Array(i.length).keys()).map((g)=>`uniforms.sizeInConcatAxis${g}`).join(\",\"), y = (g)=>`\n\n  ${(()=>{\n                g.registerUniform(\"outputSize\", \"u32\");\n                for(let x = 0; x < e1.length; x++)g.registerUniform(`sizeInConcatAxis${x}`, \"u32\");\n                return g.declareVariables(...a, u);\n            })()}\n\n  ${tf(i.length, _)}\n\n  ${g.mainStart()}\n    ${g.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n\n    var indices = ${u.offsetToIndices(\"global_idx\")};\n\n    let inputIndex = calculateInputIndex(${h});\n    if (inputIndex != 0u) {\n      let sizeInConcatAxis = array<u32, ${i.length}u>(${_});\n      ${h} -= sizeInConcatAxis[inputIndex - 1u];\n    }\n\n    ${rf(a, u)}\n  }`;\n        return {\n            name: \"Concat\",\n            shaderCache: {\n                hint: `${t}`,\n                inputDependencies: l\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: r,\n                            dataType: n\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(o / 64)\n                    },\n                    programUniforms: m\n                }),\n            getShaderSource: y\n        };\n    }, Ou = (e1, t)=>{\n        let r = e1.inputs, n = r[0].dims, o = C.normalizeAxis(t.axis, n.length);\n        ef(r, o);\n        let i = n.slice();\n        i[o] = r.reduce((d, l)=>d + (l.dims.length > o ? l.dims[o] : 0), 0);\n        let a = r.filter((d)=>C.size(d.dims) > 0);\n        e1.compute(nf(a, o, i, r[0].dataType), {\n            inputs: a\n        });\n    }, Du = (e1)=>re({\n            axis: e1.axis\n        });\n});\nvar qe, Ke, je, jr, yt = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    qe = (e1, t, r = \"f32\")=>{\n        switch(e1.activation){\n            case \"Relu\":\n                return `value = max(value, ${t}(0.0));`;\n            case \"Sigmoid\":\n                return `value = (${t}(1.0) / (${t}(1.0) + exp(-value)));`;\n            case \"Clip\":\n                return `value = clamp(value, ${t}(${r}(uniforms.clip_min)), ${t}(${r}(uniforms.clip_max)));`;\n            case \"HardSigmoid\":\n                return `value = max(${t}(0.0), min(${t}(1.0), ${r}(uniforms.alpha) * value + ${r}(uniforms.beta)));`;\n            case \"LeakyRelu\":\n                return `value = select(${r}(uniforms.alpha) * value, value, value >= ${t}(0.0));`;\n            case \"Tanh\":\n                return `let e2x = exp(-2.0 * abs(value));\n              value = sign(value) * (1.0 - e2x) / (1.0 + e2x);\n        `;\n            case \"\":\n                return \"\";\n            default:\n                throw new Error(`Unsupported activation ${e1.activation}`);\n        }\n    }, Ke = (e1, t)=>{\n        e1.activation === \"Clip\" ? t.push({\n            type: 1,\n            data: e1.clipMax\n        }, {\n            type: 1,\n            data: e1.clipMin\n        }) : e1.activation === \"HardSigmoid\" ? t.push({\n            type: 1,\n            data: e1.alpha\n        }, {\n            type: 1,\n            data: e1.beta\n        }) : e1.activation === \"LeakyRelu\" && t.push({\n            type: 1,\n            data: e1.alpha\n        });\n    }, je = (e1, t)=>{\n        e1.activation === \"Clip\" ? t.push({\n            name: \"clip_max\",\n            type: \"f32\"\n        }, {\n            name: \"clip_min\",\n            type: \"f32\"\n        }) : e1.activation === \"HardSigmoid\" ? t.push({\n            name: \"alpha\",\n            type: \"f32\"\n        }, {\n            name: \"beta\",\n            type: \"f32\"\n        }) : e1.activation === \"LeakyRelu\" && t.push({\n            name: \"alpha\",\n            type: \"f32\"\n        });\n    }, jr = (e1)=>{\n        let t = e1?.activation || \"\";\n        if (t === \"HardSigmoid\") {\n            let [r, n] = e1?.activation_params || [\n                .2,\n                .5\n            ];\n            return {\n                activation: t,\n                alpha: r,\n                beta: n\n            };\n        } else if (t === \"Clip\") {\n            let [r, n] = e1?.activation_params || [\n                es,\n                ts\n            ];\n            return {\n                activation: t,\n                clipMax: n,\n                clipMin: r\n            };\n        } else if (t === \"LeakyRelu\") {\n            let [r] = e1?.activation_params || [\n                .01\n            ];\n            return {\n                activation: t,\n                alpha: r\n            };\n        }\n        return {\n            activation: t\n        };\n    };\n});\nvar Ae, Mu, Yr = U(()=>{\n    \"use strict\";\n    Ae = (e1, t)=>{\n        switch(e1){\n            case 1:\n                return t;\n            case 2:\n                return `vec2<${t}>`;\n            case 3:\n                return `vec3<${t}>`;\n            case 4:\n                return `vec4<${t}>`;\n            default:\n                throw new Error(`${e1}-component is not supported.`);\n        }\n    }, Mu = (e1)=>`\n      ${e1 ? \"value = value + getBiasByOutputCoords(coords);\" : \"\"}\n      `;\n});\nvar Ru, Uu = U(()=>{\n    \"use strict\";\n    Ru = (e1)=>`\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n}\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n  return dot(coords, vec4<i32>(\n    i32(${e1}.x), i32(${e1}.y), i32(${e1}.z), 1));\n}\n`;\n});\nvar Jt, Zr, Qr = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    ae();\n    yt();\n    Jt = (e1, t, r, n, o)=>{\n        let i = n - r;\n        return `\n      ${Array.from({\n            length: r\n        }).map((a, d)=>`\n      if (${F(t.shape, d, t.rank)} != 1) {\n        ${t.indicesSet(e1, d, F(o, d + i, n))}\n      } else {\n        ${t.indicesSet(e1, d, 0)}\n      }`).join(\"\")}\n`;\n    }, Zr = (e1, t, r, n, o = !1, i)=>{\n        let a = e1[0].dims, d = e1[1].dims, l = a[a.length - 2], p = d[d.length - 1], m = a[a.length - 1], u = me(p), h = me(m), _ = me(l), y = C.size(r) / u / _, g = e1.length > 2, x = n ? n.slice(0, -2) : r.slice(0, -2), v = [\n            C.size(x),\n            l,\n            p\n        ], S = [\n            {\n                type: 12,\n                data: y\n            },\n            {\n                type: 12,\n                data: l\n            },\n            {\n                type: 12,\n                data: p\n            },\n            {\n                type: 12,\n                data: m\n            }\n        ];\n        Ke(t, S), S.push(...N(x, a, d)), g && S.push(...N(e1[2].dims)), S.push(...N(v));\n        let T = (A)=>{\n            let k = Lr(\"batch_dims\", e1[0].dataType, x.length), P = E(\"a\", e1[0].dataType, a.length, h), D = E(\"b\", e1[1].dataType, d.length, u), R = M(\"output\", e1[0].dataType, v.length, u), G = _e(R.type.tensor), K = qe(t, R.type.value, G), j = [\n                P,\n                D\n            ], V = \"\";\n            if (g) {\n                let Y = o ? u : 1;\n                j.push(E(\"bias\", e1[2].dataType, e1[2].dims.length, Y)), V = `${o ? `value += bias[col / ${Y}];` : `value += ${R.type.value}(bias[row + i]);`}`;\n            }\n            let Q = [\n                {\n                    name: \"output_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"M\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"N\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"K\",\n                    type: \"u32\"\n                }\n            ];\n            je(t, Q);\n            let se = ()=>{\n                let Y = `var a_data: ${P.type.value};`;\n                for(let ee = 0; ee < h; ee++)Y += `\n              let b_data${ee} = b[(b_offset + (k + ${ee}) * uniforms.N + col) / ${u}];`;\n                for(let ee = 0; ee < _; ee++){\n                    Y += `a_data = a[(a_offset + (row + ${ee}) * uniforms.K + k) / ${h}];`;\n                    for(let J = 0; J < h; J++)Y += `\n            values[${ee}] = fma(${D.type.value}(a_data${h === 1 ? \"\" : `[${J}]`}), b_data${J}, values[${ee}]);\n`;\n                }\n                return Y;\n            };\n            return `\n  ${A.registerUniforms(Q).registerInternalVariables(k).declareVariables(...j, R)}\n  ${A.mainStart()}\n    ${A.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n    let col = (global_idx % (uniforms.N / ${u})) * ${u};\n    var index1 = global_idx / (uniforms.N / ${u});\n    let stride1 = uniforms.M / ${_};\n    let row = (index1 % stride1) * ${_};\n    let batch = index1 / stride1;\n\n    ${r.length === 2 ? \"\" : `let batch_indices = ${k.offsetToIndices(\"batch\")};`}\n\n    var a_indices: ${P.type.indices};\n    ${Jt(\"a_indices\", P, P.rank - 2, k.rank, \"batch_indices\")}\n    ${P.indicesSet(\"a_indices\", P.rank - 2, 0)}\n    ${P.indicesSet(\"a_indices\", P.rank - 1, 0)}\n    let a_offset = ${P.indicesToOffset(\"a_indices\")};\n\n    var b_indices: ${D.type.indices};\n    ${Jt(\"b_indices\", D, D.rank - 2, k.rank, \"batch_indices\")}\n    ${D.indicesSet(\"b_indices\", D.rank - 2, 0)}\n    ${D.indicesSet(\"b_indices\", D.rank - 1, 0)}\n    let b_offset = ${D.indicesToOffset(\"b_indices\")};\n    var values: array<${R.type.value}, ${_}>;\n    for (var k: u32 = 0u; k < uniforms.K; k = k + ${h}) {\n      ${se()}\n    }\n    for (var i = 0u; i < ${_}u; i++) {\n      var value = values[i];\n      ${V}\n      ${K}\n      let cur_indices = ${R.type.indices}(batch, row + i, col);\n      let offset = ${R.indicesToOffset(\"cur_indices\")};\n      ${R.setByOffset(`offset / ${u}`, \"value\")};\n    }\n  }\n  `;\n        };\n        return {\n            name: \"MatMulNaive\",\n            shaderCache: {\n                hint: `${t.activation};${u};${h};${_};${o}`,\n                inputDependencies: g ? [\n                    \"rank\",\n                    \"rank\",\n                    \"rank\"\n                ] : [\n                    \"rank\",\n                    \"rank\"\n                ]\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: i ? i(r) : r,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(y / 64)\n                    },\n                    programUniforms: S\n                }),\n            getShaderSource: T\n        };\n    };\n});\nvar of, af, ho, Nu, sf, go, uf, er, Xr = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    ae();\n    yt();\n    Qr();\n    Yr();\n    of = (e1, t)=>e1 ? `\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          kStart + inputRow,\n          globalRowStart / innerElementSize + inputCol${t ? \", batchIndices\" : \"\"});\n        ` : `\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\n          globalRow + innerRow,\n          kStart / innerElementSize + inputCol${t ? \", batchIndices\" : \"\"});\n        `, af = (e1, t)=>e1 ? `\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\n        ${t === 3 ? \"\" : \"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];\"}\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${t === 3 ? \"\" : \"acc[i] = BCached3 * ACached3[i] + acc[i];\"}\n        }` : `\n        for (var i = 0; i < rowPerThread; i = i + 1) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${t === 3 ? \"\" : \"acc[i] = BCached3 * ACached.w + acc[i];\"}\n        }`, ho = (e1, t, r = \"f32\", n, o = !1, i = 32, a = !1, d = 32)=>{\n        let l = t[1] * e1[1], p = t[0] * e1[0], m = o ? l : i, u = o ? i : l, h = m / t[0], _ = i / t[1];\n        if (!((o && h === 4 && e1[1] === 4 || !o && (h === 3 || h === 4)) && m % t[0] === 0 && i % t[1] === 0 && e1[0] === 4)) throw new Error(`If transposeA ${o} is true, innerElementSize ${h} and workPerThread[1] ${e1[1]} must be 4.\n      Otherwise, innerElementSize ${h} must be 3 or 4.\n  tileAWidth ${m} must be divisible by workgroupSize[0]${t[0]}. tileInner ${i} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e1[0]} must be 4.`);\n        return `\nvar<workgroup> mm_Asub: array<array<vec${h}<${r}>, ${m / h}>, ${u}>;\nvar<workgroup> mm_Bsub: array<array<vec4<${r}>, ${p / e1[0]}>, ${i}>;\n\nconst rowPerThread = ${e1[1]};\nconst colPerThread = ${e1[0]};\nconst innerElementSize = ${h};\nconst tileInner = ${i};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n  let localRow = i32(localId.y);\n  let tileRow = localRow * rowPerThread;\n  let tileCol = i32(localId.x);\n\n  let globalRow =i32(globalId.y) * rowPerThread;\n  let globalCol = i32(globalId.x);\n  let batch = ${a ? \"0\" : \"i32(globalId.z)\"};\n  ${n ? `let batchIndices = ${n.offsetToIndices(\"u32(batch)\")};` : \"\"}\n  let globalRowStart = i32(workgroupId.y) * ${l};\n\n  let num_tiles = ${a ? `${Math.ceil(d / i)}` : \"(uniforms.dim_inner - 1) / tileInner + 1\"};\n  var kStart = ${a ? `i32(globalId.z) * ${d}` : \"0\"};\n\n  var acc: array<vec4<${r}>, rowPerThread>;\n\n  // Loop over shared dimension.\n  let tileRowB = localRow * ${_};\n  for (var t = 0; t < num_tiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let inputRow = tileRow + innerRow;\n          let inputCol = tileCol;\n          ${of(o, n)}\n      }\n\n      // Load one tile of B into local memory.\n      for (var innerRow = 0; innerRow < ${_}; innerRow = innerRow + 1) {\n          let inputRow = tileRowB + innerRow;\n          let inputCol = tileCol;\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol${n ? \", batchIndices\" : \"\"});\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\n          ${h === 3 ? \"\" : \"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];\"}\n\n          ${af(o, h)}\n      }\n\n      workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n  }\n}`;\n    }, Nu = (e1, t)=>e1 ? `\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              kStart + inputRow,\n              globalRowStart + inputCol${t ? \", batchIndices\" : \"\"});\n            ` : `\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\n              globalRowStart + inputRow,\n              kStart + inputCol${t ? \", batchIndices\" : \"\"});\n            `, sf = (e1)=>e1 ? \"let ACached = mm_Asub[k][tileRow + innerRow];\" : \"let ACached = mm_Asub[tileRow + innerRow][k];\", go = (e1, t, r = \"f32\", n, o = !1, i = 32, a = !1, d = 32, l = !1)=>{\n        let p = e1[1] * t[1], m = e1[0] * t[0], u = o ? p : i, h = o ? i : p;\n        if (!(h % t[1] === 0 && u % t[0] === 0 && i % t[1] === 0)) throw new Error(`tileAHight ${h} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${u} must be divisible by workgroupSize[0]${t[0]}, tileInner ${i} must be divisible by workgroupSize[1]${t[1]}`);\n        let _ = h / t[1], y = u / t[0], g = i / t[1], x = l ? `\n    let localRow = i32(localId.y);\n    let localCol = i32(localId.x);\n    let globalRowStart = i32(workgroupId.y) * ${p};\n    let globalColStart = i32(workgroupId.x) * ${m};\n\n    // Loop over shared dimension.\n    for (var t = 0; t < num_tiles; t = t + 1) {\n      // Load one tile of A into local memory.\n      for (var inputRow = localRow; inputRow < ${h}; inputRow = inputRow + ${t[1]}) {\n        for (var inputCol = localCol; inputCol < ${u}; inputCol = inputCol + ${t[0]}) {\n          ${Nu(o, n)}\n        }\n      }\n      // Load one tile of B into local memory.\n      for (var inputRow = localRow; inputRow < ${i}; inputRow = inputRow + ${t[1]}) {\n            for (var inputCol = localCol; inputCol < ${m}; inputCol = inputCol + ${t[0]}) {\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n            kStart + inputRow,\n            globalColStart + inputCol${n ? \", batchIndices\" : \"\"});\n        }\n      }\n      kStart = kStart + tileInner;\n      workgroupBarrier();\n\n      // Compute acc values for a single thread.\n      var BCached : array<${r}, colPerThread>;\n      for (var k = 0; k < tileInner; k = k + 1) {\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n          BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\n        }\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n          let ACached = ${o ? `mm_Asub[k][localRow + innerRow * ${t[1]}];` : `mm_Asub[localRow + innerRow * ${t[1]}][k];`}\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                ACached * BCached[innerCol];\n          }\n        }\n      }\n      workgroupBarrier();\n    }\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      let gRow = globalRowStart + localRow + innerRow * ${t[1]};\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        let gCol = globalColStart + localCol + innerCol * ${t[0]};\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n      }\n    }\n    ` : `\nlet tileRow = i32(localId.y) * rowPerThread;\nlet tileCol = i32(localId.x) * colPerThread;\n\nlet globalRow = i32(globalId.y) * rowPerThread;\nlet globalCol = i32(globalId.x) * colPerThread;\nlet globalRowStart = i32(workgroupId.y) * ${p};\n\nlet tileRowA = i32(localId.y) * ${_};\nlet tileColA = i32(localId.x) * ${y};\nlet tileRowB = i32(localId.y) * ${g};\n// Loop over shared dimension.\nfor (var t = 0; t < num_tiles; t = t + 1) {\n  // Load one tile of A into local memory.\n  for (var innerRow = 0; innerRow < ${_}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < ${y}; innerCol = innerCol + 1) {\n      let inputRow = tileRowA + innerRow;\n      let inputCol = tileColA + innerCol;\n      ${Nu(o, n)}\n    }\n  }\n\n  // Load one tile of B into local memory.\n  for (var innerRow = 0; innerRow < ${g}; innerRow = innerRow + 1) {\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n      let inputRow = tileRowB + innerRow;\n      let inputCol = tileCol + innerCol;\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\n        kStart + inputRow,\n        globalCol + innerCol${n ? \", batchIndices\" : \"\"});\n    }\n  }\n  kStart = kStart + tileInner;\n  workgroupBarrier();\n\n  // Compute acc values for a single thread.\n  var BCached : array<${r}, colPerThread>;\n  for (var k = 0; k < tileInner; k = k + 1) {\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\n    }\n\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n      ${sf(o)}\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n      }\n    }\n  }\n\n  workgroupBarrier();\n}\n\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n        acc[innerRow][innerCol]);\n  }\n}\n`;\n        return `\n  var<workgroup> mm_Asub : array<array<${r}, ${u}>, ${h}>;\n  var<workgroup> mm_Bsub : array<array<${r}, ${m}>, ${i}>;\n  const rowPerThread = ${e1[1]};\n  const colPerThread = ${e1[0]};\n  const tileInner = ${i};\n\n@compute @workgroup_size(${t[0]}, ${t[1]}, ${t[2]})\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\n        @builtin(global_invocation_id) globalId : vec3<u32>,\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\n    let batch = ${a ? \"0\" : \"i32(globalId.z)\"};\n    ${n ? `let batchIndices = ${n.offsetToIndices(\"u32(batch)\")};` : \"\"}\n    let num_tiles = ${a ? `${Math.ceil(d / i)}` : \"(uniforms.dim_inner - 1) / tileInner + 1\"};\n    var kStart = ${a ? `i32(globalId.z) * ${d}` : \"0\"};\n\n    var acc : array<array<${r}, colPerThread>, rowPerThread>;\n    ${x}\n  }\n`;\n    }, uf = (e1, t, r, n, o = !1)=>{\n        let [i, a, d, l] = n, p = _e(n[0].type.tensor);\n        return `\n    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: ${i.type.indices}) -> ${Ae(e1, p)} {\n      var value = ${Ae(e1, p)}(0.0);\n      let col = colIn * ${e1};\n      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)\n      {\n        var aIndices: ${a.type.indices};\n        ${Jt(\"aIndices\", a, a.rank - 2, i.rank, \"batchIndices\")}\n        ${a.indicesSet(\"aIndices\", a.rank - 2, \"u32(row)\")}\n        ${a.indicesSet(\"aIndices\", a.rank - 1, \"u32(colIn)\")}\n        value = ${a.getByIndices(\"aIndices\")};\n      }\n      return value;\n    }\n\n    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: ${i.type.indices}) -> ${Ae(e1, p)} {\n      var value = ${Ae(e1, p)}(0.0);\n      let col = colIn * ${e1};\n      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)\n      {\n        var bIndices: ${d.type.indices};\n        ${Jt(\"bIndices\", d, d.rank - 2, i.rank, \"batchIndices\")}\n        ${d.indicesSet(\"bIndices\", d.rank - 2, \"u32(row)\")}\n        ${d.indicesSet(\"bIndices\", d.rank - 1, \"u32(colIn)\")}\n        value = ${d.getByIndices(\"bIndices\")};\n      }\n      return value;\n    }\n\n    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${Ae(e1, p)}) {\n      let col = colIn * ${e1};\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {\n        var value = valueIn;\n        let coords = vec3<i32>(batch, row, colIn);\n        ${t ? `value = value + ${o ? \"bias[colIn]\" : `${Ae(e1, p)}(bias[row])`};` : \"\"}\n        ${r}\n        ${l.setByIndices(\"vec3<u32>(coords)\", \"value\")}\n      }\n    }\n    `;\n    }, er = (e1, t, r, n, o = !1, i)=>{\n        let a = e1[0].dims, d = e1[1].dims, l = a.slice(0, -2), p = d.slice(0, -2), m = n ? n.slice(0, -2) : r.slice(0, -2), u = C.size(m), h = a[a.length - 2], _ = a[a.length - 1], y = d[d.length - 1], g = _ % 4 === 0 && y % 4 === 0, x = h <= 8 ? [\n            4,\n            1,\n            1\n        ] : [\n            4,\n            4,\n            1\n        ], $ = [\n            8,\n            8,\n            1\n        ], v = [\n            Math.ceil(y / $[0] / x[0]),\n            Math.ceil(h / $[1] / x[1]),\n            Math.ceil(u / $[2] / x[2])\n        ], S = g ? 4 : 1, T = [\n            ...l,\n            h,\n            _ / S\n        ], A = T.length, k = [\n            ...p,\n            _,\n            y / S\n        ], P = k.length, D = [\n            u,\n            h,\n            y / S\n        ], R = [\n            {\n                type: 6,\n                data: h\n            },\n            {\n                type: 6,\n                data: y\n            },\n            {\n                type: 6,\n                data: _\n            }\n        ];\n        Ke(t, R), R.push(...N(m, T, k));\n        let G = [\n            \"rank\",\n            \"rank\"\n        ], K = e1.length > 2;\n        K && (R.push(...N(e1[2].dims)), G.push(\"rank\")), R.push(...N(D));\n        let j = (V)=>{\n            let Q = m.length, se = Lr(\"batchDims\", e1[0].dataType, Q, 1), Y = _e(e1[0].dataType), ee = E(\"a\", e1[0].dataType, A, S), J = E(\"b\", e1[1].dataType, P, S), ne = M(\"result\", e1[0].dataType, D.length, S), be = [\n                ee,\n                J\n            ];\n            if (K) {\n                let q = o ? S : 1;\n                be.push(E(\"bias\", e1[2].dataType, e1[2].dims.length, q));\n            }\n            let Oe = [\n                {\n                    name: \"dim_a_outer\",\n                    type: \"i32\"\n                },\n                {\n                    name: \"dim_b_outer\",\n                    type: \"i32\"\n                },\n                {\n                    name: \"dim_inner\",\n                    type: \"i32\"\n                }\n            ];\n            je(t, Oe);\n            let $e = _e(ne.type.tensor), le = qe(t, ne.type.value, $e), W = uf(S, K, le, [\n                se,\n                ee,\n                J,\n                ne\n            ], o);\n            return `\n  ${V.registerUniforms(Oe).registerInternalVariables(se).declareVariables(...be, ne)}\n  ${W}\n  ${g ? ho(x, $, Y, se) : go(x, $, Y, se)}\n                   `;\n        };\n        return {\n            name: \"MatMul\",\n            shaderCache: {\n                hint: `${x};${t.activation};${g};${o}`,\n                inputDependencies: G\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: i ? i(r) : r,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: v[0],\n                        y: v[1],\n                        z: v[2]\n                    },\n                    programUniforms: R\n                }),\n            getShaderSource: j\n        };\n    };\n});\nvar df, Vu, Wu = U(()=>{\n    \"use strict\";\n    te();\n    et();\n    ae();\n    yt();\n    Yr();\n    Uu();\n    Xr();\n    df = (e1, t, r, n, o = !1, i, a = 4, d = 4, l = 4, p = \"f32\")=>{\n        let m = (G)=>{\n            switch(G){\n                case 1:\n                    return \"resData = x[xIndex];\";\n                case 3:\n                    return `resData = vec3<${p}>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);`;\n                case 4:\n                    return \"resData = x[xIndex / 4];\";\n                default:\n                    throw new Error(`innerElementSize ${G} is not supported.`);\n            }\n        }, u = (G)=>{\n            switch(G){\n                case 1:\n                    return \"return w[row * i32(uniforms.w_shape[3]) + colIn];\";\n                case 4:\n                    return \"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];\";\n                default:\n                    throw new Error(`innerElementSize ${G} is not supported.`);\n            }\n        }, h = e1 ? `\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\n    ` : `\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\n    `, _ = e1 ? `\n    let coords = vec4<i32>(\n      batch,\n      row / outWidth,\n      row % outWidth,\n      col);\n    ` : `\n    let coords = vec4<i32>(\n      batch,\n      row,\n      col / outWidth,\n      col % outWidth);\n    `, y = e1 ? \"i32(uniforms.x_shape[1])\" : \"i32(uniforms.x_shape[2])\", g = e1 ? \"i32(uniforms.x_shape[2])\" : \"i32(uniforms.x_shape[3])\", x = e1 ? \"row\" : \"col\", $ = e1 ? \"col\" : \"row\", v = `\n    let inChannels = i32(uniforms.w_shape[2]);\n    let outWidth = ${e1 ? \"i32(uniforms.result_shape[2])\" : \"i32(uniforms.result_shape[3])\"};\n    let outRow = ${x} / outWidth;\n    let outCol = ${x} % outWidth;\n\n    let WRow = ${$} / (i32(uniforms.w_shape[1]) * inChannels);\n    let WCol = ${$} / inChannels % i32(uniforms.w_shape[1]);\n    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];\n    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];\n    let xCh = ${$} % inChannels;\n    var resData = ${Ae(a, p)}(0.0);\n    // The bounds checking is always needed since we use it to pad zero for\n    // the 'same' padding type.\n    if (xRow >= 0 && xRow < ${y} && xCol >= 0 && xCol < ${g}) {\n      ${h}\n      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));\n      ${m(a)}\n    }\n    return resData;`, S = e1 ? t && n ? `\n    let col = colIn * ${a};\n    ${v}` : `\n    let col = colIn * ${a};\n    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {\n      ${v}\n    }\n    return ${Ae(a, p)}(0.0);` : n && r ? `\n    let col = colIn * ${a};\n    ${v}` : `\n    let col = colIn * ${a};\n    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {\n      ${v}\n    }\n    return ${Ae(a, p)}(0.0);`, T = e1 ? n && r ? u(d) : `\n    let col = colIn * ${d};\n    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {\n      ${u(d)}\n    }\n    return ${Ae(d, p)}(0.0);` : `\n    let col = colIn * ${d};\n    if (row < uniforms.dim_inner && col < uniforms.dim_a_outer) {\n      ${u(d)}\n    }\n    return ${Ae(d, p)}(0.0);`, A = Ae(l, p), k = e1 ? Ae(a, p) : Ae(d, p), P = e1 ? Ae(d, p) : Ae(a, p), D = qe(i, A, p);\n        return `\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${k} {\n      ${e1 ? S : T}\n    }\n\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${P} {\n      ${e1 ? T : S}\n    }\n\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${A}) {\n      let col = colIn * ${l};\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)\n      {\n      var value = valueIn;\n      let outWidth = ${e1 ? \"i32(uniforms.result_shape[2])\" : \"i32(uniforms.result_shape[3])\"};\n      ${_}\n      ${Mu(o)}\n      ${D}\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n      }\n    }`;\n    }, Vu = (e1, t, r, n, o, i, a, d, l)=>{\n        let p = t.format === \"NHWC\", m = p ? e1[0].dims[3] : e1[0].dims[1], u = r[0], h = p ? r[2] : r[3], _ = p ? r[1] : r[2], y = p ? r[3] : r[1], g = p && (m % 4 === 0 || m % 3 === 0) && y % 4 === 0, x = p ? y : h * _, $ = p ? h * _ : y, v = [\n            8,\n            8,\n            1\n        ], S = n <= 8 ? [\n            4,\n            1,\n            1\n        ] : [\n            4,\n            4,\n            1\n        ], T = [\n            Math.ceil(x / v[0] / S[0]),\n            Math.ceil($ / v[1] / S[1]),\n            Math.ceil(u / v[2] / S[2])\n        ];\n        ue(\"verbose\", ()=>`[conv2d_mm_webgpu] dispatch = ${T}`);\n        let A = g ? p && m % 4 !== 0 ? 3 : 4 : 1, k = v[1] * S[1], P = v[0] * S[0], D = Math.max(v[0] * A, v[1]), R = n % k === 0, G = o % P === 0, K = i % D === 0, j = g ? [\n            A,\n            4,\n            4\n        ] : [\n            1,\n            1,\n            1\n        ], V = [\n            {\n                type: 6,\n                data: n\n            },\n            {\n                type: 6,\n                data: o\n            },\n            {\n                type: 6,\n                data: i\n            },\n            {\n                type: 6,\n                data: [\n                    t.pads[0],\n                    t.pads[1]\n                ]\n            },\n            {\n                type: 6,\n                data: t.strides\n            },\n            {\n                type: 6,\n                data: t.dilations\n            }\n        ];\n        Ke(t, V), V.push(...N(e1[0].dims, e1[1].dims));\n        let Q = [\n            \"rank\",\n            \"rank\"\n        ];\n        a && (V.push(...N(e1[2].dims)), Q.push(\"rank\")), V.push(...N(r));\n        let se = (Y)=>{\n            let ee = [\n                {\n                    name: \"dim_a_outer\",\n                    type: \"i32\"\n                },\n                {\n                    name: \"dim_b_outer\",\n                    type: \"i32\"\n                },\n                {\n                    name: \"dim_inner\",\n                    type: \"i32\"\n                },\n                {\n                    name: \"pad\",\n                    type: \"i32\",\n                    length: 2\n                },\n                {\n                    name: \"stride\",\n                    type: \"i32\",\n                    length: 2\n                },\n                {\n                    name: \"dilation\",\n                    type: \"i32\",\n                    length: 2\n                }\n            ];\n            je(t, ee);\n            let J = g ? 4 : 1, ne = _e(e1[0].dataType), be = `\n      fn setOutputAtIndex(flatIndex : i32, value : ${g ? `vec4<${ne}>` : ne}) {\n        result[flatIndex] = ${g ? `vec4<${ne}>` : ne}(value);\n      }\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${g ? `vec4<${ne}>` : ne}) {\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\n        setOutputAtIndex(flatIndex ${g ? \"/ 4\" : \"\"}, value);\n      }`, Oe = E(\"x\", e1[0].dataType, e1[0].dims.length, A === 3 ? 1 : A), $e = E(\"w\", e1[1].dataType, e1[1].dims.length, J), le = [\n                Oe,\n                $e\n            ], W = M(\"result\", e1[0].dataType, r.length, J);\n            if (a) {\n                let q = E(\"bias\", e1[2].dataType, e1[2].dims.length, J);\n                le.push(q), be += `\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${g ? `vec4<${ne}>` : ne} {\n          return bias[coords.${p ? \"w\" : \"y\"}${g ? \"/ 4\" : \"\"}];\n        }`;\n            }\n            return `\n        ${Ru(\"uniforms.result_strides\")}\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\n        ${Y.registerUniforms(ee).declareVariables(...le, W)}\n        ${be}\n        ${df(p, R, G, K, a, t, j[0], j[1], j[2], ne)}\n        ${g ? ho(S, v, ne, void 0, !p, D) : go(S, v, ne, void 0, !p, D, !1, void 0, d)}`;\n        };\n        return {\n            name: \"Conv2DMatMul\",\n            shaderCache: {\n                hint: `${t.cacheKey};${A};${g};${R};${G};${K};${k};${P};${D}`,\n                inputDependencies: Q\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: l ? l(r) : r,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: T[0],\n                        y: T[1],\n                        z: T[2]\n                    },\n                    programUniforms: V\n                }),\n            getShaderSource: se\n        };\n    };\n});\nvar lf, Lu, Jr, cf, Gu, pf, Hu, Fu, qu = U(()=>{\n    \"use strict\";\n    te();\n    et();\n    oe();\n    ae();\n    yt();\n    Yr();\n    lf = (e1)=>{\n        let t = 1;\n        for(let r = 0; r < e1.length; r++)t *= e1[r];\n        return t;\n    }, Lu = (e1)=>typeof e1 == \"number\" ? [\n            e1,\n            e1,\n            e1\n        ] : e1, Jr = (e1, t)=>t <= 1 ? e1 : e1 + (e1 - 1) * (t - 1), cf = (e1, t, r, n = 1)=>{\n        let o = Jr(t, n);\n        return Math.floor((e1[0] * (r - 1) - r + o) / 2);\n    }, Gu = (e1, t, r, n, o)=>{\n        o == null && (o = cf(e1, t[0], n[0]));\n        let i = [\n            0,\n            0,\n            0,\n            r\n        ];\n        for(let a = 0; a < 3; a++)e1[a] + 2 * o >= t[a] && (i[a] = Math.trunc((e1[a] - t[a] + 2 * o) / n[a] + 1));\n        return i;\n    }, pf = (e1, t, r, n, o, i, a, d, l, p)=>{\n        let m, u, h, _;\n        if (e1 === \"VALID\" && (e1 = 0), typeof e1 == \"number\") {\n            m = {\n                top: e1,\n                bottom: e1,\n                left: e1,\n                right: e1,\n                front: e1,\n                back: e1\n            };\n            let y = Gu([\n                t,\n                r,\n                n,\n                1\n            ], [\n                d,\n                l,\n                p\n            ], 1, [\n                o,\n                i,\n                a\n            ], e1);\n            u = y[0], h = y[1], _ = y[2];\n        } else if (Array.isArray(e1)) {\n            if (!e1.every((g, x, $)=>g === $[0])) throw Error(`Unsupported padding parameter: ${e1}`);\n            m = {\n                top: e1[0],\n                bottom: e1[1],\n                left: e1[2],\n                right: e1[3],\n                front: e1[4],\n                back: e1[5]\n            };\n            let y = Gu([\n                t,\n                r,\n                n,\n                1\n            ], [\n                d,\n                l,\n                p\n            ], 1, [\n                o,\n                i,\n                a\n            ], e1[0]);\n            u = y[0], h = y[1], _ = y[2];\n        } else if (e1 === \"SAME_UPPER\") {\n            u = Math.ceil(t / o), h = Math.ceil(r / i), _ = Math.ceil(n / a);\n            let y = (u - 1) * o + d - t, g = (h - 1) * i + l - r, x = (_ - 1) * a + p - n, $ = Math.floor(y / 2), v = y - $, S = Math.floor(g / 2), T = g - S, A = Math.floor(x / 2), k = x - A;\n            m = {\n                top: S,\n                bottom: T,\n                left: A,\n                right: k,\n                front: $,\n                back: v\n            };\n        } else throw Error(`Unknown padding parameter: ${e1}`);\n        return {\n            padInfo: m,\n            outDepth: u,\n            outHeight: h,\n            outWidth: _\n        };\n    }, Hu = (e1, t, r, n, o, i = !1, a = \"channelsLast\")=>{\n        let d, l, p, m, u;\n        if (a === \"channelsLast\") [d, l, p, m, u] = e1;\n        else if (a === \"channelsFirst\") [d, u, l, p, m] = e1;\n        else throw new Error(`Unknown dataFormat ${a}`);\n        let [h, , _, y, g] = t, [x, $, v] = Lu(r), [S, T, A] = Lu(n), k = Jr(_, S), P = Jr(y, T), D = Jr(g, A), { padInfo: R, outDepth: G, outHeight: K, outWidth: j } = pf(o, l, p, m, x, $, v, k, P, D), V = i ? h * u : h, Q = [\n            0,\n            0,\n            0,\n            0,\n            0\n        ];\n        return a === \"channelsFirst\" ? Q = [\n            d,\n            V,\n            G,\n            K,\n            j\n        ] : a === \"channelsLast\" && (Q = [\n            d,\n            G,\n            K,\n            j,\n            V\n        ]), {\n            batchSize: d,\n            dataFormat: a,\n            inDepth: l,\n            inHeight: p,\n            inWidth: m,\n            inChannels: u,\n            outDepth: G,\n            outHeight: K,\n            outWidth: j,\n            outChannels: V,\n            padInfo: R,\n            strideDepth: x,\n            strideHeight: $,\n            strideWidth: v,\n            filterDepth: _,\n            filterHeight: y,\n            filterWidth: g,\n            effectiveFilterDepth: k,\n            effectiveFilterHeight: P,\n            effectiveFilterWidth: D,\n            dilationDepth: S,\n            dilationHeight: T,\n            dilationWidth: A,\n            inShape: e1,\n            outShape: Q,\n            filterShape: t\n        };\n    }, Fu = (e1, t, r, n, o, i)=>{\n        let a = i === \"channelsLast\", d = a ? e1[0].dims[3] : e1[0].dims[1], l = !1, p = [\n            64,\n            1,\n            1\n        ], m = {\n            x: r.map((v, S)=>S)\n        }, u = [\n            Math.ceil(lf(m.x.map((v)=>r[v])) / p[0]),\n            1,\n            1\n        ];\n        ue(\"verbose\", ()=>`[conv3d_naive_webgpu] dispatch = ${u}`);\n        let h = l ? a && d % 4 !== 0 ? 3 : 4 : 1, _ = C.size(r), y = [\n            {\n                type: 12,\n                data: _\n            },\n            {\n                type: 12,\n                data: n\n            },\n            {\n                type: 12,\n                data: o\n            },\n            {\n                type: 12,\n                data: t.strides\n            },\n            {\n                type: 12,\n                data: t.dilations\n            }\n        ];\n        Ke(t, y), y.push(...N(e1[0].dims, e1[1].dims));\n        let g = [\n            \"rank\",\n            \"rank\"\n        ], x = e1.length === 3;\n        x && (y.push(...N(e1[2].dims)), g.push(\"rank\")), y.push(...N(r));\n        let $ = (v)=>{\n            let S = [\n                {\n                    name: \"output_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"filter_dims\",\n                    type: \"u32\",\n                    length: n.length\n                },\n                {\n                    name: \"pads\",\n                    type: \"u32\",\n                    length: o.length\n                },\n                {\n                    name: \"strides\",\n                    type: \"u32\",\n                    length: t.strides.length\n                },\n                {\n                    name: \"dilations\",\n                    type: \"u32\",\n                    length: t.dilations.length\n                }\n            ];\n            je(t, S);\n            let T = l ? 4 : 1, A = _e(e1[0].dataType), k = E(\"x\", e1[0].dataType, e1[0].dims.length, h === 3 ? 1 : h), P = E(\"W\", e1[1].dataType, e1[1].dims.length, T), D = [\n                k,\n                P\n            ], R = M(\"result\", e1[0].dataType, r.length, T), G = \"\";\n            if (x) {\n                let V = E(\"bias\", e1[2].dataType, e1[2].dims.length, T);\n                D.push(V), G += `\n        fn getBiasByOutputCoords(coords : array<u32, 5>) -> ${l ? `vec4<${A}>` : A} {\n          return bias[${a ? F(\"coords\", 4, 5) : F(\"coords\", 1, 5)}${l ? \"/ 4\" : \"\"}];\n        }`;\n            }\n            let K = Ae(h, A), j = qe(t, K, A);\n            return `\n            ${G}\n            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {\n              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);\n              return ${k.getByIndices(\"aIndices\")};\n            }\n            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {\n              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);\n              return ${P.getByIndices(\"aIndices\")};\n            }\n          ${v.registerUniforms(S).declareVariables(...D, R)}\n          ${v.mainStart()}\n          ${v.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n              let coords = ${R.offsetToIndices(\"global_idx\")};\n              let batch = ${F(\"coords\", 0, k.rank)};\n              let d2 = ${a ? F(\"coords\", k.rank - 1, k.rank) : F(\"coords\", 1, k.rank)};\n              let xFRCCorner = vec3<u32>(${a ? F(\"coords\", 1, k.rank) : F(\"coords\", 2, k.rank)},\n              ${a ? F(\"coords\", 2, k.rank) : F(\"coords\", 3, k.rank)},\n              ${a ? F(\"coords\", 3, k.rank) : F(\"coords\", 4, k.rank)}) * uniforms.strides - uniforms.pads;\n              let xFCorner = xFRCCorner.x;\n              let xRCorner = xFRCCorner.y;\n              let xCCorner = xFRCCorner.z;\n              let xShapeY = ${a ? F(\"uniforms.x_shape\", 1, k.rank) : F(\"uniforms.x_shape\", 2, k.rank)};\n              let xShapeZ = ${a ? F(\"uniforms.x_shape\", 2, k.rank) : F(\"uniforms.x_shape\", 3, k.rank)};\n              let xShapeW = ${a ? F(\"uniforms.x_shape\", 3, k.rank) : F(\"uniforms.x_shape\", 4, k.rank)};\n              let xShapeU = ${a ? F(\"uniforms.x_shape\", 4, k.rank) : F(\"uniforms.x_shape\", 1, k.rank)};\n              let inputDepthNearestVec4 = (xShapeU / 4) * 4;\n              let inputDepthVec4Remainder = xShapeU % 4;\n\n              var value = 0.0;\n              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {\n                let xF = xFCorner + wF * uniforms.dilations[0];\n                if (xF < 0 || xF >= xShapeY) {\n                  continue;\n                }\n\n                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {\n                  let xR = xRCorner + wR * uniforms.dilations[1];\n                  if (xR < 0 || xR >= xShapeZ) {\n                    continue;\n                  }\n\n                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {\n                    let xC = xCCorner + wC * uniforms.dilations[2];\n                    if (xC < 0 || xC >= xShapeW) {\n                      continue;\n                    }\n\n                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {\n                      ${a ? `let xValues = vec4<f32>(\n                               getX(batch, xF, xR, xC, d1),\n                               getX(batch, xF, xR, xC, d1 + 1),\n                               getX(batch, xF, xR, xC, d1 + 2),\n                               getX(batch, xF, xR, xC, d1 + 3));\n                            ` : `let xValues = vec4<f32>(\n                               getX(batch, d1, xF, xR, xC),\n                               getX(batch, d1 + 1, xF, xR, xC),\n                               getX(batch, d1 + 2, xF, xR, xC),\n                               getX(batch, d1 + 3, xF, xR, xC));\n                            `}\n                            let wValues = vec4<f32>(\n                              getW(d2, d1, wF, wR, wC),\n                              getW(d2, d1 + 1, wF, wR, wC),\n                              getW(d2, d1 + 2, wF, wR, wC),\n                              getW(d2, d1 + 3, wF, wR, wC));\n                      value += dot(xValues, wValues);\n                    }\n                    if (inputDepthVec4Remainder == 1) {\n                        ${a ? `value += getX(batch, xF, xR, xC, inputDepthNearestVec4)\n                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);` : `value += getX(batch, inputDepthNearestVec4, xF, xR, xC)\n                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);`}\n                    } else if (inputDepthVec4Remainder == 2) {\n                      ${a ? `let xValues = vec2<f32>(\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4),\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));\n                      ` : `let xValues = vec2<f32>(\n                        getX(batch, inputDepthNearestVec4, xF, xR, xC),\n                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));\n                    `}\n                    let wValues = vec2<f32>(\n                      getW(d2, inputDepthNearestVec4, wF, wR, wC),\n                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));\n                      value += dot(xValues, wValues);\n                    } else if (inputDepthVec4Remainder == 3) {\n                      ${a ? `let xValues = vec3<f32>(\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4),\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));\n                      ` : `let xValues = vec3<f32>(\n                        getX(batch, inputDepthNearestVec4, xF, xR, xC),\n                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),\n                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));\n                    `}\n                    let wValues = vec3<f32>(\n                      getW(d2, inputDepthNearestVec4, wF, wR, wC),\n                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),\n                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));\n                      value += dot(xValues, wValues);\n                    }\n                  }\n                }\n              }\n              ${x ? \"value = value + getBiasByOutputCoords(coords)\" : \"\"};\n              ${j}\n              result[global_idx] = f32(value);\n          }`;\n        };\n        return {\n            name: \"Conv3DNaive\",\n            shaderCache: {\n                hint: `${t.cacheKey};${a};${h};${x}`,\n                inputDependencies: g\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: r,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: u[0],\n                        y: u[1],\n                        z: u[2]\n                    },\n                    programUniforms: y\n                }),\n            getShaderSource: $\n        };\n    };\n});\nvar Ku, ju, Yu = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    ae();\n    yt();\n    Ku = (e1, t, r, n)=>{\n        let o = e1.length > 2, i = o ? \"value += b[output_channel];\" : \"\", a = e1[0].dims, d = e1[1].dims, l = t.format === \"NHWC\", p = l ? r[3] : r[1], m = p / t.group, u = l && m >= 4 ? me(p) : 1, h = C.size(r) / u, _ = [\n            {\n                type: 12,\n                data: h\n            },\n            {\n                type: 12,\n                data: t.dilations\n            },\n            {\n                type: 12,\n                data: [\n                    t.strides[0],\n                    t.strides[1]\n                ]\n            },\n            {\n                type: 12,\n                data: [\n                    t.pads[0],\n                    t.pads[1]\n                ]\n            },\n            {\n                type: 12,\n                data: m\n            }\n        ];\n        Ke(t, _), _.push(...N(a, [\n            d[0],\n            d[1],\n            d[2],\n            d[3] / u\n        ]));\n        let y = o ? [\n            \"rank\",\n            \"rank\",\n            \"rank\"\n        ] : [\n            \"rank\",\n            \"rank\"\n        ];\n        _.push(...N([\n            r[0],\n            r[1],\n            r[2],\n            r[3] / u\n        ]));\n        let g = (x)=>{\n            let $ = M(\"output\", e1[0].dataType, r.length, u), v = _e($.type.tensor), S = qe(t, $.type.value, v), T = E(\"x\", e1[0].dataType, a.length), A = E(\"w\", e1[1].dataType, d.length, u), k = [\n                T,\n                A\n            ];\n            o && k.push(E(\"b\", e1[2].dataType, e1[2].dims, u));\n            let P = [\n                {\n                    name: \"output_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"dilations\",\n                    type: \"u32\",\n                    length: t.dilations.length\n                },\n                {\n                    name: \"strides\",\n                    type: \"u32\",\n                    length: 2\n                },\n                {\n                    name: \"pads\",\n                    type: \"u32\",\n                    length: 2\n                },\n                {\n                    name: \"output_channels_per_group\",\n                    type: \"u32\"\n                }\n            ];\n            je(t, P);\n            let D = l ? `\n      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[0]; wHeight++) {\n        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];\n\n        if (xHeight < 0u || xHeight >= uniforms.x_shape[1]) {\n          continue;\n        }\n\n        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[1]; wWidth++) {\n          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];\n          if (xWidth < 0u || xWidth >= uniforms.x_shape[2]) {\n            continue;\n          }\n\n          for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[2]; wInChannel++) {\n            let input_channel = in_channel_offset + wInChannel;\n            let xVal = ${T.get(\"batch\", \"xHeight\", \"xWidth\", \"input_channel\")};\n            let wVal = ${A.get(\"wHeight\", \"wWidth\", \"wInChannel\", \"output_channel\")};\n            value += xVal * wVal;\n          }\n        }\n      }\n      ` : `\n      for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {\n        let input_channel = in_channel_offset + wInChannel;\n        for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {\n          let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];\n\n          if (xHeight < 0u || xHeight >= uniforms.x_shape[2]) {\n            continue;\n          }\n\n          for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {\n            let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];\n            if (xWidth < 0u || xWidth >= uniforms.x_shape[3]) {\n              continue;\n            }\n\n            let xVal = ${T.get(\"batch\", \"input_channel\", \"xHeight\", \"xWidth\")};\n            let wVal = ${A.get(\"output_channel\", \"wInChannel\", \"wHeight\", \"wWidth\")};\n            value += xVal * wVal;\n          }\n        }\n      }\n      `;\n            return `\n  ${x.registerUniforms(P).declareVariables(...k, $)}\n\n  ${x.mainStart()}\n    ${x.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n\n    let outputIndices = ${$.offsetToIndices(\"global_idx\")};\n    let batch: u32 = outputIndices[0];\n    let output_channel: u32 = outputIndices[${l ? 3 : 1}];\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${l ? 1 : 2}], outputIndices[${l ? 2 : 3}]) * uniforms.strides - uniforms.pads;\n    let group_id: u32 = output_channel * ${u} / uniforms.output_channels_per_group;\n    var in_channel_offset = group_id * uniforms.w_shape[${l ? 2 : 1}];\n\n    var value: ${$.type.value} = ${$.type.value}(0);\n    ${D}\n    ${i}\n    ${S}\n    ${$.setByOffset(\"global_idx\", \"value\")}\n  }`;\n        };\n        return {\n            name: \"GroupedConv\",\n            shaderCache: {\n                hint: `${t.cacheKey}_${u}`,\n                inputDependencies: y\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: n ? n(r) : r,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(h / 64)\n                    },\n                    programUniforms: _\n                }),\n            getShaderSource: g\n        };\n    }, ju = (e1, t, r, n)=>{\n        let o = e1.length > 2, i = me(r[3]), a = me(r[2]), d = C.size(r) / i / a, l = [\n            e1[0].dims[0],\n            e1[0].dims[1],\n            e1[0].dims[2],\n            e1[0].dims[3] / i\n        ], p = [\n            e1[1].dims[0],\n            e1[1].dims[1],\n            e1[1].dims[2],\n            e1[1].dims[3] / i\n        ], m = [\n            r[0],\n            r[1],\n            r[2],\n            r[3] / i\n        ], u = [\n            {\n                type: 12,\n                data: d\n            },\n            {\n                type: 6,\n                data: [\n                    t.strides[0],\n                    t.strides[1]\n                ]\n            },\n            {\n                type: 6,\n                data: [\n                    t.pads[0],\n                    t.pads[1]\n                ]\n            }\n        ];\n        Ke(t, u), u.push(...N(l, p, m));\n        let h = (a - 1) * t.strides[1] + p[1], _ = (y)=>{\n            let g = M(\"output\", e1[0].dataType, m.length, i), x = _e(g.type.tensor), $ = qe(t, g.type.value, x), v = E(\"x\", e1[0].dataType, l.length, i), S = E(\"w\", e1[1].dataType, p.length, i), T = [\n                v,\n                S\n            ];\n            o && T.push(E(\"b\", e1[2].dataType, e1[2].dims, i));\n            let A = o ? \"value += b[output_channel];\" : \"\", k = [\n                {\n                    name: \"output_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"strides\",\n                    type: \"i32\",\n                    length: 2\n                },\n                {\n                    name: \"pads\",\n                    type: \"i32\",\n                    length: 2\n                }\n            ];\n            return je(t, k), `\n  ${y.registerUniforms(k).declareVariables(...T, g)}\n  ${y.mainStart()}\n    ${y.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n    let width0 = uniforms.output_shape[3];\n    let output_channel = global_idx % width0;\n    var index1 = global_idx / width0;\n    let width1 = uniforms.output_shape[2] / ${a}u;\n    let col = (index1 % width1) * ${a}u;\n    index1 = index1 / width1;\n    let row = index1 % uniforms.output_shape[1];\n    let batch = index1 / uniforms.output_shape[1];\n\n    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;\n\n    var x_vals: array<${v.type.value}, ${h}>;\n    var values: array<${g.type.value}, ${a}>;\n    let input_channel = output_channel;\n    // Use constant instead of uniform can give better performance for w's height/width.\n    for (var w_height: u32 = 0u; w_height < ${p[0]}; w_height++) {\n      let x_height = x_corner.x + i32(w_height);\n      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {\n        for (var i = 0; i < ${h}; i++) {\n          let x_width = x_corner.y + i;\n          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {\n            x_vals[i] = ${v.get(\"batch\", \"u32(x_height)\", \"u32(x_width)\", \"input_channel\")};\n          } else {\n            x_vals[i] = ${v.type.value}(0);\n          }\n        }\n        for (var w_width: u32 = 0u; w_width < ${p[1]}; w_width++) {\n          let w_val = ${S.get(\"w_height\", \"w_width\", \"0\", \"output_channel\")};\n          for (var i = 0u; i < ${a}u; i++) {\n            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);\n          }\n        }\n      }\n    }\n\n    for (var i = 0u; i < ${a}u; i++) {\n      var value = values[i];\n      ${A}\n      ${$}\n      ${g.set(\"batch\", \"row\", \"col + i\", \"output_channel\", \"value\")};\n    }\n  }`;\n        };\n        return {\n            name: \"GroupedConv-Vectorize\",\n            shaderCache: {\n                hint: `${t.cacheKey};${i};${a};${h};${p[0]};${p[1]}`,\n                inputDependencies: o ? [\n                    \"rank\",\n                    \"rank\",\n                    \"type\"\n                ] : [\n                    \"rank\",\n                    \"rank\"\n                ]\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: n ? n(r) : r,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(d / 64)\n                    },\n                    programUniforms: u\n                }),\n            getShaderSource: _\n        };\n    };\n});\nvar mf, bo, ff, yo, _o, Zu, hf, gf, wo, Qu = U(()=>{\n    \"use strict\";\n    oe();\n    Wu();\n    qu();\n    Xr();\n    Yu();\n    yt();\n    Qr();\n    dt();\n    mf = (e1, t, r, n, o, i)=>{\n        let a = e1[0], d = e1.slice(i ? 1 : 2, i ? 3 : 4), l = d.length, p = t[0], u = t.slice(2).map((y, g)=>y + (y - 1) * (r[g] - 1)), _ = d.map((y, g)=>y + n[g] + n[g + l]).map((y, g)=>Math.floor((y - u[g] + o[g]) / o[g]));\n        return _.splice(0, 0, a), _.splice(i ? 3 : 1, 0, p), _;\n    }, bo = [\n        2,\n        3,\n        1,\n        0\n    ], ff = (e1, t)=>{\n        if (!e1 || e1.length !== 2 && e1.length !== 3) throw new Error(\"Conv requires 2 or 3 inputs\");\n        if (e1[0].dims.length > 5) throw new Error(\"greater than 5D is not supported\");\n        if (e1[0].dims.length !== e1[1].dims.length) throw new Error(\"filter does not have same dimension as input\");\n        let r = e1[0].dims[t.format === \"NHWC\" ? e1[0].dims.length - 1 : 1], n = e1[1].dims[1] * t.group;\n        if (r !== n) throw new Error(\"FILTER_IN_CHANNEL should be equal to DATA_CHANNEL\");\n        if (e1.length === 3 && (e1[2].dims.length !== 1 || e1[1].dims[0] !== e1[2].dims[0])) throw new Error(\"invalid bias\");\n        let o = e1[0].dims.length - 2;\n        if (t.dilations.length !== o) throw new Error(`dilations should be ${o}D`);\n        if (t.strides.length !== o) throw new Error(`strides should be ${o}D`);\n        if (t.pads.length !== o * 2) throw new Error(`pads should be ${o * 2}D`);\n        if (t.kernelShape.length !== 0 && t.kernelShape.length !== e1[1].dims.length - 2) throw new Error(\"invalid kernel shape\");\n    }, yo = (e1, t)=>{\n        let r = e1.kernelShape.slice();\n        r.length < t[1].dims.length - 2 && r.push(...Array(t[1].dims.length - 2 - r.length).fill(0));\n        for(let i = 2; i < t[1].dims.length; ++i)r[i - 2] === 0 && (r[i - 2] = t[1].dims[i]);\n        let n = e1.pads.slice();\n        At.adjustPadsBasedOnAutoPad(t[0].dims, e1.strides, e1.dilations, r, n, e1.format === \"NHWC\", e1.autoPad);\n        let o = Object.assign({}, e1);\n        return Object.assign(o, {\n            kernelShape: r,\n            pads: n\n        }), o;\n    }, _o = (e1)=>{\n        let t = jr(e1), r = e1.format, n = [\n            \"NOTSET\",\n            \"VALID\",\n            \"SAME_UPPER\",\n            \"SAME_LOWER\"\n        ][e1.auto_pad], o = e1.dilations, i = e1.group, a = e1.kernel_shape, d = e1.pads, l = e1.strides, p = e1.w_is_const();\n        return {\n            autoPad: n,\n            format: r,\n            dilations: o,\n            group: i,\n            kernelShape: a,\n            pads: d,\n            strides: l,\n            wIsConst: p,\n            ...t,\n            cacheKey: `${e1.format};${t.activation};`\n        };\n    }, Zu = (e1, t, r, n)=>{\n        let o = r.format === \"NHWC\", i = mf(t[0].dims, t[1].dims, r.dilations, r.pads, r.strides, o);\n        if (r.group !== 1) {\n            let k = [\n                t[0]\n            ];\n            if (o) {\n                let D = e1.kernelCustomData.wT ?? e1.compute(Pe(t[1], bo), {\n                    inputs: [\n                        1\n                    ],\n                    outputs: [\n                        r.wIsConst ? -2 : -1\n                    ]\n                })[0];\n                r.wIsConst && !e1.kernelCustomData.wT && (e1.kernelCustomData.wT = D), k.push(D);\n            } else k.push(t[1]);\n            t.length === 3 && k.push(t[2]), !e1.adapterInfo.isArchitecture(\"ampere\") && o && t[1].dims[0] === r.group && t[1].dims[1] === 1 && r.dilations[0] === 1 && r.dilations[1] === 1 ? e1.compute(ju(k, r, i, n), {\n                inputs: k\n            }) : e1.compute(Ku(k, r, i, n), {\n                inputs: k\n            });\n            return;\n        }\n        let a = t.length === 3, d = t[0].dims[o ? 1 : 2], l = t[0].dims[o ? 2 : 3], p = t[0].dims[o ? 3 : 1], m = t[1].dims[2], u = t[1].dims[3], h = i[o ? 1 : 2], _ = i[o ? 2 : 3], y = i[o ? 3 : 1], g = o && m === d && u === l && r.pads[0] === 0 && r.pads[1] === 0;\n        if (g || m === 1 && u === 1 && r.dilations[0] === 1 && r.dilations[1] === 1 && r.strides[0] === 1 && r.strides[1] === 1 && r.pads[0] === 0 && r.pads[1] === 0) {\n            let k = i[0], P, D, R, G = [];\n            if (o) {\n                let V = e1.kernelCustomData.wT ?? e1.compute(Pe(t[1], bo), {\n                    inputs: [\n                        1\n                    ],\n                    outputs: [\n                        r.wIsConst ? -2 : -1\n                    ]\n                })[0];\n                if (r.wIsConst && !e1.kernelCustomData.wT && (e1.kernelCustomData.wT = V), g) {\n                    let Q = d * l * p;\n                    P = t[0].reshape([\n                        1,\n                        k,\n                        Q\n                    ]), D = V.reshape([\n                        1,\n                        Q,\n                        y\n                    ]), R = [\n                        1,\n                        k,\n                        y\n                    ];\n                } else P = t[0].reshape([\n                    k,\n                    d * l,\n                    p\n                ]), D = V.reshape([\n                    1,\n                    p,\n                    y\n                ]), R = [\n                    k,\n                    h * _,\n                    y\n                ];\n                G.push(P), G.push(D);\n            } else P = t[0].reshape([\n                k,\n                p,\n                d * l\n            ]), D = t[1].reshape([\n                1,\n                y,\n                p\n            ]), R = [\n                k,\n                y,\n                h * _\n            ], G.push(D), G.push(P);\n            a && G.push(t[2]);\n            let K = R[2], j = G[0].dims[G[0].dims.length - 1];\n            K < 8 && j < 8 ? e1.compute(Zr(G, r, i, R, o, n), {\n                inputs: G\n            }) : e1.compute(er(G, r, i, R, o, n), {\n                inputs: G\n            });\n            return;\n        }\n        let x = !0, $ = e1.kernelCustomData.wT ?? e1.compute(Pe(t[1], bo), {\n            inputs: [\n                1\n            ],\n            outputs: [\n                r.wIsConst ? -2 : -1\n            ]\n        })[0];\n        r.wIsConst && !e1.kernelCustomData.wT && (e1.kernelCustomData.wT = $);\n        let v = [\n            t[0],\n            $\n        ];\n        a && v.push(t[2]);\n        let S = o ? h * _ : y, T = o ? y : h * _, A = m * u * p;\n        e1.compute(Vu(v, r, i, S, T, A, a, x, n), {\n            inputs: v\n        });\n    }, hf = (e1, t)=>{\n        let r = t.format === \"NHWC\", n = [\n            e1.inputs[0].reshape(r ? [\n                e1.inputs[0].dims[0],\n                1,\n                e1.inputs[0].dims[1],\n                e1.inputs[0].dims[2]\n            ] : [\n                e1.inputs[0].dims[0],\n                e1.inputs[0].dims[1],\n                1,\n                e1.inputs[0].dims[2]\n            ]),\n            e1.inputs[1].reshape([\n                e1.inputs[1].dims[0],\n                e1.inputs[1].dims[1],\n                1,\n                e1.inputs[1].dims[2]\n            ])\n        ];\n        e1.inputs.length === 3 && n.push(e1.inputs[2]);\n        let o = [\n            0,\n            t.pads[0],\n            0,\n            t.pads[1]\n        ], i = [\n            1\n        ].concat(t.strides), a = [\n            1\n        ].concat(t.dilations), d = [\n            1\n        ].concat(t.kernelShape), l = yo({\n            ...t,\n            pads: o,\n            strides: i,\n            dilations: a,\n            kernelShape: d\n        }, n);\n        Zu(e1, n, l, (p)=>r ? [\n                p[0],\n                p[2],\n                p[3]\n            ] : [\n                p[0],\n                p[1],\n                p[3]\n            ]);\n    }, gf = (e1, t, r)=>{\n        let n = r.format === \"NHWC\" ? \"channelsLast\" : \"channelsFirst\", o = yo(r, t), i = r.autoPad === \"NOTSET\" ? r.pads : r.autoPad, a = Hu(t[0].dims, t[1].dims, r.strides, r.dilations, i, !1, n);\n        e1.compute(Fu(t, o, a.outShape, [\n            a.filterDepth,\n            a.filterHeight,\n            a.filterWidth\n        ], [\n            a.padInfo.front,\n            a.padInfo.top,\n            a.padInfo.left\n        ], n));\n    }, wo = (e1, t)=>{\n        if (ff(e1.inputs, t), e1.inputs[0].dims.length === 3) hf(e1, t);\n        else if (e1.inputs[0].dims.length === 5) gf(e1, e1.inputs, t);\n        else {\n            let r = yo(t, e1.inputs);\n            Zu(e1, e1.inputs, r);\n        }\n    };\n});\nvar Xu, Ju = U(()=>{\n    \"use strict\";\n    te();\n    et();\n    oe();\n    ae();\n    Xu = (e1, t, r)=>{\n        let n = e1.length > 2, o = t.outputShape, i = t.format === \"NHWC\", a = t.group, d = e1[1].dims, l = d[2] / a, p = d[3], m = i ? me(l) : 1, u = i ? me(p) : 1, h = i ? p === 1 ? m : u : 1, _ = C.size(o) / u, y = [\n            Math.ceil(_ / 64),\n            1,\n            1\n        ];\n        ue(\"verbose\", ()=>`[conv2d_backprop_webgpu] dispatch = ${y}`);\n        let g = [\n            \"rank\",\n            \"rank\"\n        ], x = [\n            t.strides[0],\n            t.strides[1]\n        ], $ = [\n            t.kernelShape[i ? 1 : 2],\n            t.kernelShape[i ? 2 : 3]\n        ], v = [\n            t.dilations[0],\n            t.dilations[1]\n        ], S = [\n            $[0] + (t.dilations[0] <= 1 ? 0 : (t.kernelShape[i ? 1 : 2] - 1) * (t.dilations[0] - 1)),\n            $[1] + (t.dilations[1] <= 1 ? 0 : (t.kernelShape[i ? 2 : 3] - 1) * (t.dilations[1] - 1))\n        ], T = [\n            S[0] - 1 - Math.floor((t.pads[0] + t.pads[2]) / 2),\n            S[1] - 1 - Math.floor((t.pads[1] + t.pads[3]) / 2)\n        ], A = [\n            {\n                type: 12,\n                data: _\n            },\n            {\n                type: 12,\n                data: x\n            },\n            {\n                type: 12,\n                data: $\n            },\n            {\n                type: 12,\n                data: v\n            },\n            {\n                type: 12,\n                data: S\n            },\n            {\n                type: 6,\n                data: T\n            },\n            {\n                type: 12,\n                data: l\n            },\n            {\n                type: 12,\n                data: p\n            },\n            ...N(e1[0].dims, e1[1].dims)\n        ];\n        n && (A.push(...N(e1[2].dims)), g.push(\"rank\")), A.push(...N(o));\n        let k = (P)=>{\n            let D = [\n                {\n                    name: \"output_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"strides\",\n                    type: \"u32\",\n                    length: x.length\n                },\n                {\n                    name: \"filter_dims\",\n                    type: \"u32\",\n                    length: $.length\n                },\n                {\n                    name: \"dilations\",\n                    type: \"u32\",\n                    length: $.length\n                },\n                {\n                    name: \"effective_filter_dims\",\n                    type: \"u32\",\n                    length: S.length\n                },\n                {\n                    name: \"pads\",\n                    type: \"i32\",\n                    length: T.length\n                },\n                {\n                    name: \"input_channels_per_group\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"output_channels_per_group\",\n                    type: \"u32\"\n                }\n            ], R = _e(e1[0].dataType), G = i ? 1 : 2, K = i ? 2 : 3, j = i ? 3 : 1, V = E(\"W\", e1[1].dataType, e1[1].dims.length, h), Q = E(\"Dy\", e1[0].dataType, e1[0].dims.length, m), se = [\n                Q,\n                V\n            ];\n            n && se.push(E(\"bias\", e1[2].dataType, [\n                o[j]\n            ].length, u));\n            let Y = M(\"result\", e1[0].dataType, o.length, u), ee = ()=>{\n                let ne = \"\";\n                if (m === 1) ne += `\n        let w_offset = ${V.indicesToOffset(`${V.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)`)};\n        let wValue = ${V.getByOffset(`w_offset / ${h}`)};\n        dotProd = dotProd + xValue * wValue;`;\n                else if (p === 1) ne += `\n          let wValue = ${V.getByOffset(`${V.indicesToOffset(`${V.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)`)} / ${h}`)};\n          dotProd = dotProd + dot(xValue, wValue);`;\n                else for(let be = 0; be < m; be++)ne += `\n            let wValue${be} = ${V.getByOffset(`${V.indicesToOffset(`${V.type.indices}(u32(wRPerm), u32(wCPerm), inputChannel + ${be}, wOutChannel)`)} / ${h}`)};\n            dotProd = dotProd + xValue[${be}] * wValue${be};`;\n                return ne;\n            }, J = `\n            let outputIndices = ${Y.offsetToIndices(`global_idx * ${u}`)};\n            let batch = ${Y.indicesGet(\"outputIndices\", 0)};\n            let d1 = ${Y.indicesGet(\"outputIndices\", j)};\n            let r = ${Y.indicesGet(\"outputIndices\", G)};\n            let c = ${Y.indicesGet(\"outputIndices\", K)};\n            let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;\n            let dyRCorner = dyCorner.x;\n            let dyCCorner = dyCorner.y;\n            let groupId = d1 / uniforms.output_channels_per_group;\n            let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;\n            // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n            // ? = to be determined. : = across all values in that axis.\n            var dotProd = ${Y.type.value}(0.0);\n            for (var wR: u32 = 0; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {\n              if (wR % uniforms.dilations.x != 0) {\n                continue;\n              }\n              let dyR = (${R}(dyRCorner) + ${R}(wR)) / ${R}(uniforms.strides[0]);\n              let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;\n              if (dyR < 0.0 || dyR >= ${R}(uniforms.Dy_shape[${G}]) || fract(dyR) > 0.0 ||\n                  wRPerm < 0) {\n                continue;\n              }\n              wR = wR + uniforms.strides[0] - 1;\n              let idyR: u32 = u32(dyR);\n\n              for (var wC: u32 = 0; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {\n                if (wC % uniforms.dilations.y != 0) {\n                  continue;\n                }\n                let dyC = (${R}(dyCCorner) + ${R}(wC)) / ${R}(uniforms.strides.y);\n                let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;\n                if (dyC < 0.0 || dyC >= ${R}(uniforms.Dy_shape[${K}]) ||\n                    fract(dyC) > 0.0 || wCPerm < 0) {\n                  continue;\n                }\n                wC = wC + uniforms.strides.y - 1;\n                let idyC: u32 = u32(dyC);\n                var inputChannel = groupId * uniforms.input_channels_per_group;\n                for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group; d2 = d2 + ${m}) {\n                  let xValue = ${i ? Q.getByOffset(`${Q.indicesToOffset(`${Q.type.indices}(batch, idyR, idyC, inputChannel)`)} / ${m}`) : Q.get(\"batch\", \"inputChannel\", \"idyR\", \"idyC\")};\n                  ${ee()}\n                  inputChannel = inputChannel + ${m};\n                }\n              }\n            }\n            let value = dotProd${n ? ` + bias[d1 / ${u}]` : \"\"};\n            ${Y.setByOffset(\"global_idx\", \"value\")};\n          `;\n            return `\n    ${P.registerUniforms(D).declareVariables(...se, Y)}\n      ${P.mainStart()}\n      ${P.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")};\n    ${J}}`;\n        };\n        return {\n            name: \"ConvTranspose2D\",\n            shaderCache: {\n                hint: `${t.cacheKey};${m}${h}${u}${p === 1}`,\n                inputDependencies: g\n            },\n            getRunData: ()=>({\n                    dispatchGroup: {\n                        x: y[0],\n                        y: y[1],\n                        z: y[2]\n                    },\n                    outputs: [\n                        {\n                            dims: r ? r(o) : o,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    programUniforms: A\n                }),\n            getShaderSource: k\n        };\n    };\n});\nvar bf, yf, _f, ed, td, wf, rd, vf, nd, od = U(()=>{\n    \"use strict\";\n    Ju();\n    yt();\n    dt();\n    bf = (e1, t, r, n, o, i)=>(e1 - 1) * t + r + (n - 1) * o + 1 - i, yf = (e1, t, r, n, o)=>{\n        let i = Math.floor(e1 / 2);\n        t === \"SAME_UPPER\" ? (r[n] = i, r[o] = e1 - i) : t === \"SAME_LOWER\" && (r[n] = e1 - i, r[o] = i);\n    }, _f = (e1, t, r, n, o, i, a, d, l, p)=>{\n        let m = e1.length - 2, u = p.length === 0;\n        l.length < m && l.push(...Array(m - l.length).fill(0));\n        let h = e1[0], _ = t[d ? 3 : 1] * o;\n        for(let y = 0, g = e1.length - m - (d ? 1 : 0); y < m; ++y, ++g){\n            let x = e1[g], $ = u ? x * a[y] : p[y], v = bf(x, a[y], i[y], t[g], r[y], $);\n            yf(v, n, i, y, y + m), u && p.push(a[y] * (x - 1) + l[y] + (t[g] - 1) * r[y] + 1 - i[y] - i[y + m]);\n        }\n        p.splice(0, 0, h), p.splice(d ? 3 : 1, 0, _);\n    }, ed = (e1, t)=>{\n        let r = e1.kernelShape.slice();\n        if (e1.kernelShape.length === 0 || e1.kernelShape.reduce((u, h)=>u * h, 1) === 0) {\n            r.length = 0;\n            for(let u = 2; u < t[1].dims.length; ++u)r.push(t[1].dims[u]);\n        }\n        let n = e1.format === \"NHWC\";\n        r.splice(0, 0, t[1].dims[0]), r.splice(n ? 3 : 1, 0, t[1].dims[1]);\n        let o = e1.pads.slice(), i = e1.outputShape.slice(), a = e1.outputPadding.slice(), d = t[0].dims, l = e1.dilations.slice();\n        if (l.reduce((u, h)=>u + h, 0) === 0) {\n            let u = t[0].dims.length - 2;\n            l = new Array(u).fill(1);\n        }\n        let p = e1.strides.slice();\n        if (p.reduce((u, h)=>u + h, 0) === 0) {\n            let u = t[0].dims.length - 2;\n            p = new Array(u).fill(1);\n        }\n        _f(d, r, l, e1.autoPad, e1.group, o, p, n, a, i);\n        let m = Object.assign({}, e1);\n        return Object.assign(m, {\n            kernelShape: r,\n            pads: o,\n            outputPadding: a,\n            outputShape: i,\n            dilations: l,\n            strides: p\n        }), m;\n    }, td = (e1)=>{\n        let t = jr(e1), r = e1.format, n = [\n            \"NOTSET\",\n            \"VALID\",\n            \"SAME_UPPER\",\n            \"SAME_LOWER\"\n        ][typeof e1.autoPad > \"u\" ? 0 : e1.autoPad], o = e1.dilations, i = e1.group, a = e1.kernelShape, d = e1.pads, l = e1.strides, p = e1.wIsConst(), m = e1.outputPadding, u = e1.outputShape;\n        return {\n            autoPad: n,\n            format: r,\n            dilations: o,\n            group: i,\n            kernelShape: a,\n            outputPadding: m,\n            outputShape: u,\n            pads: d,\n            strides: l,\n            wIsConst: p,\n            ...t,\n            cacheKey: `${e1.format};${t.activation};`\n        };\n    }, wf = (e1, t)=>{\n        if (!e1 || e1.length !== 2 && e1.length !== 3) throw new Error(\"Conv requires 2 or 3 inputs\");\n        if (e1[0].dims.length !== 4 && e1[0].dims.length !== 3) throw new Error(\"currently only support 2-dimensional conv\");\n        if (e1[0].dims.length !== e1[1].dims.length) throw new Error(\"filter does not have same dimension as input\");\n        let r = e1[0].dims[t.format === \"NHWC\" ? e1[0].dims.length - 1 : 1], n = e1[1].dims[0];\n        if (r !== n) throw new Error(\"FILTER_IN_CHANNEL should be equal to DATA_CHANNEL\");\n        let o = e1[1].dims[1] * t.group;\n        if (e1.length === 3 && (e1[2].dims.length !== 1 || e1[2].dims[0] !== o)) throw new Error(\"invalid bias\");\n        let i = e1[0].dims.length - 2;\n        if (t.dilations.reduce((m, u)=>m + u, 0) > 0 && t.dilations.length !== i) throw new Error(`dilations should be ${i}D`);\n        if (t.strides.reduce((m, u)=>m + u, 0) > 0 && t.strides.length !== i) throw new Error(`strides should be ${i}D`);\n        if (t.pads.reduce((m, u)=>m + u, 0) > 0 && t.pads.length !== i * 2) throw new Error(`pads should be ${i * 2}D`);\n        if (t.outputPadding.length !== i && t.outputPadding.length !== 0) throw new Error(`output_padding should be ${i}D`);\n        if (t.kernelShape.reduce((m, u)=>m + u, 0) > 0 && t.kernelShape.length !== 0 && t.kernelShape.length !== e1[1].dims.length - 2) throw new Error(\"invalid kernel shape\");\n        if (t.outputShape.length !== 0 && t.outputShape.length !== e1[0].dims.length - 2) throw new Error(\"invalid output shape\");\n    }, rd = (e1, t, r, n)=>{\n        let o = e1.kernelCustomData.wT ?? e1.compute(Pe(t[1], [\n            2,\n            3,\n            0,\n            1\n        ]), {\n            inputs: [\n                1\n            ],\n            outputs: [\n                r.wIsConst ? -2 : -1\n            ]\n        })[0];\n        r.wIsConst && !e1.kernelCustomData.wT && (e1.kernelCustomData.wT = o);\n        let i = [\n            t[0],\n            o\n        ];\n        t.length === 3 && i.push(t[2]), e1.compute(Xu(i, r, n), {\n            inputs: i\n        });\n    }, vf = (e1, t)=>{\n        let r = t.format === \"NHWC\", n = [\n            e1.inputs[0].reshape(r ? [\n                e1.inputs[0].dims[0],\n                1,\n                e1.inputs[0].dims[1],\n                e1.inputs[0].dims[2]\n            ] : [\n                e1.inputs[0].dims[0],\n                e1.inputs[0].dims[1],\n                1,\n                e1.inputs[0].dims[2]\n            ]),\n            e1.inputs[1].reshape([\n                e1.inputs[1].dims[0],\n                e1.inputs[1].dims[1],\n                1,\n                e1.inputs[1].dims[2]\n            ])\n        ];\n        e1.inputs.length === 3 && n.push(e1.inputs[2]);\n        let o = t.kernelShape;\n        (o.length === 0 || o[0] === 0) && (o = [\n            e1.inputs[1].dims[2]\n        ]);\n        let i = t.dilations;\n        (i.length === 0 || i[0] === 0) && (i = [\n            1\n        ]);\n        let a = t.strides;\n        (a.length === 0 || a[0] === 0) && (a = [\n            1\n        ]);\n        let d = t.pads;\n        d.length === 0 && (d = [\n            0,\n            0\n        ]), d = [\n            0,\n            d[0],\n            0,\n            d[1]\n        ], a = [\n            1\n        ].concat(a), i = [\n            1\n        ].concat(i), o = [\n            1\n        ].concat(o);\n        let l = ed({\n            ...t,\n            pads: d,\n            strides: a,\n            dilations: i,\n            kernelShape: o\n        }, n);\n        rd(e1, n, l, (p)=>r ? [\n                p[0],\n                p[2],\n                p[3]\n            ] : [\n                p[0],\n                p[1],\n                p[3]\n            ]);\n    }, nd = (e1, t)=>{\n        if (wf(e1.inputs, t), e1.inputs[0].dims.length === 3) vf(e1, t);\n        else {\n            let r = ed(t, e1.inputs);\n            rd(e1, e1.inputs, r);\n        }\n    };\n});\nvar $f, id, ad, sd = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    $f = (e1, t, r, n)=>{\n        let o = C.size(t), i = t.length, a = E(\"input\", e1, i), d = M(\"output\", e1, i), l = r.dataType === 6 ? r.getInt32Array()[0] : Number(r.getBigInt64Array()[0]), p = C.normalizeAxis(l, i), m = (u)=>{\n            let h = ` i32(${a.indicesGet(\"inputIndices\", \"uniforms.axis\")}) `, _ = F(\"uniforms.input_shape\", \"uniforms.axis\", i), y = n.reverse ? h + (n.exclusive ? \" + 1\" : \"\") : \"0\", g = n.reverse ? _ : h + (n.exclusive ? \"\" : \" + 1\");\n            return `\n                ${u.registerUniform(\"outputSize\", \"u32\").registerUniform(\"axis\", \"u32\").declareVariables(a, d)}\n                ${u.mainStart()}\n                  ${u.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n                  var inputIndices = ${d.offsetToIndices(\"global_idx\")};\n                  var sum = ${d.type.value}(0);\n                  let first : i32 = ${y};\n                  let last : i32 = ${g};\n                  for (var i : i32 = first; i < last; i++) {\n                    ${a.indicesSet(\"inputIndices\", \"uniforms.axis\", \"u32(i)\")};\n                    sum = sum + ${a.getByIndices(\"inputIndices\")};\n                  }\n                  ${d.setByOffset(\"global_idx\", \"sum\")};\n                }`;\n        };\n        return {\n            name: \"CumSum\",\n            shaderCache: {\n                hint: n.cacheKey,\n                inputDependencies: [\n                    \"rank\"\n                ]\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: t,\n                            dataType: e1\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(o / 64)\n                    },\n                    programUniforms: [\n                        {\n                            type: 12,\n                            data: o\n                        },\n                        {\n                            type: 12,\n                            data: p\n                        },\n                        ...N(t, t)\n                    ]\n                }),\n            getShaderSource: m\n        };\n    }, id = (e1, t)=>{\n        let r = e1.inputs[0].dims, n = e1.inputs[0].dataType, o = e1.inputs[1];\n        e1.compute($f(n, r, o, t), {\n            inputs: [\n                0\n            ]\n        });\n    }, ad = (e1)=>{\n        let t = e1.exclusive === 1, r = e1.reverse === 1;\n        return re({\n            exclusive: t,\n            reverse: r\n        });\n    };\n});\nvar xf, Sf, Tf, ud, dd, ld = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    xf = (e1)=>{\n        if (!e1 || e1.length !== 1) throw new Error(\"DepthToSpace requires 1 input.\");\n        if (e1[0].dims.length !== 4) throw new Error(\"DepthToSpace requires 4D input.\");\n    }, Sf = (e1, t, r, n)=>{\n        let o = [];\n        o.push(`fn perm(i: ${n.type.indices}) -> ${r.type.indices} {\n    var a: ${r.type.indices};`);\n        for(let i = 0; i < t; ++i)o.push(r.indicesSet(\"a\", e1[i], `i[${i}]`));\n        return o.push(\"return a;}\"), o.join(`\n`);\n    }, Tf = (e1, t)=>{\n        let r, n, o, i, a, d, l = t.format === \"NHWC\", p = t.blocksize, m = t.mode === \"DCR\";\n        l ? ([r, n, o, i] = e1.dims, a = m ? [\n            r,\n            n,\n            o,\n            p,\n            p,\n            i / p ** 2\n        ] : [\n            r,\n            n,\n            o,\n            i / p ** 2,\n            p,\n            p\n        ], d = m ? [\n            0,\n            1,\n            3,\n            2,\n            4,\n            5\n        ] : [\n            0,\n            1,\n            4,\n            2,\n            5,\n            3\n        ]) : ([r, n, o, i] = [\n            e1.dims[0],\n            e1.dims[2],\n            e1.dims[3],\n            e1.dims[1]\n        ], a = m ? [\n            r,\n            p,\n            p,\n            i / p ** 2,\n            n,\n            o\n        ] : [\n            r,\n            i / p ** 2,\n            p,\n            p,\n            n,\n            o\n        ], d = m ? [\n            0,\n            3,\n            4,\n            1,\n            5,\n            2\n        ] : [\n            0,\n            1,\n            4,\n            2,\n            5,\n            3\n        ]);\n        let u = e1.reshape(a), h = u.dims.length, _ = e1.dataType, y = E(\"a\", _, h), g = M(\"output\", _, h), x = ($)=>`\n  ${$.registerUniform(\"output_size\", \"u32\").declareVariables(y, g)}\n\n  ${Sf(d, h, y, g)}\n\n  ${$.mainStart()}\n    ${$.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n\n    let indices = ${g.offsetToIndices(\"global_idx\")};\n    let aIndices = perm(indices);\n\n    ${g.setByOffset(\"global_idx\", y.getByIndices(\"aIndices\"))}\n  }`;\n        return {\n            name: \"DepthToSpace\",\n            shaderCache: {\n                hint: `${e1.dims};${t.blocksize};${t.mode}`,\n                inputDependencies: [\n                    \"rank\"\n                ]\n            },\n            getRunData: ($)=>{\n                let v = l ? [\n                    r,\n                    n * p,\n                    o * p,\n                    i / p ** 2\n                ] : [\n                    r,\n                    i / p ** 2,\n                    n * p,\n                    o * p\n                ], S = C.size(v), T = u.dims, A = C.sortBasedOnPerm(T, d);\n                return {\n                    outputs: [\n                        {\n                            dims: v,\n                            dataType: $[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(S / 64)\n                    },\n                    programUniforms: [\n                        {\n                            type: 12,\n                            data: S\n                        },\n                        ...N(T, A)\n                    ]\n                };\n            },\n            getShaderSource: x\n        };\n    }, ud = (e1, t)=>{\n        xf(e1.inputs), e1.compute(Tf(e1.inputs[0], t));\n    }, dd = (e1)=>re({\n            blocksize: e1.blocksize,\n            mode: e1.mode,\n            format: e1.format\n        });\n});\nvar vo, en, cd, If, Cf, $o, xo, pd, Af, md, fd, hd = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    vo = \"[a-zA-Z]|\\\\.\\\\.\\\\.\", en = \"(\" + vo + \")+\", cd = \"^\" + en + \"$\", If = \"(\" + en + \",)*\" + en, Cf = \"^\" + If + \"$\", $o = class {\n        constructor(t = -1){\n            this.symbolToIndices = new Map, this.inputIndex = t;\n        }\n        addSymbol(t, r) {\n            let n = this.symbolToIndices.get(t);\n            n === void 0 ? n = [\n                r\n            ] : n.push(r), this.symbolToIndices.set(t, n);\n        }\n    }, xo = class {\n        constructor(t, r){\n            this.equation = r;\n            this.hasEllipsis = !1, this.symbolToInfo = new Map, this.lhs = new Array, this.outputDims = [];\n            let [n, o] = r.includes(\"->\") ? r.split(\"->\", 2) : [\n                r,\n                \"\"\n            ];\n            if (!n.match(RegExp(Cf))) throw new Error(\"Invalid LHS term\");\n            if (n.split(\",\").forEach((d, l)=>{\n                let p = t[l].dims.slice();\n                if (!d.match(RegExp(cd))) throw new Error(\"Invalid LHS term\");\n                let m = this.processTerm(d, !0, p, l);\n                this.lhs.push(m);\n            }), o === \"\") o += [\n                ...this.symbolToInfo.entries()\n            ].filter(([d, l])=>l.count === 1 || d === \"...\").map(([d])=>d).join(\"\");\n            else if (!o.match(RegExp(en))) throw new Error(\"Invalid RHS\");\n            o.match(RegExp(vo, \"g\"))?.forEach((d)=>{\n                if (d === \"...\") this.outputDims = this.outputDims.concat(this.ellipsisDims);\n                else {\n                    let l = this.symbolToInfo.get(d);\n                    if (l === void 0) throw new Error(\"Invalid RHS symbol\");\n                    this.outputDims.push(l.dimValue);\n                }\n            }), this.rhs = this.processTerm(o, !1, this.outputDims);\n        }\n        addSymbol(t, r, n) {\n            let o = this.symbolToInfo.get(t);\n            if (o !== void 0) {\n                if (o.dimValue !== r && o.count !== 1) throw new Error(\"Dimension mismatch\");\n                o.count++, o.inputIndices.push(n);\n            } else o = {\n                count: 1,\n                dimValue: r,\n                inputIndices: [\n                    n\n                ]\n            };\n            this.symbolToInfo.set(t, o);\n        }\n        processTerm(t, r, n, o = -1) {\n            let i = n.length, a = !1, d = [], l = 0;\n            if (!t.match(RegExp(cd)) && !r && t !== \"\") throw new Error(\"Invalid LHS term\");\n            let p = t.match(RegExp(vo, \"g\")), m = new $o(o);\n            return p?.forEach((u, h)=>{\n                if (u === \"...\") {\n                    if (a) throw new Error(\"Only one ellipsis is allowed per input term\");\n                    a = !0;\n                    let _ = i - p.length + 1;\n                    if (_ < 0) throw new Error(\"Ellipsis out of bounds\");\n                    if (d = n.slice(l, l + _), this.hasEllipsis) {\n                        if (this.ellipsisDims.length !== d.length || this.ellipsisDims.toString() !== d.toString()) throw new Error(\"Ellipsis dimensions mismatch\");\n                    } else if (r) this.hasEllipsis = !0, this.ellipsisDims = d;\n                    else throw new Error(\"Ellipsis must be specified in the LHS\");\n                    for(let y = 0; y < d.length; y++){\n                        let g = String.fromCharCode(\"0\".charCodeAt(0) + y);\n                        m.addSymbol(g, h + y), this.addSymbol(g, n[l++], o);\n                    }\n                } else m.addSymbol(u, h + (this.hasEllipsis ? this.ellipsisDims.length - 1 : 0)), this.addSymbol(u, n[l++], o);\n            }), m;\n        }\n    }, pd = (e1)=>e1 + \"_max\", Af = (e1, t, r, n)=>{\n        let i = e1.map((m)=>m.length).map((m, u)=>E(`input${u}`, t, m)), a = C.size(n), d = M(\"output\", t, n.length), l = [\n            ...r.symbolToInfo.keys()\n        ].filter((m)=>!r.rhs.symbolToIndices.has(m)), p = (m)=>{\n            let u = [], h = \"var prod = 1.0;\", _ = \"var sum = 0.0;\", y = \"sum += prod;\", g = [], x = [], $ = [], v = [], S = r.symbolToInfo.size === r.rhs.symbolToIndices.size;\n            r.symbolToInfo.forEach((A, k)=>{\n                if (r.rhs.symbolToIndices.has(k)) {\n                    let P = r.rhs.symbolToIndices.get(k)?.[0];\n                    P !== void 0 && r.lhs.forEach((D, R)=>{\n                        if (A.inputIndices.includes(R)) {\n                            let G = D.symbolToIndices.get(k);\n                            if (G === void 0) throw new Error(\"Invalid symbol error\");\n                            G.forEach((K)=>{\n                                u.push(`${i[R].indicesSet(`input${R}Indices`, K, d.indicesGet(\"outputIndices\", P))}`);\n                            });\n                        }\n                    });\n                } else r.lhs.forEach((P, D)=>{\n                    if (A.inputIndices.includes(D)) {\n                        let R = P.symbolToIndices.get(k);\n                        if (R === void 0) throw new Error(\"Invalid symbol error\");\n                        R.forEach((G)=>{\n                            g.push(`${i[D].indicesSet(`input${D}Indices`, G, `${k}`)}`);\n                        }), v.push(`prod *= ${i[D].getByIndices(`input${D}Indices`)};`);\n                    }\n                }), x.push(`for(var ${k}: u32 = 0; ${k} < uniforms.${pd(k)}; ${k}++) {`), $.push(\"}\");\n            });\n            let T = S ? [\n                ...u,\n                `let sum = ${i.map((A, k)=>A.getByIndices(`input${k}Indices`)).join(\" * \")};`\n            ] : [\n                ...u,\n                _,\n                ...x,\n                ...g,\n                h,\n                ...v,\n                y,\n                ...$\n            ];\n            return `\n            ${m.registerUniforms(l.map((A)=>({\n                    name: `${pd(A)}`,\n                    type: \"u32\"\n                }))).registerUniform(\"outputSize\", \"u32\").declareVariables(...i, d)}\n\n            ${m.mainStart()}\n            ${m.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n            var outputIndices = ${d.offsetToIndices(\"global_idx\")};\n            ${i.map((A, k)=>`var input${k}Indices: ${i[k].type.indices};`).join(`\n`)}\n            ${T.join(`\n`)};\n            ${d.setByOffset(\"global_idx\", \"sum\")};\n          }`;\n        };\n        return {\n            name: \"Einsum\",\n            shaderCache: {\n                hint: r.equation,\n                inputDependencies: e1.map(()=>\"rank\")\n            },\n            getRunData: ()=>{\n                let m = l.filter((h)=>r.symbolToInfo.has(h)).map((h)=>({\n                        type: 12,\n                        data: r.symbolToInfo.get(h)?.dimValue || 0\n                    }));\n                m.push({\n                    type: 12,\n                    data: a\n                });\n                let u = e1.map((h, _)=>[\n                        ...N(h)\n                    ]).reduce((h, _)=>h.concat(_), m);\n                return u.push(...N(n)), {\n                    outputs: [\n                        {\n                            dims: n,\n                            dataType: t\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(a / 64)\n                    },\n                    programUniforms: u\n                };\n            },\n            getShaderSource: p\n        };\n    }, md = (e1, t)=>{\n        let r = new xo(e1.inputs, t.equation), n = r.outputDims, o = e1.inputs.map((i, a)=>i.dims);\n        e1.compute(Af(o, e1.inputs[0].dataType, r, n));\n    }, fd = (e1)=>{\n        let t = e1.equation.replace(/\\s+/g, \"\");\n        return re({\n            equation: t\n        });\n    };\n});\nvar kf, gd, Ef, Pf, bd, yd = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    ae();\n    kf = (e1)=>{\n        if (!e1 || e1.length !== 2) throw new Error(\"Expand requires 2 input.\");\n        let t = e1[0].dims, r = Array.from(e1[1].getBigInt64Array(), Number), n = r.length < t.length ? 0 : r.length - t.length, o = t.length < r.length ? 0 : t.length - r.length;\n        for(; n < r.length && o < t.length; ++n, ++o)if (r[n] !== t[o] && r[n] !== 1 && t[o] !== 1) throw new Error(\"Expand requires shape to be broadcastable to input\");\n    }, gd = (e1, t)=>{\n        let r = e1.length - t.length, n = [];\n        for(let o = 0; o < r; ++o)n.push(e1[o]);\n        for(let o = 0; o < t.length; ++o)n.push(t[o] === 1 ? e1[o + r] : t[o]);\n        return n;\n    }, Ef = (e1, t)=>e1.length > t.length ? gd(e1, t) : gd(t, e1), Pf = (e1)=>{\n        let t = e1[0].dims, r = Array.from(e1[1].getBigInt64Array(), Number), n = Ef(t, r), o = e1[0].dataType, i = o === 9 || C.size(t) === 1, a = o === 9 || t.length > 0 && t[t.length - 1] % 4 === 0 ? 4 : 1, d = i || n.length > 0 && n[n.length - 1] % 4 === 0 ? 4 : 1, l = Math.ceil(C.size(n) / d), p = (u)=>{\n            let h = E(\"input\", o, t.length, a), _ = M(\"output\", o, n.length, d), y;\n            if (o === 9) {\n                let g = (x, $, v = \"\")=>`\n          let outputIndices${$} = ${_.offsetToIndices(`outputOffset + ${$}u`)};\n          let offset${$} = ${h.broadcastedIndicesToOffset(`outputIndices${$}`, _)};\n          let index${$} = offset${$} / 4u;\n          let component${$} = offset${$} % 4u;\n          ${x}[${$}] = ${v}(${h.getByOffset(`index${$}`)}[component${$}]);\n        `;\n                y = `\n        let outputOffset = global_idx * ${d};\n        var data = vec4<u32>(0);\n        ${g(\"data\", 0, \"u32\")}\n        ${g(\"data\", 1, \"u32\")}\n        ${g(\"data\", 2, \"u32\")}\n        ${g(\"data\", 3, \"u32\")}\n        ${_.setByOffset(\"global_idx\", \"data\")}\n      }`;\n            } else y = `\n        let outputIndices = ${_.offsetToIndices(`global_idx * ${d}`)};\n        let inputOffset = ${h.broadcastedIndicesToOffset(\"outputIndices\", _)};\n        let data = ${_.type.value}(${h.getByOffset(`inputOffset / ${a}`)});\n        ${_.setByOffset(\"global_idx\", \"data\")}\n      }`;\n            return `\n    ${u.registerUniform(\"vec_size\", \"u32\").declareVariables(h, _)}\n    ${u.mainStart()}\n    ${u.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.vec_size\")}\n    ${y}`;\n        }, m = [\n            {\n                type: 12,\n                data: l\n            },\n            ...N(t, n)\n        ];\n        return {\n            name: \"Expand\",\n            shaderCache: {\n                hint: `${n.length};${a}${d}`,\n                inputDependencies: [\n                    \"rank\"\n                ]\n            },\n            getShaderSource: p,\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: n,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(l / 64)\n                    },\n                    programUniforms: m\n                })\n        };\n    }, bd = (e1)=>{\n        kf(e1.inputs), e1.compute(Pf(e1.inputs), {\n            inputs: [\n                0\n            ]\n        });\n    };\n});\nvar zf, _d, wd = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    ae();\n    Kr();\n    zf = (e1)=>{\n        let t = e1[0].dataType, r = C.size(e1[0].dims), n = C.size(e1[1].dims), o = n % 4 === 0, i = (a)=>{\n            let d = E(\"x\", t, [\n                1\n            ], 4), l = E(\"bias\", t, [\n                1\n            ], 4), p = M(\"y\", t, [\n                1\n            ], 4), m = [\n                {\n                    name: \"output_vec_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"bias_size\",\n                    type: \"u32\"\n                }\n            ], u = (_)=>`\n      let bias${_}_offset: u32 = (global_idx * 4 + ${_}) % uniforms.bias_size;\n      let bias${_} = ${l.getByOffset(`bias${_}_offset / 4`)}[bias${_}_offset % 4];`, h = o ? `\n      let bias = ${l.getByOffset(\"global_idx % (uniforms.bias_size / 4)\")};` : `${u(0)}${u(1)}${u(2)}${u(3)}\n      let bias = ${d.type.value}(bias0, bias1, bias2, bias3);`;\n            return `${a.registerUniforms(m).declareVariables(d, l, p)}\n\n    ${mo(Ee(t))}\n\n    ${a.mainStart(kt)}\n      ${a.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_vec_size\")}\n\n      let x = ${d.getByOffset(\"global_idx\")};\n      ${h}\n      let x_in = x + bias;\n      ${p.setByOffset(\"global_idx\", fo(\"x_in\"))}\n    }`;\n        };\n        return {\n            name: \"FastGeluWithBias\",\n            shaderCache: {\n                hint: `${o}`,\n                inputDependencies: [\n                    \"type\",\n                    \"type\"\n                ]\n            },\n            getShaderSource: i,\n            getRunData: (a)=>({\n                    outputs: [\n                        {\n                            dims: a[0].dims,\n                            dataType: a[0].dataType\n                        }\n                    ],\n                    programUniforms: [\n                        {\n                            type: 12,\n                            data: Math.ceil(r / 4)\n                        },\n                        {\n                            type: 12,\n                            data: n\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(r / kt / 4)\n                    }\n                })\n        };\n    }, _d = (e1)=>{\n        e1.inputs.length < 2 || C.size(e1.inputs[1].dims) === 0 ? hu(e1) : e1.compute(zf(e1.inputs));\n    };\n});\nvar Of, Df, vd, $d, xd = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    Of = (e1)=>{\n        if (!e1 || e1.length !== 2) throw new Error(\"Gather requires 2 inputs.\");\n    }, Df = (e1, t)=>{\n        let r = e1[0].dims, n = e1[1].dims, o = r.length, i = C.normalizeAxis(t.axis, o), a = r.slice(0);\n        a.splice(i, 1, ...n);\n        let d = r[i], l = e1[0].dataType === 9 ? 4 : 1, p = Math.ceil(C.size(a) / l), m = [\n            {\n                type: 12,\n                data: p\n            },\n            {\n                type: 6,\n                data: d\n            },\n            {\n                type: 12,\n                data: i\n            },\n            ...N(e1[0].dims, e1[1].dims, a)\n        ], u = (h)=>{\n            let _ = E(\"data\", e1[0].dataType, e1[0].dims.length, l), y = E(\"inputIndices\", e1[1].dataType, e1[1].dims.length), g = M(\"output\", e1[0].dataType, a.length, l), x = (v)=>{\n                let S = n.length, T = `var indicesIndices${v}  = ${y.type.indices}(0);`;\n                for(let A = 0; A < S; A++)T += `${S > 1 ? `indicesIndices${v}[${A}]` : `indicesIndices${v}`} = ${a.length > 1 ? `outputIndices${v}[uniforms.axis + ${A}]` : `outputIndices${v}`};`;\n                T += `\n          var idx${v} = ${y.getByIndices(`indicesIndices${v}`)};\n          if (idx${v} < 0) {\n            idx${v} = idx${v} + uniforms.axisDimLimit;\n          }\n          var dataIndices${v} : ${_.type.indices};\n        `;\n                for(let A = 0, k = 0; A < o; A++)A === i ? (T += `${o > 1 ? `dataIndices${v}[${A}]` : `dataIndices${v}`} = u32(idx${v});`, k += S) : (T += `${o > 1 ? `dataIndices${v}[${A}]` : `dataIndices${v}`} = ${a.length > 1 ? `outputIndices${v}[${k}]` : `outputIndices${v}`};`, k++);\n                return T;\n            }, $;\n            if (e1[0].dataType === 9) {\n                let v = (S, T, A = \"\")=>`\n          let outputIndices${T} = ${g.offsetToIndices(`outputOffset + ${T}u`)};\n          ${x(T)};\n          let offset${T} = ${_.indicesToOffset(`dataIndices${T}`)};\n          let index${T} = offset${T} / 4u;\n          let component${T} = offset${T} % 4u;\n          ${S}[${T}] = ${A}(${_.getByOffset(`index${T}`)}[component${T}]);\n        `;\n                $ = `\n        let outputOffset = global_idx * ${l};\n        var value = vec4<u32>(0);\n        ${v(\"value\", 0, \"u32\")}\n        ${v(\"value\", 1, \"u32\")}\n        ${v(\"value\", 2, \"u32\")}\n        ${v(\"value\", 3, \"u32\")}\n        ${g.setByOffset(\"global_idx\", \"value\")}\n      `;\n            } else $ = `\n      let outputIndices = ${g.offsetToIndices(\"global_idx\")};\n      ${x(\"\")};\n      let value = ${_.getByIndices(\"dataIndices\")};\n      ${g.setByOffset(\"global_idx\", \"value\")};\n      `;\n            return `\n      ${h.registerUniform(\"outputSize\", \"u32\").registerUniform(\"axisDimLimit\", \"i32\").registerUniform(\"axis\", \"u32\").declareVariables(_, y, g)}\n      ${h.mainStart()}\n        ${h.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n        ${$}\n      }`;\n        };\n        return {\n            name: \"Gather\",\n            shaderCache: {\n                hint: t.cacheKey,\n                inputDependencies: [\n                    \"rank\",\n                    \"rank\"\n                ]\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: a,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(p / 64)\n                    },\n                    programUniforms: m\n                }),\n            getShaderSource: u\n        };\n    }, vd = (e1)=>re({\n            axis: e1.axis\n        }), $d = (e1, t)=>{\n        let r = e1.inputs;\n        Of(r), e1.compute(Df(e1.inputs, t));\n    };\n});\nvar Bf, Sd, Td, Id = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    ae();\n    Bf = (e1, t, r, n, o, i, a, d, l)=>{\n        let p = [\n            {\n                type: 12,\n                data: i\n            },\n            {\n                type: 12,\n                data: n\n            },\n            {\n                type: 12,\n                data: o\n            },\n            {\n                type: 12,\n                data: r\n            },\n            {\n                type: 12,\n                data: a\n            },\n            {\n                type: 12,\n                data: d\n            },\n            {\n                type: 12,\n                data: l\n            }\n        ], m = [\n            i\n        ];\n        p.push(...N(t.dims, m));\n        let u = (h)=>{\n            let _ = E(\"indices_data\", t.dataType, t.dims.length), y = M(\"input_slice_offsets_data\", 12, 1, 1), g = [\n                _,\n                y\n            ], x = [\n                {\n                    name: \"output_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"batch_dims\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"input_dims\",\n                    type: \"u32\",\n                    length: o.length\n                },\n                {\n                    name: \"sizes_from_slice_dims_data\",\n                    type: \"u32\",\n                    length: r.length\n                },\n                {\n                    name: \"num_slices_per_batch\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"input_batch_stride\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"num_slice_dims\",\n                    type: \"u32\"\n                }\n            ];\n            return `\n  ${h.registerUniforms(x).declareVariables(...g)}\n  ${h.mainStart()}\n    ${h.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n    let batch_idx = global_idx / uniforms.num_slices_per_batch;\n    let base_offset = batch_idx * uniforms.input_batch_stride;\n\n    let slice_indices_base_offset = global_idx * uniforms.num_slice_dims;\n    var relative_slice_offset = 0;\n    for (var dim_idx = 0u; dim_idx < uniforms.num_slice_dims; dim_idx ++) {\n      var index = i32(indices_data[dim_idx + slice_indices_base_offset].x);\n      let input_dim_idx = uniforms.batch_dims + dim_idx;\n      if (index < 0) {\n        ${o.length === 1 ? \"index += i32(uniforms.input_dims);\" : \"index += i32(uniforms.input_dims[input_dim_idx]);\"}\n      }\n      ${r.length === 1 ? \"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data);\" : \"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data[dim_idx]);\"}\n    }\n\n    input_slice_offsets_data[global_idx] =  base_offset + u32(relative_slice_offset);\n  }`;\n        };\n        return e1.compute({\n            name: \"computeSliceOffsets\",\n            shaderCache: {\n                hint: `${o.length}_${r.length}`,\n                inputDependencies: [\n                    \"rank\"\n                ]\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: m,\n                            dataType: e1.inputs[1].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(i / 64)\n                    },\n                    programUniforms: p\n                }),\n            getShaderSource: u\n        }, {\n            inputs: [\n                t\n            ],\n            outputs: [\n                -1\n            ]\n        })[0];\n    }, Sd = (e1, t)=>{\n        let r = e1.inputs, n = r[0].dims, o = r[0].dataType, i = r[1].dims, a = i[i.length - 1], d = C.sizeToDimension(i, i.length - 1), l = C.sizeFromDimension(n, t.batchDims + a), p = C.sizeToDimension(n, t.batchDims), m = C.sizeFromDimension(n, t.batchDims), u = d / p, h = new Array(a), _ = l;\n        for(let T = 0; T < a; ++T)h[a - 1 - T] = _, _ *= n[t.batchDims + a - 1 - T];\n        let y = Bf(e1, r[1], h, t.batchDims, n, d, u, m, a), g = t.batchDims + a;\n        if (g > n.length) throw new Error(\"last dimension of indices must not be larger than rank of input tensor\");\n        let x = i.slice(0, -1).concat(n.slice(g)), $ = C.size(x), v = [\n            {\n                type: 12,\n                data: $\n            },\n            {\n                type: 12,\n                data: l\n            },\n            ...N(r[0].dims, y.dims, x)\n        ], S = (T)=>{\n            let A = E(\"data\", r[0].dataType, r[0].dims.length), k = E(\"slice_offsets\", 12, y.dims.length), P = M(\"output\", r[0].dataType, x.length);\n            return `\n          ${T.registerUniform(\"output_size\", \"u32\").registerUniform(\"slice_size\", \"u32\").declareVariables(A, k, P)}\n            ${T.mainStart()}\n            ${T.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n          let slice_offset = slice_offsets[global_idx / uniforms.slice_size];\n          output[global_idx] = data[u32(slice_offset) + global_idx % uniforms.slice_size];\n        }`;\n        };\n        e1.compute({\n            name: \"GatherND\",\n            shaderCache: {\n                hint: t.cacheKey,\n                inputDependencies: [\n                    \"rank\",\n                    \"rank\"\n                ]\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: x,\n                            dataType: o\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil($ / 64)\n                    },\n                    programUniforms: v\n                }),\n            getShaderSource: S\n        }, {\n            inputs: [\n                r[0],\n                y\n            ]\n        });\n    }, Td = (e1)=>({\n            batchDims: e1.batch_dims,\n            cacheKey: \"\"\n        });\n});\nvar Mf, Rf, Cd, Ad, kd = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    Mf = (e1, t)=>{\n        if (e1.length < 3 || e1.length > 4) throw new Error(\"GatherBlockQuantized requires 3 or 4 inputs.\");\n        let r = C.normalizeAxis(t.quantizeAxis, e1[0].dims.length), n = t.blockSize, o = e1[0], i = e1[2], a = e1.length === 4 ? e1[3] : void 0;\n        if (i.dims.length !== o.dims.length || !o.dims.map((d, l)=>l === r ? Math.ceil(d / n) === i.dims[l] : d === i.dims[l]).reduce((d, l)=>d && l, !0)) throw new Error(\"Scales must have the same rank as the input tensor and the dims should match except on gatherAxis.\");\n        if (a) {\n            if (a.dataType !== o.dataType) throw new Error(\"Zero point must have the same data type as the input tensor.\");\n            if (a.dims.length !== i.dims.length || !a.dims.map((d, l)=>d === i.dims[l]).reduce((d, l)=>d && l, !0)) throw new Error(\"Zero point must have the same rank as the input tensor and the dims should match except on quantizeAxis.\");\n        }\n    }, Rf = (e1, t)=>{\n        let r = e1[0].dims, n = e1[1].dims, o = r.length, i = C.normalizeAxis(t.gatherAxis, o), a = C.normalizeAxis(t.quantizeAxis, o), d = r.slice(0);\n        d.splice(i, 1, ...n);\n        let l = C.size(d), p = e1[2].dataType, u = e1[0].dataType === 22, h = [\n            {\n                type: 12,\n                data: l\n            },\n            {\n                type: 12,\n                data: a\n            },\n            {\n                type: 12,\n                data: i\n            },\n            {\n                type: 12,\n                data: t.blockSize\n            },\n            ...N(...e1.map((y, g)=>y.dims), d)\n        ], _ = (y)=>{\n            let g = E(\"data\", e1[0].dataType, e1[0].dims.length), x = E(\"inputIndices\", e1[1].dataType, e1[1].dims.length), $ = E(\"scales\", e1[2].dataType, e1[2].dims.length), v = e1.length > 3 ? E(\"zeroPoint\", e1[3].dataType, e1[3].dims.length) : void 0, S = M(\"output\", p, d.length), T = [\n                g,\n                x,\n                $\n            ];\n            v && T.push(v);\n            let A = [\n                {\n                    name: \"output_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"quantize_axis\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"gather_axis\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"block_size\",\n                    type: \"u32\"\n                }\n            ];\n            return `\n        ${y.registerUniforms(A).declareVariables(...T, S)}\n        ${y.mainStart()}\n        let output_indices = ${S.offsetToIndices(\"global_idx\")};\n        var indices_indices = ${x.type.indices}(0);\n        ${(()=>n.length > 1 ? `\n          for (var i: u32 = 0; i < ${n.length}; i++) {\n            let index = ${S.indicesGet(\"output_indices\", \"uniforms.gather_axis + i\")};\n            ${x.indicesSet(\"indices_indices\", \"i\", \"index\")};\n          }` : `indices_indices = ${S.indicesGet(\"output_indices\", \"uniforms.gather_axis\")};`)()};\n        var data_indices = ${g.type.indices}(0);\n        for (var i: u32 = 0; i < uniforms.gather_axis; i++) {\n          let index = ${S.indicesGet(\"output_indices\", \"i\")};\n          ${g.indicesSet(\"data_indices\", \"i\", \"index\")};\n        }\n        var index_from_indices = ${x.getByIndices(\"indices_indices\")};\n        if (index_from_indices < 0) {\n          index_from_indices += ${r[i]};\n        }\n        ${g.indicesSet(\"data_indices\", \"uniforms.gather_axis\", \"u32(index_from_indices)\")};\n        for (var i = uniforms.gather_axis + 1; i < ${d.length}; i++) {\n          let index = ${S.indicesGet(\"output_indices\", `i + ${n.length} - 1`)};\n          ${g.indicesSet(\"data_indices\", \"i\", \"index\")};\n        }\n        let data_offset = ${g.indicesToOffset(\"data_indices\")};\n        let data_index = data_offset % 8;\n        // Convert 4-bit packed data to 8-bit packed data.\n        let packed_4bit_quantized_data = ${g.getByOffset(\"data_offset / 8\")};\n        let packed_8bit_quantized_data = (packed_4bit_quantized_data >> (4 * (data_index % 2))) & 0x0f0f0f0f;\n        let quantized_data_vec = ${u ? \"unpack4xI8\" : \"unpack4xU8\"}(u32(packed_8bit_quantized_data));\n        let quantized_data = quantized_data_vec[data_index / 2];\n        var scale_indices = data_indices;\n        let quantize_axis_index = ${$.indicesGet(\"data_indices\", \"uniforms.quantize_axis\")} / uniforms.block_size;\n        ${$.indicesSet(\"scale_indices\", \"uniforms.quantize_axis\", \"quantize_axis_index\")};\n        var scale = ${$.getByIndices(\"scale_indices\")};\n        ${(()=>v ? `\n              let zero_point_indices = scale_indices;\n              let zero_point_offset = ${v.indicesToOffset(\"zero_point_indices\")};\n              let zero_point_index = zero_point_offset % 8;\n              let packed_4bit_zero_points = ${v.getByOffset(\"zero_point_offset / 8\")};\n              let packed_8bit_zero_points = (packed_4bit_zero_points >> (4 * (zero_point_index % 2))) & 0x0f0f0f0f;\n              let zero_point_vec = ${u ? \"unpack4xI8\" : \"unpack4xU8\"}(u32(packed_8bit_zero_points));\n              let zero_point = zero_point_vec[zero_point_index / 2];` : \"var zero_point = 0\")()};\n        let dequantized_data = ${Ee(p)}(quantized_data - zero_point) * scale;\n        ${S.setByOffset(\"global_idx\", \"dequantized_data\")};\n    }`;\n        };\n        return {\n            name: \"GatherBlockQuantized\",\n            shaderCache: {\n                hint: `${t.cacheKey};${e1.filter((y, g)=>g !== 1).map((y)=>y.dims.join(\"_\")).join(\";\")}`,\n                inputDependencies: Array.from({\n                    length: e1.length\n                }, (y, g)=>\"rank\")\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: d,\n                            dataType: p\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(l / 64)\n                    },\n                    programUniforms: h\n                }),\n            getShaderSource: _\n        };\n    }, Cd = (e1, t)=>{\n        let r = e1.inputs;\n        Mf(r, t), e1.compute(Rf(e1.inputs, t));\n    }, Ad = (e1)=>re({\n            blockSize: e1.blockSize,\n            gatherAxis: e1.gatherAxis,\n            quantizeAxis: e1.quantizeAxis\n        });\n});\nvar Uf, Nf, Ed, Pd, zd = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    Uf = (e1)=>{\n        if (!e1 || e1.length !== 2) throw new Error(\"GatherElements requires 2 inputs.\");\n        if (e1[0].dims.length < 1) throw new Error(\"GatherElements requires that the data input be rank >= 1.\");\n        if (e1[0].dims.length !== e1[1].dims.length) throw new Error(`GatherElements requires that the data input and\n                     indices input tensors be of same rank.`);\n    }, Nf = (e1, t)=>{\n        let r = e1[0].dims, n = e1[0].dataType, o = r.length, i = e1[1].dims, a = e1[1].dataType, d = C.normalizeAxis(t.axis, o), l = r[d], p = i.slice(0), m = C.size(p), u = E(\"input\", n, o), h = E(\"indicesInput\", a, i.length), _ = M(\"output\", n, p.length), y = [\n            {\n                type: 12,\n                data: m\n            },\n            {\n                type: 6,\n                data: l\n            },\n            {\n                type: 12,\n                data: d\n            }\n        ];\n        return y.push(...N(r, i, p)), {\n            name: \"GatherElements\",\n            shaderCache: {\n                inputDependencies: [\n                    \"rank\",\n                    \"rank\"\n                ]\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: p,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(m / 64)\n                    },\n                    programUniforms: y\n                }),\n            getShaderSource: ($)=>`\n      ${$.registerUniform(\"outputSize\", \"u32\").registerUniform(\"axisDimLimit\", \"i32\").registerUniform(\"axis\", \"u32\").declareVariables(u, h, _)}\n      ${$.mainStart()}\n      ${$.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n\n      let outputIndices = ${_.offsetToIndices(\"global_idx\")};\n\n      var idx = ${h.getByOffset(\"global_idx\")};\n      if (idx < 0) {\n        idx = idx + uniforms.axisDimLimit;\n      }\n      var inputIndices = ${u.type.indices}(outputIndices);\n      ${u.indicesSet(\"inputIndices\", \"uniforms.axis\", \"u32(idx)\")};\n      let value = ${u.getByIndices(\"inputIndices\")};\n\n      ${_.setByOffset(\"global_idx\", \"value\")};\n  }`\n        };\n    }, Ed = (e1)=>re({\n            axis: e1.axis\n        }), Pd = (e1, t)=>{\n        let r = e1.inputs;\n        Uf(r), e1.compute(Nf(e1.inputs, t));\n    };\n});\nvar Vf, Wf, Od, Dd, Bd = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    ae();\n    Vf = (e1)=>{\n        if (!e1) throw new Error(\"Input is missing\");\n        if (e1.length < 2 || e1.length > 3) throw new Error(\"Invaid input number.\");\n        if (e1.length === 3 && e1[2].dims.length > 2) throw new Error(\"Invalid input shape of C\");\n        if (e1[0].dataType !== e1[1].dataType || e1.length === 3 && e1[0].dataType !== e1[2].dataType) throw new Error(\"Input types are mismatched\");\n    }, Wf = (e1, t)=>{\n        let r = e1[0].dims.slice(), n = e1[1].dims.slice(), [o, i, a] = Vr.getShapeOfGemmResult(r, t.transA, n, t.transB, e1.length === 3 ? e1[2].dims : void 0), d = [\n            o,\n            i\n        ];\n        if (!d) throw new Error(\"Can't use gemm on the given tensors\");\n        let l = 16, p = Math.ceil(i / l), m = Math.ceil(o / l), u = !0, h = C.size(d), _ = [\n            {\n                type: 12,\n                data: u ? p : h\n            },\n            {\n                type: 12,\n                data: o\n            },\n            {\n                type: 12,\n                data: i\n            },\n            {\n                type: 12,\n                data: a\n            },\n            {\n                type: 1,\n                data: t.alpha\n            },\n            {\n                type: 1,\n                data: t.beta\n            }\n        ], y = [\n            \"type\",\n            \"type\"\n        ];\n        e1.length === 3 && (_.push(...N(e1[2].dims)), y.push(\"rank\")), _.push(...N(d));\n        let g = ($)=>{\n            let v = \"\";\n            t.transA && t.transB ? v = \"value += a[k * uniforms.M + m] * b[n * uniforms.K + k];\" : t.transA && !t.transB ? v = \"value += a[k * uniforms.M + m] * b[k * uniforms.N + n];\" : !t.transA && t.transB ? v = \"value += a[m * uniforms.K + k] * b[n * uniforms.K + k];\" : !t.transA && !t.transB && (v = \"value += a[m * uniforms.K + k] * b[k * uniforms.N + n];\");\n            let S = t.alpha === 1 ? \"\" : \"value *= uniforms.alpha;\", T = E(\"a\", e1[0].dataType, e1[0].dims), A = E(\"b\", e1[1].dataType, e1[1].dims), k = T.type.value, P = null, D = [\n                T,\n                A\n            ];\n            e1.length === 3 && (P = E(\"c\", e1[2].dataType, e1[2].dims.length), D.push(P));\n            let R = M(\"output\", e1[0].dataType, d.length);\n            D.push(R);\n            let G = [\n                {\n                    name: \"output_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"M\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"N\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"K\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"alpha\",\n                    type: \"f32\"\n                },\n                {\n                    name: \"beta\",\n                    type: \"f32\"\n                }\n            ];\n            return `\n  ${$.registerUniforms(G).declareVariables(...D)}\n\n  ${$.mainStart()}\n    ${$.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n\n    let m = global_idx / uniforms.N;\n    let n = global_idx % uniforms.N;\n\n    var value = ${k}(0);\n    for (var k: u32 = 0u; k < uniforms.K; k++) {\n      ${v}\n    }\n\n    ${S}\n    ${(()=>P != null ? `let cOffset = ${P.broadcastedIndicesToOffset(\"vec2(m, n)\", R)}; value += ${k}(uniforms.beta) * ${P.getByOffset(\"cOffset\")};` : \"\")()}\n    output[global_idx] = value;\n  }`;\n        }, x = ($)=>{\n            let v = E(\"a\", e1[0].dataType, e1[0].dims), S = E(\"b\", e1[1].dataType, e1[1].dims), T = null, A = [\n                v,\n                S\n            ];\n            e1.length === 3 && (T = E(\"c\", e1[2].dataType, e1[2].dims.length), A.push(T));\n            let k = M(\"output\", e1[0].dataType, d.length);\n            A.push(k);\n            let P = [\n                {\n                    name: \"num_tile_n\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"M\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"N\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"K\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"alpha\",\n                    type: \"f32\"\n                },\n                {\n                    name: \"beta\",\n                    type: \"f32\"\n                }\n            ], D = \"\", R = \"\";\n            t.transA && t.transB ? (R = `\n      var col = tile_row_start + local_id.x;\n      var row = k_start + local_id.y;\n      if (col < uniforms.M && row < uniforms.K) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${v.type.value}(0);\n      }\n\n      col = k_start + local_id.x;\n      row = tile_col_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.N) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${S.type.value}(0);\n      }\n      `, D = \"value += tile_a[k][local_id.y] * tile_b[local_id.x][k];\") : t.transA && !t.transB ? (R = `\n      var col = tile_row_start + local_id.x;\n      var row = k_start + local_id.y;\n      if (col < uniforms.M && row < uniforms.K) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${v.type.value}(0);\n      }\n\n      col = tile_col_start + local_id.x;\n      row = k_start + local_id.y;\n      if (col < uniforms.N && row < uniforms.K) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${S.type.value}(0);\n      }\n      `, D = \"value += tile_a[k][local_id.y] * tile_b[k][local_id.x];\") : !t.transA && t.transB ? (R = `\n      var col = k_start + local_id.x;\n      var row = tile_row_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.M) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${v.type.value}(0);\n      }\n\n      col = k_start + local_id.x;\n      row = tile_col_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.N) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${S.type.value}(0);\n      }\n      `, D = \"value += tile_a[local_id.y][k] * tile_b[local_id.x][k];\") : !t.transA && !t.transB && (R = `\n      var col = k_start + local_id.x;\n      var row = tile_row_start + local_id.y;\n      if (col < uniforms.K && row < uniforms.M) {\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];\n      } else {\n        tile_a[local_id.y][local_id.x] = ${v.type.value}(0);\n      }\n\n      col = tile_col_start + local_id.x;\n      row = k_start + local_id.y;\n      if (col < uniforms.N && row < uniforms.K) {\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];\n      } else {\n        tile_b[local_id.y][local_id.x] = ${S.type.value}(0);\n      }\n      `, D = \"value += tile_a[local_id.y][k] * tile_b[k][local_id.x];\");\n            let G = t.alpha === 1 ? \"\" : \"value *= uniforms.alpha;\";\n            return `\n  ${$.registerUniforms(P).declareVariables(...A)}\n  var<workgroup> tile_a: array<array<${v.type.storage}, ${l}>, ${l}>;\n  var<workgroup> tile_b: array<array<${S.type.storage}, ${l}>, ${l}>;\n  ${$.mainStart([\n                l,\n                l,\n                1\n            ])}\n    let tile_col_start = (workgroup_index % uniforms.num_tile_n) * ${l};\n    let tile_row_start = (workgroup_index / uniforms.num_tile_n) * ${l};\n    let num_tiles = (uniforms.K - 1) / ${l} + 1;\n    var k_start = 0u;\n    var value = ${k.type.value}(0);\n    for (var t: u32 = 0u; t < num_tiles; t++) {\n      ${R}\n      k_start = k_start + ${l};\n      workgroupBarrier();\n\n      for (var k: u32 = 0u; k < ${l}; k++) {\n        ${D}\n      }\n      workgroupBarrier();\n    }\n\n    ${G}\n    let m = tile_row_start + local_id.y;\n    let n = tile_col_start + local_id.x;\n    ${(()=>T != null ? `let cOffset = ${T.broadcastedIndicesToOffset(\"vec2(m, n)\", k)}; value += ${k.type.value}(uniforms.beta) * ${T.getByOffset(\"cOffset\")};` : \"\")()}\n    if (m < uniforms.M && n < uniforms.N) {\n      output[m * uniforms.N + n] = value;\n    }\n  }`;\n        };\n        return u ? {\n            name: \"GemmShared\",\n            shaderCache: {\n                hint: `${t.cacheKey}`,\n                inputDependencies: y\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: d,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: p * m\n                    },\n                    programUniforms: _\n                }),\n            getShaderSource: x\n        } : {\n            name: \"Gemm\",\n            shaderCache: {\n                hint: `${t.cacheKey}`,\n                inputDependencies: y\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: d,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(h / 64)\n                    },\n                    programUniforms: _\n                }),\n            getShaderSource: g\n        };\n    }, Od = (e1)=>{\n        let t = e1.transA, r = e1.transB, n = e1.alpha, o = e1.beta;\n        return {\n            transA: t,\n            transB: r,\n            alpha: n,\n            beta: o,\n            cacheKey: `${e1.transA};${e1.transB};${e1.alpha === 1}`\n        };\n    }, Dd = (e1, t)=>{\n        Vf(e1.inputs), e1.compute(Wf(e1.inputs, t));\n    };\n});\nvar lt, _t, Ut, Nt, Lf, Gf, Hf, Ff, qf, Kf, jf, Yf, Md, Rd, Ud = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    [lt, _t, Ut, Nt] = [\n        0,\n        1,\n        2,\n        3\n    ], Lf = (e1)=>{\n        if (e1[0].dims.length !== 4) throw new Error(\"only 4-D tensor is supported.\");\n        if (e1[0].dims.length !== e1[1].dims.length) throw new Error(\"input dimensions must be equal to grid dimensions\");\n        if (e1[0].dims.length - 2 !== e1[1].dims[e1[1].dims.length - 1]) throw new Error(`last dimension of grid must be equal to ${e1[0].dims.length - 2}`);\n        if (e1[0].dims[0] !== e1[1].dims[0]) throw new Error(\"grid batch size must match input batch size\");\n    }, Gf = `\n  fn gs_get_cubic_coeffs(x: f32) -> vec4<f32> {\n    let cubic_alpha = -0.75f;\n    let x_abs = abs(x);\n    var coeffs: vec4<f32>;\n    coeffs[0] = (((cubic_alpha * (x_abs + 1) - 5 * cubic_alpha) * (x_abs + 1) + 8 * cubic_alpha) * (x_abs + 1) - 4 * cubic_alpha);\n    coeffs[1] = (((cubic_alpha + 2) * x_abs - (cubic_alpha + 3)) * x_abs * x_abs + 1);\n    coeffs[2] = (((cubic_alpha + 2) * (1 - x_abs) - (cubic_alpha + 3)) * (1 - x_abs) * (1 - x_abs) + 1);\n    coeffs[3] = (((cubic_alpha * (2 - x_abs) - 5 * cubic_alpha) * (2 - x_abs) + 8 * cubic_alpha) * (2 - x_abs) - 4 * cubic_alpha);\n    return coeffs;\n  }\n`, Hf = (e1)=>`\n  fn gs_bicubic_interpolate(p: mat4x4<${e1}>, x: f32, y: f32) -> ${e1} {\n    var v: vec4<f32>;\n    var coeffs = gs_get_cubic_coeffs(x);\n    for (var i = 0; i < 4; i++) {\n      v[i] = coeffs[0] * p[i][0] + coeffs[1] * p[i][1] + coeffs[2] * p[i][2] + coeffs[3] * p[i][3];\n    }\n    coeffs = gs_get_cubic_coeffs(y);\n    let pixel = ${e1}(coeffs[0] * v[0] + coeffs[1] * v[1] + coeffs[2] * v[2] + coeffs[3] * v[3]);\n    return pixel;\n  }\n`, Ff = (e1)=>`\n  fn gs_denormalize(n: f32, length: i32) -> f32 {\n    ${e1.alignCorners === 0 ? `\n    // alignCorners: false => [-1, 1] to [-0.5, length - 0.5]\n    return ((n + 1.0) * f32(length) - 1.0) / 2.0;\n    ` : `\n    // alignCorners: true => [-1, 1] to [0, length - 1]\n    return (n + 1.0) / 2.0 * (f32(length - 1));\n    `}\n  }\n`, qf = (e1)=>`\n  ${e1.paddingMode === \"reflection\" ? `\n      fn gs_reflect(x: i32, x_min: f32, x_max: f32) -> u32 {\n        var dx = 0.0;\n        var fx = f32(x);\n        let range = x_max - x_min;\n        if (fx < x_min) {\n          dx = x_min - fx;\n          let n = u32(dx / range);\n          let r = dx - f32(n) * range;\n          if (n % 2 == 0) {\n            fx = x_min + r;\n          } else {\n            fx = x_max - r;\n          }\n        } else if (fx > x_max) {\n          dx = fx - x_max;\n          let n = u32(dx / range);\n          let r = dx - f32(n) * range;\n          if (n % 2 == 0) {\n            fx = x_max - r;\n          } else {\n            fx = x_min + r;\n          }\n        }\n        return u32(fx);\n      }` : \"\"}\n`, Kf = (e1, t, r)=>`\n  fn pixel_at_grid(r: i32, c: i32, H: i32, W: i32, batch: u32, channel: u32, border: vec4<f32>) -> ${t} {\n     var pixel = ${t}(0);\n     var indices = vec4<u32>(0);\n     indices[${lt}] = batch;\n     indices[${_t}] = channel;` + (()=>{\n            switch(r.paddingMode){\n                case \"zeros\":\n                    return `\n          if (r >= 0 && r < H && c >=0 && c < W) {\n            indices[${Ut}] = u32(r);\n            indices[${Nt}] = u32(c);\n          }\n        `;\n                case \"border\":\n                    return `\n          indices[${Ut}] = u32(clamp(r, 0, H - 1));\n          indices[${Nt}] = u32(clamp(c, 0, W - 1));\n        `;\n                case \"reflection\":\n                    return `\n          indices[${Ut}] = gs_reflect(r, border[1], border[3]);\n          indices[${Nt}] = gs_reflect(c, border[0], border[2]);\n        `;\n                default:\n                    throw new Error(`padding mode ${r.paddingMode} is not supported`);\n            }\n        })() + `\n    return ${e1.getByIndices(\"indices\")};\n  }\n`, jf = (e1, t, r)=>(()=>{\n            switch(r.mode){\n                case \"nearest\":\n                    return `\n          let result = pixel_at_grid(i32(round(y)), i32(round(x)), H_in, W_in, indices[${lt}], indices[${_t}], border);\n        `;\n                case \"bilinear\":\n                    return `\n          let x1 = i32(floor(x));\n          let y1 = i32(floor(y));\n          let x2 = x1 + 1;\n          let y2 = y1 + 1;\n\n          let p11 = pixel_at_grid(y1, x1, H_in, W_in, indices[${lt}], indices[${_t}], border);\n          let p12 = pixel_at_grid(y1, x2, H_in, W_in, indices[${lt}], indices[${_t}], border);\n          let p21 = pixel_at_grid(y2, x1, H_in, W_in, indices[${lt}], indices[${_t}], border);\n          let p22 = pixel_at_grid(y2, x2, H_in, W_in, indices[${lt}], indices[${_t}], border);\n\n          let dx2 = ${t}(f32(x2) - x);\n          let dx1 = ${t}(x - f32(x1));\n          let dy2 = ${t}(f32(y2) - y);\n          let dy1 = ${t}(y - f32(y1));\n          let result = dy2 * (dx2 * p11 + dx1 * p12) + dy1 * (dx2 * p21 + dx1 * p22);\n        `;\n                case \"bicubic\":\n                    return `\n          let x0 = i32(floor(x)) - 1;\n          let y0 = i32(floor(y)) - 1;\n          var p: mat4x4<${t}>;\n          for (var h = 0; h < 4; h++) {\n            for (var w = 0; w < 4; w++) {\n              p[h][w] = pixel_at_grid(h + y0, w + x0, H_in, W_in, indices[${lt}], indices[${_t}], border);\n            }\n          }\n\n          let dx = x - f32(x0 + 1);\n          let dy = y - f32(y0 + 1);\n          let result = gs_bicubic_interpolate(p, dx, dy);\n        `;\n                default:\n                    throw new Error(`mode ${r.mode} is not supported`);\n            }\n        })() + `${e1.setByOffset(\"global_idx\", \"result\")}`, Yf = (e1, t)=>{\n        let r = E(\"x\", e1[0].dataType, e1[0].dims.length), n = [\n            e1[1].dims[0],\n            e1[1].dims[1],\n            e1[1].dims[2]\n        ], o = E(\"grid\", e1[1].dataType, n.length, 2), i = [\n            e1[0].dims[0],\n            e1[0].dims[1],\n            e1[1].dims[1],\n            e1[1].dims[2]\n        ];\n        t.format === \"NHWC\" && (i = [\n            e1[0].dims[0],\n            e1[1].dims[1],\n            e1[1].dims[2],\n            e1[0].dims[3]\n        ], [lt, _t, Ut, Nt] = [\n            0,\n            3,\n            1,\n            2\n        ]);\n        let a = M(\"output\", e1[0].dataType, i.length), d = r.type.value, l = C.size(i), p = [\n            {\n                type: 12,\n                data: l\n            },\n            ...N(e1[0].dims, n, i)\n        ], m = (u)=>`\n  ${u.registerUniform(\"output_size\", \"u32\").declareVariables(r, o, a)}\n  ${Gf}\n  ${Hf(d)}\n  ${Ff(t)}\n  ${qf(t)}\n  ${Kf(r, d, t)}\n\n  ${u.mainStart()}\n    ${u.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n      let H_in = i32(uniforms.x_shape[${Ut}]);\n      let W_in = i32(uniforms.x_shape[${Nt}]);\n\n      ${t.alignCorners === 0 ? `\n      let x_min = -0.5;\n      let x_max = f32(W_in) - 0.5;\n      let y_min = -0.5;\n      let y_max = f32(H_in) - 0.5;\n      ` : `\n      let x_min = 0.0;\n      let x_max = f32(W_in) - 1.0;\n      let y_min = 0.0;\n      let y_max = f32(H_in) - 1.0;\n      `};\n      let border = vec4<f32>(x_min, y_min, x_max, y_max);\n\n      let indices = ${a.offsetToIndices(\"global_idx\")};\n      var grid_indices = vec3<u32>(indices[${lt}], indices[${Ut}], indices[${Nt}]);\n      let nxy = ${o.getByIndices(\"grid_indices\")};\n      var x = gs_denormalize(f32(nxy[0]), W_in);\n      var y = gs_denormalize(f32(nxy[1]), H_in);\n\n      ${jf(a, d, t)}\n  }`;\n        return {\n            name: \"GridSample\",\n            shaderCache: {\n                hint: `${t.cacheKey}`,\n                inputDependencies: [\n                    \"type\",\n                    \"type\"\n                ]\n            },\n            getRunData: (u)=>{\n                let h = C.size(i);\n                return {\n                    outputs: [\n                        {\n                            dims: i,\n                            dataType: u[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(h / 64)\n                    },\n                    programUniforms: p\n                };\n            },\n            getShaderSource: m\n        };\n    }, Md = (e1, t)=>{\n        Lf(e1.inputs), e1.compute(Yf(e1.inputs, t));\n    }, Rd = (e1)=>re({\n            alignCorners: e1.align_corners,\n            mode: e1.mode,\n            paddingMode: e1.padding_mode,\n            format: e1.format\n        });\n});\nvar Be, Xf, Vd, Nd, Jf, tr, Wd, So = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    Nr();\n    Fr();\n    ae();\n    dt();\n    Be = (e1, t)=>e1.length > t && e1[t].dims.length > 0 ? e1[t] : void 0, Xf = (e1, t)=>{\n        let r = e1[0], n = Be(e1, 1), o = Be(e1, 2), i = Be(e1, 3), a = Be(e1, 4), d = Be(e1, 5), l = Be(e1, 6), p = Be(e1, 7);\n        if (r.dims.length !== 3 && r.dims.length !== 5) throw new Error(\"Input query is expected to have 3 or 5 dimensions\");\n        let m = r.dims[0], u = r.dims[1], h = r.dims.length === 3 ? r.dims[2] : t.numHeads * r.dims[4], _ = u, y = 0, g = 0, x = Math.floor(h / t.numHeads);\n        if (l && p && C.size(l.dims) && C.size(p.dims)) {\n            if (l.dims.length !== 4) throw new Error('Input \"past_key\" is expected to have 4 dimensions');\n            if (l.dims[0] !== m || l.dims[1] !== t.numHeads || l.dims[3] !== x) throw new Error('Input \"past_key\" shape (batch_size, num_heads, past_sequence_length, head_size)');\n            if (p.dims[0] !== m || p.dims[1] !== t.numHeads || p.dims[3] !== x) throw new Error('Input \"past_value\" shape (batch_size, num_heads, past_sequence_length, head_size)');\n            if (l.dims[2] !== p.dims[2]) throw new Error('Input \"past_key\" and \"past_value\" shall have same dim 2 (past_sequence_length)');\n            if (p.dims.length !== 4) throw new Error('Input \"past_value\" is expected to have 4 dimensions');\n            y = l.dims[2], g = l.dims[2];\n        } else if (l && C.size(l.dims) || p && C.size(p.dims)) throw new Error('Input \"past_key\" and \"past_value\" shall be both present or both absent');\n        let $;\n        if (n && C.size(n.dims) > 0) {\n            if (r.dims.length !== 3) throw new Error('Input \"query\" is expected to have 3 dimensions when key is given');\n            if (n.dims.length < 3 || n.dims.length > 5) throw new Error('Input \"key\" is expected to have 3, 4, or 5 dimensions');\n            if (r.dims[0] !== n.dims[0]) throw new Error('Input \"query\" and \"key\" shall have same dim 0 (batch size)');\n            if (n.dims.length === 3) {\n                if (n.dims[2] !== r.dims[2]) throw new Error('Input \"query\" and \"key\" shall have same dim 2 (hidden_size)');\n                $ = 2, _ = n.dims[1];\n            } else if (n.dims.length === 5) {\n                if (n.dims[2] !== t.numHeads || n.dims[3] !== 2 || n.dims[4] !== x) throw new Error('Expect \"key\" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');\n                if (o) throw new Error('Expect \"value\" be none when \"key\" has packed kv format.');\n                $ = 5, _ = n.dims[1];\n            } else {\n                if (n.dims[1] !== t.numHeads || n.dims[3] !== x) throw new Error('Expect \"key\" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');\n                $ = 0, _ = n.dims[2];\n            }\n        } else {\n            if (r.dims.length !== 5) throw new Error('Input \"query\" is expected to have 5 dimensions when key is empty');\n            if (r.dims[2] !== t.numHeads || r.dims[3] !== 3) throw new Error('Expect \"query\" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');\n            $ = 3;\n        }\n        if (i && C.size(i.dims) > 0) {\n            if (i.dims.length !== 1) throw new Error('Input \"bias\" is expected to have 1 dimension');\n            if (n && n.dims.length === 5 && n.dims[3] === 2) throw new Error(\"bias is not allowed for packed kv.\");\n        }\n        let v = y + _, S = 0;\n        if (a && C.size(a.dims) > 0) {\n            S = 8;\n            let P = a.dims;\n            throw P.length === 1 ? P[0] === m ? S = 1 : P[0] === 3 * m + 2 && (S = 3) : P.length === 2 && P[0] === m && P[1] === v && (S = 5), S === 8 ? new Error('Input \"key_padding_mask\" shape shall be (batch_size) or (batch_size, total_sequence_length)') : new Error(\"Mask not supported\");\n        }\n        let T = !1, A = h;\n        if (o && C.size(o.dims) > 0) {\n            if (o.dims.length !== 3 && o.dims.length !== 4) throw new Error('Input \"value\" is expected to have 3 or 4 dimensions');\n            if (r.dims[0] !== o.dims[0]) throw new Error('Input \"query\" and \"value\" shall have same dim 0 (batch_size)');\n            if (o.dims.length === 3) {\n                if (_ !== o.dims[1]) throw new Error('Input \"key\" and \"value\" shall have the same dim 1 (kv_sequence_length)');\n                A = o.dims[2];\n            } else {\n                if (_ !== o.dims[2]) throw new Error('Input \"key\" and \"value\" shall have the same dim 2 (kv_sequence_length)');\n                A = o.dims[1] * o.dims[3], T = !0;\n            }\n        }\n        let k = !1;\n        if (a && C.size(a.dims) > 0) throw new Error(\"Key padding mask is not supported\");\n        if (d && C.size(d.dims) > 0) {\n            if (d.dims.length !== 4) throw new Error('Input \"attention_bias\" is expected to have 4 dimensions');\n            if (d.dims[0] !== m || d.dims[1] !== t.numHeads || d.dims[2] !== u || d.dims[3] !== v) throw new Error('Expect \"attention_bias\" shape (batch_size, num_heads, sequence_length, total_sequence_length)');\n        }\n        return {\n            batchSize: m,\n            sequenceLength: u,\n            pastSequenceLength: y,\n            kvSequenceLength: _,\n            totalSequenceLength: v,\n            maxSequenceLength: g,\n            inputHiddenSize: 0,\n            hiddenSize: h,\n            vHiddenSize: A,\n            headSize: x,\n            vHeadSize: Math.floor(A / t.numHeads),\n            numHeads: t.numHeads,\n            isUnidirectional: !1,\n            pastPresentShareBuffer: !1,\n            maskFilterValue: t.maskFilterValue,\n            maskType: S,\n            scale: t.scale,\n            broadcastResPosBias: k,\n            passPastInKv: T,\n            qkvFormat: $\n        };\n    }, Vd = (e1)=>re({\n            ...e1\n        }), Nd = re({\n        perm: [\n            0,\n            2,\n            1,\n            3\n        ]\n    }), Jf = (e1, t, r, n, o, i, a)=>{\n        let d = [\n            n,\n            o,\n            i\n        ], l = C.size(d), p = [\n            {\n                type: 12,\n                data: l\n            },\n            {\n                type: 12,\n                data: a\n            },\n            {\n                type: 12,\n                data: i\n            }\n        ], m = (u)=>{\n            let h = M(\"qkv_with_bias\", t.dataType, d), _ = E(\"qkv\", t.dataType, d), y = E(\"bias\", r.dataType, d), g = [\n                {\n                    name: \"output_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"bias_offset\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"hidden_size\",\n                    type: \"u32\"\n                }\n            ];\n            return `\n  ${u.registerUniforms(g).declareVariables(_, y, h)}\n  ${u.mainStart()}\n    ${u.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;\n\n    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];\n  }`;\n        };\n        return e1.compute({\n            name: \"MultiHeadAttentionAddBias\",\n            shaderCache: {\n                inputDependencies: [\n                    \"type\",\n                    \"type\"\n                ]\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: d,\n                            dataType: t.dataType,\n                            gpuDataType: 0\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(l / 64)\n                    },\n                    programUniforms: p\n                }),\n            getShaderSource: m\n        }, {\n            inputs: [\n                t,\n                r\n            ],\n            outputs: [\n                -1\n            ]\n        })[0];\n    }, tr = (e1, t, r, n, o, i, a, d)=>{\n        let l = i;\n        if (a && C.size(a.dims) > 0) {\n            if (n === 1) throw new Error(\"AddBiasReshape is not implemented. Please export your model with packed QKV or KV\");\n            return l = Jf(e1, i, a, t, n, r * o, d), l = l.reshape([\n                t,\n                n,\n                r,\n                o\n            ]), r === 1 || n === 1 ? l : e1.compute(Pe(l, Nd.perm), {\n                inputs: [\n                    l\n                ],\n                outputs: [\n                    -1\n                ]\n            })[0];\n        } else return i.dims.length === 3 && (l = i.reshape([\n            t,\n            n,\n            r,\n            o\n        ])), r === 1 || n === 1 ? l : e1.compute(Pe(l, Nd.perm), {\n            inputs: [\n                l\n            ],\n            outputs: [\n                -1\n            ]\n        })[0];\n    }, Wd = (e1, t)=>{\n        let r = Xf(e1.inputs, t), n = e1.inputs[0], o = Be(e1.inputs, 1), i = Be(e1.inputs, 2), a = Be(e1.inputs, 3), d = Be(e1.inputs, 4), l = Be(e1.inputs, 5), p = Be(e1.inputs, 6), m = Be(e1.inputs, 7);\n        if (n.dims.length === 5) throw new Error(\"Packed QKV is not implemented\");\n        if (o?.dims.length === 5) throw new Error(\"Packed KV is not implemented\");\n        let u = o && i && o.dims.length === 4 && i.dims.length === 4, h = tr(e1, r.batchSize, r.numHeads, r.sequenceLength, r.headSize, n, a, 0);\n        if (u) return Rt(e1, h, o, i, d, void 0, p, m, l, r);\n        if (!o || !i) throw new Error(\"key and value must be provided\");\n        let _ = tr(e1, r.batchSize, r.numHeads, r.kvSequenceLength, r.headSize, o, a, r.hiddenSize), y = tr(e1, r.batchSize, r.numHeads, r.kvSequenceLength, r.vHeadSize, i, a, 2 * r.hiddenSize);\n        Rt(e1, h, _, y, d, void 0, p, m, l, r);\n    };\n});\nvar eh, th, rh, nh, To, Ld, Gd, Io = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    eh = (e1)=>{\n        if (!e1 || e1.length < 1) throw new Error(\"too few inputs\");\n    }, th = (e1, t)=>{\n        let r = [], n = t.numOutputs;\n        return e1[1].dims[0] > 0 && (e1[1].getBigInt64Array().forEach((o)=>r.push(Number(o))), n = r.length), re({\n            numOutputs: n,\n            axis: t.axis,\n            splitSizes: r\n        });\n    }, rh = (e1)=>`\nfn calculateOutputIndex(index: u32) -> u32 {\n    for (var i: u32 = 0u; i < ${e1}u; i += 1u ) {\n    if (index < ${F(\"uniforms.size_in_split_axis\", \"i\", e1)}) {\n        return i;\n    }\n    }\n    return ${e1}u;\n}`, nh = (e1)=>{\n        let t = e1.length, r = [];\n        for(let n = 0; n < t; ++n){\n            let o = e1[n].setByIndices(\"indices\", \"input[global_idx]\");\n            t === 1 ? r.push(o) : n === 0 ? r.push(`if (output_number == ${n}u) { ${o} }`) : n === t - 1 ? r.push(`else { ${o} }`) : r.push(`else if (output_number == ${n}) { ${o} }`);\n        }\n        return `\n      fn writeBufferData(output_number: u32, indices: ${e1[0].type.indices}, global_idx: u32) {\n        ${r.join(`\n`)}\n      }`;\n    }, To = (e1, t)=>{\n        let r = e1[0].dims, n = C.size(r), o = e1[0].dataType, i = C.normalizeAxis(t.axis, r.length), a = new Array(t.numOutputs), d = E(\"input\", o, r.length), l = new Array(t.numOutputs), p = [], m = [], u = 0, h = [\n            {\n                type: 12,\n                data: n\n            }\n        ];\n        for(let y = 0; y < t.numOutputs; y++){\n            u += t.splitSizes[y], l[y] = u;\n            let g = r.slice();\n            g[i] = t.splitSizes[y], m.push(g), a[y] = M(`output${y}`, o, g.length), p.push({\n                dims: m[y],\n                dataType: e1[0].dataType\n            });\n        }\n        h.push({\n            type: 12,\n            data: l\n        }, ...N(r, ...m));\n        let _ = (y)=>`\n  ${y.registerUniform(\"input_size\", \"u32\").registerUniform(\"size_in_split_axis\", \"u32\", l.length).declareVariables(d, ...a)}\n  ${rh(l.length)}\n  ${nh(a)}\n\n  ${y.mainStart()}\n    ${y.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.input_size\")}\n\n    var indices = ${d.offsetToIndices(\"global_idx\")};\n    var index = ${d.indicesGet(\"indices\", i)};\n    let output_number = calculateOutputIndex(index);\n    if (output_number != 0) {\n      index -= ${F(\"uniforms.size_in_split_axis\", \"output_number - 1u\", l.length)};\n      ${d.indicesSet(\"indices\", i, \"index\")};\n    }\n    writeBufferData(output_number, indices, global_idx);\n  }`;\n        return {\n            name: \"Split\",\n            shaderCache: {\n                hint: t.cacheKey,\n                inputDependencies: [\n                    \"rank\"\n                ]\n            },\n            getShaderSource: _,\n            getRunData: ()=>({\n                    outputs: p,\n                    dispatchGroup: {\n                        x: Math.ceil(n / 64)\n                    },\n                    programUniforms: h\n                })\n        };\n    }, Ld = (e1, t)=>{\n        eh(e1.inputs);\n        let r = e1.inputs.length === 1 ? t : th(e1.inputs, t);\n        e1.compute(To(e1.inputs, r), {\n            inputs: [\n                0\n            ]\n        });\n    }, Gd = (e1)=>{\n        let t = e1.axis, r = e1.splitSizes, n = e1.numOutputs < 0 ? r.length : e1.numOutputs;\n        if (n !== r.length) throw new Error(\"numOutputs and splitSizes lengh must be equal\");\n        return re({\n            axis: t,\n            numOutputs: n,\n            splitSizes: r\n        });\n    };\n});\nvar oh, ih, Hd, Fd, qd = U(()=>{\n    \"use strict\";\n    Se();\n    Fr();\n    So();\n    Io();\n    dt();\n    oh = (e1, t)=>{\n        if (t.doRotary) throw new Error(\"GroupQuerryAttention do_rotary attribute is not supported\");\n        if (t.doRotary && e1.length <= 7) throw new Error(\"cos_cache and sin_cache inputs are required if do_rotary is specified\");\n        let r = e1[0], n = e1[1], o = e1[2], i = e1[3], a = e1[4];\n        if (t.localWindowSize !== -1) throw new Error(\"Local attention is not supported\");\n        if (t.softcap !== 0) throw new Error(\"Softcap is not supported\");\n        if (t.rotaryInterleaved !== 0) throw new Error(\"Rotary interleaved is not supported\");\n        if (t.smoothSoftmax) throw new Error(\"Smooth softmax is not supported\");\n        if (r.dims.length !== 3 && r.dims.length !== 5) throw new Error(\"Input query is expected to have 3 or 5 dimensions\");\n        let d = !1, l = r.dims[0], p = r.dims[1], m = r.dims.length === 3 ? d ? r.dims[2] / 3 : r.dims[2] : t.numHeads * r.dims[4], u = p, h = 0, _ = !n || n.dims.length === 0, y = Math.floor(_ ? m / (t.numHeads + 2 * t.kvNumHeads) : m / t.numHeads);\n        _ && (m = y * t.numHeads);\n        let g = i && i.dims.length !== 0, x = a && a.dims.length !== 0;\n        if (g && i.dims.length === 4 && i.dims[0] === l && i.dims[1] !== t.kvNumHeads && i.dims[2] === t.kvNumHeads && i.dims[3] === y) throw new Error(\"BSNH pastKey/pastValue is not supported\");\n        if (g && x) {\n            if (i.dims.length !== 4) throw new Error('Input \"past_key\" is expected to have 4 dimensions');\n            if (a.dims.length !== 4) throw new Error('Input \"past_value\" is expected to have 4 dimensions');\n            h = i.dims[2];\n        } else if (g || x) throw new Error('Input \"past_key\" and \"past_value\" shall be both present or both absent');\n        let v = 1;\n        if (n && n.dims.length > 0) {\n            if (r.dims.length !== 3) throw new Error('Input \"query\" is expected to have 3 dimensions when key is given');\n            if (n.dims.length < 3 || n.dims.length > 5) throw new Error('Input \"key\" is expected to have 3, 4, or 5 dimensions');\n            if (r.dims[0] !== n.dims[0]) throw new Error('Input \"query\" and \"key\" shall have same dim 0 (batch size)');\n            if (n.dims.length === 3) {\n                if (r.dims[2] % n.dims[2] !== 0) throw new Error('Dimension 2 of \"query\" should be a multiple of \"key\"');\n                u = n.dims[1];\n            } else if (n.dims.length === 5) {\n                if (n.dims[2] !== t.numHeads || n.dims[3] !== 2 || n.dims[4] !== y) throw new Error('Expect \"key\" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');\n                if (o) throw new Error('Expect \"value\" be none when \"key\" has packed kv format.');\n                u = n.dims[1];\n            } else {\n                if (n.dims[1] !== t.numHeads || n.dims[3] !== y) throw new Error('Expect \"key\" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');\n                u = n.dims[2];\n            }\n        } else {\n            if (r.dims.length !== 3 && r.dims.length !== 5) throw new Error('Input \"query\" is expected to have 3 or 5 dimensions when key is empty');\n            if (r.dims.length === 5 && (r.dims[2] !== t.numHeads || r.dims[3] !== 3)) throw new Error('Expect \"query\" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');\n            v = 3;\n        }\n        let S = 0, T = !1, A = t.kvNumHeads ? y * t.kvNumHeads : m;\n        if (o && o.dims.length > 0) {\n            if (o.dims.length !== 3 && o.dims.length !== 4) throw new Error('Input \"value\" is expected to have 3 or 4 dimensions');\n            if (r.dims[0] !== o.dims[0]) throw new Error('Input \"query\" and \"value\" shall have same dim 0 (batch_size)');\n            if (o.dims.length === 3) {\n                if (u !== o.dims[1]) throw new Error('Input \"key\" and \"value\" shall have the same dim 1 (kv_sequence_length)');\n                A = o.dims[2];\n            } else {\n                if (u !== o.dims[2]) throw new Error('Input \"past_key\" and \"past_value\" shall have the same dim 2 (kv_sequence_length)');\n                A = o.dims[1] * o.dims[3], T = !0;\n            }\n        }\n        let k = e1.length > 4 ? e1[5] : void 0;\n        if (k && k.dims.length !== 1 && k.dims[0] !== l) throw new Error('Input \"seqlens\" is expected to have 1 dimension and the same dim 0 as batch_size');\n        let P = -1, D = -1, R = !1;\n        return {\n            batchSize: l,\n            sequenceLength: p,\n            pastSequenceLength: h,\n            kvSequenceLength: u,\n            totalSequenceLength: P,\n            maxSequenceLength: D,\n            inputHiddenSize: 0,\n            hiddenSize: m,\n            vHiddenSize: A,\n            headSize: y,\n            vHeadSize: Math.floor(A / t.kvNumHeads),\n            numHeads: t.numHeads,\n            kvNumHeads: t.kvNumHeads,\n            nReps: t.numHeads / t.kvNumHeads,\n            pastPresentShareBuffer: !1,\n            maskType: S,\n            scale: t.scale,\n            broadcastResPosBias: R,\n            passPastInKv: T,\n            qkvFormat: v\n        };\n    }, ih = re({\n        perm: [\n            0,\n            2,\n            1,\n            3\n        ]\n    }), Hd = (e1, t, r)=>{\n        let n = t, o = r.kvNumHeads;\n        return t.dims.length === 3 && r.kvSequenceLength !== 0 && (n = t.reshape([\n            r.batchSize,\n            r.kvSequenceLength,\n            o,\n            r.headSize\n        ]), n = e1.compute(Pe(n, ih.perm), {\n            inputs: [\n                n\n            ],\n            outputs: [\n                -1\n            ]\n        })[0]), n;\n    }, Fd = (e1, t)=>{\n        let r = oh(e1.inputs, t);\n        if (e1.inputs[0].dims.length === 5) throw new Error(\"Packed QKV is not implemented\");\n        if (e1.inputs[1]?.dims.length === 5) throw new Error(\"Packed KV is not implemented\");\n        let n = e1.inputs[0], o = e1.inputs[1] && e1.inputs[1].dims.length > 0 ? e1.inputs[1] : void 0, i = e1.inputs[2] && e1.inputs[2].dims.length > 0 ? e1.inputs[2] : void 0, a = e1.inputs[3] && e1.inputs[3].dims.length !== 0 ? e1.inputs[3] : void 0, d = e1.inputs[4] && e1.inputs[4].dims.length !== 0 ? e1.inputs[4] : void 0, l = e1.inputs.length > 4 ? e1.inputs[5] : void 0, p = e1.inputs.length > 5 ? e1.inputs[6] : void 0, m = r.kvNumHeads ? r.kvNumHeads : r.numHeads, u = re({\n            axis: 2,\n            numOutputs: 3,\n            splitSizes: [\n                r.numHeads * r.headSize,\n                m * r.headSize,\n                m * r.headSize\n            ]\n        }), [h, _, y] = !o && !i ? e1.compute(To([\n            n\n        ], u), {\n            inputs: [\n                n\n            ],\n            outputs: [\n                -1,\n                -1,\n                -1\n            ]\n        }) : [\n            n,\n            o,\n            i\n        ], g = tr(e1, r.batchSize, r.numHeads, r.sequenceLength, r.headSize, h, void 0, 0);\n        Rt(e1, g, Hd(e1, _, r), Hd(e1, y, r), void 0, void 0, a, d, void 0, r, l, p);\n    };\n});\nvar Kd, ah, sh, jd, Yd = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    dt();\n    ae();\n    Kd = (e1, t, r, n, o, i, a, d)=>{\n        let l = me(i), p = l === 1 ? \"f32\" : `vec${l}f`, m = l === 1 ? \"vec2f\" : `mat2x${l}f`, u = o * a, h = 64;\n        u === 1 && (h = 256);\n        let _ = [\n            o,\n            a,\n            i / l\n        ], y = [\n            o,\n            a,\n            2\n        ], g = [\n            \"rank\",\n            \"type\",\n            \"type\"\n        ], x = [];\n        x.push(...N(_, y));\n        let $ = (v)=>{\n            let S = E(\"x\", t.dataType, 3, l), T = E(\"scale\", r.dataType, r.dims), A = E(\"bias\", n.dataType, n.dims), k = M(\"output\", 1, 3, 2), P = [\n                S,\n                T,\n                A,\n                k\n            ];\n            return `\n  var<workgroup> workgroup_shared : array<${m}, ${h}>;\n  const workgroup_size = ${h}u;\n  ${v.declareVariables(...P)}\n  ${v.mainStart(h)}\n    let batch = workgroup_index / uniforms.x_shape[1];\n    let channel = workgroup_index % uniforms.x_shape[1];\n    let hight = uniforms.x_shape[2];\n    // initialize workgroup memory\n    var sum = ${p}(0);\n    var squared_sum = ${p}(0);\n    for (var h = local_idx; h < hight; h += workgroup_size) {\n      let value = ${p}(${S.get(\"batch\", \"channel\", \"h\")});\n      sum += value;\n      squared_sum += value * value;\n    }\n    workgroup_shared[local_idx] = ${m}(sum, squared_sum);\n    workgroupBarrier();\n\n    for (var currSize = workgroup_size >> 1;  currSize > 0; currSize = currSize >> 1) {\n      if (local_idx < currSize) {\n        workgroup_shared[local_idx] = workgroup_shared[local_idx] + workgroup_shared[local_idx + currSize];\n      }\n      workgroupBarrier();\n    }\n    if (local_idx == 0) {\n      let sum_final = ${Fe(\"workgroup_shared[0][0]\", l)} / f32(hight * ${l});\n      let squared_sum_final = ${Fe(\"workgroup_shared[0][1]\", l)} / f32(hight * ${l});\n\n      let inv_std_dev = inverseSqrt(squared_sum_final - sum_final * sum_final + f32(${d}));\n      let channel_scale = inv_std_dev * f32(scale[channel]);\n      let channel_shift = f32(bias[channel]) - sum_final * channel_scale;\n      output[workgroup_index] = vec2f(channel_scale, channel_shift);\n    }\n  }`;\n        };\n        return e1.compute({\n            name: \"InstanceNormComputeChannelScaleShift\",\n            shaderCache: {\n                hint: `${l};${d};${h}`,\n                inputDependencies: g\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: y,\n                            dataType: 1\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: u\n                    },\n                    programUniforms: x\n                }),\n            getShaderSource: $\n        }, {\n            inputs: [\n                t,\n                r,\n                n\n            ],\n            outputs: [\n                -1\n            ]\n        })[0];\n    }, ah = (e1, t, r)=>{\n        let n = t[0].dims, o = n, i = 2, a = n[0], d = n[1], l = C.sizeFromDimension(n, i), p = me(l), m = C.size(o) / p, u = Kd(e1, t[0], t[1], t[2], a, l, d, r.epsilon), h = [\n            a,\n            d,\n            l / p\n        ], _ = [\n            a,\n            d\n        ], y = [\n            \"type\",\n            \"none\"\n        ], g = (x)=>{\n            let $ = E(\"x\", t[0].dataType, h.length, p), v = E(\"scale_shift\", 1, _.length, 2), S = M(\"output\", t[0].dataType, h.length, p), T = [\n                $,\n                v,\n                S\n            ];\n            return `\n  ${x.registerUniform(\"output_size\", \"u32\").declareVariables(...T)}\n  ${x.mainStart()}\n  ${x.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n      let outputIndices = ${S.offsetToIndices(\"global_idx\")};\n      let batch = outputIndices[0];\n      let channel = outputIndices[1];\n      let scale_shift = ${v.getByIndices(\"vec2<u32>(batch, channel)\")};\n      let value = ${$.getByOffset(\"global_idx\")} * ${S.type.value}(scale_shift.x) + ${S.type.value}(scale_shift.y);\n      ${S.setByOffset(\"global_idx\", \"value\")};\n  }`;\n        };\n        e1.compute({\n            name: \"InstanceNormalization\",\n            shaderCache: {\n                hint: `${p}`,\n                inputDependencies: y\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: o,\n                            dataType: t[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(m / 64)\n                    },\n                    programUniforms: [\n                        {\n                            type: 12,\n                            data: m\n                        },\n                        ...N(h, _, h)\n                    ]\n                }),\n            getShaderSource: g\n        }, {\n            inputs: [\n                t[0],\n                u\n            ]\n        });\n    }, sh = (e1, t, r)=>{\n        let n = t[0].dims, o = n, i = n[0], a = n[n.length - 1], d = C.sizeFromDimension(n, 1) / a, l = me(a), p = C.size(o) / l, m = [\n            {\n                type: 12,\n                data: d\n            },\n            {\n                type: 12,\n                data: Math.floor(a / l)\n            }\n        ], u = [\n            \"type\",\n            \"type\"\n        ], h = !1, _ = [\n            0,\n            n.length - 1\n        ];\n        for(let $ = 0; $ < n.length - 2; $++)h = h || n[$ + 1] !== 1, _.push($ + 1);\n        h = h && n[n.length - 1] !== 1;\n        let y = h ? e1.compute(Pe(e1.inputs[0], _), {\n            inputs: [\n                e1.inputs[0]\n            ],\n            outputs: [\n                -1\n            ]\n        })[0] : e1.inputs[0].reshape(Array.from({\n            length: n.length\n        }, ($, v)=>n[_[v]])), g = Kd(e1, y, t[1], t[2], i, d, a, r.epsilon), x = ($)=>{\n            let v = _e(t[0].dataType), S = l === 1 ? \"vec2f\" : `mat${l}x2f`, T = (P)=>{\n                let D = P === 0 ? \"x\" : \"y\", R = l === 1 ? \"f32\" : `vec${l}f`;\n                switch(l){\n                    case 1:\n                        return `${v}(${R}(scale.${D}))`;\n                    case 2:\n                        return `vec2<${v}>(${R}(scale[0].${D}, scale[1].${D}))`;\n                    case 4:\n                        return `vec4<${v}>(${R}(scale[0].${D}, scale[1].${D}, scale[2].${D}, scale[3].${D}))`;\n                    default:\n                        throw new Error(`Not supported compoents ${l}`);\n                }\n            }, A = E(\"input\", t[0].dataType, t[0].dims, l), k = M(\"output\", t[0].dataType, o, l);\n            return `\n  @group(0) @binding(0) var<storage, read> input : array<${A.type.storage}>;\n  @group(0) @binding(1) var<storage, read> scale_input : array<${S}>;\n  @group(0) @binding(2) var<storage, read_write> output : array<${k.type.storage}>;\n  struct Uniforms {H: u32, C : u32};\n  @group(0) @binding(3) var<uniform> uniforms: Uniforms;\n\n  ${$.mainStart()}\n    let current_image_number = global_idx / (uniforms.C * uniforms.H);\n    let current_channel_number = global_idx % uniforms.C;\n\n    let scale_offset = current_image_number * uniforms.C + current_channel_number;\n    let scale = scale_input[scale_offset];\n    output[global_idx] = fma(input[global_idx], ${T(0)}, ${T(1)});\n  }`;\n        };\n        e1.compute({\n            name: \"InstanceNormalizationNHWC\",\n            shaderCache: {\n                hint: `${l}`,\n                inputDependencies: u\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: o,\n                            dataType: t[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(p / 64)\n                    },\n                    programUniforms: m\n                }),\n            getShaderSource: x\n        }, {\n            inputs: [\n                t[0],\n                g\n            ]\n        });\n    }, jd = (e1, t)=>{\n        t.format === \"NHWC\" ? sh(e1, e1.inputs, t) : ah(e1, e1.inputs, t);\n    };\n});\nvar uh, dh, Zd, Qd = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    ae();\n    uh = (e1)=>{\n        if (!e1 || e1.length < 2) throw new Error(\"layerNorm requires at least 2 inputs.\");\n    }, dh = (e1, t, r)=>{\n        let n = t.simplified, o = e1[0].dims, i = e1[1], a = !n && e1[2], d = o, l = C.normalizeAxis(t.axis, o.length), p = C.sizeToDimension(o, l), m = C.sizeFromDimension(o, l), u = C.size(i.dims), h = a ? C.size(a.dims) : 0;\n        if (u !== m || a && h !== m) throw new Error(`Size of X.shape()[axis:] == ${m}.\n       Size of scale and bias (if provided) must match this.\n       Got scale size of ${u} and bias size of ${h}`);\n        let _ = [];\n        for(let A = 0; A < o.length; ++A)A < l ? _.push(o[A]) : _.push(1);\n        let y = me(m), g = [\n            \"type\",\n            \"type\"\n        ], x = [\n            {\n                type: 12,\n                data: p\n            },\n            {\n                type: 1,\n                data: m\n            },\n            {\n                type: 12,\n                data: Math.floor(m / y)\n            },\n            {\n                type: 1,\n                data: t.epsilon\n            }\n        ];\n        a && g.push(\"type\");\n        let $ = r > 1, v = r > 2, S = (A)=>{\n            let k = _e(e1[0].dataType), P = [\n                E(\"x\", e1[0].dataType, e1[0].dims, y),\n                E(\"scale\", i.dataType, i.dims, y)\n            ];\n            a && P.push(E(\"bias\", a.dataType, a.dims, y)), P.push(M(\"output\", e1[0].dataType, d, y)), $ && P.push(M(\"mean_data_output\", 1, _)), v && P.push(M(\"inv_std_output\", 1, _));\n            let D = [\n                {\n                    name: \"norm_count\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"norm_size\",\n                    type: \"f32\"\n                },\n                {\n                    name: \"norm_size_vectorized\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"epsilon\",\n                    type: \"f32\"\n                }\n            ];\n            return `\n  ${A.registerUniforms(D).declareVariables(...P)}\n  ${A.mainStart()}\n    ${A.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.norm_count\")}\n    let offset = global_idx * uniforms.norm_size_vectorized;\n    var mean_vector = ${uo(\"f32\", y)};\n    var mean_square_vector = ${uo(\"f32\", y)};\n\n    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {\n      let value = ${Et(k, y, \"x[h + offset]\")};\n      mean_vector += value;\n      mean_square_vector += value * value;\n    }\n    let mean = ${Fe(\"mean_vector\", y)} / uniforms.norm_size;\n    let inv_std_dev = inverseSqrt(${Fe(\"mean_square_vector\", y)} / uniforms.norm_size ${n ? \"\" : \"- mean * mean\"} + uniforms.epsilon);\n\n    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {\n      let f32input = ${Et(k, y, \"x[j + offset]\")};\n      let f32scale = ${Et(k, y, \"scale[j]\")};\n      output[j + offset] = ${P[0].type.value}((f32input ${n ? \"\" : \"- mean\"}) * inv_std_dev * f32scale\n        ${a ? `+ ${Et(k, y, \"bias[j]\")}` : \"\"}\n      );\n    }\n\n    ${$ ? \"mean_data_output[global_idx] = mean\" : \"\"};\n    ${v ? \"inv_std_output[global_idx] = inv_std_dev\" : \"\"};\n  }`;\n        }, T = [\n            {\n                dims: d,\n                dataType: e1[0].dataType\n            }\n        ];\n        return $ && T.push({\n            dims: _,\n            dataType: 1\n        }), v && T.push({\n            dims: _,\n            dataType: 1\n        }), {\n            name: \"LayerNormalization\",\n            shaderCache: {\n                hint: `${y};${r};${n}`,\n                inputDependencies: g\n            },\n            getRunData: ()=>({\n                    outputs: T,\n                    dispatchGroup: {\n                        x: Math.ceil(p / 64)\n                    },\n                    programUniforms: x\n                }),\n            getShaderSource: S\n        };\n    }, Zd = (e1, t)=>{\n        uh(e1.inputs), e1.compute(dh(e1.inputs, t, e1.outputCount));\n    };\n});\nvar lh, Xd, Jd = U(()=>{\n    \"use strict\";\n    oe();\n    Qr();\n    Xr();\n    lh = (e1)=>{\n        if (!e1 || e1.length !== 2) throw new Error(\"MatMul requires 2 inputs.\");\n        if (e1[0].dims[e1[0].dims.length - 1] !== e1[1].dims[e1[1].dims.length - 2]) throw new Error(\"shared dimension does not match.\");\n    }, Xd = (e1)=>{\n        lh(e1.inputs);\n        let t = tt.calcShape(e1.inputs[0].dims, e1.inputs[1].dims, !0);\n        if (!t) throw new Error(\"Can't use matmul on the given tensors\");\n        let r = t[t.length - 1], n = e1.inputs[0].dims[e1.inputs[0].dims.length - 1];\n        if (r < 8 && n < 8) e1.compute(Zr(e1.inputs, {\n            activation: \"\"\n        }, t));\n        else {\n            let o = t[t.length - 2], i = C.size(e1.inputs[0].dims.slice(0, -2)), a = C.size(e1.inputs[1].dims.slice(0, -2));\n            if (i !== 1 && o === 1 && a === 1) {\n                let d = e1.inputs[0].reshape([\n                    1,\n                    i,\n                    n\n                ]), l = e1.inputs[1].reshape([\n                    1,\n                    n,\n                    r\n                ]), p = [\n                    1,\n                    i,\n                    r\n                ], m = [\n                    d,\n                    l\n                ];\n                e1.compute(er(m, {\n                    activation: \"\"\n                }, t, p), {\n                    inputs: m\n                });\n            } else e1.compute(er(e1.inputs, {\n                activation: \"\"\n            }, t));\n        }\n    };\n});\nvar ch, ph, mh, el, tl, rl = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    ch = (e1, t)=>{\n        if (e1.length < 3 || e1.length > 4) throw new Error(\"MatMulNBits requires 3 or 4 inputs\");\n        let r = e1[0], n = r.dims.length;\n        if (r.dims[n - 1] !== t.k) throw new Error(\"The last dim of input shape does not match the k value\");\n        let o = Math.floor((t.k + t.blockSize - 1) / t.blockSize), i = t.blockSize / 8 * t.bits, a = e1[1];\n        if (!C.areEqual(a.dims, [\n            t.n,\n            o,\n            i\n        ])) throw new Error(\"The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize\");\n        let l = e1[2].dims;\n        if (C.size(l) !== t.n * o) throw new Error(\"scales input size error.\");\n        if (e1.length === 4) {\n            let m = e1[3].dims, u = t.bits > 4 ? t.n * o : t.n * Math.floor((o + 1) / 2);\n            if (C.size(m) !== u) throw new Error(\"zeroPoints input size error.\");\n        }\n    }, ph = (e1, t)=>{\n        let r = e1[0].dims, n = r.length, o = r[n - 2], i = t.k, a = t.n, d = r.slice(0, n - 2), l = C.size(d), m = e1[1].dims[2] / 4, u = e1[0].dataType, h = me(t.k), _ = me(m), y = me(a), g = d.concat([\n            o,\n            a\n        ]), x = o > 1 && a / y % 2 === 0 ? 2 : 1, $ = C.size(g) / y / x, v = 64, S = [], T = [\n            l,\n            o,\n            i / h\n        ], A = C.convertShape(e1[1].dims).slice();\n        A.splice(-1, 1, m / _), S.push(...N(T)), S.push(...N(A)), S.push(...N(e1[2].dims)), e1.length === 4 && S.push(...N(C.convertShape(e1[3].dims)));\n        let k = [\n            l,\n            o,\n            a / y\n        ];\n        S.push(...N(k));\n        let P = (D)=>{\n            let R = T.length, G = E(\"a\", e1[0].dataType, R, h), K = E(\"b\", 12, A.length, _), j = E(\"scales\", e1[2].dataType, e1[2].dims.length), V = [\n                G,\n                K,\n                j\n            ], Q = e1.length === 4 ? E(\"zero_points\", 12, e1[3].dims.length) : void 0;\n            Q && V.push(Q);\n            let se = k.length, Y = M(\"output\", e1[0].dataType, se, y), ee = _e(e1[0].dataType), J = (()=>{\n                switch(h){\n                    case 1:\n                        return `array<${ee}, 8>`;\n                    case 2:\n                        return `mat4x2<${ee}>`;\n                    case 4:\n                        return `mat2x4<${ee}>`;\n                    default:\n                        throw new Error(`${h}-component is not supported.`);\n                }\n            })(), ne = ()=>{\n                let $e = `\n          // reuse a data\n            var input_offset = ${G.indicesToOffset(`${G.type.indices}(batch, row, word_offset)`)};\n            var a_data: ${J};\n            for (var j: u32 = 0; j < ${8 / h}; j++) {\n              a_data[j] = ${G.getByOffset(\"input_offset\")};\n              input_offset++;\n            }\n          `;\n                for(let le = 0; le < y * x; le++)$e += `\n            b_value = ${_ === 1 ? `b${le}_data` : `b${le}_data[i]`};\n            b_value_lower = unpack4xU8(b_value & b_mask);\n            b_value_upper = unpack4xU8((b_value >> 4) & b_mask);\n            b_quantized_values = ${J}(${Array.from({\n                    length: 4\n                }, (W, q)=>`${ee}(b_value_lower[${q}]), ${ee}(b_value_upper[${q}])`).join(\", \")});\n            b_dequantized_values = ${(()=>h === 1 ? `${J}(${Array.from({\n                        length: 8\n                    }, (W, q)=>`(b_quantized_values[${q}] - ${Q ? `zero_point${le}` : \"zero_point\"}) * scale${le}`).join(\", \")});` : `(b_quantized_values - ${J}(${Array(8).fill(`${Q ? `zero_point${le}` : \"zero_point\"}`).join(\",\")})) * scale${le};`)()};\n            workgroup_shared[local_id.x * ${x} + ${Math.floor(le / y)}]${y > 1 ? `[${le % y}]` : \"\"} += ${Array.from({\n                    length: 8 / h\n                }, (W, q)=>`${h === 1 ? `a_data[${q}] * b_dequantized_values[${q}]` : `dot(a_data[${q}], b_dequantized_values[${q}])`}`).join(\" + \")};\n          `;\n                return $e;\n            }, be = ()=>{\n                let $e = `\n            var col_index = col * ${y};\n            ${Q ? `\n            let zero_point_bytes_per_col = (nBlocksPerCol + 1) / 2;\n            var zero_point_byte_count: u32;\n            var zero_point_word_index: u32;\n            var zero_point_byte_offset: u32;\n            let zero_point_nibble_offset: u32 = block & 0x1u;\n            var zero_point_bits_offset: u32;\n            var zero_point_word: u32;` : `\n            // The default zero point is 8 for unsigned 4-bit quantization.\n            let zero_point = ${ee}(8);`}\n            `;\n                for(let le = 0; le < y * x; le++)$e += `\n            let scale${le} = ${j.getByOffset(\"col_index * nBlocksPerCol + block\")};\n            ${Q ? `\n            zero_point_byte_count = col_index * zero_point_bytes_per_col + (block >> 0x1u);\n            zero_point_word_index = zero_point_byte_count >> 0x2u;\n            zero_point_byte_offset = zero_point_byte_count & 0x3u;\n            zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);\n            zero_point_word = ${Q.getByOffset(\"zero_point_word_index\")} >> zero_point_bits_offset;\n            let zero_point${le} = ${ee}((zero_point_word) & 0xFu);` : \"\"}\n            col_index += 1;`;\n                return $e;\n            }, Oe = ()=>{\n                let $e = `col_index = col * ${y};`;\n                for(let le = 0; le < y * x; le++)$e += `\n            let b${le}_data = ${K.getByIndices(`${K.type.indices}(col_index, block, word)`)};\n            col_index += 1;`;\n                return $e += `\n            var b_value: u32;\n            let b_mask: u32 = 0x0F0F0F0Fu;\n            var b_value_lower: vec4<u32>;\n            var b_value_upper: vec4<u32>;\n            var b_quantized_values: ${J};\n            var b_dequantized_values: ${J};`, $e;\n            };\n            return `\n        var<workgroup> workgroup_shared: array<${Y.type.value}, ${x * v}>;\n        ${D.declareVariables(...V, Y)}\n        ${D.mainStart([\n                v,\n                1,\n                1\n            ])}\n          let output_indices = ${Y.offsetToIndices(`(global_idx / ${v}) * ${x}`)};\n          let col = output_indices[2];\n          let row = output_indices[1];\n          let batch = output_indices[0];\n          let nBlocksPerCol = uniforms.b_shape[1];\n\n          for (var block = local_id.x; block < nBlocksPerCol; block += ${v}) {\n            //process one block\n            var word_offset: u32 = block * ${t.blockSize / h};\n            ${be()}\n            for (var word: u32 = 0; word < ${m}; word += ${_}) {\n              ${Oe()}\n              for (var i: u32 = 0; i < ${_}; i++) {\n                ${ne()}\n                word_offset += ${8 / h};\n              }\n            }\n          }\n          workgroupBarrier();\n\n          if (local_id.x < ${x}) {\n            var output_value: ${Y.type.value} = ${Y.type.value}(0);\n            var workgroup_shared_offset: u32 = local_id.x;\n            for (var b: u32 = 0u; b < ${v}u; b++) {\n              output_value += workgroup_shared[workgroup_shared_offset];\n              workgroup_shared_offset += ${x};\n            }\n            ${Y.setByIndices(`${Y.type.indices}(batch, row, col + local_id.x)`, \"output_value\")};\n          }\n        }`;\n        };\n        return {\n            name: \"MatMulNBits\",\n            shaderCache: {\n                hint: `${t.blockSize};${t.bits};${h};${_};${y};${x};${v}`,\n                inputDependencies: Array(e1.length).fill(\"rank\")\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: g,\n                            dataType: u\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: $\n                    },\n                    programUniforms: S\n                }),\n            getShaderSource: P\n        };\n    }, mh = (e1, t)=>{\n        let r = e1[0].dims, n = r.length, o = r[n - 2], i = t.k, a = t.n, d = r.slice(0, n - 2), l = C.size(d), m = e1[1].dims[2] / 4, u = e1[0].dataType, h = me(t.k), _ = me(m), y = d.concat([\n            o,\n            a\n        ]), g = 128, x = a % 8 === 0 ? 8 : a % 4 === 0 ? 4 : 1, $ = g / x, v = $ * _ * 8, S = v / h, T = v / t.blockSize, A = C.size(y) / x, k = [], P = [\n            l,\n            o,\n            i / h\n        ], D = C.convertShape(e1[1].dims).slice();\n        D.splice(-1, 1, m / _), k.push(...N(P)), k.push(...N(D)), k.push(...N(e1[2].dims)), e1.length === 4 && k.push(...N(C.convertShape(e1[3].dims)));\n        let R = [\n            l,\n            o,\n            a\n        ];\n        k.push(...N(R));\n        let G = (K)=>{\n            let j = P.length, V = E(\"a\", e1[0].dataType, j, h), Q = E(\"b\", 12, D.length, _), se = E(\"scales\", e1[2].dataType, e1[2].dims.length), Y = [\n                V,\n                Q,\n                se\n            ], ee = e1.length === 4 ? E(\"zero_points\", 12, e1[3].dims.length) : void 0;\n            ee && Y.push(ee);\n            let J = R.length, ne = M(\"output\", e1[0].dataType, J), be = _e(e1[0].dataType), Oe = ()=>{\n                switch(h){\n                    case 1:\n                        return `\n          let a_data0 = vec4<${be}>(sub_a[word_offset], sub_a[word_offset + 1], sub_a[word_offset + 2], sub_a[word_offset + 3]);\n          let a_data1 = vec4<${be}>(sub_a[word_offset + 4], sub_a[word_offset + 5], sub_a[word_offset + 6], sub_a[word_offset + 7]);`;\n                    case 2:\n                        return `\n          let a_data0 = vec4<${be}>(sub_a[word_offset], sub_a[word_offset + 1]);\n          let a_data1 = vec4<${be}>(sub_a[word_offset + 2], sub_a[word_offset + 3]);`;\n                    case 4:\n                        return `\n          let a_data0 = sub_a[word_offset];\n          let a_data1 = sub_a[word_offset + 1];`;\n                    default:\n                        throw new Error(`${h}-component is not supported.`);\n                }\n            };\n            return `\n        var<workgroup> sub_a: array<${V.type.value}, ${S}>;\n        var<workgroup> inter_results: array<array<${ne.type.value}, ${$}>, ${x}>;\n        ${K.declareVariables(...Y, ne)}\n        ${K.mainStart([\n                $,\n                x,\n                1\n            ])}\n          let output_indices = ${ne.offsetToIndices(`workgroup_index * ${x}`)};\n          let col = output_indices[2];\n          let row = output_indices[1];\n          let batch = output_indices[0];\n          let n_blocks_per_col = uniforms.b_shape[1];\n          let num_tiles =  (n_blocks_per_col - 1) / ${T} + 1;\n\n          // Loop over shared dimension.\n          for (var tile: u32 = 0; tile < num_tiles; tile += 1) {\n            let a_col_start = tile * ${S};\n            // load one tile A data into shared memory.\n            for (var a_offset = local_idx; a_offset < ${S}; a_offset += ${g})\n            {\n              let a_col = a_col_start + a_offset;\n              if (a_col < uniforms.a_shape[2])\n              {\n                sub_a[a_offset] = ${V.getByIndices(`${V.type.indices}(batch, row, a_col)`)};\n              } else {\n                sub_a[a_offset] = ${V.type.value}(0);\n              }\n            }\n            workgroupBarrier();\n\n            // each thread process one block\n            let b_row = col + local_id.y;\n            let block = tile * ${T} + local_id.x;\n            ${ee ? `\n            let zero_point_bytes_per_col = (n_blocks_per_col + 1) / 2;\n            let zero_point_byte_count = b_row * zero_point_bytes_per_col + (block >> 0x1u);\n            let zero_point_word_index = zero_point_byte_count >> 0x2u;\n            let zero_point_byte_offset = zero_point_byte_count & 0x3u;\n            let zero_point_nibble_offset: u32 = block & 0x1u;\n            let zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);\n            let zero_point_word = ${ee.getByOffset(\"zero_point_word_index\")} >> zero_point_bits_offset;\n            let zero_point = ${be}((zero_point_word) & 0xFu);` : `\n            // The default zero point is 8 for unsigned 4-bit quantization.\n            let zero_point = ${be}(8);`}\n            let scale = ${se.getByOffset(\"b_row * n_blocks_per_col + block\")};\n            let b_data = ${Q.getByIndices(`${Q.type.indices}(b_row, block, 0)`)};\n            var word_offset = local_id.x * ${t.blockSize / h};\n            for (var i: u32 = 0; i < ${_}; i++) {\n              ${Oe()}\n              let b_value = ${_ === 1 ? \"b_data\" : \"b_data[i]\"};\n              let b_value_lower = unpack4xU8(b_value & 0x0F0F0F0Fu);\n              let b_value_upper = unpack4xU8((b_value >> 4) & 0x0F0F0F0Fu);\n              let b_quantized_values = mat2x4<${be}>(${Array.from({\n                length: 4\n            }, ($e, le)=>`${be}(b_value_lower[${le}]), ${be}(b_value_upper[${le}])`).join(\", \")});\n              let b_dequantized_values = (b_quantized_values - mat2x4<${be}>(${Array(8).fill(\"zero_point\").join(\",\")})) * scale;\n              inter_results[local_id.y][local_id.x] += ${Array.from({\n                length: 2\n            }, ($e, le)=>`${`dot(a_data${le}, b_dequantized_values[${le}])`}`).join(\" + \")};\n              word_offset += ${8 / h};\n            }\n            workgroupBarrier();\n          }\n\n          if (local_idx < ${x}) {\n            var output_value: ${ne.type.value} = ${ne.type.value}(0);\n            for (var b = 0u; b < ${$}; b++) {\n              output_value += inter_results[local_idx][b];\n            }\n            if (col + local_idx < uniforms.output_shape[2])\n            {\n              ${ne.setByIndices(`${ne.type.indices}(batch, row, col + local_idx)`, \"output_value\")}\n            }\n          }\n        }`;\n        };\n        return {\n            name: \"BlockwiseMatMulNBits32\",\n            shaderCache: {\n                hint: `${t.blockSize};${h};${_};${$};${x}`,\n                inputDependencies: Array(e1.length).fill(\"rank\")\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: y,\n                            dataType: u\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: A\n                    },\n                    programUniforms: k\n                }),\n            getShaderSource: G\n        };\n    }, el = (e1, t)=>{\n        ch(e1.inputs, t), t.blockSize === 32 && e1.adapterInfo.isVendor(\"intel\") && e1.adapterInfo.isArchitecture(\"gen-12lp\") ? e1.compute(mh(e1.inputs, t)) : e1.compute(ph(e1.inputs, t));\n    }, tl = (e1)=>re(e1);\n});\nvar fh, hh, gh, bh, yh, _h, wh, vh, nl, ol = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    ae();\n    fh = (e1)=>{\n        if (!e1 || e1.length < 1) throw new Error(\"Too few inputs\");\n        if (e1[0].dataType !== 1 && e1[0].dataType !== 10) throw new Error(\"Input type must be float or float16.\");\n        if (e1.length >= 2) {\n            let t = e1[0].dims.length * 2 === e1[1].dims[0];\n            if (e1.length === 4 && (t = e1[3].dims[0] * 2 === e1[1].dims[0]), !t) throw new Error(\"The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].\");\n        }\n    }, hh = (e1, t, r)=>{\n        let n = \"\";\n        for(let o = t - 1; o >= 0; --o)n += `\n            k = i32(${e1.indicesGet(\"indices\", o)}) - ${F(\"uniforms.pads\", o, r)};\n            if (k < 0) {\n              break;\n            }\n            if (k >= i32(${F(\"uniforms.x_shape\", o, t)})) {\n              break;\n            }\n            offset += k * i32(${F(\"uniforms.x_strides\", o, t)});\n        `;\n        return `\n          value = ${e1.type.value}(uniforms.constant_value);\n          for (var i = 0; i < 1; i++) {\n            var offset = 0;\n            var k = 0;\n            ${n}\n            value = x[offset];\n          }\n      `;\n    }, gh = (e1, t, r)=>{\n        let n = \"\";\n        for(let o = t - 1; o >= 0; --o)n += `\n                k = i32(${e1.indicesGet(\"indices\", o)}) - ${F(\"uniforms.pads\", o, r)};\n                if (k < 0) {\n                  k = -k;\n                }\n                {\n                  let _2n_1 = 2 * (i32(${F(\"uniforms.x_shape\", o, t)}) - 1);\n                  k = k % _2n_1;\n                  if(k >= i32(${F(\"uniforms.x_shape\", o, t)})) {\n                    k = _2n_1 - k;\n                  }\n                }\n                offset += k * i32(${F(\"uniforms.x_strides\", o, t)});\n            `;\n        return `\n              var offset = 0;\n              var k = 0;\n              ${n}\n              value = x[offset];\n          `;\n    }, bh = (e1, t, r)=>{\n        let n = \"\";\n        for(let o = t - 1; o >= 0; --o)n += `\n                k = i32(${e1.indicesGet(\"indices\", o)}) - ${F(\"uniforms.pads\", o, r)};\n                if (k < 0) {\n                  k = 0;\n                }\n                if (k >= i32(${F(\"uniforms.x_shape\", o, t)})) {\n                  k = i32(${F(\"uniforms.x_shape\", o, t)}) - 1;\n                }\n                offset += k * i32(${F(\"uniforms.x_strides\", o, t)});\n            `;\n        return `\n              var offset = 0;\n              var k = 0;\n              ${n}\n              value = x[offset];\n          `;\n    }, yh = (e1, t, r)=>{\n        let n = \"\";\n        for(let o = t - 1; o >= 0; --o)n += `\n                k = i32(${e1.indicesGet(\"indices\", o)}) - ${F(\"uniforms.pads\", o, r)};\n                if (k < 0)  {\n                  k += i32(${F(\"uniforms.x_shape\", o, t)}]);\n                }\n                if (k >= i32(${F(\"uniforms.x_shape\", o, t)})) {\n                  k -= i32(${F(\"uniforms.x_shape\", o, t)});\n                }\n                offset += k * i32(${F(\"uniforms.x_strides\", o, t)});\n            `;\n        return `\n              var offset = 0;\n              var k = 0;\n              ${n}\n              value = x[offset];\n          `;\n    }, _h = (e1, t, r)=>{\n        switch(r.mode){\n            case 0:\n                return hh(e1, t, r.pads.length);\n            case 1:\n                return gh(e1, t, r.pads.length);\n            case 2:\n                return bh(e1, t, r.pads.length);\n            case 3:\n                return yh(e1, t, r.pads.length);\n            default:\n                throw new Error(\"Invalid mode\");\n        }\n    }, wh = (e1, t)=>{\n        let r = C.padShape(e1[0].dims.slice(), t.pads), n = e1[0].dims, o = C.size(r), i = [\n            {\n                type: 12,\n                data: o\n            },\n            {\n                type: 6,\n                data: t.pads\n            }\n        ], a = e1.length >= 3 && e1[2].data;\n        t.mode === 0 && i.push({\n            type: a ? e1[2].dataType : 1,\n            data: t.value\n        }), i.push(...N(e1[0].dims, r));\n        let d = [\n            \"rank\"\n        ], l = (p)=>{\n            let m = M(\"output\", e1[0].dataType, r.length), u = E(\"x\", e1[0].dataType, n.length), h = u.type.value, _ = _h(m, n.length, t), y = [\n                {\n                    name: \"output_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"pads\",\n                    type: \"i32\",\n                    length: t.pads.length\n                }\n            ];\n            return t.mode === 0 && y.push({\n                name: \"constant_value\",\n                type: a ? h : \"f32\"\n            }), `\n            ${p.registerUniforms(y).declareVariables(u, m)}\n            ${p.mainStart()}\n            ${p.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n\n            let indices = ${m.offsetToIndices(\"global_idx\")};\n\n            var value = ${h}(0);\n            ${_}\n            output[global_idx] = value;\n        }`;\n        };\n        return {\n            name: \"Pad\",\n            shaderCache: {\n                hint: `${t.mode}${a}`,\n                inputDependencies: d\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: r,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(C.size(r) / 64)\n                    },\n                    programUniforms: i\n                }),\n            getShaderSource: l\n        };\n    }, vh = (e1, t)=>{\n        if (e1.length > 1) {\n            let r = e1[1].getBigInt64Array(), n = e1.length >= 3 && e1[2].data ? e1[2].dataType === 10 ? e1[2].getUint16Array()[0] : e1[2].getFloat32Array()[0] : 0, o = e1[0].dims.length, i = new Int32Array(2 * o).fill(0);\n            if (e1.length >= 4) {\n                let d = e1[3].getBigInt64Array();\n                for(let l = 0; l < d.length; l++)i[Number(d[l])] = Number(r[l]), i[Number(d[l]) + o] = Number(r[l + d.length]);\n            } else r.forEach((d, l)=>i[Number(l)] = Number(d));\n            let a = [];\n            return i.forEach((d)=>a.push(d)), {\n                mode: t.mode,\n                value: n,\n                pads: a\n            };\n        } else return t;\n    }, nl = (e1, t)=>{\n        fh(e1.inputs);\n        let r = vh(e1.inputs, t);\n        e1.compute(wh(e1.inputs, r), {\n            inputs: [\n                0\n            ]\n        });\n    };\n});\nvar tn, il, al, sl, ul, $h, xh, dl, ll, cl, pl, ml, fl, hl, gl, bl, yl, _l, wl, vl = U(()=>{\n    \"use strict\";\n    We();\n    te();\n    oe();\n    ae();\n    tn = (e1)=>{\n        if (ve.webgpu.validateInputContent && (!e1 || e1.length !== 1)) throw new Error(\"Pool ops requires 1 input.\");\n    }, il = (e1, t, r)=>{\n        let n = t.format === \"NHWC\", o = e1.dims.slice();\n        n && o.splice(1, 0, o.pop());\n        let i = Object.hasOwnProperty.call(t, \"dilations\"), a = t.kernelShape.slice(), d = t.strides.slice(), l = i ? t.dilations.slice() : [], p = t.pads.slice();\n        At.adjustPoolAttributes(r, o, a, d, l, p);\n        let m = At.computePoolOutputShape(r, o, d, l, a, p, t.autoPad), u = Object.assign({}, t);\n        i ? Object.assign(u, {\n            kernelShape: a,\n            strides: d,\n            pads: p,\n            dilations: l,\n            cacheKey: t.cacheKey\n        }) : Object.assign(u, {\n            kernelShape: a,\n            strides: d,\n            pads: p,\n            cacheKey: t.cacheKey\n        });\n        let h = m.slice();\n        return h.push(h.splice(1, 1)[0]), [\n            u,\n            n ? h : m\n        ];\n    }, al = (e1, t)=>{\n        let r = t.format === \"NHWC\", n = C.size(e1), o = C.size(t.kernelShape), i = [\n            {\n                type: 12,\n                data: n\n            },\n            {\n                type: 12,\n                data: o\n            }\n        ], a = [\n            {\n                name: \"outputSize\",\n                type: \"u32\"\n            },\n            {\n                name: \"kernelSize\",\n                type: \"u32\"\n            }\n        ];\n        if (t.kernelShape.length <= 2) {\n            let d = t.kernelShape[t.kernelShape.length - 1], l = t.strides[t.strides.length - 1], p = t.pads[t.pads.length / 2 - 1], m = t.pads[t.pads.length - 1], u = !!(p + m);\n            i.push({\n                type: 12,\n                data: d\n            }, {\n                type: 12,\n                data: l\n            }, {\n                type: 12,\n                data: p\n            }, {\n                type: 12,\n                data: m\n            }), a.push({\n                name: \"kw\",\n                type: \"u32\"\n            }, {\n                name: \"sw\",\n                type: \"u32\"\n            }, {\n                name: \"pwStart\",\n                type: \"u32\"\n            }, {\n                name: \"pwEnd\",\n                type: \"u32\"\n            });\n            let h = !1;\n            if (t.kernelShape.length === 2) {\n                let _ = t.kernelShape[t.kernelShape.length - 2], y = t.strides[t.strides.length - 2], g = t.pads[t.pads.length / 2 - 2], x = t.pads[t.pads.length - 2];\n                h = !!(g + x), i.push({\n                    type: 12,\n                    data: _\n                }, {\n                    type: 12,\n                    data: y\n                }, {\n                    type: 12,\n                    data: g\n                }, {\n                    type: 12,\n                    data: x\n                }), a.push({\n                    name: \"kh\",\n                    type: \"u32\"\n                }, {\n                    name: \"sh\",\n                    type: \"u32\"\n                }, {\n                    name: \"phStart\",\n                    type: \"u32\"\n                }, {\n                    name: \"phEnd\",\n                    type: \"u32\"\n                });\n            }\n            return [\n                i,\n                a,\n                !0,\n                u,\n                h\n            ];\n        } else {\n            if (r) throw new Error(\"Pooling with kernelShape.length > 2 is not supported for NHWC format.\");\n            let d = C.computeStrides(t.kernelShape);\n            i.push({\n                type: 12,\n                data: d\n            }, {\n                type: 12,\n                data: t.pads\n            }, {\n                type: 12,\n                data: t.strides\n            }), a.push({\n                name: \"kernelStrides\",\n                type: \"u32\",\n                length: d.length\n            }, {\n                name: \"pads\",\n                type: \"u32\",\n                length: t.pads.length\n            }, {\n                name: \"strides\",\n                type: \"u32\",\n                length: t.strides.length\n            });\n            let l = t.pads.reduce((p, m)=>p + m);\n            return [\n                i,\n                a,\n                !!l,\n                !1,\n                !1\n            ];\n        }\n    }, sl = (e1, t, r, n, o, i, a, d, l, p, m, u)=>{\n        let h = o.format === \"NHWC\", _ = t.type.value, y = M(\"output\", t.type.tensor, n);\n        if (o.kernelShape.length <= 2) {\n            let g = \"\", x = \"\", $ = \"\", v = r - (h ? 2 : 1);\n            if (m ? g = `\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${v}] = indices[${v}] * uniforms.sw - uniforms.pwStart + i;\n                  if (xIndices[${v}] < 0 || xIndices[${v}]\n                      >= uniforms.x_shape[${v}]) {\n                    pad++;\n                    continue;\n                  }\n                  let x_val = x[${t.indicesToOffset(\"xIndices\")}];\n                  ${i}\n                }` : g = `\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\n                  xIndices[${v}] = indices[${v}] * uniforms.sw - uniforms.pwStart + i;\n                  let x_val = x[${t.indicesToOffset(\"xIndices\")}];\n                  ${i}\n                }`, o.kernelShape.length === 2) {\n                let T = r - (h ? 3 : 2);\n                u ? x = `\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${T}] = indices[${T}] * uniforms.sh - uniforms.phStart + j;\n                  if (xIndices[${T}] < 0 || xIndices[${T}] >= uniforms.x_shape[${T}]) {\n                    pad += i32(uniforms.kw);\n                    continue;\n                  }\n              ` : x = `\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\n                  xIndices[${T}] = indices[${T}] * uniforms.sh - uniforms.phStart + j;\n                `, $ = `\n              }\n            `;\n            }\n            return `\n            ${e1.registerUniforms(l).declareVariables(t, y)}\n\n            ${e1.mainStart()}\n              ${e1.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n\n              let indices = ${y.offsetToIndices(\"global_idx\")};\n              var xIndices = ${y.offsetToIndices(\"global_idx\")};\n\n              var value = ${_}(${d});\n              var pad = 0;\n              ${x}\n              ${g}\n              ${$}\n              ${a}\n\n              output[global_idx] = value;\n            }`;\n        } else {\n            if (h) throw new Error(\"Pooling with kernelShape.length > 2 is not supported for NHWC format.\");\n            let g = o.kernelShape.length, x = o.pads.length, $ = \"\";\n            return p ? $ = `\n                if (xIndices[j] >= uniforms.x_shape[j]) {\n                  pad++;\n                  isPad = true;\n                  break;\n                }\n              }\n              if (!isPad) {\n                let x_val = x[${t.indicesToOffset(\"xIndices\")}];\n                ${i}\n              }` : $ = `\n              }\n              let x_val = x[${t.indicesToOffset(\"xIndices\")}];\n              ${i}\n            `, `\n            ${e1.registerUniforms(l).declareVariables(t, y)}\n\n            ${e1.mainStart()}\n              ${e1.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n              let indices = ${y.offsetToIndices(\"global_idx\")};\n              var xIndices = ${y.offsetToIndices(\"global_idx\")};\n\n              var offsets: array<u32, ${g}>;\n\n              var value = ${_}(${d});\n              var pad = 0;\n              var isPad = false;\n\n              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {\n                var offset = i;\n                for (var j = 0u; j < ${g - 1}u; j++) {\n                  offsets[j] = offset / ${F(\"uniforms.kernelStrides\", \"j\", g)};\n                  offset -= offsets[j] * ${F(\"uniforms.kernelStrides\", \"j\", g)};\n                }\n                offsets[${g - 1}] = offset;\n\n                isPad = false;\n                for (var j = ${r - g}u; j < ${r}u; j++) {\n                  xIndices[j] = indices[j] * ${F(\"uniforms.strides\", `j - ${r - g}u`, g)}\n                    + offsets[j - ${r - g}u] - ${F(\"uniforms.pads\", \"j - 2u\", x)};\n                  ${$}\n              }\n              ${a}\n\n              output[global_idx] = value;\n            }`;\n        }\n    }, ul = (e1)=>`${e1.format};${e1.ceilMode};${e1.autoPad};${e1.kernelShape.length}`, $h = (e1)=>`${ul(e1)};${e1.countIncludePad}`, xh = (e1)=>`${ul(e1)};${e1.storageOrder};${e1.dilations}`, dl = (e1)=>({\n            format: e1.format,\n            autoPad: [\n                \"NOTSET\",\n                \"VALID\",\n                \"SAME_UPPER\",\n                \"SAME_LOWER\"\n            ][e1.auto_pad],\n            ceilMode: e1.ceil_mode,\n            kernelShape: e1.kernel_shape,\n            strides: e1.strides,\n            pads: e1.pads\n        }), ll = (e1, t, r, n)=>{\n        let [o, i] = il(t, n, r), a = E(\"x\", t.dataType, t.dims.length), d = a.type.value, l = \"value += x_val;\", p = \"\";\n        o.countIncludePad ? p += `value /= ${d}(uniforms.kernelSize);` : p += `value /= ${d}(i32(uniforms.kernelSize) - pad);`;\n        let [m, u, h, _, y] = al(i, o);\n        m.push(...N(t.dims, i));\n        let g = [\n            \"rank\"\n        ];\n        return {\n            name: e1,\n            shaderCache: {\n                hint: `${n.cacheKey};${h};${_};${y}`,\n                inputDependencies: g\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: i,\n                            dataType: t.dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(C.size(i) / 64)\n                    },\n                    programUniforms: m\n                }),\n            getShaderSource: (x)=>sl(x, a, t.dims.length, i.length, o, l, p, 0, u, h, _, y)\n        };\n    }, cl = (e1)=>{\n        let t = e1.count_include_pad !== 0, r = dl(e1);\n        if (r.ceilMode !== 0) throw new Error(\"using ceil() in shape computation is not yet supported for AveragePool\");\n        let n = {\n            countIncludePad: t,\n            ...r,\n            cacheKey: \"\"\n        };\n        return {\n            ...n,\n            cacheKey: $h(n)\n        };\n    }, pl = (e1, t)=>{\n        tn(e1.inputs), e1.compute(ll(\"AveragePool\", e1.inputs[0], !1, t));\n    }, ml = {\n        autoPad: \"\",\n        ceilMode: 0,\n        countIncludePad: !1,\n        kernelShape: [],\n        strides: [],\n        pads: [],\n        storageOrder: 0,\n        dilations: []\n    }, fl = (e1)=>{\n        let t = e1.format;\n        return {\n            format: t,\n            ...ml,\n            cacheKey: t\n        };\n    }, hl = (e1, t)=>{\n        tn(e1.inputs), e1.compute(ll(\"GlobalAveragePool\", e1.inputs[0], !0, t));\n    }, gl = (e1, t, r, n)=>{\n        let [o, i] = il(t, n, r), a = `\n      value = max(x_val, value);\n    `, d = \"\", l = E(\"x\", t.dataType, t.dims.length), p = [\n            \"rank\"\n        ], [m, u, h, _, y] = al(i, o);\n        return m.push(...N(t.dims, i)), {\n            name: e1,\n            shaderCache: {\n                hint: `${n.cacheKey};${h};${_};${y}`,\n                inputDependencies: p\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: i,\n                            dataType: t.dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(C.size(i) / 64)\n                    },\n                    programUniforms: m\n                }),\n            getShaderSource: (g)=>sl(g, l, t.dims.length, i.length, o, a, d, t.dataType === 10 ? -65504 : -1e5, u, h, _, y)\n        };\n    }, bl = (e1, t)=>{\n        tn(e1.inputs), e1.compute(gl(\"MaxPool\", e1.inputs[0], !1, t));\n    }, yl = (e1)=>{\n        let t = e1.storage_order, r = e1.dilations, n = dl(e1);\n        if (t !== 0) throw new Error(\"column major storage order is not yet supported for MaxPool\");\n        if (n.ceilMode !== 0) throw new Error(\"using ceil() in shape computation is not yet supported for MaxPool\");\n        let o = {\n            storageOrder: t,\n            dilations: r,\n            ...n,\n            cacheKey: \"\"\n        };\n        return {\n            ...o,\n            cacheKey: xh(o)\n        };\n    }, _l = (e1)=>{\n        let t = e1.format;\n        return {\n            format: t,\n            ...ml,\n            cacheKey: t\n        };\n    }, wl = (e1, t)=>{\n        tn(e1.inputs), e1.compute(gl(\"GlobalMaxPool\", e1.inputs[0], !0, t));\n    };\n});\nvar Th, Ih, $l, xl, Sl = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    Th = (e1, t)=>{\n        if (e1.length < 2 || e1.length > 3) throw new Error(\"DequantizeLinear requires 2 or 3 inputs.\");\n        if (e1.length === 3 && e1[1].dims === e1[2].dims) throw new Error(\"x-scale and x-zero-point must have the same shape.\");\n        if (e1.length === 3 && e1[0].dataType !== e1[2].dataType) throw new Error(\"x and x-zero-point must have the same data type.\");\n        if (e1[0].dataType === 6 && e1.length > 2) throw new Error(\"In the case of dequantizing int32 there is no zero point.\");\n        if (e1[1].dims.length !== 0 && e1[1].dims.length !== 1 && e1[1].dims.length !== e1[0].dims.length) throw new Error(\"scale input must be a scalar, a 1D tensor, or have the same rank as the input tensor.\");\n        if (e1.length > 2) {\n            if (e1[0].dataType !== e1[2].dataType) throw new Error(\"x and x-zero-point must have the same data type.\");\n            if (e1[1].dims.length !== e1[2].dims.length) throw new Error(\"scale and zero-point inputs must have the same rank.\");\n            if (!e1[1].dims.map((r, n)=>r === e1[2].dims[n]).reduce((r, n)=>r && n, !0)) throw new Error(\"scale and zero-point inputs must have the same shape.\");\n        }\n        if (t.blockSize > 0) {\n            if (e1[1].dims.length === 0 || e1[1].dims.length === 1 && e1[1].dims[0] === 1) throw new Error(\"blockSize must be set only for block quantization.\");\n            if (!e1[1].dims.map((o, i)=>i === t.axis || o === e1[0].dims[i]).reduce((o, i)=>o && i, !0)) throw new Error(\"For block qunatization, scale input shape to match the input shape except for the axis\");\n            if (e1[1].dims.length !== e1[0].dims.length) throw new Error(\"For block qunatization the scale input rank must be the same as the x rank.\");\n            let r = e1[0].dims[t.axis], n = e1[1].dims[t.axis];\n            if (t.blockSize < Math.ceil(r / n) || t.blockSize > Math.ceil(r / (n - 1) - 1)) throw new Error(\"blockSize must be with in the range [ceil(dI / Si), ceil(dI / (Si - 1) - 1)].\");\n        }\n    }, Ih = (e1, t)=>{\n        let r = C.normalizeAxis(t.axis, e1[0].dims.length), n = e1[0].dataType, o = n === 3, i = e1[0].dims, a = e1[1].dataType, d = C.size(i), l = n === 3 || n === 2, p = l ? [\n            Math.ceil(C.size(e1[0].dims) / 4)\n        ] : e1[0].dims, m = e1[1].dims, u = e1.length > 2 ? e1[2] : void 0, h = u ? l ? [\n            Math.ceil(C.size(u.dims) / 4)\n        ] : u.dims : void 0, _ = m.length === 0 || m.length === 1 && m[0] === 1, y = _ === !1 && m.length === 1, g = me(d), x = _ && (!l || g === 4), $ = x ? g : 1, v = x && !l ? g : 1, S = E(\"input\", l ? 12 : n, p.length, v), T = E(\"scale\", a, m.length), A = u ? E(\"zero_point\", l ? 12 : n, h.length) : void 0, k = M(\"output\", a, i.length, $), P = [\n            S,\n            T\n        ];\n        A && P.push(A);\n        let D = [\n            p,\n            m\n        ];\n        u && D.push(h);\n        let R = [\n            {\n                type: 12,\n                data: d / $\n            },\n            {\n                type: 12,\n                data: r\n            },\n            {\n                type: 12,\n                data: t.blockSize\n            },\n            ...N(...D, i)\n        ], G = (K)=>{\n            let j = [\n                {\n                    name: \"output_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"axis\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"block_size\",\n                    type: \"u32\"\n                }\n            ];\n            return `\n      ${K.registerUniforms(j).declareVariables(...P, k)}\n      ${K.mainStart()}\n          ${K.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n          let output_indices = ${k.offsetToIndices(\"global_idx\")};\n\n          // Set input x\n          ${(()=>l ? `\n            let input = ${S.getByOffset(\"global_idx / 4\")};\n            let x_vec = ${o ? \"unpack4xI8(input)\" : \"unpack4xU8(input)\"};\n            let x_value = ${$ === 1 ? \"x_vec[global_idx % 4]\" : \"x_vec\"};` : `let x_value = ${S.getByOffset(\"global_idx\")};`)()};\n\n          // Set scale input\n          ${(()=>_ ? `let scale_value= ${T.getByOffset(\"0\")}` : y ? `\n            let scale_index = ${k.indicesGet(\"output_indices\", \"uniforms.axis\")};\n            let scale_value= ${T.getByOffset(\"scale_index\")};` : `\n            var scale_indices: ${T.type.indices} = output_indices;\n            let index = ${T.indicesGet(\"scale_indices\", \"uniforms.axis\")} / uniforms.block_size;\n            ${T.indicesSet(\"scale_indices\", \"uniforms.axis\", \"index\")};\n            let scale_value= ${T.getByIndices(\"scale_indices\")};`)()};\n\n          // Set zero-point input\n          ${(()=>A ? _ ? l ? `\n                let zero_point_input = ${A.getByOffset(\"0\")};\n                let zero_point_vec =  ${o ? \"unpack4xI8(zero_point_input)\" : \"unpack4xU8(zero_point_input)\"};\n                let zero_point_value= zero_point_vec[0]` : `let zero_point_value = ${A.getByOffset(\"0\")}` : y ? l ? `\n                let zero_point_index = ${k.indicesGet(\"output_indices\", \"uniforms.axis\")};\n                let zero_point_input = ${A.getByOffset(\"zero_point_index / 4\")};\n                let zero_point_vec =  ${o ? \"unpack4xI8(zero_point_input)\" : \"unpack4xU8(zero_point_input)\"};\n                let zero_point_value = zero_point_vec[zero_point_index % 4]` : `\n                let zero_point_index = ${k.indicesGet(\"output_indices\", \"uniforms.axis\")};\n                let zero_point_value = ${A.getByOffset(\"zero_point_index\")};` : l ? `\n                let zero_point_offset = ${T.indicesToOffset(\"scale_indices\")};\n                let zero_point_input = ${A.getByOffset(\"zero_point_offset / 4\")};\n                let zero_point_vec = ${o ? \"unpack4xI8(zero_point_input)\" : \"unpack4xU8(zero_point_input)\"};\n                let zero_point_value = zero_point_vec[zero_point_offset % 4];` : `let zero_point_value = ${A.getByIndices(\"scale_indices\")};` : `let zero_point_value = ${l ? o ? \"i32\" : \"u32\" : S.type.value}(0);`)()};\n      // Compute and write output\n      ${k.setByOffset(\"global_idx\", `${k.type.value}(x_value - zero_point_value) * scale_value`)};\n      }`;\n        };\n        return {\n            name: \"DequantizeLinear\",\n            shaderCache: {\n                hint: t.cacheKey,\n                inputDependencies: A ? [\n                    \"rank\",\n                    \"rank\",\n                    \"rank\"\n                ] : [\n                    \"rank\",\n                    \"rank\"\n                ]\n            },\n            getShaderSource: G,\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: i,\n                            dataType: a\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(d / $ / 64),\n                        y: 1,\n                        z: 1\n                    },\n                    programUniforms: R\n                })\n        };\n    }, $l = (e1, t)=>{\n        Th(e1.inputs, t), e1.compute(Ih(e1.inputs, t));\n    }, xl = (e1)=>re({\n            axis: e1.axis,\n            blockSize: e1.blockSize\n        });\n});\nvar Ch, Ah, Tl, Il = U(()=>{\n    \"use strict\";\n    We();\n    te();\n    ae();\n    Ch = (e1, t, r)=>{\n        let n = e1 === t, o = e1 < t && r < 0, i = e1 > t && r > 0;\n        if (n || o || i) throw new Error(\"Range these inputs' contents are invalid.\");\n    }, Ah = (e1, t, r, n)=>{\n        let o = Math.abs(Math.ceil((t - e1) / r)), i = [\n            o\n        ], a = o, d = [\n            {\n                type: 12,\n                data: a\n            },\n            {\n                type: n,\n                data: e1\n            },\n            {\n                type: n,\n                data: r\n            },\n            ...N(i)\n        ], l = (p)=>{\n            let m = M(\"output\", n, i.length), u = m.type.value, h = [\n                {\n                    name: \"outputSize\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"start\",\n                    type: u\n                },\n                {\n                    name: \"delta\",\n                    type: u\n                }\n            ];\n            return `\n        ${p.registerUniforms(h).declareVariables(m)}\n        ${p.mainStart()}\n        ${p.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n        output[global_idx] = uniforms.start + ${u}(global_idx) * uniforms.delta;\n      }`;\n        };\n        return {\n            name: \"Range\",\n            shaderCache: {\n                hint: `${n}`\n            },\n            getShaderSource: l,\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: i,\n                            dataType: n\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(a / 64)\n                    },\n                    programUniforms: d\n                })\n        };\n    }, Tl = (e1)=>{\n        let t = 0, r = 0, n = 0;\n        e1.inputs[0].dataType === 6 ? (t = e1.inputs[0].getInt32Array()[0], r = e1.inputs[1].getInt32Array()[0], n = e1.inputs[2].getInt32Array()[0]) : e1.inputs[0].dataType === 1 && (t = e1.inputs[0].getFloat32Array()[0], r = e1.inputs[1].getFloat32Array()[0], n = e1.inputs[2].getFloat32Array()[0]), ve.webgpu.validateInputContent && Ch(t, r, n), e1.compute(Ah(t, r, n, e1.inputs[0].dataType), {\n            inputs: []\n        });\n    };\n});\nvar kh, Eh, Cl, Al, kl = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    kh = (e1, t, r, n)=>{\n        if (e1 !== \"none\" && n !== \"i32\" && n !== \"u32\" && n !== \"f32\") throw new Error(`Input ${n} is not supported with reduction ${e1}.`);\n        let o = `{\n                var oldValue = 0;\n                loop {\n                  let newValueF32 =`, i = `;\n                  let newValue = bitcast<i32>(newValueF32);\n                  let res = atomicCompareExchangeWeak(&${t}, oldValue, newValue);\n                  if res.exchanged {\n                    break;\n                  }\n                  oldValue = res.old_value;\n                }\n              }`;\n        switch(e1){\n            case \"none\":\n                return `${t}=${r};`;\n            case \"add\":\n                return n === \"i32\" || n === \"u32\" ? `atomicAdd(&${t}, bitcast<${n}>(${r}));` : `\n              ${o}bitcast<${n}>(oldValue) + (${r})${i}`;\n            case \"max\":\n                return n === \"i32\" || n === \"u32\" ? `atomicMax(&${t}, bitcast<${n}>(${r}));` : `\n                ${o}max(bitcast<f32>(oldValue), (${r}))${i}`;\n            case \"min\":\n                return n === \"i32\" || n === \"u32\" ? `atomicMin(&${t}, bitcast<${n}>(${r}));` : `${o}min(bitcast<${n}>(oldValue), (${r}))${i}`;\n            case \"mul\":\n                return `${o}(bitcast<${n}>(oldValue) * (${r}))${i}`;\n            default:\n                throw new Error(`Reduction ${e1} is not supported.`);\n        }\n    }, Eh = (e1, t)=>{\n        let r = e1[0].dims, n = e1[1].dims, o = r, i = 1, a = Math.ceil(C.size(n) / i), d = n[n.length - 1], l = C.sizeFromDimension(r, d), p = [\n            {\n                type: 12,\n                data: a\n            },\n            {\n                type: 12,\n                data: d\n            },\n            {\n                type: 12,\n                data: l\n            },\n            ...N(e1[1].dims, e1[2].dims, o)\n        ], m = (u)=>{\n            let h = E(\"indices\", e1[1].dataType, e1[1].dims.length), _ = E(\"updates\", e1[2].dataType, e1[2].dims.length, i), y = t.reduction !== \"none\" && t.reduction !== \"\" ? rs(\"output\", e1[0].dataType, o.length) : M(\"output\", e1[0].dataType, o.length, i);\n            return `\n      ${u.registerUniform(\"output_size\", \"u32\").registerUniform(\"last_index_dimension\", \"u32\").registerUniform(\"num_updates_elements\", \"u32\").declareVariables(h, _, y)}\n      ${u.mainStart()}\n        ${u.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n  var data_offset = 0u;\n  let indices_start = uniforms.last_index_dimension * global_idx;\n  let indices_end = indices_start + uniforms.last_index_dimension;\n  for (var i = indices_start; i < indices_end; i++) {\n    var index = i32(indices[i].x);\n    ${e1[0].dims.length === 1 ? `\n    let element_count_dim = uniforms.output_strides;\n    let dim_value = uniforms.output_shape;` : `\n    let element_count_dim = uniforms.output_strides[i - indices_start];\n    let dim_value = uniforms.output_shape[i - indices_start + uniforms.last_index_dimension];`}\n    if (index >= 0) {\n      if (index >= i32(dim_value)) {\n        index = i32(dim_value - 1);\n      }\n    } else {\n      if (index < -i32(dim_value)) {\n        index = 0;\n      } else {\n        index += i32(dim_value);\n      }\n    }\n    data_offset += u32((u32(index) * element_count_dim));\n  }\n\n  for (var i = 0u; i < uniforms.num_updates_elements; i++) {\n    let value = updates[uniforms.num_updates_elements * global_idx + i];\n    ${kh(t.reduction, \"output[data_offset + i]\", \"value\", y.type.value)}\n  }\n\n      }`;\n        };\n        return {\n            name: \"ScatterND\",\n            shaderCache: {\n                hint: `${t.cacheKey}_${t.reduction}`,\n                inputDependencies: [\n                    \"rank\",\n                    \"rank\"\n                ]\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: o,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(a / 64)\n                    },\n                    programUniforms: p\n                }),\n            getShaderSource: m\n        };\n    }, Cl = (e1)=>re({\n            reduction: e1.reduction\n        }), Al = (e1, t)=>{\n        e1.compute(Eh(e1.inputs, t), {\n            inputs: [\n                e1.inputs[1],\n                e1.inputs[2]\n            ],\n            outputs: []\n        });\n    };\n});\nvar Ph, zh, Oh, Dh, Bh, Mh, Rh, Uh, Nh, Vh, Wh, El, Lh, Gh, Hh, Fh, qh, Pl, zl, Ol = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    Ph = (e1, t)=>{\n        if (e1.every((r)=>r > 0 || (()=>{\n                throw new Error(\"Resize requires scales input values to be positive\");\n            })), e1.length > 0) {\n            if (t.mode === \"linear\") {\n                if (!(e1.length === 2 || e1.length === 3 || e1.length === 4 && e1[0] === 1 && e1[1] === 1 || e1.length === 4 && e1[0] === 1 && e1[3] === 1 || e1.length === 5 && e1[0] === 1 && e1[1] === 1)) throw new Error(`For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and\n            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1`);\n            } else if (t.mode === \"cubic\" && !(e1.length === 2 || e1.length === 4 && e1[0] === 1 && e1[1] === 1 || e1.length === 4 && e1[0] === 1 && e1[3] === 1)) throw new Error(\"Resize requires scales input size to be 2 or 4 for cubic mode\");\n        }\n    }, zh = (e1, t, r)=>{\n        t.every((o)=>o >= 0 && o < r || (()=>{\n                throw new Error(\"Resize requires axes input values to be positive and less than rank\");\n            }));\n        let n = new Array(r).fill(1);\n        return t.forEach((o, i)=>n[o] = e1[i]), n;\n    }, Oh = (e1, t, r, n, o, i)=>{\n        let [a, d, l] = r > 10 ? [\n            1,\n            2,\n            3\n        ] : [\n            -1,\n            e1.length > 1 ? 1 : -1,\n            -1\n        ], p = e1[0].dims.length;\n        if (a > 0 && e1.length > a && e1[a].dims.length > 0) e1[a].getFloat32Array().forEach((m)=>i.push(m));\n        else if (t.coordinateTransformMode === \"tf_crop_and_resize\") throw new Error(\"Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize\");\n        if (d > 0 && e1.length > d && e1[d].dims.length === 1 && e1[d].dims[0] > 0) {\n            if (e1[d].getFloat32Array().forEach((m)=>n.push(m)), n.length !== 0 && n.length !== p && r >= 18 && n.length !== t.axes.length) throw new Error(\"Resize requires scales input size to be same as input rank or axes size for opset 18 and up\");\n            Ph(n, t), t.axes.length > 0 && zh(n, t.axes, p).forEach((m, u)=>n[u] = m);\n        }\n        if (l > 0 && e1.length > l && e1[l].dims.length === 1 && e1[l].dims[0] > 0 && (e1[l].getBigInt64Array().forEach((m)=>o.push(Number(m))), o.length !== 0 && o.length !== p && r >= 18 && o.length !== t.axes.length)) throw new Error(\"Resize requires sizes input size to be same as input rank or axes size for opset 18 and up\");\n        if (t.axes.length > 0) {\n            if (n.length !== 0 && n.length !== t.axes.length) throw new Error('Resize requires \"scales\" input size to be of axes rank when axes attributes is specified');\n            if (o.length !== 0 && o.length !== t.axes.length) throw new Error('Resize requires \"sizes\" input size to be of rank axes rank when axes attributes is specified');\n        }\n        if (typeof n < \"u\" && typeof o < \"u\" && n.length > 0 && o.length > p) throw new Error(\"Resize requires only of scales or sizes to be specified\");\n    }, Dh = (e1, t)=>`fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,\n     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> ${t} { ` + (()=>{\n            switch(e1){\n                case \"asymmetric\":\n                    return `return ${t}(xResized) / ${t}(xScale);`;\n                case \"pytorch_half_pixel\":\n                    return `if (lengthResized > 1) {\n                    return (${t}(xResized) + 0.5) / ${t}(xScale) - 0.5;\n                  } else {\n                    return 0.0;\n                  }`;\n                case \"tf_half_pixel_for_nn\":\n                    return `return (${t}(xResized) + 0.5) / ${t}(xScale);`;\n                case \"align_corners\":\n                    return `if (lengthResized == 1) {\n                    return 0.0;\n                  } else {\n                    // The whole part and the fractional part are calculated separately due to inaccuracy of floating\n                    // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an\n                    // offset-by-one error later in floor().\n                    let whole = ${t}(xResized * (lengthOriginal - 1) / (lengthResized - 1));\n                    let fract =\n                        ${t}(xResized * (lengthOriginal - 1) % (lengthResized - 1)) / ${t}(lengthResized - 1);\n                    return whole + fract;\n                  }`;\n                case \"tf_crop_and_resize\":\n                    return `if (lengthResized > 1) {\n                    return ${t}(roiStart) * ${t}(lengthOriginal - 1) +\n                        (${t}(xResized) * ${t}(roiEnd - roiStart) * ${t}(lengthOriginal - 1)) /\n                        ${t}(lengthResized - 1);\n                  } else {\n                    return 0.5 * ${t}(roiStart + roiEnd) * ${t}(lengthOriginal - 1);\n                  }`;\n                case \"half_pixel_symmetric\":\n                    return `const outputWidth = ${t}xScale * ${t}(lengthResized);\n                  const adjustment = ${t}(lengthResized) / outputWidth;\n                  const center = ${t}(lengthOriginal) / 2;\n                  const offset = center * (1 - adjustment);\n                  return offset + ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;\n                case \"half_pixel\":\n                    return `return ((${t}(xResized) + 0.5) / ${t}(xScale)) - 0.5;`;\n                default:\n                    throw new Error(`Coordinate transform mode ${e1} is not supported`);\n            }\n        })() + \"}\", Bh = (e1, t, r)=>`fn getNearestPixelFromOriginal(xOriginal: ${r}, isDownSample: bool) -> ${r} {` + (()=>{\n            switch(e1){\n                case \"round_prefer_ceil\":\n                    return \"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }\";\n                case \"floor\":\n                    return \"return floor(xOriginal);\";\n                case \"ceil\":\n                    return \"return ceil(xOriginal);\";\n                case \"round_prefer_floor\":\n                    return \"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }\";\n                case \"simple\":\n                default:\n                    if (t < 11) return \"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }\";\n                    throw new Error(`Nearest mode ${e1} is not supported`);\n            }\n        })() + \"}\", Mh = (e1, t, r)=>{\n        let n = new Array(r).fill(0).concat(new Array(r).fill(1)), o = e1.length === 0 ? n : e1.slice();\n        return t.length > 0 ? (t.forEach((i, a)=>{\n            n[i] = o[a], n[a + r] = o[t.length + a];\n        }), n) : o;\n    }, Rh = (e1, t, r, n)=>{\n        let o = [];\n        if (r.length > 0) if (n.length > 0) {\n            if (e1.forEach((i)=>o.push(i)), Math.max(...n) > e1.length) throw new Error(\"axes is out of bound\");\n            n.forEach((i, a)=>o[i] = r[a]);\n        } else r.forEach((i)=>o.push(i));\n        else {\n            if (t.length === 0) throw new Error(\"Resize requires either scales or sizes.\");\n            o = e1.map((i, a)=>Math.round(i * t[a]));\n        }\n        return o;\n    }, Uh = (e1, t, r)=>{\n        let n = (()=>{\n            switch(r.keepAspectRatioPolicy){\n                case \"not_larger\":\n                    return r.axes.length > 0 ? Math.min(...r.axes.map((i)=>t[i]), Number.MAX_VALUE) : Math.min(...t, Number.MAX_VALUE);\n                case \"not_smaller\":\n                    return r.axes.length > 0 ? Math.max(...r.axes.map((i)=>t[i]), Number.MIN_VALUE) : Math.max(...t, Number.MIN_VALUE);\n                default:\n                    throw new Error(`Keep aspect ratio policy ${r.keepAspectRatioPolicy} is not supported`);\n            }\n        })();\n        t.fill(1, 0, t.length);\n        let o = e1.slice();\n        return r.axes.length > 0 ? (r.axes.forEach((i)=>t[i] = n), r.axes.forEach((i)=>o[i] = Math.round(e1[i] * t[i]))) : (t.fill(n, 0, t.length), o.forEach((i, a)=>o[a] = Math.round(i * t[a]))), o;\n    }, Nh = (e1, t, r, n, o)=>`\n    fn calculateOriginalIndicesFromOutputIndices(output_indices: ${e1.type.indices}) -> array<${e1.type.value}, ${r.length}> {\n      var original_indices: array<${e1.type.value}, ${r.length}>;\n      for (var i:u32 = 0; i < ${r.length}; i++) {\n        var output_index = ${e1.indicesGet(\"output_indices\", \"i\")};\n        var scale = ${F(\"uniforms.scales\", \"i\", n)};\n        var roi_low = ${F(\"uniforms.roi\", \"i\", o)};\n        var roi_hi = ${F(\"uniforms.roi\", `i + ${t.length}`, o)};\n        if (scale == 1.0) {\n          original_indices[i] = ${e1.type.value}(output_index);\n        } else {\n          var input_shape_i = ${F(\"uniforms.input_shape\", \"i\", t.length)};\n          var output_shape_i = ${F(\"uniforms.output_shape\", \"i\", r.length)};\n          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                           input_shape_i, roi_low, roi_hi);\n        }\n      }\n      return original_indices;\n    }`, Vh = (e1, t, r, n, o, i, a)=>`\n    fn calculateInputIndicesFromOutputIndices(output_indices: ${t.type.indices}) -> ${e1.type.indices} {\n      var input_indices: ${e1.type.indices};\n      for (var i:u32 = 0; i < ${n.length}; i++) {\n        var output_index = ${t.indicesGet(\"output_indices\", \"i\")};\n        var input_index: u32;\n        var scale = ${F(\"uniforms.scales\", \"i\", o)};\n        if (scale == 1.0) {\n          input_index = output_index;\n        } else {\n          var roi_low = ${F(\"uniforms.roi\", \"i\", i)};\n          var roi_hi = ${F(\"uniforms.roi\", `i + ${r.length}`, i)};\n          var input_shape_i = ${F(\"uniforms.input_shape\", \"i\", r.length)};\n          var output_shape_i = ${F(\"uniforms.output_shape\", \"i\", n.length)};\n          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\n                                                                        input_shape_i, roi_low, roi_hi);\n          if (!${a} || (original_idx >= 0 && original_idx < ${t.type.value}(input_shape_i))) {\n            if (original_idx < 0) {\n              input_index = 0;\n            } else if (original_idx > ${t.type.value}(input_shape_i - 1)) {\n              input_index = input_shape_i - 1;\n            } else {\n              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));\n            }\n          } else {\n            input_index = u32(original_idx);\n          }\n        }\n        ${e1.indicesSet(\"input_indices\", \"i\", \" input_index\")}\n      }\n      return input_indices;\n    }`, Wh = (e1, t)=>`\n    fn checkInputIndices(input_indices: ${e1.type.indices}) -> bool {\n      for (var i:u32 = 0; i < ${t.length}; i++) {\n        var input_index = ${e1.indicesGet(\"input_indices\", \"i\")};\n        if (input_index < 0 || input_index >= ${F(\"uniforms.input_shape\", \"i\", t.length)}) {\n          return false;\n        }\n      }\n      return true;\n    }`, El = (e1, t, r, n)=>e1.rank > n ? `\n    ${e1.indicesSet(\"input_indices\", t, \"channel\")};\n    ${e1.indicesSet(\"input_indices\", r, \"batch\")};\n` : \"\", Lh = (e1, t, r, n, o)=>{\n        let [a, d, l, p] = r.length === 2 ? [\n            -1,\n            0,\n            1,\n            -1\n        ] : [\n            0,\n            2,\n            3,\n            1\n        ], m = e1.type.value;\n        return `\n    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> ${m} {\n      var input_indices: ${e1.type.indices};\n      ${e1.indicesSet(\"input_indices\", d, `max(0, min(row, ${r[d]} - 1))`)};\n      ${e1.indicesSet(\"input_indices\", l, `max(0, min(col, ${r[l]} - 1))`)};\n      ${El(e1, p, a, 2)}\n      return ${e1.getByIndices(\"input_indices\")};\n    }\n\n    fn bilinearInterpolation(output_indices: ${t.type.indices}) -> ${m} {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\n      var row:${m} = originalIndices[${d}];\n      var col:${m} = originalIndices[${l}];\n      ${n ? `if (row < 0 || row > (${r[d]} - 1) || col < 0 || col > (${r[l]} - 1)) {\n        return ${o};\n      }` : \"\"};\n      row = max(0, min(row, ${r[d]} - 1));\n      col = max(0, min(col, ${r[l]} - 1));\n      var row1: u32 = u32(row);\n      var col1: u32 = u32(col);\n      var row2: u32 = u32(row + 1);\n      var col2: u32 = u32(col + 1);\n      var channel: u32 = ${r.length > 2 ? `u32(originalIndices[${p}])` : \"0\"};\n      var batch: u32 =  ${r.length > 2 ? `u32(originalIndices[${a}])` : \"0\"};\n      var x11: ${m} = getInputValue(batch, channel, row1, col1);\n      var x12: ${m} = getInputValue(batch, channel, row1, col2);\n      var x21: ${m} = getInputValue(batch, channel, row2, col1);\n      var x22: ${m} = getInputValue(batch, channel, row2, col2);\n      var dx1: ${m} = abs(row - ${m}(row1));\n      var dx2: ${m} = abs(${m}(row2) - row);\n      var dy1: ${m} = abs(col - ${m}(col1));\n      var dy2: ${m} = abs(${m}(col2) - col);\n      if (row1 == row2) {\n        dx1 = 0.5;\n        dx2 = 0.5;\n      }\n      if (col1 == col2) {\n        dy1 = 0.5;\n        dy2 = 0.5;\n      }\n      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);\n    }`;\n    }, Gh = (e1, t, r, n, o, i, a, d, l, p)=>{\n        let m = r.length === 2, u = !0, [h, _] = m ? [\n            0,\n            1\n        ] : u ? [\n            2,\n            3\n        ] : [\n            1,\n            2\n        ], y = e1.type.value, g = (x)=>{\n            let $ = x === h ? \"row\" : \"col\";\n            return `\n      fn ${$}CubicInterpolation(input_indices: ${e1.type.indices}, output_indices: ${t.type.indices}) -> ${y} {\n        var output_index = ${t.indicesGet(\"output_indices\", x)};\n        var originalIdx: ${y} = getOriginalCoordinateFromResizedCoordinate(output_index, ${o[x]},\n        ${n[x]}, ${r[x]}, ${i[x]}, ${i[x]} + ${r.length});\n        var fractOriginalIdx: ${y} = originalIdx - floor(originalIdx);\n        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);\n\n        if (${d} && (originalIdx < 0 || originalIdx > (${r[x]} - 1))) {\n          return ${l};\n        }\n        var data: array<${y}, 4> = array<${y}, 4>(0.0, 0.0, 0.0, 0.0);\n        for (var i: i32 = -1; i < 3; i++) {\n          var ${$}: ${y} = originalIdx + ${y}(i);\n          if (${$} < 0 || ${$} >= ${r[x]}) {\n            ${(()=>p ? `coefs[i + 1] = 0.0;\n                        continue;` : d ? `return ${l};` : `${$} = max(0, min(${$}, ${r[x]} - 1));`)()};\n          }\n        var input_indices_copy: ${e1.type.indices} = input_indices;\n          ${e1.indicesSet(\"input_indices_copy\", x, `u32(${$})`)};\n          data[i + 1] = ${x === h ? e1.getByIndices(\"input_indices_copy\") : \"rowCubicInterpolation(input_indices_copy, output_indices)\"};\n        }\n        return cubicInterpolation1D(data, coefs);\n      }`;\n        };\n        return `\n    ${g(h)};\n    ${g(_)};\n  fn getCubicInterpolationCoefs(s: ${y}) -> array<${y}, 4> {\n    var absS = abs(s);\n    var coeffs: array<${y}, 4> = array<${y}, 4>(0.0, 0.0, 0.0, 0.0);\n    var oneMinusAbsS: ${y} = 1.0 - absS;\n    var twoMinusAbsS: ${y} = 2.0 - absS;\n    var onePlusAbsS: ${y} = 1.0 + absS;\n    coeffs[0] = ((${a} * onePlusAbsS - 5 * ${a}) * onePlusAbsS + 8 * ${a}) * onePlusAbsS - 4 * ${a};\n    coeffs[1] = ((${a} + 2) * absS - (${a} + 3)) * absS * absS + 1;\n    coeffs[2] = ((${a} + 2) * oneMinusAbsS - (${a} + 3)) * oneMinusAbsS * oneMinusAbsS + 1;\n    coeffs[3] = ((${a} * twoMinusAbsS - 5 * ${a}) * twoMinusAbsS + 8 * ${a}) * twoMinusAbsS - 4 * ${a};\n    return coeffs;\n  }\n\n  fn cubicInterpolation1D(x: array<${y}, 4>, coefs: array<${y}, 4>) -> ${y} {\n    var coefsSum: ${y} = coefs[0] + coefs[1] + coefs[2] + coefs[3];\n    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;\n  }\n\n  fn bicubicInterpolation(output_indices: ${t.type.indices}) -> ${y} {\n    var input_indices: ${e1.type.indices} = output_indices;\n    return colCubicInterpolation(input_indices, output_indices);\n  }\n    `;\n    }, Hh = (e1, t, r, n, o)=>{\n        let [a, d, l, p, m] = r.length === 3 ? [\n            -1,\n            0,\n            1,\n            2,\n            -1\n        ] : [\n            0,\n            2,\n            3,\n            4,\n            1\n        ], u = e1.type.value;\n        return `\n    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> ${u} {\n      var input_indices: ${e1.type.indices};\n      ${e1.indicesSet(\"input_indices\", d, `max(0, min(depth, ${r[d]} - 1))`)};\n      ${e1.indicesSet(\"input_indices\", l, `max(0, min(height, ${r[l]} - 1))`)};\n      ${e1.indicesSet(\"input_indices\", p, `max(0, min(width, ${r[p]} - 1))`)};\n      ${El(e1, m, a, 3)}\n      return ${e1.getByIndices(\"input_indices\")};\n    }\n\n    fn trilinearInterpolation(output_indices: ${t.type.indices}) -> ${u} {\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\n      var depth:${u} = originalIndices[${d}];\n      var height:${u} = originalIndices[${l}];\n      var width:${u} = originalIndices[${p}];\n      ${n ? `if (depth < 0 || depth > (${r[d]} - 1) || height < 0 || height > (${r[l]} - 1) || width < 0 || (width > ${r[p]} - 1)) {\n      return ${o};\n        }` : \"\"};\n\n    depth = max(0, min(depth, ${r[d]} - 1));\n      height = max(0, min(height, ${r[l]} - 1));\n      width = max(0, min(width, ${r[p]} - 1));\n      var depth1: u32 = u32(depth);\n      var height1: u32 = u32(height);\n      var width1: u32 = u32(width);\n      var depth2: u32 = u32(depth + 1);\n      var height2: u32 = u32(height + 1);\n      var width2: u32 = u32(width + 1);\n      var channel: u32 = ${r.length > 3 ? `u32(originalIndices[${m}])` : \"0\"};\n      var batch: u32 =  ${r.length > 3 ? `u32(originalIndices[${a}])` : \"0\"};\n\n      var x111: ${u} = getInputValue(batch, channel, depth1, height1, width1);\n      var x112: ${u} = getInputValue(batch, channel, depth1, height1, width2);\n      var x121: ${u} = getInputValue(batch, channel, depth1, height2, width1);\n      var x122: ${u} = getInputValue(batch, channel, depth1, height2, width2);\n      var x211: ${u} = getInputValue(batch, channel, depth2, height1, width1);\n      var x212: ${u} = getInputValue(batch, channel, depth2, height1, width2);\n      var x221: ${u} = getInputValue(batch, channel, depth2, height2, width1);\n      var x222: ${u} = getInputValue(batch, channel, depth2, height2, width2);\n      var dx1: ${u} = abs(depth - ${u}(depth1));\n      var dx2: ${u} = abs(${u}(depth2) - depth);\n      var dy1: ${u} = abs(height - ${u}(height1));\n      var dy2: ${u} = abs(${u}(height2) - height);\n      var dz1: ${u} = abs(width - ${u}(width1));\n      var dz2: ${u} = abs(${u}(width2) - width);\n      if (depth1 == depth2) {\n        dx1 = 0.5;\n        dx2 = 0.5;\n      }\n      if (height1 == height2) {\n        dy1 = 0.5;\n        dy2 = 0.5;\n      }\n      if (width1 == width2) {\n        dz1 = 0.5;\n        dz2 = 0.5;\n      }\n      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +\n              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);\n    }`;\n    }, Fh = (e1, t, r, n, o, i)=>{\n        let a = e1.dims, d = Mh(i, t.axes, a.length), l = Rh(a, n, o, t.axes), p = n.slice();\n        n.length === 0 && (p = a.map((v, S)=>v === 0 ? 1 : l[S] / v), t.keepAspectRatioPolicy !== \"stretch\" && (l = Uh(a, p, t)));\n        let m = M(\"output\", e1.dataType, l.length), u = E(\"input\", e1.dataType, a.length), h = C.size(l), _ = a.length === l.length && a.every((v, S)=>v === l[S]), y = t.coordinateTransformMode === \"tf_crop_and_resize\", g = t.extrapolationValue, x = u.type.value, $ = (v)=>`\n      ${_ ? \"\" : `\n      ${Dh(t.coordinateTransformMode, x)};\n      ${(()=>{\n                switch(t.mode){\n                    case \"nearest\":\n                        return `\n              ${Wh(u, a)};\n              ${Bh(t.nearestMode, r, x)};\n              ${Vh(u, m, a, l, p.length, d.length, y)};\n              `;\n                    case \"linear\":\n                        return `\n              ${Nh(m, a, l, p.length, d.length)};\n              ${(()=>{\n                            if (a.length === 2 || a.length === 4) return `${Lh(u, m, a, y, g)}`;\n                            if (a.length === 3 || a.length === 5) return `${Hh(u, m, a, y, g)}`;\n                            throw Error(\"Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.\");\n                        })()};\n            `;\n                    case \"cubic\":\n                        return `\n            ${(()=>{\n                            if (a.length === 2 || a.length === 4) return `${Gh(u, m, a, l, p, d, t.cubicCoeffA, y, t.extrapolationValue, t.excludeOutside)}`;\n                            throw Error(\"Cubic mode only supports input dims 2 and 4 are supported in linear mode.\");\n                        })()};\n            `;\n                    default:\n                        throw Error(\"Invalid resize mode\");\n                }\n            })()};\n      `}\n      ${v.registerUniform(\"output_size\", \"u32\").registerUniform(\"scales\", \"f32\", p.length).registerUniform(\"roi\", \"f32\", d.length).declareVariables(u, m)}\n      ${v.mainStart()}\n        ${v.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n        ${_ ? \"output[global_idx] = input[global_idx];\" : `\n        let output_indices = ${m.offsetToIndices(\"global_idx\")};\n        var input_indices: ${u.type.indices};\n        ${(()=>{\n                switch(t.mode){\n                    case \"nearest\":\n                        return `input_indices = calculateInputIndicesFromOutputIndices(output_indices);\n                if (checkInputIndices(input_indices)) {\n                  output[global_idx] = ${u.getByIndices(\"input_indices\")};\n                } else {\n                  output[global_idx] = ${t.extrapolationValue};\n                }`;\n                    case \"linear\":\n                        return `output[global_idx] = ${a.length === 2 || a.length === 4 ? \"bilinearInterpolation\" : \"trilinearInterpolation\"}(output_indices);`;\n                    case \"cubic\":\n                        return \"output[global_idx] = bicubicInterpolation(output_indices);\";\n                    default:\n                        throw Error(`Unsupported resize mode: ${t.mode}`);\n                }\n            })()};\n`}\n      }`;\n        return {\n            name: \"Resize\",\n            shaderCache: {\n                hint: `${t.cacheKey}|${r}|${p.length > 0 ? p : \"\"}|${o.length > 0 ? o : \"\"}|${d.length > 0 ? d : \"\"}|${_}|${a}`,\n                inputDependencies: [\n                    \"rank\"\n                ]\n            },\n            getShaderSource: $,\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: l,\n                            dataType: e1.dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(h / 64)\n                    },\n                    programUniforms: [\n                        {\n                            type: 12,\n                            data: h\n                        },\n                        {\n                            type: 1,\n                            data: p\n                        },\n                        {\n                            type: 1,\n                            data: d\n                        },\n                        ...N(a, l)\n                    ]\n                })\n        };\n    }, qh = (e1)=>{\n        let t = e1.customDataBuffer;\n        return new Uint32Array(t, t.byteOffset, 1)[0];\n    }, Pl = (e1, t)=>{\n        let r = [], n = [], o = [], i = qh(e1);\n        if (t.antialias !== 0) throw Error(\"Only default value (0) for Antialias attribute is supported\");\n        Oh(e1.inputs, t, i, r, n, o), e1.compute(Fh(e1.inputs[0], t, i, r, n, o), {\n            inputs: [\n                0\n            ]\n        });\n    }, zl = (e1)=>{\n        let t = e1.antialias, r = e1.axes, n = e1.coordinateTransformMode, o = e1.cubicCoeffA, i = e1.excludeOutside !== 0, a = e1.extrapolationValue, d = e1.keepAspectRatioPolicy, l = e1.mode, p = e1.nearestMode === \"\" ? \"simple\" : e1.nearestMode;\n        return re({\n            antialias: t,\n            axes: r,\n            coordinateTransformMode: n,\n            cubicCoeffA: o,\n            excludeOutside: i,\n            extrapolationValue: a,\n            keepAspectRatioPolicy: d,\n            mode: l,\n            nearestMode: p\n        });\n    };\n});\nvar Kh, jh, Dl, Bl = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    Kh = (e1, t)=>{\n        let [r, n, o, i] = e1, { numHeads: a, rotaryEmbeddingDim: d } = t;\n        if (r.dims.length !== 3 && r.dims.length !== 4) throw new Error(`Input 'x' is expected to have 3 or 4 dimensions, got ${r.dims.length}`);\n        if (!C.areEqual(n.dims, []) && !C.areEqual(n.dims, [\n            1\n        ]) && n.dims.length !== 2) throw new Error(`Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got ${n.dims.length}`);\n        if (o.dims.length !== 2) throw new Error(`Input 'cos_cache' is expected to have 2 dimensions, got ${o.dims.length}`);\n        if (i.dims.length !== 2) throw new Error(`Input 'sin_cache' is expected to have 2 dimensions, got ${i.dims.length}`);\n        if (!C.areEqual(o.dims, i.dims)) throw new Error(\"Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape\");\n        if (d > 0 && a === 0) throw new Error(\"num_heads must be provided if rotary_embedding_dim is specified\");\n        let l = r.dims[0], p = r.dims[r.dims.length - 2], m = o.dims[0], u = C.sizeFromDimension(r.dims, 1) / p, h = d === 0 ? o.dims[1] * 2 : u / a;\n        if (d > h) throw new Error(\"rotary_embedding_dim must be less than or equal to head_size\");\n        if (n.dims.length === 2) {\n            if (l !== n.dims[0]) throw new Error(`Input 'position_ids' dimension 0 should be of size batch_size, got ${n.dims[0]}`);\n            if (p !== n.dims[1]) throw new Error(`Input 'position_ids' dimension 1 should be of size sequence_length, got ${n.dims[1]}`);\n        }\n        if (h / 2 !== o.dims[1] && d / 2 !== o.dims[1]) throw new Error(`Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got ${o.dims[1]}`);\n        if (p > m) throw new Error(\"Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported\");\n    }, jh = (e1, t)=>{\n        let { interleaved: r, numHeads: n, rotaryEmbeddingDim: o, scale: i } = t, a = e1[0].dims[0], d = C.sizeFromDimension(e1[0].dims, 1), l = e1[0].dims[e1[0].dims.length - 2], p = d / l, m = e1[2].dims[1], u = o === 0 ? m * 2 : p / n, h = new Array(a, l, p / u, u - m), _ = C.computeStrides(h), y = [\n            {\n                type: 1,\n                data: i\n            },\n            {\n                type: 12,\n                data: h\n            },\n            {\n                type: 12,\n                data: _\n            },\n            ...e1[0].dims.length === 3 ? new Array({\n                type: 12,\n                data: [\n                    d,\n                    p,\n                    u,\n                    1\n                ]\n            }) : [],\n            ...e1[0].dims.length === 4 ? new Array({\n                type: 12,\n                data: [\n                    d,\n                    u,\n                    l * u,\n                    1\n                ]\n            }) : [],\n            ...N(e1[0].dims, e1[1].dims, e1[2].dims, e1[3].dims, e1[0].dims)\n        ], g = (x)=>{\n            let $ = E(\"input\", e1[0].dataType, e1[0].dims.length), v = E(\"position_ids\", e1[1].dataType, e1[1].dims.length), S = E(\"cos_cache\", e1[2].dataType, e1[2].dims.length), T = E(\"sin_cache\", e1[3].dataType, e1[3].dims.length), A = M(\"output\", e1[0].dataType, e1[0].dims.length);\n            return x.registerUniforms([\n                {\n                    name: \"scale\",\n                    type: \"f32\"\n                },\n                {\n                    name: \"global_shape\",\n                    type: \"u32\",\n                    length: h.length\n                },\n                {\n                    name: \"global_strides\",\n                    type: \"u32\",\n                    length: _.length\n                },\n                {\n                    name: \"input_output_strides\",\n                    type: \"u32\",\n                    length: _.length\n                }\n            ]), `\n        ${x.declareVariables($, v, S, T, A)}\n\n        ${x.mainStart(kt)}\n          let half_rotary_emb_dim = uniforms.${S.name}_shape[1];\n          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;\n          let size = uniforms.global_shape[0] * uniforms.global_strides[0];\n          ${x.guardAgainstOutOfBoundsWorkgroupSizes(\"size\")}\n\n          if (bsnh[3] < half_rotary_emb_dim) {\n            let position_ids_idx =\n                ${v.broadcastedIndicesToOffset(\"bsnh.xy\", M(\"\", v.type.tensor, 2))};\n            let position_id =\n                u32(${v.getByOffset(\"position_ids_idx\")}) + select(0, bsnh[1], position_ids_idx == 0);\n            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], ${r});\n            let j = i + select(half_rotary_emb_dim, 1, ${r});\n            let re = ${$.getByOffset(\"i\")} * ${S.get(\"position_id\", \"bsnh[3]\")} -\n                ${$.getByOffset(\"j\")} * ${T.get(\"position_id\", \"bsnh[3]\")};\n            ${A.setByOffset(\"i\", \"re\")}\n            let im = ${$.getByOffset(\"i\")} * ${T.get(\"position_id\", \"bsnh[3]\")} +\n                ${$.getByOffset(\"j\")} * ${S.get(\"position_id\", \"bsnh[3]\")};\n            ${A.setByOffset(\"j\", \"im\")}\n          } else {\n            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;\n            ${A.setByOffset(\"k\", $.getByOffset(\"k\"))}\n          }\n        }`;\n        };\n        return {\n            name: \"RotaryEmbedding\",\n            shaderCache: {\n                hint: re({\n                    interleaved: r\n                }).cacheKey,\n                inputDependencies: [\n                    \"rank\",\n                    \"rank\",\n                    \"rank\",\n                    \"rank\"\n                ]\n            },\n            getShaderSource: g,\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: e1[0].dims,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(C.size(h) / kt)\n                    },\n                    programUniforms: y\n                })\n        };\n    }, Dl = (e1, t)=>{\n        Kh(e1.inputs, t), e1.compute(jh(e1.inputs, t));\n    };\n});\nvar Yh, Zh, Ml, Rl = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    ae();\n    Yh = (e1)=>{\n        if (!e1 || e1.length < 3) throw new Error(\"layerNorm requires at least 3 inputs.\");\n        let t = e1[0], r = e1[1], n = e1[2];\n        if (t.dataType !== r.dataType || t.dataType !== n.dataType) throw new Error(\"All inputs must have the same data type\");\n        if (t.dims.length !== 3 && t.dims.length !== 2) throw new Error(\"Input must be 2D or 3D\");\n        if (r.dims.length !== 3 && r.dims.length !== 2) throw new Error(\"Skip must be 2D or 3D\");\n        let o = t.dims[t.dims.length - 1], i = t.dims[t.dims.length - 2];\n        if (r.dims[r.dims.length - 1] !== o) throw new Error(\"Skip must have the same hidden size as input\");\n        if (r.dims[r.dims.length - 2] !== i) throw new Error(\"Skip must have the same sequence length as input\");\n        if (n.dims.length !== 1) throw new Error(\"Gamma must be 1D\");\n        if (n.dims[n.dims.length - 1] !== o) throw new Error(\"Gamma must have the same hidden size as input\");\n        if (e1.length > 3) {\n            let a = e1[3];\n            if (a.dims.length !== 1) throw new Error(\"Beta must be 1D\");\n            if (a.dims[a.dims.length - 1] !== o) throw new Error(\"Beta must have the same hidden size as input\");\n        }\n        if (e1.length > 4) {\n            let a = e1[4];\n            if (a.dims.length !== 1) throw new Error(\"Bias must be 1D\");\n            if (a.dims[a.dims.length - 1] !== o) throw new Error(\"Bias must have the same hidden size as input\");\n        }\n    }, Zh = (e1, t, r, n)=>{\n        let o = t.simplified, i = e1[0].dims, a = C.size(i), d = i, l = a, p = i.slice(-1)[0], m = n ? i.slice(0, -1).concat(1) : [], u = !o && e1.length > 3, h = e1.length > 4, _ = n && r > 1, y = n && r > 2, g = r > 3, x = 64, $ = me(p), v = [\n            {\n                type: 12,\n                data: l\n            },\n            {\n                type: 12,\n                data: $\n            },\n            {\n                type: 12,\n                data: p\n            },\n            {\n                type: 1,\n                data: t.epsilon\n            }\n        ], S = (A)=>{\n            let k = [\n                {\n                    name: \"output_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"components\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"hidden_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"epsilon\",\n                    type: \"f32\"\n                }\n            ], P = [\n                E(\"x\", e1[0].dataType, e1[0].dims, $),\n                E(\"skip\", e1[1].dataType, e1[1].dims, $),\n                E(\"gamma\", e1[2].dataType, e1[2].dims, $)\n            ];\n            u && P.push(E(\"beta\", e1[3].dataType, e1[3].dims, $)), h && P.push(E(\"bias\", e1[4].dataType, e1[4].dims, $)), P.push(M(\"output\", e1[0].dataType, d, $)), _ && P.push(M(\"mean_output\", 1, m)), y && P.push(M(\"inv_std_output\", 1, m)), g && P.push(M(\"input_skip_bias_sum\", e1[0].dataType, d, $));\n            let D = _e(e1[0].dataType), R = _e(1, $);\n            return `\n\n      ${A.registerUniforms(k).declareVariables(...P)}\n      var<workgroup> sum_shared : array<${R}, ${x}>;\n      var<workgroup> sum_squared_shared : array<${R}, ${x}>;\n\n      ${A.mainStart([\n                x,\n                1,\n                1\n            ])}\n        let ix = local_id.x;\n        let iy = global_id.x / ${x};\n\n        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;\n        var stride = hidden_size_vectorized / ${x};\n        let offset = ix * stride + iy * hidden_size_vectorized;\n        let offset1d = stride * ix;\n        if (ix == ${x - 1}) {\n          stride = hidden_size_vectorized - stride * ix;\n        }\n        for (var i: u32 = 0; i < stride; i++) {\n          let skip_value = skip[offset + i];\n          let bias_value = ${h ? \"bias[offset1d + i]\" : D + \"(0.0)\"};\n          let input_value = x[offset + i];\n          let value = input_value + skip_value + bias_value;\n          ${g ? \"input_skip_bias_sum[offset + i] = value;\" : \"\"}\n          output[offset + i] = value;\n          let f32_value = ${Et(D, $, \"value\")};\n          sum_shared[ix] += f32_value;\n          sum_squared_shared[ix] += f32_value * f32_value;\n        }\n        workgroupBarrier();\n\n        var reduce_size : u32 = ${x};\n        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {\n          reduce_size = curr_size + (reduce_size & 1);\n          if (ix < curr_size) {\n            sum_shared[ix] += sum_shared[ix + reduce_size];\n            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];\n          }\n          workgroupBarrier();\n        }\n\n        let sum = sum_shared[0];\n        let square_sum = sum_squared_shared[0];\n        let mean = ${Fe(\"sum\", $)} / f32(uniforms.hidden_size);\n        let inv_std_dev = inverseSqrt(${Fe(\"square_sum\", $)} / f32(uniforms.hidden_size) ${o ? \"\" : \"- mean * mean\"} + uniforms.epsilon);\n        ${_ ? \"mean_output[global_idx] = mean;\" : \"\"}\n        ${y ? \"inv_std_output[global_idx] = inv_std_dev;\" : \"\"}\n\n        for (var i: u32 = 0; i < stride; i++) {\n          output[offset + i] = (output[offset + i] ${o ? \"\" : `- ${D}(mean)`}) *\n            ${D}(inv_std_dev) * gamma[offset1d + i]\n            ${u ? \"+ beta[offset1d + i]\" : \"\"};\n        }\n      }`;\n        }, T = [\n            {\n                dims: d,\n                dataType: e1[0].dataType\n            }\n        ];\n        return r > 1 && T.push({\n            dims: m,\n            dataType: 1\n        }), r > 2 && T.push({\n            dims: m,\n            dataType: 1\n        }), r > 3 && T.push({\n            dims: i,\n            dataType: e1[0].dataType\n        }), {\n            name: \"SkipLayerNormalization\",\n            shaderCache: {\n                hint: `${$};${_};${y};${g}`,\n                inputDependencies: e1.map((A, k)=>\"type\")\n            },\n            getShaderSource: S,\n            getRunData: ()=>({\n                    outputs: T,\n                    dispatchGroup: {\n                        x: Math.ceil(l / p)\n                    },\n                    programUniforms: v\n                })\n        };\n    }, Ml = (e1, t)=>{\n        Yh(e1.inputs);\n        let n = [\n            0\n        ];\n        e1.outputCount > 1 && n.push(-3), e1.outputCount > 2 && n.push(-3), e1.outputCount > 3 && n.push(3), e1.compute(Zh(e1.inputs, t, e1.outputCount, !1), {\n            outputs: n\n        });\n    };\n});\nvar Qh, rn, Xh, Ul, Jh, eg, Nl, Vl, Wl = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    Qh = (e1, t)=>{\n        if (!e1 || e1.length < 1) throw new Error(\"too few inputs\");\n        if (t.axes.length !== 0) {\n            if (t.axes.length !== t.starts.length || t.axes.length !== t.ends.length) throw new Error(\"axes, starts and ends must have the same length\");\n        } else if (t.starts.length !== t.ends.length) throw new Error(\"starts and ends must have the same length\");\n        e1.slice(1).forEach((r, n)=>{\n            if (e1[n + 1].dataType !== 6 && e1[n + 1].dataType !== 7) throw new Error(`Input ${n} must be an array of int32 or int64`);\n        });\n    }, rn = (e1, t)=>{\n        let r = [];\n        if (e1.length > t) if (e1[t].dataType === 7) e1[t].getBigInt64Array().forEach((n)=>r.push(Number(n)));\n        else if (e1[t].dataType === 6) e1[t].getInt32Array().forEach((n)=>r.push(Number(n)));\n        else throw new Error(`Input ${t} must be an array of int32 or int64`);\n        return r;\n    }, Xh = (e1, t)=>{\n        if (e1.length > 1) {\n            let r = rn(e1, 1), n = rn(e1, 2), o = rn(e1, 3);\n            return o.length === 0 && (o = [\n                ...Array(e1[0].dims.length).keys()\n            ]), re({\n                starts: r,\n                ends: n,\n                axes: o\n            });\n        } else return t;\n    }, Ul = (e1, t, r, n, o)=>{\n        let i = e1;\n        return e1 < 0 && (i += r[n[t]]), o[t] < 0 ? Math.max(0, Math.min(i, r[n[t]] - 1)) : Math.max(0, Math.min(i, r[n[t]]));\n    }, Jh = (e1, t, r)=>`fn calculateInputIndices(output_indices: ${t.type.indices}) -> ${e1.type.indices} {\n          var input_indices: ${e1.type.indices};\n          var carry = 0u;\n          for (var i = ${r.length}; i >= 0; i--) {\n            let input_shape_i = ${F(\"uniforms.input_shape\", \"i\", r.length)};\n            let steps_i = ${F(\"uniforms.steps\", \"i\", r.length)};\n            let signs_i = ${F(\"uniforms.signs\", \"i\", r.length)};\n            let starts_i = ${F(\"uniforms.starts\", \"i\", r.length)};\n            var output_index = ${t.indicesGet(\"output_indices\", \"i\")};\n            var input_index = output_index * steps_i + starts_i + carry;\n            carry = input_index / input_shape_i;\n            input_index = input_index % input_shape_i;\n            if (signs_i < 0) {\n              input_index = input_shape_i - input_index - 1u + starts_i;\n            }\n            ${e1.indicesSet(\"input_indices\", \"i\", \"input_index\")};\n          }\n          return input_indices;\n      }`, eg = (e1, t)=>{\n        let r = e1[0].dims, n = C.size(r), o = t.axes.length > 0 ? C.normalizeAxes(t.axes, r.length) : [\n            ...Array(r.length).keys()\n        ], i = rn(e1, 4);\n        i.forEach(($)=>$ !== 0 || (()=>{\n                throw new Error(\"step cannot be 0\");\n            })), i.length === 0 && (i = Array(o.length).fill(1));\n        let a = t.starts.map(($, v)=>Ul($, v, r, o, i)), d = t.ends.map(($, v)=>Ul($, v, r, o, i));\n        if (o.length !== a.length || o.length !== d.length) throw new Error(\"start, ends and axes should have the same number of elements\");\n        if (o.length !== r.length) for(let $ = 0; $ < r.length; ++$)o.includes($) || (a.splice($, 0, 0), d.splice($, 0, r[$]), i.splice($, 0, 1));\n        let l = i.map(($)=>Math.sign($));\n        i.forEach(($, v, S)=>{\n            if ($ < 0) {\n                let T = (d[v] - a[v]) / $, A = a[v], k = A + T * i[v];\n                a[v] = k, d[v] = A, S[v] = -$;\n            }\n        });\n        let p = r.slice(0);\n        o.forEach(($, v)=>{\n            p[$] = Math.ceil((d[$] - a[$]) / i[$]);\n        });\n        let m = {\n            dims: p,\n            dataType: e1[0].dataType\n        }, u = M(\"output\", e1[0].dataType, p.length), h = E(\"input\", e1[0].dataType, e1[0].dims.length), _ = C.size(p), y = [\n            {\n                name: \"outputSize\",\n                type: \"u32\"\n            },\n            {\n                name: \"starts\",\n                type: \"u32\",\n                length: a.length\n            },\n            {\n                name: \"signs\",\n                type: \"i32\",\n                length: l.length\n            },\n            {\n                name: \"steps\",\n                type: \"u32\",\n                length: i.length\n            }\n        ], g = [\n            {\n                type: 12,\n                data: _\n            },\n            {\n                type: 12,\n                data: a\n            },\n            {\n                type: 6,\n                data: l\n            },\n            {\n                type: 12,\n                data: i\n            },\n            ...N(e1[0].dims, p)\n        ], x = ($)=>`\n      ${$.registerUniforms(y).declareVariables(h, u)}\n        ${Jh(h, u, r)}\n        ${$.mainStart()}\n          ${$.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\")}\n          let output_indices = ${u.offsetToIndices(\"global_idx\")};\n          let input_indices = calculateInputIndices(output_indices);\n          ${u.setByOffset(\"global_idx\", h.getByIndices(\"input_indices\"))}\n      }`;\n        return {\n            name: \"Slice\",\n            shaderCache: {\n                hint: `${l.length}_${a.length}_${i.length}`,\n                inputDependencies: [\n                    \"rank\"\n                ]\n            },\n            getShaderSource: x,\n            getRunData: ()=>({\n                    outputs: [\n                        m\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(n / 64)\n                    },\n                    programUniforms: g\n                })\n        };\n    }, Nl = (e1, t)=>{\n        Qh(e1.inputs, t);\n        let r = Xh(e1.inputs, t);\n        e1.compute(eg(e1.inputs, r), {\n            inputs: [\n                0\n            ]\n        });\n    }, Vl = (e1)=>{\n        let t = e1.starts, r = e1.ends, n = e1.axes;\n        return re({\n            starts: t,\n            ends: r,\n            axes: n\n        });\n    };\n});\nvar tg, rg, Ll, Gl, Hl = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    dt();\n    ae();\n    tg = (e1)=>{\n        if (!e1 || e1.length !== 1) throw new Error(\"Softmax op requires 1 input.\");\n    }, rg = (e1, t)=>{\n        let r = e1.inputs[0], n = r.dims, o = C.size(n), i = n.length, a = C.normalizeAxis(t.axis, i), d = a < n.length - 1, l, p = [];\n        d ? (p = Array.from({\n            length: i\n        }, (P, D)=>D), p[a] = i - 1, p[i - 1] = a, l = e1.compute(Pe(r, p), {\n            inputs: [\n                r\n            ],\n            outputs: [\n                -1\n            ]\n        })[0]) : l = r;\n        let m = l.dims, u = m[i - 1], h = o / u, _ = me(u), y = u / _, g = 64;\n        h === 1 && (g = 256);\n        let x = (P, D)=>D === 4 ? `max(max(${P}.x, ${P}.y), max(${P}.z, ${P}.w))` : D === 2 ? `max(${P}.x, ${P}.y)` : D === 3 ? `max(max(${P}.x, ${P}.y), ${P}.z)` : P, $ = E(\"x\", l.dataType, l.dims, _), v = M(\"result\", l.dataType, l.dims, _), S = $.type.value, T = _e(l.dataType) === \"f32\" ? `var threadMax = ${S}(-3.402823e+38f);` : `var threadMax = ${S}(-65504.0h);`, A = (P)=>`\n      var<workgroup> rowMaxShared : ${S};\n      var<workgroup> rowSumShared : ${S};\n      var<workgroup> threadShared : array<${S}, ${g}>;\n\n      fn getValue(row: i32, col: i32, row_stride: i32) -> ${S} {\n        let index = row * row_stride + col;\n        return x[index];\n      }\n\n      fn setValue(row: i32, col: i32, row_stride: i32, value: ${S}) {\n        let index = row * row_stride + col;\n        result[index] = value;\n      }\n      ${P.registerUniform(\"packedCols\", \"i32\").declareVariables($, v)}\n      ${P.mainStart(g)}\n        let gindex = i32(global_idx);\n        let lindex = i32(local_idx);\n        const wg = ${g};\n        let row = gindex / wg;\n        let cols = uniforms.packedCols;\n        let row_stride : i32 = uniforms.packedCols;\n\n        // find the rows max\n        ${T}\n        for (var col = lindex; col < cols; col += wg) {\n          let value = getValue(row, col, row_stride);\n          threadMax = max(threadMax, value);\n        }\n        if (lindex < cols) {\n          threadShared[lindex] = threadMax;\n        }\n        workgroupBarrier();\n\n        var reduceSize = min(cols, wg);\n        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\n          reduceSize = currSize + (reduceSize & 1);\n          if (lindex < currSize) {\n            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowMaxShared = ${S}(${x(\"threadShared[0]\", _)});\n        }\n        workgroupBarrier();\n\n        // find the rows sum\n        var threadSum = ${S}(0.0);\n        for (var col = lindex; col < cols; col += wg) {\n          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);\n          threadSum += subExp;\n        }\n        threadShared[lindex] = threadSum;\n        workgroupBarrier();\n\n        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {\n          if (lindex < currSize) {\n            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];\n          }\n          workgroupBarrier();\n        }\n        if (lindex == 0) {\n          rowSumShared = ${S}(${Fe(\"threadShared[0]\", _)});\n        }\n        workgroupBarrier();\n\n        // calculate final value for each element in the row\n        for (var col = lindex; col < cols; col += wg) {\n          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;\n          setValue(row, col, row_stride, value);\n        }\n      }`, k = e1.compute({\n            name: \"Softmax\",\n            shaderCache: {\n                hint: `${_};${g}`,\n                inputDependencies: [\n                    \"type\"\n                ]\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: m,\n                            dataType: l.dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: h\n                    },\n                    programUniforms: [\n                        {\n                            type: 6,\n                            data: y\n                        }\n                    ]\n                }),\n            getShaderSource: A\n        }, {\n            inputs: [\n                l\n            ],\n            outputs: [\n                d ? -1 : 0\n            ]\n        })[0];\n        d && e1.compute(Pe(k, p), {\n            inputs: [\n                k\n            ]\n        });\n    }, Ll = (e1, t)=>{\n        tg(e1.inputs), rg(e1, t);\n    }, Gl = (e1)=>re({\n            axis: e1.axis\n        });\n});\nvar Fl, ng, og, ig, ql, Kl = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    ae();\n    Fl = (e1)=>Array.from(e1.getBigInt64Array(), Number), ng = (e1)=>{\n        if (!e1 || e1.length !== 2) throw new Error(\"Tile requires 2 inputs.\");\n        if (e1[0].dataType !== 1 && e1[0].dataType !== 10 && e1[0].dataType !== 6 && e1[0].dataType !== 12) throw new Error(\"Tile only support float, float16, int32, and uint32 data types\");\n        if (e1[1].dataType !== 7) throw new Error(\"Tile `repeats` input should be of int64 data type\");\n        if (e1[1].dims.length !== 1) throw new Error(\"Tile `repeats` input should be 1-D\");\n        if (Fl(e1[1]).length !== e1[0].dims.length) throw new Error(\"Tile `repeats` input should have same number of elements as rank of input data tensor\");\n    }, og = (e1, t)=>{\n        let r = [];\n        for(let n = 0; n < e1.length; ++n)r.push(e1[n] * t[n]);\n        return r;\n    }, ig = (e1, t)=>{\n        let r = e1[0].dims, n = t ?? Fl(e1[1]), o = og(r, n), i = C.size(o), a = e1[0].dataType, d = E(\"input\", a, r.length), l = M(\"output\", a, o.length), p = (m)=>`\n      const inputShape = ${d.indices(...r)};\n      ${m.registerUniform(\"output_size\", \"u32\").declareVariables(d, l)}\n      ${m.mainStart()}\n      ${m.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\")}\n      let output_indices = ${l.offsetToIndices(\"global_idx\")};\n      var input_indices: ${d.type.indices};\n      for (var i = 0; i < ${r.length}; i++) {\n        let input_dim_i = ${d.indicesGet(\"uniforms.input_shape\", \"i\")};\n        let input_dim_value = ${l.indicesGet(\"output_indices\", \"i\")}  % input_dim_i;\n\n        ${d.indicesSet(\"input_indices\", \"i\", \"input_dim_value\")}\n      }\n      ${l.setByOffset(\"global_idx\", d.getByIndices(\"input_indices\"))}\n    }`;\n        return {\n            name: \"Tile\",\n            shaderCache: {\n                hint: `${n}`,\n                inputDependencies: [\n                    \"rank\"\n                ]\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: o,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(i / 64)\n                    },\n                    programUniforms: [\n                        {\n                            type: 12,\n                            data: i\n                        },\n                        ...N(e1[0].dims, o)\n                    ]\n                }),\n            getShaderSource: p\n        };\n    }, ql = (e1)=>{\n        ng(e1.inputs), e1.compute(ig(e1.inputs), {\n            inputs: [\n                0\n            ]\n        });\n    };\n});\nvar ag, sg, jl, Yl = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    ae();\n    ag = (e1, t, r, n, o)=>{\n        let i = M(\"output_data\", o, r.length, 4), a = E(\"a_data\", t[1].dataType, t[1].dims.length, 4), d = E(\"b_data\", t[2].dataType, t[2].dims.length, 4), l = E(\"c_data\", t[0].dataType, t[0].dims.length, 4), p, m = (u, h, _)=>`select(${h}, ${u}, ${_})`;\n        if (!n) p = i.setByOffset(\"global_idx\", m(a.getByOffset(\"global_idx\"), d.getByOffset(\"global_idx\"), l.getByOffset(\"global_idx\")));\n        else {\n            let u = (h, _, y = \"\")=>{\n                let g = `a_data[index_a${_}][component_a${_}]`, x = `b_data[index_b${_}][component_b${_}]`, $ = `bool(c_data[index_c${_}] & (0xffu << (component_c${_} * 8)))`;\n                return `\n            let output_indices${_} = ${i.offsetToIndices(`global_idx * 4u + ${_}u`)};\n            let offset_a${_} = ${a.broadcastedIndicesToOffset(`output_indices${_}`, i)};\n            let offset_b${_} = ${d.broadcastedIndicesToOffset(`output_indices${_}`, i)};\n            let offset_c${_} = ${l.broadcastedIndicesToOffset(`output_indices${_}`, i)};\n            let index_a${_} = offset_a${_} / 4u;\n            let index_b${_} = offset_b${_} / 4u;\n            let index_c${_} = offset_c${_} / 4u;\n            let component_a${_} = offset_a${_} % 4u;\n            let component_b${_} = offset_b${_} % 4u;\n            let component_c${_} = offset_c${_} % 4u;\n            ${h}[${_}] = ${y}(${m(g, x, $)});\n          `;\n            };\n            o === 9 ? p = `\n            var data = vec4<u32>(0);\n            ${u(\"data\", 0, \"u32\")}\n            ${u(\"data\", 1, \"u32\")}\n            ${u(\"data\", 2, \"u32\")}\n            ${u(\"data\", 3, \"u32\")}\n            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));` : p = `\n            ${u(\"output_data[global_idx]\", 0)}\n            ${u(\"output_data[global_idx]\", 1)}\n            ${u(\"output_data[global_idx]\", 2)}\n            ${u(\"output_data[global_idx]\", 3)}\n          `;\n        }\n        return `\n        ${e1.registerUniform(\"vec_size\", \"u32\").declareVariables(l, a, d, i)}\n        ${e1.mainStart()}\n        ${e1.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.vec_size\")}\n        ${p}\n      }`;\n    }, sg = (e1)=>{\n        let t = e1[1].dims, r = e1[2].dims, n = e1[0].dims, o = e1[1].dataType, i = !(C.areEqual(t, r) && C.areEqual(r, n)), a = t, d = C.size(t);\n        if (i) {\n            let p = tt.calcShape(tt.calcShape(t, r, !1), n, !1);\n            if (!p) throw new Error(\"Can't perform where op on the given tensors\");\n            a = p, d = C.size(a);\n        }\n        let l = Math.ceil(d / 4);\n        return {\n            name: \"Where\",\n            shaderCache: {\n                inputDependencies: [\n                    \"rank\",\n                    \"rank\",\n                    \"rank\"\n                ]\n            },\n            getShaderSource: (p)=>ag(p, e1, a, i, o),\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: a,\n                            dataType: o\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(d / 64 / 4)\n                    },\n                    programUniforms: [\n                        {\n                            type: 12,\n                            data: l\n                        },\n                        ...N(n, t, r, a)\n                    ]\n                })\n        };\n    }, jl = (e1)=>{\n        e1.compute(sg(e1.inputs));\n    };\n});\nvar Zl, Ql = U(()=>{\n    \"use strict\";\n    Ps();\n    Fr();\n    Ds();\n    Ms();\n    vu();\n    zu();\n    Bu();\n    Qu();\n    od();\n    sd();\n    ld();\n    hd();\n    yd();\n    wd();\n    xd();\n    Id();\n    kd();\n    zd();\n    Bd();\n    Ud();\n    qd();\n    Yd();\n    Qd();\n    Jd();\n    rl();\n    So();\n    ol();\n    vl();\n    Sl();\n    Il();\n    kl();\n    Gr();\n    Ol();\n    Bl();\n    Rl();\n    Wl();\n    Hl();\n    Io();\n    Kl();\n    dt();\n    Kr();\n    Yl();\n    Zl = new Map([\n        [\n            \"Abs\",\n            [\n                Rs\n            ]\n        ],\n        [\n            \"Acos\",\n            [\n                Us\n            ]\n        ],\n        [\n            \"Acosh\",\n            [\n                Ns\n            ]\n        ],\n        [\n            \"Add\",\n            [\n                $u\n            ]\n        ],\n        [\n            \"ArgMax\",\n            [\n                Es,\n                co\n            ]\n        ],\n        [\n            \"ArgMin\",\n            [\n                ks,\n                co\n            ]\n        ],\n        [\n            \"Asin\",\n            [\n                Vs\n            ]\n        ],\n        [\n            \"Asinh\",\n            [\n                Ws\n            ]\n        ],\n        [\n            \"Atan\",\n            [\n                Ls\n            ]\n        ],\n        [\n            \"Atanh\",\n            [\n                Gs\n            ]\n        ],\n        [\n            \"Attention\",\n            [\n                zs\n            ]\n        ],\n        [\n            \"AveragePool\",\n            [\n                pl,\n                cl\n            ]\n        ],\n        [\n            \"BatchNormalization\",\n            [\n                Os\n            ]\n        ],\n        [\n            \"BiasAdd\",\n            [\n                Bs\n            ]\n        ],\n        [\n            \"BiasSplitGelu\",\n            [\n                wu\n            ]\n        ],\n        [\n            \"Cast\",\n            [\n                Fs,\n                Hs\n            ]\n        ],\n        [\n            \"Ceil\",\n            [\n                Ks\n            ]\n        ],\n        [\n            \"Clip\",\n            [\n                qs\n            ]\n        ],\n        [\n            \"Concat\",\n            [\n                Ou,\n                Du\n            ]\n        ],\n        [\n            \"Conv\",\n            [\n                wo,\n                _o\n            ]\n        ],\n        [\n            \"ConvTranspose\",\n            [\n                nd,\n                td\n            ]\n        ],\n        [\n            \"Cos\",\n            [\n                js\n            ]\n        ],\n        [\n            \"Cosh\",\n            [\n                Ys\n            ]\n        ],\n        [\n            \"CumSum\",\n            [\n                id,\n                ad\n            ]\n        ],\n        [\n            \"DepthToSpace\",\n            [\n                ud,\n                dd\n            ]\n        ],\n        [\n            \"DequantizeLinear\",\n            [\n                $l,\n                xl\n            ]\n        ],\n        [\n            \"Div\",\n            [\n                xu\n            ]\n        ],\n        [\n            \"Einsum\",\n            [\n                md,\n                fd\n            ]\n        ],\n        [\n            \"Elu\",\n            [\n                Zs,\n                Xt\n            ]\n        ],\n        [\n            \"Equal\",\n            [\n                Su\n            ]\n        ],\n        [\n            \"Erf\",\n            [\n                Qs\n            ]\n        ],\n        [\n            \"Exp\",\n            [\n                Xs\n            ]\n        ],\n        [\n            \"Expand\",\n            [\n                bd\n            ]\n        ],\n        [\n            \"FastGelu\",\n            [\n                _d\n            ]\n        ],\n        [\n            \"Floor\",\n            [\n                Js\n            ]\n        ],\n        [\n            \"FusedConv\",\n            [\n                wo,\n                _o\n            ]\n        ],\n        [\n            \"Gather\",\n            [\n                $d,\n                vd\n            ]\n        ],\n        [\n            \"GatherElements\",\n            [\n                Pd,\n                Ed\n            ]\n        ],\n        [\n            \"GatherBlockQuantized\",\n            [\n                Cd,\n                Ad\n            ]\n        ],\n        [\n            \"GatherND\",\n            [\n                Sd,\n                Td\n            ]\n        ],\n        [\n            \"Gelu\",\n            [\n                eu\n            ]\n        ],\n        [\n            \"Gemm\",\n            [\n                Dd,\n                Od\n            ]\n        ],\n        [\n            \"GlobalAveragePool\",\n            [\n                hl,\n                fl\n            ]\n        ],\n        [\n            \"GlobalMaxPool\",\n            [\n                wl,\n                _l\n            ]\n        ],\n        [\n            \"Greater\",\n            [\n                Au\n            ]\n        ],\n        [\n            \"GreaterOrEqual\",\n            [\n                Eu\n            ]\n        ],\n        [\n            \"GridSample\",\n            [\n                Md,\n                Rd\n            ]\n        ],\n        [\n            \"GroupQueryAttention\",\n            [\n                Fd\n            ]\n        ],\n        [\n            \"HardSigmoid\",\n            [\n                uu,\n                su\n            ]\n        ],\n        [\n            \"InstanceNormalization\",\n            [\n                jd\n            ]\n        ],\n        [\n            \"LayerNormalization\",\n            [\n                Zd\n            ]\n        ],\n        [\n            \"LeakyRelu\",\n            [\n                tu,\n                Xt\n            ]\n        ],\n        [\n            \"Less\",\n            [\n                ku\n            ]\n        ],\n        [\n            \"LessOrEqual\",\n            [\n                Pu\n            ]\n        ],\n        [\n            \"Log\",\n            [\n                bu\n            ]\n        ],\n        [\n            \"MatMul\",\n            [\n                Xd\n            ]\n        ],\n        [\n            \"MatMulNBits\",\n            [\n                el,\n                tl\n            ]\n        ],\n        [\n            \"MaxPool\",\n            [\n                bl,\n                yl\n            ]\n        ],\n        [\n            \"Mul\",\n            [\n                Tu\n            ]\n        ],\n        [\n            \"MultiHeadAttention\",\n            [\n                Wd,\n                Vd\n            ]\n        ],\n        [\n            \"Neg\",\n            [\n                nu\n            ]\n        ],\n        [\n            \"Not\",\n            [\n                ru\n            ]\n        ],\n        [\n            \"Pad\",\n            [\n                nl\n            ]\n        ],\n        [\n            \"Pow\",\n            [\n                Iu\n            ]\n        ],\n        [\n            \"QuickGelu\",\n            [\n                yu,\n                Xt\n            ]\n        ],\n        [\n            \"Range\",\n            [\n                Tl\n            ]\n        ],\n        [\n            \"Reciprocal\",\n            [\n                ou\n            ]\n        ],\n        [\n            \"ReduceMin\",\n            [\n                xs\n            ]\n        ],\n        [\n            \"ReduceMean\",\n            [\n                ys\n            ]\n        ],\n        [\n            \"ReduceMax\",\n            [\n                $s\n            ]\n        ],\n        [\n            \"ReduceSum\",\n            [\n                Ts\n            ]\n        ],\n        [\n            \"ReduceProd\",\n            [\n                Ss\n            ]\n        ],\n        [\n            \"ReduceL1\",\n            [\n                _s\n            ]\n        ],\n        [\n            \"ReduceL2\",\n            [\n                ws\n            ]\n        ],\n        [\n            \"ReduceLogSum\",\n            [\n                Cs\n            ]\n        ],\n        [\n            \"ReduceLogSumExp\",\n            [\n                vs\n            ]\n        ],\n        [\n            \"ReduceSumSquare\",\n            [\n                Is\n            ]\n        ],\n        [\n            \"Relu\",\n            [\n                iu\n            ]\n        ],\n        [\n            \"Resize\",\n            [\n                Pl,\n                zl\n            ]\n        ],\n        [\n            \"RotaryEmbedding\",\n            [\n                Dl\n            ]\n        ],\n        [\n            \"ScatterND\",\n            [\n                Al,\n                Cl\n            ]\n        ],\n        [\n            \"Sigmoid\",\n            [\n                au\n            ]\n        ],\n        [\n            \"Sin\",\n            [\n                du\n            ]\n        ],\n        [\n            \"Sinh\",\n            [\n                lu\n            ]\n        ],\n        [\n            \"Slice\",\n            [\n                Nl,\n                Vl\n            ]\n        ],\n        [\n            \"SkipLayerNormalization\",\n            [\n                Ml\n            ]\n        ],\n        [\n            \"Split\",\n            [\n                Ld,\n                Gd\n            ]\n        ],\n        [\n            \"Sqrt\",\n            [\n                cu\n            ]\n        ],\n        [\n            \"Softmax\",\n            [\n                Ll,\n                Gl\n            ]\n        ],\n        [\n            \"Sub\",\n            [\n                Cu\n            ]\n        ],\n        [\n            \"Tan\",\n            [\n                pu\n            ]\n        ],\n        [\n            \"Tanh\",\n            [\n                fu\n            ]\n        ],\n        [\n            \"ThresholdedRelu\",\n            [\n                gu,\n                Xt\n            ]\n        ],\n        [\n            \"Tile\",\n            [\n                ql\n            ]\n        ],\n        [\n            \"Transpose\",\n            [\n                is,\n                as\n            ]\n        ],\n        [\n            \"Where\",\n            [\n                jl\n            ]\n        ]\n    ]);\n});\nvar nn, Xl = U(()=>{\n    \"use strict\";\n    We();\n    et();\n    ae();\n    nn = class {\n        constructor(t){\n            this.backend = t;\n            this.repo = new Map, this.attributesBound = !1;\n        }\n        getArtifact(t) {\n            return this.repo.get(t);\n        }\n        setArtifact(t, r) {\n            this.repo.set(t, r);\n        }\n        run(t, r, n, o, i) {\n            Ue(t.programInfo.name);\n            let a = this.backend.device, d = this.backend.getComputePassEncoder();\n            this.backend.writeTimestamp(this.backend.pendingDispatchNumber * 2);\n            let l = [];\n            for (let m of r)l.push({\n                binding: l.length,\n                resource: {\n                    buffer: m.buffer\n                }\n            });\n            for (let m of n)l.push({\n                binding: l.length,\n                resource: {\n                    buffer: m.buffer\n                }\n            });\n            i && l.push({\n                binding: l.length,\n                resource: i\n            });\n            let p = a.createBindGroup({\n                layout: t.computePipeline.getBindGroupLayout(0),\n                entries: l,\n                label: t.programInfo.name\n            });\n            if (this.backend.sessionStatus === \"capturing\") {\n                let m = {\n                    kernelId: this.backend.currentKernelId,\n                    computePipeline: t.computePipeline,\n                    bindGroup: p,\n                    dispatchGroup: o\n                };\n                this.backend.capturedCommandList.get(this.backend.currentSessionId).push(m);\n            }\n            d.setPipeline(t.computePipeline), d.setBindGroup(0, p), d.dispatchWorkgroups(...o), this.backend.writeTimestamp(this.backend.pendingDispatchNumber * 2 + 1), this.backend.pendingDispatchNumber++, (this.backend.pendingDispatchNumber >= this.backend.maxDispatchNumber || this.backend.queryType === \"at-passes\") && this.backend.endComputePass(), this.backend.pendingDispatchNumber >= this.backend.maxDispatchNumber && this.backend.flush(), De(t.programInfo.name);\n        }\n        dispose() {}\n        build(t, r) {\n            Ue(t.name);\n            let n = this.backend.device, o = [];\n            [\n                {\n                    feature: \"shader-f16\",\n                    extension: \"f16\"\n                },\n                {\n                    feature: \"subgroups\",\n                    extension: \"subgroups\"\n                },\n                {\n                    feature: \"subgroups-f16\",\n                    extension: \"subgroups_f16\"\n                }\n            ].forEach((u)=>{\n                n.features.has(u.feature) && o.push(`enable ${u.extension};`);\n            });\n            let a = ns(r, this.backend.device.limits), d = t.getShaderSource(a), l = `${o.join(`\n`)}\n${a.additionalImplementations}\n${d}`, p = n.createShaderModule({\n                code: l,\n                label: t.name\n            });\n            ue(\"verbose\", ()=>`[WebGPU] ${t.name} shader code: ${l}`);\n            let m = n.createComputePipeline({\n                compute: {\n                    module: p,\n                    entryPoint: \"main\"\n                },\n                layout: \"auto\",\n                label: t.name\n            });\n            return De(t.name), {\n                programInfo: t,\n                computePipeline: m,\n                uniformVariablesInfo: a.variablesInfo\n            };\n        }\n        normalizeDispatchGroupSize(t) {\n            let r = typeof t == \"number\" ? t : t.x, n = typeof t == \"number\" ? 1 : t.y || 1, o = typeof t == \"number\" ? 1 : t.z || 1, i = this.backend.device.limits.maxComputeWorkgroupsPerDimension;\n            if (r <= i && n <= i && o <= i) return [\n                r,\n                n,\n                o\n            ];\n            let a = r * n * o, d = Math.ceil(Math.sqrt(a));\n            if (d > i) {\n                if (d = Math.ceil(Math.cbrt(a)), d > i) throw new Error(\"Total dispatch size exceeds WebGPU maximum.\");\n                return [\n                    d,\n                    d,\n                    d\n                ];\n            } else return [\n                d,\n                d,\n                1\n            ];\n        }\n    };\n});\nvar ug, dg, Co, Ao, on, Jl = U(()=>{\n    \"use strict\";\n    We();\n    te();\n    et();\n    Jn();\n    Ja();\n    Ql();\n    Xl();\n    ug = (e1, t)=>{\n        if (t.length !== e1.length) throw new Error(`inputDependencies length ${t.length} is not equal to inputTensors length ${e1.length}.`);\n        let r = [];\n        for(let n = 0; n < e1.length; ++n){\n            let o = e1[n].dataType;\n            switch(t[n]){\n                case \"none\":\n                    {\n                        r.push(\"\");\n                        break;\n                    }\n                case \"type\":\n                    {\n                        r.push(`${o}`);\n                        break;\n                    }\n                case \"rank\":\n                    {\n                        let i = e1[n].dims.length;\n                        r.push(`${o};${i}`);\n                        break;\n                    }\n                case \"dims\":\n                    {\n                        let i = e1[n].dims.join(\",\");\n                        r.push(`${o};${i}`);\n                        break;\n                    }\n                default:\n                    throw new Error(`unsupported input dependency: ${t[n]}`);\n            }\n        }\n        return r.join(\"|\");\n    }, dg = (e1, t, r)=>{\n        let n = e1.name;\n        return e1.shaderCache?.hint && (n += \"[\" + e1.shaderCache.hint + \"]\"), n += \":\" + r + `:${ug(t, e1.shaderCache?.inputDependencies ?? new Array(t.length).fill(\"dims\"))}`, n;\n    }, Co = class {\n        constructor(t){\n            t && (this.architecture = t.architecture, this.vendor = t.vendor);\n        }\n        isArchitecture(t) {\n            return this.architecture === t;\n        }\n        isVendor(t) {\n            return this.vendor === t;\n        }\n    }, Ao = class {\n        constructor(t){\n            this.subgroupsSupported = t.features.has(\"subgroups\"), this.subgroupsF16Supported = t.features.has(\"subgroups\");\n            let r = t.limits;\n            !this.subgroupsSupported || !r.minSubgroupSize || !r.maxSubgroupSize ? this.subgroupSizeRange = void 0 : this.subgroupSizeRange = [\n                r.minSubgroupSize,\n                r.maxSubgroupSize\n            ];\n        }\n    }, on = class {\n        constructor(){\n            this.currentSessionId = null;\n            this.currentKernelId = null;\n            this.commandEncoder = null;\n            this.computePassEncoder = null;\n            this.maxDispatchNumber = 16;\n            this.pendingDispatchNumber = 0;\n            this.pendingKernels = [];\n            this.pendingQueries = new Map;\n            this.sessionStatus = \"default\";\n            this.capturedCommandList = new Map;\n            this.capturedPendingKernels = new Map;\n            this.sessionExternalDataMapping = new Map;\n        }\n        get currentKernelCustomData() {\n            if (this.currentKernelId === null) throw new Error(\"currentKernelCustomData(): currentKernelId is null. (should not happen)\");\n            let t = this.kernelCustomData.get(this.currentKernelId);\n            return t || (t = {}, this.kernelCustomData.set(this.currentKernelId, t)), t;\n        }\n        async initialize(t, r) {\n            this.env = t;\n            let n = [], o = {\n                requiredLimits: {\n                    maxComputeWorkgroupStorageSize: r.limits.maxComputeWorkgroupStorageSize,\n                    maxComputeWorkgroupsPerDimension: r.limits.maxComputeWorkgroupsPerDimension,\n                    maxStorageBufferBindingSize: r.limits.maxStorageBufferBindingSize,\n                    maxBufferSize: r.limits.maxBufferSize,\n                    maxComputeInvocationsPerWorkgroup: r.limits.maxComputeInvocationsPerWorkgroup,\n                    maxComputeWorkgroupSizeX: r.limits.maxComputeWorkgroupSizeX,\n                    maxComputeWorkgroupSizeY: r.limits.maxComputeWorkgroupSizeY,\n                    maxComputeWorkgroupSizeZ: r.limits.maxComputeWorkgroupSizeZ\n                },\n                requiredFeatures: n\n            }, i = (a)=>r.features.has(a) && n.push(a) && !0;\n            i(\"chromium-experimental-timestamp-query-inside-passes\") || i(\"timestamp-query\"), i(\"shader-f16\"), i(\"subgroups\") && i(\"subgroups-f16\"), this.device = await r.requestDevice(o), this.deviceInfo = new Ao(this.device), this.adapterInfo = new Co(r.info || await r.requestAdapterInfo()), this.gpuDataManager = Xa(this), this.programManager = new nn(this), this.kernels = new Map, this.kernelPersistentData = new Map, this.kernelCustomData = new Map, Rr(t.logLevel, !!t.debug), this.device.onuncapturederror = (a)=>{\n                a.error instanceof GPUValidationError && console.error(`An uncaught WebGPU validation error was raised: ${a.error.message}`);\n            }, Object.defineProperty(this.env.webgpu, \"device\", {\n                value: this.device,\n                writable: !1,\n                enumerable: !0,\n                configurable: !1\n            }), Object.defineProperty(this.env.webgpu, \"adapter\", {\n                value: r,\n                writable: !1,\n                enumerable: !0,\n                configurable: !1\n            }), this.setQueryType();\n        }\n        dispose() {\n            typeof this.querySet < \"u\" && this.querySet.destroy(), this.gpuDataManager.dispose();\n        }\n        getCommandEncoder() {\n            return this.commandEncoder || (this.commandEncoder = this.device.createCommandEncoder()), this.commandEncoder;\n        }\n        getComputePassEncoder() {\n            if (!this.computePassEncoder) {\n                let t = this.getCommandEncoder(), r = {};\n                this.queryType === \"at-passes\" && (r.timestampWrites = {\n                    querySet: this.querySet,\n                    beginningOfPassWriteIndex: this.pendingDispatchNumber * 2,\n                    endOfPassWriteIndex: this.pendingDispatchNumber * 2 + 1\n                }), this.computePassEncoder = t.beginComputePass(r);\n            }\n            return this.computePassEncoder;\n        }\n        endComputePass() {\n            this.computePassEncoder && (this.computePassEncoder.end(), this.computePassEncoder = null);\n        }\n        flush() {\n            if (!this.commandEncoder) return;\n            Ue(), this.endComputePass();\n            let t;\n            this.queryType !== \"none\" && (this.commandEncoder.resolveQuerySet(this.querySet, 0, this.pendingDispatchNumber * 2, this.queryResolveBuffer, 0), t = this.device.createBuffer({\n                size: this.pendingDispatchNumber * 2 * 8,\n                usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST\n            }), this.pendingQueries.set(t, this.pendingKernels), this.pendingKernels = [], this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer, 0, t, 0, this.pendingDispatchNumber * 2 * 8)), this.device.queue.submit([\n                this.commandEncoder.finish()\n            ]), this.gpuDataManager.refreshPendingBuffers(), this.commandEncoder = null, this.pendingDispatchNumber = 0, this.queryType !== \"none\" && t.mapAsync(GPUMapMode.READ).then(()=>{\n                let r = new BigUint64Array(t.getMappedRange()), n = this.pendingQueries.get(t);\n                for(let o = 0; o < r.length / 2; o++){\n                    let i = n[o], a = i.kernelId, d = this.kernels.get(a), l = d.kernelType, p = d.kernelName, m = i.programName, u = i.inputTensorViews, h = i.outputTensorViews, _ = r[o * 2], y = r[o * 2 + 1];\n                    typeof this.queryTimeBase > \"u\" && (this.queryTimeBase = _);\n                    let g = Number(_ - this.queryTimeBase), x = Number(y - this.queryTimeBase);\n                    if (!Number.isSafeInteger(g) || !Number.isSafeInteger(x)) throw new RangeError(\"incorrect timestamp range\");\n                    if (this.env.webgpu.profiling?.ondata) this.env.webgpu.profiling.ondata({\n                        version: 1,\n                        inputsMetadata: u.map(($)=>({\n                                dims: $.dims,\n                                dataType: bt($.dataType)\n                            })),\n                        outputsMetadata: h.map(($)=>({\n                                dims: $.dims,\n                                dataType: bt($.dataType)\n                            })),\n                        kernelId: a,\n                        kernelType: l,\n                        kernelName: p,\n                        programName: m,\n                        startTime: g,\n                        endTime: x\n                    });\n                    else {\n                        let $ = \"\";\n                        u.forEach((S, T)=>{\n                            $ += `input[${T}]: [${S.dims}] | ${bt(S.dataType)}, `;\n                        });\n                        let v = \"\";\n                        h.forEach((S, T)=>{\n                            v += `output[${T}]: [${S.dims}] | ${bt(S.dataType)}, `;\n                        }), console.log(`[profiling] kernel \"${a}|${l}|${p}|${m}\" ${$}${v}execution time: ${x - g} ns`);\n                    }\n                    wr(\"GPU\", `${m}::${_}::${y}`);\n                }\n                t.unmap(), this.pendingQueries.delete(t);\n            }), De();\n        }\n        run(t, r, n, o, i, a) {\n            Ue(t.name);\n            let d = [];\n            for(let S = 0; S < r.length; ++S){\n                let T = r[S].data;\n                if (T === 0) continue;\n                let A = this.gpuDataManager.get(T);\n                if (!A) throw new Error(`no GPU data for input: ${T}`);\n                d.push(A);\n            }\n            let { outputs: l, dispatchGroup: p, programUniforms: m } = t.getRunData(r), u = n.length === 0 ? l.map((S, T)=>T) : n;\n            if (u.length !== l.length) throw new Error(`Output size ${u.length} must be equal to ${l.length}.`);\n            let h = [], _ = [];\n            for(let S = 0; S < l.length; ++S){\n                if (!Number.isInteger(u[S]) || u[S] < -3 || u[S] >= a) throw new Error(`Invalid output index: ${u[S]}`);\n                if (u[S] === -3) continue;\n                let T = u[S] === -1, A = u[S] === -2, k = T || A ? i(l[S].dataType, l[S].dims) : o(u[S], l[S].dataType, l[S].dims);\n                if (h.push(k), k.data === 0) continue;\n                let P = this.gpuDataManager.get(k.data);\n                if (!P) throw new Error(`no GPU data for output: ${k.data}`);\n                if (T && this.temporaryData.push(P), A) {\n                    let D = this.kernelPersistentData.get(this.currentKernelId);\n                    D || (D = [], this.kernelPersistentData.set(this.currentKernelId, D)), D.push(P);\n                }\n                _.push(P);\n            }\n            if (d.length !== r.length || _.length !== h.length) {\n                if (_.length === 0) return De(t.name), h;\n                throw new Error(`Program ${t.name} has zero-sized tensor(s) in inputs or outputs. This is not supported now.`);\n            }\n            let y;\n            if (m) {\n                let S = 0, T = [];\n                m.forEach((D)=>{\n                    let R = typeof D.data == \"number\" ? [\n                        D.data\n                    ] : D.data;\n                    if (R.length === 0) return;\n                    let G = D.type === 10 ? 2 : 4, K, j;\n                    D.type === 10 ? (j = R.length > 4 ? 16 : R.length > 2 ? 8 : R.length * G, K = R.length > 4 ? 16 : G * R.length) : (j = R.length <= 2 ? R.length * G : 16, K = 16), S = Math.ceil(S / j) * j, T.push(S);\n                    let V = D.type === 10 ? 8 : 4;\n                    S += R.length > 4 ? Math.ceil(R.length / V) * K : R.length * G;\n                });\n                let A = 16;\n                S = Math.ceil(S / A) * A;\n                let k = new ArrayBuffer(S);\n                m.forEach((D, R)=>{\n                    let G = T[R], K = typeof D.data == \"number\" ? [\n                        D.data\n                    ] : D.data;\n                    if (D.type === 6) new Int32Array(k, G, K.length).set(K);\n                    else if (D.type === 12) new Uint32Array(k, G, K.length).set(K);\n                    else if (D.type === 10) new Uint16Array(k, G, K.length).set(K);\n                    else if (D.type === 1) new Float32Array(k, G, K.length).set(K);\n                    else throw new Error(`Unsupported uniform type: ${bt(D.type)}`);\n                });\n                let P = this.gpuDataManager.create(S, GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM);\n                this.device.queue.writeBuffer(P.buffer, 0, k, 0, S), this.gpuDataManager.release(P.id), y = {\n                    offset: 0,\n                    size: S,\n                    buffer: P.buffer\n                };\n            }\n            let g = this.programManager.normalizeDispatchGroupSize(p), x = g[1] === 1 && g[2] === 1, $ = dg(t, r, x), v = this.programManager.getArtifact($);\n            if (v || (v = this.programManager.build(t, g), this.programManager.setArtifact($, v), ue(\"info\", ()=>`[artifact] key: ${$}, programName: ${t.name}`)), m && v.uniformVariablesInfo) {\n                if (m.length !== v.uniformVariablesInfo.length) throw new Error(`Uniform variables count mismatch: expect ${v.uniformVariablesInfo.length}, got ${m.length} in program \"${v.programInfo.name}\".`);\n                for(let S = 0; S < m.length; S++){\n                    let T = m[S], A = T.type, k = typeof T.data == \"number\" ? 1 : T.data.length, [P, D] = v.uniformVariablesInfo[S];\n                    if (A !== P || k !== D) throw new Error(`Uniform variable ${S} mismatch: expect type ${P} with size ${D}, got type ${A} with size ${k} in program \"${v.programInfo.name}\".`);\n                }\n            }\n            if (ue(\"info\", ()=>`[ProgramManager] run \"${t.name}\" (key=${$}) with ${g[0]}x${g[1]}x${g[2]}`), this.queryType !== \"none\" || this.sessionStatus === \"capturing\") {\n                let S = {\n                    kernelId: this.currentKernelId,\n                    programName: v.programInfo.name,\n                    inputTensorViews: r,\n                    outputTensorViews: h\n                };\n                this.pendingKernels.push(S), this.sessionStatus === \"capturing\" && this.capturedPendingKernels.get(this.currentSessionId).push(S);\n            }\n            return this.programManager.run(v, d, _, g, y), De(t.name), h;\n        }\n        upload(t, r) {\n            this.gpuDataManager.upload(t, r);\n        }\n        memcpy(t, r) {\n            this.gpuDataManager.memcpy(t, r);\n        }\n        async download(t, r) {\n            await this.gpuDataManager.download(t, r);\n        }\n        alloc(t) {\n            return this.gpuDataManager.create(t).id;\n        }\n        free(t) {\n            return this.gpuDataManager.release(t);\n        }\n        createKernel(t, r, n, o) {\n            let i = Zl.get(t);\n            if (!i) throw new Error(`kernel not implemented: ${t}`);\n            let a = {\n                kernelType: t,\n                kernelName: o,\n                kernelEntry: i[0],\n                attributes: [\n                    i[1],\n                    n\n                ]\n            };\n            this.kernels.set(r, a);\n        }\n        releaseKernel(t) {\n            let r = this.kernelPersistentData.get(t);\n            if (r) {\n                for (let n of r)this.gpuDataManager.release(n.id);\n                this.kernelPersistentData.delete(t);\n            }\n            this.kernelCustomData.delete(t), this.kernels.delete(t);\n        }\n        computeKernel(t, r, n) {\n            let o = this.kernels.get(t);\n            if (!o) throw new Error(`kernel not created: ${t}`);\n            let i = o.kernelType, a = o.kernelName, d = o.kernelEntry, l = o.attributes;\n            if (this.currentKernelId !== null) throw new Error(`kernel \"[${i}] ${a}\" is not allowed to be called recursively`);\n            this.currentKernelId = t, l[0] && (l[1] = l[0](l[1]), l[0] = void 0), ue(\"info\", ()=>`[WebGPU] Start to run kernel \"[${i}] ${a}\"...`);\n            let p = this.env.debug;\n            this.temporaryData = [];\n            try {\n                return p && this.device.pushErrorScope(\"validation\"), d(r, l[1]), 0;\n            } catch (m) {\n                return n.push(Promise.resolve(`[WebGPU] Kernel \"[${i}] ${a}\" failed. ${m}`)), 1;\n            } finally{\n                p && n.push(this.device.popErrorScope().then((m)=>m ? `GPU validation error for kernel \"[${i}] ${a}\": ${m.message}` : null));\n                for (let m of this.temporaryData)this.gpuDataManager.release(m.id);\n                this.temporaryData = [], this.currentKernelId = null;\n            }\n        }\n        registerBuffer(t, r, n, o) {\n            let i = this.sessionExternalDataMapping.get(t);\n            i || (i = new Map, this.sessionExternalDataMapping.set(t, i));\n            let a = i.get(r), d = this.gpuDataManager.registerExternalBuffer(n, o, a);\n            return i.set(r, [\n                d,\n                n\n            ]), d;\n        }\n        unregisterBuffers(t) {\n            let r = this.sessionExternalDataMapping.get(t);\n            r && (r.forEach((n)=>this.gpuDataManager.unregisterExternalBuffer(n[0])), this.sessionExternalDataMapping.delete(t));\n        }\n        getBuffer(t) {\n            let r = this.gpuDataManager.get(t);\n            if (!r) throw new Error(`no GPU data for buffer: ${t}`);\n            return r.buffer;\n        }\n        createDownloader(t, r, n) {\n            return async ()=>{\n                let o = await no(this, t, r);\n                return Ur(o.buffer, n);\n            };\n        }\n        writeTimestamp(t) {\n            this.queryType === \"inside-passes\" && this.computePassEncoder.writeTimestamp(this.querySet, t);\n        }\n        setQueryType() {\n            this.queryType = \"none\", (this.env.webgpu.profiling?.mode === \"default\" || (typeof this.env.trace > \"u\" ? this.env.wasm.trace : this.env.trace)) && (this.device.features.has(\"chromium-experimental-timestamp-query-inside-passes\") ? this.queryType = \"inside-passes\" : this.device.features.has(\"timestamp-query\") && (this.queryType = \"at-passes\"), this.queryType !== \"none\" && typeof this.querySet > \"u\" && (this.querySet = this.device.createQuerySet({\n                type: \"timestamp\",\n                count: this.maxDispatchNumber * 2\n            }), this.queryResolveBuffer = this.device.createBuffer({\n                size: this.maxDispatchNumber * 2 * 8,\n                usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.QUERY_RESOLVE\n            })));\n        }\n        captureBegin() {\n            ue(\"info\", \"captureBegin\"), this.capturedCommandList.get(this.currentSessionId) || this.capturedCommandList.set(this.currentSessionId, []), this.capturedPendingKernels.get(this.currentSessionId) || this.capturedPendingKernels.set(this.currentSessionId, []), this.flush(), this.sessionStatus = \"capturing\";\n        }\n        captureEnd() {\n            ue(\"info\", \"captureEnd\"), this.flush(), this.sessionStatus = \"default\";\n        }\n        replay() {\n            ue(\"info\", \"replay\"), this.sessionStatus = \"replaying\";\n            let t = this.capturedCommandList.get(this.currentSessionId), r = this.capturedPendingKernels.get(this.currentSessionId), n = t.length;\n            this.pendingKernels = [];\n            for(let o = 0; o < n; o++){\n                let i = this.getComputePassEncoder(), a = t[o];\n                this.writeTimestamp(this.pendingDispatchNumber * 2), i.setPipeline(a.computePipeline), i.setBindGroup(0, a.bindGroup), i.dispatchWorkgroups(...a.dispatchGroup), this.writeTimestamp(this.pendingDispatchNumber * 2 + 1), this.pendingDispatchNumber++, this.queryType !== \"none\" && this.pendingKernels.push(r[o]), (this.pendingDispatchNumber >= this.maxDispatchNumber || this.queryType === \"at-passes\") && this.endComputePass(), this.pendingDispatchNumber >= this.maxDispatchNumber && this.flush();\n            }\n            this.flush(), this.sessionStatus = \"default\";\n        }\n        onCreateSession() {\n            this.gpuDataManager.onCreateSession();\n        }\n        onReleaseSession(t) {\n            this.unregisterBuffers(t), this.capturedCommandList.has(t) && this.capturedCommandList.delete(t), this.capturedPendingKernels.has(t) && this.capturedPendingKernels.delete(t), this.gpuDataManager.onReleaseSession(t);\n        }\n        onRunStart(t) {\n            this.currentSessionId = t, this.setQueryType();\n        }\n    };\n});\nvar lg, ec, cg, tc, an, sn, ko, rc, nc = U(()=>{\n    \"use strict\";\n    et();\n    lg = 1, ec = ()=>lg++, cg = new Map([\n        [\n            \"float32\",\n            32\n        ],\n        [\n            \"float16\",\n            16\n        ],\n        [\n            \"int32\",\n            32\n        ],\n        [\n            \"uint32\",\n            32\n        ],\n        [\n            \"int64\",\n            64\n        ],\n        [\n            \"uint64\",\n            64\n        ],\n        [\n            \"int8\",\n            8\n        ],\n        [\n            \"uint8\",\n            8\n        ],\n        [\n            \"int4\",\n            4\n        ],\n        [\n            \"uint4\",\n            4\n        ]\n    ]), tc = (e1, t)=>{\n        let r = cg.get(e1);\n        if (!r) throw new Error(\"Unsupported data type.\");\n        return t.length > 0 ? Math.ceil(t.reduce((n, o)=>n * o) * r / 8) : 0;\n    }, an = class {\n        constructor(t){\n            this.sessionId = t.sessionId, this.mlContext = t.context, this.mlTensor = t.tensor, this.dataType = t.dataType, this.tensorShape = t.shape;\n        }\n        get tensor() {\n            return this.mlTensor;\n        }\n        get type() {\n            return this.dataType;\n        }\n        get shape() {\n            return this.tensorShape;\n        }\n        get byteLength() {\n            return tc(this.dataType, this.tensorShape);\n        }\n        destroy() {\n            ue(\"verbose\", ()=>\"[WebNN] TensorWrapper.destroy\"), this.mlTensor.destroy();\n        }\n        write(t) {\n            this.mlContext.writeTensor(this.mlTensor, t);\n        }\n        async read(t) {\n            return t ? this.mlContext.readTensor(this.mlTensor, t) : this.mlContext.readTensor(this.mlTensor);\n        }\n        canReuseTensor(t, r, n) {\n            return this.mlContext === t && this.dataType === r && this.tensorShape.length === n.length && this.tensorShape.every((o, i)=>o === n[i]);\n        }\n    }, sn = class {\n        constructor(t, r){\n            this.tensorManager = t;\n            this.wrapper = r;\n        }\n        get tensorWrapper() {\n            return this.wrapper;\n        }\n        releaseTensor() {\n            this.tensorWrapper && (this.tensorManager.releaseTensor(this.tensorWrapper), this.wrapper = void 0);\n        }\n        async ensureTensor(t, r, n, o) {\n            if (this.wrapper) {\n                if (this.wrapper.canReuseTensor(t, r, n)) return this.wrapper.tensor;\n                if (o) {\n                    if (this.wrapper.byteLength !== tc(r, n)) throw new Error(\"Unable to copy data to tensor with different size.\");\n                    this.activeUpload = new Uint8Array(await this.wrapper.read());\n                }\n                this.tensorManager.releaseTensor(this.wrapper);\n            }\n            let i = typeof MLTensorUsage > \"u\" ? void 0 : MLTensorUsage.READ | MLTensorUsage.WRITE;\n            return this.wrapper = await this.tensorManager.getCachedTensor(r, n, i, !0, !0), o && this.activeUpload && (this.wrapper.write(this.activeUpload), this.activeUpload = void 0), this.wrapper.tensor;\n        }\n        upload(t) {\n            if (this.wrapper) if (t.byteLength === this.wrapper.byteLength) {\n                this.wrapper.write(t);\n                return;\n            } else ue(\"verbose\", ()=>\"Data size does not match tensor size. Releasing tensor.\"), this.releaseTensor();\n            this.activeUpload ? this.activeUpload.set(t) : this.activeUpload = new Uint8Array(t);\n        }\n        async download(t) {\n            if (this.activeUpload) if (t) {\n                t instanceof ArrayBuffer ? new Uint8Array(t).set(this.activeUpload) : new Uint8Array(t.buffer, t.byteOffset, t.byteLength).set(this.activeUpload);\n                return;\n            } else return this.activeUpload.buffer;\n            if (!this.wrapper) throw new Error(\"Tensor has not been created.\");\n            return t ? this.wrapper.read(t) : this.wrapper.read();\n        }\n    }, ko = class {\n        constructor(t){\n            this.backend = t;\n            this.tensorTrackersById = new Map;\n            this.freeTensors = [];\n            this.externalTensors = new Set;\n        }\n        reserveTensorId() {\n            let t = ec();\n            return this.tensorTrackersById.set(t, new sn(this)), t;\n        }\n        releaseTensorId(t) {\n            let r = this.tensorTrackersById.get(t);\n            r && (this.tensorTrackersById.delete(t), r.tensorWrapper && this.releaseTensor(r.tensorWrapper));\n        }\n        async ensureTensor(t, r, n, o) {\n            ue(\"verbose\", ()=>`[WebNN] TensorManager.ensureTensor {tensorId: ${t}, dataType: ${r}, shape: ${n}, copyOld: ${o}}`);\n            let i = this.tensorTrackersById.get(t);\n            if (!i) throw new Error(\"Tensor not found.\");\n            return i.ensureTensor(this.backend.currentContext, r, n, o);\n        }\n        upload(t, r) {\n            let n = this.tensorTrackersById.get(t);\n            if (!n) throw new Error(\"Tensor not found.\");\n            n.upload(r);\n        }\n        async download(t, r) {\n            ue(\"verbose\", ()=>`[WebNN] TensorManager.download {tensorId: ${t}, dstBuffer: ${r?.byteLength}}`);\n            let n = this.tensorTrackersById.get(t);\n            if (!n) throw new Error(\"Tensor not found.\");\n            return n.download(r);\n        }\n        releaseTensorsForSession(t) {\n            for (let r of this.freeTensors)r.sessionId === t && r.destroy();\n            this.freeTensors = this.freeTensors.filter((r)=>r.sessionId !== t);\n        }\n        registerTensor(t, r, n, o) {\n            let i = ec(), a = new an({\n                sessionId: this.backend.currentSessionId,\n                context: t,\n                tensor: r,\n                dataType: n,\n                shape: o\n            });\n            return this.tensorTrackersById.set(i, new sn(this, a)), this.externalTensors.add(a), i;\n        }\n        async getCachedTensor(t, r, n, o, i) {\n            let a = this.backend.currentSessionId, d = this.backend.currentContext;\n            for (let [p, m] of this.freeTensors.entries())if (m.canReuseTensor(d, t, r)) {\n                ue(\"verbose\", ()=>`[WebNN] Reusing tensor {dataType: ${t}, shape: ${r}}`);\n                let u = this.freeTensors.splice(p, 1)[0];\n                return u.sessionId = a, u;\n            }\n            ue(\"verbose\", ()=>`[WebNN] MLContext.createTensor {dataType: ${t}, shape: ${r}}`);\n            let l = await d.createTensor({\n                dataType: t,\n                shape: r,\n                dimensions: r,\n                usage: n,\n                writable: o,\n                readable: i\n            });\n            return new an({\n                sessionId: a,\n                context: d,\n                tensor: l,\n                dataType: t,\n                shape: r\n            });\n        }\n        releaseTensor(t) {\n            this.externalTensors.has(t) && this.externalTensors.delete(t), this.freeTensors.push(t);\n        }\n    }, rc = (...e1)=>new ko(...e1);\n});\nvar oc, pg, un, ic = U(()=>{\n    \"use strict\";\n    te();\n    gt();\n    Jn();\n    nc();\n    et();\n    oc = new Map([\n        [\n            1,\n            \"float32\"\n        ],\n        [\n            10,\n            \"float16\"\n        ],\n        [\n            6,\n            \"int32\"\n        ],\n        [\n            12,\n            \"uint32\"\n        ],\n        [\n            7,\n            \"int64\"\n        ],\n        [\n            13,\n            \"uint64\"\n        ],\n        [\n            22,\n            \"int4\"\n        ],\n        [\n            21,\n            \"uint4\"\n        ],\n        [\n            3,\n            \"int8\"\n        ],\n        [\n            2,\n            \"uint8\"\n        ],\n        [\n            9,\n            \"uint8\"\n        ]\n    ]), pg = (e1, t)=>{\n        if (e1 === t) return !0;\n        if (e1 === void 0 || t === void 0) return !1;\n        let r = Object.keys(e1).sort(), n = Object.keys(t).sort();\n        return r.length === n.length && r.every((o, i)=>o === n[i] && e1[o] === t[o]);\n    }, un = class {\n        constructor(t){\n            this.tensorManager = rc(this);\n            this.mlContextBySessionId = new Map;\n            this.sessionIdsByMLContext = new Map;\n            this.mlContextCache = [];\n            Rr(t.logLevel, !!t.debug);\n        }\n        get currentSessionId() {\n            if (this.activeSessionId === void 0) throw new Error(\"No active session\");\n            return this.activeSessionId;\n        }\n        onRunStart(t) {\n            this.activeSessionId = t;\n        }\n        async createMLContext(t) {\n            if (t instanceof GPUDevice) {\n                let n = this.mlContextCache.findIndex((o)=>o.gpuDevice === t);\n                if (n !== -1) return this.mlContextCache[n].mlContext;\n                {\n                    let o = await navigator.ml.createContext(t);\n                    return this.mlContextCache.push({\n                        gpuDevice: t,\n                        mlContext: o\n                    }), o;\n                }\n            } else if (t === void 0) {\n                let n = this.mlContextCache.findIndex((o)=>o.options === void 0 && o.gpuDevice === void 0);\n                if (n !== -1) return this.mlContextCache[n].mlContext;\n                {\n                    let o = await navigator.ml.createContext();\n                    return this.mlContextCache.push({\n                        mlContext: o\n                    }), o;\n                }\n            }\n            let r = this.mlContextCache.findIndex((n)=>pg(n.options, t));\n            if (r !== -1) return this.mlContextCache[r].mlContext;\n            {\n                let n = await navigator.ml.createContext(t);\n                return this.mlContextCache.push({\n                    options: t,\n                    mlContext: n\n                }), n;\n            }\n        }\n        get currentContext() {\n            let t = this.getMLContext(this.currentSessionId);\n            if (!t) throw new Error(`No MLContext found for session ${this.currentSessionId}`);\n            return t;\n        }\n        registerMLContext(t, r) {\n            this.mlContextBySessionId.set(t, r);\n            let n = this.sessionIdsByMLContext.get(r);\n            n || (n = new Set, this.sessionIdsByMLContext.set(r, n)), n.add(t);\n        }\n        onReleaseSession(t) {\n            let r = this.mlContextBySessionId.get(t);\n            if (!r) return;\n            this.tensorManager.releaseTensorsForSession(t), this.mlContextBySessionId.delete(t);\n            let n = this.sessionIdsByMLContext.get(r);\n            if (n.delete(t), n.size === 0) {\n                this.sessionIdsByMLContext.delete(r);\n                let o = this.mlContextCache.findIndex((i)=>i.mlContext === r);\n                o !== -1 && this.mlContextCache.splice(o, 1);\n            }\n        }\n        getMLContext(t) {\n            return this.mlContextBySessionId.get(t);\n        }\n        reserveTensorId() {\n            return this.tensorManager.reserveTensorId();\n        }\n        releaseTensorId(t) {\n            ue(\"verbose\", ()=>`[WebNN] releaseTensorId {tensorId: ${t}}`), this.tensorManager.releaseTensorId(t);\n        }\n        async ensureTensor(t, r, n, o) {\n            let i = oc.get(r);\n            if (!i) throw new Error(`Unsupported ONNX data type: ${r}`);\n            return this.tensorManager.ensureTensor(t, i, n, o);\n        }\n        uploadTensor(t, r) {\n            if (!Ie().shouldTransferToMLTensor) throw new Error(\"Trying to upload to a MLTensor while shouldTransferToMLTensor is false\");\n            ue(\"verbose\", ()=>`[WebNN] uploadTensor {tensorId: ${t}, data: ${r.byteLength}}`), this.tensorManager.upload(t, r);\n        }\n        async downloadTensor(t, r) {\n            return this.tensorManager.download(t, r);\n        }\n        createMLTensorDownloader(t, r) {\n            return async ()=>{\n                let n = await this.tensorManager.download(t);\n                return Ur(n, r);\n            };\n        }\n        registerMLTensor(t, r, n) {\n            let o = oc.get(r);\n            if (!o) throw new Error(`Unsupported ONNX data type: ${r}`);\n            let i = this.tensorManager.registerTensor(this.currentContext, t, o, n);\n            return ue(\"verbose\", ()=>`[WebNN] registerMLTensor {tensor: ${t}, dataType: ${o}, dimensions: ${n}} -> {tensorId: ${i}}`), i;\n        }\n        registerMLConstant(t, r, n, o, i, a) {\n            if (!a) throw new Error(\"External mounted files are not available.\");\n            let d = t;\n            t.startsWith(\"./\") && (d = t.substring(2));\n            let l = a.get(d);\n            if (!l) throw new Error(`File with name ${d} not found in preloaded files.`);\n            if (r + n > l.byteLength) throw new Error(\"Out of bounds: data offset and length exceed the external file data size.\");\n            let p = l.slice(r, r + n).buffer, m;\n            switch(i.dataType){\n                case \"float32\":\n                    m = new Float32Array(p);\n                    break;\n                case \"float16\":\n                    m = new Uint16Array(p);\n                    break;\n                case \"int32\":\n                    m = new Int32Array(p);\n                    break;\n                case \"uint32\":\n                    m = new Uint32Array(p);\n                    break;\n                case \"int64\":\n                    m = new BigInt64Array(p);\n                    break;\n                case \"uint64\":\n                    m = new BigUint64Array(p);\n                    break;\n                case \"int8\":\n                    m = new Int8Array(p);\n                    break;\n                case \"int4\":\n                case \"uint4\":\n                case \"uint8\":\n                    m = new Uint8Array(p);\n                    break;\n                default:\n                    throw new Error(`Unsupported data type: ${i.dataType} in creating WebNN Constant from external data.`);\n            }\n            return ue(\"verbose\", ()=>`[WebNN] registerMLConstant {dataType: ${i.dataType}, shape: ${i.shape}}}`), o.constant(i, m);\n        }\n        flush() {}\n    };\n});\nvar ac = {};\nFt(ac, {\n    init: ()=>mg\n});\nvar rr, Eo, mg, sc = U(()=>{\n    \"use strict\";\n    te();\n    Jl();\n    et();\n    oe();\n    ic();\n    rr = class e1 {\n        constructor(t, r, n, o){\n            this.module = t;\n            this.dataType = r;\n            this.data = n;\n            this.dims = o;\n        }\n        getFloat32Array() {\n            if (this.dataType !== 1) throw new Error(\"Invalid data type\");\n            let t = C.size(this.dims);\n            return t === 0 ? new Float32Array : new Float32Array(this.module.HEAP8.buffer, this.data, t);\n        }\n        getBigInt64Array() {\n            if (this.dataType !== 7) throw new Error(\"Invalid data type\");\n            let t = C.size(this.dims);\n            return t === 0 ? new BigInt64Array : new BigInt64Array(this.module.HEAP8.buffer, this.data, t);\n        }\n        getInt32Array() {\n            if (this.dataType !== 6) throw new Error(\"Invalid data type\");\n            let t = C.size(this.dims);\n            return t === 0 ? new Int32Array : new Int32Array(this.module.HEAP8.buffer, this.data, t);\n        }\n        getUint16Array() {\n            if (this.dataType !== 10 && this.dataType !== 4) throw new Error(\"Invalid data type\");\n            let t = C.size(this.dims);\n            return t === 0 ? new Uint16Array : new Uint16Array(this.module.HEAP8.buffer, this.data, t);\n        }\n        reshape(t) {\n            if (C.size(t) !== C.size(this.dims)) throw new Error(\"Invalid new shape\");\n            return new e1(this.module, this.dataType, this.data, t);\n        }\n    }, Eo = class {\n        constructor(t, r, n){\n            this.module = t;\n            this.backend = r;\n            this.customDataOffset = 0;\n            this.customDataSize = 0;\n            this.adapterInfo = r.adapterInfo, this.deviceInfo = r.deviceInfo;\n            let o = t.PTR_SIZE, i = n / t.PTR_SIZE, a = o === 4 ? \"i32\" : \"i64\";\n            this.opKernelContext = Number(t.getValue(o * i++, a));\n            let d = Number(t.getValue(o * i++, a));\n            this.outputCount = Number(t.getValue(o * i++, a)), this.customDataOffset = Number(t.getValue(o * i++, \"*\")), this.customDataSize = Number(t.getValue(o * i++, a));\n            let l = [];\n            for(let p = 0; p < d; p++){\n                let m = Number(t.getValue(o * i++, a)), u = Number(t.getValue(o * i++, \"*\")), h = Number(t.getValue(o * i++, a)), _ = [];\n                for(let y = 0; y < h; y++)_.push(Number(t.getValue(o * i++, a)));\n                l.push(new rr(t, m, u, _));\n            }\n            this.inputs = l;\n        }\n        get kernelCustomData() {\n            return this.backend.currentKernelCustomData;\n        }\n        get customDataBuffer() {\n            return this.module.HEAPU8.subarray(this.customDataOffset, this.customDataOffset + this.customDataSize);\n        }\n        compute(t, r) {\n            let n = r?.inputs?.map((d)=>typeof d == \"number\" ? this.inputs[d] : d) ?? this.inputs, o = r?.outputs ?? [], i = (d, l, p)=>new rr(this.module, l, this.output(d, p), p), a = (d, l)=>{\n                let p = Ct(d, l);\n                if (!p) throw new Error(`Unsupported data type: ${d}`);\n                let m = p > 0 ? this.backend.gpuDataManager.create(p).id : 0;\n                return new rr(this.module, d, m, l);\n            };\n            return this.backend.run(t, n, o, i, a, this.outputCount);\n        }\n        output(t, r) {\n            let n = this.module.stackSave();\n            try {\n                let o = this.module.PTR_SIZE, i = o === 4 ? \"i32\" : \"i64\", a = this.module.stackAlloc((1 + r.length) * o);\n                this.module.setValue(a, r.length, i);\n                for(let d = 0; d < r.length; d++)this.module.setValue(a + o * (d + 1), r[d], i);\n                return this.module._JsepOutput(this.opKernelContext, t, a);\n            } catch (o) {\n                throw new Error(`Failed to generate kernel's output[${t}] with dims [${r}]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: ${o}`);\n            } finally{\n                this.module.stackRestore(n);\n            }\n        }\n    }, mg = async (e1, t, r, n)=>{\n        let o = t.jsepInit;\n        if (!o) throw new Error(\"Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.\");\n        if (e1 === \"webgpu\") {\n            let i = new on;\n            await i.initialize(r, n), o(\"webgpu\", [\n                i,\n                (a)=>i.alloc(Number(a)),\n                (a)=>i.free(a),\n                (a, d, l, p = !1)=>{\n                    if (p) ue(\"verbose\", ()=>`[WebGPU] jsepCopyGpuToGpu: src=${Number(a)}, dst=${Number(d)}, size=${Number(l)}`), i.memcpy(Number(a), Number(d));\n                    else {\n                        ue(\"verbose\", ()=>`[WebGPU] jsepCopyCpuToGpu: dataOffset=${Number(a)}, gpuDataId=${Number(d)}, size=${Number(l)}`);\n                        let m = t.HEAPU8.subarray(Number(a >>> 0), Number(a >>> 0) + Number(l));\n                        i.upload(Number(d), m);\n                    }\n                },\n                async (a, d, l)=>{\n                    ue(\"verbose\", ()=>`[WebGPU] jsepCopyGpuToCpu: gpuDataId=${a}, dataOffset=${d}, size=${l}`), await i.download(Number(a), ()=>t.HEAPU8.subarray(Number(d) >>> 0, Number(d + l) >>> 0));\n                },\n                (a, d, l)=>i.createKernel(a, Number(d), l, t.UTF8ToString(t._JsepGetNodeName(Number(d)))),\n                (a)=>i.releaseKernel(a),\n                (a, d, l, p)=>{\n                    ue(\"verbose\", ()=>`[WebGPU] jsepRun: sessionHandle=${l}, kernel=${a}, contextDataOffset=${d}`);\n                    let m = new Eo(t, i, Number(d));\n                    return i.computeKernel(Number(a), m, p);\n                },\n                ()=>i.captureBegin(),\n                ()=>i.captureEnd(),\n                ()=>i.replay()\n            ]);\n        } else {\n            let i = new un(r);\n            o(\"webnn\", [\n                i,\n                ()=>i.reserveTensorId(),\n                (a)=>i.releaseTensorId(a),\n                async (a, d, l, p)=>i.ensureTensor(a, d, l, p),\n                (a, d)=>{\n                    i.uploadTensor(a, d);\n                },\n                async (a, d)=>i.downloadTensor(a, d)\n            ]);\n        }\n    };\n});\nvar fg, Tr, Ir, Pt, hg, Kt, Cr, Ar, uc, kr, Er, Pr, qn = U(()=>{\n    \"use strict\";\n    Ha();\n    qa();\n    te();\n    gt();\n    Or();\n    Xn();\n    fg = (e1, t)=>{\n        Ie()._OrtInit(e1, t) !== 0 && pe(\"Can't initialize onnxruntime.\");\n    }, Tr = async (e1)=>{\n        fg(e1.wasm.numThreads, Zt(e1.logLevel));\n    }, Ir = async (e1, t)=>{\n        {\n            let r = (sc(), br(ac)).init;\n            if (t === \"webgpu\") {\n                if (typeof navigator > \"u\" || !navigator.gpu) throw new Error(\"WebGPU is not supported in current environment\");\n                let n = e1.webgpu.adapter;\n                if (n) {\n                    if (typeof n.limits != \"object\" || typeof n.features != \"object\" || typeof n.requestDevice != \"function\") throw new Error(\"Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.\");\n                } else {\n                    let o = e1.webgpu.powerPreference;\n                    if (o !== void 0 && o !== \"low-power\" && o !== \"high-performance\") throw new Error(`Invalid powerPreference setting: \"${o}\"`);\n                    let i = e1.webgpu.forceFallbackAdapter;\n                    if (i !== void 0 && typeof i != \"boolean\") throw new Error(`Invalid forceFallbackAdapter setting: \"${i}\"`);\n                    if (n = await navigator.gpu.requestAdapter({\n                        powerPreference: o,\n                        forceFallbackAdapter: i\n                    }), !n) throw new Error('Failed to get GPU adapter. You may need to enable flag \"--enable-unsafe-webgpu\" if you are using Chrome.');\n                }\n                await r(\"webgpu\", Ie(), e1, n);\n            }\n            if (t === \"webnn\") {\n                if (typeof navigator > \"u\" || !navigator.ml) throw new Error(\"WebNN is not supported in current environment\");\n                await r(\"webnn\", Ie(), e1);\n            }\n        }\n    }, Pt = new Map, hg = (e1)=>{\n        let t = Ie(), r = t.stackSave();\n        try {\n            let n = t.PTR_SIZE, o = t.stackAlloc(2 * n);\n            t._OrtGetInputOutputCount(e1, o, o + n) !== 0 && pe(\"Can't get session input/output count.\");\n            let a = n === 4 ? \"i32\" : \"i64\";\n            return [\n                Number(t.getValue(o, a)),\n                Number(t.getValue(o + n, a))\n            ];\n        } finally{\n            t.stackRestore(r);\n        }\n    }, Kt = (e1)=>{\n        let t = Ie(), r = t._malloc(e1.byteLength);\n        if (r === 0) throw new Error(`Can't create a session. failed to allocate a buffer of size ${e1.byteLength}.`);\n        return t.HEAPU8.set(e1, r), [\n            r,\n            e1.byteLength\n        ];\n    }, Cr = async (e1, t)=>{\n        let r, n, o = Ie();\n        Array.isArray(e1) ? [r, n] = e1 : e1.buffer === o.HEAPU8.buffer ? [r, n] = [\n            e1.byteOffset,\n            e1.byteLength\n        ] : [r, n] = Kt(e1);\n        let i = 0, a = 0, d = 0, l = [], p = [], m = [];\n        try {\n            if ([a, l] = Fa(t), t?.externalData && o.mountExternalData) {\n                let v = [];\n                for (let S of t.externalData){\n                    let T = typeof S == \"string\" ? S : S.path;\n                    v.push(Qt(typeof S == \"string\" ? S : S.data).then((A)=>{\n                        o.mountExternalData(T, A);\n                    }));\n                }\n                await Promise.all(v);\n            }\n            for (let v of t?.executionProviders ?? [])if ((typeof v == \"string\" ? v : v.name) === \"webnn\") {\n                if (o.shouldTransferToMLTensor = !1, typeof v != \"string\") {\n                    let T = v, A = T?.context, k = T?.gpuDevice, P = T?.deviceType, D = T?.powerPreference;\n                    A ? o.currentContext = A : k ? o.currentContext = await o.jsepCreateMLContext(k) : o.currentContext = await o.jsepCreateMLContext({\n                        deviceType: P,\n                        powerPreference: D\n                    });\n                } else o.currentContext = await o.jsepCreateMLContext();\n                break;\n            }\n            i = await o._OrtCreateSession(r, n, a), i === 0 && pe(\"Can't create a session.\"), o.jsepOnCreateSession?.(), o.currentContext && (o.jsepRegisterMLContext(i, o.currentContext), o.currentContext = void 0, o.shouldTransferToMLTensor = !0);\n            let [u, h] = hg(i), _ = !!t?.enableGraphCapture, y = [], g = [], x = [];\n            for(let v = 0; v < u; v++){\n                let S = o._OrtGetInputName(i, v);\n                S === 0 && pe(\"Can't get an input name.\"), p.push(S), y.push(o.UTF8ToString(S));\n            }\n            for(let v = 0; v < h; v++){\n                let S = o._OrtGetOutputName(i, v);\n                S === 0 && pe(\"Can't get an output name.\"), m.push(S);\n                let T = o.UTF8ToString(S);\n                g.push(T);\n                {\n                    if (_ && t?.preferredOutputLocation === void 0) {\n                        x.push(\"gpu-buffer\");\n                        continue;\n                    }\n                    let A = typeof t?.preferredOutputLocation == \"string\" ? t.preferredOutputLocation : t?.preferredOutputLocation?.[T] ?? \"cpu\";\n                    if (A !== \"cpu\" && A !== \"cpu-pinned\" && A !== \"gpu-buffer\" && A !== \"ml-tensor\") throw new Error(`Not supported preferred output location: ${A}.`);\n                    if (_ && A !== \"gpu-buffer\") throw new Error(`Not supported preferred output location: ${A}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);\n                    x.push(A);\n                }\n            }\n            let $ = null;\n            return x.some((v)=>v === \"gpu-buffer\" || v === \"ml-tensor\") && (d = o._OrtCreateBinding(i), d === 0 && pe(\"Can't create IO binding.\"), $ = {\n                handle: d,\n                outputPreferredLocations: x,\n                outputPreferredLocationsEncoded: x.map((v)=>Qn(v))\n            }), Pt.set(i, [\n                i,\n                p,\n                m,\n                $,\n                _,\n                !1\n            ]), [\n                i,\n                y,\n                g\n            ];\n        } catch (u) {\n            throw p.forEach((h)=>o._OrtFree(h)), m.forEach((h)=>o._OrtFree(h)), d !== 0 && o._OrtReleaseBinding(d) !== 0 && pe(\"Can't release IO binding.\"), i !== 0 && o._OrtReleaseSession(i) !== 0 && pe(\"Can't release session.\"), u;\n        } finally{\n            o._free(r), a !== 0 && o._OrtReleaseSessionOptions(a) !== 0 && pe(\"Can't release session options.\"), l.forEach((u)=>o._free(u)), o.unmountExternalData?.();\n        }\n    }, Ar = (e1)=>{\n        let t = Ie(), r = Pt.get(e1);\n        if (!r) throw new Error(`cannot release session. invalid session id: ${e1}`);\n        let [n, o, i, a, d] = r;\n        a && (d && t._OrtClearBoundOutputs(a.handle) !== 0 && pe(\"Can't clear bound outputs.\"), t._OrtReleaseBinding(a.handle) !== 0 && pe(\"Can't release IO binding.\")), t.jsepOnReleaseSession?.(e1), o.forEach((l)=>t._OrtFree(l)), i.forEach((l)=>t._OrtFree(l)), t._OrtReleaseSession(n) !== 0 && pe(\"Can't release session.\"), Pt.delete(e1);\n    }, uc = (e1, t, r, n, o, i = !1)=>{\n        if (!e1) {\n            t.push(0);\n            return;\n        }\n        let a = Ie(), d = a.PTR_SIZE, l = e1[0], p = e1[1], m = e1[3], u, h;\n        if (l === \"string\" && (m === \"gpu-buffer\" || m === \"ml-tensor\")) throw new Error(\"String tensor is not supported on GPU.\");\n        if (i && m !== \"gpu-buffer\") throw new Error(`External buffer must be provided for input/output index ${o} when enableGraphCapture is true.`);\n        if (m === \"gpu-buffer\") {\n            let g = e1[2].gpuBuffer;\n            h = Ct(Yt(l), p);\n            let x = a.jsepRegisterBuffer;\n            if (!x) throw new Error('Tensor location \"gpu-buffer\" is not supported without using WebGPU.');\n            u = x(n, o, g, h);\n        } else if (m === \"ml-tensor\") {\n            let g = e1[2].mlTensor;\n            h = Ct(Yt(l), p);\n            let x = a.jsepRegisterMLTensor;\n            if (!x) throw new Error('Tensor location \"ml-tensor\" is not supported without using WebNN.');\n            u = x(g, Yt(l), p);\n        } else {\n            let g = e1[2];\n            if (Array.isArray(g)) {\n                h = d * g.length, u = a._malloc(h), r.push(u);\n                for(let x = 0; x < g.length; x++){\n                    if (typeof g[x] != \"string\") throw new TypeError(`tensor data at index ${x} is not a string`);\n                    a.setValue(u + x * d, ke(g[x], r), \"*\");\n                }\n            } else h = g.byteLength, u = a._malloc(h), r.push(u), a.HEAPU8.set(new Uint8Array(g.buffer, g.byteOffset, h), u);\n        }\n        let _ = a.stackSave(), y = a.stackAlloc(4 * p.length);\n        try {\n            p.forEach((x, $)=>a.setValue(y + $ * d, x, d === 4 ? \"i32\" : \"i64\"));\n            let g = a._OrtCreateTensor(Yt(l), u, h, y, p.length, Qn(m));\n            g === 0 && pe(`Can't create tensor for input/output. session=${n}, index=${o}.`), t.push(g);\n        } finally{\n            a.stackRestore(_);\n        }\n    }, kr = async (e1, t, r, n, o, i)=>{\n        let a = Ie(), d = a.PTR_SIZE, l = Pt.get(e1);\n        if (!l) throw new Error(`cannot run inference. invalid session id: ${e1}`);\n        let p = l[0], m = l[1], u = l[2], h = l[3], _ = l[4], y = l[5], g = t.length, x = n.length, $ = 0, v = [], S = [], T = [], A = [], k = a.stackSave(), P = a.stackAlloc(g * d), D = a.stackAlloc(g * d), R = a.stackAlloc(x * d), G = a.stackAlloc(x * d);\n        try {\n            a.jsepOnRunStart?.(p), [$, v] = Ga(i);\n            for(let V = 0; V < g; V++)uc(r[V], S, A, e1, t[V], _);\n            for(let V = 0; V < x; V++)uc(o[V], T, A, e1, g + n[V], _);\n            for(let V = 0; V < g; V++)a.setValue(P + V * d, S[V], \"*\"), a.setValue(D + V * d, m[t[V]], \"*\");\n            for(let V = 0; V < x; V++)a.setValue(R + V * d, T[V], \"*\"), a.setValue(G + V * d, u[n[V]], \"*\");\n            if (h && !y) {\n                let { handle: V, outputPreferredLocations: Q, outputPreferredLocationsEncoded: se } = h;\n                if (m.length !== g) throw new Error(`input count from feeds (${g}) is expected to be always equal to model's input count (${m.length}).`);\n                for(let Y = 0; Y < g; Y++){\n                    let ee = t[Y];\n                    await a._OrtBindInput(V, m[ee], S[Y]) !== 0 && pe(`Can't bind input[${Y}] for session=${e1}.`);\n                }\n                for(let Y = 0; Y < x; Y++){\n                    let ee = n[Y];\n                    o[Y]?.[3] ? a._OrtBindOutput(V, u[ee], T[Y], 0) !== 0 && pe(`Can't bind pre-allocated output[${Y}] for session=${e1}.`) : a._OrtBindOutput(V, u[ee], 0, se[ee]) !== 0 && pe(`Can't bind output[${Y}] to ${Q[Y]} for session=${e1}.`);\n                }\n                Pt.set(e1, [\n                    p,\n                    m,\n                    u,\n                    h,\n                    _,\n                    !0\n                ]);\n            }\n            let K;\n            h ? K = await a._OrtRunWithBinding(p, h.handle, x, R, $) : K = await a._OrtRun(p, D, P, g, G, x, R, $), K !== 0 && pe(\"failed to call OrtRun().\");\n            let j = [];\n            for(let V = 0; V < x; V++){\n                let Q = Number(a.getValue(R + V * d, \"*\"));\n                if (Q === T[V]) {\n                    j.push(o[V]);\n                    continue;\n                }\n                let se = a.stackSave(), Y = a.stackAlloc(4 * d), ee = !1, J, ne = 0;\n                try {\n                    a._OrtGetTensorData(Q, Y, Y + d, Y + 2 * d, Y + 3 * d) !== 0 && pe(`Can't access output tensor data on index ${V}.`);\n                    let Oe = d === 4 ? \"i32\" : \"i64\", $e = Number(a.getValue(Y, Oe));\n                    ne = a.getValue(Y + d, \"*\");\n                    let le = a.getValue(Y + d * 2, \"*\"), W = Number(a.getValue(Y + d * 3, Oe)), q = [];\n                    for(let we = 0; we < W; we++)q.push(Number(a.getValue(le + we * d, Oe)));\n                    a._OrtFree(le) !== 0 && pe(\"Can't free memory for tensor dims.\");\n                    let he = q.reduce((we, ye)=>we * ye, 1);\n                    J = bt($e);\n                    let Ge = h?.outputPreferredLocations[n[V]];\n                    if (J === \"string\") {\n                        if (Ge === \"gpu-buffer\" || Ge === \"ml-tensor\") throw new Error(\"String tensor is not supported on GPU.\");\n                        let we = [];\n                        for(let ye = 0; ye < he; ye++){\n                            let Ye = a.getValue(ne + ye * d, \"*\"), Lt = a.getValue(ne + (ye + 1) * d, \"*\"), fn = ye === he - 1 ? void 0 : Lt - Ye;\n                            we.push(a.UTF8ToString(Ye, fn));\n                        }\n                        j.push([\n                            J,\n                            q,\n                            we,\n                            \"cpu\"\n                        ]);\n                    } else if (Ge === \"gpu-buffer\" && he > 0) {\n                        let we = a.jsepGetBuffer;\n                        if (!we) throw new Error('preferredLocation \"gpu-buffer\" is not supported without using WebGPU.');\n                        let ye = we(ne), Ye = Ct($e, he);\n                        if (Ye === void 0 || !Br(J)) throw new Error(`Unsupported data type: ${J}`);\n                        ee = !0, j.push([\n                            J,\n                            q,\n                            {\n                                gpuBuffer: ye,\n                                download: a.jsepCreateDownloader(ye, Ye, J),\n                                dispose: ()=>{\n                                    a._OrtReleaseTensor(Q) !== 0 && pe(\"Can't release tensor.\");\n                                }\n                            },\n                            \"gpu-buffer\"\n                        ]);\n                    } else if (Ge === \"ml-tensor\" && he > 0) {\n                        let we = a.jsepEnsureTensor;\n                        if (!we) throw new Error('preferredLocation \"ml-tensor\" is not supported without using WebNN.');\n                        if (Ct($e, he) === void 0 || !Mr(J)) throw new Error(`Unsupported data type: ${J}`);\n                        let Ye = await we(ne, $e, q, !1);\n                        ee = !0, j.push([\n                            J,\n                            q,\n                            {\n                                mlTensor: Ye,\n                                download: a.jsepCreateMLTensorDownloader(ne, J),\n                                dispose: ()=>{\n                                    a.jsepReleaseTensorId(ne), a._OrtReleaseTensor(Q);\n                                }\n                            },\n                            \"ml-tensor\"\n                        ]);\n                    } else {\n                        let we = Dr(J), ye = new we(he);\n                        new Uint8Array(ye.buffer, ye.byteOffset, ye.byteLength).set(a.HEAPU8.subarray(ne, ne + ye.byteLength)), j.push([\n                            J,\n                            q,\n                            ye,\n                            \"cpu\"\n                        ]);\n                    }\n                } finally{\n                    a.stackRestore(se), J === \"string\" && ne && a._free(ne), ee || a._OrtReleaseTensor(Q);\n                }\n            }\n            return h && !_ && (a._OrtClearBoundOutputs(h.handle) !== 0 && pe(\"Can't clear bound outputs.\"), Pt.set(e1, [\n                p,\n                m,\n                u,\n                h,\n                _,\n                !1\n            ])), j;\n        } finally{\n            a.stackRestore(k), S.forEach((K)=>a._OrtReleaseTensor(K)), T.forEach((K)=>a._OrtReleaseTensor(K)), A.forEach((K)=>a._free(K)), $ !== 0 && a._OrtReleaseRunOptions($), v.forEach((K)=>a._free(K));\n        }\n    }, Er = (e1)=>{\n        let t = Ie(), r = Pt.get(e1);\n        if (!r) throw new Error(\"invalid session id\");\n        let n = r[0], o = t._OrtEndProfiling(n);\n        o === 0 && pe(\"Can't get an profile file name.\"), t._OrtFree(o);\n    }, Pr = (e1)=>{\n        let t = [];\n        for (let r of e1){\n            let n = r[2];\n            !Array.isArray(n) && \"buffer\" in n && t.push(n.buffer);\n        }\n        return t;\n    };\n});\nvar zt, Le, nr, ln, cn, dn, Po, zo, Vt, Wt, bg, dc, lc, cc, pc, mc, fc, hc, Oo = U(()=>{\n    \"use strict\";\n    We();\n    qn();\n    gt();\n    xr();\n    zt = ()=>!!ve.wasm.proxy && typeof document < \"u\", nr = !1, ln = !1, cn = !1, zo = new Map, Vt = (e1, t)=>{\n        let r = zo.get(e1);\n        r ? r.push(t) : zo.set(e1, [\n            t\n        ]);\n    }, Wt = ()=>{\n        if (nr || !ln || cn || !Le) throw new Error(\"worker not ready\");\n    }, bg = (e1)=>{\n        switch(e1.data.type){\n            case \"init-wasm\":\n                nr = !1, e1.data.err ? (cn = !0, Po[1](e1.data.err)) : (ln = !0, Po[0]()), dn && (URL.revokeObjectURL(dn), dn = void 0);\n                break;\n            case \"init-ep\":\n            case \"copy-from\":\n            case \"create\":\n            case \"release\":\n            case \"run\":\n            case \"end-profiling\":\n                {\n                    let t = zo.get(e1.data.type);\n                    e1.data.err ? t.shift()[1](e1.data.err) : t.shift()[0](e1.data.out);\n                    break;\n                }\n            default:\n        }\n    }, dc = async ()=>{\n        if (!ln) {\n            if (nr) throw new Error(\"multiple calls to 'initWasm()' detected.\");\n            if (cn) throw new Error(\"previous call to 'initWasm()' failed.\");\n            if (nr = !0, zt()) return new Promise((e1, t)=>{\n                Le?.terminate(), Va().then(([r, n])=>{\n                    try {\n                        Le = n, Le.onerror = (i)=>t(i), Le.onmessage = bg, Po = [\n                            e1,\n                            t\n                        ];\n                        let o = {\n                            type: \"init-wasm\",\n                            in: ve\n                        };\n                        !o.in.wasm.wasmPaths && (r || \"file:///Users/amityadav/Desktop/Text-Behind%20Image/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs\"?.startsWith(\"file:\")) && (o.in.wasm.wasmPaths = {\n                            wasm: /* asset import */ new __webpack_require__.U(__webpack_require__(/*! ort-wasm-simd-threaded.jsep.wasm */ \"(ssr)/./node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm\")).href\n                        }), Le.postMessage(o), dn = r;\n                    } catch (o) {\n                        t(o);\n                    }\n                }, t);\n            });\n            try {\n                await Sr(ve.wasm), await Tr(ve), ln = !0;\n            } catch (e1) {\n                throw cn = !0, e1;\n            } finally{\n                nr = !1;\n            }\n        }\n    }, lc = async (e1)=>{\n        if (zt()) return Wt(), new Promise((t, r)=>{\n            Vt(\"init-ep\", [\n                t,\n                r\n            ]);\n            let n = {\n                type: \"init-ep\",\n                in: {\n                    epName: e1,\n                    env: ve\n                }\n            };\n            Le.postMessage(n);\n        });\n        await Ir(ve, e1);\n    }, cc = async (e1)=>zt() ? (Wt(), new Promise((t, r)=>{\n            Vt(\"copy-from\", [\n                t,\n                r\n            ]);\n            let n = {\n                type: \"copy-from\",\n                in: {\n                    buffer: e1\n                }\n            };\n            Le.postMessage(n, [\n                e1.buffer\n            ]);\n        })) : Kt(e1), pc = async (e1, t)=>{\n        if (zt()) {\n            if (t?.preferredOutputLocation) throw new Error('session option \"preferredOutputLocation\" is not supported for proxy.');\n            return Wt(), new Promise((r, n)=>{\n                Vt(\"create\", [\n                    r,\n                    n\n                ]);\n                let o = {\n                    type: \"create\",\n                    in: {\n                        model: e1,\n                        options: {\n                            ...t\n                        }\n                    }\n                }, i = [];\n                e1 instanceof Uint8Array && i.push(e1.buffer), Le.postMessage(o, i);\n            });\n        } else return Cr(e1, t);\n    }, mc = async (e1)=>{\n        if (zt()) return Wt(), new Promise((t, r)=>{\n            Vt(\"release\", [\n                t,\n                r\n            ]);\n            let n = {\n                type: \"release\",\n                in: e1\n            };\n            Le.postMessage(n);\n        });\n        Ar(e1);\n    }, fc = async (e1, t, r, n, o, i)=>{\n        if (zt()) {\n            if (r.some((a)=>a[3] !== \"cpu\")) throw new Error(\"input tensor on GPU is not supported for proxy.\");\n            if (o.some((a)=>a)) throw new Error(\"pre-allocated output tensor is not supported for proxy.\");\n            return Wt(), new Promise((a, d)=>{\n                Vt(\"run\", [\n                    a,\n                    d\n                ]);\n                let l = r, p = {\n                    type: \"run\",\n                    in: {\n                        sessionId: e1,\n                        inputIndices: t,\n                        inputs: l,\n                        outputIndices: n,\n                        options: i\n                    }\n                };\n                Le.postMessage(p, Pr(l));\n            });\n        } else return kr(e1, t, r, n, o, i);\n    }, hc = async (e1)=>{\n        if (zt()) return Wt(), new Promise((t, r)=>{\n            Vt(\"end-profiling\", [\n                t,\n                r\n            ]);\n            let n = {\n                type: \"end-profiling\",\n                in: e1\n            };\n            Le.postMessage(n);\n        });\n        Er(e1);\n    };\n});\nvar gc, yg, pn, bc = U(()=>{\n    \"use strict\";\n    We();\n    Oo();\n    te();\n    $r();\n    Xn();\n    gc = (e1, t)=>{\n        switch(e1.location){\n            case \"cpu\":\n                return [\n                    e1.type,\n                    e1.dims,\n                    e1.data,\n                    \"cpu\"\n                ];\n            case \"gpu-buffer\":\n                return [\n                    e1.type,\n                    e1.dims,\n                    {\n                        gpuBuffer: e1.gpuBuffer\n                    },\n                    \"gpu-buffer\"\n                ];\n            case \"ml-tensor\":\n                return [\n                    e1.type,\n                    e1.dims,\n                    {\n                        mlTensor: e1.mlTensor\n                    },\n                    \"ml-tensor\"\n                ];\n            default:\n                throw new Error(`invalid data location: ${e1.location} for ${t()}`);\n        }\n    }, yg = (e1)=>{\n        switch(e1[3]){\n            case \"cpu\":\n                return new He(e1[0], e1[2], e1[1]);\n            case \"gpu-buffer\":\n                {\n                    let t = e1[0];\n                    if (!Br(t)) throw new Error(`not supported data type: ${t} for deserializing GPU tensor`);\n                    let { gpuBuffer: r, download: n, dispose: o } = e1[2];\n                    return He.fromGpuBuffer(r, {\n                        dataType: t,\n                        dims: e1[1],\n                        download: n,\n                        dispose: o\n                    });\n                }\n            case \"ml-tensor\":\n                {\n                    let t = e1[0];\n                    if (!Mr(t)) throw new Error(`not supported data type: ${t} for deserializing MLTensor tensor`);\n                    let { mlTensor: r, download: n, dispose: o } = e1[2];\n                    return He.fromMLTensor(r, {\n                        dataType: t,\n                        dims: e1[1],\n                        download: n,\n                        dispose: o\n                    });\n                }\n            default:\n                throw new Error(`invalid data location: ${e1[3]}`);\n        }\n    }, pn = class {\n        async fetchModelAndCopyToWasmMemory(t) {\n            return cc(await Qt(t));\n        }\n        async loadModel(t, r) {\n            Ue();\n            let n;\n            typeof t == \"string\" ?  false ? 0 : n = await this.fetchModelAndCopyToWasmMemory(t) : n = t, [this.sessionId, this.inputNames, this.outputNames] = await pc(n, r), De();\n        }\n        async dispose() {\n            return mc(this.sessionId);\n        }\n        async run(t, r, n) {\n            Ue();\n            let o = [], i = [];\n            Object.entries(t).forEach((h)=>{\n                let _ = h[0], y = h[1], g = this.inputNames.indexOf(_);\n                if (g === -1) throw new Error(`invalid input '${_}'`);\n                o.push(y), i.push(g);\n            });\n            let a = [], d = [];\n            Object.entries(r).forEach((h)=>{\n                let _ = h[0], y = h[1], g = this.outputNames.indexOf(_);\n                if (g === -1) throw new Error(`invalid output '${_}'`);\n                a.push(y), d.push(g);\n            });\n            let l = o.map((h, _)=>gc(h, ()=>`input \"${this.inputNames[i[_]]}\"`)), p = a.map((h, _)=>h ? gc(h, ()=>`output \"${this.outputNames[d[_]]}\"`) : null), m = await fc(this.sessionId, i, l, d, p, n), u = {};\n            for(let h = 0; h < m.length; h++)u[this.outputNames[d[h]]] = a[h] ?? yg(m[h]);\n            return De(), u;\n        }\n        startProfiling() {}\n        endProfiling() {\n            hc(this.sessionId);\n        }\n    };\n});\nvar _c = {};\nFt(_c, {\n    OnnxruntimeWebAssemblyBackend: ()=>mn,\n    initializeFlags: ()=>yc,\n    wasmBackend: ()=>_g\n});\nvar yc, mn, _g, wc = U(()=>{\n    \"use strict\";\n    We();\n    Oo();\n    bc();\n    yc = ()=>{\n        if ((typeof ve.wasm.initTimeout != \"number\" || ve.wasm.initTimeout < 0) && (ve.wasm.initTimeout = 0), ve.wasm.simd === !1 && console.warn('Deprecated property \"env.wasm.simd\" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'), typeof ve.wasm.proxy != \"boolean\" && (ve.wasm.proxy = !1), typeof ve.wasm.trace != \"boolean\" && (ve.wasm.trace = !1), typeof ve.wasm.numThreads != \"number\" || !Number.isInteger(ve.wasm.numThreads) || ve.wasm.numThreads <= 0) if (typeof self < \"u\" && !self.crossOriginIsolated) ve.wasm.numThreads = 1;\n        else {\n            let e1 = typeof navigator > \"u\" ? Nn(\"node:os\").cpus().length : navigator.hardwareConcurrency;\n            ve.wasm.numThreads = Math.min(4, Math.ceil((e1 || 1) / 2));\n        }\n    }, mn = class {\n        async init(t) {\n            yc(), await dc(), await lc(t);\n        }\n        async createInferenceSessionHandler(t, r) {\n            let n = new pn;\n            return await n.loadModel(t, r), Promise.resolve(n);\n        }\n    }, _g = new mn;\n});\nWe();\nWe();\nWe();\nvar Ca = \"1.21.0-dev.20250114-228dd16893\";\nvar $1 = Fn;\n{\n    let e1 = (wc(), br(_c)).wasmBackend;\n    St(\"webgpu\", e1, 5), St(\"webnn\", e1, 5), St(\"cpu\", e1, 10), St(\"wasm\", e1, 10);\n}Object.defineProperty(ve.versions, \"web\", {\n    value: Ca,\n    enumerable: !0\n});\n /**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */  /**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */  /**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */  //# sourceMappingURL=ort.webgpu.bundle.min.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL2Rpc3Qvb3J0LndlYmdwdS5idW5kbGUubWluLm1qcz9lZTBmIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Q0FJQyxHQUNELElBQUlBLEtBQUdDLE9BQU9DLGNBQWM7QUFBQyxJQUFJQyxLQUFHRixPQUFPRyx3QkFBd0I7QUFBQyxJQUFJQyxLQUFHSixPQUFPSyxtQkFBbUI7QUFBQyxJQUFJQyxLQUFHTixPQUFPTyxTQUFTLENBQUNDLGNBQWM7QUFBQyxJQUFJQyxLQUFHLENBQUNDLENBQUFBLEtBQUcsT0FBT0MsVUFBUSxNQUFJQSxVQUFRLE9BQU9DLFFBQU0sTUFBSSxJQUFJQSxNQUFNRixJQUFFO1FBQUNHLEtBQUksQ0FBQ0MsR0FBRUMsSUFBSSxDQUFDLE9BQU9KLFVBQVEsTUFBSUEsVUFBUUcsQ0FBQUEsQ0FBRSxDQUFDQyxFQUFFO0lBQUEsS0FBR0wsRUFBQUEsRUFBRyxTQUFTQSxFQUFDO0lBQUUsSUFBRyxPQUFPQyxVQUFRLEtBQUksT0FBT0EsUUFBUUssS0FBSyxDQUFDLElBQUksRUFBQ0M7SUFBVyxNQUFNQyxNQUFNLHlCQUF1QlIsS0FBRTtBQUFxQjtBQUFHLElBQUlTLElBQUUsQ0FBQ1QsSUFBRUksSUFBSSxJQUFLSixDQUFBQSxNQUFJSSxDQUFBQSxJQUFFSixHQUFFQSxLQUFFLEVBQUMsR0FBR0ksQ0FBQUE7QUFBRyxJQUFJTSxLQUFHLENBQUNWLElBQUVJO0lBQUssSUFBSSxJQUFJQyxLQUFLRCxFQUFFZixHQUFHVyxJQUFFSyxHQUFFO1FBQUNGLEtBQUlDLENBQUMsQ0FBQ0MsRUFBRTtRQUFDTSxZQUFXLENBQUM7SUFBQztBQUFFLEdBQUVDLEtBQUcsQ0FBQ1osSUFBRUksR0FBRUMsR0FBRVE7SUFBSyxJQUFHVCxLQUFHLE9BQU9BLEtBQUcsWUFBVSxPQUFPQSxLQUFHLFlBQVcsS0FBSSxJQUFJVSxLQUFLcEIsR0FBR1UsR0FBRyxDQUFDUixHQUFHbUIsSUFBSSxD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QUUsRUFBR0ssV0FBVztJQUFDcHpELEdBQUcsVUFBU3BCLElBQUUsSUFBR29CLEdBQUcsU0FBUXBCLElBQUUsSUFBR29CLEdBQUcsT0FBTXBCLElBQUUsS0FBSW9CLEdBQUcsUUFBT3BCLElBQUU7QUFBRyxDQUFDVixPQUFPQyxjQUFjLENBQUM4RSxHQUFHSCxRQUFRLEVBQUMsT0FBTTtJQUFDakQsT0FBTTZ5QjtJQUFHbnpCLFlBQVcsQ0FBQztBQUFDO0FBQXFKLENBQ3RnekM7Ozs7Ozs7Ozs7Ozs7OztDQWVDLElBQ0Q7Ozs7Ozs7Ozs7Ozs7OztDQWVDLElBQ0Q7Ozs7Ozs7Ozs7Ozs7OztDQWVDLElBQ0Qsa0RBQWtEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGV4dC1iZWhpbmQtaW1hZ2UvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL2Rpc3Qvb3J0LndlYmdwdS5idW5kbGUubWluLm1qcz9kMGYyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogT05OWCBSdW50aW1lIFdlYiB2MS4yMS4wLWRldi4yMDI1MDExNC0yMjhkZDE2ODkzXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xudmFyIFVuPU9iamVjdC5kZWZpbmVQcm9wZXJ0eTt2YXIgVnA9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjt2YXIgV3A9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7dmFyIExwPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7dmFyIE5uPShlPT50eXBlb2YgcmVxdWlyZTxcInVcIj9yZXF1aXJlOnR5cGVvZiBQcm94eTxcInVcIj9uZXcgUHJveHkoZSx7Z2V0Oih0LHIpPT4odHlwZW9mIHJlcXVpcmU8XCJ1XCI/cmVxdWlyZTp0KVtyXX0pOmUpKGZ1bmN0aW9uKGUpe2lmKHR5cGVvZiByZXF1aXJlPFwidVwiKXJldHVybiByZXF1aXJlLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt0aHJvdyBFcnJvcignRHluYW1pYyByZXF1aXJlIG9mIFwiJytlKydcIiBpcyBub3Qgc3VwcG9ydGVkJyl9KTt2YXIgVT0oZSx0KT0+KCk9PihlJiYodD1lKGU9MCkpLHQpO3ZhciBGdD0oZSx0KT0+e2Zvcih2YXIgciBpbiB0KVVuKGUscix7Z2V0OnRbcl0sZW51bWVyYWJsZTohMH0pfSxHcD0oZSx0LHIsbik9PntpZih0JiZ0eXBlb2YgdD09XCJvYmplY3RcInx8dHlwZW9mIHQ9PVwiZnVuY3Rpb25cIilmb3IobGV0IG8gb2YgV3AodCkpIUxwLmNhbGwoZSxvKSYmbyE9PXImJlVuKGUsbyx7Z2V0OigpPT50W29dLGVudW1lcmFibGU6IShuPVZwKHQsbykpfHxuLmVudW1lcmFibGV9KTtyZXR1cm4gZX07dmFyIGJyPWU9PkdwKFVuKHt9LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUpO3ZhciB5cix4dCxTdCxIcCxKaSxWbj1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7eXI9bmV3IE1hcCx4dD1bXSxTdD0oZSx0LHIpPT57aWYodCYmdHlwZW9mIHQuaW5pdD09XCJmdW5jdGlvblwiJiZ0eXBlb2YgdC5jcmVhdGVJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcj09XCJmdW5jdGlvblwiKXtsZXQgbj15ci5nZXQoZSk7aWYobj09PXZvaWQgMCl5ci5zZXQoZSx7YmFja2VuZDp0LHByaW9yaXR5OnJ9KTtlbHNle2lmKG4ucHJpb3JpdHk+cilyZXR1cm47aWYobi5wcmlvcml0eT09PXImJm4uYmFja2VuZCE9PXQpdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgcmVnaXN0ZXIgYmFja2VuZCBcIiR7ZX1cIiB1c2luZyBwcmlvcml0eSAke3J9YCl9aWYocj49MCl7bGV0IG89eHQuaW5kZXhPZihlKTtvIT09LTEmJnh0LnNwbGljZShvLDEpO2ZvcihsZXQgaT0wO2k8eHQubGVuZ3RoO2krKylpZih5ci5nZXQoeHRbaV0pLnByaW9yaXR5PD1yKXt4dC5zcGxpY2UoaSwwLGUpO3JldHVybn14dC5wdXNoKGUpfXJldHVybn10aHJvdyBuZXcgVHlwZUVycm9yKFwibm90IGEgdmFsaWQgYmFja2VuZFwiKX0sSHA9YXN5bmMgZT0+e2xldCB0PXlyLmdldChlKTtpZighdClyZXR1cm5cImJhY2tlbmQgbm90IGZvdW5kLlwiO2lmKHQuaW5pdGlhbGl6ZWQpcmV0dXJuIHQuYmFja2VuZDtpZih0LmFib3J0ZWQpcmV0dXJuIHQuZXJyb3I7e2xldCByPSEhdC5pbml0UHJvbWlzZTt0cnl7cmV0dXJuIHJ8fCh0LmluaXRQcm9taXNlPXQuYmFja2VuZC5pbml0KGUpKSxhd2FpdCB0LmluaXRQcm9taXNlLHQuaW5pdGlhbGl6ZWQ9ITAsdC5iYWNrZW5kfWNhdGNoKG4pe3JldHVybiByfHwodC5lcnJvcj1gJHtufWAsdC5hYm9ydGVkPSEwKSx0LmVycm9yfWZpbmFsbHl7ZGVsZXRlIHQuaW5pdFByb21pc2V9fX0sSmk9YXN5bmMgZT0+e2xldCB0PWUuZXhlY3V0aW9uUHJvdmlkZXJzfHxbXSxyPXQubWFwKGw9PnR5cGVvZiBsPT1cInN0cmluZ1wiP2w6bC5uYW1lKSxuPXIubGVuZ3RoPT09MD94dDpyLG8saT1bXSxhPW5ldyBTZXQ7Zm9yKGxldCBsIG9mIG4pe2xldCBwPWF3YWl0IEhwKGwpO3R5cGVvZiBwPT1cInN0cmluZ1wiP2kucHVzaCh7bmFtZTpsLGVycjpwfSk6KG98fChvPXApLG89PT1wJiZhLmFkZChsKSl9aWYoIW8pdGhyb3cgbmV3IEVycm9yKGBubyBhdmFpbGFibGUgYmFja2VuZCBmb3VuZC4gRVJSOiAke2kubWFwKGw9PmBbJHtsLm5hbWV9XSAke2wuZXJyfWApLmpvaW4oXCIsIFwiKX1gKTtmb3IobGV0e25hbWU6bCxlcnI6cH1vZiBpKXIuaW5jbHVkZXMobCkmJmNvbnNvbGUud2FybihgcmVtb3ZpbmcgcmVxdWVzdGVkIGV4ZWN1dGlvbiBwcm92aWRlciBcIiR7bH1cIiBmcm9tIHNlc3Npb24gb3B0aW9ucyBiZWNhdXNlIGl0IGlzIG5vdCBhdmFpbGFibGU6ICR7cH1gKTtsZXQgZD10LmZpbHRlcihsPT5hLmhhcyh0eXBlb2YgbD09XCJzdHJpbmdcIj9sOmwubmFtZSkpO3JldHVybltvLG5ldyBQcm94eShlLHtnZXQ6KGwscCk9PnA9PT1cImV4ZWN1dGlvblByb3ZpZGVyc1wiP2Q6UmVmbGVjdC5nZXQobCxwKX0pXX19KTt2YXIgZWE9VSgoKT0+e1widXNlIHN0cmljdFwiO1ZuKCl9KTt2YXIgdGEscmE9VSgoKT0+e1widXNlIHN0cmljdFwiO3RhPVwiMS4yMS4wLWRldi4yMDI0MTIxMi0xZjg4Mjg0Zjk2XCJ9KTt2YXIgbmEsUmUsV249VSgoKT0+e1widXNlIHN0cmljdFwiO3JhKCk7bmE9XCJ3YXJuaW5nXCIsUmU9e3dhc206e30sd2ViZ2w6e30sd2ViZ3B1Ont9LHZlcnNpb25zOntjb21tb246dGF9LHNldCBsb2dMZXZlbChlKXtpZihlIT09dm9pZCAwKXtpZih0eXBlb2YgZSE9XCJzdHJpbmdcInx8W1widmVyYm9zZVwiLFwiaW5mb1wiLFwid2FybmluZ1wiLFwiZXJyb3JcIixcImZhdGFsXCJdLmluZGV4T2YoZSk9PT0tMSl0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGxvZ2dpbmcgbGV2ZWw6ICR7ZX1gKTtuYT1lfX0sZ2V0IGxvZ0xldmVsKCl7cmV0dXJuIG5hfX07T2JqZWN0LmRlZmluZVByb3BlcnR5KFJlLFwibG9nTGV2ZWxcIix7ZW51bWVyYWJsZTohMH0pfSk7dmFyIHZlLG9hPVUoKCk9PntcInVzZSBzdHJpY3RcIjtXbigpO3ZlPVJlfSk7dmFyIGlhLGFhLHNhPVUoKCk9PntcInVzZSBzdHJpY3RcIjtpYT0oZSx0KT0+e2xldCByPXR5cGVvZiBkb2N1bWVudDxcInVcIj9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpOm5ldyBPZmZzY3JlZW5DYW52YXMoMSwxKTtyLndpZHRoPWUuZGltc1szXSxyLmhlaWdodD1lLmRpbXNbMl07bGV0IG49ci5nZXRDb250ZXh0KFwiMmRcIik7aWYobiE9bnVsbCl7bGV0IG8saTt0Py50ZW5zb3JMYXlvdXQhPT12b2lkIDAmJnQudGVuc29yTGF5b3V0PT09XCJOSFdDXCI/KG89ZS5kaW1zWzJdLGk9ZS5kaW1zWzNdKToobz1lLmRpbXNbM10saT1lLmRpbXNbMl0pO2xldCBhPXQ/LmZvcm1hdCE9PXZvaWQgMD90LmZvcm1hdDpcIlJHQlwiLGQ9dD8ubm9ybSxsLHA7ZD09PXZvaWQgMHx8ZC5tZWFuPT09dm9pZCAwP2w9WzI1NSwyNTUsMjU1LDI1NV06dHlwZW9mIGQubWVhbj09XCJudW1iZXJcIj9sPVtkLm1lYW4sZC5tZWFuLGQubWVhbixkLm1lYW5dOihsPVtkLm1lYW5bMF0sZC5tZWFuWzFdLGQubWVhblsyXSwwXSxkLm1lYW5bM10hPT12b2lkIDAmJihsWzNdPWQubWVhblszXSkpLGQ9PT12b2lkIDB8fGQuYmlhcz09PXZvaWQgMD9wPVswLDAsMCwwXTp0eXBlb2YgZC5iaWFzPT1cIm51bWJlclwiP3A9W2QuYmlhcyxkLmJpYXMsZC5iaWFzLGQuYmlhc106KHA9W2QuYmlhc1swXSxkLmJpYXNbMV0sZC5iaWFzWzJdLDBdLGQuYmlhc1szXSE9PXZvaWQgMCYmKHBbM109ZC5iaWFzWzNdKSk7bGV0IG09aSpvLHU9MCxoPW0sXz1tKjIseT0tMTthPT09XCJSR0JBXCI/KHU9MCxoPW0sXz1tKjIseT1tKjMpOmE9PT1cIlJHQlwiPyh1PTAsaD1tLF89bSoyKTphPT09XCJSQkdcIiYmKHU9MCxfPW0saD1tKjIpO2ZvcihsZXQgZz0wO2c8aTtnKyspZm9yKGxldCB4PTA7eDxvO3grKyl7bGV0ICQ9KGUuZGF0YVt1KytdLXBbMF0pKmxbMF0sdj0oZS5kYXRhW2grK10tcFsxXSkqbFsxXSxTPShlLmRhdGFbXysrXS1wWzJdKSpsWzJdLFQ9eT09PS0xPzI1NTooZS5kYXRhW3krK10tcFszXSkqbFszXTtuLmZpbGxTdHlsZT1cInJnYmEoXCIrJCtcIixcIit2K1wiLFwiK1MrXCIsXCIrVCtcIilcIixuLmZpbGxSZWN0KHgsZywxLDEpfWlmKFwidG9EYXRhVVJMXCJpbiByKXJldHVybiByLnRvRGF0YVVSTCgpO3Rocm93IG5ldyBFcnJvcihcInRvRGF0YVVSTCBpcyBub3Qgc3VwcG9ydGVkXCIpfWVsc2UgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YVwiKX0sYWE9KGUsdCk9PntsZXQgcj10eXBlb2YgZG9jdW1lbnQ8XCJ1XCI/ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKS5nZXRDb250ZXh0KFwiMmRcIik6bmV3IE9mZnNjcmVlbkNhbnZhcygxLDEpLmdldENvbnRleHQoXCIyZFwiKSxuO2lmKHIhPW51bGwpe2xldCBvLGksYTt0Py50ZW5zb3JMYXlvdXQhPT12b2lkIDAmJnQudGVuc29yTGF5b3V0PT09XCJOSFdDXCI/KG89ZS5kaW1zWzJdLGk9ZS5kaW1zWzFdLGE9ZS5kaW1zWzNdKToobz1lLmRpbXNbM10saT1lLmRpbXNbMl0sYT1lLmRpbXNbMV0pO2xldCBkPXQhPT12b2lkIDAmJnQuZm9ybWF0IT09dm9pZCAwP3QuZm9ybWF0OlwiUkdCXCIsbD10Py5ub3JtLHAsbTtsPT09dm9pZCAwfHxsLm1lYW49PT12b2lkIDA/cD1bMjU1LDI1NSwyNTUsMjU1XTp0eXBlb2YgbC5tZWFuPT1cIm51bWJlclwiP3A9W2wubWVhbixsLm1lYW4sbC5tZWFuLGwubWVhbl06KHA9W2wubWVhblswXSxsLm1lYW5bMV0sbC5tZWFuWzJdLDI1NV0sbC5tZWFuWzNdIT09dm9pZCAwJiYocFszXT1sLm1lYW5bM10pKSxsPT09dm9pZCAwfHxsLmJpYXM9PT12b2lkIDA/bT1bMCwwLDAsMF06dHlwZW9mIGwuYmlhcz09XCJudW1iZXJcIj9tPVtsLmJpYXMsbC5iaWFzLGwuYmlhcyxsLmJpYXNdOihtPVtsLmJpYXNbMF0sbC5iaWFzWzFdLGwuYmlhc1syXSwwXSxsLmJpYXNbM10hPT12b2lkIDAmJihtWzNdPWwuYmlhc1szXSkpO2xldCB1PWkqbztpZih0IT09dm9pZCAwJiYodC5mb3JtYXQhPT12b2lkIDAmJmE9PT00JiZ0LmZvcm1hdCE9PVwiUkdCQVwifHxhPT09MyYmdC5mb3JtYXQhPT1cIlJHQlwiJiZ0LmZvcm1hdCE9PVwiQkdSXCIpKXRocm93IG5ldyBFcnJvcihcIlRlbnNvciBmb3JtYXQgZG9lc24ndCBtYXRjaCBpbnB1dCB0ZW5zb3IgZGltc1wiKTtsZXQgaD00LF89MCx5PTEsZz0yLHg9MywkPTAsdj11LFM9dSoyLFQ9LTE7ZD09PVwiUkdCQVwiPygkPTAsdj11LFM9dSoyLFQ9dSozKTpkPT09XCJSR0JcIj8oJD0wLHY9dSxTPXUqMik6ZD09PVwiUkJHXCImJigkPTAsUz11LHY9dSoyKSxuPXIuY3JlYXRlSW1hZ2VEYXRhKG8saSk7Zm9yKGxldCBBPTA7QTxpKm87Xys9aCx5Kz1oLGcrPWgseCs9aCxBKyspbi5kYXRhW19dPShlLmRhdGFbJCsrXS1tWzBdKSpwWzBdLG4uZGF0YVt5XT0oZS5kYXRhW3YrK10tbVsxXSkqcFsxXSxuLmRhdGFbZ109KGUuZGF0YVtTKytdLW1bMl0pKnBbMl0sbi5kYXRhW3hdPVQ9PT0tMT8yNTU6KGUuZGF0YVtUKytdLW1bM10pKnBbM119ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhXCIpO3JldHVybiBufX0pO3ZhciBMbix1YSxkYSxsYSxjYSxwYSxtYT1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7X3IoKTtMbj0oZSx0KT0+e2lmKGU9PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiSW1hZ2UgYnVmZmVyIG11c3QgYmUgZGVmaW5lZFwiKTtpZih0LmhlaWdodD09PXZvaWQgMHx8dC53aWR0aD09PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJJbWFnZSBoZWlnaHQgYW5kIHdpZHRoIG11c3QgYmUgZGVmaW5lZFwiKTtpZih0LnRlbnNvckxheW91dD09PVwiTkhXQ1wiKXRocm93IG5ldyBFcnJvcihcIk5IV0MgVGVuc29yIGxheW91dCBpcyBub3Qgc3VwcG9ydGVkIHlldFwiKTtsZXR7aGVpZ2h0OnIsd2lkdGg6bn09dCxvPXQubm9ybT8/e21lYW46MjU1LGJpYXM6MH0saSxhO3R5cGVvZiBvLm1lYW49PVwibnVtYmVyXCI/aT1bby5tZWFuLG8ubWVhbixvLm1lYW4sby5tZWFuXTppPVtvLm1lYW5bMF0sby5tZWFuWzFdLG8ubWVhblsyXSxvLm1lYW5bM10/PzI1NV0sdHlwZW9mIG8uYmlhcz09XCJudW1iZXJcIj9hPVtvLmJpYXMsby5iaWFzLG8uYmlhcyxvLmJpYXNdOmE9W28uYmlhc1swXSxvLmJpYXNbMV0sby5iaWFzWzJdLG8uYmlhc1szXT8/MF07bGV0IGQ9dC5mb3JtYXQhPT12b2lkIDA/dC5mb3JtYXQ6XCJSR0JBXCIsbD10LnRlbnNvckZvcm1hdCE9PXZvaWQgMCYmdC50ZW5zb3JGb3JtYXQhPT12b2lkIDA/dC50ZW5zb3JGb3JtYXQ6XCJSR0JcIixwPXIqbixtPWw9PT1cIlJHQkFcIj9uZXcgRmxvYXQzMkFycmF5KHAqNCk6bmV3IEZsb2F0MzJBcnJheShwKjMpLHU9NCxoPTAsXz0xLHk9MixnPTMseD0wLCQ9cCx2PXAqMixTPS0xO2Q9PT1cIlJHQlwiJiYodT0zLGg9MCxfPTEseT0yLGc9LTEpLGw9PT1cIlJHQkFcIj9TPXAqMzpsPT09XCJSQkdcIj8oeD0wLHY9cCwkPXAqMik6bD09PVwiQkdSXCImJih2PTAsJD1wLHg9cCoyKTtmb3IobGV0IEE9MDtBPHA7QSsrLGgrPXUseSs9dSxfKz11LGcrPXUpbVt4KytdPShlW2hdK2FbMF0pL2lbMF0sbVskKytdPShlW19dK2FbMV0pL2lbMV0sbVt2KytdPShlW3ldK2FbMl0pL2lbMl0sUyE9PS0xJiZnIT09LTEmJihtW1MrK109KGVbZ10rYVszXSkvaVszXSk7cmV0dXJuIGw9PT1cIlJHQkFcIj9uZXcgemUoXCJmbG9hdDMyXCIsbSxbMSw0LHIsbl0pOm5ldyB6ZShcImZsb2F0MzJcIixtLFsxLDMscixuXSl9LHVhPWFzeW5jKGUsdCk9PntsZXQgcj10eXBlb2YgSFRNTEltYWdlRWxlbWVudDxcInVcIiYmZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQsbj10eXBlb2YgSW1hZ2VEYXRhPFwidVwiJiZlIGluc3RhbmNlb2YgSW1hZ2VEYXRhLG89dHlwZW9mIEltYWdlQml0bWFwPFwidVwiJiZlIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXAsaT10eXBlb2YgZT09XCJzdHJpbmdcIixhLGQ9dD8/e30sbD0oKT0+e2lmKHR5cGVvZiBkb2N1bWVudDxcInVcIilyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtpZih0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzPFwidVwiKXJldHVybiBuZXcgT2Zmc2NyZWVuQ2FudmFzKDEsMSk7dGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIGlzIG5vdCBzdXBwb3J0ZWRcIil9LHA9bT0+dHlwZW9mIEhUTUxDYW52YXNFbGVtZW50PFwidVwiJiZtIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnR8fG0gaW5zdGFuY2VvZiBPZmZzY3JlZW5DYW52YXM/bS5nZXRDb250ZXh0KFwiMmRcIik6bnVsbDtpZihyKXtsZXQgbT1sKCk7bS53aWR0aD1lLndpZHRoLG0uaGVpZ2h0PWUuaGVpZ2h0O2xldCB1PXAobSk7aWYodSE9bnVsbCl7bGV0IGg9ZS5oZWlnaHQsXz1lLndpZHRoO2lmKHQhPT12b2lkIDAmJnQucmVzaXplZEhlaWdodCE9PXZvaWQgMCYmdC5yZXNpemVkV2lkdGghPT12b2lkIDAmJihoPXQucmVzaXplZEhlaWdodCxfPXQucmVzaXplZFdpZHRoKSx0IT09dm9pZCAwKXtpZihkPXQsdC50ZW5zb3JGb3JtYXQhPT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiSW1hZ2UgaW5wdXQgY29uZmlnIGZvcm1hdCBtdXN0IGJlIFJHQkEgZm9yIEhUTUxJbWFnZUVsZW1lbnRcIik7ZC50ZW5zb3JGb3JtYXQ9XCJSR0JBXCIsZC5oZWlnaHQ9aCxkLndpZHRoPV99ZWxzZSBkLnRlbnNvckZvcm1hdD1cIlJHQkFcIixkLmhlaWdodD1oLGQud2lkdGg9Xzt1LmRyYXdJbWFnZShlLDAsMCksYT11LmdldEltYWdlRGF0YSgwLDAsXyxoKS5kYXRhfWVsc2UgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YVwiKX1lbHNlIGlmKG4pe2xldCBtLHU7aWYodCE9PXZvaWQgMCYmdC5yZXNpemVkV2lkdGghPT12b2lkIDAmJnQucmVzaXplZEhlaWdodCE9PXZvaWQgMD8obT10LnJlc2l6ZWRIZWlnaHQsdT10LnJlc2l6ZWRXaWR0aCk6KG09ZS5oZWlnaHQsdT1lLndpZHRoKSx0IT09dm9pZCAwJiYoZD10KSxkLmZvcm1hdD1cIlJHQkFcIixkLmhlaWdodD1tLGQud2lkdGg9dSx0IT09dm9pZCAwKXtsZXQgaD1sKCk7aC53aWR0aD11LGguaGVpZ2h0PW07bGV0IF89cChoKTtpZihfIT1udWxsKV8ucHV0SW1hZ2VEYXRhKGUsMCwwKSxhPV8uZ2V0SW1hZ2VEYXRhKDAsMCx1LG0pLmRhdGE7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhXCIpfWVsc2UgYT1lLmRhdGF9ZWxzZSBpZihvKXtpZih0PT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIlBsZWFzZSBwcm92aWRlIGltYWdlIGNvbmZpZyB3aXRoIGZvcm1hdCBmb3IgSW1hZ2ViaXRtYXBcIik7bGV0IG09bCgpO20ud2lkdGg9ZS53aWR0aCxtLmhlaWdodD1lLmhlaWdodDtsZXQgdT1wKG0pO2lmKHUhPW51bGwpe2xldCBoPWUuaGVpZ2h0LF89ZS53aWR0aDtyZXR1cm4gdS5kcmF3SW1hZ2UoZSwwLDAsXyxoKSxhPXUuZ2V0SW1hZ2VEYXRhKDAsMCxfLGgpLmRhdGEsZC5oZWlnaHQ9aCxkLndpZHRoPV8sTG4oYSxkKX1lbHNlIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgYWNjZXNzIGltYWdlIGRhdGFcIil9ZWxzZXtpZihpKXJldHVybiBuZXcgUHJvbWlzZSgobSx1KT0+e2xldCBoPWwoKSxfPXAoaCk7aWYoIWV8fCFfKXJldHVybiB1KCk7bGV0IHk9bmV3IEltYWdlO3kuY3Jvc3NPcmlnaW49XCJBbm9ueW1vdXNcIix5LnNyYz1lLHkub25sb2FkPSgpPT57aC53aWR0aD15LndpZHRoLGguaGVpZ2h0PXkuaGVpZ2h0LF8uZHJhd0ltYWdlKHksMCwwLGgud2lkdGgsaC5oZWlnaHQpO2xldCBnPV8uZ2V0SW1hZ2VEYXRhKDAsMCxoLndpZHRoLGguaGVpZ2h0KTtkLmhlaWdodD1oLmhlaWdodCxkLndpZHRoPWgud2lkdGgsbShMbihnLmRhdGEsZCkpfX0pO3Rocm93IG5ldyBFcnJvcihcIklucHV0IGRhdGEgcHJvdmlkZWQgaXMgbm90IHN1cHBvcnRlZCAtIGFib3J0ZWQgdGVuc29yIGNyZWF0aW9uXCIpfWlmKGEhPT12b2lkIDApcmV0dXJuIExuKGEsZCk7dGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgZGF0YSBwcm92aWRlZCBpcyBub3Qgc3VwcG9ydGVkIC0gYWJvcnRlZCB0ZW5zb3IgY3JlYXRpb25cIil9LGRhPShlLHQpPT57bGV0e3dpZHRoOnIsaGVpZ2h0Om4sZG93bmxvYWQ6byxkaXNwb3NlOml9PXQsYT1bMSxuLHIsNF07cmV0dXJuIG5ldyB6ZSh7bG9jYXRpb246XCJ0ZXh0dXJlXCIsdHlwZTpcImZsb2F0MzJcIix0ZXh0dXJlOmUsZGltczphLGRvd25sb2FkOm8sZGlzcG9zZTppfSl9LGxhPShlLHQpPT57bGV0e2RhdGFUeXBlOnIsZGltczpuLGRvd25sb2FkOm8sZGlzcG9zZTppfT10O3JldHVybiBuZXcgemUoe2xvY2F0aW9uOlwiZ3B1LWJ1ZmZlclwiLHR5cGU6cj8/XCJmbG9hdDMyXCIsZ3B1QnVmZmVyOmUsZGltczpuLGRvd25sb2FkOm8sZGlzcG9zZTppfSl9LGNhPShlLHQpPT57bGV0e2RhdGFUeXBlOnIsZGltczpuLGRvd25sb2FkOm8sZGlzcG9zZTppfT10O3JldHVybiBuZXcgemUoe2xvY2F0aW9uOlwibWwtdGVuc29yXCIsdHlwZTpyPz9cImZsb2F0MzJcIixtbFRlbnNvcjplLGRpbXM6bixkb3dubG9hZDpvLGRpc3Bvc2U6aX0pfSxwYT0oZSx0LHIpPT5uZXcgemUoe2xvY2F0aW9uOlwiY3B1LXBpbm5lZFwiLHR5cGU6ZSxkYXRhOnQsZGltczpyPz9bdC5sZW5ndGhdfSl9KTt2YXIgVHQscXQsZmEsaGEsZ2E9VSgoKT0+e1widXNlIHN0cmljdFwiO1R0PW5ldyBNYXAoW1tcImZsb2F0MzJcIixGbG9hdDMyQXJyYXldLFtcInVpbnQ4XCIsVWludDhBcnJheV0sW1wiaW50OFwiLEludDhBcnJheV0sW1widWludDE2XCIsVWludDE2QXJyYXldLFtcImludDE2XCIsSW50MTZBcnJheV0sW1wiaW50MzJcIixJbnQzMkFycmF5XSxbXCJib29sXCIsVWludDhBcnJheV0sW1wiZmxvYXQ2NFwiLEZsb2F0NjRBcnJheV0sW1widWludDMyXCIsVWludDMyQXJyYXldLFtcImludDRcIixVaW50OEFycmF5XSxbXCJ1aW50NFwiLFVpbnQ4QXJyYXldXSkscXQ9bmV3IE1hcChbW0Zsb2F0MzJBcnJheSxcImZsb2F0MzJcIl0sW1VpbnQ4QXJyYXksXCJ1aW50OFwiXSxbSW50OEFycmF5LFwiaW50OFwiXSxbVWludDE2QXJyYXksXCJ1aW50MTZcIl0sW0ludDE2QXJyYXksXCJpbnQxNlwiXSxbSW50MzJBcnJheSxcImludDMyXCJdLFtGbG9hdDY0QXJyYXksXCJmbG9hdDY0XCJdLFtVaW50MzJBcnJheSxcInVpbnQzMlwiXV0pLGZhPSExLGhhPSgpPT57aWYoIWZhKXtmYT0hMDtsZXQgZT10eXBlb2YgQmlnSW50NjRBcnJheTxcInVcIiYmQmlnSW50NjRBcnJheS5mcm9tLHQ9dHlwZW9mIEJpZ1VpbnQ2NEFycmF5PFwidVwiJiZCaWdVaW50NjRBcnJheS5mcm9tLHI9dHlwZW9mIEZsb2F0MTZBcnJheTxcInVcIiYmRmxvYXQxNkFycmF5LmZyb207ZSYmKFR0LnNldChcImludDY0XCIsQmlnSW50NjRBcnJheSkscXQuc2V0KEJpZ0ludDY0QXJyYXksXCJpbnQ2NFwiKSksdCYmKFR0LnNldChcInVpbnQ2NFwiLEJpZ1VpbnQ2NEFycmF5KSxxdC5zZXQoQmlnVWludDY0QXJyYXksXCJ1aW50NjRcIikpLHI/KFR0LnNldChcImZsb2F0MTZcIixGbG9hdDE2QXJyYXkpLHF0LnNldChGbG9hdDE2QXJyYXksXCJmbG9hdDE2XCIpKTpUdC5zZXQoXCJmbG9hdDE2XCIsVWludDE2QXJyYXkpfX19KTt2YXIgYmEseWEsX2E9VSgoKT0+e1widXNlIHN0cmljdFwiO19yKCk7YmE9ZT0+e2xldCB0PTE7Zm9yKGxldCByPTA7cjxlLmxlbmd0aDtyKyspe2xldCBuPWVbcl07aWYodHlwZW9mIG4hPVwibnVtYmVyXCJ8fCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSl0aHJvdyBuZXcgVHlwZUVycm9yKGBkaW1zWyR7cn1dIG11c3QgYmUgYW4gaW50ZWdlciwgZ290OiAke259YCk7aWYobjwwKXRocm93IG5ldyBSYW5nZUVycm9yKGBkaW1zWyR7cn1dIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlciwgZ290OiAke259YCk7dCo9bn1yZXR1cm4gdH0seWE9KGUsdCk9Pntzd2l0Y2goZS5sb2NhdGlvbil7Y2FzZVwiY3B1XCI6cmV0dXJuIG5ldyB6ZShlLnR5cGUsZS5kYXRhLHQpO2Nhc2VcImNwdS1waW5uZWRcIjpyZXR1cm4gbmV3IHplKHtsb2NhdGlvbjpcImNwdS1waW5uZWRcIixkYXRhOmUuZGF0YSx0eXBlOmUudHlwZSxkaW1zOnR9KTtjYXNlXCJ0ZXh0dXJlXCI6cmV0dXJuIG5ldyB6ZSh7bG9jYXRpb246XCJ0ZXh0dXJlXCIsdGV4dHVyZTplLnRleHR1cmUsdHlwZTplLnR5cGUsZGltczp0fSk7Y2FzZVwiZ3B1LWJ1ZmZlclwiOnJldHVybiBuZXcgemUoe2xvY2F0aW9uOlwiZ3B1LWJ1ZmZlclwiLGdwdUJ1ZmZlcjplLmdwdUJ1ZmZlcix0eXBlOmUudHlwZSxkaW1zOnR9KTtjYXNlXCJtbC10ZW5zb3JcIjpyZXR1cm4gbmV3IHplKHtsb2NhdGlvbjpcIm1sLXRlbnNvclwiLG1sVGVuc29yOmUubWxUZW5zb3IsdHlwZTplLnR5cGUsZGltczp0fSk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHRlbnNvclJlc2hhcGU6IHRlbnNvciBsb2NhdGlvbiAke2UubG9jYXRpb259IGlzIG5vdCBzdXBwb3J0ZWRgKX19fSk7dmFyIHplLF9yPVUoKCk9PntcInVzZSBzdHJpY3RcIjtzYSgpO21hKCk7Z2EoKTtfYSgpO3plPWNsYXNze2NvbnN0cnVjdG9yKHQscixuKXtoYSgpO2xldCBvLGk7aWYodHlwZW9mIHQ9PVwib2JqZWN0XCImJlwibG9jYXRpb25cImluIHQpc3dpdGNoKHRoaXMuZGF0YUxvY2F0aW9uPXQubG9jYXRpb24sbz10LnR5cGUsaT10LmRpbXMsdC5sb2NhdGlvbil7Y2FzZVwiY3B1LXBpbm5lZFwiOntsZXQgZD1UdC5nZXQobyk7aWYoIWQpdGhyb3cgbmV3IFR5cGVFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZSBcIiR7b31cIiB0byBjcmVhdGUgdGVuc29yIGZyb20gcGlubmVkIGJ1ZmZlcmApO2lmKCEodC5kYXRhIGluc3RhbmNlb2YgZCkpdGhyb3cgbmV3IFR5cGVFcnJvcihgYnVmZmVyIHNob3VsZCBiZSBvZiB0eXBlICR7ZC5uYW1lfWApO3RoaXMuY3B1RGF0YT10LmRhdGE7YnJlYWt9Y2FzZVwidGV4dHVyZVwiOntpZihvIT09XCJmbG9hdDMyXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZSBcIiR7b31cIiB0byBjcmVhdGUgdGVuc29yIGZyb20gdGV4dHVyZWApO3RoaXMuZ3B1VGV4dHVyZURhdGE9dC50ZXh0dXJlLHRoaXMuZG93bmxvYWRlcj10LmRvd25sb2FkLHRoaXMuZGlzcG9zZXI9dC5kaXNwb3NlO2JyZWFrfWNhc2VcImdwdS1idWZmZXJcIjp7aWYobyE9PVwiZmxvYXQzMlwiJiZvIT09XCJmbG9hdDE2XCImJm8hPT1cImludDMyXCImJm8hPT1cImludDY0XCImJm8hPT1cInVpbnQzMlwiJiZvIT09XCJ1aW50OFwiJiZvIT09XCJib29sXCImJm8hPT1cInVpbnQ0XCImJm8hPT1cImludDRcIil0aHJvdyBuZXcgVHlwZUVycm9yKGB1bnN1cHBvcnRlZCB0eXBlIFwiJHtvfVwiIHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbSBncHUgYnVmZmVyYCk7dGhpcy5ncHVCdWZmZXJEYXRhPXQuZ3B1QnVmZmVyLHRoaXMuZG93bmxvYWRlcj10LmRvd25sb2FkLHRoaXMuZGlzcG9zZXI9dC5kaXNwb3NlO2JyZWFrfWNhc2VcIm1sLXRlbnNvclwiOntpZihvIT09XCJmbG9hdDMyXCImJm8hPT1cImZsb2F0MTZcIiYmbyE9PVwiaW50MzJcIiYmbyE9PVwiaW50NjRcIiYmbyE9PVwidWludDMyXCImJm8hPT1cInVpbnQ2NFwiJiZvIT09XCJpbnQ4XCImJm8hPT1cInVpbnQ4XCImJm8hPT1cImJvb2xcIiYmbyE9PVwidWludDRcIiYmbyE9PVwiaW50NFwiKXRocm93IG5ldyBUeXBlRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGUgXCIke299XCIgdG8gY3JlYXRlIHRlbnNvciBmcm9tIE1MVGVuc29yYCk7dGhpcy5tbFRlbnNvckRhdGE9dC5tbFRlbnNvcix0aGlzLmRvd25sb2FkZXI9dC5kb3dubG9hZCx0aGlzLmRpc3Bvc2VyPXQuZGlzcG9zZTticmVha31kZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVGVuc29yIGNvbnN0cnVjdG9yOiB1bnN1cHBvcnRlZCBsb2NhdGlvbiAnJHt0aGlzLmRhdGFMb2NhdGlvbn0nYCl9ZWxzZXtsZXQgZCxsO2lmKHR5cGVvZiB0PT1cInN0cmluZ1wiKWlmKG89dCxsPW4sdD09PVwic3RyaW5nXCIpe2lmKCFBcnJheS5pc0FycmF5KHIpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJBIHN0cmluZyB0ZW5zb3IncyBkYXRhIG11c3QgYmUgYSBzdHJpbmcgYXJyYXkuXCIpO2Q9cn1lbHNle2xldCBwPVR0LmdldCh0KTtpZihwPT09dm9pZCAwKXRocm93IG5ldyBUeXBlRXJyb3IoYFVuc3VwcG9ydGVkIHRlbnNvciB0eXBlOiAke3R9LmApO2lmKEFycmF5LmlzQXJyYXkocikpe2lmKHQ9PT1cImZsb2F0MTZcIiYmcD09PVVpbnQxNkFycmF5fHx0PT09XCJ1aW50NFwifHx0PT09XCJpbnQ0XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihgQ3JlYXRpbmcgYSAke3R9IHRlbnNvciBmcm9tIG51bWJlciBhcnJheSBpcyBub3Qgc3VwcG9ydGVkLiBQbGVhc2UgdXNlICR7cC5uYW1lfSBhcyBkYXRhLmApO3Q9PT1cInVpbnQ2NFwifHx0PT09XCJpbnQ2NFwiP2Q9cC5mcm9tKHIsQmlnSW50KTpkPXAuZnJvbShyKX1lbHNlIGlmKHIgaW5zdGFuY2VvZiBwKWQ9cjtlbHNlIGlmKHIgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSlpZih0PT09XCJ1aW50OFwiKWQ9VWludDhBcnJheS5mcm9tKHIpO2Vsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkEgVWludDhDbGFtcGVkQXJyYXkgdGVuc29yJ3MgZGF0YSBtdXN0IGJlIHR5cGUgb2YgdWludDhcIik7ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKGBBICR7b30gdGVuc29yJ3MgZGF0YSBtdXN0IGJlIHR5cGUgb2YgJHtwfWApfWVsc2UgaWYobD1yLEFycmF5LmlzQXJyYXkodCkpe2lmKHQubGVuZ3RoPT09MCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGVuc29yIHR5cGUgY2Fubm90IGJlIGluZmVycmVkIGZyb20gYW4gZW1wdHkgYXJyYXkuXCIpO2xldCBwPXR5cGVvZiB0WzBdO2lmKHA9PT1cInN0cmluZ1wiKW89XCJzdHJpbmdcIixkPXQ7ZWxzZSBpZihwPT09XCJib29sZWFuXCIpbz1cImJvb2xcIixkPVVpbnQ4QXJyYXkuZnJvbSh0KTtlbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgZWxlbWVudCB0eXBlIG9mIGRhdGEgYXJyYXk6ICR7cH0uYCl9ZWxzZSBpZih0IGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkpbz1cInVpbnQ4XCIsZD1VaW50OEFycmF5LmZyb20odCk7ZWxzZXtsZXQgcD1xdC5nZXQodC5jb25zdHJ1Y3Rvcik7aWYocD09PXZvaWQgMCl0aHJvdyBuZXcgVHlwZUVycm9yKGBVbnN1cHBvcnRlZCB0eXBlIGZvciB0ZW5zb3IgZGF0YTogJHt0LmNvbnN0cnVjdG9yfS5gKTtvPXAsZD10fWlmKGw9PT12b2lkIDApbD1bZC5sZW5ndGhdO2Vsc2UgaWYoIUFycmF5LmlzQXJyYXkobCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkEgdGVuc29yJ3MgZGltcyBtdXN0IGJlIGEgbnVtYmVyIGFycmF5XCIpO2k9bCx0aGlzLmNwdURhdGE9ZCx0aGlzLmRhdGFMb2NhdGlvbj1cImNwdVwifWxldCBhPWJhKGkpO2lmKHRoaXMuY3B1RGF0YSYmYSE9PXRoaXMuY3B1RGF0YS5sZW5ndGgmJiEoKG89PT1cInVpbnQ0XCJ8fG89PT1cImludDRcIikmJk1hdGguY2VpbChhLzIpPT09dGhpcy5jcHVEYXRhLmxlbmd0aCkpdGhyb3cgbmV3IEVycm9yKGBUZW5zb3IncyBzaXplKCR7YX0pIGRvZXMgbm90IG1hdGNoIGRhdGEgbGVuZ3RoKCR7dGhpcy5jcHVEYXRhLmxlbmd0aH0pLmApO3RoaXMudHlwZT1vLHRoaXMuZGltcz1pLHRoaXMuc2l6ZT1hfXN0YXRpYyBhc3luYyBmcm9tSW1hZ2UodCxyKXtyZXR1cm4gdWEodCxyKX1zdGF0aWMgZnJvbVRleHR1cmUodCxyKXtyZXR1cm4gZGEodCxyKX1zdGF0aWMgZnJvbUdwdUJ1ZmZlcih0LHIpe3JldHVybiBsYSh0LHIpfXN0YXRpYyBmcm9tTUxUZW5zb3IodCxyKXtyZXR1cm4gY2EodCxyKX1zdGF0aWMgZnJvbVBpbm5lZEJ1ZmZlcih0LHIsbil7cmV0dXJuIHBhKHQscixuKX10b0RhdGFVUkwodCl7cmV0dXJuIGlhKHRoaXMsdCl9dG9JbWFnZURhdGEodCl7cmV0dXJuIGFhKHRoaXMsdCl9Z2V0IGRhdGEoKXtpZih0aGlzLmVuc3VyZVZhbGlkKCksIXRoaXMuY3B1RGF0YSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZGF0YSBpcyBub3Qgb24gQ1BVLiBVc2UgYGdldERhdGEoKWAgdG8gZG93bmxvYWQgR1BVIGRhdGEgdG8gQ1BVLCBvciB1c2UgYHRleHR1cmVgIG9yIGBncHVCdWZmZXJgIHByb3BlcnR5IHRvIGFjY2VzcyB0aGUgR1BVIGRhdGEgZGlyZWN0bHkuXCIpO3JldHVybiB0aGlzLmNwdURhdGF9Z2V0IGxvY2F0aW9uKCl7cmV0dXJuIHRoaXMuZGF0YUxvY2F0aW9ufWdldCB0ZXh0dXJlKCl7aWYodGhpcy5lbnN1cmVWYWxpZCgpLCF0aGlzLmdwdVRleHR1cmVEYXRhKXRocm93IG5ldyBFcnJvcihcIlRoZSBkYXRhIGlzIG5vdCBzdG9yZWQgYXMgYSBXZWJHTCB0ZXh0dXJlLlwiKTtyZXR1cm4gdGhpcy5ncHVUZXh0dXJlRGF0YX1nZXQgZ3B1QnVmZmVyKCl7aWYodGhpcy5lbnN1cmVWYWxpZCgpLCF0aGlzLmdwdUJ1ZmZlckRhdGEpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGRhdGEgaXMgbm90IHN0b3JlZCBhcyBhIFdlYkdQVSBidWZmZXIuXCIpO3JldHVybiB0aGlzLmdwdUJ1ZmZlckRhdGF9Z2V0IG1sVGVuc29yKCl7aWYodGhpcy5lbnN1cmVWYWxpZCgpLCF0aGlzLm1sVGVuc29yRGF0YSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZGF0YSBpcyBub3Qgc3RvcmVkIGFzIGEgV2ViTk4gTUxUZW5zb3IuXCIpO3JldHVybiB0aGlzLm1sVGVuc29yRGF0YX1hc3luYyBnZXREYXRhKHQpe3N3aXRjaCh0aGlzLmVuc3VyZVZhbGlkKCksdGhpcy5kYXRhTG9jYXRpb24pe2Nhc2VcImNwdVwiOmNhc2VcImNwdS1waW5uZWRcIjpyZXR1cm4gdGhpcy5kYXRhO2Nhc2VcInRleHR1cmVcIjpjYXNlXCJncHUtYnVmZmVyXCI6Y2FzZVwibWwtdGVuc29yXCI6e2lmKCF0aGlzLmRvd25sb2FkZXIpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGN1cnJlbnQgdGVuc29yIGlzIG5vdCBjcmVhdGVkIHdpdGggYSBzcGVjaWZpZWQgZGF0YSBkb3dubG9hZGVyLlwiKTtpZih0aGlzLmlzRG93bmxvYWRpbmcpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGN1cnJlbnQgdGVuc29yIGlzIGJlaW5nIGRvd25sb2FkZWQuXCIpO3RyeXt0aGlzLmlzRG93bmxvYWRpbmc9ITA7bGV0IHI9YXdhaXQgdGhpcy5kb3dubG9hZGVyKCk7cmV0dXJuIHRoaXMuZG93bmxvYWRlcj12b2lkIDAsdGhpcy5kYXRhTG9jYXRpb249XCJjcHVcIix0aGlzLmNwdURhdGE9cix0JiZ0aGlzLmRpc3Bvc2VyJiYodGhpcy5kaXNwb3NlcigpLHRoaXMuZGlzcG9zZXI9dm9pZCAwKSxyfWZpbmFsbHl7dGhpcy5pc0Rvd25sb2FkaW5nPSExfX1kZWZhdWx0OnRocm93IG5ldyBFcnJvcihgY2Fubm90IGdldCBkYXRhIGZyb20gbG9jYXRpb246ICR7dGhpcy5kYXRhTG9jYXRpb259YCl9fWRpc3Bvc2UoKXtpZih0aGlzLmlzRG93bmxvYWRpbmcpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGN1cnJlbnQgdGVuc29yIGlzIGJlaW5nIGRvd25sb2FkZWQuXCIpO3RoaXMuZGlzcG9zZXImJih0aGlzLmRpc3Bvc2VyKCksdGhpcy5kaXNwb3Nlcj12b2lkIDApLHRoaXMuY3B1RGF0YT12b2lkIDAsdGhpcy5ncHVUZXh0dXJlRGF0YT12b2lkIDAsdGhpcy5ncHVCdWZmZXJEYXRhPXZvaWQgMCx0aGlzLm1sVGVuc29yRGF0YT12b2lkIDAsdGhpcy5kb3dubG9hZGVyPXZvaWQgMCx0aGlzLmlzRG93bmxvYWRpbmc9dm9pZCAwLHRoaXMuZGF0YUxvY2F0aW9uPVwibm9uZVwifWVuc3VyZVZhbGlkKCl7aWYodGhpcy5kYXRhTG9jYXRpb249PT1cIm5vbmVcIil0aHJvdyBuZXcgRXJyb3IoXCJUaGUgdGVuc29yIGlzIGRpc3Bvc2VkLlwiKX1yZXNoYXBlKHQpe2lmKHRoaXMuZW5zdXJlVmFsaWQoKSx0aGlzLmRvd25sb2FkZXJ8fHRoaXMuZGlzcG9zZXIpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlc2hhcGUgYSB0ZW5zb3IgdGhhdCBvd25zIEdQVSByZXNvdXJjZS5cIik7cmV0dXJuIHlhKHRoaXMsdCl9fX0pO3ZhciBIZSxHbj1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7X3IoKTtIZT16ZX0pO3ZhciB3cix3YSxVZSxEZSxIbj1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7V24oKTt3cj0oZSx0KT0+eyh0eXBlb2YgUmUudHJhY2U+XCJ1XCI/IVJlLndhc20udHJhY2U6IVJlLnRyYWNlKXx8Y29uc29sZS50aW1lU3RhbXAoYCR7ZX06Ok9SVDo6JHt0fWApfSx3YT0oZSx0KT0+e2xldCByPW5ldyBFcnJvcigpLnN0YWNrPy5zcGxpdCgvXFxyXFxufFxccnxcXG4vZyl8fFtdLG49ITE7Zm9yKGxldCBvPTA7bzxyLmxlbmd0aDtvKyspe2lmKG4mJiFyW29dLmluY2x1ZGVzKFwiVFJBQ0VfRlVOQ1wiKSl7bGV0IGk9YEZVTkNfJHtlfTo6JHtyW29dLnRyaW0oKS5zcGxpdChcIiBcIilbMV19YDt0JiYoaSs9YDo6JHt0fWApLHdyKFwiQ1BVXCIsaSk7cmV0dXJufXJbb10uaW5jbHVkZXMoXCJUUkFDRV9GVU5DXCIpJiYobj0hMCl9fSxVZT1lPT57KHR5cGVvZiBSZS50cmFjZT5cInVcIj8hUmUud2FzbS50cmFjZTohUmUudHJhY2UpfHx3YShcIkJFR0lOXCIsZSl9LERlPWU9PnsodHlwZW9mIFJlLnRyYWNlPlwidVwiPyFSZS53YXNtLnRyYWNlOiFSZS50cmFjZSl8fHdhKFwiRU5EXCIsZSl9fSk7dmFyIHZyLHZhPVUoKCk9PntcInVzZSBzdHJpY3RcIjtWbigpO0duKCk7SG4oKTt2cj1jbGFzcyBle2NvbnN0cnVjdG9yKHQpe3RoaXMuaGFuZGxlcj10fWFzeW5jIHJ1bih0LHIsbil7VWUoKTtsZXQgbz17fSxpPXt9O2lmKHR5cGVvZiB0IT1cIm9iamVjdFwifHx0PT09bnVsbHx8dCBpbnN0YW5jZW9mIEhlfHxBcnJheS5pc0FycmF5KHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCInZmVlZHMnIG11c3QgYmUgYW4gb2JqZWN0IHRoYXQgdXNlIGlucHV0IG5hbWVzIGFzIGtleXMgYW5kIE9ubnhWYWx1ZSBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy5cIik7bGV0IGE9ITA7aWYodHlwZW9mIHI9PVwib2JqZWN0XCIpe2lmKHI9PT1udWxsKXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmV4cGVjdGVkIGFyZ3VtZW50WzFdOiBjYW5ub3QgYmUgbnVsbC5cIik7aWYociBpbnN0YW5jZW9mIEhlKXRocm93IG5ldyBUeXBlRXJyb3IoXCInZmV0Y2hlcycgY2Fubm90IGJlIGEgVGVuc29yXCIpO2lmKEFycmF5LmlzQXJyYXkocikpe2lmKHIubGVuZ3RoPT09MCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2ZldGNoZXMnIGNhbm5vdCBiZSBhbiBlbXB0eSBhcnJheS5cIik7YT0hMTtmb3IobGV0IHAgb2Ygcil7aWYodHlwZW9mIHAhPVwic3RyaW5nXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZXRjaGVzJyBtdXN0IGJlIGEgc3RyaW5nIGFycmF5IG9yIGFuIG9iamVjdC5cIik7aWYodGhpcy5vdXRwdXROYW1lcy5pbmRleE9mKHApPT09LTEpdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCdmZXRjaGVzJyBjb250YWlucyBpbnZhbGlkIG91dHB1dCBuYW1lOiAke3B9LmApO29bcF09bnVsbH1pZih0eXBlb2Ygbj09XCJvYmplY3RcIiYmbiE9PW51bGwpaT1uO2Vsc2UgaWYodHlwZW9mIG48XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIil9ZWxzZXtsZXQgcD0hMSxtPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHIpO2ZvcihsZXQgdSBvZiB0aGlzLm91dHB1dE5hbWVzKWlmKG0uaW5kZXhPZih1KSE9PS0xKXtsZXQgaD1yW3VdOyhoPT09bnVsbHx8aCBpbnN0YW5jZW9mIEhlKSYmKHA9ITAsYT0hMSxvW3VdPWgpfWlmKHApe2lmKHR5cGVvZiBuPT1cIm9iamVjdFwiJiZuIT09bnVsbClpPW47ZWxzZSBpZih0eXBlb2YgbjxcInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKX1lbHNlIGk9cn19ZWxzZSBpZih0eXBlb2YgcjxcInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5leHBlY3RlZCBhcmd1bWVudFsxXTogbXVzdCBiZSAnZmV0Y2hlcycgb3IgJ29wdGlvbnMnLlwiKTtmb3IobGV0IHAgb2YgdGhpcy5pbnB1dE5hbWVzKWlmKHR5cGVvZiB0W3BdPlwidVwiKXRocm93IG5ldyBFcnJvcihgaW5wdXQgJyR7cH0nIGlzIG1pc3NpbmcgaW4gJ2ZlZWRzJy5gKTtpZihhKWZvcihsZXQgcCBvZiB0aGlzLm91dHB1dE5hbWVzKW9bcF09bnVsbDtsZXQgZD1hd2FpdCB0aGlzLmhhbmRsZXIucnVuKHQsbyxpKSxsPXt9O2ZvcihsZXQgcCBpbiBkKWlmKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGQscCkpe2xldCBtPWRbcF07bSBpbnN0YW5jZW9mIEhlP2xbcF09bTpsW3BdPW5ldyBIZShtLnR5cGUsbS5kYXRhLG0uZGltcyl9cmV0dXJuIERlKCksbH1hc3luYyByZWxlYXNlKCl7cmV0dXJuIHRoaXMuaGFuZGxlci5kaXNwb3NlKCl9c3RhdGljIGFzeW5jIGNyZWF0ZSh0LHIsbixvKXtVZSgpO2xldCBpLGE9e307aWYodHlwZW9mIHQ9PVwic3RyaW5nXCIpe2lmKGk9dCx0eXBlb2Ygcj09XCJvYmplY3RcIiYmciE9PW51bGwpYT1yO2Vsc2UgaWYodHlwZW9mIHI8XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIil9ZWxzZSBpZih0IGluc3RhbmNlb2YgVWludDhBcnJheSl7aWYoaT10LHR5cGVvZiByPT1cIm9iamVjdFwiJiZyIT09bnVsbClhPXI7ZWxzZSBpZih0eXBlb2YgcjxcInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKX1lbHNlIGlmKHQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcnx8dHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyPFwidVwiJiZ0IGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXIpe2xldCBtPXQsdT0wLGg9dC5ieXRlTGVuZ3RoO2lmKHR5cGVvZiByPT1cIm9iamVjdFwiJiZyIT09bnVsbClhPXI7ZWxzZSBpZih0eXBlb2Ygcj09XCJudW1iZXJcIil7aWYodT1yLCFOdW1iZXIuaXNTYWZlSW50ZWdlcih1KSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIidieXRlT2Zmc2V0JyBtdXN0IGJlIGFuIGludGVnZXIuXCIpO2lmKHU8MHx8dT49bS5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKGAnYnl0ZU9mZnNldCcgaXMgb3V0IG9mIHJhbmdlIFswLCAke20uYnl0ZUxlbmd0aH0pLmApO2lmKGg9dC5ieXRlTGVuZ3RoLXUsdHlwZW9mIG49PVwibnVtYmVyXCIpe2lmKGg9biwhTnVtYmVyLmlzU2FmZUludGVnZXIoaCkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCInYnl0ZUxlbmd0aCcgbXVzdCBiZSBhbiBpbnRlZ2VyLlwiKTtpZihoPD0wfHx1K2g+bS5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKGAnYnl0ZUxlbmd0aCcgaXMgb3V0IG9mIHJhbmdlICgwLCAke20uYnl0ZUxlbmd0aC11fV0uYCk7aWYodHlwZW9mIG89PVwib2JqZWN0XCImJm8hPT1udWxsKWE9bztlbHNlIGlmKHR5cGVvZiBvPFwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpfWVsc2UgaWYodHlwZW9mIG48XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidieXRlTGVuZ3RoJyBtdXN0IGJlIGEgbnVtYmVyLlwiKX1lbHNlIGlmKHR5cGVvZiByPFwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpO2k9bmV3IFVpbnQ4QXJyYXkobSx1LGgpfWVsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuZXhwZWN0ZWQgYXJndW1lbnRbMF06IG11c3QgYmUgJ3BhdGgnIG9yICdidWZmZXInLlwiKTtsZXRbZCxsXT1hd2FpdCBKaShhKSxwPWF3YWl0IGQuY3JlYXRlSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIoaSxsKTtyZXR1cm4gRGUoKSxuZXcgZShwKX1zdGFydFByb2ZpbGluZygpe3RoaXMuaGFuZGxlci5zdGFydFByb2ZpbGluZygpfWVuZFByb2ZpbGluZygpe3RoaXMuaGFuZGxlci5lbmRQcm9maWxpbmcoKX1nZXQgaW5wdXROYW1lcygpe3JldHVybiB0aGlzLmhhbmRsZXIuaW5wdXROYW1lc31nZXQgb3V0cHV0TmFtZXMoKXtyZXR1cm4gdGhpcy5oYW5kbGVyLm91dHB1dE5hbWVzfX19KTt2YXIgRnAsJGE9VSgoKT0+e1widXNlIHN0cmljdFwiO3ZhKCk7RnA9dnJ9KTt2YXIgeGE9VSgoKT0+e1widXNlIHN0cmljdFwifSk7dmFyIFNhPVUoKCk9PntcInVzZSBzdHJpY3RcIn0pO3ZhciBUYT1VKCgpPT57XCJ1c2Ugc3RyaWN0XCJ9KTt2YXIgSWE9VSgoKT0+e1widXNlIHN0cmljdFwifSk7dmFyIEZuPXt9O0Z0KEZuLHtJbmZlcmVuY2VTZXNzaW9uOigpPT5GcCxUUkFDRTooKT0+d3IsVFJBQ0VfRlVOQ19CRUdJTjooKT0+VWUsVFJBQ0VfRlVOQ19FTkQ6KCk9PkRlLFRlbnNvcjooKT0+SGUsZW52OigpPT52ZSxyZWdpc3RlckJhY2tlbmQ6KCk9PlN0fSk7dmFyIFdlPVUoKCk9PntcInVzZSBzdHJpY3RcIjtlYSgpO29hKCk7JGEoKTtHbigpO3hhKCk7U2EoKTtIbigpO1RhKCk7SWEoKX0pO3ZhciAkcj1VKCgpPT57XCJ1c2Ugc3RyaWN0XCJ9KTt2YXIgRWE9e307RnQoRWEse2RlZmF1bHQ6KCk9PnFwfSk7dmFyIEFhLGthLHFwLFBhPVUoKCk9PntcInVzZSBzdHJpY3RcIjtxbigpO2d0KCk7eHIoKTtBYT1cIm9ydC13YXNtLXByb3h5LXdvcmtlclwiLGthPWdsb2JhbFRoaXMuc2VsZj8ubmFtZT09PUFhO2thJiYoc2VsZi5vbm1lc3NhZ2U9ZT0+e2xldHt0eXBlOnQsaW46cn09ZS5kYXRhO3RyeXtzd2l0Y2godCl7Y2FzZVwiaW5pdC13YXNtXCI6U3Ioci53YXNtKS50aGVuKCgpPT57VHIocikudGhlbigoKT0+e3Bvc3RNZXNzYWdlKHt0eXBlOnR9KX0sbj0+e3Bvc3RNZXNzYWdlKHt0eXBlOnQsZXJyOm59KX0pfSxuPT57cG9zdE1lc3NhZ2Uoe3R5cGU6dCxlcnI6bn0pfSk7YnJlYWs7Y2FzZVwiaW5pdC1lcFwiOntsZXR7ZXBOYW1lOm4sZW52Om99PXI7SXIobyxuKS50aGVuKCgpPT57cG9zdE1lc3NhZ2Uoe3R5cGU6dH0pfSxpPT57cG9zdE1lc3NhZ2Uoe3R5cGU6dCxlcnI6aX0pfSk7YnJlYWt9Y2FzZVwiY29weS1mcm9tXCI6e2xldHtidWZmZXI6bn09cixvPUt0KG4pO3Bvc3RNZXNzYWdlKHt0eXBlOnQsb3V0Om99KTticmVha31jYXNlXCJjcmVhdGVcIjp7bGV0e21vZGVsOm4sb3B0aW9uczpvfT1yO0NyKG4sbykudGhlbihpPT57cG9zdE1lc3NhZ2Uoe3R5cGU6dCxvdXQ6aX0pfSxpPT57cG9zdE1lc3NhZ2Uoe3R5cGU6dCxlcnI6aX0pfSk7YnJlYWt9Y2FzZVwicmVsZWFzZVwiOkFyKHIpLHBvc3RNZXNzYWdlKHt0eXBlOnR9KTticmVhaztjYXNlXCJydW5cIjp7bGV0e3Nlc3Npb25JZDpuLGlucHV0SW5kaWNlczpvLGlucHV0czppLG91dHB1dEluZGljZXM6YSxvcHRpb25zOmR9PXI7a3IobixvLGksYSxuZXcgQXJyYXkoYS5sZW5ndGgpLmZpbGwobnVsbCksZCkudGhlbihsPT57bC5zb21lKHA9PnBbM10hPT1cImNwdVwiKT9wb3N0TWVzc2FnZSh7dHlwZTp0LGVycjpcIlByb3h5IGRvZXMgbm90IHN1cHBvcnQgbm9uLWNwdSB0ZW5zb3IgbG9jYXRpb24uXCJ9KTpwb3N0TWVzc2FnZSh7dHlwZTp0LG91dDpsfSxQcihbLi4uaSwuLi5sXSkpfSxsPT57cG9zdE1lc3NhZ2Uoe3R5cGU6dCxlcnI6bH0pfSk7YnJlYWt9Y2FzZVwiZW5kLXByb2ZpbGluZ1wiOkVyKHIpLHBvc3RNZXNzYWdlKHt0eXBlOnR9KTticmVhaztkZWZhdWx0On19Y2F0Y2gobil7cG9zdE1lc3NhZ2Uoe3R5cGU6dCxlcnI6bn0pfX0pO3FwPWthP251bGw6ZT0+bmV3IFdvcmtlcihlPz9OZSx7dHlwZTpcIm1vZHVsZVwiLG5hbWU6QWF9KX0pO3ZhciBPYT17fTtGdChPYSx7ZGVmYXVsdDooKT0+S3B9KTt2YXIgS24semEsS3AsRGE9VSgoKT0+e1widXNlIHN0cmljdFwiO3phPShLbj1pbXBvcnQubWV0YS51cmwsYXN5bmMgZnVuY3Rpb24oZT17fSl7ZnVuY3Rpb24gdCgpe3JldHVybiBzZS5idWZmZXIhPUouYnVmZmVyJiZ5ZSgpLEp9ZnVuY3Rpb24gcigpe3JldHVybiBzZS5idWZmZXIhPUouYnVmZmVyJiZ5ZSgpLG5lfWZ1bmN0aW9uIG4oKXtyZXR1cm4gc2UuYnVmZmVyIT1KLmJ1ZmZlciYmeWUoKSxiZX1mdW5jdGlvbiBvKCl7cmV0dXJuIHNlLmJ1ZmZlciE9Si5idWZmZXImJnllKCksT2V9ZnVuY3Rpb24gaSgpe3JldHVybiBzZS5idWZmZXIhPUouYnVmZmVyJiZ5ZSgpLCRlfWZ1bmN0aW9uIGEoKXtyZXR1cm4gc2UuYnVmZmVyIT1KLmJ1ZmZlciYmeWUoKSxsZX1mdW5jdGlvbiBkKCl7cmV0dXJuIHNlLmJ1ZmZlciE9Si5idWZmZXImJnllKCksV31mdW5jdGlvbiBsKCl7cmV0dXJuIHNlLmJ1ZmZlciE9Si5idWZmZXImJnllKCksR2V9dmFyIHAsbSx1PU9iamVjdC5hc3NpZ24oe30sZSksaD1uZXcgUHJvbWlzZSgocyxjKT0+e3A9cyxtPWN9KSxfPXR5cGVvZiB3aW5kb3c9PVwib2JqZWN0XCIseT10eXBlb2YgaW1wb3J0U2NyaXB0cz09XCJmdW5jdGlvblwiLGc9eSYmc2VsZi5uYW1lPT1cImVtLXB0aHJlYWRcIjt1Lm1vdW50RXh0ZXJuYWxEYXRhPShzLGMpPT57cy5zdGFydHNXaXRoKFwiLi9cIikmJihzPXMuc3Vic3RyaW5nKDIpKSwodS5GYnx8KHUuRmI9bmV3IE1hcCkpLnNldChzLGMpfSx1LnVubW91bnRFeHRlcm5hbERhdGE9KCk9PntkZWxldGUgdS5GYn07dmFyIHg9Z2xvYmFsVGhpcy5TaGFyZWRBcnJheUJ1ZmZlcj8/bmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7aW5pdGlhbDowLG1heGltdW06MCxzaGFyZWQ6ITB9KS5idWZmZXIuY29uc3RydWN0b3I7bGV0ICQ9KCk9PntsZXQgcz0oZixiLHcpPT4oLi4uSSk9PntsZXQgTz1YZSxCPWI/LigpO0k9ZiguLi5JKTtsZXQgTD1iPy4oKTtyZXR1cm4gQiE9PUwmJihmPUwsdyhCKSxiPXc9bnVsbCksWGUhPU8/bmV3IFByb21pc2UoKEgsWCk9PntFbj17cmVzb2x2ZTpILHJlamVjdDpYfX0pOkl9LGM9Zj0+YXN5bmMoLi4uYik9Pnt0cnl7aWYodS5HYil0aHJvdyBFcnJvcihcIlNlc3Npb24gYWxyZWFkeSBzdGFydGVkXCIpO2xldCB3PXUuR2I9e2hjOmJbMF0sZXJyb3JzOltdfSxJPWF3YWl0IGYoLi4uYik7aWYodS5HYiE9PXcpdGhyb3cgRXJyb3IoXCJTZXNzaW9uIG1pc21hdGNoXCIpO3UuSGI/LmZsdXNoKCk7bGV0IE89dy5lcnJvcnM7aWYoMDxPLmxlbmd0aCl7bGV0IEI9YXdhaXQgUHJvbWlzZS5hbGwoTyk7aWYoQj1CLmZpbHRlcihMPT5MKSwwPEIubGVuZ3RoKXRocm93IEVycm9yKEIuam9pbihgXG5gKSl9cmV0dXJuIEl9ZmluYWxseXt1LkdiPW51bGx9fTt1Ll9PcnRDcmVhdGVTZXNzaW9uPXModS5fT3J0Q3JlYXRlU2Vzc2lvbiwoKT0+dS5fT3J0Q3JlYXRlU2Vzc2lvbixmPT51Ll9PcnRDcmVhdGVTZXNzaW9uPWYpLHUuX09ydFJ1bj1jKHModS5fT3J0UnVuLCgpPT51Ll9PcnRSdW4sZj0+dS5fT3J0UnVuPWYpKSx1Ll9PcnRSdW5XaXRoQmluZGluZz1jKHModS5fT3J0UnVuV2l0aEJpbmRpbmcsKCk9PnUuX09ydFJ1bldpdGhCaW5kaW5nLGY9PnUuX09ydFJ1bldpdGhCaW5kaW5nPWYpKSx1Ll9PcnRCaW5kSW5wdXQ9cyh1Ll9PcnRCaW5kSW5wdXQsKCk9PnUuX09ydEJpbmRJbnB1dCxmPT51Ll9PcnRCaW5kSW5wdXQ9ZiksJD12b2lkIDB9O3UuanNlcEluaXQ9KHMsYyk9PntpZigkPy4oKSxzPT09XCJ3ZWJncHVcIil7W3UuSGIsdS5WYix1LlpiLHUuT2IsdS5ZYix1LmtiLHUuJGIsdS5jYyx1LldiLHUuWGIsdS5hY109YztsZXQgZj11LkhiO3UuanNlcFJlZ2lzdGVyQnVmZmVyPShiLHcsSSxPKT0+Zi5yZWdpc3RlckJ1ZmZlcihiLHcsSSxPKSx1LmpzZXBHZXRCdWZmZXI9Yj0+Zi5nZXRCdWZmZXIoYiksdS5qc2VwQ3JlYXRlRG93bmxvYWRlcj0oYix3LEkpPT5mLmNyZWF0ZURvd25sb2FkZXIoYix3LEkpLHUuanNlcE9uQ3JlYXRlU2Vzc2lvbj1iPT57Zi5vbkNyZWF0ZVNlc3Npb24oYil9LHUuanNlcE9uUmVsZWFzZVNlc3Npb249Yj0+e2Yub25SZWxlYXNlU2Vzc2lvbihiKX0sdS5qc2VwT25SdW5TdGFydD1iPT5mLm9uUnVuU3RhcnQoYiksdS5kYz0oYix3KT0+e2YudXBsb2FkKGIsdyl9fWVsc2UgaWYocz09PVwid2Vibm5cIil7W3UuSGIsdS5iYyx1LlBiLHUuanNlcEVuc3VyZVRlbnNvcix1LmVjLHUuanNlcERvd25sb2FkVGVuc29yXT1jLHUuanNlcFJlbGVhc2VUZW5zb3JJZD11LlBiO2xldCBmPXUuSGI7dS5qc2VwT25SdW5TdGFydD1iPT5mLm9uUnVuU3RhcnQoYiksdS5qc2VwUmVnaXN0ZXJNTENvbnRleHQ9KGIsdyk9PntmLnJlZ2lzdGVyTUxDb250ZXh0KGIsdyl9LHUuanNlcE9uUmVsZWFzZVNlc3Npb249Yj0+e2Yub25SZWxlYXNlU2Vzc2lvbihiKX0sdS5qc2VwQ3JlYXRlTUxUZW5zb3JEb3dubG9hZGVyPShiLHcpPT5mLmNyZWF0ZU1MVGVuc29yRG93bmxvYWRlcihiLHcpLHUuanNlcFJlZ2lzdGVyTUxUZW5zb3I9KGIsdyxJKT0+Zi5yZWdpc3Rlck1MVGVuc29yKGIsdyxJKSx1LmpzZXBDcmVhdGVNTENvbnRleHQ9Yj0+Zi5jcmVhdGVNTENvbnRleHQoYiksdS5qc2VwUmVnaXN0ZXJNTENvbnN0YW50PShiLHcsSSxPLEIpPT5mLnJlZ2lzdGVyTUxDb25zdGFudChiLHcsSSxPLEIsdS5GYil9fTt2YXIgdixTLFQ9T2JqZWN0LmFzc2lnbih7fSx1KSxBPVwiLi90aGlzLnByb2dyYW1cIixrPShzLGMpPT57dGhyb3cgY30sUD1cIlwiOyhffHx5KSYmKHk/UD1zZWxmLmxvY2F0aW9uLmhyZWY6dHlwZW9mIGRvY3VtZW50PFwidVwiJiZkb2N1bWVudC5jdXJyZW50U2NyaXB0JiYoUD1kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYyksS24mJihQPUtuKSxQPVAuc3RhcnRzV2l0aChcImJsb2I6XCIpP1wiXCI6UC5zdWJzdHIoMCxQLnJlcGxhY2UoL1s/I10uKi8sXCJcIikubGFzdEluZGV4T2YoXCIvXCIpKzEpLHkmJihTPXM9Pnt2YXIgYz1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIGMub3BlbihcIkdFVFwiLHMsITEpLGMucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIixjLnNlbmQobnVsbCksbmV3IFVpbnQ4QXJyYXkoYy5yZXNwb25zZSl9KSx2PShzLGMsZik9Pnt2YXIgYj1uZXcgWE1MSHR0cFJlcXVlc3Q7Yi5vcGVuKFwiR0VUXCIscywhMCksYi5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiLGIub25sb2FkPSgpPT57Yi5zdGF0dXM9PTIwMHx8Yi5zdGF0dXM9PTAmJmIucmVzcG9uc2U/YyhiLnJlc3BvbnNlKTpmKCl9LGIub25lcnJvcj1mLGIuc2VuZChudWxsKX0pO3ZhciBELFI9Y29uc29sZS5sb2cuYmluZChjb25zb2xlKSxHPWNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKSxLPVIsaj1HO2lmKE9iamVjdC5hc3NpZ24odSxUKSxUPW51bGwsZyl7bGV0IHM9ZnVuY3Rpb24oYyl7dHJ5e3ZhciBmPWMuZGF0YSxiPWYuY21kO2lmKGI9PT1cImxvYWRcIil7bGV0IHc9W107c2VsZi5vbm1lc3NhZ2U9ST0+dy5wdXNoKEkpLHNlbGYuc3RhcnRXb3JrZXI9KCk9Pntwb3N0TWVzc2FnZSh7Y21kOlwibG9hZGVkXCJ9KTtmb3IobGV0IEkgb2YgdylzKEkpO3NlbGYub25tZXNzYWdlPXN9O2ZvcihsZXQgSSBvZiBmLmhhbmRsZXJzKXVbSV0mJiF1W0ldLnByb3h5fHwodVtJXT0oLi4uTyk9Pntwb3N0TWVzc2FnZSh7TmI6XCJjYWxsSGFuZGxlclwiLHBjOkksYXJnczpPfSl9LEk9PVwicHJpbnRcIiYmKEs9dVtJXSksST09XCJwcmludEVyclwiJiYoaj11W0ldKSk7c2U9Zi53YXNtTWVtb3J5LHllKCksVihmLndhc21Nb2R1bGUpfWVsc2UgaWYoYj09PVwicnVuXCIpe0RuKGYucHRocmVhZF9wdHIsMCwwLDEsMCwwKSxBbihmLnB0aHJlYWRfcHRyKSx4YygpLEhvKCksUXx8KFdpKCksUT0hMCk7dHJ5e1NjKGYuc3RhcnRfcm91dGluZSxmLmFyZyl9Y2F0Y2godyl7aWYodyE9XCJ1bndpbmRcIil0aHJvdyB3fX1lbHNlIGI9PT1cImNhbmNlbFwiP010KCkmJmhyKC0xKTpmLnRhcmdldCE9PVwic2V0aW1tZWRpYXRlXCImJihiPT09XCJjaGVja01haWxib3hcIj9RJiZpcigpOmImJihqKGB3b3JrZXI6IHJlY2VpdmVkIHVua25vd24gY29tbWFuZCAke2J9YCksaihmKSkpfWNhdGNoKHcpe3Rocm93IExpKCksd319O3ZhciB3Zz1zLFYsUT0hMTtqPWZ1bmN0aW9uKC4uLmMpe2M9Yy5qb2luKFwiIFwiKSxjb25zb2xlLmVycm9yKGMpfSxzZWxmLmFsZXJ0PWZ1bmN0aW9uKC4uLmMpe3Bvc3RNZXNzYWdlKHtOYjpcImFsZXJ0XCIsdGV4dDpjLmpvaW4oXCIgXCIpLHJjOk10KCl9KX0sdS5pbnN0YW50aWF0ZVdhc209KGMsZik9Pm5ldyBQcm9taXNlKGI9PntWPXc9Pnt3PW5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZSh3LE5vKCkpLGYodyksYigpfX0pLHNlbGYub251bmhhbmRsZWRyZWplY3Rpb249Yz0+e3Rocm93IGMucmVhc29ufHxjfSxzZWxmLm9ubWVzc2FnZT1zfXUud2FzbUJpbmFyeSYmKEQ9dS53YXNtQmluYXJ5KTt2YXIgc2UsWSxlZSxKLG5lLGJlLE9lLCRlLGxlLFcscSxoZSxHZSx3ZT0hMTtmdW5jdGlvbiB5ZSgpe3ZhciBzPXNlLmJ1ZmZlcjt1LkhFQVA4PUo9bmV3IEludDhBcnJheShzKSx1LkhFQVAxNj1iZT1uZXcgSW50MTZBcnJheShzKSx1LkhFQVBVOD1uZT1uZXcgVWludDhBcnJheShzKSx1LkhFQVBVMTY9T2U9bmV3IFVpbnQxNkFycmF5KHMpLHUuSEVBUDMyPSRlPW5ldyBJbnQzMkFycmF5KHMpLHUuSEVBUFUzMj1sZT1uZXcgVWludDMyQXJyYXkocyksdS5IRUFQRjMyPVc9bmV3IEZsb2F0MzJBcnJheShzKSx1LkhFQVBGNjQ9R2U9bmV3IEZsb2F0NjRBcnJheShzKSx1LkhFQVA2ND1xPW5ldyBCaWdJbnQ2NEFycmF5KHMpLHUuSEVBUFU2ND1oZT1uZXcgQmlnVWludDY0QXJyYXkocyl9aWYoIWcpe2lmKCEoKHNlPW5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe2luaXRpYWw6MjU2LG1heGltdW06NjU1MzYsc2hhcmVkOiEwfSkpLmJ1ZmZlciBpbnN0YW5jZW9mIHgpKXRocm93IGooXCJyZXF1ZXN0ZWQgYSBzaGFyZWQgV2ViQXNzZW1ibHkuTWVtb3J5IGJ1dCB0aGUgcmV0dXJuZWQgYnVmZmVyIGlzIG5vdCBhIFNoYXJlZEFycmF5QnVmZmVyLCBpbmRpY2F0aW5nIHRoYXQgd2hpbGUgdGhlIGJyb3dzZXIgaGFzIFNoYXJlZEFycmF5QnVmZmVyIGl0IGRvZXMgbm90IGhhdmUgV2ViQXNzZW1ibHkgdGhyZWFkcyBzdXBwb3J0IC0geW91IG1heSBuZWVkIHRvIHNldCBhIGZsYWdcIiksRXJyb3IoXCJiYWQgbWVtb3J5XCIpO3llKCl9dmFyIFllPVtdLEx0PVtdLGZuPVtdLEd0PTAsaG49bnVsbCxIdD1udWxsO2Z1bmN0aW9uIERvKCl7aWYoLS1HdD09MCYmKGhuIT09bnVsbCYmKGNsZWFySW50ZXJ2YWwoaG4pLGhuPW51bGwpLEh0KSl7dmFyIHM9SHQ7SHQ9bnVsbCxzKCl9fWZ1bmN0aW9uIGN0KHMpe3Rocm93IGoocz1cIkFib3J0ZWQoXCIrcytcIilcIiksd2U9ITAsZWU9MSxzPW5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3IocytcIi4gQnVpbGQgd2l0aCAtc0FTU0VSVElPTlMgZm9yIG1vcmUgaW5mby5cIiksbShzKSxzfXZhciBnbixCbz1zPT5zLnN0YXJ0c1dpdGgoXCJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsXCIpLE1vPXM9PnMuc3RhcnRzV2l0aChcImZpbGU6Ly9cIik7ZnVuY3Rpb24gUm8ocyl7aWYocz09Z24mJkQpcmV0dXJuIG5ldyBVaW50OEFycmF5KEQpO2lmKFMpcmV0dXJuIFMocyk7dGhyb3dcImJvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkXCJ9ZnVuY3Rpb24gVW8ocyxjLGYpe3JldHVybiBmdW5jdGlvbihiKXtpZighRCYmKF98fHkpKXtpZih0eXBlb2YgZmV0Y2g9PVwiZnVuY3Rpb25cIiYmIU1vKGIpKXJldHVybiBmZXRjaChiLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKHc9PntpZighdy5vayl0aHJvd2BmYWlsZWQgdG8gbG9hZCB3YXNtIGJpbmFyeSBmaWxlIGF0ICcke2J9J2A7cmV0dXJuIHcuYXJyYXlCdWZmZXIoKX0pLmNhdGNoKCgpPT5SbyhiKSk7aWYodilyZXR1cm4gbmV3IFByb21pc2UoKHcsSSk9Pnt2KGIsTz0+dyhuZXcgVWludDhBcnJheShPKSksSSl9KX1yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKT0+Um8oYikpfShzKS50aGVuKGI9PldlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGIsYykpLnRoZW4oZixiPT57aihgZmFpbGVkIHRvIGFzeW5jaHJvbm91c2x5IHByZXBhcmUgd2FzbTogJHtifWApLGN0KGIpfSl9ZnVuY3Rpb24gTm8oKXtyZXR1cm57YTp7TzokYyxBYTp2YyxiOkljLGFhOmpvLEI6UW8scWE6WG8sWTplaSxfOnRpLHJhOnJpLG9hOm5pLGhhOm9pLG5hOmlpLEw6YWksWjpzaSxXOnVpLHBhOmRpLFg6bGksdmE6Q2MsRjprYyxROkVjLFA6emMsRTpEYyx1OkJjLHE6TWMsRzpSYyxBOkhjLFI6RmMsdWE6cWMsa2E6S2MsVTpqYyxiYTpZYyxIOlpjLGphOkFuLHRhOlFjLHQ6WGMsQmE6SmMseDpycCxuOm5wLGw6aXAsYzpJbixvOmFwLGo6ZHAsdzpscCxwOmNwLGY6cHAsczptcCxtOmZwLGU6aHAsazpncCxpOmJwLGg6eXAsZDpfcCxlYTp3cCxmYTp2cCxnYTokcCxjYTpTaSxkYTpUaSxUOnhwLGc6U3AsRDpUcCxJOklwLE06Q3AseTpBcCxzYTprcCxWOkVwLHY6Q2ksejpQcCxOOnpwLFM6T3AsemE6RHAseWE6QnAsbGE6RWksbWE6UGksJDp2bixDOnppLEs6T2ksaWE6RGksSjpCaSxhOnNlLHhhOnduLHdhOlVpLHI6VXB9fX12YXIgYm49ezkxMzcwMDoocyxjLGYsYix3KT0+e2lmKHU9PT12b2lkIDB8fCF1LkZiKXJldHVybiAxO2lmKChzPUNlKE51bWJlcihzPj4+MCkpKS5zdGFydHNXaXRoKFwiLi9cIikmJihzPXMuc3Vic3RyaW5nKDIpKSwhKHM9dS5GYi5nZXQocykpKXJldHVybiAyO2lmKGM9TnVtYmVyKGM+Pj4wKSxmPU51bWJlcihmPj4+MCksYj1OdW1iZXIoYj4+PjApLGMrZj5zLmJ5dGVMZW5ndGgpcmV0dXJuIDM7dHJ5e2xldCBJPXMuc3ViYXJyYXkoYyxjK2YpO3N3aXRjaCh3KXtjYXNlIDA6cigpLnNldChJLGI+Pj4wKTticmVhaztjYXNlIDE6dS5kYyhiLEkpO2JyZWFrO2RlZmF1bHQ6cmV0dXJuIDR9cmV0dXJuIDB9Y2F0Y2h7cmV0dXJuIDR9fSw5MTQ0MTU6KHMsYyxmKT0+e3UuZWMocyxyKCkuc3ViYXJyYXkoYz4+PjAsYytmPj4+MCkpfSw5MTQ0Nzg6KCk9PnUuYmMoKSw5MTQ1MTk6cz0+e3UuUGIocyl9LDkxNDU1NTooKT0+e3UuV2IoKX0sOTE0NTg2OigpPT57dS5YYigpfSw5MTQ2MTU6KCk9Pnt1LmFjKCl9LDkxNDY0MDpzPT51LlZiKHMpLDkxNDY3MzpzPT51LlpiKHMpLDkxNDcwNToocyxjLGYpPT57dS5PYihOdW1iZXIocyksTnVtYmVyKGMpLE51bWJlcihmKSwhMCl9LDkxNDc2ODoocyxjLGYpPT57dS5PYihOdW1iZXIocyksTnVtYmVyKGMpLE51bWJlcihmKSl9LDkxNDgyNTooKT0+dHlwZW9mIHdhc21PZmZzZXRDb252ZXJ0ZXI8XCJ1XCIsOTE0ODgyOnM9Pnt1LmtiKFwiQWJzXCIscyx2b2lkIDApfSw5MTQ5MzM6cz0+e3Uua2IoXCJOZWdcIixzLHZvaWQgMCl9LDkxNDk4NDpzPT57dS5rYihcIkZsb29yXCIscyx2b2lkIDApfSw5MTUwMzc6cz0+e3Uua2IoXCJDZWlsXCIscyx2b2lkIDApfSw5MTUwODk6cz0+e3Uua2IoXCJSZWNpcHJvY2FsXCIscyx2b2lkIDApfSw5MTUxNDc6cz0+e3Uua2IoXCJTcXJ0XCIscyx2b2lkIDApfSw5MTUxOTk6cz0+e3Uua2IoXCJFeHBcIixzLHZvaWQgMCl9LDkxNTI1MDpzPT57dS5rYihcIkVyZlwiLHMsdm9pZCAwKX0sOTE1MzAxOnM9Pnt1LmtiKFwiU2lnbW9pZFwiLHMsdm9pZCAwKX0sOTE1MzU2OihzLGMsZik9Pnt1LmtiKFwiSGFyZFNpZ21vaWRcIixzLHthbHBoYTpjLGJldGE6Zn0pfSw5MTU0MzU6cz0+e3Uua2IoXCJMb2dcIixzLHZvaWQgMCl9LDkxNTQ4NjpzPT57dS5rYihcIlNpblwiLHMsdm9pZCAwKX0sOTE1NTM3OnM9Pnt1LmtiKFwiQ29zXCIscyx2b2lkIDApfSw5MTU1ODg6cz0+e3Uua2IoXCJUYW5cIixzLHZvaWQgMCl9LDkxNTYzOTpzPT57dS5rYihcIkFzaW5cIixzLHZvaWQgMCl9LDkxNTY5MTpzPT57dS5rYihcIkFjb3NcIixzLHZvaWQgMCl9LDkxNTc0MzpzPT57dS5rYihcIkF0YW5cIixzLHZvaWQgMCl9LDkxNTc5NTpzPT57dS5rYihcIlNpbmhcIixzLHZvaWQgMCl9LDkxNTg0NzpzPT57dS5rYihcIkNvc2hcIixzLHZvaWQgMCl9LDkxNTg5OTpzPT57dS5rYihcIkFzaW5oXCIscyx2b2lkIDApfSw5MTU5NTI6cz0+e3Uua2IoXCJBY29zaFwiLHMsdm9pZCAwKX0sOTE2MDA1OnM9Pnt1LmtiKFwiQXRhbmhcIixzLHZvaWQgMCl9LDkxNjA1ODpzPT57dS5rYihcIlRhbmhcIixzLHZvaWQgMCl9LDkxNjExMDpzPT57dS5rYihcIk5vdFwiLHMsdm9pZCAwKX0sOTE2MTYxOihzLGMsZik9Pnt1LmtiKFwiQ2xpcFwiLHMse21pbjpjLG1heDpmfSl9LDkxNjIzMDpzPT57dS5rYihcIkNsaXBcIixzLHZvaWQgMCl9LDkxNjI4MjoocyxjKT0+e3Uua2IoXCJFbHVcIixzLHthbHBoYTpjfSl9LDkxNjM0MDpzPT57dS5rYihcIkdlbHVcIixzLHZvaWQgMCl9LDkxNjM5MjpzPT57dS5rYihcIlJlbHVcIixzLHZvaWQgMCl9LDkxNjQ0NDoocyxjKT0+e3Uua2IoXCJMZWFreVJlbHVcIixzLHthbHBoYTpjfSl9LDkxNjUwODoocyxjKT0+e3Uua2IoXCJUaHJlc2hvbGRlZFJlbHVcIixzLHthbHBoYTpjfSl9LDkxNjU3ODoocyxjKT0+e3Uua2IoXCJDYXN0XCIscyx7dG86Y30pfSw5MTY2MzY6cz0+e3Uua2IoXCJBZGRcIixzLHZvaWQgMCl9LDkxNjY4NzpzPT57dS5rYihcIlN1YlwiLHMsdm9pZCAwKX0sOTE2NzM4OnM9Pnt1LmtiKFwiTXVsXCIscyx2b2lkIDApfSw5MTY3ODk6cz0+e3Uua2IoXCJEaXZcIixzLHZvaWQgMCl9LDkxNjg0MDpzPT57dS5rYihcIlBvd1wiLHMsdm9pZCAwKX0sOTE2ODkxOnM9Pnt1LmtiKFwiRXF1YWxcIixzLHZvaWQgMCl9LDkxNjk0NDpzPT57dS5rYihcIkdyZWF0ZXJcIixzLHZvaWQgMCl9LDkxNjk5OTpzPT57dS5rYihcIkdyZWF0ZXJPckVxdWFsXCIscyx2b2lkIDApfSw5MTcwNjE6cz0+e3Uua2IoXCJMZXNzXCIscyx2b2lkIDApfSw5MTcxMTM6cz0+e3Uua2IoXCJMZXNzT3JFcXVhbFwiLHMsdm9pZCAwKX0sOTE3MTcyOihzLGMsZixiLHcpPT57dS5rYihcIlJlZHVjZU1lYW5cIixzLHtrZWVwRGltczohIWMsbm9vcFdpdGhFbXB0eUF4ZXM6ISFmLGF4ZXM6Yj9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoYik+Pj4wLE51bWJlcih3KT4+PjApKTpbXX0pfSw5MTczNDc6KHMsYyxmLGIsdyk9Pnt1LmtiKFwiUmVkdWNlTWF4XCIscyx7a2VlcERpbXM6ISFjLG5vb3BXaXRoRW1wdHlBeGVzOiEhZixheGVzOmI/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGIpPj4+MCxOdW1iZXIodyk+Pj4wKSk6W119KX0sOTE3NTIxOihzLGMsZixiLHcpPT57dS5rYihcIlJlZHVjZU1pblwiLHMse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWYsYXhlczpiP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihiKT4+PjAsTnVtYmVyKHcpPj4+MCkpOltdfSl9LDkxNzY5NToocyxjLGYsYix3KT0+e3Uua2IoXCJSZWR1Y2VQcm9kXCIscyx7a2VlcERpbXM6ISFjLG5vb3BXaXRoRW1wdHlBeGVzOiEhZixheGVzOmI/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGIpPj4+MCxOdW1iZXIodyk+Pj4wKSk6W119KX0sOTE3ODcwOihzLGMsZixiLHcpPT57dS5rYihcIlJlZHVjZVN1bVwiLHMse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWYsYXhlczpiP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihiKT4+PjAsTnVtYmVyKHcpPj4+MCkpOltdfSl9LDkxODA0NDoocyxjLGYsYix3KT0+e3Uua2IoXCJSZWR1Y2VMMVwiLHMse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWYsYXhlczpiP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihiKT4+PjAsTnVtYmVyKHcpPj4+MCkpOltdfSl9LDkxODIxNzoocyxjLGYsYix3KT0+e3Uua2IoXCJSZWR1Y2VMMlwiLHMse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWYsYXhlczpiP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihiKT4+PjAsTnVtYmVyKHcpPj4+MCkpOltdfSl9LDkxODM5MDoocyxjLGYsYix3KT0+e3Uua2IoXCJSZWR1Y2VMb2dTdW1cIixzLHtrZWVwRGltczohIWMsbm9vcFdpdGhFbXB0eUF4ZXM6ISFmLGF4ZXM6Yj9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoYik+Pj4wLE51bWJlcih3KT4+PjApKTpbXX0pfSw5MTg1Njc6KHMsYyxmLGIsdyk9Pnt1LmtiKFwiUmVkdWNlU3VtU3F1YXJlXCIscyx7a2VlcERpbXM6ISFjLG5vb3BXaXRoRW1wdHlBeGVzOiEhZixheGVzOmI/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGIpPj4+MCxOdW1iZXIodyk+Pj4wKSk6W119KX0sOTE4NzQ3OihzLGMsZixiLHcpPT57dS5rYihcIlJlZHVjZUxvZ1N1bUV4cFwiLHMse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWYsYXhlczpiP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihiKT4+PjAsTnVtYmVyKHcpPj4+MCkpOltdfSl9LDkxODkyNzpzPT57dS5rYihcIldoZXJlXCIscyx2b2lkIDApfSw5MTg5ODA6KHMsYyxmKT0+e3Uua2IoXCJUcmFuc3Bvc2VcIixzLHtwZXJtOmM/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGMpPj4+MCxOdW1iZXIoZik+Pj4wKSk6W119KX0sOTE5MTA0OihzLGMsZixiKT0+e3Uua2IoXCJEZXB0aFRvU3BhY2VcIixzLHtibG9ja3NpemU6Yyxtb2RlOkNlKGYpLGZvcm1hdDpiP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkxOTIzNzoocyxjLGYsYik9Pnt1LmtiKFwiRGVwdGhUb1NwYWNlXCIscyx7YmxvY2tzaXplOmMsbW9kZTpDZShmKSxmb3JtYXQ6Yj9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5MTkzNzA6KHMsYyxmLGIsdyxJLE8sQixMLEgsWCxjZSxnZSx6LGRlKT0+e3Uua2IoXCJDb252VHJhbnNwb3NlXCIscyx7Zm9ybWF0Okw/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b1BhZDpjLGRpbGF0aW9uczpbZl0sZ3JvdXA6YixrZXJuZWxTaGFwZTpbd10scGFkczpbSSxPXSxzdHJpZGVzOltCXSx3SXNDb25zdDooKT0+ISF0KClbSD4+PjBdLG91dHB1dFBhZGRpbmc6WD9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoWCk+Pj4wLE51bWJlcihjZSk+Pj4wKSk6W10sb3V0cHV0U2hhcGU6Z2U/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGdlKT4+PjAsTnVtYmVyKHopPj4+MCkpOltdLGFjdGl2YXRpb246Q2UoZGUpfSl9LDkxOTgwMzoocyxjLGYsYix3LEksTyxCLEwsSCxYLGNlLGdlLHopPT57dS5rYihcIkNvbnZUcmFuc3Bvc2VcIixzLHtmb3JtYXQ6Qj9cIk5IV0NcIjpcIk5DSFdcIixhdXRvUGFkOmMsZGlsYXRpb25zOkFycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihmKT4+PjAsMisoTnVtYmVyKGYpPj4+MCk+Pj4wKSksZ3JvdXA6YixrZXJuZWxTaGFwZTpBcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIodyk+Pj4wLDIrKE51bWJlcih3KT4+PjApPj4+MCkpLHBhZHM6QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKEkpPj4+MCw0KyhOdW1iZXIoSSk+Pj4wKT4+PjApKSxzdHJpZGVzOkFycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihPKT4+PjAsMisoTnVtYmVyKE8pPj4+MCk+Pj4wKSksd0lzQ29uc3Q6KCk9PiEhdCgpW0w+Pj4wXSxvdXRwdXRQYWRkaW5nOkg/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKEgpPj4+MCxOdW1iZXIoWCk+Pj4wKSk6W10sb3V0cHV0U2hhcGU6Y2U/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGNlKT4+PjAsTnVtYmVyKGdlKT4+PjApKTpbXSxhY3RpdmF0aW9uOkNlKHopfSl9LDkyMDQ2NDoocyxjLGYsYix3LEksTyxCLEwsSCxYLGNlLGdlLHosZGUpPT57dS5rYihcIkNvbnZUcmFuc3Bvc2VcIixzLHtmb3JtYXQ6TD9cIk5IV0NcIjpcIk5DSFdcIixhdXRvUGFkOmMsZGlsYXRpb25zOltmXSxncm91cDpiLGtlcm5lbFNoYXBlOlt3XSxwYWRzOltJLE9dLHN0cmlkZXM6W0JdLHdJc0NvbnN0OigpPT4hIXQoKVtIPj4+MF0sb3V0cHV0UGFkZGluZzpYP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihYKT4+PjAsTnVtYmVyKGNlKT4+PjApKTpbXSxvdXRwdXRTaGFwZTpnZT9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoZ2UpPj4+MCxOdW1iZXIoeik+Pj4wKSk6W10sYWN0aXZhdGlvbjpDZShkZSl9KX0sOTIwODk3OihzLGMsZixiLHcsSSxPLEIsTCxILFgsY2UsZ2Useik9Pnt1LmtiKFwiQ29udlRyYW5zcG9zZVwiLHMse2Zvcm1hdDpCP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9QYWQ6YyxkaWxhdGlvbnM6QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGYpPj4+MCwyKyhOdW1iZXIoZik+Pj4wKT4+PjApKSxncm91cDpiLGtlcm5lbFNoYXBlOkFycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcih3KT4+PjAsMisoTnVtYmVyKHcpPj4+MCk+Pj4wKSkscGFkczpBcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoSSk+Pj4wLDQrKE51bWJlcihJKT4+PjApPj4+MCkpLHN0cmlkZXM6QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKE8pPj4+MCwyKyhOdW1iZXIoTyk+Pj4wKT4+PjApKSx3SXNDb25zdDooKT0+ISF0KClbTD4+PjBdLG91dHB1dFBhZGRpbmc6SD9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoSCk+Pj4wLE51bWJlcihYKT4+PjApKTpbXSxvdXRwdXRTaGFwZTpjZT9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoY2UpPj4+MCxOdW1iZXIoZ2UpPj4+MCkpOltdLGFjdGl2YXRpb246Q2Uoeil9KX0sOTIxNTU4OihzLGMpPT57dS5rYihcIkdsb2JhbEF2ZXJhZ2VQb29sXCIscyx7Zm9ybWF0OmM/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTIxNjQ5OihzLGMsZixiLHcsSSxPLEIsTCxILFgsY2UsZ2Useik9Pnt1LmtiKFwiQXZlcmFnZVBvb2xcIixzLHtmb3JtYXQ6ej9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDpjLGNlaWxfbW9kZTpmLGNvdW50X2luY2x1ZGVfcGFkOmIsc3RvcmFnZV9vcmRlcjp3LGRpbGF0aW9uczpJP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihJKT4+PjAsTnVtYmVyKE8pPj4+MCkpOltdLGtlcm5lbF9zaGFwZTpCP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihCKT4+PjAsTnVtYmVyKEwpPj4+MCkpOltdLHBhZHM6SD9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoSCk+Pj4wLE51bWJlcihYKT4+PjApKTpbXSxzdHJpZGVzOmNlP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihjZSk+Pj4wLE51bWJlcihnZSk+Pj4wKSk6W119KX0sOTIyMTI4OihzLGMpPT57dS5rYihcIkdsb2JhbEF2ZXJhZ2VQb29sXCIscyx7Zm9ybWF0OmM/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTIyMjE5OihzLGMsZixiLHcsSSxPLEIsTCxILFgsY2UsZ2Useik9Pnt1LmtiKFwiQXZlcmFnZVBvb2xcIixzLHtmb3JtYXQ6ej9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDpjLGNlaWxfbW9kZTpmLGNvdW50X2luY2x1ZGVfcGFkOmIsc3RvcmFnZV9vcmRlcjp3LGRpbGF0aW9uczpJP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihJKT4+PjAsTnVtYmVyKE8pPj4+MCkpOltdLGtlcm5lbF9zaGFwZTpCP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihCKT4+PjAsTnVtYmVyKEwpPj4+MCkpOltdLHBhZHM6SD9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoSCk+Pj4wLE51bWJlcihYKT4+PjApKTpbXSxzdHJpZGVzOmNlP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihjZSk+Pj4wLE51bWJlcihnZSk+Pj4wKSk6W119KX0sOTIyNjk4OihzLGMpPT57dS5rYihcIkdsb2JhbE1heFBvb2xcIixzLHtmb3JtYXQ6Yz9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5MjI3ODU6KHMsYyxmLGIsdyxJLE8sQixMLEgsWCxjZSxnZSx6KT0+e3Uua2IoXCJNYXhQb29sXCIscyx7Zm9ybWF0Ono/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6YyxjZWlsX21vZGU6Zixjb3VudF9pbmNsdWRlX3BhZDpiLHN0b3JhZ2Vfb3JkZXI6dyxkaWxhdGlvbnM6ST9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoSSk+Pj4wLE51bWJlcihPKT4+PjApKTpbXSxrZXJuZWxfc2hhcGU6Qj9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoQik+Pj4wLE51bWJlcihMKT4+PjApKTpbXSxwYWRzOkg/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKEgpPj4+MCxOdW1iZXIoWCk+Pj4wKSk6W10sc3RyaWRlczpjZT9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoY2UpPj4+MCxOdW1iZXIoZ2UpPj4+MCkpOltdfSl9LDkyMzI2MDoocyxjKT0+e3Uua2IoXCJHbG9iYWxNYXhQb29sXCIscyx7Zm9ybWF0OmM/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTIzMzQ3OihzLGMsZixiLHcsSSxPLEIsTCxILFgsY2UsZ2Useik9Pnt1LmtiKFwiTWF4UG9vbFwiLHMse2Zvcm1hdDp6P1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOmMsY2VpbF9tb2RlOmYsY291bnRfaW5jbHVkZV9wYWQ6YixzdG9yYWdlX29yZGVyOncsZGlsYXRpb25zOkk/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKEkpPj4+MCxOdW1iZXIoTyk+Pj4wKSk6W10sa2VybmVsX3NoYXBlOkI/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKEIpPj4+MCxOdW1iZXIoTCk+Pj4wKSk6W10scGFkczpIP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihIKT4+PjAsTnVtYmVyKFgpPj4+MCkpOltdLHN0cmlkZXM6Y2U/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGNlKT4+PjAsTnVtYmVyKGdlKT4+PjApKTpbXX0pfSw5MjM4MjI6KHMsYyxmLGIsdyk9Pnt1LmtiKFwiR2VtbVwiLHMse2FscGhhOmMsYmV0YTpmLHRyYW5zQTpiLHRyYW5zQjp3fSl9LDkyMzkyNjpzPT57dS5rYihcIk1hdE11bFwiLHMsdm9pZCAwKX0sOTIzOTgwOihzLGMsZixiKT0+e3Uua2IoXCJBcmdNYXhcIixzLHtrZWVwRGltczohIWMsc2VsZWN0TGFzdEluZGV4OiEhZixheGlzOmJ9KX0sOTI0MDg4OihzLGMsZixiKT0+e3Uua2IoXCJBcmdNaW5cIixzLHtrZWVwRGltczohIWMsc2VsZWN0TGFzdEluZGV4OiEhZixheGlzOmJ9KX0sOTI0MTk2OihzLGMpPT57dS5rYihcIlNvZnRtYXhcIixzLHtheGlzOmN9KX0sOTI0MjU5OihzLGMpPT57dS5rYihcIkNvbmNhdFwiLHMse2F4aXM6Y30pfSw5MjQzMTk6KHMsYyxmLGIsdyk9Pnt1LmtiKFwiU3BsaXRcIixzLHtheGlzOmMsbnVtT3V0cHV0czpmLHNwbGl0U2l6ZXM6Yj9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoYik+Pj4wLE51bWJlcih3KT4+PjApKTpbXX0pfSw5MjQ0NzU6cz0+e3Uua2IoXCJFeHBhbmRcIixzLHZvaWQgMCl9LDkyNDUyOToocyxjKT0+e3Uua2IoXCJHYXRoZXJcIixzLHtheGlzOk51bWJlcihjKX0pfSw5MjQ2MDA6KHMsYyk9Pnt1LmtiKFwiR2F0aGVyRWxlbWVudHNcIixzLHtheGlzOk51bWJlcihjKX0pfSw5MjQ2Nzk6KHMsYyk9Pnt1LmtiKFwiR2F0aGVyTkRcIixzLHtiYXRjaF9kaW1zOk51bWJlcihjKX0pfSw5MjQ3NTg6KHMsYyxmLGIsdyxJLE8sQixMLEgsWCk9Pnt1LmtiKFwiUmVzaXplXCIscyx7YW50aWFsaWFzOmMsYXhlczpmP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihmKT4+PjAsTnVtYmVyKGIpPj4+MCkpOltdLGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlOkNlKHcpLGN1YmljQ29lZmZBOkksZXhjbHVkZU91dHNpZGU6TyxleHRyYXBvbGF0aW9uVmFsdWU6QixrZWVwQXNwZWN0UmF0aW9Qb2xpY3k6Q2UoTCksbW9kZTpDZShIKSxuZWFyZXN0TW9kZTpDZShYKX0pfSw5MjUxMjA6KHMsYyxmLGIsdyxJLE8pPT57dS5rYihcIlNsaWNlXCIscyx7c3RhcnRzOmM/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGMpPj4+MCxOdW1iZXIoZik+Pj4wKSk6W10sZW5kczpiP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihiKT4+PjAsTnVtYmVyKHcpPj4+MCkpOltdLGF4ZXM6ST9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoSSk+Pj4wLE51bWJlcihPKT4+PjApKTpbXX0pfSw5MjUzODQ6cz0+e3Uua2IoXCJUaWxlXCIscyx2b2lkIDApfSw5MjU0MzY6KHMsYyxmKT0+e3Uua2IoXCJJbnN0YW5jZU5vcm1hbGl6YXRpb25cIixzLHtlcHNpbG9uOmMsZm9ybWF0OmY/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTI1NTUwOihzLGMsZik9Pnt1LmtiKFwiSW5zdGFuY2VOb3JtYWxpemF0aW9uXCIscyx7ZXBzaWxvbjpjLGZvcm1hdDpmP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkyNTY2NDpzPT57dS5rYihcIlJhbmdlXCIscyx2b2lkIDApfSw5MjU3MTc6KHMsYyk9Pnt1LmtiKFwiRWluc3VtXCIscyx7ZXF1YXRpb246Q2UoYyl9KX0sOTI1Nzk4OihzLGMsZixiLHcpPT57dS5rYihcIlBhZFwiLHMse21vZGU6Yyx2YWx1ZTpmLHBhZHM6Yj9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoYik+Pj4wLE51bWJlcih3KT4+PjApKTpbXX0pfSw5MjU5NDE6KHMsYyxmLGIsdyxJKT0+e3Uua2IoXCJCYXRjaE5vcm1hbGl6YXRpb25cIixzLHtlcHNpbG9uOmMsbW9tZW50dW06ZixzcGF0aWFsOiEhdyx0cmFpbmluZ01vZGU6ISFiLGZvcm1hdDpJP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkyNjExMDoocyxjLGYsYix3LEkpPT57dS5rYihcIkJhdGNoTm9ybWFsaXphdGlvblwiLHMse2Vwc2lsb246Yyxtb21lbnR1bTpmLHNwYXRpYWw6ISF3LHRyYWluaW5nTW9kZTohIWIsZm9ybWF0Okk/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTI2Mjc5OihzLGMsZik9Pnt1LmtiKFwiQ3VtU3VtXCIscyx7ZXhjbHVzaXZlOk51bWJlcihjKSxyZXZlcnNlOk51bWJlcihmKX0pfSw5MjYzNzY6KHMsYyxmKT0+e3Uua2IoXCJEZXF1YW50aXplTGluZWFyXCIscyx7YXhpczpjLGJsb2NrU2l6ZTpmfSl9LDkyNjQ2NjoocyxjLGYsYix3KT0+e3Uua2IoXCJHcmlkU2FtcGxlXCIscyx7YWxpZ25fY29ybmVyczpjLG1vZGU6Q2UoZikscGFkZGluZ19tb2RlOkNlKGIpLGZvcm1hdDp3P1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkyNjYzNjoocyxjLGYsYix3KT0+e3Uua2IoXCJHcmlkU2FtcGxlXCIscyx7YWxpZ25fY29ybmVyczpjLG1vZGU6Q2UoZikscGFkZGluZ19tb2RlOkNlKGIpLGZvcm1hdDp3P1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkyNjgwNjoocyxjLGYsYix3LEksTyxCLEwpPT57dS5rYihcIkF0dGVudGlvblwiLHMse251bUhlYWRzOmMsaXNVbmlkaXJlY3Rpb25hbDpmLG1hc2tGaWx0ZXJWYWx1ZTpiLHNjYWxlOncsZG9Sb3Rhcnk6SSxxa3ZIaWRkZW5TaXplczpPP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihCKT4+PjAsTnVtYmVyKEIpK08+Pj4wKSk6W10scGFzdFByZXNlbnRTaGFyZUJ1ZmZlcjohIUx9KX0sOTI3MDc4OnM9Pnt1LmtiKFwiQmlhc0FkZFwiLHMsdm9pZCAwKX0sOTI3MTMzOnM9Pnt1LmtiKFwiQmlhc1NwbGl0R2VsdVwiLHMsdm9pZCAwKX0sOTI3MTk0OnM9Pnt1LmtiKFwiRmFzdEdlbHVcIixzLHZvaWQgMCl9LDkyNzI1MDoocyxjLGYsYix3LEksTyxCLEwsSCxYLGNlLGdlLHosZGUsVGUpPT57dS5rYihcIkNvbnZcIixzLHtmb3JtYXQ6Y2U/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6YyxkaWxhdGlvbnM6Zj9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoZik+Pj4wLE51bWJlcihiKT4+PjApKTpbXSxncm91cDp3LGtlcm5lbF9zaGFwZTpJP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihJKT4+PjAsTnVtYmVyKE8pPj4+MCkpOltdLHBhZHM6Qj9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoQik+Pj4wLE51bWJlcihMKT4+PjApKTpbXSxzdHJpZGVzOkg/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKEgpPj4+MCxOdW1iZXIoWCk+Pj4wKSk6W10sd19pc19jb25zdDooKT0+ISF0KClbTnVtYmVyKGdlKT4+PjBdLGFjdGl2YXRpb246Q2UoeiksYWN0aXZhdGlvbl9wYXJhbXM6ZGU/QXJyYXkuZnJvbShkKCkuc3ViYXJyYXkoTnVtYmVyKGRlKT4+PjAsTnVtYmVyKFRlKT4+PjApKTpbXX0pfSw5Mjc4MzQ6cz0+e3Uua2IoXCJHZWx1XCIscyx2b2lkIDApfSw5Mjc4ODY6KHMsYyxmLGIsdyxJLE8sQixMKT0+e3Uua2IoXCJHcm91cFF1ZXJ5QXR0ZW50aW9uXCIscyx7bnVtSGVhZHM6Yyxrdk51bUhlYWRzOmYsc2NhbGU6Yixzb2Z0Y2FwOncsZG9Sb3Rhcnk6SSxyb3RhcnlJbnRlcmxlYXZlZDpPLHNtb290aFNvZnRtYXg6Qixsb2NhbFdpbmRvd1NpemU6TH0pfSw5MjgxMDM6KHMsYyxmLGIpPT57dS5rYihcIkxheWVyTm9ybWFsaXphdGlvblwiLHMse2F4aXM6YyxlcHNpbG9uOmYsc2ltcGxpZmllZDohIWJ9KX0sOTI4MjE0OihzLGMsZixiKT0+e3Uua2IoXCJMYXllck5vcm1hbGl6YXRpb25cIixzLHtheGlzOmMsZXBzaWxvbjpmLHNpbXBsaWZpZWQ6ISFifSl9LDkyODMyNToocyxjLGYsYix3LEkpPT57dS5rYihcIk1hdE11bE5CaXRzXCIscyx7azpjLG46ZixhY2N1cmFjeUxldmVsOmIsYml0czp3LGJsb2NrU2l6ZTpJfSl9LDkyODQ1MjoocyxjLGYsYix3LEkpPT57dS5rYihcIk11bHRpSGVhZEF0dGVudGlvblwiLHMse251bUhlYWRzOmMsaXNVbmlkaXJlY3Rpb25hbDpmLG1hc2tGaWx0ZXJWYWx1ZTpiLHNjYWxlOncsZG9Sb3Rhcnk6SX0pfSw5Mjg2MTE6KHMsYyk9Pnt1LmtiKFwiUXVpY2tHZWx1XCIscyx7YWxwaGE6Y30pfSw5Mjg2NzU6KHMsYyxmLGIsdyk9Pnt1LmtiKFwiUm90YXJ5RW1iZWRkaW5nXCIscyx7aW50ZXJsZWF2ZWQ6ISFjLG51bUhlYWRzOmYscm90YXJ5RW1iZWRkaW5nRGltOmIsc2NhbGU6d30pfSw5Mjg4MTQ6KHMsYyxmKT0+e3Uua2IoXCJTa2lwTGF5ZXJOb3JtYWxpemF0aW9uXCIscyx7ZXBzaWxvbjpjLHNpbXBsaWZpZWQ6ISFmfSl9LDkyODkxNjoocyxjLGYpPT57dS5rYihcIlNraXBMYXllck5vcm1hbGl6YXRpb25cIixzLHtlcHNpbG9uOmMsc2ltcGxpZmllZDohIWZ9KX0sOTI5MDE4OihzLGMsZixiKT0+e3Uua2IoXCJHYXRoZXJCbG9ja1F1YW50aXplZFwiLHMse2dhdGhlckF4aXM6YyxxdWFudGl6ZUF4aXM6ZixibG9ja1NpemU6Yn0pfSw5MjkxMzk6cz0+e3UuJGIocyl9LDkyOTE3MzoocyxjKT0+dS5jYyhOdW1iZXIocyksTnVtYmVyKGMpLHUuR2IuaGMsdS5HYi5lcnJvcnMpfTtmdW5jdGlvbiB2YyhzLGMsZil7cmV0dXJuIF9pKGFzeW5jKCk9Pnthd2FpdCB1LlliKE51bWJlcihzKSxOdW1iZXIoYyksTnVtYmVyKGYpKX0pfWZ1bmN0aW9uICRjKCl7cmV0dXJuIHR5cGVvZiB3YXNtT2Zmc2V0Q29udmVydGVyPFwidVwifWZ1bmN0aW9uIHluKHMpe3RoaXMubmFtZT1cIkV4aXRTdGF0dXNcIix0aGlzLm1lc3NhZ2U9YFByb2dyYW0gdGVybWluYXRlZCB3aXRoIGV4aXQoJHtzfSlgLHRoaXMuc3RhdHVzPXN9dmFyIF9uPXM9PntzLnRlcm1pbmF0ZSgpLHMub25tZXNzYWdlPSgpPT57fX0sVm89cz0+e3B0Lmxlbmd0aD09MCYmKHFvKCksRm8ocHRbMF0pKTt2YXIgYz1wdC5wb3AoKTtpZighYylyZXR1cm4gNjt2dC5wdXNoKGMpLFplW3MuQmJdPWMsYy5CYj1zLkJiO3ZhciBmPXtjbWQ6XCJydW5cIixzdGFydF9yb3V0aW5lOnMuaWMsYXJnOnMuUmIscHRocmVhZF9wdHI6cy5CYn07cmV0dXJuIGMucG9zdE1lc3NhZ2UoZixzLm5jKSwwfSx3dD0wLHhlPShzLGMsLi4uZik9Pntmb3IodmFyIGI9MipmLmxlbmd0aCx3PVJuKCksST1Nbig4KmIpLE89ST4+PjMsQj0wO0I8Zi5sZW5ndGg7QisrKXt2YXIgTD1mW0JdO3R5cGVvZiBMPT1cImJpZ2ludFwiPyhxW08rMipCXT0xbixxW08rMipCKzFdPUwpOihxW08rMipCXT0wbixsKClbTysyKkIrMT4+PjBdPUwpfXJldHVybiBzPUdpKHMsMCxiLEksYyksZ3Iodyksc307ZnVuY3Rpb24gd24ocyl7aWYoZylyZXR1cm4geGUoMCwxLHMpO2lmKGVlPXMsISgwPHd0KSl7Zm9yKHZhciBjIG9mIHZ0KV9uKGMpO2ZvcihjIG9mIHB0KV9uKGMpO3B0PVtdLHZ0PVtdLFplPVtdLHdlPSEwfWsocyxuZXcgeW4ocykpfWZ1bmN0aW9uIFdvKHMpe2lmKGcpcmV0dXJuIHhlKDEsMCxzKTt2bihzKX12YXIgdm49cz0+e2lmKGVlPXMsZyl0aHJvdyBXbyhzKSxcInVud2luZFwiO3duKHMpfSxwdD1bXSx2dD1bXSxMbz1bXSxaZT17fSxHbz1zPT57dmFyIGM9cy5CYjtkZWxldGUgWmVbY10scHQucHVzaChzKSx2dC5zcGxpY2UodnQuaW5kZXhPZihzKSwxKSxzLkJiPTAsQm4oYyl9O2Z1bmN0aW9uIEhvKCl7TG8uZm9yRWFjaChzPT5zKCkpfXZhciBGbz1zPT5uZXcgUHJvbWlzZShjPT57cy5vbm1lc3NhZ2U9dz0+e3ZhciBJPSh3PXcuZGF0YSkuY21kO2lmKHcudGFyZ2V0VGhyZWFkJiZ3LnRhcmdldFRocmVhZCE9TXQoKSl7dmFyIE89WmVbdy50YXJnZXRUaHJlYWRdO08/Ty5wb3N0TWVzc2FnZSh3LHcudHJhbnNmZXJMaXN0KTpqKGBJbnRlcm5hbCBlcnJvciEgV29ya2VyIHNlbnQgYSBtZXNzYWdlIFwiJHtJfVwiIHRvIHRhcmdldCBwdGhyZWFkICR7dy50YXJnZXRUaHJlYWR9LCBidXQgdGhhdCB0aHJlYWQgbm8gbG9uZ2VyIGV4aXN0cyFgKX1lbHNlIEk9PT1cImNoZWNrTWFpbGJveFwiP2lyKCk6ST09PVwic3Bhd25UaHJlYWRcIj9Wbyh3KTpJPT09XCJjbGVhbnVwVGhyZWFkXCI/R28oWmVbdy50aHJlYWRdKTpJPT09XCJraWxsVGhyZWFkXCI/KHc9dy50aHJlYWQsST1aZVt3XSxkZWxldGUgWmVbd10sX24oSSksQm4odyksdnQuc3BsaWNlKHZ0LmluZGV4T2YoSSksMSksSS5CYj0wKTpJPT09XCJjYW5jZWxUaHJlYWRcIj9aZVt3LnRocmVhZF0ucG9zdE1lc3NhZ2Uoe2NtZDpcImNhbmNlbFwifSk6ST09PVwibG9hZGVkXCI/KHMubG9hZGVkPSEwLGMocykpOkk9PT1cImFsZXJ0XCI/YWxlcnQoYFRocmVhZCAke3cudGhyZWFkSWR9OiAke3cudGV4dH1gKTp3LnRhcmdldD09PVwic2V0aW1tZWRpYXRlXCI/cy5wb3N0TWVzc2FnZSh3KTpJPT09XCJjYWxsSGFuZGxlclwiP3Vbdy5oYW5kbGVyXSguLi53LmFyZ3MpOkkmJmooYHdvcmtlciBzZW50IGFuIHVua25vd24gY29tbWFuZCAke0l9YCl9LHMub25lcnJvcj13PT57dGhyb3cgaihgd29ya2VyIHNlbnQgYW4gZXJyb3IhICR7dy5maWxlbmFtZX06JHt3LmxpbmVub306ICR7dy5tZXNzYWdlfWApLHd9O3ZhciBmLGI9W107Zm9yKGYgb2ZbXSl1Lmhhc093blByb3BlcnR5KGYpJiZiLnB1c2goZik7cy5wb3N0TWVzc2FnZSh7Y21kOlwibG9hZFwiLGhhbmRsZXJzOmIsd2FzbU1lbW9yeTpzZSx3YXNtTW9kdWxlOll9KX0pO2Z1bmN0aW9uIHFvKCl7dmFyIHM9bmV3IFdvcmtlcihpbXBvcnQubWV0YS51cmwuc3RhcnRzV2l0aChcImZpbGU6XCIpP25ldyBVUkwoXCJvcnQud2ViZ3B1LmJ1bmRsZS5taW4ubWpzXCIsaW1wb3J0Lm1ldGEudXJsKTpuZXcgVVJMKGltcG9ydC5tZXRhLnVybCkse3R5cGU6XCJtb2R1bGVcIix3b3JrZXJEYXRhOlwiZW0tcHRocmVhZFwiLG5hbWU6XCJlbS1wdGhyZWFkXCJ9KTtwdC5wdXNoKHMpfXZhciBvcj1zPT57Zm9yKDswPHMubGVuZ3RoOylzLnNoaWZ0KCkodSl9LHhjPSgpPT57dmFyIHM9TXQoKSxjPWEoKVtzKzUyPj4+Mj4+PjBdO3M9YSgpW3MrNTY+Pj4yPj4+MF0sRmkoYyxjLXMpLGdyKGMpfSxTYz0ocyxjKT0+e3d0PTAscz1xaShzLGMpLDA8d3Q/ZWU9czpocihzKX07Y2xhc3MgVGN7Y29uc3RydWN0b3IoYyl7dGhpcy5LYj1jLTI0fX1mdW5jdGlvbiBJYyhzLGMsZil7dmFyIGI9bmV3IFRjKHM+Pj49MCk7dGhyb3cgYz4+Pj0wLGY+Pj49MCxhKClbYi5LYisxNj4+PjI+Pj4wXT0wLGEoKVtiLktiKzQ+Pj4yPj4+MF09YyxhKClbYi5LYis4Pj4+Mj4+PjBdPWYsc31mdW5jdGlvbiBLbyhzLGMsZixiKXtyZXR1cm4gZz94ZSgyLDEscyxjLGYsYik6am8ocyxjLGYsYil9ZnVuY3Rpb24gam8ocyxjLGYsYil7aWYocz4+Pj0wLGM+Pj49MCxmPj4+PTAsYj4+Pj0wLHg9PT12b2lkIDApcmV0dXJuIGooXCJDdXJyZW50IGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgU2hhcmVkQXJyYXlCdWZmZXIsIHB0aHJlYWRzIGFyZSBub3QgYXZhaWxhYmxlIVwiKSw2O3ZhciB3PVtdO3JldHVybiBnJiZ3Lmxlbmd0aD09PTA/S28ocyxjLGYsYik6KHM9e2ljOmYsQmI6cyxSYjpiLG5jOnd9LGc/KHMuTmI9XCJzcGF3blRocmVhZFwiLHBvc3RNZXNzYWdlKHMsdyksMCk6Vm8ocykpfXZhciBZbz10eXBlb2YgVGV4dERlY29kZXI8XCJ1XCI/bmV3IFRleHREZWNvZGVyKFwidXRmOFwiKTp2b2lkIDAsWm89KHMsYyxmKT0+e3ZhciBiPShjPj4+PTApK2Y7Zm9yKGY9YztzW2ZdJiYhKGY+PWIpOykrK2Y7aWYoMTY8Zi1jJiZzLmJ1ZmZlciYmWW8pcmV0dXJuIFlvLmRlY29kZShzLmJ1ZmZlciBpbnN0YW5jZW9mIHg/cy5zbGljZShjLGYpOnMuc3ViYXJyYXkoYyxmKSk7Zm9yKGI9XCJcIjtjPGY7KXt2YXIgdz1zW2MrK107aWYoMTI4Jncpe3ZhciBJPTYzJnNbYysrXTtpZigoMjI0JncpPT0xOTIpYis9U3RyaW5nLmZyb21DaGFyQ29kZSgoMzEmdyk8PDZ8SSk7ZWxzZXt2YXIgTz02MyZzW2MrK107NjU1MzY+KHc9KDI0MCZ3KT09MjI0PygxNSZ3KTw8MTJ8STw8NnxPOig3JncpPDwxOHxJPDwxMnxPPDw2fDYzJnNbYysrXSk/Yis9U3RyaW5nLmZyb21DaGFyQ29kZSh3KToody09NjU1MzYsYis9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5Nnx3Pj4xMCw1NjMyMHwxMDIzJncpKX19ZWxzZSBiKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHcpfXJldHVybiBifSxDZT0ocyxjKT0+KHM+Pj49MCk/Wm8ocigpLHMsYyk6XCJcIjtmdW5jdGlvbiBRbyhzLGMsZil7cmV0dXJuIGc/eGUoMywxLHMsYyxmKTowfWZ1bmN0aW9uIFhvKHMsYyl7aWYoZylyZXR1cm4geGUoNCwxLHMsYyl9dmFyICRuPXM9Pntmb3IodmFyIGM9MCxmPTA7ZjxzLmxlbmd0aDsrK2Ype3ZhciBiPXMuY2hhckNvZGVBdChmKTsxMjc+PWI/YysrOjIwNDc+PWI/Yys9Mjo1NTI5Njw9YiYmNTczNDM+PWI/KGMrPTQsKytmKTpjKz0zfXJldHVybiBjfSxKbz0ocyxjLGYsYik9PntpZighKDA8YikpcmV0dXJuIDA7dmFyIHc9Zj4+Pj0wO2I9ZitiLTE7Zm9yKHZhciBJPTA7STxzLmxlbmd0aDsrK0kpe3ZhciBPPXMuY2hhckNvZGVBdChJKTtpZig1NTI5Njw9TyYmNTczNDM+PU8mJihPPTY1NTM2KygoMTAyMyZPKTw8MTApfDEwMjMmcy5jaGFyQ29kZUF0KCsrSSkpLDEyNz49Tyl7aWYoZj49YilicmVhaztjW2YrKz4+PjBdPU99ZWxzZXtpZigyMDQ3Pj1PKXtpZihmKzE+PWIpYnJlYWs7Y1tmKys+Pj4wXT0xOTJ8Tz4+Nn1lbHNle2lmKDY1NTM1Pj1PKXtpZihmKzI+PWIpYnJlYWs7Y1tmKys+Pj4wXT0yMjR8Tz4+MTJ9ZWxzZXtpZihmKzM+PWIpYnJlYWs7Y1tmKys+Pj4wXT0yNDB8Tz4+MTgsY1tmKys+Pj4wXT0xMjh8Tz4+MTImNjN9Y1tmKys+Pj4wXT0xMjh8Tz4+NiY2M31jW2YrKz4+PjBdPTEyOHw2MyZPfX1yZXR1cm4gY1tmPj4+MF09MCxmLXd9LE90PShzLGMsZik9PkpvKHMscigpLGMsZik7ZnVuY3Rpb24gZWkocyxjKXtpZihnKXJldHVybiB4ZSg1LDEscyxjKX1mdW5jdGlvbiB0aShzLGMsZil7aWYoZylyZXR1cm4geGUoNiwxLHMsYyxmKX1mdW5jdGlvbiByaShzLGMsZil7cmV0dXJuIGc/eGUoNywxLHMsYyxmKTowfWZ1bmN0aW9uIG5pKHMsYyl7aWYoZylyZXR1cm4geGUoOCwxLHMsYyl9ZnVuY3Rpb24gb2kocyxjLGYpe2lmKGcpcmV0dXJuIHhlKDksMSxzLGMsZil9ZnVuY3Rpb24gaWkocyxjLGYsYil7aWYoZylyZXR1cm4geGUoMTAsMSxzLGMsZixiKX1mdW5jdGlvbiBhaShzLGMsZixiKXtpZihnKXJldHVybiB4ZSgxMSwxLHMsYyxmLGIpfWZ1bmN0aW9uIHNpKHMsYyxmLGIpe2lmKGcpcmV0dXJuIHhlKDEyLDEscyxjLGYsYil9ZnVuY3Rpb24gdWkocyl7aWYoZylyZXR1cm4geGUoMTMsMSxzKX1mdW5jdGlvbiBkaShzLGMpe2lmKGcpcmV0dXJuIHhlKDE0LDEscyxjKX1mdW5jdGlvbiBsaShzLGMsZil7aWYoZylyZXR1cm4geGUoMTUsMSxzLGMsZil9dmFyIGNpLG10LENjPSgpPT57Y3QoXCJcIil9LFFlPXM9Pntmb3IodmFyIGM9XCJcIjtyKClbcz4+PjBdOyljKz1jaVtyKClbcysrPj4+MF1dO3JldHVybiBjfSx4bj17fSxTbj17fSxBYz17fTtmdW5jdGlvbiBzdChzLGMsZj17fSl7aWYoIShcImFyZ1BhY2tBZHZhbmNlXCJpbiBjKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwicmVnaXN0ZXJUeXBlIHJlZ2lzdGVyZWRJbnN0YW5jZSByZXF1aXJlcyBhcmdQYWNrQWR2YW5jZVwiKTtyZXR1cm4gZnVuY3Rpb24oYix3LEk9e30pe3ZhciBPPXcubmFtZTtpZighYil0aHJvdyBuZXcgbXQoYHR5cGUgXCIke099XCIgbXVzdCBoYXZlIGEgcG9zaXRpdmUgaW50ZWdlciB0eXBlaWQgcG9pbnRlcmApO2lmKFNuLmhhc093blByb3BlcnR5KGIpKXtpZihJLlRiKXJldHVybjt0aHJvdyBuZXcgbXQoYENhbm5vdCByZWdpc3RlciB0eXBlICcke099JyB0d2ljZWApfVNuW2JdPXcsZGVsZXRlIEFjW2JdLHhuLmhhc093blByb3BlcnR5KGIpJiYodz14bltiXSxkZWxldGUgeG5bYl0sdy5mb3JFYWNoKEI9PkIoKSkpfShzLGMsZil9dmFyIHBpPShzLGMsZik9Pntzd2l0Y2goYyl7Y2FzZSAxOnJldHVybiBmP2I9PnQoKVtiPj4+MF06Yj0+cigpW2I+Pj4wXTtjYXNlIDI6cmV0dXJuIGY/Yj0+bigpW2I+Pj4xPj4+MF06Yj0+bygpW2I+Pj4xPj4+MF07Y2FzZSA0OnJldHVybiBmP2I9PmkoKVtiPj4+Mj4+PjBdOmI9PmEoKVtiPj4+Mj4+PjBdO2Nhc2UgODpyZXR1cm4gZj9iPT5xW2I+Pj4zXTpiPT5oZVtiPj4+M107ZGVmYXVsdDp0aHJvdyBuZXcgVHlwZUVycm9yKGBpbnZhbGlkIGludGVnZXIgd2lkdGggKCR7Y30pOiAke3N9YCl9fTtmdW5jdGlvbiBrYyhzLGMsZil7Zj4+Pj0wLHN0KHM+Pj49MCx7bmFtZTpjPVFlKGM+Pj4wKSxmcm9tV2lyZVR5cGU6Yj0+Yix0b1dpcmVUeXBlOmZ1bmN0aW9uKGIsdyl7aWYodHlwZW9mIHchPVwiYmlnaW50XCImJnR5cGVvZiB3IT1cIm51bWJlclwiKXRocm93IHc9dz09PW51bGw/XCJudWxsXCI6KGI9dHlwZW9mIHcpPT1cIm9iamVjdFwifHxiPT09XCJhcnJheVwifHxiPT09XCJmdW5jdGlvblwiP3cudG9TdHJpbmcoKTpcIlwiK3csbmV3IFR5cGVFcnJvcihgQ2Fubm90IGNvbnZlcnQgXCIke3d9XCIgdG8gJHt0aGlzLm5hbWV9YCk7cmV0dXJuIHR5cGVvZiB3PT1cIm51bWJlclwiJiYodz1CaWdJbnQodykpLHd9LGFyZ1BhY2tBZHZhbmNlOmZ0LHJlYWRWYWx1ZUZyb21Qb2ludGVyOnBpKGMsZixjLmluZGV4T2YoXCJ1XCIpPT0tMSksRWI6bnVsbH0pfXZhciBmdD04O2Z1bmN0aW9uIEVjKHMsYyxmLGIpe3N0KHM+Pj49MCx7bmFtZTpjPVFlKGM+Pj4wKSxmcm9tV2lyZVR5cGU6ZnVuY3Rpb24odyl7cmV0dXJuISF3fSx0b1dpcmVUeXBlOmZ1bmN0aW9uKHcsSSl7cmV0dXJuIEk/ZjpifSxhcmdQYWNrQWR2YW5jZTpmdCxyZWFkVmFsdWVGcm9tUG9pbnRlcjpmdW5jdGlvbih3KXtyZXR1cm4gdGhpcy5mcm9tV2lyZVR5cGUocigpW3c+Pj4wXSl9LEViOm51bGx9KX12YXIgVG49W10sdXQ9W107ZnVuY3Rpb24gSW4ocyl7OTwocz4+Pj0wKSYmLS11dFtzKzFdPT0wJiYodXRbc109dm9pZCAwLFRuLnB1c2gocykpfXZhciBNZT1zPT57aWYoIXMpdGhyb3cgbmV3IG10KFwiQ2Fubm90IHVzZSBkZWxldGVkIHZhbC4gaGFuZGxlID0gXCIrcyk7cmV0dXJuIHV0W3NdfSxWZT1zPT57c3dpdGNoKHMpe2Nhc2Ugdm9pZCAwOnJldHVybiAyO2Nhc2UgbnVsbDpyZXR1cm4gNDtjYXNlITA6cmV0dXJuIDY7Y2FzZSExOnJldHVybiA4O2RlZmF1bHQ6bGV0IGM9VG4ucG9wKCl8fHV0Lmxlbmd0aDtyZXR1cm4gdXRbY109cyx1dFtjKzFdPTEsY319O2Z1bmN0aW9uIENuKHMpe3JldHVybiB0aGlzLmZyb21XaXJlVHlwZShhKClbcz4+PjI+Pj4wXSl9dmFyIFBjPXtuYW1lOlwiZW1zY3JpcHRlbjo6dmFsXCIsZnJvbVdpcmVUeXBlOnM9Pnt2YXIgYz1NZShzKTtyZXR1cm4gSW4ocyksY30sdG9XaXJlVHlwZToocyxjKT0+VmUoYyksYXJnUGFja0FkdmFuY2U6ZnQscmVhZFZhbHVlRnJvbVBvaW50ZXI6Q24sRWI6bnVsbH07ZnVuY3Rpb24gemMocyl7cmV0dXJuIHN0KHM+Pj4wLFBjKX12YXIgT2M9KHMsYyk9Pntzd2l0Y2goYyl7Y2FzZSA0OnJldHVybiBmdW5jdGlvbihmKXtyZXR1cm4gdGhpcy5mcm9tV2lyZVR5cGUoZCgpW2Y+Pj4yPj4+MF0pfTtjYXNlIDg6cmV0dXJuIGZ1bmN0aW9uKGYpe3JldHVybiB0aGlzLmZyb21XaXJlVHlwZShsKClbZj4+PjM+Pj4wXSl9O2RlZmF1bHQ6dGhyb3cgbmV3IFR5cGVFcnJvcihgaW52YWxpZCBmbG9hdCB3aWR0aCAoJHtjfSk6ICR7c31gKX19O2Z1bmN0aW9uIERjKHMsYyxmKXtmPj4+PTAsc3Qocz4+Pj0wLHtuYW1lOmM9UWUoYz4+PjApLGZyb21XaXJlVHlwZTpiPT5iLHRvV2lyZVR5cGU6KGIsdyk9PncsYXJnUGFja0FkdmFuY2U6ZnQscmVhZFZhbHVlRnJvbVBvaW50ZXI6T2MoYyxmKSxFYjpudWxsfSl9ZnVuY3Rpb24gQmMocyxjLGYsYix3KXtpZihzPj4+PTAsZj4+Pj0wLGM9UWUoYz4+PjApLHc9PT0tMSYmKHc9NDI5NDk2NzI5NSksdz1CPT5CLGI9PT0wKXt2YXIgST0zMi04KmY7dz1CPT5CPDxJPj4+SX12YXIgTz1jLmluY2x1ZGVzKFwidW5zaWduZWRcIik/ZnVuY3Rpb24oQixMKXtyZXR1cm4gTD4+PjB9OmZ1bmN0aW9uKEIsTCl7cmV0dXJuIEx9O3N0KHMse25hbWU6Yyxmcm9tV2lyZVR5cGU6dyx0b1dpcmVUeXBlOk8sYXJnUGFja0FkdmFuY2U6ZnQscmVhZFZhbHVlRnJvbVBvaW50ZXI6cGkoYyxmLGIhPT0wKSxFYjpudWxsfSl9ZnVuY3Rpb24gTWMocyxjLGYpe2Z1bmN0aW9uIGIoSSl7dmFyIE89YSgpW0k+Pj4yPj4+MF07cmV0dXJuIEk9YSgpW0krND4+PjI+Pj4wXSxuZXcgdyh0KCkuYnVmZmVyLEksTyl9dmFyIHc9W0ludDhBcnJheSxVaW50OEFycmF5LEludDE2QXJyYXksVWludDE2QXJyYXksSW50MzJBcnJheSxVaW50MzJBcnJheSxGbG9hdDMyQXJyYXksRmxvYXQ2NEFycmF5LEJpZ0ludDY0QXJyYXksQmlnVWludDY0QXJyYXldW2NdO3N0KHM+Pj49MCx7bmFtZTpmPVFlKGY+Pj4wKSxmcm9tV2lyZVR5cGU6YixhcmdQYWNrQWR2YW5jZTpmdCxyZWFkVmFsdWVGcm9tUG9pbnRlcjpifSx7VGI6ITB9KX1mdW5jdGlvbiBSYyhzLGMpe3M+Pj49MDt2YXIgZj0oYz1RZShjPj4+MCkpPT09XCJzdGQ6OnN0cmluZ1wiO3N0KHMse25hbWU6Yyxmcm9tV2lyZVR5cGU6ZnVuY3Rpb24oYil7dmFyIHc9YSgpW2I+Pj4yPj4+MF0sST1iKzQ7aWYoZilmb3IodmFyIE89SSxCPTA7Qjw9dzsrK0Ipe3ZhciBMPUkrQjtpZihCPT13fHxyKClbTD4+PjBdPT0wKXtpZihPPUNlKE8sTC1PKSxIPT09dm9pZCAwKXZhciBIPU87ZWxzZSBIKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDApLEgrPU87Tz1MKzF9fWVsc2V7Zm9yKEg9QXJyYXkodyksQj0wO0I8dzsrK0IpSFtCXT1TdHJpbmcuZnJvbUNoYXJDb2RlKHIoKVtJK0I+Pj4wXSk7SD1ILmpvaW4oXCJcIil9cmV0dXJuIEplKGIpLEh9LHRvV2lyZVR5cGU6ZnVuY3Rpb24oYix3KXt3IGluc3RhbmNlb2YgQXJyYXlCdWZmZXImJih3PW5ldyBVaW50OEFycmF5KHcpKTt2YXIgST10eXBlb2Ygdz09XCJzdHJpbmdcIjtpZighKEl8fHcgaW5zdGFuY2VvZiBVaW50OEFycmF5fHx3IGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXl8fHcgaW5zdGFuY2VvZiBJbnQ4QXJyYXkpKXRocm93IG5ldyBtdChcIkNhbm5vdCBwYXNzIG5vbi1zdHJpbmcgdG8gc3RkOjpzdHJpbmdcIik7dmFyIE89ZiYmST8kbih3KTp3Lmxlbmd0aCxCPWZyKDQrTysxKSxMPUIrNDtpZihhKClbQj4+PjI+Pj4wXT1PLGYmJkkpT3QodyxMLE8rMSk7ZWxzZSBpZihJKWZvcihJPTA7STxPOysrSSl7dmFyIEg9dy5jaGFyQ29kZUF0KEkpO2lmKDI1NTxIKXRocm93IEplKEwpLG5ldyBtdChcIlN0cmluZyBoYXMgVVRGLTE2IGNvZGUgdW5pdHMgdGhhdCBkbyBub3QgZml0IGluIDggYml0c1wiKTtyKClbTCtJPj4+MF09SH1lbHNlIGZvcihJPTA7STxPOysrSSlyKClbTCtJPj4+MF09d1tJXTtyZXR1cm4gYiE9PW51bGwmJmIucHVzaChKZSxCKSxCfSxhcmdQYWNrQWR2YW5jZTpmdCxyZWFkVmFsdWVGcm9tUG9pbnRlcjpDbixFYihiKXtKZShiKX19KX12YXIgbWk9dHlwZW9mIFRleHREZWNvZGVyPFwidVwiP25ldyBUZXh0RGVjb2RlcihcInV0Zi0xNmxlXCIpOnZvaWQgMCxVYz0ocyxjKT0+e2Zvcih2YXIgZj1zPj4xLGI9ZitjLzI7IShmPj1iKSYmbygpW2Y+Pj4wXTspKytmO2lmKDMyPChmPDw9MSktcyYmbWkpcmV0dXJuIG1pLmRlY29kZShyKCkuc2xpY2UocyxmKSk7Zm9yKGY9XCJcIixiPTA7IShiPj1jLzIpOysrYil7dmFyIHc9bigpW3MrMipiPj4+MT4+PjBdO2lmKHc9PTApYnJlYWs7Zis9U3RyaW5nLmZyb21DaGFyQ29kZSh3KX1yZXR1cm4gZn0sTmM9KHMsYyxmKT0+e2lmKGY/Pz0yMTQ3NDgzNjQ3LDI+ZilyZXR1cm4gMDt2YXIgYj1jO2Y9KGYtPTIpPDIqcy5sZW5ndGg/Zi8yOnMubGVuZ3RoO2Zvcih2YXIgdz0wO3c8ZjsrK3cpe3ZhciBJPXMuY2hhckNvZGVBdCh3KTtuKClbYz4+PjE+Pj4wXT1JLGMrPTJ9cmV0dXJuIG4oKVtjPj4+MT4+PjBdPTAsYy1ifSxWYz1zPT4yKnMubGVuZ3RoLFdjPShzLGMpPT57Zm9yKHZhciBmPTAsYj1cIlwiOyEoZj49Yy80KTspe3ZhciB3PWkoKVtzKzQqZj4+PjI+Pj4wXTtpZih3PT0wKWJyZWFrOysrZiw2NTUzNjw9dz8ody09NjU1MzYsYis9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5Nnx3Pj4xMCw1NjMyMHwxMDIzJncpKTpiKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHcpfXJldHVybiBifSxMYz0ocyxjLGYpPT57aWYoYz4+Pj0wLGY/Pz0yMTQ3NDgzNjQ3LDQ+ZilyZXR1cm4gMDt2YXIgYj1jO2Y9YitmLTQ7Zm9yKHZhciB3PTA7dzxzLmxlbmd0aDsrK3cpe3ZhciBJPXMuY2hhckNvZGVBdCh3KTtpZig1NTI5Njw9SSYmNTczNDM+PUkmJihJPTY1NTM2KygoMTAyMyZJKTw8MTApfDEwMjMmcy5jaGFyQ29kZUF0KCsrdykpLGkoKVtjPj4+Mj4+PjBdPUksKGMrPTQpKzQ+ZilicmVha31yZXR1cm4gaSgpW2M+Pj4yPj4+MF09MCxjLWJ9LEdjPXM9Pntmb3IodmFyIGM9MCxmPTA7ZjxzLmxlbmd0aDsrK2Ype3ZhciBiPXMuY2hhckNvZGVBdChmKTs1NTI5Njw9YiYmNTczNDM+PWImJisrZixjKz00fXJldHVybiBjfTtmdW5jdGlvbiBIYyhzLGMsZil7aWYocz4+Pj0wLGM+Pj49MCxmPVFlKGY+Pj49MCksYz09PTIpdmFyIGI9VWMsdz1OYyxJPVZjLE89Qj0+bygpW0I+Pj4xPj4+MF07ZWxzZSBjPT09NCYmKGI9V2Msdz1MYyxJPUdjLE89Qj0+YSgpW0I+Pj4yPj4+MF0pO3N0KHMse25hbWU6Zixmcm9tV2lyZVR5cGU6Qj0+e2Zvcih2YXIgTCxIPWEoKVtCPj4+Mj4+PjBdLFg9Qis0LGNlPTA7Y2U8PUg7KytjZSl7dmFyIGdlPUIrNCtjZSpjO2NlIT1IJiZPKGdlKSE9MHx8KFg9YihYLGdlLVgpLEw9PT12b2lkIDA/TD1YOihMKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDApLEwrPVgpLFg9Z2UrYyl9cmV0dXJuIEplKEIpLEx9LHRvV2lyZVR5cGU6KEIsTCk9PntpZih0eXBlb2YgTCE9XCJzdHJpbmdcIil0aHJvdyBuZXcgbXQoYENhbm5vdCBwYXNzIG5vbi1zdHJpbmcgdG8gQysrIHN0cmluZyB0eXBlICR7Zn1gKTt2YXIgSD1JKEwpLFg9ZnIoNCtIK2MpO3JldHVybiBhKClbWD4+PjI+Pj4wXT1IL2MsdyhMLFgrNCxIK2MpLEIhPT1udWxsJiZCLnB1c2goSmUsWCksWH0sYXJnUGFja0FkdmFuY2U6ZnQscmVhZFZhbHVlRnJvbVBvaW50ZXI6Q24sRWIoQil7SmUoQil9fSl9ZnVuY3Rpb24gRmMocyxjKXtzdChzPj4+PTAse1ViOiEwLG5hbWU6Yz1RZShjPj4+MCksYXJnUGFja0FkdmFuY2U6MCxmcm9tV2lyZVR5cGU6KCk9Pnt9LHRvV2lyZVR5cGU6KCk9Pnt9fSl9dmFyIHFjPSgpPT4xO2Z1bmN0aW9uIEtjKHMpe0RuKHM+Pj4wLCF5LDEsIV8sMTMxMDcyLCExKSxIbygpfXZhciBmaT1zPT57aWYoIXdlKXRyeXtpZihzKCksISgwPHd0KSl0cnl7Zz9ocihlZSk6dm4oZWUpfWNhdGNoKGMpe2MgaW5zdGFuY2VvZiB5bnx8Yz09XCJ1bndpbmRcInx8aygxLGMpfX1jYXRjaChjKXtjIGluc3RhbmNlb2YgeW58fGM9PVwidW53aW5kXCJ8fGsoMSxjKX19O2Z1bmN0aW9uIEFuKHMpe3M+Pj49MCx0eXBlb2YgQXRvbWljcy5vYz09XCJmdW5jdGlvblwiJiYoQXRvbWljcy5vYyhpKCkscz4+PjIscykudmFsdWUudGhlbihpcikscys9MTI4LEF0b21pY3Muc3RvcmUoaSgpLHM+Pj4yLDEpKX12YXIgaXI9KCk9Pnt2YXIgcz1NdCgpO3MmJihBbihzKSxmaShIaSkpfTtmdW5jdGlvbiBqYyhzLGMpeyhzPj4+PTApPT1jPj4+MD9zZXRUaW1lb3V0KGlyKTpnP3Bvc3RNZXNzYWdlKHt0YXJnZXRUaHJlYWQ6cyxjbWQ6XCJjaGVja01haWxib3hcIn0pOihzPVplW3NdKSYmcy5wb3N0TWVzc2FnZSh7Y21kOlwiY2hlY2tNYWlsYm94XCJ9KX12YXIga249W107ZnVuY3Rpb24gWWMocyxjLGYsYix3KXtmb3IoYz4+Pj0wLGIvPTIsa24ubGVuZ3RoPWIsZj13Pj4+MD4+PjMsdz0wO3c8Yjt3Kyspa25bd109cVtmKzIqd10/cVtmKzIqdysxXTpsKClbZisyKncrMT4+PjBdO3JldHVybihjP2JuW2NdOk5wW3NdKSguLi5rbil9ZnVuY3Rpb24gWmMocyl7cz4+Pj0wLGc/cG9zdE1lc3NhZ2Uoe2NtZDpcImNsZWFudXBUaHJlYWRcIix0aHJlYWQ6c30pOkdvKFplW3NdKX1mdW5jdGlvbiBRYyhzKXt9dmFyIGFyPShzLGMpPT57dmFyIGY9U25bc107aWYoZj09PXZvaWQgMCl0aHJvdyBzPVZpKHMpLGY9UWUocyksSmUocyksbmV3IG10KGAke2N9IGhhcyB1bmtub3duIHR5cGUgJHtmfWApO3JldHVybiBmfSxoaT0ocyxjLGYpPT57dmFyIGI9W107cmV0dXJuIHM9cy50b1dpcmVUeXBlKGIsZiksYi5sZW5ndGgmJihhKClbYz4+PjI+Pj4wXT1WZShiKSksc307ZnVuY3Rpb24gWGMocyxjLGYpe3JldHVybiBjPj4+PTAsZj4+Pj0wLHM9TWUocz4+PjApLGM9YXIoYyxcImVtdmFsOjphc1wiKSxoaShjLGYscyl9ZnVuY3Rpb24gSmMocyxjKXtyZXR1cm4gYz4+Pj0wLHM9TWUocz4+PjApLChjPWFyKGMsXCJlbXZhbDo6YXNcIikpLnRvV2lyZVR5cGUobnVsbCxzKX12YXIgc3I9cz0+e3RyeXtzKCl9Y2F0Y2goYyl7Y3QoYyl9fSxodD0wLFhlPW51bGwsZ2k9MCx1cj1bXSxiaT17fSx5aT17fSxlcD0wLEVuPW51bGwsdHA9W107ZnVuY3Rpb24gX2kocyl7cmV0dXJuIGZ1bmN0aW9uKGMpe2lmKCF3ZSl7aWYoaHQ9PT0wKXt2YXIgZj0hMSxiPSExO2MoKHc9MCk9PntpZighd2UmJihnaT13LGY9ITAsYikpe2h0PTIsc3IoKCk9PllpKFhlKSksdHlwZW9mIEJyb3dzZXI8XCJ1XCImJkJyb3dzZXIuTGIuU2ImJkJyb3dzZXIuTGIucmVzdW1lKCksdz0hMTt0cnl7dmFyIEk9ZnVuY3Rpb24oKXt2YXIgTD1pKClbWGUrOD4+PjI+Pj4wXTtyZXR1cm4gTD1aW3lpW0xdXSwtLXd0LEwoKX0oKX1jYXRjaChMKXtJPUwsdz0hMH12YXIgTz0hMTtpZighWGUpe3ZhciBCPUVuO0ImJihFbj1udWxsLCh3P0IucmVqZWN0OkIucmVzb2x2ZSkoSSksTz0hMCl9aWYodyYmIU8pdGhyb3cgSX19KSxiPSEwLGZ8fChodD0xLFhlPWZ1bmN0aW9uKCl7dmFyIHc9ZnIoNjU1NDgpLEk9dysxMjthKClbdz4+PjI+Pj4wXT1JLGEoKVt3KzQ+Pj4yPj4+MF09SSs2NTUzNixJPXVyWzBdO3ZhciBPPWJpW0ldO3JldHVybiBPPT09dm9pZCAwJiYoTz1lcCsrLGJpW0ldPU8seWlbT109SSksST1PLGkoKVt3Kzg+Pj4yPj4+MF09SSx3fSgpLHR5cGVvZiBCcm93c2VyPFwidVwiJiZCcm93c2VyLkxiLlNiJiZCcm93c2VyLkxiLnBhdXNlKCksc3IoKCk9PktpKFhlKSkpfWVsc2UgaHQ9PT0yPyhodD0wLHNyKFppKSxKZShYZSksWGU9bnVsbCx0cC5mb3JFYWNoKGZpKSk6Y3QoYGludmFsaWQgc3RhdGU6ICR7aHR9YCk7cmV0dXJuIGdpfX0oYz0+e3MoKS50aGVuKGMpfSl9ZnVuY3Rpb24gcnAocyl7cmV0dXJuIHM+Pj49MCxfaSgoKT0+KHM9TWUocykpLnRoZW4oVmUpKX12YXIgZHI9W107ZnVuY3Rpb24gbnAocyxjLGYsYil7cmV0dXJuIGY+Pj49MCxiPj4+PTAsKHM9ZHJbcz4+PjBdKShudWxsLGM9TWUoYz4+PjApLGYsYil9dmFyIG9wPXt9LGxyPXM9Pnt2YXIgYz1vcFtzXTtyZXR1cm4gYz09PXZvaWQgMD9RZShzKTpjfTtmdW5jdGlvbiBpcChzLGMsZixiLHcpe3JldHVybiBmPj4+PTAsYj4+Pj0wLHc+Pj49MCwocz1kcltzPj4+MF0pKGM9TWUoYz4+PjApLGNbZj1scihmKV0sYix3KX12YXIgd2k9KCk9PnR5cGVvZiBnbG9iYWxUaGlzPT1cIm9iamVjdFwiP2dsb2JhbFRoaXM6RnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO2Z1bmN0aW9uIGFwKHMpe3JldHVybihzPj4+PTApPT0wP1ZlKHdpKCkpOihzPWxyKHMpLFZlKHdpKClbc10pKX12YXIgc3A9cz0+e3ZhciBjPWRyLmxlbmd0aDtyZXR1cm4gZHIucHVzaChzKSxjfSx1cD0ocyxjKT0+e2Zvcih2YXIgZj1BcnJheShzKSxiPTA7YjxzOysrYilmW2JdPWFyKGEoKVtjKzQqYj4+PjI+Pj4wXSxcInBhcmFtZXRlciBcIitiKTtyZXR1cm4gZn0sdmk9KHMsYyk9Pk9iamVjdC5kZWZpbmVQcm9wZXJ0eShjLFwibmFtZVwiLHt2YWx1ZTpzfSk7ZnVuY3Rpb24gZHAocyxjLGYpe3ZhciBiPShjPXVwKHMsYz4+PjApKS5zaGlmdCgpO3MtLTt2YXIgdz1gcmV0dXJuIGZ1bmN0aW9uIChvYmosIGZ1bmMsIGRlc3RydWN0b3JzUmVmLCBhcmdzKSB7XG5gLEk9MCxPPVtdO2Y9PT0wJiZPLnB1c2goXCJvYmpcIik7Zm9yKHZhciBCPVtcInJldFR5cGVcIl0sTD1bYl0sSD0wO0g8czsrK0gpTy5wdXNoKFwiYXJnXCIrSCksQi5wdXNoKFwiYXJnVHlwZVwiK0gpLEwucHVzaChjW0hdKSx3Kz1gICB2YXIgYXJnJHtIfSA9IGFyZ1R5cGUke0h9LnJlYWRWYWx1ZUZyb21Qb2ludGVyKGFyZ3Mke0k/XCIrXCIrSTpcIlwifSk7XG5gLEkrPWNbSF0uYXJnUGFja0FkdmFuY2U7cmV0dXJuIHcrPWAgIHZhciBydiA9ICR7Zj09PTE/XCJuZXcgZnVuY1wiOlwiZnVuYy5jYWxsXCJ9KCR7Ty5qb2luKFwiLCBcIil9KTtcbmAsYi5VYnx8KEIucHVzaChcImVtdmFsX3JldHVyblZhbHVlXCIpLEwucHVzaChoaSksdys9YCAgcmV0dXJuIGVtdmFsX3JldHVyblZhbHVlKHJldFR5cGUsIGRlc3RydWN0b3JzUmVmLCBydik7XG5gKSxCLnB1c2godytgfTtcbmApLHM9ZnVuY3Rpb24oWCl7dmFyIGNlPUZ1bmN0aW9uO2lmKCEoY2UgaW5zdGFuY2VvZiBGdW5jdGlvbikpdGhyb3cgbmV3IFR5cGVFcnJvcihgbmV3XyBjYWxsZWQgd2l0aCBjb25zdHJ1Y3RvciB0eXBlICR7dHlwZW9mIGNlfSB3aGljaCBpcyBub3QgYSBmdW5jdGlvbmApO3ZhciBnZT12aShjZS5uYW1lfHxcInVua25vd25GdW5jdGlvbk5hbWVcIixmdW5jdGlvbigpe30pO3JldHVybiBnZS5wcm90b3R5cGU9Y2UucHJvdG90eXBlLGdlPW5ldyBnZSwoWD1jZS5hcHBseShnZSxYKSlpbnN0YW5jZW9mIE9iamVjdD9YOmdlfShCKSguLi5MKSxmPWBtZXRob2RDYWxsZXI8KCR7Yy5tYXAoWD0+WC5uYW1lKS5qb2luKFwiLCBcIil9KSA9PiAke2IubmFtZX0+YCxzcCh2aShmLHMpKX1mdW5jdGlvbiBscChzKXtyZXR1cm4gcz1scihzPj4+MCksVmUodVtzXSl9ZnVuY3Rpb24gY3AocyxjKXtyZXR1cm4gYz4+Pj0wLHM9TWUocz4+PjApLGM9TWUoYyksVmUoc1tjXSl9ZnVuY3Rpb24gcHAocyl7OTwocz4+Pj0wKSYmKHV0W3MrMV0rPTEpfWZ1bmN0aW9uIG1wKCl7cmV0dXJuIFZlKFtdKX1mdW5jdGlvbiBmcChzKXtzPU1lKHM+Pj4wKTtmb3IodmFyIGM9QXJyYXkocy5sZW5ndGgpLGY9MDtmPHMubGVuZ3RoO2YrKyljW2ZdPXNbZl07cmV0dXJuIFZlKGMpfWZ1bmN0aW9uIGhwKHMpe3JldHVybiBWZShscihzPj4+MCkpfWZ1bmN0aW9uIGdwKCl7cmV0dXJuIFZlKHt9KX1mdW5jdGlvbiBicChzKXtmb3IodmFyIGM9TWUocz4+Pj0wKTtjLmxlbmd0aDspe3ZhciBmPWMucG9wKCk7Yy5wb3AoKShmKX1JbihzKX1mdW5jdGlvbiB5cChzLGMsZil7Yz4+Pj0wLGY+Pj49MCxzPU1lKHM+Pj4wKSxjPU1lKGMpLGY9TWUoZiksc1tjXT1mfWZ1bmN0aW9uIF9wKHMsYyl7cmV0dXJuIGM+Pj49MCxzPShzPWFyKHM+Pj4wLFwiX2VtdmFsX3Rha2VfdmFsdWVcIikpLnJlYWRWYWx1ZUZyb21Qb2ludGVyKGMpLFZlKHMpfWZ1bmN0aW9uIHdwKHMsYyl7cz0tOTAwNzE5OTI1NDc0MDk5Mj5zfHw5MDA3MTk5MjU0NzQwOTkyPHM/TmFOOk51bWJlcihzKSxjPj4+PTAscz1uZXcgRGF0ZSgxZTMqcyksaSgpW2M+Pj4yPj4+MF09cy5nZXRVVENTZWNvbmRzKCksaSgpW2MrND4+PjI+Pj4wXT1zLmdldFVUQ01pbnV0ZXMoKSxpKClbYys4Pj4+Mj4+PjBdPXMuZ2V0VVRDSG91cnMoKSxpKClbYysxMj4+PjI+Pj4wXT1zLmdldFVUQ0RhdGUoKSxpKClbYysxNj4+PjI+Pj4wXT1zLmdldFVUQ01vbnRoKCksaSgpW2MrMjA+Pj4yPj4+MF09cy5nZXRVVENGdWxsWWVhcigpLTE5MDAsaSgpW2MrMjQ+Pj4yPj4+MF09cy5nZXRVVENEYXkoKSxzPShzLmdldFRpbWUoKS1EYXRlLlVUQyhzLmdldFVUQ0Z1bGxZZWFyKCksMCwxLDAsMCwwLDApKS84NjRlNXwwLGkoKVtjKzI4Pj4+Mj4+PjBdPXN9dmFyIER0PXM9PnMlND09MCYmKHMlMTAwIT0wfHxzJTQwMD09MCksJGk9WzAsMzEsNjAsOTEsMTIxLDE1MiwxODIsMjEzLDI0NCwyNzQsMzA1LDMzNV0seGk9WzAsMzEsNTksOTAsMTIwLDE1MSwxODEsMjEyLDI0MywyNzMsMzA0LDMzNF07ZnVuY3Rpb24gdnAocyxjKXtzPS05MDA3MTk5MjU0NzQwOTkyPnN8fDkwMDcxOTkyNTQ3NDA5OTI8cz9OYU46TnVtYmVyKHMpLGM+Pj49MCxzPW5ldyBEYXRlKDFlMypzKSxpKClbYz4+PjI+Pj4wXT1zLmdldFNlY29uZHMoKSxpKClbYys0Pj4+Mj4+PjBdPXMuZ2V0TWludXRlcygpLGkoKVtjKzg+Pj4yPj4+MF09cy5nZXRIb3VycygpLGkoKVtjKzEyPj4+Mj4+PjBdPXMuZ2V0RGF0ZSgpLGkoKVtjKzE2Pj4+Mj4+PjBdPXMuZ2V0TW9udGgoKSxpKClbYysyMD4+PjI+Pj4wXT1zLmdldEZ1bGxZZWFyKCktMTkwMCxpKClbYysyND4+PjI+Pj4wXT1zLmdldERheSgpO3ZhciBmPShEdChzLmdldEZ1bGxZZWFyKCkpPyRpOnhpKVtzLmdldE1vbnRoKCldK3MuZ2V0RGF0ZSgpLTF8MDtpKClbYysyOD4+PjI+Pj4wXT1mLGkoKVtjKzM2Pj4+Mj4+PjBdPS02MCpzLmdldFRpbWV6b25lT2Zmc2V0KCksZj1uZXcgRGF0ZShzLmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciBiPW5ldyBEYXRlKHMuZ2V0RnVsbFllYXIoKSwwLDEpLmdldFRpbWV6b25lT2Zmc2V0KCk7cz0wfChmIT1iJiZzLmdldFRpbWV6b25lT2Zmc2V0KCk9PU1hdGgubWluKGIsZikpLGkoKVtjKzMyPj4+Mj4+PjBdPXN9ZnVuY3Rpb24gJHAocyl7cz4+Pj0wO3ZhciBjPW5ldyBEYXRlKGkoKVtzKzIwPj4+Mj4+PjBdKzE5MDAsaSgpW3MrMTY+Pj4yPj4+MF0saSgpW3MrMTI+Pj4yPj4+MF0saSgpW3MrOD4+PjI+Pj4wXSxpKClbcys0Pj4+Mj4+PjBdLGkoKVtzPj4+Mj4+PjBdLDApLGY9aSgpW3MrMzI+Pj4yPj4+MF0sYj1jLmdldFRpbWV6b25lT2Zmc2V0KCksdz1uZXcgRGF0ZShjLmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpLEk9bmV3IERhdGUoYy5nZXRGdWxsWWVhcigpLDAsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKSxPPU1hdGgubWluKEksdyk7cmV0dXJuIDA+Zj9pKClbcyszMj4+PjI+Pj4wXT0rKHchPUkmJk89PWIpOjA8ZiE9KE89PWIpJiYodz1NYXRoLm1heChJLHcpLGMuc2V0VGltZShjLmdldFRpbWUoKSs2ZTQqKCgwPGY/Tzp3KS1iKSkpLGkoKVtzKzI0Pj4+Mj4+PjBdPWMuZ2V0RGF5KCksZj0oRHQoYy5nZXRGdWxsWWVhcigpKT8kaTp4aSlbYy5nZXRNb250aCgpXStjLmdldERhdGUoKS0xfDAsaSgpW3MrMjg+Pj4yPj4+MF09ZixpKClbcz4+PjI+Pj4wXT1jLmdldFNlY29uZHMoKSxpKClbcys0Pj4+Mj4+PjBdPWMuZ2V0TWludXRlcygpLGkoKVtzKzg+Pj4yPj4+MF09Yy5nZXRIb3VycygpLGkoKVtzKzEyPj4+Mj4+PjBdPWMuZ2V0RGF0ZSgpLGkoKVtzKzE2Pj4+Mj4+PjBdPWMuZ2V0TW9udGgoKSxpKClbcysyMD4+PjI+Pj4wXT1jLmdldFllYXIoKSxzPWMuZ2V0VGltZSgpLEJpZ0ludChpc05hTihzKT8tMTpzLzFlMyl9ZnVuY3Rpb24gU2kocyxjLGYsYix3LEksTyl7cmV0dXJuIGc/eGUoMTYsMSxzLGMsZixiLHcsSSxPKTotNTJ9ZnVuY3Rpb24gVGkocyxjLGYsYix3LEkpe2lmKGcpcmV0dXJuIHhlKDE3LDEscyxjLGYsYix3LEkpfWZ1bmN0aW9uIHhwKHMsYyxmLGIpe3M+Pj49MCxjPj4+PTAsZj4+Pj0wLGI+Pj49MDt2YXIgdz1uZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCksST1uZXcgRGF0ZSh3LDAsMSksTz1uZXcgRGF0ZSh3LDYsMSk7dz1JLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIEI9Ty5nZXRUaW1lem9uZU9mZnNldCgpLEw9TWF0aC5tYXgodyxCKTthKClbcz4+PjI+Pj4wXT02MCpMLGkoKVtjPj4+Mj4+PjBdPSsodyE9QiksST0ocz1IPT5ILnRvTG9jYWxlVGltZVN0cmluZyh2b2lkIDAse2hvdXIxMjohMSx0aW1lWm9uZU5hbWU6XCJzaG9ydFwifSkuc3BsaXQoXCIgXCIpWzFdKShJKSxPPXMoTyksQjx3PyhPdChJLGYsMTcpLE90KE8sYiwxNykpOihPdChJLGIsMTcpLE90KE8sZiwxNykpfXZhciBQbj1bXSxJaT0ocyxjKT0+e1BuLmxlbmd0aD0wO2Zvcih2YXIgZjtmPXIoKVtzKys+Pj4wXTspe3ZhciBiPWYhPTEwNTtjKz0oYiY9ZiE9MTEyKSYmYyU4PzQ6MCxQbi5wdXNoKGY9PTExMj9hKClbYz4+PjI+Pj4wXTpmPT0xMDY/cVtjPj4+M106Zj09MTA1P2koKVtjPj4+Mj4+PjBdOmwoKVtjPj4+Mz4+PjBdKSxjKz1iPzg6NH1yZXR1cm4gUG59O2Z1bmN0aW9uIFNwKHMsYyxmKXtyZXR1cm4gcz4+Pj0wLGM9SWkoYz4+PjAsZj4+PjApLGJuW3NdKC4uLmMpfWZ1bmN0aW9uIFRwKHMsYyxmKXtyZXR1cm4gcz4+Pj0wLGM9SWkoYz4+PjAsZj4+PjApLGJuW3NdKC4uLmMpfXZhciBJcD0oKT0+e30sQ3A9KCk9PkRhdGUubm93KCk7ZnVuY3Rpb24gQXAocyxjKXtyZXR1cm4gaihDZShzPj4+MCxjPj4+MCkpfXZhciBDaSxrcD0oKT0+e3Rocm93IHd0Kz0xLFwidW53aW5kXCJ9O2Z1bmN0aW9uIEVwKCl7cmV0dXJuIDQyOTQ5MDE3NjB9Q2k9KCk9PnBlcmZvcm1hbmNlLnRpbWVPcmlnaW4rcGVyZm9ybWFuY2Uubm93KCk7dmFyIFBwPSgpPT5uYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeTtmdW5jdGlvbiB6cCgpe3JldHVybiBjdChcIkNhbm5vdCB1c2UgZW1zY3JpcHRlbl9wY19nZXRfZnVuY3Rpb24gd2l0aG91dCAtc1VTRV9PRkZTRVRfQ09OVkVSVEVSXCIpLDB9ZnVuY3Rpb24gT3Aocyl7cz4+Pj0wO3ZhciBjPXIoKS5sZW5ndGg7aWYoczw9Y3x8NDI5NDkwMTc2MDxzKXJldHVybiExO2Zvcih2YXIgZj0xOzQ+PWY7Zio9Mil7dmFyIGI9YyooMSsuMi9mKTtiPU1hdGgubWluKGIscysxMDA2NjMyOTYpO3ZhciB3PU1hdGg7Yj1NYXRoLm1heChzLGIpO2U6e3c9KHcubWluLmNhbGwodyw0Mjk0OTAxNzYwLGIrKDY1NTM2LWIlNjU1MzYpJTY1NTM2KS1zZS5idWZmZXIuYnl0ZUxlbmd0aCs2NTUzNSkvNjU1MzY7dHJ5e3NlLmdyb3codykseWUoKTt2YXIgST0xO2JyZWFrIGV9Y2F0Y2h7fUk9dm9pZCAwfWlmKEkpcmV0dXJuITB9cmV0dXJuITF9dmFyIGNyPSgpPT4oY3QoXCJDYW5ub3QgdXNlIGNvbnZlcnRGcmFtZVRvUEMgKG5lZWRlZCBieSBfX2J1aWx0aW5fcmV0dXJuX2FkZHJlc3MpIHdpdGhvdXQgLXNVU0VfT0ZGU0VUX0NPTlZFUlRFUlwiKSwwKSxCdD17fSxBaT1zPT57cy5mb3JFYWNoKGM9Pnt2YXIgZj1jcigpO2YmJihCdFtmXT1jKX0pfTtmdW5jdGlvbiBEcCgpe3ZhciBzPUVycm9yKCkuc3RhY2sudG9TdHJpbmcoKS5zcGxpdChgXG5gKTtyZXR1cm4gc1swXT09XCJFcnJvclwiJiZzLnNoaWZ0KCksQWkocyksQnQuUWI9Y3IoKSxCdC5mYz1zLEJ0LlFifWZ1bmN0aW9uIEJwKHMsYyxmKXtpZihzPj4+PTAsYz4+Pj0wLEJ0LlFiPT1zKXZhciBiPUJ0LmZjO2Vsc2UoYj1FcnJvcigpLnN0YWNrLnRvU3RyaW5nKCkuc3BsaXQoYFxuYCkpWzBdPT1cIkVycm9yXCImJmIuc2hpZnQoKSxBaShiKTtmb3IodmFyIHc9MztiW3ddJiZjcigpIT1zOykrK3c7Zm9yKHM9MDtzPGYmJmJbcyt3XTsrK3MpaSgpW2MrNCpzPj4+Mj4+PjBdPWNyKCk7cmV0dXJuIHN9dmFyIHpuLE9uPXt9LGtpPSgpPT57aWYoIXpuKXt2YXIgcyxjPXtVU0VSOlwid2ViX3VzZXJcIixMT0dOQU1FOlwid2ViX3VzZXJcIixQQVRIOlwiL1wiLFBXRDpcIi9cIixIT01FOlwiL2hvbWUvd2ViX3VzZXJcIixMQU5HOih0eXBlb2YgbmF2aWdhdG9yPT1cIm9iamVjdFwiJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdfHxcIkNcIikucmVwbGFjZShcIi1cIixcIl9cIikrXCIuVVRGLThcIixfOkF8fFwiLi90aGlzLnByb2dyYW1cIn07Zm9yKHMgaW4gT24pT25bc109PT12b2lkIDA/ZGVsZXRlIGNbc106Y1tzXT1PbltzXTt2YXIgZj1bXTtmb3IocyBpbiBjKWYucHVzaChgJHtzfT0ke2Nbc119YCk7em49Zn1yZXR1cm4gem59O2Z1bmN0aW9uIEVpKHMsYyl7aWYoZylyZXR1cm4geGUoMTgsMSxzLGMpO3M+Pj49MCxjPj4+PTA7dmFyIGY9MDtyZXR1cm4ga2koKS5mb3JFYWNoKChiLHcpPT57dmFyIEk9YytmO2Zvcih3PWEoKVtzKzQqdz4+PjI+Pj4wXT1JLEk9MDtJPGIubGVuZ3RoOysrSSl0KClbdysrPj4+MF09Yi5jaGFyQ29kZUF0KEkpO3QoKVt3Pj4+MF09MCxmKz1iLmxlbmd0aCsxfSksMH1mdW5jdGlvbiBQaShzLGMpe2lmKGcpcmV0dXJuIHhlKDE5LDEscyxjKTtzPj4+PTAsYz4+Pj0wO3ZhciBmPWtpKCk7YSgpW3M+Pj4yPj4+MF09Zi5sZW5ndGg7dmFyIGI9MDtyZXR1cm4gZi5mb3JFYWNoKHc9PmIrPXcubGVuZ3RoKzEpLGEoKVtjPj4+Mj4+PjBdPWIsMH1mdW5jdGlvbiB6aShzKXtyZXR1cm4gZz94ZSgyMCwxLHMpOjUyfWZ1bmN0aW9uIE9pKHMsYyxmLGIpe3JldHVybiBnP3hlKDIxLDEscyxjLGYsYik6NTJ9ZnVuY3Rpb24gRGkocyxjLGYsYil7cmV0dXJuIGc/eGUoMjIsMSxzLGMsZixiKTo3MH12YXIgTXA9W251bGwsW10sW11dO2Z1bmN0aW9uIEJpKHMsYyxmLGIpe2lmKGcpcmV0dXJuIHhlKDIzLDEscyxjLGYsYik7Yz4+Pj0wLGY+Pj49MCxiPj4+PTA7Zm9yKHZhciB3PTAsST0wO0k8ZjtJKyspe3ZhciBPPWEoKVtjPj4+Mj4+PjBdLEI9YSgpW2MrND4+PjI+Pj4wXTtjKz04O2Zvcih2YXIgTD0wO0w8QjtMKyspe3ZhciBIPXIoKVtPK0w+Pj4wXSxYPU1wW3NdO0g9PT0wfHxIPT09MTA/KChzPT09MT9LOmopKFpvKFgsMCkpLFgubGVuZ3RoPTApOlgucHVzaChIKX13Kz1CfXJldHVybiBhKClbYj4+PjI+Pj4wXT13LDB9dmFyIE1pPVszMSwyOSwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV0sUmk9WzMxLDI4LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXSxScD0ocyxjKT0+e3QoKS5zZXQocyxjPj4+MCl9O2Z1bmN0aW9uIFVpKHMsYyxmLGIpe2Z1bmN0aW9uIHcoeixkZSxUZSl7Zm9yKHo9dHlwZW9mIHo9PVwibnVtYmVyXCI/ei50b1N0cmluZygpOnp8fFwiXCI7ei5sZW5ndGg8ZGU7KXo9VGVbMF0rejtyZXR1cm4gen1mdW5jdGlvbiBJKHosZGUpe3JldHVybiB3KHosZGUsXCIwXCIpfWZ1bmN0aW9uIE8oeixkZSl7ZnVuY3Rpb24gVGUoWGkpe3JldHVybiAwPlhpPy0xOjA8WGk/MTowfXZhciAkdDtyZXR1cm4oJHQ9VGUoei5nZXRGdWxsWWVhcigpLWRlLmdldEZ1bGxZZWFyKCkpKT09PTAmJigkdD1UZSh6LmdldE1vbnRoKCktZGUuZ2V0TW9udGgoKSkpPT09MCYmKCR0PVRlKHouZ2V0RGF0ZSgpLWRlLmdldERhdGUoKSkpLCR0fWZ1bmN0aW9uIEIoeil7c3dpdGNoKHouZ2V0RGF5KCkpe2Nhc2UgMDpyZXR1cm4gbmV3IERhdGUoei5nZXRGdWxsWWVhcigpLTEsMTEsMjkpO2Nhc2UgMTpyZXR1cm4gejtjYXNlIDI6cmV0dXJuIG5ldyBEYXRlKHouZ2V0RnVsbFllYXIoKSwwLDMpO2Nhc2UgMzpyZXR1cm4gbmV3IERhdGUoei5nZXRGdWxsWWVhcigpLDAsMik7Y2FzZSA0OnJldHVybiBuZXcgRGF0ZSh6LmdldEZ1bGxZZWFyKCksMCwxKTtjYXNlIDU6cmV0dXJuIG5ldyBEYXRlKHouZ2V0RnVsbFllYXIoKS0xLDExLDMxKTtjYXNlIDY6cmV0dXJuIG5ldyBEYXRlKHouZ2V0RnVsbFllYXIoKS0xLDExLDMwKX19ZnVuY3Rpb24gTCh6KXt2YXIgZGU9ei5DYjtmb3Ioej1uZXcgRGF0ZShuZXcgRGF0ZSh6LkRiKzE5MDAsMCwxKS5nZXRUaW1lKCkpOzA8ZGU7KXt2YXIgVGU9ei5nZXRNb250aCgpLCR0PShEdCh6LmdldEZ1bGxZZWFyKCkpP01pOlJpKVtUZV07aWYoIShkZT4kdC16LmdldERhdGUoKSkpe3ouc2V0RGF0ZSh6LmdldERhdGUoKStkZSk7YnJlYWt9ZGUtPSR0LXouZ2V0RGF0ZSgpKzEsei5zZXREYXRlKDEpLDExPlRlP3ouc2V0TW9udGgoVGUrMSk6KHouc2V0TW9udGgoMCksei5zZXRGdWxsWWVhcih6LmdldEZ1bGxZZWFyKCkrMSkpfXJldHVybiBUZT1uZXcgRGF0ZSh6LmdldEZ1bGxZZWFyKCkrMSwwLDQpLGRlPUIobmV3IERhdGUoei5nZXRGdWxsWWVhcigpLDAsNCkpLFRlPUIoVGUpLDA+PU8oZGUseik/MD49TyhUZSx6KT96LmdldEZ1bGxZZWFyKCkrMTp6LmdldEZ1bGxZZWFyKCk6ei5nZXRGdWxsWWVhcigpLTF9cz4+Pj0wLGM+Pj49MCxmPj4+PTAsYj4+Pj0wO3ZhciBIPWEoKVtiKzQwPj4+Mj4+PjBdO2Zvcih2YXIgWCBpbiBiPXtsYzppKClbYj4+PjI+Pj4wXSxrYzppKClbYis0Pj4+Mj4+PjBdLEliOmkoKVtiKzg+Pj4yPj4+MF0sTWI6aSgpW2IrMTI+Pj4yPj4+MF0sSmI6aSgpW2IrMTY+Pj4yPj4+MF0sRGI6aSgpW2IrMjA+Pj4yPj4+MF0sdmI6aSgpW2IrMjQ+Pj4yPj4+MF0sQ2I6aSgpW2IrMjg+Pj4yPj4+MF0sc2M6aSgpW2IrMzI+Pj4yPj4+MF0samM6aSgpW2IrMzY+Pj4yPj4+MF0sbWM6SD9DZShIKTpcIlwifSxmPUNlKGYpLEg9e1wiJWNcIjpcIiVhICViICVkICVIOiVNOiVTICVZXCIsXCIlRFwiOlwiJW0vJWQvJXlcIixcIiVGXCI6XCIlWS0lbS0lZFwiLFwiJWhcIjpcIiViXCIsXCIlclwiOlwiJUk6JU06JVMgJXBcIixcIiVSXCI6XCIlSDolTVwiLFwiJVRcIjpcIiVIOiVNOiVTXCIsXCIleFwiOlwiJW0vJWQvJXlcIixcIiVYXCI6XCIlSDolTTolU1wiLFwiJUVjXCI6XCIlY1wiLFwiJUVDXCI6XCIlQ1wiLFwiJUV4XCI6XCIlbS8lZC8leVwiLFwiJUVYXCI6XCIlSDolTTolU1wiLFwiJUV5XCI6XCIleVwiLFwiJUVZXCI6XCIlWVwiLFwiJU9kXCI6XCIlZFwiLFwiJU9lXCI6XCIlZVwiLFwiJU9IXCI6XCIlSFwiLFwiJU9JXCI6XCIlSVwiLFwiJU9tXCI6XCIlbVwiLFwiJU9NXCI6XCIlTVwiLFwiJU9TXCI6XCIlU1wiLFwiJU91XCI6XCIldVwiLFwiJU9VXCI6XCIlVVwiLFwiJU9WXCI6XCIlVlwiLFwiJU93XCI6XCIld1wiLFwiJU9XXCI6XCIlV1wiLFwiJU95XCI6XCIleVwifSlmPWYucmVwbGFjZShuZXcgUmVnRXhwKFgsXCJnXCIpLEhbWF0pO3ZhciBjZT1cIlN1bmRheSBNb25kYXkgVHVlc2RheSBXZWRuZXNkYXkgVGh1cnNkYXkgRnJpZGF5IFNhdHVyZGF5XCIuc3BsaXQoXCIgXCIpLGdlPVwiSmFudWFyeSBGZWJydWFyeSBNYXJjaCBBcHJpbCBNYXkgSnVuZSBKdWx5IEF1Z3VzdCBTZXB0ZW1iZXIgT2N0b2JlciBOb3ZlbWJlciBEZWNlbWJlclwiLnNwbGl0KFwiIFwiKTtmb3IoWCBpbiBIPXtcIiVhXCI6ej0+Y2Vbei52Yl0uc3Vic3RyaW5nKDAsMyksXCIlQVwiOno9PmNlW3oudmJdLFwiJWJcIjp6PT5nZVt6LkpiXS5zdWJzdHJpbmcoMCwzKSxcIiVCXCI6ej0+Z2Vbei5KYl0sXCIlQ1wiOno9PkkoKHouRGIrMTkwMCkvMTAwfDAsMiksXCIlZFwiOno9Pkkoei5NYiwyKSxcIiVlXCI6ej0+dyh6Lk1iLDIsXCIgXCIpLFwiJWdcIjp6PT5MKHopLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpLFwiJUdcIjpMLFwiJUhcIjp6PT5JKHouSWIsMiksXCIlSVwiOno9Pigoej16LkliKT09MD96PTEyOjEyPHomJih6LT0xMiksSSh6LDIpKSxcIiVqXCI6ej0+e2Zvcih2YXIgZGU9MCxUZT0wO1RlPD16LkpiLTE7ZGUrPShEdCh6LkRiKzE5MDApP01pOlJpKVtUZSsrXSk7cmV0dXJuIEkoei5NYitkZSwzKX0sXCIlbVwiOno9Pkkoei5KYisxLDIpLFwiJU1cIjp6PT5JKHoua2MsMiksXCIlblwiOigpPT5gXG5gLFwiJXBcIjp6PT4wPD16LkliJiYxMj56LkliP1wiQU1cIjpcIlBNXCIsXCIlU1wiOno9Pkkoei5sYywyKSxcIiV0XCI6KCk9PlwiXHRcIixcIiV1XCI6ej0+ei52Ynx8NyxcIiVVXCI6ej0+SShNYXRoLmZsb29yKCh6LkNiKzctei52YikvNyksMiksXCIlVlwiOno9Pnt2YXIgZGU9TWF0aC5mbG9vcigoei5DYis3LSh6LnZiKzYpJTcpLzcpO2lmKDI+PSh6LnZiKzM3MS16LkNiLTIpJTcmJmRlKyssZGUpZGU9PTUzJiYoKFRlPSh6LnZiKzM3MS16LkNiKSU3KT09NHx8VGU9PTMmJkR0KHouRGIpfHwoZGU9MSkpO2Vsc2V7ZGU9NTI7dmFyIFRlPSh6LnZiKzctei5DYi0xKSU3OyhUZT09NHx8VGU9PTUmJkR0KHouRGIlNDAwLTEpKSYmZGUrK31yZXR1cm4gSShkZSwyKX0sXCIld1wiOno9PnoudmIsXCIlV1wiOno9PkkoTWF0aC5mbG9vcigoei5DYis3LSh6LnZiKzYpJTcpLzcpLDIpLFwiJXlcIjp6PT4oei5EYisxOTAwKS50b1N0cmluZygpLnN1YnN0cmluZygyKSxcIiVZXCI6ej0+ei5EYisxOTAwLFwiJXpcIjp6PT57dmFyIGRlPTA8PSh6PXouamMpO3JldHVybiB6PU1hdGguYWJzKHopLzYwLChkZT9cIitcIjpcIi1cIikrKFwiMDAwMFwiKyh6LzYwKjEwMCt6JTYwKSkuc2xpY2UoLTQpfSxcIiVaXCI6ej0+ei5tYyxcIiUlXCI6KCk9PlwiJVwifSxmPWYucmVwbGFjZSgvJSUvZyxcIlxcMFxcMFwiKSxIKWYuaW5jbHVkZXMoWCkmJihmPWYucmVwbGFjZShuZXcgUmVnRXhwKFgsXCJnXCIpLEhbWF0oYikpKTtyZXR1cm4gWD1mdW5jdGlvbih6KXt2YXIgZGU9QXJyYXkoJG4oeikrMSk7cmV0dXJuIEpvKHosZGUsMCxkZS5sZW5ndGgpLGRlfShmPWYucmVwbGFjZSgvXFwwXFwwL2csXCIlXCIpKSxYLmxlbmd0aD5jPzA6KFJwKFgscyksWC5sZW5ndGgtMSl9ZnVuY3Rpb24gVXAocyxjLGYsYil7cmV0dXJuIFVpKHM+Pj4wLGM+Pj4wLGY+Pj4wLGI+Pj4wKX1nfHxmdW5jdGlvbigpe2Zvcih2YXIgcz11Lm51bVRocmVhZHMtMTtzLS07KXFvKCk7WWUudW5zaGlmdCgoKT0+e0d0KyssZnVuY3Rpb24oYyl7Zz9jKCk6UHJvbWlzZS5hbGwocHQubWFwKEZvKSkudGhlbihjKX0oKCk9PkRvKCkpfSl9KCk7Zm9yKHZhciBOaT1BcnJheSgyNTYpLHByPTA7MjU2PnByOysrcHIpTmlbcHJdPVN0cmluZy5mcm9tQ2hhckNvZGUocHIpO2NpPU5pLG10PXUuQmluZGluZ0Vycm9yPWNsYXNzIGV4dGVuZHMgRXJyb3J7Y29uc3RydWN0b3Iocyl7c3VwZXIocyksdGhpcy5uYW1lPVwiQmluZGluZ0Vycm9yXCJ9fSx1LkludGVybmFsRXJyb3I9Y2xhc3MgZXh0ZW5kcyBFcnJvcntjb25zdHJ1Y3RvcihzKXtzdXBlcihzKSx0aGlzLm5hbWU9XCJJbnRlcm5hbEVycm9yXCJ9fSx1dC5wdXNoKDAsMSx2b2lkIDAsMSxudWxsLDEsITAsMSwhMSwxKSx1LmNvdW50X2VtdmFsX2hhbmRsZXM9KCk9PnV0Lmxlbmd0aC8yLTUtVG4ubGVuZ3RoO3ZhciBOcD1bd24sV28sS28sUW8sWG8sZWksdGkscmksbmksb2ksaWksYWksc2ksdWksZGksbGksU2ksVGksRWksUGksemksT2ksRGksQmldLFo9ZnVuY3Rpb24oKXtmdW5jdGlvbiBzKGYsYil7cmV0dXJuIFo9Zi5leHBvcnRzLFo9ZnVuY3Rpb24oKXt2YXIgdz1aLEk9e307Zm9yKGxldFtPLEJdb2YgT2JqZWN0LmVudHJpZXModykpSVtPXT10eXBlb2YgQj09XCJmdW5jdGlvblwiPyguLi5MKT0+e3VyLnB1c2goTyk7dHJ5e3JldHVybiBCKC4uLkwpfWZpbmFsbHl7d2V8fCh1ci5wb3AoKSxYZSYmaHQ9PT0xJiZ1ci5sZW5ndGg9PT0wJiYoaHQ9MCx3dCs9MSxzcihqaSksdHlwZW9mIEZpYmVyczxcInVcIiYmRmliZXJzLnRjKCkpKX19OkI7cmV0dXJuIEl9KCksWj1mdW5jdGlvbigpe3ZhciB3PVosST1CPT5MPT5CKEwpPj4+MCxPPUI9PigpPT5CKCk+Pj4wO3JldHVybih3PU9iamVjdC5hc3NpZ24oe30sdykpLkRhPUkody5EYSksdy5nYj1PKHcuZ2IpLHcuaWI9SSh3LmliKSx3LmVtc2NyaXB0ZW5fbWFpbl9ydW50aW1lX3RocmVhZF9pZD1PKHcuZW1zY3JpcHRlbl9tYWluX3J1bnRpbWVfdGhyZWFkX2lkKSx3LnRiPUkody50Yiksdy51Yj1PKHcudWIpLHd9KCksTG8ucHVzaChaLmpiKSxMdC51bnNoaWZ0KFouQ2EpLFk9YixEbygpLFp9dmFyIGM9Tm8oKTtpZihHdCsrLHUuaW5zdGFudGlhdGVXYXNtKXRyeXtyZXR1cm4gdS5pbnN0YW50aWF0ZVdhc20oYyxzKX1jYXRjaChmKXtqKGBNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiAke2Z9YCksbShmKX1yZXR1cm4gZ258fD11LmxvY2F0ZUZpbGU/Qm8oXCJvcnQtd2FzbS1zaW1kLXRocmVhZGVkLmpzZXAud2FzbVwiKT9cIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC53YXNtXCI6dS5sb2NhdGVGaWxlP3UubG9jYXRlRmlsZShcIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC53YXNtXCIsUCk6UCtcIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC53YXNtXCI6bmV3IFVSTChcIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC53YXNtXCIsaW1wb3J0Lm1ldGEudXJsKS5ocmVmLGZ1bmN0aW9uKGYsYil7dmFyIHc9Z247cmV0dXJuIER8fHR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyE9XCJmdW5jdGlvblwifHxCbyh3KXx8TW8odyl8fHR5cGVvZiBmZXRjaCE9XCJmdW5jdGlvblwiP1VvKHcsZixiKTpmZXRjaCh3LHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKEk9PldlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKEksZikudGhlbihiLGZ1bmN0aW9uKE8pe3JldHVybiBqKGB3YXNtIHN0cmVhbWluZyBjb21waWxlIGZhaWxlZDogJHtPfWApLGooXCJmYWxsaW5nIGJhY2sgdG8gQXJyYXlCdWZmZXIgaW5zdGFudGlhdGlvblwiKSxVbyh3LGYsYil9KSl9KGMsZnVuY3Rpb24oZil7cyhmLmluc3RhbmNlLGYubW9kdWxlKX0pLmNhdGNoKG0pLHt9fSgpLFZpPXM9PihWaT1aLkRhKShzKSxXaT0oKT0+KFdpPVouRWEpKCk7dS5fT3J0SW5pdD0ocyxjKT0+KHUuX09ydEluaXQ9Wi5GYSkocyxjKSx1Ll9PcnRHZXRMYXN0RXJyb3I9KHMsYyk9Pih1Ll9PcnRHZXRMYXN0RXJyb3I9Wi5HYSkocyxjKSx1Ll9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucz0ocyxjLGYsYix3LEksTyxCLEwsSCk9Pih1Ll9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucz1aLkhhKShzLGMsZixiLHcsSSxPLEIsTCxIKSx1Ll9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlcj0ocyxjKT0+KHUuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPVouSWEpKHMsYyksdS5fT3J0QWRkRnJlZURpbWVuc2lvbk92ZXJyaWRlPShzLGMsZik9Pih1Ll9PcnRBZGRGcmVlRGltZW5zaW9uT3ZlcnJpZGU9Wi5KYSkocyxjLGYpLHUuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT0ocyxjLGYpPT4odS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5PVouS2EpKHMsYyxmKSx1Ll9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnM9cz0+KHUuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucz1aLkxhKShzKSx1Ll9PcnRDcmVhdGVTZXNzaW9uPShzLGMsZik9Pih1Ll9PcnRDcmVhdGVTZXNzaW9uPVouTWEpKHMsYyxmKSx1Ll9PcnRSZWxlYXNlU2Vzc2lvbj1zPT4odS5fT3J0UmVsZWFzZVNlc3Npb249Wi5OYSkocyksdS5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudD0ocyxjLGYpPT4odS5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudD1aLk9hKShzLGMsZiksdS5fT3J0R2V0SW5wdXROYW1lPShzLGMpPT4odS5fT3J0R2V0SW5wdXROYW1lPVouUGEpKHMsYyksdS5fT3J0R2V0T3V0cHV0TmFtZT0ocyxjKT0+KHUuX09ydEdldE91dHB1dE5hbWU9Wi5RYSkocyxjKSx1Ll9PcnRGcmVlPXM9Pih1Ll9PcnRGcmVlPVouUmEpKHMpLHUuX09ydENyZWF0ZVRlbnNvcj0ocyxjLGYsYix3LEkpPT4odS5fT3J0Q3JlYXRlVGVuc29yPVouU2EpKHMsYyxmLGIsdyxJKSx1Ll9PcnRHZXRUZW5zb3JEYXRhPShzLGMsZixiLHcpPT4odS5fT3J0R2V0VGVuc29yRGF0YT1aLlRhKShzLGMsZixiLHcpLHUuX09ydFJlbGVhc2VUZW5zb3I9cz0+KHUuX09ydFJlbGVhc2VUZW5zb3I9Wi5VYSkocyksdS5fT3J0Q3JlYXRlUnVuT3B0aW9ucz0ocyxjLGYsYik9Pih1Ll9PcnRDcmVhdGVSdW5PcHRpb25zPVouVmEpKHMsYyxmLGIpLHUuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PShzLGMsZik9Pih1Ll9PcnRBZGRSdW5Db25maWdFbnRyeT1aLldhKShzLGMsZiksdS5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9cz0+KHUuX09ydFJlbGVhc2VSdW5PcHRpb25zPVouWGEpKHMpLHUuX09ydENyZWF0ZUJpbmRpbmc9cz0+KHUuX09ydENyZWF0ZUJpbmRpbmc9Wi5ZYSkocyksdS5fT3J0QmluZElucHV0PShzLGMsZik9Pih1Ll9PcnRCaW5kSW5wdXQ9Wi5aYSkocyxjLGYpLHUuX09ydEJpbmRPdXRwdXQ9KHMsYyxmLGIpPT4odS5fT3J0QmluZE91dHB1dD1aLl9hKShzLGMsZixiKSx1Ll9PcnRDbGVhckJvdW5kT3V0cHV0cz1zPT4odS5fT3J0Q2xlYXJCb3VuZE91dHB1dHM9Wi4kYSkocyksdS5fT3J0UmVsZWFzZUJpbmRpbmc9cz0+KHUuX09ydFJlbGVhc2VCaW5kaW5nPVouYWIpKHMpLHUuX09ydFJ1bldpdGhCaW5kaW5nPShzLGMsZixiLHcpPT4odS5fT3J0UnVuV2l0aEJpbmRpbmc9Wi5iYikocyxjLGYsYix3KSx1Ll9PcnRSdW49KHMsYyxmLGIsdyxJLE8sQik9Pih1Ll9PcnRSdW49Wi5jYikocyxjLGYsYix3LEksTyxCKSx1Ll9PcnRFbmRQcm9maWxpbmc9cz0+KHUuX09ydEVuZFByb2ZpbGluZz1aLmRiKShzKSx1Ll9Kc2VwT3V0cHV0PShzLGMsZik9Pih1Ll9Kc2VwT3V0cHV0PVouZWIpKHMsYyxmKSx1Ll9Kc2VwR2V0Tm9kZU5hbWU9cz0+KHUuX0pzZXBHZXROb2RlTmFtZT1aLmZiKShzKTt2YXIgbXIsTXQ9KCk9PihNdD1aLmdiKSgpLEplPXUuX2ZyZWU9cz0+KEplPXUuX2ZyZWU9Wi5oYikocyksZnI9dS5fbWFsbG9jPXM9Pihmcj11Ll9tYWxsb2M9Wi5pYikocyksRG49KHMsYyxmLGIsdyxJKT0+KERuPVoubGIpKHMsYyxmLGIsdyxJKSxMaT0oKT0+KExpPVoubWIpKCksR2k9KHMsYyxmLGIsdyk9PihHaT1aLm5iKShzLGMsZixiLHcpLEJuPXM9PihCbj1aLm9iKShzKSxocj1zPT4oaHI9Wi5wYikocyksSGk9KCk9PihIaT1aLnFiKSgpLEZpPShzLGMpPT4oRmk9Wi5yYikocyxjKSxncj1zPT4oZ3I9Wi5zYikocyksTW49cz0+KE1uPVoudGIpKHMpLFJuPSgpPT4oUm49Wi51YikoKSxxaT11LmR5bkNhbGxfaWk9KHMsYyk9PihxaT11LmR5bkNhbGxfaWk9Wi53YikocyxjKSxLaT1zPT4oS2k9Wi54Yikocyksamk9KCk9PihqaT1aLnliKSgpLFlpPXM9PihZaT1aLnpiKShzKSxaaT0oKT0+KFppPVouQWIpKCk7ZnVuY3Rpb24gUWkoKXswPEd0fHwoZz8ocCh1KSxnfHxvcihMdCksc3RhcnRXb3JrZXIodSkpOihvcihZZSksMDxHdHx8bXJ8fChtcj0hMCx1LmNhbGxlZFJ1bj0hMCx3ZXx8KGd8fG9yKEx0KSxwKHUpLGd8fG9yKGZuKSkpKSl9cmV0dXJuIHUuX19fc3RhcnRfZW1fanM9OTI5MzAxLHUuX19fc3RvcF9lbV9qcz05Mjk1NDcsdS5zdGFja1NhdmU9KCk9PlJuKCksdS5zdGFja1Jlc3RvcmU9cz0+Z3IocyksdS5zdGFja0FsbG9jPXM9Pk1uKHMpLHUuc2V0VmFsdWU9ZnVuY3Rpb24ocyxjLGY9XCJpOFwiKXtzd2l0Y2goZi5lbmRzV2l0aChcIipcIikmJihmPVwiKlwiKSxmKXtjYXNlXCJpMVwiOmNhc2VcImk4XCI6dCgpW3M+Pj4wXT1jO2JyZWFrO2Nhc2VcImkxNlwiOm4oKVtzPj4+MT4+PjBdPWM7YnJlYWs7Y2FzZVwiaTMyXCI6aSgpW3M+Pj4yPj4+MF09YzticmVhaztjYXNlXCJpNjRcIjpxW3M+Pj4zXT1CaWdJbnQoYyk7YnJlYWs7Y2FzZVwiZmxvYXRcIjpkKClbcz4+PjI+Pj4wXT1jO2JyZWFrO2Nhc2VcImRvdWJsZVwiOmwoKVtzPj4+Mz4+PjBdPWM7YnJlYWs7Y2FzZVwiKlwiOmEoKVtzPj4+Mj4+PjBdPWM7YnJlYWs7ZGVmYXVsdDpjdChgaW52YWxpZCB0eXBlIGZvciBzZXRWYWx1ZTogJHtmfWApfX0sdS5nZXRWYWx1ZT1mdW5jdGlvbihzLGM9XCJpOFwiKXtzd2l0Y2goYy5lbmRzV2l0aChcIipcIikmJihjPVwiKlwiKSxjKXtjYXNlXCJpMVwiOmNhc2VcImk4XCI6cmV0dXJuIHQoKVtzPj4+MF07Y2FzZVwiaTE2XCI6cmV0dXJuIG4oKVtzPj4+MT4+PjBdO2Nhc2VcImkzMlwiOnJldHVybiBpKClbcz4+PjI+Pj4wXTtjYXNlXCJpNjRcIjpyZXR1cm4gcVtzPj4+M107Y2FzZVwiZmxvYXRcIjpyZXR1cm4gZCgpW3M+Pj4yPj4+MF07Y2FzZVwiZG91YmxlXCI6cmV0dXJuIGwoKVtzPj4+Mz4+PjBdO2Nhc2VcIipcIjpyZXR1cm4gYSgpW3M+Pj4yPj4+MF07ZGVmYXVsdDpjdChgaW52YWxpZCB0eXBlIGZvciBnZXRWYWx1ZTogJHtjfWApfX0sdS5VVEY4VG9TdHJpbmc9Q2UsdS5zdHJpbmdUb1VURjg9T3QsdS5sZW5ndGhCeXRlc1VURjg9JG4sSHQ9ZnVuY3Rpb24gcygpe21yfHxRaSgpLG1yfHwoSHQ9cyl9LFFpKCksdS5QVFJfU0laRT00LGh9KSxLcD16YTtnbG9iYWxUaGlzLnNlbGY/Lm5hbWU9PT1cImVtLXB0aHJlYWRcIiYmemEoKX0pO3ZhciBSYSxqcCxOZSxVYSxqbixZcCxacCxOYSxRcCxCYSxWYSxNYSxXYSx4cj1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7JHIoKTtSYT0hMXx8dHlwZW9mIGxvY2F0aW9uPlwidVwiP3ZvaWQgMDpsb2NhdGlvbi5vcmlnaW4sanA9KCk9PntpZighITEpcmV0dXJuIGltcG9ydC5tZXRhLnVybD8uc3RhcnRzV2l0aChcImZpbGU6XCIpP25ldyBVUkwobmV3IFVSTChcIm9ydC53ZWJncHUuYnVuZGxlLm1pbi5tanNcIixpbXBvcnQubWV0YS51cmwpLmhyZWYsUmEpLmhyZWY6aW1wb3J0Lm1ldGEudXJsfSxOZT1qcCgpLFVhPSgpPT57aWYoTmUmJiFOZS5zdGFydHNXaXRoKFwiYmxvYjpcIikpcmV0dXJuIE5lLnN1YnN0cmluZygwLE5lLmxhc3RJbmRleE9mKFwiL1wiKSsxKX0sam49KGUsdCk9Pnt0cnl7bGV0IHI9dD8/TmU7cmV0dXJuKHI/bmV3IFVSTChlLHIpOm5ldyBVUkwoZSkpLm9yaWdpbj09PVJhfWNhdGNoe3JldHVybiExfX0sWXA9KGUsdCk9PntsZXQgcj10Pz9OZTt0cnl7cmV0dXJuKHI/bmV3IFVSTChlLHIpOm5ldyBVUkwoZSkpLmhyZWZ9Y2F0Y2h7cmV0dXJufX0sWnA9KGUsdCk9PmAke3Q/P1wiLi9cIn0ke2V9YCxOYT1hc3luYyBlPT57bGV0IHI9YXdhaXQoYXdhaXQgZmV0Y2goZSx7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkpLmJsb2IoKTtyZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChyKX0sUXA9YXN5bmMgZT0+KGF3YWl0IGltcG9ydCgvKndlYnBhY2tJZ25vcmU6dHJ1ZSovZSkpLmRlZmF1bHQsQmE9KFBhKCksYnIoRWEpKS5kZWZhdWx0LFZhPWFzeW5jKCk9PntpZighTmUpdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGxvYWQgcHJveHkgd29ya2VyOiBjYW5ub3QgZGV0ZXJtaW5lIHRoZSBzY3JpcHQgc291cmNlIFVSTC5cIik7aWYoam4oTmUpKXJldHVyblt2b2lkIDAsQmEoKV07bGV0IGU9YXdhaXQgTmEoTmUpO3JldHVybltlLEJhKGUpXX0sTWE9KERhKCksYnIoT2EpKS5kZWZhdWx0LFdhPWFzeW5jKGUsdCxyKT0+e2lmKCFlJiYhdCYmTWEmJk5lJiZqbihOZSkpcmV0dXJuW3ZvaWQgMCxNYV07e2xldCBuPVwib3J0LXdhc20tc2ltZC10aHJlYWRlZC5qc2VwLm1qc1wiLG89ZT8/WXAobix0KSxpPSEhMSYmciYmbyYmIWpuKG8sdCksYT1pP2F3YWl0IE5hKG8pOm8/P1pwKG4sdCk7cmV0dXJuW2k/YTp2b2lkIDAsYXdhaXQgUXAoYSldfX19KTt2YXIgWW4sWm4senIsTGEsWHAsSnAsU3IsSWUsZ3Q9VSgoKT0+e1widXNlIHN0cmljdFwiO3hyKCk7Wm49ITEsenI9ITEsTGE9ITEsWHA9KCk9PntpZih0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXI+XCJ1XCIpcmV0dXJuITE7dHJ5e3JldHVybiB0eXBlb2YgTWVzc2FnZUNoYW5uZWw8XCJ1XCImJm5ldyBNZXNzYWdlQ2hhbm5lbCgpLnBvcnQxLnBvc3RNZXNzYWdlKG5ldyBTaGFyZWRBcnJheUJ1ZmZlcigxKSksV2ViQXNzZW1ibHkudmFsaWRhdGUobmV3IFVpbnQ4QXJyYXkoWzAsOTcsMTE1LDEwOSwxLDAsMCwwLDEsNCwxLDk2LDAsMCwzLDIsMSwwLDUsNCwxLDMsMSwxLDEwLDExLDEsOSwwLDY1LDAsMjU0LDE2LDIsMCwyNiwxMV0pKX1jYXRjaHtyZXR1cm4hMX19LEpwPSgpPT57dHJ5e3JldHVybiBXZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw0LDEsOTYsMCwwLDMsMiwxLDAsMTAsMzAsMSwyOCwwLDY1LDAsMjUzLDE1LDI1MywxMiwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDI1MywxODYsMSwyNiwxMV0pKX1jYXRjaHtyZXR1cm4hMX19LFNyPWFzeW5jIGU9PntpZihabilyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7aWYoenIpdGhyb3cgbmV3IEVycm9yKFwibXVsdGlwbGUgY2FsbHMgdG8gJ2luaXRpYWxpemVXZWJBc3NlbWJseSgpJyBkZXRlY3RlZC5cIik7aWYoTGEpdGhyb3cgbmV3IEVycm9yKFwicHJldmlvdXMgY2FsbCB0byAnaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KCknIGZhaWxlZC5cIik7enI9ITA7bGV0IHQ9ZS5pbml0VGltZW91dCxyPWUubnVtVGhyZWFkcztpZighSnAoKSl0aHJvdyBuZXcgRXJyb3IoXCJXZWJBc3NlbWJseSBTSU1EIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuXCIpO2xldCBuPVhwKCk7cj4xJiYhbiYmKHR5cGVvZiBzZWxmPFwidVwiJiYhc2VsZi5jcm9zc09yaWdpbklzb2xhdGVkJiZjb25zb2xlLndhcm4oXCJlbnYud2FzbS5udW1UaHJlYWRzIGlzIHNldCB0byBcIityK1wiLCBidXQgdGhpcyB3aWxsIG5vdCB3b3JrIHVubGVzcyB5b3UgZW5hYmxlIGNyb3NzT3JpZ2luSXNvbGF0ZWQgbW9kZS4gU2VlIGh0dHBzOi8vd2ViLmRldi9jcm9zcy1vcmlnaW4taXNvbGF0aW9uLWd1aWRlLyBmb3IgbW9yZSBpbmZvLlwiKSxjb25zb2xlLndhcm4oXCJXZWJBc3NlbWJseSBtdWx0aS10aHJlYWRpbmcgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC4gRmFsbGluZyBiYWNrIHRvIHNpbmdsZS10aHJlYWRpbmcuXCIpLGUubnVtVGhyZWFkcz1yPTEpO2xldCBvPWUud2FzbVBhdGhzLGk9dHlwZW9mIG89PVwic3RyaW5nXCI/bzp2b2lkIDAsYT1vPy5tanMsZD1hPy5ocmVmPz9hLGw9bz8ud2FzbSxwPWw/LmhyZWY/P2wsbT1lLndhc21CaW5hcnksW3UsaF09YXdhaXQgV2EoZCxpLHI+MSksXz0hMSx5PVtdO2lmKHQ+MCYmeS5wdXNoKG5ldyBQcm9taXNlKGc9PntzZXRUaW1lb3V0KCgpPT57Xz0hMCxnKCl9LHQpfSkpLHkucHVzaChuZXcgUHJvbWlzZSgoZyx4KT0+e2xldCAkPXtudW1UaHJlYWRzOnJ9O2lmKG0pJC53YXNtQmluYXJ5PW07ZWxzZSBpZihwfHxpKSQubG9jYXRlRmlsZT12PT5wPz9pK3Y7ZWxzZSBpZihkJiZkLmluZGV4T2YoXCJibG9iOlwiKSE9PTApJC5sb2NhdGVGaWxlPXY9Pm5ldyBVUkwodixkKS5ocmVmO2Vsc2UgaWYodSl7bGV0IHY9VWEoKTt2JiYoJC5sb2NhdGVGaWxlPVM9PnYrUyl9aCgkKS50aGVuKHY9Pnt6cj0hMSxabj0hMCxZbj12LGcoKSx1JiZVUkwucmV2b2tlT2JqZWN0VVJMKHUpfSx2PT57enI9ITEsTGE9ITAseCh2KX0pfSkpLGF3YWl0IFByb21pc2UucmFjZSh5KSxfKXRocm93IG5ldyBFcnJvcihgV2ViQXNzZW1ibHkgYmFja2VuZCBpbml0aWFsaXppbmcgZmFpbGVkIGR1ZSB0byB0aW1lb3V0OiAke3R9bXNgKX0sSWU9KCk9PntpZihabiYmWW4pcmV0dXJuIFluO3Rocm93IG5ldyBFcnJvcihcIldlYkFzc2VtYmx5IGlzIG5vdCBpbml0aWFsaXplZCB5ZXQuXCIpfX0pO3ZhciBrZSxqdCxwZSxPcj1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Z3QoKTtrZT0oZSx0KT0+e2xldCByPUllKCksbj1yLmxlbmd0aEJ5dGVzVVRGOChlKSsxLG89ci5fbWFsbG9jKG4pO3JldHVybiByLnN0cmluZ1RvVVRGOChlLG8sbiksdC5wdXNoKG8pLG99LGp0PShlLHQscixuKT0+e2lmKHR5cGVvZiBlPT1cIm9iamVjdFwiJiZlIT09bnVsbCl7aWYoci5oYXMoZSkpdGhyb3cgbmV3IEVycm9yKFwiQ2lyY3VsYXIgcmVmZXJlbmNlIGluIG9wdGlvbnNcIik7ci5hZGQoZSl9T2JqZWN0LmVudHJpZXMoZSkuZm9yRWFjaCgoW28saV0pPT57bGV0IGE9dD90K286bztpZih0eXBlb2YgaT09XCJvYmplY3RcIilqdChpLGErXCIuXCIscixuKTtlbHNlIGlmKHR5cGVvZiBpPT1cInN0cmluZ1wifHx0eXBlb2YgaT09XCJudW1iZXJcIiluKGEsaS50b1N0cmluZygpKTtlbHNlIGlmKHR5cGVvZiBpPT1cImJvb2xlYW5cIiluKGEsaT9cIjFcIjpcIjBcIik7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoYENhbid0IGhhbmRsZSBleHRyYSBjb25maWcgdHlwZTogJHt0eXBlb2YgaX1gKX0pfSxwZT1lPT57bGV0IHQ9SWUoKSxyPXQuc3RhY2tTYXZlKCk7dHJ5e2xldCBuPXQuUFRSX1NJWkUsbz10LnN0YWNrQWxsb2MoMipuKTt0Ll9PcnRHZXRMYXN0RXJyb3IobyxvK24pO2xldCBpPU51bWJlcih0LmdldFZhbHVlKG8sbj09PTQ/XCJpMzJcIjpcImk2NFwiKSksYT10LmdldFZhbHVlKG8rbixcIipcIiksZD1hP3QuVVRGOFRvU3RyaW5nKGEpOlwiXCI7dGhyb3cgbmV3IEVycm9yKGAke2V9IEVSUk9SX0NPREU6ICR7aX0sIEVSUk9SX01FU1NBR0U6ICR7ZH1gKX1maW5hbGx5e3Quc3RhY2tSZXN0b3JlKHIpfX19KTt2YXIgR2EsSGE9VSgoKT0+e1widXNlIHN0cmljdFwiO2d0KCk7T3IoKTtHYT1lPT57bGV0IHQ9SWUoKSxyPTAsbj1bXSxvPWV8fHt9O3RyeXtpZihlPy5sb2dTZXZlcml0eUxldmVsPT09dm9pZCAwKW8ubG9nU2V2ZXJpdHlMZXZlbD0yO2Vsc2UgaWYodHlwZW9mIGUubG9nU2V2ZXJpdHlMZXZlbCE9XCJudW1iZXJcInx8IU51bWJlci5pc0ludGVnZXIoZS5sb2dTZXZlcml0eUxldmVsKXx8ZS5sb2dTZXZlcml0eUxldmVsPDB8fGUubG9nU2V2ZXJpdHlMZXZlbD40KXRocm93IG5ldyBFcnJvcihgbG9nIHNlcnZlcml0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7ZS5sb2dTZXZlcml0eUxldmVsfWApO2lmKGU/LmxvZ1ZlcmJvc2l0eUxldmVsPT09dm9pZCAwKW8ubG9nVmVyYm9zaXR5TGV2ZWw9MDtlbHNlIGlmKHR5cGVvZiBlLmxvZ1ZlcmJvc2l0eUxldmVsIT1cIm51bWJlclwifHwhTnVtYmVyLmlzSW50ZWdlcihlLmxvZ1ZlcmJvc2l0eUxldmVsKSl0aHJvdyBuZXcgRXJyb3IoYGxvZyB2ZXJib3NpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke2UubG9nVmVyYm9zaXR5TGV2ZWx9YCk7ZT8udGVybWluYXRlPT09dm9pZCAwJiYoby50ZXJtaW5hdGU9ITEpO2xldCBpPTA7cmV0dXJuIGU/LnRhZyE9PXZvaWQgMCYmKGk9a2UoZS50YWcsbikpLHI9dC5fT3J0Q3JlYXRlUnVuT3B0aW9ucyhvLmxvZ1NldmVyaXR5TGV2ZWwsby5sb2dWZXJib3NpdHlMZXZlbCwhIW8udGVybWluYXRlLGkpLHI9PT0wJiZwZShcIkNhbid0IGNyZWF0ZSBydW4gb3B0aW9ucy5cIiksZT8uZXh0cmEhPT12b2lkIDAmJmp0KGUuZXh0cmEsXCJcIixuZXcgV2Vha1NldCwoYSxkKT0+e2xldCBsPWtlKGEsbikscD1rZShkLG4pO3QuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5KHIsbCxwKSE9PTAmJnBlKGBDYW4ndCBzZXQgYSBydW4gY29uZmlnIGVudHJ5OiAke2F9IC0gJHtkfS5gKX0pLFtyLG5dfWNhdGNoKGkpe3Rocm93IHIhPT0wJiZ0Ll9PcnRSZWxlYXNlUnVuT3B0aW9ucyhyKSxuLmZvckVhY2goYT0+dC5fZnJlZShhKSksaX19fSk7dmFyIGVtLHRtLHJtLG5tLEZhLHFhPVUoKCk9PntcInVzZSBzdHJpY3RcIjtndCgpO09yKCk7ZW09ZT0+e3N3aXRjaChlKXtjYXNlXCJkaXNhYmxlZFwiOnJldHVybiAwO2Nhc2VcImJhc2ljXCI6cmV0dXJuIDE7Y2FzZVwiZXh0ZW5kZWRcIjpyZXR1cm4gMjtjYXNlXCJhbGxcIjpyZXR1cm4gOTk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGdyYXBoIG9wdGltaXphdGlvbiBsZXZlbDogJHtlfWApfX0sdG09ZT0+e3N3aXRjaChlKXtjYXNlXCJzZXF1ZW50aWFsXCI6cmV0dXJuIDA7Y2FzZVwicGFyYWxsZWxcIjpyZXR1cm4gMTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZXhlY3V0aW9uIG1vZGU6ICR7ZX1gKX19LHJtPWU9PntlLmV4dHJhfHwoZS5leHRyYT17fSksZS5leHRyYS5zZXNzaW9ufHwoZS5leHRyYS5zZXNzaW9uPXt9KTtsZXQgdD1lLmV4dHJhLnNlc3Npb247dC51c2Vfb3J0X21vZGVsX2J5dGVzX2RpcmVjdGx5fHwodC51c2Vfb3J0X21vZGVsX2J5dGVzX2RpcmVjdGx5PVwiMVwiKSxlLmV4ZWN1dGlvblByb3ZpZGVycyYmZS5leGVjdXRpb25Qcm92aWRlcnMuc29tZShyPT4odHlwZW9mIHI9PVwic3RyaW5nXCI/cjpyLm5hbWUpPT09XCJ3ZWJncHVcIikmJihlLmVuYWJsZU1lbVBhdHRlcm49ITEpfSxubT0oZSx0LHIpPT57Zm9yKGxldCBuIG9mIHQpe2xldCBvPXR5cGVvZiBuPT1cInN0cmluZ1wiP246bi5uYW1lO3N3aXRjaChvKXtjYXNlXCJ3ZWJublwiOmlmKG89XCJXRUJOTlwiLHR5cGVvZiBuIT1cInN0cmluZ1wiKXtsZXQgZD1uPy5kZXZpY2VUeXBlO2lmKGQpe2xldCBsPWtlKFwiZGV2aWNlVHlwZVwiLHIpLHA9a2UoZCxyKTtJZSgpLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkoZSxsLHApIT09MCYmcGUoYENhbid0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAnZGV2aWNlVHlwZScgLSAke2R9LmApfX1icmVhaztjYXNlXCJ3ZWJncHVcIjppZihvPVwiSlNcIix0eXBlb2YgbiE9XCJzdHJpbmdcIil7bGV0IGE9bjtpZihhPy5wcmVmZXJyZWRMYXlvdXQpe2lmKGEucHJlZmVycmVkTGF5b3V0IT09XCJOQ0hXXCImJmEucHJlZmVycmVkTGF5b3V0IT09XCJOSFdDXCIpdGhyb3cgbmV3IEVycm9yKGBwcmVmZXJyZWRMYXlvdXQgbXVzdCBiZSBlaXRoZXIgJ05DSFcnIG9yICdOSFdDJzogJHthLnByZWZlcnJlZExheW91dH1gKTtsZXQgZD1rZShcInByZWZlcnJlZExheW91dFwiLHIpLGw9a2UoYS5wcmVmZXJyZWRMYXlvdXQscik7SWUoKS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KGUsZCxsKSE9PTAmJnBlKGBDYW4ndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogJ3ByZWZlcnJlZExheW91dCcgLSAke2EucHJlZmVycmVkTGF5b3V0fS5gKX19YnJlYWs7Y2FzZVwid2FzbVwiOmNhc2VcImNwdVwiOmNvbnRpbnVlO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIGV4ZWN1dGlvbiBwcm92aWRlcjogJHtvfWApfWxldCBpPWtlKG8scik7SWUoKS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXIoZSxpKSE9PTAmJnBlKGBDYW4ndCBhcHBlbmQgZXhlY3V0aW9uIHByb3ZpZGVyOiAke299LmApfX0sRmE9ZT0+e2xldCB0PUllKCkscj0wLG49W10sbz1lfHx7fTtybShvKTt0cnl7bGV0IGk9ZW0oby5ncmFwaE9wdGltaXphdGlvbkxldmVsPz9cImFsbFwiKSxhPXRtKG8uZXhlY3V0aW9uTW9kZT8/XCJzZXF1ZW50aWFsXCIpLGQ9dHlwZW9mIG8ubG9nSWQ9PVwic3RyaW5nXCI/a2Uoby5sb2dJZCxuKTowLGw9by5sb2dTZXZlcml0eUxldmVsPz8yO2lmKCFOdW1iZXIuaXNJbnRlZ2VyKGwpfHxsPDB8fGw+NCl0aHJvdyBuZXcgRXJyb3IoYGxvZyBzZXJ2ZXJpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke2x9YCk7bGV0IHA9by5sb2dWZXJib3NpdHlMZXZlbD8/MDtpZighTnVtYmVyLmlzSW50ZWdlcihwKXx8cDwwfHxwPjQpdGhyb3cgbmV3IEVycm9yKGBsb2cgdmVyYm9zaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtwfWApO2xldCBtPXR5cGVvZiBvLm9wdGltaXplZE1vZGVsRmlsZVBhdGg9PVwic3RyaW5nXCI/a2Uoby5vcHRpbWl6ZWRNb2RlbEZpbGVQYXRoLG4pOjA7aWYocj10Ll9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucyhpLCEhby5lbmFibGVDcHVNZW1BcmVuYSwhIW8uZW5hYmxlTWVtUGF0dGVybixhLCEhby5lbmFibGVQcm9maWxpbmcsMCxkLGwscCxtKSxyPT09MCYmcGUoXCJDYW4ndCBjcmVhdGUgc2Vzc2lvbiBvcHRpb25zLlwiKSxvLmV4ZWN1dGlvblByb3ZpZGVycyYmbm0ocixvLmV4ZWN1dGlvblByb3ZpZGVycyxuKSxvLmVuYWJsZUdyYXBoQ2FwdHVyZSE9PXZvaWQgMCl7aWYodHlwZW9mIG8uZW5hYmxlR3JhcGhDYXB0dXJlIT1cImJvb2xlYW5cIil0aHJvdyBuZXcgRXJyb3IoYGVuYWJsZUdyYXBoQ2FwdHVyZSBtdXN0IGJlIGEgYm9vbGVhbiB2YWx1ZTogJHtvLmVuYWJsZUdyYXBoQ2FwdHVyZX1gKTtsZXQgdT1rZShcImVuYWJsZUdyYXBoQ2FwdHVyZVwiLG4pLGg9a2Uoby5lbmFibGVHcmFwaENhcHR1cmUudG9TdHJpbmcoKSxuKTt0Ll9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkocix1LGgpIT09MCYmcGUoYENhbid0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAnZW5hYmxlR3JhcGhDYXB0dXJlJyAtICR7by5lbmFibGVHcmFwaENhcHR1cmV9LmApfWlmKG8uZnJlZURpbWVuc2lvbk92ZXJyaWRlcylmb3IobGV0W3UsaF1vZiBPYmplY3QuZW50cmllcyhvLmZyZWVEaW1lbnNpb25PdmVycmlkZXMpKXtpZih0eXBlb2YgdSE9XCJzdHJpbmdcIil0aHJvdyBuZXcgRXJyb3IoYGZyZWUgZGltZW5zaW9uIG92ZXJyaWRlIG5hbWUgbXVzdCBiZSBhIHN0cmluZzogJHt1fWApO2lmKHR5cGVvZiBoIT1cIm51bWJlclwifHwhTnVtYmVyLmlzSW50ZWdlcihoKXx8aDwwKXRocm93IG5ldyBFcnJvcihgZnJlZSBkaW1lbnNpb24gb3ZlcnJpZGUgdmFsdWUgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyOiAke2h9YCk7bGV0IF89a2UodSxuKTt0Ll9PcnRBZGRGcmVlRGltZW5zaW9uT3ZlcnJpZGUocixfLGgpIT09MCYmcGUoYENhbid0IHNldCBhIGZyZWUgZGltZW5zaW9uIG92ZXJyaWRlOiAke3V9IC0gJHtofS5gKX1yZXR1cm4gby5leHRyYSE9PXZvaWQgMCYmanQoby5leHRyYSxcIlwiLG5ldyBXZWFrU2V0LCh1LGgpPT57bGV0IF89a2UodSxuKSx5PWtlKGgsbik7dC5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KHIsXyx5KSE9PTAmJnBlKGBDYW4ndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogJHt1fSAtICR7aH0uYCl9KSxbcixuXX1jYXRjaChpKXt0aHJvdyByIT09MCYmdC5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zKHIpIT09MCYmcGUoXCJDYW4ndCByZWxlYXNlIHNlc3Npb24gb3B0aW9ucy5cIiksbi5mb3JFYWNoKGE9PnQuX2ZyZWUoYSkpLGl9fX0pO3ZhciBZdCxidCxDdCxEcixadCxCcixNcixRbix0ZT1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7WXQ9ZT0+e3N3aXRjaChlKXtjYXNlXCJpbnQ4XCI6cmV0dXJuIDM7Y2FzZVwidWludDhcIjpyZXR1cm4gMjtjYXNlXCJib29sXCI6cmV0dXJuIDk7Y2FzZVwiaW50MTZcIjpyZXR1cm4gNTtjYXNlXCJ1aW50MTZcIjpyZXR1cm4gNDtjYXNlXCJpbnQzMlwiOnJldHVybiA2O2Nhc2VcInVpbnQzMlwiOnJldHVybiAxMjtjYXNlXCJmbG9hdDE2XCI6cmV0dXJuIDEwO2Nhc2VcImZsb2F0MzJcIjpyZXR1cm4gMTtjYXNlXCJmbG9hdDY0XCI6cmV0dXJuIDExO2Nhc2VcInN0cmluZ1wiOnJldHVybiA4O2Nhc2VcImludDY0XCI6cmV0dXJuIDc7Y2FzZVwidWludDY0XCI6cmV0dXJuIDEzO2Nhc2VcImludDRcIjpyZXR1cm4gMjI7Y2FzZVwidWludDRcIjpyZXR1cm4gMjE7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtlfWApfX0sYnQ9ZT0+e3N3aXRjaChlKXtjYXNlIDM6cmV0dXJuXCJpbnQ4XCI7Y2FzZSAyOnJldHVyblwidWludDhcIjtjYXNlIDk6cmV0dXJuXCJib29sXCI7Y2FzZSA1OnJldHVyblwiaW50MTZcIjtjYXNlIDQ6cmV0dXJuXCJ1aW50MTZcIjtjYXNlIDY6cmV0dXJuXCJpbnQzMlwiO2Nhc2UgMTI6cmV0dXJuXCJ1aW50MzJcIjtjYXNlIDEwOnJldHVyblwiZmxvYXQxNlwiO2Nhc2UgMTpyZXR1cm5cImZsb2F0MzJcIjtjYXNlIDExOnJldHVyblwiZmxvYXQ2NFwiO2Nhc2UgODpyZXR1cm5cInN0cmluZ1wiO2Nhc2UgNzpyZXR1cm5cImludDY0XCI7Y2FzZSAxMzpyZXR1cm5cInVpbnQ2NFwiO2Nhc2UgMjI6cmV0dXJuXCJpbnQ0XCI7Y2FzZSAyMTpyZXR1cm5cInVpbnQ0XCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtlfWApfX0sQ3Q9KGUsdCk9PntsZXQgcj1bLTEsNCwxLDEsMiwyLDQsOCwtMSwxLDIsOCw0LDgsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLjUsLjVdW2VdLG49dHlwZW9mIHQ9PVwibnVtYmVyXCI/dDp0LnJlZHVjZSgobyxpKT0+byppLDEpO3JldHVybiByPjA/TWF0aC5jZWlsKG4qcik6dm9pZCAwfSxEcj1lPT57c3dpdGNoKGUpe2Nhc2VcImZsb2F0MTZcIjpyZXR1cm4gdHlwZW9mIEZsb2F0MTZBcnJheTxcInVcIiYmRmxvYXQxNkFycmF5LmZyb20/RmxvYXQxNkFycmF5OlVpbnQxNkFycmF5O2Nhc2VcImZsb2F0MzJcIjpyZXR1cm4gRmxvYXQzMkFycmF5O2Nhc2VcInVpbnQ4XCI6cmV0dXJuIFVpbnQ4QXJyYXk7Y2FzZVwiaW50OFwiOnJldHVybiBJbnQ4QXJyYXk7Y2FzZVwidWludDE2XCI6cmV0dXJuIFVpbnQxNkFycmF5O2Nhc2VcImludDE2XCI6cmV0dXJuIEludDE2QXJyYXk7Y2FzZVwiaW50MzJcIjpyZXR1cm4gSW50MzJBcnJheTtjYXNlXCJib29sXCI6cmV0dXJuIFVpbnQ4QXJyYXk7Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiBGbG9hdDY0QXJyYXk7Y2FzZVwidWludDMyXCI6cmV0dXJuIFVpbnQzMkFycmF5O2Nhc2VcImludDY0XCI6cmV0dXJuIEJpZ0ludDY0QXJyYXk7Y2FzZVwidWludDY0XCI6cmV0dXJuIEJpZ1VpbnQ2NEFycmF5O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCB0eXBlOiAke2V9YCl9fSxadD1lPT57c3dpdGNoKGUpe2Nhc2VcInZlcmJvc2VcIjpyZXR1cm4gMDtjYXNlXCJpbmZvXCI6cmV0dXJuIDE7Y2FzZVwid2FybmluZ1wiOnJldHVybiAyO2Nhc2VcImVycm9yXCI6cmV0dXJuIDM7Y2FzZVwiZmF0YWxcIjpyZXR1cm4gNDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgbG9nZ2luZyBsZXZlbDogJHtlfWApfX0sQnI9ZT0+ZT09PVwiZmxvYXQzMlwifHxlPT09XCJmbG9hdDE2XCJ8fGU9PT1cImludDMyXCJ8fGU9PT1cImludDY0XCJ8fGU9PT1cInVpbnQzMlwifHxlPT09XCJ1aW50OFwifHxlPT09XCJib29sXCJ8fGU9PT1cInVpbnQ0XCJ8fGU9PT1cImludDRcIixNcj1lPT5lPT09XCJmbG9hdDMyXCJ8fGU9PT1cImZsb2F0MTZcInx8ZT09PVwiaW50MzJcInx8ZT09PVwiaW50NjRcInx8ZT09PVwidWludDMyXCJ8fGU9PT1cInVpbnQ2NFwifHxlPT09XCJpbnQ4XCJ8fGU9PT1cInVpbnQ4XCJ8fGU9PT1cImJvb2xcInx8ZT09PVwidWludDRcInx8ZT09PVwiaW50NFwiLFFuPWU9Pntzd2l0Y2goZSl7Y2FzZVwibm9uZVwiOnJldHVybiAwO2Nhc2VcImNwdVwiOnJldHVybiAxO2Nhc2VcImNwdS1waW5uZWRcIjpyZXR1cm4gMjtjYXNlXCJ0ZXh0dXJlXCI6cmV0dXJuIDM7Y2FzZVwiZ3B1LWJ1ZmZlclwiOnJldHVybiA0O2Nhc2VcIm1sLXRlbnNvclwiOnJldHVybiA1O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIGxvY2F0aW9uOiAke2V9YCl9fX0pO3ZhciBRdCxYbj1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7JHIoKTtRdD1hc3luYyBlPT57aWYodHlwZW9mIGU9PVwic3RyaW5nXCIpaWYoITEpdHJ5e2xldHtyZWFkRmlsZTp0fT1ObihcIm5vZGU6ZnMvcHJvbWlzZXNcIik7cmV0dXJuIG5ldyBVaW50OEFycmF5KGF3YWl0IHQoZSkpfWNhdGNoKHQpe2lmKHQuY29kZT09PVwiRVJSX0ZTX0ZJTEVfVE9PX0xBUkdFXCIpe2xldHtjcmVhdGVSZWFkU3RyZWFtOnJ9PU5uKFwibm9kZTpmc1wiKSxuPXIoZSksbz1bXTtmb3IgYXdhaXQobGV0IGkgb2YgbilvLnB1c2goaSk7cmV0dXJuIG5ldyBVaW50OEFycmF5KEJ1ZmZlci5jb25jYXQobykpfXRocm93IHR9ZWxzZXtsZXQgdD1hd2FpdCBmZXRjaChlKTtpZighdC5vayl0aHJvdyBuZXcgRXJyb3IoYGZhaWxlZCB0byBsb2FkIGV4dGVybmFsIGRhdGEgZmlsZTogJHtlfWApO2xldCByPXQuaGVhZGVycy5nZXQoXCJDb250ZW50LUxlbmd0aFwiKSxuPXI/cGFyc2VJbnQociwxMCk6MDtpZihuPDEwNzM3NDE4MjQpcmV0dXJuIG5ldyBVaW50OEFycmF5KGF3YWl0IHQuYXJyYXlCdWZmZXIoKSk7e2lmKCF0LmJvZHkpdGhyb3cgbmV3IEVycm9yKGBmYWlsZWQgdG8gbG9hZCBleHRlcm5hbCBkYXRhIGZpbGU6ICR7ZX0sIG5vIHJlc3BvbnNlIGJvZHkuYCk7bGV0IG89dC5ib2R5LmdldFJlYWRlcigpLGk7dHJ5e2k9bmV3IEFycmF5QnVmZmVyKG4pfWNhdGNoKGQpe2lmKGQgaW5zdGFuY2VvZiBSYW5nZUVycm9yKXtsZXQgbD1NYXRoLmNlaWwobi82NTUzNik7aT1uZXcgV2ViQXNzZW1ibHkuTWVtb3J5KHtpbml0aWFsOmwsbWF4aW11bTpsfSkuYnVmZmVyfWVsc2UgdGhyb3cgZH1sZXQgYT0wO2Zvcig7Oyl7bGV0e2RvbmU6ZCx2YWx1ZTpsfT1hd2FpdCBvLnJlYWQoKTtpZihkKWJyZWFrO2xldCBwPWwuYnl0ZUxlbmd0aDtuZXcgVWludDhBcnJheShpLGEscCkuc2V0KGwpLGErPXB9cmV0dXJuIG5ldyBVaW50OEFycmF5KGksMCxuKX19ZWxzZSByZXR1cm4gZSBpbnN0YW5jZW9mIEJsb2I/bmV3IFVpbnQ4QXJyYXkoYXdhaXQgZS5hcnJheUJ1ZmZlcigpKTplIGluc3RhbmNlb2YgVWludDhBcnJheT9lOm5ldyBVaW50OEFycmF5KGUpfX0pO3ZhciBvbSxpbSxLYSxqYSxScixhbSx1ZSxldD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtvbT1bXCJWXCIsXCJJXCIsXCJXXCIsXCJFXCIsXCJGXCJdLGltPShlLHQpPT57Y29uc29sZS5sb2coYFske29tW2VdfSwke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKX1dJHt0fWApfSxScj0oZSx0KT0+e0thPWUsamE9dH0sYW09KGUsdCk9PntsZXQgcj1adChlKSxuPVp0KEthKTtyPj1uJiZpbShyLHR5cGVvZiB0PT1cImZ1bmN0aW9uXCI/dCgpOnQpfSx1ZT0oLi4uZSk9PntqYSYmYW0oLi4uZSl9fSk7dmFyIFVyLEpuPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO1VyPShlLHQpPT5uZXcoRHIodCkpKGUpfSk7dmFyIE5yPVUoKCk9PntcInVzZSBzdHJpY3RcIn0pO3ZhciBZYSxlbyx0byxzbSx1bSxaYSxubyxybyxYYSxKYT1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7ZXQoKTtOcigpO1lhPW5ldyBNYXAoW1s2NCwyNTBdLFsxMjgsMjAwXSxbMjU2LDIwMF0sWzUxMiwyMDBdLFsyMDQ4LDIzMF0sWzQwOTYsMjAwXSxbODE5Miw1MF0sWzE2Mzg0LDUwXSxbMzI3NjgsNTBdLFs2NTUzNiw1MF0sWzEzMTA3Miw1MF0sWzI2MjE0NCw1MF0sWzUyNDI4OCw1MF0sWzEwNDg1NzYsNTBdLFsyMDk3MTUyLDMwXSxbNDE5NDMwNCwyMF0sWzgzODg2MDgsMTBdLFsxMjU4MjkxMiwxMF0sWzE2Nzc3MjE2LDEwXSxbMjYyMTQ0MDAsMTVdLFszMzU1NDQzMiwyMl0sWzQ0MjM2ODAwLDJdLFs1ODk4MjQwMCw2XSxbNjcxMDg4NjQsNl0sWzEzNDIxNzcyOCw2XSxbMTY3NzcyMTYwLDZdXSksZW89W10sdG89ZT0+TWF0aC5jZWlsKE51bWJlcihlKS8xNikqMTYsc209ZT0+e2ZvcihsZXQgdD0wO3Q8ZW8ubGVuZ3RoO3QrKyl7bGV0IHI9ZW9bdF07aWYoZTw9cilyZXR1cm4gcn1yZXR1cm4gTWF0aC5jZWlsKGUvMTYpKjE2fSx1bT0xLFphPSgpPT51bSsrLG5vPWFzeW5jKGUsdCxyLG4pPT57bGV0IG89dG8ociksaT1lLmRldmljZS5jcmVhdGVCdWZmZXIoe3NpemU6byx1c2FnZTpHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVHxHUFVCdWZmZXJVc2FnZS5NQVBfUkVBRH0pO3RyeXtsZXQgYT1lLmdldENvbW1hbmRFbmNvZGVyKCk7ZS5lbmRDb21wdXRlUGFzcygpLGEuY29weUJ1ZmZlclRvQnVmZmVyKHQsMCxpLDAsbyksZS5mbHVzaCgpLGF3YWl0IGkubWFwQXN5bmMoR1BVTWFwTW9kZS5SRUFEKTtsZXQgZD1pLmdldE1hcHBlZFJhbmdlKCk7aWYobil7bGV0IGw9bigpO3JldHVybiBsLnNldChuZXcgVWludDhBcnJheShkLDAscikpLGx9ZWxzZSByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZC5zbGljZSgwLHIpKX1maW5hbGx5e2kuZGVzdHJveSgpfX0scm89Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5iYWNrZW5kPXQ7dGhpcy5zdG9yYWdlQ2FjaGU9bmV3IE1hcCx0aGlzLmZyZWVCdWZmZXJzPW5ldyBNYXAsdGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnM9bmV3IE1hcCx0aGlzLmJ1ZmZlcnNQZW5kaW5nPVtdLHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycz1uZXcgTWFwO2ZvcihsZXRbcl1vZiBZYSllby5wdXNoKHIpLHRoaXMuZnJlZUJ1ZmZlcnMuc2V0KHIsW10pLHRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzLnNldChyLFtdKTt0aGlzLnNlc3Npb25Db3VudD0wfXVwbG9hZCh0LHIpe2xldCBuPXIuYnVmZmVyLG89ci5ieXRlT2Zmc2V0LGk9ci5ieXRlTGVuZ3RoLGE9dG8oaSksZD10aGlzLnN0b3JhZ2VDYWNoZS5nZXQodCk7aWYoIWQpdGhyb3cgbmV3IEVycm9yKFwiZ3B1IGRhdGEgZm9yIHVwbG9hZGluZyBkb2VzIG5vdCBleGlzdFwiKTtpZihOdW1iZXIoZC5vcmlnaW5hbFNpemUpIT09aSl0aHJvdyBuZXcgRXJyb3IoYGluY29uc2lzdGVudCBkYXRhIHNpemUuIGdwdSBkYXRhIHNpemU9JHtkLm9yaWdpbmFsU2l6ZX0sIGRhdGEgc2l6ZT0ke2l9YCk7bGV0IGw9dGhpcy5iYWNrZW5kLmRldmljZS5jcmVhdGVCdWZmZXIoe21hcHBlZEF0Q3JlYXRpb246ITAsc2l6ZTphLHVzYWdlOkdQVUJ1ZmZlclVzYWdlLk1BUF9XUklURXxHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQ30pLHA9bC5nZXRNYXBwZWRSYW5nZSgpO25ldyBVaW50OEFycmF5KHApLnNldChuZXcgVWludDhBcnJheShuLG8saSkpLGwudW5tYXAoKTtsZXQgbT10aGlzLmJhY2tlbmQuZGV2aWNlLmNyZWF0ZUNvbW1hbmRFbmNvZGVyKCk7bS5jb3B5QnVmZmVyVG9CdWZmZXIobCwwLGQuZ3B1RGF0YS5idWZmZXIsMCxhKSx0aGlzLmJhY2tlbmQuZGV2aWNlLnF1ZXVlLnN1Ym1pdChbbS5maW5pc2goKV0pLGwuZGVzdHJveSgpLHVlKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIudXBsb2FkKGlkPSR7dH0pYCl9bWVtY3B5KHQscil7bGV0IG49dGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KHQpO2lmKCFuKXRocm93IG5ldyBFcnJvcihcInNvdXJjZSBncHUgZGF0YSBmb3IgbWVtY3B5IGRvZXMgbm90IGV4aXN0XCIpO2xldCBvPXRoaXMuc3RvcmFnZUNhY2hlLmdldChyKTtpZighbyl0aHJvdyBuZXcgRXJyb3IoXCJkZXN0aW5hdGlvbiBncHUgZGF0YSBmb3IgbWVtY3B5IGRvZXMgbm90IGV4aXN0XCIpO2lmKG4ub3JpZ2luYWxTaXplIT09by5vcmlnaW5hbFNpemUpdGhyb3cgbmV3IEVycm9yKFwiaW5jb25zaXN0ZW50IHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZ3B1IGRhdGEgc2l6ZVwiKTtsZXQgaT10byhuLm9yaWdpbmFsU2l6ZSksYT10aGlzLmJhY2tlbmQuZ2V0Q29tbWFuZEVuY29kZXIoKTt0aGlzLmJhY2tlbmQuZW5kQ29tcHV0ZVBhc3MoKSxhLmNvcHlCdWZmZXJUb0J1ZmZlcihuLmdwdURhdGEuYnVmZmVyLDAsby5ncHVEYXRhLmJ1ZmZlciwwLGkpfXJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIodCxyLG4pe2xldCBvO2lmKG4pe2lmKG89blswXSx0PT09blsxXSlyZXR1cm4gdWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci5yZWdpc3RlckV4dGVybmFsQnVmZmVyKHNpemU9JHtyfSkgPT4gaWQ9JHtvfSwgYnVmZmVyIGlzIHRoZSBzYW1lLCBza2lwLmApLG87aWYodGhpcy5iYWNrZW5kLmNhcHR1cmVkQ29tbWFuZExpc3QuaGFzKHRoaXMuYmFja2VuZC5jdXJyZW50U2Vzc2lvbklkKSl0aHJvdyBuZXcgRXJyb3IoYFJlZ2lzdGVyaW5nIGEgZGlmZmVyZW50IGV4dGVybmFsIGJ1ZmZlciB1bmRlciBncmFwaCBjYXB0dXJlIG1vZGUgaXMgbm90IHN1cHBvcnRlZCB5ZXQuXG4gICAgICAgICAgICAgUGxlYXNlIHVzZSB0aGUgcHJldmlvdXMgZXh0ZXJuYWwgYnVmZmVyIWApfWVsc2Ugbz1aYSgpO3JldHVybiB0aGlzLnN0b3JhZ2VDYWNoZS5zZXQobyx7Z3B1RGF0YTp7aWQ6byx0eXBlOjAsYnVmZmVyOnR9LG9yaWdpbmFsU2l6ZTpyfSksdWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci5yZWdpc3RlckV4dGVybmFsQnVmZmVyKHNpemU9JHtyfSkgPT4gaWQ9JHtvfSwgcmVnaXN0ZXJlZC5gKSxvfXVucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcih0KXt0IT09dm9pZCAwJiYodGhpcy5zdG9yYWdlQ2FjaGUuZGVsZXRlKHQpLHVlKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIudW5yZWdpc3RlckV4dGVybmFsQnVmZmVyKCkgPT4gaWQ9JHt0fWApKX1jcmVhdGUodCxyPUdQVUJ1ZmZlclVzYWdlLlNUT1JBR0V8R1BVQnVmZmVyVXNhZ2UuQ09QWV9TUkN8R1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1Qpe2xldCBuPXNtKHQpLG8saT0ociZHUFVCdWZmZXJVc2FnZS5TVE9SQUdFKT09PUdQVUJ1ZmZlclVzYWdlLlNUT1JBR0UsYT0ociZHUFVCdWZmZXJVc2FnZS5VTklGT1JNKT09PUdQVUJ1ZmZlclVzYWdlLlVOSUZPUk07aWYoaXx8YSl7bGV0IHA9KGk/dGhpcy5mcmVlQnVmZmVyczp0aGlzLmZyZWVVbmlmb3JtQnVmZmVycykuZ2V0KG4pO3A/cC5sZW5ndGg+MD9vPXAucG9wKCk6bz10aGlzLmJhY2tlbmQuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7c2l6ZTpuLHVzYWdlOnJ9KTpvPXRoaXMuYmFja2VuZC5kZXZpY2UuY3JlYXRlQnVmZmVyKHtzaXplOm4sdXNhZ2U6cn0pfWVsc2Ugbz10aGlzLmJhY2tlbmQuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7c2l6ZTpuLHVzYWdlOnJ9KTtsZXQgZD17aWQ6WmEoKSx0eXBlOjAsYnVmZmVyOm99O3JldHVybiB0aGlzLnN0b3JhZ2VDYWNoZS5zZXQoZC5pZCx7Z3B1RGF0YTpkLG9yaWdpbmFsU2l6ZTpOdW1iZXIodCl9KSx1ZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLmNyZWF0ZShzaXplPSR7dH0pID0+IGlkPSR7ZC5pZH1gKSxkfWdldCh0KXtyZXR1cm4gdGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KHQpPy5ncHVEYXRhfXJlbGVhc2UodCl7bGV0IHI9dHlwZW9mIHQ9PVwiYmlnaW50XCI/TnVtYmVyKHQpOnQsbj10aGlzLnN0b3JhZ2VDYWNoZS5nZXQocik7aWYoIW4pe2lmKHRoaXMuc3RvcmFnZUNhY2hlLnNpemU9PT0wKXJldHVybiAwO3Rocm93IG5ldyBFcnJvcihcInJlbGVhc2luZyBkYXRhIGRvZXMgbm90IGV4aXN0XCIpfXJldHVybiB1ZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLnJlbGVhc2UoaWQ9JHtyfSksIGdwdURhdGFJZD0ke24uZ3B1RGF0YS5pZH1gKSx0aGlzLnN0b3JhZ2VDYWNoZS5kZWxldGUociksdGhpcy5idWZmZXJzUGVuZGluZy5wdXNoKG4uZ3B1RGF0YS5idWZmZXIpLG4ub3JpZ2luYWxTaXplfWFzeW5jIGRvd25sb2FkKHQscil7bGV0IG49dGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KE51bWJlcih0KSk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiZGF0YSBkb2VzIG5vdCBleGlzdFwiKTthd2FpdCBubyh0aGlzLmJhY2tlbmQsbi5ncHVEYXRhLmJ1ZmZlcixuLm9yaWdpbmFsU2l6ZSxyKX1yZWZyZXNoUGVuZGluZ0J1ZmZlcnMoKXtpZih0aGlzLmJ1ZmZlcnNQZW5kaW5nLmxlbmd0aCE9PTApaWYodGhpcy5iYWNrZW5kLnNlc3Npb25TdGF0dXM9PT1cImRlZmF1bHRcIil7Zm9yKGxldCB0IG9mIHRoaXMuYnVmZmVyc1BlbmRpbmcpe2xldCByPVlhLmdldCh0LnNpemUpO2lmKCh0LnVzYWdlJkdQVUJ1ZmZlclVzYWdlLlNUT1JBR0UpPT09R1BVQnVmZmVyVXNhZ2UuU1RPUkFHRSl7bGV0IG49dGhpcy5mcmVlQnVmZmVycy5nZXQodC5zaXplKXx8W107cj09PXZvaWQgMHx8bi5sZW5ndGg+PXI/dC5kZXN0cm95KCk6bi5wdXNoKHQpfWVsc2UgaWYoKHQudXNhZ2UmR1BVQnVmZmVyVXNhZ2UuVU5JRk9STSk9PT1HUFVCdWZmZXJVc2FnZS5VTklGT1JNKXtsZXQgbj10aGlzLmZyZWVVbmlmb3JtQnVmZmVycy5nZXQodC5zaXplKXx8W107cj09PXZvaWQgMHx8bi5sZW5ndGg+PXI/dC5kZXN0cm95KCk6bi5wdXNoKHQpfWVsc2UgdC5kZXN0cm95KCl9dGhpcy5idWZmZXJzUGVuZGluZz1bXX1lbHNle2xldCB0PXRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycy5nZXQodGhpcy5iYWNrZW5kLmN1cnJlbnRTZXNzaW9uSWQpO3R8fCh0PVtdLHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycy5zZXQodGhpcy5iYWNrZW5kLmN1cnJlbnRTZXNzaW9uSWQsdCkpO2ZvcihsZXQgciBvZiB0aGlzLmJ1ZmZlcnNQZW5kaW5nKXQucHVzaChyKTt0aGlzLmJ1ZmZlcnNQZW5kaW5nPVtdfX1kaXNwb3NlKCl7dGhpcy5mcmVlQnVmZmVycy5mb3JFYWNoKHQ9Pnt0LmZvckVhY2gocj0+e3IuZGVzdHJveSgpfSl9KSx0aGlzLmZyZWVVbmlmb3JtQnVmZmVycy5mb3JFYWNoKHQ9Pnt0LmZvckVhY2gocj0+e3IuZGVzdHJveSgpfSl9KSx0aGlzLnN0b3JhZ2VDYWNoZS5mb3JFYWNoKHQ9Pnt0LmdwdURhdGEuYnVmZmVyLmRlc3Ryb3koKX0pLHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycy5mb3JFYWNoKHQ9Pnt0LmZvckVhY2gocj0+e3IuZGVzdHJveSgpfSl9KSx0aGlzLnN0b3JhZ2VDYWNoZT1uZXcgTWFwLHRoaXMuZnJlZUJ1ZmZlcnM9bmV3IE1hcCx0aGlzLmZyZWVVbmlmb3JtQnVmZmVycz1uZXcgTWFwLHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycz1uZXcgTWFwfW9uQ3JlYXRlU2Vzc2lvbigpe3RoaXMuc2Vzc2lvbkNvdW50Kz0xfW9uUmVsZWFzZVNlc3Npb24odCl7bGV0IHI9dGhpcy5jYXB0dXJlZFBlbmRpbmdCdWZmZXJzLmdldCh0KTtyJiYoci5mb3JFYWNoKG49PntuLmRlc3Ryb3koKX0pLHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycy5kZWxldGUodCkpLHRoaXMuc2Vzc2lvbkNvdW50LT0xLHRoaXMuc2Vzc2lvbkNvdW50PT09MCYmKHVlKFwid2FybmluZ1wiLCgpPT5cIltXZWJHUFVdIENsZWFyaW5nIHdlYmdwdSBidWZmZXIgY2FjaGVcIiksdGhpcy5zdG9yYWdlQ2FjaGUuZm9yRWFjaChuPT57bi5ncHVEYXRhLmJ1ZmZlci5kZXN0cm95KCl9KSx0aGlzLnN0b3JhZ2VDYWNoZT1uZXcgTWFwKX19LFhhPSguLi5lKT0+bmV3IHJvKC4uLmUpfSk7dmFyIG9vLHJlLFNlPVUoKCk9PntcInVzZSBzdHJpY3RcIjtvbz1jbGFzc3tjb25zdHJ1Y3Rvcih0KXtPYmplY3QuYXNzaWduKHRoaXMsdCl9Z2V0IGNhY2hlS2V5KCl7cmV0dXJuIHRoaXMua2V5fHwodGhpcy5rZXk9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykuc29ydCgpLm1hcCh0PT5gJHt0aGlzW3RdfWApLmpvaW4oXCI7XCIpKSx0aGlzLmtleX19LHJlPWU9Pm5ldyBvbyhlKX0pO3ZhciBpbyx0dCxDLEF0LFZyLGVzLHRzLG9lPVUoKCk9PntcInVzZSBzdHJpY3RcIjtpbz1jbGFzc3tzdGF0aWMgY2FsY01hdE11bFNoYXBlKHQscil7cmV0dXJuIHRbMV0hPT1yWzBdP3ZvaWQgMDpbdFswXSxyWzFdXX19LHR0PWNsYXNze3N0YXRpYyBjYWxjU2hhcGUodCxyLG49ITEpe2xldCBvPXQubGVuZ3RoLGk9ci5sZW5ndGg7aWYobz09PTApcmV0dXJuIHI7aWYoaT09PTApcmV0dXJuIHQ7bGV0IGE9TWF0aC5tYXgodC5sZW5ndGgsci5sZW5ndGgpLGQ9bmV3IEFycmF5KGEpO2lmKG4pe2lmKG88Mnx8aTwyKXJldHVybjtsZXQgbD1pby5jYWxjTWF0TXVsU2hhcGUoW3Rbby0yXSx0W28tMV1dLFtyW2ktMl0scltpLTFdXSk7aWYobD09PXZvaWQgMClyZXR1cm47W2RbYS0yXSxkW2EtMV1dPWx9Zm9yKGxldCBsPW4/MzoxO2w8PWE7bCsrKXtsZXQgcD1vLWw8MD8xOnRbby1sXSxtPWktbDwwPzE6cltpLWxdO2lmKHAhPT1tJiZwPjEmJm0+MSlyZXR1cm47bGV0IHU9TWF0aC5tYXgocCxtKTtpZihwJiZtKWRbYS1sXT1NYXRoLm1heChwLG0pO2Vsc2V7aWYodT4xKXJldHVybjtkW2EtbF09MH19cmV0dXJuIGR9c3RhdGljIGlzVmFsaWRCcm9hZGNhc3QodCxyKXtsZXQgbj10Lmxlbmd0aCxvPXIubGVuZ3RoO2lmKG4+bylyZXR1cm4hMTtmb3IobGV0IGk9MTtpPD1uO2krKylpZih0W24taV0hPT0xJiZ0W24taV0hPT1yW28taV0pcmV0dXJuITE7cmV0dXJuITB9fSxDPWNsYXNzIGV7c3RhdGljIHNpemUodCl7cmV0dXJuIGUuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZSh0LDAsdC5sZW5ndGgpfXN0YXRpYyBjb252ZXJ0U2hhcGUodCxyPTQpe2xldCBuPXQubGVuZ3RoO2lmKG49PT0wKXJldHVybltdO2xldCBvPW5ldyBBcnJheShuKSxpPW4tMTtmb3IoO2k+PTA7KXtpZih0W2ldJXI9PT0wKXtvW2ldPXRbaV0vcjticmVha31pZihyJXRbaV0hPT0wKXRocm93IG5ldyBFcnJvcihcImNhbm5vdCBjb252ZXJ0IHNoYXBlXCIpO29baV09MSxyLz10W2ldLGktLX1mb3IoaS0tO2k+PTA7aS0tKW9baV09dFtpXTtyZXR1cm4gb31zdGF0aWMgc2l6ZUZyb21EaW1lbnNpb24odCxyKXtpZihyPDB8fHI+dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRpbWVuc2lvbiBvZiAke3J9IGZvciBzaXplRnJvbURpbWVuc2lvbiBhcyBUZW5zb3IgaGFzICR7dC5sZW5ndGh9IGRpbWVuc2lvbnMuYCk7cmV0dXJuIGUuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZSh0LHIsdC5sZW5ndGgpfXN0YXRpYyBzaXplVG9EaW1lbnNpb24odCxyKXtpZihyPDB8fHI+dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRpbWVuc2lvbiBvZiAke3J9IGZvciBzaXplVG9EaW1lbnNpb24gYXMgVGVuc29yIGhhcyAke3QubGVuZ3RofSBkaW1lbnNpb25zLmApO3JldHVybiBlLmdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UodCwwLHIpfXN0YXRpYyBnZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKHQscixuKXtsZXQgbz0xO2ZvcihsZXQgaT1yO2k8bjtpKyspe2lmKHRbaV08MCl0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZ2V0IHZhbGlkIHNpemUgZnJvbSBzcGVjaWZpZWQgZGltZW5zaW9uIHJhbmdlLiBNb3N0IGxpa2VseSB0aGUgcmFuZ2UgY29udGFpbnMgbmVnYXRpdmUgdmFsdWVzIGluIHRoZW0uXCIpO28qPU51bWJlcih0W2ldKX1yZXR1cm4gb31zdGF0aWMgY29tcHV0ZVN0cmlkZXModCl7bGV0IHI9dC5sZW5ndGg7aWYocj09PTApcmV0dXJuW107aWYocj09PTEpcmV0dXJuWzFdO2xldCBuPW5ldyBBcnJheShyKTtuW3ItMV09MSxuW3ItMl09dFtyLTFdO2ZvcihsZXQgbz1yLTM7bz49MDstLW8pbltvXT1uW28rMV0qdFtvKzFdO3JldHVybiBufXN0YXRpYyBub3JtYWxpemVBeGlzKHQscil7aWYodDwtciYmdD49cil0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBheGlzIGZvciB0aGlzIG9wZXJhdGlvbi5cIik7cmV0dXJuIHQ8MD90K3I6dH1zdGF0aWMgbm9ybWFsaXplQXhlcyh0LHIpe3JldHVybiB0Lm1hcChuPT50aGlzLm5vcm1hbGl6ZUF4aXMobixyPz90Lmxlbmd0aCkpfXN0YXRpYyBzb3J0QmFzZWRPblBlcm0odCxyKXtyZXR1cm4gcj9yLm1hcChuPT50W25dKTp0LnNsaWNlKCkucmV2ZXJzZSgpfXN0YXRpYyBwYWRTaGFwZSh0LHIpe2xldCBuPXQubGVuZ3RoO3JldHVybiB0Lm1hcCgobyxpKT0+bytyW2ldK3JbaStuXSl9c3RhdGljIGFyZUVxdWFsKHQscil7cmV0dXJuIHQubGVuZ3RoIT09ci5sZW5ndGg/ITE6dC5ldmVyeSgobixvKT0+bj09PXJbb10pfX0sQXQ9Y2xhc3MgZXtzdGF0aWMgYWRqdXN0UG9vbEF0dHJpYnV0ZXModCxyLG4sbyxpLGEpe2lmKCF0JiZuLmxlbmd0aCE9PXIubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG9mIHNwZWNpZmllZCBrZXJuZWwgc2hhcGVzIHNob3VsZCBiZSAyIGxlc3MgdGhhbiBsZW5ndGggb2YgaW5wdXQgZGltZW5zaW9uc1wiKTtpZih0KWZvcihsZXQgZD0wO2Q8ci5sZW5ndGgtMjtkKyspZD49bi5sZW5ndGg/bi5wdXNoKHJbZCsyXSk6bltkXT1yW2QrMl07Zm9yKGxldCBkPTA7ZDxuLmxlbmd0aDtkKyspaWYoZDxvLmxlbmd0aCl7aWYob1tkXTwwKXRocm93IG5ldyBFcnJvcihcInN0cmlkZXMgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxXCIpfWVsc2Ugby5wdXNoKDEpO2ZvcihsZXQgZD0wO2Q8bi5sZW5ndGg7ZCsrKWlmKGQ8aS5sZW5ndGgpe2lmKGlbZF08MCl0aHJvdyBuZXcgRXJyb3IoXCJkaWxhdGlvbnMgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxXCIpfWVsc2UgaS5wdXNoKDEpO2ZvcihsZXQgZD0wO2Q8bi5sZW5ndGgqMjtkKyspaWYoZDxhLmxlbmd0aCl7aWYoYVtkXTwwKXRocm93IG5ldyBFcnJvcihcInBhZCBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDFcIil9ZWxzZSBhLnB1c2goMCk7Zm9yKGxldCBkPTA7ZDxuLmxlbmd0aDtkKyspe2lmKG5bZF08PTApdGhyb3cgbmV3IEVycm9yKFwia2VybmVsIHNoYXBlcyBuZWVkIHRvIGJlIGdyZWF0ZXIgdGhhbiAwXCIpO2lmKGFbZF0+PW5bZF18fGFbZCtuLmxlbmd0aF0+PW5bZF0pdGhyb3cgbmV3IEVycm9yKFwicGFkcyBzaG91bGQgYmUgc21hbGxlciB0aGFuIGtlcm5lbFwiKX19c3RhdGljIGFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZCh0LHIsbixvLGksYSxkKXtpZihkKXtpZihpLmxlbmd0aCE9PTIqKHQubGVuZ3RoLTIpKXRocm93IG5ldyBFcnJvcihcImxlbmd0aCBvZiBwYWRzIHNob3VsZCBiZSB0d2ljZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9uc1wiKTtpZihyLmxlbmd0aCE9PXQubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG9mIHN0cmlkZXMgc2hvdWxkIGJlIHRoZSBsZW5ndGggb2YgZGF0YSBkaW1lbnNpb25zXCIpO2lmKG8ubGVuZ3RoIT09dC5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggb2Yga2VybmVsIHNoYXBlcyBzaG91bGQgYmUgdGhlIGxlbmd0aCBvZiBkYXRhIGRpbWVuc2lvbnNcIik7Zm9yKGxldCBsPTA7bDx0Lmxlbmd0aC0yO2wrKyllLmFkanVzdFBhZEFuZFJldHVyblNoYXBlKHRbbCsoYT8xOjIpXSxyW2xdLG5bbF0sb1tsXSxpLGwsbCt0Lmxlbmd0aC0yLGQpfX1zdGF0aWMgY29tcHV0ZVBvb2xPdXRwdXRTaGFwZSh0LHIsbixvLGksYSxkKXtpZihyLmxlbmd0aDw9MCl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCBzaGFwZSBtdXN0IGJlIG9mIHNpemUgZ3JlYXRlciB0aGFuIDBcIik7bGV0IGw9W3JbMF0sclsxXV07cmV0dXJuIGUuY29tcHV0ZVNoYXBlSGVscGVyKHQscixsLG4sbyxpLGEsZCksbH1zdGF0aWMgY29tcHV0ZUNvbnZPdXRwdXRTaGFwZSh0LHIsbixvLGksYSxkKXtpZih0Lmxlbmd0aDw9MHx8ci5sZW5ndGg8PTApdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnB1dCB0ZW5zb3IgZGltcyBvciBpbnZhbGlkIGZpbHRlciB0ZW5zb3IgZGltc1wiKTtsZXQgbD1bdFswXSxyWzBdXTtyZXR1cm4gZS5jb21wdXRlU2hhcGVIZWxwZXIoITEsdCxsLG4sbyxpLGEsZCksbH1zdGF0aWMgY29tcHV0ZVNoYXBlSGVscGVyKHQscixuLG8saSxhLGQsbCl7aWYodClmb3IobGV0IHA9MDtwPHIubGVuZ3RoLTI7cCsrKW4ucHVzaCgxKTtlbHNlIGZvcihsZXQgcD0wO3A8ci5sZW5ndGgtMjtwKyspbi5wdXNoKGUuYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUocltwKzJdLG9bcF0saVtwXSxhW3BdLGQscCxwK3IubGVuZ3RoLTIsbCkpfXN0YXRpYyBhZGp1c3RQYWRBbmRSZXR1cm5TaGFwZSh0LHIsbixvLGksYSxkLGwpe2xldCBwPW4qKG8tMSkrMTtpZihsJiZsIT09XCJOT1RTRVRcIilzd2l0Y2gobCl7Y2FzZVwiVkFMSURcIjpyZXR1cm4gaVthXT0wLGlbZF09MCxNYXRoLmZsb29yKCh0LXApL3IrMSk7Y2FzZVwiU0FNRV9MT1dFUlwiOmNhc2VcIlNBTUVfVVBQRVJcIjppZihuIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJEaWxhdGlvbiBub3Qgc3VwcG9ydGVkIGZvciBTQU1FX1VQUEVSIG9yIFNBTUVfTE9XRVJcIik7e2xldCB1PSgodCtyLTEpL3ItMSkqcitvLXQ7cmV0dXJuIGlbYV09TWF0aC5mbG9vcihsPT09XCJTQU1FX0xPV0VSXCI/KHUrMSkvMjp1LzIpLGlbZF09dS1pW2FdLE1hdGguZmxvb3IoKHQrdS1vKS9yKzEpfWRlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgQXV0b1BhZCB0eXBlXCIpfWVsc2UgcmV0dXJuIE1hdGguZmxvb3IoKHQraVthXStpW2RdLXApL3IrMSl9fSxWcj1jbGFzc3tzdGF0aWMgZ2V0U2hhcGVPZkdlbW1SZXN1bHQodCxyLG4sbyxpKXtpZih0Lmxlbmd0aCE9PTJ8fG4ubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJzaGFwZSBuZWVkIHRvIGJlIG9mIHNpemUgMlwiKTtsZXQgYSxkLGw7cj8oYT10WzFdLGQ9dFswXSk6KGE9dFswXSxkPXRbMV0pO2xldCBwPS0xO2lmKG8/KGw9blswXSxwPTEpOihsPW5bMV0scD0wKSxuW3BdIT09ZCl0aHJvdyBuZXcgRXJyb3IoXCJkaW1lbnNpb24gbWlzbWF0Y2hcIik7aWYoYTw9MHx8bDw9MHx8ZDw9MCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNoYXBlIHNwZWNpZmllZFwiKTtpZihpJiYhdHQuaXNWYWxpZEJyb2FkY2FzdChpLFthLGxdKSl0aHJvdyBuZXcgRXJyb3IoXCJnZW1tOiBpbnZhbGlkIGJpYXMgc2hhcGUgZm9yIGJyb2FkY2FzdFwiKTtyZXR1cm5bYSxsLGRdfX0sZXM9LTM0MDI4MjM0NjYzODUyODg2ZTIyLHRzPTM0MDI4MjM0NjYzODUyODg2ZTIyfSk7dmFyIGt0LHNvLF9lLEVlLE4sbWUsdW8sRXQsRmUsRixXcixFLE0scnMsTHIsYW8sbnMsYWU9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTtrdD02NCxzbz0oZSx0KT0+e2lmKHQ9PT0zKXRocm93IG5ldyBFcnJvcihcInZlYzMgaGFzIHNhbWUgYWxpZ25tZW50IGFzIHZlYzQsIHVzZSB2ZWM0IGluc3RlYWRcIik7c3dpdGNoKE51bWJlcihlKSl7Y2FzZSAxMDpyZXR1cm4gdD4xP2B2ZWMke3R9PGYxNj5gOlwiZjE2XCI7Y2FzZSAxOnJldHVybiB0PjE/YHZlYyR7dH08ZjMyPmA6XCJmMzJcIjtjYXNlIDY6cmV0dXJuIHQ+MT9gdmVjJHt0fTxpMzI+YDpcImkzMlwiO2Nhc2UgMTI6cmV0dXJuIHQ+MT9gdmVjJHt0fTx1MzI+YDpcInUzMlwiO2Nhc2UgNzppZih0PjEpdGhyb3cgbmV3IEVycm9yKFwiY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQgdmVjWCBvZiB1aW50NjQgeWV0XCIpO3JldHVybltcInZlYzI8dTMyPlwiLFwiaTMyXCJdO2Nhc2UgMTM6aWYodD4xKXRocm93IG5ldyBFcnJvcihcImN1cnJlbnRseSBub3Qgc3VwcG9ydGVkIHZlY1ggb2YgdWludDY0IHlldFwiKTtyZXR1cm5bXCJ2ZWMyPHUzMj5cIixcInUzMlwiXTtjYXNlIDk6aWYodCE9PTQpdGhyb3cgbmV3IEVycm9yKFwiYm9vbCBtdXN0IGJlIHZlYzRcIik7cmV0dXJuW1widTMyXCIsXCJ2ZWM0PGJvb2w+XCJdO2Nhc2UgMjI6cmV0dXJuXCJpMzJcIjtjYXNlIDIxOnJldHVyblwidTMyXCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZGF0YSB0eXBlOiAke2V9YCl9fSxfZT0oZSx0PTEpPT57bGV0IHI9c28oZSx0KTtyZXR1cm4gdHlwZW9mIHI9PVwic3RyaW5nXCI/cjpyWzBdfSxFZT0oZSx0PTEpPT57bGV0IHI9c28oZSx0KTtyZXR1cm4gdHlwZW9mIHI9PVwic3RyaW5nXCI/cjpyWzFdfSxOPSguLi5lKT0+e2xldCB0PVtdO3JldHVybiBlLmZvckVhY2gocj0+e3IubGVuZ3RoIT09MCYmdC5wdXNoKHt0eXBlOjEyLGRhdGE6cn0se3R5cGU6MTIsZGF0YTpDLmNvbXB1dGVTdHJpZGVzKHIpfSl9KSx0fSxtZT1lPT5lJTQ9PT0wPzQ6ZSUyPT09MD8yOjEsdW89KGU9XCJmMzJcIix0LHI9XCIwXCIpPT4hdHx8dD09PTE/YCR7ZX0oJHtyfSlgOmB2ZWMke3R9PCR7ZX0+KCR7cn0pYCxFdD0oZSx0LHIpPT5lPT09XCJmMzJcIj9yOnQ9PT0xP2BmMzIoJHtyfSlgOmB2ZWMke3R9PGYzMj4oJHtyfSlgLEZlPShlLHQpPT50PT09ND9gKCR7ZX0ueCArICR7ZX0ueSArICR7ZX0ueiArICR7ZX0udylgOnQ9PT0yP2AoJHtlfS54ICsgJHtlfS55KWA6dD09PTM/YCgke2V9LnggKyAke2V9LnkgKyAke2V9LnopYDplLEY9KGUsdCxyLG4pPT5lLnN0YXJ0c1dpdGgoXCJ1bmlmb3Jtcy5cIikmJnI+ND90eXBlb2YgdD09XCJzdHJpbmdcIj9uPT09XCJmMTZcIj9gJHtlfVsoJHt0fSkgLyA4XVsoJHt0fSkgJSA4IC8gNF1bKCR7dH0pICUgOCAlIDRdYDpgJHtlfVsoJHt0fSkgLyA0XVsoJHt0fSkgJSA0XWA6bj09PVwiZjE2XCI/YCR7ZX1bJHtNYXRoLmZsb29yKHQvOCl9XVske01hdGguZmxvb3IodCU4LzQpfV1bJHt0JTglNH1dYDpgJHtlfVske01hdGguZmxvb3IodC80KX1dWyR7dCU0fV1gOnI+MT9gJHtlfVske3R9XWA6ZSxXcj0oZSx0LHIsbixvKT0+e2xldCBpPXR5cGVvZiByPT1cIm51bWJlclwiLGE9aT9yOnIubGVuZ3RoLGQ9Wy4uLm5ldyBBcnJheShhKS5rZXlzKCldLGw9YTwyP1widTMyXCI6YTw9ND9gdmVjJHthfTx1MzI+YDpgYXJyYXk8dTMyLCAke2F9PmAscD1zbyh0LG8pLG09dHlwZW9mIHA9PVwic3RyaW5nXCI/cDpwWzFdLHU9dHlwZW9mIHA9PVwic3RyaW5nXCI/cDpwWzBdLGg9e2luZGljZXM6bCx2YWx1ZTptLHN0b3JhZ2U6dSx0ZW5zb3I6dH0sXz1XPT50eXBlb2YgVz09XCJzdHJpbmdcIj9XOmAke1d9dWAseT17b2Zmc2V0VG9JbmRpY2VzOiExLGluZGljZXNUb09mZnNldDohMSxicm9hZGNhc3RlZEluZGljZXNUb09mZnNldDohMSxzZXQ6ITEsc2V0QnlJbmRpY2VzOiExLGdldDohMSxnZXRCeUluZGljZXM6ITF9LGc9aT9cInVuaWZvcm1zLlwiOlwiXCIseD1gJHtnfSR7ZX1fc2hhcGVgLCQ9YCR7Z30ke2V9X3N0cmlkZXNgLHY9XCJcIjtmb3IobGV0IFc9MDtXPGEtMTtXKyspdis9YFxuICAgIGxldCBkaW0ke1d9ID0gY3VycmVudCAvICR7RigkLFcsYSl9O1xuICAgIGxldCByZXN0JHtXfSA9IGN1cnJlbnQgJSAke0YoJCxXLGEpfTtcbiAgICBpbmRpY2VzWyR7V31dID0gZGltJHtXfTtcbiAgICBjdXJyZW50ID0gcmVzdCR7V307XG4gICAgYDt2Kz1gaW5kaWNlc1ske2EtMX1dID0gY3VycmVudDtgO2xldCBTPWE8Mj9cIlwiOmBcbiAgZm4gbzJpXyR7ZX0ob2Zmc2V0OiB1MzIpIC0+ICR7aC5pbmRpY2VzfSB7XG4gICAgdmFyIGluZGljZXM6ICR7aC5pbmRpY2VzfTtcbiAgICB2YXIgY3VycmVudCA9IG9mZnNldDtcbiAgICAke3Z9XG4gICAgcmV0dXJuIGluZGljZXM7XG4gIH1gLFQ9Vz0+KHkub2Zmc2V0VG9JbmRpY2VzPSEwLGE8Mj9XOmBvMmlfJHtlfSgke1d9KWApLEE9W107aWYoYT49Milmb3IobGV0IFc9YS0xO1c+PTA7Vy0tKUEucHVzaChgJHtGKCQsVyxhKX0gKiAoaW5kaWNlc1ske1d9XSlgKTtsZXQgaz1hPDI/XCJcIjpgXG4gIGZuIGkyb18ke2V9KGluZGljZXM6ICR7aC5pbmRpY2VzfSkgLT4gdTMyIHtcbiAgICByZXR1cm4gJHtBLmpvaW4oXCIrXCIpfTtcbiAgfWAsUD1XPT4oeS5pbmRpY2VzVG9PZmZzZXQ9ITAsYTwyP1c6YGkyb18ke2V9KCR7V30pYCksRD0oLi4uVyk9PmE9PT0wP1wiMHVcIjpgJHtoLmluZGljZXN9KCR7Vy5tYXAoXykuam9pbihcIixcIil9KWAsUj0oVyxxKT0+YTwyP2Ake1d9YDpgJHtGKFcscSxhKX1gLEc9KFcscSxoZSk9PmE8Mj9gJHtXfT0ke2hlfTtgOmAke0YoVyxxLGEpfT0ke2hlfTtgLEs9e30saj0oVyxxKT0+e3kuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQ9ITA7bGV0IGhlPWAke3EubmFtZX1icm9hZGNhc3RlZEluZGljZXNUbyR7ZX1PZmZzZXRgO2lmKGhlIGluIEspcmV0dXJuYCR7aGV9KCR7V30pYDtsZXQgR2U9W107Zm9yKGxldCB3ZT1hLTE7d2U+PTA7d2UtLSl7bGV0IHllPXEuaW5kaWNlc0dldChcIm91dHB1dEluZGljZXNcIix3ZStxLnJhbmstYSk7R2UucHVzaChgJHtSKCQsd2UpfSAqICgke3llfSAlICR7Uih4LHdlKX0pYCl9cmV0dXJuIEtbaGVdPWBmbiAke2hlfShvdXRwdXRJbmRpY2VzOiAke3EudHlwZS5pbmRpY2VzfSkgLT4gdTMyIHtcbiAgICAgICAgICAgICByZXR1cm4gJHtHZS5sZW5ndGg+MD9HZS5qb2luKFwiK1wiKTpcIjB1XCJ9O1xuICAgICAgICAgICB9YCxgJHtoZX0oJHtXfSlgfSxWPShXLHEpPT4oKCk9PntpZihoLnN0b3JhZ2U9PT1oLnZhbHVlKXJldHVybmAke2V9WyR7V31dPSR7cX07YDtpZihoLnN0b3JhZ2U9PT1cInZlYzI8dTMyPlwiJiZoLnZhbHVlPT09XCJpMzJcIilyZXR1cm5gJHtlfVske1d9XT12ZWMyPHUzMj4odTMyKCR7cX0pLCBzZWxlY3QoMHUsIDB4RkZGRkZGRkZ1LCAke3F9IDwgMCkpO2A7aWYoaC5zdG9yYWdlPT09XCJ2ZWMyPHUzMj5cIiYmaC52YWx1ZT09PVwidTMyXCIpcmV0dXJuYCR7ZX1bJHtXfV09dmVjMjx1MzI+KHUzMigke3F9KSwgMHUpO2A7aWYoaC5zdG9yYWdlPT09XCJ1MzJcIiYmaC52YWx1ZT09PVwidmVjNDxib29sPlwiKXJldHVybmAke2V9WyR7V31dPWRvdCh2ZWM0PHUzMj4oMHgxLCAweDEwMCwgMHgxMDAwMCwgMHgxMDAwMDAwKSwgdmVjNDx1MzI+KCR7cX0pKTtgO3Rocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBjb21iaW5hdGlvbiBvZiBzdG9yYWdlIHR5cGUgJHtoLnN0b3JhZ2V9IGFuZCB2YWx1ZSB0eXBlICR7aC52YWx1ZX0geWV0YCl9KSgpLFE9Vz0+KCgpPT57aWYoaC5zdG9yYWdlPT09aC52YWx1ZSlyZXR1cm5gJHtlfVske1d9XWA7aWYoaC5zdG9yYWdlPT09XCJ2ZWMyPHUzMj5cIiYmaC52YWx1ZT09PVwiaTMyXCIpcmV0dXJuYGkzMigke2V9WyR7V31dLngpYDtpZihoLnN0b3JhZ2U9PT1cInZlYzI8dTMyPlwiJiZoLnZhbHVlPT09XCJ1MzJcIilyZXR1cm5gdTMyKCR7ZX1bJHtXfV0ueClgO2lmKGguc3RvcmFnZT09PVwidTMyXCImJmgudmFsdWU9PT1cInZlYzQ8Ym9vbD5cIilyZXR1cm5gdmVjNDxib29sPihib29sKCR7ZX1bJHtXfV0gJiAweEZGdSksIGJvb2woJHtlfVske1d9XSAmIDB4RkYwMHUpLCBib29sKCR7ZX1bJHtXfV0gJiAweEZGMDAwMHUpLCBib29sKCR7ZX1bJHtXfV0gJiAweEZGMDAwMDAwdSkpYDt0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgY29tYmluYXRpb24gb2Ygc3RvcmFnZSB0eXBlICR7aC5zdG9yYWdlfSBhbmQgdmFsdWUgdHlwZSAke2gudmFsdWV9IHlldGApfSkoKSxzZT1hPDI/XCJcIjpgXG4gIGZuIGdldF8ke2V9QnlJbmRpY2VzKGluZGljZXM6ICR7aC5pbmRpY2VzfSkgLT4gJHttfSB7XG4gICAgcmV0dXJuICR7UShgaTJvXyR7ZX0oaW5kaWNlcylgKX07XG4gIH1gLFk9YTwyP1wiXCI6KCgpPT57bGV0IFc9ZC5tYXAoaGU9PmBkJHtoZX06IHUzMmApLmpvaW4oXCIsIFwiKSxxPWQubWFwKGhlPT5gZCR7aGV9YCkuam9pbihcIiwgXCIpO3JldHVybmBcbiAgZm4gZ2V0XyR7ZX0oJHtXfSkgLT4gJHttfSB7XG4gICAgcmV0dXJuIGdldF8ke2V9QnlJbmRpY2VzKCR7RChxKX0pO1xuICB9YH0pKCksZWU9KC4uLlcpPT57aWYoVy5sZW5ndGghPT1hKXRocm93IG5ldyBFcnJvcihgaW5kaWNlcyBsZW5ndGggbXVzdCBiZSAke2F9YCk7bGV0IHE9Vy5tYXAoXykuam9pbihcIixcIik7cmV0dXJuIGE9PT0wP1EoXCIwdVwiKTphPT09MT9RKHFbMF0pOih5LmdldD0hMCx5LmdldEJ5SW5kaWNlcz0hMCx5LmluZGljZXNUb09mZnNldD0hMCxgZ2V0XyR7ZX0oJHtxfSlgKX0sSj1XPT5hPDI/UShXKTooeS5nZXRCeUluZGljZXM9ITAseS5pbmRpY2VzVG9PZmZzZXQ9ITAsYGdldF8ke2V9QnlJbmRpY2VzKCR7V30pYCksbmU9YTwyP1wiXCI6YFxuICBmbiBzZXRfJHtlfUJ5SW5kaWNlcyhpbmRpY2VzOiAke2guaW5kaWNlc30sIHZhbHVlOiAke219KSB7XG4gICAgJHtWKGBpMm9fJHtlfShpbmRpY2VzKWAsXCJ2YWx1ZVwiKX1cbiAgfWAsYmU9YTwyP1wiXCI6KCgpPT57bGV0IFc9ZC5tYXAoaGU9PmBkJHtoZX06IHUzMmApLmpvaW4oXCIsIFwiKSxxPWQubWFwKGhlPT5gZCR7aGV9YCkuam9pbihcIiwgXCIpO3JldHVybmBcbiAgZm4gc2V0XyR7ZX0oJHtXfSwgdmFsdWU6ICR7bX0pIHtcbiAgICBzZXRfJHtlfUJ5SW5kaWNlcygke0QocSl9LCB2YWx1ZSk7XG4gIH1gfSkoKTtyZXR1cm57aW1wbDooKT0+e2xldCBXPVtdLHE9ITE7cmV0dXJuIHkub2Zmc2V0VG9JbmRpY2VzJiYoVy5wdXNoKFMpLHE9ITApLHkuaW5kaWNlc1RvT2Zmc2V0JiYoVy5wdXNoKGspLHE9ITApLHkuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQmJihPYmplY3QudmFsdWVzKEspLmZvckVhY2goaGU9PlcucHVzaChoZSkpLHE9ITApLHkuc2V0JiYoVy5wdXNoKGJlKSxxPSEwKSx5LnNldEJ5SW5kaWNlcyYmKFcucHVzaChuZSkscT0hMCkseS5nZXQmJihXLnB1c2goWSkscT0hMCkseS5nZXRCeUluZGljZXMmJihXLnB1c2goc2UpLHE9ITApLCFpJiZxJiZXLnVuc2hpZnQoYGNvbnN0ICR7eH0gPSAke2guaW5kaWNlc30oJHtyLmpvaW4oXCIsXCIpfSk7YCxgY29uc3QgJHskfSA9ICR7aC5pbmRpY2VzfSgke0MuY29tcHV0ZVN0cmlkZXMocikuam9pbihcIixcIil9KTtgKSxXLmpvaW4oYFxuYCl9LHR5cGU6aCxvZmZzZXRUb0luZGljZXM6VCxpbmRpY2VzVG9PZmZzZXQ6UCxicm9hZGNhc3RlZEluZGljZXNUb09mZnNldDpqLGluZGljZXM6RCxpbmRpY2VzR2V0OlIsaW5kaWNlc1NldDpHLHNldDooLi4uVyk9PntpZihXLmxlbmd0aCE9PWErMSl0aHJvdyBuZXcgRXJyb3IoYGluZGljZXMgbGVuZ3RoIG11c3QgYmUgJHthfWApO2xldCBxPVdbYV07aWYodHlwZW9mIHEhPVwic3RyaW5nXCIpdGhyb3cgbmV3IEVycm9yKFwidmFsdWUgbXVzdCBiZSBzdHJpbmdcIik7bGV0IGhlPVcuc2xpY2UoMCxhKS5tYXAoXykuam9pbihcIixcIik7cmV0dXJuIGE9PT0wP1YoXCIwdVwiLHEpOmE9PT0xP1YoaGVbMF0scSk6KHkuc2V0PSEwLHkuc2V0QnlJbmRpY2VzPSEwLHkuaW5kaWNlc1RvT2Zmc2V0PSEwLGBzZXRfJHtlfSgke2hlfSwgJHtxfSlgKX0sc2V0QnlPZmZzZXQ6VixzZXRCeUluZGljZXM6KFcscSk9PmE8Mj9WKFcscSk6KHkuc2V0QnlJbmRpY2VzPSEwLHkuaW5kaWNlc1RvT2Zmc2V0PSEwLGBzZXRfJHtlfUJ5SW5kaWNlcygke1d9LCAke3F9KTtgKSxnZXQ6ZWUsZ2V0QnlPZmZzZXQ6USxnZXRCeUluZGljZXM6Six1c2FnZTpuLG5hbWU6ZSxzdHJpZGVzOiQsc2hhcGU6eCxyYW5rOmF9fSxFPShlLHQscixuPTEpPT5XcihlLHQscixcImlucHV0XCIsbiksTT0oZSx0LHIsbj0xKT0+V3IoZSx0LHIsXCJvdXRwdXRcIixuKSxycz0oZSx0LHIpPT5XcihlLHQscixcImF0b21pY091dHB1dFwiLDEpLExyPShlLHQscixuPTEpPT5XcihlLHQscixcImludGVybmFsXCIsbiksYW89Y2xhc3N7Y29uc3RydWN0b3IodCxyKXt0aGlzLm5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwPXQ7dGhpcy5saW1pdHM9cjt0aGlzLmludGVybmFsVmFyaWFibGVzPVtdO3RoaXMudmFyaWFibGVzPVtdO3RoaXMudW5pZm9ybXM9W107dGhpcy52YXJpYWJsZUluZGV4PTB9Z3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyh0KXtyZXR1cm5gaWYgKGdsb2JhbF9pZHggPj0gJHt0eXBlb2YgdD09XCJudW1iZXJcIj9gJHt0fXVgOnR9KSB7IHJldHVybjsgfWB9bWFpblN0YXJ0KHQ9a3Qpe2xldCByPXR5cGVvZiB0PT1cIm51bWJlclwiP3Q6dFswXSxuPXR5cGVvZiB0PT1cIm51bWJlclwiPzE6dFsxXSxvPXR5cGVvZiB0PT1cIm51bWJlclwiPzE6dFsyXTtpZihyPnRoaXMubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWHx8bj50aGlzLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVl8fG8+dGhpcy5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVaKXRocm93IG5ldyBFcnJvcihgd29ya2dyb3VwIHNpemUgWyR7cn0sICR7bn0sICR7b31dIGV4Y2VlZHMgdGhlIG1heGltdW0gd29ya2dyb3VwIHNpemUgWyR7dGhpcy5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVYfSwgJHt0aGlzLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVl9LCAke3RoaXMubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWn1dLmApO2lmKHIqbipvPnRoaXMubGltaXRzLm1heENvbXB1dGVJbnZvY2F0aW9uc1Blcldvcmtncm91cCl0aHJvdyBuZXcgRXJyb3IoYHdvcmtncm91cCBzaXplIFske3J9LCAke259LCAke299XSBleGNlZWRzIHRoZSBtYXhpbXVtIHdvcmtncm91cCBpbnZvY2F0aW9ucyAke3RoaXMubGltaXRzLm1heENvbXB1dGVJbnZvY2F0aW9uc1Blcldvcmtncm91cH0uYCk7bGV0IGk9dGhpcy5ub3JtYWxpemVkRGlzcGF0Y2hHcm91cFsxXT09PTEmJnRoaXMubm9ybWFsaXplZERpc3BhdGNoR3JvdXBbMl09PT0xLGE9aT9gQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIGdsb2JhbF9pZCA6IHZlYzM8dTMyPixcbiAgICBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cF9pZCA6IHZlYzM8dTMyPixcbiAgICBAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2luZGV4KSBsb2NhbF9pZHggOiB1MzIsXG4gICAgQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pZCkgbG9jYWxfaWQgOiB2ZWMzPHUzMj5gOmBAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsX2lkIDogdmVjMzx1MzI+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pZCkgbG9jYWxfaWQgOiB2ZWMzPHUzMj4sXG4gICAgQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pbmRleCkgbG9jYWxfaWR4IDogdTMyLFxuICAgIEBidWlsdGluKHdvcmtncm91cF9pZCkgd29ya2dyb3VwX2lkIDogdmVjMzx1MzI+LFxuICAgIEBidWlsdGluKG51bV93b3JrZ3JvdXBzKSBudW1fd29ya2dyb3VwcyA6IHZlYzM8dTMyPmAsZD1pP2BsZXQgZ2xvYmFsX2lkeCA9IGdsb2JhbF9pZC54O1xuICAgICAgICAgbGV0IHdvcmtncm91cF9pbmRleCA9IHdvcmtncm91cF9pZC54O2A6YGxldCB3b3JrZ3JvdXBfaW5kZXggPSB3b3JrZ3JvdXBfaWQueiAqIG51bV93b3JrZ3JvdXBzWzBdICogbnVtX3dvcmtncm91cHNbMV0gK1xuICAgICAgICAgICAgIHdvcmtncm91cF9pZC55ICogbnVtX3dvcmtncm91cHNbMF0gKyB3b3JrZ3JvdXBfaWQueDtcbiAgICAgICAgIGxldCBnbG9iYWxfaWR4ID0gd29ya2dyb3VwX2luZGV4ICogJHtyKm4qb311ICsgbG9jYWxfaWR4O2A7cmV0dXJuYEBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSgke3J9LCAke259LCAke299KVxuICBmbiBtYWluKCR7YX0pIHtcbiAgICAke2R9XG4gIGB9YXBwZW5kVmFyaWFibGVVbmlmb3Jtcyh0KXt0LnJhbmshPT0wJiYodC5zaGFwZS5zdGFydHNXaXRoKFwidW5pZm9ybXMuXCIpJiZ0aGlzLnVuaWZvcm1zLnB1c2goe25hbWU6dC5zaGFwZS5yZXBsYWNlKFwidW5pZm9ybXMuXCIsXCJcIiksdHlwZTpcInUzMlwiLGxlbmd0aDp0LnJhbmt9KSx0LnN0cmlkZXMuc3RhcnRzV2l0aChcInVuaWZvcm1zLlwiKSYmdGhpcy51bmlmb3Jtcy5wdXNoKHtuYW1lOnQuc3RyaWRlcy5yZXBsYWNlKFwidW5pZm9ybXMuXCIsXCJcIiksdHlwZTpcInUzMlwiLGxlbmd0aDp0LnJhbmt9KSl9ZGVjbGFyZVZhcmlhYmxlKHQscil7aWYodC51c2FnZT09PVwiaW50ZXJuYWxcIil0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgdXNlIGludGVybmFsIHZhcmlhYmxlIHdpdGggZGVjbGFyZVZhcmlhYmxlKCkuIHVzZSByZWdpc3RlckludGVybmFsVmFyaWFibGVzKCkgaW5zdGVhZC5cIik7dGhpcy52YXJpYWJsZXMucHVzaCh0KSx0aGlzLmFwcGVuZFZhcmlhYmxlVW5pZm9ybXModCk7bGV0IG49dC51c2FnZT09PVwiaW5wdXRcIj9cInJlYWRcIjpcInJlYWRfd3JpdGVcIixvPXQudXNhZ2U9PT1cImF0b21pY091dHB1dFwiP1wiYXRvbWljPGkzMj5cIjp0LnR5cGUuc3RvcmFnZTtyZXR1cm5gQGdyb3VwKDApIEBiaW5kaW5nKCR7cn0pIHZhcjxzdG9yYWdlLCAke259PiAke3QubmFtZX06IGFycmF5PCR7b30+O2B9ZGVjbGFyZVZhcmlhYmxlcyguLi50KXtyZXR1cm4gdC5tYXAocj0+dGhpcy5kZWNsYXJlVmFyaWFibGUocix0aGlzLnZhcmlhYmxlSW5kZXgrKykpLmpvaW4oYFxuYCl9cmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlKHQpe2lmKHQudXNhZ2UhPT1cImludGVybmFsXCIpdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IHVzZSBpbnB1dCBvciBvdXRwdXQgdmFyaWFibGUgd2l0aCByZWdpc3RlckludGVybmFsVmFyaWFibGUoKS4gdXNlIGRlY2xhcmVWYXJpYWJsZXMoKSBpbnN0ZWFkLlwiKTt0aGlzLmludGVybmFsVmFyaWFibGVzLnB1c2godCksdGhpcy5hcHBlbmRWYXJpYWJsZVVuaWZvcm1zKHQpfXJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZXMoLi4udCl7cmV0dXJuIHQuZm9yRWFjaChyPT50aGlzLnJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZShyKSksdGhpc31yZWdpc3RlclVuaWZvcm0odCxyLG49MSl7cmV0dXJuIHRoaXMudW5pZm9ybXMucHVzaCh7bmFtZTp0LHR5cGU6cixsZW5ndGg6bn0pLHRoaXN9cmVnaXN0ZXJVbmlmb3Jtcyh0KXtyZXR1cm4gdGhpcy51bmlmb3Jtcz10aGlzLnVuaWZvcm1zLmNvbmNhdCh0KSx0aGlzfXVuaWZvcm1EZWNsYXJhdGlvbigpe2lmKHRoaXMudW5pZm9ybXMubGVuZ3RoPT09MClyZXR1cm5cIlwiO2xldCB0PVtdO2ZvcihsZXR7bmFtZTpyLHR5cGU6bixsZW5ndGg6b31vZiB0aGlzLnVuaWZvcm1zKWlmKG8mJm8+NCluPT09XCJmMTZcIj90LnB1c2goYEBhbGlnbigxNikgJHtyfTphcnJheTxtYXQyeDQ8JHtufT4sICR7TWF0aC5jZWlsKG8vOCl9PmApOnQucHVzaChgJHtyfTphcnJheTx2ZWM0PCR7bn0+LCAke01hdGguY2VpbChvLzQpfT5gKTtlbHNle2xldCBpPW89PW51bGx8fG89PT0xP246YHZlYyR7b308JHtufT5gO3QucHVzaChgJHtyfToke2l9YCl9cmV0dXJuYFxuICAgICAgc3RydWN0IFVuaWZvcm1zIHsgJHt0LmpvaW4oXCIsIFwiKX0gfTtcbiAgICAgIEBncm91cCgwKSBAYmluZGluZygke3RoaXMudmFyaWFibGVJbmRleH0pIHZhcjx1bmlmb3JtPiB1bmlmb3JtczogVW5pZm9ybXM7YH1nZXQgYWRkaXRpb25hbEltcGxlbWVudGF0aW9ucygpe3JldHVybiB0aGlzLnVuaWZvcm1EZWNsYXJhdGlvbigpK3RoaXMudmFyaWFibGVzLm1hcCh0PT50LmltcGwoKSkuam9pbihgXG5gKSt0aGlzLmludGVybmFsVmFyaWFibGVzLm1hcCh0PT50LmltcGwoKSkuam9pbihgXG5gKX1nZXQgdmFyaWFibGVzSW5mbygpe2lmKHRoaXMudW5pZm9ybXMubGVuZ3RoPT09MClyZXR1cm47bGV0IHQ9cj0+WzEyLDEwLDEsNl1bW1widTMyXCIsXCJmMTZcIixcImYzMlwiLFwiaTMyXCJdLmluZGV4T2YocildO3JldHVybiB0aGlzLnVuaWZvcm1zLm1hcChyPT5bdChyLnR5cGUpLHIubGVuZ3RoPz8xXSl9fSxucz0oZSx0KT0+bmV3IGFvKGUsdCl9KTt2YXIgZG0sb3MsbG0sY20scG0sbW0sUGUsaXMsYXMsZHQ9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTtTZSgpO2FlKCk7ZG09KGUsdCk9PntpZighZXx8ZS5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIlRyYW5zcG9zZSByZXF1aXJlcyAxIGlucHV0LlwiKTtpZih0Lmxlbmd0aCE9PTAmJnQubGVuZ3RoIT09ZVswXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYHBlcm0gc2l6ZSAke3QubGVuZ3RofSBkb2VzIG5vdCBtYXRjaCBpbnB1dCByYW5rICR7ZVswXS5kaW1zLmxlbmd0aH1gKX0sb3M9KGUsdCk9PnQubGVuZ3RoIT09MD90OlsuLi5uZXcgQXJyYXkoZSkua2V5cygpXS5yZXZlcnNlKCksbG09KGUsdCk9PkMuc29ydEJhc2VkT25QZXJtKGUsb3MoZS5sZW5ndGgsdCkpLGNtPShlLHQscixuKT0+e2xldCBvPWBmbiBwZXJtKGk6ICR7bi50eXBlLmluZGljZXN9KSAtPiAke3IudHlwZS5pbmRpY2VzfSB7XG4gICAgdmFyIGE6ICR7ci50eXBlLmluZGljZXN9O2A7Zm9yKGxldCBpPTA7aTx0OysraSlvKz1gYVske2VbaV19XT1pWyR7aX1dO2A7cmV0dXJuIG8rPVwicmV0dXJuIGE7fVwifSxwbT0oZSx0KT0+e2xldCByPVtdLG49W107Zm9yKGxldCBvPTA7bzxlLmxlbmd0aDsrK28pZVtvXSE9PTEmJnIucHVzaChlW29dKSxlW3Rbb11dIT09MSYmbi5wdXNoKHRbb10pO3JldHVybntuZXdTaGFwZTpyLG5ld1Blcm06bn19LG1tPShlLHQpPT57bGV0IHI9MDtmb3IobGV0IG49MDtuPGUubGVuZ3RoOysrbilpZih0W2Vbbl1dIT09MSl7aWYoZVtuXTxyKXJldHVybiExO3I9ZVtuXX1yZXR1cm4hMH0sUGU9KGUsdCk9PntsZXQgcj1lLmRhdGFUeXBlLG49ZS5kaW1zLmxlbmd0aCxvPW9zKG4sdCksaT1sbShlLmRpbXMsbyksYT1lLmRpbXMsZD1pLGw9bjwyfHxtbShvLGUuZGltcykscDtpZihsKXJldHVybiBwPWc9PntsZXQgeD1FKFwiaW5wdXRcIixyLGEsNCksJD1NKFwib3V0cHV0XCIscixkLDQpO3JldHVybmBcbiAgJHtnLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dF9zaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyh4LCQpfVxuICAke2cubWFpblN0YXJ0KCl9XG4gICAgJHtnLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSBpbnB1dFtnbG9iYWxfaWR4XTtcbiAgfWB9LHtuYW1lOlwiVHJhbnNwb3NlQ29weVwiLHNoYWRlckNhY2hlOntpbnB1dERlcGVuZGVuY2llczpbXCJ0eXBlXCJdfSxnZXRSdW5EYXRhOigpPT57bGV0IGc9Qy5zaXplKGkpO3JldHVybntvdXRwdXRzOlt7ZGltczppLGRhdGFUeXBlOmUuZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChnLzY0LzQpfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjEyLGRhdGE6TWF0aC5jZWlsKGcvNCl9XX19LGdldFNoYWRlclNvdXJjZTpwfTtsZXR7bmV3U2hhcGU6bSxuZXdQZXJtOnV9PXBtKGUuZGltcyxvKSxoPUMuYXJlRXF1YWwodSxbMiwzLDFdKSxfPUMuYXJlRXF1YWwodSxbMywxLDJdKTtpZihtLmxlbmd0aD09PTJ8fGh8fF8pe2E9aD9bbVswXSxtWzFdKm1bMl1dOl8/W21bMF0qbVsxXSxtWzJdXTptLGQ9W2FbMV0sYVswXV07bGV0IGc9MTY7cmV0dXJuIHA9eD0+e2xldCAkPUUoXCJhXCIscixhLmxlbmd0aCksdj1NKFwib3V0cHV0XCIscixkLmxlbmd0aCk7cmV0dXJuYFxuICAke3gucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0X3NpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKCQsdil9XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGUgOiBhcnJheTxhcnJheTwke3YudHlwZS52YWx1ZX0sICR7ZysxfT4sICR7Z30+O1xuICAke3gubWFpblN0YXJ0KFtnLGcsMV0pfVxuICAgIGxldCBzdHJpZGUgPSAodW5pZm9ybXMub3V0cHV0X3NoYXBlWzFdIC0gMSkgLyAke2d9ICsgMTtcbiAgICBsZXQgd29ya2dyb3VwX2lkX3ggPSB3b3JrZ3JvdXBfaW5kZXggJSBzdHJpZGU7XG4gICAgbGV0IHdvcmtncm91cF9pZF95ID0gd29ya2dyb3VwX2luZGV4IC8gc3RyaWRlO1xuICAgIGxldCBpbnB1dF9jb2wgPSB3b3JrZ3JvdXBfaWRfeSAqICR7Z311ICsgbG9jYWxfaWQueDtcbiAgICBsZXQgaW5wdXRfcm93ID0gd29ya2dyb3VwX2lkX3ggKiAke2d9dSArIGxvY2FsX2lkLnk7XG4gICAgaWYgKGlucHV0X3JvdyA8IHVuaWZvcm1zLmFfc2hhcGVbMF0gJiYgaW5wdXRfY29sIDwgdW5pZm9ybXMuYV9zaGFwZVsxXSkge1xuICAgICAgdGlsZVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9ICR7JC5nZXRCeUluZGljZXMoYCR7JC50eXBlLmluZGljZXN9KGlucHV0X3JvdywgaW5wdXRfY29sKWApfTtcbiAgICB9XG4gICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgbGV0IG91dHB1dF9jb2wgPSB3b3JrZ3JvdXBfaWRfeCAqICR7Z311ICsgbG9jYWxfaWQueDtcbiAgICBsZXQgb3V0cHV0X3JvdyA9IHdvcmtncm91cF9pZF95ICogJHtnfXUgKyBsb2NhbF9pZC55O1xuICAgIGlmIChvdXRwdXRfcm93IDwgdW5pZm9ybXMub3V0cHV0X3NoYXBlWzBdICYmIG91dHB1dF9jb2wgPCB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMV0pIHtcbiAgICAgICR7di5zZXRCeUluZGljZXMoYCR7di50eXBlLmluZGljZXN9KG91dHB1dF9yb3csIG91dHB1dF9jb2wpYCxcInRpbGVbbG9jYWxfaWQueF1bbG9jYWxfaWQueV1cIil9XG4gICAgfVxuICB9YH0se25hbWU6XCJUcmFuc3Bvc2VTaGFyZWRcIixzaGFkZXJDYWNoZTp7aW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiXX0sZ2V0UnVuRGF0YTooKT0+e2xldCB4PUMuc2l6ZShpKTtyZXR1cm57b3V0cHV0czpbe2RpbXM6aSxkYXRhVHlwZTplLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoZFsxXS9nKSx5Ok1hdGguY2VpbChkWzBdL2cpfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjEyLGRhdGE6eH0sLi4uTihhLGQpXX19LGdldFNoYWRlclNvdXJjZTpwfX1yZXR1cm4gcD1nPT57bGV0IHg9RShcImFcIixyLGEubGVuZ3RoKSwkPU0oXCJvdXRwdXRcIixyLGQubGVuZ3RoKTtyZXR1cm5gXG4gICR7Zy5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoeCwkKX1cblxuICAke2NtKG8sbix4LCQpfVxuXG4gICR7Zy5tYWluU3RhcnQoKX1cbiAgICAke2cuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuXG4gICAgbGV0IGluZGljZXMgPSAkeyQub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgbGV0IGFJbmRpY2VzID0gcGVybShpbmRpY2VzKTtcblxuICAgICR7JC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIix4LmdldEJ5SW5kaWNlcyhcImFJbmRpY2VzXCIpKX1cbiAgfWB9LHtuYW1lOlwiVHJhbnNwb3NlXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dH1gLGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LGdldFJ1bkRhdGE6KCk9PntsZXQgZz1DLnNpemUoaSk7cmV0dXJue291dHB1dHM6W3tkaW1zOmksZGF0YVR5cGU6ZS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGcvNjQpfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjEyLGRhdGE6Z30sLi4uTihhLGQpXX19LGdldFNoYWRlclNvdXJjZTpwfX0saXM9KGUsdCk9PntkbShlLmlucHV0cyx0LnBlcm0pLGUuY29tcHV0ZShQZShlLmlucHV0c1swXSx0LnBlcm0pKX0sYXM9ZT0+cmUoe3Blcm06ZS5wZXJtfSl9KTt2YXIgZm0saG0sZ20sYm0seW0sX20sd20sdm0sJG0seG0scnQsc3MsdXMsZHMsbHMsY3MscHMsbXMsZnMsaHMsZ3MsYnM9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTthZSgpO0dyKCk7ZHQoKTtmbT17bWF4Olwic2VsZWN0KGJlc3RWYWx1ZSwgY2FuZGlkYXRlLCBjYW5kaWRhdGUgPiBiZXN0VmFsdWUpXCIsbWluOlwic2VsZWN0KGJlc3RWYWx1ZSwgY2FuZGlkYXRlLCBjYW5kaWRhdGUgPCBiZXN0VmFsdWUpXCIsbWVhbjpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLHN1bTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLHByb2Q6XCJiZXN0VmFsdWUgKiBjYW5kaWRhdGVcIixzdW1TcXVhcmU6XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGUgKiBjYW5kaWRhdGVcIixsb2dTdW1FeHA6XCJiZXN0VmFsdWUgKyBleHAoY2FuZGlkYXRlKVwiLGwxOlwiYmVzdFZhbHVlICsgYWJzKGNhbmRpZGF0ZSlcIixsMjpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZSAqIGNhbmRpZGF0ZVwiLGxvZ1N1bTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwifSxobT17bWF4Olwic2VsZWN0KGJlc3RWYWx1ZSwgY2FuZGlkYXRlLCBjYW5kaWRhdGUgPiBiZXN0VmFsdWUpXCIsbWluOlwic2VsZWN0KGJlc3RWYWx1ZSwgY2FuZGlkYXRlLCBjYW5kaWRhdGUgPCBiZXN0VmFsdWUpXCIsbWVhbjpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLHN1bTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLHByb2Q6XCJiZXN0VmFsdWUgKiBjYW5kaWRhdGVcIixzdW1TcXVhcmU6XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixsb2dTdW1FeHA6XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixsMTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLGwyOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCIsbG9nU3VtOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCJ9LGdtPXttYXg6XCJfQVtvZmZzZXRdXCIsbWluOlwiX0Fbb2Zmc2V0XVwiLG1lYW46XCIwXCIsc3VtOlwiMFwiLHByb2Q6XCIxXCIsc3VtU3F1YXJlOlwiMFwiLGxvZ1N1bUV4cDpcIjBcIixsMTpcIjBcIixsMjpcIjBcIixsb2dTdW06XCIwXCJ9LGJtPXttYXg6XCJiZXN0VmFsdWVcIixtaW46XCJiZXN0VmFsdWVcIixzdW06XCJiZXN0VmFsdWVcIixwcm9kOlwiYmVzdFZhbHVlXCIsc3VtU3F1YXJlOlwiYmVzdFZhbHVlXCIsbG9nU3VtRXhwOlwibG9nKGJlc3RWYWx1ZSlcIixsMTpcImJlc3RWYWx1ZVwiLGwyOlwic3FydChiZXN0VmFsdWUpXCIsbG9nU3VtOlwibG9nKGJlc3RWYWx1ZSlcIn0seW09KGUsdCk9PntsZXQgcj1bXTtmb3IobGV0IG49dC1lO248dDsrK24pci5wdXNoKG4pO3JldHVybiByfSxfbT0oZSx0KT0+e2xldCByPVtdLG49ZS5sZW5ndGg7Zm9yKGxldCBpPTA7aTxuO2krKyl0LmluZGV4T2YoaSk9PT0tMSYmci5wdXNoKGVbaV0pO2xldCBvPXQubWFwKGk9PmVbaV0pO3JldHVybltyLG9dfSx3bT0oZSx0KT0+e2xldCByPWUubGVuZ3RoK3QubGVuZ3RoLG49W10sbz0wO2ZvcihsZXQgaT0wO2k8cjtpKyspdC5pbmRleE9mKGkpPT09LTE/bi5wdXNoKGVbbysrXSk6bi5wdXNoKDEpO3JldHVybiBufSx2bT0oZSx0KT0+e2ZvcihsZXQgcj0wO3I8ZS5sZW5ndGg7KytyKWlmKGVbZS5sZW5ndGgtci0xXSE9PXQtMS1yKXJldHVybiExO3JldHVybiEwfSwkbT0oZSx0KT0+e2xldCByPVtdO2lmKCF2bShlLHQpKXtmb3IobGV0IG49MDtuPHQ7KytuKWUuaW5kZXhPZihuKT09PS0xJiZyLnB1c2gobik7ZS5mb3JFYWNoKG49PnIucHVzaChuKSl9cmV0dXJuIHJ9LHhtPShlLHQscixuLG8saSxhKT0+e2xldCBkPXJbMF0uZGltcyxsPUMuc2l6ZShpKSxwPUMuc2l6ZShhKSxtPUUoXCJfQVwiLHJbMF0uZGF0YVR5cGUsZCksdT1NKFwib3V0cHV0XCIsbyxpKSxoPTY0O2w9PT0xJiYoaD0yNTYpO2xldCBfPWBcbiAgICAgICAgICB2YXI8d29ya2dyb3VwPiBhQmVzdFZhbHVlcyA6IGFycmF5PGYzMiwgJHtofT47XG4gICAgICAgYCx5PWc9PmBcbiAgICAgICAgJHtnLnJlZ2lzdGVyVW5pZm9ybShcInJlZHVjZVNpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKG0sdSl9XG4gICAgICAgICR7X31cbiAgICAgICAgZm4gRElWX0NFSUwoYSA6IHUzMiwgYiA6IHUzMikgLT4gdTMyIHtcbiAgICAgICAgICByZXR1cm4gKChhIC0gMXUpIC8gYiArIDF1KTtcbiAgICAgICAgIH1cbiAgICAgICAgICR7Zy5tYWluU3RhcnQoaCl9XG5cbiAgICAgICAgICBsZXQgb3V0cHV0SW5kZXggPSBnbG9iYWxfaWR4IC8gJHtofTtcbiAgICAgICAgICBsZXQgb2Zmc2V0ID0gb3V0cHV0SW5kZXggKiB1bmlmb3Jtcy5yZWR1Y2VTaXplO1xuXG4gICAgICAgICAgdmFyIGJlc3RWYWx1ZSA9IGYzMigke2dtW25dfSk7XG4gICAgICAgICAgbGV0IExlbmd0aCA9IHVuaWZvcm1zLnJlZHVjZVNpemU7XG4gICAgICAgICAgZm9yICh2YXIgayA9IGxvY2FsX2lkeDsgayA8IExlbmd0aDsgayA9IGsgKyAke2h9KSB7XG4gICAgICAgICAgIGxldCBjYW5kaWRhdGUgPSBmMzIoJHttLmdldEJ5T2Zmc2V0KFwib2Zmc2V0ICsga1wiKX0pO1xuICAgICAgICAgICBiZXN0VmFsdWUgPSAke2ZtW25dfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYUJlc3RWYWx1ZXNbbG9jYWxfaWR4XSA9IGJlc3RWYWx1ZTtcbiAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgIHZhciByZWR1Y2VTaXplID0gbWluKExlbmd0aCwgJHtofXUpO1xuICAgICAgICAgZm9yICh2YXIgY3VycmVudFNpemUgPSByZWR1Y2VTaXplIC8gMnU7IHJlZHVjZVNpemUgPiAxdTtcbiAgICAgICAgICAgICBjdXJyZW50U2l6ZSA9IHJlZHVjZVNpemUgLyAydSkge1xuICAgICAgICAgICBsZXQgaW50ZXJ2YWwgPSBESVZfQ0VJTChyZWR1Y2VTaXplLCAydSk7XG4gICAgICAgICAgIGlmIChsb2NhbF9pZHggPCBjdXJyZW50U2l6ZSkge1xuICAgICAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IGFCZXN0VmFsdWVzW2xvY2FsX2lkeCArIGludGVydmFsXTtcbiAgICAgICAgICAgIGJlc3RWYWx1ZSA9ICR7aG1bbl19O1xuICAgICAgICAgICAgYUJlc3RWYWx1ZXNbbG9jYWxfaWR4XSA9IGJlc3RWYWx1ZTtcbiAgICAgICAgICAgfVxuICAgICAgICAgICByZWR1Y2VTaXplID0gaW50ZXJ2YWw7XG4gICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgaWYgKGxvY2FsX2lkeCA9PSAwdSkge1xuICAgICAgICAgICR7dS5zZXRCeU9mZnNldChcIm91dHB1dEluZGV4XCIsYCR7bj09PVwibWVhblwiP2Ake3UudHlwZS5zdG9yYWdlfShiZXN0VmFsdWUgLyBmMzIodW5pZm9ybXMucmVkdWNlU2l6ZSkpYDpgJHt1LnR5cGUuc3RvcmFnZX0oJHtibVtuXX0pYH1gKX07XG4gICAgICAgICB9XG4gICAgICAgIH1gO3JldHVybntuYW1lOmUsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dH07JHtofWAsaW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiXX0sZ2V0U2hhZGVyU291cmNlOnksZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczppLGRhdGFUeXBlOm99XSxkaXNwYXRjaEdyb3VwOnt4Omx9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTpwfV19KX19LHJ0PShlLHQscixuKT0+e2xldCBvPWUuaW5wdXRzLmxlbmd0aD09PTE/cjpsbyhlLmlucHV0cyxyKSxpPW8uYXhlcztpLmxlbmd0aD09PTAmJiFvLm5vb3BXaXRoRW1wdHlBeGVzJiYoaT1lLmlucHV0c1swXS5kaW1zLm1hcCgoXyx5KT0+eSkpO2xldCBhPUMubm9ybWFsaXplQXhlcyhpLGUuaW5wdXRzWzBdLmRpbXMubGVuZ3RoKSxkPWEsbD1lLmlucHV0c1swXSxwPSRtKGQsZS5pbnB1dHNbMF0uZGltcy5sZW5ndGgpO3AubGVuZ3RoPjAmJihsPWUuY29tcHV0ZShQZShlLmlucHV0c1swXSxwKSx7aW5wdXRzOlswXSxvdXRwdXRzOlstMV19KVswXSxkPXltKGQubGVuZ3RoLGwuZGltcy5sZW5ndGgpKTtsZXRbbSx1XT1fbShsLmRpbXMsZCksaD1tO28ua2VlcERpbXMmJihoPXdtKG0sYSkpLGUuY29tcHV0ZSh4bSh0LG8uY2FjaGVLZXksW2xdLG4sZS5pbnB1dHNbMF0uZGF0YVR5cGUsaCx1KSx7aW5wdXRzOltsXX0pfSxzcz0oZSx0KT0+e3J0KGUsXCJSZWR1Y2VNZWFuU2hhcmVkXCIsdCxcIm1lYW5cIil9LHVzPShlLHQpPT57cnQoZSxcIlJlZHVjZUwxU2hhcmVkXCIsdCxcImwxXCIpfSxkcz0oZSx0KT0+e3J0KGUsXCJSZWR1Y2VMMlNoYXJlZFwiLHQsXCJsMlwiKX0sbHM9KGUsdCk9PntydChlLFwiUmVkdWNlTG9nU3VtRXhwU2hhcmVkXCIsdCxcImxvZ1N1bUV4cFwiKX0sY3M9KGUsdCk9PntydChlLFwiUmVkdWNlTWF4U2hhcmVkXCIsdCxcIm1heFwiKX0scHM9KGUsdCk9PntydChlLFwiUmVkdWNlTWluU2hhcmVkXCIsdCxcIm1pblwiKX0sbXM9KGUsdCk9PntydChlLFwiUmVkdWNlUHJvZFNoYXJlZFwiLHQsXCJwcm9kXCIpfSxmcz0oZSx0KT0+e3J0KGUsXCJSZWR1Y2VTdW1TaGFyZWRcIix0LFwic3VtXCIpfSxocz0oZSx0KT0+e3J0KGUsXCJSZWR1Y2VTdW1TcXVhcmVTaGFyZWRcIix0LFwic3VtU3F1YXJlXCIpfSxncz0oZSx0KT0+e3J0KGUsXCJSZWR1Y2VMb2dTdW1TaGFyZWRcIix0LFwibG9nU3VtXCIpfX0pO3ZhciBudCxTbSxIcixsbyxvdCxUbSxJbSxDbSxBbSxrbSxFbSxQbSx6bSxPbSxEbSxpdCx5cyxfcyx3cyx2cywkcyx4cyxTcyxUcyxJcyxDcyxHcj1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtvZSgpO1NlKCk7YWUoKTticygpO250PWU9PntpZighZXx8ZS5sZW5ndGg9PT0wfHxlLmxlbmd0aD4yKXRocm93IG5ldyBFcnJvcihcIlJlZHVjZSBvcCByZXF1aXJlcyAxIG9yIDIgaW5wdXRzLlwiKTtpZihlLmxlbmd0aD09PTImJmVbMV0uZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXhlcyBpbnB1dCBkaW1zLlwiKX0sU209ZT0+W1wiXCIsXCJcIixgdmFyIHZhbHVlID0gJHtlLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O2AsXCJcIl0sSHI9KGUsdCxyLG4sbyxpLGE9ITEsZD0hMSk9PntsZXQgbD1bXSxwPXJbMF0uZGltcyxtPXAubGVuZ3RoLHU9Qy5ub3JtYWxpemVBeGVzKG8sbSksaD0hZCYmdS5sZW5ndGg9PT0wO3AuZm9yRWFjaCgoeCwkKT0+e2h8fHUuaW5kZXhPZigkKT49MD9hJiZsLnB1c2goMSk6bC5wdXNoKHgpfSk7bGV0IF89bC5sZW5ndGgseT1DLnNpemUobCk7cmV0dXJue25hbWU6ZSxzaGFkZXJDYWNoZTp0LGdldFNoYWRlclNvdXJjZTp4PT57bGV0ICQ9W10sdj1FKFwiX0FcIixyWzBdLmRhdGFUeXBlLG0pLFM9TShcIm91dHB1dFwiLGksXyksVD1uKHYsUyx1KSxBPVRbMl07Zm9yKGxldCBrPTAsUD0wO2s8bTtrKyspaHx8dS5pbmRleE9mKGspPj0wPyhhJiZQKyssQT1gZm9yKHZhciBqJHtrfTogdTMyID0gMDsgaiR7a30gPCAke3Bba119OyBqJHtrfSsrKSB7XG4gICAgICAgICAgICAgICAgICAke1RbMl0uaW5jbHVkZXMoXCJsYXN0X2luZGV4XCIpP2BsZXQgbGFzdF9pbmRleCA9IGoke2t9O2A6XCJcIn1cbiAgICAgICAgICAgICAgICAgICR7di5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLGssYGoke2t9YCl9XG4gICAgICAgICAgICAgICAgICAke0F9XG4gICAgICAgICAgICAgICAgfWApOigkLnB1c2goYCR7di5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLGssUy5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixQKSl9O2ApLFArKyk7cmV0dXJuYFxuXG4gICAgICAgICR7eC5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXModixTKX1cblxuICAgICAgICAke3gubWFpblN0YXJ0KCl9XG4gICAgICAgICAgJHt4Lmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICAgICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHt2LnR5cGUuaW5kaWNlc307XG4gICAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHtTLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuXG4gICAgICAgICAgJHskLmpvaW4oYFxuYCl9XG4gICAgICAgICAgJHtUWzBdfSAgICAgICAvLyBpbml0IG9wcyBmb3IgcmVkdWNlIG1heC9taW5cbiAgICAgICAgICAke1RbMV19XG4gICAgICAgICAgJHtBfVxuICAgICAgICAgICR7VFszXX1cbiAgICAgICAgICAke1QubGVuZ3RoPT09ND9TLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIik6VC5zbGljZSg0KS5qb2luKGBcbmApfVxuICAgICAgICB9YH0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpsLGRhdGFUeXBlOml9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbCh5LzY0KX0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZToxMixkYXRhOnl9LC4uLk4ocCxsKV19KX19LGxvPShlLHQpPT57bGV0IHI9W107cmV0dXJuIGVbMV0uZGltc1swXT4wJiZlWzFdLmdldEJpZ0ludDY0QXJyYXkoKS5mb3JFYWNoKG49PnIucHVzaChOdW1iZXIobikpKSxyZSh7YXhlczpyLGtlZXBEaW1zOnQua2VlcERpbXMsbm9vcFdpdGhFbXB0eUF4ZXM6dC5ub29wV2l0aEVtcHR5QXhlc30pfSxvdD0oZSx0LHIsbik9PntsZXQgbz1lLmlucHV0cyxpPW8ubGVuZ3RoPT09MT9yOmxvKG8scik7ZS5jb21wdXRlKEhyKHQse2hpbnQ6aS5jYWNoZUtleSxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxbb1swXV0saS5ub29wV2l0aEVtcHR5QXhlcyYmaS5heGVzLmxlbmd0aD09PTA/U206bixpLmF4ZXMsb1swXS5kYXRhVHlwZSxpLmtlZXBEaW1zLGkubm9vcFdpdGhFbXB0eUF4ZXMpLHtpbnB1dHM6WzBdfSl9LFRtPShlLHQpPT57bnQoZS5pbnB1dHMpLG90KGUsXCJSZWR1Y2VMb2dTdW1cIix0LChuLG8pPT5bYHZhciB2YWx1ZSA9ICR7by50eXBlLnN0b3JhZ2V9KDApO2AsXCJcIixgdmFsdWUgKz0gJHtuLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O2AsXCJ2YWx1ZSA9IGxvZyh2YWx1ZSk7XCJdKX0sSW09KGUsdCk9PntudChlLmlucHV0cyksb3QoZSxcIlJlZHVjZUwxXCIsdCwobixvKT0+W2B2YXIgdmFsdWUgPSAke28udHlwZS5zdG9yYWdlfSgwKTtgLFwiXCIsYHZhbHVlICs9IGFicygke24uZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX0pO2AsXCJcIl0pfSxDbT0oZSx0KT0+e250KGUuaW5wdXRzKSxvdChlLFwiUmVkdWNlTDJcIix0LChuLG8pPT5bYHZhciB0ID0gJHtvLnR5cGUudmFsdWV9KDApOyB2YXIgdmFsdWUgPSAke28udHlwZS52YWx1ZX0oMCk7YCxcIlwiLGB0ID0gJHtuLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9OyB2YWx1ZSArPSAodCAqIHQpO2AsXCJ2YWx1ZSA9IHNxcnQodmFsdWUpO1wiXSl9LEFtPShlLHQpPT57bnQoZS5pbnB1dHMpLG90KGUsXCJSZWR1Y2VMb2dTdW1FeHBcIix0LChuLG8pPT5bYHZhciB2YWx1ZSA9ICR7by50eXBlLnN0b3JhZ2V9KDApO2AsXCJcIixgdmFsdWUgKz0gZXhwKCR7bi5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfSk7YCxcInZhbHVlID0gbG9nKHZhbHVlKTtcIl0pfSxrbT0oZSx0KT0+e250KGUuaW5wdXRzKSxvdChlLFwiUmVkdWNlTWF4XCIsdCwobixvLGkpPT57bGV0IGE9W107Zm9yKGxldCBkPTA7ZDxuLnJhbms7ZCsrKShpLmluZGV4T2YoZCk+PTB8fGkubGVuZ3RoPT09MCkmJmEucHVzaChuLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsZCwwKSk7cmV0dXJuW2Ake2Euam9pbihgXG5gKX1gLGB2YXIgdmFsdWUgPSAke24uZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07YCxgdmFsdWUgPSBtYXgodmFsdWUsICR7bi5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfSk7YCxcIlwiXX0pfSxFbT0oZSx0KT0+e250KGUuaW5wdXRzKSxvdChlLFwiUmVkdWNlTWVhblwiLHQsKG4sbyxpKT0+e2xldCBhPTE7Zm9yKGxldCBkPTA7ZDxuLnJhbms7ZCsrKShpLmluZGV4T2YoZCk+PTB8fGkubGVuZ3RoPT09MCkmJihhKj1lLmlucHV0c1swXS5kaW1zW2RdKTtyZXR1cm5bXCJ2YXIgc3VtID0gZjMyKDApO1wiLFwiXCIsYHN1bSArPSBmMzIoJHtuLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9KTtgLGBsZXQgdmFsdWUgPSAke28udHlwZS52YWx1ZX0oc3VtIC8gJHthfSk7YF19KX0sUG09KGUsdCk9PntudChlLmlucHV0cyksb3QoZSxcIlJlZHVjZU1pblwiLHQsKG4sbyxpKT0+e2xldCBhPVtdO2ZvcihsZXQgZD0wO2Q8bi5yYW5rO2QrKykoaS5pbmRleE9mKGQpPj0wfHxpLmxlbmd0aD09PTApJiZhLnB1c2goYGlucHV0X2luZGljZXNbJHtkfV0gPSAwO2ApO3JldHVybltgJHthLmpvaW4oYFxuYCl9YCxgdmFyIHZhbHVlID0gJHtuLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O2AsYHZhbHVlID0gbWluKHZhbHVlLCAke24uZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX0pO2AsXCJcIl19KX0sem09KGUsdCk9PntudChlLmlucHV0cyksb3QoZSxcIlJlZHVjZVByb2RcIix0LChuLG8pPT5bYHZhciB2YWx1ZSA9ICR7by50eXBlLnN0b3JhZ2V9KDEpO2AsXCJcIixgdmFsdWUgKj0gJHtuLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O2AsXCJcIl0pfSxPbT0oZSx0KT0+e250KGUuaW5wdXRzKSxvdChlLFwiUmVkdWNlU3VtXCIsdCwobixvKT0+W2B2YXIgdmFsdWUgPSAke28udHlwZS5zdG9yYWdlfSgwKTtgLFwiXCIsYHZhbHVlICs9ICR7bi5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtgLFwiXCJdKX0sRG09KGUsdCk9PntudChlLmlucHV0cyksb3QoZSxcIlJlZHVjZVN1bVNxdWFyZVwiLHQsKG4sbyk9PltgdmFyIHQgPSAke28udHlwZS52YWx1ZX0oMCk7IHZhciB2YWx1ZSA9ICR7by50eXBlLnZhbHVlfSgwKTtgLFwiXCIsYHQgPSAke24uZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07IHZhbHVlICs9IHQgKiB0O2AsXCJcIl0pfSxpdD0oZSx0LHIpPT57aWYodC5sZW5ndGg9PT0wKXJldHVybiByO2xldCBuPTEsbz0xO2ZvcihsZXQgaT0wO2k8dC5sZW5ndGg7aSsrKXQuaW5kZXhPZihpKT09PS0xP24qPWVbaV06byo9ZVtpXTtyZXR1cm4gbzwzMiYmbj4xMDI0fSx5cz0oZSx0KT0+e2l0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP0VtKGUsdCk6c3MoZSx0KX0sX3M9KGUsdCk9PntpdChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT9JbShlLHQpOnVzKGUsdCl9LHdzPShlLHQpPT57aXQoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/Q20oZSx0KTpkcyhlLHQpfSx2cz0oZSx0KT0+e2l0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP0FtKGUsdCk6bHMoZSx0KX0sJHM9KGUsdCk9PntpdChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT9rbShlLHQpOmNzKGUsdCl9LHhzPShlLHQpPT57aXQoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/UG0oZSx0KTpwcyhlLHQpfSxTcz0oZSx0KT0+e2l0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP3ptKGUsdCk6bXMoZSx0KX0sVHM9KGUsdCk9PntpdChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT9PbShlLHQpOmZzKGUsdCl9LElzPShlLHQpPT57aXQoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/RG0oZSx0KTpocyhlLHQpfSxDcz0oZSx0KT0+e2l0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP1RtKGUsdCk6Z3MoZSx0KX19KTt2YXIgQXMsa3MsRXMsY28sUHM9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7U2UoKTtHcigpO0FzPWU9PntpZighZXx8ZS5sZW5ndGg9PT0wfHxlLmxlbmd0aD4yKXRocm93IG5ldyBFcnJvcihcIkFyZ01pbk1heE9wIG9wIHJlcXVpcmVzIDEgb3IgMiBpbnB1dHMuXCIpO2lmKGVbMF0uZGF0YVR5cGUhPT0xKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIil9LGtzPShlLHQpPT57QXMoZS5pbnB1dHMpO2xldCByPShuLG8saSk9PntsZXQgYT1bXTtmb3IobGV0IGQ9MDtkPG4ucmFuaztkKyspKGkuaW5kZXhPZihkKT49MHx8aS5sZW5ndGg9PT0wKSYmYS5wdXNoKGBpbnB1dF9pbmRpY2VzWyR7ZH1dID0gMDtgKTtyZXR1cm5bYCR7YS5qb2luKGBcbmApfWAsYHZhciB2YWx1ZSA9ICR7bi5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtcbnZhciBiZXN0X2luZGV4IDogaTMyID0gMDtgLGBpZiAoJHtuLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9ICR7dC5zZWxlY3RMYXN0SW5kZXg+MD9cIjw9XCI6XCI8XCJ9IHZhbHVlKSB7XG4gICAgICAgICB2YWx1ZSA9ICR7bi5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtcbiAgICAgICAgIGJlc3RfaW5kZXggPSBpMzIobGFzdF9pbmRleCk7XG4gICAgICAgfWAsXCJcIixvLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwiYmVzdF9pbmRleFwiKV19O2UuY29tcHV0ZShIcihcIkFyZ01pblwiLHtoaW50OnQuY2FjaGVLZXksaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiXX0sW2UuaW5wdXRzWzBdXSxyLFt0LmF4aXNdLDcsdC5rZWVwRGltcykse2lucHV0czpbMF19KX0sRXM9KGUsdCk9PntBcyhlLmlucHV0cyk7bGV0IHI9KG4sbyxpKT0+e2xldCBhPVtdO2ZvcihsZXQgZD0wO2Q8bi5yYW5rO2QrKykoaS5pbmRleE9mKGQpPj0wfHxpLmxlbmd0aD09PTApJiZhLnB1c2goYGlucHV0X2luZGljZXNbJHtkfV0gPSAwO2ApO3JldHVybltgJHthLmpvaW4oYFxuYCl9YCxgdmFyIHZhbHVlID0gJHtuLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O1xudmFyIGJlc3RfaW5kZXggOiBpMzIgPSAwO2AsYGlmICgke24uZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX0gJHt0LnNlbGVjdExhc3RJbmRleD4wP1wiPj1cIjpcIj5cIn0gdmFsdWUpIHtcbiAgICAgICAgIHZhbHVlID0gJHtuLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O1xuICAgICAgICAgYmVzdF9pbmRleCA9IGkzMihsYXN0X2luZGV4KTtcbiAgICAgICB9YCxcIlwiLG8uc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJiZXN0X2luZGV4XCIpXX07ZS5jb21wdXRlKEhyKFwiYXJnTWF4XCIse2hpbnQ6dC5jYWNoZUtleSxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxbZS5pbnB1dHNbMF1dLHIsW3QuYXhpc10sNyx0LmtlZXBEaW1zKSx7aW5wdXRzOlswXX0pfSxjbz1lPT5yZShlKX0pO3ZhciBCbSxwbyxNbSxSbSxVbSxSdCxObSx6cyxGcj1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtvZSgpO05yKCk7YWUoKTtCbT0oZSx0KT0+e2xldCByPWVbMF0sbj1lWzFdLG89ZVsyXSxpPWVbM10sYT1lWzRdLGQ9ZVs1XTtpZihhJiZkKXRocm93IG5ldyBFcnJvcihcIkF0dGVudGlvbiBjYW5ub3QgaGF2ZSBib3RoIHBhc3QgYW5kIGF0dGVudGlvbl9iaWFzXCIpO2lmKHIuZGltcy5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJpbnB1dFwiIG11c3QgaGF2ZSAzIGRpbWVuc2lvbnMnKTtsZXQgbD1yLmRpbXNbMF0scD1yLmRpbXNbMV0sbT1yLmRpbXNbMl07aWYoby5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImJpYXNcIiBpcyBleHBlY3RlZCB0byBoYXZlIDEgZGltZW5zaW9ucycpO2lmKG4uZGltcy5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJ3ZWlnaHRzXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAyIGRpbWVuc2lvbnMnKTtpZihuLmRpbXNbMF0hPT1tKXRocm93IG5ldyBFcnJvcihcIklucHV0IDEgZGltZW5zaW9uIDAgc2hvdWxkIGhhdmUgc2FtZSBsZW5ndGggYXMgZGltZW5zaW9uIDIgb2YgaW5wdXQgMFwiKTtpZihvLmRpbXNbMF0hPT1uLmRpbXNbMV0pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImJpYXNcIiBkaW1lbnNpb24gMCBzaG91bGQgaGF2ZSBzYW1lIGxlbmd0aCBhcyBkaW1lbnNpb24gMSBvZiBpbnB1dCBcIndlaWdodHNcIicpO2xldCB1PW8uZGltc1swXS8zLGg9dSxfPWg7aWYodC5xa3ZIaWRkZW5TaXplcy5sZW5ndGg+MCl7aWYodC5xa3ZIaWRkZW5TaXplcy5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcihcInFrdl9oaWRkZW5fc2l6ZXMgYXR0cmlidXRlIHNob3VsZCBoYXZlIDMgZWxlbWVudHNcIik7Zm9yKGxldCBTIG9mIHQucWt2SGlkZGVuU2l6ZXMpaWYoUyV0Lm51bUhlYWRzIT09MCl0aHJvdyBuZXcgRXJyb3IoXCJxa3ZfaGlkZGVuX3NpemVzIHNob3VsZCBiZSBkaXZpc2libGUgYnkgbnVtX2hlYWRzXCIpO3U9dC5xa3ZIaWRkZW5TaXplc1swXSxoPXQucWt2SGlkZGVuU2l6ZXNbMV0sXz10LnFrdkhpZGRlblNpemVzWzJdfWxldCB5PXA7aWYodSE9PWgpdGhyb3cgbmV3IEVycm9yKFwicWt2X2hpZGRlbl9zaXplcyBmaXJzdCBlbGVtZW50IHNob3VsZCBiZSBzYW1lIGFzIHRoZSBzZWNvbmRcIik7aWYoby5kaW1zWzBdIT09dStoK18pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImJpYXNcIiBkaW1lbnNpb24gMCBzaG91bGQgaGF2ZSBzYW1lIGxlbmd0aCBhcyBzdW0gb2YgUS9LL1YgaGlkZGVuIHNpemVzJyk7bGV0IGc9MDtpZihhKXtpZihoIT09Xyl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdFwiIGV4cGVjdCBrX2hpZGRlbl9zaXplID09IHZfaGlkZGVuX3NpemUnKTtpZihhLmRpbXMubGVuZ3RoIT09NSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdFwiIG11c3QgaGF2ZSA1IGRpbWVuc2lvbnMnKTtpZihhLmRpbXNbMF0hPT0yKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0XCIgZmlyc3QgZGltZW5zaW9uIG11c3QgYmUgMicpO2lmKGEuZGltc1sxXSE9PWwpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RcIiBzZWNvbmQgZGltZW5zaW9uIG11c3QgYmUgYmF0Y2hfc2l6ZScpO2lmKGEuZGltc1syXSE9PXQubnVtSGVhZHMpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RcIiB0aGlyZCBkaW1lbnNpb24gbXVzdCBiZSBudW1faGVhZHMnKTtpZihhLmRpbXNbNF0hPT1oL3QubnVtSGVhZHMpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RcIiBmaWZ0aCBkaW1lbnNpb24gbXVzdCBiZSBrX2hpZGRlbl9zaXplIC8gbnVtX2hlYWRzJyk7dC5wYXN0UHJlc2VudFNoYXJlQnVmZmVyfHwoZz1hLmRpbXNbM10pfWxldCB4PXkrZywkPS0xLHY9MDtpZihpKXRocm93IG5ldyBFcnJvcihcIk1hc2sgbm90IHN1cHBvcnRlZFwiKTtpZihhKXRocm93IG5ldyBFcnJvcihcInBhc3QgaXMgbm90IHN1cHBvcnRlZFwiKTtpZihkKXtpZihkLmRpbXMubGVuZ3RoIT09NCl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwiYXR0ZW50aW9uX2JpYXNcIiBtdXN0IGhhdmUgNCBkaW1lbnNpb25zJyk7aWYoZC5kaW1zWzBdIT09bHx8ZC5kaW1zWzFdIT09dC5udW1IZWFkc3x8ZC5kaW1zWzJdIT09cHx8ZC5kaW1zWzNdIT09eCl0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcImF0dGVudGlvbl9iaWFzXCIgc2hhcGUgKGJhdGNoX3NpemUsIG51bV9oZWFkcywgc2VxdWVuY2VfbGVuZ3RoLCB0b3RhbF9zZXF1ZW5jZV9sZW5ndGgpJyl9cmV0dXJue2JhdGNoU2l6ZTpsLHNlcXVlbmNlTGVuZ3RoOnAscGFzdFNlcXVlbmNlTGVuZ3RoOmcsa3ZTZXF1ZW5jZUxlbmd0aDp5LHRvdGFsU2VxdWVuY2VMZW5ndGg6eCxtYXhTZXF1ZW5jZUxlbmd0aDokLGlucHV0SGlkZGVuU2l6ZTptLGhpZGRlblNpemU6dSx2SGlkZGVuU2l6ZTpfLGhlYWRTaXplOk1hdGguZmxvb3IodS90Lm51bUhlYWRzKSx2SGVhZFNpemU6TWF0aC5mbG9vcihfL3QubnVtSGVhZHMpLG51bUhlYWRzOnQubnVtSGVhZHMsaXNVbmlkaXJlY3Rpb25hbDohMSxwYXN0UHJlc2VudFNoYXJlQnVmZmVyOiExLG1hc2tGaWx0ZXJWYWx1ZTp0Lm1hc2tGaWx0ZXJWYWx1ZSxtYXNrVHlwZTp2LHNjYWxlOnQuc2NhbGUsYnJvYWRjYXN0UmVzUG9zQmlhczohMSxwYXNzUGFzdEluS3Y6ITEscWt2Rm9ybWF0OjF9fSxwbz0oZSx0LHIpPT50JiZlP2BcbiAgICAgIGxldCB0b3RhbF9zZXF1ZW5jZV9sZW5ndGhfaW5wdXQgPSB1MzIoJHt0LmdldEJ5T2Zmc2V0KFwiMFwiKX0pO1xuICAgICAgbGV0IHByZXNlbnRfc2VxdWVuY2VfbGVuZ3RoID0gbWF4KHRvdGFsX3NlcXVlbmNlX2xlbmd0aF9pbnB1dCwgdW5pZm9ybXMucGFzdF9zZXF1ZW5jZV9sZW5ndGgpO1xuICAgICAgbGV0IGlzX3N1YnNlcXVlbnRfcHJvbXB0OiBib29sID0gc2VxdWVuY2VfbGVuZ3RoID4gMSAmJiBzZXF1ZW5jZV9sZW5ndGggIT0gdG90YWxfc2VxdWVuY2VfbGVuZ3RoX2lucHV0O1xuICAgICAgbGV0IGlzX2ZpcnN0X3Byb21wdDogYm9vbCA9IGlzX3N1YnNlcXVlbnRfcHJvbXB0ID09IGZhbHNlICYmIHNlcXVlbmNlX2xlbmd0aCA9PSB0b3RhbF9zZXF1ZW5jZV9sZW5ndGhfaW5wdXQ7XG4gICAgICB0b3RhbF9zZXF1ZW5jZV9sZW5ndGggPSB1MzIoJHtlPy5nZXRCeU9mZnNldChcImJhdGNoSWR4XCIpfSkgKyAxO1xuICAgICAgdmFyIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoOiB1MzIgPSAwO1xuICAgICAgaWYgKGlzX2ZpcnN0X3Byb21wdCA9PSBmYWxzZSkge1xuICAgICAgICBwYXN0X3NlcXVlbmNlX2xlbmd0aCA9IHRvdGFsX3NlcXVlbmNlX2xlbmd0aCAtIHNlcXVlbmNlX2xlbmd0aDtcbiAgICAgIH1cbiAgICAgICBgOmBcbiAgICAke3I/XCJsZXQgcGFzdF9zZXF1ZW5jZV9sZW5ndGggPSB1bmlmb3Jtcy5wYXN0X3NlcXVlbmNlX2xlbmd0aFwiOlwiXCJ9O1xuICAgIGxldCBwcmVzZW50X3NlcXVlbmNlX2xlbmd0aCA9IHRvdGFsX3NlcXVlbmNlX2xlbmd0aDtcbiAgICBgLE1tPShlLHQscixuLG8saSxhLGQpPT57bGV0IGw9bWUoYT8xOmkpLHA9NjQsbT1pL2w7bTxwJiYocD0zMik7bGV0IHU9TWF0aC5jZWlsKGkvbC9wKSxoPVt7dHlwZToxMixkYXRhOnR9LHt0eXBlOjEyLGRhdGE6cn0se3R5cGU6MTIsZGF0YTpufSx7dHlwZToxMixkYXRhOm99LHt0eXBlOjEyLGRhdGE6bX0se3R5cGU6MTIsZGF0YTp1fV0sXz1fZShlLmRhdGFUeXBlLGwpLHk9RWUoMSxsKSxnPVtcInR5cGVcIl07YSYmZy5wdXNoKFwidHlwZVwiKSxkJiZnLnB1c2goXCJ0eXBlXCIpO2xldCB4PSQ9PntsZXQgdj1NKFwieFwiLGUuZGF0YVR5cGUsZS5kaW1zLGwpLFM9W3ZdLFQ9YT9FKFwic2VxX2xlbnNcIixhLmRhdGFUeXBlLGEuZGltcyk6dm9pZCAwO1QmJlMucHVzaChUKTtsZXQgQT1kP0UoXCJ0b3RhbF9zZXF1ZW5jZV9sZW5ndGhfaW5wdXRcIixkLmRhdGFUeXBlLGQuZGltcyk6dm9pZCAwO0EmJlMucHVzaChBKTtsZXQgaz1FZShlLmRhdGFUeXBlKSxQPVt7bmFtZTpcImJhdGNoX3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibnVtX2hlYWRzXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInBhc3Rfc2VxdWVuY2VfbGVuZ3RoXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInNlcXVlbmNlX2xlbmd0aFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJ0b3RhbF9zZXF1ZW5jZV9sZW5ndGhcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiZWxlbWVudHNfcGVyX3RocmVhZFwiLHR5cGU6XCJ1MzJcIn1dO3JldHVybmBcbiAgdmFyPHdvcmtncm91cD4gdGhyZWFkX21heDogYXJyYXk8ZjMyLCAke3B9PjtcbiAgdmFyPHdvcmtncm91cD4gdGhyZWFkX3N1bTogYXJyYXk8ZjMyLCAke3B9PjtcbiAgJHskLnJlZ2lzdGVyVW5pZm9ybXMoUCkuZGVjbGFyZVZhcmlhYmxlcyguLi5TKX1cbiAgJHskLm1haW5TdGFydChbcCwxLDFdKX1cbiAgICBsZXQgYmF0Y2hJZHggPSB3b3JrZ3JvdXBfaWQueiAvIHVuaWZvcm1zLm51bV9oZWFkcztcbiAgICBsZXQgaGVhZElkeCA9IHdvcmtncm91cF9pZC56ICUgdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgIGxldCBzZXF1ZW5jZV9sZW5ndGggPSB1bmlmb3Jtcy5zZXF1ZW5jZV9sZW5ndGg7XG4gICAgdmFyIHRvdGFsX3NlcXVlbmNlX2xlbmd0aCA9IHVuaWZvcm1zLnRvdGFsX3NlcXVlbmNlX2xlbmd0aDtcbiAgICAke3BvKFQsQSwhMSl9XG4gICAgbGV0IGxvY2FsX29mZnNldCA9IGxvY2FsX2lkeCAqIHVuaWZvcm1zLmVsZW1lbnRzX3Blcl90aHJlYWQ7XG4gICAgbGV0IG9mZnNldCA9IChnbG9iYWxfaWR4IC8gJHtwfSkgKiB1bmlmb3Jtcy50b3RhbF9zZXF1ZW5jZV9sZW5ndGggKyBsb2NhbF9vZmZzZXQ7XG4gICAgbGV0IHNlcV9jYXVzYWxfbGVuZ3RoID0gJHthP1widTMyKHBhc3Rfc2VxdWVuY2VfbGVuZ3RoICsgd29ya2dyb3VwX2lkLnkgKyAxKVwiOlwidG90YWxfc2VxdWVuY2VfbGVuZ3RoXCJ9O1xuICAgIHZhciB0aHJlYWRfbWF4X3ZlY3RvciA9ICR7eX0oLTMuNDAyODIzZSszOGYpO1xuICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCB1bmlmb3Jtcy5lbGVtZW50c19wZXJfdGhyZWFkICYmIGkgKyBsb2NhbF9vZmZzZXQgPCBzZXFfY2F1c2FsX2xlbmd0aDsgaSsrKSB7XG4gICAgICB0aHJlYWRfbWF4X3ZlY3RvciA9IG1heCgke3l9KHhbb2Zmc2V0ICsgaV0pLCB0aHJlYWRfbWF4X3ZlY3Rvcik7XG4gICAgfVxuICAgIHRocmVhZF9tYXhbbG9jYWxfaWR4XSA9ICR7KCgpPT57c3dpdGNoKGwpe2Nhc2UgMTpyZXR1cm5cInRocmVhZF9tYXhfdmVjdG9yXCI7Y2FzZSAyOnJldHVyblwibWF4KHRocmVhZF9tYXhfdmVjdG9yLngsIHRocmVhZF9tYXhfdmVjdG9yLnkpXCI7Y2FzZSA0OnJldHVyblwibWF4KG1heCh0aHJlYWRfbWF4X3ZlY3Rvci54LCB0aHJlYWRfbWF4X3ZlY3Rvci55KSwgbWF4KHRocmVhZF9tYXhfdmVjdG9yLnosIHRocmVhZF9tYXhfdmVjdG9yLncpKVwiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjb21wb25lbnRzOiAke2x9YCl9fSkoKX07XG4gICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgdmFyIG1heF92YWx1ZSA9ICBmMzIoLTMuNDAyODIzZSszOGYpO1xuICAgIGZvciAodmFyIGkgPSAwdTsgaSA8ICR7cH07IGkrKykge1xuICAgICAgbWF4X3ZhbHVlID0gbWF4KHRocmVhZF9tYXhbaV0sIG1heF92YWx1ZSk7XG4gICAgfVxuXG4gICAgdmFyIHN1bV92ZWN0b3IgPSAke3l9KDApO1xuICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCB1bmlmb3Jtcy5lbGVtZW50c19wZXJfdGhyZWFkICYmIGkgKyBsb2NhbF9vZmZzZXQgPCBzZXFfY2F1c2FsX2xlbmd0aDsgaSsrKSB7XG4gICAgICBzdW1fdmVjdG9yICs9IGV4cCgke3l9KHhbb2Zmc2V0ICsgaV0pIC0gbWF4X3ZhbHVlKTtcbiAgICB9XG4gICAgdGhyZWFkX3N1bVtsb2NhbF9pZHhdID0gJHsoKCk9Pntzd2l0Y2gobCl7Y2FzZSAxOnJldHVyblwic3VtX3ZlY3RvclwiO2Nhc2UgMjpyZXR1cm5cInN1bV92ZWN0b3IueCArIHN1bV92ZWN0b3IueVwiO2Nhc2UgNDpyZXR1cm5cInN1bV92ZWN0b3IueCArIHN1bV92ZWN0b3IueSArIHN1bV92ZWN0b3IueiArIHN1bV92ZWN0b3Iud1wiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjb21wb25lbnRzOiAke2x9YCl9fSkoKX07XG4gICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgdmFyIHN1bTogZjMyID0gMDtcbiAgICBmb3IgKHZhciBpID0gMHU7IGkgPCAke3B9OyBpKyspIHtcbiAgICAgIHN1bSArPSB0aHJlYWRfc3VtW2ldO1xuICAgIH1cblxuICAgIGlmIChzdW0gPT0gMCkge1xuICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHVuaWZvcm1zLmVsZW1lbnRzX3Blcl90aHJlYWQgJiYgaSArIGxvY2FsX29mZnNldCA8IHNlcV9jYXVzYWxfbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgeFtvZmZzZXQgKyBpXSA9ICR7di50eXBlLnZhbHVlfSgke2t9KDEuMCkgLyAke2t9KHNlcV9jYXVzYWxfbGVuZ3RoKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCB1bmlmb3Jtcy5lbGVtZW50c19wZXJfdGhyZWFkICYmIGkgKyBsb2NhbF9vZmZzZXQgPCBzZXFfY2F1c2FsX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBmMzJpbnB1dCA9ICR7eX0oeFtvZmZzZXQgKyBpXSk7XG4gICAgICAgIHhbb2Zmc2V0ICsgaV0gPSAke3YudHlwZS52YWx1ZX0oZXhwKGYzMmlucHV0IC0gbWF4X3ZhbHVlKSAvIHN1bSk7XG4gICAgICB9XG4gICAgfVxuICAgICAgJHthP2BcbiAgICAgICAgZm9yICh2YXIgdG90YWxfc2VxX2lkOiB1MzIgPSBzZXFfY2F1c2FsX2xlbmd0aDsgdG90YWxfc2VxX2lkICsgbG9jYWxfb2Zmc2V0IDwgdW5pZm9ybXMudG90YWxfc2VxdWVuY2VfbGVuZ3RoOyB0b3RhbF9zZXFfaWQrKykge1xuICAgICAgICAgIHhbb2Zmc2V0ICsgdG90YWxfc2VxX2lkXSA9ICR7di50eXBlLnZhbHVlfSgke2t9KDApKTtcbiAgICAgICAgfWA6XCJcIn07XG4gIH1gfTtyZXR1cm57bmFtZTpcIkF0dGVudGlvblByb2JzU29mdG1heFwiLHNoYWRlckNhY2hlOntoaW50OmAke3B9OyR7X307JHtsfWAsaW5wdXREZXBlbmRlbmNpZXM6Z30sZ2V0U2hhZGVyU291cmNlOngsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOltdLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGkvcCkseTpvLHo6dCpyfSxwcm9ncmFtVW5pZm9ybXM6aH0pfX0sUm09KGUsdCxyLG4sbyxpLGEsZCxsKT0+e2xldCBwPWEraS5rdlNlcXVlbmNlTGVuZ3RoLG09W2kuYmF0Y2hTaXplLGkubnVtSGVhZHMsaS5zZXF1ZW5jZUxlbmd0aCxwXSx1PWU+MSYmbixoPWkua3ZOdW1IZWFkcz9pLmt2TnVtSGVhZHM6aS5udW1IZWFkcyxfPXU/W2kuYmF0Y2hTaXplLGgscCxpLmhlYWRTaXplXTp2b2lkIDAseT1pLm5SZXBzP2kublJlcHM6MSxnPWkuc2NhbGU9PT0wPzEvTWF0aC5zcXJ0KGkuaGVhZFNpemUpOmkuc2NhbGUseD1tZShpLmhlYWRTaXplKSwkPWkuaGVhZFNpemUveCx2PTEyLFM9e3g6TWF0aC5jZWlsKHAvdikseTpNYXRoLmNlaWwoaS5zZXF1ZW5jZUxlbmd0aC92KSx6OmkuYmF0Y2hTaXplKmkubnVtSGVhZHN9LFQ9W3t0eXBlOjEyLGRhdGE6aS5zZXF1ZW5jZUxlbmd0aH0se3R5cGU6MTIsZGF0YTokfSx7dHlwZToxMixkYXRhOnB9LHt0eXBlOjEyLGRhdGE6aS5udW1IZWFkc30se3R5cGU6MTIsZGF0YTppLmhlYWRTaXplfSx7dHlwZToxLGRhdGE6Z30se3R5cGU6MTIsZGF0YTphfSx7dHlwZToxMixkYXRhOmkua3ZTZXF1ZW5jZUxlbmd0aH0se3R5cGU6MTIsZGF0YTp5fV0sQT11JiZuJiZDLnNpemUobi5kaW1zKT4wLGs9W1widHlwZVwiLFwidHlwZVwiXTtBJiZrLnB1c2goXCJ0eXBlXCIpLG8mJmsucHVzaChcInR5cGVcIiksZCYmay5wdXNoKFwidHlwZVwiKSxsJiZrLnB1c2goXCJ0eXBlXCIpO2xldCBQPVt7ZGltczptLGRhdGFUeXBlOnQuZGF0YVR5cGUsZ3B1RGF0YVR5cGU6MH1dO3UmJlAucHVzaCh7ZGltczpfLGRhdGFUeXBlOnQuZGF0YVR5cGUsZ3B1RGF0YVR5cGU6MH0pO2xldCBEPVI9PntsZXQgRz1FKFwicVwiLHQuZGF0YVR5cGUsdC5kaW1zLHgpLEs9RShcImtleVwiLHIuZGF0YVR5cGUsci5kaW1zLHgpLGo9W0csS107aWYoQSl7bGV0IG5lPUUoXCJwYXN0X2tleVwiLG4uZGF0YVR5cGUsbi5kaW1zLHgpO2oucHVzaChuZSl9byYmai5wdXNoKEUoXCJhdHRlbnRpb25fYmlhc1wiLG8uZGF0YVR5cGUsby5kaW1zKSk7bGV0IFY9ZD9FKFwic2VxX2xlbnNcIixkLmRhdGFUeXBlLGQuZGltcyk6dm9pZCAwO1YmJmoucHVzaChWKTtsZXQgUT1sP0UoXCJ0b3RhbF9zZXF1ZW5jZV9sZW5ndGhfaW5wdXRcIixsLmRhdGFUeXBlLGwuZGltcyk6dm9pZCAwO1EmJmoucHVzaChRKTtsZXQgc2U9TShcIm91dHB1dFwiLHQuZGF0YVR5cGUsbSksWT1bc2VdO3UmJlkucHVzaChNKFwicHJlc2VudF9rZXlcIix0LmRhdGFUeXBlLF8seCkpO2xldCBlZT1FZSgxLHgpLEo9W3tuYW1lOlwiTVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJLXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIk5cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibnVtX2hlYWRzXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImhlYWRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJhbHBoYVwiLHR5cGU6XCJmMzJcIn0se25hbWU6XCJwYXN0X3NlcXVlbmNlX2xlbmd0aFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJrdl9zZXF1ZW5jZV9sZW5ndGhcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibl9yZXBzXCIsdHlwZTpcInUzMlwifV07cmV0dXJuYFxuICBjb25zdCBUSUxFX1NJWkUgPSAke3Z9dTtcblxuICB2YXI8d29ya2dyb3VwPiB0aWxlUTogYXJyYXk8JHtHLnR5cGUuc3RvcmFnZX0sICR7dip2fT47XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVLOiBhcnJheTwke0cudHlwZS5zdG9yYWdlfSwgJHt2KnZ9PjtcbiAgJHtSLnJlZ2lzdGVyVW5pZm9ybXMoSikuZGVjbGFyZVZhcmlhYmxlcyguLi5qLC4uLlkpfVxuICAke1IubWFpblN0YXJ0KFt2LHYsMV0pfVxuICAgIC8vIHggaG9sZHMgdGhlIE4gYW5kIHkgaG9sZHMgdGhlIE1cbiAgICBsZXQgaGVhZElkeCA9IHdvcmtncm91cF9pZC56ICUgdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgIGxldCBrdkhlYWRJZHggPSAke3k9PT0xP1wiaGVhZElkeFwiOlwiaGVhZElkeCAvIHVuaWZvcm1zLm5fcmVwc1wifTtcbiAgICBsZXQga3ZfbnVtX2hlYWRzID0gJHt5PT09MT9cInVuaWZvcm1zLm51bV9oZWFkc1wiOlwidW5pZm9ybXMubnVtX2hlYWRzIC8gdW5pZm9ybXMubl9yZXBzXCJ9O1xuICAgIGxldCBiYXRjaElkeCA9IHdvcmtncm91cF9pZC56IC8gdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgIGxldCBtID0gd29ya2dyb3VwX2lkLnkgKiBUSUxFX1NJWkU7XG4gICAgbGV0IG4gPSB3b3JrZ3JvdXBfaWQueCAqIFRJTEVfU0laRTtcbiAgICBsZXQgc2VxdWVuY2VfbGVuZ3RoID0gdW5pZm9ybXMuTTtcbiAgICB2YXIgdG90YWxfc2VxdWVuY2VfbGVuZ3RoID0gdW5pZm9ybXMuTjtcbiAgICAke3BvKFYsUSwhMCl9XG4gICAgbGV0IGFic0t2SGVhZElkeCA9IGJhdGNoSWR4ICoga3ZfbnVtX2hlYWRzICsga3ZIZWFkSWR4O1xuICAgIGxldCBxT2Zmc2V0ID0gd29ya2dyb3VwX2lkLnogKiB1bmlmb3Jtcy5NICogdW5pZm9ybXMuSyArIG0gKiB1bmlmb3Jtcy5LO1xuICAgICR7QSYmdT9cImxldCBwYXN0S2V5T2Zmc2V0ID0gYWJzS3ZIZWFkSWR4ICogdW5pZm9ybXMucGFzdF9zZXF1ZW5jZV9sZW5ndGggKiB1bmlmb3Jtcy5LO1wiOlwiXCJ9O1xuICAgIGxldCBrT2Zmc2V0ID0gYWJzS3ZIZWFkSWR4ICogdW5pZm9ybXMua3Zfc2VxdWVuY2VfbGVuZ3RoICogdW5pZm9ybXMuSztcbiAgICAke3U/XCJsZXQgcHJlc2VudEtleU9mZnNldCA9IGFic0t2SGVhZElkeCAqIHVuaWZvcm1zLk4gKiB1bmlmb3Jtcy5LO1wiOlwiXCJ9XG4gICAgdmFyIHZhbHVlID0gJHtlZX0oMCk7XG4gICAgZm9yICh2YXIgdzogdTMyID0gMHU7IHcgPCB1bmlmb3Jtcy5LOyB3ICs9IFRJTEVfU0laRSkge1xuICAgICAgaWYgKGdsb2JhbF9pZC55IDwgdW5pZm9ybXMuTSAmJiB3ICsgbG9jYWxfaWQueCA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdGlsZVFbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLnhdID0gcVtxT2Zmc2V0ICsgbG9jYWxfaWQueSAqIHVuaWZvcm1zLksgKyB3ICsgbG9jYWxfaWQueF07XG4gICAgICB9XG4gICAgICBpZiAobiArIGxvY2FsX2lkLnkgPCB1bmlmb3Jtcy5OICYmIHcgKyBsb2NhbF9pZC54IDwgdW5pZm9ybXMuSykge1xuICAgICAgICB2YXIgaWR4ID0gVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLng7XG4gICAgICAkeygoKT0+QSYmdT9gXG4gICAgICAgICAgICAgIGlmIChuICsgbG9jYWxfaWQueSA8IHBhc3Rfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGlsZUtbaWR4XSA9IHBhc3Rfa2V5W3Bhc3RLZXlPZmZzZXQgKyAobiArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMuSyArIHcgKyBsb2NhbF9pZC54XTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChuICsgbG9jYWxfaWQueSAtIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoIDwgdW5pZm9ybXMua3Zfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGlsZUtbaWR4XSA9IGtleVtrT2Zmc2V0ICsgKG4gKyBsb2NhbF9pZC55IC0gcGFzdF9zZXF1ZW5jZV9sZW5ndGgpICogdW5pZm9ybXMuSyArIHcgKyBsb2NhbF9pZC54XTtcbiAgICAgICAgICAgICAgfWA6YFxuICAgICAgICAgIGlmIChuICsgbG9jYWxfaWQueSA8IHVuaWZvcm1zLmt2X3NlcXVlbmNlX2xlbmd0aCkge1xuICAgICAgICAgICAgdGlsZUtbaWR4XSA9IGtleVtrT2Zmc2V0ICsgKG4gKyBsb2NhbF9pZC55KSAqIHVuaWZvcm1zLksgKyB3ICsgbG9jYWxfaWQueF07XG4gICAgICAgICAgfWApKCl9XG4gICAgICAke3U/YGlmIChuICsgbG9jYWxfaWQueSA8IHByZXNlbnRfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgIHByZXNlbnRfa2V5W3ByZXNlbnRLZXlPZmZzZXQgKyAobiArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMuSyArIHcgKyBsb2NhbF9pZC54XSA9IHRpbGVLW2lkeF07XG4gICAgICB9YDpcIlwifVxuICAgICAgfVxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICBmb3IgKHZhciBrOiB1MzIgPSAwdTsgayA8IFRJTEVfU0laRSAmJiB3K2sgPCB1bmlmb3Jtcy5LOyBrKyspIHtcbiAgICAgICAgICB2YWx1ZSArPSAke2VlfSh0aWxlUVtUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsga10gKiB0aWxlS1tUSUxFX1NJWkUgKiBsb2NhbF9pZC54ICsga10pO1xuICAgICAgfVxuXG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgfVxuXG4gICAgaWYgKGdsb2JhbF9pZC55IDwgdW5pZm9ybXMuTSAmJiBnbG9iYWxfaWQueCA8IHRvdGFsX3NlcXVlbmNlX2xlbmd0aCkge1xuICAgICAgbGV0IGhlYWRPZmZzZXQgPSB3b3JrZ3JvdXBfaWQueiAqIHVuaWZvcm1zLk0gKiB1bmlmb3Jtcy5OO1xuICAgICAgbGV0IG91dHB1dElkeCA9IGhlYWRPZmZzZXQgKyBnbG9iYWxfaWQueSAqIHVuaWZvcm1zLk4gKyBnbG9iYWxfaWQueDtcbiAgICAgIHZhciBzdW06IGYzMiA9ICR7KCgpPT57c3dpdGNoKHgpe2Nhc2UgMTpyZXR1cm5cInZhbHVlXCI7Y2FzZSAyOnJldHVyblwidmFsdWUueCArIHZhbHVlLnlcIjtjYXNlIDQ6cmV0dXJuXCJ2YWx1ZS54ICsgdmFsdWUueSArIHZhbHVlLnogKyB2YWx1ZS53XCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNvbXBvbmVudHM6ICR7eH1gKX19KSgpfTtcbiAgICAgICAgb3V0cHV0W291dHB1dElkeF0gPSAke3NlLnR5cGUudmFsdWV9IChzdW0gKiB1bmlmb3Jtcy5hbHBoYSkgKyAke28/XCJhdHRlbnRpb25fYmlhc1tvdXRwdXRJZHhdXCI6XCIwLjBcIn07XG4gICAgfVxuICB9YH07cmV0dXJue25hbWU6XCJBdHRlbnRpb25Qcm9ic1wiLHNoYWRlckNhY2hlOntoaW50OmAke3h9OyR7byE9PXZvaWQgMH07JHtuIT09dm9pZCAwfTske2V9YCxpbnB1dERlcGVuZGVuY2llczprfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6UCxkaXNwYXRjaEdyb3VwOlMscHJvZ3JhbVVuaWZvcm1zOlR9KSxnZXRTaGFkZXJTb3VyY2U6RH19LFVtPShlLHQscixuLG8saSxhPXZvaWQgMCxkPXZvaWQgMCk9PntsZXQgbD1pK28ua3ZTZXF1ZW5jZUxlbmd0aCxwPW8ublJlcHM/by5uUmVwczoxLG09by52SGlkZGVuU2l6ZSpwLHU9ZT4xJiZuLGg9by5rdk51bUhlYWRzP28ua3ZOdW1IZWFkczpvLm51bUhlYWRzLF89dT9bby5iYXRjaFNpemUsaCxsLG8uaGVhZFNpemVdOnZvaWQgMCx5PVtvLmJhdGNoU2l6ZSxvLnNlcXVlbmNlTGVuZ3RoLG1dLGc9MTIseD17eDpNYXRoLmNlaWwoby52SGVhZFNpemUvZykseTpNYXRoLmNlaWwoby5zZXF1ZW5jZUxlbmd0aC9nKSx6Om8uYmF0Y2hTaXplKm8ubnVtSGVhZHN9LCQ9W3t0eXBlOjEyLGRhdGE6by5zZXF1ZW5jZUxlbmd0aH0se3R5cGU6MTIsZGF0YTpsfSx7dHlwZToxMixkYXRhOm8udkhlYWRTaXplfSx7dHlwZToxMixkYXRhOm8ubnVtSGVhZHN9LHt0eXBlOjEyLGRhdGE6by5oZWFkU2l6ZX0se3R5cGU6MTIsZGF0YTptfSx7dHlwZToxMixkYXRhOml9LHt0eXBlOjEyLGRhdGE6by5rdlNlcXVlbmNlTGVuZ3RofSx7dHlwZToxMixkYXRhOnB9XSx2PXUmJm4mJkMuc2l6ZShuLmRpbXMpPjAsUz1bXCJ0eXBlXCIsXCJ0eXBlXCJdO3YmJlMucHVzaChcInR5cGVcIiksYSYmUy5wdXNoKFwidHlwZVwiKSxkJiZTLnB1c2goXCJ0eXBlXCIpO2xldCBUPVt7ZGltczp5LGRhdGFUeXBlOnQuZGF0YVR5cGUsZ3B1RGF0YVR5cGU6MH1dO3UmJlQucHVzaCh7ZGltczpfLGRhdGFUeXBlOnQuZGF0YVR5cGUsZ3B1RGF0YVR5cGU6MH0pO2xldCBBPWs9PntsZXQgUD1FKFwicHJvYnNcIix0LmRhdGFUeXBlLHQuZGltcyksRD1FKFwidlwiLHIuZGF0YVR5cGUsci5kaW1zKSxSPVtQLERdO3YmJlIucHVzaChFKFwicGFzdF92YWx1ZVwiLG4uZGF0YVR5cGUsbi5kaW1zKSk7bGV0IEc9YT9FKFwic2VxX2xlbnNcIixhLmRhdGFUeXBlLGEuZGltcyk6dm9pZCAwO2EmJlIucHVzaChHKTtsZXQgSz1kP0UoXCJ0b3RhbF9zZXF1ZW5jZV9sZW5ndGhfaW5wdXRcIixkLmRhdGFUeXBlLGQuZGltcyk6dm9pZCAwO2QmJlIucHVzaChLKTtsZXQgVj1bTShcIm91dHB1dFwiLHQuZGF0YVR5cGUseSldO3UmJlYucHVzaChNKFwicHJlc2VudF92YWx1ZVwiLHQuZGF0YVR5cGUsXykpO2xldCBRPVt7bmFtZTpcIk1cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiS1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJOXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIm51bV9oZWFkc1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJoZWFkX3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwidl9oaWRkZW5fc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJwYXN0X3NlcXVlbmNlX2xlbmd0aFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJrdl9zZXF1ZW5jZV9sZW5ndGhcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibl9yZXBzXCIsdHlwZTpcInUzMlwifV07cmV0dXJuYFxuICBjb25zdCBUSUxFX1NJWkUgPSAke2d9dTtcbiAgdmFyPHdvcmtncm91cD4gdGlsZVE6IGFycmF5PCR7UC50eXBlLnZhbHVlfSwgJHtnKmd9PjtcbiAgdmFyPHdvcmtncm91cD4gdGlsZVY6IGFycmF5PCR7UC50eXBlLnZhbHVlfSwgJHtnKmd9PjtcbiAgJHtrLnJlZ2lzdGVyVW5pZm9ybXMoUSkuZGVjbGFyZVZhcmlhYmxlcyguLi5SLC4uLlYpfVxuICAke2subWFpblN0YXJ0KFtnLGcsMV0pfVxuICAgbGV0IGhlYWRJZHggPSB3b3JrZ3JvdXBfaWQueiAlIHVuaWZvcm1zLm51bV9oZWFkcztcbiAgIGxldCBiYXRjaElkeCA9IHdvcmtncm91cF9pZC56IC8gdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgbGV0IGt2SGVhZElkeCA9ICR7cD09PTE/XCJoZWFkSWR4XCI6XCJoZWFkSWR4IC8gdW5pZm9ybXMubl9yZXBzXCJ9O1xuICAgbGV0IGt2X251bV9oZWFkcyA9ICR7cD09PTE/XCJ1bmlmb3Jtcy5udW1faGVhZHNcIjpcInVuaWZvcm1zLm51bV9oZWFkcyAvIHVuaWZvcm1zLm5fcmVwc1wifTtcbiAgIGxldCBtID0gZ2xvYmFsX2lkLnk7XG4gICBsZXQgbiA9IGdsb2JhbF9pZC54O1xuICAgbGV0IHNlcXVlbmNlX2xlbmd0aCA9IHVuaWZvcm1zLk07XG4gICB2YXIgdG90YWxfc2VxdWVuY2VfbGVuZ3RoID0gdW5pZm9ybXMuSztcbiAgICR7cG8oRyxLLCEwKX1cbiAgIGxldCBvZmZzZXRBID0gd29ya2dyb3VwX2lkLnogKiB1bmlmb3Jtcy5NICogdW5pZm9ybXMuSyArIG0gKiB1bmlmb3Jtcy5LO1xuICAgbGV0IGFic0t2SGVhZElkeCA9IGJhdGNoSWR4ICoga3ZfbnVtX2hlYWRzICsga3ZIZWFkSWR4OyAvLyBrdkhlYWRJZHggaXMgcmVsYXRpdmUgdG8gdGhlIGJhdGNoXG4gICAke3YmJnU/XCJsZXQgcGFzdFZhbHVlT2Zmc2V0ID0gYWJzS3ZIZWFkSWR4ICogdW5pZm9ybXMuTiAqIHVuaWZvcm1zLnBhc3Rfc2VxdWVuY2VfbGVuZ3RoICsgbjtcIjpcIlwifTtcbiAgIGxldCB2T2Zmc2V0ID0gYWJzS3ZIZWFkSWR4ICogdW5pZm9ybXMuTiAqIHVuaWZvcm1zLmt2X3NlcXVlbmNlX2xlbmd0aCArIG47XG4gICAke3U/XCJsZXQgcHJlc2VudFZhbHVlT2Zmc2V0ID0gYWJzS3ZIZWFkSWR4ICogdW5pZm9ybXMuTiAqIHVuaWZvcm1zLksgKyBuO1wiOlwiXCJ9XG4gICB2YXIgdmFsdWUgPSAke1AudHlwZS5zdG9yYWdlfSgwKTtcbiAgIGZvciAodmFyIHc6IHUzMiA9IDB1OyB3IDwgdW5pZm9ybXMuSzsgdyArPSBUSUxFX1NJWkUpIHtcbiAgICAgIGlmIChtIDwgdW5pZm9ybXMuTSAmJiB3ICsgbG9jYWxfaWQueCA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdGlsZVFbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLnhdID0gcHJvYnNbb2Zmc2V0QSArIHcgKyBsb2NhbF9pZC54XTtcbiAgICAgIH1cbiAgICAgIGlmIChuIDwgdW5pZm9ybXMuTiAmJiB3ICsgbG9jYWxfaWQueSA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdmFyIGlkeCA9IFRJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54O1xuICAgICAgICAkeygoKT0+diYmdT9gXG4gICAgICAgIGlmICh3ICsgbG9jYWxfaWQueSA8IHBhc3Rfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgICAgdGlsZVZbaWR4XSA9IHBhc3RfdmFsdWVbcGFzdFZhbHVlT2Zmc2V0ICsgKHcgKyBsb2NhbF9pZC55KSAqIHVuaWZvcm1zLk5dO1xuICAgICAgICB9IGVsc2UgaWYgKHcgKyBsb2NhbF9pZC55IC0gcGFzdF9zZXF1ZW5jZV9sZW5ndGggPCB1bmlmb3Jtcy5rdl9zZXF1ZW5jZV9sZW5ndGgpIHtcbiAgICAgICAgICB0aWxlVltpZHhdID0gdlt2T2Zmc2V0ICsgKHcgKyBsb2NhbF9pZC55IC0gcGFzdF9zZXF1ZW5jZV9sZW5ndGgpICogdW5pZm9ybXMuTl07XG4gICAgICAgIH1cbiAgICAgIGA6YFxuICAgICAgICAgICAgaWYgKHcgKyBsb2NhbF9pZC55IDwgdW5pZm9ybXMua3Zfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRpbGVWW2lkeF0gPSB2W3ZPZmZzZXQgKyAodyArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMuTl07XG4gICAgICAgICAgICB9YCkoKX1cbiAgICAgICAgJHt1P2BcbiAgICAgICAgICAgIGlmICh3ICsgbG9jYWxfaWQueSA8IHByZXNlbnRfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgICAgcHJlc2VudF92YWx1ZVtwcmVzZW50VmFsdWVPZmZzZXQgKyAodyArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMuTl0gPSB0aWxlVltpZHhdO1xuICAgICAgICB9YDpcIlwifVxuICAgICAgfVxuICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgIGZvciAodmFyIGs6IHUzMiA9IDB1OyBrIDwgVElMRV9TSVpFICYmIHcrayA8IHRvdGFsX3NlcXVlbmNlX2xlbmd0aDsgaysrKSB7XG4gICAgICAgdmFsdWUgKz0gdGlsZVFbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGtdICogdGlsZVZbVElMRV9TSVpFICogayArIGxvY2FsX2lkLnhdO1xuICAgICB9XG4gICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgIH1cblxuICAgLy8gd2UgbmVlZCB0byB0cmFuc3Bvc2Ugb3V0cHV0IGZyb20gQk5TSF92IHRvIEJTTkRfdlxuICAgaWYgKG0gPCB1bmlmb3Jtcy5NICYmIG4gPCB1bmlmb3Jtcy5OKSB7XG4gICAgIGxldCBvdXRwdXRJZHggPSBiYXRjaElkeCAqIHVuaWZvcm1zLk0gKiB1bmlmb3Jtcy52X2hpZGRlbl9zaXplICsgbSAqIHVuaWZvcm1zLnZfaGlkZGVuX3NpemVcbiAgICAgICArIGhlYWRJZHggKiB1bmlmb3Jtcy5OICsgbjtcbiAgICAgb3V0cHV0W291dHB1dElkeF0gPSB2YWx1ZTtcbiAgIH1cbiAgfWB9O3JldHVybntuYW1lOlwiQXR0ZW50aW9uU2NvcmVcIixzaGFkZXJDYWNoZTp7aGludDpgJHtuIT09dm9pZCAwfTske2V9YCxpbnB1dERlcGVuZGVuY2llczpTfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6VCxkaXNwYXRjaEdyb3VwOngscHJvZ3JhbVVuaWZvcm1zOiR9KSxnZXRTaGFkZXJTb3VyY2U6QX19LFJ0PShlLHQscixuLG8saSxhLGQsbCxwLG09dm9pZCAwLHU9dm9pZCAwKT0+e2xldCBoPU1hdGgubWluKGUub3V0cHV0Q291bnQsMSsoYT8xOjApKyhkPzE6MCkpLF89aD4xP3AucGFzdFNlcXVlbmNlTGVuZ3RoOjAseT1fK3Aua3ZTZXF1ZW5jZUxlbmd0aCxnPWwmJkMuc2l6ZShsLmRpbXMpPjA/bDp2b2lkIDAseD1bdCxyXTtoPjEmJmEmJkMuc2l6ZShhLmRpbXMpPjAmJngucHVzaChhKSxnJiZ4LnB1c2goZyksbSYmeC5wdXNoKG0pLHUmJngucHVzaCh1KTtsZXQgJD1lLmNvbXB1dGUoUm0oaCx0LHIsYSxnLHAsXyxtLHUpLHtpbnB1dHM6eCxvdXRwdXRzOmg+MT9bLTEsMV06Wy0xXX0pWzBdO2UuY29tcHV0ZShNbSgkLHAuYmF0Y2hTaXplLHAubnVtSGVhZHMsXyxwLnNlcXVlbmNlTGVuZ3RoLHksbSx1KSx7aW5wdXRzOm0mJnU/WyQsbSx1XTpbJF0sb3V0cHV0czpbXX0pO2xldCB2PVskLG5dO2g+MSYmZCYmQy5zaXplKGQuZGltcyk+MCYmdi5wdXNoKGQpLG0mJnYucHVzaChtKSx1JiZ2LnB1c2godSksZS5jb21wdXRlKFVtKGgsJCxuLGQscCxfLG0sdSkse2lucHV0czp2LG91dHB1dHM6aD4xP1swLDJdOlswXX0pfSxObT0oZSx0KT0+e2xldCByPVt0LmJhdGNoU2l6ZSx0Lm51bUhlYWRzLHQuc2VxdWVuY2VMZW5ndGgsdC5oZWFkU2l6ZV0sbj10LnNlcXVlbmNlTGVuZ3RoLG89dC5pbnB1dEhpZGRlblNpemUsaT10LmhlYWRTaXplLGE9MTIsZD17eDpNYXRoLmNlaWwodC5oZWFkU2l6ZS9hKSx5Ok1hdGguY2VpbCh0LnNlcXVlbmNlTGVuZ3RoL2EpLHo6dC5iYXRjaFNpemUqdC5udW1IZWFkc30sbD1bZS5pbnB1dHNbMF0sZS5pbnB1dHNbMV0sZS5pbnB1dHNbMl1dLHA9W3t0eXBlOjEyLGRhdGE6bn0se3R5cGU6MTIsZGF0YTpvfSx7dHlwZToxMixkYXRhOml9LHt0eXBlOjEyLGRhdGE6dC5udW1IZWFkc30se3R5cGU6MTIsZGF0YTp0LmhlYWRTaXplfSx7dHlwZToxMixkYXRhOnQuaGlkZGVuU2l6ZX0se3R5cGU6MTIsZGF0YTp0LmhpZGRlblNpemUrdC5oaWRkZW5TaXplK3QudkhpZGRlblNpemV9XSxtPXU9PntsZXQgaD1NKFwib3V0cHV0X3FcIixsWzBdLmRhdGFUeXBlLHIpLF89TShcIm91dHB1dF9rXCIsbFswXS5kYXRhVHlwZSxyKSx5PU0oXCJvdXRwdXRfdlwiLGxbMF0uZGF0YVR5cGUsciksZz1FKFwiaW5wdXRcIixsWzBdLmRhdGFUeXBlLGxbMF0uZGltcykseD1FKFwid2VpZ2h0XCIsbFsxXS5kYXRhVHlwZSxsWzFdLmRpbXMpLCQ9RShcImJpYXNcIixsWzJdLmRhdGFUeXBlLGxbMl0uZGltcyksdj1nLnR5cGUuc3RvcmFnZSxTPVt7bmFtZTpcIk1cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiS1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJOXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIm51bV9oZWFkc1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJoZWFkX3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiaGlkZGVuX3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibGRiXCIsdHlwZTpcInUzMlwifV07cmV0dXJuYFxuICBjb25zdCBUSUxFX1NJWkUgPSAke2F9dTtcbiAgdmFyPHdvcmtncm91cD4gdGlsZUlucHV0OiBhcnJheTwke3Z9LCAke2EqYX0+O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlV2VpZ2h0UTogYXJyYXk8JHt2fSwgJHthKmF9PjtcbiAgdmFyPHdvcmtncm91cD4gdGlsZVdlaWdodEs6IGFycmF5PCR7dn0sICR7YSphfT47XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVXZWlnaHRWOiBhcnJheTwke3Z9LCAke2EqYX0+O1xuICAke3UucmVnaXN0ZXJVbmlmb3JtcyhTKS5kZWNsYXJlVmFyaWFibGVzKGcseCwkLGgsXyx5KX1cbiAgJHt1Lm1haW5TdGFydChbYSxhLDFdKX1cbiAgICBsZXQgYmF0Y2hJbmRleCA9IHdvcmtncm91cF9pZC56IC8gdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgIGxldCBoZWFkTnVtYmVyID0gd29ya2dyb3VwX2lkLnogJSB1bmlmb3Jtcy5udW1faGVhZHM7XG4gICAgbGV0IG0gPSBnbG9iYWxfaWQueTtcbiAgICBsZXQgbiA9IGdsb2JhbF9pZC54O1xuXG4gICAgbGV0IGlucHV0T2Zmc2V0ID0gYmF0Y2hJbmRleCAqICh1bmlmb3Jtcy5NICogdW5pZm9ybXMuSykgKyBtICogdW5pZm9ybXMuSztcbiAgICBsZXQgYmlhc09mZnNldFEgPSBoZWFkTnVtYmVyICogdW5pZm9ybXMuaGVhZF9zaXplO1xuICAgIGxldCBiaWFzT2Zmc2V0SyA9IHVuaWZvcm1zLmhpZGRlbl9zaXplICsgYmlhc09mZnNldFE7XG4gICAgbGV0IGJpYXNPZmZzZXRWID0gdW5pZm9ybXMuaGlkZGVuX3NpemUgKyBiaWFzT2Zmc2V0SztcblxuICAgIHZhciB2YWx1ZVEgPSAke3Z9KDApO1xuICAgIHZhciB2YWx1ZUsgPSAke3Z9KDApO1xuICAgIHZhciB2YWx1ZVYgPSAke3Z9KDApO1xuICAgIGZvciAodmFyIHc6IHUzMiA9IDB1OyB3IDwgdW5pZm9ybXMuSzsgdyArPSBUSUxFX1NJWkUpIHtcbiAgICAgIGlmIChtIDwgdW5pZm9ybXMuTSAmJiB3ICsgbG9jYWxfaWQueCA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdGlsZUlucHV0W1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IGlucHV0W2lucHV0T2Zmc2V0ICsgdyArIGxvY2FsX2lkLnhdO1xuICAgICAgfVxuICAgICAgaWYgKG4gPCB1bmlmb3Jtcy5OICYmIHcgKyBsb2NhbF9pZC55IDwgdW5pZm9ybXMuSykge1xuICAgICAgICBsZXQgb2Zmc2V0ID0gbiArICh3ICsgbG9jYWxfaWQueSkgKiB1bmlmb3Jtcy5sZGI7XG4gICAgICAgIHRpbGVXZWlnaHRRW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IHdlaWdodFtiaWFzT2Zmc2V0USArIG9mZnNldF07XG4gICAgICAgIHRpbGVXZWlnaHRLW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IHdlaWdodFtiaWFzT2Zmc2V0SyArIG9mZnNldF07XG4gICAgICAgIHRpbGVXZWlnaHRWW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IHdlaWdodFtiaWFzT2Zmc2V0ViArIG9mZnNldF07XG4gICAgICB9XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgICBmb3IgKHZhciBrOiB1MzIgPSAwdTsgazxUSUxFX1NJWkUgJiYgdytrIDwgdW5pZm9ybXMuSzsgaysrKSB7XG4gICAgICAgIGxldCBpbnB1dFRpbGVPZmZzZXQgPSBUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgaztcbiAgICAgICAgbGV0IHdlaWdodFRpbGVPZmZzZXQgPSBUSUxFX1NJWkUgKiBrICsgbG9jYWxfaWQueDtcbiAgICAgICAgdmFsdWVRICs9IHRpbGVJbnB1dFtpbnB1dFRpbGVPZmZzZXRdICogdGlsZVdlaWdodFFbd2VpZ2h0VGlsZU9mZnNldF07XG4gICAgICAgIHZhbHVlSyArPSB0aWxlSW5wdXRbaW5wdXRUaWxlT2Zmc2V0XSAqIHRpbGVXZWlnaHRLW3dlaWdodFRpbGVPZmZzZXRdO1xuICAgICAgICB2YWx1ZVYgKz0gdGlsZUlucHV0W2lucHV0VGlsZU9mZnNldF0gKiB0aWxlV2VpZ2h0Vlt3ZWlnaHRUaWxlT2Zmc2V0XTtcbiAgICAgIH1cblxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgIH1cblxuICAgIGxldCBoZWFkT2Zmc2V0ID0gKG0gKiB1bmlmb3Jtcy5OICsgbikgJSB1bmlmb3Jtcy5oZWFkX3NpemU7XG4gICAgdmFsdWVRICs9IGJpYXNbaGVhZE9mZnNldCArIGJpYXNPZmZzZXRRXTtcbiAgICB2YWx1ZUsgKz0gYmlhc1toZWFkT2Zmc2V0ICsgYmlhc09mZnNldEtdO1xuICAgIHZhbHVlViArPSBiaWFzW2hlYWRPZmZzZXQgKyBiaWFzT2Zmc2V0Vl07XG5cbiAgICBsZXQgb2Zmc2V0ID0gd29ya2dyb3VwX2lkLnogKiB1bmlmb3Jtcy5NICogdW5pZm9ybXMuTjtcbiAgICBpZiAobSA8IHVuaWZvcm1zLk0gJiYgbiA8IHVuaWZvcm1zLk4pIHtcbiAgICAgIGxldCBvdXRwdXRJZHggPSBvZmZzZXQgKyBtICogdW5pZm9ybXMuTiArIG47XG4gICAgICBvdXRwdXRfcVtvdXRwdXRJZHhdID0gdmFsdWVRO1xuICAgICAgb3V0cHV0X2tbb3V0cHV0SWR4XSA9IHZhbHVlSztcbiAgICAgIG91dHB1dF92W291dHB1dElkeF0gPSB2YWx1ZVY7XG4gICAgfVxuICB9YH07cmV0dXJuIGUuY29tcHV0ZSh7bmFtZTpcIkF0dGVudGlvblByZXBhcmVcIixzaGFkZXJDYWNoZTp7aW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiLFwidHlwZVwiLFwidHlwZVwiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpyLGRhdGFUeXBlOmUuaW5wdXRzWzBdLmRhdGFUeXBlLGdwdURhdGFUeXBlOjB9LHtkaW1zOnIsZGF0YVR5cGU6ZS5pbnB1dHNbMF0uZGF0YVR5cGUsZ3B1RGF0YVR5cGU6MH0se2RpbXM6cixkYXRhVHlwZTplLmlucHV0c1swXS5kYXRhVHlwZSxncHVEYXRhVHlwZTowfV0sZGlzcGF0Y2hHcm91cDpkLHByb2dyYW1Vbmlmb3JtczpwfSksZ2V0U2hhZGVyU291cmNlOm19LHtpbnB1dHM6bCxvdXRwdXRzOlstMSwtMSwtMV19KX0senM9KGUsdCk9PntsZXQgcj1CbShlLmlucHV0cyx0KSxbbixvLGldPU5tKGUscik7cmV0dXJuIFJ0KGUsbixvLGksZS5pbnB1dHNbNF0sdm9pZCAwLHZvaWQgMCx2b2lkIDAsZS5pbnB1dHNbNV0scil9fSk7dmFyIFZtLFdtLExtLE9zLERzPVUoKCk9PntcInVzZSBzdHJpY3RcIjtXZSgpO3RlKCk7b2UoKTtTZSgpO2FlKCk7Vm09KGUsdCk9PntpZighZXx8ZS5sZW5ndGghPT01KXRocm93IG5ldyBFcnJvcihcIkJhdGNoTm9ybWFsaXphdGlvbiByZXF1aXJlcyA1IGlucHV0c1wiKTtsZXQgcj0obixvLGkpPT57bGV0IGE9by5sZW5ndGg7aWYoYSE9PW4ubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgJHtpfTogbnVtIGRpbWVuc2lvbnMgIT0gJHthfWApO28uZm9yRWFjaCgoZCxsKT0+e2lmKGQhPT1uW2xdKXRocm93IG5ldyBFcnJvcihgJHtpfTogZGltWyR7bH1dIGRvIG5vdCBtYXRjaGApfSl9O2lmKGVbMF0uZGltcy5sZW5ndGg+MSl7bGV0IG49dC5mb3JtYXQ9PT1cIk5IV0NcIj90LnNwYXRpYWw/ZVswXS5kaW1zLnNsaWNlKC0xKTplWzBdLmRpbXMuc2xpY2UoLTEpLmNvbmNhdChlWzBdLmRpbXMuc2xpY2UoMSxlWzBdLmRpbXMubGVuZ3RoLTEpKTplWzBdLmRpbXMuc2xpY2UoMSx0LnNwYXRpYWw/Mjp2b2lkIDApO3IoZVsxXS5kaW1zLG4sXCJJbnZhbGlkIGlucHV0IHNjYWxlXCIpLHIoZVsyXS5kaW1zLG4sXCJJbnZhbGlkIGlucHV0IEJcIikscihlWzNdLmRpbXMsbixcIkludmFsaWQgaW5wdXQgbWVhblwiKSxyKGVbNF0uZGltcyxuLFwiSW52YWxpZCBpbnB1dCB2YXJcIil9ZWxzZSByKGVbMV0uZGltcyxbMV0sXCJJbnZhbGlkIGlucHV0IHNjYWxlXCIpLHIoZVsyXS5kaW1zLFsxXSxcIkludmFsaWQgaW5wdXQgQlwiKSxyKGVbM10uZGltcyxbMV0sXCJJbnZhbGlkIGlucHV0IG1lYW5cIikscihlWzRdLmRpbXMsWzFdLFwiSW52YWxpZCBpbnB1dCB2YXJcIil9LFdtPShlLHQpPT57bGV0e2Vwc2lsb246cixzcGF0aWFsOm4sZm9ybWF0Om99PXQsaT1lWzBdLmRpbXMsYT1uP21lKGlbaS5sZW5ndGgtMV0pOjEsZD1vPT09XCJOSFdDXCImJmkubGVuZ3RoPjE/YToxLGw9Qy5zaXplKGkpL2EscD1uLG09cD9pLmxlbmd0aDppLHU9RShcInhcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcyxhKSxoPUUoXCJzY2FsZVwiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zLGQpLF89RShcImJpYXNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcyxkKSx5PUUoXCJpbnB1dE1lYW5cIixlWzNdLmRhdGFUeXBlLGVbM10uZGltcyxkKSxnPUUoXCJpbnB1dFZhclwiLGVbNF0uZGF0YVR5cGUsZVs0XS5kaW1zLGQpLHg9TShcInlcIixlWzBdLmRhdGFUeXBlLG0sYSksJD0oKT0+e2xldCBTPVwiXCI7aWYobilTPWBsZXQgY09mZnNldCA9ICR7aS5sZW5ndGg9PT0xP1wiMHVcIjpvPT09XCJOSFdDXCI/YG91dHB1dEluZGljZXNbJHtpLmxlbmd0aC0xfV0gLyAke2F9YDpcIm91dHB1dEluZGljZXNbMV1cIn07YDtlbHNlIGlmKG89PT1cIk5DSFdcIilTPWBcbiAgICAgICAgICAgICR7eC5pbmRpY2VzU2V0KFwib3V0cHV0SW5kaWNlc1wiLFwiMFwiLFwiMFwiKX1cbiAgICAgICAgICAgIGxldCBjT2Zmc2V0ID0gJHt4LmluZGljZXNUb09mZnNldChcIm91dHB1dEluZGljZXNcIil9O2A7ZWxzZXtTPWB2YXIgY0luZGljZXMgPSAke2gudHlwZS5pbmRpY2VzfSgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgY0luZGljZXNbMF0gPSBvdXRwdXRJbmRpY2VzWyR7aS5sZW5ndGgtMX1dO2A7Zm9yKGxldCBUPTE7VDxoLnJhbms7VCsrKVMrPWBjSW5kaWNlc1ske1R9XSA9IG91dHB1dEluZGljZXNbJHtUfV07YDtTKz1gbGV0IGNPZmZzZXQgPSAke2guaW5kaWNlc1RvT2Zmc2V0KFwiY0luZGljZXNcIil9O2B9cmV0dXJuIFN9LHY9Uz0+YFxuICBjb25zdCBlcHNpbG9uID0gJHtyfTtcbiAgJHtTLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dFNpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKHUsaCxfLHksZyx4KX1cbiAgJHtTLm1haW5TdGFydCgpfVxuICAke1MuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG4gICAgdmFyIG91dHB1dEluZGljZXMgPSAke3gub2Zmc2V0VG9JbmRpY2VzKGBnbG9iYWxfaWR4ICogJHthfWApfTtcbiAgICAkeyQoKX1cbiAgICBsZXQgc2NhbGUgPSAke2guZ2V0QnlPZmZzZXQoXCJjT2Zmc2V0XCIpfTtcbiAgICBsZXQgYmlhcyA9ICR7Xy5nZXRCeU9mZnNldChcImNPZmZzZXRcIil9O1xuICAgIGxldCBpbnB1dE1lYW4gPSAke3kuZ2V0QnlPZmZzZXQoXCJjT2Zmc2V0XCIpfTtcbiAgICBsZXQgaW5wdXRWYXIgPSAke2cuZ2V0QnlPZmZzZXQoXCJjT2Zmc2V0XCIpfTtcbiAgICBsZXQgeCA9ICR7dS5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIil9O1xuICAgIGxldCB2YWx1ZSA9ICh4IC0gaW5wdXRNZWFuKSAqIGludmVyc2VTcXJ0KGlucHV0VmFyICsgZXBzaWxvbikgKiBzY2FsZSArIGJpYXM7XG4gICAgJHt4LnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIil9XG4gIH1gO3JldHVybntuYW1lOlwiQmF0Y2hOb3JtYWxpemF0aW9uXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5lcHNpbG9ufV8ke3QuZm9ybWF0fV8ke259XyR7YX1gLGlucHV0RGVwZW5kZW5jaWVzOnA/W1wicmFua1wiLFwidHlwZVwiLFwidHlwZVwiLFwidHlwZVwiLFwidHlwZVwiXTp2b2lkIDB9LGdldFNoYWRlclNvdXJjZTp2LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6ZVswXS5kaW1zLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChsLzY0KX0scHJvZ3JhbVVuaWZvcm1zOnA/W3t0eXBlOjEyLGRhdGE6bH0sLi4uTihpKV06W3t0eXBlOjEyLGRhdGE6bH1dfSl9fSxMbT1lPT5yZShlKSxPcz0oZSx0KT0+e2xldHtpbnB1dHM6cixvdXRwdXRDb3VudDpufT1lLG89TG0oey4uLnQsb3V0cHV0Q291bnQ6bn0pO2lmKHZlLndlYmdwdS52YWxpZGF0ZUlucHV0Q29udGVudCYmVm0ocixvKSx0LnRyYWluaW5nTW9kZSl0aHJvdyBuZXcgRXJyb3IoXCJCYXRjaE5vcm1hbGl6YXRpb24gdHJhaW5pbmdNb2RlIGlzIG5vdCBzdXBwb3J0ZWQgeWV0LlwiKTtlLmNvbXB1dGUoV20ocixvKSl9fSk7dmFyIEdtLEhtLEJzLE1zPVUoKCk9PntcInVzZSBzdHJpY3RcIjtvZSgpO2FlKCk7R209ZT0+e2lmKGVbMF0uZGltcy5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcihcImlucHV0IHNob3VsZCBoYXZlIDMgZGltZW5zaW9uc1wiKTtpZighWzMyMCw2NDAsMTI4MF0uaW5jbHVkZXMoZVswXS5kaW1zWzJdKSl0aHJvdyBuZXcgRXJyb3IoXCJudW1iZXIgb2YgY2hhbm5lbHMgc2hvdWxkIGJlIDMyMCwgNjQwIG9yIDEyODBcIik7aWYoZVsxXS5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiYmlhcyBpcyBleHBlY3RlZCB0byBoYXZlIDEgZGltZW5zaW9uc1wiKTtpZihlWzBdLmRpbXNbMl0hPT1lWzFdLmRpbXNbMF0pdGhyb3cgbmV3IEVycm9yKFwibGFzdCBkaW1lbnNpb24gb2YgaW5wdXQgYW5kIGJpYXMgYXJlIG5vdCB0aGUgc2FtZVwiKX0sSG09ZT0+e2xldCB0PWVbMF0uZGltcyxyPWVbMF0uZGltc1syXSxuPUMuc2l6ZSh0KS80LG89ZVswXS5kYXRhVHlwZSxpPUUoXCJpbnB1dFwiLG8sdCw0KSxhPUUoXCJiaWFzXCIsbyxbcl0sNCksZD1FKFwicmVzaWR1YWxcIixvLHQsNCksbD1NKFwib3V0cHV0XCIsbyx0LDQpO3JldHVybntuYW1lOlwiQmlhc0FkZFwiLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6dCxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwobi82NCl9fSksZ2V0U2hhZGVyU291cmNlOm09PmBcbiAgY29uc3QgY2hhbm5lbHMgPSAke3J9dSAvIDQ7XG4gICR7bS5kZWNsYXJlVmFyaWFibGVzKGksYSxkLGwpfVxuXG4gICR7bS5tYWluU3RhcnQoKX1cbiAgICAke20uZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhuKX1cbiAgICBsZXQgdmFsdWUgPSAke2kuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpfVxuICAgICAgKyAke2EuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4ICUgY2hhbm5lbHNcIil9ICsgJHtkLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgJHtsLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIil9XG4gIH1gfX0sQnM9ZT0+e0dtKGUuaW5wdXRzKSxlLmNvbXB1dGUoSG0oZS5pbnB1dHMpKX19KTt2YXIgRm0sZmUsUnMsVXMsTnMsVnMsV3MsTHMsR3MsSHMsRnMscW0scXMsS3MsanMsWXMsWHQsWnMscXIsUXMsWHMsSnMsZXUsdHUscnUsbnUsb3UsaXUsYXUsc3UsdXUsZHUsbHUsY3UscHUsbXUsZnUsbW8sZm8saHUsZ3UsYnUsS20sam0seXUsS3I9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTtTZSgpO2FlKCk7Rm09KGUsdCxyLG4sbyxpLGEpPT57bGV0IGQ9TWF0aC5jZWlsKHQvNCksbD1cIlwiO3R5cGVvZiBvPT1cInN0cmluZ1wiP2w9YCR7b30oYSlgOmw9byhcImFcIik7bGV0IHA9RShcImlucHV0RGF0YVwiLHIsW2RdLDQpLG09TShcIm91dHB1dERhdGFcIixuLFtkXSw0KSx1PVt7bmFtZTpcInZlY19zaXplXCIsdHlwZTpcInUzMlwifV07cmV0dXJuIGEmJnUucHVzaCguLi5hKSxgXG4gICAgICAke2UucmVnaXN0ZXJVbmlmb3Jtcyh1KS5kZWNsYXJlVmFyaWFibGVzKHAsbSl9XG5cbiAgJHtpPz9cIlwifVxuXG4gICR7ZS5tYWluU3RhcnQoKX1cbiAgICAke2UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLnZlY19zaXplXCIpfVxuXG4gICAgbGV0IGEgPSAke3AuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAke20uc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsbCl9XG4gIH1gfSxmZT0oZSx0LHIsbixvLGk9ZS5kYXRhVHlwZSxhLGQpPT57bGV0IGw9W3t0eXBlOjEyLGRhdGE6TWF0aC5jZWlsKEMuc2l6ZShlLmRpbXMpLzQpfV07cmV0dXJuIGEmJmwucHVzaCguLi5hKSx7bmFtZTp0LHNoYWRlckNhY2hlOntoaW50Om8saW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiXX0sZ2V0U2hhZGVyU291cmNlOnA9PkZtKHAsQy5zaXplKGUuZGltcyksZS5kYXRhVHlwZSxpLHIsbixkKSxnZXRSdW5EYXRhOnA9Pih7b3V0cHV0czpbe2RpbXM6ZS5kaW1zLGRhdGFUeXBlOml9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChDLnNpemUocFswXS5kaW1zKS82NC80KX0scHJvZ3JhbVVuaWZvcm1zOmx9KX19LFJzPWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJBYnNcIixcImFic1wiKSl9LFVzPWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJBY29zXCIsXCJhY29zXCIpKX0sTnM9ZT0+e2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIkFjb3NoXCIsXCJhY29zaFwiKSl9LFZzPWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJBc2luXCIsXCJhc2luXCIpKX0sV3M9ZT0+e2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIkFzaW5oXCIsXCJhc2luaFwiKSl9LExzPWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJBdGFuXCIsXCJhdGFuXCIpKX0sR3M9ZT0+e2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIkF0YW5oXCIsXCJhdGFuaFwiKSl9LEhzPWU9PnJlKGUpLEZzPShlLHQpPT57bGV0IHI7c3dpdGNoKHQudG8pe2Nhc2UgMTA6cj1cInZlYzQ8ZjE2PlwiO2JyZWFrO2Nhc2UgMTpyPVwidmVjNDxmMzI+XCI7YnJlYWs7Y2FzZSAxMjpyPVwidmVjNDx1MzI+XCI7YnJlYWs7Y2FzZSA2OnI9XCJ2ZWM0PGkzMj5cIjticmVhaztjYXNlIDk6cj1cInZlYzQ8Ym9vbD5cIjticmVhaztkZWZhdWx0OnRocm93IG5ldyBSYW5nZUVycm9yKGBub3Qgc3VwcG9ydGVkIHR5cGUgKHNwZWNpZmllZCBpbiBhdHRyaWJ1dGUgJ3RvJyBmcm9tICdDYXN0JyBvcGVyYXRvcik6ICR7dC50b31gKX1lLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJDYXN0XCIscix2b2lkIDAsdC5jYWNoZUtleSx0LnRvKSl9LHFtPWU9PntsZXQgdCxyLG49ZS5sZW5ndGg+PTImJmVbMV0uZGF0YSE9PTAsbz1lLmxlbmd0aD49MyYmZVsyXS5kYXRhIT09MDtzd2l0Y2goZVswXS5kYXRhVHlwZSl7Y2FzZSAxOnQ9bj9lWzFdLmdldEZsb2F0MzJBcnJheSgpWzBdOi0zNDAyODIzNDY2Mzg1Mjg4NmUyMixyPW8/ZVsyXS5nZXRGbG9hdDMyQXJyYXkoKVswXTozNDAyODIzNDY2Mzg1Mjg4NmUyMjticmVhaztjYXNlIDEwOnQ9bj9lWzFdLmdldFVpbnQxNkFycmF5KClbMF06NjQ1MTEscj1vP2VbMl0uZ2V0VWludDE2QXJyYXkoKVswXTozMTc0MzticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydCBkYXRhIHR5cGVcIil9cmV0dXJuIHJlKHttaW46dCxtYXg6cn0pfSxxcz0oZSx0KT0+e2xldCByPXR8fHFtKGUuaW5wdXRzKSxuPUVlKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJDbGlwXCIsbz0+YGNsYW1wKCR7b30sIHZlYzQ8JHtufT4odW5pZm9ybXMubWluKSwgdmVjNDwke259Pih1bmlmb3Jtcy5tYXgpKWAsdm9pZCAwLHIuY2FjaGVLZXksdm9pZCAwLFt7dHlwZTplLmlucHV0c1swXS5kYXRhVHlwZSxkYXRhOnIubWlufSx7dHlwZTplLmlucHV0c1swXS5kYXRhVHlwZSxkYXRhOnIubWF4fV0sW3tuYW1lOlwibWluXCIsdHlwZTpufSx7bmFtZTpcIm1heFwiLHR5cGU6bn1dKSx7aW5wdXRzOlswXX0pfSxLcz1lPT57ZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiQ2VpbFwiLFwiY2VpbFwiKSl9LGpzPWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJDb3NcIixcImNvc1wiKSl9LFlzPWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJDb3NoXCIsXCJjb3NoXCIpKX0sWHQ9ZT0+cmUoZSksWnM9KGUsdCk9PntsZXQgcj1FZShlLmlucHV0c1swXS5kYXRhVHlwZSk7ZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiRWx1XCIsbj0+YGVsdV92ZjMyKCR7bn0pYCxgXG4gIGNvbnN0IGVsdV9hbHBoYV8gPSAke3J9KCR7dC5hbHBoYX0pO1xuXG4gIGZuIGVsdV9mMzIoYTogJHtyfSkgLT4gJHtyfSB7XG4gIHJldHVybiBzZWxlY3QoKGV4cChhKSAtIDEuMCkgKiBlbHVfYWxwaGFfLCBhLCBhID49IDAuMCk7XG4gIH1cblxuICBmbiBlbHVfdmYzMih2OiB2ZWM0PCR7cn0+KSAtPiB2ZWM0PCR7cn0+IHtcbiAgcmV0dXJuIHZlYzQoZWx1X2YzMih2LngpLCBlbHVfZjMyKHYueSksIGVsdV9mMzIodi56KSwgZWx1X2YzMih2LncpKTtcbiAgfWAsdC5jYWNoZUtleSkpfSxxcj0oZT1cImYzMlwiKT0+YFxuY29uc3QgcjA6ICR7ZX0gPSAwLjMyNzU5MTE7XG5jb25zdCByMTogJHtlfSA9IDAuMjU0ODI5NTkyO1xuY29uc3QgcjI6ICR7ZX0gPSAtMC4yODQ0OTY3MzY7XG5jb25zdCByMzogJHtlfSA9IDEuNDIxNDEzNzQxO1xuY29uc3QgcjQ6ICR7ZX0gPSAtMS40NTMxNTIwMjc7XG5jb25zdCByNTogJHtlfSA9IDEuMDYxNDA1NDI5O1xuXG5mbiBlcmZfdmYzMih2OiB2ZWM0PCR7ZX0+KSAtPiB2ZWM0PCR7ZX0+IHtcbiAgbGV0IGFic3YgPSBhYnModik7XG4gIGxldCB4ID0gMS4wIC8gKDEuMCArIHIwICogYWJzdik7XG4gIHJldHVybiBzaWduKHYpICogKDEuMCAtICgoKChyNSAqIHggKyByNCkgKiB4ICsgcjMpICogeCArIHIyKSAqIHggKyByMSkgKiB4ICogZXhwKC1hYnN2ICogYWJzdikpO1xufWAsUXM9ZT0+e2xldCB0PUVlKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJFcmZcIixyPT5gZXJmX3ZmMzIoJHtyfSlgLHFyKHQpKSl9LFhzPWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJFeHBcIixcImV4cFwiKSl9LEpzPWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJGbG9vclwiLFwiZmxvb3JcIikpfSxldT1lPT57bGV0IHQ9RWUoZS5pbnB1dHNbMF0uZGF0YVR5cGUpO2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIkdlbHVcIixyPT5gMC41ICogJHtyfSAqICgxLjAgKyBlcmZfdmYzMigke3J9ICogMC43MDcxMDY3ODExODY1NDc1KSlgLHFyKHQpKSl9LHR1PShlLHQpPT57bGV0IHI9RWUoZS5pbnB1dHNbMF0uZGF0YVR5cGUpO2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIkxlYWt5UmVsdVwiLG49PmBzZWxlY3QobGVha3lfcmVsdV9hbHBoYV8gKiAke259LCAke259LCAke259ID49IHZlYzQ8JHtyfT4oMC4wKSlgLGBjb25zdCBsZWFreV9yZWx1X2FscGhhXyA9ICR7cn0oJHt0LmFscGhhfSk7YCx0LmNhY2hlS2V5KSl9LHJ1PWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJOb3RcIix0PT5gISR7dH1gKSl9LG51PWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJOZWdcIix0PT5gLSR7dH1gKSl9LG91PWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJSZWNpcHJvY2FsXCIsdD0+YDEuMC8ke3R9YCkpfSxpdT1lPT57bGV0IHQ9RWUoZS5pbnB1dHNbMF0uZGF0YVR5cGUpO2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIlJlbHVcIixyPT5gc2VsZWN0KHZlYzQ8JHt0fT4oMC4wKSwgJHtyfSwgJHtyfSA+IHZlYzQ8JHt0fT4oMC4wKSlgKSl9LGF1PWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJTaWdtb2lkXCIsdD0+YCgxLjAgLyAoMS4wICsgZXhwKC0ke3R9KSkpYCkpfSxzdT1lPT5yZShlKSx1dT0oZSx0KT0+e2xldCByPUVlKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJIYXJkU2lnbW9pZFwiLG49PmBtYXgodmVjNDwke3J9PigwLjApLCBtaW4odmVjNDwke3J9PigxLjApLCAke3QuYWxwaGF9ICogJHtufSArIHZlYzQ8JHtyfT4oJHt0LmJldGF9KSkpYCx2b2lkIDAsdC5jYWNoZUtleSkpfSxkdT1lPT57ZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiU2luXCIsXCJzaW5cIikpfSxsdT1lPT57ZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiU2luaFwiLFwic2luaFwiKSl9LGN1PWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJTcXJ0XCIsXCJzcXJ0XCIpKX0scHU9ZT0+e2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIlRhblwiLFwidGFuXCIpKX0sbXU9ZT0+YHNpZ24oJHtlfSkgKiAoMSAtIGV4cCgtMiAqIGFicygke2V9KSkpIC8gKDEgKyBleHAoLTIgKiBhYnMoJHtlfSkpKWAsZnU9ZT0+e2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIlRhbmhcIixtdSkpfSxtbz0oZT1cImYzMlwiKT0+YFxuY29uc3QgZmFzdF9nZWx1X2E6ICR7ZX0gPSAwLjU7XG5jb25zdCBmYXN0X2dlbHVfYjogJHtlfSA9IDAuNzk3ODg0NTYwODAyODY1NDtcbmNvbnN0IGZhc3RfZ2VsdV9jOiAke2V9ID0gMC4wMzU2Nzc0MDgxMzYzMDAxMjU7XG5cbmZuIHRhbmhfdih2OiB2ZWM0PCR7ZX0+KSAtPiB2ZWM0PCR7ZX0+IHtcbiAgcmV0dXJuICR7bXUoXCJ2XCIpfTtcbn1cbmAsZm89ZT0+YChmYXN0X2dlbHVfYSArIGZhc3RfZ2VsdV9hICogdGFuaF92KCR7ZX0gKiAoZmFzdF9nZWx1X2MgKiAke2V9ICogJHtlfSArIGZhc3RfZ2VsdV9iKSkpICogJHtlfWAsaHU9ZT0+e2xldCB0PUVlKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJGYXN0R2VsdVwiLGZvLG1vKHQpLHZvaWQgMCxlLmlucHV0c1swXS5kYXRhVHlwZSkpfSxndT0oZSx0KT0+e2xldCByPUVlKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtyZXR1cm4gZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiVGhyZXNob2xkZWRSZWx1XCIsbj0+YHNlbGVjdCh2ZWM0PCR7cn0+KDAuMCksICR7bn0sICR7bn0gPiB0aHJlc2hvbGRlZF9yZWx1X2FscGhhXylgLGBjb25zdCB0aHJlc2hvbGRlZF9yZWx1X2FscGhhXyA9IHZlYzQ8JHtyfT4oJHt0LmFscGhhfSk7YCx0LmNhY2hlS2V5KSksMH0sYnU9ZT0+e2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIkxvZ1wiLFwibG9nXCIpKX0sS209KGUsdCk9PmBcbmNvbnN0IGFscGhhID0gdmVjNDwke2V9Pigke3R9KTtcbmNvbnN0IG9uZSA9ICR7ZX0oMS4wKTtcbmNvbnN0IHplcm8gPSAke2V9KDAuMCk7XG5cbmZuIHF1aWNrX2dlbHVfaW1wbCh4OiB2ZWM0PCR7ZX0+KSAtPiB2ZWM0PCR7ZX0+IHtcbiAgbGV0IHYgPSB4ICphbHBoYTtcbiAgdmFyIHgxIDogdmVjNDwke2V9PjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpID0gaSArIDEpIHtcbiAgICBpZiAodltpXSA+PSB6ZXJvKSB7XG4gICAgICB4MVtpXSA9IG9uZSAvIChvbmUgKyBleHAoLXZbaV0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeDFbaV0gPSBvbmUgLSBvbmUgLyAob25lICsgZXhwKHZbaV0pKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHggKiB4MTtcbn1cbmAsam09ZT0+YHF1aWNrX2dlbHVfaW1wbCgke2V9KWAseXU9KGUsdCk9PntsZXQgcj1FZShlLmlucHV0c1swXS5kYXRhVHlwZSk7ZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiUXVpY2tHZWx1XCIsam0sS20ocix0LmFscGhhKSx0LmNhY2hlS2V5LGUuaW5wdXRzWzBdLmRhdGFUeXBlKSl9fSk7dmFyIFltLFptLHd1LHZ1PVUoKCk9PntcInVzZSBzdHJpY3RcIjtvZSgpO2FlKCk7S3IoKTtZbT1lPT57aWYoZVswXS5kaW1zLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgc2hvdWxkIGhhdmUgMyBkaW1lbnNpb25zXCIpO2lmKCFbMjU2MCw1MTIwLDEwMjQwXS5pbmNsdWRlcyhlWzBdLmRpbXNbMl0pKXRocm93IG5ldyBFcnJvcihcImhpZGRlbiBzdGF0ZSBzaG91bGQgYmUgMjU2MCwgNTEyMCBvciAxMDI0MFwiKTtpZihlWzFdLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJiaWFzIGlzIGV4cGVjdGVkIHRvIGhhdmUgMSBkaW1lbnNpb25zXCIpO2lmKGVbMF0uZGltc1syXSE9PWVbMV0uZGltc1swXSl0aHJvdyBuZXcgRXJyb3IoXCJsYXN0IGRpbWVuc2lvbiBvZiBpbnB1dCBhbmQgYmlhcyBhcmUgbm90IHRoZSBzYW1lXCIpfSxabT1lPT57bGV0IHQ9ZVswXS5kaW1zLnNsaWNlKCk7dFsyXT10WzJdLzI7bGV0IHI9RShcImlucHV0XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMsNCksbj1FKFwiYmlhc1wiLGVbMF0uZGF0YVR5cGUsW2VbMF0uZGltc1syXV0sNCksbz1NKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSx0LDQpLGk9Qy5zaXplKHQpLzQsYT1fZShlWzBdLmRhdGFUeXBlKTtyZXR1cm57bmFtZTpcIkJpYXNTcGxpdEdlbHVcIixnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnQsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGkvNjQpfX0pLGdldFNoYWRlclNvdXJjZTpsPT5gXG4gIGNvbnN0IE1fU1FSVDIgPSBzcXJ0KDIuMCk7XG4gIGNvbnN0IGhhbGZDaGFubmVscyA9ICR7ZVswXS5kaW1zWzJdLzQvMn11O1xuXG4gICR7bC5kZWNsYXJlVmFyaWFibGVzKHIsbixvKX1cblxuICAke3FyKGEpfVxuXG4gICR7bC5tYWluU3RhcnQoKX1cbiAgICAke2wuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhpKX1cbiAgICBsZXQgYmlhc0lkeCA9IGdsb2JhbF9pZHggJSBoYWxmQ2hhbm5lbHM7XG4gICAgbGV0IGJhdGNoSW5kZXggPSBnbG9iYWxfaWR4IC8gaGFsZkNoYW5uZWxzO1xuICAgIGxldCBpbnB1dE9mZnNldCA9IGJpYXNJZHggKyBiYXRjaEluZGV4ICogaGFsZkNoYW5uZWxzICogMjtcbiAgICBsZXQgdmFsdWVMZWZ0ID0gaW5wdXRbaW5wdXRPZmZzZXRdICsgYmlhc1tiaWFzSWR4XTtcbiAgICBsZXQgdmFsdWVSaWdodCA9IGlucHV0W2lucHV0T2Zmc2V0ICsgaGFsZkNoYW5uZWxzXSArIGJpYXNbYmlhc0lkeCArIGhhbGZDaGFubmVsc107XG4gICAgbGV0IGdlbHVSaWdodCA9IHZhbHVlUmlnaHQgKiAwLjUgKiAoZXJmX3ZmMzIodmFsdWVSaWdodCAvIE1fU1FSVDIpICsgMSk7XG5cbiAgICAke28uc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZUxlZnQgKiBnZWx1UmlnaHRcIil9XG4gIH1gfX0sd3U9ZT0+e1ltKGUuaW5wdXRzKSxlLmNvbXB1dGUoWm0oZS5pbnB1dHMpKX19KTt2YXIgUW0sWG0sYXQsJHUseHUsU3UsVHUsSXUsQ3UsQXUsa3UsRXUsUHUsenU9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTthZSgpO1FtPShlLHQscixuLG8saSxhLGQsbCxwLG0sdSk9PntsZXQgaCxfO3R5cGVvZiBkPT1cInN0cmluZ1wiP2g9Xz0odixTKT0+YCR7ZH0oKCR7dn0pLCgke1N9KSlgOnR5cGVvZiBkPT1cImZ1bmN0aW9uXCI/aD1fPWQ6KGg9ZC5zY2FsYXIsXz1kLnZlY3Rvcik7bGV0IHk9TShcIm91dHB1dERhdGFcIixtLG4ubGVuZ3RoLDQpLGc9RShcImFEYXRhXCIsbCx0Lmxlbmd0aCw0KSx4PUUoXCJiRGF0YVwiLHAsci5sZW5ndGgsNCksJDtpZihvKWlmKGkpe2xldCB2PUMuc2l6ZSh0KT09PTEsUz1DLnNpemUocik9PT0xLFQ9dC5sZW5ndGg+MCYmdFt0Lmxlbmd0aC0xXSU0PT09MCxBPXIubGVuZ3RoPjAmJnJbci5sZW5ndGgtMV0lND09PTA7dnx8Uz8kPXkuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXyh2P2Ake2cudHlwZS52YWx1ZX0oJHtnLmdldEJ5T2Zmc2V0KFwiMFwiKX0ueClgOmcuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpLFM/YCR7eC50eXBlLnZhbHVlfSgke3guZ2V0QnlPZmZzZXQoXCIwXCIpfS54KWA6eC5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIikpKTokPWBcbiAgICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHt5Lm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHggKiA0dVwiKX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0QSA9ICR7Zy5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChcIm91dHB1dEluZGljZXNcIix5KX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0QiA9ICR7eC5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChcIm91dHB1dEluZGljZXNcIix5KX07XG4gICAgICAgICAgICAke3kuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXyhhfHxUP2cuZ2V0QnlPZmZzZXQoXCJvZmZzZXRBIC8gNHVcIik6YCR7Zy50eXBlLnZhbHVlfSgke2cuZ2V0QnlPZmZzZXQoXCJvZmZzZXRBIC8gNHVcIil9W29mZnNldEEgJSA0dV0pYCxhfHxBP3guZ2V0QnlPZmZzZXQoXCJvZmZzZXRCIC8gNHVcIik6YCR7eC50eXBlLnZhbHVlfSgke3guZ2V0QnlPZmZzZXQoXCJvZmZzZXRCIC8gNHVcIil9W29mZnNldEIgJSA0dV0pYCkpfVxuICAgICAgICAgIGB9ZWxzZSAkPXkuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXyhnLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSx4LmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSkpO2Vsc2V7aWYoIWkpdGhyb3cgbmV3IEVycm9yKFwibm8gbmVjZXNzYXJ5IHRvIHVzZSBzY2FsYXIgaW1wbGVtZW50YXRpb24gZm9yIGVsZW1lbnQtd2lzZSBiaW5hcnkgb3AgaW1wbGVtZW50YXRpb24uXCIpO2xldCB2PShTLFQsQT1cIlwiKT0+e2xldCBrPWBhRGF0YVtpbmRleEEke1R9XVtjb21wb25lbnRBJHtUfV1gLFA9YGJEYXRhW2luZGV4QiR7VH1dW2NvbXBvbmVudEIke1R9XWA7cmV0dXJuYFxuICAgICAgICAgICAgbGV0IG91dHB1dEluZGljZXMke1R9ID0gJHt5Lm9mZnNldFRvSW5kaWNlcyhgZ2xvYmFsX2lkeCAqIDR1ICsgJHtUfXVgKX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0QSR7VH0gPSAke2cuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dEluZGljZXMke1R9YCx5KX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0QiR7VH0gPSAke3guYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dEluZGljZXMke1R9YCx5KX07XG4gICAgICAgICAgICBsZXQgaW5kZXhBJHtUfSA9IG9mZnNldEEke1R9IC8gNHU7XG4gICAgICAgICAgICBsZXQgaW5kZXhCJHtUfSA9IG9mZnNldEIke1R9IC8gNHU7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50QSR7VH0gPSBvZmZzZXRBJHtUfSAlIDR1O1xuICAgICAgICAgICAgbGV0IGNvbXBvbmVudEIke1R9ID0gb2Zmc2V0QiR7VH0gJSA0dTtcbiAgICAgICAgICAgICR7U31bJHtUfV0gPSAke0F9KCR7aChrLFApfSk7XG4gICAgICAgICAgYH07bT09PTk/JD1gXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHZlYzQ8dTMyPigwKTtcbiAgICAgICAgICAgICR7dihcImRhdGFcIiwwLFwidTMyXCIpfVxuICAgICAgICAgICAgJHt2KFwiZGF0YVwiLDEsXCJ1MzJcIil9XG4gICAgICAgICAgICAke3YoXCJkYXRhXCIsMixcInUzMlwiKX1cbiAgICAgICAgICAgICR7dihcImRhdGFcIiwzLFwidTMyXCIpfVxuICAgICAgICAgICAgb3V0cHV0RGF0YVtnbG9iYWxfaWR4XSA9IGRvdCh2ZWM0PHUzMj4oMHgxLCAweDEwMCwgMHgxMDAwMCwgMHgxMDAwMDAwKSwgdmVjNDx1MzI+KGRhdGEpKTtgOiQ9YFxuICAgICAgICAgICAgJHt2KFwib3V0cHV0RGF0YVtnbG9iYWxfaWR4XVwiLDApfVxuICAgICAgICAgICAgJHt2KFwib3V0cHV0RGF0YVtnbG9iYWxfaWR4XVwiLDEpfVxuICAgICAgICAgICAgJHt2KFwib3V0cHV0RGF0YVtnbG9iYWxfaWR4XVwiLDIpfVxuICAgICAgICAgICAgJHt2KFwib3V0cHV0RGF0YVtnbG9iYWxfaWR4XVwiLDMpfVxuICAgICAgICAgIGB9cmV0dXJuYFxuICAgICAgICAke2UucmVnaXN0ZXJVbmlmb3JtKFwidmVjX3NpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKGcseCx5KX1cblxuICAgICAgICAke3U/P1wiXCJ9XG5cbiAgICAgICAgJHtlLm1haW5TdGFydCgpfVxuICAgICAgICAke2UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLnZlY19zaXplXCIpfVxuICAgICAgICAkeyR9XG4gICAgICB9YH0sWG09KGUsdCxyLG4sbyxpLGE9ci5kYXRhVHlwZSk9PntsZXQgZD1yLmRpbXMubWFwKGc9Pk51bWJlcihnKT8/MSksbD1uLmRpbXMubWFwKGc9Pk51bWJlcihnKT8/MSkscD0hQy5hcmVFcXVhbChkLGwpLG09ZCx1PUMuc2l6ZShkKSxoPSExLF89ITEseT1bcF07aWYocCl7bGV0IGc9dHQuY2FsY1NoYXBlKGQsbCwhMSk7aWYoIWcpdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgcGVyZm9ybSBiaW5hcnkgb3Agb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7bT1nLnNsaWNlKCksdT1DLnNpemUobSk7bGV0IHg9Qy5zaXplKGQpPT09MSwkPUMuc2l6ZShsKT09PTEsdj1kLmxlbmd0aD4wJiZkW2QubGVuZ3RoLTFdJTQ9PT0wLFM9bC5sZW5ndGg+MCYmbFtsLmxlbmd0aC0xXSU0PT09MDt5LnB1c2goeCkseS5wdXNoKCQpLHkucHVzaCh2KSx5LnB1c2goUyk7bGV0IFQ9MTtmb3IobGV0IEE9MTtBPG0ubGVuZ3RoO0ErKyl7bGV0IGs9ZFtkLmxlbmd0aC1BXSxQPWxbbC5sZW5ndGgtQV07aWYoaz09PVApVCo9aztlbHNlIGJyZWFrfVQlND09PTA/KF89ITAsaD0hMCk6KHh8fCR8fHZ8fFMpJiYoaD0hMCl9ZWxzZSBoPSEwO3JldHVybiB5LnB1c2goaCkse25hbWU6ZSxzaGFkZXJDYWNoZTp7aGludDp0K3kubWFwKGc9PmcudG9TdHJpbmcoKSkuam9pbihcIl9cIiksaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiLFwicmFua1wiXX0sZ2V0U2hhZGVyU291cmNlOmc9PlFtKGcsZCxsLG0saCxwLF8sbyxyLmRhdGFUeXBlLG4uZGF0YVR5cGUsYSxpKSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm0sZGF0YVR5cGU6YX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHUvNjQvNCl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTpNYXRoLmNlaWwoQy5zaXplKG0pLzQpfSwuLi5OKGQsbCxtKV19KX19LGF0PShlLHQscixuLG8saSk9PntlLmNvbXB1dGUoWG0odCxvPz9cIlwiLGUuaW5wdXRzWzBdLGUuaW5wdXRzWzFdLHIsbixpKSl9LCR1PWU9PnthdChlLFwiQWRkXCIsKHQscik9PmAke3R9KyR7cn1gKX0seHU9ZT0+e2F0KGUsXCJEaXZcIiwodCxyKT0+YCR7dH0vJHtyfWApfSxTdT1lPT57YXQoZSxcIkVxdWFsXCIse3NjYWxhcjoodCxyKT0+YHUzMigke3R9PT0ke3J9KWAsdmVjdG9yOih0LHIpPT5gdmVjNDx1MzI+KCR7dH09PSR7cn0pYH0sdm9pZCAwLHZvaWQgMCw5KX0sVHU9ZT0+e2F0KGUsXCJNdWxcIiwodCxyKT0+YCR7dH0qJHtyfWApfSxJdT1lPT57bGV0IHQ9RShcImlucHV0XCIsZS5pbnB1dHNbMF0uZGF0YVR5cGUsZS5pbnB1dHNbMF0uZGltcykudHlwZS52YWx1ZTthdChlLFwiUG93XCIse3NjYWxhcjoobixvKT0+YHBvd19jdXN0b20oJHtufSwke299KWAsdmVjdG9yOihuLG8pPT5gcG93X3ZlY3Rvcl9jdXN0b20oJHtufSwke299KWB9LGBcbiAgICBmbiBwb3dfY3VzdG9tKGEgOiAke3R9LCBiIDogJHt0fSkgLT4gJHt0fSB7XG4gICAgICBpZiAoYiA9PSAke3R9KDAuMCkpIHtcbiAgICAgICAgcmV0dXJuICR7dH0oMS4wKTtcbiAgICAgIH0gZWxzZSBpZiAoYSA8ICR7dH0oMC4wKSAmJiBmMzIoYikgIT0gZmxvb3IoZjMyKGIpKSkge1xuICAgICAgICByZXR1cm4gJHt0fShwb3coZjMyKGEpLCBmMzIoYikpKTsgLy8gTmFOXG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZWN0KHNpZ24oYSksICR7dH0oMS4wKSwgcm91bmQoZjMyKGFicyhiKSAlICR7dH0oMi4wKSkpICE9IDEuMCkgKiAke3R9KCR7dD09PVwiaTMyXCI/XCJyb3VuZFwiOlwiXCJ9KHBvdyhmMzIoYWJzKGEpKSwgZjMyKGIpKSkpO1xuICAgIH1cbiAgICBmbiBwb3dfdmVjdG9yX2N1c3RvbShhIDogdmVjNDwke3R9PiwgYiA6IHZlYzQ8JHt0fT4pIC0+IHZlYzQ8JHt0fT4ge1xuICAgICAgLy8gVE9ETzogaW1wbGVtZW50IHZlY3Rvcml6ZWQgcG93XG4gICAgICByZXR1cm4gdmVjNDwke3R9Pihwb3dfY3VzdG9tKGEueCwgYi54KSwgcG93X2N1c3RvbShhLnksIGIueSksIHBvd19jdXN0b20oYS56LCBiLnopLCBwb3dfY3VzdG9tKGEudywgYi53KSk7XG4gICAgfVxuICAgICAgYCl9LEN1PWU9PnthdChlLFwiU3ViXCIsKHQscik9PmAke3R9LSR7cn1gKX0sQXU9ZT0+e2F0KGUsXCJHcmVhdGVyXCIse3NjYWxhcjoodCxyKT0+YHUzMigke3R9PiR7cn0pYCx2ZWN0b3I6KHQscik9PmB2ZWM0PHUzMj4oJHt0fT4ke3J9KWB9LHZvaWQgMCx2b2lkIDAsOSl9LGt1PWU9PnthdChlLFwiTGVzc1wiLHtzY2FsYXI6KHQscik9PmB1MzIoJHt0fTwke3J9KWAsdmVjdG9yOih0LHIpPT5gdmVjNDx1MzI+KCR7dH08JHtyfSlgfSx2b2lkIDAsdm9pZCAwLDkpfSxFdT1lPT57YXQoZSxcIkdyZWF0ZXJPckVxdWFsXCIse3NjYWxhcjoodCxyKT0+YHUzMigke3R9Pj0ke3J9KWAsdmVjdG9yOih0LHIpPT5gdmVjNDx1MzI+KCR7dH0+PSR7cn0pYH0sdm9pZCAwLHZvaWQgMCw5KX0sUHU9ZT0+e2F0KGUsXCJMZXNzT3JFcXVhbFwiLHtzY2FsYXI6KHQscik9PmB1MzIoJHt0fTw9JHtyfSlgLHZlY3RvcjoodCxyKT0+YHZlYzQ8dTMyPigke3R9PD0ke3J9KWB9LHZvaWQgMCx2b2lkIDAsOSl9fSk7dmFyIGVmLHRmLHJmLG5mLE91LER1LEJ1PVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7U2UoKTthZSgpO2VmPShlLHQpPT57aWYoIWV8fGUubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKFwidG9vIGZldyBpbnB1dHNcIik7bGV0IHI9MCxuPWVbcl0sbz1uLmRhdGFUeXBlLGk9bi5kaW1zLmxlbmd0aDtlLmZvckVhY2goKGEsZCk9PntpZihkIT09cil7aWYoYS5kYXRhVHlwZSE9PW8pdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgdGVuc29ycyBzaG91bGQgYmUgb25lIHR5cGVcIik7aWYoYS5kaW1zLmxlbmd0aCE9PWkpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgdGVuc29ycyBzaG91bGQgaGF2ZSB0aGUgc2FtZSBzaGFwZVwiKTthLmRpbXMuZm9yRWFjaCgobCxwKT0+e2lmKHAhPT10JiZsIT09bi5kaW1zW3BdKXRocm93IG5ldyBFcnJvcihcIm5vbiBjb25jYXQgZGltZW5zaW9ucyBtdXN0IG1hdGNoXCIpfSl9fSl9LHRmPShlLHQpPT5gXG4gIGZuIGNhbGN1bGF0ZUlucHV0SW5kZXgoaW5kZXg6IHUzMikgLT4gdTMyIHtcbiAgICBsZXQgc2l6ZUluQ29uY2F0QXhpcyA9IGFycmF5PHUzMiwgJHtlfXU+KCR7dH0pO1xuICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgJHtlfTsgaSArPSAxdSApIHtcbiAgICAgIGlmIChpbmRleCA8IHNpemVJbkNvbmNhdEF4aXNbaV0pIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAke2V9dTtcbiAgfWAscmY9KGUsdCk9PntsZXQgcj1lLmxlbmd0aCxuPVtdO2ZvcihsZXQgbz0wO288cjsrK28pe2xldCBpPXQuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsZVtvXS5nZXRCeUluZGljZXMoXCJpbmRpY2VzXCIpKTtyPT09MT9uLnB1c2goaSk6bz09PTA/bi5wdXNoKGBpZiAoaW5wdXRJbmRleCA9PSAke299dSkgeyAke2l9IH1gKTpvPT09ci0xP24ucHVzaChgZWxzZSB7ICR7aX0gfWApOm4ucHVzaChgZWxzZSBpZiAoaW5wdXRJbmRleCA9PSAke299KSB7ICR7aX0gfWApfXJldHVybiBuLmpvaW4oYFxuYCl9LG5mPShlLHQscixuKT0+e2xldCBvPUMuc2l6ZShyKSxpPW5ldyBBcnJheShlLmxlbmd0aCksYT1uZXcgQXJyYXkoZS5sZW5ndGgpLGQ9MCxsPVtdLHA9W10sbT1be3R5cGU6MTIsZGF0YTpvfV07Zm9yKGxldCBnPTA7ZzxlLmxlbmd0aDsrK2cpZCs9ZVtnXS5kaW1zW3RdLGlbZ109ZCxwLnB1c2goZVtnXS5kaW1zLmxlbmd0aCksYVtnXT1FKGBpbnB1dCR7Z31gLG4scFtnXSksbC5wdXNoKFwicmFua1wiKSxtLnB1c2goe3R5cGU6MTIsZGF0YTppW2ddfSk7Zm9yKGxldCBnPTA7ZzxlLmxlbmd0aDsrK2cpbS5wdXNoKC4uLk4oZVtnXS5kaW1zKSk7bS5wdXNoKC4uLk4ocikpO2xldCB1PU0oXCJvdXRwdXRcIixuLHIubGVuZ3RoKSxoPXUuaW5kaWNlc0dldChcImluZGljZXNcIix0KSxfPUFycmF5LmZyb20oQXJyYXkoaS5sZW5ndGgpLmtleXMoKSkubWFwKGc9PmB1bmlmb3Jtcy5zaXplSW5Db25jYXRBeGlzJHtnfWApLmpvaW4oXCIsXCIpLHk9Zz0+YFxuXG4gICR7KCgpPT57Zy5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRTaXplXCIsXCJ1MzJcIik7Zm9yKGxldCB4PTA7eDxlLmxlbmd0aDt4KyspZy5yZWdpc3RlclVuaWZvcm0oYHNpemVJbkNvbmNhdEF4aXMke3h9YCxcInUzMlwiKTtyZXR1cm4gZy5kZWNsYXJlVmFyaWFibGVzKC4uLmEsdSl9KSgpfVxuXG4gICR7dGYoaS5sZW5ndGgsXyl9XG5cbiAgJHtnLm1haW5TdGFydCgpfVxuICAgICR7Zy5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0U2l6ZVwiKX1cblxuICAgIHZhciBpbmRpY2VzID0gJHt1Lm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuXG4gICAgbGV0IGlucHV0SW5kZXggPSBjYWxjdWxhdGVJbnB1dEluZGV4KCR7aH0pO1xuICAgIGlmIChpbnB1dEluZGV4ICE9IDB1KSB7XG4gICAgICBsZXQgc2l6ZUluQ29uY2F0QXhpcyA9IGFycmF5PHUzMiwgJHtpLmxlbmd0aH11Pigke199KTtcbiAgICAgICR7aH0gLT0gc2l6ZUluQ29uY2F0QXhpc1tpbnB1dEluZGV4IC0gMXVdO1xuICAgIH1cblxuICAgICR7cmYoYSx1KX1cbiAgfWA7cmV0dXJue25hbWU6XCJDb25jYXRcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0fWAsaW5wdXREZXBlbmRlbmNpZXM6bH0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpyLGRhdGFUeXBlOm59XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChvLzY0KX0scHJvZ3JhbVVuaWZvcm1zOm19KSxnZXRTaGFkZXJTb3VyY2U6eX19LE91PShlLHQpPT57bGV0IHI9ZS5pbnB1dHMsbj1yWzBdLmRpbXMsbz1DLm5vcm1hbGl6ZUF4aXModC5heGlzLG4ubGVuZ3RoKTtlZihyLG8pO2xldCBpPW4uc2xpY2UoKTtpW29dPXIucmVkdWNlKChkLGwpPT5kKyhsLmRpbXMubGVuZ3RoPm8/bC5kaW1zW29dOjApLDApO2xldCBhPXIuZmlsdGVyKGQ9PkMuc2l6ZShkLmRpbXMpPjApO2UuY29tcHV0ZShuZihhLG8saSxyWzBdLmRhdGFUeXBlKSx7aW5wdXRzOmF9KX0sRHU9ZT0+cmUoe2F4aXM6ZS5heGlzfSl9KTt2YXIgcWUsS2UsamUsanIseXQ9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTtxZT0oZSx0LHI9XCJmMzJcIik9Pntzd2l0Y2goZS5hY3RpdmF0aW9uKXtjYXNlXCJSZWx1XCI6cmV0dXJuYHZhbHVlID0gbWF4KHZhbHVlLCAke3R9KDAuMCkpO2A7Y2FzZVwiU2lnbW9pZFwiOnJldHVybmB2YWx1ZSA9ICgke3R9KDEuMCkgLyAoJHt0fSgxLjApICsgZXhwKC12YWx1ZSkpKTtgO2Nhc2VcIkNsaXBcIjpyZXR1cm5gdmFsdWUgPSBjbGFtcCh2YWx1ZSwgJHt0fSgke3J9KHVuaWZvcm1zLmNsaXBfbWluKSksICR7dH0oJHtyfSh1bmlmb3Jtcy5jbGlwX21heCkpKTtgO2Nhc2VcIkhhcmRTaWdtb2lkXCI6cmV0dXJuYHZhbHVlID0gbWF4KCR7dH0oMC4wKSwgbWluKCR7dH0oMS4wKSwgJHtyfSh1bmlmb3Jtcy5hbHBoYSkgKiB2YWx1ZSArICR7cn0odW5pZm9ybXMuYmV0YSkpKTtgO2Nhc2VcIkxlYWt5UmVsdVwiOnJldHVybmB2YWx1ZSA9IHNlbGVjdCgke3J9KHVuaWZvcm1zLmFscGhhKSAqIHZhbHVlLCB2YWx1ZSwgdmFsdWUgPj0gJHt0fSgwLjApKTtgO2Nhc2VcIlRhbmhcIjpyZXR1cm5gbGV0IGUyeCA9IGV4cCgtMi4wICogYWJzKHZhbHVlKSk7XG4gICAgICAgICAgICAgIHZhbHVlID0gc2lnbih2YWx1ZSkgKiAoMS4wIC0gZTJ4KSAvICgxLjAgKyBlMngpO1xuICAgICAgICBgO2Nhc2VcIlwiOnJldHVyblwiXCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGFjdGl2YXRpb24gJHtlLmFjdGl2YXRpb259YCl9fSxLZT0oZSx0KT0+e2UuYWN0aXZhdGlvbj09PVwiQ2xpcFwiP3QucHVzaCh7dHlwZToxLGRhdGE6ZS5jbGlwTWF4fSx7dHlwZToxLGRhdGE6ZS5jbGlwTWlufSk6ZS5hY3RpdmF0aW9uPT09XCJIYXJkU2lnbW9pZFwiP3QucHVzaCh7dHlwZToxLGRhdGE6ZS5hbHBoYX0se3R5cGU6MSxkYXRhOmUuYmV0YX0pOmUuYWN0aXZhdGlvbj09PVwiTGVha3lSZWx1XCImJnQucHVzaCh7dHlwZToxLGRhdGE6ZS5hbHBoYX0pfSxqZT0oZSx0KT0+e2UuYWN0aXZhdGlvbj09PVwiQ2xpcFwiP3QucHVzaCh7bmFtZTpcImNsaXBfbWF4XCIsdHlwZTpcImYzMlwifSx7bmFtZTpcImNsaXBfbWluXCIsdHlwZTpcImYzMlwifSk6ZS5hY3RpdmF0aW9uPT09XCJIYXJkU2lnbW9pZFwiP3QucHVzaCh7bmFtZTpcImFscGhhXCIsdHlwZTpcImYzMlwifSx7bmFtZTpcImJldGFcIix0eXBlOlwiZjMyXCJ9KTplLmFjdGl2YXRpb249PT1cIkxlYWt5UmVsdVwiJiZ0LnB1c2goe25hbWU6XCJhbHBoYVwiLHR5cGU6XCJmMzJcIn0pfSxqcj1lPT57bGV0IHQ9ZT8uYWN0aXZhdGlvbnx8XCJcIjtpZih0PT09XCJIYXJkU2lnbW9pZFwiKXtsZXRbcixuXT1lPy5hY3RpdmF0aW9uX3BhcmFtc3x8Wy4yLC41XTtyZXR1cm57YWN0aXZhdGlvbjp0LGFscGhhOnIsYmV0YTpufX1lbHNlIGlmKHQ9PT1cIkNsaXBcIil7bGV0W3Isbl09ZT8uYWN0aXZhdGlvbl9wYXJhbXN8fFtlcyx0c107cmV0dXJue2FjdGl2YXRpb246dCxjbGlwTWF4Om4sY2xpcE1pbjpyfX1lbHNlIGlmKHQ9PT1cIkxlYWt5UmVsdVwiKXtsZXRbcl09ZT8uYWN0aXZhdGlvbl9wYXJhbXN8fFsuMDFdO3JldHVybnthY3RpdmF0aW9uOnQsYWxwaGE6cn19cmV0dXJue2FjdGl2YXRpb246dH19fSk7dmFyIEFlLE11LFlyPVUoKCk9PntcInVzZSBzdHJpY3RcIjtBZT0oZSx0KT0+e3N3aXRjaChlKXtjYXNlIDE6cmV0dXJuIHQ7Y2FzZSAyOnJldHVybmB2ZWMyPCR7dH0+YDtjYXNlIDM6cmV0dXJuYHZlYzM8JHt0fT5gO2Nhc2UgNDpyZXR1cm5gdmVjNDwke3R9PmA7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYCR7ZX0tY29tcG9uZW50IGlzIG5vdCBzdXBwb3J0ZWQuYCl9fSxNdT1lPT5gXG4gICAgICAke2U/XCJ2YWx1ZSA9IHZhbHVlICsgZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3Jkcyk7XCI6XCJcIn1cbiAgICAgIGB9KTt2YXIgUnUsVXU9VSgoKT0+e1widXNlIHN0cmljdFwiO1J1PWU9PmBcbmZuIGdldEluZGV4RnJvbUNvb3JkczREKGNvb3JkcyA6IHZlYzQ8aTMyPiwgc2hhcGUgOiB2ZWM0PGkzMj4pIC0+IGkzMiB7XG4gIHJldHVybiBkb3QoY29vcmRzLCB2ZWM0PGkzMj4oXG4gICAgICBzaGFwZS55ICogc2hhcGUueiAqIHNoYXBlLncsIHNoYXBlLnogKiBzaGFwZS53LCBzaGFwZS53LCAxKSk7XG59XG5mbiBnZXRPdXRwdXRJbmRleEZyb21Db29yZHMoY29vcmRzIDogdmVjNDxpMzI+KSAtPiBpMzIge1xuICByZXR1cm4gZG90KGNvb3JkcywgdmVjNDxpMzI+KFxuICAgIGkzMigke2V9LngpLCBpMzIoJHtlfS55KSwgaTMyKCR7ZX0ueiksIDEpKTtcbn1cbmB9KTt2YXIgSnQsWnIsUXI9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTthZSgpO3l0KCk7SnQ9KGUsdCxyLG4sbyk9PntsZXQgaT1uLXI7cmV0dXJuYFxuICAgICAgJHtBcnJheS5mcm9tKHtsZW5ndGg6cn0pLm1hcCgoYSxkKT0+YFxuICAgICAgaWYgKCR7Rih0LnNoYXBlLGQsdC5yYW5rKX0gIT0gMSkge1xuICAgICAgICAke3QuaW5kaWNlc1NldChlLGQsRihvLGQraSxuKSl9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAke3QuaW5kaWNlc1NldChlLGQsMCl9XG4gICAgICB9YCkuam9pbihcIlwiKX1cbmB9LFpyPShlLHQscixuLG89ITEsaSk9PntsZXQgYT1lWzBdLmRpbXMsZD1lWzFdLmRpbXMsbD1hW2EubGVuZ3RoLTJdLHA9ZFtkLmxlbmd0aC0xXSxtPWFbYS5sZW5ndGgtMV0sdT1tZShwKSxoPW1lKG0pLF89bWUobCkseT1DLnNpemUocikvdS9fLGc9ZS5sZW5ndGg+Mix4PW4/bi5zbGljZSgwLC0yKTpyLnNsaWNlKDAsLTIpLHY9W0Muc2l6ZSh4KSxsLHBdLFM9W3t0eXBlOjEyLGRhdGE6eX0se3R5cGU6MTIsZGF0YTpsfSx7dHlwZToxMixkYXRhOnB9LHt0eXBlOjEyLGRhdGE6bX1dO0tlKHQsUyksUy5wdXNoKC4uLk4oeCxhLGQpKSxnJiZTLnB1c2goLi4uTihlWzJdLmRpbXMpKSxTLnB1c2goLi4uTih2KSk7bGV0IFQ9QT0+e2xldCBrPUxyKFwiYmF0Y2hfZGltc1wiLGVbMF0uZGF0YVR5cGUseC5sZW5ndGgpLFA9RShcImFcIixlWzBdLmRhdGFUeXBlLGEubGVuZ3RoLGgpLEQ9RShcImJcIixlWzFdLmRhdGFUeXBlLGQubGVuZ3RoLHUpLFI9TShcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsdi5sZW5ndGgsdSksRz1fZShSLnR5cGUudGVuc29yKSxLPXFlKHQsUi50eXBlLnZhbHVlLEcpLGo9W1AsRF0sVj1cIlwiO2lmKGcpe2xldCBZPW8/dToxO2oucHVzaChFKFwiYmlhc1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLmxlbmd0aCxZKSksVj1gJHtvP2B2YWx1ZSArPSBiaWFzW2NvbCAvICR7WX1dO2A6YHZhbHVlICs9ICR7Ui50eXBlLnZhbHVlfShiaWFzW3JvdyArIGldKTtgfWB9bGV0IFE9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiTVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJOXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIktcIix0eXBlOlwidTMyXCJ9XTtqZSh0LFEpO2xldCBzZT0oKT0+e2xldCBZPWB2YXIgYV9kYXRhOiAke1AudHlwZS52YWx1ZX07YDtmb3IobGV0IGVlPTA7ZWU8aDtlZSsrKVkrPWBcbiAgICAgICAgICAgICAgbGV0IGJfZGF0YSR7ZWV9ID0gYlsoYl9vZmZzZXQgKyAoayArICR7ZWV9KSAqIHVuaWZvcm1zLk4gKyBjb2wpIC8gJHt1fV07YDtmb3IobGV0IGVlPTA7ZWU8XztlZSsrKXtZKz1gYV9kYXRhID0gYVsoYV9vZmZzZXQgKyAocm93ICsgJHtlZX0pICogdW5pZm9ybXMuSyArIGspIC8gJHtofV07YDtmb3IobGV0IEo9MDtKPGg7SisrKVkrPWBcbiAgICAgICAgICAgIHZhbHVlc1ske2VlfV0gPSBmbWEoJHtELnR5cGUudmFsdWV9KGFfZGF0YSR7aD09PTE/XCJcIjpgWyR7Sn1dYH0pLCBiX2RhdGEke0p9LCB2YWx1ZXNbJHtlZX1dKTtcbmB9cmV0dXJuIFl9O3JldHVybmBcbiAgJHtBLnJlZ2lzdGVyVW5pZm9ybXMoUSkucmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlcyhrKS5kZWNsYXJlVmFyaWFibGVzKC4uLmosUil9XG4gICR7QS5tYWluU3RhcnQoKX1cbiAgICAke0EuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgIGxldCBjb2wgPSAoZ2xvYmFsX2lkeCAlICh1bmlmb3Jtcy5OIC8gJHt1fSkpICogJHt1fTtcbiAgICB2YXIgaW5kZXgxID0gZ2xvYmFsX2lkeCAvICh1bmlmb3Jtcy5OIC8gJHt1fSk7XG4gICAgbGV0IHN0cmlkZTEgPSB1bmlmb3Jtcy5NIC8gJHtffTtcbiAgICBsZXQgcm93ID0gKGluZGV4MSAlIHN0cmlkZTEpICogJHtffTtcbiAgICBsZXQgYmF0Y2ggPSBpbmRleDEgLyBzdHJpZGUxO1xuXG4gICAgJHtyLmxlbmd0aD09PTI/XCJcIjpgbGV0IGJhdGNoX2luZGljZXMgPSAke2sub2Zmc2V0VG9JbmRpY2VzKFwiYmF0Y2hcIil9O2B9XG5cbiAgICB2YXIgYV9pbmRpY2VzOiAke1AudHlwZS5pbmRpY2VzfTtcbiAgICAke0p0KFwiYV9pbmRpY2VzXCIsUCxQLnJhbmstMixrLnJhbmssXCJiYXRjaF9pbmRpY2VzXCIpfVxuICAgICR7UC5pbmRpY2VzU2V0KFwiYV9pbmRpY2VzXCIsUC5yYW5rLTIsMCl9XG4gICAgJHtQLmluZGljZXNTZXQoXCJhX2luZGljZXNcIixQLnJhbmstMSwwKX1cbiAgICBsZXQgYV9vZmZzZXQgPSAke1AuaW5kaWNlc1RvT2Zmc2V0KFwiYV9pbmRpY2VzXCIpfTtcblxuICAgIHZhciBiX2luZGljZXM6ICR7RC50eXBlLmluZGljZXN9O1xuICAgICR7SnQoXCJiX2luZGljZXNcIixELEQucmFuay0yLGsucmFuayxcImJhdGNoX2luZGljZXNcIil9XG4gICAgJHtELmluZGljZXNTZXQoXCJiX2luZGljZXNcIixELnJhbmstMiwwKX1cbiAgICAke0QuaW5kaWNlc1NldChcImJfaW5kaWNlc1wiLEQucmFuay0xLDApfVxuICAgIGxldCBiX29mZnNldCA9ICR7RC5pbmRpY2VzVG9PZmZzZXQoXCJiX2luZGljZXNcIil9O1xuICAgIHZhciB2YWx1ZXM6IGFycmF5PCR7Ui50eXBlLnZhbHVlfSwgJHtffT47XG4gICAgZm9yICh2YXIgazogdTMyID0gMHU7IGsgPCB1bmlmb3Jtcy5LOyBrID0gayArICR7aH0pIHtcbiAgICAgICR7c2UoKX1cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDB1OyBpIDwgJHtffXU7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgJHtWfVxuICAgICAgJHtLfVxuICAgICAgbGV0IGN1cl9pbmRpY2VzID0gJHtSLnR5cGUuaW5kaWNlc30oYmF0Y2gsIHJvdyArIGksIGNvbCk7XG4gICAgICBsZXQgb2Zmc2V0ID0gJHtSLmluZGljZXNUb09mZnNldChcImN1cl9pbmRpY2VzXCIpfTtcbiAgICAgICR7Ui5zZXRCeU9mZnNldChgb2Zmc2V0IC8gJHt1fWAsXCJ2YWx1ZVwiKX07XG4gICAgfVxuICB9XG4gIGB9O3JldHVybntuYW1lOlwiTWF0TXVsTmFpdmVcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmFjdGl2YXRpb259OyR7dX07JHtofTske199OyR7b31gLGlucHV0RGVwZW5kZW5jaWVzOmc/W1wicmFua1wiLFwicmFua1wiLFwicmFua1wiXTpbXCJyYW5rXCIsXCJyYW5rXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmk/aShyKTpyLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbCh5LzY0KX0scHJvZ3JhbVVuaWZvcm1zOlN9KSxnZXRTaGFkZXJTb3VyY2U6VH19fSk7dmFyIG9mLGFmLGhvLE51LHNmLGdvLHVmLGVyLFhyPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7YWUoKTt5dCgpO1FyKCk7WXIoKTtvZj0oZSx0KT0+ZT9gXG4gICAgICAgIG1tX0FzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRBKGJhdGNoLFxuICAgICAgICAgIGtTdGFydCArIGlucHV0Um93LFxuICAgICAgICAgIGdsb2JhbFJvd1N0YXJ0IC8gaW5uZXJFbGVtZW50U2l6ZSArIGlucHV0Q29sJHt0P1wiLCBiYXRjaEluZGljZXNcIjpcIlwifSk7XG4gICAgICAgIGA6YFxuICAgICAgICBtbV9Bc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQShiYXRjaCxcbiAgICAgICAgICBnbG9iYWxSb3cgKyBpbm5lclJvdyxcbiAgICAgICAgICBrU3RhcnQgLyBpbm5lckVsZW1lbnRTaXplICsgaW5wdXRDb2wke3Q/XCIsIGJhdGNoSW5kaWNlc1wiOlwiXCJ9KTtcbiAgICAgICAgYCxhZj0oZSx0KT0+ZT9gXG4gICAgICAgIGxldCBBQ2FjaGVkMCA9IG1tX0FzdWJbayAqIGlubmVyRWxlbWVudFNpemVdW2xvY2FsUm93XTtcbiAgICAgICAgbGV0IEFDYWNoZWQxID0gbW1fQXN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDFdW2xvY2FsUm93XTtcbiAgICAgICAgbGV0IEFDYWNoZWQyID0gbW1fQXN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDJdW2xvY2FsUm93XTtcbiAgICAgICAgJHt0PT09Mz9cIlwiOlwibGV0IEFDYWNoZWQzID0gbW1fQXN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDNdW2xvY2FsUm93XTtcIn1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dQZXJUaHJlYWQ7IGkgPSBpICsgMSkge1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQwICogQUNhY2hlZDBbaV0gKyBhY2NbaV07XG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDEgKiBBQ2FjaGVkMVtpXSArIGFjY1tpXTtcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMiAqIEFDYWNoZWQyW2ldICsgYWNjW2ldO1xuICAgICAgICAgICR7dD09PTM/XCJcIjpcImFjY1tpXSA9IEJDYWNoZWQzICogQUNhY2hlZDNbaV0gKyBhY2NbaV07XCJ9XG4gICAgICAgIH1gOmBcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dQZXJUaHJlYWQ7IGkgPSBpICsgMSkge1xuICAgICAgICAgIGxldCBBQ2FjaGVkID0gbW1fQXN1Ylt0aWxlUm93ICsgaV1ba107XG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDAgKiBBQ2FjaGVkLnggKyBhY2NbaV07XG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDEgKiBBQ2FjaGVkLnkgKyBhY2NbaV07XG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDIgKiBBQ2FjaGVkLnogKyBhY2NbaV07XG4gICAgICAgICAgJHt0PT09Mz9cIlwiOlwiYWNjW2ldID0gQkNhY2hlZDMgKiBBQ2FjaGVkLncgKyBhY2NbaV07XCJ9XG4gICAgICAgIH1gLGhvPShlLHQscj1cImYzMlwiLG4sbz0hMSxpPTMyLGE9ITEsZD0zMik9PntsZXQgbD10WzFdKmVbMV0scD10WzBdKmVbMF0sbT1vP2w6aSx1PW8/aTpsLGg9bS90WzBdLF89aS90WzFdO2lmKCEoKG8mJmg9PT00JiZlWzFdPT09NHx8IW8mJihoPT09M3x8aD09PTQpKSYmbSV0WzBdPT09MCYmaSV0WzFdPT09MCYmZVswXT09PTQpKXRocm93IG5ldyBFcnJvcihgSWYgdHJhbnNwb3NlQSAke299IGlzIHRydWUsIGlubmVyRWxlbWVudFNpemUgJHtofSBhbmQgd29ya1BlclRocmVhZFsxXSAke2VbMV19IG11c3QgYmUgNC5cbiAgICAgIE90aGVyd2lzZSwgaW5uZXJFbGVtZW50U2l6ZSAke2h9IG11c3QgYmUgMyBvciA0LlxuICB0aWxlQVdpZHRoICR7bX0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVswXSR7dFswXX0uIHRpbGVJbm5lciAke2l9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMV0gJHt0WzFdfS4gY29sUGVyVGhyZWFkICR7ZVswXX0gbXVzdCBiZSA0LmApO3JldHVybmBcbnZhcjx3b3JrZ3JvdXA+IG1tX0FzdWI6IGFycmF5PGFycmF5PHZlYyR7aH08JHtyfT4sICR7bS9ofT4sICR7dX0+O1xudmFyPHdvcmtncm91cD4gbW1fQnN1YjogYXJyYXk8YXJyYXk8dmVjNDwke3J9PiwgJHtwL2VbMF19PiwgJHtpfT47XG5cbmNvbnN0IHJvd1BlclRocmVhZCA9ICR7ZVsxXX07XG5jb25zdCBjb2xQZXJUaHJlYWQgPSAke2VbMF19O1xuY29uc3QgaW5uZXJFbGVtZW50U2l6ZSA9ICR7aH07XG5jb25zdCB0aWxlSW5uZXIgPSAke2l9O1xuXG5AY29tcHV0ZSBAd29ya2dyb3VwX3NpemUoJHt0WzBdfSwgJHt0WzFdfSwgJHt0WzJdfSlcbmZuIG1haW4oQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pZCkgbG9jYWxJZCA6IHZlYzM8dTMyPixcbiAgICAgICAgQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIGdsb2JhbElkIDogdmVjMzx1MzI+LFxuICAgICAgICBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cElkIDogdmVjMzx1MzI+KSB7XG4gIGxldCBsb2NhbFJvdyA9IGkzMihsb2NhbElkLnkpO1xuICBsZXQgdGlsZVJvdyA9IGxvY2FsUm93ICogcm93UGVyVGhyZWFkO1xuICBsZXQgdGlsZUNvbCA9IGkzMihsb2NhbElkLngpO1xuXG4gIGxldCBnbG9iYWxSb3cgPWkzMihnbG9iYWxJZC55KSAqIHJvd1BlclRocmVhZDtcbiAgbGV0IGdsb2JhbENvbCA9IGkzMihnbG9iYWxJZC54KTtcbiAgbGV0IGJhdGNoID0gJHthP1wiMFwiOlwiaTMyKGdsb2JhbElkLnopXCJ9O1xuICAke24/YGxldCBiYXRjaEluZGljZXMgPSAke24ub2Zmc2V0VG9JbmRpY2VzKFwidTMyKGJhdGNoKVwiKX07YDpcIlwifVxuICBsZXQgZ2xvYmFsUm93U3RhcnQgPSBpMzIod29ya2dyb3VwSWQueSkgKiAke2x9O1xuXG4gIGxldCBudW1fdGlsZXMgPSAke2E/YCR7TWF0aC5jZWlsKGQvaSl9YDpcIih1bmlmb3Jtcy5kaW1faW5uZXIgLSAxKSAvIHRpbGVJbm5lciArIDFcIn07XG4gIHZhciBrU3RhcnQgPSAke2E/YGkzMihnbG9iYWxJZC56KSAqICR7ZH1gOlwiMFwifTtcblxuICB2YXIgYWNjOiBhcnJheTx2ZWM0PCR7cn0+LCByb3dQZXJUaHJlYWQ+O1xuXG4gIC8vIExvb3Agb3ZlciBzaGFyZWQgZGltZW5zaW9uLlxuICBsZXQgdGlsZVJvd0IgPSBsb2NhbFJvdyAqICR7X307XG4gIGZvciAodmFyIHQgPSAwOyB0IDwgbnVtX3RpbGVzOyB0ID0gdCArIDEpIHtcbiAgICAgIC8vIExvYWQgb25lIHRpbGUgb2YgQSBpbnRvIGxvY2FsIG1lbW9yeS5cbiAgICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICAgICAgbGV0IGlucHV0Um93ID0gdGlsZVJvdyArIGlubmVyUm93O1xuICAgICAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2w7XG4gICAgICAgICAgJHtvZihvLG4pfVxuICAgICAgfVxuXG4gICAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIEIgaW50byBsb2NhbCBtZW1vcnkuXG4gICAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgJHtffTsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgICAgICBsZXQgaW5wdXRSb3cgPSB0aWxlUm93QiArIGlubmVyUm93O1xuICAgICAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2w7XG4gICAgICAgICAgbW1fQnN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEIoYmF0Y2gsIGtTdGFydCArIGlucHV0Um93LCBnbG9iYWxDb2wke24/XCIsIGJhdGNoSW5kaWNlc1wiOlwiXCJ9KTtcbiAgICAgIH1cbiAgICAgIGtTdGFydCA9IGtTdGFydCArIHRpbGVJbm5lcjtcbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgLy8gQ29tcHV0ZSBhY2MgdmFsdWVzIGZvciBhIHNpbmdsZSB0aHJlYWQuXG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRpbGVJbm5lciAvIGlubmVyRWxlbWVudFNpemU7IGsgPSBrICsgMSkge1xuICAgICAgICAgIGxldCBCQ2FjaGVkMCA9IG1tX0JzdWJbayAqIGlubmVyRWxlbWVudFNpemVdW3RpbGVDb2xdO1xuICAgICAgICAgIGxldCBCQ2FjaGVkMSA9IG1tX0JzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAxXVt0aWxlQ29sXTtcbiAgICAgICAgICBsZXQgQkNhY2hlZDIgPSBtbV9Cc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgMl1bdGlsZUNvbF07XG4gICAgICAgICAgJHtoPT09Mz9cIlwiOlwibGV0IEJDYWNoZWQzID0gbW1fQnN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDNdW3RpbGVDb2xdO1wifVxuXG4gICAgICAgICAgJHthZihvLGgpfVxuICAgICAgfVxuXG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gIH1cblxuICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgICAgbW1fd3JpdGUoYmF0Y2gsIGdsb2JhbFJvdyArIGlubmVyUm93LCBnbG9iYWxDb2wsIGFjY1tpbm5lclJvd10pO1xuICB9XG59YH0sTnU9KGUsdCk9PmU/YFxuICAgICAgICAgICAgbW1fQXN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEEoYmF0Y2gsXG4gICAgICAgICAgICAgIGtTdGFydCArIGlucHV0Um93LFxuICAgICAgICAgICAgICBnbG9iYWxSb3dTdGFydCArIGlucHV0Q29sJHt0P1wiLCBiYXRjaEluZGljZXNcIjpcIlwifSk7XG4gICAgICAgICAgICBgOmBcbiAgICAgICAgICAgIG1tX0FzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRBKGJhdGNoLFxuICAgICAgICAgICAgICBnbG9iYWxSb3dTdGFydCArIGlucHV0Um93LFxuICAgICAgICAgICAgICBrU3RhcnQgKyBpbnB1dENvbCR7dD9cIiwgYmF0Y2hJbmRpY2VzXCI6XCJcIn0pO1xuICAgICAgICAgICAgYCxzZj1lPT5lP1wibGV0IEFDYWNoZWQgPSBtbV9Bc3ViW2tdW3RpbGVSb3cgKyBpbm5lclJvd107XCI6XCJsZXQgQUNhY2hlZCA9IG1tX0FzdWJbdGlsZVJvdyArIGlubmVyUm93XVtrXTtcIixnbz0oZSx0LHI9XCJmMzJcIixuLG89ITEsaT0zMixhPSExLGQ9MzIsbD0hMSk9PntsZXQgcD1lWzFdKnRbMV0sbT1lWzBdKnRbMF0sdT1vP3A6aSxoPW8/aTpwO2lmKCEoaCV0WzFdPT09MCYmdSV0WzBdPT09MCYmaSV0WzFdPT09MCkpdGhyb3cgbmV3IEVycm9yKGB0aWxlQUhpZ2h0ICR7aH0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVsxXSR7dFsxXX0sIHRpbGVBV2lkdGggJHt1fSBtdXN0IGJlIGRpdmlzaWJsZSBieSB3b3JrZ3JvdXBTaXplWzBdJHt0WzBdfSwgdGlsZUlubmVyICR7aX0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVsxXSR7dFsxXX1gKTtsZXQgXz1oL3RbMV0seT11L3RbMF0sZz1pL3RbMV0seD1sP2BcbiAgICBsZXQgbG9jYWxSb3cgPSBpMzIobG9jYWxJZC55KTtcbiAgICBsZXQgbG9jYWxDb2wgPSBpMzIobG9jYWxJZC54KTtcbiAgICBsZXQgZ2xvYmFsUm93U3RhcnQgPSBpMzIod29ya2dyb3VwSWQueSkgKiAke3B9O1xuICAgIGxldCBnbG9iYWxDb2xTdGFydCA9IGkzMih3b3JrZ3JvdXBJZC54KSAqICR7bX07XG5cbiAgICAvLyBMb29wIG92ZXIgc2hhcmVkIGRpbWVuc2lvbi5cbiAgICBmb3IgKHZhciB0ID0gMDsgdCA8IG51bV90aWxlczsgdCA9IHQgKyAxKSB7XG4gICAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIEEgaW50byBsb2NhbCBtZW1vcnkuXG4gICAgICBmb3IgKHZhciBpbnB1dFJvdyA9IGxvY2FsUm93OyBpbnB1dFJvdyA8ICR7aH07IGlucHV0Um93ID0gaW5wdXRSb3cgKyAke3RbMV19KSB7XG4gICAgICAgIGZvciAodmFyIGlucHV0Q29sID0gbG9jYWxDb2w7IGlucHV0Q29sIDwgJHt1fTsgaW5wdXRDb2wgPSBpbnB1dENvbCArICR7dFswXX0pIHtcbiAgICAgICAgICAke051KG8sbil9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIExvYWQgb25lIHRpbGUgb2YgQiBpbnRvIGxvY2FsIG1lbW9yeS5cbiAgICAgIGZvciAodmFyIGlucHV0Um93ID0gbG9jYWxSb3c7IGlucHV0Um93IDwgJHtpfTsgaW5wdXRSb3cgPSBpbnB1dFJvdyArICR7dFsxXX0pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGlucHV0Q29sID0gbG9jYWxDb2w7IGlucHV0Q29sIDwgJHttfTsgaW5wdXRDb2wgPSBpbnB1dENvbCArICR7dFswXX0pIHtcbiAgICAgICAgICBtbV9Cc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQihiYXRjaCxcbiAgICAgICAgICAgIGtTdGFydCArIGlucHV0Um93LFxuICAgICAgICAgICAgZ2xvYmFsQ29sU3RhcnQgKyBpbnB1dENvbCR7bj9cIiwgYmF0Y2hJbmRpY2VzXCI6XCJcIn0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBrU3RhcnQgPSBrU3RhcnQgKyB0aWxlSW5uZXI7XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgIC8vIENvbXB1dGUgYWNjIHZhbHVlcyBmb3IgYSBzaW5nbGUgdGhyZWFkLlxuICAgICAgdmFyIEJDYWNoZWQgOiBhcnJheTwke3J9LCBjb2xQZXJUaHJlYWQ+O1xuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aWxlSW5uZXI7IGsgPSBrICsgMSkge1xuICAgICAgICBmb3IgKHZhciBpbm5lciA9IDA7IGlubmVyIDwgY29sUGVyVGhyZWFkOyBpbm5lciA9IGlubmVyICsgMSkge1xuICAgICAgICAgIEJDYWNoZWRbaW5uZXJdID0gbW1fQnN1YltrXVtsb2NhbENvbCArIGlubmVyICogJHt0WzBdfV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgICAgICBsZXQgQUNhY2hlZCA9ICR7bz9gbW1fQXN1YltrXVtsb2NhbFJvdyArIGlubmVyUm93ICogJHt0WzFdfV07YDpgbW1fQXN1Yltsb2NhbFJvdyArIGlubmVyUm93ICogJHt0WzFdfV1ba107YH1cbiAgICAgICAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgICAgICAgICAgYWNjW2lubmVyUm93XVtpbm5lckNvbF0gPSBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSArXG4gICAgICAgICAgICAgICAgQUNhY2hlZCAqIEJDYWNoZWRbaW5uZXJDb2xdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgICAgbGV0IGdSb3cgPSBnbG9iYWxSb3dTdGFydCArIGxvY2FsUm93ICsgaW5uZXJSb3cgKiAke3RbMV19O1xuICAgICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICAgICAgbGV0IGdDb2wgPSBnbG9iYWxDb2xTdGFydCArIGxvY2FsQ29sICsgaW5uZXJDb2wgKiAke3RbMF19O1xuICAgICAgICBtbV93cml0ZShiYXRjaCwgZ1JvdywgZ0NvbCwgYWNjW2lubmVyUm93XVtpbm5lckNvbF0pO1xuICAgICAgfVxuICAgIH1cbiAgICBgOmBcbmxldCB0aWxlUm93ID0gaTMyKGxvY2FsSWQueSkgKiByb3dQZXJUaHJlYWQ7XG5sZXQgdGlsZUNvbCA9IGkzMihsb2NhbElkLngpICogY29sUGVyVGhyZWFkO1xuXG5sZXQgZ2xvYmFsUm93ID0gaTMyKGdsb2JhbElkLnkpICogcm93UGVyVGhyZWFkO1xubGV0IGdsb2JhbENvbCA9IGkzMihnbG9iYWxJZC54KSAqIGNvbFBlclRocmVhZDtcbmxldCBnbG9iYWxSb3dTdGFydCA9IGkzMih3b3JrZ3JvdXBJZC55KSAqICR7cH07XG5cbmxldCB0aWxlUm93QSA9IGkzMihsb2NhbElkLnkpICogJHtffTtcbmxldCB0aWxlQ29sQSA9IGkzMihsb2NhbElkLngpICogJHt5fTtcbmxldCB0aWxlUm93QiA9IGkzMihsb2NhbElkLnkpICogJHtnfTtcbi8vIExvb3Agb3ZlciBzaGFyZWQgZGltZW5zaW9uLlxuZm9yICh2YXIgdCA9IDA7IHQgPCBudW1fdGlsZXM7IHQgPSB0ICsgMSkge1xuICAvLyBMb2FkIG9uZSB0aWxlIG9mIEEgaW50byBsb2NhbCBtZW1vcnkuXG4gIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCAke199OyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCAke3l9OyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgICAgbGV0IGlucHV0Um93ID0gdGlsZVJvd0EgKyBpbm5lclJvdztcbiAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2xBICsgaW5uZXJDb2w7XG4gICAgICAke051KG8sbil9XG4gICAgfVxuICB9XG5cbiAgLy8gTG9hZCBvbmUgdGlsZSBvZiBCIGludG8gbG9jYWwgbWVtb3J5LlxuICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgJHtnfTsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgICAgbGV0IGlucHV0Um93ID0gdGlsZVJvd0IgKyBpbm5lclJvdztcbiAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2wgKyBpbm5lckNvbDtcbiAgICAgIG1tX0JzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRCKGJhdGNoLFxuICAgICAgICBrU3RhcnQgKyBpbnB1dFJvdyxcbiAgICAgICAgZ2xvYmFsQ29sICsgaW5uZXJDb2wke24/XCIsIGJhdGNoSW5kaWNlc1wiOlwiXCJ9KTtcbiAgICB9XG4gIH1cbiAga1N0YXJ0ID0ga1N0YXJ0ICsgdGlsZUlubmVyO1xuICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgLy8gQ29tcHV0ZSBhY2MgdmFsdWVzIGZvciBhIHNpbmdsZSB0aHJlYWQuXG4gIHZhciBCQ2FjaGVkIDogYXJyYXk8JHtyfSwgY29sUGVyVGhyZWFkPjtcbiAgZm9yICh2YXIgayA9IDA7IGsgPCB0aWxlSW5uZXI7IGsgPSBrICsgMSkge1xuICAgIGZvciAodmFyIGlubmVyID0gMDsgaW5uZXIgPCBjb2xQZXJUaHJlYWQ7IGlubmVyID0gaW5uZXIgKyAxKSB7XG4gICAgICBCQ2FjaGVkW2lubmVyXSA9IG1tX0JzdWJba11bdGlsZUNvbCArIGlubmVyXTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgICAgJHtzZihvKX1cbiAgICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XG4gICAgICAgIGFjY1tpbm5lclJvd11baW5uZXJDb2xdID0gYWNjW2lubmVyUm93XVtpbm5lckNvbF0gKyBBQ2FjaGVkICogQkNhY2hlZFtpbm5lckNvbF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgd29ya2dyb3VwQmFycmllcigpO1xufVxuXG5mb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgIG1tX3dyaXRlKGJhdGNoLCBnbG9iYWxSb3cgKyBpbm5lclJvdywgZ2xvYmFsQ29sICsgaW5uZXJDb2wsXG4gICAgICAgIGFjY1tpbm5lclJvd11baW5uZXJDb2xdKTtcbiAgfVxufVxuYDtyZXR1cm5gXG4gIHZhcjx3b3JrZ3JvdXA+IG1tX0FzdWIgOiBhcnJheTxhcnJheTwke3J9LCAke3V9PiwgJHtofT47XG4gIHZhcjx3b3JrZ3JvdXA+IG1tX0JzdWIgOiBhcnJheTxhcnJheTwke3J9LCAke219PiwgJHtpfT47XG4gIGNvbnN0IHJvd1BlclRocmVhZCA9ICR7ZVsxXX07XG4gIGNvbnN0IGNvbFBlclRocmVhZCA9ICR7ZVswXX07XG4gIGNvbnN0IHRpbGVJbm5lciA9ICR7aX07XG5cbkBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSgke3RbMF19LCAke3RbMV19LCAke3RbMl19KVxuZm4gbWFpbihAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBsb2NhbElkIDogdmVjMzx1MzI+LFxuICAgICAgICBAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsSWQgOiB2ZWMzPHUzMj4sXG4gICAgICAgIEBidWlsdGluKHdvcmtncm91cF9pZCkgd29ya2dyb3VwSWQgOiB2ZWMzPHUzMj4pIHtcbiAgICBsZXQgYmF0Y2ggPSAke2E/XCIwXCI6XCJpMzIoZ2xvYmFsSWQueilcIn07XG4gICAgJHtuP2BsZXQgYmF0Y2hJbmRpY2VzID0gJHtuLm9mZnNldFRvSW5kaWNlcyhcInUzMihiYXRjaClcIil9O2A6XCJcIn1cbiAgICBsZXQgbnVtX3RpbGVzID0gJHthP2Ake01hdGguY2VpbChkL2kpfWA6XCIodW5pZm9ybXMuZGltX2lubmVyIC0gMSkgLyB0aWxlSW5uZXIgKyAxXCJ9O1xuICAgIHZhciBrU3RhcnQgPSAke2E/YGkzMihnbG9iYWxJZC56KSAqICR7ZH1gOlwiMFwifTtcblxuICAgIHZhciBhY2MgOiBhcnJheTxhcnJheTwke3J9LCBjb2xQZXJUaHJlYWQ+LCByb3dQZXJUaHJlYWQ+O1xuICAgICR7eH1cbiAgfVxuYH0sdWY9KGUsdCxyLG4sbz0hMSk9PntsZXRbaSxhLGQsbF09bixwPV9lKG5bMF0udHlwZS50ZW5zb3IpO3JldHVybmBcbiAgICBmbiBtbV9yZWFkQShiYXRjaDogaTMyLCByb3c6IGkzMiwgY29sSW46IGkzMiwgYmF0Y2hJbmRpY2VzOiAke2kudHlwZS5pbmRpY2VzfSkgLT4gJHtBZShlLHApfSB7XG4gICAgICB2YXIgdmFsdWUgPSAke0FlKGUscCl9KDAuMCk7XG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke2V9O1xuICAgICAgaWYocm93IDwgdW5pZm9ybXMuZGltX2Ffb3V0ZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2lubmVyKVxuICAgICAge1xuICAgICAgICB2YXIgYUluZGljZXM6ICR7YS50eXBlLmluZGljZXN9O1xuICAgICAgICAke0p0KFwiYUluZGljZXNcIixhLGEucmFuay0yLGkucmFuayxcImJhdGNoSW5kaWNlc1wiKX1cbiAgICAgICAgJHthLmluZGljZXNTZXQoXCJhSW5kaWNlc1wiLGEucmFuay0yLFwidTMyKHJvdylcIil9XG4gICAgICAgICR7YS5pbmRpY2VzU2V0KFwiYUluZGljZXNcIixhLnJhbmstMSxcInUzMihjb2xJbilcIil9XG4gICAgICAgIHZhbHVlID0gJHthLmdldEJ5SW5kaWNlcyhcImFJbmRpY2VzXCIpfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmbiBtbV9yZWFkQihiYXRjaDogaTMyLCByb3c6IGkzMiwgY29sSW46IGkzMiwgYmF0Y2hJbmRpY2VzOiAke2kudHlwZS5pbmRpY2VzfSkgLT4gJHtBZShlLHApfSB7XG4gICAgICB2YXIgdmFsdWUgPSAke0FlKGUscCl9KDAuMCk7XG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke2V9O1xuICAgICAgaWYocm93IDwgdW5pZm9ybXMuZGltX2lubmVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9iX291dGVyKVxuICAgICAge1xuICAgICAgICB2YXIgYkluZGljZXM6ICR7ZC50eXBlLmluZGljZXN9O1xuICAgICAgICAke0p0KFwiYkluZGljZXNcIixkLGQucmFuay0yLGkucmFuayxcImJhdGNoSW5kaWNlc1wiKX1cbiAgICAgICAgJHtkLmluZGljZXNTZXQoXCJiSW5kaWNlc1wiLGQucmFuay0yLFwidTMyKHJvdylcIil9XG4gICAgICAgICR7ZC5pbmRpY2VzU2V0KFwiYkluZGljZXNcIixkLnJhbmstMSxcInUzMihjb2xJbilcIil9XG4gICAgICAgIHZhbHVlID0gJHtkLmdldEJ5SW5kaWNlcyhcImJJbmRpY2VzXCIpfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmbiBtbV93cml0ZShiYXRjaDogaTMyLCByb3c6IGkzMiwgY29sSW46IGkzMiwgdmFsdWVJbjogJHtBZShlLHApfSkge1xuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHtlfTtcbiAgICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1fYV9vdXRlciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1fYl9vdXRlcikge1xuICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZUluO1xuICAgICAgICBsZXQgY29vcmRzID0gdmVjMzxpMzI+KGJhdGNoLCByb3csIGNvbEluKTtcbiAgICAgICAgJHt0P2B2YWx1ZSA9IHZhbHVlICsgJHtvP1wiYmlhc1tjb2xJbl1cIjpgJHtBZShlLHApfShiaWFzW3Jvd10pYH07YDpcIlwifVxuICAgICAgICAke3J9XG4gICAgICAgICR7bC5zZXRCeUluZGljZXMoXCJ2ZWMzPHUzMj4oY29vcmRzKVwiLFwidmFsdWVcIil9XG4gICAgICB9XG4gICAgfVxuICAgIGB9LGVyPShlLHQscixuLG89ITEsaSk9PntsZXQgYT1lWzBdLmRpbXMsZD1lWzFdLmRpbXMsbD1hLnNsaWNlKDAsLTIpLHA9ZC5zbGljZSgwLC0yKSxtPW4/bi5zbGljZSgwLC0yKTpyLnNsaWNlKDAsLTIpLHU9Qy5zaXplKG0pLGg9YVthLmxlbmd0aC0yXSxfPWFbYS5sZW5ndGgtMV0seT1kW2QubGVuZ3RoLTFdLGc9XyU0PT09MCYmeSU0PT09MCx4PWg8PTg/WzQsMSwxXTpbNCw0LDFdLCQ9WzgsOCwxXSx2PVtNYXRoLmNlaWwoeS8kWzBdL3hbMF0pLE1hdGguY2VpbChoLyRbMV0veFsxXSksTWF0aC5jZWlsKHUvJFsyXS94WzJdKV0sUz1nPzQ6MSxUPVsuLi5sLGgsXy9TXSxBPVQubGVuZ3RoLGs9Wy4uLnAsXyx5L1NdLFA9ay5sZW5ndGgsRD1bdSxoLHkvU10sUj1be3R5cGU6NixkYXRhOmh9LHt0eXBlOjYsZGF0YTp5fSx7dHlwZTo2LGRhdGE6X31dO0tlKHQsUiksUi5wdXNoKC4uLk4obSxULGspKTtsZXQgRz1bXCJyYW5rXCIsXCJyYW5rXCJdLEs9ZS5sZW5ndGg+MjtLJiYoUi5wdXNoKC4uLk4oZVsyXS5kaW1zKSksRy5wdXNoKFwicmFua1wiKSksUi5wdXNoKC4uLk4oRCkpO2xldCBqPVY9PntsZXQgUT1tLmxlbmd0aCxzZT1McihcImJhdGNoRGltc1wiLGVbMF0uZGF0YVR5cGUsUSwxKSxZPV9lKGVbMF0uZGF0YVR5cGUpLGVlPUUoXCJhXCIsZVswXS5kYXRhVHlwZSxBLFMpLEo9RShcImJcIixlWzFdLmRhdGFUeXBlLFAsUyksbmU9TShcInJlc3VsdFwiLGVbMF0uZGF0YVR5cGUsRC5sZW5ndGgsUyksYmU9W2VlLEpdO2lmKEspe2xldCBxPW8/UzoxO2JlLnB1c2goRShcImJpYXNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcy5sZW5ndGgscSkpfWxldCBPZT1be25hbWU6XCJkaW1fYV9vdXRlclwiLHR5cGU6XCJpMzJcIn0se25hbWU6XCJkaW1fYl9vdXRlclwiLHR5cGU6XCJpMzJcIn0se25hbWU6XCJkaW1faW5uZXJcIix0eXBlOlwiaTMyXCJ9XTtqZSh0LE9lKTtsZXQgJGU9X2UobmUudHlwZS50ZW5zb3IpLGxlPXFlKHQsbmUudHlwZS52YWx1ZSwkZSksVz11ZihTLEssbGUsW3NlLGVlLEosbmVdLG8pO3JldHVybmBcbiAgJHtWLnJlZ2lzdGVyVW5pZm9ybXMoT2UpLnJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZXMoc2UpLmRlY2xhcmVWYXJpYWJsZXMoLi4uYmUsbmUpfVxuICAke1d9XG4gICR7Zz9obyh4LCQsWSxzZSk6Z28oeCwkLFksc2UpfVxuICAgICAgICAgICAgICAgICAgIGB9O3JldHVybntuYW1lOlwiTWF0TXVsXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7eH07JHt0LmFjdGl2YXRpb259OyR7Z307JHtvfWAsaW5wdXREZXBlbmRlbmNpZXM6R30sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczppP2kocik6cixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDp2WzBdLHk6dlsxXSx6OnZbMl19LHByb2dyYW1Vbmlmb3JtczpSfSksZ2V0U2hhZGVyU291cmNlOmp9fX0pO3ZhciBkZixWdSxXdT1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtldCgpO2FlKCk7eXQoKTtZcigpO1V1KCk7WHIoKTtkZj0oZSx0LHIsbixvPSExLGksYT00LGQ9NCxsPTQscD1cImYzMlwiKT0+e2xldCBtPUc9Pntzd2l0Y2goRyl7Y2FzZSAxOnJldHVyblwicmVzRGF0YSA9IHhbeEluZGV4XTtcIjtjYXNlIDM6cmV0dXJuYHJlc0RhdGEgPSB2ZWMzPCR7cH0+KHhbeEluZGV4XSwgeFt4SW5kZXggKyAxXSwgeFt4SW5kZXggKyAyXSk7YDtjYXNlIDQ6cmV0dXJuXCJyZXNEYXRhID0geFt4SW5kZXggLyA0XTtcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW5uZXJFbGVtZW50U2l6ZSAke0d9IGlzIG5vdCBzdXBwb3J0ZWQuYCl9fSx1PUc9Pntzd2l0Y2goRyl7Y2FzZSAxOnJldHVyblwicmV0dXJuIHdbcm93ICogaTMyKHVuaWZvcm1zLndfc2hhcGVbM10pICsgY29sSW5dO1wiO2Nhc2UgNDpyZXR1cm5cInJldHVybiB3W3JvdyAqIGkzMih1bmlmb3Jtcy53X3NoYXBlWzNdKSAvIDQgKyBjb2xJbl07XCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGlubmVyRWxlbWVudFNpemUgJHtHfSBpcyBub3Qgc3VwcG9ydGVkLmApfX0saD1lP2BcbiAgICBsZXQgY29vcmQgPSB2ZWM0PGkzMj4oYmF0Y2gsIHhSb3csIHhDb2wsIHhDaCk7XG4gICAgYDpgXG4gICAgbGV0IGNvb3JkID0gdmVjNDxpMzI+KGJhdGNoLCB4Q2gsIHhSb3csIHhDb2wpO1xuICAgIGAsXz1lP2BcbiAgICBsZXQgY29vcmRzID0gdmVjNDxpMzI+KFxuICAgICAgYmF0Y2gsXG4gICAgICByb3cgLyBvdXRXaWR0aCxcbiAgICAgIHJvdyAlIG91dFdpZHRoLFxuICAgICAgY29sKTtcbiAgICBgOmBcbiAgICBsZXQgY29vcmRzID0gdmVjNDxpMzI+KFxuICAgICAgYmF0Y2gsXG4gICAgICByb3csXG4gICAgICBjb2wgLyBvdXRXaWR0aCxcbiAgICAgIGNvbCAlIG91dFdpZHRoKTtcbiAgICBgLHk9ZT9cImkzMih1bmlmb3Jtcy54X3NoYXBlWzFdKVwiOlwiaTMyKHVuaWZvcm1zLnhfc2hhcGVbMl0pXCIsZz1lP1wiaTMyKHVuaWZvcm1zLnhfc2hhcGVbMl0pXCI6XCJpMzIodW5pZm9ybXMueF9zaGFwZVszXSlcIix4PWU/XCJyb3dcIjpcImNvbFwiLCQ9ZT9cImNvbFwiOlwicm93XCIsdj1gXG4gICAgbGV0IGluQ2hhbm5lbHMgPSBpMzIodW5pZm9ybXMud19zaGFwZVsyXSk7XG4gICAgbGV0IG91dFdpZHRoID0gJHtlP1wiaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVsyXSlcIjpcImkzMih1bmlmb3Jtcy5yZXN1bHRfc2hhcGVbM10pXCJ9O1xuICAgIGxldCBvdXRSb3cgPSAke3h9IC8gb3V0V2lkdGg7XG4gICAgbGV0IG91dENvbCA9ICR7eH0gJSBvdXRXaWR0aDtcblxuICAgIGxldCBXUm93ID0gJHskfSAvIChpMzIodW5pZm9ybXMud19zaGFwZVsxXSkgKiBpbkNoYW5uZWxzKTtcbiAgICBsZXQgV0NvbCA9ICR7JH0gLyBpbkNoYW5uZWxzICUgaTMyKHVuaWZvcm1zLndfc2hhcGVbMV0pO1xuICAgIGxldCB4Um93ID0gb3V0Um93ICogdW5pZm9ybXMuc3RyaWRlWzBdICsgdW5pZm9ybXMuZGlsYXRpb25bMF0gKiBXUm93IC0gdW5pZm9ybXMucGFkWzBdO1xuICAgIGxldCB4Q29sID0gb3V0Q29sICogdW5pZm9ybXMuc3RyaWRlWzFdICsgdW5pZm9ybXMuZGlsYXRpb25bMV0gKiBXQ29sIC0gdW5pZm9ybXMucGFkWzFdO1xuICAgIGxldCB4Q2ggPSAkeyR9ICUgaW5DaGFubmVscztcbiAgICB2YXIgcmVzRGF0YSA9ICR7QWUoYSxwKX0oMC4wKTtcbiAgICAvLyBUaGUgYm91bmRzIGNoZWNraW5nIGlzIGFsd2F5cyBuZWVkZWQgc2luY2Ugd2UgdXNlIGl0IHRvIHBhZCB6ZXJvIGZvclxuICAgIC8vIHRoZSAnc2FtZScgcGFkZGluZyB0eXBlLlxuICAgIGlmICh4Um93ID49IDAgJiYgeFJvdyA8ICR7eX0gJiYgeENvbCA+PSAwICYmIHhDb2wgPCAke2d9KSB7XG4gICAgICAke2h9XG4gICAgICBsZXQgeEluZGV4ID0gZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmQsIHZlYzQ8aTMyPih1bmlmb3Jtcy54X3NoYXBlKSk7XG4gICAgICAke20oYSl9XG4gICAgfVxuICAgIHJldHVybiByZXNEYXRhO2AsUz1lP3QmJm4/YFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7YX07XG4gICAgJHt2fWA6YFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7YX07XG4gICAgaWYgKHJvdyA8IHVuaWZvcm1zLmRpbV9hX291dGVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9pbm5lcikge1xuICAgICAgJHt2fVxuICAgIH1cbiAgICByZXR1cm4gJHtBZShhLHApfSgwLjApO2A6biYmcj9gXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHthfTtcbiAgICAke3Z9YDpgXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHthfTtcbiAgICBpZiAocm93IDwgdW5pZm9ybXMuZGltX2lubmVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9iX291dGVyKSB7XG4gICAgICAke3Z9XG4gICAgfVxuICAgIHJldHVybiAke0FlKGEscCl9KDAuMCk7YCxUPWU/biYmcj91KGQpOmBcbiAgICBsZXQgY29sID0gY29sSW4gKiAke2R9O1xuICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1faW5uZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXIpIHtcbiAgICAgICR7dShkKX1cbiAgICB9XG4gICAgcmV0dXJuICR7QWUoZCxwKX0oMC4wKTtgOmBcbiAgICBsZXQgY29sID0gY29sSW4gKiAke2R9O1xuICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1faW5uZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Ffb3V0ZXIpIHtcbiAgICAgICR7dShkKX1cbiAgICB9XG4gICAgcmV0dXJuICR7QWUoZCxwKX0oMC4wKTtgLEE9QWUobCxwKSxrPWU/QWUoYSxwKTpBZShkLHApLFA9ZT9BZShkLHApOkFlKGEscCksRD1xZShpLEEscCk7cmV0dXJuYFxuICAgIGZuIG1tX3JlYWRBKGJhdGNoOiBpMzIsIHJvdyA6IGkzMiwgY29sSW4gOiBpMzIpIC0+ICR7a30ge1xuICAgICAgJHtlP1M6VH1cbiAgICB9XG5cbiAgICBmbiBtbV9yZWFkQihiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyKSAtPiAke1B9IHtcbiAgICAgICR7ZT9UOlN9XG4gICAgfVxuXG4gICAgZm4gbW1fd3JpdGUoYmF0Y2g6IGkzMiwgcm93IDogaTMyLCBjb2xJbiA6IGkzMiwgdmFsdWVJbiA6ICR7QX0pIHtcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7bH07XG4gICAgICBpZiAocm93IDwgdW5pZm9ybXMuZGltX2Ffb3V0ZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXIpXG4gICAgICB7XG4gICAgICB2YXIgdmFsdWUgPSB2YWx1ZUluO1xuICAgICAgbGV0IG91dFdpZHRoID0gJHtlP1wiaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVsyXSlcIjpcImkzMih1bmlmb3Jtcy5yZXN1bHRfc2hhcGVbM10pXCJ9O1xuICAgICAgJHtffVxuICAgICAgJHtNdShvKX1cbiAgICAgICR7RH1cbiAgICAgIHNldE91dHB1dEF0Q29vcmRzKGNvb3Jkc1swXSwgY29vcmRzWzFdLCBjb29yZHNbMl0sIGNvb3Jkc1szXSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1gfSxWdT0oZSx0LHIsbixvLGksYSxkLGwpPT57bGV0IHA9dC5mb3JtYXQ9PT1cIk5IV0NcIixtPXA/ZVswXS5kaW1zWzNdOmVbMF0uZGltc1sxXSx1PXJbMF0saD1wP3JbMl06clszXSxfPXA/clsxXTpyWzJdLHk9cD9yWzNdOnJbMV0sZz1wJiYobSU0PT09MHx8bSUzPT09MCkmJnklND09PTAseD1wP3k6aCpfLCQ9cD9oKl86eSx2PVs4LDgsMV0sUz1uPD04P1s0LDEsMV06WzQsNCwxXSxUPVtNYXRoLmNlaWwoeC92WzBdL1NbMF0pLE1hdGguY2VpbCgkL3ZbMV0vU1sxXSksTWF0aC5jZWlsKHUvdlsyXS9TWzJdKV07dWUoXCJ2ZXJib3NlXCIsKCk9PmBbY29udjJkX21tX3dlYmdwdV0gZGlzcGF0Y2ggPSAke1R9YCk7bGV0IEE9Zz9wJiZtJTQhPT0wPzM6NDoxLGs9dlsxXSpTWzFdLFA9dlswXSpTWzBdLEQ9TWF0aC5tYXgodlswXSpBLHZbMV0pLFI9biVrPT09MCxHPW8lUD09PTAsSz1pJUQ9PT0wLGo9Zz9bQSw0LDRdOlsxLDEsMV0sVj1be3R5cGU6NixkYXRhOm59LHt0eXBlOjYsZGF0YTpvfSx7dHlwZTo2LGRhdGE6aX0se3R5cGU6NixkYXRhOlt0LnBhZHNbMF0sdC5wYWRzWzFdXX0se3R5cGU6NixkYXRhOnQuc3RyaWRlc30se3R5cGU6NixkYXRhOnQuZGlsYXRpb25zfV07S2UodCxWKSxWLnB1c2goLi4uTihlWzBdLmRpbXMsZVsxXS5kaW1zKSk7bGV0IFE9W1wicmFua1wiLFwicmFua1wiXTthJiYoVi5wdXNoKC4uLk4oZVsyXS5kaW1zKSksUS5wdXNoKFwicmFua1wiKSksVi5wdXNoKC4uLk4ocikpO2xldCBzZT1ZPT57bGV0IGVlPVt7bmFtZTpcImRpbV9hX291dGVyXCIsdHlwZTpcImkzMlwifSx7bmFtZTpcImRpbV9iX291dGVyXCIsdHlwZTpcImkzMlwifSx7bmFtZTpcImRpbV9pbm5lclwiLHR5cGU6XCJpMzJcIn0se25hbWU6XCJwYWRcIix0eXBlOlwiaTMyXCIsbGVuZ3RoOjJ9LHtuYW1lOlwic3RyaWRlXCIsdHlwZTpcImkzMlwiLGxlbmd0aDoyfSx7bmFtZTpcImRpbGF0aW9uXCIsdHlwZTpcImkzMlwiLGxlbmd0aDoyfV07amUodCxlZSk7bGV0IEo9Zz80OjEsbmU9X2UoZVswXS5kYXRhVHlwZSksYmU9YFxuICAgICAgZm4gc2V0T3V0cHV0QXRJbmRleChmbGF0SW5kZXggOiBpMzIsIHZhbHVlIDogJHtnP2B2ZWM0PCR7bmV9PmA6bmV9KSB7XG4gICAgICAgIHJlc3VsdFtmbGF0SW5kZXhdID0gJHtnP2B2ZWM0PCR7bmV9PmA6bmV9KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGZuIHNldE91dHB1dEF0Q29vcmRzKGQwIDogaTMyLCBkMSA6IGkzMiwgZDIgOiBpMzIsIGQzIDogaTMyLCB2YWx1ZSA6ICR7Zz9gdmVjNDwke25lfT5gOm5lfSkge1xuICAgICAgICBsZXQgZmxhdEluZGV4ID0gZ2V0T3V0cHV0SW5kZXhGcm9tQ29vcmRzKHZlYzQ8aTMyPihkMCwgZDEsIGQyLCBkMykpO1xuICAgICAgICBzZXRPdXRwdXRBdEluZGV4KGZsYXRJbmRleCAke2c/XCIvIDRcIjpcIlwifSwgdmFsdWUpO1xuICAgICAgfWAsT2U9RShcInhcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcy5sZW5ndGgsQT09PTM/MTpBKSwkZT1FKFwid1wiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zLmxlbmd0aCxKKSxsZT1bT2UsJGVdLFc9TShcInJlc3VsdFwiLGVbMF0uZGF0YVR5cGUsci5sZW5ndGgsSik7aWYoYSl7bGV0IHE9RShcImJpYXNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcy5sZW5ndGgsSik7bGUucHVzaChxKSxiZSs9YFxuICAgICAgICBmbiBnZXRCaWFzQnlPdXRwdXRDb29yZHMoY29vcmRzIDogdmVjNDxpMzI+KSAtPiAke2c/YHZlYzQ8JHtuZX0+YDpuZX0ge1xuICAgICAgICAgIHJldHVybiBiaWFzW2Nvb3Jkcy4ke3A/XCJ3XCI6XCJ5XCJ9JHtnP1wiLyA0XCI6XCJcIn1dO1xuICAgICAgICB9YH1yZXR1cm5gXG4gICAgICAgICR7UnUoXCJ1bmlmb3Jtcy5yZXN1bHRfc3RyaWRlc1wiKX1cbiAgICAgICAgLy9zdHJ1Y3QgVW5pZm9ybXMgeyB4U2hhcGUgOiB2ZWM0PGkzMj4sIHdTaGFwZSA6IHZlYzQ8aTMyPiwgb3V0U2hhcGUgOiB2ZWM0PGkzMj4sXG4gICAgICAgIC8vICBvdXRTaGFwZVN0cmlkZXM6IHZlYzM8aTMyPiwgZmlsdGVyRGltcyA6IHZlYzI8aTMyPiwgcGFkIDogdmVjMjxpMzI+LCBzdHJpZGUgOiB2ZWMyPGkzMj4sXG4gICAgICAgIC8vICBkaWxhdGlvbiA6IHZlYzI8aTMyPiwgZGltQU91dGVyIDogaTMyLCBkaW1CT3V0ZXIgOiBpMzIsIGRpbUlubmVyIDogaTMyIH07XG4gICAgICAgICR7WS5yZWdpc3RlclVuaWZvcm1zKGVlKS5kZWNsYXJlVmFyaWFibGVzKC4uLmxlLFcpfVxuICAgICAgICAke2JlfVxuICAgICAgICAke2RmKHAsUixHLEssYSx0LGpbMF0salsxXSxqWzJdLG5lKX1cbiAgICAgICAgJHtnP2hvKFMsdixuZSx2b2lkIDAsIXAsRCk6Z28oUyx2LG5lLHZvaWQgMCwhcCxELCExLHZvaWQgMCxkKX1gfTtyZXR1cm57bmFtZTpcIkNvbnYyRE1hdE11bFwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9OyR7QX07JHtnfTske1J9OyR7R307JHtLfTske2t9OyR7UH07JHtEfWAsaW5wdXREZXBlbmRlbmNpZXM6UX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpsP2wocik6cixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpUWzBdLHk6VFsxXSx6OlRbMl19LHByb2dyYW1Vbmlmb3JtczpWfSksZ2V0U2hhZGVyU291cmNlOnNlfX19KTt2YXIgbGYsTHUsSnIsY2YsR3UscGYsSHUsRnUscXU9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7ZXQoKTtvZSgpO2FlKCk7eXQoKTtZcigpO2xmPWU9PntsZXQgdD0xO2ZvcihsZXQgcj0wO3I8ZS5sZW5ndGg7cisrKXQqPWVbcl07cmV0dXJuIHR9LEx1PWU9PnR5cGVvZiBlPT1cIm51bWJlclwiP1tlLGUsZV06ZSxKcj0oZSx0KT0+dDw9MT9lOmUrKGUtMSkqKHQtMSksY2Y9KGUsdCxyLG49MSk9PntsZXQgbz1Kcih0LG4pO3JldHVybiBNYXRoLmZsb29yKChlWzBdKihyLTEpLXIrbykvMil9LEd1PShlLHQscixuLG8pPT57bz09bnVsbCYmKG89Y2YoZSx0WzBdLG5bMF0pKTtsZXQgaT1bMCwwLDAscl07Zm9yKGxldCBhPTA7YTwzO2ErKyllW2FdKzIqbz49dFthXSYmKGlbYV09TWF0aC50cnVuYygoZVthXS10W2FdKzIqbykvblthXSsxKSk7cmV0dXJuIGl9LHBmPShlLHQscixuLG8saSxhLGQsbCxwKT0+e2xldCBtLHUsaCxfO2lmKGU9PT1cIlZBTElEXCImJihlPTApLHR5cGVvZiBlPT1cIm51bWJlclwiKXttPXt0b3A6ZSxib3R0b206ZSxsZWZ0OmUscmlnaHQ6ZSxmcm9udDplLGJhY2s6ZX07bGV0IHk9R3UoW3QscixuLDFdLFtkLGwscF0sMSxbbyxpLGFdLGUpO3U9eVswXSxoPXlbMV0sXz15WzJdfWVsc2UgaWYoQXJyYXkuaXNBcnJheShlKSl7aWYoIWUuZXZlcnkoKGcseCwkKT0+Zz09PSRbMF0pKXRocm93IEVycm9yKGBVbnN1cHBvcnRlZCBwYWRkaW5nIHBhcmFtZXRlcjogJHtlfWApO209e3RvcDplWzBdLGJvdHRvbTplWzFdLGxlZnQ6ZVsyXSxyaWdodDplWzNdLGZyb250OmVbNF0sYmFjazplWzVdfTtsZXQgeT1HdShbdCxyLG4sMV0sW2QsbCxwXSwxLFtvLGksYV0sZVswXSk7dT15WzBdLGg9eVsxXSxfPXlbMl19ZWxzZSBpZihlPT09XCJTQU1FX1VQUEVSXCIpe3U9TWF0aC5jZWlsKHQvbyksaD1NYXRoLmNlaWwoci9pKSxfPU1hdGguY2VpbChuL2EpO2xldCB5PSh1LTEpKm8rZC10LGc9KGgtMSkqaStsLXIseD0oXy0xKSphK3AtbiwkPU1hdGguZmxvb3IoeS8yKSx2PXktJCxTPU1hdGguZmxvb3IoZy8yKSxUPWctUyxBPU1hdGguZmxvb3IoeC8yKSxrPXgtQTttPXt0b3A6Uyxib3R0b206VCxsZWZ0OkEscmlnaHQ6ayxmcm9udDokLGJhY2s6dn19ZWxzZSB0aHJvdyBFcnJvcihgVW5rbm93biBwYWRkaW5nIHBhcmFtZXRlcjogJHtlfWApO3JldHVybntwYWRJbmZvOm0sb3V0RGVwdGg6dSxvdXRIZWlnaHQ6aCxvdXRXaWR0aDpffX0sSHU9KGUsdCxyLG4sbyxpPSExLGE9XCJjaGFubmVsc0xhc3RcIik9PntsZXQgZCxsLHAsbSx1O2lmKGE9PT1cImNoYW5uZWxzTGFzdFwiKVtkLGwscCxtLHVdPWU7ZWxzZSBpZihhPT09XCJjaGFubmVsc0ZpcnN0XCIpW2QsdSxsLHAsbV09ZTtlbHNlIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBkYXRhRm9ybWF0ICR7YX1gKTtsZXRbaCwsXyx5LGddPXQsW3gsJCx2XT1MdShyKSxbUyxULEFdPUx1KG4pLGs9SnIoXyxTKSxQPUpyKHksVCksRD1KcihnLEEpLHtwYWRJbmZvOlIsb3V0RGVwdGg6RyxvdXRIZWlnaHQ6SyxvdXRXaWR0aDpqfT1wZihvLGwscCxtLHgsJCx2LGssUCxEKSxWPWk/aCp1OmgsUT1bMCwwLDAsMCwwXTtyZXR1cm4gYT09PVwiY2hhbm5lbHNGaXJzdFwiP1E9W2QsVixHLEssal06YT09PVwiY2hhbm5lbHNMYXN0XCImJihRPVtkLEcsSyxqLFZdKSx7YmF0Y2hTaXplOmQsZGF0YUZvcm1hdDphLGluRGVwdGg6bCxpbkhlaWdodDpwLGluV2lkdGg6bSxpbkNoYW5uZWxzOnUsb3V0RGVwdGg6RyxvdXRIZWlnaHQ6SyxvdXRXaWR0aDpqLG91dENoYW5uZWxzOlYscGFkSW5mbzpSLHN0cmlkZURlcHRoOngsc3RyaWRlSGVpZ2h0OiQsc3RyaWRlV2lkdGg6dixmaWx0ZXJEZXB0aDpfLGZpbHRlckhlaWdodDp5LGZpbHRlcldpZHRoOmcsZWZmZWN0aXZlRmlsdGVyRGVwdGg6ayxlZmZlY3RpdmVGaWx0ZXJIZWlnaHQ6UCxlZmZlY3RpdmVGaWx0ZXJXaWR0aDpELGRpbGF0aW9uRGVwdGg6UyxkaWxhdGlvbkhlaWdodDpULGRpbGF0aW9uV2lkdGg6QSxpblNoYXBlOmUsb3V0U2hhcGU6USxmaWx0ZXJTaGFwZTp0fX0sRnU9KGUsdCxyLG4sbyxpKT0+e2xldCBhPWk9PT1cImNoYW5uZWxzTGFzdFwiLGQ9YT9lWzBdLmRpbXNbM106ZVswXS5kaW1zWzFdLGw9ITEscD1bNjQsMSwxXSxtPXt4OnIubWFwKCh2LFMpPT5TKX0sdT1bTWF0aC5jZWlsKGxmKG0ueC5tYXAodj0+clt2XSkpL3BbMF0pLDEsMV07dWUoXCJ2ZXJib3NlXCIsKCk9PmBbY29udjNkX25haXZlX3dlYmdwdV0gZGlzcGF0Y2ggPSAke3V9YCk7bGV0IGg9bD9hJiZkJTQhPT0wPzM6NDoxLF89Qy5zaXplKHIpLHk9W3t0eXBlOjEyLGRhdGE6X30se3R5cGU6MTIsZGF0YTpufSx7dHlwZToxMixkYXRhOm99LHt0eXBlOjEyLGRhdGE6dC5zdHJpZGVzfSx7dHlwZToxMixkYXRhOnQuZGlsYXRpb25zfV07S2UodCx5KSx5LnB1c2goLi4uTihlWzBdLmRpbXMsZVsxXS5kaW1zKSk7bGV0IGc9W1wicmFua1wiLFwicmFua1wiXSx4PWUubGVuZ3RoPT09Mzt4JiYoeS5wdXNoKC4uLk4oZVsyXS5kaW1zKSksZy5wdXNoKFwicmFua1wiKSkseS5wdXNoKC4uLk4ocikpO2xldCAkPXY9PntsZXQgUz1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJmaWx0ZXJfZGltc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6bi5sZW5ndGh9LHtuYW1lOlwicGFkc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6by5sZW5ndGh9LHtuYW1lOlwic3RyaWRlc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6dC5zdHJpZGVzLmxlbmd0aH0se25hbWU6XCJkaWxhdGlvbnNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOnQuZGlsYXRpb25zLmxlbmd0aH1dO2plKHQsUyk7bGV0IFQ9bD80OjEsQT1fZShlWzBdLmRhdGFUeXBlKSxrPUUoXCJ4XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMubGVuZ3RoLGg9PT0zPzE6aCksUD1FKFwiV1wiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zLmxlbmd0aCxUKSxEPVtrLFBdLFI9TShcInJlc3VsdFwiLGVbMF0uZGF0YVR5cGUsci5sZW5ndGgsVCksRz1cIlwiO2lmKHgpe2xldCBWPUUoXCJiaWFzXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMubGVuZ3RoLFQpO0QucHVzaChWKSxHKz1gXG4gICAgICAgIGZuIGdldEJpYXNCeU91dHB1dENvb3Jkcyhjb29yZHMgOiBhcnJheTx1MzIsIDU+KSAtPiAke2w/YHZlYzQ8JHtBfT5gOkF9IHtcbiAgICAgICAgICByZXR1cm4gYmlhc1ske2E/RihcImNvb3Jkc1wiLDQsNSk6RihcImNvb3Jkc1wiLDEsNSl9JHtsP1wiLyA0XCI6XCJcIn1dO1xuICAgICAgICB9YH1sZXQgSz1BZShoLEEpLGo9cWUodCxLLEEpO3JldHVybmBcbiAgICAgICAgICAgICR7R31cbiAgICAgICAgICAgIGZuIGdldFgoZDAgOiB1MzIsIGQxIDogdTMyLCBkMiA6IHUzMiwgZDMgOiB1MzIsIGQ0IDogdTMyKSAtPiBmMzIge1xuICAgICAgICAgICAgICBsZXQgYUluZGljZXMgPSBhcnJheTx1MzIsIDU+KGQwLCBkMSwgZDIsIGQzLCBkNCk7XG4gICAgICAgICAgICAgIHJldHVybiAke2suZ2V0QnlJbmRpY2VzKFwiYUluZGljZXNcIil9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm4gZ2V0VyhkMCA6IHUzMiwgZDEgOiB1MzIsIGQyIDogdTMyLCBkMyA6IHUzMiwgZDQgOiB1MzIpIC0+IGYzMiB7XG4gICAgICAgICAgICAgIGxldCBhSW5kaWNlcyA9IGFycmF5PHUzMiwgNT4oZDAsIGQxLCBkMiwgZDMsIGQ0KTtcbiAgICAgICAgICAgICAgcmV0dXJuICR7UC5nZXRCeUluZGljZXMoXCJhSW5kaWNlc1wiKX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgJHt2LnJlZ2lzdGVyVW5pZm9ybXMoUykuZGVjbGFyZVZhcmlhYmxlcyguLi5ELFIpfVxuICAgICAgICAgICR7di5tYWluU3RhcnQoKX1cbiAgICAgICAgICAke3YuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgICAgICAgICAgICBsZXQgY29vcmRzID0gJHtSLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgICAgICAgICBsZXQgYmF0Y2ggPSAke0YoXCJjb29yZHNcIiwwLGsucmFuayl9O1xuICAgICAgICAgICAgICBsZXQgZDIgPSAke2E/RihcImNvb3Jkc1wiLGsucmFuay0xLGsucmFuayk6RihcImNvb3Jkc1wiLDEsay5yYW5rKX07XG4gICAgICAgICAgICAgIGxldCB4RlJDQ29ybmVyID0gdmVjMzx1MzI+KCR7YT9GKFwiY29vcmRzXCIsMSxrLnJhbmspOkYoXCJjb29yZHNcIiwyLGsucmFuayl9LFxuICAgICAgICAgICAgICAke2E/RihcImNvb3Jkc1wiLDIsay5yYW5rKTpGKFwiY29vcmRzXCIsMyxrLnJhbmspfSxcbiAgICAgICAgICAgICAgJHthP0YoXCJjb29yZHNcIiwzLGsucmFuayk6RihcImNvb3Jkc1wiLDQsay5yYW5rKX0pICogdW5pZm9ybXMuc3RyaWRlcyAtIHVuaWZvcm1zLnBhZHM7XG4gICAgICAgICAgICAgIGxldCB4RkNvcm5lciA9IHhGUkNDb3JuZXIueDtcbiAgICAgICAgICAgICAgbGV0IHhSQ29ybmVyID0geEZSQ0Nvcm5lci55O1xuICAgICAgICAgICAgICBsZXQgeENDb3JuZXIgPSB4RlJDQ29ybmVyLno7XG4gICAgICAgICAgICAgIGxldCB4U2hhcGVZID0gJHthP0YoXCJ1bmlmb3Jtcy54X3NoYXBlXCIsMSxrLnJhbmspOkYoXCJ1bmlmb3Jtcy54X3NoYXBlXCIsMixrLnJhbmspfTtcbiAgICAgICAgICAgICAgbGV0IHhTaGFwZVogPSAke2E/RihcInVuaWZvcm1zLnhfc2hhcGVcIiwyLGsucmFuayk6RihcInVuaWZvcm1zLnhfc2hhcGVcIiwzLGsucmFuayl9O1xuICAgICAgICAgICAgICBsZXQgeFNoYXBlVyA9ICR7YT9GKFwidW5pZm9ybXMueF9zaGFwZVwiLDMsay5yYW5rKTpGKFwidW5pZm9ybXMueF9zaGFwZVwiLDQsay5yYW5rKX07XG4gICAgICAgICAgICAgIGxldCB4U2hhcGVVID0gJHthP0YoXCJ1bmlmb3Jtcy54X3NoYXBlXCIsNCxrLnJhbmspOkYoXCJ1bmlmb3Jtcy54X3NoYXBlXCIsMSxrLnJhbmspfTtcbiAgICAgICAgICAgICAgbGV0IGlucHV0RGVwdGhOZWFyZXN0VmVjNCA9ICh4U2hhcGVVIC8gNCkgKiA0O1xuICAgICAgICAgICAgICBsZXQgaW5wdXREZXB0aFZlYzRSZW1haW5kZXIgPSB4U2hhcGVVICUgNDtcblxuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSAwLjA7XG4gICAgICAgICAgICAgIGZvciAodmFyIHdGID0gMHU7IHdGIDwgdW5pZm9ybXMuZmlsdGVyX2RpbXNbMF07IHdGKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgeEYgPSB4RkNvcm5lciArIHdGICogdW5pZm9ybXMuZGlsYXRpb25zWzBdO1xuICAgICAgICAgICAgICAgIGlmICh4RiA8IDAgfHwgeEYgPj0geFNoYXBlWSkge1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgd1IgPSAwdTsgd1IgPCB1bmlmb3Jtcy5maWx0ZXJfZGltc1sxXTsgd1IrKykge1xuICAgICAgICAgICAgICAgICAgbGV0IHhSID0geFJDb3JuZXIgKyB3UiAqIHVuaWZvcm1zLmRpbGF0aW9uc1sxXTtcbiAgICAgICAgICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0geFNoYXBlWikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgd0MgPSAwdTsgd0MgPCB1bmlmb3Jtcy5maWx0ZXJfZGltc1syXTsgd0MrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeEMgPSB4Q0Nvcm5lciArIHdDICogdW5pZm9ybXMuZGlsYXRpb25zWzJdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IHhTaGFwZVcpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGQxID0gMHU7IGQxIDwgaW5wdXREZXB0aE5lYXJlc3RWZWM0OyBkMSArPSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgJHthP2BsZXQgeFZhbHVlcyA9IHZlYzQ8ZjMyPihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBkMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgZDEgKyAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBkMSArIDIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGQxICsgMykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGA6YGxldCB4VmFsdWVzID0gdmVjNDxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGQxLCB4RiwgeFIsIHhDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBkMSArIDEsIHhGLCB4UiwgeEMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGQxICsgMiwgeEYsIHhSLCB4QyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgZDEgKyAzLCB4RiwgeFIsIHhDKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlcyA9IHZlYzQ8ZjMyPihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGQxLCB3Riwgd1IsIHdDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGQxICsgMSwgd0YsIHdSLCB3QyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBkMSArIDIsIHdGLCB3Uiwgd0MpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgZDEgKyAzLCB3Riwgd1IsIHdDKSk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAke2E/YHZhbHVlICs9IGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGlucHV0RGVwdGhOZWFyZXN0VmVjNClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKiBnZXRXKGQyLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQsIHdGLCB3Uiwgd0MpO2A6YHZhbHVlICs9IGdldFgoYmF0Y2gsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCwgeEYsIHhSLCB4QylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKiBnZXRXKGQyLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQsIHdGLCB3Uiwgd0MpO2B9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXREZXB0aFZlYzRSZW1haW5kZXIgPT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICR7YT9gbGV0IHhWYWx1ZXMgPSB2ZWMyPGYzMj4oXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICAgIGA6YGxldCB4VmFsdWVzID0gdmVjMjxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgaW5wdXREZXB0aE5lYXJlc3RWZWM0LCB4RiwgeFIsIHhDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDEsIHhGLCB4UiwgeEMpKTtcbiAgICAgICAgICAgICAgICAgICAgYH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IHdWYWx1ZXMgPSB2ZWMyPGYzMj4oXG4gICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgaW5wdXREZXB0aE5lYXJlc3RWZWM0LCB3Riwgd1IsIHdDKSxcbiAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAxLCB3Riwgd1IsIHdDKSk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0RGVwdGhWZWM0UmVtYWluZGVyID09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAke2E/YGxldCB4VmFsdWVzID0gdmVjMzxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgaW5wdXREZXB0aE5lYXJlc3RWZWM0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMikpO1xuICAgICAgICAgICAgICAgICAgICAgIGA6YGxldCB4VmFsdWVzID0gdmVjMzxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgaW5wdXREZXB0aE5lYXJlc3RWZWM0LCB4RiwgeFIsIHhDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDEsIHhGLCB4UiwgeEMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMiwgeEYsIHhSLCB4QykpO1xuICAgICAgICAgICAgICAgICAgICBgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlcyA9IHZlYzM8ZjMyPihcbiAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQsIHdGLCB3Uiwgd0MpLFxuICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDEsIHdGLCB3Uiwgd0MpLFxuICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDIsIHdGLCB3Uiwgd0MpKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgJHt4P1widmFsdWUgPSB2YWx1ZSArIGdldEJpYXNCeU91dHB1dENvb3Jkcyhjb29yZHMpXCI6XCJcIn07XG4gICAgICAgICAgICAgICR7an1cbiAgICAgICAgICAgICAgcmVzdWx0W2dsb2JhbF9pZHhdID0gZjMyKHZhbHVlKTtcbiAgICAgICAgICB9YH07cmV0dXJue25hbWU6XCJDb252M0ROYWl2ZVwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9OyR7YX07JHtofTske3h9YCxpbnB1dERlcGVuZGVuY2llczpnfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnIsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6dVswXSx5OnVbMV0sejp1WzJdfSxwcm9ncmFtVW5pZm9ybXM6eX0pLGdldFNoYWRlclNvdXJjZTokfX19KTt2YXIgS3UsanUsWXU9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTthZSgpO3l0KCk7S3U9KGUsdCxyLG4pPT57bGV0IG89ZS5sZW5ndGg+MixpPW8/XCJ2YWx1ZSArPSBiW291dHB1dF9jaGFubmVsXTtcIjpcIlwiLGE9ZVswXS5kaW1zLGQ9ZVsxXS5kaW1zLGw9dC5mb3JtYXQ9PT1cIk5IV0NcIixwPWw/clszXTpyWzFdLG09cC90Lmdyb3VwLHU9bCYmbT49ND9tZShwKToxLGg9Qy5zaXplKHIpL3UsXz1be3R5cGU6MTIsZGF0YTpofSx7dHlwZToxMixkYXRhOnQuZGlsYXRpb25zfSx7dHlwZToxMixkYXRhOlt0LnN0cmlkZXNbMF0sdC5zdHJpZGVzWzFdXX0se3R5cGU6MTIsZGF0YTpbdC5wYWRzWzBdLHQucGFkc1sxXV19LHt0eXBlOjEyLGRhdGE6bX1dO0tlKHQsXyksXy5wdXNoKC4uLk4oYSxbZFswXSxkWzFdLGRbMl0sZFszXS91XSkpO2xldCB5PW8/W1wicmFua1wiLFwicmFua1wiLFwicmFua1wiXTpbXCJyYW5rXCIsXCJyYW5rXCJdO18ucHVzaCguLi5OKFtyWzBdLHJbMV0sclsyXSxyWzNdL3VdKSk7bGV0IGc9eD0+e2xldCAkPU0oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLHIubGVuZ3RoLHUpLHY9X2UoJC50eXBlLnRlbnNvciksUz1xZSh0LCQudHlwZS52YWx1ZSx2KSxUPUUoXCJ4XCIsZVswXS5kYXRhVHlwZSxhLmxlbmd0aCksQT1FKFwid1wiLGVbMV0uZGF0YVR5cGUsZC5sZW5ndGgsdSksaz1bVCxBXTtvJiZrLnB1c2goRShcImJcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcyx1KSk7bGV0IFA9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiZGlsYXRpb25zXCIsdHlwZTpcInUzMlwiLGxlbmd0aDp0LmRpbGF0aW9ucy5sZW5ndGh9LHtuYW1lOlwic3RyaWRlc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6Mn0se25hbWU6XCJwYWRzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDoyfSx7bmFtZTpcIm91dHB1dF9jaGFubmVsc19wZXJfZ3JvdXBcIix0eXBlOlwidTMyXCJ9XTtqZSh0LFApO2xldCBEPWw/YFxuICAgICAgZm9yICh2YXIgd0hlaWdodDogdTMyID0gMHU7IHdIZWlnaHQgPCB1bmlmb3Jtcy53X3NoYXBlWzBdOyB3SGVpZ2h0KyspIHtcbiAgICAgICAgbGV0IHhIZWlnaHQgPSB4UkNDb3JuZXIueCArIHdIZWlnaHQgKiB1bmlmb3Jtcy5kaWxhdGlvbnNbMF07XG5cbiAgICAgICAgaWYgKHhIZWlnaHQgPCAwdSB8fCB4SGVpZ2h0ID49IHVuaWZvcm1zLnhfc2hhcGVbMV0pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIHdXaWR0aDogdTMyID0gMHU7IHdXaWR0aCA8IHVuaWZvcm1zLndfc2hhcGVbMV07IHdXaWR0aCsrKSB7XG4gICAgICAgICAgbGV0IHhXaWR0aCA9IHhSQ0Nvcm5lci55ICsgd1dpZHRoICogdW5pZm9ybXMuZGlsYXRpb25zWzFdO1xuICAgICAgICAgIGlmICh4V2lkdGggPCAwdSB8fCB4V2lkdGggPj0gdW5pZm9ybXMueF9zaGFwZVsyXSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgd0luQ2hhbm5lbDogdTMyID0gMHU7IHdJbkNoYW5uZWwgPCB1bmlmb3Jtcy53X3NoYXBlWzJdOyB3SW5DaGFubmVsKyspIHtcbiAgICAgICAgICAgIGxldCBpbnB1dF9jaGFubmVsID0gaW5fY2hhbm5lbF9vZmZzZXQgKyB3SW5DaGFubmVsO1xuICAgICAgICAgICAgbGV0IHhWYWwgPSAke1QuZ2V0KFwiYmF0Y2hcIixcInhIZWlnaHRcIixcInhXaWR0aFwiLFwiaW5wdXRfY2hhbm5lbFwiKX07XG4gICAgICAgICAgICBsZXQgd1ZhbCA9ICR7QS5nZXQoXCJ3SGVpZ2h0XCIsXCJ3V2lkdGhcIixcIndJbkNoYW5uZWxcIixcIm91dHB1dF9jaGFubmVsXCIpfTtcbiAgICAgICAgICAgIHZhbHVlICs9IHhWYWwgKiB3VmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYDpgXG4gICAgICBmb3IgKHZhciB3SW5DaGFubmVsOiB1MzIgPSAwdTsgd0luQ2hhbm5lbCA8IHVuaWZvcm1zLndfc2hhcGVbMV07IHdJbkNoYW5uZWwrKykge1xuICAgICAgICBsZXQgaW5wdXRfY2hhbm5lbCA9IGluX2NoYW5uZWxfb2Zmc2V0ICsgd0luQ2hhbm5lbDtcbiAgICAgICAgZm9yICh2YXIgd0hlaWdodDogdTMyID0gMHU7IHdIZWlnaHQgPCB1bmlmb3Jtcy53X3NoYXBlWzJdOyB3SGVpZ2h0KyspIHtcbiAgICAgICAgICBsZXQgeEhlaWdodCA9IHhSQ0Nvcm5lci54ICsgd0hlaWdodCAqIHVuaWZvcm1zLmRpbGF0aW9uc1swXTtcblxuICAgICAgICAgIGlmICh4SGVpZ2h0IDwgMHUgfHwgeEhlaWdodCA+PSB1bmlmb3Jtcy54X3NoYXBlWzJdKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciB3V2lkdGg6IHUzMiA9IDB1OyB3V2lkdGggPCB1bmlmb3Jtcy53X3NoYXBlWzNdOyB3V2lkdGgrKykge1xuICAgICAgICAgICAgbGV0IHhXaWR0aCA9IHhSQ0Nvcm5lci55ICsgd1dpZHRoICogdW5pZm9ybXMuZGlsYXRpb25zWzFdO1xuICAgICAgICAgICAgaWYgKHhXaWR0aCA8IDB1IHx8IHhXaWR0aCA+PSB1bmlmb3Jtcy54X3NoYXBlWzNdKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgeFZhbCA9ICR7VC5nZXQoXCJiYXRjaFwiLFwiaW5wdXRfY2hhbm5lbFwiLFwieEhlaWdodFwiLFwieFdpZHRoXCIpfTtcbiAgICAgICAgICAgIGxldCB3VmFsID0gJHtBLmdldChcIm91dHB1dF9jaGFubmVsXCIsXCJ3SW5DaGFubmVsXCIsXCJ3SGVpZ2h0XCIsXCJ3V2lkdGhcIil9O1xuICAgICAgICAgICAgdmFsdWUgKz0geFZhbCAqIHdWYWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBgO3JldHVybmBcbiAgJHt4LnJlZ2lzdGVyVW5pZm9ybXMoUCkuZGVjbGFyZVZhcmlhYmxlcyguLi5rLCQpfVxuXG4gICR7eC5tYWluU3RhcnQoKX1cbiAgICAke3guZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuXG4gICAgbGV0IG91dHB1dEluZGljZXMgPSAkeyQub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgbGV0IGJhdGNoOiB1MzIgPSBvdXRwdXRJbmRpY2VzWzBdO1xuICAgIGxldCBvdXRwdXRfY2hhbm5lbDogdTMyID0gb3V0cHV0SW5kaWNlc1ske2w/MzoxfV07XG4gICAgbGV0IHhSQ0Nvcm5lcjogdmVjMjx1MzI+ID0gdmVjMjx1MzI+KG91dHB1dEluZGljZXNbJHtsPzE6Mn1dLCBvdXRwdXRJbmRpY2VzWyR7bD8yOjN9XSkgKiB1bmlmb3Jtcy5zdHJpZGVzIC0gdW5pZm9ybXMucGFkcztcbiAgICBsZXQgZ3JvdXBfaWQ6IHUzMiA9IG91dHB1dF9jaGFubmVsICogJHt1fSAvIHVuaWZvcm1zLm91dHB1dF9jaGFubmVsc19wZXJfZ3JvdXA7XG4gICAgdmFyIGluX2NoYW5uZWxfb2Zmc2V0ID0gZ3JvdXBfaWQgKiB1bmlmb3Jtcy53X3NoYXBlWyR7bD8yOjF9XTtcblxuICAgIHZhciB2YWx1ZTogJHskLnR5cGUudmFsdWV9ID0gJHskLnR5cGUudmFsdWV9KDApO1xuICAgICR7RH1cbiAgICAke2l9XG4gICAgJHtTfVxuICAgICR7JC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlXCIpfVxuICB9YH07cmV0dXJue25hbWU6XCJHcm91cGVkQ29udlwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9XyR7dX1gLGlucHV0RGVwZW5kZW5jaWVzOnl9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6bj9uKHIpOnIsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGgvNjQpfSxwcm9ncmFtVW5pZm9ybXM6X30pLGdldFNoYWRlclNvdXJjZTpnfX0sanU9KGUsdCxyLG4pPT57bGV0IG89ZS5sZW5ndGg+MixpPW1lKHJbM10pLGE9bWUoclsyXSksZD1DLnNpemUocikvaS9hLGw9W2VbMF0uZGltc1swXSxlWzBdLmRpbXNbMV0sZVswXS5kaW1zWzJdLGVbMF0uZGltc1szXS9pXSxwPVtlWzFdLmRpbXNbMF0sZVsxXS5kaW1zWzFdLGVbMV0uZGltc1syXSxlWzFdLmRpbXNbM10vaV0sbT1bclswXSxyWzFdLHJbMl0sclszXS9pXSx1PVt7dHlwZToxMixkYXRhOmR9LHt0eXBlOjYsZGF0YTpbdC5zdHJpZGVzWzBdLHQuc3RyaWRlc1sxXV19LHt0eXBlOjYsZGF0YTpbdC5wYWRzWzBdLHQucGFkc1sxXV19XTtLZSh0LHUpLHUucHVzaCguLi5OKGwscCxtKSk7bGV0IGg9KGEtMSkqdC5zdHJpZGVzWzFdK3BbMV0sXz15PT57bGV0IGc9TShcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsbS5sZW5ndGgsaSkseD1fZShnLnR5cGUudGVuc29yKSwkPXFlKHQsZy50eXBlLnZhbHVlLHgpLHY9RShcInhcIixlWzBdLmRhdGFUeXBlLGwubGVuZ3RoLGkpLFM9RShcIndcIixlWzFdLmRhdGFUeXBlLHAubGVuZ3RoLGkpLFQ9W3YsU107byYmVC5wdXNoKEUoXCJiXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMsaSkpO2xldCBBPW8/XCJ2YWx1ZSArPSBiW291dHB1dF9jaGFubmVsXTtcIjpcIlwiLGs9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwic3RyaWRlc1wiLHR5cGU6XCJpMzJcIixsZW5ndGg6Mn0se25hbWU6XCJwYWRzXCIsdHlwZTpcImkzMlwiLGxlbmd0aDoyfV07cmV0dXJuIGplKHQsayksYFxuICAke3kucmVnaXN0ZXJVbmlmb3JtcyhrKS5kZWNsYXJlVmFyaWFibGVzKC4uLlQsZyl9XG4gICR7eS5tYWluU3RhcnQoKX1cbiAgICAke3kuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgIGxldCB3aWR0aDAgPSB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbM107XG4gICAgbGV0IG91dHB1dF9jaGFubmVsID0gZ2xvYmFsX2lkeCAlIHdpZHRoMDtcbiAgICB2YXIgaW5kZXgxID0gZ2xvYmFsX2lkeCAvIHdpZHRoMDtcbiAgICBsZXQgd2lkdGgxID0gdW5pZm9ybXMub3V0cHV0X3NoYXBlWzJdIC8gJHthfXU7XG4gICAgbGV0IGNvbCA9IChpbmRleDEgJSB3aWR0aDEpICogJHthfXU7XG4gICAgaW5kZXgxID0gaW5kZXgxIC8gd2lkdGgxO1xuICAgIGxldCByb3cgPSBpbmRleDEgJSB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMV07XG4gICAgbGV0IGJhdGNoID0gaW5kZXgxIC8gdW5pZm9ybXMub3V0cHV0X3NoYXBlWzFdO1xuXG4gICAgbGV0IHhfY29ybmVyID0gdmVjMjxpMzI+KGkzMihyb3cpLCBpMzIoY29sKSkgKiB1bmlmb3Jtcy5zdHJpZGVzIC0gdW5pZm9ybXMucGFkcztcblxuICAgIHZhciB4X3ZhbHM6IGFycmF5PCR7di50eXBlLnZhbHVlfSwgJHtofT47XG4gICAgdmFyIHZhbHVlczogYXJyYXk8JHtnLnR5cGUudmFsdWV9LCAke2F9PjtcbiAgICBsZXQgaW5wdXRfY2hhbm5lbCA9IG91dHB1dF9jaGFubmVsO1xuICAgIC8vIFVzZSBjb25zdGFudCBpbnN0ZWFkIG9mIHVuaWZvcm0gY2FuIGdpdmUgYmV0dGVyIHBlcmZvcm1hbmNlIGZvciB3J3MgaGVpZ2h0L3dpZHRoLlxuICAgIGZvciAodmFyIHdfaGVpZ2h0OiB1MzIgPSAwdTsgd19oZWlnaHQgPCAke3BbMF19OyB3X2hlaWdodCsrKSB7XG4gICAgICBsZXQgeF9oZWlnaHQgPSB4X2Nvcm5lci54ICsgaTMyKHdfaGVpZ2h0KTtcbiAgICAgIGlmICh4X2hlaWdodCA+PSAwICYmIHUzMih4X2hlaWdodCkgPCB1bmlmb3Jtcy54X3NoYXBlWzFdKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgJHtofTsgaSsrKSB7XG4gICAgICAgICAgbGV0IHhfd2lkdGggPSB4X2Nvcm5lci55ICsgaTtcbiAgICAgICAgICBpZiAoeF93aWR0aCA+PSAwICYmIHUzMih4X3dpZHRoKSA8IHVuaWZvcm1zLnhfc2hhcGVbMl0pIHtcbiAgICAgICAgICAgIHhfdmFsc1tpXSA9ICR7di5nZXQoXCJiYXRjaFwiLFwidTMyKHhfaGVpZ2h0KVwiLFwidTMyKHhfd2lkdGgpXCIsXCJpbnB1dF9jaGFubmVsXCIpfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeF92YWxzW2ldID0gJHt2LnR5cGUudmFsdWV9KDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciB3X3dpZHRoOiB1MzIgPSAwdTsgd193aWR0aCA8ICR7cFsxXX07IHdfd2lkdGgrKykge1xuICAgICAgICAgIGxldCB3X3ZhbCA9ICR7Uy5nZXQoXCJ3X2hlaWdodFwiLFwid193aWR0aFwiLFwiMFwiLFwib3V0cHV0X2NoYW5uZWxcIil9O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwdTsgaSA8ICR7YX11OyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlc1tpXSA9IGZtYSh4X3ZhbHNbaSAqIHUzMih1bmlmb3Jtcy5zdHJpZGVzWzFdKSArIHdfd2lkdGhdLCB3X3ZhbCwgdmFsdWVzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMHU7IGkgPCAke2F9dTsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAke0F9XG4gICAgICAkeyR9XG4gICAgICAke2cuc2V0KFwiYmF0Y2hcIixcInJvd1wiLFwiY29sICsgaVwiLFwib3V0cHV0X2NoYW5uZWxcIixcInZhbHVlXCIpfTtcbiAgICB9XG4gIH1gfTtyZXR1cm57bmFtZTpcIkdyb3VwZWRDb252LVZlY3Rvcml6ZVwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9OyR7aX07JHthfTske2h9OyR7cFswXX07JHtwWzFdfWAsaW5wdXREZXBlbmRlbmNpZXM6bz9bXCJyYW5rXCIsXCJyYW5rXCIsXCJ0eXBlXCJdOltcInJhbmtcIixcInJhbmtcIl19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6bj9uKHIpOnIsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGQvNjQpfSxwcm9ncmFtVW5pZm9ybXM6dX0pLGdldFNoYWRlclNvdXJjZTpffX19KTt2YXIgbWYsYm8sZmYseW8sX28sWnUsaGYsZ2Ysd28sUXU9VSgoKT0+e1widXNlIHN0cmljdFwiO29lKCk7V3UoKTtxdSgpO1hyKCk7WXUoKTt5dCgpO1FyKCk7ZHQoKTttZj0oZSx0LHIsbixvLGkpPT57bGV0IGE9ZVswXSxkPWUuc2xpY2UoaT8xOjIsaT8zOjQpLGw9ZC5sZW5ndGgscD10WzBdLHU9dC5zbGljZSgyKS5tYXAoKHksZyk9PnkrKHktMSkqKHJbZ10tMSkpLF89ZC5tYXAoKHksZyk9PnkrbltnXStuW2crbF0pLm1hcCgoeSxnKT0+TWF0aC5mbG9vcigoeS11W2ddK29bZ10pL29bZ10pKTtyZXR1cm4gXy5zcGxpY2UoMCwwLGEpLF8uc3BsaWNlKGk/MzoxLDAscCksX30sYm89WzIsMywxLDBdLGZmPShlLHQpPT57aWYoIWV8fGUubGVuZ3RoIT09MiYmZS5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcihcIkNvbnYgcmVxdWlyZXMgMiBvciAzIGlucHV0c1wiKTtpZihlWzBdLmRpbXMubGVuZ3RoPjUpdGhyb3cgbmV3IEVycm9yKFwiZ3JlYXRlciB0aGFuIDVEIGlzIG5vdCBzdXBwb3J0ZWRcIik7aWYoZVswXS5kaW1zLmxlbmd0aCE9PWVbMV0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiZmlsdGVyIGRvZXMgbm90IGhhdmUgc2FtZSBkaW1lbnNpb24gYXMgaW5wdXRcIik7bGV0IHI9ZVswXS5kaW1zW3QuZm9ybWF0PT09XCJOSFdDXCI/ZVswXS5kaW1zLmxlbmd0aC0xOjFdLG49ZVsxXS5kaW1zWzFdKnQuZ3JvdXA7aWYociE9PW4pdGhyb3cgbmV3IEVycm9yKFwiRklMVEVSX0lOX0NIQU5ORUwgc2hvdWxkIGJlIGVxdWFsIHRvIERBVEFfQ0hBTk5FTFwiKTtpZihlLmxlbmd0aD09PTMmJihlWzJdLmRpbXMubGVuZ3RoIT09MXx8ZVsxXS5kaW1zWzBdIT09ZVsyXS5kaW1zWzBdKSl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJpYXNcIik7bGV0IG89ZVswXS5kaW1zLmxlbmd0aC0yO2lmKHQuZGlsYXRpb25zLmxlbmd0aCE9PW8pdGhyb3cgbmV3IEVycm9yKGBkaWxhdGlvbnMgc2hvdWxkIGJlICR7b31EYCk7aWYodC5zdHJpZGVzLmxlbmd0aCE9PW8pdGhyb3cgbmV3IEVycm9yKGBzdHJpZGVzIHNob3VsZCBiZSAke299RGApO2lmKHQucGFkcy5sZW5ndGghPT1vKjIpdGhyb3cgbmV3IEVycm9yKGBwYWRzIHNob3VsZCBiZSAke28qMn1EYCk7aWYodC5rZXJuZWxTaGFwZS5sZW5ndGghPT0wJiZ0Lmtlcm5lbFNoYXBlLmxlbmd0aCE9PWVbMV0uZGltcy5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGtlcm5lbCBzaGFwZVwiKX0seW89KGUsdCk9PntsZXQgcj1lLmtlcm5lbFNoYXBlLnNsaWNlKCk7ci5sZW5ndGg8dFsxXS5kaW1zLmxlbmd0aC0yJiZyLnB1c2goLi4uQXJyYXkodFsxXS5kaW1zLmxlbmd0aC0yLXIubGVuZ3RoKS5maWxsKDApKTtmb3IobGV0IGk9MjtpPHRbMV0uZGltcy5sZW5ndGg7KytpKXJbaS0yXT09PTAmJihyW2ktMl09dFsxXS5kaW1zW2ldKTtsZXQgbj1lLnBhZHMuc2xpY2UoKTtBdC5hZGp1c3RQYWRzQmFzZWRPbkF1dG9QYWQodFswXS5kaW1zLGUuc3RyaWRlcyxlLmRpbGF0aW9ucyxyLG4sZS5mb3JtYXQ9PT1cIk5IV0NcIixlLmF1dG9QYWQpO2xldCBvPU9iamVjdC5hc3NpZ24oe30sZSk7cmV0dXJuIE9iamVjdC5hc3NpZ24obyx7a2VybmVsU2hhcGU6cixwYWRzOm59KSxvfSxfbz1lPT57bGV0IHQ9anIoZSkscj1lLmZvcm1hdCxuPVtcIk5PVFNFVFwiLFwiVkFMSURcIixcIlNBTUVfVVBQRVJcIixcIlNBTUVfTE9XRVJcIl1bZS5hdXRvX3BhZF0sbz1lLmRpbGF0aW9ucyxpPWUuZ3JvdXAsYT1lLmtlcm5lbF9zaGFwZSxkPWUucGFkcyxsPWUuc3RyaWRlcyxwPWUud19pc19jb25zdCgpO3JldHVybnthdXRvUGFkOm4sZm9ybWF0OnIsZGlsYXRpb25zOm8sZ3JvdXA6aSxrZXJuZWxTaGFwZTphLHBhZHM6ZCxzdHJpZGVzOmwsd0lzQ29uc3Q6cCwuLi50LGNhY2hlS2V5OmAke2UuZm9ybWF0fTske3QuYWN0aXZhdGlvbn07YH19LFp1PShlLHQscixuKT0+e2xldCBvPXIuZm9ybWF0PT09XCJOSFdDXCIsaT1tZih0WzBdLmRpbXMsdFsxXS5kaW1zLHIuZGlsYXRpb25zLHIucGFkcyxyLnN0cmlkZXMsbyk7aWYoci5ncm91cCE9PTEpe2xldCBrPVt0WzBdXTtpZihvKXtsZXQgRD1lLmtlcm5lbEN1c3RvbURhdGEud1Q/P2UuY29tcHV0ZShQZSh0WzFdLGJvKSx7aW5wdXRzOlsxXSxvdXRwdXRzOltyLndJc0NvbnN0Py0yOi0xXX0pWzBdO3Iud0lzQ29uc3QmJiFlLmtlcm5lbEN1c3RvbURhdGEud1QmJihlLmtlcm5lbEN1c3RvbURhdGEud1Q9RCksay5wdXNoKEQpfWVsc2Ugay5wdXNoKHRbMV0pO3QubGVuZ3RoPT09MyYmay5wdXNoKHRbMl0pLCFlLmFkYXB0ZXJJbmZvLmlzQXJjaGl0ZWN0dXJlKFwiYW1wZXJlXCIpJiZvJiZ0WzFdLmRpbXNbMF09PT1yLmdyb3VwJiZ0WzFdLmRpbXNbMV09PT0xJiZyLmRpbGF0aW9uc1swXT09PTEmJnIuZGlsYXRpb25zWzFdPT09MT9lLmNvbXB1dGUoanUoayxyLGksbikse2lucHV0czprfSk6ZS5jb21wdXRlKEt1KGsscixpLG4pLHtpbnB1dHM6a30pO3JldHVybn1sZXQgYT10Lmxlbmd0aD09PTMsZD10WzBdLmRpbXNbbz8xOjJdLGw9dFswXS5kaW1zW28/MjozXSxwPXRbMF0uZGltc1tvPzM6MV0sbT10WzFdLmRpbXNbMl0sdT10WzFdLmRpbXNbM10saD1pW28/MToyXSxfPWlbbz8yOjNdLHk9aVtvPzM6MV0sZz1vJiZtPT09ZCYmdT09PWwmJnIucGFkc1swXT09PTAmJnIucGFkc1sxXT09PTA7aWYoZ3x8bT09PTEmJnU9PT0xJiZyLmRpbGF0aW9uc1swXT09PTEmJnIuZGlsYXRpb25zWzFdPT09MSYmci5zdHJpZGVzWzBdPT09MSYmci5zdHJpZGVzWzFdPT09MSYmci5wYWRzWzBdPT09MCYmci5wYWRzWzFdPT09MCl7bGV0IGs9aVswXSxQLEQsUixHPVtdO2lmKG8pe2xldCBWPWUua2VybmVsQ3VzdG9tRGF0YS53VD8/ZS5jb21wdXRlKFBlKHRbMV0sYm8pLHtpbnB1dHM6WzFdLG91dHB1dHM6W3Iud0lzQ29uc3Q/LTI6LTFdfSlbMF07aWYoci53SXNDb25zdCYmIWUua2VybmVsQ3VzdG9tRGF0YS53VCYmKGUua2VybmVsQ3VzdG9tRGF0YS53VD1WKSxnKXtsZXQgUT1kKmwqcDtQPXRbMF0ucmVzaGFwZShbMSxrLFFdKSxEPVYucmVzaGFwZShbMSxRLHldKSxSPVsxLGsseV19ZWxzZSBQPXRbMF0ucmVzaGFwZShbayxkKmwscF0pLEQ9Vi5yZXNoYXBlKFsxLHAseV0pLFI9W2ssaCpfLHldO0cucHVzaChQKSxHLnB1c2goRCl9ZWxzZSBQPXRbMF0ucmVzaGFwZShbayxwLGQqbF0pLEQ9dFsxXS5yZXNoYXBlKFsxLHkscF0pLFI9W2sseSxoKl9dLEcucHVzaChEKSxHLnB1c2goUCk7YSYmRy5wdXNoKHRbMl0pO2xldCBLPVJbMl0saj1HWzBdLmRpbXNbR1swXS5kaW1zLmxlbmd0aC0xXTtLPDgmJmo8OD9lLmNvbXB1dGUoWnIoRyxyLGksUixvLG4pLHtpbnB1dHM6R30pOmUuY29tcHV0ZShlcihHLHIsaSxSLG8sbikse2lucHV0czpHfSk7cmV0dXJufWxldCB4PSEwLCQ9ZS5rZXJuZWxDdXN0b21EYXRhLndUPz9lLmNvbXB1dGUoUGUodFsxXSxibykse2lucHV0czpbMV0sb3V0cHV0czpbci53SXNDb25zdD8tMjotMV19KVswXTtyLndJc0NvbnN0JiYhZS5rZXJuZWxDdXN0b21EYXRhLndUJiYoZS5rZXJuZWxDdXN0b21EYXRhLndUPSQpO2xldCB2PVt0WzBdLCRdO2EmJnYucHVzaCh0WzJdKTtsZXQgUz1vP2gqXzp5LFQ9bz95OmgqXyxBPW0qdSpwO2UuY29tcHV0ZShWdSh2LHIsaSxTLFQsQSxhLHgsbikse2lucHV0czp2fSl9LGhmPShlLHQpPT57bGV0IHI9dC5mb3JtYXQ9PT1cIk5IV0NcIixuPVtlLmlucHV0c1swXS5yZXNoYXBlKHI/W2UuaW5wdXRzWzBdLmRpbXNbMF0sMSxlLmlucHV0c1swXS5kaW1zWzFdLGUuaW5wdXRzWzBdLmRpbXNbMl1dOltlLmlucHV0c1swXS5kaW1zWzBdLGUuaW5wdXRzWzBdLmRpbXNbMV0sMSxlLmlucHV0c1swXS5kaW1zWzJdXSksZS5pbnB1dHNbMV0ucmVzaGFwZShbZS5pbnB1dHNbMV0uZGltc1swXSxlLmlucHV0c1sxXS5kaW1zWzFdLDEsZS5pbnB1dHNbMV0uZGltc1syXV0pXTtlLmlucHV0cy5sZW5ndGg9PT0zJiZuLnB1c2goZS5pbnB1dHNbMl0pO2xldCBvPVswLHQucGFkc1swXSwwLHQucGFkc1sxXV0saT1bMV0uY29uY2F0KHQuc3RyaWRlcyksYT1bMV0uY29uY2F0KHQuZGlsYXRpb25zKSxkPVsxXS5jb25jYXQodC5rZXJuZWxTaGFwZSksbD15byh7Li4udCxwYWRzOm8sc3RyaWRlczppLGRpbGF0aW9uczphLGtlcm5lbFNoYXBlOmR9LG4pO1p1KGUsbixsLHA9PnI/W3BbMF0scFsyXSxwWzNdXTpbcFswXSxwWzFdLHBbM11dKX0sZ2Y9KGUsdCxyKT0+e2xldCBuPXIuZm9ybWF0PT09XCJOSFdDXCI/XCJjaGFubmVsc0xhc3RcIjpcImNoYW5uZWxzRmlyc3RcIixvPXlvKHIsdCksaT1yLmF1dG9QYWQ9PT1cIk5PVFNFVFwiP3IucGFkczpyLmF1dG9QYWQsYT1IdSh0WzBdLmRpbXMsdFsxXS5kaW1zLHIuc3RyaWRlcyxyLmRpbGF0aW9ucyxpLCExLG4pO2UuY29tcHV0ZShGdSh0LG8sYS5vdXRTaGFwZSxbYS5maWx0ZXJEZXB0aCxhLmZpbHRlckhlaWdodCxhLmZpbHRlcldpZHRoXSxbYS5wYWRJbmZvLmZyb250LGEucGFkSW5mby50b3AsYS5wYWRJbmZvLmxlZnRdLG4pKX0sd289KGUsdCk9PntpZihmZihlLmlucHV0cyx0KSxlLmlucHV0c1swXS5kaW1zLmxlbmd0aD09PTMpaGYoZSx0KTtlbHNlIGlmKGUuaW5wdXRzWzBdLmRpbXMubGVuZ3RoPT09NSlnZihlLGUuaW5wdXRzLHQpO2Vsc2V7bGV0IHI9eW8odCxlLmlucHV0cyk7WnUoZSxlLmlucHV0cyxyKX19fSk7dmFyIFh1LEp1PVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO2V0KCk7b2UoKTthZSgpO1h1PShlLHQscik9PntsZXQgbj1lLmxlbmd0aD4yLG89dC5vdXRwdXRTaGFwZSxpPXQuZm9ybWF0PT09XCJOSFdDXCIsYT10Lmdyb3VwLGQ9ZVsxXS5kaW1zLGw9ZFsyXS9hLHA9ZFszXSxtPWk/bWUobCk6MSx1PWk/bWUocCk6MSxoPWk/cD09PTE/bTp1OjEsXz1DLnNpemUobykvdSx5PVtNYXRoLmNlaWwoXy82NCksMSwxXTt1ZShcInZlcmJvc2VcIiwoKT0+YFtjb252MmRfYmFja3Byb3Bfd2ViZ3B1XSBkaXNwYXRjaCA9ICR7eX1gKTtsZXQgZz1bXCJyYW5rXCIsXCJyYW5rXCJdLHg9W3Quc3RyaWRlc1swXSx0LnN0cmlkZXNbMV1dLCQ9W3Qua2VybmVsU2hhcGVbaT8xOjJdLHQua2VybmVsU2hhcGVbaT8yOjNdXSx2PVt0LmRpbGF0aW9uc1swXSx0LmRpbGF0aW9uc1sxXV0sUz1bJFswXSsodC5kaWxhdGlvbnNbMF08PTE/MDoodC5rZXJuZWxTaGFwZVtpPzE6Ml0tMSkqKHQuZGlsYXRpb25zWzBdLTEpKSwkWzFdKyh0LmRpbGF0aW9uc1sxXTw9MT8wOih0Lmtlcm5lbFNoYXBlW2k/MjozXS0xKSoodC5kaWxhdGlvbnNbMV0tMSkpXSxUPVtTWzBdLTEtTWF0aC5mbG9vcigodC5wYWRzWzBdK3QucGFkc1syXSkvMiksU1sxXS0xLU1hdGguZmxvb3IoKHQucGFkc1sxXSt0LnBhZHNbM10pLzIpXSxBPVt7dHlwZToxMixkYXRhOl99LHt0eXBlOjEyLGRhdGE6eH0se3R5cGU6MTIsZGF0YTokfSx7dHlwZToxMixkYXRhOnZ9LHt0eXBlOjEyLGRhdGE6U30se3R5cGU6NixkYXRhOlR9LHt0eXBlOjEyLGRhdGE6bH0se3R5cGU6MTIsZGF0YTpwfSwuLi5OKGVbMF0uZGltcyxlWzFdLmRpbXMpXTtuJiYoQS5wdXNoKC4uLk4oZVsyXS5kaW1zKSksZy5wdXNoKFwicmFua1wiKSksQS5wdXNoKC4uLk4obykpO2xldCBrPVA9PntsZXQgRD1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJzdHJpZGVzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDp4Lmxlbmd0aH0se25hbWU6XCJmaWx0ZXJfZGltc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6JC5sZW5ndGh9LHtuYW1lOlwiZGlsYXRpb25zXCIsdHlwZTpcInUzMlwiLGxlbmd0aDokLmxlbmd0aH0se25hbWU6XCJlZmZlY3RpdmVfZmlsdGVyX2RpbXNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOlMubGVuZ3RofSx7bmFtZTpcInBhZHNcIix0eXBlOlwiaTMyXCIsbGVuZ3RoOlQubGVuZ3RofSx7bmFtZTpcImlucHV0X2NoYW5uZWxzX3Blcl9ncm91cFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJvdXRwdXRfY2hhbm5lbHNfcGVyX2dyb3VwXCIsdHlwZTpcInUzMlwifV0sUj1fZShlWzBdLmRhdGFUeXBlKSxHPWk/MToyLEs9aT8yOjMsaj1pPzM6MSxWPUUoXCJXXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMubGVuZ3RoLGgpLFE9RShcIkR5XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMubGVuZ3RoLG0pLHNlPVtRLFZdO24mJnNlLnB1c2goRShcImJpYXNcIixlWzJdLmRhdGFUeXBlLFtvW2pdXS5sZW5ndGgsdSkpO2xldCBZPU0oXCJyZXN1bHRcIixlWzBdLmRhdGFUeXBlLG8ubGVuZ3RoLHUpLGVlPSgpPT57bGV0IG5lPVwiXCI7aWYobT09PTEpbmUrPWBcbiAgICAgICAgbGV0IHdfb2Zmc2V0ID0gJHtWLmluZGljZXNUb09mZnNldChgJHtWLnR5cGUuaW5kaWNlc30odTMyKHdSUGVybSksIHUzMih3Q1Blcm0pLCBpbnB1dENoYW5uZWwsIHdPdXRDaGFubmVsKWApfTtcbiAgICAgICAgbGV0IHdWYWx1ZSA9ICR7Vi5nZXRCeU9mZnNldChgd19vZmZzZXQgLyAke2h9YCl9O1xuICAgICAgICBkb3RQcm9kID0gZG90UHJvZCArIHhWYWx1ZSAqIHdWYWx1ZTtgO2Vsc2UgaWYocD09PTEpbmUrPWBcbiAgICAgICAgICBsZXQgd1ZhbHVlID0gJHtWLmdldEJ5T2Zmc2V0KGAke1YuaW5kaWNlc1RvT2Zmc2V0KGAke1YudHlwZS5pbmRpY2VzfSh1MzIod1JQZXJtKSwgdTMyKHdDUGVybSksIGlucHV0Q2hhbm5lbCwgd091dENoYW5uZWwpYCl9IC8gJHtofWApfTtcbiAgICAgICAgICBkb3RQcm9kID0gZG90UHJvZCArIGRvdCh4VmFsdWUsIHdWYWx1ZSk7YDtlbHNlIGZvcihsZXQgYmU9MDtiZTxtO2JlKyspbmUrPWBcbiAgICAgICAgICAgIGxldCB3VmFsdWUke2JlfSA9ICR7Vi5nZXRCeU9mZnNldChgJHtWLmluZGljZXNUb09mZnNldChgJHtWLnR5cGUuaW5kaWNlc30odTMyKHdSUGVybSksIHUzMih3Q1Blcm0pLCBpbnB1dENoYW5uZWwgKyAke2JlfSwgd091dENoYW5uZWwpYCl9IC8gJHtofWApfTtcbiAgICAgICAgICAgIGRvdFByb2QgPSBkb3RQcm9kICsgeFZhbHVlWyR7YmV9XSAqIHdWYWx1ZSR7YmV9O2A7cmV0dXJuIG5lfSxKPWBcbiAgICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtZLm9mZnNldFRvSW5kaWNlcyhgZ2xvYmFsX2lkeCAqICR7dX1gKX07XG4gICAgICAgICAgICBsZXQgYmF0Y2ggPSAke1kuaW5kaWNlc0dldChcIm91dHB1dEluZGljZXNcIiwwKX07XG4gICAgICAgICAgICBsZXQgZDEgPSAke1kuaW5kaWNlc0dldChcIm91dHB1dEluZGljZXNcIixqKX07XG4gICAgICAgICAgICBsZXQgciA9ICR7WS5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLEcpfTtcbiAgICAgICAgICAgIGxldCBjID0gJHtZLmluZGljZXNHZXQoXCJvdXRwdXRJbmRpY2VzXCIsSyl9O1xuICAgICAgICAgICAgbGV0IGR5Q29ybmVyID0gdmVjMjxpMzI+KGkzMihyKSwgaTMyKGMpKSAtIHVuaWZvcm1zLnBhZHM7XG4gICAgICAgICAgICBsZXQgZHlSQ29ybmVyID0gZHlDb3JuZXIueDtcbiAgICAgICAgICAgIGxldCBkeUNDb3JuZXIgPSBkeUNvcm5lci55O1xuICAgICAgICAgICAgbGV0IGdyb3VwSWQgPSBkMSAvIHVuaWZvcm1zLm91dHB1dF9jaGFubmVsc19wZXJfZ3JvdXA7XG4gICAgICAgICAgICBsZXQgd091dENoYW5uZWwgPSBkMSAtIGdyb3VwSWQgKiB1bmlmb3Jtcy5vdXRwdXRfY2hhbm5lbHNfcGVyX2dyb3VwO1xuICAgICAgICAgICAgLy8gQ29udm9sdmUgZHkoPywgPywgZDIpIHdpdGggdyg6LCA6LCBkMSwgZDIpIHRvIGNvbXB1dGUgZHgoeFIsIHhDLCBkMSkuXG4gICAgICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cbiAgICAgICAgICAgIHZhciBkb3RQcm9kID0gJHtZLnR5cGUudmFsdWV9KDAuMCk7XG4gICAgICAgICAgICBmb3IgKHZhciB3UjogdTMyID0gMDsgd1IgPCB1bmlmb3Jtcy5lZmZlY3RpdmVfZmlsdGVyX2RpbXMueDsgd1IgPSB3UiArIDEpIHtcbiAgICAgICAgICAgICAgaWYgKHdSICUgdW5pZm9ybXMuZGlsYXRpb25zLnggIT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldCBkeVIgPSAoJHtSfShkeVJDb3JuZXIpICsgJHtSfSh3UikpIC8gJHtSfSh1bmlmb3Jtcy5zdHJpZGVzWzBdKTtcbiAgICAgICAgICAgICAgbGV0IHdSUGVybSA9IHVuaWZvcm1zLmZpbHRlcl9kaW1zLnggLSAxIC0gd1IgLyB1bmlmb3Jtcy5kaWxhdGlvbnMueDtcbiAgICAgICAgICAgICAgaWYgKGR5UiA8IDAuMCB8fCBkeVIgPj0gJHtSfSh1bmlmb3Jtcy5EeV9zaGFwZVske0d9XSkgfHwgZnJhY3QoZHlSKSA+IDAuMCB8fFxuICAgICAgICAgICAgICAgICAgd1JQZXJtIDwgMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdSID0gd1IgKyB1bmlmb3Jtcy5zdHJpZGVzWzBdIC0gMTtcbiAgICAgICAgICAgICAgbGV0IGlkeVI6IHUzMiA9IHUzMihkeVIpO1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIHdDOiB1MzIgPSAwOyB3QyA8IHVuaWZvcm1zLmVmZmVjdGl2ZV9maWx0ZXJfZGltcy55OyB3QyA9IHdDICsgMSkge1xuICAgICAgICAgICAgICAgIGlmICh3QyAlIHVuaWZvcm1zLmRpbGF0aW9ucy55ICE9IDApIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgZHlDID0gKCR7Un0oZHlDQ29ybmVyKSArICR7Un0od0MpKSAvICR7Un0odW5pZm9ybXMuc3RyaWRlcy55KTtcbiAgICAgICAgICAgICAgICBsZXQgd0NQZXJtID0gdW5pZm9ybXMuZmlsdGVyX2RpbXMueSAtIDEgLSB3QyAvIHVuaWZvcm1zLmRpbGF0aW9ucy55O1xuICAgICAgICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49ICR7Un0odW5pZm9ybXMuRHlfc2hhcGVbJHtLfV0pIHx8XG4gICAgICAgICAgICAgICAgICAgIGZyYWN0KGR5QykgPiAwLjAgfHwgd0NQZXJtIDwgMCkge1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdDID0gd0MgKyB1bmlmb3Jtcy5zdHJpZGVzLnkgLSAxO1xuICAgICAgICAgICAgICAgIGxldCBpZHlDOiB1MzIgPSB1MzIoZHlDKTtcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXRDaGFubmVsID0gZ3JvdXBJZCAqIHVuaWZvcm1zLmlucHV0X2NoYW5uZWxzX3Blcl9ncm91cDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBkMjogdTMyID0gMDsgZDIgPCB1bmlmb3Jtcy5pbnB1dF9jaGFubmVsc19wZXJfZ3JvdXA7IGQyID0gZDIgKyAke219KSB7XG4gICAgICAgICAgICAgICAgICBsZXQgeFZhbHVlID0gJHtpP1EuZ2V0QnlPZmZzZXQoYCR7US5pbmRpY2VzVG9PZmZzZXQoYCR7US50eXBlLmluZGljZXN9KGJhdGNoLCBpZHlSLCBpZHlDLCBpbnB1dENoYW5uZWwpYCl9IC8gJHttfWApOlEuZ2V0KFwiYmF0Y2hcIixcImlucHV0Q2hhbm5lbFwiLFwiaWR5UlwiLFwiaWR5Q1wiKX07XG4gICAgICAgICAgICAgICAgICAke2VlKCl9XG4gICAgICAgICAgICAgICAgICBpbnB1dENoYW5uZWwgPSBpbnB1dENoYW5uZWwgKyAke219O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHZhbHVlID0gZG90UHJvZCR7bj9gICsgYmlhc1tkMSAvICR7dX1dYDpcIlwifTtcbiAgICAgICAgICAgICR7WS5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlXCIpfTtcbiAgICAgICAgICBgO3JldHVybmBcbiAgICAke1AucmVnaXN0ZXJVbmlmb3JtcyhEKS5kZWNsYXJlVmFyaWFibGVzKC4uLnNlLFkpfVxuICAgICAgJHtQLm1haW5TdGFydCgpfVxuICAgICAgJHtQLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX07XG4gICAgJHtKfX1gfTtyZXR1cm57bmFtZTpcIkNvbnZUcmFuc3Bvc2UyRFwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9OyR7bX0ke2h9JHt1fSR7cD09PTF9YCxpbnB1dERlcGVuZGVuY2llczpnfSxnZXRSdW5EYXRhOigpPT4oe2Rpc3BhdGNoR3JvdXA6e3g6eVswXSx5OnlbMV0sejp5WzJdfSxvdXRwdXRzOlt7ZGltczpyP3Iobyk6byxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0scHJvZ3JhbVVuaWZvcm1zOkF9KSxnZXRTaGFkZXJTb3VyY2U6a319fSk7dmFyIGJmLHlmLF9mLGVkLHRkLHdmLHJkLHZmLG5kLG9kPVUoKCk9PntcInVzZSBzdHJpY3RcIjtKdSgpO3l0KCk7ZHQoKTtiZj0oZSx0LHIsbixvLGkpPT4oZS0xKSp0K3IrKG4tMSkqbysxLWkseWY9KGUsdCxyLG4sbyk9PntsZXQgaT1NYXRoLmZsb29yKGUvMik7dD09PVwiU0FNRV9VUFBFUlwiPyhyW25dPWkscltvXT1lLWkpOnQ9PT1cIlNBTUVfTE9XRVJcIiYmKHJbbl09ZS1pLHJbb109aSl9LF9mPShlLHQscixuLG8saSxhLGQsbCxwKT0+e2xldCBtPWUubGVuZ3RoLTIsdT1wLmxlbmd0aD09PTA7bC5sZW5ndGg8bSYmbC5wdXNoKC4uLkFycmF5KG0tbC5sZW5ndGgpLmZpbGwoMCkpO2xldCBoPWVbMF0sXz10W2Q/MzoxXSpvO2ZvcihsZXQgeT0wLGc9ZS5sZW5ndGgtbS0oZD8xOjApO3k8bTsrK3ksKytnKXtsZXQgeD1lW2ddLCQ9dT94KmFbeV06cFt5XSx2PWJmKHgsYVt5XSxpW3ldLHRbZ10sclt5XSwkKTt5Zih2LG4saSx5LHkrbSksdSYmcC5wdXNoKGFbeV0qKHgtMSkrbFt5XSsodFtnXS0xKSpyW3ldKzEtaVt5XS1pW3krbV0pfXAuc3BsaWNlKDAsMCxoKSxwLnNwbGljZShkPzM6MSwwLF8pfSxlZD0oZSx0KT0+e2xldCByPWUua2VybmVsU2hhcGUuc2xpY2UoKTtpZihlLmtlcm5lbFNoYXBlLmxlbmd0aD09PTB8fGUua2VybmVsU2hhcGUucmVkdWNlKCh1LGgpPT51KmgsMSk9PT0wKXtyLmxlbmd0aD0wO2ZvcihsZXQgdT0yO3U8dFsxXS5kaW1zLmxlbmd0aDsrK3Upci5wdXNoKHRbMV0uZGltc1t1XSl9bGV0IG49ZS5mb3JtYXQ9PT1cIk5IV0NcIjtyLnNwbGljZSgwLDAsdFsxXS5kaW1zWzBdKSxyLnNwbGljZShuPzM6MSwwLHRbMV0uZGltc1sxXSk7bGV0IG89ZS5wYWRzLnNsaWNlKCksaT1lLm91dHB1dFNoYXBlLnNsaWNlKCksYT1lLm91dHB1dFBhZGRpbmcuc2xpY2UoKSxkPXRbMF0uZGltcyxsPWUuZGlsYXRpb25zLnNsaWNlKCk7aWYobC5yZWR1Y2UoKHUsaCk9PnUraCwwKT09PTApe2xldCB1PXRbMF0uZGltcy5sZW5ndGgtMjtsPW5ldyBBcnJheSh1KS5maWxsKDEpfWxldCBwPWUuc3RyaWRlcy5zbGljZSgpO2lmKHAucmVkdWNlKCh1LGgpPT51K2gsMCk9PT0wKXtsZXQgdT10WzBdLmRpbXMubGVuZ3RoLTI7cD1uZXcgQXJyYXkodSkuZmlsbCgxKX1fZihkLHIsbCxlLmF1dG9QYWQsZS5ncm91cCxvLHAsbixhLGkpO2xldCBtPU9iamVjdC5hc3NpZ24oe30sZSk7cmV0dXJuIE9iamVjdC5hc3NpZ24obSx7a2VybmVsU2hhcGU6cixwYWRzOm8sb3V0cHV0UGFkZGluZzphLG91dHB1dFNoYXBlOmksZGlsYXRpb25zOmwsc3RyaWRlczpwfSksbX0sdGQ9ZT0+e2xldCB0PWpyKGUpLHI9ZS5mb3JtYXQsbj1bXCJOT1RTRVRcIixcIlZBTElEXCIsXCJTQU1FX1VQUEVSXCIsXCJTQU1FX0xPV0VSXCJdW3R5cGVvZiBlLmF1dG9QYWQ+XCJ1XCI/MDplLmF1dG9QYWRdLG89ZS5kaWxhdGlvbnMsaT1lLmdyb3VwLGE9ZS5rZXJuZWxTaGFwZSxkPWUucGFkcyxsPWUuc3RyaWRlcyxwPWUud0lzQ29uc3QoKSxtPWUub3V0cHV0UGFkZGluZyx1PWUub3V0cHV0U2hhcGU7cmV0dXJue2F1dG9QYWQ6bixmb3JtYXQ6cixkaWxhdGlvbnM6byxncm91cDppLGtlcm5lbFNoYXBlOmEsb3V0cHV0UGFkZGluZzptLG91dHB1dFNoYXBlOnUscGFkczpkLHN0cmlkZXM6bCx3SXNDb25zdDpwLC4uLnQsY2FjaGVLZXk6YCR7ZS5mb3JtYXR9OyR7dC5hY3RpdmF0aW9ufTtgfX0sd2Y9KGUsdCk9PntpZighZXx8ZS5sZW5ndGghPT0yJiZlLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwiQ29udiByZXF1aXJlcyAyIG9yIDMgaW5wdXRzXCIpO2lmKGVbMF0uZGltcy5sZW5ndGghPT00JiZlWzBdLmRpbXMubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoXCJjdXJyZW50bHkgb25seSBzdXBwb3J0IDItZGltZW5zaW9uYWwgY29udlwiKTtpZihlWzBdLmRpbXMubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJmaWx0ZXIgZG9lcyBub3QgaGF2ZSBzYW1lIGRpbWVuc2lvbiBhcyBpbnB1dFwiKTtsZXQgcj1lWzBdLmRpbXNbdC5mb3JtYXQ9PT1cIk5IV0NcIj9lWzBdLmRpbXMubGVuZ3RoLTE6MV0sbj1lWzFdLmRpbXNbMF07aWYociE9PW4pdGhyb3cgbmV3IEVycm9yKFwiRklMVEVSX0lOX0NIQU5ORUwgc2hvdWxkIGJlIGVxdWFsIHRvIERBVEFfQ0hBTk5FTFwiKTtsZXQgbz1lWzFdLmRpbXNbMV0qdC5ncm91cDtpZihlLmxlbmd0aD09PTMmJihlWzJdLmRpbXMubGVuZ3RoIT09MXx8ZVsyXS5kaW1zWzBdIT09bykpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBiaWFzXCIpO2xldCBpPWVbMF0uZGltcy5sZW5ndGgtMjtpZih0LmRpbGF0aW9ucy5yZWR1Y2UoKG0sdSk9Pm0rdSwwKT4wJiZ0LmRpbGF0aW9ucy5sZW5ndGghPT1pKXRocm93IG5ldyBFcnJvcihgZGlsYXRpb25zIHNob3VsZCBiZSAke2l9RGApO2lmKHQuc3RyaWRlcy5yZWR1Y2UoKG0sdSk9Pm0rdSwwKT4wJiZ0LnN0cmlkZXMubGVuZ3RoIT09aSl0aHJvdyBuZXcgRXJyb3IoYHN0cmlkZXMgc2hvdWxkIGJlICR7aX1EYCk7aWYodC5wYWRzLnJlZHVjZSgobSx1KT0+bSt1LDApPjAmJnQucGFkcy5sZW5ndGghPT1pKjIpdGhyb3cgbmV3IEVycm9yKGBwYWRzIHNob3VsZCBiZSAke2kqMn1EYCk7aWYodC5vdXRwdXRQYWRkaW5nLmxlbmd0aCE9PWkmJnQub3V0cHV0UGFkZGluZy5sZW5ndGghPT0wKXRocm93IG5ldyBFcnJvcihgb3V0cHV0X3BhZGRpbmcgc2hvdWxkIGJlICR7aX1EYCk7aWYodC5rZXJuZWxTaGFwZS5yZWR1Y2UoKG0sdSk9Pm0rdSwwKT4wJiZ0Lmtlcm5lbFNoYXBlLmxlbmd0aCE9PTAmJnQua2VybmVsU2hhcGUubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImludmFsaWQga2VybmVsIHNoYXBlXCIpO2lmKHQub3V0cHV0U2hhcGUubGVuZ3RoIT09MCYmdC5vdXRwdXRTaGFwZS5sZW5ndGghPT1lWzBdLmRpbXMubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBvdXRwdXQgc2hhcGVcIil9LHJkPShlLHQscixuKT0+e2xldCBvPWUua2VybmVsQ3VzdG9tRGF0YS53VD8/ZS5jb21wdXRlKFBlKHRbMV0sWzIsMywwLDFdKSx7aW5wdXRzOlsxXSxvdXRwdXRzOltyLndJc0NvbnN0Py0yOi0xXX0pWzBdO3Iud0lzQ29uc3QmJiFlLmtlcm5lbEN1c3RvbURhdGEud1QmJihlLmtlcm5lbEN1c3RvbURhdGEud1Q9byk7bGV0IGk9W3RbMF0sb107dC5sZW5ndGg9PT0zJiZpLnB1c2godFsyXSksZS5jb21wdXRlKFh1KGkscixuKSx7aW5wdXRzOml9KX0sdmY9KGUsdCk9PntsZXQgcj10LmZvcm1hdD09PVwiTkhXQ1wiLG49W2UuaW5wdXRzWzBdLnJlc2hhcGUocj9bZS5pbnB1dHNbMF0uZGltc1swXSwxLGUuaW5wdXRzWzBdLmRpbXNbMV0sZS5pbnB1dHNbMF0uZGltc1syXV06W2UuaW5wdXRzWzBdLmRpbXNbMF0sZS5pbnB1dHNbMF0uZGltc1sxXSwxLGUuaW5wdXRzWzBdLmRpbXNbMl1dKSxlLmlucHV0c1sxXS5yZXNoYXBlKFtlLmlucHV0c1sxXS5kaW1zWzBdLGUuaW5wdXRzWzFdLmRpbXNbMV0sMSxlLmlucHV0c1sxXS5kaW1zWzJdXSldO2UuaW5wdXRzLmxlbmd0aD09PTMmJm4ucHVzaChlLmlucHV0c1syXSk7bGV0IG89dC5rZXJuZWxTaGFwZTsoby5sZW5ndGg9PT0wfHxvWzBdPT09MCkmJihvPVtlLmlucHV0c1sxXS5kaW1zWzJdXSk7bGV0IGk9dC5kaWxhdGlvbnM7KGkubGVuZ3RoPT09MHx8aVswXT09PTApJiYoaT1bMV0pO2xldCBhPXQuc3RyaWRlczsoYS5sZW5ndGg9PT0wfHxhWzBdPT09MCkmJihhPVsxXSk7bGV0IGQ9dC5wYWRzO2QubGVuZ3RoPT09MCYmKGQ9WzAsMF0pLGQ9WzAsZFswXSwwLGRbMV1dLGE9WzFdLmNvbmNhdChhKSxpPVsxXS5jb25jYXQoaSksbz1bMV0uY29uY2F0KG8pO2xldCBsPWVkKHsuLi50LHBhZHM6ZCxzdHJpZGVzOmEsZGlsYXRpb25zOmksa2VybmVsU2hhcGU6b30sbik7cmQoZSxuLGwscD0+cj9bcFswXSxwWzJdLHBbM11dOltwWzBdLHBbMV0scFszXV0pfSxuZD0oZSx0KT0+e2lmKHdmKGUuaW5wdXRzLHQpLGUuaW5wdXRzWzBdLmRpbXMubGVuZ3RoPT09Myl2ZihlLHQpO2Vsc2V7bGV0IHI9ZWQodCxlLmlucHV0cyk7cmQoZSxlLmlucHV0cyxyKX19fSk7dmFyICRmLGlkLGFkLHNkPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7U2UoKTthZSgpOyRmPShlLHQscixuKT0+e2xldCBvPUMuc2l6ZSh0KSxpPXQubGVuZ3RoLGE9RShcImlucHV0XCIsZSxpKSxkPU0oXCJvdXRwdXRcIixlLGkpLGw9ci5kYXRhVHlwZT09PTY/ci5nZXRJbnQzMkFycmF5KClbMF06TnVtYmVyKHIuZ2V0QmlnSW50NjRBcnJheSgpWzBdKSxwPUMubm9ybWFsaXplQXhpcyhsLGkpLG09dT0+e2xldCBoPWAgaTMyKCR7YS5pbmRpY2VzR2V0KFwiaW5wdXRJbmRpY2VzXCIsXCJ1bmlmb3Jtcy5heGlzXCIpfSkgYCxfPUYoXCJ1bmlmb3Jtcy5pbnB1dF9zaGFwZVwiLFwidW5pZm9ybXMuYXhpc1wiLGkpLHk9bi5yZXZlcnNlP2grKG4uZXhjbHVzaXZlP1wiICsgMVwiOlwiXCIpOlwiMFwiLGc9bi5yZXZlcnNlP186aCsobi5leGNsdXNpdmU/XCJcIjpcIiArIDFcIik7cmV0dXJuYFxuICAgICAgICAgICAgICAgICR7dS5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRTaXplXCIsXCJ1MzJcIikucmVnaXN0ZXJVbmlmb3JtKFwiYXhpc1wiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoYSxkKX1cbiAgICAgICAgICAgICAgICAke3UubWFpblN0YXJ0KCl9XG4gICAgICAgICAgICAgICAgICAke3UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG4gICAgICAgICAgICAgICAgICB2YXIgaW5wdXRJbmRpY2VzID0gJHtkLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgICAgICAgICAgICAgdmFyIHN1bSA9ICR7ZC50eXBlLnZhbHVlfSgwKTtcbiAgICAgICAgICAgICAgICAgIGxldCBmaXJzdCA6IGkzMiA9ICR7eX07XG4gICAgICAgICAgICAgICAgICBsZXQgbGFzdCA6IGkzMiA9ICR7Z307XG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBpIDogaTMyID0gZmlyc3Q7IGkgPCBsYXN0OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgJHthLmluZGljZXNTZXQoXCJpbnB1dEluZGljZXNcIixcInVuaWZvcm1zLmF4aXNcIixcInUzMihpKVwiKX07XG4gICAgICAgICAgICAgICAgICAgIHN1bSA9IHN1bSArICR7YS5nZXRCeUluZGljZXMoXCJpbnB1dEluZGljZXNcIil9O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgJHtkLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwic3VtXCIpfTtcbiAgICAgICAgICAgICAgICB9YH07cmV0dXJue25hbWU6XCJDdW1TdW1cIixzaGFkZXJDYWNoZTp7aGludDpuLmNhY2hlS2V5LGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6dCxkYXRhVHlwZTplfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoby82NCl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTpvfSx7dHlwZToxMixkYXRhOnB9LC4uLk4odCx0KV19KSxnZXRTaGFkZXJTb3VyY2U6bX19LGlkPShlLHQpPT57bGV0IHI9ZS5pbnB1dHNbMF0uZGltcyxuPWUuaW5wdXRzWzBdLmRhdGFUeXBlLG89ZS5pbnB1dHNbMV07ZS5jb21wdXRlKCRmKG4scixvLHQpLHtpbnB1dHM6WzBdfSl9LGFkPWU9PntsZXQgdD1lLmV4Y2x1c2l2ZT09PTEscj1lLnJldmVyc2U9PT0xO3JldHVybiByZSh7ZXhjbHVzaXZlOnQscmV2ZXJzZTpyfSl9fSk7dmFyIHhmLFNmLFRmLHVkLGRkLGxkPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7U2UoKTthZSgpO3hmPWU9PntpZighZXx8ZS5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIkRlcHRoVG9TcGFjZSByZXF1aXJlcyAxIGlucHV0LlwiKTtpZihlWzBdLmRpbXMubGVuZ3RoIT09NCl0aHJvdyBuZXcgRXJyb3IoXCJEZXB0aFRvU3BhY2UgcmVxdWlyZXMgNEQgaW5wdXQuXCIpfSxTZj0oZSx0LHIsbik9PntsZXQgbz1bXTtvLnB1c2goYGZuIHBlcm0oaTogJHtuLnR5cGUuaW5kaWNlc30pIC0+ICR7ci50eXBlLmluZGljZXN9IHtcbiAgICB2YXIgYTogJHtyLnR5cGUuaW5kaWNlc307YCk7Zm9yKGxldCBpPTA7aTx0OysraSlvLnB1c2goci5pbmRpY2VzU2V0KFwiYVwiLGVbaV0sYGlbJHtpfV1gKSk7cmV0dXJuIG8ucHVzaChcInJldHVybiBhO31cIiksby5qb2luKGBcbmApfSxUZj0oZSx0KT0+e2xldCByLG4sbyxpLGEsZCxsPXQuZm9ybWF0PT09XCJOSFdDXCIscD10LmJsb2Nrc2l6ZSxtPXQubW9kZT09PVwiRENSXCI7bD8oW3IsbixvLGldPWUuZGltcyxhPW0/W3IsbixvLHAscCxpL3AqKjJdOltyLG4sbyxpL3AqKjIscCxwXSxkPW0/WzAsMSwzLDIsNCw1XTpbMCwxLDQsMiw1LDNdKTooW3IsbixvLGldPVtlLmRpbXNbMF0sZS5kaW1zWzJdLGUuZGltc1szXSxlLmRpbXNbMV1dLGE9bT9bcixwLHAsaS9wKioyLG4sb106W3IsaS9wKioyLHAscCxuLG9dLGQ9bT9bMCwzLDQsMSw1LDJdOlswLDEsNCwyLDUsM10pO2xldCB1PWUucmVzaGFwZShhKSxoPXUuZGltcy5sZW5ndGgsXz1lLmRhdGFUeXBlLHk9RShcImFcIixfLGgpLGc9TShcIm91dHB1dFwiLF8saCkseD0kPT5gXG4gICR7JC5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoeSxnKX1cblxuICAke1NmKGQsaCx5LGcpfVxuXG4gICR7JC5tYWluU3RhcnQoKX1cbiAgICAkeyQuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuXG4gICAgbGV0IGluZGljZXMgPSAke2cub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgbGV0IGFJbmRpY2VzID0gcGVybShpbmRpY2VzKTtcblxuICAgICR7Zy5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIix5LmdldEJ5SW5kaWNlcyhcImFJbmRpY2VzXCIpKX1cbiAgfWA7cmV0dXJue25hbWU6XCJEZXB0aFRvU3BhY2VcIixzaGFkZXJDYWNoZTp7aGludDpgJHtlLmRpbXN9OyR7dC5ibG9ja3NpemV9OyR7dC5tb2RlfWAsaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiXX0sZ2V0UnVuRGF0YTokPT57bGV0IHY9bD9bcixuKnAsbypwLGkvcCoqMl06W3IsaS9wKioyLG4qcCxvKnBdLFM9Qy5zaXplKHYpLFQ9dS5kaW1zLEE9Qy5zb3J0QmFzZWRPblBlcm0oVCxkKTtyZXR1cm57b3V0cHV0czpbe2RpbXM6dixkYXRhVHlwZTokWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoUy82NCl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTpTfSwuLi5OKFQsQSldfX0sZ2V0U2hhZGVyU291cmNlOnh9fSx1ZD0oZSx0KT0+e3hmKGUuaW5wdXRzKSxlLmNvbXB1dGUoVGYoZS5pbnB1dHNbMF0sdCkpfSxkZD1lPT5yZSh7YmxvY2tzaXplOmUuYmxvY2tzaXplLG1vZGU6ZS5tb2RlLGZvcm1hdDplLmZvcm1hdH0pfSk7dmFyIHZvLGVuLGNkLElmLENmLCRvLHhvLHBkLEFmLG1kLGZkLGhkPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7U2UoKTthZSgpO3ZvPVwiW2EtekEtWl18XFxcXC5cXFxcLlxcXFwuXCIsZW49XCIoXCIrdm8rXCIpK1wiLGNkPVwiXlwiK2VuK1wiJFwiLElmPVwiKFwiK2VuK1wiLCkqXCIrZW4sQ2Y9XCJeXCIrSWYrXCIkXCIsJG89Y2xhc3N7Y29uc3RydWN0b3IodD0tMSl7dGhpcy5zeW1ib2xUb0luZGljZXM9bmV3IE1hcCx0aGlzLmlucHV0SW5kZXg9dH1hZGRTeW1ib2wodCxyKXtsZXQgbj10aGlzLnN5bWJvbFRvSW5kaWNlcy5nZXQodCk7bj09PXZvaWQgMD9uPVtyXTpuLnB1c2gociksdGhpcy5zeW1ib2xUb0luZGljZXMuc2V0KHQsbil9fSx4bz1jbGFzc3tjb25zdHJ1Y3Rvcih0LHIpe3RoaXMuZXF1YXRpb249cjt0aGlzLmhhc0VsbGlwc2lzPSExLHRoaXMuc3ltYm9sVG9JbmZvPW5ldyBNYXAsdGhpcy5saHM9bmV3IEFycmF5LHRoaXMub3V0cHV0RGltcz1bXTtsZXRbbixvXT1yLmluY2x1ZGVzKFwiLT5cIik/ci5zcGxpdChcIi0+XCIsMik6W3IsXCJcIl07aWYoIW4ubWF0Y2goUmVnRXhwKENmKSkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBMSFMgdGVybVwiKTtpZihuLnNwbGl0KFwiLFwiKS5mb3JFYWNoKChkLGwpPT57bGV0IHA9dFtsXS5kaW1zLnNsaWNlKCk7aWYoIWQubWF0Y2goUmVnRXhwKGNkKSkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBMSFMgdGVybVwiKTtsZXQgbT10aGlzLnByb2Nlc3NUZXJtKGQsITAscCxsKTt0aGlzLmxocy5wdXNoKG0pfSksbz09PVwiXCIpbys9Wy4uLnRoaXMuc3ltYm9sVG9JbmZvLmVudHJpZXMoKV0uZmlsdGVyKChbZCxsXSk9PmwuY291bnQ9PT0xfHxkPT09XCIuLi5cIikubWFwKChbZF0pPT5kKS5qb2luKFwiXCIpO2Vsc2UgaWYoIW8ubWF0Y2goUmVnRXhwKGVuKSkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBSSFNcIik7by5tYXRjaChSZWdFeHAodm8sXCJnXCIpKT8uZm9yRWFjaChkPT57aWYoZD09PVwiLi4uXCIpdGhpcy5vdXRwdXREaW1zPXRoaXMub3V0cHV0RGltcy5jb25jYXQodGhpcy5lbGxpcHNpc0RpbXMpO2Vsc2V7bGV0IGw9dGhpcy5zeW1ib2xUb0luZm8uZ2V0KGQpO2lmKGw9PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBSSFMgc3ltYm9sXCIpO3RoaXMub3V0cHV0RGltcy5wdXNoKGwuZGltVmFsdWUpfX0pLHRoaXMucmhzPXRoaXMucHJvY2Vzc1Rlcm0obywhMSx0aGlzLm91dHB1dERpbXMpfWFkZFN5bWJvbCh0LHIsbil7bGV0IG89dGhpcy5zeW1ib2xUb0luZm8uZ2V0KHQpO2lmKG8hPT12b2lkIDApe2lmKG8uZGltVmFsdWUhPT1yJiZvLmNvdW50IT09MSl0aHJvdyBuZXcgRXJyb3IoXCJEaW1lbnNpb24gbWlzbWF0Y2hcIik7by5jb3VudCsrLG8uaW5wdXRJbmRpY2VzLnB1c2gobil9ZWxzZSBvPXtjb3VudDoxLGRpbVZhbHVlOnIsaW5wdXRJbmRpY2VzOltuXX07dGhpcy5zeW1ib2xUb0luZm8uc2V0KHQsbyl9cHJvY2Vzc1Rlcm0odCxyLG4sbz0tMSl7bGV0IGk9bi5sZW5ndGgsYT0hMSxkPVtdLGw9MDtpZighdC5tYXRjaChSZWdFeHAoY2QpKSYmIXImJnQhPT1cIlwiKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgTEhTIHRlcm1cIik7bGV0IHA9dC5tYXRjaChSZWdFeHAodm8sXCJnXCIpKSxtPW5ldyAkbyhvKTtyZXR1cm4gcD8uZm9yRWFjaCgodSxoKT0+e2lmKHU9PT1cIi4uLlwiKXtpZihhKXRocm93IG5ldyBFcnJvcihcIk9ubHkgb25lIGVsbGlwc2lzIGlzIGFsbG93ZWQgcGVyIGlucHV0IHRlcm1cIik7YT0hMDtsZXQgXz1pLXAubGVuZ3RoKzE7aWYoXzwwKXRocm93IG5ldyBFcnJvcihcIkVsbGlwc2lzIG91dCBvZiBib3VuZHNcIik7aWYoZD1uLnNsaWNlKGwsbCtfKSx0aGlzLmhhc0VsbGlwc2lzKXtpZih0aGlzLmVsbGlwc2lzRGltcy5sZW5ndGghPT1kLmxlbmd0aHx8dGhpcy5lbGxpcHNpc0RpbXMudG9TdHJpbmcoKSE9PWQudG9TdHJpbmcoKSl0aHJvdyBuZXcgRXJyb3IoXCJFbGxpcHNpcyBkaW1lbnNpb25zIG1pc21hdGNoXCIpfWVsc2UgaWYocil0aGlzLmhhc0VsbGlwc2lzPSEwLHRoaXMuZWxsaXBzaXNEaW1zPWQ7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJFbGxpcHNpcyBtdXN0IGJlIHNwZWNpZmllZCBpbiB0aGUgTEhTXCIpO2ZvcihsZXQgeT0wO3k8ZC5sZW5ndGg7eSsrKXtsZXQgZz1TdHJpbmcuZnJvbUNoYXJDb2RlKFwiMFwiLmNoYXJDb2RlQXQoMCkreSk7bS5hZGRTeW1ib2woZyxoK3kpLHRoaXMuYWRkU3ltYm9sKGcsbltsKytdLG8pfX1lbHNlIG0uYWRkU3ltYm9sKHUsaCsodGhpcy5oYXNFbGxpcHNpcz90aGlzLmVsbGlwc2lzRGltcy5sZW5ndGgtMTowKSksdGhpcy5hZGRTeW1ib2wodSxuW2wrK10sbyl9KSxtfX0scGQ9ZT0+ZStcIl9tYXhcIixBZj0oZSx0LHIsbik9PntsZXQgaT1lLm1hcChtPT5tLmxlbmd0aCkubWFwKChtLHUpPT5FKGBpbnB1dCR7dX1gLHQsbSkpLGE9Qy5zaXplKG4pLGQ9TShcIm91dHB1dFwiLHQsbi5sZW5ndGgpLGw9Wy4uLnIuc3ltYm9sVG9JbmZvLmtleXMoKV0uZmlsdGVyKG09PiFyLnJocy5zeW1ib2xUb0luZGljZXMuaGFzKG0pKSxwPW09PntsZXQgdT1bXSxoPVwidmFyIHByb2QgPSAxLjA7XCIsXz1cInZhciBzdW0gPSAwLjA7XCIseT1cInN1bSArPSBwcm9kO1wiLGc9W10seD1bXSwkPVtdLHY9W10sUz1yLnN5bWJvbFRvSW5mby5zaXplPT09ci5yaHMuc3ltYm9sVG9JbmRpY2VzLnNpemU7ci5zeW1ib2xUb0luZm8uZm9yRWFjaCgoQSxrKT0+e2lmKHIucmhzLnN5bWJvbFRvSW5kaWNlcy5oYXMoaykpe2xldCBQPXIucmhzLnN5bWJvbFRvSW5kaWNlcy5nZXQoayk/LlswXTtQIT09dm9pZCAwJiZyLmxocy5mb3JFYWNoKChELFIpPT57aWYoQS5pbnB1dEluZGljZXMuaW5jbHVkZXMoUikpe2xldCBHPUQuc3ltYm9sVG9JbmRpY2VzLmdldChrKTtpZihHPT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3ltYm9sIGVycm9yXCIpO0cuZm9yRWFjaChLPT57dS5wdXNoKGAke2lbUl0uaW5kaWNlc1NldChgaW5wdXQke1J9SW5kaWNlc2AsSyxkLmluZGljZXNHZXQoXCJvdXRwdXRJbmRpY2VzXCIsUCkpfWApfSl9fSl9ZWxzZSByLmxocy5mb3JFYWNoKChQLEQpPT57aWYoQS5pbnB1dEluZGljZXMuaW5jbHVkZXMoRCkpe2xldCBSPVAuc3ltYm9sVG9JbmRpY2VzLmdldChrKTtpZihSPT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3ltYm9sIGVycm9yXCIpO1IuZm9yRWFjaChHPT57Zy5wdXNoKGAke2lbRF0uaW5kaWNlc1NldChgaW5wdXQke0R9SW5kaWNlc2AsRyxgJHtrfWApfWApfSksdi5wdXNoKGBwcm9kICo9ICR7aVtEXS5nZXRCeUluZGljZXMoYGlucHV0JHtEfUluZGljZXNgKX07YCl9fSkseC5wdXNoKGBmb3IodmFyICR7a306IHUzMiA9IDA7ICR7a30gPCB1bmlmb3Jtcy4ke3BkKGspfTsgJHtrfSsrKSB7YCksJC5wdXNoKFwifVwiKX0pO2xldCBUPVM/Wy4uLnUsYGxldCBzdW0gPSAke2kubWFwKChBLGspPT5BLmdldEJ5SW5kaWNlcyhgaW5wdXQke2t9SW5kaWNlc2ApKS5qb2luKFwiICogXCIpfTtgXTpbLi4udSxfLC4uLngsLi4uZyxoLC4uLnYseSwuLi4kXTtyZXR1cm5gXG4gICAgICAgICAgICAke20ucmVnaXN0ZXJVbmlmb3JtcyhsLm1hcChBPT4oe25hbWU6YCR7cGQoQSl9YCx0eXBlOlwidTMyXCJ9KSkpLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dFNpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKC4uLmksZCl9XG5cbiAgICAgICAgICAgICR7bS5tYWluU3RhcnQoKX1cbiAgICAgICAgICAgICR7bS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0U2l6ZVwiKX1cbiAgICAgICAgICAgIHZhciBvdXRwdXRJbmRpY2VzID0gJHtkLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgICAgICAgJHtpLm1hcCgoQSxrKT0+YHZhciBpbnB1dCR7a31JbmRpY2VzOiAke2lba10udHlwZS5pbmRpY2VzfTtgKS5qb2luKGBcbmApfVxuICAgICAgICAgICAgJHtULmpvaW4oYFxuYCl9O1xuICAgICAgICAgICAgJHtkLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwic3VtXCIpfTtcbiAgICAgICAgICB9YH07cmV0dXJue25hbWU6XCJFaW5zdW1cIixzaGFkZXJDYWNoZTp7aGludDpyLmVxdWF0aW9uLGlucHV0RGVwZW5kZW5jaWVzOmUubWFwKCgpPT5cInJhbmtcIil9LGdldFJ1bkRhdGE6KCk9PntsZXQgbT1sLmZpbHRlcihoPT5yLnN5bWJvbFRvSW5mby5oYXMoaCkpLm1hcChoPT4oe3R5cGU6MTIsZGF0YTpyLnN5bWJvbFRvSW5mby5nZXQoaCk/LmRpbVZhbHVlfHwwfSkpO20ucHVzaCh7dHlwZToxMixkYXRhOmF9KTtsZXQgdT1lLm1hcCgoaCxfKT0+Wy4uLk4oaCldKS5yZWR1Y2UoKGgsXyk9PmguY29uY2F0KF8pLG0pO3JldHVybiB1LnB1c2goLi4uTihuKSkse291dHB1dHM6W3tkaW1zOm4sZGF0YVR5cGU6dH1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGEvNjQpfSxwcm9ncmFtVW5pZm9ybXM6dX19LGdldFNoYWRlclNvdXJjZTpwfX0sbWQ9KGUsdCk9PntsZXQgcj1uZXcgeG8oZS5pbnB1dHMsdC5lcXVhdGlvbiksbj1yLm91dHB1dERpbXMsbz1lLmlucHV0cy5tYXAoKGksYSk9PmkuZGltcyk7ZS5jb21wdXRlKEFmKG8sZS5pbnB1dHNbMF0uZGF0YVR5cGUscixuKSl9LGZkPWU9PntsZXQgdD1lLmVxdWF0aW9uLnJlcGxhY2UoL1xccysvZyxcIlwiKTtyZXR1cm4gcmUoe2VxdWF0aW9uOnR9KX19KTt2YXIga2YsZ2QsRWYsUGYsYmQseWQ9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTthZSgpO2tmPWU9PntpZighZXx8ZS5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIkV4cGFuZCByZXF1aXJlcyAyIGlucHV0LlwiKTtsZXQgdD1lWzBdLmRpbXMscj1BcnJheS5mcm9tKGVbMV0uZ2V0QmlnSW50NjRBcnJheSgpLE51bWJlciksbj1yLmxlbmd0aDx0Lmxlbmd0aD8wOnIubGVuZ3RoLXQubGVuZ3RoLG89dC5sZW5ndGg8ci5sZW5ndGg/MDp0Lmxlbmd0aC1yLmxlbmd0aDtmb3IoO248ci5sZW5ndGgmJm88dC5sZW5ndGg7KytuLCsrbylpZihyW25dIT09dFtvXSYmcltuXSE9PTEmJnRbb10hPT0xKXRocm93IG5ldyBFcnJvcihcIkV4cGFuZCByZXF1aXJlcyBzaGFwZSB0byBiZSBicm9hZGNhc3RhYmxlIHRvIGlucHV0XCIpfSxnZD0oZSx0KT0+e2xldCByPWUubGVuZ3RoLXQubGVuZ3RoLG49W107Zm9yKGxldCBvPTA7bzxyOysrbyluLnB1c2goZVtvXSk7Zm9yKGxldCBvPTA7bzx0Lmxlbmd0aDsrK28pbi5wdXNoKHRbb109PT0xP2VbbytyXTp0W29dKTtyZXR1cm4gbn0sRWY9KGUsdCk9PmUubGVuZ3RoPnQubGVuZ3RoP2dkKGUsdCk6Z2QodCxlKSxQZj1lPT57bGV0IHQ9ZVswXS5kaW1zLHI9QXJyYXkuZnJvbShlWzFdLmdldEJpZ0ludDY0QXJyYXkoKSxOdW1iZXIpLG49RWYodCxyKSxvPWVbMF0uZGF0YVR5cGUsaT1vPT09OXx8Qy5zaXplKHQpPT09MSxhPW89PT05fHx0Lmxlbmd0aD4wJiZ0W3QubGVuZ3RoLTFdJTQ9PT0wPzQ6MSxkPWl8fG4ubGVuZ3RoPjAmJm5bbi5sZW5ndGgtMV0lND09PTA/NDoxLGw9TWF0aC5jZWlsKEMuc2l6ZShuKS9kKSxwPXU9PntsZXQgaD1FKFwiaW5wdXRcIixvLHQubGVuZ3RoLGEpLF89TShcIm91dHB1dFwiLG8sbi5sZW5ndGgsZCkseTtpZihvPT09OSl7bGV0IGc9KHgsJCx2PVwiXCIpPT5gXG4gICAgICAgICAgbGV0IG91dHB1dEluZGljZXMkeyR9ID0gJHtfLm9mZnNldFRvSW5kaWNlcyhgb3V0cHV0T2Zmc2V0ICsgJHskfXVgKX07XG4gICAgICAgICAgbGV0IG9mZnNldCR7JH0gPSAke2guYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dEluZGljZXMkeyR9YCxfKX07XG4gICAgICAgICAgbGV0IGluZGV4JHskfSA9IG9mZnNldCR7JH0gLyA0dTtcbiAgICAgICAgICBsZXQgY29tcG9uZW50JHskfSA9IG9mZnNldCR7JH0gJSA0dTtcbiAgICAgICAgICAke3h9WyR7JH1dID0gJHt2fSgke2guZ2V0QnlPZmZzZXQoYGluZGV4JHskfWApfVtjb21wb25lbnQkeyR9XSk7XG4gICAgICAgIGA7eT1gXG4gICAgICAgIGxldCBvdXRwdXRPZmZzZXQgPSBnbG9iYWxfaWR4ICogJHtkfTtcbiAgICAgICAgdmFyIGRhdGEgPSB2ZWM0PHUzMj4oMCk7XG4gICAgICAgICR7ZyhcImRhdGFcIiwwLFwidTMyXCIpfVxuICAgICAgICAke2coXCJkYXRhXCIsMSxcInUzMlwiKX1cbiAgICAgICAgJHtnKFwiZGF0YVwiLDIsXCJ1MzJcIil9XG4gICAgICAgICR7ZyhcImRhdGFcIiwzLFwidTMyXCIpfVxuICAgICAgICAke18uc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJkYXRhXCIpfVxuICAgICAgfWB9ZWxzZSB5PWBcbiAgICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke18ub2Zmc2V0VG9JbmRpY2VzKGBnbG9iYWxfaWR4ICogJHtkfWApfTtcbiAgICAgICAgbGV0IGlucHV0T2Zmc2V0ID0gJHtoLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KFwib3V0cHV0SW5kaWNlc1wiLF8pfTtcbiAgICAgICAgbGV0IGRhdGEgPSAke18udHlwZS52YWx1ZX0oJHtoLmdldEJ5T2Zmc2V0KGBpbnB1dE9mZnNldCAvICR7YX1gKX0pO1xuICAgICAgICAke18uc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJkYXRhXCIpfVxuICAgICAgfWA7cmV0dXJuYFxuICAgICR7dS5yZWdpc3RlclVuaWZvcm0oXCJ2ZWNfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoaCxfKX1cbiAgICAke3UubWFpblN0YXJ0KCl9XG4gICAgJHt1Lmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy52ZWNfc2l6ZVwiKX1cbiAgICAke3l9YH0sbT1be3R5cGU6MTIsZGF0YTpsfSwuLi5OKHQsbildO3JldHVybntuYW1lOlwiRXhwYW5kXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7bi5sZW5ndGh9OyR7YX0ke2R9YCxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxnZXRTaGFkZXJTb3VyY2U6cCxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm4sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGwvNjQpfSxwcm9ncmFtVW5pZm9ybXM6bX0pfX0sYmQ9ZT0+e2tmKGUuaW5wdXRzKSxlLmNvbXB1dGUoUGYoZS5pbnB1dHMpLHtpbnB1dHM6WzBdfSl9fSk7dmFyIHpmLF9kLHdkPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7YWUoKTtLcigpO3pmPWU9PntsZXQgdD1lWzBdLmRhdGFUeXBlLHI9Qy5zaXplKGVbMF0uZGltcyksbj1DLnNpemUoZVsxXS5kaW1zKSxvPW4lND09PTAsaT1hPT57bGV0IGQ9RShcInhcIix0LFsxXSw0KSxsPUUoXCJiaWFzXCIsdCxbMV0sNCkscD1NKFwieVwiLHQsWzFdLDQpLG09W3tuYW1lOlwib3V0cHV0X3ZlY19zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImJpYXNfc2l6ZVwiLHR5cGU6XCJ1MzJcIn1dLHU9Xz0+YFxuICAgICAgbGV0IGJpYXMke199X29mZnNldDogdTMyID0gKGdsb2JhbF9pZHggKiA0ICsgJHtffSkgJSB1bmlmb3Jtcy5iaWFzX3NpemU7XG4gICAgICBsZXQgYmlhcyR7X30gPSAke2wuZ2V0QnlPZmZzZXQoYGJpYXMke199X29mZnNldCAvIDRgKX1bYmlhcyR7X31fb2Zmc2V0ICUgNF07YCxoPW8/YFxuICAgICAgbGV0IGJpYXMgPSAke2wuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4ICUgKHVuaWZvcm1zLmJpYXNfc2l6ZSAvIDQpXCIpfTtgOmAke3UoMCl9JHt1KDEpfSR7dSgyKX0ke3UoMyl9XG4gICAgICBsZXQgYmlhcyA9ICR7ZC50eXBlLnZhbHVlfShiaWFzMCwgYmlhczEsIGJpYXMyLCBiaWFzMyk7YDtyZXR1cm5gJHthLnJlZ2lzdGVyVW5pZm9ybXMobSkuZGVjbGFyZVZhcmlhYmxlcyhkLGwscCl9XG5cbiAgICAke21vKEVlKHQpKX1cblxuICAgICR7YS5tYWluU3RhcnQoa3QpfVxuICAgICAgJHthLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfdmVjX3NpemVcIil9XG5cbiAgICAgIGxldCB4ID0gJHtkLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAke2h9XG4gICAgICBsZXQgeF9pbiA9IHggKyBiaWFzO1xuICAgICAgJHtwLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLGZvKFwieF9pblwiKSl9XG4gICAgfWB9O3JldHVybntuYW1lOlwiRmFzdEdlbHVXaXRoQmlhc1wiLHNoYWRlckNhY2hlOntoaW50OmAke299YCxpbnB1dERlcGVuZGVuY2llczpbXCJ0eXBlXCIsXCJ0eXBlXCJdfSxnZXRTaGFkZXJTb3VyY2U6aSxnZXRSdW5EYXRhOmE9Pih7b3V0cHV0czpbe2RpbXM6YVswXS5kaW1zLGRhdGFUeXBlOmFbMF0uZGF0YVR5cGV9XSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjEyLGRhdGE6TWF0aC5jZWlsKHIvNCl9LHt0eXBlOjEyLGRhdGE6bn1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHIva3QvNCl9fSl9fSxfZD1lPT57ZS5pbnB1dHMubGVuZ3RoPDJ8fEMuc2l6ZShlLmlucHV0c1sxXS5kaW1zKT09PTA/aHUoZSk6ZS5jb21wdXRlKHpmKGUuaW5wdXRzKSl9fSk7dmFyIE9mLERmLHZkLCRkLHhkPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7U2UoKTthZSgpO09mPWU9PntpZighZXx8ZS5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIkdhdGhlciByZXF1aXJlcyAyIGlucHV0cy5cIil9LERmPShlLHQpPT57bGV0IHI9ZVswXS5kaW1zLG49ZVsxXS5kaW1zLG89ci5sZW5ndGgsaT1DLm5vcm1hbGl6ZUF4aXModC5heGlzLG8pLGE9ci5zbGljZSgwKTthLnNwbGljZShpLDEsLi4ubik7bGV0IGQ9cltpXSxsPWVbMF0uZGF0YVR5cGU9PT05PzQ6MSxwPU1hdGguY2VpbChDLnNpemUoYSkvbCksbT1be3R5cGU6MTIsZGF0YTpwfSx7dHlwZTo2LGRhdGE6ZH0se3R5cGU6MTIsZGF0YTppfSwuLi5OKGVbMF0uZGltcyxlWzFdLmRpbXMsYSldLHU9aD0+e2xldCBfPUUoXCJkYXRhXCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMubGVuZ3RoLGwpLHk9RShcImlucHV0SW5kaWNlc1wiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zLmxlbmd0aCksZz1NKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxhLmxlbmd0aCxsKSx4PXY9PntsZXQgUz1uLmxlbmd0aCxUPWB2YXIgaW5kaWNlc0luZGljZXMke3Z9ICA9ICR7eS50eXBlLmluZGljZXN9KDApO2A7Zm9yKGxldCBBPTA7QTxTO0ErKylUKz1gJHtTPjE/YGluZGljZXNJbmRpY2VzJHt2fVske0F9XWA6YGluZGljZXNJbmRpY2VzJHt2fWB9ID0gJHthLmxlbmd0aD4xP2BvdXRwdXRJbmRpY2VzJHt2fVt1bmlmb3Jtcy5heGlzICsgJHtBfV1gOmBvdXRwdXRJbmRpY2VzJHt2fWB9O2A7VCs9YFxuICAgICAgICAgIHZhciBpZHgke3Z9ID0gJHt5LmdldEJ5SW5kaWNlcyhgaW5kaWNlc0luZGljZXMke3Z9YCl9O1xuICAgICAgICAgIGlmIChpZHgke3Z9IDwgMCkge1xuICAgICAgICAgICAgaWR4JHt2fSA9IGlkeCR7dn0gKyB1bmlmb3Jtcy5heGlzRGltTGltaXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBkYXRhSW5kaWNlcyR7dn0gOiAke18udHlwZS5pbmRpY2VzfTtcbiAgICAgICAgYDtmb3IobGV0IEE9MCxrPTA7QTxvO0ErKylBPT09aT8oVCs9YCR7bz4xP2BkYXRhSW5kaWNlcyR7dn1bJHtBfV1gOmBkYXRhSW5kaWNlcyR7dn1gfSA9IHUzMihpZHgke3Z9KTtgLGsrPVMpOihUKz1gJHtvPjE/YGRhdGFJbmRpY2VzJHt2fVske0F9XWA6YGRhdGFJbmRpY2VzJHt2fWB9ID0gJHthLmxlbmd0aD4xP2BvdXRwdXRJbmRpY2VzJHt2fVske2t9XWA6YG91dHB1dEluZGljZXMke3Z9YH07YCxrKyspO3JldHVybiBUfSwkO2lmKGVbMF0uZGF0YVR5cGU9PT05KXtsZXQgdj0oUyxULEE9XCJcIik9PmBcbiAgICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyR7VH0gPSAke2cub2Zmc2V0VG9JbmRpY2VzKGBvdXRwdXRPZmZzZXQgKyAke1R9dWApfTtcbiAgICAgICAgICAke3goVCl9O1xuICAgICAgICAgIGxldCBvZmZzZXQke1R9ID0gJHtfLmluZGljZXNUb09mZnNldChgZGF0YUluZGljZXMke1R9YCl9O1xuICAgICAgICAgIGxldCBpbmRleCR7VH0gPSBvZmZzZXQke1R9IC8gNHU7XG4gICAgICAgICAgbGV0IGNvbXBvbmVudCR7VH0gPSBvZmZzZXQke1R9ICUgNHU7XG4gICAgICAgICAgJHtTfVske1R9XSA9ICR7QX0oJHtfLmdldEJ5T2Zmc2V0KGBpbmRleCR7VH1gKX1bY29tcG9uZW50JHtUfV0pO1xuICAgICAgICBgOyQ9YFxuICAgICAgICBsZXQgb3V0cHV0T2Zmc2V0ID0gZ2xvYmFsX2lkeCAqICR7bH07XG4gICAgICAgIHZhciB2YWx1ZSA9IHZlYzQ8dTMyPigwKTtcbiAgICAgICAgJHt2KFwidmFsdWVcIiwwLFwidTMyXCIpfVxuICAgICAgICAke3YoXCJ2YWx1ZVwiLDEsXCJ1MzJcIil9XG4gICAgICAgICR7dihcInZhbHVlXCIsMixcInUzMlwiKX1cbiAgICAgICAgJHt2KFwidmFsdWVcIiwzLFwidTMyXCIpfVxuICAgICAgICAke2cuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKX1cbiAgICAgIGB9ZWxzZSAkPWBcbiAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtnLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgJHt4KFwiXCIpfTtcbiAgICAgIGxldCB2YWx1ZSA9ICR7Xy5nZXRCeUluZGljZXMoXCJkYXRhSW5kaWNlc1wiKX07XG4gICAgICAke2cuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKX07XG4gICAgICBgO3JldHVybmBcbiAgICAgICR7aC5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRTaXplXCIsXCJ1MzJcIikucmVnaXN0ZXJVbmlmb3JtKFwiYXhpc0RpbUxpbWl0XCIsXCJpMzJcIikucmVnaXN0ZXJVbmlmb3JtKFwiYXhpc1wiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoXyx5LGcpfVxuICAgICAgJHtoLm1haW5TdGFydCgpfVxuICAgICAgICAke2guZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG4gICAgICAgICR7JH1cbiAgICAgIH1gfTtyZXR1cm57bmFtZTpcIkdhdGhlclwiLHNoYWRlckNhY2hlOntoaW50OnQuY2FjaGVLZXksaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiLFwicmFua1wiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczphLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChwLzY0KX0scHJvZ3JhbVVuaWZvcm1zOm19KSxnZXRTaGFkZXJTb3VyY2U6dX19LHZkPWU9PnJlKHtheGlzOmUuYXhpc30pLCRkPShlLHQpPT57bGV0IHI9ZS5pbnB1dHM7T2YociksZS5jb21wdXRlKERmKGUuaW5wdXRzLHQpKX19KTt2YXIgQmYsU2QsVGQsSWQ9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTthZSgpO0JmPShlLHQscixuLG8saSxhLGQsbCk9PntsZXQgcD1be3R5cGU6MTIsZGF0YTppfSx7dHlwZToxMixkYXRhOm59LHt0eXBlOjEyLGRhdGE6b30se3R5cGU6MTIsZGF0YTpyfSx7dHlwZToxMixkYXRhOmF9LHt0eXBlOjEyLGRhdGE6ZH0se3R5cGU6MTIsZGF0YTpsfV0sbT1baV07cC5wdXNoKC4uLk4odC5kaW1zLG0pKTtsZXQgdT1oPT57bGV0IF89RShcImluZGljZXNfZGF0YVwiLHQuZGF0YVR5cGUsdC5kaW1zLmxlbmd0aCkseT1NKFwiaW5wdXRfc2xpY2Vfb2Zmc2V0c19kYXRhXCIsMTIsMSwxKSxnPVtfLHldLHg9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiYmF0Y2hfZGltc1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJpbnB1dF9kaW1zXCIsdHlwZTpcInUzMlwiLGxlbmd0aDpvLmxlbmd0aH0se25hbWU6XCJzaXplc19mcm9tX3NsaWNlX2RpbXNfZGF0YVwiLHR5cGU6XCJ1MzJcIixsZW5ndGg6ci5sZW5ndGh9LHtuYW1lOlwibnVtX3NsaWNlc19wZXJfYmF0Y2hcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiaW5wdXRfYmF0Y2hfc3RyaWRlXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIm51bV9zbGljZV9kaW1zXCIsdHlwZTpcInUzMlwifV07cmV0dXJuYFxuICAke2gucmVnaXN0ZXJVbmlmb3Jtcyh4KS5kZWNsYXJlVmFyaWFibGVzKC4uLmcpfVxuICAke2gubWFpblN0YXJ0KCl9XG4gICAgJHtoLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICBsZXQgYmF0Y2hfaWR4ID0gZ2xvYmFsX2lkeCAvIHVuaWZvcm1zLm51bV9zbGljZXNfcGVyX2JhdGNoO1xuICAgIGxldCBiYXNlX29mZnNldCA9IGJhdGNoX2lkeCAqIHVuaWZvcm1zLmlucHV0X2JhdGNoX3N0cmlkZTtcblxuICAgIGxldCBzbGljZV9pbmRpY2VzX2Jhc2Vfb2Zmc2V0ID0gZ2xvYmFsX2lkeCAqIHVuaWZvcm1zLm51bV9zbGljZV9kaW1zO1xuICAgIHZhciByZWxhdGl2ZV9zbGljZV9vZmZzZXQgPSAwO1xuICAgIGZvciAodmFyIGRpbV9pZHggPSAwdTsgZGltX2lkeCA8IHVuaWZvcm1zLm51bV9zbGljZV9kaW1zOyBkaW1faWR4ICsrKSB7XG4gICAgICB2YXIgaW5kZXggPSBpMzIoaW5kaWNlc19kYXRhW2RpbV9pZHggKyBzbGljZV9pbmRpY2VzX2Jhc2Vfb2Zmc2V0XS54KTtcbiAgICAgIGxldCBpbnB1dF9kaW1faWR4ID0gdW5pZm9ybXMuYmF0Y2hfZGltcyArIGRpbV9pZHg7XG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICR7by5sZW5ndGg9PT0xP1wiaW5kZXggKz0gaTMyKHVuaWZvcm1zLmlucHV0X2RpbXMpO1wiOlwiaW5kZXggKz0gaTMyKHVuaWZvcm1zLmlucHV0X2RpbXNbaW5wdXRfZGltX2lkeF0pO1wifVxuICAgICAgfVxuICAgICAgJHtyLmxlbmd0aD09PTE/XCJyZWxhdGl2ZV9zbGljZV9vZmZzZXQgKz0gaW5kZXggKiBpMzIodW5pZm9ybXMuc2l6ZXNfZnJvbV9zbGljZV9kaW1zX2RhdGEpO1wiOlwicmVsYXRpdmVfc2xpY2Vfb2Zmc2V0ICs9IGluZGV4ICogaTMyKHVuaWZvcm1zLnNpemVzX2Zyb21fc2xpY2VfZGltc19kYXRhW2RpbV9pZHhdKTtcIn1cbiAgICB9XG5cbiAgICBpbnB1dF9zbGljZV9vZmZzZXRzX2RhdGFbZ2xvYmFsX2lkeF0gPSAgYmFzZV9vZmZzZXQgKyB1MzIocmVsYXRpdmVfc2xpY2Vfb2Zmc2V0KTtcbiAgfWB9O3JldHVybiBlLmNvbXB1dGUoe25hbWU6XCJjb21wdXRlU2xpY2VPZmZzZXRzXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7by5sZW5ndGh9XyR7ci5sZW5ndGh9YCxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm0sZGF0YVR5cGU6ZS5pbnB1dHNbMV0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChpLzY0KX0scHJvZ3JhbVVuaWZvcm1zOnB9KSxnZXRTaGFkZXJTb3VyY2U6dX0se2lucHV0czpbdF0sb3V0cHV0czpbLTFdfSlbMF19LFNkPShlLHQpPT57bGV0IHI9ZS5pbnB1dHMsbj1yWzBdLmRpbXMsbz1yWzBdLmRhdGFUeXBlLGk9clsxXS5kaW1zLGE9aVtpLmxlbmd0aC0xXSxkPUMuc2l6ZVRvRGltZW5zaW9uKGksaS5sZW5ndGgtMSksbD1DLnNpemVGcm9tRGltZW5zaW9uKG4sdC5iYXRjaERpbXMrYSkscD1DLnNpemVUb0RpbWVuc2lvbihuLHQuYmF0Y2hEaW1zKSxtPUMuc2l6ZUZyb21EaW1lbnNpb24obix0LmJhdGNoRGltcyksdT1kL3AsaD1uZXcgQXJyYXkoYSksXz1sO2ZvcihsZXQgVD0wO1Q8YTsrK1QpaFthLTEtVF09XyxfKj1uW3QuYmF0Y2hEaW1zK2EtMS1UXTtsZXQgeT1CZihlLHJbMV0saCx0LmJhdGNoRGltcyxuLGQsdSxtLGEpLGc9dC5iYXRjaERpbXMrYTtpZihnPm4ubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImxhc3QgZGltZW5zaW9uIG9mIGluZGljZXMgbXVzdCBub3QgYmUgbGFyZ2VyIHRoYW4gcmFuayBvZiBpbnB1dCB0ZW5zb3JcIik7bGV0IHg9aS5zbGljZSgwLC0xKS5jb25jYXQobi5zbGljZShnKSksJD1DLnNpemUoeCksdj1be3R5cGU6MTIsZGF0YTokfSx7dHlwZToxMixkYXRhOmx9LC4uLk4oclswXS5kaW1zLHkuZGltcyx4KV0sUz1UPT57bGV0IEE9RShcImRhdGFcIixyWzBdLmRhdGFUeXBlLHJbMF0uZGltcy5sZW5ndGgpLGs9RShcInNsaWNlX29mZnNldHNcIiwxMix5LmRpbXMubGVuZ3RoKSxQPU0oXCJvdXRwdXRcIixyWzBdLmRhdGFUeXBlLHgubGVuZ3RoKTtyZXR1cm5gXG4gICAgICAgICAgJHtULnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dF9zaXplXCIsXCJ1MzJcIikucmVnaXN0ZXJVbmlmb3JtKFwic2xpY2Vfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoQSxrLFApfVxuICAgICAgICAgICAgJHtULm1haW5TdGFydCgpfVxuICAgICAgICAgICAgJHtULmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICAgICAgICBsZXQgc2xpY2Vfb2Zmc2V0ID0gc2xpY2Vfb2Zmc2V0c1tnbG9iYWxfaWR4IC8gdW5pZm9ybXMuc2xpY2Vfc2l6ZV07XG4gICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gZGF0YVt1MzIoc2xpY2Vfb2Zmc2V0KSArIGdsb2JhbF9pZHggJSB1bmlmb3Jtcy5zbGljZV9zaXplXTtcbiAgICAgICAgfWB9O2UuY29tcHV0ZSh7bmFtZTpcIkdhdGhlck5EXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6dC5jYWNoZUtleSxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCIsXCJyYW5rXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOngsZGF0YVR5cGU6b31dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKCQvNjQpfSxwcm9ncmFtVW5pZm9ybXM6dn0pLGdldFNoYWRlclNvdXJjZTpTfSx7aW5wdXRzOltyWzBdLHldfSl9LFRkPWU9Pih7YmF0Y2hEaW1zOmUuYmF0Y2hfZGltcyxjYWNoZUtleTpcIlwifSl9KTt2YXIgTWYsUmYsQ2QsQWQsa2Q9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTtTZSgpO2FlKCk7TWY9KGUsdCk9PntpZihlLmxlbmd0aDwzfHxlLmxlbmd0aD40KXRocm93IG5ldyBFcnJvcihcIkdhdGhlckJsb2NrUXVhbnRpemVkIHJlcXVpcmVzIDMgb3IgNCBpbnB1dHMuXCIpO2xldCByPUMubm9ybWFsaXplQXhpcyh0LnF1YW50aXplQXhpcyxlWzBdLmRpbXMubGVuZ3RoKSxuPXQuYmxvY2tTaXplLG89ZVswXSxpPWVbMl0sYT1lLmxlbmd0aD09PTQ/ZVszXTp2b2lkIDA7aWYoaS5kaW1zLmxlbmd0aCE9PW8uZGltcy5sZW5ndGh8fCFvLmRpbXMubWFwKChkLGwpPT5sPT09cj9NYXRoLmNlaWwoZC9uKT09PWkuZGltc1tsXTpkPT09aS5kaW1zW2xdKS5yZWR1Y2UoKGQsbCk9PmQmJmwsITApKXRocm93IG5ldyBFcnJvcihcIlNjYWxlcyBtdXN0IGhhdmUgdGhlIHNhbWUgcmFuayBhcyB0aGUgaW5wdXQgdGVuc29yIGFuZCB0aGUgZGltcyBzaG91bGQgbWF0Y2ggZXhjZXB0IG9uIGdhdGhlckF4aXMuXCIpO2lmKGEpe2lmKGEuZGF0YVR5cGUhPT1vLmRhdGFUeXBlKXRocm93IG5ldyBFcnJvcihcIlplcm8gcG9pbnQgbXVzdCBoYXZlIHRoZSBzYW1lIGRhdGEgdHlwZSBhcyB0aGUgaW5wdXQgdGVuc29yLlwiKTtpZihhLmRpbXMubGVuZ3RoIT09aS5kaW1zLmxlbmd0aHx8IWEuZGltcy5tYXAoKGQsbCk9PmQ9PT1pLmRpbXNbbF0pLnJlZHVjZSgoZCxsKT0+ZCYmbCwhMCkpdGhyb3cgbmV3IEVycm9yKFwiWmVybyBwb2ludCBtdXN0IGhhdmUgdGhlIHNhbWUgcmFuayBhcyB0aGUgaW5wdXQgdGVuc29yIGFuZCB0aGUgZGltcyBzaG91bGQgbWF0Y2ggZXhjZXB0IG9uIHF1YW50aXplQXhpcy5cIil9fSxSZj0oZSx0KT0+e2xldCByPWVbMF0uZGltcyxuPWVbMV0uZGltcyxvPXIubGVuZ3RoLGk9Qy5ub3JtYWxpemVBeGlzKHQuZ2F0aGVyQXhpcyxvKSxhPUMubm9ybWFsaXplQXhpcyh0LnF1YW50aXplQXhpcyxvKSxkPXIuc2xpY2UoMCk7ZC5zcGxpY2UoaSwxLC4uLm4pO2xldCBsPUMuc2l6ZShkKSxwPWVbMl0uZGF0YVR5cGUsdT1lWzBdLmRhdGFUeXBlPT09MjIsaD1be3R5cGU6MTIsZGF0YTpsfSx7dHlwZToxMixkYXRhOmF9LHt0eXBlOjEyLGRhdGE6aX0se3R5cGU6MTIsZGF0YTp0LmJsb2NrU2l6ZX0sLi4uTiguLi5lLm1hcCgoeSxnKT0+eS5kaW1zKSxkKV0sXz15PT57bGV0IGc9RShcImRhdGFcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcy5sZW5ndGgpLHg9RShcImlucHV0SW5kaWNlc1wiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zLmxlbmd0aCksJD1FKFwic2NhbGVzXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMubGVuZ3RoKSx2PWUubGVuZ3RoPjM/RShcInplcm9Qb2ludFwiLGVbM10uZGF0YVR5cGUsZVszXS5kaW1zLmxlbmd0aCk6dm9pZCAwLFM9TShcIm91dHB1dFwiLHAsZC5sZW5ndGgpLFQ9W2cseCwkXTt2JiZULnB1c2godik7bGV0IEE9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwicXVhbnRpemVfYXhpc1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJnYXRoZXJfYXhpc1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJibG9ja19zaXplXCIsdHlwZTpcInUzMlwifV07cmV0dXJuYFxuICAgICAgICAke3kucmVnaXN0ZXJVbmlmb3JtcyhBKS5kZWNsYXJlVmFyaWFibGVzKC4uLlQsUyl9XG4gICAgICAgICR7eS5tYWluU3RhcnQoKX1cbiAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHtTLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgICB2YXIgaW5kaWNlc19pbmRpY2VzID0gJHt4LnR5cGUuaW5kaWNlc30oMCk7XG4gICAgICAgICR7KCgpPT5uLmxlbmd0aD4xP2BcbiAgICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgJHtuLmxlbmd0aH07IGkrKykge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gJHtTLmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLFwidW5pZm9ybXMuZ2F0aGVyX2F4aXMgKyBpXCIpfTtcbiAgICAgICAgICAgICR7eC5pbmRpY2VzU2V0KFwiaW5kaWNlc19pbmRpY2VzXCIsXCJpXCIsXCJpbmRleFwiKX07XG4gICAgICAgICAgfWA6YGluZGljZXNfaW5kaWNlcyA9ICR7Uy5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixcInVuaWZvcm1zLmdhdGhlcl9heGlzXCIpfTtgKSgpfTtcbiAgICAgICAgdmFyIGRhdGFfaW5kaWNlcyA9ICR7Zy50eXBlLmluZGljZXN9KDApO1xuICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgdW5pZm9ybXMuZ2F0aGVyX2F4aXM7IGkrKykge1xuICAgICAgICAgIGxldCBpbmRleCA9ICR7Uy5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixcImlcIil9O1xuICAgICAgICAgICR7Zy5pbmRpY2VzU2V0KFwiZGF0YV9pbmRpY2VzXCIsXCJpXCIsXCJpbmRleFwiKX07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4X2Zyb21faW5kaWNlcyA9ICR7eC5nZXRCeUluZGljZXMoXCJpbmRpY2VzX2luZGljZXNcIil9O1xuICAgICAgICBpZiAoaW5kZXhfZnJvbV9pbmRpY2VzIDwgMCkge1xuICAgICAgICAgIGluZGV4X2Zyb21faW5kaWNlcyArPSAke3JbaV19O1xuICAgICAgICB9XG4gICAgICAgICR7Zy5pbmRpY2VzU2V0KFwiZGF0YV9pbmRpY2VzXCIsXCJ1bmlmb3Jtcy5nYXRoZXJfYXhpc1wiLFwidTMyKGluZGV4X2Zyb21faW5kaWNlcylcIil9O1xuICAgICAgICBmb3IgKHZhciBpID0gdW5pZm9ybXMuZ2F0aGVyX2F4aXMgKyAxOyBpIDwgJHtkLmxlbmd0aH07IGkrKykge1xuICAgICAgICAgIGxldCBpbmRleCA9ICR7Uy5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixgaSArICR7bi5sZW5ndGh9IC0gMWApfTtcbiAgICAgICAgICAke2cuaW5kaWNlc1NldChcImRhdGFfaW5kaWNlc1wiLFwiaVwiLFwiaW5kZXhcIil9O1xuICAgICAgICB9XG4gICAgICAgIGxldCBkYXRhX29mZnNldCA9ICR7Zy5pbmRpY2VzVG9PZmZzZXQoXCJkYXRhX2luZGljZXNcIil9O1xuICAgICAgICBsZXQgZGF0YV9pbmRleCA9IGRhdGFfb2Zmc2V0ICUgODtcbiAgICAgICAgLy8gQ29udmVydCA0LWJpdCBwYWNrZWQgZGF0YSB0byA4LWJpdCBwYWNrZWQgZGF0YS5cbiAgICAgICAgbGV0IHBhY2tlZF80Yml0X3F1YW50aXplZF9kYXRhID0gJHtnLmdldEJ5T2Zmc2V0KFwiZGF0YV9vZmZzZXQgLyA4XCIpfTtcbiAgICAgICAgbGV0IHBhY2tlZF84Yml0X3F1YW50aXplZF9kYXRhID0gKHBhY2tlZF80Yml0X3F1YW50aXplZF9kYXRhID4+ICg0ICogKGRhdGFfaW5kZXggJSAyKSkpICYgMHgwZjBmMGYwZjtcbiAgICAgICAgbGV0IHF1YW50aXplZF9kYXRhX3ZlYyA9ICR7dT9cInVucGFjazR4SThcIjpcInVucGFjazR4VThcIn0odTMyKHBhY2tlZF84Yml0X3F1YW50aXplZF9kYXRhKSk7XG4gICAgICAgIGxldCBxdWFudGl6ZWRfZGF0YSA9IHF1YW50aXplZF9kYXRhX3ZlY1tkYXRhX2luZGV4IC8gMl07XG4gICAgICAgIHZhciBzY2FsZV9pbmRpY2VzID0gZGF0YV9pbmRpY2VzO1xuICAgICAgICBsZXQgcXVhbnRpemVfYXhpc19pbmRleCA9ICR7JC5pbmRpY2VzR2V0KFwiZGF0YV9pbmRpY2VzXCIsXCJ1bmlmb3Jtcy5xdWFudGl6ZV9heGlzXCIpfSAvIHVuaWZvcm1zLmJsb2NrX3NpemU7XG4gICAgICAgICR7JC5pbmRpY2VzU2V0KFwic2NhbGVfaW5kaWNlc1wiLFwidW5pZm9ybXMucXVhbnRpemVfYXhpc1wiLFwicXVhbnRpemVfYXhpc19pbmRleFwiKX07XG4gICAgICAgIHZhciBzY2FsZSA9ICR7JC5nZXRCeUluZGljZXMoXCJzY2FsZV9pbmRpY2VzXCIpfTtcbiAgICAgICAgJHsoKCk9PnY/YFxuICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9pbmRpY2VzID0gc2NhbGVfaW5kaWNlcztcbiAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfb2Zmc2V0ID0gJHt2LmluZGljZXNUb09mZnNldChcInplcm9fcG9pbnRfaW5kaWNlc1wiKX07XG4gICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2luZGV4ID0gemVyb19wb2ludF9vZmZzZXQgJSA4O1xuICAgICAgICAgICAgICBsZXQgcGFja2VkXzRiaXRfemVyb19wb2ludHMgPSAke3YuZ2V0QnlPZmZzZXQoXCJ6ZXJvX3BvaW50X29mZnNldCAvIDhcIil9O1xuICAgICAgICAgICAgICBsZXQgcGFja2VkXzhiaXRfemVyb19wb2ludHMgPSAocGFja2VkXzRiaXRfemVyb19wb2ludHMgPj4gKDQgKiAoemVyb19wb2ludF9pbmRleCAlIDIpKSkgJiAweDBmMGYwZjBmO1xuICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF92ZWMgPSAke3U/XCJ1bnBhY2s0eEk4XCI6XCJ1bnBhY2s0eFU4XCJ9KHUzMihwYWNrZWRfOGJpdF96ZXJvX3BvaW50cykpO1xuICAgICAgICAgICAgICBsZXQgemVyb19wb2ludCA9IHplcm9fcG9pbnRfdmVjW3plcm9fcG9pbnRfaW5kZXggLyAyXTtgOlwidmFyIHplcm9fcG9pbnQgPSAwXCIpKCl9O1xuICAgICAgICBsZXQgZGVxdWFudGl6ZWRfZGF0YSA9ICR7RWUocCl9KHF1YW50aXplZF9kYXRhIC0gemVyb19wb2ludCkgKiBzY2FsZTtcbiAgICAgICAgJHtTLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwiZGVxdWFudGl6ZWRfZGF0YVwiKX07XG4gICAgfWB9O3JldHVybntuYW1lOlwiR2F0aGVyQmxvY2tRdWFudGl6ZWRcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmNhY2hlS2V5fTske2UuZmlsdGVyKCh5LGcpPT5nIT09MSkubWFwKHk9PnkuZGltcy5qb2luKFwiX1wiKSkuam9pbihcIjtcIil9YCxpbnB1dERlcGVuZGVuY2llczpBcnJheS5mcm9tKHtsZW5ndGg6ZS5sZW5ndGh9LCh5LGcpPT5cInJhbmtcIil9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6ZCxkYXRhVHlwZTpwfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwobC82NCl9LHByb2dyYW1Vbmlmb3JtczpofSksZ2V0U2hhZGVyU291cmNlOl99fSxDZD0oZSx0KT0+e2xldCByPWUuaW5wdXRzO01mKHIsdCksZS5jb21wdXRlKFJmKGUuaW5wdXRzLHQpKX0sQWQ9ZT0+cmUoe2Jsb2NrU2l6ZTplLmJsb2NrU2l6ZSxnYXRoZXJBeGlzOmUuZ2F0aGVyQXhpcyxxdWFudGl6ZUF4aXM6ZS5xdWFudGl6ZUF4aXN9KX0pO3ZhciBVZixOZixFZCxQZCx6ZD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtvZSgpO1NlKCk7YWUoKTtVZj1lPT57aWYoIWV8fGUubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJHYXRoZXJFbGVtZW50cyByZXF1aXJlcyAyIGlucHV0cy5cIik7aWYoZVswXS5kaW1zLmxlbmd0aDwxKXRocm93IG5ldyBFcnJvcihcIkdhdGhlckVsZW1lbnRzIHJlcXVpcmVzIHRoYXQgdGhlIGRhdGEgaW5wdXQgYmUgcmFuayA+PSAxLlwiKTtpZihlWzBdLmRpbXMubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYEdhdGhlckVsZW1lbnRzIHJlcXVpcmVzIHRoYXQgdGhlIGRhdGEgaW5wdXQgYW5kXG4gICAgICAgICAgICAgICAgICAgICBpbmRpY2VzIGlucHV0IHRlbnNvcnMgYmUgb2Ygc2FtZSByYW5rLmApfSxOZj0oZSx0KT0+e2xldCByPWVbMF0uZGltcyxuPWVbMF0uZGF0YVR5cGUsbz1yLmxlbmd0aCxpPWVbMV0uZGltcyxhPWVbMV0uZGF0YVR5cGUsZD1DLm5vcm1hbGl6ZUF4aXModC5heGlzLG8pLGw9cltkXSxwPWkuc2xpY2UoMCksbT1DLnNpemUocCksdT1FKFwiaW5wdXRcIixuLG8pLGg9RShcImluZGljZXNJbnB1dFwiLGEsaS5sZW5ndGgpLF89TShcIm91dHB1dFwiLG4scC5sZW5ndGgpLHk9W3t0eXBlOjEyLGRhdGE6bX0se3R5cGU6NixkYXRhOmx9LHt0eXBlOjEyLGRhdGE6ZH1dO3JldHVybiB5LnB1c2goLi4uTihyLGkscCkpLHtuYW1lOlwiR2F0aGVyRWxlbWVudHNcIixzaGFkZXJDYWNoZTp7aW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiLFwicmFua1wiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpwLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChtLzY0KX0scHJvZ3JhbVVuaWZvcm1zOnl9KSxnZXRTaGFkZXJTb3VyY2U6JD0+YFxuICAgICAgJHskLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dFNpemVcIixcInUzMlwiKS5yZWdpc3RlclVuaWZvcm0oXCJheGlzRGltTGltaXRcIixcImkzMlwiKS5yZWdpc3RlclVuaWZvcm0oXCJheGlzXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyh1LGgsXyl9XG4gICAgICAkeyQubWFpblN0YXJ0KCl9XG4gICAgICAkeyQuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG5cbiAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtfLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuXG4gICAgICB2YXIgaWR4ID0gJHtoLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgICBpZHggPSBpZHggKyB1bmlmb3Jtcy5heGlzRGltTGltaXQ7XG4gICAgICB9XG4gICAgICB2YXIgaW5wdXRJbmRpY2VzID0gJHt1LnR5cGUuaW5kaWNlc30ob3V0cHV0SW5kaWNlcyk7XG4gICAgICAke3UuaW5kaWNlc1NldChcImlucHV0SW5kaWNlc1wiLFwidW5pZm9ybXMuYXhpc1wiLFwidTMyKGlkeClcIil9O1xuICAgICAgbGV0IHZhbHVlID0gJHt1LmdldEJ5SW5kaWNlcyhcImlucHV0SW5kaWNlc1wiKX07XG5cbiAgICAgICR7Xy5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlXCIpfTtcbiAgfWB9fSxFZD1lPT5yZSh7YXhpczplLmF4aXN9KSxQZD0oZSx0KT0+e2xldCByPWUuaW5wdXRzO1VmKHIpLGUuY29tcHV0ZShOZihlLmlucHV0cyx0KSl9fSk7dmFyIFZmLFdmLE9kLERkLEJkPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7YWUoKTtWZj1lPT57aWYoIWUpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgaXMgbWlzc2luZ1wiKTtpZihlLmxlbmd0aDwyfHxlLmxlbmd0aD4zKXRocm93IG5ldyBFcnJvcihcIkludmFpZCBpbnB1dCBudW1iZXIuXCIpO2lmKGUubGVuZ3RoPT09MyYmZVsyXS5kaW1zLmxlbmd0aD4yKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgc2hhcGUgb2YgQ1wiKTtpZihlWzBdLmRhdGFUeXBlIT09ZVsxXS5kYXRhVHlwZXx8ZS5sZW5ndGg9PT0zJiZlWzBdLmRhdGFUeXBlIT09ZVsyXS5kYXRhVHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCB0eXBlcyBhcmUgbWlzbWF0Y2hlZFwiKX0sV2Y9KGUsdCk9PntsZXQgcj1lWzBdLmRpbXMuc2xpY2UoKSxuPWVbMV0uZGltcy5zbGljZSgpLFtvLGksYV09VnIuZ2V0U2hhcGVPZkdlbW1SZXN1bHQocix0LnRyYW5zQSxuLHQudHJhbnNCLGUubGVuZ3RoPT09Mz9lWzJdLmRpbXM6dm9pZCAwKSxkPVtvLGldO2lmKCFkKXRocm93IG5ldyBFcnJvcihcIkNhbid0IHVzZSBnZW1tIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO2xldCBsPTE2LHA9TWF0aC5jZWlsKGkvbCksbT1NYXRoLmNlaWwoby9sKSx1PSEwLGg9Qy5zaXplKGQpLF89W3t0eXBlOjEyLGRhdGE6dT9wOmh9LHt0eXBlOjEyLGRhdGE6b30se3R5cGU6MTIsZGF0YTppfSx7dHlwZToxMixkYXRhOmF9LHt0eXBlOjEsZGF0YTp0LmFscGhhfSx7dHlwZToxLGRhdGE6dC5iZXRhfV0seT1bXCJ0eXBlXCIsXCJ0eXBlXCJdO2UubGVuZ3RoPT09MyYmKF8ucHVzaCguLi5OKGVbMl0uZGltcykpLHkucHVzaChcInJhbmtcIikpLF8ucHVzaCguLi5OKGQpKTtsZXQgZz0kPT57bGV0IHY9XCJcIjt0LnRyYW5zQSYmdC50cmFuc0I/dj1cInZhbHVlICs9IGFbayAqIHVuaWZvcm1zLk0gKyBtXSAqIGJbbiAqIHVuaWZvcm1zLksgKyBrXTtcIjp0LnRyYW5zQSYmIXQudHJhbnNCP3Y9XCJ2YWx1ZSArPSBhW2sgKiB1bmlmb3Jtcy5NICsgbV0gKiBiW2sgKiB1bmlmb3Jtcy5OICsgbl07XCI6IXQudHJhbnNBJiZ0LnRyYW5zQj92PVwidmFsdWUgKz0gYVttICogdW5pZm9ybXMuSyArIGtdICogYltuICogdW5pZm9ybXMuSyArIGtdO1wiOiF0LnRyYW5zQSYmIXQudHJhbnNCJiYodj1cInZhbHVlICs9IGFbbSAqIHVuaWZvcm1zLksgKyBrXSAqIGJbayAqIHVuaWZvcm1zLk4gKyBuXTtcIik7bGV0IFM9dC5hbHBoYT09PTE/XCJcIjpcInZhbHVlICo9IHVuaWZvcm1zLmFscGhhO1wiLFQ9RShcImFcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcyksQT1FKFwiYlwiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zKSxrPVQudHlwZS52YWx1ZSxQPW51bGwsRD1bVCxBXTtlLmxlbmd0aD09PTMmJihQPUUoXCJjXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMubGVuZ3RoKSxELnB1c2goUCkpO2xldCBSPU0oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLGQubGVuZ3RoKTtELnB1c2goUik7bGV0IEc9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiTVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJOXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIktcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiYWxwaGFcIix0eXBlOlwiZjMyXCJ9LHtuYW1lOlwiYmV0YVwiLHR5cGU6XCJmMzJcIn1dO3JldHVybmBcbiAgJHskLnJlZ2lzdGVyVW5pZm9ybXMoRykuZGVjbGFyZVZhcmlhYmxlcyguLi5EKX1cblxuICAkeyQubWFpblN0YXJ0KCl9XG4gICAgJHskLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cblxuICAgIGxldCBtID0gZ2xvYmFsX2lkeCAvIHVuaWZvcm1zLk47XG4gICAgbGV0IG4gPSBnbG9iYWxfaWR4ICUgdW5pZm9ybXMuTjtcblxuICAgIHZhciB2YWx1ZSA9ICR7a30oMCk7XG4gICAgZm9yICh2YXIgazogdTMyID0gMHU7IGsgPCB1bmlmb3Jtcy5LOyBrKyspIHtcbiAgICAgICR7dn1cbiAgICB9XG5cbiAgICAke1N9XG4gICAgJHsoKCk9PlAhPW51bGw/YGxldCBjT2Zmc2V0ID0gJHtQLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KFwidmVjMihtLCBuKVwiLFIpfTsgdmFsdWUgKz0gJHtrfSh1bmlmb3Jtcy5iZXRhKSAqICR7UC5nZXRCeU9mZnNldChcImNPZmZzZXRcIil9O2A6XCJcIikoKX1cbiAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSB2YWx1ZTtcbiAgfWB9LHg9JD0+e2xldCB2PUUoXCJhXCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMpLFM9RShcImJcIixlWzFdLmRhdGFUeXBlLGVbMV0uZGltcyksVD1udWxsLEE9W3YsU107ZS5sZW5ndGg9PT0zJiYoVD1FKFwiY1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLmxlbmd0aCksQS5wdXNoKFQpKTtsZXQgaz1NKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxkLmxlbmd0aCk7QS5wdXNoKGspO2xldCBQPVt7bmFtZTpcIm51bV90aWxlX25cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiTVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJOXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIktcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiYWxwaGFcIix0eXBlOlwiZjMyXCJ9LHtuYW1lOlwiYmV0YVwiLHR5cGU6XCJmMzJcIn1dLEQ9XCJcIixSPVwiXCI7dC50cmFuc0EmJnQudHJhbnNCPyhSPWBcbiAgICAgIHZhciBjb2wgPSB0aWxlX3Jvd19zdGFydCArIGxvY2FsX2lkLng7XG4gICAgICB2YXIgcm93ID0ga19zdGFydCArIGxvY2FsX2lkLnk7XG4gICAgICBpZiAoY29sIDwgdW5pZm9ybXMuTSAmJiByb3cgPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIHRpbGVfYVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9IGFbcm93ICogdW5pZm9ybXMuTSArIGNvbF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWxlX2FbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke3YudHlwZS52YWx1ZX0oMCk7XG4gICAgICB9XG5cbiAgICAgIGNvbCA9IGtfc3RhcnQgKyBsb2NhbF9pZC54O1xuICAgICAgcm93ID0gdGlsZV9jb2xfc3RhcnQgKyBsb2NhbF9pZC55O1xuICAgICAgaWYgKGNvbCA8IHVuaWZvcm1zLksgJiYgcm93IDwgdW5pZm9ybXMuTikge1xuICAgICAgICB0aWxlX2JbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSBiW3JvdyAqIHVuaWZvcm1zLksgKyBjb2xdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGlsZV9iW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gJHtTLnR5cGUudmFsdWV9KDApO1xuICAgICAgfVxuICAgICAgYCxEPVwidmFsdWUgKz0gdGlsZV9hW2tdW2xvY2FsX2lkLnldICogdGlsZV9iW2xvY2FsX2lkLnhdW2tdO1wiKTp0LnRyYW5zQSYmIXQudHJhbnNCPyhSPWBcbiAgICAgIHZhciBjb2wgPSB0aWxlX3Jvd19zdGFydCArIGxvY2FsX2lkLng7XG4gICAgICB2YXIgcm93ID0ga19zdGFydCArIGxvY2FsX2lkLnk7XG4gICAgICBpZiAoY29sIDwgdW5pZm9ybXMuTSAmJiByb3cgPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIHRpbGVfYVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9IGFbcm93ICogdW5pZm9ybXMuTSArIGNvbF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWxlX2FbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke3YudHlwZS52YWx1ZX0oMCk7XG4gICAgICB9XG5cbiAgICAgIGNvbCA9IHRpbGVfY29sX3N0YXJ0ICsgbG9jYWxfaWQueDtcbiAgICAgIHJvdyA9IGtfc3RhcnQgKyBsb2NhbF9pZC55O1xuICAgICAgaWYgKGNvbCA8IHVuaWZvcm1zLk4gJiYgcm93IDwgdW5pZm9ybXMuSykge1xuICAgICAgICB0aWxlX2JbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSBiW3JvdyAqIHVuaWZvcm1zLk4gKyBjb2xdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGlsZV9iW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gJHtTLnR5cGUudmFsdWV9KDApO1xuICAgICAgfVxuICAgICAgYCxEPVwidmFsdWUgKz0gdGlsZV9hW2tdW2xvY2FsX2lkLnldICogdGlsZV9iW2tdW2xvY2FsX2lkLnhdO1wiKTohdC50cmFuc0EmJnQudHJhbnNCPyhSPWBcbiAgICAgIHZhciBjb2wgPSBrX3N0YXJ0ICsgbG9jYWxfaWQueDtcbiAgICAgIHZhciByb3cgPSB0aWxlX3Jvd19zdGFydCArIGxvY2FsX2lkLnk7XG4gICAgICBpZiAoY29sIDwgdW5pZm9ybXMuSyAmJiByb3cgPCB1bmlmb3Jtcy5NKSB7XG4gICAgICAgIHRpbGVfYVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9IGFbcm93ICogdW5pZm9ybXMuSyArIGNvbF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWxlX2FbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke3YudHlwZS52YWx1ZX0oMCk7XG4gICAgICB9XG5cbiAgICAgIGNvbCA9IGtfc3RhcnQgKyBsb2NhbF9pZC54O1xuICAgICAgcm93ID0gdGlsZV9jb2xfc3RhcnQgKyBsb2NhbF9pZC55O1xuICAgICAgaWYgKGNvbCA8IHVuaWZvcm1zLksgJiYgcm93IDwgdW5pZm9ybXMuTikge1xuICAgICAgICB0aWxlX2JbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSBiW3JvdyAqIHVuaWZvcm1zLksgKyBjb2xdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGlsZV9iW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gJHtTLnR5cGUudmFsdWV9KDApO1xuICAgICAgfVxuICAgICAgYCxEPVwidmFsdWUgKz0gdGlsZV9hW2xvY2FsX2lkLnldW2tdICogdGlsZV9iW2xvY2FsX2lkLnhdW2tdO1wiKTohdC50cmFuc0EmJiF0LnRyYW5zQiYmKFI9YFxuICAgICAgdmFyIGNvbCA9IGtfc3RhcnQgKyBsb2NhbF9pZC54O1xuICAgICAgdmFyIHJvdyA9IHRpbGVfcm93X3N0YXJ0ICsgbG9jYWxfaWQueTtcbiAgICAgIGlmIChjb2wgPCB1bmlmb3Jtcy5LICYmIHJvdyA8IHVuaWZvcm1zLk0pIHtcbiAgICAgICAgdGlsZV9hW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gYVtyb3cgKiB1bmlmb3Jtcy5LICsgY29sXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbGVfYVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9ICR7di50eXBlLnZhbHVlfSgwKTtcbiAgICAgIH1cblxuICAgICAgY29sID0gdGlsZV9jb2xfc3RhcnQgKyBsb2NhbF9pZC54O1xuICAgICAgcm93ID0ga19zdGFydCArIGxvY2FsX2lkLnk7XG4gICAgICBpZiAoY29sIDwgdW5pZm9ybXMuTiAmJiByb3cgPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIHRpbGVfYltsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9IGJbcm93ICogdW5pZm9ybXMuTiArIGNvbF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWxlX2JbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke1MudHlwZS52YWx1ZX0oMCk7XG4gICAgICB9XG4gICAgICBgLEQ9XCJ2YWx1ZSArPSB0aWxlX2FbbG9jYWxfaWQueV1ba10gKiB0aWxlX2Jba11bbG9jYWxfaWQueF07XCIpO2xldCBHPXQuYWxwaGE9PT0xP1wiXCI6XCJ2YWx1ZSAqPSB1bmlmb3Jtcy5hbHBoYTtcIjtyZXR1cm5gXG4gICR7JC5yZWdpc3RlclVuaWZvcm1zKFApLmRlY2xhcmVWYXJpYWJsZXMoLi4uQSl9XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVfYTogYXJyYXk8YXJyYXk8JHt2LnR5cGUuc3RvcmFnZX0sICR7bH0+LCAke2x9PjtcbiAgdmFyPHdvcmtncm91cD4gdGlsZV9iOiBhcnJheTxhcnJheTwke1MudHlwZS5zdG9yYWdlfSwgJHtsfT4sICR7bH0+O1xuICAkeyQubWFpblN0YXJ0KFtsLGwsMV0pfVxuICAgIGxldCB0aWxlX2NvbF9zdGFydCA9ICh3b3JrZ3JvdXBfaW5kZXggJSB1bmlmb3Jtcy5udW1fdGlsZV9uKSAqICR7bH07XG4gICAgbGV0IHRpbGVfcm93X3N0YXJ0ID0gKHdvcmtncm91cF9pbmRleCAvIHVuaWZvcm1zLm51bV90aWxlX24pICogJHtsfTtcbiAgICBsZXQgbnVtX3RpbGVzID0gKHVuaWZvcm1zLksgLSAxKSAvICR7bH0gKyAxO1xuICAgIHZhciBrX3N0YXJ0ID0gMHU7XG4gICAgdmFyIHZhbHVlID0gJHtrLnR5cGUudmFsdWV9KDApO1xuICAgIGZvciAodmFyIHQ6IHUzMiA9IDB1OyB0IDwgbnVtX3RpbGVzOyB0KyspIHtcbiAgICAgICR7Un1cbiAgICAgIGtfc3RhcnQgPSBrX3N0YXJ0ICsgJHtsfTtcbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgZm9yICh2YXIgazogdTMyID0gMHU7IGsgPCAke2x9OyBrKyspIHtcbiAgICAgICAgJHtEfVxuICAgICAgfVxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgIH1cblxuICAgICR7R31cbiAgICBsZXQgbSA9IHRpbGVfcm93X3N0YXJ0ICsgbG9jYWxfaWQueTtcbiAgICBsZXQgbiA9IHRpbGVfY29sX3N0YXJ0ICsgbG9jYWxfaWQueDtcbiAgICAkeygoKT0+VCE9bnVsbD9gbGV0IGNPZmZzZXQgPSAke1QuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoXCJ2ZWMyKG0sIG4pXCIsayl9OyB2YWx1ZSArPSAke2sudHlwZS52YWx1ZX0odW5pZm9ybXMuYmV0YSkgKiAke1QuZ2V0QnlPZmZzZXQoXCJjT2Zmc2V0XCIpfTtgOlwiXCIpKCl9XG4gICAgaWYgKG0gPCB1bmlmb3Jtcy5NICYmIG4gPCB1bmlmb3Jtcy5OKSB7XG4gICAgICBvdXRwdXRbbSAqIHVuaWZvcm1zLk4gKyBuXSA9IHZhbHVlO1xuICAgIH1cbiAgfWB9O3JldHVybiB1P3tuYW1lOlwiR2VtbVNoYXJlZFwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9YCxpbnB1dERlcGVuZGVuY2llczp5fSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmQsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6cCptfSxwcm9ncmFtVW5pZm9ybXM6X30pLGdldFNoYWRlclNvdXJjZTp4fTp7bmFtZTpcIkdlbW1cIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmNhY2hlS2V5fWAsaW5wdXREZXBlbmRlbmNpZXM6eX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpkLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChoLzY0KX0scHJvZ3JhbVVuaWZvcm1zOl99KSxnZXRTaGFkZXJTb3VyY2U6Z319LE9kPWU9PntsZXQgdD1lLnRyYW5zQSxyPWUudHJhbnNCLG49ZS5hbHBoYSxvPWUuYmV0YTtyZXR1cm57dHJhbnNBOnQsdHJhbnNCOnIsYWxwaGE6bixiZXRhOm8sY2FjaGVLZXk6YCR7ZS50cmFuc0F9OyR7ZS50cmFuc0J9OyR7ZS5hbHBoYT09PTF9YH19LERkPShlLHQpPT57VmYoZS5pbnB1dHMpLGUuY29tcHV0ZShXZihlLmlucHV0cyx0KSl9fSk7dmFyIGx0LF90LFV0LE50LExmLEdmLEhmLEZmLHFmLEtmLGpmLFlmLE1kLFJkLFVkPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7U2UoKTthZSgpO1tsdCxfdCxVdCxOdF09WzAsMSwyLDNdLExmPWU9PntpZihlWzBdLmRpbXMubGVuZ3RoIT09NCl0aHJvdyBuZXcgRXJyb3IoXCJvbmx5IDQtRCB0ZW5zb3IgaXMgc3VwcG9ydGVkLlwiKTtpZihlWzBdLmRpbXMubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCBkaW1lbnNpb25zIG11c3QgYmUgZXF1YWwgdG8gZ3JpZCBkaW1lbnNpb25zXCIpO2lmKGVbMF0uZGltcy5sZW5ndGgtMiE9PWVbMV0uZGltc1tlWzFdLmRpbXMubGVuZ3RoLTFdKXRocm93IG5ldyBFcnJvcihgbGFzdCBkaW1lbnNpb24gb2YgZ3JpZCBtdXN0IGJlIGVxdWFsIHRvICR7ZVswXS5kaW1zLmxlbmd0aC0yfWApO2lmKGVbMF0uZGltc1swXSE9PWVbMV0uZGltc1swXSl0aHJvdyBuZXcgRXJyb3IoXCJncmlkIGJhdGNoIHNpemUgbXVzdCBtYXRjaCBpbnB1dCBiYXRjaCBzaXplXCIpfSxHZj1gXG4gIGZuIGdzX2dldF9jdWJpY19jb2VmZnMoeDogZjMyKSAtPiB2ZWM0PGYzMj4ge1xuICAgIGxldCBjdWJpY19hbHBoYSA9IC0wLjc1ZjtcbiAgICBsZXQgeF9hYnMgPSBhYnMoeCk7XG4gICAgdmFyIGNvZWZmczogdmVjNDxmMzI+O1xuICAgIGNvZWZmc1swXSA9ICgoKGN1YmljX2FscGhhICogKHhfYWJzICsgMSkgLSA1ICogY3ViaWNfYWxwaGEpICogKHhfYWJzICsgMSkgKyA4ICogY3ViaWNfYWxwaGEpICogKHhfYWJzICsgMSkgLSA0ICogY3ViaWNfYWxwaGEpO1xuICAgIGNvZWZmc1sxXSA9ICgoKGN1YmljX2FscGhhICsgMikgKiB4X2FicyAtIChjdWJpY19hbHBoYSArIDMpKSAqIHhfYWJzICogeF9hYnMgKyAxKTtcbiAgICBjb2VmZnNbMl0gPSAoKChjdWJpY19hbHBoYSArIDIpICogKDEgLSB4X2FicykgLSAoY3ViaWNfYWxwaGEgKyAzKSkgKiAoMSAtIHhfYWJzKSAqICgxIC0geF9hYnMpICsgMSk7XG4gICAgY29lZmZzWzNdID0gKCgoY3ViaWNfYWxwaGEgKiAoMiAtIHhfYWJzKSAtIDUgKiBjdWJpY19hbHBoYSkgKiAoMiAtIHhfYWJzKSArIDggKiBjdWJpY19hbHBoYSkgKiAoMiAtIHhfYWJzKSAtIDQgKiBjdWJpY19hbHBoYSk7XG4gICAgcmV0dXJuIGNvZWZmcztcbiAgfVxuYCxIZj1lPT5gXG4gIGZuIGdzX2JpY3ViaWNfaW50ZXJwb2xhdGUocDogbWF0NHg0PCR7ZX0+LCB4OiBmMzIsIHk6IGYzMikgLT4gJHtlfSB7XG4gICAgdmFyIHY6IHZlYzQ8ZjMyPjtcbiAgICB2YXIgY29lZmZzID0gZ3NfZ2V0X2N1YmljX2NvZWZmcyh4KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgdltpXSA9IGNvZWZmc1swXSAqIHBbaV1bMF0gKyBjb2VmZnNbMV0gKiBwW2ldWzFdICsgY29lZmZzWzJdICogcFtpXVsyXSArIGNvZWZmc1szXSAqIHBbaV1bM107XG4gICAgfVxuICAgIGNvZWZmcyA9IGdzX2dldF9jdWJpY19jb2VmZnMoeSk7XG4gICAgbGV0IHBpeGVsID0gJHtlfShjb2VmZnNbMF0gKiB2WzBdICsgY29lZmZzWzFdICogdlsxXSArIGNvZWZmc1syXSAqIHZbMl0gKyBjb2VmZnNbM10gKiB2WzNdKTtcbiAgICByZXR1cm4gcGl4ZWw7XG4gIH1cbmAsRmY9ZT0+YFxuICBmbiBnc19kZW5vcm1hbGl6ZShuOiBmMzIsIGxlbmd0aDogaTMyKSAtPiBmMzIge1xuICAgICR7ZS5hbGlnbkNvcm5lcnM9PT0wP2BcbiAgICAvLyBhbGlnbkNvcm5lcnM6IGZhbHNlID0+IFstMSwgMV0gdG8gWy0wLjUsIGxlbmd0aCAtIDAuNV1cbiAgICByZXR1cm4gKChuICsgMS4wKSAqIGYzMihsZW5ndGgpIC0gMS4wKSAvIDIuMDtcbiAgICBgOmBcbiAgICAvLyBhbGlnbkNvcm5lcnM6IHRydWUgPT4gWy0xLCAxXSB0byBbMCwgbGVuZ3RoIC0gMV1cbiAgICByZXR1cm4gKG4gKyAxLjApIC8gMi4wICogKGYzMihsZW5ndGggLSAxKSk7XG4gICAgYH1cbiAgfVxuYCxxZj1lPT5gXG4gICR7ZS5wYWRkaW5nTW9kZT09PVwicmVmbGVjdGlvblwiP2BcbiAgICAgIGZuIGdzX3JlZmxlY3QoeDogaTMyLCB4X21pbjogZjMyLCB4X21heDogZjMyKSAtPiB1MzIge1xuICAgICAgICB2YXIgZHggPSAwLjA7XG4gICAgICAgIHZhciBmeCA9IGYzMih4KTtcbiAgICAgICAgbGV0IHJhbmdlID0geF9tYXggLSB4X21pbjtcbiAgICAgICAgaWYgKGZ4IDwgeF9taW4pIHtcbiAgICAgICAgICBkeCA9IHhfbWluIC0gZng7XG4gICAgICAgICAgbGV0IG4gPSB1MzIoZHggLyByYW5nZSk7XG4gICAgICAgICAgbGV0IHIgPSBkeCAtIGYzMihuKSAqIHJhbmdlO1xuICAgICAgICAgIGlmIChuICUgMiA9PSAwKSB7XG4gICAgICAgICAgICBmeCA9IHhfbWluICsgcjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnggPSB4X21heCAtIHI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGZ4ID4geF9tYXgpIHtcbiAgICAgICAgICBkeCA9IGZ4IC0geF9tYXg7XG4gICAgICAgICAgbGV0IG4gPSB1MzIoZHggLyByYW5nZSk7XG4gICAgICAgICAgbGV0IHIgPSBkeCAtIGYzMihuKSAqIHJhbmdlO1xuICAgICAgICAgIGlmIChuICUgMiA9PSAwKSB7XG4gICAgICAgICAgICBmeCA9IHhfbWF4IC0gcjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnggPSB4X21pbiArIHI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1MzIoZngpO1xuICAgICAgfWA6XCJcIn1cbmAsS2Y9KGUsdCxyKT0+YFxuICBmbiBwaXhlbF9hdF9ncmlkKHI6IGkzMiwgYzogaTMyLCBIOiBpMzIsIFc6IGkzMiwgYmF0Y2g6IHUzMiwgY2hhbm5lbDogdTMyLCBib3JkZXI6IHZlYzQ8ZjMyPikgLT4gJHt0fSB7XG4gICAgIHZhciBwaXhlbCA9ICR7dH0oMCk7XG4gICAgIHZhciBpbmRpY2VzID0gdmVjNDx1MzI+KDApO1xuICAgICBpbmRpY2VzWyR7bHR9XSA9IGJhdGNoO1xuICAgICBpbmRpY2VzWyR7X3R9XSA9IGNoYW5uZWw7YCsoKCk9Pntzd2l0Y2goci5wYWRkaW5nTW9kZSl7Y2FzZVwiemVyb3NcIjpyZXR1cm5gXG4gICAgICAgICAgaWYgKHIgPj0gMCAmJiByIDwgSCAmJiBjID49MCAmJiBjIDwgVykge1xuICAgICAgICAgICAgaW5kaWNlc1ske1V0fV0gPSB1MzIocik7XG4gICAgICAgICAgICBpbmRpY2VzWyR7TnR9XSA9IHUzMihjKTtcbiAgICAgICAgICB9XG4gICAgICAgIGA7Y2FzZVwiYm9yZGVyXCI6cmV0dXJuYFxuICAgICAgICAgIGluZGljZXNbJHtVdH1dID0gdTMyKGNsYW1wKHIsIDAsIEggLSAxKSk7XG4gICAgICAgICAgaW5kaWNlc1ske050fV0gPSB1MzIoY2xhbXAoYywgMCwgVyAtIDEpKTtcbiAgICAgICAgYDtjYXNlXCJyZWZsZWN0aW9uXCI6cmV0dXJuYFxuICAgICAgICAgIGluZGljZXNbJHtVdH1dID0gZ3NfcmVmbGVjdChyLCBib3JkZXJbMV0sIGJvcmRlclszXSk7XG4gICAgICAgICAgaW5kaWNlc1ske050fV0gPSBnc19yZWZsZWN0KGMsIGJvcmRlclswXSwgYm9yZGVyWzJdKTtcbiAgICAgICAgYDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgcGFkZGluZyBtb2RlICR7ci5wYWRkaW5nTW9kZX0gaXMgbm90IHN1cHBvcnRlZGApfX0pKCkrYFxuICAgIHJldHVybiAke2UuZ2V0QnlJbmRpY2VzKFwiaW5kaWNlc1wiKX07XG4gIH1cbmAsamY9KGUsdCxyKT0+KCgpPT57c3dpdGNoKHIubW9kZSl7Y2FzZVwibmVhcmVzdFwiOnJldHVybmBcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gcGl4ZWxfYXRfZ3JpZChpMzIocm91bmQoeSkpLCBpMzIocm91bmQoeCkpLCBIX2luLCBXX2luLCBpbmRpY2VzWyR7bHR9XSwgaW5kaWNlc1ske190fV0sIGJvcmRlcik7XG4gICAgICAgIGA7Y2FzZVwiYmlsaW5lYXJcIjpyZXR1cm5gXG4gICAgICAgICAgbGV0IHgxID0gaTMyKGZsb29yKHgpKTtcbiAgICAgICAgICBsZXQgeTEgPSBpMzIoZmxvb3IoeSkpO1xuICAgICAgICAgIGxldCB4MiA9IHgxICsgMTtcbiAgICAgICAgICBsZXQgeTIgPSB5MSArIDE7XG5cbiAgICAgICAgICBsZXQgcDExID0gcGl4ZWxfYXRfZ3JpZCh5MSwgeDEsIEhfaW4sIFdfaW4sIGluZGljZXNbJHtsdH1dLCBpbmRpY2VzWyR7X3R9XSwgYm9yZGVyKTtcbiAgICAgICAgICBsZXQgcDEyID0gcGl4ZWxfYXRfZ3JpZCh5MSwgeDIsIEhfaW4sIFdfaW4sIGluZGljZXNbJHtsdH1dLCBpbmRpY2VzWyR7X3R9XSwgYm9yZGVyKTtcbiAgICAgICAgICBsZXQgcDIxID0gcGl4ZWxfYXRfZ3JpZCh5MiwgeDEsIEhfaW4sIFdfaW4sIGluZGljZXNbJHtsdH1dLCBpbmRpY2VzWyR7X3R9XSwgYm9yZGVyKTtcbiAgICAgICAgICBsZXQgcDIyID0gcGl4ZWxfYXRfZ3JpZCh5MiwgeDIsIEhfaW4sIFdfaW4sIGluZGljZXNbJHtsdH1dLCBpbmRpY2VzWyR7X3R9XSwgYm9yZGVyKTtcblxuICAgICAgICAgIGxldCBkeDIgPSAke3R9KGYzMih4MikgLSB4KTtcbiAgICAgICAgICBsZXQgZHgxID0gJHt0fSh4IC0gZjMyKHgxKSk7XG4gICAgICAgICAgbGV0IGR5MiA9ICR7dH0oZjMyKHkyKSAtIHkpO1xuICAgICAgICAgIGxldCBkeTEgPSAke3R9KHkgLSBmMzIoeTEpKTtcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gZHkyICogKGR4MiAqIHAxMSArIGR4MSAqIHAxMikgKyBkeTEgKiAoZHgyICogcDIxICsgZHgxICogcDIyKTtcbiAgICAgICAgYDtjYXNlXCJiaWN1YmljXCI6cmV0dXJuYFxuICAgICAgICAgIGxldCB4MCA9IGkzMihmbG9vcih4KSkgLSAxO1xuICAgICAgICAgIGxldCB5MCA9IGkzMihmbG9vcih5KSkgLSAxO1xuICAgICAgICAgIHZhciBwOiBtYXQ0eDQ8JHt0fT47XG4gICAgICAgICAgZm9yICh2YXIgaCA9IDA7IGggPCA0OyBoKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIHcgPSAwOyB3IDwgNDsgdysrKSB7XG4gICAgICAgICAgICAgIHBbaF1bd10gPSBwaXhlbF9hdF9ncmlkKGggKyB5MCwgdyArIHgwLCBIX2luLCBXX2luLCBpbmRpY2VzWyR7bHR9XSwgaW5kaWNlc1ske190fV0sIGJvcmRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IGR4ID0geCAtIGYzMih4MCArIDEpO1xuICAgICAgICAgIGxldCBkeSA9IHkgLSBmMzIoeTAgKyAxKTtcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gZ3NfYmljdWJpY19pbnRlcnBvbGF0ZShwLCBkeCwgZHkpO1xuICAgICAgICBgO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBtb2RlICR7ci5tb2RlfSBpcyBub3Qgc3VwcG9ydGVkYCl9fSkoKStgJHtlLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwicmVzdWx0XCIpfWAsWWY9KGUsdCk9PntsZXQgcj1FKFwieFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLmxlbmd0aCksbj1bZVsxXS5kaW1zWzBdLGVbMV0uZGltc1sxXSxlWzFdLmRpbXNbMl1dLG89RShcImdyaWRcIixlWzFdLmRhdGFUeXBlLG4ubGVuZ3RoLDIpLGk9W2VbMF0uZGltc1swXSxlWzBdLmRpbXNbMV0sZVsxXS5kaW1zWzFdLGVbMV0uZGltc1syXV07dC5mb3JtYXQ9PT1cIk5IV0NcIiYmKGk9W2VbMF0uZGltc1swXSxlWzFdLmRpbXNbMV0sZVsxXS5kaW1zWzJdLGVbMF0uZGltc1szXV0sW2x0LF90LFV0LE50XT1bMCwzLDEsMl0pO2xldCBhPU0oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLGkubGVuZ3RoKSxkPXIudHlwZS52YWx1ZSxsPUMuc2l6ZShpKSxwPVt7dHlwZToxMixkYXRhOmx9LC4uLk4oZVswXS5kaW1zLG4saSldLG09dT0+YFxuICAke3UucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0X3NpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKHIsbyxhKX1cbiAgJHtHZn1cbiAgJHtIZihkKX1cbiAgJHtGZih0KX1cbiAgJHtxZih0KX1cbiAgJHtLZihyLGQsdCl9XG5cbiAgJHt1Lm1haW5TdGFydCgpfVxuICAgICR7dS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgICBsZXQgSF9pbiA9IGkzMih1bmlmb3Jtcy54X3NoYXBlWyR7VXR9XSk7XG4gICAgICBsZXQgV19pbiA9IGkzMih1bmlmb3Jtcy54X3NoYXBlWyR7TnR9XSk7XG5cbiAgICAgICR7dC5hbGlnbkNvcm5lcnM9PT0wP2BcbiAgICAgIGxldCB4X21pbiA9IC0wLjU7XG4gICAgICBsZXQgeF9tYXggPSBmMzIoV19pbikgLSAwLjU7XG4gICAgICBsZXQgeV9taW4gPSAtMC41O1xuICAgICAgbGV0IHlfbWF4ID0gZjMyKEhfaW4pIC0gMC41O1xuICAgICAgYDpgXG4gICAgICBsZXQgeF9taW4gPSAwLjA7XG4gICAgICBsZXQgeF9tYXggPSBmMzIoV19pbikgLSAxLjA7XG4gICAgICBsZXQgeV9taW4gPSAwLjA7XG4gICAgICBsZXQgeV9tYXggPSBmMzIoSF9pbikgLSAxLjA7XG4gICAgICBgfTtcbiAgICAgIGxldCBib3JkZXIgPSB2ZWM0PGYzMj4oeF9taW4sIHlfbWluLCB4X21heCwgeV9tYXgpO1xuXG4gICAgICBsZXQgaW5kaWNlcyA9ICR7YS5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgIHZhciBncmlkX2luZGljZXMgPSB2ZWMzPHUzMj4oaW5kaWNlc1ske2x0fV0sIGluZGljZXNbJHtVdH1dLCBpbmRpY2VzWyR7TnR9XSk7XG4gICAgICBsZXQgbnh5ID0gJHtvLmdldEJ5SW5kaWNlcyhcImdyaWRfaW5kaWNlc1wiKX07XG4gICAgICB2YXIgeCA9IGdzX2Rlbm9ybWFsaXplKGYzMihueHlbMF0pLCBXX2luKTtcbiAgICAgIHZhciB5ID0gZ3NfZGVub3JtYWxpemUoZjMyKG54eVsxXSksIEhfaW4pO1xuXG4gICAgICAke2pmKGEsZCx0KX1cbiAgfWA7cmV0dXJue25hbWU6XCJHcmlkU2FtcGxlXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5jYWNoZUtleX1gLGlucHV0RGVwZW5kZW5jaWVzOltcInR5cGVcIixcInR5cGVcIl19LGdldFJ1bkRhdGE6dT0+e2xldCBoPUMuc2l6ZShpKTtyZXR1cm57b3V0cHV0czpbe2RpbXM6aSxkYXRhVHlwZTp1WzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoaC82NCl9LHByb2dyYW1Vbmlmb3JtczpwfX0sZ2V0U2hhZGVyU291cmNlOm19fSxNZD0oZSx0KT0+e0xmKGUuaW5wdXRzKSxlLmNvbXB1dGUoWWYoZS5pbnB1dHMsdCkpfSxSZD1lPT5yZSh7YWxpZ25Db3JuZXJzOmUuYWxpZ25fY29ybmVycyxtb2RlOmUubW9kZSxwYWRkaW5nTW9kZTplLnBhZGRpbmdfbW9kZSxmb3JtYXQ6ZS5mb3JtYXR9KX0pO3ZhciBCZSxYZixWZCxOZCxKZix0cixXZCxTbz1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtvZSgpO1NlKCk7TnIoKTtGcigpO2FlKCk7ZHQoKTtCZT0oZSx0KT0+ZS5sZW5ndGg+dCYmZVt0XS5kaW1zLmxlbmd0aD4wP2VbdF06dm9pZCAwLFhmPShlLHQpPT57bGV0IHI9ZVswXSxuPUJlKGUsMSksbz1CZShlLDIpLGk9QmUoZSwzKSxhPUJlKGUsNCksZD1CZShlLDUpLGw9QmUoZSw2KSxwPUJlKGUsNyk7aWYoci5kaW1zLmxlbmd0aCE9PTMmJnIuZGltcy5sZW5ndGghPT01KXRocm93IG5ldyBFcnJvcihcIklucHV0IHF1ZXJ5IGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBvciA1IGRpbWVuc2lvbnNcIik7bGV0IG09ci5kaW1zWzBdLHU9ci5kaW1zWzFdLGg9ci5kaW1zLmxlbmd0aD09PTM/ci5kaW1zWzJdOnQubnVtSGVhZHMqci5kaW1zWzRdLF89dSx5PTAsZz0wLHg9TWF0aC5mbG9vcihoL3QubnVtSGVhZHMpO2lmKGwmJnAmJkMuc2l6ZShsLmRpbXMpJiZDLnNpemUocC5kaW1zKSl7aWYobC5kaW1zLmxlbmd0aCE9PTQpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3Rfa2V5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSA0IGRpbWVuc2lvbnMnKTtpZihsLmRpbXNbMF0hPT1tfHxsLmRpbXNbMV0hPT10Lm51bUhlYWRzfHxsLmRpbXNbM10hPT14KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIHNoYXBlIChiYXRjaF9zaXplLCBudW1faGVhZHMsIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoLCBoZWFkX3NpemUpJyk7aWYocC5kaW1zWzBdIT09bXx8cC5kaW1zWzFdIT09dC5udW1IZWFkc3x8cC5kaW1zWzNdIT09eCl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF92YWx1ZVwiIHNoYXBlIChiYXRjaF9zaXplLCBudW1faGVhZHMsIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoLCBoZWFkX3NpemUpJyk7aWYobC5kaW1zWzJdIT09cC5kaW1zWzJdKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIGFuZCBcInBhc3RfdmFsdWVcIiBzaGFsbCBoYXZlIHNhbWUgZGltIDIgKHBhc3Rfc2VxdWVuY2VfbGVuZ3RoKScpO2lmKHAuZGltcy5sZW5ndGghPT00KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X3ZhbHVlXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSA0IGRpbWVuc2lvbnMnKTt5PWwuZGltc1syXSxnPWwuZGltc1syXX1lbHNlIGlmKGwmJkMuc2l6ZShsLmRpbXMpfHxwJiZDLnNpemUocC5kaW1zKSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBhbmQgXCJwYXN0X3ZhbHVlXCIgc2hhbGwgYmUgYm90aCBwcmVzZW50IG9yIGJvdGggYWJzZW50Jyk7bGV0ICQ7aWYobiYmQy5zaXplKG4uZGltcyk+MCl7aWYoci5kaW1zLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIGRpbWVuc2lvbnMgd2hlbiBrZXkgaXMgZ2l2ZW4nKTtpZihuLmRpbXMubGVuZ3RoPDN8fG4uZGltcy5sZW5ndGg+NSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwia2V5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzLCA0LCBvciA1IGRpbWVuc2lvbnMnKTtpZihyLmRpbXNbMF0hPT1uLmRpbXNbMF0pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgYW5kIFwia2V5XCIgc2hhbGwgaGF2ZSBzYW1lIGRpbSAwIChiYXRjaCBzaXplKScpO2lmKG4uZGltcy5sZW5ndGg9PT0zKXtpZihuLmRpbXNbMl0hPT1yLmRpbXNbMl0pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgYW5kIFwia2V5XCIgc2hhbGwgaGF2ZSBzYW1lIGRpbSAyIChoaWRkZW5fc2l6ZSknKTskPTIsXz1uLmRpbXNbMV19ZWxzZSBpZihuLmRpbXMubGVuZ3RoPT09NSl7aWYobi5kaW1zWzJdIT09dC5udW1IZWFkc3x8bi5kaW1zWzNdIT09Mnx8bi5kaW1zWzRdIT09eCl0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcImtleVwiIHNoYXBlIChiYXRjaF9zaXplLCBrdl9zZXF1ZW5jZV9sZW5ndGgsIG51bV9oZWFkcywgMiwgaGVhZF9zaXplKSBmb3IgcGFja2VkIGt2Jyk7aWYobyl0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcInZhbHVlXCIgYmUgbm9uZSB3aGVuIFwia2V5XCIgaGFzIHBhY2tlZCBrdiBmb3JtYXQuJyk7JD01LF89bi5kaW1zWzFdfWVsc2V7aWYobi5kaW1zWzFdIT09dC5udW1IZWFkc3x8bi5kaW1zWzNdIT09eCl0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcImtleVwiIHNoYXBlIChiYXRjaF9zaXplLCBudW1faGVhZHMsIGt2X3NlcXVlbmNlX2xlbmd0aCwgaGVhZF9zaXplKSBmb3IgcGFzdF9rZXknKTskPTAsXz1uLmRpbXNbMl19fWVsc2V7aWYoci5kaW1zLmxlbmd0aCE9PTUpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSA1IGRpbWVuc2lvbnMgd2hlbiBrZXkgaXMgZW1wdHknKTtpZihyLmRpbXNbMl0hPT10Lm51bUhlYWRzfHxyLmRpbXNbM10hPT0zKXRocm93IG5ldyBFcnJvcignRXhwZWN0IFwicXVlcnlcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwga3Zfc2VxdWVuY2VfbGVuZ3RoLCBudW1faGVhZHMsIDMsIGhlYWRfc2l6ZSkgZm9yIHBhY2tlZCBrdicpOyQ9M31pZihpJiZDLnNpemUoaS5kaW1zKT4wKXtpZihpLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwiYmlhc1wiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMSBkaW1lbnNpb24nKTtpZihuJiZuLmRpbXMubGVuZ3RoPT09NSYmbi5kaW1zWzNdPT09Mil0aHJvdyBuZXcgRXJyb3IoXCJiaWFzIGlzIG5vdCBhbGxvd2VkIGZvciBwYWNrZWQga3YuXCIpfWxldCB2PXkrXyxTPTA7aWYoYSYmQy5zaXplKGEuZGltcyk+MCl7Uz04O2xldCBQPWEuZGltczt0aHJvdyBQLmxlbmd0aD09PTE/UFswXT09PW0/Uz0xOlBbMF09PT0zKm0rMiYmKFM9Myk6UC5sZW5ndGg9PT0yJiZQWzBdPT09bSYmUFsxXT09PXYmJihTPTUpLFM9PT04P25ldyBFcnJvcignSW5wdXQgXCJrZXlfcGFkZGluZ19tYXNrXCIgc2hhcGUgc2hhbGwgYmUgKGJhdGNoX3NpemUpIG9yIChiYXRjaF9zaXplLCB0b3RhbF9zZXF1ZW5jZV9sZW5ndGgpJyk6bmV3IEVycm9yKFwiTWFzayBub3Qgc3VwcG9ydGVkXCIpfWxldCBUPSExLEE9aDtpZihvJiZDLnNpemUoby5kaW1zKT4wKXtpZihvLmRpbXMubGVuZ3RoIT09MyYmby5kaW1zLmxlbmd0aCE9PTQpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInZhbHVlXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIG9yIDQgZGltZW5zaW9ucycpO2lmKHIuZGltc1swXSE9PW8uZGltc1swXSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBhbmQgXCJ2YWx1ZVwiIHNoYWxsIGhhdmUgc2FtZSBkaW0gMCAoYmF0Y2hfc2l6ZSknKTtpZihvLmRpbXMubGVuZ3RoPT09Myl7aWYoXyE9PW8uZGltc1sxXSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwia2V5XCIgYW5kIFwidmFsdWVcIiBzaGFsbCBoYXZlIHRoZSBzYW1lIGRpbSAxIChrdl9zZXF1ZW5jZV9sZW5ndGgpJyk7QT1vLmRpbXNbMl19ZWxzZXtpZihfIT09by5kaW1zWzJdKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJrZXlcIiBhbmQgXCJ2YWx1ZVwiIHNoYWxsIGhhdmUgdGhlIHNhbWUgZGltIDIgKGt2X3NlcXVlbmNlX2xlbmd0aCknKTtBPW8uZGltc1sxXSpvLmRpbXNbM10sVD0hMH19bGV0IGs9ITE7aWYoYSYmQy5zaXplKGEuZGltcyk+MCl0aHJvdyBuZXcgRXJyb3IoXCJLZXkgcGFkZGluZyBtYXNrIGlzIG5vdCBzdXBwb3J0ZWRcIik7aWYoZCYmQy5zaXplKGQuZGltcyk+MCl7aWYoZC5kaW1zLmxlbmd0aCE9PTQpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImF0dGVudGlvbl9iaWFzXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSA0IGRpbWVuc2lvbnMnKTtpZihkLmRpbXNbMF0hPT1tfHxkLmRpbXNbMV0hPT10Lm51bUhlYWRzfHxkLmRpbXNbMl0hPT11fHxkLmRpbXNbM10hPT12KXRocm93IG5ldyBFcnJvcignRXhwZWN0IFwiYXR0ZW50aW9uX2JpYXNcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwgbnVtX2hlYWRzLCBzZXF1ZW5jZV9sZW5ndGgsIHRvdGFsX3NlcXVlbmNlX2xlbmd0aCknKX1yZXR1cm57YmF0Y2hTaXplOm0sc2VxdWVuY2VMZW5ndGg6dSxwYXN0U2VxdWVuY2VMZW5ndGg6eSxrdlNlcXVlbmNlTGVuZ3RoOl8sdG90YWxTZXF1ZW5jZUxlbmd0aDp2LG1heFNlcXVlbmNlTGVuZ3RoOmcsaW5wdXRIaWRkZW5TaXplOjAsaGlkZGVuU2l6ZTpoLHZIaWRkZW5TaXplOkEsaGVhZFNpemU6eCx2SGVhZFNpemU6TWF0aC5mbG9vcihBL3QubnVtSGVhZHMpLG51bUhlYWRzOnQubnVtSGVhZHMsaXNVbmlkaXJlY3Rpb25hbDohMSxwYXN0UHJlc2VudFNoYXJlQnVmZmVyOiExLG1hc2tGaWx0ZXJWYWx1ZTp0Lm1hc2tGaWx0ZXJWYWx1ZSxtYXNrVHlwZTpTLHNjYWxlOnQuc2NhbGUsYnJvYWRjYXN0UmVzUG9zQmlhczprLHBhc3NQYXN0SW5LdjpULHFrdkZvcm1hdDokfX0sVmQ9ZT0+cmUoey4uLmV9KSxOZD1yZSh7cGVybTpbMCwyLDEsM119KSxKZj0oZSx0LHIsbixvLGksYSk9PntsZXQgZD1bbixvLGldLGw9Qy5zaXplKGQpLHA9W3t0eXBlOjEyLGRhdGE6bH0se3R5cGU6MTIsZGF0YTphfSx7dHlwZToxMixkYXRhOml9XSxtPXU9PntsZXQgaD1NKFwicWt2X3dpdGhfYmlhc1wiLHQuZGF0YVR5cGUsZCksXz1FKFwicWt2XCIsdC5kYXRhVHlwZSxkKSx5PUUoXCJiaWFzXCIsci5kYXRhVHlwZSxkKSxnPVt7bmFtZTpcIm91dHB1dF9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImJpYXNfb2Zmc2V0XCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImhpZGRlbl9zaXplXCIsdHlwZTpcInUzMlwifV07cmV0dXJuYFxuICAke3UucmVnaXN0ZXJVbmlmb3JtcyhnKS5kZWNsYXJlVmFyaWFibGVzKF8seSxoKX1cbiAgJHt1Lm1haW5TdGFydCgpfVxuICAgICR7dS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgbGV0IGJpYXNfb2Zmc2V0X2lkeCA9IChnbG9iYWxfaWR4ICUgdW5pZm9ybXMuaGlkZGVuX3NpemUpICsgdW5pZm9ybXMuYmlhc19vZmZzZXQ7XG5cbiAgICBxa3Zfd2l0aF9iaWFzW2dsb2JhbF9pZHhdID0gcWt2W2dsb2JhbF9pZHhdICsgYmlhc1tiaWFzX29mZnNldF9pZHhdO1xuICB9YH07cmV0dXJuIGUuY29tcHV0ZSh7bmFtZTpcIk11bHRpSGVhZEF0dGVudGlvbkFkZEJpYXNcIixzaGFkZXJDYWNoZTp7aW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiLFwidHlwZVwiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpkLGRhdGFUeXBlOnQuZGF0YVR5cGUsZ3B1RGF0YVR5cGU6MH1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGwvNjQpfSxwcm9ncmFtVW5pZm9ybXM6cH0pLGdldFNoYWRlclNvdXJjZTptfSx7aW5wdXRzOlt0LHJdLG91dHB1dHM6Wy0xXX0pWzBdfSx0cj0oZSx0LHIsbixvLGksYSxkKT0+e2xldCBsPWk7aWYoYSYmQy5zaXplKGEuZGltcyk+MCl7aWYobj09PTEpdGhyb3cgbmV3IEVycm9yKFwiQWRkQmlhc1Jlc2hhcGUgaXMgbm90IGltcGxlbWVudGVkLiBQbGVhc2UgZXhwb3J0IHlvdXIgbW9kZWwgd2l0aCBwYWNrZWQgUUtWIG9yIEtWXCIpO3JldHVybiBsPUpmKGUsaSxhLHQsbixyKm8sZCksbD1sLnJlc2hhcGUoW3QsbixyLG9dKSxyPT09MXx8bj09PTE/bDplLmNvbXB1dGUoUGUobCxOZC5wZXJtKSx7aW5wdXRzOltsXSxvdXRwdXRzOlstMV19KVswXX1lbHNlIHJldHVybiBpLmRpbXMubGVuZ3RoPT09MyYmKGw9aS5yZXNoYXBlKFt0LG4scixvXSkpLHI9PT0xfHxuPT09MT9sOmUuY29tcHV0ZShQZShsLE5kLnBlcm0pLHtpbnB1dHM6W2xdLG91dHB1dHM6Wy0xXX0pWzBdfSxXZD0oZSx0KT0+e2xldCByPVhmKGUuaW5wdXRzLHQpLG49ZS5pbnB1dHNbMF0sbz1CZShlLmlucHV0cywxKSxpPUJlKGUuaW5wdXRzLDIpLGE9QmUoZS5pbnB1dHMsMyksZD1CZShlLmlucHV0cyw0KSxsPUJlKGUuaW5wdXRzLDUpLHA9QmUoZS5pbnB1dHMsNiksbT1CZShlLmlucHV0cyw3KTtpZihuLmRpbXMubGVuZ3RoPT09NSl0aHJvdyBuZXcgRXJyb3IoXCJQYWNrZWQgUUtWIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtpZihvPy5kaW1zLmxlbmd0aD09PTUpdGhyb3cgbmV3IEVycm9yKFwiUGFja2VkIEtWIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtsZXQgdT1vJiZpJiZvLmRpbXMubGVuZ3RoPT09NCYmaS5kaW1zLmxlbmd0aD09PTQsaD10cihlLHIuYmF0Y2hTaXplLHIubnVtSGVhZHMsci5zZXF1ZW5jZUxlbmd0aCxyLmhlYWRTaXplLG4sYSwwKTtpZih1KXJldHVybiBSdChlLGgsbyxpLGQsdm9pZCAwLHAsbSxsLHIpO2lmKCFvfHwhaSl0aHJvdyBuZXcgRXJyb3IoXCJrZXkgYW5kIHZhbHVlIG11c3QgYmUgcHJvdmlkZWRcIik7bGV0IF89dHIoZSxyLmJhdGNoU2l6ZSxyLm51bUhlYWRzLHIua3ZTZXF1ZW5jZUxlbmd0aCxyLmhlYWRTaXplLG8sYSxyLmhpZGRlblNpemUpLHk9dHIoZSxyLmJhdGNoU2l6ZSxyLm51bUhlYWRzLHIua3ZTZXF1ZW5jZUxlbmd0aCxyLnZIZWFkU2l6ZSxpLGEsMipyLmhpZGRlblNpemUpO1J0KGUsaCxfLHksZCx2b2lkIDAscCxtLGwscil9fSk7dmFyIGVoLHRoLHJoLG5oLFRvLExkLEdkLElvPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7U2UoKTthZSgpO2VoPWU9PntpZighZXx8ZS5sZW5ndGg8MSl0aHJvdyBuZXcgRXJyb3IoXCJ0b28gZmV3IGlucHV0c1wiKX0sdGg9KGUsdCk9PntsZXQgcj1bXSxuPXQubnVtT3V0cHV0cztyZXR1cm4gZVsxXS5kaW1zWzBdPjAmJihlWzFdLmdldEJpZ0ludDY0QXJyYXkoKS5mb3JFYWNoKG89PnIucHVzaChOdW1iZXIobykpKSxuPXIubGVuZ3RoKSxyZSh7bnVtT3V0cHV0czpuLGF4aXM6dC5heGlzLHNwbGl0U2l6ZXM6cn0pfSxyaD1lPT5gXG5mbiBjYWxjdWxhdGVPdXRwdXRJbmRleChpbmRleDogdTMyKSAtPiB1MzIge1xuICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgJHtlfXU7IGkgKz0gMXUgKSB7XG4gICAgaWYgKGluZGV4IDwgJHtGKFwidW5pZm9ybXMuc2l6ZV9pbl9zcGxpdF9heGlzXCIsXCJpXCIsZSl9KSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICR7ZX11O1xufWAsbmg9ZT0+e2xldCB0PWUubGVuZ3RoLHI9W107Zm9yKGxldCBuPTA7bjx0Oysrbil7bGV0IG89ZVtuXS5zZXRCeUluZGljZXMoXCJpbmRpY2VzXCIsXCJpbnB1dFtnbG9iYWxfaWR4XVwiKTt0PT09MT9yLnB1c2gobyk6bj09PTA/ci5wdXNoKGBpZiAob3V0cHV0X251bWJlciA9PSAke259dSkgeyAke299IH1gKTpuPT09dC0xP3IucHVzaChgZWxzZSB7ICR7b30gfWApOnIucHVzaChgZWxzZSBpZiAob3V0cHV0X251bWJlciA9PSAke259KSB7ICR7b30gfWApfXJldHVybmBcbiAgICAgIGZuIHdyaXRlQnVmZmVyRGF0YShvdXRwdXRfbnVtYmVyOiB1MzIsIGluZGljZXM6ICR7ZVswXS50eXBlLmluZGljZXN9LCBnbG9iYWxfaWR4OiB1MzIpIHtcbiAgICAgICAgJHtyLmpvaW4oYFxuYCl9XG4gICAgICB9YH0sVG89KGUsdCk9PntsZXQgcj1lWzBdLmRpbXMsbj1DLnNpemUociksbz1lWzBdLmRhdGFUeXBlLGk9Qy5ub3JtYWxpemVBeGlzKHQuYXhpcyxyLmxlbmd0aCksYT1uZXcgQXJyYXkodC5udW1PdXRwdXRzKSxkPUUoXCJpbnB1dFwiLG8sci5sZW5ndGgpLGw9bmV3IEFycmF5KHQubnVtT3V0cHV0cykscD1bXSxtPVtdLHU9MCxoPVt7dHlwZToxMixkYXRhOm59XTtmb3IobGV0IHk9MDt5PHQubnVtT3V0cHV0czt5Kyspe3UrPXQuc3BsaXRTaXplc1t5XSxsW3ldPXU7bGV0IGc9ci5zbGljZSgpO2dbaV09dC5zcGxpdFNpemVzW3ldLG0ucHVzaChnKSxhW3ldPU0oYG91dHB1dCR7eX1gLG8sZy5sZW5ndGgpLHAucHVzaCh7ZGltczptW3ldLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9KX1oLnB1c2goe3R5cGU6MTIsZGF0YTpsfSwuLi5OKHIsLi4ubSkpO2xldCBfPXk9PmBcbiAgJHt5LnJlZ2lzdGVyVW5pZm9ybShcImlucHV0X3NpemVcIixcInUzMlwiKS5yZWdpc3RlclVuaWZvcm0oXCJzaXplX2luX3NwbGl0X2F4aXNcIixcInUzMlwiLGwubGVuZ3RoKS5kZWNsYXJlVmFyaWFibGVzKGQsLi4uYSl9XG4gICR7cmgobC5sZW5ndGgpfVxuICAke25oKGEpfVxuXG4gICR7eS5tYWluU3RhcnQoKX1cbiAgICAke3kuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLmlucHV0X3NpemVcIil9XG5cbiAgICB2YXIgaW5kaWNlcyA9ICR7ZC5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICB2YXIgaW5kZXggPSAke2QuaW5kaWNlc0dldChcImluZGljZXNcIixpKX07XG4gICAgbGV0IG91dHB1dF9udW1iZXIgPSBjYWxjdWxhdGVPdXRwdXRJbmRleChpbmRleCk7XG4gICAgaWYgKG91dHB1dF9udW1iZXIgIT0gMCkge1xuICAgICAgaW5kZXggLT0gJHtGKFwidW5pZm9ybXMuc2l6ZV9pbl9zcGxpdF9heGlzXCIsXCJvdXRwdXRfbnVtYmVyIC0gMXVcIixsLmxlbmd0aCl9O1xuICAgICAgJHtkLmluZGljZXNTZXQoXCJpbmRpY2VzXCIsaSxcImluZGV4XCIpfTtcbiAgICB9XG4gICAgd3JpdGVCdWZmZXJEYXRhKG91dHB1dF9udW1iZXIsIGluZGljZXMsIGdsb2JhbF9pZHgpO1xuICB9YDtyZXR1cm57bmFtZTpcIlNwbGl0XCIsc2hhZGVyQ2FjaGU6e2hpbnQ6dC5jYWNoZUtleSxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxnZXRTaGFkZXJTb3VyY2U6XyxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6cCxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChuLzY0KX0scHJvZ3JhbVVuaWZvcm1zOmh9KX19LExkPShlLHQpPT57ZWgoZS5pbnB1dHMpO2xldCByPWUuaW5wdXRzLmxlbmd0aD09PTE/dDp0aChlLmlucHV0cyx0KTtlLmNvbXB1dGUoVG8oZS5pbnB1dHMscikse2lucHV0czpbMF19KX0sR2Q9ZT0+e2xldCB0PWUuYXhpcyxyPWUuc3BsaXRTaXplcyxuPWUubnVtT3V0cHV0czwwP3IubGVuZ3RoOmUubnVtT3V0cHV0cztpZihuIT09ci5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwibnVtT3V0cHV0cyBhbmQgc3BsaXRTaXplcyBsZW5naCBtdXN0IGJlIGVxdWFsXCIpO3JldHVybiByZSh7YXhpczp0LG51bU91dHB1dHM6bixzcGxpdFNpemVzOnJ9KX19KTt2YXIgb2gsaWgsSGQsRmQscWQ9VSgoKT0+e1widXNlIHN0cmljdFwiO1NlKCk7RnIoKTtTbygpO0lvKCk7ZHQoKTtvaD0oZSx0KT0+e2lmKHQuZG9Sb3RhcnkpdGhyb3cgbmV3IEVycm9yKFwiR3JvdXBRdWVycnlBdHRlbnRpb24gZG9fcm90YXJ5IGF0dHJpYnV0ZSBpcyBub3Qgc3VwcG9ydGVkXCIpO2lmKHQuZG9Sb3RhcnkmJmUubGVuZ3RoPD03KXRocm93IG5ldyBFcnJvcihcImNvc19jYWNoZSBhbmQgc2luX2NhY2hlIGlucHV0cyBhcmUgcmVxdWlyZWQgaWYgZG9fcm90YXJ5IGlzIHNwZWNpZmllZFwiKTtsZXQgcj1lWzBdLG49ZVsxXSxvPWVbMl0saT1lWzNdLGE9ZVs0XTtpZih0LmxvY2FsV2luZG93U2l6ZSE9PS0xKXRocm93IG5ldyBFcnJvcihcIkxvY2FsIGF0dGVudGlvbiBpcyBub3Qgc3VwcG9ydGVkXCIpO2lmKHQuc29mdGNhcCE9PTApdGhyb3cgbmV3IEVycm9yKFwiU29mdGNhcCBpcyBub3Qgc3VwcG9ydGVkXCIpO2lmKHQucm90YXJ5SW50ZXJsZWF2ZWQhPT0wKXRocm93IG5ldyBFcnJvcihcIlJvdGFyeSBpbnRlcmxlYXZlZCBpcyBub3Qgc3VwcG9ydGVkXCIpO2lmKHQuc21vb3RoU29mdG1heCl0aHJvdyBuZXcgRXJyb3IoXCJTbW9vdGggc29mdG1heCBpcyBub3Qgc3VwcG9ydGVkXCIpO2lmKHIuZGltcy5sZW5ndGghPT0zJiZyLmRpbXMubGVuZ3RoIT09NSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBxdWVyeSBpcyBleHBlY3RlZCB0byBoYXZlIDMgb3IgNSBkaW1lbnNpb25zXCIpO2xldCBkPSExLGw9ci5kaW1zWzBdLHA9ci5kaW1zWzFdLG09ci5kaW1zLmxlbmd0aD09PTM/ZD9yLmRpbXNbMl0vMzpyLmRpbXNbMl06dC5udW1IZWFkcypyLmRpbXNbNF0sdT1wLGg9MCxfPSFufHxuLmRpbXMubGVuZ3RoPT09MCx5PU1hdGguZmxvb3IoXz9tLyh0Lm51bUhlYWRzKzIqdC5rdk51bUhlYWRzKTptL3QubnVtSGVhZHMpO18mJihtPXkqdC5udW1IZWFkcyk7bGV0IGc9aSYmaS5kaW1zLmxlbmd0aCE9PTAseD1hJiZhLmRpbXMubGVuZ3RoIT09MDtpZihnJiZpLmRpbXMubGVuZ3RoPT09NCYmaS5kaW1zWzBdPT09bCYmaS5kaW1zWzFdIT09dC5rdk51bUhlYWRzJiZpLmRpbXNbMl09PT10Lmt2TnVtSGVhZHMmJmkuZGltc1szXT09PXkpdGhyb3cgbmV3IEVycm9yKFwiQlNOSCBwYXN0S2V5L3Bhc3RWYWx1ZSBpcyBub3Qgc3VwcG9ydGVkXCIpO2lmKGcmJngpe2lmKGkuZGltcy5sZW5ndGghPT00KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgNCBkaW1lbnNpb25zJyk7aWYoYS5kaW1zLmxlbmd0aCE9PTQpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RfdmFsdWVcIiBpcyBleHBlY3RlZCB0byBoYXZlIDQgZGltZW5zaW9ucycpO2g9aS5kaW1zWzJdfWVsc2UgaWYoZ3x8eCl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBhbmQgXCJwYXN0X3ZhbHVlXCIgc2hhbGwgYmUgYm90aCBwcmVzZW50IG9yIGJvdGggYWJzZW50Jyk7bGV0IHY9MTtpZihuJiZuLmRpbXMubGVuZ3RoPjApe2lmKHIuZGltcy5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBkaW1lbnNpb25zIHdoZW4ga2V5IGlzIGdpdmVuJyk7aWYobi5kaW1zLmxlbmd0aDwzfHxuLmRpbXMubGVuZ3RoPjUpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImtleVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMywgNCwgb3IgNSBkaW1lbnNpb25zJyk7aWYoci5kaW1zWzBdIT09bi5kaW1zWzBdKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGFuZCBcImtleVwiIHNoYWxsIGhhdmUgc2FtZSBkaW0gMCAoYmF0Y2ggc2l6ZSknKTtpZihuLmRpbXMubGVuZ3RoPT09Myl7aWYoci5kaW1zWzJdJW4uZGltc1syXSE9PTApdGhyb3cgbmV3IEVycm9yKCdEaW1lbnNpb24gMiBvZiBcInF1ZXJ5XCIgc2hvdWxkIGJlIGEgbXVsdGlwbGUgb2YgXCJrZXlcIicpO3U9bi5kaW1zWzFdfWVsc2UgaWYobi5kaW1zLmxlbmd0aD09PTUpe2lmKG4uZGltc1syXSE9PXQubnVtSGVhZHN8fG4uZGltc1szXSE9PTJ8fG4uZGltc1s0XSE9PXkpdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJrZXlcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwga3Zfc2VxdWVuY2VfbGVuZ3RoLCBudW1faGVhZHMsIDIsIGhlYWRfc2l6ZSkgZm9yIHBhY2tlZCBrdicpO2lmKG8pdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJ2YWx1ZVwiIGJlIG5vbmUgd2hlbiBcImtleVwiIGhhcyBwYWNrZWQga3YgZm9ybWF0LicpO3U9bi5kaW1zWzFdfWVsc2V7aWYobi5kaW1zWzFdIT09dC5udW1IZWFkc3x8bi5kaW1zWzNdIT09eSl0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcImtleVwiIHNoYXBlIChiYXRjaF9zaXplLCBudW1faGVhZHMsIGt2X3NlcXVlbmNlX2xlbmd0aCwgaGVhZF9zaXplKSBmb3IgcGFzdF9rZXknKTt1PW4uZGltc1syXX19ZWxzZXtpZihyLmRpbXMubGVuZ3RoIT09MyYmci5kaW1zLmxlbmd0aCE9PTUpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIG9yIDUgZGltZW5zaW9ucyB3aGVuIGtleSBpcyBlbXB0eScpO2lmKHIuZGltcy5sZW5ndGg9PT01JiYoci5kaW1zWzJdIT09dC5udW1IZWFkc3x8ci5kaW1zWzNdIT09MykpdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJxdWVyeVwiIHNoYXBlIChiYXRjaF9zaXplLCBrdl9zZXF1ZW5jZV9sZW5ndGgsIG51bV9oZWFkcywgMywgaGVhZF9zaXplKSBmb3IgcGFja2VkIGt2Jyk7dj0zfWxldCBTPTAsVD0hMSxBPXQua3ZOdW1IZWFkcz95KnQua3ZOdW1IZWFkczptO2lmKG8mJm8uZGltcy5sZW5ndGg+MCl7aWYoby5kaW1zLmxlbmd0aCE9PTMmJm8uZGltcy5sZW5ndGghPT00KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJ2YWx1ZVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBvciA0IGRpbWVuc2lvbnMnKTtpZihyLmRpbXNbMF0hPT1vLmRpbXNbMF0pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgYW5kIFwidmFsdWVcIiBzaGFsbCBoYXZlIHNhbWUgZGltIDAgKGJhdGNoX3NpemUpJyk7aWYoby5kaW1zLmxlbmd0aD09PTMpe2lmKHUhPT1vLmRpbXNbMV0pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImtleVwiIGFuZCBcInZhbHVlXCIgc2hhbGwgaGF2ZSB0aGUgc2FtZSBkaW0gMSAoa3Zfc2VxdWVuY2VfbGVuZ3RoKScpO0E9by5kaW1zWzJdfWVsc2V7aWYodSE9PW8uZGltc1syXSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBhbmQgXCJwYXN0X3ZhbHVlXCIgc2hhbGwgaGF2ZSB0aGUgc2FtZSBkaW0gMiAoa3Zfc2VxdWVuY2VfbGVuZ3RoKScpO0E9by5kaW1zWzFdKm8uZGltc1szXSxUPSEwfX1sZXQgaz1lLmxlbmd0aD40P2VbNV06dm9pZCAwO2lmKGsmJmsuZGltcy5sZW5ndGghPT0xJiZrLmRpbXNbMF0hPT1sKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJzZXFsZW5zXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAxIGRpbWVuc2lvbiBhbmQgdGhlIHNhbWUgZGltIDAgYXMgYmF0Y2hfc2l6ZScpO2xldCBQPS0xLEQ9LTEsUj0hMTtyZXR1cm57YmF0Y2hTaXplOmwsc2VxdWVuY2VMZW5ndGg6cCxwYXN0U2VxdWVuY2VMZW5ndGg6aCxrdlNlcXVlbmNlTGVuZ3RoOnUsdG90YWxTZXF1ZW5jZUxlbmd0aDpQLG1heFNlcXVlbmNlTGVuZ3RoOkQsaW5wdXRIaWRkZW5TaXplOjAsaGlkZGVuU2l6ZTptLHZIaWRkZW5TaXplOkEsaGVhZFNpemU6eSx2SGVhZFNpemU6TWF0aC5mbG9vcihBL3Qua3ZOdW1IZWFkcyksbnVtSGVhZHM6dC5udW1IZWFkcyxrdk51bUhlYWRzOnQua3ZOdW1IZWFkcyxuUmVwczp0Lm51bUhlYWRzL3Qua3ZOdW1IZWFkcyxwYXN0UHJlc2VudFNoYXJlQnVmZmVyOiExLG1hc2tUeXBlOlMsc2NhbGU6dC5zY2FsZSxicm9hZGNhc3RSZXNQb3NCaWFzOlIscGFzc1Bhc3RJbkt2OlQscWt2Rm9ybWF0OnZ9fSxpaD1yZSh7cGVybTpbMCwyLDEsM119KSxIZD0oZSx0LHIpPT57bGV0IG49dCxvPXIua3ZOdW1IZWFkcztyZXR1cm4gdC5kaW1zLmxlbmd0aD09PTMmJnIua3ZTZXF1ZW5jZUxlbmd0aCE9PTAmJihuPXQucmVzaGFwZShbci5iYXRjaFNpemUsci5rdlNlcXVlbmNlTGVuZ3RoLG8sci5oZWFkU2l6ZV0pLG49ZS5jb21wdXRlKFBlKG4saWgucGVybSkse2lucHV0czpbbl0sb3V0cHV0czpbLTFdfSlbMF0pLG59LEZkPShlLHQpPT57bGV0IHI9b2goZS5pbnB1dHMsdCk7aWYoZS5pbnB1dHNbMF0uZGltcy5sZW5ndGg9PT01KXRocm93IG5ldyBFcnJvcihcIlBhY2tlZCBRS1YgaXMgbm90IGltcGxlbWVudGVkXCIpO2lmKGUuaW5wdXRzWzFdPy5kaW1zLmxlbmd0aD09PTUpdGhyb3cgbmV3IEVycm9yKFwiUGFja2VkIEtWIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtsZXQgbj1lLmlucHV0c1swXSxvPWUuaW5wdXRzWzFdJiZlLmlucHV0c1sxXS5kaW1zLmxlbmd0aD4wP2UuaW5wdXRzWzFdOnZvaWQgMCxpPWUuaW5wdXRzWzJdJiZlLmlucHV0c1syXS5kaW1zLmxlbmd0aD4wP2UuaW5wdXRzWzJdOnZvaWQgMCxhPWUuaW5wdXRzWzNdJiZlLmlucHV0c1szXS5kaW1zLmxlbmd0aCE9PTA/ZS5pbnB1dHNbM106dm9pZCAwLGQ9ZS5pbnB1dHNbNF0mJmUuaW5wdXRzWzRdLmRpbXMubGVuZ3RoIT09MD9lLmlucHV0c1s0XTp2b2lkIDAsbD1lLmlucHV0cy5sZW5ndGg+ND9lLmlucHV0c1s1XTp2b2lkIDAscD1lLmlucHV0cy5sZW5ndGg+NT9lLmlucHV0c1s2XTp2b2lkIDAsbT1yLmt2TnVtSGVhZHM/ci5rdk51bUhlYWRzOnIubnVtSGVhZHMsdT1yZSh7YXhpczoyLG51bU91dHB1dHM6MyxzcGxpdFNpemVzOltyLm51bUhlYWRzKnIuaGVhZFNpemUsbSpyLmhlYWRTaXplLG0qci5oZWFkU2l6ZV19KSxbaCxfLHldPSFvJiYhaT9lLmNvbXB1dGUoVG8oW25dLHUpLHtpbnB1dHM6W25dLG91dHB1dHM6Wy0xLC0xLC0xXX0pOltuLG8saV0sZz10cihlLHIuYmF0Y2hTaXplLHIubnVtSGVhZHMsci5zZXF1ZW5jZUxlbmd0aCxyLmhlYWRTaXplLGgsdm9pZCAwLDApO1J0KGUsZyxIZChlLF8sciksSGQoZSx5LHIpLHZvaWQgMCx2b2lkIDAsYSxkLHZvaWQgMCxyLGwscCl9fSk7dmFyIEtkLGFoLHNoLGpkLFlkPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7ZHQoKTthZSgpO0tkPShlLHQscixuLG8saSxhLGQpPT57bGV0IGw9bWUoaSkscD1sPT09MT9cImYzMlwiOmB2ZWMke2x9ZmAsbT1sPT09MT9cInZlYzJmXCI6YG1hdDJ4JHtsfWZgLHU9byphLGg9NjQ7dT09PTEmJihoPTI1Nik7bGV0IF89W28sYSxpL2xdLHk9W28sYSwyXSxnPVtcInJhbmtcIixcInR5cGVcIixcInR5cGVcIl0seD1bXTt4LnB1c2goLi4uTihfLHkpKTtsZXQgJD12PT57bGV0IFM9RShcInhcIix0LmRhdGFUeXBlLDMsbCksVD1FKFwic2NhbGVcIixyLmRhdGFUeXBlLHIuZGltcyksQT1FKFwiYmlhc1wiLG4uZGF0YVR5cGUsbi5kaW1zKSxrPU0oXCJvdXRwdXRcIiwxLDMsMiksUD1bUyxULEEsa107cmV0dXJuYFxuICB2YXI8d29ya2dyb3VwPiB3b3JrZ3JvdXBfc2hhcmVkIDogYXJyYXk8JHttfSwgJHtofT47XG4gIGNvbnN0IHdvcmtncm91cF9zaXplID0gJHtofXU7XG4gICR7di5kZWNsYXJlVmFyaWFibGVzKC4uLlApfVxuICAke3YubWFpblN0YXJ0KGgpfVxuICAgIGxldCBiYXRjaCA9IHdvcmtncm91cF9pbmRleCAvIHVuaWZvcm1zLnhfc2hhcGVbMV07XG4gICAgbGV0IGNoYW5uZWwgPSB3b3JrZ3JvdXBfaW5kZXggJSB1bmlmb3Jtcy54X3NoYXBlWzFdO1xuICAgIGxldCBoaWdodCA9IHVuaWZvcm1zLnhfc2hhcGVbMl07XG4gICAgLy8gaW5pdGlhbGl6ZSB3b3JrZ3JvdXAgbWVtb3J5XG4gICAgdmFyIHN1bSA9ICR7cH0oMCk7XG4gICAgdmFyIHNxdWFyZWRfc3VtID0gJHtwfSgwKTtcbiAgICBmb3IgKHZhciBoID0gbG9jYWxfaWR4OyBoIDwgaGlnaHQ7IGggKz0gd29ya2dyb3VwX3NpemUpIHtcbiAgICAgIGxldCB2YWx1ZSA9ICR7cH0oJHtTLmdldChcImJhdGNoXCIsXCJjaGFubmVsXCIsXCJoXCIpfSk7XG4gICAgICBzdW0gKz0gdmFsdWU7XG4gICAgICBzcXVhcmVkX3N1bSArPSB2YWx1ZSAqIHZhbHVlO1xuICAgIH1cbiAgICB3b3JrZ3JvdXBfc2hhcmVkW2xvY2FsX2lkeF0gPSAke219KHN1bSwgc3F1YXJlZF9zdW0pO1xuICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgIGZvciAodmFyIGN1cnJTaXplID0gd29ya2dyb3VwX3NpemUgPj4gMTsgIGN1cnJTaXplID4gMDsgY3VyclNpemUgPSBjdXJyU2l6ZSA+PiAxKSB7XG4gICAgICBpZiAobG9jYWxfaWR4IDwgY3VyclNpemUpIHtcbiAgICAgICAgd29ya2dyb3VwX3NoYXJlZFtsb2NhbF9pZHhdID0gd29ya2dyb3VwX3NoYXJlZFtsb2NhbF9pZHhdICsgd29ya2dyb3VwX3NoYXJlZFtsb2NhbF9pZHggKyBjdXJyU2l6ZV07XG4gICAgICB9XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgfVxuICAgIGlmIChsb2NhbF9pZHggPT0gMCkge1xuICAgICAgbGV0IHN1bV9maW5hbCA9ICR7RmUoXCJ3b3JrZ3JvdXBfc2hhcmVkWzBdWzBdXCIsbCl9IC8gZjMyKGhpZ2h0ICogJHtsfSk7XG4gICAgICBsZXQgc3F1YXJlZF9zdW1fZmluYWwgPSAke0ZlKFwid29ya2dyb3VwX3NoYXJlZFswXVsxXVwiLGwpfSAvIGYzMihoaWdodCAqICR7bH0pO1xuXG4gICAgICBsZXQgaW52X3N0ZF9kZXYgPSBpbnZlcnNlU3FydChzcXVhcmVkX3N1bV9maW5hbCAtIHN1bV9maW5hbCAqIHN1bV9maW5hbCArIGYzMigke2R9KSk7XG4gICAgICBsZXQgY2hhbm5lbF9zY2FsZSA9IGludl9zdGRfZGV2ICogZjMyKHNjYWxlW2NoYW5uZWxdKTtcbiAgICAgIGxldCBjaGFubmVsX3NoaWZ0ID0gZjMyKGJpYXNbY2hhbm5lbF0pIC0gc3VtX2ZpbmFsICogY2hhbm5lbF9zY2FsZTtcbiAgICAgIG91dHB1dFt3b3JrZ3JvdXBfaW5kZXhdID0gdmVjMmYoY2hhbm5lbF9zY2FsZSwgY2hhbm5lbF9zaGlmdCk7XG4gICAgfVxuICB9YH07cmV0dXJuIGUuY29tcHV0ZSh7bmFtZTpcIkluc3RhbmNlTm9ybUNvbXB1dGVDaGFubmVsU2NhbGVTaGlmdFwiLHNoYWRlckNhY2hlOntoaW50OmAke2x9OyR7ZH07JHtofWAsaW5wdXREZXBlbmRlbmNpZXM6Z30sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczp5LGRhdGFUeXBlOjF9XSxkaXNwYXRjaEdyb3VwOnt4OnV9LHByb2dyYW1Vbmlmb3Jtczp4fSksZ2V0U2hhZGVyU291cmNlOiR9LHtpbnB1dHM6W3QscixuXSxvdXRwdXRzOlstMV19KVswXX0sYWg9KGUsdCxyKT0+e2xldCBuPXRbMF0uZGltcyxvPW4saT0yLGE9blswXSxkPW5bMV0sbD1DLnNpemVGcm9tRGltZW5zaW9uKG4saSkscD1tZShsKSxtPUMuc2l6ZShvKS9wLHU9S2QoZSx0WzBdLHRbMV0sdFsyXSxhLGwsZCxyLmVwc2lsb24pLGg9W2EsZCxsL3BdLF89W2EsZF0seT1bXCJ0eXBlXCIsXCJub25lXCJdLGc9eD0+e2xldCAkPUUoXCJ4XCIsdFswXS5kYXRhVHlwZSxoLmxlbmd0aCxwKSx2PUUoXCJzY2FsZV9zaGlmdFwiLDEsXy5sZW5ndGgsMiksUz1NKFwib3V0cHV0XCIsdFswXS5kYXRhVHlwZSxoLmxlbmd0aCxwKSxUPVskLHYsU107cmV0dXJuYFxuICAke3gucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0X3NpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKC4uLlQpfVxuICAke3gubWFpblN0YXJ0KCl9XG4gICR7eC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7Uy5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgIGxldCBiYXRjaCA9IG91dHB1dEluZGljZXNbMF07XG4gICAgICBsZXQgY2hhbm5lbCA9IG91dHB1dEluZGljZXNbMV07XG4gICAgICBsZXQgc2NhbGVfc2hpZnQgPSAke3YuZ2V0QnlJbmRpY2VzKFwidmVjMjx1MzI+KGJhdGNoLCBjaGFubmVsKVwiKX07XG4gICAgICBsZXQgdmFsdWUgPSAkeyQuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpfSAqICR7Uy50eXBlLnZhbHVlfShzY2FsZV9zaGlmdC54KSArICR7Uy50eXBlLnZhbHVlfShzY2FsZV9zaGlmdC55KTtcbiAgICAgICR7Uy5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlXCIpfTtcbiAgfWB9O2UuY29tcHV0ZSh7bmFtZTpcIkluc3RhbmNlTm9ybWFsaXphdGlvblwiLHNoYWRlckNhY2hlOntoaW50OmAke3B9YCxpbnB1dERlcGVuZGVuY2llczp5fSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm8sZGF0YVR5cGU6dFswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKG0vNjQpfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjEyLGRhdGE6bX0sLi4uTihoLF8saCldfSksZ2V0U2hhZGVyU291cmNlOmd9LHtpbnB1dHM6W3RbMF0sdV19KX0sc2g9KGUsdCxyKT0+e2xldCBuPXRbMF0uZGltcyxvPW4saT1uWzBdLGE9bltuLmxlbmd0aC0xXSxkPUMuc2l6ZUZyb21EaW1lbnNpb24obiwxKS9hLGw9bWUoYSkscD1DLnNpemUobykvbCxtPVt7dHlwZToxMixkYXRhOmR9LHt0eXBlOjEyLGRhdGE6TWF0aC5mbG9vcihhL2wpfV0sdT1bXCJ0eXBlXCIsXCJ0eXBlXCJdLGg9ITEsXz1bMCxuLmxlbmd0aC0xXTtmb3IobGV0ICQ9MDskPG4ubGVuZ3RoLTI7JCsrKWg9aHx8blskKzFdIT09MSxfLnB1c2goJCsxKTtoPWgmJm5bbi5sZW5ndGgtMV0hPT0xO2xldCB5PWg/ZS5jb21wdXRlKFBlKGUuaW5wdXRzWzBdLF8pLHtpbnB1dHM6W2UuaW5wdXRzWzBdXSxvdXRwdXRzOlstMV19KVswXTplLmlucHV0c1swXS5yZXNoYXBlKEFycmF5LmZyb20oe2xlbmd0aDpuLmxlbmd0aH0sKCQsdik9Pm5bX1t2XV0pKSxnPUtkKGUseSx0WzFdLHRbMl0saSxkLGEsci5lcHNpbG9uKSx4PSQ9PntsZXQgdj1fZSh0WzBdLmRhdGFUeXBlKSxTPWw9PT0xP1widmVjMmZcIjpgbWF0JHtsfXgyZmAsVD1QPT57bGV0IEQ9UD09PTA/XCJ4XCI6XCJ5XCIsUj1sPT09MT9cImYzMlwiOmB2ZWMke2x9ZmA7c3dpdGNoKGwpe2Nhc2UgMTpyZXR1cm5gJHt2fSgke1J9KHNjYWxlLiR7RH0pKWA7Y2FzZSAyOnJldHVybmB2ZWMyPCR7dn0+KCR7Un0oc2NhbGVbMF0uJHtEfSwgc2NhbGVbMV0uJHtEfSkpYDtjYXNlIDQ6cmV0dXJuYHZlYzQ8JHt2fT4oJHtSfShzY2FsZVswXS4ke0R9LCBzY2FsZVsxXS4ke0R9LCBzY2FsZVsyXS4ke0R9LCBzY2FsZVszXS4ke0R9KSlgO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBOb3Qgc3VwcG9ydGVkIGNvbXBvZW50cyAke2x9YCl9fSxBPUUoXCJpbnB1dFwiLHRbMF0uZGF0YVR5cGUsdFswXS5kaW1zLGwpLGs9TShcIm91dHB1dFwiLHRbMF0uZGF0YVR5cGUsbyxsKTtyZXR1cm5gXG4gIEBncm91cCgwKSBAYmluZGluZygwKSB2YXI8c3RvcmFnZSwgcmVhZD4gaW5wdXQgOiBhcnJheTwke0EudHlwZS5zdG9yYWdlfT47XG4gIEBncm91cCgwKSBAYmluZGluZygxKSB2YXI8c3RvcmFnZSwgcmVhZD4gc2NhbGVfaW5wdXQgOiBhcnJheTwke1N9PjtcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiBvdXRwdXQgOiBhcnJheTwke2sudHlwZS5zdG9yYWdlfT47XG4gIHN0cnVjdCBVbmlmb3JtcyB7SDogdTMyLCBDIDogdTMyfTtcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDMpIHZhcjx1bmlmb3JtPiB1bmlmb3JtczogVW5pZm9ybXM7XG5cbiAgJHskLm1haW5TdGFydCgpfVxuICAgIGxldCBjdXJyZW50X2ltYWdlX251bWJlciA9IGdsb2JhbF9pZHggLyAodW5pZm9ybXMuQyAqIHVuaWZvcm1zLkgpO1xuICAgIGxldCBjdXJyZW50X2NoYW5uZWxfbnVtYmVyID0gZ2xvYmFsX2lkeCAlIHVuaWZvcm1zLkM7XG5cbiAgICBsZXQgc2NhbGVfb2Zmc2V0ID0gY3VycmVudF9pbWFnZV9udW1iZXIgKiB1bmlmb3Jtcy5DICsgY3VycmVudF9jaGFubmVsX251bWJlcjtcbiAgICBsZXQgc2NhbGUgPSBzY2FsZV9pbnB1dFtzY2FsZV9vZmZzZXRdO1xuICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IGZtYShpbnB1dFtnbG9iYWxfaWR4XSwgJHtUKDApfSwgJHtUKDEpfSk7XG4gIH1gfTtlLmNvbXB1dGUoe25hbWU6XCJJbnN0YW5jZU5vcm1hbGl6YXRpb25OSFdDXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7bH1gLGlucHV0RGVwZW5kZW5jaWVzOnV9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6byxkYXRhVHlwZTp0WzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwocC82NCl9LHByb2dyYW1Vbmlmb3JtczptfSksZ2V0U2hhZGVyU291cmNlOnh9LHtpbnB1dHM6W3RbMF0sZ119KX0samQ9KGUsdCk9Pnt0LmZvcm1hdD09PVwiTkhXQ1wiP3NoKGUsZS5pbnB1dHMsdCk6YWgoZSxlLmlucHV0cyx0KX19KTt2YXIgdWgsZGgsWmQsUWQ9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTthZSgpO3VoPWU9PntpZighZXx8ZS5sZW5ndGg8Mil0aHJvdyBuZXcgRXJyb3IoXCJsYXllck5vcm0gcmVxdWlyZXMgYXQgbGVhc3QgMiBpbnB1dHMuXCIpfSxkaD0oZSx0LHIpPT57bGV0IG49dC5zaW1wbGlmaWVkLG89ZVswXS5kaW1zLGk9ZVsxXSxhPSFuJiZlWzJdLGQ9byxsPUMubm9ybWFsaXplQXhpcyh0LmF4aXMsby5sZW5ndGgpLHA9Qy5zaXplVG9EaW1lbnNpb24obyxsKSxtPUMuc2l6ZUZyb21EaW1lbnNpb24obyxsKSx1PUMuc2l6ZShpLmRpbXMpLGg9YT9DLnNpemUoYS5kaW1zKTowO2lmKHUhPT1tfHxhJiZoIT09bSl0aHJvdyBuZXcgRXJyb3IoYFNpemUgb2YgWC5zaGFwZSgpW2F4aXM6XSA9PSAke219LlxuICAgICAgIFNpemUgb2Ygc2NhbGUgYW5kIGJpYXMgKGlmIHByb3ZpZGVkKSBtdXN0IG1hdGNoIHRoaXMuXG4gICAgICAgR290IHNjYWxlIHNpemUgb2YgJHt1fSBhbmQgYmlhcyBzaXplIG9mICR7aH1gKTtsZXQgXz1bXTtmb3IobGV0IEE9MDtBPG8ubGVuZ3RoOysrQSlBPGw/Xy5wdXNoKG9bQV0pOl8ucHVzaCgxKTtsZXQgeT1tZShtKSxnPVtcInR5cGVcIixcInR5cGVcIl0seD1be3R5cGU6MTIsZGF0YTpwfSx7dHlwZToxLGRhdGE6bX0se3R5cGU6MTIsZGF0YTpNYXRoLmZsb29yKG0veSl9LHt0eXBlOjEsZGF0YTp0LmVwc2lsb259XTthJiZnLnB1c2goXCJ0eXBlXCIpO2xldCAkPXI+MSx2PXI+MixTPUE9PntsZXQgaz1fZShlWzBdLmRhdGFUeXBlKSxQPVtFKFwieFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLHkpLEUoXCJzY2FsZVwiLGkuZGF0YVR5cGUsaS5kaW1zLHkpXTthJiZQLnB1c2goRShcImJpYXNcIixhLmRhdGFUeXBlLGEuZGltcyx5KSksUC5wdXNoKE0oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLGQseSkpLCQmJlAucHVzaChNKFwibWVhbl9kYXRhX291dHB1dFwiLDEsXykpLHYmJlAucHVzaChNKFwiaW52X3N0ZF9vdXRwdXRcIiwxLF8pKTtsZXQgRD1be25hbWU6XCJub3JtX2NvdW50XCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIm5vcm1fc2l6ZVwiLHR5cGU6XCJmMzJcIn0se25hbWU6XCJub3JtX3NpemVfdmVjdG9yaXplZFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJlcHNpbG9uXCIsdHlwZTpcImYzMlwifV07cmV0dXJuYFxuICAke0EucmVnaXN0ZXJVbmlmb3JtcyhEKS5kZWNsYXJlVmFyaWFibGVzKC4uLlApfVxuICAke0EubWFpblN0YXJ0KCl9XG4gICAgJHtBLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5ub3JtX2NvdW50XCIpfVxuICAgIGxldCBvZmZzZXQgPSBnbG9iYWxfaWR4ICogdW5pZm9ybXMubm9ybV9zaXplX3ZlY3Rvcml6ZWQ7XG4gICAgdmFyIG1lYW5fdmVjdG9yID0gJHt1byhcImYzMlwiLHkpfTtcbiAgICB2YXIgbWVhbl9zcXVhcmVfdmVjdG9yID0gJHt1byhcImYzMlwiLHkpfTtcblxuICAgIGZvciAodmFyIGg6IHUzMiA9IDB1OyBoIDwgdW5pZm9ybXMubm9ybV9zaXplX3ZlY3Rvcml6ZWQ7IGgrKykge1xuICAgICAgbGV0IHZhbHVlID0gJHtFdChrLHksXCJ4W2ggKyBvZmZzZXRdXCIpfTtcbiAgICAgIG1lYW5fdmVjdG9yICs9IHZhbHVlO1xuICAgICAgbWVhbl9zcXVhcmVfdmVjdG9yICs9IHZhbHVlICogdmFsdWU7XG4gICAgfVxuICAgIGxldCBtZWFuID0gJHtGZShcIm1lYW5fdmVjdG9yXCIseSl9IC8gdW5pZm9ybXMubm9ybV9zaXplO1xuICAgIGxldCBpbnZfc3RkX2RldiA9IGludmVyc2VTcXJ0KCR7RmUoXCJtZWFuX3NxdWFyZV92ZWN0b3JcIix5KX0gLyB1bmlmb3Jtcy5ub3JtX3NpemUgJHtuP1wiXCI6XCItIG1lYW4gKiBtZWFuXCJ9ICsgdW5pZm9ybXMuZXBzaWxvbik7XG5cbiAgICBmb3IgKHZhciBqOiB1MzIgPSAwOyBqIDwgdW5pZm9ybXMubm9ybV9zaXplX3ZlY3Rvcml6ZWQ7IGorKykge1xuICAgICAgbGV0IGYzMmlucHV0ID0gJHtFdChrLHksXCJ4W2ogKyBvZmZzZXRdXCIpfTtcbiAgICAgIGxldCBmMzJzY2FsZSA9ICR7RXQoayx5LFwic2NhbGVbal1cIil9O1xuICAgICAgb3V0cHV0W2ogKyBvZmZzZXRdID0gJHtQWzBdLnR5cGUudmFsdWV9KChmMzJpbnB1dCAke24/XCJcIjpcIi0gbWVhblwifSkgKiBpbnZfc3RkX2RldiAqIGYzMnNjYWxlXG4gICAgICAgICR7YT9gKyAke0V0KGsseSxcImJpYXNbal1cIil9YDpcIlwifVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAkeyQ/XCJtZWFuX2RhdGFfb3V0cHV0W2dsb2JhbF9pZHhdID0gbWVhblwiOlwiXCJ9O1xuICAgICR7dj9cImludl9zdGRfb3V0cHV0W2dsb2JhbF9pZHhdID0gaW52X3N0ZF9kZXZcIjpcIlwifTtcbiAgfWB9LFQ9W3tkaW1zOmQsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dO3JldHVybiAkJiZULnB1c2goe2RpbXM6XyxkYXRhVHlwZToxfSksdiYmVC5wdXNoKHtkaW1zOl8sZGF0YVR5cGU6MX0pLHtuYW1lOlwiTGF5ZXJOb3JtYWxpemF0aW9uXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7eX07JHtyfTske259YCxpbnB1dERlcGVuZGVuY2llczpnfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6VCxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChwLzY0KX0scHJvZ3JhbVVuaWZvcm1zOnh9KSxnZXRTaGFkZXJTb3VyY2U6U319LFpkPShlLHQpPT57dWgoZS5pbnB1dHMpLGUuY29tcHV0ZShkaChlLmlucHV0cyx0LGUub3V0cHV0Q291bnQpKX19KTt2YXIgbGgsWGQsSmQ9VSgoKT0+e1widXNlIHN0cmljdFwiO29lKCk7UXIoKTtYcigpO2xoPWU9PntpZighZXx8ZS5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIk1hdE11bCByZXF1aXJlcyAyIGlucHV0cy5cIik7aWYoZVswXS5kaW1zW2VbMF0uZGltcy5sZW5ndGgtMV0hPT1lWzFdLmRpbXNbZVsxXS5kaW1zLmxlbmd0aC0yXSl0aHJvdyBuZXcgRXJyb3IoXCJzaGFyZWQgZGltZW5zaW9uIGRvZXMgbm90IG1hdGNoLlwiKX0sWGQ9ZT0+e2xoKGUuaW5wdXRzKTtsZXQgdD10dC5jYWxjU2hhcGUoZS5pbnB1dHNbMF0uZGltcyxlLmlucHV0c1sxXS5kaW1zLCEwKTtpZighdCl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCB1c2UgbWF0bXVsIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO2xldCByPXRbdC5sZW5ndGgtMV0sbj1lLmlucHV0c1swXS5kaW1zW2UuaW5wdXRzWzBdLmRpbXMubGVuZ3RoLTFdO2lmKHI8OCYmbjw4KWUuY29tcHV0ZShacihlLmlucHV0cyx7YWN0aXZhdGlvbjpcIlwifSx0KSk7ZWxzZXtsZXQgbz10W3QubGVuZ3RoLTJdLGk9Qy5zaXplKGUuaW5wdXRzWzBdLmRpbXMuc2xpY2UoMCwtMikpLGE9Qy5zaXplKGUuaW5wdXRzWzFdLmRpbXMuc2xpY2UoMCwtMikpO2lmKGkhPT0xJiZvPT09MSYmYT09PTEpe2xldCBkPWUuaW5wdXRzWzBdLnJlc2hhcGUoWzEsaSxuXSksbD1lLmlucHV0c1sxXS5yZXNoYXBlKFsxLG4scl0pLHA9WzEsaSxyXSxtPVtkLGxdO2UuY29tcHV0ZShlcihtLHthY3RpdmF0aW9uOlwiXCJ9LHQscCkse2lucHV0czptfSl9ZWxzZSBlLmNvbXB1dGUoZXIoZS5pbnB1dHMse2FjdGl2YXRpb246XCJcIn0sdCkpfX19KTt2YXIgY2gscGgsbWgsZWwsdGwscmw9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTtTZSgpO2FlKCk7Y2g9KGUsdCk9PntpZihlLmxlbmd0aDwzfHxlLmxlbmd0aD40KXRocm93IG5ldyBFcnJvcihcIk1hdE11bE5CaXRzIHJlcXVpcmVzIDMgb3IgNCBpbnB1dHNcIik7bGV0IHI9ZVswXSxuPXIuZGltcy5sZW5ndGg7aWYoci5kaW1zW24tMV0hPT10LmspdGhyb3cgbmV3IEVycm9yKFwiVGhlIGxhc3QgZGltIG9mIGlucHV0IHNoYXBlIGRvZXMgbm90IG1hdGNoIHRoZSBrIHZhbHVlXCIpO2xldCBvPU1hdGguZmxvb3IoKHQuayt0LmJsb2NrU2l6ZS0xKS90LmJsb2NrU2l6ZSksaT10LmJsb2NrU2l6ZS84KnQuYml0cyxhPWVbMV07aWYoIUMuYXJlRXF1YWwoYS5kaW1zLFt0Lm4sbyxpXSkpdGhyb3cgbmV3IEVycm9yKFwiVGhlIHNlY29uZCBpbnB1dHMgbXVzdCBiZSAzRCB0ZW5zb3Igd2l0aCBzaGFwZSBOIFggbkJsb2Nrc1BlckNvbCBYIGJsb2JTaXplXCIpO2xldCBsPWVbMl0uZGltcztpZihDLnNpemUobCkhPT10Lm4qbyl0aHJvdyBuZXcgRXJyb3IoXCJzY2FsZXMgaW5wdXQgc2l6ZSBlcnJvci5cIik7aWYoZS5sZW5ndGg9PT00KXtsZXQgbT1lWzNdLmRpbXMsdT10LmJpdHM+ND90Lm4qbzp0Lm4qTWF0aC5mbG9vcigobysxKS8yKTtpZihDLnNpemUobSkhPT11KXRocm93IG5ldyBFcnJvcihcInplcm9Qb2ludHMgaW5wdXQgc2l6ZSBlcnJvci5cIil9fSxwaD0oZSx0KT0+e2xldCByPWVbMF0uZGltcyxuPXIubGVuZ3RoLG89cltuLTJdLGk9dC5rLGE9dC5uLGQ9ci5zbGljZSgwLG4tMiksbD1DLnNpemUoZCksbT1lWzFdLmRpbXNbMl0vNCx1PWVbMF0uZGF0YVR5cGUsaD1tZSh0LmspLF89bWUobSkseT1tZShhKSxnPWQuY29uY2F0KFtvLGFdKSx4PW8+MSYmYS95JTI9PT0wPzI6MSwkPUMuc2l6ZShnKS95L3gsdj02NCxTPVtdLFQ9W2wsbyxpL2hdLEE9Qy5jb252ZXJ0U2hhcGUoZVsxXS5kaW1zKS5zbGljZSgpO0Euc3BsaWNlKC0xLDEsbS9fKSxTLnB1c2goLi4uTihUKSksUy5wdXNoKC4uLk4oQSkpLFMucHVzaCguLi5OKGVbMl0uZGltcykpLGUubGVuZ3RoPT09NCYmUy5wdXNoKC4uLk4oQy5jb252ZXJ0U2hhcGUoZVszXS5kaW1zKSkpO2xldCBrPVtsLG8sYS95XTtTLnB1c2goLi4uTihrKSk7bGV0IFA9RD0+e2xldCBSPVQubGVuZ3RoLEc9RShcImFcIixlWzBdLmRhdGFUeXBlLFIsaCksSz1FKFwiYlwiLDEyLEEubGVuZ3RoLF8pLGo9RShcInNjYWxlc1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLmxlbmd0aCksVj1bRyxLLGpdLFE9ZS5sZW5ndGg9PT00P0UoXCJ6ZXJvX3BvaW50c1wiLDEyLGVbM10uZGltcy5sZW5ndGgpOnZvaWQgMDtRJiZWLnB1c2goUSk7bGV0IHNlPWsubGVuZ3RoLFk9TShcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsc2UseSksZWU9X2UoZVswXS5kYXRhVHlwZSksSj0oKCk9Pntzd2l0Y2goaCl7Y2FzZSAxOnJldHVybmBhcnJheTwke2VlfSwgOD5gO2Nhc2UgMjpyZXR1cm5gbWF0NHgyPCR7ZWV9PmA7Y2FzZSA0OnJldHVybmBtYXQyeDQ8JHtlZX0+YDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgJHtofS1jb21wb25lbnQgaXMgbm90IHN1cHBvcnRlZC5gKX19KSgpLG5lPSgpPT57bGV0ICRlPWBcbiAgICAgICAgICAvLyByZXVzZSBhIGRhdGFcbiAgICAgICAgICAgIHZhciBpbnB1dF9vZmZzZXQgPSAke0cuaW5kaWNlc1RvT2Zmc2V0KGAke0cudHlwZS5pbmRpY2VzfShiYXRjaCwgcm93LCB3b3JkX29mZnNldClgKX07XG4gICAgICAgICAgICB2YXIgYV9kYXRhOiAke0p9O1xuICAgICAgICAgICAgZm9yICh2YXIgajogdTMyID0gMDsgaiA8ICR7OC9ofTsgaisrKSB7XG4gICAgICAgICAgICAgIGFfZGF0YVtqXSA9ICR7Ry5nZXRCeU9mZnNldChcImlucHV0X29mZnNldFwiKX07XG4gICAgICAgICAgICAgIGlucHV0X29mZnNldCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGA7Zm9yKGxldCBsZT0wO2xlPHkqeDtsZSsrKSRlKz1gXG4gICAgICAgICAgICBiX3ZhbHVlID0gJHtfPT09MT9gYiR7bGV9X2RhdGFgOmBiJHtsZX1fZGF0YVtpXWB9O1xuICAgICAgICAgICAgYl92YWx1ZV9sb3dlciA9IHVucGFjazR4VTgoYl92YWx1ZSAmIGJfbWFzayk7XG4gICAgICAgICAgICBiX3ZhbHVlX3VwcGVyID0gdW5wYWNrNHhVOCgoYl92YWx1ZSA+PiA0KSAmIGJfbWFzayk7XG4gICAgICAgICAgICBiX3F1YW50aXplZF92YWx1ZXMgPSAke0p9KCR7QXJyYXkuZnJvbSh7bGVuZ3RoOjR9LChXLHEpPT5gJHtlZX0oYl92YWx1ZV9sb3dlclske3F9XSksICR7ZWV9KGJfdmFsdWVfdXBwZXJbJHtxfV0pYCkuam9pbihcIiwgXCIpfSk7XG4gICAgICAgICAgICBiX2RlcXVhbnRpemVkX3ZhbHVlcyA9ICR7KCgpPT5oPT09MT9gJHtKfSgke0FycmF5LmZyb20oe2xlbmd0aDo4fSwoVyxxKT0+YChiX3F1YW50aXplZF92YWx1ZXNbJHtxfV0gLSAke1E/YHplcm9fcG9pbnQke2xlfWA6XCJ6ZXJvX3BvaW50XCJ9KSAqIHNjYWxlJHtsZX1gKS5qb2luKFwiLCBcIil9KTtgOmAoYl9xdWFudGl6ZWRfdmFsdWVzIC0gJHtKfSgke0FycmF5KDgpLmZpbGwoYCR7UT9gemVyb19wb2ludCR7bGV9YDpcInplcm9fcG9pbnRcIn1gKS5qb2luKFwiLFwiKX0pKSAqIHNjYWxlJHtsZX07YCkoKX07XG4gICAgICAgICAgICB3b3JrZ3JvdXBfc2hhcmVkW2xvY2FsX2lkLnggKiAke3h9ICsgJHtNYXRoLmZsb29yKGxlL3kpfV0ke3k+MT9gWyR7bGUleX1dYDpcIlwifSArPSAke0FycmF5LmZyb20oe2xlbmd0aDo4L2h9LChXLHEpPT5gJHtoPT09MT9gYV9kYXRhWyR7cX1dICogYl9kZXF1YW50aXplZF92YWx1ZXNbJHtxfV1gOmBkb3QoYV9kYXRhWyR7cX1dLCBiX2RlcXVhbnRpemVkX3ZhbHVlc1ske3F9XSlgfWApLmpvaW4oXCIgKyBcIil9O1xuICAgICAgICAgIGA7cmV0dXJuICRlfSxiZT0oKT0+e2xldCAkZT1gXG4gICAgICAgICAgICB2YXIgY29sX2luZGV4ID0gY29sICogJHt5fTtcbiAgICAgICAgICAgICR7UT9gXG4gICAgICAgICAgICBsZXQgemVyb19wb2ludF9ieXRlc19wZXJfY29sID0gKG5CbG9ja3NQZXJDb2wgKyAxKSAvIDI7XG4gICAgICAgICAgICB2YXIgemVyb19wb2ludF9ieXRlX2NvdW50OiB1MzI7XG4gICAgICAgICAgICB2YXIgemVyb19wb2ludF93b3JkX2luZGV4OiB1MzI7XG4gICAgICAgICAgICB2YXIgemVyb19wb2ludF9ieXRlX29mZnNldDogdTMyO1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfbmliYmxlX29mZnNldDogdTMyID0gYmxvY2sgJiAweDF1O1xuICAgICAgICAgICAgdmFyIHplcm9fcG9pbnRfYml0c19vZmZzZXQ6IHUzMjtcbiAgICAgICAgICAgIHZhciB6ZXJvX3BvaW50X3dvcmQ6IHUzMjtgOmBcbiAgICAgICAgICAgIC8vIFRoZSBkZWZhdWx0IHplcm8gcG9pbnQgaXMgOCBmb3IgdW5zaWduZWQgNC1iaXQgcXVhbnRpemF0aW9uLlxuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnQgPSAke2VlfSg4KTtgfVxuICAgICAgICAgICAgYDtmb3IobGV0IGxlPTA7bGU8eSp4O2xlKyspJGUrPWBcbiAgICAgICAgICAgIGxldCBzY2FsZSR7bGV9ID0gJHtqLmdldEJ5T2Zmc2V0KFwiY29sX2luZGV4ICogbkJsb2Nrc1BlckNvbCArIGJsb2NrXCIpfTtcbiAgICAgICAgICAgICR7UT9gXG4gICAgICAgICAgICB6ZXJvX3BvaW50X2J5dGVfY291bnQgPSBjb2xfaW5kZXggKiB6ZXJvX3BvaW50X2J5dGVzX3Blcl9jb2wgKyAoYmxvY2sgPj4gMHgxdSk7XG4gICAgICAgICAgICB6ZXJvX3BvaW50X3dvcmRfaW5kZXggPSB6ZXJvX3BvaW50X2J5dGVfY291bnQgPj4gMHgydTtcbiAgICAgICAgICAgIHplcm9fcG9pbnRfYnl0ZV9vZmZzZXQgPSB6ZXJvX3BvaW50X2J5dGVfY291bnQgJiAweDN1O1xuICAgICAgICAgICAgemVyb19wb2ludF9iaXRzX29mZnNldCA9ICh6ZXJvX3BvaW50X2J5dGVfb2Zmc2V0IDw8IDMpICsgKHplcm9fcG9pbnRfbmliYmxlX29mZnNldCA8PCAyKTtcbiAgICAgICAgICAgIHplcm9fcG9pbnRfd29yZCA9ICR7US5nZXRCeU9mZnNldChcInplcm9fcG9pbnRfd29yZF9pbmRleFwiKX0gPj4gemVyb19wb2ludF9iaXRzX29mZnNldDtcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50JHtsZX0gPSAke2VlfSgoemVyb19wb2ludF93b3JkKSAmIDB4RnUpO2A6XCJcIn1cbiAgICAgICAgICAgIGNvbF9pbmRleCArPSAxO2A7cmV0dXJuICRlfSxPZT0oKT0+e2xldCAkZT1gY29sX2luZGV4ID0gY29sICogJHt5fTtgO2ZvcihsZXQgbGU9MDtsZTx5Kng7bGUrKykkZSs9YFxuICAgICAgICAgICAgbGV0IGIke2xlfV9kYXRhID0gJHtLLmdldEJ5SW5kaWNlcyhgJHtLLnR5cGUuaW5kaWNlc30oY29sX2luZGV4LCBibG9jaywgd29yZClgKX07XG4gICAgICAgICAgICBjb2xfaW5kZXggKz0gMTtgO3JldHVybiAkZSs9YFxuICAgICAgICAgICAgdmFyIGJfdmFsdWU6IHUzMjtcbiAgICAgICAgICAgIGxldCBiX21hc2s6IHUzMiA9IDB4MEYwRjBGMEZ1O1xuICAgICAgICAgICAgdmFyIGJfdmFsdWVfbG93ZXI6IHZlYzQ8dTMyPjtcbiAgICAgICAgICAgIHZhciBiX3ZhbHVlX3VwcGVyOiB2ZWM0PHUzMj47XG4gICAgICAgICAgICB2YXIgYl9xdWFudGl6ZWRfdmFsdWVzOiAke0p9O1xuICAgICAgICAgICAgdmFyIGJfZGVxdWFudGl6ZWRfdmFsdWVzOiAke0p9O2AsJGV9O3JldHVybmBcbiAgICAgICAgdmFyPHdvcmtncm91cD4gd29ya2dyb3VwX3NoYXJlZDogYXJyYXk8JHtZLnR5cGUudmFsdWV9LCAke3gqdn0+O1xuICAgICAgICAke0QuZGVjbGFyZVZhcmlhYmxlcyguLi5WLFkpfVxuICAgICAgICAke0QubWFpblN0YXJ0KFt2LDEsMV0pfVxuICAgICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7WS5vZmZzZXRUb0luZGljZXMoYChnbG9iYWxfaWR4IC8gJHt2fSkgKiAke3h9YCl9O1xuICAgICAgICAgIGxldCBjb2wgPSBvdXRwdXRfaW5kaWNlc1syXTtcbiAgICAgICAgICBsZXQgcm93ID0gb3V0cHV0X2luZGljZXNbMV07XG4gICAgICAgICAgbGV0IGJhdGNoID0gb3V0cHV0X2luZGljZXNbMF07XG4gICAgICAgICAgbGV0IG5CbG9ja3NQZXJDb2wgPSB1bmlmb3Jtcy5iX3NoYXBlWzFdO1xuXG4gICAgICAgICAgZm9yICh2YXIgYmxvY2sgPSBsb2NhbF9pZC54OyBibG9jayA8IG5CbG9ja3NQZXJDb2w7IGJsb2NrICs9ICR7dn0pIHtcbiAgICAgICAgICAgIC8vcHJvY2VzcyBvbmUgYmxvY2tcbiAgICAgICAgICAgIHZhciB3b3JkX29mZnNldDogdTMyID0gYmxvY2sgKiAke3QuYmxvY2tTaXplL2h9O1xuICAgICAgICAgICAgJHtiZSgpfVxuICAgICAgICAgICAgZm9yICh2YXIgd29yZDogdTMyID0gMDsgd29yZCA8ICR7bX07IHdvcmQgKz0gJHtffSkge1xuICAgICAgICAgICAgICAke09lKCl9XG4gICAgICAgICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCAke199OyBpKyspIHtcbiAgICAgICAgICAgICAgICAke25lKCl9XG4gICAgICAgICAgICAgICAgd29yZF9vZmZzZXQgKz0gJHs4L2h9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICAgIGlmIChsb2NhbF9pZC54IDwgJHt4fSkge1xuICAgICAgICAgICAgdmFyIG91dHB1dF92YWx1ZTogJHtZLnR5cGUudmFsdWV9ID0gJHtZLnR5cGUudmFsdWV9KDApO1xuICAgICAgICAgICAgdmFyIHdvcmtncm91cF9zaGFyZWRfb2Zmc2V0OiB1MzIgPSBsb2NhbF9pZC54O1xuICAgICAgICAgICAgZm9yICh2YXIgYjogdTMyID0gMHU7IGIgPCAke3Z9dTsgYisrKSB7XG4gICAgICAgICAgICAgIG91dHB1dF92YWx1ZSArPSB3b3JrZ3JvdXBfc2hhcmVkW3dvcmtncm91cF9zaGFyZWRfb2Zmc2V0XTtcbiAgICAgICAgICAgICAgd29ya2dyb3VwX3NoYXJlZF9vZmZzZXQgKz0gJHt4fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICR7WS5zZXRCeUluZGljZXMoYCR7WS50eXBlLmluZGljZXN9KGJhdGNoLCByb3csIGNvbCArIGxvY2FsX2lkLngpYCxcIm91dHB1dF92YWx1ZVwiKX07XG4gICAgICAgICAgfVxuICAgICAgICB9YH07cmV0dXJue25hbWU6XCJNYXRNdWxOQml0c1wiLHNoYWRlckNhY2hlOntoaW50OmAke3QuYmxvY2tTaXplfTske3QuYml0c307JHtofTske199OyR7eX07JHt4fTske3Z9YCxpbnB1dERlcGVuZGVuY2llczpBcnJheShlLmxlbmd0aCkuZmlsbChcInJhbmtcIil9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6ZyxkYXRhVHlwZTp1fV0sZGlzcGF0Y2hHcm91cDp7eDokfSxwcm9ncmFtVW5pZm9ybXM6U30pLGdldFNoYWRlclNvdXJjZTpQfX0sbWg9KGUsdCk9PntsZXQgcj1lWzBdLmRpbXMsbj1yLmxlbmd0aCxvPXJbbi0yXSxpPXQuayxhPXQubixkPXIuc2xpY2UoMCxuLTIpLGw9Qy5zaXplKGQpLG09ZVsxXS5kaW1zWzJdLzQsdT1lWzBdLmRhdGFUeXBlLGg9bWUodC5rKSxfPW1lKG0pLHk9ZC5jb25jYXQoW28sYV0pLGc9MTI4LHg9YSU4PT09MD84OmElND09PTA/NDoxLCQ9Zy94LHY9JCpfKjgsUz12L2gsVD12L3QuYmxvY2tTaXplLEE9Qy5zaXplKHkpL3gsaz1bXSxQPVtsLG8saS9oXSxEPUMuY29udmVydFNoYXBlKGVbMV0uZGltcykuc2xpY2UoKTtELnNwbGljZSgtMSwxLG0vXyksay5wdXNoKC4uLk4oUCkpLGsucHVzaCguLi5OKEQpKSxrLnB1c2goLi4uTihlWzJdLmRpbXMpKSxlLmxlbmd0aD09PTQmJmsucHVzaCguLi5OKEMuY29udmVydFNoYXBlKGVbM10uZGltcykpKTtsZXQgUj1bbCxvLGFdO2sucHVzaCguLi5OKFIpKTtsZXQgRz1LPT57bGV0IGo9UC5sZW5ndGgsVj1FKFwiYVwiLGVbMF0uZGF0YVR5cGUsaixoKSxRPUUoXCJiXCIsMTIsRC5sZW5ndGgsXyksc2U9RShcInNjYWxlc1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLmxlbmd0aCksWT1bVixRLHNlXSxlZT1lLmxlbmd0aD09PTQ/RShcInplcm9fcG9pbnRzXCIsMTIsZVszXS5kaW1zLmxlbmd0aCk6dm9pZCAwO2VlJiZZLnB1c2goZWUpO2xldCBKPVIubGVuZ3RoLG5lPU0oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLEopLGJlPV9lKGVbMF0uZGF0YVR5cGUpLE9lPSgpPT57c3dpdGNoKGgpe2Nhc2UgMTpyZXR1cm5gXG4gICAgICAgICAgbGV0IGFfZGF0YTAgPSB2ZWM0PCR7YmV9PihzdWJfYVt3b3JkX29mZnNldF0sIHN1Yl9hW3dvcmRfb2Zmc2V0ICsgMV0sIHN1Yl9hW3dvcmRfb2Zmc2V0ICsgMl0sIHN1Yl9hW3dvcmRfb2Zmc2V0ICsgM10pO1xuICAgICAgICAgIGxldCBhX2RhdGExID0gdmVjNDwke2JlfT4oc3ViX2Fbd29yZF9vZmZzZXQgKyA0XSwgc3ViX2Fbd29yZF9vZmZzZXQgKyA1XSwgc3ViX2Fbd29yZF9vZmZzZXQgKyA2XSwgc3ViX2Fbd29yZF9vZmZzZXQgKyA3XSk7YDtjYXNlIDI6cmV0dXJuYFxuICAgICAgICAgIGxldCBhX2RhdGEwID0gdmVjNDwke2JlfT4oc3ViX2Fbd29yZF9vZmZzZXRdLCBzdWJfYVt3b3JkX29mZnNldCArIDFdKTtcbiAgICAgICAgICBsZXQgYV9kYXRhMSA9IHZlYzQ8JHtiZX0+KHN1Yl9hW3dvcmRfb2Zmc2V0ICsgMl0sIHN1Yl9hW3dvcmRfb2Zmc2V0ICsgM10pO2A7Y2FzZSA0OnJldHVybmBcbiAgICAgICAgICBsZXQgYV9kYXRhMCA9IHN1Yl9hW3dvcmRfb2Zmc2V0XTtcbiAgICAgICAgICBsZXQgYV9kYXRhMSA9IHN1Yl9hW3dvcmRfb2Zmc2V0ICsgMV07YDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgJHtofS1jb21wb25lbnQgaXMgbm90IHN1cHBvcnRlZC5gKX19O3JldHVybmBcbiAgICAgICAgdmFyPHdvcmtncm91cD4gc3ViX2E6IGFycmF5PCR7Vi50eXBlLnZhbHVlfSwgJHtTfT47XG4gICAgICAgIHZhcjx3b3JrZ3JvdXA+IGludGVyX3Jlc3VsdHM6IGFycmF5PGFycmF5PCR7bmUudHlwZS52YWx1ZX0sICR7JH0+LCAke3h9PjtcbiAgICAgICAgJHtLLmRlY2xhcmVWYXJpYWJsZXMoLi4uWSxuZSl9XG4gICAgICAgICR7Sy5tYWluU3RhcnQoWyQseCwxXSl9XG4gICAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHtuZS5vZmZzZXRUb0luZGljZXMoYHdvcmtncm91cF9pbmRleCAqICR7eH1gKX07XG4gICAgICAgICAgbGV0IGNvbCA9IG91dHB1dF9pbmRpY2VzWzJdO1xuICAgICAgICAgIGxldCByb3cgPSBvdXRwdXRfaW5kaWNlc1sxXTtcbiAgICAgICAgICBsZXQgYmF0Y2ggPSBvdXRwdXRfaW5kaWNlc1swXTtcbiAgICAgICAgICBsZXQgbl9ibG9ja3NfcGVyX2NvbCA9IHVuaWZvcm1zLmJfc2hhcGVbMV07XG4gICAgICAgICAgbGV0IG51bV90aWxlcyA9ICAobl9ibG9ja3NfcGVyX2NvbCAtIDEpIC8gJHtUfSArIDE7XG5cbiAgICAgICAgICAvLyBMb29wIG92ZXIgc2hhcmVkIGRpbWVuc2lvbi5cbiAgICAgICAgICBmb3IgKHZhciB0aWxlOiB1MzIgPSAwOyB0aWxlIDwgbnVtX3RpbGVzOyB0aWxlICs9IDEpIHtcbiAgICAgICAgICAgIGxldCBhX2NvbF9zdGFydCA9IHRpbGUgKiAke1N9O1xuICAgICAgICAgICAgLy8gbG9hZCBvbmUgdGlsZSBBIGRhdGEgaW50byBzaGFyZWQgbWVtb3J5LlxuICAgICAgICAgICAgZm9yICh2YXIgYV9vZmZzZXQgPSBsb2NhbF9pZHg7IGFfb2Zmc2V0IDwgJHtTfTsgYV9vZmZzZXQgKz0gJHtnfSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbGV0IGFfY29sID0gYV9jb2xfc3RhcnQgKyBhX29mZnNldDtcbiAgICAgICAgICAgICAgaWYgKGFfY29sIDwgdW5pZm9ybXMuYV9zaGFwZVsyXSlcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN1Yl9hW2Ffb2Zmc2V0XSA9ICR7Vi5nZXRCeUluZGljZXMoYCR7Vi50eXBlLmluZGljZXN9KGJhdGNoLCByb3csIGFfY29sKWApfTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdWJfYVthX29mZnNldF0gPSAke1YudHlwZS52YWx1ZX0oMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICAgICAgLy8gZWFjaCB0aHJlYWQgcHJvY2VzcyBvbmUgYmxvY2tcbiAgICAgICAgICAgIGxldCBiX3JvdyA9IGNvbCArIGxvY2FsX2lkLnk7XG4gICAgICAgICAgICBsZXQgYmxvY2sgPSB0aWxlICogJHtUfSArIGxvY2FsX2lkLng7XG4gICAgICAgICAgICAke2VlP2BcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2J5dGVzX3Blcl9jb2wgPSAobl9ibG9ja3NfcGVyX2NvbCArIDEpIC8gMjtcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2J5dGVfY291bnQgPSBiX3JvdyAqIHplcm9fcG9pbnRfYnl0ZXNfcGVyX2NvbCArIChibG9jayA+PiAweDF1KTtcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3dvcmRfaW5kZXggPSB6ZXJvX3BvaW50X2J5dGVfY291bnQgPj4gMHgydTtcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2J5dGVfb2Zmc2V0ID0gemVyb19wb2ludF9ieXRlX2NvdW50ICYgMHgzdTtcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X25pYmJsZV9vZmZzZXQ6IHUzMiA9IGJsb2NrICYgMHgxdTtcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2JpdHNfb2Zmc2V0ID0gKHplcm9fcG9pbnRfYnl0ZV9vZmZzZXQgPDwgMykgKyAoemVyb19wb2ludF9uaWJibGVfb2Zmc2V0IDw8IDIpO1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfd29yZCA9ICR7ZWUuZ2V0QnlPZmZzZXQoXCJ6ZXJvX3BvaW50X3dvcmRfaW5kZXhcIil9ID4+IHplcm9fcG9pbnRfYml0c19vZmZzZXQ7XG4gICAgICAgICAgICBsZXQgemVyb19wb2ludCA9ICR7YmV9KCh6ZXJvX3BvaW50X3dvcmQpICYgMHhGdSk7YDpgXG4gICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCB6ZXJvIHBvaW50IGlzIDggZm9yIHVuc2lnbmVkIDQtYml0IHF1YW50aXphdGlvbi5cbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50ID0gJHtiZX0oOCk7YH1cbiAgICAgICAgICAgIGxldCBzY2FsZSA9ICR7c2UuZ2V0QnlPZmZzZXQoXCJiX3JvdyAqIG5fYmxvY2tzX3Blcl9jb2wgKyBibG9ja1wiKX07XG4gICAgICAgICAgICBsZXQgYl9kYXRhID0gJHtRLmdldEJ5SW5kaWNlcyhgJHtRLnR5cGUuaW5kaWNlc30oYl9yb3csIGJsb2NrLCAwKWApfTtcbiAgICAgICAgICAgIHZhciB3b3JkX29mZnNldCA9IGxvY2FsX2lkLnggKiAke3QuYmxvY2tTaXplL2h9O1xuICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8ICR7X307IGkrKykge1xuICAgICAgICAgICAgICAke09lKCl9XG4gICAgICAgICAgICAgIGxldCBiX3ZhbHVlID0gJHtfPT09MT9cImJfZGF0YVwiOlwiYl9kYXRhW2ldXCJ9O1xuICAgICAgICAgICAgICBsZXQgYl92YWx1ZV9sb3dlciA9IHVucGFjazR4VTgoYl92YWx1ZSAmIDB4MEYwRjBGMEZ1KTtcbiAgICAgICAgICAgICAgbGV0IGJfdmFsdWVfdXBwZXIgPSB1bnBhY2s0eFU4KChiX3ZhbHVlID4+IDQpICYgMHgwRjBGMEYwRnUpO1xuICAgICAgICAgICAgICBsZXQgYl9xdWFudGl6ZWRfdmFsdWVzID0gbWF0Mng0PCR7YmV9Pigke0FycmF5LmZyb20oe2xlbmd0aDo0fSwoJGUsbGUpPT5gJHtiZX0oYl92YWx1ZV9sb3dlclske2xlfV0pLCAke2JlfShiX3ZhbHVlX3VwcGVyWyR7bGV9XSlgKS5qb2luKFwiLCBcIil9KTtcbiAgICAgICAgICAgICAgbGV0IGJfZGVxdWFudGl6ZWRfdmFsdWVzID0gKGJfcXVhbnRpemVkX3ZhbHVlcyAtIG1hdDJ4NDwke2JlfT4oJHtBcnJheSg4KS5maWxsKFwiemVyb19wb2ludFwiKS5qb2luKFwiLFwiKX0pKSAqIHNjYWxlO1xuICAgICAgICAgICAgICBpbnRlcl9yZXN1bHRzW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdICs9ICR7QXJyYXkuZnJvbSh7bGVuZ3RoOjJ9LCgkZSxsZSk9PmAke2Bkb3QoYV9kYXRhJHtsZX0sIGJfZGVxdWFudGl6ZWRfdmFsdWVzWyR7bGV9XSlgfWApLmpvaW4oXCIgKyBcIil9O1xuICAgICAgICAgICAgICB3b3JkX29mZnNldCArPSAkezgvaH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGxvY2FsX2lkeCA8ICR7eH0pIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXRfdmFsdWU6ICR7bmUudHlwZS52YWx1ZX0gPSAke25lLnR5cGUudmFsdWV9KDApO1xuICAgICAgICAgICAgZm9yICh2YXIgYiA9IDB1OyBiIDwgJHskfTsgYisrKSB7XG4gICAgICAgICAgICAgIG91dHB1dF92YWx1ZSArPSBpbnRlcl9yZXN1bHRzW2xvY2FsX2lkeF1bYl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29sICsgbG9jYWxfaWR4IDwgdW5pZm9ybXMub3V0cHV0X3NoYXBlWzJdKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAke25lLnNldEJ5SW5kaWNlcyhgJHtuZS50eXBlLmluZGljZXN9KGJhdGNoLCByb3csIGNvbCArIGxvY2FsX2lkeClgLFwib3V0cHV0X3ZhbHVlXCIpfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfWB9O3JldHVybntuYW1lOlwiQmxvY2t3aXNlTWF0TXVsTkJpdHMzMlwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuYmxvY2tTaXplfTske2h9OyR7X307JHskfTske3h9YCxpbnB1dERlcGVuZGVuY2llczpBcnJheShlLmxlbmd0aCkuZmlsbChcInJhbmtcIil9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6eSxkYXRhVHlwZTp1fV0sZGlzcGF0Y2hHcm91cDp7eDpBfSxwcm9ncmFtVW5pZm9ybXM6a30pLGdldFNoYWRlclNvdXJjZTpHfX0sZWw9KGUsdCk9PntjaChlLmlucHV0cyx0KSx0LmJsb2NrU2l6ZT09PTMyJiZlLmFkYXB0ZXJJbmZvLmlzVmVuZG9yKFwiaW50ZWxcIikmJmUuYWRhcHRlckluZm8uaXNBcmNoaXRlY3R1cmUoXCJnZW4tMTJscFwiKT9lLmNvbXB1dGUobWgoZS5pbnB1dHMsdCkpOmUuY29tcHV0ZShwaChlLmlucHV0cyx0KSl9LHRsPWU9PnJlKGUpfSk7dmFyIGZoLGhoLGdoLGJoLHloLF9oLHdoLHZoLG5sLG9sPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7YWUoKTtmaD1lPT57aWYoIWV8fGUubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKFwiVG9vIGZldyBpbnB1dHNcIik7aWYoZVswXS5kYXRhVHlwZSE9PTEmJmVbMF0uZGF0YVR5cGUhPT0xMCl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCB0eXBlIG11c3QgYmUgZmxvYXQgb3IgZmxvYXQxNi5cIik7aWYoZS5sZW5ndGg+PTIpe2xldCB0PWVbMF0uZGltcy5sZW5ndGgqMj09PWVbMV0uZGltc1swXTtpZihlLmxlbmd0aD09PTQmJih0PWVbM10uZGltc1swXSoyPT09ZVsxXS5kaW1zWzBdKSwhdCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcGFkcyBzaG91bGQgYmUgYSAxRCB0ZW5zb3Igb2Ygc2hhcGUgWzIgKiBpbnB1dF9yYW5rXSBvciBbMiAqIG51bV9heGVzXS5cIil9fSxoaD0oZSx0LHIpPT57bGV0IG49XCJcIjtmb3IobGV0IG89dC0xO28+PTA7LS1vKW4rPWBcbiAgICAgICAgICAgIGsgPSBpMzIoJHtlLmluZGljZXNHZXQoXCJpbmRpY2VzXCIsbyl9KSAtICR7RihcInVuaWZvcm1zLnBhZHNcIixvLHIpfTtcbiAgICAgICAgICAgIGlmIChrIDwgMCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrID49IGkzMigke0YoXCJ1bmlmb3Jtcy54X3NoYXBlXCIsbyx0KX0pKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ICs9IGsgKiBpMzIoJHtGKFwidW5pZm9ybXMueF9zdHJpZGVzXCIsbyx0KX0pO1xuICAgICAgICBgO3JldHVybmBcbiAgICAgICAgICB2YWx1ZSA9ICR7ZS50eXBlLnZhbHVlfSh1bmlmb3Jtcy5jb25zdGFudF92YWx1ZSk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgJHtufVxuICAgICAgICAgICAgdmFsdWUgPSB4W29mZnNldF07XG4gICAgICAgICAgfVxuICAgICAgYH0sZ2g9KGUsdCxyKT0+e2xldCBuPVwiXCI7Zm9yKGxldCBvPXQtMTtvPj0wOy0tbyluKz1gXG4gICAgICAgICAgICAgICAgayA9IGkzMigke2UuaW5kaWNlc0dldChcImluZGljZXNcIixvKX0pIC0gJHtGKFwidW5pZm9ybXMucGFkc1wiLG8scil9O1xuICAgICAgICAgICAgICAgIGlmIChrIDwgMCkge1xuICAgICAgICAgICAgICAgICAgayA9IC1rO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBsZXQgXzJuXzEgPSAyICogKGkzMigke0YoXCJ1bmlmb3Jtcy54X3NoYXBlXCIsbyx0KX0pIC0gMSk7XG4gICAgICAgICAgICAgICAgICBrID0gayAlIF8ybl8xO1xuICAgICAgICAgICAgICAgICAgaWYoayA+PSBpMzIoJHtGKFwidW5pZm9ybXMueF9zaGFwZVwiLG8sdCl9KSkge1xuICAgICAgICAgICAgICAgICAgICBrID0gXzJuXzEgLSBrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gayAqIGkzMigke0YoXCJ1bmlmb3Jtcy54X3N0cmlkZXNcIixvLHQpfSk7XG4gICAgICAgICAgICBgO3JldHVybmBcbiAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgICAgICAgIHZhciBrID0gMDtcbiAgICAgICAgICAgICAgJHtufVxuICAgICAgICAgICAgICB2YWx1ZSA9IHhbb2Zmc2V0XTtcbiAgICAgICAgICBgfSxiaD0oZSx0LHIpPT57bGV0IG49XCJcIjtmb3IobGV0IG89dC0xO28+PTA7LS1vKW4rPWBcbiAgICAgICAgICAgICAgICBrID0gaTMyKCR7ZS5pbmRpY2VzR2V0KFwiaW5kaWNlc1wiLG8pfSkgLSAke0YoXCJ1bmlmb3Jtcy5wYWRzXCIsbyxyKX07XG4gICAgICAgICAgICAgICAgaWYgKGsgPCAwKSB7XG4gICAgICAgICAgICAgICAgICBrID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGsgPj0gaTMyKCR7RihcInVuaWZvcm1zLnhfc2hhcGVcIixvLHQpfSkpIHtcbiAgICAgICAgICAgICAgICAgIGsgPSBpMzIoJHtGKFwidW5pZm9ybXMueF9zaGFwZVwiLG8sdCl9KSAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBrICogaTMyKCR7RihcInVuaWZvcm1zLnhfc3RyaWRlc1wiLG8sdCl9KTtcbiAgICAgICAgICAgIGA7cmV0dXJuYFxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgICAke259XG4gICAgICAgICAgICAgIHZhbHVlID0geFtvZmZzZXRdO1xuICAgICAgICAgIGB9LHloPShlLHQscik9PntsZXQgbj1cIlwiO2ZvcihsZXQgbz10LTE7bz49MDstLW8pbis9YFxuICAgICAgICAgICAgICAgIGsgPSBpMzIoJHtlLmluZGljZXNHZXQoXCJpbmRpY2VzXCIsbyl9KSAtICR7RihcInVuaWZvcm1zLnBhZHNcIixvLHIpfTtcbiAgICAgICAgICAgICAgICBpZiAoayA8IDApICB7XG4gICAgICAgICAgICAgICAgICBrICs9IGkzMigke0YoXCJ1bmlmb3Jtcy54X3NoYXBlXCIsbyx0KX1dKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGsgPj0gaTMyKCR7RihcInVuaWZvcm1zLnhfc2hhcGVcIixvLHQpfSkpIHtcbiAgICAgICAgICAgICAgICAgIGsgLT0gaTMyKCR7RihcInVuaWZvcm1zLnhfc2hhcGVcIixvLHQpfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBrICogaTMyKCR7RihcInVuaWZvcm1zLnhfc3RyaWRlc1wiLG8sdCl9KTtcbiAgICAgICAgICAgIGA7cmV0dXJuYFxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgICAke259XG4gICAgICAgICAgICAgIHZhbHVlID0geFtvZmZzZXRdO1xuICAgICAgICAgIGB9LF9oPShlLHQscik9Pntzd2l0Y2goci5tb2RlKXtjYXNlIDA6cmV0dXJuIGhoKGUsdCxyLnBhZHMubGVuZ3RoKTtjYXNlIDE6cmV0dXJuIGdoKGUsdCxyLnBhZHMubGVuZ3RoKTtjYXNlIDI6cmV0dXJuIGJoKGUsdCxyLnBhZHMubGVuZ3RoKTtjYXNlIDM6cmV0dXJuIHloKGUsdCxyLnBhZHMubGVuZ3RoKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbW9kZVwiKX19LHdoPShlLHQpPT57bGV0IHI9Qy5wYWRTaGFwZShlWzBdLmRpbXMuc2xpY2UoKSx0LnBhZHMpLG49ZVswXS5kaW1zLG89Qy5zaXplKHIpLGk9W3t0eXBlOjEyLGRhdGE6b30se3R5cGU6NixkYXRhOnQucGFkc31dLGE9ZS5sZW5ndGg+PTMmJmVbMl0uZGF0YTt0Lm1vZGU9PT0wJiZpLnB1c2goe3R5cGU6YT9lWzJdLmRhdGFUeXBlOjEsZGF0YTp0LnZhbHVlfSksaS5wdXNoKC4uLk4oZVswXS5kaW1zLHIpKTtsZXQgZD1bXCJyYW5rXCJdLGw9cD0+e2xldCBtPU0oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLHIubGVuZ3RoKSx1PUUoXCJ4XCIsZVswXS5kYXRhVHlwZSxuLmxlbmd0aCksaD11LnR5cGUudmFsdWUsXz1faChtLG4ubGVuZ3RoLHQpLHk9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwicGFkc1wiLHR5cGU6XCJpMzJcIixsZW5ndGg6dC5wYWRzLmxlbmd0aH1dO3JldHVybiB0Lm1vZGU9PT0wJiZ5LnB1c2goe25hbWU6XCJjb25zdGFudF92YWx1ZVwiLHR5cGU6YT9oOlwiZjMyXCJ9KSxgXG4gICAgICAgICAgICAke3AucmVnaXN0ZXJVbmlmb3Jtcyh5KS5kZWNsYXJlVmFyaWFibGVzKHUsbSl9XG4gICAgICAgICAgICAke3AubWFpblN0YXJ0KCl9XG4gICAgICAgICAgICAke3AuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuXG4gICAgICAgICAgICBsZXQgaW5kaWNlcyA9ICR7bS5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcblxuICAgICAgICAgICAgdmFyIHZhbHVlID0gJHtofSgwKTtcbiAgICAgICAgICAgICR7X31cbiAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHZhbHVlO1xuICAgICAgICB9YH07cmV0dXJue25hbWU6XCJQYWRcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0Lm1vZGV9JHthfWAsaW5wdXREZXBlbmRlbmNpZXM6ZH0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpyLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChDLnNpemUocikvNjQpfSxwcm9ncmFtVW5pZm9ybXM6aX0pLGdldFNoYWRlclNvdXJjZTpsfX0sdmg9KGUsdCk9PntpZihlLmxlbmd0aD4xKXtsZXQgcj1lWzFdLmdldEJpZ0ludDY0QXJyYXkoKSxuPWUubGVuZ3RoPj0zJiZlWzJdLmRhdGE/ZVsyXS5kYXRhVHlwZT09PTEwP2VbMl0uZ2V0VWludDE2QXJyYXkoKVswXTplWzJdLmdldEZsb2F0MzJBcnJheSgpWzBdOjAsbz1lWzBdLmRpbXMubGVuZ3RoLGk9bmV3IEludDMyQXJyYXkoMipvKS5maWxsKDApO2lmKGUubGVuZ3RoPj00KXtsZXQgZD1lWzNdLmdldEJpZ0ludDY0QXJyYXkoKTtmb3IobGV0IGw9MDtsPGQubGVuZ3RoO2wrKylpW051bWJlcihkW2xdKV09TnVtYmVyKHJbbF0pLGlbTnVtYmVyKGRbbF0pK29dPU51bWJlcihyW2wrZC5sZW5ndGhdKX1lbHNlIHIuZm9yRWFjaCgoZCxsKT0+aVtOdW1iZXIobCldPU51bWJlcihkKSk7bGV0IGE9W107cmV0dXJuIGkuZm9yRWFjaChkPT5hLnB1c2goZCkpLHttb2RlOnQubW9kZSx2YWx1ZTpuLHBhZHM6YX19ZWxzZSByZXR1cm4gdH0sbmw9KGUsdCk9PntmaChlLmlucHV0cyk7bGV0IHI9dmgoZS5pbnB1dHMsdCk7ZS5jb21wdXRlKHdoKGUuaW5wdXRzLHIpLHtpbnB1dHM6WzBdfSl9fSk7dmFyIHRuLGlsLGFsLHNsLHVsLCRoLHhoLGRsLGxsLGNsLHBsLG1sLGZsLGhsLGdsLGJsLHlsLF9sLHdsLHZsPVUoKCk9PntcInVzZSBzdHJpY3RcIjtXZSgpO3RlKCk7b2UoKTthZSgpO3RuPWU9PntpZih2ZS53ZWJncHUudmFsaWRhdGVJbnB1dENvbnRlbnQmJighZXx8ZS5sZW5ndGghPT0xKSl0aHJvdyBuZXcgRXJyb3IoXCJQb29sIG9wcyByZXF1aXJlcyAxIGlucHV0LlwiKX0saWw9KGUsdCxyKT0+e2xldCBuPXQuZm9ybWF0PT09XCJOSFdDXCIsbz1lLmRpbXMuc2xpY2UoKTtuJiZvLnNwbGljZSgxLDAsby5wb3AoKSk7bGV0IGk9T2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwodCxcImRpbGF0aW9uc1wiKSxhPXQua2VybmVsU2hhcGUuc2xpY2UoKSxkPXQuc3RyaWRlcy5zbGljZSgpLGw9aT90LmRpbGF0aW9ucy5zbGljZSgpOltdLHA9dC5wYWRzLnNsaWNlKCk7QXQuYWRqdXN0UG9vbEF0dHJpYnV0ZXMocixvLGEsZCxsLHApO2xldCBtPUF0LmNvbXB1dGVQb29sT3V0cHV0U2hhcGUocixvLGQsbCxhLHAsdC5hdXRvUGFkKSx1PU9iamVjdC5hc3NpZ24oe30sdCk7aT9PYmplY3QuYXNzaWduKHUse2tlcm5lbFNoYXBlOmEsc3RyaWRlczpkLHBhZHM6cCxkaWxhdGlvbnM6bCxjYWNoZUtleTp0LmNhY2hlS2V5fSk6T2JqZWN0LmFzc2lnbih1LHtrZXJuZWxTaGFwZTphLHN0cmlkZXM6ZCxwYWRzOnAsY2FjaGVLZXk6dC5jYWNoZUtleX0pO2xldCBoPW0uc2xpY2UoKTtyZXR1cm4gaC5wdXNoKGguc3BsaWNlKDEsMSlbMF0pLFt1LG4/aDptXX0sYWw9KGUsdCk9PntsZXQgcj10LmZvcm1hdD09PVwiTkhXQ1wiLG49Qy5zaXplKGUpLG89Qy5zaXplKHQua2VybmVsU2hhcGUpLGk9W3t0eXBlOjEyLGRhdGE6bn0se3R5cGU6MTIsZGF0YTpvfV0sYT1be25hbWU6XCJvdXRwdXRTaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImtlcm5lbFNpemVcIix0eXBlOlwidTMyXCJ9XTtpZih0Lmtlcm5lbFNoYXBlLmxlbmd0aDw9Mil7bGV0IGQ9dC5rZXJuZWxTaGFwZVt0Lmtlcm5lbFNoYXBlLmxlbmd0aC0xXSxsPXQuc3RyaWRlc1t0LnN0cmlkZXMubGVuZ3RoLTFdLHA9dC5wYWRzW3QucGFkcy5sZW5ndGgvMi0xXSxtPXQucGFkc1t0LnBhZHMubGVuZ3RoLTFdLHU9ISEocCttKTtpLnB1c2goe3R5cGU6MTIsZGF0YTpkfSx7dHlwZToxMixkYXRhOmx9LHt0eXBlOjEyLGRhdGE6cH0se3R5cGU6MTIsZGF0YTptfSksYS5wdXNoKHtuYW1lOlwia3dcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwic3dcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwicHdTdGFydFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJwd0VuZFwiLHR5cGU6XCJ1MzJcIn0pO2xldCBoPSExO2lmKHQua2VybmVsU2hhcGUubGVuZ3RoPT09Mil7bGV0IF89dC5rZXJuZWxTaGFwZVt0Lmtlcm5lbFNoYXBlLmxlbmd0aC0yXSx5PXQuc3RyaWRlc1t0LnN0cmlkZXMubGVuZ3RoLTJdLGc9dC5wYWRzW3QucGFkcy5sZW5ndGgvMi0yXSx4PXQucGFkc1t0LnBhZHMubGVuZ3RoLTJdO2g9ISEoZyt4KSxpLnB1c2goe3R5cGU6MTIsZGF0YTpffSx7dHlwZToxMixkYXRhOnl9LHt0eXBlOjEyLGRhdGE6Z30se3R5cGU6MTIsZGF0YTp4fSksYS5wdXNoKHtuYW1lOlwia2hcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwic2hcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwicGhTdGFydFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJwaEVuZFwiLHR5cGU6XCJ1MzJcIn0pfXJldHVybltpLGEsITAsdSxoXX1lbHNle2lmKHIpdGhyb3cgbmV3IEVycm9yKFwiUG9vbGluZyB3aXRoIGtlcm5lbFNoYXBlLmxlbmd0aCA+IDIgaXMgbm90IHN1cHBvcnRlZCBmb3IgTkhXQyBmb3JtYXQuXCIpO2xldCBkPUMuY29tcHV0ZVN0cmlkZXModC5rZXJuZWxTaGFwZSk7aS5wdXNoKHt0eXBlOjEyLGRhdGE6ZH0se3R5cGU6MTIsZGF0YTp0LnBhZHN9LHt0eXBlOjEyLGRhdGE6dC5zdHJpZGVzfSksYS5wdXNoKHtuYW1lOlwia2VybmVsU3RyaWRlc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6ZC5sZW5ndGh9LHtuYW1lOlwicGFkc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6dC5wYWRzLmxlbmd0aH0se25hbWU6XCJzdHJpZGVzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDp0LnN0cmlkZXMubGVuZ3RofSk7bGV0IGw9dC5wYWRzLnJlZHVjZSgocCxtKT0+cCttKTtyZXR1cm5baSxhLCEhbCwhMSwhMV19fSxzbD0oZSx0LHIsbixvLGksYSxkLGwscCxtLHUpPT57bGV0IGg9by5mb3JtYXQ9PT1cIk5IV0NcIixfPXQudHlwZS52YWx1ZSx5PU0oXCJvdXRwdXRcIix0LnR5cGUudGVuc29yLG4pO2lmKG8ua2VybmVsU2hhcGUubGVuZ3RoPD0yKXtsZXQgZz1cIlwiLHg9XCJcIiwkPVwiXCIsdj1yLShoPzI6MSk7aWYobT9nPWBcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwdTsgaSA8IHVuaWZvcm1zLmt3OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIHhJbmRpY2VzWyR7dn1dID0gaW5kaWNlc1ske3Z9XSAqIHVuaWZvcm1zLnN3IC0gdW5pZm9ybXMucHdTdGFydCArIGk7XG4gICAgICAgICAgICAgICAgICBpZiAoeEluZGljZXNbJHt2fV0gPCAwIHx8IHhJbmRpY2VzWyR7dn1dXG4gICAgICAgICAgICAgICAgICAgICAgPj0gdW5pZm9ybXMueF9zaGFwZVske3Z9XSkge1xuICAgICAgICAgICAgICAgICAgICBwYWQrKztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBsZXQgeF92YWwgPSB4WyR7dC5pbmRpY2VzVG9PZmZzZXQoXCJ4SW5kaWNlc1wiKX1dO1xuICAgICAgICAgICAgICAgICAgJHtpfVxuICAgICAgICAgICAgICAgIH1gOmc9YFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgdW5pZm9ybXMua3c7IGkrKykge1xuICAgICAgICAgICAgICAgICAgeEluZGljZXNbJHt2fV0gPSBpbmRpY2VzWyR7dn1dICogdW5pZm9ybXMuc3cgLSB1bmlmb3Jtcy5wd1N0YXJ0ICsgaTtcbiAgICAgICAgICAgICAgICAgIGxldCB4X3ZhbCA9IHhbJHt0LmluZGljZXNUb09mZnNldChcInhJbmRpY2VzXCIpfV07XG4gICAgICAgICAgICAgICAgICAke2l9XG4gICAgICAgICAgICAgICAgfWAsby5rZXJuZWxTaGFwZS5sZW5ndGg9PT0yKXtsZXQgVD1yLShoPzM6Mik7dT94PWBcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqOiB1MzIgPSAwdTsgaiA8IHVuaWZvcm1zLmtoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIHhJbmRpY2VzWyR7VH1dID0gaW5kaWNlc1ske1R9XSAqIHVuaWZvcm1zLnNoIC0gdW5pZm9ybXMucGhTdGFydCArIGo7XG4gICAgICAgICAgICAgICAgICBpZiAoeEluZGljZXNbJHtUfV0gPCAwIHx8IHhJbmRpY2VzWyR7VH1dID49IHVuaWZvcm1zLnhfc2hhcGVbJHtUfV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcGFkICs9IGkzMih1bmlmb3Jtcy5rdyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBgOng9YFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGo6IHUzMiA9IDB1OyBqIDwgdW5pZm9ybXMua2g7IGorKykge1xuICAgICAgICAgICAgICAgICAgeEluZGljZXNbJHtUfV0gPSBpbmRpY2VzWyR7VH1dICogdW5pZm9ybXMuc2ggLSB1bmlmb3Jtcy5waFN0YXJ0ICsgajtcbiAgICAgICAgICAgICAgICBgLCQ9YFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBgfXJldHVybmBcbiAgICAgICAgICAgICR7ZS5yZWdpc3RlclVuaWZvcm1zKGwpLmRlY2xhcmVWYXJpYWJsZXModCx5KX1cblxuICAgICAgICAgICAgJHtlLm1haW5TdGFydCgpfVxuICAgICAgICAgICAgICAke2UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG5cbiAgICAgICAgICAgICAgbGV0IGluZGljZXMgPSAke3kub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAgICAgICAgIHZhciB4SW5kaWNlcyA9ICR7eS5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcblxuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSAke199KCR7ZH0pO1xuICAgICAgICAgICAgICB2YXIgcGFkID0gMDtcbiAgICAgICAgICAgICAgJHt4fVxuICAgICAgICAgICAgICAke2d9XG4gICAgICAgICAgICAgICR7JH1cbiAgICAgICAgICAgICAgJHthfVxuXG4gICAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHZhbHVlO1xuICAgICAgICAgICAgfWB9ZWxzZXtpZihoKXRocm93IG5ldyBFcnJvcihcIlBvb2xpbmcgd2l0aCBrZXJuZWxTaGFwZS5sZW5ndGggPiAyIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIE5IV0MgZm9ybWF0LlwiKTtsZXQgZz1vLmtlcm5lbFNoYXBlLmxlbmd0aCx4PW8ucGFkcy5sZW5ndGgsJD1cIlwiO3JldHVybiBwPyQ9YFxuICAgICAgICAgICAgICAgIGlmICh4SW5kaWNlc1tqXSA+PSB1bmlmb3Jtcy54X3NoYXBlW2pdKSB7XG4gICAgICAgICAgICAgICAgICBwYWQrKztcbiAgICAgICAgICAgICAgICAgIGlzUGFkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWlzUGFkKSB7XG4gICAgICAgICAgICAgICAgbGV0IHhfdmFsID0geFske3QuaW5kaWNlc1RvT2Zmc2V0KFwieEluZGljZXNcIil9XTtcbiAgICAgICAgICAgICAgICAke2l9XG4gICAgICAgICAgICAgIH1gOiQ9YFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldCB4X3ZhbCA9IHhbJHt0LmluZGljZXNUb09mZnNldChcInhJbmRpY2VzXCIpfV07XG4gICAgICAgICAgICAgICR7aX1cbiAgICAgICAgICAgIGAsYFxuICAgICAgICAgICAgJHtlLnJlZ2lzdGVyVW5pZm9ybXMobCkuZGVjbGFyZVZhcmlhYmxlcyh0LHkpfVxuXG4gICAgICAgICAgICAke2UubWFpblN0YXJ0KCl9XG4gICAgICAgICAgICAgICR7ZS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0U2l6ZVwiKX1cbiAgICAgICAgICAgICAgbGV0IGluZGljZXMgPSAke3kub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAgICAgICAgIHZhciB4SW5kaWNlcyA9ICR7eS5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcblxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0czogYXJyYXk8dTMyLCAke2d9PjtcblxuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSAke199KCR7ZH0pO1xuICAgICAgICAgICAgICB2YXIgcGFkID0gMDtcbiAgICAgICAgICAgICAgdmFyIGlzUGFkID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCB1bmlmb3Jtcy5rZXJuZWxTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gaTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMHU7IGogPCAke2ctMX11OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIG9mZnNldHNbal0gPSBvZmZzZXQgLyAke0YoXCJ1bmlmb3Jtcy5rZXJuZWxTdHJpZGVzXCIsXCJqXCIsZyl9O1xuICAgICAgICAgICAgICAgICAgb2Zmc2V0IC09IG9mZnNldHNbal0gKiAke0YoXCJ1bmlmb3Jtcy5rZXJuZWxTdHJpZGVzXCIsXCJqXCIsZyl9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXRzWyR7Zy0xfV0gPSBvZmZzZXQ7XG5cbiAgICAgICAgICAgICAgICBpc1BhZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAke3ItZ311OyBqIDwgJHtyfXU7IGorKykge1xuICAgICAgICAgICAgICAgICAgeEluZGljZXNbal0gPSBpbmRpY2VzW2pdICogJHtGKFwidW5pZm9ybXMuc3RyaWRlc1wiLGBqIC0gJHtyLWd9dWAsZyl9XG4gICAgICAgICAgICAgICAgICAgICsgb2Zmc2V0c1tqIC0gJHtyLWd9dV0gLSAke0YoXCJ1bmlmb3Jtcy5wYWRzXCIsXCJqIC0gMnVcIix4KX07XG4gICAgICAgICAgICAgICAgICAkeyR9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgJHthfVxuXG4gICAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHZhbHVlO1xuICAgICAgICAgICAgfWB9fSx1bD1lPT5gJHtlLmZvcm1hdH07JHtlLmNlaWxNb2RlfTske2UuYXV0b1BhZH07JHtlLmtlcm5lbFNoYXBlLmxlbmd0aH1gLCRoPWU9PmAke3VsKGUpfTske2UuY291bnRJbmNsdWRlUGFkfWAseGg9ZT0+YCR7dWwoZSl9OyR7ZS5zdG9yYWdlT3JkZXJ9OyR7ZS5kaWxhdGlvbnN9YCxkbD1lPT4oe2Zvcm1hdDplLmZvcm1hdCxhdXRvUGFkOltcIk5PVFNFVFwiLFwiVkFMSURcIixcIlNBTUVfVVBQRVJcIixcIlNBTUVfTE9XRVJcIl1bZS5hdXRvX3BhZF0sY2VpbE1vZGU6ZS5jZWlsX21vZGUsa2VybmVsU2hhcGU6ZS5rZXJuZWxfc2hhcGUsc3RyaWRlczplLnN0cmlkZXMscGFkczplLnBhZHN9KSxsbD0oZSx0LHIsbik9PntsZXRbbyxpXT1pbCh0LG4sciksYT1FKFwieFwiLHQuZGF0YVR5cGUsdC5kaW1zLmxlbmd0aCksZD1hLnR5cGUudmFsdWUsbD1cInZhbHVlICs9IHhfdmFsO1wiLHA9XCJcIjtvLmNvdW50SW5jbHVkZVBhZD9wKz1gdmFsdWUgLz0gJHtkfSh1bmlmb3Jtcy5rZXJuZWxTaXplKTtgOnArPWB2YWx1ZSAvPSAke2R9KGkzMih1bmlmb3Jtcy5rZXJuZWxTaXplKSAtIHBhZCk7YDtsZXRbbSx1LGgsXyx5XT1hbChpLG8pO20ucHVzaCguLi5OKHQuZGltcyxpKSk7bGV0IGc9W1wicmFua1wiXTtyZXR1cm57bmFtZTplLHNoYWRlckNhY2hlOntoaW50OmAke24uY2FjaGVLZXl9OyR7aH07JHtffTske3l9YCxpbnB1dERlcGVuZGVuY2llczpnfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmksZGF0YVR5cGU6dC5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKEMuc2l6ZShpKS82NCl9LHByb2dyYW1Vbmlmb3JtczptfSksZ2V0U2hhZGVyU291cmNlOng9PnNsKHgsYSx0LmRpbXMubGVuZ3RoLGkubGVuZ3RoLG8sbCxwLDAsdSxoLF8seSl9fSxjbD1lPT57bGV0IHQ9ZS5jb3VudF9pbmNsdWRlX3BhZCE9PTAscj1kbChlKTtpZihyLmNlaWxNb2RlIT09MCl0aHJvdyBuZXcgRXJyb3IoXCJ1c2luZyBjZWlsKCkgaW4gc2hhcGUgY29tcHV0YXRpb24gaXMgbm90IHlldCBzdXBwb3J0ZWQgZm9yIEF2ZXJhZ2VQb29sXCIpO2xldCBuPXtjb3VudEluY2x1ZGVQYWQ6dCwuLi5yLGNhY2hlS2V5OlwiXCJ9O3JldHVybnsuLi5uLGNhY2hlS2V5OiRoKG4pfX0scGw9KGUsdCk9Pnt0bihlLmlucHV0cyksZS5jb21wdXRlKGxsKFwiQXZlcmFnZVBvb2xcIixlLmlucHV0c1swXSwhMSx0KSl9LG1sPXthdXRvUGFkOlwiXCIsY2VpbE1vZGU6MCxjb3VudEluY2x1ZGVQYWQ6ITEsa2VybmVsU2hhcGU6W10sc3RyaWRlczpbXSxwYWRzOltdLHN0b3JhZ2VPcmRlcjowLGRpbGF0aW9uczpbXX0sZmw9ZT0+e2xldCB0PWUuZm9ybWF0O3JldHVybntmb3JtYXQ6dCwuLi5tbCxjYWNoZUtleTp0fX0saGw9KGUsdCk9Pnt0bihlLmlucHV0cyksZS5jb21wdXRlKGxsKFwiR2xvYmFsQXZlcmFnZVBvb2xcIixlLmlucHV0c1swXSwhMCx0KSl9LGdsPShlLHQscixuKT0+e2xldFtvLGldPWlsKHQsbixyKSxhPWBcbiAgICAgIHZhbHVlID0gbWF4KHhfdmFsLCB2YWx1ZSk7XG4gICAgYCxkPVwiXCIsbD1FKFwieFwiLHQuZGF0YVR5cGUsdC5kaW1zLmxlbmd0aCkscD1bXCJyYW5rXCJdLFttLHUsaCxfLHldPWFsKGksbyk7cmV0dXJuIG0ucHVzaCguLi5OKHQuZGltcyxpKSkse25hbWU6ZSxzaGFkZXJDYWNoZTp7aGludDpgJHtuLmNhY2hlS2V5fTske2h9OyR7X307JHt5fWAsaW5wdXREZXBlbmRlbmNpZXM6cH0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczppLGRhdGFUeXBlOnQuZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChDLnNpemUoaSkvNjQpfSxwcm9ncmFtVW5pZm9ybXM6bX0pLGdldFNoYWRlclNvdXJjZTpnPT5zbChnLGwsdC5kaW1zLmxlbmd0aCxpLmxlbmd0aCxvLGEsZCx0LmRhdGFUeXBlPT09MTA/LTY1NTA0Oi0xZTUsdSxoLF8seSl9fSxibD0oZSx0KT0+e3RuKGUuaW5wdXRzKSxlLmNvbXB1dGUoZ2woXCJNYXhQb29sXCIsZS5pbnB1dHNbMF0sITEsdCkpfSx5bD1lPT57bGV0IHQ9ZS5zdG9yYWdlX29yZGVyLHI9ZS5kaWxhdGlvbnMsbj1kbChlKTtpZih0IT09MCl0aHJvdyBuZXcgRXJyb3IoXCJjb2x1bW4gbWFqb3Igc3RvcmFnZSBvcmRlciBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgTWF4UG9vbFwiKTtpZihuLmNlaWxNb2RlIT09MCl0aHJvdyBuZXcgRXJyb3IoXCJ1c2luZyBjZWlsKCkgaW4gc2hhcGUgY29tcHV0YXRpb24gaXMgbm90IHlldCBzdXBwb3J0ZWQgZm9yIE1heFBvb2xcIik7bGV0IG89e3N0b3JhZ2VPcmRlcjp0LGRpbGF0aW9uczpyLC4uLm4sY2FjaGVLZXk6XCJcIn07cmV0dXJuey4uLm8sY2FjaGVLZXk6eGgobyl9fSxfbD1lPT57bGV0IHQ9ZS5mb3JtYXQ7cmV0dXJue2Zvcm1hdDp0LC4uLm1sLGNhY2hlS2V5OnR9fSx3bD0oZSx0KT0+e3RuKGUuaW5wdXRzKSxlLmNvbXB1dGUoZ2woXCJHbG9iYWxNYXhQb29sXCIsZS5pbnB1dHNbMF0sITAsdCkpfX0pO3ZhciBUaCxJaCwkbCx4bCxTbD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtvZSgpO1NlKCk7YWUoKTtUaD0oZSx0KT0+e2lmKGUubGVuZ3RoPDJ8fGUubGVuZ3RoPjMpdGhyb3cgbmV3IEVycm9yKFwiRGVxdWFudGl6ZUxpbmVhciByZXF1aXJlcyAyIG9yIDMgaW5wdXRzLlwiKTtpZihlLmxlbmd0aD09PTMmJmVbMV0uZGltcz09PWVbMl0uZGltcyl0aHJvdyBuZXcgRXJyb3IoXCJ4LXNjYWxlIGFuZCB4LXplcm8tcG9pbnQgbXVzdCBoYXZlIHRoZSBzYW1lIHNoYXBlLlwiKTtpZihlLmxlbmd0aD09PTMmJmVbMF0uZGF0YVR5cGUhPT1lWzJdLmRhdGFUeXBlKXRocm93IG5ldyBFcnJvcihcInggYW5kIHgtemVyby1wb2ludCBtdXN0IGhhdmUgdGhlIHNhbWUgZGF0YSB0eXBlLlwiKTtpZihlWzBdLmRhdGFUeXBlPT09NiYmZS5sZW5ndGg+Mil0aHJvdyBuZXcgRXJyb3IoXCJJbiB0aGUgY2FzZSBvZiBkZXF1YW50aXppbmcgaW50MzIgdGhlcmUgaXMgbm8gemVybyBwb2ludC5cIik7aWYoZVsxXS5kaW1zLmxlbmd0aCE9PTAmJmVbMV0uZGltcy5sZW5ndGghPT0xJiZlWzFdLmRpbXMubGVuZ3RoIT09ZVswXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzY2FsZSBpbnB1dCBtdXN0IGJlIGEgc2NhbGFyLCBhIDFEIHRlbnNvciwgb3IgaGF2ZSB0aGUgc2FtZSByYW5rIGFzIHRoZSBpbnB1dCB0ZW5zb3IuXCIpO2lmKGUubGVuZ3RoPjIpe2lmKGVbMF0uZGF0YVR5cGUhPT1lWzJdLmRhdGFUeXBlKXRocm93IG5ldyBFcnJvcihcInggYW5kIHgtemVyby1wb2ludCBtdXN0IGhhdmUgdGhlIHNhbWUgZGF0YSB0eXBlLlwiKTtpZihlWzFdLmRpbXMubGVuZ3RoIT09ZVsyXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzY2FsZSBhbmQgemVyby1wb2ludCBpbnB1dHMgbXVzdCBoYXZlIHRoZSBzYW1lIHJhbmsuXCIpO2lmKCFlWzFdLmRpbXMubWFwKChyLG4pPT5yPT09ZVsyXS5kaW1zW25dKS5yZWR1Y2UoKHIsbik9PnImJm4sITApKXRocm93IG5ldyBFcnJvcihcInNjYWxlIGFuZCB6ZXJvLXBvaW50IGlucHV0cyBtdXN0IGhhdmUgdGhlIHNhbWUgc2hhcGUuXCIpfWlmKHQuYmxvY2tTaXplPjApe2lmKGVbMV0uZGltcy5sZW5ndGg9PT0wfHxlWzFdLmRpbXMubGVuZ3RoPT09MSYmZVsxXS5kaW1zWzBdPT09MSl0aHJvdyBuZXcgRXJyb3IoXCJibG9ja1NpemUgbXVzdCBiZSBzZXQgb25seSBmb3IgYmxvY2sgcXVhbnRpemF0aW9uLlwiKTtpZighZVsxXS5kaW1zLm1hcCgobyxpKT0+aT09PXQuYXhpc3x8bz09PWVbMF0uZGltc1tpXSkucmVkdWNlKChvLGkpPT5vJiZpLCEwKSl0aHJvdyBuZXcgRXJyb3IoXCJGb3IgYmxvY2sgcXVuYXRpemF0aW9uLCBzY2FsZSBpbnB1dCBzaGFwZSB0byBtYXRjaCB0aGUgaW5wdXQgc2hhcGUgZXhjZXB0IGZvciB0aGUgYXhpc1wiKTtpZihlWzFdLmRpbXMubGVuZ3RoIT09ZVswXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJGb3IgYmxvY2sgcXVuYXRpemF0aW9uIHRoZSBzY2FsZSBpbnB1dCByYW5rIG11c3QgYmUgdGhlIHNhbWUgYXMgdGhlIHggcmFuay5cIik7bGV0IHI9ZVswXS5kaW1zW3QuYXhpc10sbj1lWzFdLmRpbXNbdC5heGlzXTtpZih0LmJsb2NrU2l6ZTxNYXRoLmNlaWwoci9uKXx8dC5ibG9ja1NpemU+TWF0aC5jZWlsKHIvKG4tMSktMSkpdGhyb3cgbmV3IEVycm9yKFwiYmxvY2tTaXplIG11c3QgYmUgd2l0aCBpbiB0aGUgcmFuZ2UgW2NlaWwoZEkgLyBTaSksIGNlaWwoZEkgLyAoU2kgLSAxKSAtIDEpXS5cIil9fSxJaD0oZSx0KT0+e2xldCByPUMubm9ybWFsaXplQXhpcyh0LmF4aXMsZVswXS5kaW1zLmxlbmd0aCksbj1lWzBdLmRhdGFUeXBlLG89bj09PTMsaT1lWzBdLmRpbXMsYT1lWzFdLmRhdGFUeXBlLGQ9Qy5zaXplKGkpLGw9bj09PTN8fG49PT0yLHA9bD9bTWF0aC5jZWlsKEMuc2l6ZShlWzBdLmRpbXMpLzQpXTplWzBdLmRpbXMsbT1lWzFdLmRpbXMsdT1lLmxlbmd0aD4yP2VbMl06dm9pZCAwLGg9dT9sP1tNYXRoLmNlaWwoQy5zaXplKHUuZGltcykvNCldOnUuZGltczp2b2lkIDAsXz1tLmxlbmd0aD09PTB8fG0ubGVuZ3RoPT09MSYmbVswXT09PTEseT1fPT09ITEmJm0ubGVuZ3RoPT09MSxnPW1lKGQpLHg9XyYmKCFsfHxnPT09NCksJD14P2c6MSx2PXgmJiFsP2c6MSxTPUUoXCJpbnB1dFwiLGw/MTI6bixwLmxlbmd0aCx2KSxUPUUoXCJzY2FsZVwiLGEsbS5sZW5ndGgpLEE9dT9FKFwiemVyb19wb2ludFwiLGw/MTI6bixoLmxlbmd0aCk6dm9pZCAwLGs9TShcIm91dHB1dFwiLGEsaS5sZW5ndGgsJCksUD1bUyxUXTtBJiZQLnB1c2goQSk7bGV0IEQ9W3AsbV07dSYmRC5wdXNoKGgpO2xldCBSPVt7dHlwZToxMixkYXRhOmQvJH0se3R5cGU6MTIsZGF0YTpyfSx7dHlwZToxMixkYXRhOnQuYmxvY2tTaXplfSwuLi5OKC4uLkQsaSldLEc9Sz0+e2xldCBqPVt7bmFtZTpcIm91dHB1dF9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImF4aXNcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiYmxvY2tfc2l6ZVwiLHR5cGU6XCJ1MzJcIn1dO3JldHVybmBcbiAgICAgICR7Sy5yZWdpc3RlclVuaWZvcm1zKGopLmRlY2xhcmVWYXJpYWJsZXMoLi4uUCxrKX1cbiAgICAgICR7Sy5tYWluU3RhcnQoKX1cbiAgICAgICAgICAke0suZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7ay5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcblxuICAgICAgICAgIC8vIFNldCBpbnB1dCB4XG4gICAgICAgICAgJHsoKCk9Pmw/YFxuICAgICAgICAgICAgbGV0IGlucHV0ID0gJHtTLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeCAvIDRcIil9O1xuICAgICAgICAgICAgbGV0IHhfdmVjID0gJHtvP1widW5wYWNrNHhJOChpbnB1dClcIjpcInVucGFjazR4VTgoaW5wdXQpXCJ9O1xuICAgICAgICAgICAgbGV0IHhfdmFsdWUgPSAkeyQ9PT0xP1wieF92ZWNbZ2xvYmFsX2lkeCAlIDRdXCI6XCJ4X3ZlY1wifTtgOmBsZXQgeF92YWx1ZSA9ICR7Uy5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIil9O2ApKCl9O1xuXG4gICAgICAgICAgLy8gU2V0IHNjYWxlIGlucHV0XG4gICAgICAgICAgJHsoKCk9Pl8/YGxldCBzY2FsZV92YWx1ZT0gJHtULmdldEJ5T2Zmc2V0KFwiMFwiKX1gOnk/YFxuICAgICAgICAgICAgbGV0IHNjYWxlX2luZGV4ID0gJHtrLmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLFwidW5pZm9ybXMuYXhpc1wiKX07XG4gICAgICAgICAgICBsZXQgc2NhbGVfdmFsdWU9ICR7VC5nZXRCeU9mZnNldChcInNjYWxlX2luZGV4XCIpfTtgOmBcbiAgICAgICAgICAgIHZhciBzY2FsZV9pbmRpY2VzOiAke1QudHlwZS5pbmRpY2VzfSA9IG91dHB1dF9pbmRpY2VzO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gJHtULmluZGljZXNHZXQoXCJzY2FsZV9pbmRpY2VzXCIsXCJ1bmlmb3Jtcy5heGlzXCIpfSAvIHVuaWZvcm1zLmJsb2NrX3NpemU7XG4gICAgICAgICAgICAke1QuaW5kaWNlc1NldChcInNjYWxlX2luZGljZXNcIixcInVuaWZvcm1zLmF4aXNcIixcImluZGV4XCIpfTtcbiAgICAgICAgICAgIGxldCBzY2FsZV92YWx1ZT0gJHtULmdldEJ5SW5kaWNlcyhcInNjYWxlX2luZGljZXNcIil9O2ApKCl9O1xuXG4gICAgICAgICAgLy8gU2V0IHplcm8tcG9pbnQgaW5wdXRcbiAgICAgICAgICAkeygoKT0+QT9fP2w/YFxuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2lucHV0ID0gJHtBLmdldEJ5T2Zmc2V0KFwiMFwiKX07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmVjID0gICR7bz9cInVucGFjazR4STgoemVyb19wb2ludF9pbnB1dClcIjpcInVucGFjazR4VTgoemVyb19wb2ludF9pbnB1dClcIn07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmFsdWU9IHplcm9fcG9pbnRfdmVjWzBdYDpgbGV0IHplcm9fcG9pbnRfdmFsdWUgPSAke0EuZ2V0QnlPZmZzZXQoXCIwXCIpfWA6eT9sP2BcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9pbmRleCA9ICR7ay5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixcInVuaWZvcm1zLmF4aXNcIil9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2lucHV0ID0gJHtBLmdldEJ5T2Zmc2V0KFwiemVyb19wb2ludF9pbmRleCAvIDRcIil9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3ZlYyA9ICAke28/XCJ1bnBhY2s0eEk4KHplcm9fcG9pbnRfaW5wdXQpXCI6XCJ1bnBhY2s0eFU4KHplcm9fcG9pbnRfaW5wdXQpXCJ9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3ZhbHVlID0gemVyb19wb2ludF92ZWNbemVyb19wb2ludF9pbmRleCAlIDRdYDpgXG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfaW5kZXggPSAke2suaW5kaWNlc0dldChcIm91dHB1dF9pbmRpY2VzXCIsXCJ1bmlmb3Jtcy5heGlzXCIpfTtcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF92YWx1ZSA9ICR7QS5nZXRCeU9mZnNldChcInplcm9fcG9pbnRfaW5kZXhcIil9O2A6bD9gXG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfb2Zmc2V0ID0gJHtULmluZGljZXNUb09mZnNldChcInNjYWxlX2luZGljZXNcIil9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2lucHV0ID0gJHtBLmdldEJ5T2Zmc2V0KFwiemVyb19wb2ludF9vZmZzZXQgLyA0XCIpfTtcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF92ZWMgPSAke28/XCJ1bnBhY2s0eEk4KHplcm9fcG9pbnRfaW5wdXQpXCI6XCJ1bnBhY2s0eFU4KHplcm9fcG9pbnRfaW5wdXQpXCJ9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3ZhbHVlID0gemVyb19wb2ludF92ZWNbemVyb19wb2ludF9vZmZzZXQgJSA0XTtgOmBsZXQgemVyb19wb2ludF92YWx1ZSA9ICR7QS5nZXRCeUluZGljZXMoXCJzY2FsZV9pbmRpY2VzXCIpfTtgOmBsZXQgemVyb19wb2ludF92YWx1ZSA9ICR7bD9vP1wiaTMyXCI6XCJ1MzJcIjpTLnR5cGUudmFsdWV9KDApO2ApKCl9O1xuICAgICAgLy8gQ29tcHV0ZSBhbmQgd3JpdGUgb3V0cHV0XG4gICAgICAke2suc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsYCR7ay50eXBlLnZhbHVlfSh4X3ZhbHVlIC0gemVyb19wb2ludF92YWx1ZSkgKiBzY2FsZV92YWx1ZWApfTtcbiAgICAgIH1gfTtyZXR1cm57bmFtZTpcIkRlcXVhbnRpemVMaW5lYXJcIixzaGFkZXJDYWNoZTp7aGludDp0LmNhY2hlS2V5LGlucHV0RGVwZW5kZW5jaWVzOkE/W1wicmFua1wiLFwicmFua1wiLFwicmFua1wiXTpbXCJyYW5rXCIsXCJyYW5rXCJdfSxnZXRTaGFkZXJTb3VyY2U6RyxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmksZGF0YVR5cGU6YX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGQvJC82NCkseToxLHo6MX0scHJvZ3JhbVVuaWZvcm1zOlJ9KX19LCRsPShlLHQpPT57VGgoZS5pbnB1dHMsdCksZS5jb21wdXRlKEloKGUuaW5wdXRzLHQpKX0seGw9ZT0+cmUoe2F4aXM6ZS5heGlzLGJsb2NrU2l6ZTplLmJsb2NrU2l6ZX0pfSk7dmFyIENoLEFoLFRsLElsPVUoKCk9PntcInVzZSBzdHJpY3RcIjtXZSgpO3RlKCk7YWUoKTtDaD0oZSx0LHIpPT57bGV0IG49ZT09PXQsbz1lPHQmJnI8MCxpPWU+dCYmcj4wO2lmKG58fG98fGkpdGhyb3cgbmV3IEVycm9yKFwiUmFuZ2UgdGhlc2UgaW5wdXRzJyBjb250ZW50cyBhcmUgaW52YWxpZC5cIil9LEFoPShlLHQscixuKT0+e2xldCBvPU1hdGguYWJzKE1hdGguY2VpbCgodC1lKS9yKSksaT1bb10sYT1vLGQ9W3t0eXBlOjEyLGRhdGE6YX0se3R5cGU6bixkYXRhOmV9LHt0eXBlOm4sZGF0YTpyfSwuLi5OKGkpXSxsPXA9PntsZXQgbT1NKFwib3V0cHV0XCIsbixpLmxlbmd0aCksdT1tLnR5cGUudmFsdWUsaD1be25hbWU6XCJvdXRwdXRTaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInN0YXJ0XCIsdHlwZTp1fSx7bmFtZTpcImRlbHRhXCIsdHlwZTp1fV07cmV0dXJuYFxuICAgICAgICAke3AucmVnaXN0ZXJVbmlmb3JtcyhoKS5kZWNsYXJlVmFyaWFibGVzKG0pfVxuICAgICAgICAke3AubWFpblN0YXJ0KCl9XG4gICAgICAgICR7cC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0U2l6ZVwiKX1cbiAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gdW5pZm9ybXMuc3RhcnQgKyAke3V9KGdsb2JhbF9pZHgpICogdW5pZm9ybXMuZGVsdGE7XG4gICAgICB9YH07cmV0dXJue25hbWU6XCJSYW5nZVwiLHNoYWRlckNhY2hlOntoaW50OmAke259YH0sZ2V0U2hhZGVyU291cmNlOmwsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczppLGRhdGFUeXBlOm59XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChhLzY0KX0scHJvZ3JhbVVuaWZvcm1zOmR9KX19LFRsPWU9PntsZXQgdD0wLHI9MCxuPTA7ZS5pbnB1dHNbMF0uZGF0YVR5cGU9PT02Pyh0PWUuaW5wdXRzWzBdLmdldEludDMyQXJyYXkoKVswXSxyPWUuaW5wdXRzWzFdLmdldEludDMyQXJyYXkoKVswXSxuPWUuaW5wdXRzWzJdLmdldEludDMyQXJyYXkoKVswXSk6ZS5pbnB1dHNbMF0uZGF0YVR5cGU9PT0xJiYodD1lLmlucHV0c1swXS5nZXRGbG9hdDMyQXJyYXkoKVswXSxyPWUuaW5wdXRzWzFdLmdldEZsb2F0MzJBcnJheSgpWzBdLG49ZS5pbnB1dHNbMl0uZ2V0RmxvYXQzMkFycmF5KClbMF0pLHZlLndlYmdwdS52YWxpZGF0ZUlucHV0Q29udGVudCYmQ2godCxyLG4pLGUuY29tcHV0ZShBaCh0LHIsbixlLmlucHV0c1swXS5kYXRhVHlwZSkse2lucHV0czpbXX0pfX0pO3ZhciBraCxFaCxDbCxBbCxrbD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtvZSgpO1NlKCk7YWUoKTtraD0oZSx0LHIsbik9PntpZihlIT09XCJub25lXCImJm4hPT1cImkzMlwiJiZuIT09XCJ1MzJcIiYmbiE9PVwiZjMyXCIpdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAke259IGlzIG5vdCBzdXBwb3J0ZWQgd2l0aCByZWR1Y3Rpb24gJHtlfS5gKTtsZXQgbz1ge1xuICAgICAgICAgICAgICAgIHZhciBvbGRWYWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgbG9vcCB7XG4gICAgICAgICAgICAgICAgICBsZXQgbmV3VmFsdWVGMzIgPWAsaT1gO1xuICAgICAgICAgICAgICAgICAgbGV0IG5ld1ZhbHVlID0gYml0Y2FzdDxpMzI+KG5ld1ZhbHVlRjMyKTtcbiAgICAgICAgICAgICAgICAgIGxldCByZXMgPSBhdG9taWNDb21wYXJlRXhjaGFuZ2VXZWFrKCYke3R9LCBvbGRWYWx1ZSwgbmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgaWYgcmVzLmV4Y2hhbmdlZCB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgb2xkVmFsdWUgPSByZXMub2xkX3ZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfWA7c3dpdGNoKGUpe2Nhc2VcIm5vbmVcIjpyZXR1cm5gJHt0fT0ke3J9O2A7Y2FzZVwiYWRkXCI6cmV0dXJuIG49PT1cImkzMlwifHxuPT09XCJ1MzJcIj9gYXRvbWljQWRkKCYke3R9LCBiaXRjYXN0PCR7bn0+KCR7cn0pKTtgOmBcbiAgICAgICAgICAgICAgJHtvfWJpdGNhc3Q8JHtufT4ob2xkVmFsdWUpICsgKCR7cn0pJHtpfWA7Y2FzZVwibWF4XCI6cmV0dXJuIG49PT1cImkzMlwifHxuPT09XCJ1MzJcIj9gYXRvbWljTWF4KCYke3R9LCBiaXRjYXN0PCR7bn0+KCR7cn0pKTtgOmBcbiAgICAgICAgICAgICAgICAke299bWF4KGJpdGNhc3Q8ZjMyPihvbGRWYWx1ZSksICgke3J9KSkke2l9YDtjYXNlXCJtaW5cIjpyZXR1cm4gbj09PVwiaTMyXCJ8fG49PT1cInUzMlwiP2BhdG9taWNNaW4oJiR7dH0sIGJpdGNhc3Q8JHtufT4oJHtyfSkpO2A6YCR7b31taW4oYml0Y2FzdDwke259PihvbGRWYWx1ZSksICgke3J9KSkke2l9YDtjYXNlXCJtdWxcIjpyZXR1cm5gJHtvfShiaXRjYXN0PCR7bn0+KG9sZFZhbHVlKSAqICgke3J9KSkke2l9YDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgUmVkdWN0aW9uICR7ZX0gaXMgbm90IHN1cHBvcnRlZC5gKX19LEVoPShlLHQpPT57bGV0IHI9ZVswXS5kaW1zLG49ZVsxXS5kaW1zLG89cixpPTEsYT1NYXRoLmNlaWwoQy5zaXplKG4pL2kpLGQ9bltuLmxlbmd0aC0xXSxsPUMuc2l6ZUZyb21EaW1lbnNpb24ocixkKSxwPVt7dHlwZToxMixkYXRhOmF9LHt0eXBlOjEyLGRhdGE6ZH0se3R5cGU6MTIsZGF0YTpsfSwuLi5OKGVbMV0uZGltcyxlWzJdLmRpbXMsbyldLG09dT0+e2xldCBoPUUoXCJpbmRpY2VzXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMubGVuZ3RoKSxfPUUoXCJ1cGRhdGVzXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMubGVuZ3RoLGkpLHk9dC5yZWR1Y3Rpb24hPT1cIm5vbmVcIiYmdC5yZWR1Y3Rpb24hPT1cIlwiP3JzKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxvLmxlbmd0aCk6TShcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsby5sZW5ndGgsaSk7cmV0dXJuYFxuICAgICAgJHt1LnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dF9zaXplXCIsXCJ1MzJcIikucmVnaXN0ZXJVbmlmb3JtKFwibGFzdF9pbmRleF9kaW1lbnNpb25cIixcInUzMlwiKS5yZWdpc3RlclVuaWZvcm0oXCJudW1fdXBkYXRlc19lbGVtZW50c1wiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoaCxfLHkpfVxuICAgICAgJHt1Lm1haW5TdGFydCgpfVxuICAgICAgICAke3UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICB2YXIgZGF0YV9vZmZzZXQgPSAwdTtcbiAgbGV0IGluZGljZXNfc3RhcnQgPSB1bmlmb3Jtcy5sYXN0X2luZGV4X2RpbWVuc2lvbiAqIGdsb2JhbF9pZHg7XG4gIGxldCBpbmRpY2VzX2VuZCA9IGluZGljZXNfc3RhcnQgKyB1bmlmb3Jtcy5sYXN0X2luZGV4X2RpbWVuc2lvbjtcbiAgZm9yICh2YXIgaSA9IGluZGljZXNfc3RhcnQ7IGkgPCBpbmRpY2VzX2VuZDsgaSsrKSB7XG4gICAgdmFyIGluZGV4ID0gaTMyKGluZGljZXNbaV0ueCk7XG4gICAgJHtlWzBdLmRpbXMubGVuZ3RoPT09MT9gXG4gICAgbGV0IGVsZW1lbnRfY291bnRfZGltID0gdW5pZm9ybXMub3V0cHV0X3N0cmlkZXM7XG4gICAgbGV0IGRpbV92YWx1ZSA9IHVuaWZvcm1zLm91dHB1dF9zaGFwZTtgOmBcbiAgICBsZXQgZWxlbWVudF9jb3VudF9kaW0gPSB1bmlmb3Jtcy5vdXRwdXRfc3RyaWRlc1tpIC0gaW5kaWNlc19zdGFydF07XG4gICAgbGV0IGRpbV92YWx1ZSA9IHVuaWZvcm1zLm91dHB1dF9zaGFwZVtpIC0gaW5kaWNlc19zdGFydCArIHVuaWZvcm1zLmxhc3RfaW5kZXhfZGltZW5zaW9uXTtgfVxuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICBpZiAoaW5kZXggPj0gaTMyKGRpbV92YWx1ZSkpIHtcbiAgICAgICAgaW5kZXggPSBpMzIoZGltX3ZhbHVlIC0gMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpbmRleCA8IC1pMzIoZGltX3ZhbHVlKSkge1xuICAgICAgICBpbmRleCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmRleCArPSBpMzIoZGltX3ZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZGF0YV9vZmZzZXQgKz0gdTMyKCh1MzIoaW5kZXgpICogZWxlbWVudF9jb3VudF9kaW0pKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwdTsgaSA8IHVuaWZvcm1zLm51bV91cGRhdGVzX2VsZW1lbnRzOyBpKyspIHtcbiAgICBsZXQgdmFsdWUgPSB1cGRhdGVzW3VuaWZvcm1zLm51bV91cGRhdGVzX2VsZW1lbnRzICogZ2xvYmFsX2lkeCArIGldO1xuICAgICR7a2godC5yZWR1Y3Rpb24sXCJvdXRwdXRbZGF0YV9vZmZzZXQgKyBpXVwiLFwidmFsdWVcIix5LnR5cGUudmFsdWUpfVxuICB9XG5cbiAgICAgIH1gfTtyZXR1cm57bmFtZTpcIlNjYXR0ZXJORFwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9XyR7dC5yZWR1Y3Rpb259YCxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCIsXCJyYW5rXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm8sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGEvNjQpfSxwcm9ncmFtVW5pZm9ybXM6cH0pLGdldFNoYWRlclNvdXJjZTptfX0sQ2w9ZT0+cmUoe3JlZHVjdGlvbjplLnJlZHVjdGlvbn0pLEFsPShlLHQpPT57ZS5jb21wdXRlKEVoKGUuaW5wdXRzLHQpLHtpbnB1dHM6W2UuaW5wdXRzWzFdLGUuaW5wdXRzWzJdXSxvdXRwdXRzOltdfSl9fSk7dmFyIFBoLHpoLE9oLERoLEJoLE1oLFJoLFVoLE5oLFZoLFdoLEVsLExoLEdoLEhoLEZoLHFoLFBsLHpsLE9sPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7U2UoKTthZSgpO1BoPShlLHQpPT57aWYoZS5ldmVyeShyPT5yPjB8fCgoKT0+e3Rocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBzY2FsZXMgaW5wdXQgdmFsdWVzIHRvIGJlIHBvc2l0aXZlXCIpfSkpLGUubGVuZ3RoPjApe2lmKHQubW9kZT09PVwibGluZWFyXCIpe2lmKCEoZS5sZW5ndGg9PT0yfHxlLmxlbmd0aD09PTN8fGUubGVuZ3RoPT09NCYmZVswXT09PTEmJmVbMV09PT0xfHxlLmxlbmd0aD09PTQmJmVbMF09PT0xJiZlWzNdPT09MXx8ZS5sZW5ndGg9PT01JiZlWzBdPT09MSYmZVsxXT09PTEpKXRocm93IG5ldyBFcnJvcihgRm9yIGxpbmVhciBtb2RlLCBSZXNpemUgcmVxdWlyZXMgc2NhbGVzIHRvIGJlIDJELCAzRCwgNEQgd2l0aCBlaXRoZXIgdHdvIG91dGVybW9zdCBvciBvbmUgaW5uZXJtb3N0IGFuZFxuICAgICAgICAgICAgb25lIG91dGVybW9zdCBzY2FsZSB2YWx1ZXMgZXF1YWwgdG8gMSwgb3IgNUQgd2l0aCB0d28gb3V0ZXJtb3N0IHNjYWxlIHZhbHVlcyBlcXVhbCB0byAxYCl9ZWxzZSBpZih0Lm1vZGU9PT1cImN1YmljXCImJiEoZS5sZW5ndGg9PT0yfHxlLmxlbmd0aD09PTQmJmVbMF09PT0xJiZlWzFdPT09MXx8ZS5sZW5ndGg9PT00JiZlWzBdPT09MSYmZVszXT09PTEpKXRocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBzY2FsZXMgaW5wdXQgc2l6ZSB0byBiZSAyIG9yIDQgZm9yIGN1YmljIG1vZGVcIil9fSx6aD0oZSx0LHIpPT57dC5ldmVyeShvPT5vPj0wJiZvPHJ8fCgoKT0+e3Rocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBheGVzIGlucHV0IHZhbHVlcyB0byBiZSBwb3NpdGl2ZSBhbmQgbGVzcyB0aGFuIHJhbmtcIil9KSk7bGV0IG49bmV3IEFycmF5KHIpLmZpbGwoMSk7cmV0dXJuIHQuZm9yRWFjaCgobyxpKT0+bltvXT1lW2ldKSxufSxPaD0oZSx0LHIsbixvLGkpPT57bGV0W2EsZCxsXT1yPjEwP1sxLDIsM106Wy0xLGUubGVuZ3RoPjE/MTotMSwtMV0scD1lWzBdLmRpbXMubGVuZ3RoO2lmKGE+MCYmZS5sZW5ndGg+YSYmZVthXS5kaW1zLmxlbmd0aD4wKWVbYV0uZ2V0RmxvYXQzMkFycmF5KCkuZm9yRWFjaChtPT5pLnB1c2gobSkpO2Vsc2UgaWYodC5jb29yZGluYXRlVHJhbnNmb3JtTW9kZT09PVwidGZfY3JvcF9hbmRfcmVzaXplXCIpdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIFJvSSBpbnB1dCB0byBiZSBzcGVjaWZpZWQgd2hlbiBjb29yZGluYXRlVHJhbnNmb3JtTW9kZSBpcyB0ZkNyb3BBbmRSZXNpemVcIik7aWYoZD4wJiZlLmxlbmd0aD5kJiZlW2RdLmRpbXMubGVuZ3RoPT09MSYmZVtkXS5kaW1zWzBdPjApe2lmKGVbZF0uZ2V0RmxvYXQzMkFycmF5KCkuZm9yRWFjaChtPT5uLnB1c2gobSkpLG4ubGVuZ3RoIT09MCYmbi5sZW5ndGghPT1wJiZyPj0xOCYmbi5sZW5ndGghPT10LmF4ZXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBzY2FsZXMgaW5wdXQgc2l6ZSB0byBiZSBzYW1lIGFzIGlucHV0IHJhbmsgb3IgYXhlcyBzaXplIGZvciBvcHNldCAxOCBhbmQgdXBcIik7UGgobix0KSx0LmF4ZXMubGVuZ3RoPjAmJnpoKG4sdC5heGVzLHApLmZvckVhY2goKG0sdSk9Pm5bdV09bSl9aWYobD4wJiZlLmxlbmd0aD5sJiZlW2xdLmRpbXMubGVuZ3RoPT09MSYmZVtsXS5kaW1zWzBdPjAmJihlW2xdLmdldEJpZ0ludDY0QXJyYXkoKS5mb3JFYWNoKG09Pm8ucHVzaChOdW1iZXIobSkpKSxvLmxlbmd0aCE9PTAmJm8ubGVuZ3RoIT09cCYmcj49MTgmJm8ubGVuZ3RoIT09dC5heGVzLmxlbmd0aCkpdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIHNpemVzIGlucHV0IHNpemUgdG8gYmUgc2FtZSBhcyBpbnB1dCByYW5rIG9yIGF4ZXMgc2l6ZSBmb3Igb3BzZXQgMTggYW5kIHVwXCIpO2lmKHQuYXhlcy5sZW5ndGg+MCl7aWYobi5sZW5ndGghPT0wJiZuLmxlbmd0aCE9PXQuYXhlcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKCdSZXNpemUgcmVxdWlyZXMgXCJzY2FsZXNcIiBpbnB1dCBzaXplIHRvIGJlIG9mIGF4ZXMgcmFuayB3aGVuIGF4ZXMgYXR0cmlidXRlcyBpcyBzcGVjaWZpZWQnKTtpZihvLmxlbmd0aCE9PTAmJm8ubGVuZ3RoIT09dC5heGVzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoJ1Jlc2l6ZSByZXF1aXJlcyBcInNpemVzXCIgaW5wdXQgc2l6ZSB0byBiZSBvZiByYW5rIGF4ZXMgcmFuayB3aGVuIGF4ZXMgYXR0cmlidXRlcyBpcyBzcGVjaWZpZWQnKX1pZih0eXBlb2YgbjxcInVcIiYmdHlwZW9mIG88XCJ1XCImJm4ubGVuZ3RoPjAmJm8ubGVuZ3RoPnApdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIG9ubHkgb2Ygc2NhbGVzIG9yIHNpemVzIHRvIGJlIHNwZWNpZmllZFwiKX0sRGg9KGUsdCk9PmBmbiBnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUoeFJlc2l6ZWQ6IHUzMiwgeFNjYWxlOiBmMzIsIGxlbmd0aFJlc2l6ZWQ6IHUzMixcbiAgICAgbGVuZ3RoT3JpZ2luYWw6IHUzMiwgcm9pU3RhcnQ6IGYzMiwgcm9pRW5kOiBmMzIpIC0+ICR7dH0geyBgKygoKT0+e3N3aXRjaChlKXtjYXNlXCJhc3ltbWV0cmljXCI6cmV0dXJuYHJldHVybiAke3R9KHhSZXNpemVkKSAvICR7dH0oeFNjYWxlKTtgO2Nhc2VcInB5dG9yY2hfaGFsZl9waXhlbFwiOnJldHVybmBpZiAobGVuZ3RoUmVzaXplZCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgke3R9KHhSZXNpemVkKSArIDAuNSkgLyAke3R9KHhTY2FsZSkgLSAwLjU7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMC4wO1xuICAgICAgICAgICAgICAgICAgfWA7Y2FzZVwidGZfaGFsZl9waXhlbF9mb3Jfbm5cIjpyZXR1cm5gcmV0dXJuICgke3R9KHhSZXNpemVkKSArIDAuNSkgLyAke3R9KHhTY2FsZSk7YDtjYXNlXCJhbGlnbl9jb3JuZXJzXCI6cmV0dXJuYGlmIChsZW5ndGhSZXNpemVkID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuMDtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSB3aG9sZSBwYXJ0IGFuZCB0aGUgZnJhY3Rpb25hbCBwYXJ0IGFyZSBjYWxjdWxhdGVkIHNlcGFyYXRlbHkgZHVlIHRvIGluYWNjdXJhY3kgb2YgZmxvYXRpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gcG9pbnQgZGl2aXNpb24uIEFzIGFuIGV4YW1wbGUsIGYzMigyMSkgLyBmMzIoNykgbWF5IGV2YWx1YXRlIHRvIDIuOTkuLi4gaW5zdGVhZCBvZiAzLCBjYXVzaW5nIGFuXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mZnNldC1ieS1vbmUgZXJyb3IgbGF0ZXIgaW4gZmxvb3IoKS5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHdob2xlID0gJHt0fSh4UmVzaXplZCAqIChsZW5ndGhPcmlnaW5hbCAtIDEpIC8gKGxlbmd0aFJlc2l6ZWQgLSAxKSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmcmFjdCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAke3R9KHhSZXNpemVkICogKGxlbmd0aE9yaWdpbmFsIC0gMSkgJSAobGVuZ3RoUmVzaXplZCAtIDEpKSAvICR7dH0obGVuZ3RoUmVzaXplZCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2hvbGUgKyBmcmFjdDtcbiAgICAgICAgICAgICAgICAgIH1gO2Nhc2VcInRmX2Nyb3BfYW5kX3Jlc2l6ZVwiOnJldHVybmBpZiAobGVuZ3RoUmVzaXplZCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR7dH0ocm9pU3RhcnQpICogJHt0fShsZW5ndGhPcmlnaW5hbCAtIDEpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICgke3R9KHhSZXNpemVkKSAqICR7dH0ocm9pRW5kIC0gcm9pU3RhcnQpICogJHt0fShsZW5ndGhPcmlnaW5hbCAtIDEpKSAvXG4gICAgICAgICAgICAgICAgICAgICAgICAke3R9KGxlbmd0aFJlc2l6ZWQgLSAxKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwLjUgKiAke3R9KHJvaVN0YXJ0ICsgcm9pRW5kKSAqICR7dH0obGVuZ3RoT3JpZ2luYWwgLSAxKTtcbiAgICAgICAgICAgICAgICAgIH1gO2Nhc2VcImhhbGZfcGl4ZWxfc3ltbWV0cmljXCI6cmV0dXJuYGNvbnN0IG91dHB1dFdpZHRoID0gJHt0fXhTY2FsZSAqICR7dH0obGVuZ3RoUmVzaXplZCk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBhZGp1c3RtZW50ID0gJHt0fShsZW5ndGhSZXNpemVkKSAvIG91dHB1dFdpZHRoO1xuICAgICAgICAgICAgICAgICAgY29uc3QgY2VudGVyID0gJHt0fShsZW5ndGhPcmlnaW5hbCkgLyAyO1xuICAgICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gY2VudGVyICogKDEgLSBhZGp1c3RtZW50KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBvZmZzZXQgKyAoKCR7dH0oeFJlc2l6ZWQpICsgMC41KSAvICR7dH0oeFNjYWxlKSkgLSAwLjU7YDtjYXNlXCJoYWxmX3BpeGVsXCI6cmV0dXJuYHJldHVybiAoKCR7dH0oeFJlc2l6ZWQpICsgMC41KSAvICR7dH0oeFNjYWxlKSkgLSAwLjU7YDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgQ29vcmRpbmF0ZSB0cmFuc2Zvcm0gbW9kZSAke2V9IGlzIG5vdCBzdXBwb3J0ZWRgKX19KSgpK1wifVwiLEJoPShlLHQscik9PmBmbiBnZXROZWFyZXN0UGl4ZWxGcm9tT3JpZ2luYWwoeE9yaWdpbmFsOiAke3J9LCBpc0Rvd25TYW1wbGU6IGJvb2wpIC0+ICR7cn0ge2ArKCgpPT57c3dpdGNoKGUpe2Nhc2VcInJvdW5kX3ByZWZlcl9jZWlsXCI6cmV0dXJuXCJpZiAoZnJhY3QoeE9yaWdpbmFsKSA9PSAwLjUpIHsgICAgICAgICAgICAgcmV0dXJuIGNlaWwoeE9yaWdpbmFsKTsgICAgICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgIHJldHVybiByb3VuZCh4T3JpZ2luYWwpOyAgICAgICAgICAgfVwiO2Nhc2VcImZsb29yXCI6cmV0dXJuXCJyZXR1cm4gZmxvb3IoeE9yaWdpbmFsKTtcIjtjYXNlXCJjZWlsXCI6cmV0dXJuXCJyZXR1cm4gY2VpbCh4T3JpZ2luYWwpO1wiO2Nhc2VcInJvdW5kX3ByZWZlcl9mbG9vclwiOnJldHVyblwiaWYgKGZyYWN0KHhPcmlnaW5hbCkgPT0gMC41KSB7ICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZsb29yKHhPcmlnaW5hbCk7ICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJvdW5kKHhPcmlnaW5hbCk7ICAgICAgICAgICAgICAgICAgIH1cIjtjYXNlXCJzaW1wbGVcIjpkZWZhdWx0OmlmKHQ8MTEpcmV0dXJuXCJpZiAoaXNEb3duU2FtcGxlKSAgICAgICAgICAgICAgICAgICAgIHsgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjZWlsKHhPcmlnaW5hbCk7ICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4T3JpZ2luYWw7ICAgICAgICAgICAgICAgICAgICAgfVwiO3Rocm93IG5ldyBFcnJvcihgTmVhcmVzdCBtb2RlICR7ZX0gaXMgbm90IHN1cHBvcnRlZGApfX0pKCkrXCJ9XCIsTWg9KGUsdCxyKT0+e2xldCBuPW5ldyBBcnJheShyKS5maWxsKDApLmNvbmNhdChuZXcgQXJyYXkocikuZmlsbCgxKSksbz1lLmxlbmd0aD09PTA/bjplLnNsaWNlKCk7cmV0dXJuIHQubGVuZ3RoPjA/KHQuZm9yRWFjaCgoaSxhKT0+e25baV09b1thXSxuW2Ercl09b1t0Lmxlbmd0aCthXX0pLG4pOm99LFJoPShlLHQscixuKT0+e2xldCBvPVtdO2lmKHIubGVuZ3RoPjApaWYobi5sZW5ndGg+MCl7aWYoZS5mb3JFYWNoKGk9Pm8ucHVzaChpKSksTWF0aC5tYXgoLi4ubik+ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiYXhlcyBpcyBvdXQgb2YgYm91bmRcIik7bi5mb3JFYWNoKChpLGEpPT5vW2ldPXJbYV0pfWVsc2Ugci5mb3JFYWNoKGk9Pm8ucHVzaChpKSk7ZWxzZXtpZih0Lmxlbmd0aD09PTApdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIGVpdGhlciBzY2FsZXMgb3Igc2l6ZXMuXCIpO289ZS5tYXAoKGksYSk9Pk1hdGgucm91bmQoaSp0W2FdKSl9cmV0dXJuIG99LFVoPShlLHQscik9PntsZXQgbj0oKCk9Pntzd2l0Y2goci5rZWVwQXNwZWN0UmF0aW9Qb2xpY3kpe2Nhc2VcIm5vdF9sYXJnZXJcIjpyZXR1cm4gci5heGVzLmxlbmd0aD4wP01hdGgubWluKC4uLnIuYXhlcy5tYXAoaT0+dFtpXSksTnVtYmVyLk1BWF9WQUxVRSk6TWF0aC5taW4oLi4udCxOdW1iZXIuTUFYX1ZBTFVFKTtjYXNlXCJub3Rfc21hbGxlclwiOnJldHVybiByLmF4ZXMubGVuZ3RoPjA/TWF0aC5tYXgoLi4uci5heGVzLm1hcChpPT50W2ldKSxOdW1iZXIuTUlOX1ZBTFVFKTpNYXRoLm1heCguLi50LE51bWJlci5NSU5fVkFMVUUpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBLZWVwIGFzcGVjdCByYXRpbyBwb2xpY3kgJHtyLmtlZXBBc3BlY3RSYXRpb1BvbGljeX0gaXMgbm90IHN1cHBvcnRlZGApfX0pKCk7dC5maWxsKDEsMCx0Lmxlbmd0aCk7bGV0IG89ZS5zbGljZSgpO3JldHVybiByLmF4ZXMubGVuZ3RoPjA/KHIuYXhlcy5mb3JFYWNoKGk9PnRbaV09biksci5heGVzLmZvckVhY2goaT0+b1tpXT1NYXRoLnJvdW5kKGVbaV0qdFtpXSkpKToodC5maWxsKG4sMCx0Lmxlbmd0aCksby5mb3JFYWNoKChpLGEpPT5vW2FdPU1hdGgucm91bmQoaSp0W2FdKSkpLG99LE5oPShlLHQscixuLG8pPT5gXG4gICAgZm4gY2FsY3VsYXRlT3JpZ2luYWxJbmRpY2VzRnJvbU91dHB1dEluZGljZXMob3V0cHV0X2luZGljZXM6ICR7ZS50eXBlLmluZGljZXN9KSAtPiBhcnJheTwke2UudHlwZS52YWx1ZX0sICR7ci5sZW5ndGh9PiB7XG4gICAgICB2YXIgb3JpZ2luYWxfaW5kaWNlczogYXJyYXk8JHtlLnR5cGUudmFsdWV9LCAke3IubGVuZ3RofT47XG4gICAgICBmb3IgKHZhciBpOnUzMiA9IDA7IGkgPCAke3IubGVuZ3RofTsgaSsrKSB7XG4gICAgICAgIHZhciBvdXRwdXRfaW5kZXggPSAke2UuaW5kaWNlc0dldChcIm91dHB1dF9pbmRpY2VzXCIsXCJpXCIpfTtcbiAgICAgICAgdmFyIHNjYWxlID0gJHtGKFwidW5pZm9ybXMuc2NhbGVzXCIsXCJpXCIsbil9O1xuICAgICAgICB2YXIgcm9pX2xvdyA9ICR7RihcInVuaWZvcm1zLnJvaVwiLFwiaVwiLG8pfTtcbiAgICAgICAgdmFyIHJvaV9oaSA9ICR7RihcInVuaWZvcm1zLnJvaVwiLGBpICsgJHt0Lmxlbmd0aH1gLG8pfTtcbiAgICAgICAgaWYgKHNjYWxlID09IDEuMCkge1xuICAgICAgICAgIG9yaWdpbmFsX2luZGljZXNbaV0gPSAke2UudHlwZS52YWx1ZX0ob3V0cHV0X2luZGV4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgaW5wdXRfc2hhcGVfaSA9ICR7RihcInVuaWZvcm1zLmlucHV0X3NoYXBlXCIsXCJpXCIsdC5sZW5ndGgpfTtcbiAgICAgICAgICB2YXIgb3V0cHV0X3NoYXBlX2kgPSAke0YoXCJ1bmlmb3Jtcy5vdXRwdXRfc2hhcGVcIixcImlcIixyLmxlbmd0aCl9O1xuICAgICAgICAgIG9yaWdpbmFsX2luZGljZXNbaV0gPSBnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUob3V0cHV0X2luZGV4LCBzY2FsZSwgb3V0cHV0X3NoYXBlX2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dF9zaGFwZV9pLCByb2lfbG93LCByb2lfaGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ2luYWxfaW5kaWNlcztcbiAgICB9YCxWaD0oZSx0LHIsbixvLGksYSk9PmBcbiAgICBmbiBjYWxjdWxhdGVJbnB1dEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlczogJHt0LnR5cGUuaW5kaWNlc30pIC0+ICR7ZS50eXBlLmluZGljZXN9IHtcbiAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2UudHlwZS5pbmRpY2VzfTtcbiAgICAgIGZvciAodmFyIGk6dTMyID0gMDsgaSA8ICR7bi5sZW5ndGh9OyBpKyspIHtcbiAgICAgICAgdmFyIG91dHB1dF9pbmRleCA9ICR7dC5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixcImlcIil9O1xuICAgICAgICB2YXIgaW5wdXRfaW5kZXg6IHUzMjtcbiAgICAgICAgdmFyIHNjYWxlID0gJHtGKFwidW5pZm9ybXMuc2NhbGVzXCIsXCJpXCIsbyl9O1xuICAgICAgICBpZiAoc2NhbGUgPT0gMS4wKSB7XG4gICAgICAgICAgaW5wdXRfaW5kZXggPSBvdXRwdXRfaW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHJvaV9sb3cgPSAke0YoXCJ1bmlmb3Jtcy5yb2lcIixcImlcIixpKX07XG4gICAgICAgICAgdmFyIHJvaV9oaSA9ICR7RihcInVuaWZvcm1zLnJvaVwiLGBpICsgJHtyLmxlbmd0aH1gLGkpfTtcbiAgICAgICAgICB2YXIgaW5wdXRfc2hhcGVfaSA9ICR7RihcInVuaWZvcm1zLmlucHV0X3NoYXBlXCIsXCJpXCIsci5sZW5ndGgpfTtcbiAgICAgICAgICB2YXIgb3V0cHV0X3NoYXBlX2kgPSAke0YoXCJ1bmlmb3Jtcy5vdXRwdXRfc2hhcGVcIixcImlcIixuLmxlbmd0aCl9O1xuICAgICAgICAgIHZhciBvcmlnaW5hbF9pZHggPSBnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUob3V0cHV0X2luZGV4LCBzY2FsZSwgb3V0cHV0X3NoYXBlX2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dF9zaGFwZV9pLCByb2lfbG93LCByb2lfaGkpO1xuICAgICAgICAgIGlmICghJHthfSB8fCAob3JpZ2luYWxfaWR4ID49IDAgJiYgb3JpZ2luYWxfaWR4IDwgJHt0LnR5cGUudmFsdWV9KGlucHV0X3NoYXBlX2kpKSkge1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsX2lkeCA8IDApIHtcbiAgICAgICAgICAgICAgaW5wdXRfaW5kZXggPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcmlnaW5hbF9pZHggPiAke3QudHlwZS52YWx1ZX0oaW5wdXRfc2hhcGVfaSAtIDEpKSB7XG4gICAgICAgICAgICAgIGlucHV0X2luZGV4ID0gaW5wdXRfc2hhcGVfaSAtIDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpbnB1dF9pbmRleCA9IHUzMihnZXROZWFyZXN0UGl4ZWxGcm9tT3JpZ2luYWwob3JpZ2luYWxfaWR4LCBzY2FsZSA8IDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXRfaW5kZXggPSB1MzIob3JpZ2luYWxfaWR4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgJHtlLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsXCJpXCIsXCIgaW5wdXRfaW5kZXhcIil9XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5wdXRfaW5kaWNlcztcbiAgICB9YCxXaD0oZSx0KT0+YFxuICAgIGZuIGNoZWNrSW5wdXRJbmRpY2VzKGlucHV0X2luZGljZXM6ICR7ZS50eXBlLmluZGljZXN9KSAtPiBib29sIHtcbiAgICAgIGZvciAodmFyIGk6dTMyID0gMDsgaSA8ICR7dC5sZW5ndGh9OyBpKyspIHtcbiAgICAgICAgdmFyIGlucHV0X2luZGV4ID0gJHtlLmluZGljZXNHZXQoXCJpbnB1dF9pbmRpY2VzXCIsXCJpXCIpfTtcbiAgICAgICAgaWYgKGlucHV0X2luZGV4IDwgMCB8fCBpbnB1dF9pbmRleCA+PSAke0YoXCJ1bmlmb3Jtcy5pbnB1dF9zaGFwZVwiLFwiaVwiLHQubGVuZ3RoKX0pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1gLEVsPShlLHQscixuKT0+ZS5yYW5rPm4/YFxuICAgICR7ZS5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLHQsXCJjaGFubmVsXCIpfTtcbiAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixyLFwiYmF0Y2hcIil9O1xuYDpcIlwiLExoPShlLHQscixuLG8pPT57bGV0W2EsZCxsLHBdPXIubGVuZ3RoPT09Mj9bLTEsMCwxLC0xXTpbMCwyLDMsMV0sbT1lLnR5cGUudmFsdWU7cmV0dXJuYFxuICAgIGZuIGdldElucHV0VmFsdWUoYmF0Y2g6IHUzMiwgY2hhbm5lbDogdTMyLCByb3c6IHUzMiwgY29sOiB1MzIpIC0+ICR7bX0ge1xuICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7ZS50eXBlLmluZGljZXN9O1xuICAgICAgJHtlLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsZCxgbWF4KDAsIG1pbihyb3csICR7cltkXX0gLSAxKSlgKX07XG4gICAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixsLGBtYXgoMCwgbWluKGNvbCwgJHtyW2xdfSAtIDEpKWApfTtcbiAgICAgICR7RWwoZSxwLGEsMil9XG4gICAgICByZXR1cm4gJHtlLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O1xuICAgIH1cblxuICAgIGZuIGJpbGluZWFySW50ZXJwb2xhdGlvbihvdXRwdXRfaW5kaWNlczogJHt0LnR5cGUuaW5kaWNlc30pIC0+ICR7bX0ge1xuICAgICAgdmFyIG9yaWdpbmFsSW5kaWNlcyA9IGNhbGN1bGF0ZU9yaWdpbmFsSW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzKTtcbiAgICAgIHZhciByb3c6JHttfSA9IG9yaWdpbmFsSW5kaWNlc1ske2R9XTtcbiAgICAgIHZhciBjb2w6JHttfSA9IG9yaWdpbmFsSW5kaWNlc1ske2x9XTtcbiAgICAgICR7bj9gaWYgKHJvdyA8IDAgfHwgcm93ID4gKCR7cltkXX0gLSAxKSB8fCBjb2wgPCAwIHx8IGNvbCA+ICgke3JbbF19IC0gMSkpIHtcbiAgICAgICAgcmV0dXJuICR7b307XG4gICAgICB9YDpcIlwifTtcbiAgICAgIHJvdyA9IG1heCgwLCBtaW4ocm93LCAke3JbZF19IC0gMSkpO1xuICAgICAgY29sID0gbWF4KDAsIG1pbihjb2wsICR7cltsXX0gLSAxKSk7XG4gICAgICB2YXIgcm93MTogdTMyID0gdTMyKHJvdyk7XG4gICAgICB2YXIgY29sMTogdTMyID0gdTMyKGNvbCk7XG4gICAgICB2YXIgcm93MjogdTMyID0gdTMyKHJvdyArIDEpO1xuICAgICAgdmFyIGNvbDI6IHUzMiA9IHUzMihjb2wgKyAxKTtcbiAgICAgIHZhciBjaGFubmVsOiB1MzIgPSAke3IubGVuZ3RoPjI/YHUzMihvcmlnaW5hbEluZGljZXNbJHtwfV0pYDpcIjBcIn07XG4gICAgICB2YXIgYmF0Y2g6IHUzMiA9ICAke3IubGVuZ3RoPjI/YHUzMihvcmlnaW5hbEluZGljZXNbJHthfV0pYDpcIjBcIn07XG4gICAgICB2YXIgeDExOiAke219ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgcm93MSwgY29sMSk7XG4gICAgICB2YXIgeDEyOiAke219ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgcm93MSwgY29sMik7XG4gICAgICB2YXIgeDIxOiAke219ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgcm93MiwgY29sMSk7XG4gICAgICB2YXIgeDIyOiAke219ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgcm93MiwgY29sMik7XG4gICAgICB2YXIgZHgxOiAke219ID0gYWJzKHJvdyAtICR7bX0ocm93MSkpO1xuICAgICAgdmFyIGR4MjogJHttfSA9IGFicygke219KHJvdzIpIC0gcm93KTtcbiAgICAgIHZhciBkeTE6ICR7bX0gPSBhYnMoY29sIC0gJHttfShjb2wxKSk7XG4gICAgICB2YXIgZHkyOiAke219ID0gYWJzKCR7bX0oY29sMikgLSBjb2wpO1xuICAgICAgaWYgKHJvdzEgPT0gcm93Mikge1xuICAgICAgICBkeDEgPSAwLjU7XG4gICAgICAgIGR4MiA9IDAuNTtcbiAgICAgIH1cbiAgICAgIGlmIChjb2wxID09IGNvbDIpIHtcbiAgICAgICAgZHkxID0gMC41O1xuICAgICAgICBkeTIgPSAwLjU7XG4gICAgICB9XG4gICAgICByZXR1cm4gKHgxMSAqIGR4MiAqIGR5MiArIHgxMiAqIGR4MiAqIGR5MSArIHgyMSAqIGR4MSAqIGR5MiArIHgyMiAqIGR4MSAqIGR5MSk7XG4gICAgfWB9LEdoPShlLHQscixuLG8saSxhLGQsbCxwKT0+e2xldCBtPXIubGVuZ3RoPT09Mix1PSEwLFtoLF9dPW0/WzAsMV06dT9bMiwzXTpbMSwyXSx5PWUudHlwZS52YWx1ZSxnPXg9PntsZXQgJD14PT09aD9cInJvd1wiOlwiY29sXCI7cmV0dXJuYFxuICAgICAgZm4gJHskfUN1YmljSW50ZXJwb2xhdGlvbihpbnB1dF9pbmRpY2VzOiAke2UudHlwZS5pbmRpY2VzfSwgb3V0cHV0X2luZGljZXM6ICR7dC50eXBlLmluZGljZXN9KSAtPiAke3l9IHtcbiAgICAgICAgdmFyIG91dHB1dF9pbmRleCA9ICR7dC5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIix4KX07XG4gICAgICAgIHZhciBvcmlnaW5hbElkeDogJHt5fSA9IGdldE9yaWdpbmFsQ29vcmRpbmF0ZUZyb21SZXNpemVkQ29vcmRpbmF0ZShvdXRwdXRfaW5kZXgsICR7b1t4XX0sXG4gICAgICAgICR7blt4XX0sICR7clt4XX0sICR7aVt4XX0sICR7aVt4XX0gKyAke3IubGVuZ3RofSk7XG4gICAgICAgIHZhciBmcmFjdE9yaWdpbmFsSWR4OiAke3l9ID0gb3JpZ2luYWxJZHggLSBmbG9vcihvcmlnaW5hbElkeCk7XG4gICAgICAgIHZhciBjb2VmcyA9IGdldEN1YmljSW50ZXJwb2xhdGlvbkNvZWZzKGZyYWN0T3JpZ2luYWxJZHgpO1xuXG4gICAgICAgIGlmICgke2R9ICYmIChvcmlnaW5hbElkeCA8IDAgfHwgb3JpZ2luYWxJZHggPiAoJHtyW3hdfSAtIDEpKSkge1xuICAgICAgICAgIHJldHVybiAke2x9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXRhOiBhcnJheTwke3l9LCA0PiA9IGFycmF5PCR7eX0sIDQ+KDAuMCwgMC4wLCAwLjAsIDAuMCk7XG4gICAgICAgIGZvciAodmFyIGk6IGkzMiA9IC0xOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgdmFyICR7JH06ICR7eX0gPSBvcmlnaW5hbElkeCArICR7eX0oaSk7XG4gICAgICAgICAgaWYgKCR7JH0gPCAwIHx8ICR7JH0gPj0gJHtyW3hdfSkge1xuICAgICAgICAgICAgJHsoKCk9PnA/YGNvZWZzW2kgKyAxXSA9IDAuMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO2A6ZD9gcmV0dXJuICR7bH07YDpgJHskfSA9IG1heCgwLCBtaW4oJHskfSwgJHtyW3hdfSAtIDEpKTtgKSgpfTtcbiAgICAgICAgICB9XG4gICAgICAgIHZhciBpbnB1dF9pbmRpY2VzX2NvcHk6ICR7ZS50eXBlLmluZGljZXN9ID0gaW5wdXRfaW5kaWNlcztcbiAgICAgICAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNfY29weVwiLHgsYHUzMigkeyR9KWApfTtcbiAgICAgICAgICBkYXRhW2kgKyAxXSA9ICR7eD09PWg/ZS5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzX2NvcHlcIik6XCJyb3dDdWJpY0ludGVycG9sYXRpb24oaW5wdXRfaW5kaWNlc19jb3B5LCBvdXRwdXRfaW5kaWNlcylcIn07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1YmljSW50ZXJwb2xhdGlvbjFEKGRhdGEsIGNvZWZzKTtcbiAgICAgIH1gfTtyZXR1cm5gXG4gICAgJHtnKGgpfTtcbiAgICAke2coXyl9O1xuICBmbiBnZXRDdWJpY0ludGVycG9sYXRpb25Db2VmcyhzOiAke3l9KSAtPiBhcnJheTwke3l9LCA0PiB7XG4gICAgdmFyIGFic1MgPSBhYnMocyk7XG4gICAgdmFyIGNvZWZmczogYXJyYXk8JHt5fSwgND4gPSBhcnJheTwke3l9LCA0PigwLjAsIDAuMCwgMC4wLCAwLjApO1xuICAgIHZhciBvbmVNaW51c0Fic1M6ICR7eX0gPSAxLjAgLSBhYnNTO1xuICAgIHZhciB0d29NaW51c0Fic1M6ICR7eX0gPSAyLjAgLSBhYnNTO1xuICAgIHZhciBvbmVQbHVzQWJzUzogJHt5fSA9IDEuMCArIGFic1M7XG4gICAgY29lZmZzWzBdID0gKCgke2F9ICogb25lUGx1c0Fic1MgLSA1ICogJHthfSkgKiBvbmVQbHVzQWJzUyArIDggKiAke2F9KSAqIG9uZVBsdXNBYnNTIC0gNCAqICR7YX07XG4gICAgY29lZmZzWzFdID0gKCgke2F9ICsgMikgKiBhYnNTIC0gKCR7YX0gKyAzKSkgKiBhYnNTICogYWJzUyArIDE7XG4gICAgY29lZmZzWzJdID0gKCgke2F9ICsgMikgKiBvbmVNaW51c0Fic1MgLSAoJHthfSArIDMpKSAqIG9uZU1pbnVzQWJzUyAqIG9uZU1pbnVzQWJzUyArIDE7XG4gICAgY29lZmZzWzNdID0gKCgke2F9ICogdHdvTWludXNBYnNTIC0gNSAqICR7YX0pICogdHdvTWludXNBYnNTICsgOCAqICR7YX0pICogdHdvTWludXNBYnNTIC0gNCAqICR7YX07XG4gICAgcmV0dXJuIGNvZWZmcztcbiAgfVxuXG4gIGZuIGN1YmljSW50ZXJwb2xhdGlvbjFEKHg6IGFycmF5PCR7eX0sIDQ+LCBjb2VmczogYXJyYXk8JHt5fSwgND4pIC0+ICR7eX0ge1xuICAgIHZhciBjb2Vmc1N1bTogJHt5fSA9IGNvZWZzWzBdICsgY29lZnNbMV0gKyBjb2Vmc1syXSArIGNvZWZzWzNdO1xuICAgIHJldHVybiAoeFswXSAqIGNvZWZzWzBdICsgeFsxXSAqIGNvZWZzWzFdKyB4WzJdICogY29lZnNbMl0rIHhbM10gKiBjb2Vmc1szXSkgLyBjb2Vmc1N1bTtcbiAgfVxuXG4gIGZuIGJpY3ViaWNJbnRlcnBvbGF0aW9uKG91dHB1dF9pbmRpY2VzOiAke3QudHlwZS5pbmRpY2VzfSkgLT4gJHt5fSB7XG4gICAgdmFyIGlucHV0X2luZGljZXM6ICR7ZS50eXBlLmluZGljZXN9ID0gb3V0cHV0X2luZGljZXM7XG4gICAgcmV0dXJuIGNvbEN1YmljSW50ZXJwb2xhdGlvbihpbnB1dF9pbmRpY2VzLCBvdXRwdXRfaW5kaWNlcyk7XG4gIH1cbiAgICBgfSxIaD0oZSx0LHIsbixvKT0+e2xldFthLGQsbCxwLG1dPXIubGVuZ3RoPT09Mz9bLTEsMCwxLDIsLTFdOlswLDIsMyw0LDFdLHU9ZS50eXBlLnZhbHVlO3JldHVybmBcbiAgICBmbiBnZXRJbnB1dFZhbHVlKGJhdGNoOiB1MzIsIGNoYW5uZWw6IHUzMiwgZGVwdGg6dTMyLCBoZWlnaHQ6IHUzMiwgd2lkdGg6IHUzMikgLT4gJHt1fSB7XG4gICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc307XG4gICAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixkLGBtYXgoMCwgbWluKGRlcHRoLCAke3JbZF19IC0gMSkpYCl9O1xuICAgICAgJHtlLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsbCxgbWF4KDAsIG1pbihoZWlnaHQsICR7cltsXX0gLSAxKSlgKX07XG4gICAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixwLGBtYXgoMCwgbWluKHdpZHRoLCAke3JbcF19IC0gMSkpYCl9O1xuICAgICAgJHtFbChlLG0sYSwzKX1cbiAgICAgIHJldHVybiAke2UuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07XG4gICAgfVxuXG4gICAgZm4gdHJpbGluZWFySW50ZXJwb2xhdGlvbihvdXRwdXRfaW5kaWNlczogJHt0LnR5cGUuaW5kaWNlc30pIC0+ICR7dX0ge1xuICAgICAgdmFyIG9yaWdpbmFsSW5kaWNlcyA9IGNhbGN1bGF0ZU9yaWdpbmFsSW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzKTtcbiAgICAgIHZhciBkZXB0aDoke3V9ID0gb3JpZ2luYWxJbmRpY2VzWyR7ZH1dO1xuICAgICAgdmFyIGhlaWdodDoke3V9ID0gb3JpZ2luYWxJbmRpY2VzWyR7bH1dO1xuICAgICAgdmFyIHdpZHRoOiR7dX0gPSBvcmlnaW5hbEluZGljZXNbJHtwfV07XG4gICAgICAke24/YGlmIChkZXB0aCA8IDAgfHwgZGVwdGggPiAoJHtyW2RdfSAtIDEpIHx8IGhlaWdodCA8IDAgfHwgaGVpZ2h0ID4gKCR7cltsXX0gLSAxKSB8fCB3aWR0aCA8IDAgfHwgKHdpZHRoID4gJHtyW3BdfSAtIDEpKSB7XG4gICAgICByZXR1cm4gJHtvfTtcbiAgICAgICAgfWA6XCJcIn07XG5cbiAgICBkZXB0aCA9IG1heCgwLCBtaW4oZGVwdGgsICR7cltkXX0gLSAxKSk7XG4gICAgICBoZWlnaHQgPSBtYXgoMCwgbWluKGhlaWdodCwgJHtyW2xdfSAtIDEpKTtcbiAgICAgIHdpZHRoID0gbWF4KDAsIG1pbih3aWR0aCwgJHtyW3BdfSAtIDEpKTtcbiAgICAgIHZhciBkZXB0aDE6IHUzMiA9IHUzMihkZXB0aCk7XG4gICAgICB2YXIgaGVpZ2h0MTogdTMyID0gdTMyKGhlaWdodCk7XG4gICAgICB2YXIgd2lkdGgxOiB1MzIgPSB1MzIod2lkdGgpO1xuICAgICAgdmFyIGRlcHRoMjogdTMyID0gdTMyKGRlcHRoICsgMSk7XG4gICAgICB2YXIgaGVpZ2h0MjogdTMyID0gdTMyKGhlaWdodCArIDEpO1xuICAgICAgdmFyIHdpZHRoMjogdTMyID0gdTMyKHdpZHRoICsgMSk7XG4gICAgICB2YXIgY2hhbm5lbDogdTMyID0gJHtyLmxlbmd0aD4zP2B1MzIob3JpZ2luYWxJbmRpY2VzWyR7bX1dKWA6XCIwXCJ9O1xuICAgICAgdmFyIGJhdGNoOiB1MzIgPSAgJHtyLmxlbmd0aD4zP2B1MzIob3JpZ2luYWxJbmRpY2VzWyR7YX1dKWA6XCIwXCJ9O1xuXG4gICAgICB2YXIgeDExMTogJHt1fSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMSwgaGVpZ2h0MSwgd2lkdGgxKTtcbiAgICAgIHZhciB4MTEyOiAke3V9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgxLCBoZWlnaHQxLCB3aWR0aDIpO1xuICAgICAgdmFyIHgxMjE6ICR7dX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDEsIGhlaWdodDIsIHdpZHRoMSk7XG4gICAgICB2YXIgeDEyMjogJHt1fSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMSwgaGVpZ2h0Miwgd2lkdGgyKTtcbiAgICAgIHZhciB4MjExOiAke3V9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgyLCBoZWlnaHQxLCB3aWR0aDEpO1xuICAgICAgdmFyIHgyMTI6ICR7dX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDIsIGhlaWdodDEsIHdpZHRoMik7XG4gICAgICB2YXIgeDIyMTogJHt1fSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMiwgaGVpZ2h0Miwgd2lkdGgxKTtcbiAgICAgIHZhciB4MjIyOiAke3V9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgyLCBoZWlnaHQyLCB3aWR0aDIpO1xuICAgICAgdmFyIGR4MTogJHt1fSA9IGFicyhkZXB0aCAtICR7dX0oZGVwdGgxKSk7XG4gICAgICB2YXIgZHgyOiAke3V9ID0gYWJzKCR7dX0oZGVwdGgyKSAtIGRlcHRoKTtcbiAgICAgIHZhciBkeTE6ICR7dX0gPSBhYnMoaGVpZ2h0IC0gJHt1fShoZWlnaHQxKSk7XG4gICAgICB2YXIgZHkyOiAke3V9ID0gYWJzKCR7dX0oaGVpZ2h0MikgLSBoZWlnaHQpO1xuICAgICAgdmFyIGR6MTogJHt1fSA9IGFicyh3aWR0aCAtICR7dX0od2lkdGgxKSk7XG4gICAgICB2YXIgZHoyOiAke3V9ID0gYWJzKCR7dX0od2lkdGgyKSAtIHdpZHRoKTtcbiAgICAgIGlmIChkZXB0aDEgPT0gZGVwdGgyKSB7XG4gICAgICAgIGR4MSA9IDAuNTtcbiAgICAgICAgZHgyID0gMC41O1xuICAgICAgfVxuICAgICAgaWYgKGhlaWdodDEgPT0gaGVpZ2h0Mikge1xuICAgICAgICBkeTEgPSAwLjU7XG4gICAgICAgIGR5MiA9IDAuNTtcbiAgICAgIH1cbiAgICAgIGlmICh3aWR0aDEgPT0gd2lkdGgyKSB7XG4gICAgICAgIGR6MSA9IDAuNTtcbiAgICAgICAgZHoyID0gMC41O1xuICAgICAgfVxuICAgICAgcmV0dXJuICh4MTExICogZHgyICogZHkyICogZHoyICsgeDExMiAqIGR4MiAqIGR5MiAqIGR6MSArIHgxMjEgKiBkeDIgKiBkeTEgKmR6MiArIHgxMjIgKiBkeDIgKiBkeTEgKiBkejEgK1xuICAgICAgICAgICAgICB4MjExICogZHgxICogZHkyICogZHoyICsgeDIxMiAqIGR4MSAqIGR5MiAqIGR6MSArIHgyMjEgKiBkeDEgKiBkeTEgKmR6MiArIHgyMjIgKiBkeDEgKiBkeTEgKiBkejEpO1xuICAgIH1gfSxGaD0oZSx0LHIsbixvLGkpPT57bGV0IGE9ZS5kaW1zLGQ9TWgoaSx0LmF4ZXMsYS5sZW5ndGgpLGw9UmgoYSxuLG8sdC5heGVzKSxwPW4uc2xpY2UoKTtuLmxlbmd0aD09PTAmJihwPWEubWFwKCh2LFMpPT52PT09MD8xOmxbU10vdiksdC5rZWVwQXNwZWN0UmF0aW9Qb2xpY3khPT1cInN0cmV0Y2hcIiYmKGw9VWgoYSxwLHQpKSk7bGV0IG09TShcIm91dHB1dFwiLGUuZGF0YVR5cGUsbC5sZW5ndGgpLHU9RShcImlucHV0XCIsZS5kYXRhVHlwZSxhLmxlbmd0aCksaD1DLnNpemUobCksXz1hLmxlbmd0aD09PWwubGVuZ3RoJiZhLmV2ZXJ5KCh2LFMpPT52PT09bFtTXSkseT10LmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlPT09XCJ0Zl9jcm9wX2FuZF9yZXNpemVcIixnPXQuZXh0cmFwb2xhdGlvblZhbHVlLHg9dS50eXBlLnZhbHVlLCQ9dj0+YFxuICAgICAgJHtfP1wiXCI6YFxuICAgICAgJHtEaCh0LmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlLHgpfTtcbiAgICAgICR7KCgpPT57c3dpdGNoKHQubW9kZSl7Y2FzZVwibmVhcmVzdFwiOnJldHVybmBcbiAgICAgICAgICAgICAgJHtXaCh1LGEpfTtcbiAgICAgICAgICAgICAgJHtCaCh0Lm5lYXJlc3RNb2RlLHIseCl9O1xuICAgICAgICAgICAgICAke1ZoKHUsbSxhLGwscC5sZW5ndGgsZC5sZW5ndGgseSl9O1xuICAgICAgICAgICAgICBgO2Nhc2VcImxpbmVhclwiOnJldHVybmBcbiAgICAgICAgICAgICAgJHtOaChtLGEsbCxwLmxlbmd0aCxkLmxlbmd0aCl9O1xuICAgICAgICAgICAgICAkeygoKT0+e2lmKGEubGVuZ3RoPT09Mnx8YS5sZW5ndGg9PT00KXJldHVybmAke0xoKHUsbSxhLHksZyl9YDtpZihhLmxlbmd0aD09PTN8fGEubGVuZ3RoPT09NSlyZXR1cm5gJHtIaCh1LG0sYSx5LGcpfWA7dGhyb3cgRXJyb3IoXCJMaW5lYXIgbW9kZSBvbmx5IHN1cHBvcnRzIGlucHV0IGRpbXMgMiwgMywgNCBhbmQgNSBhcmUgc3VwcG9ydGVkIGluIGxpbmVhciBtb2RlLlwiKX0pKCl9O1xuICAgICAgICAgICAgYDtjYXNlXCJjdWJpY1wiOnJldHVybmBcbiAgICAgICAgICAgICR7KCgpPT57aWYoYS5sZW5ndGg9PT0yfHxhLmxlbmd0aD09PTQpcmV0dXJuYCR7R2godSxtLGEsbCxwLGQsdC5jdWJpY0NvZWZmQSx5LHQuZXh0cmFwb2xhdGlvblZhbHVlLHQuZXhjbHVkZU91dHNpZGUpfWA7dGhyb3cgRXJyb3IoXCJDdWJpYyBtb2RlIG9ubHkgc3VwcG9ydHMgaW5wdXQgZGltcyAyIGFuZCA0IGFyZSBzdXBwb3J0ZWQgaW4gbGluZWFyIG1vZGUuXCIpfSkoKX07XG4gICAgICAgICAgICBgO2RlZmF1bHQ6dGhyb3cgRXJyb3IoXCJJbnZhbGlkIHJlc2l6ZSBtb2RlXCIpfX0pKCl9O1xuICAgICAgYH1cbiAgICAgICR7di5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLnJlZ2lzdGVyVW5pZm9ybShcInNjYWxlc1wiLFwiZjMyXCIscC5sZW5ndGgpLnJlZ2lzdGVyVW5pZm9ybShcInJvaVwiLFwiZjMyXCIsZC5sZW5ndGgpLmRlY2xhcmVWYXJpYWJsZXModSxtKX1cbiAgICAgICR7di5tYWluU3RhcnQoKX1cbiAgICAgICAgJHt2Lmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICAgICAgJHtfP1wib3V0cHV0W2dsb2JhbF9pZHhdID0gaW5wdXRbZ2xvYmFsX2lkeF07XCI6YFxuICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke20ub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke3UudHlwZS5pbmRpY2VzfTtcbiAgICAgICAgJHsoKCk9Pntzd2l0Y2godC5tb2RlKXtjYXNlXCJuZWFyZXN0XCI6cmV0dXJuYGlucHV0X2luZGljZXMgPSBjYWxjdWxhdGVJbnB1dEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlcyk7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrSW5wdXRJbmRpY2VzKGlucHV0X2luZGljZXMpKSB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSAke3UuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9ICR7dC5leHRyYXBvbGF0aW9uVmFsdWV9O1xuICAgICAgICAgICAgICAgIH1gO2Nhc2VcImxpbmVhclwiOnJldHVybmBvdXRwdXRbZ2xvYmFsX2lkeF0gPSAke2EubGVuZ3RoPT09Mnx8YS5sZW5ndGg9PT00P1wiYmlsaW5lYXJJbnRlcnBvbGF0aW9uXCI6XCJ0cmlsaW5lYXJJbnRlcnBvbGF0aW9uXCJ9KG91dHB1dF9pbmRpY2VzKTtgO2Nhc2VcImN1YmljXCI6cmV0dXJuXCJvdXRwdXRbZ2xvYmFsX2lkeF0gPSBiaWN1YmljSW50ZXJwb2xhdGlvbihvdXRwdXRfaW5kaWNlcyk7XCI7ZGVmYXVsdDp0aHJvdyBFcnJvcihgVW5zdXBwb3J0ZWQgcmVzaXplIG1vZGU6ICR7dC5tb2RlfWApfX0pKCl9O1xuYH1cbiAgICAgIH1gO3JldHVybntuYW1lOlwiUmVzaXplXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5jYWNoZUtleX18JHtyfXwke3AubGVuZ3RoPjA/cDpcIlwifXwke28ubGVuZ3RoPjA/bzpcIlwifXwke2QubGVuZ3RoPjA/ZDpcIlwifXwke199fCR7YX1gLGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LGdldFNoYWRlclNvdXJjZTokLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6bCxkYXRhVHlwZTplLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoaC82NCl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTpofSx7dHlwZToxLGRhdGE6cH0se3R5cGU6MSxkYXRhOmR9LC4uLk4oYSxsKV19KX19LHFoPWU9PntsZXQgdD1lLmN1c3RvbURhdGFCdWZmZXI7cmV0dXJuIG5ldyBVaW50MzJBcnJheSh0LHQuYnl0ZU9mZnNldCwxKVswXX0sUGw9KGUsdCk9PntsZXQgcj1bXSxuPVtdLG89W10saT1xaChlKTtpZih0LmFudGlhbGlhcyE9PTApdGhyb3cgRXJyb3IoXCJPbmx5IGRlZmF1bHQgdmFsdWUgKDApIGZvciBBbnRpYWxpYXMgYXR0cmlidXRlIGlzIHN1cHBvcnRlZFwiKTtPaChlLmlucHV0cyx0LGkscixuLG8pLGUuY29tcHV0ZShGaChlLmlucHV0c1swXSx0LGkscixuLG8pLHtpbnB1dHM6WzBdfSl9LHpsPWU9PntsZXQgdD1lLmFudGlhbGlhcyxyPWUuYXhlcyxuPWUuY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUsbz1lLmN1YmljQ29lZmZBLGk9ZS5leGNsdWRlT3V0c2lkZSE9PTAsYT1lLmV4dHJhcG9sYXRpb25WYWx1ZSxkPWUua2VlcEFzcGVjdFJhdGlvUG9saWN5LGw9ZS5tb2RlLHA9ZS5uZWFyZXN0TW9kZT09PVwiXCI/XCJzaW1wbGVcIjplLm5lYXJlc3RNb2RlO3JldHVybiByZSh7YW50aWFsaWFzOnQsYXhlczpyLGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlOm4sY3ViaWNDb2VmZkE6byxleGNsdWRlT3V0c2lkZTppLGV4dHJhcG9sYXRpb25WYWx1ZTphLGtlZXBBc3BlY3RSYXRpb1BvbGljeTpkLG1vZGU6bCxuZWFyZXN0TW9kZTpwfSl9fSk7dmFyIEtoLGpoLERsLEJsPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7U2UoKTthZSgpO0toPShlLHQpPT57bGV0W3IsbixvLGldPWUse251bUhlYWRzOmEscm90YXJ5RW1iZWRkaW5nRGltOmR9PXQ7aWYoci5kaW1zLmxlbmd0aCE9PTMmJnIuZGltcy5sZW5ndGghPT00KXRocm93IG5ldyBFcnJvcihgSW5wdXQgJ3gnIGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBvciA0IGRpbWVuc2lvbnMsIGdvdCAke3IuZGltcy5sZW5ndGh9YCk7aWYoIUMuYXJlRXF1YWwobi5kaW1zLFtdKSYmIUMuYXJlRXF1YWwobi5kaW1zLFsxXSkmJm4uZGltcy5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihgSW5wdXQgJ3Bvc2l0aW9uX2lkcycgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAwLCAxLCBvciAyIGRpbWVuc2lvbnMsIGdvdCAke24uZGltcy5sZW5ndGh9YCk7aWYoby5kaW1zLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAnY29zX2NhY2hlJyBpcyBleHBlY3RlZCB0byBoYXZlIDIgZGltZW5zaW9ucywgZ290ICR7by5kaW1zLmxlbmd0aH1gKTtpZihpLmRpbXMubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoYElucHV0ICdzaW5fY2FjaGUnIGlzIGV4cGVjdGVkIHRvIGhhdmUgMiBkaW1lbnNpb25zLCBnb3QgJHtpLmRpbXMubGVuZ3RofWApO2lmKCFDLmFyZUVxdWFsKG8uZGltcyxpLmRpbXMpKXRocm93IG5ldyBFcnJvcihcIklucHV0cyAnY29zX2NhY2hlJyBhbmQgJ3Npbl9jYWNoZScgYXJlIGV4cGVjdGVkIHRvIGhhdmUgdGhlIHNhbWUgc2hhcGVcIik7aWYoZD4wJiZhPT09MCl0aHJvdyBuZXcgRXJyb3IoXCJudW1faGVhZHMgbXVzdCBiZSBwcm92aWRlZCBpZiByb3RhcnlfZW1iZWRkaW5nX2RpbSBpcyBzcGVjaWZpZWRcIik7bGV0IGw9ci5kaW1zWzBdLHA9ci5kaW1zW3IuZGltcy5sZW5ndGgtMl0sbT1vLmRpbXNbMF0sdT1DLnNpemVGcm9tRGltZW5zaW9uKHIuZGltcywxKS9wLGg9ZD09PTA/by5kaW1zWzFdKjI6dS9hO2lmKGQ+aCl0aHJvdyBuZXcgRXJyb3IoXCJyb3RhcnlfZW1iZWRkaW5nX2RpbSBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byBoZWFkX3NpemVcIik7aWYobi5kaW1zLmxlbmd0aD09PTIpe2lmKGwhPT1uLmRpbXNbMF0pdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAncG9zaXRpb25faWRzJyBkaW1lbnNpb24gMCBzaG91bGQgYmUgb2Ygc2l6ZSBiYXRjaF9zaXplLCBnb3QgJHtuLmRpbXNbMF19YCk7aWYocCE9PW4uZGltc1sxXSl0aHJvdyBuZXcgRXJyb3IoYElucHV0ICdwb3NpdGlvbl9pZHMnIGRpbWVuc2lvbiAxIHNob3VsZCBiZSBvZiBzaXplIHNlcXVlbmNlX2xlbmd0aCwgZ290ICR7bi5kaW1zWzFdfWApfWlmKGgvMiE9PW8uZGltc1sxXSYmZC8yIT09by5kaW1zWzFdKXRocm93IG5ldyBFcnJvcihgSW5wdXQgJ2Nvc19jYWNoZScgZGltZW5zaW9uIDEgc2hvdWxkIGJlIHNhbWUgYXMgaGVhZF9zaXplIC8gMiBvciByb3RhcnlfZW1iZWRkaW5nX2RpbSAvIDIsIGdvdCAke28uZGltc1sxXX1gKTtpZihwPm0pdGhyb3cgbmV3IEVycm9yKFwiVXBkYXRpbmcgY29zX2NhY2hlIGFuZCBzaW5fY2FjaGUgaW4gUm90YXJ5RW1iZWRkaW5nIGlzIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkXCIpfSxqaD0oZSx0KT0+e2xldHtpbnRlcmxlYXZlZDpyLG51bUhlYWRzOm4scm90YXJ5RW1iZWRkaW5nRGltOm8sc2NhbGU6aX09dCxhPWVbMF0uZGltc1swXSxkPUMuc2l6ZUZyb21EaW1lbnNpb24oZVswXS5kaW1zLDEpLGw9ZVswXS5kaW1zW2VbMF0uZGltcy5sZW5ndGgtMl0scD1kL2wsbT1lWzJdLmRpbXNbMV0sdT1vPT09MD9tKjI6cC9uLGg9bmV3IEFycmF5KGEsbCxwL3UsdS1tKSxfPUMuY29tcHV0ZVN0cmlkZXMoaCkseT1be3R5cGU6MSxkYXRhOml9LHt0eXBlOjEyLGRhdGE6aH0se3R5cGU6MTIsZGF0YTpffSwuLi5lWzBdLmRpbXMubGVuZ3RoPT09Mz9uZXcgQXJyYXkoe3R5cGU6MTIsZGF0YTpbZCxwLHUsMV19KTpbXSwuLi5lWzBdLmRpbXMubGVuZ3RoPT09ND9uZXcgQXJyYXkoe3R5cGU6MTIsZGF0YTpbZCx1LGwqdSwxXX0pOltdLC4uLk4oZVswXS5kaW1zLGVbMV0uZGltcyxlWzJdLmRpbXMsZVszXS5kaW1zLGVbMF0uZGltcyldLGc9eD0+e2xldCAkPUUoXCJpbnB1dFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLmxlbmd0aCksdj1FKFwicG9zaXRpb25faWRzXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMubGVuZ3RoKSxTPUUoXCJjb3NfY2FjaGVcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcy5sZW5ndGgpLFQ9RShcInNpbl9jYWNoZVwiLGVbM10uZGF0YVR5cGUsZVszXS5kaW1zLmxlbmd0aCksQT1NKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMubGVuZ3RoKTtyZXR1cm4geC5yZWdpc3RlclVuaWZvcm1zKFt7bmFtZTpcInNjYWxlXCIsdHlwZTpcImYzMlwifSx7bmFtZTpcImdsb2JhbF9zaGFwZVwiLHR5cGU6XCJ1MzJcIixsZW5ndGg6aC5sZW5ndGh9LHtuYW1lOlwiZ2xvYmFsX3N0cmlkZXNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOl8ubGVuZ3RofSx7bmFtZTpcImlucHV0X291dHB1dF9zdHJpZGVzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDpfLmxlbmd0aH1dKSxgXG4gICAgICAgICR7eC5kZWNsYXJlVmFyaWFibGVzKCQsdixTLFQsQSl9XG5cbiAgICAgICAgJHt4Lm1haW5TdGFydChrdCl9XG4gICAgICAgICAgbGV0IGhhbGZfcm90YXJ5X2VtYl9kaW0gPSB1bmlmb3Jtcy4ke1MubmFtZX1fc2hhcGVbMV07XG4gICAgICAgICAgbGV0IGJzbmggPSBnbG9iYWxfaWR4IC8gdW5pZm9ybXMuZ2xvYmFsX3N0cmlkZXMgJSB1bmlmb3Jtcy5nbG9iYWxfc2hhcGU7XG4gICAgICAgICAgbGV0IHNpemUgPSB1bmlmb3Jtcy5nbG9iYWxfc2hhcGVbMF0gKiB1bmlmb3Jtcy5nbG9iYWxfc3RyaWRlc1swXTtcbiAgICAgICAgICAke3guZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInNpemVcIil9XG5cbiAgICAgICAgICBpZiAoYnNuaFszXSA8IGhhbGZfcm90YXJ5X2VtYl9kaW0pIHtcbiAgICAgICAgICAgIGxldCBwb3NpdGlvbl9pZHNfaWR4ID1cbiAgICAgICAgICAgICAgICAke3YuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoXCJic25oLnh5XCIsTShcIlwiLHYudHlwZS50ZW5zb3IsMikpfTtcbiAgICAgICAgICAgIGxldCBwb3NpdGlvbl9pZCA9XG4gICAgICAgICAgICAgICAgdTMyKCR7di5nZXRCeU9mZnNldChcInBvc2l0aW9uX2lkc19pZHhcIil9KSArIHNlbGVjdCgwLCBic25oWzFdLCBwb3NpdGlvbl9pZHNfaWR4ID09IDApO1xuICAgICAgICAgICAgbGV0IGkgPSBkb3QoYnNuaCwgdW5pZm9ybXMuaW5wdXRfb3V0cHV0X3N0cmlkZXMpICsgc2VsZWN0KDAsIGJzbmhbM10sICR7cn0pO1xuICAgICAgICAgICAgbGV0IGogPSBpICsgc2VsZWN0KGhhbGZfcm90YXJ5X2VtYl9kaW0sIDEsICR7cn0pO1xuICAgICAgICAgICAgbGV0IHJlID0gJHskLmdldEJ5T2Zmc2V0KFwiaVwiKX0gKiAke1MuZ2V0KFwicG9zaXRpb25faWRcIixcImJzbmhbM11cIil9IC1cbiAgICAgICAgICAgICAgICAkeyQuZ2V0QnlPZmZzZXQoXCJqXCIpfSAqICR7VC5nZXQoXCJwb3NpdGlvbl9pZFwiLFwiYnNuaFszXVwiKX07XG4gICAgICAgICAgICAke0Euc2V0QnlPZmZzZXQoXCJpXCIsXCJyZVwiKX1cbiAgICAgICAgICAgIGxldCBpbSA9ICR7JC5nZXRCeU9mZnNldChcImlcIil9ICogJHtULmdldChcInBvc2l0aW9uX2lkXCIsXCJic25oWzNdXCIpfSArXG4gICAgICAgICAgICAgICAgJHskLmdldEJ5T2Zmc2V0KFwialwiKX0gKiAke1MuZ2V0KFwicG9zaXRpb25faWRcIixcImJzbmhbM11cIil9O1xuICAgICAgICAgICAgJHtBLnNldEJ5T2Zmc2V0KFwialwiLFwiaW1cIil9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBrID0gZG90KGJzbmgsIHVuaWZvcm1zLmlucHV0X291dHB1dF9zdHJpZGVzKSArIGhhbGZfcm90YXJ5X2VtYl9kaW07XG4gICAgICAgICAgICAke0Euc2V0QnlPZmZzZXQoXCJrXCIsJC5nZXRCeU9mZnNldChcImtcIikpfVxuICAgICAgICAgIH1cbiAgICAgICAgfWB9O3JldHVybntuYW1lOlwiUm90YXJ5RW1iZWRkaW5nXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6cmUoe2ludGVybGVhdmVkOnJ9KS5jYWNoZUtleSxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCIsXCJyYW5rXCIsXCJyYW5rXCIsXCJyYW5rXCJdfSxnZXRTaGFkZXJTb3VyY2U6ZyxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmVbMF0uZGltcyxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoQy5zaXplKGgpL2t0KX0scHJvZ3JhbVVuaWZvcm1zOnl9KX19LERsPShlLHQpPT57S2goZS5pbnB1dHMsdCksZS5jb21wdXRlKGpoKGUuaW5wdXRzLHQpKX19KTt2YXIgWWgsWmgsTWwsUmw9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTthZSgpO1loPWU9PntpZighZXx8ZS5sZW5ndGg8Myl0aHJvdyBuZXcgRXJyb3IoXCJsYXllck5vcm0gcmVxdWlyZXMgYXQgbGVhc3QgMyBpbnB1dHMuXCIpO2xldCB0PWVbMF0scj1lWzFdLG49ZVsyXTtpZih0LmRhdGFUeXBlIT09ci5kYXRhVHlwZXx8dC5kYXRhVHlwZSE9PW4uZGF0YVR5cGUpdGhyb3cgbmV3IEVycm9yKFwiQWxsIGlucHV0cyBtdXN0IGhhdmUgdGhlIHNhbWUgZGF0YSB0eXBlXCIpO2lmKHQuZGltcy5sZW5ndGghPT0zJiZ0LmRpbXMubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBtdXN0IGJlIDJEIG9yIDNEXCIpO2lmKHIuZGltcy5sZW5ndGghPT0zJiZyLmRpbXMubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJTa2lwIG11c3QgYmUgMkQgb3IgM0RcIik7bGV0IG89dC5kaW1zW3QuZGltcy5sZW5ndGgtMV0saT10LmRpbXNbdC5kaW1zLmxlbmd0aC0yXTtpZihyLmRpbXNbci5kaW1zLmxlbmd0aC0xXSE9PW8pdGhyb3cgbmV3IEVycm9yKFwiU2tpcCBtdXN0IGhhdmUgdGhlIHNhbWUgaGlkZGVuIHNpemUgYXMgaW5wdXRcIik7aWYoci5kaW1zW3IuZGltcy5sZW5ndGgtMl0hPT1pKXRocm93IG5ldyBFcnJvcihcIlNraXAgbXVzdCBoYXZlIHRoZSBzYW1lIHNlcXVlbmNlIGxlbmd0aCBhcyBpbnB1dFwiKTtpZihuLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJHYW1tYSBtdXN0IGJlIDFEXCIpO2lmKG4uZGltc1tuLmRpbXMubGVuZ3RoLTFdIT09byl0aHJvdyBuZXcgRXJyb3IoXCJHYW1tYSBtdXN0IGhhdmUgdGhlIHNhbWUgaGlkZGVuIHNpemUgYXMgaW5wdXRcIik7aWYoZS5sZW5ndGg+Myl7bGV0IGE9ZVszXTtpZihhLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJCZXRhIG11c3QgYmUgMURcIik7aWYoYS5kaW1zW2EuZGltcy5sZW5ndGgtMV0hPT1vKXRocm93IG5ldyBFcnJvcihcIkJldGEgbXVzdCBoYXZlIHRoZSBzYW1lIGhpZGRlbiBzaXplIGFzIGlucHV0XCIpfWlmKGUubGVuZ3RoPjQpe2xldCBhPWVbNF07aWYoYS5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiQmlhcyBtdXN0IGJlIDFEXCIpO2lmKGEuZGltc1thLmRpbXMubGVuZ3RoLTFdIT09byl0aHJvdyBuZXcgRXJyb3IoXCJCaWFzIG11c3QgaGF2ZSB0aGUgc2FtZSBoaWRkZW4gc2l6ZSBhcyBpbnB1dFwiKX19LFpoPShlLHQscixuKT0+e2xldCBvPXQuc2ltcGxpZmllZCxpPWVbMF0uZGltcyxhPUMuc2l6ZShpKSxkPWksbD1hLHA9aS5zbGljZSgtMSlbMF0sbT1uP2kuc2xpY2UoMCwtMSkuY29uY2F0KDEpOltdLHU9IW8mJmUubGVuZ3RoPjMsaD1lLmxlbmd0aD40LF89biYmcj4xLHk9biYmcj4yLGc9cj4zLHg9NjQsJD1tZShwKSx2PVt7dHlwZToxMixkYXRhOmx9LHt0eXBlOjEyLGRhdGE6JH0se3R5cGU6MTIsZGF0YTpwfSx7dHlwZToxLGRhdGE6dC5lcHNpbG9ufV0sUz1BPT57bGV0IGs9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiY29tcG9uZW50c1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJoaWRkZW5fc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJlcHNpbG9uXCIsdHlwZTpcImYzMlwifV0sUD1bRShcInhcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcywkKSxFKFwic2tpcFwiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zLCQpLEUoXCJnYW1tYVwiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLCQpXTt1JiZQLnB1c2goRShcImJldGFcIixlWzNdLmRhdGFUeXBlLGVbM10uZGltcywkKSksaCYmUC5wdXNoKEUoXCJiaWFzXCIsZVs0XS5kYXRhVHlwZSxlWzRdLmRpbXMsJCkpLFAucHVzaChNKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxkLCQpKSxfJiZQLnB1c2goTShcIm1lYW5fb3V0cHV0XCIsMSxtKSkseSYmUC5wdXNoKE0oXCJpbnZfc3RkX291dHB1dFwiLDEsbSkpLGcmJlAucHVzaChNKFwiaW5wdXRfc2tpcF9iaWFzX3N1bVwiLGVbMF0uZGF0YVR5cGUsZCwkKSk7bGV0IEQ9X2UoZVswXS5kYXRhVHlwZSksUj1fZSgxLCQpO3JldHVybmBcblxuICAgICAgJHtBLnJlZ2lzdGVyVW5pZm9ybXMoaykuZGVjbGFyZVZhcmlhYmxlcyguLi5QKX1cbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHN1bV9zaGFyZWQgOiBhcnJheTwke1J9LCAke3h9PjtcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHN1bV9zcXVhcmVkX3NoYXJlZCA6IGFycmF5PCR7Un0sICR7eH0+O1xuXG4gICAgICAke0EubWFpblN0YXJ0KFt4LDEsMV0pfVxuICAgICAgICBsZXQgaXggPSBsb2NhbF9pZC54O1xuICAgICAgICBsZXQgaXkgPSBnbG9iYWxfaWQueCAvICR7eH07XG5cbiAgICAgICAgbGV0IGhpZGRlbl9zaXplX3ZlY3Rvcml6ZWQ6IHUzMiA9IHVuaWZvcm1zLmhpZGRlbl9zaXplIC8gdW5pZm9ybXMuY29tcG9uZW50cztcbiAgICAgICAgdmFyIHN0cmlkZSA9IGhpZGRlbl9zaXplX3ZlY3Rvcml6ZWQgLyAke3h9O1xuICAgICAgICBsZXQgb2Zmc2V0ID0gaXggKiBzdHJpZGUgKyBpeSAqIGhpZGRlbl9zaXplX3ZlY3Rvcml6ZWQ7XG4gICAgICAgIGxldCBvZmZzZXQxZCA9IHN0cmlkZSAqIGl4O1xuICAgICAgICBpZiAoaXggPT0gJHt4LTF9KSB7XG4gICAgICAgICAgc3RyaWRlID0gaGlkZGVuX3NpemVfdmVjdG9yaXplZCAtIHN0cmlkZSAqIGl4O1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCBzdHJpZGU7IGkrKykge1xuICAgICAgICAgIGxldCBza2lwX3ZhbHVlID0gc2tpcFtvZmZzZXQgKyBpXTtcbiAgICAgICAgICBsZXQgYmlhc192YWx1ZSA9ICR7aD9cImJpYXNbb2Zmc2V0MWQgKyBpXVwiOkQrXCIoMC4wKVwifTtcbiAgICAgICAgICBsZXQgaW5wdXRfdmFsdWUgPSB4W29mZnNldCArIGldO1xuICAgICAgICAgIGxldCB2YWx1ZSA9IGlucHV0X3ZhbHVlICsgc2tpcF92YWx1ZSArIGJpYXNfdmFsdWU7XG4gICAgICAgICAgJHtnP1wiaW5wdXRfc2tpcF9iaWFzX3N1bVtvZmZzZXQgKyBpXSA9IHZhbHVlO1wiOlwiXCJ9XG4gICAgICAgICAgb3V0cHV0W29mZnNldCArIGldID0gdmFsdWU7XG4gICAgICAgICAgbGV0IGYzMl92YWx1ZSA9ICR7RXQoRCwkLFwidmFsdWVcIil9O1xuICAgICAgICAgIHN1bV9zaGFyZWRbaXhdICs9IGYzMl92YWx1ZTtcbiAgICAgICAgICBzdW1fc3F1YXJlZF9zaGFyZWRbaXhdICs9IGYzMl92YWx1ZSAqIGYzMl92YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgdmFyIHJlZHVjZV9zaXplIDogdTMyID0gJHt4fTtcbiAgICAgICAgZm9yICh2YXIgY3Vycl9zaXplID0gcmVkdWNlX3NpemUgPj4gMTsgIGN1cnJfc2l6ZSA+IDA7IGN1cnJfc2l6ZSA9IHJlZHVjZV9zaXplID4+IDEpIHtcbiAgICAgICAgICByZWR1Y2Vfc2l6ZSA9IGN1cnJfc2l6ZSArIChyZWR1Y2Vfc2l6ZSAmIDEpO1xuICAgICAgICAgIGlmIChpeCA8IGN1cnJfc2l6ZSkge1xuICAgICAgICAgICAgc3VtX3NoYXJlZFtpeF0gKz0gc3VtX3NoYXJlZFtpeCArIHJlZHVjZV9zaXplXTtcbiAgICAgICAgICAgIHN1bV9zcXVhcmVkX3NoYXJlZFtpeF0gKz0gc3VtX3NxdWFyZWRfc2hhcmVkW2l4ICsgcmVkdWNlX3NpemVdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc3VtID0gc3VtX3NoYXJlZFswXTtcbiAgICAgICAgbGV0IHNxdWFyZV9zdW0gPSBzdW1fc3F1YXJlZF9zaGFyZWRbMF07XG4gICAgICAgIGxldCBtZWFuID0gJHtGZShcInN1bVwiLCQpfSAvIGYzMih1bmlmb3Jtcy5oaWRkZW5fc2l6ZSk7XG4gICAgICAgIGxldCBpbnZfc3RkX2RldiA9IGludmVyc2VTcXJ0KCR7RmUoXCJzcXVhcmVfc3VtXCIsJCl9IC8gZjMyKHVuaWZvcm1zLmhpZGRlbl9zaXplKSAke28/XCJcIjpcIi0gbWVhbiAqIG1lYW5cIn0gKyB1bmlmb3Jtcy5lcHNpbG9uKTtcbiAgICAgICAgJHtfP1wibWVhbl9vdXRwdXRbZ2xvYmFsX2lkeF0gPSBtZWFuO1wiOlwiXCJ9XG4gICAgICAgICR7eT9cImludl9zdGRfb3V0cHV0W2dsb2JhbF9pZHhdID0gaW52X3N0ZF9kZXY7XCI6XCJcIn1cblxuICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgc3RyaWRlOyBpKyspIHtcbiAgICAgICAgICBvdXRwdXRbb2Zmc2V0ICsgaV0gPSAob3V0cHV0W29mZnNldCArIGldICR7bz9cIlwiOmAtICR7RH0obWVhbilgfSkgKlxuICAgICAgICAgICAgJHtEfShpbnZfc3RkX2RldikgKiBnYW1tYVtvZmZzZXQxZCArIGldXG4gICAgICAgICAgICAke3U/XCIrIGJldGFbb2Zmc2V0MWQgKyBpXVwiOlwiXCJ9O1xuICAgICAgICB9XG4gICAgICB9YH0sVD1be2RpbXM6ZCxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV07cmV0dXJuIHI+MSYmVC5wdXNoKHtkaW1zOm0sZGF0YVR5cGU6MX0pLHI+MiYmVC5wdXNoKHtkaW1zOm0sZGF0YVR5cGU6MX0pLHI+MyYmVC5wdXNoKHtkaW1zOmksZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX0pLHtuYW1lOlwiU2tpcExheWVyTm9ybWFsaXphdGlvblwiLHNoYWRlckNhY2hlOntoaW50OmAkeyR9OyR7X307JHt5fTske2d9YCxpbnB1dERlcGVuZGVuY2llczplLm1hcCgoQSxrKT0+XCJ0eXBlXCIpfSxnZXRTaGFkZXJTb3VyY2U6UyxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6VCxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChsL3ApfSxwcm9ncmFtVW5pZm9ybXM6dn0pfX0sTWw9KGUsdCk9PntZaChlLmlucHV0cyk7bGV0IG49WzBdO2Uub3V0cHV0Q291bnQ+MSYmbi5wdXNoKC0zKSxlLm91dHB1dENvdW50PjImJm4ucHVzaCgtMyksZS5vdXRwdXRDb3VudD4zJiZuLnB1c2goMyksZS5jb21wdXRlKFpoKGUuaW5wdXRzLHQsZS5vdXRwdXRDb3VudCwhMSkse291dHB1dHM6bn0pfX0pO3ZhciBRaCxybixYaCxVbCxKaCxlZyxObCxWbCxXbD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtvZSgpO1NlKCk7YWUoKTtRaD0oZSx0KT0+e2lmKCFlfHxlLmxlbmd0aDwxKXRocm93IG5ldyBFcnJvcihcInRvbyBmZXcgaW5wdXRzXCIpO2lmKHQuYXhlcy5sZW5ndGghPT0wKXtpZih0LmF4ZXMubGVuZ3RoIT09dC5zdGFydHMubGVuZ3RofHx0LmF4ZXMubGVuZ3RoIT09dC5lbmRzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJheGVzLCBzdGFydHMgYW5kIGVuZHMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiKX1lbHNlIGlmKHQuc3RhcnRzLmxlbmd0aCE9PXQuZW5kcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic3RhcnRzIGFuZCBlbmRzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIik7ZS5zbGljZSgxKS5mb3JFYWNoKChyLG4pPT57aWYoZVtuKzFdLmRhdGFUeXBlIT09NiYmZVtuKzFdLmRhdGFUeXBlIT09Nyl0aHJvdyBuZXcgRXJyb3IoYElucHV0ICR7bn0gbXVzdCBiZSBhbiBhcnJheSBvZiBpbnQzMiBvciBpbnQ2NGApfSl9LHJuPShlLHQpPT57bGV0IHI9W107aWYoZS5sZW5ndGg+dClpZihlW3RdLmRhdGFUeXBlPT09NyllW3RdLmdldEJpZ0ludDY0QXJyYXkoKS5mb3JFYWNoKG49PnIucHVzaChOdW1iZXIobikpKTtlbHNlIGlmKGVbdF0uZGF0YVR5cGU9PT02KWVbdF0uZ2V0SW50MzJBcnJheSgpLmZvckVhY2gobj0+ci5wdXNoKE51bWJlcihuKSkpO2Vsc2UgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAke3R9IG11c3QgYmUgYW4gYXJyYXkgb2YgaW50MzIgb3IgaW50NjRgKTtyZXR1cm4gcn0sWGg9KGUsdCk9PntpZihlLmxlbmd0aD4xKXtsZXQgcj1ybihlLDEpLG49cm4oZSwyKSxvPXJuKGUsMyk7cmV0dXJuIG8ubGVuZ3RoPT09MCYmKG89Wy4uLkFycmF5KGVbMF0uZGltcy5sZW5ndGgpLmtleXMoKV0pLHJlKHtzdGFydHM6cixlbmRzOm4sYXhlczpvfSl9ZWxzZSByZXR1cm4gdH0sVWw9KGUsdCxyLG4sbyk9PntsZXQgaT1lO3JldHVybiBlPDAmJihpKz1yW25bdF1dKSxvW3RdPDA/TWF0aC5tYXgoMCxNYXRoLm1pbihpLHJbblt0XV0tMSkpOk1hdGgubWF4KDAsTWF0aC5taW4oaSxyW25bdF1dKSl9LEpoPShlLHQscik9PmBmbiBjYWxjdWxhdGVJbnB1dEluZGljZXMob3V0cHV0X2luZGljZXM6ICR7dC50eXBlLmluZGljZXN9KSAtPiAke2UudHlwZS5pbmRpY2VzfSB7XG4gICAgICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7ZS50eXBlLmluZGljZXN9O1xuICAgICAgICAgIHZhciBjYXJyeSA9IDB1O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAke3IubGVuZ3RofTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBpbnB1dF9zaGFwZV9pID0gJHtGKFwidW5pZm9ybXMuaW5wdXRfc2hhcGVcIixcImlcIixyLmxlbmd0aCl9O1xuICAgICAgICAgICAgbGV0IHN0ZXBzX2kgPSAke0YoXCJ1bmlmb3Jtcy5zdGVwc1wiLFwiaVwiLHIubGVuZ3RoKX07XG4gICAgICAgICAgICBsZXQgc2lnbnNfaSA9ICR7RihcInVuaWZvcm1zLnNpZ25zXCIsXCJpXCIsci5sZW5ndGgpfTtcbiAgICAgICAgICAgIGxldCBzdGFydHNfaSA9ICR7RihcInVuaWZvcm1zLnN0YXJ0c1wiLFwiaVwiLHIubGVuZ3RoKX07XG4gICAgICAgICAgICB2YXIgb3V0cHV0X2luZGV4ID0gJHt0LmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLFwiaVwiKX07XG4gICAgICAgICAgICB2YXIgaW5wdXRfaW5kZXggPSBvdXRwdXRfaW5kZXggKiBzdGVwc19pICsgc3RhcnRzX2kgKyBjYXJyeTtcbiAgICAgICAgICAgIGNhcnJ5ID0gaW5wdXRfaW5kZXggLyBpbnB1dF9zaGFwZV9pO1xuICAgICAgICAgICAgaW5wdXRfaW5kZXggPSBpbnB1dF9pbmRleCAlIGlucHV0X3NoYXBlX2k7XG4gICAgICAgICAgICBpZiAoc2lnbnNfaSA8IDApIHtcbiAgICAgICAgICAgICAgaW5wdXRfaW5kZXggPSBpbnB1dF9zaGFwZV9pIC0gaW5wdXRfaW5kZXggLSAxdSArIHN0YXJ0c19pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHtlLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsXCJpXCIsXCJpbnB1dF9pbmRleFwiKX07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpbnB1dF9pbmRpY2VzO1xuICAgICAgfWAsZWc9KGUsdCk9PntsZXQgcj1lWzBdLmRpbXMsbj1DLnNpemUociksbz10LmF4ZXMubGVuZ3RoPjA/Qy5ub3JtYWxpemVBeGVzKHQuYXhlcyxyLmxlbmd0aCk6Wy4uLkFycmF5KHIubGVuZ3RoKS5rZXlzKCldLGk9cm4oZSw0KTtpLmZvckVhY2goJD0+JCE9PTB8fCgoKT0+e3Rocm93IG5ldyBFcnJvcihcInN0ZXAgY2Fubm90IGJlIDBcIil9KSksaS5sZW5ndGg9PT0wJiYoaT1BcnJheShvLmxlbmd0aCkuZmlsbCgxKSk7bGV0IGE9dC5zdGFydHMubWFwKCgkLHYpPT5VbCgkLHYscixvLGkpKSxkPXQuZW5kcy5tYXAoKCQsdik9PlVsKCQsdixyLG8saSkpO2lmKG8ubGVuZ3RoIT09YS5sZW5ndGh8fG8ubGVuZ3RoIT09ZC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic3RhcnQsIGVuZHMgYW5kIGF4ZXMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzXCIpO2lmKG8ubGVuZ3RoIT09ci5sZW5ndGgpZm9yKGxldCAkPTA7JDxyLmxlbmd0aDsrKyQpby5pbmNsdWRlcygkKXx8KGEuc3BsaWNlKCQsMCwwKSxkLnNwbGljZSgkLDAsclskXSksaS5zcGxpY2UoJCwwLDEpKTtsZXQgbD1pLm1hcCgkPT5NYXRoLnNpZ24oJCkpO2kuZm9yRWFjaCgoJCx2LFMpPT57aWYoJDwwKXtsZXQgVD0oZFt2XS1hW3ZdKS8kLEE9YVt2XSxrPUErVCppW3ZdO2Fbdl09ayxkW3ZdPUEsU1t2XT0tJH19KTtsZXQgcD1yLnNsaWNlKDApO28uZm9yRWFjaCgoJCx2KT0+e3BbJF09TWF0aC5jZWlsKChkWyRdLWFbJF0pL2lbJF0pfSk7bGV0IG09e2RpbXM6cCxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfSx1PU0oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLHAubGVuZ3RoKSxoPUUoXCJpbnB1dFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLmxlbmd0aCksXz1DLnNpemUocCkseT1be25hbWU6XCJvdXRwdXRTaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInN0YXJ0c1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6YS5sZW5ndGh9LHtuYW1lOlwic2lnbnNcIix0eXBlOlwiaTMyXCIsbGVuZ3RoOmwubGVuZ3RofSx7bmFtZTpcInN0ZXBzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDppLmxlbmd0aH1dLGc9W3t0eXBlOjEyLGRhdGE6X30se3R5cGU6MTIsZGF0YTphfSx7dHlwZTo2LGRhdGE6bH0se3R5cGU6MTIsZGF0YTppfSwuLi5OKGVbMF0uZGltcyxwKV0seD0kPT5gXG4gICAgICAkeyQucmVnaXN0ZXJVbmlmb3Jtcyh5KS5kZWNsYXJlVmFyaWFibGVzKGgsdSl9XG4gICAgICAgICR7SmgoaCx1LHIpfVxuICAgICAgICAkeyQubWFpblN0YXJ0KCl9XG4gICAgICAgICAgJHskLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRTaXplXCIpfVxuICAgICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7dS5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgICAgICBsZXQgaW5wdXRfaW5kaWNlcyA9IGNhbGN1bGF0ZUlucHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlcyk7XG4gICAgICAgICAgJHt1LnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLGguZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKSl9XG4gICAgICB9YDtyZXR1cm57bmFtZTpcIlNsaWNlXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7bC5sZW5ndGh9XyR7YS5sZW5ndGh9XyR7aS5sZW5ndGh9YCxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxnZXRTaGFkZXJTb3VyY2U6eCxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W21dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKG4vNjQpfSxwcm9ncmFtVW5pZm9ybXM6Z30pfX0sTmw9KGUsdCk9PntRaChlLmlucHV0cyx0KTtsZXQgcj1YaChlLmlucHV0cyx0KTtlLmNvbXB1dGUoZWcoZS5pbnB1dHMscikse2lucHV0czpbMF19KX0sVmw9ZT0+e2xldCB0PWUuc3RhcnRzLHI9ZS5lbmRzLG49ZS5heGVzO3JldHVybiByZSh7c3RhcnRzOnQsZW5kczpyLGF4ZXM6bn0pfX0pO3ZhciB0ZyxyZyxMbCxHbCxIbD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtvZSgpO1NlKCk7ZHQoKTthZSgpO3RnPWU9PntpZighZXx8ZS5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIlNvZnRtYXggb3AgcmVxdWlyZXMgMSBpbnB1dC5cIil9LHJnPShlLHQpPT57bGV0IHI9ZS5pbnB1dHNbMF0sbj1yLmRpbXMsbz1DLnNpemUobiksaT1uLmxlbmd0aCxhPUMubm9ybWFsaXplQXhpcyh0LmF4aXMsaSksZD1hPG4ubGVuZ3RoLTEsbCxwPVtdO2Q/KHA9QXJyYXkuZnJvbSh7bGVuZ3RoOml9LChQLEQpPT5EKSxwW2FdPWktMSxwW2ktMV09YSxsPWUuY29tcHV0ZShQZShyLHApLHtpbnB1dHM6W3JdLG91dHB1dHM6Wy0xXX0pWzBdKTpsPXI7bGV0IG09bC5kaW1zLHU9bVtpLTFdLGg9by91LF89bWUodSkseT11L18sZz02NDtoPT09MSYmKGc9MjU2KTtsZXQgeD0oUCxEKT0+RD09PTQ/YG1heChtYXgoJHtQfS54LCAke1B9LnkpLCBtYXgoJHtQfS56LCAke1B9LncpKWA6RD09PTI/YG1heCgke1B9LngsICR7UH0ueSlgOkQ9PT0zP2BtYXgobWF4KCR7UH0ueCwgJHtQfS55KSwgJHtQfS56KWA6UCwkPUUoXCJ4XCIsbC5kYXRhVHlwZSxsLmRpbXMsXyksdj1NKFwicmVzdWx0XCIsbC5kYXRhVHlwZSxsLmRpbXMsXyksUz0kLnR5cGUudmFsdWUsVD1fZShsLmRhdGFUeXBlKT09PVwiZjMyXCI/YHZhciB0aHJlYWRNYXggPSAke1N9KC0zLjQwMjgyM2UrMzhmKTtgOmB2YXIgdGhyZWFkTWF4ID0gJHtTfSgtNjU1MDQuMGgpO2AsQT1QPT5gXG4gICAgICB2YXI8d29ya2dyb3VwPiByb3dNYXhTaGFyZWQgOiAke1N9O1xuICAgICAgdmFyPHdvcmtncm91cD4gcm93U3VtU2hhcmVkIDogJHtTfTtcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHRocmVhZFNoYXJlZCA6IGFycmF5PCR7U30sICR7Z30+O1xuXG4gICAgICBmbiBnZXRWYWx1ZShyb3c6IGkzMiwgY29sOiBpMzIsIHJvd19zdHJpZGU6IGkzMikgLT4gJHtTfSB7XG4gICAgICAgIGxldCBpbmRleCA9IHJvdyAqIHJvd19zdHJpZGUgKyBjb2w7XG4gICAgICAgIHJldHVybiB4W2luZGV4XTtcbiAgICAgIH1cblxuICAgICAgZm4gc2V0VmFsdWUocm93OiBpMzIsIGNvbDogaTMyLCByb3dfc3RyaWRlOiBpMzIsIHZhbHVlOiAke1N9KSB7XG4gICAgICAgIGxldCBpbmRleCA9IHJvdyAqIHJvd19zdHJpZGUgKyBjb2w7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgICR7UC5yZWdpc3RlclVuaWZvcm0oXCJwYWNrZWRDb2xzXCIsXCJpMzJcIikuZGVjbGFyZVZhcmlhYmxlcygkLHYpfVxuICAgICAgJHtQLm1haW5TdGFydChnKX1cbiAgICAgICAgbGV0IGdpbmRleCA9IGkzMihnbG9iYWxfaWR4KTtcbiAgICAgICAgbGV0IGxpbmRleCA9IGkzMihsb2NhbF9pZHgpO1xuICAgICAgICBjb25zdCB3ZyA9ICR7Z307XG4gICAgICAgIGxldCByb3cgPSBnaW5kZXggLyB3ZztcbiAgICAgICAgbGV0IGNvbHMgPSB1bmlmb3Jtcy5wYWNrZWRDb2xzO1xuICAgICAgICBsZXQgcm93X3N0cmlkZSA6IGkzMiA9IHVuaWZvcm1zLnBhY2tlZENvbHM7XG5cbiAgICAgICAgLy8gZmluZCB0aGUgcm93cyBtYXhcbiAgICAgICAgJHtUfVxuICAgICAgICBmb3IgKHZhciBjb2wgPSBsaW5kZXg7IGNvbCA8IGNvbHM7IGNvbCArPSB3Zykge1xuICAgICAgICAgIGxldCB2YWx1ZSA9IGdldFZhbHVlKHJvdywgY29sLCByb3dfc3RyaWRlKTtcbiAgICAgICAgICB0aHJlYWRNYXggPSBtYXgodGhyZWFkTWF4LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmRleCA8IGNvbHMpIHtcbiAgICAgICAgICB0aHJlYWRTaGFyZWRbbGluZGV4XSA9IHRocmVhZE1heDtcbiAgICAgICAgfVxuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgdmFyIHJlZHVjZVNpemUgPSBtaW4oY29scywgd2cpO1xuICAgICAgICBmb3IgKHZhciBjdXJyU2l6ZSA9IHJlZHVjZVNpemUgPj4gMTsgIGN1cnJTaXplID4gMDsgY3VyclNpemUgPSByZWR1Y2VTaXplID4+IDEpIHtcbiAgICAgICAgICByZWR1Y2VTaXplID0gY3VyclNpemUgKyAocmVkdWNlU2l6ZSAmIDEpO1xuICAgICAgICAgIGlmIChsaW5kZXggPCBjdXJyU2l6ZSkge1xuICAgICAgICAgICAgdGhyZWFkU2hhcmVkW2xpbmRleF0gPSBtYXgodGhyZWFkU2hhcmVkW2xpbmRleF0sIHRocmVhZFNoYXJlZFtsaW5kZXggKyByZWR1Y2VTaXplXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZGV4ID09IDApIHtcbiAgICAgICAgICByb3dNYXhTaGFyZWQgPSAke1N9KCR7eChcInRocmVhZFNoYXJlZFswXVwiLF8pfSk7XG4gICAgICAgIH1cbiAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIHJvd3Mgc3VtXG4gICAgICAgIHZhciB0aHJlYWRTdW0gPSAke1N9KDAuMCk7XG4gICAgICAgIGZvciAodmFyIGNvbCA9IGxpbmRleDsgY29sIDwgY29sczsgY29sICs9IHdnKSB7XG4gICAgICAgICAgbGV0IHN1YkV4cCA9IGV4cChnZXRWYWx1ZShyb3csIGNvbCwgcm93X3N0cmlkZSkgLSByb3dNYXhTaGFyZWQpO1xuICAgICAgICAgIHRocmVhZFN1bSArPSBzdWJFeHA7XG4gICAgICAgIH1cbiAgICAgICAgdGhyZWFkU2hhcmVkW2xpbmRleF0gPSB0aHJlYWRTdW07XG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICBmb3IgKHZhciBjdXJyU2l6ZSA9IHdnID4+IDE7ICBjdXJyU2l6ZSA+IDA7IGN1cnJTaXplID0gY3VyclNpemUgPj4gMSkge1xuICAgICAgICAgIGlmIChsaW5kZXggPCBjdXJyU2l6ZSkge1xuICAgICAgICAgICAgdGhyZWFkU2hhcmVkW2xpbmRleF0gPSB0aHJlYWRTaGFyZWRbbGluZGV4XSArIHRocmVhZFNoYXJlZFtsaW5kZXggKyBjdXJyU2l6ZV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZGV4ID09IDApIHtcbiAgICAgICAgICByb3dTdW1TaGFyZWQgPSAke1N9KCR7RmUoXCJ0aHJlYWRTaGFyZWRbMF1cIixfKX0pO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgZmluYWwgdmFsdWUgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgcm93XG4gICAgICAgIGZvciAodmFyIGNvbCA9IGxpbmRleDsgY29sIDwgY29sczsgY29sICs9IHdnKSB7XG4gICAgICAgICAgbGV0IHZhbHVlID0gZXhwKGdldFZhbHVlKHJvdywgY29sLCByb3dfc3RyaWRlKSAtIHJvd01heFNoYXJlZCkgLyByb3dTdW1TaGFyZWQ7XG4gICAgICAgICAgc2V0VmFsdWUocm93LCBjb2wsIHJvd19zdHJpZGUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfWAsaz1lLmNvbXB1dGUoe25hbWU6XCJTb2Z0bWF4XCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7X307JHtnfWAsaW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczptLGRhdGFUeXBlOmwuZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Omh9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6NixkYXRhOnl9XX0pLGdldFNoYWRlclNvdXJjZTpBfSx7aW5wdXRzOltsXSxvdXRwdXRzOltkPy0xOjBdfSlbMF07ZCYmZS5jb21wdXRlKFBlKGsscCkse2lucHV0czpba119KX0sTGw9KGUsdCk9Pnt0ZyhlLmlucHV0cykscmcoZSx0KX0sR2w9ZT0+cmUoe2F4aXM6ZS5heGlzfSl9KTt2YXIgRmwsbmcsb2csaWcscWwsS2w9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTthZSgpO0ZsPWU9PkFycmF5LmZyb20oZS5nZXRCaWdJbnQ2NEFycmF5KCksTnVtYmVyKSxuZz1lPT57aWYoIWV8fGUubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJUaWxlIHJlcXVpcmVzIDIgaW5wdXRzLlwiKTtpZihlWzBdLmRhdGFUeXBlIT09MSYmZVswXS5kYXRhVHlwZSE9PTEwJiZlWzBdLmRhdGFUeXBlIT09NiYmZVswXS5kYXRhVHlwZSE9PTEyKXRocm93IG5ldyBFcnJvcihcIlRpbGUgb25seSBzdXBwb3J0IGZsb2F0LCBmbG9hdDE2LCBpbnQzMiwgYW5kIHVpbnQzMiBkYXRhIHR5cGVzXCIpO2lmKGVbMV0uZGF0YVR5cGUhPT03KXRocm93IG5ldyBFcnJvcihcIlRpbGUgYHJlcGVhdHNgIGlucHV0IHNob3VsZCBiZSBvZiBpbnQ2NCBkYXRhIHR5cGVcIik7aWYoZVsxXS5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiVGlsZSBgcmVwZWF0c2AgaW5wdXQgc2hvdWxkIGJlIDEtRFwiKTtpZihGbChlWzFdKS5sZW5ndGghPT1lWzBdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlRpbGUgYHJlcGVhdHNgIGlucHV0IHNob3VsZCBoYXZlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzIGFzIHJhbmsgb2YgaW5wdXQgZGF0YSB0ZW5zb3JcIil9LG9nPShlLHQpPT57bGV0IHI9W107Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDsrK24pci5wdXNoKGVbbl0qdFtuXSk7cmV0dXJuIHJ9LGlnPShlLHQpPT57bGV0IHI9ZVswXS5kaW1zLG49dD8/RmwoZVsxXSksbz1vZyhyLG4pLGk9Qy5zaXplKG8pLGE9ZVswXS5kYXRhVHlwZSxkPUUoXCJpbnB1dFwiLGEsci5sZW5ndGgpLGw9TShcIm91dHB1dFwiLGEsby5sZW5ndGgpLHA9bT0+YFxuICAgICAgY29uc3QgaW5wdXRTaGFwZSA9ICR7ZC5pbmRpY2VzKC4uLnIpfTtcbiAgICAgICR7bS5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoZCxsKX1cbiAgICAgICR7bS5tYWluU3RhcnQoKX1cbiAgICAgICR7bS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke2wub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtkLnR5cGUuaW5kaWNlc307XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8ICR7ci5sZW5ndGh9OyBpKyspIHtcbiAgICAgICAgbGV0IGlucHV0X2RpbV9pID0gJHtkLmluZGljZXNHZXQoXCJ1bmlmb3Jtcy5pbnB1dF9zaGFwZVwiLFwiaVwiKX07XG4gICAgICAgIGxldCBpbnB1dF9kaW1fdmFsdWUgPSAke2wuaW5kaWNlc0dldChcIm91dHB1dF9pbmRpY2VzXCIsXCJpXCIpfSAgJSBpbnB1dF9kaW1faTtcblxuICAgICAgICAke2QuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixcImlcIixcImlucHV0X2RpbV92YWx1ZVwiKX1cbiAgICAgIH1cbiAgICAgICR7bC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixkLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIikpfVxuICAgIH1gO3JldHVybntuYW1lOlwiVGlsZVwiLHNoYWRlckNhY2hlOntoaW50OmAke259YCxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm8sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGkvNjQpfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjEyLGRhdGE6aX0sLi4uTihlWzBdLmRpbXMsbyldfSksZ2V0U2hhZGVyU291cmNlOnB9fSxxbD1lPT57bmcoZS5pbnB1dHMpLGUuY29tcHV0ZShpZyhlLmlucHV0cykse2lucHV0czpbMF19KX19KTt2YXIgYWcsc2csamwsWWw9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTthZSgpO2FnPShlLHQscixuLG8pPT57bGV0IGk9TShcIm91dHB1dF9kYXRhXCIsbyxyLmxlbmd0aCw0KSxhPUUoXCJhX2RhdGFcIix0WzFdLmRhdGFUeXBlLHRbMV0uZGltcy5sZW5ndGgsNCksZD1FKFwiYl9kYXRhXCIsdFsyXS5kYXRhVHlwZSx0WzJdLmRpbXMubGVuZ3RoLDQpLGw9RShcImNfZGF0YVwiLHRbMF0uZGF0YVR5cGUsdFswXS5kaW1zLmxlbmd0aCw0KSxwLG09KHUsaCxfKT0+YHNlbGVjdCgke2h9LCAke3V9LCAke199KWA7aWYoIW4pcD1pLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLG0oYS5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIiksZC5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIiksbC5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIikpKTtlbHNle2xldCB1PShoLF8seT1cIlwiKT0+e2xldCBnPWBhX2RhdGFbaW5kZXhfYSR7X31dW2NvbXBvbmVudF9hJHtffV1gLHg9YGJfZGF0YVtpbmRleF9iJHtffV1bY29tcG9uZW50X2Ike199XWAsJD1gYm9vbChjX2RhdGFbaW5kZXhfYyR7X31dICYgKDB4ZmZ1IDw8IChjb21wb25lbnRfYyR7X30gKiA4KSkpYDtyZXR1cm5gXG4gICAgICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMke199ID0gJHtpLm9mZnNldFRvSW5kaWNlcyhgZ2xvYmFsX2lkeCAqIDR1ICsgJHtffXVgKX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0X2Eke199ID0gJHthLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KGBvdXRwdXRfaW5kaWNlcyR7X31gLGkpfTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRfYiR7X30gPSAke2QuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dF9pbmRpY2VzJHtffWAsaSl9O1xuICAgICAgICAgICAgbGV0IG9mZnNldF9jJHtffSA9ICR7bC5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0X2luZGljZXMke199YCxpKX07XG4gICAgICAgICAgICBsZXQgaW5kZXhfYSR7X30gPSBvZmZzZXRfYSR7X30gLyA0dTtcbiAgICAgICAgICAgIGxldCBpbmRleF9iJHtffSA9IG9mZnNldF9iJHtffSAvIDR1O1xuICAgICAgICAgICAgbGV0IGluZGV4X2Mke199ID0gb2Zmc2V0X2Mke199IC8gNHU7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50X2Eke199ID0gb2Zmc2V0X2Eke199ICUgNHU7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50X2Ike199ID0gb2Zmc2V0X2Ike199ICUgNHU7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50X2Mke199ID0gb2Zmc2V0X2Mke199ICUgNHU7XG4gICAgICAgICAgICAke2h9WyR7X31dID0gJHt5fSgke20oZyx4LCQpfSk7XG4gICAgICAgICAgYH07bz09PTk/cD1gXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHZlYzQ8dTMyPigwKTtcbiAgICAgICAgICAgICR7dShcImRhdGFcIiwwLFwidTMyXCIpfVxuICAgICAgICAgICAgJHt1KFwiZGF0YVwiLDEsXCJ1MzJcIil9XG4gICAgICAgICAgICAke3UoXCJkYXRhXCIsMixcInUzMlwiKX1cbiAgICAgICAgICAgICR7dShcImRhdGFcIiwzLFwidTMyXCIpfVxuICAgICAgICAgICAgb3V0cHV0X2RhdGFbZ2xvYmFsX2lkeF0gPSBkb3QodmVjNDx1MzI+KDB4MSwgMHgxMDAsIDB4MTAwMDAsIDB4MTAwMDAwMCksIHZlYzQ8dTMyPihkYXRhKSk7YDpwPWBcbiAgICAgICAgICAgICR7dShcIm91dHB1dF9kYXRhW2dsb2JhbF9pZHhdXCIsMCl9XG4gICAgICAgICAgICAke3UoXCJvdXRwdXRfZGF0YVtnbG9iYWxfaWR4XVwiLDEpfVxuICAgICAgICAgICAgJHt1KFwib3V0cHV0X2RhdGFbZ2xvYmFsX2lkeF1cIiwyKX1cbiAgICAgICAgICAgICR7dShcIm91dHB1dF9kYXRhW2dsb2JhbF9pZHhdXCIsMyl9XG4gICAgICAgICAgYH1yZXR1cm5gXG4gICAgICAgICR7ZS5yZWdpc3RlclVuaWZvcm0oXCJ2ZWNfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMobCxhLGQsaSl9XG4gICAgICAgICR7ZS5tYWluU3RhcnQoKX1cbiAgICAgICAgJHtlLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy52ZWNfc2l6ZVwiKX1cbiAgICAgICAgJHtwfVxuICAgICAgfWB9LHNnPWU9PntsZXQgdD1lWzFdLmRpbXMscj1lWzJdLmRpbXMsbj1lWzBdLmRpbXMsbz1lWzFdLmRhdGFUeXBlLGk9IShDLmFyZUVxdWFsKHQscikmJkMuYXJlRXF1YWwocixuKSksYT10LGQ9Qy5zaXplKHQpO2lmKGkpe2xldCBwPXR0LmNhbGNTaGFwZSh0dC5jYWxjU2hhcGUodCxyLCExKSxuLCExKTtpZighcCl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBwZXJmb3JtIHdoZXJlIG9wIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO2E9cCxkPUMuc2l6ZShhKX1sZXQgbD1NYXRoLmNlaWwoZC80KTtyZXR1cm57bmFtZTpcIldoZXJlXCIsc2hhZGVyQ2FjaGU6e2lucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIixcInJhbmtcIixcInJhbmtcIl19LGdldFNoYWRlclNvdXJjZTpwPT5hZyhwLGUsYSxpLG8pLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6YSxkYXRhVHlwZTpvfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoZC82NC80KX0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZToxMixkYXRhOmx9LC4uLk4obix0LHIsYSldfSl9fSxqbD1lPT57ZS5jb21wdXRlKHNnKGUuaW5wdXRzKSl9fSk7dmFyIFpsLFFsPVUoKCk9PntcInVzZSBzdHJpY3RcIjtQcygpO0ZyKCk7RHMoKTtNcygpO3Z1KCk7enUoKTtCdSgpO1F1KCk7b2QoKTtzZCgpO2xkKCk7aGQoKTt5ZCgpO3dkKCk7eGQoKTtJZCgpO2tkKCk7emQoKTtCZCgpO1VkKCk7cWQoKTtZZCgpO1FkKCk7SmQoKTtybCgpO1NvKCk7b2woKTt2bCgpO1NsKCk7SWwoKTtrbCgpO0dyKCk7T2woKTtCbCgpO1JsKCk7V2woKTtIbCgpO0lvKCk7S2woKTtkdCgpO0tyKCk7WWwoKTtabD1uZXcgTWFwKFtbXCJBYnNcIixbUnNdXSxbXCJBY29zXCIsW1VzXV0sW1wiQWNvc2hcIixbTnNdXSxbXCJBZGRcIixbJHVdXSxbXCJBcmdNYXhcIixbRXMsY29dXSxbXCJBcmdNaW5cIixba3MsY29dXSxbXCJBc2luXCIsW1ZzXV0sW1wiQXNpbmhcIixbV3NdXSxbXCJBdGFuXCIsW0xzXV0sW1wiQXRhbmhcIixbR3NdXSxbXCJBdHRlbnRpb25cIixbenNdXSxbXCJBdmVyYWdlUG9vbFwiLFtwbCxjbF1dLFtcIkJhdGNoTm9ybWFsaXphdGlvblwiLFtPc11dLFtcIkJpYXNBZGRcIixbQnNdXSxbXCJCaWFzU3BsaXRHZWx1XCIsW3d1XV0sW1wiQ2FzdFwiLFtGcyxIc11dLFtcIkNlaWxcIixbS3NdXSxbXCJDbGlwXCIsW3FzXV0sW1wiQ29uY2F0XCIsW091LER1XV0sW1wiQ29udlwiLFt3byxfb11dLFtcIkNvbnZUcmFuc3Bvc2VcIixbbmQsdGRdXSxbXCJDb3NcIixbanNdXSxbXCJDb3NoXCIsW1lzXV0sW1wiQ3VtU3VtXCIsW2lkLGFkXV0sW1wiRGVwdGhUb1NwYWNlXCIsW3VkLGRkXV0sW1wiRGVxdWFudGl6ZUxpbmVhclwiLFskbCx4bF1dLFtcIkRpdlwiLFt4dV1dLFtcIkVpbnN1bVwiLFttZCxmZF1dLFtcIkVsdVwiLFtacyxYdF1dLFtcIkVxdWFsXCIsW1N1XV0sW1wiRXJmXCIsW1FzXV0sW1wiRXhwXCIsW1hzXV0sW1wiRXhwYW5kXCIsW2JkXV0sW1wiRmFzdEdlbHVcIixbX2RdXSxbXCJGbG9vclwiLFtKc11dLFtcIkZ1c2VkQ29udlwiLFt3byxfb11dLFtcIkdhdGhlclwiLFskZCx2ZF1dLFtcIkdhdGhlckVsZW1lbnRzXCIsW1BkLEVkXV0sW1wiR2F0aGVyQmxvY2tRdWFudGl6ZWRcIixbQ2QsQWRdXSxbXCJHYXRoZXJORFwiLFtTZCxUZF1dLFtcIkdlbHVcIixbZXVdXSxbXCJHZW1tXCIsW0RkLE9kXV0sW1wiR2xvYmFsQXZlcmFnZVBvb2xcIixbaGwsZmxdXSxbXCJHbG9iYWxNYXhQb29sXCIsW3dsLF9sXV0sW1wiR3JlYXRlclwiLFtBdV1dLFtcIkdyZWF0ZXJPckVxdWFsXCIsW0V1XV0sW1wiR3JpZFNhbXBsZVwiLFtNZCxSZF1dLFtcIkdyb3VwUXVlcnlBdHRlbnRpb25cIixbRmRdXSxbXCJIYXJkU2lnbW9pZFwiLFt1dSxzdV1dLFtcIkluc3RhbmNlTm9ybWFsaXphdGlvblwiLFtqZF1dLFtcIkxheWVyTm9ybWFsaXphdGlvblwiLFtaZF1dLFtcIkxlYWt5UmVsdVwiLFt0dSxYdF1dLFtcIkxlc3NcIixba3VdXSxbXCJMZXNzT3JFcXVhbFwiLFtQdV1dLFtcIkxvZ1wiLFtidV1dLFtcIk1hdE11bFwiLFtYZF1dLFtcIk1hdE11bE5CaXRzXCIsW2VsLHRsXV0sW1wiTWF4UG9vbFwiLFtibCx5bF1dLFtcIk11bFwiLFtUdV1dLFtcIk11bHRpSGVhZEF0dGVudGlvblwiLFtXZCxWZF1dLFtcIk5lZ1wiLFtudV1dLFtcIk5vdFwiLFtydV1dLFtcIlBhZFwiLFtubF1dLFtcIlBvd1wiLFtJdV1dLFtcIlF1aWNrR2VsdVwiLFt5dSxYdF1dLFtcIlJhbmdlXCIsW1RsXV0sW1wiUmVjaXByb2NhbFwiLFtvdV1dLFtcIlJlZHVjZU1pblwiLFt4c11dLFtcIlJlZHVjZU1lYW5cIixbeXNdXSxbXCJSZWR1Y2VNYXhcIixbJHNdXSxbXCJSZWR1Y2VTdW1cIixbVHNdXSxbXCJSZWR1Y2VQcm9kXCIsW1NzXV0sW1wiUmVkdWNlTDFcIixbX3NdXSxbXCJSZWR1Y2VMMlwiLFt3c11dLFtcIlJlZHVjZUxvZ1N1bVwiLFtDc11dLFtcIlJlZHVjZUxvZ1N1bUV4cFwiLFt2c11dLFtcIlJlZHVjZVN1bVNxdWFyZVwiLFtJc11dLFtcIlJlbHVcIixbaXVdXSxbXCJSZXNpemVcIixbUGwsemxdXSxbXCJSb3RhcnlFbWJlZGRpbmdcIixbRGxdXSxbXCJTY2F0dGVyTkRcIixbQWwsQ2xdXSxbXCJTaWdtb2lkXCIsW2F1XV0sW1wiU2luXCIsW2R1XV0sW1wiU2luaFwiLFtsdV1dLFtcIlNsaWNlXCIsW05sLFZsXV0sW1wiU2tpcExheWVyTm9ybWFsaXphdGlvblwiLFtNbF1dLFtcIlNwbGl0XCIsW0xkLEdkXV0sW1wiU3FydFwiLFtjdV1dLFtcIlNvZnRtYXhcIixbTGwsR2xdXSxbXCJTdWJcIixbQ3VdXSxbXCJUYW5cIixbcHVdXSxbXCJUYW5oXCIsW2Z1XV0sW1wiVGhyZXNob2xkZWRSZWx1XCIsW2d1LFh0XV0sW1wiVGlsZVwiLFtxbF1dLFtcIlRyYW5zcG9zZVwiLFtpcyxhc11dLFtcIldoZXJlXCIsW2psXV1dKX0pO3ZhciBubixYbD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7V2UoKTtldCgpO2FlKCk7bm49Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5iYWNrZW5kPXQ7dGhpcy5yZXBvPW5ldyBNYXAsdGhpcy5hdHRyaWJ1dGVzQm91bmQ9ITF9Z2V0QXJ0aWZhY3QodCl7cmV0dXJuIHRoaXMucmVwby5nZXQodCl9c2V0QXJ0aWZhY3QodCxyKXt0aGlzLnJlcG8uc2V0KHQscil9cnVuKHQscixuLG8saSl7VWUodC5wcm9ncmFtSW5mby5uYW1lKTtsZXQgYT10aGlzLmJhY2tlbmQuZGV2aWNlLGQ9dGhpcy5iYWNrZW5kLmdldENvbXB1dGVQYXNzRW5jb2RlcigpO3RoaXMuYmFja2VuZC53cml0ZVRpbWVzdGFtcCh0aGlzLmJhY2tlbmQucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKjIpO2xldCBsPVtdO2ZvcihsZXQgbSBvZiByKWwucHVzaCh7YmluZGluZzpsLmxlbmd0aCxyZXNvdXJjZTp7YnVmZmVyOm0uYnVmZmVyfX0pO2ZvcihsZXQgbSBvZiBuKWwucHVzaCh7YmluZGluZzpsLmxlbmd0aCxyZXNvdXJjZTp7YnVmZmVyOm0uYnVmZmVyfX0pO2kmJmwucHVzaCh7YmluZGluZzpsLmxlbmd0aCxyZXNvdXJjZTppfSk7bGV0IHA9YS5jcmVhdGVCaW5kR3JvdXAoe2xheW91dDp0LmNvbXB1dGVQaXBlbGluZS5nZXRCaW5kR3JvdXBMYXlvdXQoMCksZW50cmllczpsLGxhYmVsOnQucHJvZ3JhbUluZm8ubmFtZX0pO2lmKHRoaXMuYmFja2VuZC5zZXNzaW9uU3RhdHVzPT09XCJjYXB0dXJpbmdcIil7bGV0IG09e2tlcm5lbElkOnRoaXMuYmFja2VuZC5jdXJyZW50S2VybmVsSWQsY29tcHV0ZVBpcGVsaW5lOnQuY29tcHV0ZVBpcGVsaW5lLGJpbmRHcm91cDpwLGRpc3BhdGNoR3JvdXA6b307dGhpcy5iYWNrZW5kLmNhcHR1cmVkQ29tbWFuZExpc3QuZ2V0KHRoaXMuYmFja2VuZC5jdXJyZW50U2Vzc2lvbklkKS5wdXNoKG0pfWQuc2V0UGlwZWxpbmUodC5jb21wdXRlUGlwZWxpbmUpLGQuc2V0QmluZEdyb3VwKDAscCksZC5kaXNwYXRjaFdvcmtncm91cHMoLi4ubyksdGhpcy5iYWNrZW5kLndyaXRlVGltZXN0YW1wKHRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIqMisxKSx0aGlzLmJhY2tlbmQucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKyssKHRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXI+PXRoaXMuYmFja2VuZC5tYXhEaXNwYXRjaE51bWJlcnx8dGhpcy5iYWNrZW5kLnF1ZXJ5VHlwZT09PVwiYXQtcGFzc2VzXCIpJiZ0aGlzLmJhY2tlbmQuZW5kQ29tcHV0ZVBhc3MoKSx0aGlzLmJhY2tlbmQucGVuZGluZ0Rpc3BhdGNoTnVtYmVyPj10aGlzLmJhY2tlbmQubWF4RGlzcGF0Y2hOdW1iZXImJnRoaXMuYmFja2VuZC5mbHVzaCgpLERlKHQucHJvZ3JhbUluZm8ubmFtZSl9ZGlzcG9zZSgpe31idWlsZCh0LHIpe1VlKHQubmFtZSk7bGV0IG49dGhpcy5iYWNrZW5kLmRldmljZSxvPVtdO1t7ZmVhdHVyZTpcInNoYWRlci1mMTZcIixleHRlbnNpb246XCJmMTZcIn0se2ZlYXR1cmU6XCJzdWJncm91cHNcIixleHRlbnNpb246XCJzdWJncm91cHNcIn0se2ZlYXR1cmU6XCJzdWJncm91cHMtZjE2XCIsZXh0ZW5zaW9uOlwic3ViZ3JvdXBzX2YxNlwifV0uZm9yRWFjaCh1PT57bi5mZWF0dXJlcy5oYXModS5mZWF0dXJlKSYmby5wdXNoKGBlbmFibGUgJHt1LmV4dGVuc2lvbn07YCl9KTtsZXQgYT1ucyhyLHRoaXMuYmFja2VuZC5kZXZpY2UubGltaXRzKSxkPXQuZ2V0U2hhZGVyU291cmNlKGEpLGw9YCR7by5qb2luKGBcbmApfVxuJHthLmFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbnN9XG4ke2R9YCxwPW4uY3JlYXRlU2hhZGVyTW9kdWxlKHtjb2RlOmwsbGFiZWw6dC5uYW1lfSk7dWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSAke3QubmFtZX0gc2hhZGVyIGNvZGU6ICR7bH1gKTtsZXQgbT1uLmNyZWF0ZUNvbXB1dGVQaXBlbGluZSh7Y29tcHV0ZTp7bW9kdWxlOnAsZW50cnlQb2ludDpcIm1haW5cIn0sbGF5b3V0OlwiYXV0b1wiLGxhYmVsOnQubmFtZX0pO3JldHVybiBEZSh0Lm5hbWUpLHtwcm9ncmFtSW5mbzp0LGNvbXB1dGVQaXBlbGluZTptLHVuaWZvcm1WYXJpYWJsZXNJbmZvOmEudmFyaWFibGVzSW5mb319bm9ybWFsaXplRGlzcGF0Y2hHcm91cFNpemUodCl7bGV0IHI9dHlwZW9mIHQ9PVwibnVtYmVyXCI/dDp0Lngsbj10eXBlb2YgdD09XCJudW1iZXJcIj8xOnQueXx8MSxvPXR5cGVvZiB0PT1cIm51bWJlclwiPzE6dC56fHwxLGk9dGhpcy5iYWNrZW5kLmRldmljZS5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cHNQZXJEaW1lbnNpb247aWYocjw9aSYmbjw9aSYmbzw9aSlyZXR1cm5bcixuLG9dO2xldCBhPXIqbipvLGQ9TWF0aC5jZWlsKE1hdGguc3FydChhKSk7aWYoZD5pKXtpZihkPU1hdGguY2VpbChNYXRoLmNicnQoYSkpLGQ+aSl0aHJvdyBuZXcgRXJyb3IoXCJUb3RhbCBkaXNwYXRjaCBzaXplIGV4Y2VlZHMgV2ViR1BVIG1heGltdW0uXCIpO3JldHVybltkLGQsZF19ZWxzZSByZXR1cm5bZCxkLDFdfX19KTt2YXIgdWcsZGcsQ28sQW8sb24sSmw9VSgoKT0+e1widXNlIHN0cmljdFwiO1dlKCk7dGUoKTtldCgpO0puKCk7SmEoKTtRbCgpO1hsKCk7dWc9KGUsdCk9PntpZih0Lmxlbmd0aCE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgaW5wdXREZXBlbmRlbmNpZXMgbGVuZ3RoICR7dC5sZW5ndGh9IGlzIG5vdCBlcXVhbCB0byBpbnB1dFRlbnNvcnMgbGVuZ3RoICR7ZS5sZW5ndGh9LmApO2xldCByPVtdO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7KytuKXtsZXQgbz1lW25dLmRhdGFUeXBlO3N3aXRjaCh0W25dKXtjYXNlXCJub25lXCI6e3IucHVzaChcIlwiKTticmVha31jYXNlXCJ0eXBlXCI6e3IucHVzaChgJHtvfWApO2JyZWFrfWNhc2VcInJhbmtcIjp7bGV0IGk9ZVtuXS5kaW1zLmxlbmd0aDtyLnB1c2goYCR7b307JHtpfWApO2JyZWFrfWNhc2VcImRpbXNcIjp7bGV0IGk9ZVtuXS5kaW1zLmpvaW4oXCIsXCIpO3IucHVzaChgJHtvfTske2l9YCk7YnJlYWt9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGlucHV0IGRlcGVuZGVuY3k6ICR7dFtuXX1gKX19cmV0dXJuIHIuam9pbihcInxcIil9LGRnPShlLHQscik9PntsZXQgbj1lLm5hbWU7cmV0dXJuIGUuc2hhZGVyQ2FjaGU/LmhpbnQmJihuKz1cIltcIitlLnNoYWRlckNhY2hlLmhpbnQrXCJdXCIpLG4rPVwiOlwiK3IrYDoke3VnKHQsZS5zaGFkZXJDYWNoZT8uaW5wdXREZXBlbmRlbmNpZXM/P25ldyBBcnJheSh0Lmxlbmd0aCkuZmlsbChcImRpbXNcIikpfWAsbn0sQ289Y2xhc3N7Y29uc3RydWN0b3IodCl7dCYmKHRoaXMuYXJjaGl0ZWN0dXJlPXQuYXJjaGl0ZWN0dXJlLHRoaXMudmVuZG9yPXQudmVuZG9yKX1pc0FyY2hpdGVjdHVyZSh0KXtyZXR1cm4gdGhpcy5hcmNoaXRlY3R1cmU9PT10fWlzVmVuZG9yKHQpe3JldHVybiB0aGlzLnZlbmRvcj09PXR9fSxBbz1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLnN1Ymdyb3Vwc1N1cHBvcnRlZD10LmZlYXR1cmVzLmhhcyhcInN1Ymdyb3Vwc1wiKSx0aGlzLnN1Ymdyb3Vwc0YxNlN1cHBvcnRlZD10LmZlYXR1cmVzLmhhcyhcInN1Ymdyb3Vwc1wiKTtsZXQgcj10LmxpbWl0czshdGhpcy5zdWJncm91cHNTdXBwb3J0ZWR8fCFyLm1pblN1Ymdyb3VwU2l6ZXx8IXIubWF4U3ViZ3JvdXBTaXplP3RoaXMuc3ViZ3JvdXBTaXplUmFuZ2U9dm9pZCAwOnRoaXMuc3ViZ3JvdXBTaXplUmFuZ2U9W3IubWluU3ViZ3JvdXBTaXplLHIubWF4U3ViZ3JvdXBTaXplXX19LG9uPWNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5jdXJyZW50U2Vzc2lvbklkPW51bGw7dGhpcy5jdXJyZW50S2VybmVsSWQ9bnVsbDt0aGlzLmNvbW1hbmRFbmNvZGVyPW51bGw7dGhpcy5jb21wdXRlUGFzc0VuY29kZXI9bnVsbDt0aGlzLm1heERpc3BhdGNoTnVtYmVyPTE2O3RoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyPTA7dGhpcy5wZW5kaW5nS2VybmVscz1bXTt0aGlzLnBlbmRpbmdRdWVyaWVzPW5ldyBNYXA7dGhpcy5zZXNzaW9uU3RhdHVzPVwiZGVmYXVsdFwiO3RoaXMuY2FwdHVyZWRDb21tYW5kTGlzdD1uZXcgTWFwO3RoaXMuY2FwdHVyZWRQZW5kaW5nS2VybmVscz1uZXcgTWFwO3RoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmc9bmV3IE1hcH1nZXQgY3VycmVudEtlcm5lbEN1c3RvbURhdGEoKXtpZih0aGlzLmN1cnJlbnRLZXJuZWxJZD09PW51bGwpdGhyb3cgbmV3IEVycm9yKFwiY3VycmVudEtlcm5lbEN1c3RvbURhdGEoKTogY3VycmVudEtlcm5lbElkIGlzIG51bGwuIChzaG91bGQgbm90IGhhcHBlbilcIik7bGV0IHQ9dGhpcy5rZXJuZWxDdXN0b21EYXRhLmdldCh0aGlzLmN1cnJlbnRLZXJuZWxJZCk7cmV0dXJuIHR8fCh0PXt9LHRoaXMua2VybmVsQ3VzdG9tRGF0YS5zZXQodGhpcy5jdXJyZW50S2VybmVsSWQsdCkpLHR9YXN5bmMgaW5pdGlhbGl6ZSh0LHIpe3RoaXMuZW52PXQ7bGV0IG49W10sbz17cmVxdWlyZWRMaW1pdHM6e21heENvbXB1dGVXb3JrZ3JvdXBTdG9yYWdlU2l6ZTpyLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU3RvcmFnZVNpemUsbWF4Q29tcHV0ZVdvcmtncm91cHNQZXJEaW1lbnNpb246ci5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cHNQZXJEaW1lbnNpb24sbWF4U3RvcmFnZUJ1ZmZlckJpbmRpbmdTaXplOnIubGltaXRzLm1heFN0b3JhZ2VCdWZmZXJCaW5kaW5nU2l6ZSxtYXhCdWZmZXJTaXplOnIubGltaXRzLm1heEJ1ZmZlclNpemUsbWF4Q29tcHV0ZUludm9jYXRpb25zUGVyV29ya2dyb3VwOnIubGltaXRzLm1heENvbXB1dGVJbnZvY2F0aW9uc1Blcldvcmtncm91cCxtYXhDb21wdXRlV29ya2dyb3VwU2l6ZVg6ci5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVYLG1heENvbXB1dGVXb3JrZ3JvdXBTaXplWTpyLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVksbWF4Q29tcHV0ZVdvcmtncm91cFNpemVaOnIubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWn0scmVxdWlyZWRGZWF0dXJlczpufSxpPWE9PnIuZmVhdHVyZXMuaGFzKGEpJiZuLnB1c2goYSkmJiEwO2koXCJjaHJvbWl1bS1leHBlcmltZW50YWwtdGltZXN0YW1wLXF1ZXJ5LWluc2lkZS1wYXNzZXNcIil8fGkoXCJ0aW1lc3RhbXAtcXVlcnlcIiksaShcInNoYWRlci1mMTZcIiksaShcInN1Ymdyb3Vwc1wiKSYmaShcInN1Ymdyb3Vwcy1mMTZcIiksdGhpcy5kZXZpY2U9YXdhaXQgci5yZXF1ZXN0RGV2aWNlKG8pLHRoaXMuZGV2aWNlSW5mbz1uZXcgQW8odGhpcy5kZXZpY2UpLHRoaXMuYWRhcHRlckluZm89bmV3IENvKHIuaW5mb3x8YXdhaXQgci5yZXF1ZXN0QWRhcHRlckluZm8oKSksdGhpcy5ncHVEYXRhTWFuYWdlcj1YYSh0aGlzKSx0aGlzLnByb2dyYW1NYW5hZ2VyPW5ldyBubih0aGlzKSx0aGlzLmtlcm5lbHM9bmV3IE1hcCx0aGlzLmtlcm5lbFBlcnNpc3RlbnREYXRhPW5ldyBNYXAsdGhpcy5rZXJuZWxDdXN0b21EYXRhPW5ldyBNYXAsUnIodC5sb2dMZXZlbCwhIXQuZGVidWcpLHRoaXMuZGV2aWNlLm9udW5jYXB0dXJlZGVycm9yPWE9PnthLmVycm9yIGluc3RhbmNlb2YgR1BVVmFsaWRhdGlvbkVycm9yJiZjb25zb2xlLmVycm9yKGBBbiB1bmNhdWdodCBXZWJHUFUgdmFsaWRhdGlvbiBlcnJvciB3YXMgcmFpc2VkOiAke2EuZXJyb3IubWVzc2FnZX1gKX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuZW52LndlYmdwdSxcImRldmljZVwiLHt2YWx1ZTp0aGlzLmRldmljZSx3cml0YWJsZTohMSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLmVudi53ZWJncHUsXCJhZGFwdGVyXCIse3ZhbHVlOnIsd3JpdGFibGU6ITEsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITF9KSx0aGlzLnNldFF1ZXJ5VHlwZSgpfWRpc3Bvc2UoKXt0eXBlb2YgdGhpcy5xdWVyeVNldDxcInVcIiYmdGhpcy5xdWVyeVNldC5kZXN0cm95KCksdGhpcy5ncHVEYXRhTWFuYWdlci5kaXNwb3NlKCl9Z2V0Q29tbWFuZEVuY29kZXIoKXtyZXR1cm4gdGhpcy5jb21tYW5kRW5jb2Rlcnx8KHRoaXMuY29tbWFuZEVuY29kZXI9dGhpcy5kZXZpY2UuY3JlYXRlQ29tbWFuZEVuY29kZXIoKSksdGhpcy5jb21tYW5kRW5jb2Rlcn1nZXRDb21wdXRlUGFzc0VuY29kZXIoKXtpZighdGhpcy5jb21wdXRlUGFzc0VuY29kZXIpe2xldCB0PXRoaXMuZ2V0Q29tbWFuZEVuY29kZXIoKSxyPXt9O3RoaXMucXVlcnlUeXBlPT09XCJhdC1wYXNzZXNcIiYmKHIudGltZXN0YW1wV3JpdGVzPXtxdWVyeVNldDp0aGlzLnF1ZXJ5U2V0LGJlZ2lubmluZ09mUGFzc1dyaXRlSW5kZXg6dGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIqMixlbmRPZlBhc3NXcml0ZUluZGV4OnRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKjIrMX0pLHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyPXQuYmVnaW5Db21wdXRlUGFzcyhyKX1yZXR1cm4gdGhpcy5jb21wdXRlUGFzc0VuY29kZXJ9ZW5kQ29tcHV0ZVBhc3MoKXt0aGlzLmNvbXB1dGVQYXNzRW5jb2RlciYmKHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyLmVuZCgpLHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyPW51bGwpfWZsdXNoKCl7aWYoIXRoaXMuY29tbWFuZEVuY29kZXIpcmV0dXJuO1VlKCksdGhpcy5lbmRDb21wdXRlUGFzcygpO2xldCB0O3RoaXMucXVlcnlUeXBlIT09XCJub25lXCImJih0aGlzLmNvbW1hbmRFbmNvZGVyLnJlc29sdmVRdWVyeVNldCh0aGlzLnF1ZXJ5U2V0LDAsdGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIqMix0aGlzLnF1ZXJ5UmVzb2x2ZUJ1ZmZlciwwKSx0PXRoaXMuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7c2l6ZTp0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcioyKjgsdXNhZ2U6R1BVQnVmZmVyVXNhZ2UuTUFQX1JFQUR8R1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1R9KSx0aGlzLnBlbmRpbmdRdWVyaWVzLnNldCh0LHRoaXMucGVuZGluZ0tlcm5lbHMpLHRoaXMucGVuZGluZ0tlcm5lbHM9W10sdGhpcy5jb21tYW5kRW5jb2Rlci5jb3B5QnVmZmVyVG9CdWZmZXIodGhpcy5xdWVyeVJlc29sdmVCdWZmZXIsMCx0LDAsdGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIqMio4KSksdGhpcy5kZXZpY2UucXVldWUuc3VibWl0KFt0aGlzLmNvbW1hbmRFbmNvZGVyLmZpbmlzaCgpXSksdGhpcy5ncHVEYXRhTWFuYWdlci5yZWZyZXNoUGVuZGluZ0J1ZmZlcnMoKSx0aGlzLmNvbW1hbmRFbmNvZGVyPW51bGwsdGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXI9MCx0aGlzLnF1ZXJ5VHlwZSE9PVwibm9uZVwiJiZ0Lm1hcEFzeW5jKEdQVU1hcE1vZGUuUkVBRCkudGhlbigoKT0+e2xldCByPW5ldyBCaWdVaW50NjRBcnJheSh0LmdldE1hcHBlZFJhbmdlKCkpLG49dGhpcy5wZW5kaW5nUXVlcmllcy5nZXQodCk7Zm9yKGxldCBvPTA7bzxyLmxlbmd0aC8yO28rKyl7bGV0IGk9bltvXSxhPWkua2VybmVsSWQsZD10aGlzLmtlcm5lbHMuZ2V0KGEpLGw9ZC5rZXJuZWxUeXBlLHA9ZC5rZXJuZWxOYW1lLG09aS5wcm9ncmFtTmFtZSx1PWkuaW5wdXRUZW5zb3JWaWV3cyxoPWkub3V0cHV0VGVuc29yVmlld3MsXz1yW28qMl0seT1yW28qMisxXTt0eXBlb2YgdGhpcy5xdWVyeVRpbWVCYXNlPlwidVwiJiYodGhpcy5xdWVyeVRpbWVCYXNlPV8pO2xldCBnPU51bWJlcihfLXRoaXMucXVlcnlUaW1lQmFzZSkseD1OdW1iZXIoeS10aGlzLnF1ZXJ5VGltZUJhc2UpO2lmKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihnKXx8IU51bWJlci5pc1NhZmVJbnRlZ2VyKHgpKXRocm93IG5ldyBSYW5nZUVycm9yKFwiaW5jb3JyZWN0IHRpbWVzdGFtcCByYW5nZVwiKTtpZih0aGlzLmVudi53ZWJncHUucHJvZmlsaW5nPy5vbmRhdGEpdGhpcy5lbnYud2ViZ3B1LnByb2ZpbGluZy5vbmRhdGEoe3ZlcnNpb246MSxpbnB1dHNNZXRhZGF0YTp1Lm1hcCgkPT4oe2RpbXM6JC5kaW1zLGRhdGFUeXBlOmJ0KCQuZGF0YVR5cGUpfSkpLG91dHB1dHNNZXRhZGF0YTpoLm1hcCgkPT4oe2RpbXM6JC5kaW1zLGRhdGFUeXBlOmJ0KCQuZGF0YVR5cGUpfSkpLGtlcm5lbElkOmEsa2VybmVsVHlwZTpsLGtlcm5lbE5hbWU6cCxwcm9ncmFtTmFtZTptLHN0YXJ0VGltZTpnLGVuZFRpbWU6eH0pO2Vsc2V7bGV0ICQ9XCJcIjt1LmZvckVhY2goKFMsVCk9PnskKz1gaW5wdXRbJHtUfV06IFske1MuZGltc31dIHwgJHtidChTLmRhdGFUeXBlKX0sIGB9KTtsZXQgdj1cIlwiO2guZm9yRWFjaCgoUyxUKT0+e3YrPWBvdXRwdXRbJHtUfV06IFske1MuZGltc31dIHwgJHtidChTLmRhdGFUeXBlKX0sIGB9KSxjb25zb2xlLmxvZyhgW3Byb2ZpbGluZ10ga2VybmVsIFwiJHthfXwke2x9fCR7cH18JHttfVwiICR7JH0ke3Z9ZXhlY3V0aW9uIHRpbWU6ICR7eC1nfSBuc2ApfXdyKFwiR1BVXCIsYCR7bX06OiR7X306OiR7eX1gKX10LnVubWFwKCksdGhpcy5wZW5kaW5nUXVlcmllcy5kZWxldGUodCl9KSxEZSgpfXJ1bih0LHIsbixvLGksYSl7VWUodC5uYW1lKTtsZXQgZD1bXTtmb3IobGV0IFM9MDtTPHIubGVuZ3RoOysrUyl7bGV0IFQ9cltTXS5kYXRhO2lmKFQ9PT0wKWNvbnRpbnVlO2xldCBBPXRoaXMuZ3B1RGF0YU1hbmFnZXIuZ2V0KFQpO2lmKCFBKXRocm93IG5ldyBFcnJvcihgbm8gR1BVIGRhdGEgZm9yIGlucHV0OiAke1R9YCk7ZC5wdXNoKEEpfWxldHtvdXRwdXRzOmwsZGlzcGF0Y2hHcm91cDpwLHByb2dyYW1Vbmlmb3JtczptfT10LmdldFJ1bkRhdGEociksdT1uLmxlbmd0aD09PTA/bC5tYXAoKFMsVCk9PlQpOm47aWYodS5sZW5ndGghPT1sLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYE91dHB1dCBzaXplICR7dS5sZW5ndGh9IG11c3QgYmUgZXF1YWwgdG8gJHtsLmxlbmd0aH0uYCk7bGV0IGg9W10sXz1bXTtmb3IobGV0IFM9MDtTPGwubGVuZ3RoOysrUyl7aWYoIU51bWJlci5pc0ludGVnZXIodVtTXSl8fHVbU108LTN8fHVbU10+PWEpdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG91dHB1dCBpbmRleDogJHt1W1NdfWApO2lmKHVbU109PT0tMyljb250aW51ZTtsZXQgVD11W1NdPT09LTEsQT11W1NdPT09LTIsaz1UfHxBP2kobFtTXS5kYXRhVHlwZSxsW1NdLmRpbXMpOm8odVtTXSxsW1NdLmRhdGFUeXBlLGxbU10uZGltcyk7aWYoaC5wdXNoKGspLGsuZGF0YT09PTApY29udGludWU7bGV0IFA9dGhpcy5ncHVEYXRhTWFuYWdlci5nZXQoay5kYXRhKTtpZighUCl0aHJvdyBuZXcgRXJyb3IoYG5vIEdQVSBkYXRhIGZvciBvdXRwdXQ6ICR7ay5kYXRhfWApO2lmKFQmJnRoaXMudGVtcG9yYXJ5RGF0YS5wdXNoKFApLEEpe2xldCBEPXRoaXMua2VybmVsUGVyc2lzdGVudERhdGEuZ2V0KHRoaXMuY3VycmVudEtlcm5lbElkKTtEfHwoRD1bXSx0aGlzLmtlcm5lbFBlcnNpc3RlbnREYXRhLnNldCh0aGlzLmN1cnJlbnRLZXJuZWxJZCxEKSksRC5wdXNoKFApfV8ucHVzaChQKX1pZihkLmxlbmd0aCE9PXIubGVuZ3RofHxfLmxlbmd0aCE9PWgubGVuZ3RoKXtpZihfLmxlbmd0aD09PTApcmV0dXJuIERlKHQubmFtZSksaDt0aHJvdyBuZXcgRXJyb3IoYFByb2dyYW0gJHt0Lm5hbWV9IGhhcyB6ZXJvLXNpemVkIHRlbnNvcihzKSBpbiBpbnB1dHMgb3Igb3V0cHV0cy4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkIG5vdy5gKX1sZXQgeTtpZihtKXtsZXQgUz0wLFQ9W107bS5mb3JFYWNoKEQ9PntsZXQgUj10eXBlb2YgRC5kYXRhPT1cIm51bWJlclwiP1tELmRhdGFdOkQuZGF0YTtpZihSLmxlbmd0aD09PTApcmV0dXJuO2xldCBHPUQudHlwZT09PTEwPzI6NCxLLGo7RC50eXBlPT09MTA/KGo9Ui5sZW5ndGg+ND8xNjpSLmxlbmd0aD4yPzg6Ui5sZW5ndGgqRyxLPVIubGVuZ3RoPjQ/MTY6RypSLmxlbmd0aCk6KGo9Ui5sZW5ndGg8PTI/Ui5sZW5ndGgqRzoxNixLPTE2KSxTPU1hdGguY2VpbChTL2opKmosVC5wdXNoKFMpO2xldCBWPUQudHlwZT09PTEwPzg6NDtTKz1SLmxlbmd0aD40P01hdGguY2VpbChSLmxlbmd0aC9WKSpLOlIubGVuZ3RoKkd9KTtsZXQgQT0xNjtTPU1hdGguY2VpbChTL0EpKkE7bGV0IGs9bmV3IEFycmF5QnVmZmVyKFMpO20uZm9yRWFjaCgoRCxSKT0+e2xldCBHPVRbUl0sSz10eXBlb2YgRC5kYXRhPT1cIm51bWJlclwiP1tELmRhdGFdOkQuZGF0YTtpZihELnR5cGU9PT02KW5ldyBJbnQzMkFycmF5KGssRyxLLmxlbmd0aCkuc2V0KEspO2Vsc2UgaWYoRC50eXBlPT09MTIpbmV3IFVpbnQzMkFycmF5KGssRyxLLmxlbmd0aCkuc2V0KEspO2Vsc2UgaWYoRC50eXBlPT09MTApbmV3IFVpbnQxNkFycmF5KGssRyxLLmxlbmd0aCkuc2V0KEspO2Vsc2UgaWYoRC50eXBlPT09MSluZXcgRmxvYXQzMkFycmF5KGssRyxLLmxlbmd0aCkuc2V0KEspO2Vsc2UgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCB1bmlmb3JtIHR5cGU6ICR7YnQoRC50eXBlKX1gKX0pO2xldCBQPXRoaXMuZ3B1RGF0YU1hbmFnZXIuY3JlYXRlKFMsR1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1R8R1BVQnVmZmVyVXNhZ2UuVU5JRk9STSk7dGhpcy5kZXZpY2UucXVldWUud3JpdGVCdWZmZXIoUC5idWZmZXIsMCxrLDAsUyksdGhpcy5ncHVEYXRhTWFuYWdlci5yZWxlYXNlKFAuaWQpLHk9e29mZnNldDowLHNpemU6UyxidWZmZXI6UC5idWZmZXJ9fWxldCBnPXRoaXMucHJvZ3JhbU1hbmFnZXIubm9ybWFsaXplRGlzcGF0Y2hHcm91cFNpemUocCkseD1nWzFdPT09MSYmZ1syXT09PTEsJD1kZyh0LHIseCksdj10aGlzLnByb2dyYW1NYW5hZ2VyLmdldEFydGlmYWN0KCQpO2lmKHZ8fCh2PXRoaXMucHJvZ3JhbU1hbmFnZXIuYnVpbGQodCxnKSx0aGlzLnByb2dyYW1NYW5hZ2VyLnNldEFydGlmYWN0KCQsdiksdWUoXCJpbmZvXCIsKCk9PmBbYXJ0aWZhY3RdIGtleTogJHskfSwgcHJvZ3JhbU5hbWU6ICR7dC5uYW1lfWApKSxtJiZ2LnVuaWZvcm1WYXJpYWJsZXNJbmZvKXtpZihtLmxlbmd0aCE9PXYudW5pZm9ybVZhcmlhYmxlc0luZm8ubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgVW5pZm9ybSB2YXJpYWJsZXMgY291bnQgbWlzbWF0Y2g6IGV4cGVjdCAke3YudW5pZm9ybVZhcmlhYmxlc0luZm8ubGVuZ3RofSwgZ290ICR7bS5sZW5ndGh9IGluIHByb2dyYW0gXCIke3YucHJvZ3JhbUluZm8ubmFtZX1cIi5gKTtmb3IobGV0IFM9MDtTPG0ubGVuZ3RoO1MrKyl7bGV0IFQ9bVtTXSxBPVQudHlwZSxrPXR5cGVvZiBULmRhdGE9PVwibnVtYmVyXCI/MTpULmRhdGEubGVuZ3RoLFtQLERdPXYudW5pZm9ybVZhcmlhYmxlc0luZm9bU107aWYoQSE9PVB8fGshPT1EKXRocm93IG5ldyBFcnJvcihgVW5pZm9ybSB2YXJpYWJsZSAke1N9IG1pc21hdGNoOiBleHBlY3QgdHlwZSAke1B9IHdpdGggc2l6ZSAke0R9LCBnb3QgdHlwZSAke0F9IHdpdGggc2l6ZSAke2t9IGluIHByb2dyYW0gXCIke3YucHJvZ3JhbUluZm8ubmFtZX1cIi5gKX19aWYodWUoXCJpbmZvXCIsKCk9PmBbUHJvZ3JhbU1hbmFnZXJdIHJ1biBcIiR7dC5uYW1lfVwiIChrZXk9JHskfSkgd2l0aCAke2dbMF19eCR7Z1sxXX14JHtnWzJdfWApLHRoaXMucXVlcnlUeXBlIT09XCJub25lXCJ8fHRoaXMuc2Vzc2lvblN0YXR1cz09PVwiY2FwdHVyaW5nXCIpe2xldCBTPXtrZXJuZWxJZDp0aGlzLmN1cnJlbnRLZXJuZWxJZCxwcm9ncmFtTmFtZTp2LnByb2dyYW1JbmZvLm5hbWUsaW5wdXRUZW5zb3JWaWV3czpyLG91dHB1dFRlbnNvclZpZXdzOmh9O3RoaXMucGVuZGluZ0tlcm5lbHMucHVzaChTKSx0aGlzLnNlc3Npb25TdGF0dXM9PT1cImNhcHR1cmluZ1wiJiZ0aGlzLmNhcHR1cmVkUGVuZGluZ0tlcm5lbHMuZ2V0KHRoaXMuY3VycmVudFNlc3Npb25JZCkucHVzaChTKX1yZXR1cm4gdGhpcy5wcm9ncmFtTWFuYWdlci5ydW4odixkLF8sZyx5KSxEZSh0Lm5hbWUpLGh9dXBsb2FkKHQscil7dGhpcy5ncHVEYXRhTWFuYWdlci51cGxvYWQodCxyKX1tZW1jcHkodCxyKXt0aGlzLmdwdURhdGFNYW5hZ2VyLm1lbWNweSh0LHIpfWFzeW5jIGRvd25sb2FkKHQscil7YXdhaXQgdGhpcy5ncHVEYXRhTWFuYWdlci5kb3dubG9hZCh0LHIpfWFsbG9jKHQpe3JldHVybiB0aGlzLmdwdURhdGFNYW5hZ2VyLmNyZWF0ZSh0KS5pZH1mcmVlKHQpe3JldHVybiB0aGlzLmdwdURhdGFNYW5hZ2VyLnJlbGVhc2UodCl9Y3JlYXRlS2VybmVsKHQscixuLG8pe2xldCBpPVpsLmdldCh0KTtpZighaSl0aHJvdyBuZXcgRXJyb3IoYGtlcm5lbCBub3QgaW1wbGVtZW50ZWQ6ICR7dH1gKTtsZXQgYT17a2VybmVsVHlwZTp0LGtlcm5lbE5hbWU6byxrZXJuZWxFbnRyeTppWzBdLGF0dHJpYnV0ZXM6W2lbMV0sbl19O3RoaXMua2VybmVscy5zZXQocixhKX1yZWxlYXNlS2VybmVsKHQpe2xldCByPXRoaXMua2VybmVsUGVyc2lzdGVudERhdGEuZ2V0KHQpO2lmKHIpe2ZvcihsZXQgbiBvZiByKXRoaXMuZ3B1RGF0YU1hbmFnZXIucmVsZWFzZShuLmlkKTt0aGlzLmtlcm5lbFBlcnNpc3RlbnREYXRhLmRlbGV0ZSh0KX10aGlzLmtlcm5lbEN1c3RvbURhdGEuZGVsZXRlKHQpLHRoaXMua2VybmVscy5kZWxldGUodCl9Y29tcHV0ZUtlcm5lbCh0LHIsbil7bGV0IG89dGhpcy5rZXJuZWxzLmdldCh0KTtpZighbyl0aHJvdyBuZXcgRXJyb3IoYGtlcm5lbCBub3QgY3JlYXRlZDogJHt0fWApO2xldCBpPW8ua2VybmVsVHlwZSxhPW8ua2VybmVsTmFtZSxkPW8ua2VybmVsRW50cnksbD1vLmF0dHJpYnV0ZXM7aWYodGhpcy5jdXJyZW50S2VybmVsSWQhPT1udWxsKXRocm93IG5ldyBFcnJvcihga2VybmVsIFwiWyR7aX1dICR7YX1cIiBpcyBub3QgYWxsb3dlZCB0byBiZSBjYWxsZWQgcmVjdXJzaXZlbHlgKTt0aGlzLmN1cnJlbnRLZXJuZWxJZD10LGxbMF0mJihsWzFdPWxbMF0obFsxXSksbFswXT12b2lkIDApLHVlKFwiaW5mb1wiLCgpPT5gW1dlYkdQVV0gU3RhcnQgdG8gcnVuIGtlcm5lbCBcIlske2l9XSAke2F9XCIuLi5gKTtsZXQgcD10aGlzLmVudi5kZWJ1Zzt0aGlzLnRlbXBvcmFyeURhdGE9W107dHJ5e3JldHVybiBwJiZ0aGlzLmRldmljZS5wdXNoRXJyb3JTY29wZShcInZhbGlkYXRpb25cIiksZChyLGxbMV0pLDB9Y2F0Y2gobSl7cmV0dXJuIG4ucHVzaChQcm9taXNlLnJlc29sdmUoYFtXZWJHUFVdIEtlcm5lbCBcIlske2l9XSAke2F9XCIgZmFpbGVkLiAke219YCkpLDF9ZmluYWxseXtwJiZuLnB1c2godGhpcy5kZXZpY2UucG9wRXJyb3JTY29wZSgpLnRoZW4obT0+bT9gR1BVIHZhbGlkYXRpb24gZXJyb3IgZm9yIGtlcm5lbCBcIlske2l9XSAke2F9XCI6ICR7bS5tZXNzYWdlfWA6bnVsbCkpO2ZvcihsZXQgbSBvZiB0aGlzLnRlbXBvcmFyeURhdGEpdGhpcy5ncHVEYXRhTWFuYWdlci5yZWxlYXNlKG0uaWQpO3RoaXMudGVtcG9yYXJ5RGF0YT1bXSx0aGlzLmN1cnJlbnRLZXJuZWxJZD1udWxsfX1yZWdpc3RlckJ1ZmZlcih0LHIsbixvKXtsZXQgaT10aGlzLnNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nLmdldCh0KTtpfHwoaT1uZXcgTWFwLHRoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmcuc2V0KHQsaSkpO2xldCBhPWkuZ2V0KHIpLGQ9dGhpcy5ncHVEYXRhTWFuYWdlci5yZWdpc3RlckV4dGVybmFsQnVmZmVyKG4sbyxhKTtyZXR1cm4gaS5zZXQocixbZCxuXSksZH11bnJlZ2lzdGVyQnVmZmVycyh0KXtsZXQgcj10aGlzLnNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nLmdldCh0KTtyJiYoci5mb3JFYWNoKG49PnRoaXMuZ3B1RGF0YU1hbmFnZXIudW5yZWdpc3RlckV4dGVybmFsQnVmZmVyKG5bMF0pKSx0aGlzLnNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nLmRlbGV0ZSh0KSl9Z2V0QnVmZmVyKHQpe2xldCByPXRoaXMuZ3B1RGF0YU1hbmFnZXIuZ2V0KHQpO2lmKCFyKXRocm93IG5ldyBFcnJvcihgbm8gR1BVIGRhdGEgZm9yIGJ1ZmZlcjogJHt0fWApO3JldHVybiByLmJ1ZmZlcn1jcmVhdGVEb3dubG9hZGVyKHQscixuKXtyZXR1cm4gYXN5bmMoKT0+e2xldCBvPWF3YWl0IG5vKHRoaXMsdCxyKTtyZXR1cm4gVXIoby5idWZmZXIsbil9fXdyaXRlVGltZXN0YW1wKHQpe3RoaXMucXVlcnlUeXBlPT09XCJpbnNpZGUtcGFzc2VzXCImJnRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyLndyaXRlVGltZXN0YW1wKHRoaXMucXVlcnlTZXQsdCl9c2V0UXVlcnlUeXBlKCl7dGhpcy5xdWVyeVR5cGU9XCJub25lXCIsKHRoaXMuZW52LndlYmdwdS5wcm9maWxpbmc/Lm1vZGU9PT1cImRlZmF1bHRcInx8KHR5cGVvZiB0aGlzLmVudi50cmFjZT5cInVcIj90aGlzLmVudi53YXNtLnRyYWNlOnRoaXMuZW52LnRyYWNlKSkmJih0aGlzLmRldmljZS5mZWF0dXJlcy5oYXMoXCJjaHJvbWl1bS1leHBlcmltZW50YWwtdGltZXN0YW1wLXF1ZXJ5LWluc2lkZS1wYXNzZXNcIik/dGhpcy5xdWVyeVR5cGU9XCJpbnNpZGUtcGFzc2VzXCI6dGhpcy5kZXZpY2UuZmVhdHVyZXMuaGFzKFwidGltZXN0YW1wLXF1ZXJ5XCIpJiYodGhpcy5xdWVyeVR5cGU9XCJhdC1wYXNzZXNcIiksdGhpcy5xdWVyeVR5cGUhPT1cIm5vbmVcIiYmdHlwZW9mIHRoaXMucXVlcnlTZXQ+XCJ1XCImJih0aGlzLnF1ZXJ5U2V0PXRoaXMuZGV2aWNlLmNyZWF0ZVF1ZXJ5U2V0KHt0eXBlOlwidGltZXN0YW1wXCIsY291bnQ6dGhpcy5tYXhEaXNwYXRjaE51bWJlcioyfSksdGhpcy5xdWVyeVJlc29sdmVCdWZmZXI9dGhpcy5kZXZpY2UuY3JlYXRlQnVmZmVyKHtzaXplOnRoaXMubWF4RGlzcGF0Y2hOdW1iZXIqMio4LHVzYWdlOkdQVUJ1ZmZlclVzYWdlLkNPUFlfU1JDfEdQVUJ1ZmZlclVzYWdlLlFVRVJZX1JFU09MVkV9KSkpfWNhcHR1cmVCZWdpbigpe3VlKFwiaW5mb1wiLFwiY2FwdHVyZUJlZ2luXCIpLHRoaXMuY2FwdHVyZWRDb21tYW5kTGlzdC5nZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkKXx8dGhpcy5jYXB0dXJlZENvbW1hbmRMaXN0LnNldCh0aGlzLmN1cnJlbnRTZXNzaW9uSWQsW10pLHRoaXMuY2FwdHVyZWRQZW5kaW5nS2VybmVscy5nZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkKXx8dGhpcy5jYXB0dXJlZFBlbmRpbmdLZXJuZWxzLnNldCh0aGlzLmN1cnJlbnRTZXNzaW9uSWQsW10pLHRoaXMuZmx1c2goKSx0aGlzLnNlc3Npb25TdGF0dXM9XCJjYXB0dXJpbmdcIn1jYXB0dXJlRW5kKCl7dWUoXCJpbmZvXCIsXCJjYXB0dXJlRW5kXCIpLHRoaXMuZmx1c2goKSx0aGlzLnNlc3Npb25TdGF0dXM9XCJkZWZhdWx0XCJ9cmVwbGF5KCl7dWUoXCJpbmZvXCIsXCJyZXBsYXlcIiksdGhpcy5zZXNzaW9uU3RhdHVzPVwicmVwbGF5aW5nXCI7bGV0IHQ9dGhpcy5jYXB0dXJlZENvbW1hbmRMaXN0LmdldCh0aGlzLmN1cnJlbnRTZXNzaW9uSWQpLHI9dGhpcy5jYXB0dXJlZFBlbmRpbmdLZXJuZWxzLmdldCh0aGlzLmN1cnJlbnRTZXNzaW9uSWQpLG49dC5sZW5ndGg7dGhpcy5wZW5kaW5nS2VybmVscz1bXTtmb3IobGV0IG89MDtvPG47bysrKXtsZXQgaT10aGlzLmdldENvbXB1dGVQYXNzRW5jb2RlcigpLGE9dFtvXTt0aGlzLndyaXRlVGltZXN0YW1wKHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKjIpLGkuc2V0UGlwZWxpbmUoYS5jb21wdXRlUGlwZWxpbmUpLGkuc2V0QmluZEdyb3VwKDAsYS5iaW5kR3JvdXApLGkuZGlzcGF0Y2hXb3JrZ3JvdXBzKC4uLmEuZGlzcGF0Y2hHcm91cCksdGhpcy53cml0ZVRpbWVzdGFtcCh0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcioyKzEpLHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKyssdGhpcy5xdWVyeVR5cGUhPT1cIm5vbmVcIiYmdGhpcy5wZW5kaW5nS2VybmVscy5wdXNoKHJbb10pLCh0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcj49dGhpcy5tYXhEaXNwYXRjaE51bWJlcnx8dGhpcy5xdWVyeVR5cGU9PT1cImF0LXBhc3Nlc1wiKSYmdGhpcy5lbmRDb21wdXRlUGFzcygpLHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyPj10aGlzLm1heERpc3BhdGNoTnVtYmVyJiZ0aGlzLmZsdXNoKCl9dGhpcy5mbHVzaCgpLHRoaXMuc2Vzc2lvblN0YXR1cz1cImRlZmF1bHRcIn1vbkNyZWF0ZVNlc3Npb24oKXt0aGlzLmdwdURhdGFNYW5hZ2VyLm9uQ3JlYXRlU2Vzc2lvbigpfW9uUmVsZWFzZVNlc3Npb24odCl7dGhpcy51bnJlZ2lzdGVyQnVmZmVycyh0KSx0aGlzLmNhcHR1cmVkQ29tbWFuZExpc3QuaGFzKHQpJiZ0aGlzLmNhcHR1cmVkQ29tbWFuZExpc3QuZGVsZXRlKHQpLHRoaXMuY2FwdHVyZWRQZW5kaW5nS2VybmVscy5oYXModCkmJnRoaXMuY2FwdHVyZWRQZW5kaW5nS2VybmVscy5kZWxldGUodCksdGhpcy5ncHVEYXRhTWFuYWdlci5vblJlbGVhc2VTZXNzaW9uKHQpfW9uUnVuU3RhcnQodCl7dGhpcy5jdXJyZW50U2Vzc2lvbklkPXQsdGhpcy5zZXRRdWVyeVR5cGUoKX19fSk7dmFyIGxnLGVjLGNnLHRjLGFuLHNuLGtvLHJjLG5jPVUoKCk9PntcInVzZSBzdHJpY3RcIjtldCgpO2xnPTEsZWM9KCk9PmxnKyssY2c9bmV3IE1hcChbW1wiZmxvYXQzMlwiLDMyXSxbXCJmbG9hdDE2XCIsMTZdLFtcImludDMyXCIsMzJdLFtcInVpbnQzMlwiLDMyXSxbXCJpbnQ2NFwiLDY0XSxbXCJ1aW50NjRcIiw2NF0sW1wiaW50OFwiLDhdLFtcInVpbnQ4XCIsOF0sW1wiaW50NFwiLDRdLFtcInVpbnQ0XCIsNF1dKSx0Yz0oZSx0KT0+e2xldCByPWNnLmdldChlKTtpZighcil0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBkYXRhIHR5cGUuXCIpO3JldHVybiB0Lmxlbmd0aD4wP01hdGguY2VpbCh0LnJlZHVjZSgobixvKT0+bipvKSpyLzgpOjB9LGFuPWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMuc2Vzc2lvbklkPXQuc2Vzc2lvbklkLHRoaXMubWxDb250ZXh0PXQuY29udGV4dCx0aGlzLm1sVGVuc29yPXQudGVuc29yLHRoaXMuZGF0YVR5cGU9dC5kYXRhVHlwZSx0aGlzLnRlbnNvclNoYXBlPXQuc2hhcGV9Z2V0IHRlbnNvcigpe3JldHVybiB0aGlzLm1sVGVuc29yfWdldCB0eXBlKCl7cmV0dXJuIHRoaXMuZGF0YVR5cGV9Z2V0IHNoYXBlKCl7cmV0dXJuIHRoaXMudGVuc29yU2hhcGV9Z2V0IGJ5dGVMZW5ndGgoKXtyZXR1cm4gdGModGhpcy5kYXRhVHlwZSx0aGlzLnRlbnNvclNoYXBlKX1kZXN0cm95KCl7dWUoXCJ2ZXJib3NlXCIsKCk9PlwiW1dlYk5OXSBUZW5zb3JXcmFwcGVyLmRlc3Ryb3lcIiksdGhpcy5tbFRlbnNvci5kZXN0cm95KCl9d3JpdGUodCl7dGhpcy5tbENvbnRleHQud3JpdGVUZW5zb3IodGhpcy5tbFRlbnNvcix0KX1hc3luYyByZWFkKHQpe3JldHVybiB0P3RoaXMubWxDb250ZXh0LnJlYWRUZW5zb3IodGhpcy5tbFRlbnNvcix0KTp0aGlzLm1sQ29udGV4dC5yZWFkVGVuc29yKHRoaXMubWxUZW5zb3IpfWNhblJldXNlVGVuc29yKHQscixuKXtyZXR1cm4gdGhpcy5tbENvbnRleHQ9PT10JiZ0aGlzLmRhdGFUeXBlPT09ciYmdGhpcy50ZW5zb3JTaGFwZS5sZW5ndGg9PT1uLmxlbmd0aCYmdGhpcy50ZW5zb3JTaGFwZS5ldmVyeSgobyxpKT0+bz09PW5baV0pfX0sc249Y2xhc3N7Y29uc3RydWN0b3IodCxyKXt0aGlzLnRlbnNvck1hbmFnZXI9dDt0aGlzLndyYXBwZXI9cn1nZXQgdGVuc29yV3JhcHBlcigpe3JldHVybiB0aGlzLndyYXBwZXJ9cmVsZWFzZVRlbnNvcigpe3RoaXMudGVuc29yV3JhcHBlciYmKHRoaXMudGVuc29yTWFuYWdlci5yZWxlYXNlVGVuc29yKHRoaXMudGVuc29yV3JhcHBlciksdGhpcy53cmFwcGVyPXZvaWQgMCl9YXN5bmMgZW5zdXJlVGVuc29yKHQscixuLG8pe2lmKHRoaXMud3JhcHBlcil7aWYodGhpcy53cmFwcGVyLmNhblJldXNlVGVuc29yKHQscixuKSlyZXR1cm4gdGhpcy53cmFwcGVyLnRlbnNvcjtpZihvKXtpZih0aGlzLndyYXBwZXIuYnl0ZUxlbmd0aCE9PXRjKHIsbikpdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGNvcHkgZGF0YSB0byB0ZW5zb3Igd2l0aCBkaWZmZXJlbnQgc2l6ZS5cIik7dGhpcy5hY3RpdmVVcGxvYWQ9bmV3IFVpbnQ4QXJyYXkoYXdhaXQgdGhpcy53cmFwcGVyLnJlYWQoKSl9dGhpcy50ZW5zb3JNYW5hZ2VyLnJlbGVhc2VUZW5zb3IodGhpcy53cmFwcGVyKX1sZXQgaT10eXBlb2YgTUxUZW5zb3JVc2FnZT5cInVcIj92b2lkIDA6TUxUZW5zb3JVc2FnZS5SRUFEfE1MVGVuc29yVXNhZ2UuV1JJVEU7cmV0dXJuIHRoaXMud3JhcHBlcj1hd2FpdCB0aGlzLnRlbnNvck1hbmFnZXIuZ2V0Q2FjaGVkVGVuc29yKHIsbixpLCEwLCEwKSxvJiZ0aGlzLmFjdGl2ZVVwbG9hZCYmKHRoaXMud3JhcHBlci53cml0ZSh0aGlzLmFjdGl2ZVVwbG9hZCksdGhpcy5hY3RpdmVVcGxvYWQ9dm9pZCAwKSx0aGlzLndyYXBwZXIudGVuc29yfXVwbG9hZCh0KXtpZih0aGlzLndyYXBwZXIpaWYodC5ieXRlTGVuZ3RoPT09dGhpcy53cmFwcGVyLmJ5dGVMZW5ndGgpe3RoaXMud3JhcHBlci53cml0ZSh0KTtyZXR1cm59ZWxzZSB1ZShcInZlcmJvc2VcIiwoKT0+XCJEYXRhIHNpemUgZG9lcyBub3QgbWF0Y2ggdGVuc29yIHNpemUuIFJlbGVhc2luZyB0ZW5zb3IuXCIpLHRoaXMucmVsZWFzZVRlbnNvcigpO3RoaXMuYWN0aXZlVXBsb2FkP3RoaXMuYWN0aXZlVXBsb2FkLnNldCh0KTp0aGlzLmFjdGl2ZVVwbG9hZD1uZXcgVWludDhBcnJheSh0KX1hc3luYyBkb3dubG9hZCh0KXtpZih0aGlzLmFjdGl2ZVVwbG9hZClpZih0KXt0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXI/bmV3IFVpbnQ4QXJyYXkodCkuc2V0KHRoaXMuYWN0aXZlVXBsb2FkKTpuZXcgVWludDhBcnJheSh0LmJ1ZmZlcix0LmJ5dGVPZmZzZXQsdC5ieXRlTGVuZ3RoKS5zZXQodGhpcy5hY3RpdmVVcGxvYWQpO3JldHVybn1lbHNlIHJldHVybiB0aGlzLmFjdGl2ZVVwbG9hZC5idWZmZXI7aWYoIXRoaXMud3JhcHBlcil0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3IgaGFzIG5vdCBiZWVuIGNyZWF0ZWQuXCIpO3JldHVybiB0P3RoaXMud3JhcHBlci5yZWFkKHQpOnRoaXMud3JhcHBlci5yZWFkKCl9fSxrbz1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLmJhY2tlbmQ9dDt0aGlzLnRlbnNvclRyYWNrZXJzQnlJZD1uZXcgTWFwO3RoaXMuZnJlZVRlbnNvcnM9W107dGhpcy5leHRlcm5hbFRlbnNvcnM9bmV3IFNldH1yZXNlcnZlVGVuc29ySWQoKXtsZXQgdD1lYygpO3JldHVybiB0aGlzLnRlbnNvclRyYWNrZXJzQnlJZC5zZXQodCxuZXcgc24odGhpcykpLHR9cmVsZWFzZVRlbnNvcklkKHQpe2xldCByPXRoaXMudGVuc29yVHJhY2tlcnNCeUlkLmdldCh0KTtyJiYodGhpcy50ZW5zb3JUcmFja2Vyc0J5SWQuZGVsZXRlKHQpLHIudGVuc29yV3JhcHBlciYmdGhpcy5yZWxlYXNlVGVuc29yKHIudGVuc29yV3JhcHBlcikpfWFzeW5jIGVuc3VyZVRlbnNvcih0LHIsbixvKXt1ZShcInZlcmJvc2VcIiwoKT0+YFtXZWJOTl0gVGVuc29yTWFuYWdlci5lbnN1cmVUZW5zb3Ige3RlbnNvcklkOiAke3R9LCBkYXRhVHlwZTogJHtyfSwgc2hhcGU6ICR7bn0sIGNvcHlPbGQ6ICR7b319YCk7bGV0IGk9dGhpcy50ZW5zb3JUcmFja2Vyc0J5SWQuZ2V0KHQpO2lmKCFpKXRocm93IG5ldyBFcnJvcihcIlRlbnNvciBub3QgZm91bmQuXCIpO3JldHVybiBpLmVuc3VyZVRlbnNvcih0aGlzLmJhY2tlbmQuY3VycmVudENvbnRleHQscixuLG8pfXVwbG9hZCh0LHIpe2xldCBuPXRoaXMudGVuc29yVHJhY2tlcnNCeUlkLmdldCh0KTtpZighbil0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3Igbm90IGZvdW5kLlwiKTtuLnVwbG9hZChyKX1hc3luYyBkb3dubG9hZCh0LHIpe3VlKFwidmVyYm9zZVwiLCgpPT5gW1dlYk5OXSBUZW5zb3JNYW5hZ2VyLmRvd25sb2FkIHt0ZW5zb3JJZDogJHt0fSwgZHN0QnVmZmVyOiAke3I/LmJ5dGVMZW5ndGh9fWApO2xldCBuPXRoaXMudGVuc29yVHJhY2tlcnNCeUlkLmdldCh0KTtpZighbil0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3Igbm90IGZvdW5kLlwiKTtyZXR1cm4gbi5kb3dubG9hZChyKX1yZWxlYXNlVGVuc29yc0ZvclNlc3Npb24odCl7Zm9yKGxldCByIG9mIHRoaXMuZnJlZVRlbnNvcnMpci5zZXNzaW9uSWQ9PT10JiZyLmRlc3Ryb3koKTt0aGlzLmZyZWVUZW5zb3JzPXRoaXMuZnJlZVRlbnNvcnMuZmlsdGVyKHI9PnIuc2Vzc2lvbklkIT09dCl9cmVnaXN0ZXJUZW5zb3IodCxyLG4sbyl7bGV0IGk9ZWMoKSxhPW5ldyBhbih7c2Vzc2lvbklkOnRoaXMuYmFja2VuZC5jdXJyZW50U2Vzc2lvbklkLGNvbnRleHQ6dCx0ZW5zb3I6cixkYXRhVHlwZTpuLHNoYXBlOm99KTtyZXR1cm4gdGhpcy50ZW5zb3JUcmFja2Vyc0J5SWQuc2V0KGksbmV3IHNuKHRoaXMsYSkpLHRoaXMuZXh0ZXJuYWxUZW5zb3JzLmFkZChhKSxpfWFzeW5jIGdldENhY2hlZFRlbnNvcih0LHIsbixvLGkpe2xldCBhPXRoaXMuYmFja2VuZC5jdXJyZW50U2Vzc2lvbklkLGQ9dGhpcy5iYWNrZW5kLmN1cnJlbnRDb250ZXh0O2ZvcihsZXRbcCxtXW9mIHRoaXMuZnJlZVRlbnNvcnMuZW50cmllcygpKWlmKG0uY2FuUmV1c2VUZW5zb3IoZCx0LHIpKXt1ZShcInZlcmJvc2VcIiwoKT0+YFtXZWJOTl0gUmV1c2luZyB0ZW5zb3Ige2RhdGFUeXBlOiAke3R9LCBzaGFwZTogJHtyfX1gKTtsZXQgdT10aGlzLmZyZWVUZW5zb3JzLnNwbGljZShwLDEpWzBdO3JldHVybiB1LnNlc3Npb25JZD1hLHV9dWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViTk5dIE1MQ29udGV4dC5jcmVhdGVUZW5zb3Ige2RhdGFUeXBlOiAke3R9LCBzaGFwZTogJHtyfX1gKTtsZXQgbD1hd2FpdCBkLmNyZWF0ZVRlbnNvcih7ZGF0YVR5cGU6dCxzaGFwZTpyLGRpbWVuc2lvbnM6cix1c2FnZTpuLHdyaXRhYmxlOm8scmVhZGFibGU6aX0pO3JldHVybiBuZXcgYW4oe3Nlc3Npb25JZDphLGNvbnRleHQ6ZCx0ZW5zb3I6bCxkYXRhVHlwZTp0LHNoYXBlOnJ9KX1yZWxlYXNlVGVuc29yKHQpe3RoaXMuZXh0ZXJuYWxUZW5zb3JzLmhhcyh0KSYmdGhpcy5leHRlcm5hbFRlbnNvcnMuZGVsZXRlKHQpLHRoaXMuZnJlZVRlbnNvcnMucHVzaCh0KX19LHJjPSguLi5lKT0+bmV3IGtvKC4uLmUpfSk7dmFyIG9jLHBnLHVuLGljPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO2d0KCk7Sm4oKTtuYygpO2V0KCk7b2M9bmV3IE1hcChbWzEsXCJmbG9hdDMyXCJdLFsxMCxcImZsb2F0MTZcIl0sWzYsXCJpbnQzMlwiXSxbMTIsXCJ1aW50MzJcIl0sWzcsXCJpbnQ2NFwiXSxbMTMsXCJ1aW50NjRcIl0sWzIyLFwiaW50NFwiXSxbMjEsXCJ1aW50NFwiXSxbMyxcImludDhcIl0sWzIsXCJ1aW50OFwiXSxbOSxcInVpbnQ4XCJdXSkscGc9KGUsdCk9PntpZihlPT09dClyZXR1cm4hMDtpZihlPT09dm9pZCAwfHx0PT09dm9pZCAwKXJldHVybiExO2xldCByPU9iamVjdC5rZXlzKGUpLnNvcnQoKSxuPU9iamVjdC5rZXlzKHQpLnNvcnQoKTtyZXR1cm4gci5sZW5ndGg9PT1uLmxlbmd0aCYmci5ldmVyeSgobyxpKT0+bz09PW5baV0mJmVbb109PT10W29dKX0sdW49Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy50ZW5zb3JNYW5hZ2VyPXJjKHRoaXMpO3RoaXMubWxDb250ZXh0QnlTZXNzaW9uSWQ9bmV3IE1hcDt0aGlzLnNlc3Npb25JZHNCeU1MQ29udGV4dD1uZXcgTWFwO3RoaXMubWxDb250ZXh0Q2FjaGU9W107UnIodC5sb2dMZXZlbCwhIXQuZGVidWcpfWdldCBjdXJyZW50U2Vzc2lvbklkKCl7aWYodGhpcy5hY3RpdmVTZXNzaW9uSWQ9PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiTm8gYWN0aXZlIHNlc3Npb25cIik7cmV0dXJuIHRoaXMuYWN0aXZlU2Vzc2lvbklkfW9uUnVuU3RhcnQodCl7dGhpcy5hY3RpdmVTZXNzaW9uSWQ9dH1hc3luYyBjcmVhdGVNTENvbnRleHQodCl7aWYodCBpbnN0YW5jZW9mIEdQVURldmljZSl7bGV0IG49dGhpcy5tbENvbnRleHRDYWNoZS5maW5kSW5kZXgobz0+by5ncHVEZXZpY2U9PT10KTtpZihuIT09LTEpcmV0dXJuIHRoaXMubWxDb250ZXh0Q2FjaGVbbl0ubWxDb250ZXh0O3tsZXQgbz1hd2FpdCBuYXZpZ2F0b3IubWwuY3JlYXRlQ29udGV4dCh0KTtyZXR1cm4gdGhpcy5tbENvbnRleHRDYWNoZS5wdXNoKHtncHVEZXZpY2U6dCxtbENvbnRleHQ6b30pLG99fWVsc2UgaWYodD09PXZvaWQgMCl7bGV0IG49dGhpcy5tbENvbnRleHRDYWNoZS5maW5kSW5kZXgobz0+by5vcHRpb25zPT09dm9pZCAwJiZvLmdwdURldmljZT09PXZvaWQgMCk7aWYobiE9PS0xKXJldHVybiB0aGlzLm1sQ29udGV4dENhY2hlW25dLm1sQ29udGV4dDt7bGV0IG89YXdhaXQgbmF2aWdhdG9yLm1sLmNyZWF0ZUNvbnRleHQoKTtyZXR1cm4gdGhpcy5tbENvbnRleHRDYWNoZS5wdXNoKHttbENvbnRleHQ6b30pLG99fWxldCByPXRoaXMubWxDb250ZXh0Q2FjaGUuZmluZEluZGV4KG49PnBnKG4ub3B0aW9ucyx0KSk7aWYociE9PS0xKXJldHVybiB0aGlzLm1sQ29udGV4dENhY2hlW3JdLm1sQ29udGV4dDt7bGV0IG49YXdhaXQgbmF2aWdhdG9yLm1sLmNyZWF0ZUNvbnRleHQodCk7cmV0dXJuIHRoaXMubWxDb250ZXh0Q2FjaGUucHVzaCh7b3B0aW9uczp0LG1sQ29udGV4dDpufSksbn19Z2V0IGN1cnJlbnRDb250ZXh0KCl7bGV0IHQ9dGhpcy5nZXRNTENvbnRleHQodGhpcy5jdXJyZW50U2Vzc2lvbklkKTtpZighdCl0aHJvdyBuZXcgRXJyb3IoYE5vIE1MQ29udGV4dCBmb3VuZCBmb3Igc2Vzc2lvbiAke3RoaXMuY3VycmVudFNlc3Npb25JZH1gKTtyZXR1cm4gdH1yZWdpc3Rlck1MQ29udGV4dCh0LHIpe3RoaXMubWxDb250ZXh0QnlTZXNzaW9uSWQuc2V0KHQscik7bGV0IG49dGhpcy5zZXNzaW9uSWRzQnlNTENvbnRleHQuZ2V0KHIpO258fChuPW5ldyBTZXQsdGhpcy5zZXNzaW9uSWRzQnlNTENvbnRleHQuc2V0KHIsbikpLG4uYWRkKHQpfW9uUmVsZWFzZVNlc3Npb24odCl7bGV0IHI9dGhpcy5tbENvbnRleHRCeVNlc3Npb25JZC5nZXQodCk7aWYoIXIpcmV0dXJuO3RoaXMudGVuc29yTWFuYWdlci5yZWxlYXNlVGVuc29yc0ZvclNlc3Npb24odCksdGhpcy5tbENvbnRleHRCeVNlc3Npb25JZC5kZWxldGUodCk7bGV0IG49dGhpcy5zZXNzaW9uSWRzQnlNTENvbnRleHQuZ2V0KHIpO2lmKG4uZGVsZXRlKHQpLG4uc2l6ZT09PTApe3RoaXMuc2Vzc2lvbklkc0J5TUxDb250ZXh0LmRlbGV0ZShyKTtsZXQgbz10aGlzLm1sQ29udGV4dENhY2hlLmZpbmRJbmRleChpPT5pLm1sQ29udGV4dD09PXIpO28hPT0tMSYmdGhpcy5tbENvbnRleHRDYWNoZS5zcGxpY2UobywxKX19Z2V0TUxDb250ZXh0KHQpe3JldHVybiB0aGlzLm1sQ29udGV4dEJ5U2Vzc2lvbklkLmdldCh0KX1yZXNlcnZlVGVuc29ySWQoKXtyZXR1cm4gdGhpcy50ZW5zb3JNYW5hZ2VyLnJlc2VydmVUZW5zb3JJZCgpfXJlbGVhc2VUZW5zb3JJZCh0KXt1ZShcInZlcmJvc2VcIiwoKT0+YFtXZWJOTl0gcmVsZWFzZVRlbnNvcklkIHt0ZW5zb3JJZDogJHt0fX1gKSx0aGlzLnRlbnNvck1hbmFnZXIucmVsZWFzZVRlbnNvcklkKHQpfWFzeW5jIGVuc3VyZVRlbnNvcih0LHIsbixvKXtsZXQgaT1vYy5nZXQocik7aWYoIWkpdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBPTk5YIGRhdGEgdHlwZTogJHtyfWApO3JldHVybiB0aGlzLnRlbnNvck1hbmFnZXIuZW5zdXJlVGVuc29yKHQsaSxuLG8pfXVwbG9hZFRlbnNvcih0LHIpe2lmKCFJZSgpLnNob3VsZFRyYW5zZmVyVG9NTFRlbnNvcil0aHJvdyBuZXcgRXJyb3IoXCJUcnlpbmcgdG8gdXBsb2FkIHRvIGEgTUxUZW5zb3Igd2hpbGUgc2hvdWxkVHJhbnNmZXJUb01MVGVuc29yIGlzIGZhbHNlXCIpO3VlKFwidmVyYm9zZVwiLCgpPT5gW1dlYk5OXSB1cGxvYWRUZW5zb3Ige3RlbnNvcklkOiAke3R9LCBkYXRhOiAke3IuYnl0ZUxlbmd0aH19YCksdGhpcy50ZW5zb3JNYW5hZ2VyLnVwbG9hZCh0LHIpfWFzeW5jIGRvd25sb2FkVGVuc29yKHQscil7cmV0dXJuIHRoaXMudGVuc29yTWFuYWdlci5kb3dubG9hZCh0LHIpfWNyZWF0ZU1MVGVuc29yRG93bmxvYWRlcih0LHIpe3JldHVybiBhc3luYygpPT57bGV0IG49YXdhaXQgdGhpcy50ZW5zb3JNYW5hZ2VyLmRvd25sb2FkKHQpO3JldHVybiBVcihuLHIpfX1yZWdpc3Rlck1MVGVuc29yKHQscixuKXtsZXQgbz1vYy5nZXQocik7aWYoIW8pdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBPTk5YIGRhdGEgdHlwZTogJHtyfWApO2xldCBpPXRoaXMudGVuc29yTWFuYWdlci5yZWdpc3RlclRlbnNvcih0aGlzLmN1cnJlbnRDb250ZXh0LHQsbyxuKTtyZXR1cm4gdWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViTk5dIHJlZ2lzdGVyTUxUZW5zb3Ige3RlbnNvcjogJHt0fSwgZGF0YVR5cGU6ICR7b30sIGRpbWVuc2lvbnM6ICR7bn19IC0+IHt0ZW5zb3JJZDogJHtpfX1gKSxpfXJlZ2lzdGVyTUxDb25zdGFudCh0LHIsbixvLGksYSl7aWYoIWEpdGhyb3cgbmV3IEVycm9yKFwiRXh0ZXJuYWwgbW91bnRlZCBmaWxlcyBhcmUgbm90IGF2YWlsYWJsZS5cIik7bGV0IGQ9dDt0LnN0YXJ0c1dpdGgoXCIuL1wiKSYmKGQ9dC5zdWJzdHJpbmcoMikpO2xldCBsPWEuZ2V0KGQpO2lmKCFsKXRocm93IG5ldyBFcnJvcihgRmlsZSB3aXRoIG5hbWUgJHtkfSBub3QgZm91bmQgaW4gcHJlbG9hZGVkIGZpbGVzLmApO2lmKHIrbj5sLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiT3V0IG9mIGJvdW5kczogZGF0YSBvZmZzZXQgYW5kIGxlbmd0aCBleGNlZWQgdGhlIGV4dGVybmFsIGZpbGUgZGF0YSBzaXplLlwiKTtsZXQgcD1sLnNsaWNlKHIscituKS5idWZmZXIsbTtzd2l0Y2goaS5kYXRhVHlwZSl7Y2FzZVwiZmxvYXQzMlwiOm09bmV3IEZsb2F0MzJBcnJheShwKTticmVhaztjYXNlXCJmbG9hdDE2XCI6bT1uZXcgVWludDE2QXJyYXkocCk7YnJlYWs7Y2FzZVwiaW50MzJcIjptPW5ldyBJbnQzMkFycmF5KHApO2JyZWFrO2Nhc2VcInVpbnQzMlwiOm09bmV3IFVpbnQzMkFycmF5KHApO2JyZWFrO2Nhc2VcImludDY0XCI6bT1uZXcgQmlnSW50NjRBcnJheShwKTticmVhaztjYXNlXCJ1aW50NjRcIjptPW5ldyBCaWdVaW50NjRBcnJheShwKTticmVhaztjYXNlXCJpbnQ4XCI6bT1uZXcgSW50OEFycmF5KHApO2JyZWFrO2Nhc2VcImludDRcIjpjYXNlXCJ1aW50NFwiOmNhc2VcInVpbnQ4XCI6bT1uZXcgVWludDhBcnJheShwKTticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2kuZGF0YVR5cGV9IGluIGNyZWF0aW5nIFdlYk5OIENvbnN0YW50IGZyb20gZXh0ZXJuYWwgZGF0YS5gKX1yZXR1cm4gdWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViTk5dIHJlZ2lzdGVyTUxDb25zdGFudCB7ZGF0YVR5cGU6ICR7aS5kYXRhVHlwZX0sIHNoYXBlOiAke2kuc2hhcGV9fX1gKSxvLmNvbnN0YW50KGksbSl9Zmx1c2goKXt9fX0pO3ZhciBhYz17fTtGdChhYyx7aW5pdDooKT0+bWd9KTt2YXIgcnIsRW8sbWcsc2M9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7SmwoKTtldCgpO29lKCk7aWMoKTtycj1jbGFzcyBle2NvbnN0cnVjdG9yKHQscixuLG8pe3RoaXMubW9kdWxlPXQ7dGhpcy5kYXRhVHlwZT1yO3RoaXMuZGF0YT1uO3RoaXMuZGltcz1vfWdldEZsb2F0MzJBcnJheSgpe2lmKHRoaXMuZGF0YVR5cGUhPT0xKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0YSB0eXBlXCIpO2xldCB0PUMuc2l6ZSh0aGlzLmRpbXMpO3JldHVybiB0PT09MD9uZXcgRmxvYXQzMkFycmF5Om5ldyBGbG9hdDMyQXJyYXkodGhpcy5tb2R1bGUuSEVBUDguYnVmZmVyLHRoaXMuZGF0YSx0KX1nZXRCaWdJbnQ2NEFycmF5KCl7aWYodGhpcy5kYXRhVHlwZSE9PTcpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkYXRhIHR5cGVcIik7bGV0IHQ9Qy5zaXplKHRoaXMuZGltcyk7cmV0dXJuIHQ9PT0wP25ldyBCaWdJbnQ2NEFycmF5Om5ldyBCaWdJbnQ2NEFycmF5KHRoaXMubW9kdWxlLkhFQVA4LmJ1ZmZlcix0aGlzLmRhdGEsdCl9Z2V0SW50MzJBcnJheSgpe2lmKHRoaXMuZGF0YVR5cGUhPT02KXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0YSB0eXBlXCIpO2xldCB0PUMuc2l6ZSh0aGlzLmRpbXMpO3JldHVybiB0PT09MD9uZXcgSW50MzJBcnJheTpuZXcgSW50MzJBcnJheSh0aGlzLm1vZHVsZS5IRUFQOC5idWZmZXIsdGhpcy5kYXRhLHQpfWdldFVpbnQxNkFycmF5KCl7aWYodGhpcy5kYXRhVHlwZSE9PTEwJiZ0aGlzLmRhdGFUeXBlIT09NCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGEgdHlwZVwiKTtsZXQgdD1DLnNpemUodGhpcy5kaW1zKTtyZXR1cm4gdD09PTA/bmV3IFVpbnQxNkFycmF5Om5ldyBVaW50MTZBcnJheSh0aGlzLm1vZHVsZS5IRUFQOC5idWZmZXIsdGhpcy5kYXRhLHQpfXJlc2hhcGUodCl7aWYoQy5zaXplKHQpIT09Qy5zaXplKHRoaXMuZGltcykpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBuZXcgc2hhcGVcIik7cmV0dXJuIG5ldyBlKHRoaXMubW9kdWxlLHRoaXMuZGF0YVR5cGUsdGhpcy5kYXRhLHQpfX0sRW89Y2xhc3N7Y29uc3RydWN0b3IodCxyLG4pe3RoaXMubW9kdWxlPXQ7dGhpcy5iYWNrZW5kPXI7dGhpcy5jdXN0b21EYXRhT2Zmc2V0PTA7dGhpcy5jdXN0b21EYXRhU2l6ZT0wO3RoaXMuYWRhcHRlckluZm89ci5hZGFwdGVySW5mbyx0aGlzLmRldmljZUluZm89ci5kZXZpY2VJbmZvO2xldCBvPXQuUFRSX1NJWkUsaT1uL3QuUFRSX1NJWkUsYT1vPT09ND9cImkzMlwiOlwiaTY0XCI7dGhpcy5vcEtlcm5lbENvbnRleHQ9TnVtYmVyKHQuZ2V0VmFsdWUobyppKyssYSkpO2xldCBkPU51bWJlcih0LmdldFZhbHVlKG8qaSsrLGEpKTt0aGlzLm91dHB1dENvdW50PU51bWJlcih0LmdldFZhbHVlKG8qaSsrLGEpKSx0aGlzLmN1c3RvbURhdGFPZmZzZXQ9TnVtYmVyKHQuZ2V0VmFsdWUobyppKyssXCIqXCIpKSx0aGlzLmN1c3RvbURhdGFTaXplPU51bWJlcih0LmdldFZhbHVlKG8qaSsrLGEpKTtsZXQgbD1bXTtmb3IobGV0IHA9MDtwPGQ7cCsrKXtsZXQgbT1OdW1iZXIodC5nZXRWYWx1ZShvKmkrKyxhKSksdT1OdW1iZXIodC5nZXRWYWx1ZShvKmkrKyxcIipcIikpLGg9TnVtYmVyKHQuZ2V0VmFsdWUobyppKyssYSkpLF89W107Zm9yKGxldCB5PTA7eTxoO3krKylfLnB1c2goTnVtYmVyKHQuZ2V0VmFsdWUobyppKyssYSkpKTtsLnB1c2gobmV3IHJyKHQsbSx1LF8pKX10aGlzLmlucHV0cz1sfWdldCBrZXJuZWxDdXN0b21EYXRhKCl7cmV0dXJuIHRoaXMuYmFja2VuZC5jdXJyZW50S2VybmVsQ3VzdG9tRGF0YX1nZXQgY3VzdG9tRGF0YUJ1ZmZlcigpe3JldHVybiB0aGlzLm1vZHVsZS5IRUFQVTguc3ViYXJyYXkodGhpcy5jdXN0b21EYXRhT2Zmc2V0LHRoaXMuY3VzdG9tRGF0YU9mZnNldCt0aGlzLmN1c3RvbURhdGFTaXplKX1jb21wdXRlKHQscil7bGV0IG49cj8uaW5wdXRzPy5tYXAoZD0+dHlwZW9mIGQ9PVwibnVtYmVyXCI/dGhpcy5pbnB1dHNbZF06ZCk/P3RoaXMuaW5wdXRzLG89cj8ub3V0cHV0cz8/W10saT0oZCxsLHApPT5uZXcgcnIodGhpcy5tb2R1bGUsbCx0aGlzLm91dHB1dChkLHApLHApLGE9KGQsbCk9PntsZXQgcD1DdChkLGwpO2lmKCFwKXRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2R9YCk7bGV0IG09cD4wP3RoaXMuYmFja2VuZC5ncHVEYXRhTWFuYWdlci5jcmVhdGUocCkuaWQ6MDtyZXR1cm4gbmV3IHJyKHRoaXMubW9kdWxlLGQsbSxsKX07cmV0dXJuIHRoaXMuYmFja2VuZC5ydW4odCxuLG8saSxhLHRoaXMub3V0cHV0Q291bnQpfW91dHB1dCh0LHIpe2xldCBuPXRoaXMubW9kdWxlLnN0YWNrU2F2ZSgpO3RyeXtsZXQgbz10aGlzLm1vZHVsZS5QVFJfU0laRSxpPW89PT00P1wiaTMyXCI6XCJpNjRcIixhPXRoaXMubW9kdWxlLnN0YWNrQWxsb2MoKDErci5sZW5ndGgpKm8pO3RoaXMubW9kdWxlLnNldFZhbHVlKGEsci5sZW5ndGgsaSk7Zm9yKGxldCBkPTA7ZDxyLmxlbmd0aDtkKyspdGhpcy5tb2R1bGUuc2V0VmFsdWUoYStvKihkKzEpLHJbZF0saSk7cmV0dXJuIHRoaXMubW9kdWxlLl9Kc2VwT3V0cHV0KHRoaXMub3BLZXJuZWxDb250ZXh0LHQsYSl9Y2F0Y2gobyl7dGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZ2VuZXJhdGUga2VybmVsJ3Mgb3V0cHV0WyR7dH1dIHdpdGggZGltcyBbJHtyfV0uIElmIHlvdSBhcmUgcnVubmluZyB3aXRoIHByZS1hbGxvY2F0ZWQgb3V0cHV0LCBwbGVhc2UgbWFrZSBzdXJlIHRoZSBvdXRwdXQgdHlwZS9kaW1zIGFyZSBjb3JyZWN0LiBFcnJvcjogJHtvfWApfWZpbmFsbHl7dGhpcy5tb2R1bGUuc3RhY2tSZXN0b3JlKG4pfX19LG1nPWFzeW5jKGUsdCxyLG4pPT57bGV0IG89dC5qc2VwSW5pdDtpZighbyl0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gaW5pdGlhbGl6ZSBKU0VQLiBUaGUgV2ViQXNzZW1ibHkgbW9kdWxlIGlzIG5vdCBidWlsdCB3aXRoIEpTRVAgc3VwcG9ydC5cIik7aWYoZT09PVwid2ViZ3B1XCIpe2xldCBpPW5ldyBvbjthd2FpdCBpLmluaXRpYWxpemUocixuKSxvKFwid2ViZ3B1XCIsW2ksYT0+aS5hbGxvYyhOdW1iZXIoYSkpLGE9PmkuZnJlZShhKSwoYSxkLGwscD0hMSk9PntpZihwKXVlKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0ganNlcENvcHlHcHVUb0dwdTogc3JjPSR7TnVtYmVyKGEpfSwgZHN0PSR7TnVtYmVyKGQpfSwgc2l6ZT0ke051bWJlcihsKX1gKSxpLm1lbWNweShOdW1iZXIoYSksTnVtYmVyKGQpKTtlbHNle3VlKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0ganNlcENvcHlDcHVUb0dwdTogZGF0YU9mZnNldD0ke051bWJlcihhKX0sIGdwdURhdGFJZD0ke051bWJlcihkKX0sIHNpemU9JHtOdW1iZXIobCl9YCk7bGV0IG09dC5IRUFQVTguc3ViYXJyYXkoTnVtYmVyKGE+Pj4wKSxOdW1iZXIoYT4+PjApK051bWJlcihsKSk7aS51cGxvYWQoTnVtYmVyKGQpLG0pfX0sYXN5bmMoYSxkLGwpPT57dWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBqc2VwQ29weUdwdVRvQ3B1OiBncHVEYXRhSWQ9JHthfSwgZGF0YU9mZnNldD0ke2R9LCBzaXplPSR7bH1gKSxhd2FpdCBpLmRvd25sb2FkKE51bWJlcihhKSwoKT0+dC5IRUFQVTguc3ViYXJyYXkoTnVtYmVyKGQpPj4+MCxOdW1iZXIoZCtsKT4+PjApKX0sKGEsZCxsKT0+aS5jcmVhdGVLZXJuZWwoYSxOdW1iZXIoZCksbCx0LlVURjhUb1N0cmluZyh0Ll9Kc2VwR2V0Tm9kZU5hbWUoTnVtYmVyKGQpKSkpLGE9PmkucmVsZWFzZUtlcm5lbChhKSwoYSxkLGwscCk9Pnt1ZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIGpzZXBSdW46IHNlc3Npb25IYW5kbGU9JHtsfSwga2VybmVsPSR7YX0sIGNvbnRleHREYXRhT2Zmc2V0PSR7ZH1gKTtsZXQgbT1uZXcgRW8odCxpLE51bWJlcihkKSk7cmV0dXJuIGkuY29tcHV0ZUtlcm5lbChOdW1iZXIoYSksbSxwKX0sKCk9PmkuY2FwdHVyZUJlZ2luKCksKCk9PmkuY2FwdHVyZUVuZCgpLCgpPT5pLnJlcGxheSgpXSl9ZWxzZXtsZXQgaT1uZXcgdW4ocik7byhcIndlYm5uXCIsW2ksKCk9PmkucmVzZXJ2ZVRlbnNvcklkKCksYT0+aS5yZWxlYXNlVGVuc29ySWQoYSksYXN5bmMoYSxkLGwscCk9PmkuZW5zdXJlVGVuc29yKGEsZCxsLHApLChhLGQpPT57aS51cGxvYWRUZW5zb3IoYSxkKX0sYXN5bmMoYSxkKT0+aS5kb3dubG9hZFRlbnNvcihhLGQpXSl9fX0pO3ZhciBmZyxUcixJcixQdCxoZyxLdCxDcixBcix1YyxrcixFcixQcixxbj1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7SGEoKTtxYSgpO3RlKCk7Z3QoKTtPcigpO1huKCk7Zmc9KGUsdCk9PntJZSgpLl9PcnRJbml0KGUsdCkhPT0wJiZwZShcIkNhbid0IGluaXRpYWxpemUgb25ueHJ1bnRpbWUuXCIpfSxUcj1hc3luYyBlPT57ZmcoZS53YXNtLm51bVRocmVhZHMsWnQoZS5sb2dMZXZlbCkpfSxJcj1hc3luYyhlLHQpPT57e2xldCByPShzYygpLGJyKGFjKSkuaW5pdDtpZih0PT09XCJ3ZWJncHVcIil7aWYodHlwZW9mIG5hdmlnYXRvcj5cInVcInx8IW5hdmlnYXRvci5ncHUpdGhyb3cgbmV3IEVycm9yKFwiV2ViR1BVIGlzIG5vdCBzdXBwb3J0ZWQgaW4gY3VycmVudCBlbnZpcm9ubWVudFwiKTtsZXQgbj1lLndlYmdwdS5hZGFwdGVyO2lmKG4pe2lmKHR5cGVvZiBuLmxpbWl0cyE9XCJvYmplY3RcInx8dHlwZW9mIG4uZmVhdHVyZXMhPVwib2JqZWN0XCJ8fHR5cGVvZiBuLnJlcXVlc3REZXZpY2UhPVwiZnVuY3Rpb25cIil0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIEdQVSBhZGFwdGVyIHNldCBpbiBgZW52LndlYmdwdS5hZGFwdGVyYC4gSXQgbXVzdCBiZSBhIEdQVUFkYXB0ZXIgb2JqZWN0LlwiKX1lbHNle2xldCBvPWUud2ViZ3B1LnBvd2VyUHJlZmVyZW5jZTtpZihvIT09dm9pZCAwJiZvIT09XCJsb3ctcG93ZXJcIiYmbyE9PVwiaGlnaC1wZXJmb3JtYW5jZVwiKXRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwb3dlclByZWZlcmVuY2Ugc2V0dGluZzogXCIke299XCJgKTtsZXQgaT1lLndlYmdwdS5mb3JjZUZhbGxiYWNrQWRhcHRlcjtpZihpIT09dm9pZCAwJiZ0eXBlb2YgaSE9XCJib29sZWFuXCIpdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGZvcmNlRmFsbGJhY2tBZGFwdGVyIHNldHRpbmc6IFwiJHtpfVwiYCk7aWYobj1hd2FpdCBuYXZpZ2F0b3IuZ3B1LnJlcXVlc3RBZGFwdGVyKHtwb3dlclByZWZlcmVuY2U6byxmb3JjZUZhbGxiYWNrQWRhcHRlcjppfSksIW4pdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZ2V0IEdQVSBhZGFwdGVyLiBZb3UgbWF5IG5lZWQgdG8gZW5hYmxlIGZsYWcgXCItLWVuYWJsZS11bnNhZmUtd2ViZ3B1XCIgaWYgeW91IGFyZSB1c2luZyBDaHJvbWUuJyl9YXdhaXQgcihcIndlYmdwdVwiLEllKCksZSxuKX1pZih0PT09XCJ3ZWJublwiKXtpZih0eXBlb2YgbmF2aWdhdG9yPlwidVwifHwhbmF2aWdhdG9yLm1sKXRocm93IG5ldyBFcnJvcihcIldlYk5OIGlzIG5vdCBzdXBwb3J0ZWQgaW4gY3VycmVudCBlbnZpcm9ubWVudFwiKTthd2FpdCByKFwid2Vibm5cIixJZSgpLGUpfX19LFB0PW5ldyBNYXAsaGc9ZT0+e2xldCB0PUllKCkscj10LnN0YWNrU2F2ZSgpO3RyeXtsZXQgbj10LlBUUl9TSVpFLG89dC5zdGFja0FsbG9jKDIqbik7dC5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudChlLG8sbytuKSE9PTAmJnBlKFwiQ2FuJ3QgZ2V0IHNlc3Npb24gaW5wdXQvb3V0cHV0IGNvdW50LlwiKTtsZXQgYT1uPT09ND9cImkzMlwiOlwiaTY0XCI7cmV0dXJuW051bWJlcih0LmdldFZhbHVlKG8sYSkpLE51bWJlcih0LmdldFZhbHVlKG8rbixhKSldfWZpbmFsbHl7dC5zdGFja1Jlc3RvcmUocil9fSxLdD1lPT57bGV0IHQ9SWUoKSxyPXQuX21hbGxvYyhlLmJ5dGVMZW5ndGgpO2lmKHI9PT0wKXRocm93IG5ldyBFcnJvcihgQ2FuJ3QgY3JlYXRlIGEgc2Vzc2lvbi4gZmFpbGVkIHRvIGFsbG9jYXRlIGEgYnVmZmVyIG9mIHNpemUgJHtlLmJ5dGVMZW5ndGh9LmApO3JldHVybiB0LkhFQVBVOC5zZXQoZSxyKSxbcixlLmJ5dGVMZW5ndGhdfSxDcj1hc3luYyhlLHQpPT57bGV0IHIsbixvPUllKCk7QXJyYXkuaXNBcnJheShlKT9bcixuXT1lOmUuYnVmZmVyPT09by5IRUFQVTguYnVmZmVyP1tyLG5dPVtlLmJ5dGVPZmZzZXQsZS5ieXRlTGVuZ3RoXTpbcixuXT1LdChlKTtsZXQgaT0wLGE9MCxkPTAsbD1bXSxwPVtdLG09W107dHJ5e2lmKFthLGxdPUZhKHQpLHQ/LmV4dGVybmFsRGF0YSYmby5tb3VudEV4dGVybmFsRGF0YSl7bGV0IHY9W107Zm9yKGxldCBTIG9mIHQuZXh0ZXJuYWxEYXRhKXtsZXQgVD10eXBlb2YgUz09XCJzdHJpbmdcIj9TOlMucGF0aDt2LnB1c2goUXQodHlwZW9mIFM9PVwic3RyaW5nXCI/UzpTLmRhdGEpLnRoZW4oQT0+e28ubW91bnRFeHRlcm5hbERhdGEoVCxBKX0pKX1hd2FpdCBQcm9taXNlLmFsbCh2KX1mb3IobGV0IHYgb2YgdD8uZXhlY3V0aW9uUHJvdmlkZXJzPz9bXSlpZigodHlwZW9mIHY9PVwic3RyaW5nXCI/djp2Lm5hbWUpPT09XCJ3ZWJublwiKXtpZihvLnNob3VsZFRyYW5zZmVyVG9NTFRlbnNvcj0hMSx0eXBlb2YgdiE9XCJzdHJpbmdcIil7bGV0IFQ9dixBPVQ/LmNvbnRleHQsaz1UPy5ncHVEZXZpY2UsUD1UPy5kZXZpY2VUeXBlLEQ9VD8ucG93ZXJQcmVmZXJlbmNlO0E/by5jdXJyZW50Q29udGV4dD1BOms/by5jdXJyZW50Q29udGV4dD1hd2FpdCBvLmpzZXBDcmVhdGVNTENvbnRleHQoayk6by5jdXJyZW50Q29udGV4dD1hd2FpdCBvLmpzZXBDcmVhdGVNTENvbnRleHQoe2RldmljZVR5cGU6UCxwb3dlclByZWZlcmVuY2U6RH0pfWVsc2Ugby5jdXJyZW50Q29udGV4dD1hd2FpdCBvLmpzZXBDcmVhdGVNTENvbnRleHQoKTticmVha31pPWF3YWl0IG8uX09ydENyZWF0ZVNlc3Npb24ocixuLGEpLGk9PT0wJiZwZShcIkNhbid0IGNyZWF0ZSBhIHNlc3Npb24uXCIpLG8uanNlcE9uQ3JlYXRlU2Vzc2lvbj8uKCksby5jdXJyZW50Q29udGV4dCYmKG8uanNlcFJlZ2lzdGVyTUxDb250ZXh0KGksby5jdXJyZW50Q29udGV4dCksby5jdXJyZW50Q29udGV4dD12b2lkIDAsby5zaG91bGRUcmFuc2ZlclRvTUxUZW5zb3I9ITApO2xldFt1LGhdPWhnKGkpLF89ISF0Py5lbmFibGVHcmFwaENhcHR1cmUseT1bXSxnPVtdLHg9W107Zm9yKGxldCB2PTA7djx1O3YrKyl7bGV0IFM9by5fT3J0R2V0SW5wdXROYW1lKGksdik7Uz09PTAmJnBlKFwiQ2FuJ3QgZ2V0IGFuIGlucHV0IG5hbWUuXCIpLHAucHVzaChTKSx5LnB1c2goby5VVEY4VG9TdHJpbmcoUykpfWZvcihsZXQgdj0wO3Y8aDt2Kyspe2xldCBTPW8uX09ydEdldE91dHB1dE5hbWUoaSx2KTtTPT09MCYmcGUoXCJDYW4ndCBnZXQgYW4gb3V0cHV0IG5hbWUuXCIpLG0ucHVzaChTKTtsZXQgVD1vLlVURjhUb1N0cmluZyhTKTtnLnB1c2goVCk7e2lmKF8mJnQ/LnByZWZlcnJlZE91dHB1dExvY2F0aW9uPT09dm9pZCAwKXt4LnB1c2goXCJncHUtYnVmZmVyXCIpO2NvbnRpbnVlfWxldCBBPXR5cGVvZiB0Py5wcmVmZXJyZWRPdXRwdXRMb2NhdGlvbj09XCJzdHJpbmdcIj90LnByZWZlcnJlZE91dHB1dExvY2F0aW9uOnQ/LnByZWZlcnJlZE91dHB1dExvY2F0aW9uPy5bVF0/P1wiY3B1XCI7aWYoQSE9PVwiY3B1XCImJkEhPT1cImNwdS1waW5uZWRcIiYmQSE9PVwiZ3B1LWJ1ZmZlclwiJiZBIT09XCJtbC10ZW5zb3JcIil0aHJvdyBuZXcgRXJyb3IoYE5vdCBzdXBwb3J0ZWQgcHJlZmVycmVkIG91dHB1dCBsb2NhdGlvbjogJHtBfS5gKTtpZihfJiZBIT09XCJncHUtYnVmZmVyXCIpdGhyb3cgbmV3IEVycm9yKGBOb3Qgc3VwcG9ydGVkIHByZWZlcnJlZCBvdXRwdXQgbG9jYXRpb246ICR7QX0uIE9ubHkgJ2dwdS1idWZmZXInIGxvY2F0aW9uIGlzIHN1cHBvcnRlZCB3aGVuIGVuYWJsZUdyYXBoQ2FwdHVyZSBpcyB0cnVlLmApO3gucHVzaChBKX19bGV0ICQ9bnVsbDtyZXR1cm4geC5zb21lKHY9PnY9PT1cImdwdS1idWZmZXJcInx8dj09PVwibWwtdGVuc29yXCIpJiYoZD1vLl9PcnRDcmVhdGVCaW5kaW5nKGkpLGQ9PT0wJiZwZShcIkNhbid0IGNyZWF0ZSBJTyBiaW5kaW5nLlwiKSwkPXtoYW5kbGU6ZCxvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnM6eCxvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNFbmNvZGVkOngubWFwKHY9PlFuKHYpKX0pLFB0LnNldChpLFtpLHAsbSwkLF8sITFdKSxbaSx5LGddfWNhdGNoKHUpe3Rocm93IHAuZm9yRWFjaChoPT5vLl9PcnRGcmVlKGgpKSxtLmZvckVhY2goaD0+by5fT3J0RnJlZShoKSksZCE9PTAmJm8uX09ydFJlbGVhc2VCaW5kaW5nKGQpIT09MCYmcGUoXCJDYW4ndCByZWxlYXNlIElPIGJpbmRpbmcuXCIpLGkhPT0wJiZvLl9PcnRSZWxlYXNlU2Vzc2lvbihpKSE9PTAmJnBlKFwiQ2FuJ3QgcmVsZWFzZSBzZXNzaW9uLlwiKSx1fWZpbmFsbHl7by5fZnJlZShyKSxhIT09MCYmby5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zKGEpIT09MCYmcGUoXCJDYW4ndCByZWxlYXNlIHNlc3Npb24gb3B0aW9ucy5cIiksbC5mb3JFYWNoKHU9Pm8uX2ZyZWUodSkpLG8udW5tb3VudEV4dGVybmFsRGF0YT8uKCl9fSxBcj1lPT57bGV0IHQ9SWUoKSxyPVB0LmdldChlKTtpZighcil0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZWxlYXNlIHNlc3Npb24uIGludmFsaWQgc2Vzc2lvbiBpZDogJHtlfWApO2xldFtuLG8saSxhLGRdPXI7YSYmKGQmJnQuX09ydENsZWFyQm91bmRPdXRwdXRzKGEuaGFuZGxlKSE9PTAmJnBlKFwiQ2FuJ3QgY2xlYXIgYm91bmQgb3V0cHV0cy5cIiksdC5fT3J0UmVsZWFzZUJpbmRpbmcoYS5oYW5kbGUpIT09MCYmcGUoXCJDYW4ndCByZWxlYXNlIElPIGJpbmRpbmcuXCIpKSx0LmpzZXBPblJlbGVhc2VTZXNzaW9uPy4oZSksby5mb3JFYWNoKGw9PnQuX09ydEZyZWUobCkpLGkuZm9yRWFjaChsPT50Ll9PcnRGcmVlKGwpKSx0Ll9PcnRSZWxlYXNlU2Vzc2lvbihuKSE9PTAmJnBlKFwiQ2FuJ3QgcmVsZWFzZSBzZXNzaW9uLlwiKSxQdC5kZWxldGUoZSl9LHVjPShlLHQscixuLG8saT0hMSk9PntpZighZSl7dC5wdXNoKDApO3JldHVybn1sZXQgYT1JZSgpLGQ9YS5QVFJfU0laRSxsPWVbMF0scD1lWzFdLG09ZVszXSx1LGg7aWYobD09PVwic3RyaW5nXCImJihtPT09XCJncHUtYnVmZmVyXCJ8fG09PT1cIm1sLXRlbnNvclwiKSl0aHJvdyBuZXcgRXJyb3IoXCJTdHJpbmcgdGVuc29yIGlzIG5vdCBzdXBwb3J0ZWQgb24gR1BVLlwiKTtpZihpJiZtIT09XCJncHUtYnVmZmVyXCIpdGhyb3cgbmV3IEVycm9yKGBFeHRlcm5hbCBidWZmZXIgbXVzdCBiZSBwcm92aWRlZCBmb3IgaW5wdXQvb3V0cHV0IGluZGV4ICR7b30gd2hlbiBlbmFibGVHcmFwaENhcHR1cmUgaXMgdHJ1ZS5gKTtpZihtPT09XCJncHUtYnVmZmVyXCIpe2xldCBnPWVbMl0uZ3B1QnVmZmVyO2g9Q3QoWXQobCkscCk7bGV0IHg9YS5qc2VwUmVnaXN0ZXJCdWZmZXI7aWYoIXgpdGhyb3cgbmV3IEVycm9yKCdUZW5zb3IgbG9jYXRpb24gXCJncHUtYnVmZmVyXCIgaXMgbm90IHN1cHBvcnRlZCB3aXRob3V0IHVzaW5nIFdlYkdQVS4nKTt1PXgobixvLGcsaCl9ZWxzZSBpZihtPT09XCJtbC10ZW5zb3JcIil7bGV0IGc9ZVsyXS5tbFRlbnNvcjtoPUN0KFl0KGwpLHApO2xldCB4PWEuanNlcFJlZ2lzdGVyTUxUZW5zb3I7aWYoIXgpdGhyb3cgbmV3IEVycm9yKCdUZW5zb3IgbG9jYXRpb24gXCJtbC10ZW5zb3JcIiBpcyBub3Qgc3VwcG9ydGVkIHdpdGhvdXQgdXNpbmcgV2ViTk4uJyk7dT14KGcsWXQobCkscCl9ZWxzZXtsZXQgZz1lWzJdO2lmKEFycmF5LmlzQXJyYXkoZykpe2g9ZCpnLmxlbmd0aCx1PWEuX21hbGxvYyhoKSxyLnB1c2godSk7Zm9yKGxldCB4PTA7eDxnLmxlbmd0aDt4Kyspe2lmKHR5cGVvZiBnW3hdIT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoYHRlbnNvciBkYXRhIGF0IGluZGV4ICR7eH0gaXMgbm90IGEgc3RyaW5nYCk7YS5zZXRWYWx1ZSh1K3gqZCxrZShnW3hdLHIpLFwiKlwiKX19ZWxzZSBoPWcuYnl0ZUxlbmd0aCx1PWEuX21hbGxvYyhoKSxyLnB1c2godSksYS5IRUFQVTguc2V0KG5ldyBVaW50OEFycmF5KGcuYnVmZmVyLGcuYnl0ZU9mZnNldCxoKSx1KX1sZXQgXz1hLnN0YWNrU2F2ZSgpLHk9YS5zdGFja0FsbG9jKDQqcC5sZW5ndGgpO3RyeXtwLmZvckVhY2goKHgsJCk9PmEuc2V0VmFsdWUoeSskKmQseCxkPT09ND9cImkzMlwiOlwiaTY0XCIpKTtsZXQgZz1hLl9PcnRDcmVhdGVUZW5zb3IoWXQobCksdSxoLHkscC5sZW5ndGgsUW4obSkpO2c9PT0wJiZwZShgQ2FuJ3QgY3JlYXRlIHRlbnNvciBmb3IgaW5wdXQvb3V0cHV0LiBzZXNzaW9uPSR7bn0sIGluZGV4PSR7b30uYCksdC5wdXNoKGcpfWZpbmFsbHl7YS5zdGFja1Jlc3RvcmUoXyl9fSxrcj1hc3luYyhlLHQscixuLG8saSk9PntsZXQgYT1JZSgpLGQ9YS5QVFJfU0laRSxsPVB0LmdldChlKTtpZighbCl0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBydW4gaW5mZXJlbmNlLiBpbnZhbGlkIHNlc3Npb24gaWQ6ICR7ZX1gKTtsZXQgcD1sWzBdLG09bFsxXSx1PWxbMl0saD1sWzNdLF89bFs0XSx5PWxbNV0sZz10Lmxlbmd0aCx4PW4ubGVuZ3RoLCQ9MCx2PVtdLFM9W10sVD1bXSxBPVtdLGs9YS5zdGFja1NhdmUoKSxQPWEuc3RhY2tBbGxvYyhnKmQpLEQ9YS5zdGFja0FsbG9jKGcqZCksUj1hLnN0YWNrQWxsb2MoeCpkKSxHPWEuc3RhY2tBbGxvYyh4KmQpO3RyeXthLmpzZXBPblJ1blN0YXJ0Py4ocCksWyQsdl09R2EoaSk7Zm9yKGxldCBWPTA7VjxnO1YrKyl1YyhyW1ZdLFMsQSxlLHRbVl0sXyk7Zm9yKGxldCBWPTA7Vjx4O1YrKyl1YyhvW1ZdLFQsQSxlLGcrbltWXSxfKTtmb3IobGV0IFY9MDtWPGc7VisrKWEuc2V0VmFsdWUoUCtWKmQsU1tWXSxcIipcIiksYS5zZXRWYWx1ZShEK1YqZCxtW3RbVl1dLFwiKlwiKTtmb3IobGV0IFY9MDtWPHg7VisrKWEuc2V0VmFsdWUoUitWKmQsVFtWXSxcIipcIiksYS5zZXRWYWx1ZShHK1YqZCx1W25bVl1dLFwiKlwiKTtpZihoJiYheSl7bGV0e2hhbmRsZTpWLG91dHB1dFByZWZlcnJlZExvY2F0aW9uczpRLG91dHB1dFByZWZlcnJlZExvY2F0aW9uc0VuY29kZWQ6c2V9PWg7aWYobS5sZW5ndGghPT1nKXRocm93IG5ldyBFcnJvcihgaW5wdXQgY291bnQgZnJvbSBmZWVkcyAoJHtnfSkgaXMgZXhwZWN0ZWQgdG8gYmUgYWx3YXlzIGVxdWFsIHRvIG1vZGVsJ3MgaW5wdXQgY291bnQgKCR7bS5sZW5ndGh9KS5gKTtmb3IobGV0IFk9MDtZPGc7WSsrKXtsZXQgZWU9dFtZXTthd2FpdCBhLl9PcnRCaW5kSW5wdXQoVixtW2VlXSxTW1ldKSE9PTAmJnBlKGBDYW4ndCBiaW5kIGlucHV0WyR7WX1dIGZvciBzZXNzaW9uPSR7ZX0uYCl9Zm9yKGxldCBZPTA7WTx4O1krKyl7bGV0IGVlPW5bWV07b1tZXT8uWzNdP2EuX09ydEJpbmRPdXRwdXQoVix1W2VlXSxUW1ldLDApIT09MCYmcGUoYENhbid0IGJpbmQgcHJlLWFsbG9jYXRlZCBvdXRwdXRbJHtZfV0gZm9yIHNlc3Npb249JHtlfS5gKTphLl9PcnRCaW5kT3V0cHV0KFYsdVtlZV0sMCxzZVtlZV0pIT09MCYmcGUoYENhbid0IGJpbmQgb3V0cHV0WyR7WX1dIHRvICR7UVtZXX0gZm9yIHNlc3Npb249JHtlfS5gKX1QdC5zZXQoZSxbcCxtLHUsaCxfLCEwXSl9bGV0IEs7aD9LPWF3YWl0IGEuX09ydFJ1bldpdGhCaW5kaW5nKHAsaC5oYW5kbGUseCxSLCQpOks9YXdhaXQgYS5fT3J0UnVuKHAsRCxQLGcsRyx4LFIsJCksSyE9PTAmJnBlKFwiZmFpbGVkIHRvIGNhbGwgT3J0UnVuKCkuXCIpO2xldCBqPVtdO2ZvcihsZXQgVj0wO1Y8eDtWKyspe2xldCBRPU51bWJlcihhLmdldFZhbHVlKFIrVipkLFwiKlwiKSk7aWYoUT09PVRbVl0pe2oucHVzaChvW1ZdKTtjb250aW51ZX1sZXQgc2U9YS5zdGFja1NhdmUoKSxZPWEuc3RhY2tBbGxvYyg0KmQpLGVlPSExLEosbmU9MDt0cnl7YS5fT3J0R2V0VGVuc29yRGF0YShRLFksWStkLFkrMipkLFkrMypkKSE9PTAmJnBlKGBDYW4ndCBhY2Nlc3Mgb3V0cHV0IHRlbnNvciBkYXRhIG9uIGluZGV4ICR7Vn0uYCk7bGV0IE9lPWQ9PT00P1wiaTMyXCI6XCJpNjRcIiwkZT1OdW1iZXIoYS5nZXRWYWx1ZShZLE9lKSk7bmU9YS5nZXRWYWx1ZShZK2QsXCIqXCIpO2xldCBsZT1hLmdldFZhbHVlKFkrZCoyLFwiKlwiKSxXPU51bWJlcihhLmdldFZhbHVlKFkrZCozLE9lKSkscT1bXTtmb3IobGV0IHdlPTA7d2U8Vzt3ZSsrKXEucHVzaChOdW1iZXIoYS5nZXRWYWx1ZShsZSt3ZSpkLE9lKSkpO2EuX09ydEZyZWUobGUpIT09MCYmcGUoXCJDYW4ndCBmcmVlIG1lbW9yeSBmb3IgdGVuc29yIGRpbXMuXCIpO2xldCBoZT1xLnJlZHVjZSgod2UseWUpPT53ZSp5ZSwxKTtKPWJ0KCRlKTtsZXQgR2U9aD8ub3V0cHV0UHJlZmVycmVkTG9jYXRpb25zW25bVl1dO2lmKEo9PT1cInN0cmluZ1wiKXtpZihHZT09PVwiZ3B1LWJ1ZmZlclwifHxHZT09PVwibWwtdGVuc29yXCIpdGhyb3cgbmV3IEVycm9yKFwiU3RyaW5nIHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkIG9uIEdQVS5cIik7bGV0IHdlPVtdO2ZvcihsZXQgeWU9MDt5ZTxoZTt5ZSsrKXtsZXQgWWU9YS5nZXRWYWx1ZShuZSt5ZSpkLFwiKlwiKSxMdD1hLmdldFZhbHVlKG5lKyh5ZSsxKSpkLFwiKlwiKSxmbj15ZT09PWhlLTE/dm9pZCAwOkx0LVllO3dlLnB1c2goYS5VVEY4VG9TdHJpbmcoWWUsZm4pKX1qLnB1c2goW0oscSx3ZSxcImNwdVwiXSl9ZWxzZSBpZihHZT09PVwiZ3B1LWJ1ZmZlclwiJiZoZT4wKXtsZXQgd2U9YS5qc2VwR2V0QnVmZmVyO2lmKCF3ZSl0aHJvdyBuZXcgRXJyb3IoJ3ByZWZlcnJlZExvY2F0aW9uIFwiZ3B1LWJ1ZmZlclwiIGlzIG5vdCBzdXBwb3J0ZWQgd2l0aG91dCB1c2luZyBXZWJHUFUuJyk7bGV0IHllPXdlKG5lKSxZZT1DdCgkZSxoZSk7aWYoWWU9PT12b2lkIDB8fCFCcihKKSl0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtKfWApO2VlPSEwLGoucHVzaChbSixxLHtncHVCdWZmZXI6eWUsZG93bmxvYWQ6YS5qc2VwQ3JlYXRlRG93bmxvYWRlcih5ZSxZZSxKKSxkaXNwb3NlOigpPT57YS5fT3J0UmVsZWFzZVRlbnNvcihRKSE9PTAmJnBlKFwiQ2FuJ3QgcmVsZWFzZSB0ZW5zb3IuXCIpfX0sXCJncHUtYnVmZmVyXCJdKX1lbHNlIGlmKEdlPT09XCJtbC10ZW5zb3JcIiYmaGU+MCl7bGV0IHdlPWEuanNlcEVuc3VyZVRlbnNvcjtpZighd2UpdGhyb3cgbmV3IEVycm9yKCdwcmVmZXJyZWRMb2NhdGlvbiBcIm1sLXRlbnNvclwiIGlzIG5vdCBzdXBwb3J0ZWQgd2l0aG91dCB1c2luZyBXZWJOTi4nKTtpZihDdCgkZSxoZSk9PT12b2lkIDB8fCFNcihKKSl0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtKfWApO2xldCBZZT1hd2FpdCB3ZShuZSwkZSxxLCExKTtlZT0hMCxqLnB1c2goW0oscSx7bWxUZW5zb3I6WWUsZG93bmxvYWQ6YS5qc2VwQ3JlYXRlTUxUZW5zb3JEb3dubG9hZGVyKG5lLEopLGRpc3Bvc2U6KCk9PnthLmpzZXBSZWxlYXNlVGVuc29ySWQobmUpLGEuX09ydFJlbGVhc2VUZW5zb3IoUSl9fSxcIm1sLXRlbnNvclwiXSl9ZWxzZXtsZXQgd2U9RHIoSikseWU9bmV3IHdlKGhlKTtuZXcgVWludDhBcnJheSh5ZS5idWZmZXIseWUuYnl0ZU9mZnNldCx5ZS5ieXRlTGVuZ3RoKS5zZXQoYS5IRUFQVTguc3ViYXJyYXkobmUsbmUreWUuYnl0ZUxlbmd0aCkpLGoucHVzaChbSixxLHllLFwiY3B1XCJdKX19ZmluYWxseXthLnN0YWNrUmVzdG9yZShzZSksSj09PVwic3RyaW5nXCImJm5lJiZhLl9mcmVlKG5lKSxlZXx8YS5fT3J0UmVsZWFzZVRlbnNvcihRKX19cmV0dXJuIGgmJiFfJiYoYS5fT3J0Q2xlYXJCb3VuZE91dHB1dHMoaC5oYW5kbGUpIT09MCYmcGUoXCJDYW4ndCBjbGVhciBib3VuZCBvdXRwdXRzLlwiKSxQdC5zZXQoZSxbcCxtLHUsaCxfLCExXSkpLGp9ZmluYWxseXthLnN0YWNrUmVzdG9yZShrKSxTLmZvckVhY2goSz0+YS5fT3J0UmVsZWFzZVRlbnNvcihLKSksVC5mb3JFYWNoKEs9PmEuX09ydFJlbGVhc2VUZW5zb3IoSykpLEEuZm9yRWFjaChLPT5hLl9mcmVlKEspKSwkIT09MCYmYS5fT3J0UmVsZWFzZVJ1bk9wdGlvbnMoJCksdi5mb3JFYWNoKEs9PmEuX2ZyZWUoSykpfX0sRXI9ZT0+e2xldCB0PUllKCkscj1QdC5nZXQoZSk7aWYoIXIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzZXNzaW9uIGlkXCIpO2xldCBuPXJbMF0sbz10Ll9PcnRFbmRQcm9maWxpbmcobik7bz09PTAmJnBlKFwiQ2FuJ3QgZ2V0IGFuIHByb2ZpbGUgZmlsZSBuYW1lLlwiKSx0Ll9PcnRGcmVlKG8pfSxQcj1lPT57bGV0IHQ9W107Zm9yKGxldCByIG9mIGUpe2xldCBuPXJbMl07IUFycmF5LmlzQXJyYXkobikmJlwiYnVmZmVyXCJpbiBuJiZ0LnB1c2gobi5idWZmZXIpfXJldHVybiB0fX0pO3ZhciB6dCxMZSxucixsbixjbixkbixQbyx6byxWdCxXdCxiZyxkYyxsYyxjYyxwYyxtYyxmYyxoYyxPbz1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7V2UoKTtxbigpO2d0KCk7eHIoKTt6dD0oKT0+ISF2ZS53YXNtLnByb3h5JiZ0eXBlb2YgZG9jdW1lbnQ8XCJ1XCIsbnI9ITEsbG49ITEsY249ITEsem89bmV3IE1hcCxWdD0oZSx0KT0+e2xldCByPXpvLmdldChlKTtyP3IucHVzaCh0KTp6by5zZXQoZSxbdF0pfSxXdD0oKT0+e2lmKG5yfHwhbG58fGNufHwhTGUpdGhyb3cgbmV3IEVycm9yKFwid29ya2VyIG5vdCByZWFkeVwiKX0sYmc9ZT0+e3N3aXRjaChlLmRhdGEudHlwZSl7Y2FzZVwiaW5pdC13YXNtXCI6bnI9ITEsZS5kYXRhLmVycj8oY249ITAsUG9bMV0oZS5kYXRhLmVycikpOihsbj0hMCxQb1swXSgpKSxkbiYmKFVSTC5yZXZva2VPYmplY3RVUkwoZG4pLGRuPXZvaWQgMCk7YnJlYWs7Y2FzZVwiaW5pdC1lcFwiOmNhc2VcImNvcHktZnJvbVwiOmNhc2VcImNyZWF0ZVwiOmNhc2VcInJlbGVhc2VcIjpjYXNlXCJydW5cIjpjYXNlXCJlbmQtcHJvZmlsaW5nXCI6e2xldCB0PXpvLmdldChlLmRhdGEudHlwZSk7ZS5kYXRhLmVycj90LnNoaWZ0KClbMV0oZS5kYXRhLmVycik6dC5zaGlmdCgpWzBdKGUuZGF0YS5vdXQpO2JyZWFrfWRlZmF1bHQ6fX0sZGM9YXN5bmMoKT0+e2lmKCFsbil7aWYobnIpdGhyb3cgbmV3IEVycm9yKFwibXVsdGlwbGUgY2FsbHMgdG8gJ2luaXRXYXNtKCknIGRldGVjdGVkLlwiKTtpZihjbil0aHJvdyBuZXcgRXJyb3IoXCJwcmV2aW91cyBjYWxsIHRvICdpbml0V2FzbSgpJyBmYWlsZWQuXCIpO2lmKG5yPSEwLHp0KCkpcmV0dXJuIG5ldyBQcm9taXNlKChlLHQpPT57TGU/LnRlcm1pbmF0ZSgpLFZhKCkudGhlbigoW3Isbl0pPT57dHJ5e0xlPW4sTGUub25lcnJvcj1pPT50KGkpLExlLm9ubWVzc2FnZT1iZyxQbz1bZSx0XTtsZXQgbz17dHlwZTpcImluaXQtd2FzbVwiLGluOnZlfTshby5pbi53YXNtLndhc21QYXRocyYmKHJ8fGltcG9ydC5tZXRhLnVybD8uc3RhcnRzV2l0aChcImZpbGU6XCIpKSYmKG8uaW4ud2FzbS53YXNtUGF0aHM9e3dhc206bmV3IFVSTChcIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC53YXNtXCIsaW1wb3J0Lm1ldGEudXJsKS5ocmVmfSksTGUucG9zdE1lc3NhZ2UobyksZG49cn1jYXRjaChvKXt0KG8pfX0sdCl9KTt0cnl7YXdhaXQgU3IodmUud2FzbSksYXdhaXQgVHIodmUpLGxuPSEwfWNhdGNoKGUpe3Rocm93IGNuPSEwLGV9ZmluYWxseXtucj0hMX19fSxsYz1hc3luYyBlPT57aWYoenQoKSlyZXR1cm4gV3QoKSxuZXcgUHJvbWlzZSgodCxyKT0+e1Z0KFwiaW5pdC1lcFwiLFt0LHJdKTtsZXQgbj17dHlwZTpcImluaXQtZXBcIixpbjp7ZXBOYW1lOmUsZW52OnZlfX07TGUucG9zdE1lc3NhZ2Uobil9KTthd2FpdCBJcih2ZSxlKX0sY2M9YXN5bmMgZT0+enQoKT8oV3QoKSxuZXcgUHJvbWlzZSgodCxyKT0+e1Z0KFwiY29weS1mcm9tXCIsW3Qscl0pO2xldCBuPXt0eXBlOlwiY29weS1mcm9tXCIsaW46e2J1ZmZlcjplfX07TGUucG9zdE1lc3NhZ2UobixbZS5idWZmZXJdKX0pKTpLdChlKSxwYz1hc3luYyhlLHQpPT57aWYoenQoKSl7aWYodD8ucHJlZmVycmVkT3V0cHV0TG9jYXRpb24pdGhyb3cgbmV3IEVycm9yKCdzZXNzaW9uIG9wdGlvbiBcInByZWZlcnJlZE91dHB1dExvY2F0aW9uXCIgaXMgbm90IHN1cHBvcnRlZCBmb3IgcHJveHkuJyk7cmV0dXJuIFd0KCksbmV3IFByb21pc2UoKHIsbik9PntWdChcImNyZWF0ZVwiLFtyLG5dKTtsZXQgbz17dHlwZTpcImNyZWF0ZVwiLGluOnttb2RlbDplLG9wdGlvbnM6ey4uLnR9fX0saT1bXTtlIGluc3RhbmNlb2YgVWludDhBcnJheSYmaS5wdXNoKGUuYnVmZmVyKSxMZS5wb3N0TWVzc2FnZShvLGkpfSl9ZWxzZSByZXR1cm4gQ3IoZSx0KX0sbWM9YXN5bmMgZT0+e2lmKHp0KCkpcmV0dXJuIFd0KCksbmV3IFByb21pc2UoKHQscik9PntWdChcInJlbGVhc2VcIixbdCxyXSk7bGV0IG49e3R5cGU6XCJyZWxlYXNlXCIsaW46ZX07TGUucG9zdE1lc3NhZ2Uobil9KTtBcihlKX0sZmM9YXN5bmMoZSx0LHIsbixvLGkpPT57aWYoenQoKSl7aWYoci5zb21lKGE9PmFbM10hPT1cImNwdVwiKSl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCB0ZW5zb3Igb24gR1BVIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHByb3h5LlwiKTtpZihvLnNvbWUoYT0+YSkpdGhyb3cgbmV3IEVycm9yKFwicHJlLWFsbG9jYXRlZCBvdXRwdXQgdGVuc29yIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHByb3h5LlwiKTtyZXR1cm4gV3QoKSxuZXcgUHJvbWlzZSgoYSxkKT0+e1Z0KFwicnVuXCIsW2EsZF0pO2xldCBsPXIscD17dHlwZTpcInJ1blwiLGluOntzZXNzaW9uSWQ6ZSxpbnB1dEluZGljZXM6dCxpbnB1dHM6bCxvdXRwdXRJbmRpY2VzOm4sb3B0aW9uczppfX07TGUucG9zdE1lc3NhZ2UocCxQcihsKSl9KX1lbHNlIHJldHVybiBrcihlLHQscixuLG8saSl9LGhjPWFzeW5jIGU9PntpZih6dCgpKXJldHVybiBXdCgpLG5ldyBQcm9taXNlKCh0LHIpPT57VnQoXCJlbmQtcHJvZmlsaW5nXCIsW3Qscl0pO2xldCBuPXt0eXBlOlwiZW5kLXByb2ZpbGluZ1wiLGluOmV9O0xlLnBvc3RNZXNzYWdlKG4pfSk7RXIoZSl9fSk7dmFyIGdjLHlnLHBuLGJjPVUoKCk9PntcInVzZSBzdHJpY3RcIjtXZSgpO09vKCk7dGUoKTskcigpO1huKCk7Z2M9KGUsdCk9Pntzd2l0Y2goZS5sb2NhdGlvbil7Y2FzZVwiY3B1XCI6cmV0dXJuW2UudHlwZSxlLmRpbXMsZS5kYXRhLFwiY3B1XCJdO2Nhc2VcImdwdS1idWZmZXJcIjpyZXR1cm5bZS50eXBlLGUuZGltcyx7Z3B1QnVmZmVyOmUuZ3B1QnVmZmVyfSxcImdwdS1idWZmZXJcIl07Y2FzZVwibWwtdGVuc29yXCI6cmV0dXJuW2UudHlwZSxlLmRpbXMse21sVGVuc29yOmUubWxUZW5zb3J9LFwibWwtdGVuc29yXCJdO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRhdGEgbG9jYXRpb246ICR7ZS5sb2NhdGlvbn0gZm9yICR7dCgpfWApfX0seWc9ZT0+e3N3aXRjaChlWzNdKXtjYXNlXCJjcHVcIjpyZXR1cm4gbmV3IEhlKGVbMF0sZVsyXSxlWzFdKTtjYXNlXCJncHUtYnVmZmVyXCI6e2xldCB0PWVbMF07aWYoIUJyKHQpKXRocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7dH0gZm9yIGRlc2VyaWFsaXppbmcgR1BVIHRlbnNvcmApO2xldHtncHVCdWZmZXI6cixkb3dubG9hZDpuLGRpc3Bvc2U6b309ZVsyXTtyZXR1cm4gSGUuZnJvbUdwdUJ1ZmZlcihyLHtkYXRhVHlwZTp0LGRpbXM6ZVsxXSxkb3dubG9hZDpuLGRpc3Bvc2U6b30pfWNhc2VcIm1sLXRlbnNvclwiOntsZXQgdD1lWzBdO2lmKCFNcih0KSl0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgZGF0YSB0eXBlOiAke3R9IGZvciBkZXNlcmlhbGl6aW5nIE1MVGVuc29yIHRlbnNvcmApO2xldHttbFRlbnNvcjpyLGRvd25sb2FkOm4sZGlzcG9zZTpvfT1lWzJdO3JldHVybiBIZS5mcm9tTUxUZW5zb3Iocix7ZGF0YVR5cGU6dCxkaW1zOmVbMV0sZG93bmxvYWQ6bixkaXNwb3NlOm99KX1kZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkYXRhIGxvY2F0aW9uOiAke2VbM119YCl9fSxwbj1jbGFzc3thc3luYyBmZXRjaE1vZGVsQW5kQ29weVRvV2FzbU1lbW9yeSh0KXtyZXR1cm4gY2MoYXdhaXQgUXQodCkpfWFzeW5jIGxvYWRNb2RlbCh0LHIpe1VlKCk7bGV0IG47dHlwZW9mIHQ9PVwic3RyaW5nXCI/ITE/bj1hd2FpdCBRdCh0KTpuPWF3YWl0IHRoaXMuZmV0Y2hNb2RlbEFuZENvcHlUb1dhc21NZW1vcnkodCk6bj10LFt0aGlzLnNlc3Npb25JZCx0aGlzLmlucHV0TmFtZXMsdGhpcy5vdXRwdXROYW1lc109YXdhaXQgcGMobixyKSxEZSgpfWFzeW5jIGRpc3Bvc2UoKXtyZXR1cm4gbWModGhpcy5zZXNzaW9uSWQpfWFzeW5jIHJ1bih0LHIsbil7VWUoKTtsZXQgbz1bXSxpPVtdO09iamVjdC5lbnRyaWVzKHQpLmZvckVhY2goaD0+e2xldCBfPWhbMF0seT1oWzFdLGc9dGhpcy5pbnB1dE5hbWVzLmluZGV4T2YoXyk7aWYoZz09PS0xKXRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbnB1dCAnJHtffSdgKTtvLnB1c2goeSksaS5wdXNoKGcpfSk7bGV0IGE9W10sZD1bXTtPYmplY3QuZW50cmllcyhyKS5mb3JFYWNoKGg9PntsZXQgXz1oWzBdLHk9aFsxXSxnPXRoaXMub3V0cHV0TmFtZXMuaW5kZXhPZihfKTtpZihnPT09LTEpdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIG91dHB1dCAnJHtffSdgKTthLnB1c2goeSksZC5wdXNoKGcpfSk7bGV0IGw9by5tYXAoKGgsXyk9PmdjKGgsKCk9PmBpbnB1dCBcIiR7dGhpcy5pbnB1dE5hbWVzW2lbX11dfVwiYCkpLHA9YS5tYXAoKGgsXyk9Pmg/Z2MoaCwoKT0+YG91dHB1dCBcIiR7dGhpcy5vdXRwdXROYW1lc1tkW19dXX1cImApOm51bGwpLG09YXdhaXQgZmModGhpcy5zZXNzaW9uSWQsaSxsLGQscCxuKSx1PXt9O2ZvcihsZXQgaD0wO2g8bS5sZW5ndGg7aCsrKXVbdGhpcy5vdXRwdXROYW1lc1tkW2hdXV09YVtoXT8/eWcobVtoXSk7cmV0dXJuIERlKCksdX1zdGFydFByb2ZpbGluZygpe31lbmRQcm9maWxpbmcoKXtoYyh0aGlzLnNlc3Npb25JZCl9fX0pO3ZhciBfYz17fTtGdChfYyx7T25ueHJ1bnRpbWVXZWJBc3NlbWJseUJhY2tlbmQ6KCk9Pm1uLGluaXRpYWxpemVGbGFnczooKT0+eWMsd2FzbUJhY2tlbmQ6KCk9Pl9nfSk7dmFyIHljLG1uLF9nLHdjPVUoKCk9PntcInVzZSBzdHJpY3RcIjtXZSgpO09vKCk7YmMoKTt5Yz0oKT0+e2lmKCh0eXBlb2YgdmUud2FzbS5pbml0VGltZW91dCE9XCJudW1iZXJcInx8dmUud2FzbS5pbml0VGltZW91dDwwKSYmKHZlLndhc20uaW5pdFRpbWVvdXQ9MCksdmUud2FzbS5zaW1kPT09ITEmJmNvbnNvbGUud2FybignRGVwcmVjYXRlZCBwcm9wZXJ0eSBcImVudi53YXNtLnNpbWRcIiBpcyBzZXQgdG8gZmFsc2UuIG5vbi1TSU1EIGJ1aWxkIGlzIG5vIGxvbmdlciBwcm92aWRlZCwgYW5kIHRoaXMgc2V0dGluZyB3aWxsIGJlIGlnbm9yZWQuJyksdHlwZW9mIHZlLndhc20ucHJveHkhPVwiYm9vbGVhblwiJiYodmUud2FzbS5wcm94eT0hMSksdHlwZW9mIHZlLndhc20udHJhY2UhPVwiYm9vbGVhblwiJiYodmUud2FzbS50cmFjZT0hMSksdHlwZW9mIHZlLndhc20ubnVtVGhyZWFkcyE9XCJudW1iZXJcInx8IU51bWJlci5pc0ludGVnZXIodmUud2FzbS5udW1UaHJlYWRzKXx8dmUud2FzbS5udW1UaHJlYWRzPD0wKWlmKHR5cGVvZiBzZWxmPFwidVwiJiYhc2VsZi5jcm9zc09yaWdpbklzb2xhdGVkKXZlLndhc20ubnVtVGhyZWFkcz0xO2Vsc2V7bGV0IGU9dHlwZW9mIG5hdmlnYXRvcj5cInVcIj9ObihcIm5vZGU6b3NcIikuY3B1cygpLmxlbmd0aDpuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeTt2ZS53YXNtLm51bVRocmVhZHM9TWF0aC5taW4oNCxNYXRoLmNlaWwoKGV8fDEpLzIpKX19LG1uPWNsYXNze2FzeW5jIGluaXQodCl7eWMoKSxhd2FpdCBkYygpLGF3YWl0IGxjKHQpfWFzeW5jIGNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKHQscil7bGV0IG49bmV3IHBuO3JldHVybiBhd2FpdCBuLmxvYWRNb2RlbCh0LHIpLFByb21pc2UucmVzb2x2ZShuKX19LF9nPW5ldyBtbn0pO1dlKCk7V2UoKTtXZSgpO3ZhciBDYT1cIjEuMjEuMC1kZXYuMjAyNTAxMTQtMjI4ZGQxNjg5M1wiO3ZhciAkMT1Gbjt7bGV0IGU9KHdjKCksYnIoX2MpKS53YXNtQmFja2VuZDtTdChcIndlYmdwdVwiLGUsNSksU3QoXCJ3ZWJublwiLGUsNSksU3QoXCJjcHVcIixlLDEwKSxTdChcIndhc21cIixlLDEwKX1PYmplY3QuZGVmaW5lUHJvcGVydHkodmUudmVyc2lvbnMsXCJ3ZWJcIix7dmFsdWU6Q2EsZW51bWVyYWJsZTohMH0pO2V4cG9ydHtGcCBhcyBJbmZlcmVuY2VTZXNzaW9uLHdyIGFzIFRSQUNFLFVlIGFzIFRSQUNFX0ZVTkNfQkVHSU4sRGUgYXMgVFJBQ0VfRlVOQ19FTkQsSGUgYXMgVGVuc29yLCQxIGFzIGRlZmF1bHQsdmUgYXMgZW52LFN0IGFzIHJlZ2lzdGVyQmFja2VuZH07XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcnQud2ViZ3B1LmJ1bmRsZS5taW4ubWpzLm1hcFxuIl0sIm5hbWVzIjpbIlVuIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJWcCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIldwIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIkxwIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJObiIsImUiLCJyZXF1aXJlIiwiUHJveHkiLCJnZXQiLCJ0IiwiciIsImFwcGx5IiwiYXJndW1lbnRzIiwiRXJyb3IiLCJVIiwiRnQiLCJlbnVtZXJhYmxlIiwiR3AiLCJuIiwibyIsImNhbGwiLCJiciIsInZhbHVlIiwieXIiLCJ4dCIsIlN0IiwiSHAiLCJKaSIsIlZuIiwiTWFwIiwiaW5pdCIsImNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyIiwic2V0IiwiYmFja2VuZCIsInByaW9yaXR5IiwiaW5kZXhPZiIsInNwbGljZSIsImkiLCJsZW5ndGgiLCJwdXNoIiwiVHlwZUVycm9yIiwiaW5pdGlhbGl6ZWQiLCJhYm9ydGVkIiwiZXJyb3IiLCJpbml0UHJvbWlzZSIsImV4ZWN1dGlvblByb3ZpZGVycyIsIm1hcCIsImwiLCJuYW1lIiwiYSIsIlNldCIsInAiLCJlcnIiLCJhZGQiLCJqb2luIiwiaW5jbHVkZXMiLCJjb25zb2xlIiwid2FybiIsImQiLCJmaWx0ZXIiLCJoYXMiLCJSZWZsZWN0IiwiZWEiLCJ0YSIsInJhIiwibmEiLCJSZSIsIlduIiwid2FzbSIsIndlYmdsIiwid2ViZ3B1IiwidmVyc2lvbnMiLCJjb21tb24iLCJsb2dMZXZlbCIsInZlIiwib2EiLCJpYSIsImFhIiwic2EiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJPZmZzY3JlZW5DYW52YXMiLCJ3aWR0aCIsImRpbXMiLCJoZWlnaHQiLCJnZXRDb250ZXh0IiwidGVuc29yTGF5b3V0IiwiZm9ybWF0Iiwibm9ybSIsIm1lYW4iLCJiaWFzIiwibSIsInUiLCJoIiwiXyIsInkiLCJnIiwieCIsIiQiLCJkYXRhIiwidiIsIlMiLCJUIiwiZmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJ0b0RhdGFVUkwiLCJjcmVhdGVJbWFnZURhdGEiLCJBIiwiTG4iLCJ1YSIsImRhIiwibGEiLCJjYSIsInBhIiwibWEiLCJfciIsInRlbnNvckZvcm1hdCIsIkZsb2F0MzJBcnJheSIsInplIiwiSFRNTEltYWdlRWxlbWVudCIsIkltYWdlRGF0YSIsIkltYWdlQml0bWFwIiwiSFRNTENhbnZhc0VsZW1lbnQiLCJyZXNpemVkSGVpZ2h0IiwicmVzaXplZFdpZHRoIiwiZHJhd0ltYWdlIiwiZ2V0SW1hZ2VEYXRhIiwicHV0SW1hZ2VEYXRhIiwiUHJvbWlzZSIsIkltYWdlIiwiY3Jvc3NPcmlnaW4iLCJzcmMiLCJvbmxvYWQiLCJkb3dubG9hZCIsImRpc3Bvc2UiLCJsb2NhdGlvbiIsInR5cGUiLCJ0ZXh0dXJlIiwiZGF0YVR5cGUiLCJncHVCdWZmZXIiLCJtbFRlbnNvciIsIlR0IiwicXQiLCJmYSIsImhhIiwiZ2EiLCJVaW50OEFycmF5IiwiSW50OEFycmF5IiwiVWludDE2QXJyYXkiLCJJbnQxNkFycmF5IiwiSW50MzJBcnJheSIsIkZsb2F0NjRBcnJheSIsIlVpbnQzMkFycmF5IiwiQmlnSW50NjRBcnJheSIsImZyb20iLCJCaWdVaW50NjRBcnJheSIsIkZsb2F0MTZBcnJheSIsImJhIiwieWEiLCJfYSIsIk51bWJlciIsImlzU2FmZUludGVnZXIiLCJSYW5nZUVycm9yIiwiY29uc3RydWN0b3IiLCJkYXRhTG9jYXRpb24iLCJjcHVEYXRhIiwiZ3B1VGV4dHVyZURhdGEiLCJkb3dubG9hZGVyIiwiZGlzcG9zZXIiLCJncHVCdWZmZXJEYXRhIiwibWxUZW5zb3JEYXRhIiwiQXJyYXkiLCJpc0FycmF5IiwiQmlnSW50IiwiVWludDhDbGFtcGVkQXJyYXkiLCJNYXRoIiwiY2VpbCIsInNpemUiLCJmcm9tSW1hZ2UiLCJmcm9tVGV4dHVyZSIsImZyb21HcHVCdWZmZXIiLCJmcm9tTUxUZW5zb3IiLCJmcm9tUGlubmVkQnVmZmVyIiwidG9JbWFnZURhdGEiLCJlbnN1cmVWYWxpZCIsImdldERhdGEiLCJpc0Rvd25sb2FkaW5nIiwicmVzaGFwZSIsIkhlIiwiR24iLCJ3ciIsIndhIiwiVWUiLCJEZSIsIkhuIiwidHJhY2UiLCJ0aW1lU3RhbXAiLCJzdGFjayIsInNwbGl0IiwidHJpbSIsInZyIiwidmEiLCJoYW5kbGVyIiwicnVuIiwib3V0cHV0TmFtZXMiLCJpbnB1dE5hbWVzIiwicmVsZWFzZSIsImNyZWF0ZSIsIkFycmF5QnVmZmVyIiwiU2hhcmVkQXJyYXlCdWZmZXIiLCJieXRlTGVuZ3RoIiwic3RhcnRQcm9maWxpbmciLCJlbmRQcm9maWxpbmciLCJGcCIsIiRhIiwieGEiLCJTYSIsIlRhIiwiSWEiLCJGbiIsIkluZmVyZW5jZVNlc3Npb24iLCJUUkFDRSIsIlRSQUNFX0ZVTkNfQkVHSU4iLCJUUkFDRV9GVU5DX0VORCIsIlRlbnNvciIsImVudiIsInJlZ2lzdGVyQmFja2VuZCIsIldlIiwiJHIiLCJFYSIsImRlZmF1bHQiLCJxcCIsIkFhIiwia2EiLCJQYSIsInFuIiwiZ3QiLCJ4ciIsImdsb2JhbFRoaXMiLCJzZWxmIiwib25tZXNzYWdlIiwiaW4iLCJTciIsInRoZW4iLCJUciIsInBvc3RNZXNzYWdlIiwiZXBOYW1lIiwiSXIiLCJidWZmZXIiLCJLdCIsIm91dCIsIm1vZGVsIiwib3B0aW9ucyIsIkNyIiwiQXIiLCJzZXNzaW9uSWQiLCJpbnB1dEluZGljZXMiLCJpbnB1dHMiLCJvdXRwdXRJbmRpY2VzIiwia3IiLCJmaWxsIiwic29tZSIsIlByIiwiRXIiLCJXb3JrZXIiLCJOZSIsIk9hIiwiS3AiLCJLbiIsInphIiwiRGEiLCJ1cmwiLCJzZSIsIkoiLCJ5ZSIsIm5lIiwiYmUiLCJPZSIsIiRlIiwibGUiLCJXIiwiR2UiLCJhc3NpZ24iLCJzIiwiYyIsImltcG9ydFNjcmlwdHMiLCJtb3VudEV4dGVybmFsRGF0YSIsInN0YXJ0c1dpdGgiLCJzdWJzdHJpbmciLCJGYiIsInVubW91bnRFeHRlcm5hbERhdGEiLCJXZWJBc3NlbWJseSIsIk1lbW9yeSIsImluaXRpYWwiLCJtYXhpbXVtIiwic2hhcmVkIiwiZiIsImIiLCJ3IiwiSSIsIk8iLCJYZSIsIkIiLCJMIiwiSCIsIlgiLCJFbiIsInJlc29sdmUiLCJyZWplY3QiLCJHYiIsImhjIiwiZXJyb3JzIiwiSGIiLCJmbHVzaCIsImFsbCIsIl9PcnRDcmVhdGVTZXNzaW9uIiwiX09ydFJ1biIsIl9PcnRSdW5XaXRoQmluZGluZyIsIl9PcnRCaW5kSW5wdXQiLCJqc2VwSW5pdCIsIlZiIiwiWmIiLCJPYiIsIlliIiwia2IiLCIkYiIsImNjIiwiV2IiLCJYYiIsImFjIiwianNlcFJlZ2lzdGVyQnVmZmVyIiwicmVnaXN0ZXJCdWZmZXIiLCJqc2VwR2V0QnVmZmVyIiwiZ2V0QnVmZmVyIiwianNlcENyZWF0ZURvd25sb2FkZXIiLCJjcmVhdGVEb3dubG9hZGVyIiwianNlcE9uQ3JlYXRlU2Vzc2lvbiIsIm9uQ3JlYXRlU2Vzc2lvbiIsImpzZXBPblJlbGVhc2VTZXNzaW9uIiwib25SZWxlYXNlU2Vzc2lvbiIsImpzZXBPblJ1blN0YXJ0Iiwib25SdW5TdGFydCIsImRjIiwidXBsb2FkIiwiYmMiLCJQYiIsImpzZXBFbnN1cmVUZW5zb3IiLCJlYyIsImpzZXBEb3dubG9hZFRlbnNvciIsImpzZXBSZWxlYXNlVGVuc29ySWQiLCJqc2VwUmVnaXN0ZXJNTENvbnRleHQiLCJyZWdpc3Rlck1MQ29udGV4dCIsImpzZXBDcmVhdGVNTFRlbnNvckRvd25sb2FkZXIiLCJjcmVhdGVNTFRlbnNvckRvd25sb2FkZXIiLCJqc2VwUmVnaXN0ZXJNTFRlbnNvciIsInJlZ2lzdGVyTUxUZW5zb3IiLCJqc2VwQ3JlYXRlTUxDb250ZXh0IiwiY3JlYXRlTUxDb250ZXh0IiwianNlcFJlZ2lzdGVyTUxDb25zdGFudCIsInJlZ2lzdGVyTUxDb25zdGFudCIsImsiLCJQIiwiaHJlZiIsImN1cnJlbnRTY3JpcHQiLCJzdWJzdHIiLCJyZXBsYWNlIiwibGFzdEluZGV4T2YiLCJYTUxIdHRwUmVxdWVzdCIsIm9wZW4iLCJyZXNwb25zZVR5cGUiLCJzZW5kIiwicmVzcG9uc2UiLCJzdGF0dXMiLCJvbmVycm9yIiwiRCIsIlIiLCJsb2ciLCJiaW5kIiwiRyIsIksiLCJqIiwiY21kIiwic3RhcnRXb3JrZXIiLCJoYW5kbGVycyIsInByb3h5IiwiTmIiLCJwYyIsImFyZ3MiLCJ3YXNtTWVtb3J5IiwiViIsIndhc21Nb2R1bGUiLCJEbiIsInB0aHJlYWRfcHRyIiwiQW4iLCJ4YyIsIkhvIiwiUSIsIldpIiwiU2MiLCJzdGFydF9yb3V0aW5lIiwiYXJnIiwiTXQiLCJociIsInRhcmdldCIsImlyIiwiTGkiLCJ3ZyIsImFsZXJ0IiwidGV4dCIsInJjIiwiaW5zdGFudGlhdGVXYXNtIiwiSW5zdGFuY2UiLCJObyIsIm9udW5oYW5kbGVkcmVqZWN0aW9uIiwicmVhc29uIiwid2FzbUJpbmFyeSIsIlkiLCJlZSIsInEiLCJoZSIsIndlIiwiSEVBUDgiLCJIRUFQMTYiLCJIRUFQVTgiLCJIRUFQVTE2IiwiSEVBUDMyIiwiSEVBUFUzMiIsIkhFQVBGMzIiLCJIRUFQRjY0IiwiSEVBUDY0IiwiSEVBUFU2NCIsIlllIiwiTHQiLCJmbiIsIkd0IiwiaG4iLCJIdCIsIkRvIiwiY2xlYXJJbnRlcnZhbCIsImN0IiwiUnVudGltZUVycm9yIiwiZ24iLCJCbyIsIk1vIiwiUm8iLCJVbyIsImZldGNoIiwiY3JlZGVudGlhbHMiLCJvayIsImFycmF5QnVmZmVyIiwiY2F0Y2giLCJpbnN0YW50aWF0ZSIsIiRjIiwidmMiLCJJYyIsImpvIiwiUW8iLCJxYSIsIlhvIiwiZWkiLCJ0aSIsInJpIiwibmkiLCJvaSIsImlpIiwiYWkiLCJaIiwic2kiLCJ1aSIsImRpIiwibGkiLCJDYyIsIkYiLCJrYyIsIkVjIiwiemMiLCJFIiwiRGMiLCJCYyIsIk1jIiwiUmMiLCJIYyIsIkZjIiwicWMiLCJLYyIsImpjIiwiWWMiLCJaYyIsImphIiwiUWMiLCJYYyIsIkJhIiwiSmMiLCJycCIsIm5wIiwiaXAiLCJJbiIsImFwIiwiZHAiLCJscCIsImNwIiwicHAiLCJtcCIsImZwIiwiaHAiLCJncCIsImJwIiwieXAiLCJfcCIsIndwIiwidnAiLCIkcCIsIlNpIiwiVGkiLCJ4cCIsIlNwIiwiVHAiLCJJcCIsIk0iLCJDcCIsIkFwIiwia3AiLCJFcCIsIkNpIiwieiIsIlBwIiwiTiIsInpwIiwiT3AiLCJEcCIsIkJwIiwiRWkiLCJQaSIsInZuIiwiQyIsInppIiwiT2kiLCJEaSIsIkJpIiwid24iLCJVaSIsIlVwIiwiYm4iLCJDZSIsInN1YmFycmF5Iiwid2FzbU9mZnNldENvbnZlcnRlciIsImFscGhhIiwiYmV0YSIsIm1pbiIsIm1heCIsInRvIiwia2VlcERpbXMiLCJub29wV2l0aEVtcHR5QXhlcyIsImF4ZXMiLCJwZXJtIiwiYmxvY2tzaXplIiwibW9kZSIsImNlIiwiZ2UiLCJkZSIsImF1dG9QYWQiLCJkaWxhdGlvbnMiLCJncm91cCIsImtlcm5lbFNoYXBlIiwicGFkcyIsInN0cmlkZXMiLCJ3SXNDb25zdCIsIm91dHB1dFBhZGRpbmciLCJvdXRwdXRTaGFwZSIsImFjdGl2YXRpb24iLCJhdXRvX3BhZCIsImNlaWxfbW9kZSIsImNvdW50X2luY2x1ZGVfcGFkIiwic3RvcmFnZV9vcmRlciIsImtlcm5lbF9zaGFwZSIsInRyYW5zQSIsInRyYW5zQiIsInNlbGVjdExhc3RJbmRleCIsImF4aXMiLCJudW1PdXRwdXRzIiwic3BsaXRTaXplcyIsImJhdGNoX2RpbXMiLCJhbnRpYWxpYXMiLCJjb29yZGluYXRlVHJhbnNmb3JtTW9kZSIsImN1YmljQ29lZmZBIiwiZXhjbHVkZU91dHNpZGUiLCJleHRyYXBvbGF0aW9uVmFsdWUiLCJrZWVwQXNwZWN0UmF0aW9Qb2xpY3kiLCJuZWFyZXN0TW9kZSIsInN0YXJ0cyIsImVuZHMiLCJlcHNpbG9uIiwiZXF1YXRpb24iLCJtb21lbnR1bSIsInNwYXRpYWwiLCJ0cmFpbmluZ01vZGUiLCJleGNsdXNpdmUiLCJyZXZlcnNlIiwiYmxvY2tTaXplIiwiYWxpZ25fY29ybmVycyIsInBhZGRpbmdfbW9kZSIsIm51bUhlYWRzIiwiaXNVbmlkaXJlY3Rpb25hbCIsIm1hc2tGaWx0ZXJWYWx1ZSIsInNjYWxlIiwiZG9Sb3RhcnkiLCJxa3ZIaWRkZW5TaXplcyIsInBhc3RQcmVzZW50U2hhcmVCdWZmZXIiLCJUZSIsIndfaXNfY29uc3QiLCJhY3RpdmF0aW9uX3BhcmFtcyIsImt2TnVtSGVhZHMiLCJzb2Z0Y2FwIiwicm90YXJ5SW50ZXJsZWF2ZWQiLCJzbW9vdGhTb2Z0bWF4IiwibG9jYWxXaW5kb3dTaXplIiwic2ltcGxpZmllZCIsImFjY3VyYWN5TGV2ZWwiLCJiaXRzIiwiaW50ZXJsZWF2ZWQiLCJyb3RhcnlFbWJlZGRpbmdEaW0iLCJnYXRoZXJBeGlzIiwicXVhbnRpemVBeGlzIiwiX2kiLCJ5biIsIm1lc3NhZ2UiLCJfbiIsInRlcm1pbmF0ZSIsIlZvIiwicHQiLCJxbyIsIkZvIiwicG9wIiwidnQiLCJaZSIsIkJiIiwiaWMiLCJSYiIsIm5jIiwid3QiLCJ4ZSIsIlJuIiwiTW4iLCJHaSIsImdyIiwiV28iLCJMbyIsIkdvIiwiQm4iLCJmb3JFYWNoIiwidGFyZ2V0VGhyZWFkIiwidHJhbnNmZXJMaXN0IiwidGhyZWFkIiwibG9hZGVkIiwidGhyZWFkSWQiLCJmaWxlbmFtZSIsImxpbmVubyIsIlVSTCIsIndvcmtlckRhdGEiLCJvciIsInNoaWZ0IiwiRmkiLCJxaSIsIlRjIiwiS2IiLCJLbyIsIllvIiwiVGV4dERlY29kZXIiLCJabyIsImRlY29kZSIsInNsaWNlIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiJG4iLCJjaGFyQ29kZUF0IiwiSm8iLCJPdCIsImNpIiwibXQiLCJRZSIsInhuIiwiU24iLCJBYyIsInN0IiwiVGIiLCJwaSIsImZyb21XaXJlVHlwZSIsInRvV2lyZVR5cGUiLCJ0b1N0cmluZyIsImFyZ1BhY2tBZHZhbmNlIiwiZnQiLCJyZWFkVmFsdWVGcm9tUG9pbnRlciIsIkViIiwiVG4iLCJ1dCIsIk1lIiwiVmUiLCJDbiIsIlBjIiwiT2MiLCJKZSIsImZyIiwibWkiLCJVYyIsIk5jIiwiVmMiLCJXYyIsIkxjIiwiR2MiLCJVYiIsImZpIiwiQXRvbWljcyIsIm9jIiwic3RvcmUiLCJIaSIsInNldFRpbWVvdXQiLCJrbiIsIk5wIiwiYXIiLCJWaSIsImhpIiwic3IiLCJodCIsImdpIiwidXIiLCJiaSIsInlpIiwiZXAiLCJ0cCIsIllpIiwiQnJvd3NlciIsIkxiIiwiU2IiLCJyZXN1bWUiLCJwYXVzZSIsIktpIiwiWmkiLCJkciIsIm9wIiwibHIiLCJ3aSIsIkZ1bmN0aW9uIiwic3AiLCJ1cCIsInZpIiwiTmFOIiwiRGF0ZSIsImdldFVUQ1NlY29uZHMiLCJnZXRVVENNaW51dGVzIiwiZ2V0VVRDSG91cnMiLCJnZXRVVENEYXRlIiwiZ2V0VVRDTW9udGgiLCJnZXRVVENGdWxsWWVhciIsImdldFVUQ0RheSIsImdldFRpbWUiLCJVVEMiLCJEdCIsIiRpIiwieGkiLCJnZXRTZWNvbmRzIiwiZ2V0TWludXRlcyIsImdldEhvdXJzIiwiZ2V0RGF0ZSIsImdldE1vbnRoIiwiZ2V0RnVsbFllYXIiLCJnZXREYXkiLCJnZXRUaW1lem9uZU9mZnNldCIsInNldFRpbWUiLCJnZXRZZWFyIiwiaXNOYU4iLCJ0b0xvY2FsZVRpbWVTdHJpbmciLCJob3VyMTIiLCJ0aW1lWm9uZU5hbWUiLCJQbiIsIklpIiwibm93IiwicGVyZm9ybWFuY2UiLCJ0aW1lT3JpZ2luIiwibmF2aWdhdG9yIiwiaGFyZHdhcmVDb25jdXJyZW5jeSIsImdyb3ciLCJjciIsIkJ0IiwiQWkiLCJRYiIsImZjIiwiem4iLCJPbiIsImtpIiwiVVNFUiIsIkxPR05BTUUiLCJQQVRIIiwiUFdEIiwiSE9NRSIsIkxBTkciLCJsYW5ndWFnZXMiLCJNcCIsIk1pIiwiUmkiLCJScCIsIlhpIiwiJHQiLCJDYiIsIkRiIiwic2V0RGF0ZSIsInNldE1vbnRoIiwic2V0RnVsbFllYXIiLCJsYyIsIkliIiwiTWIiLCJKYiIsInZiIiwic2MiLCJtYyIsIlJlZ0V4cCIsImZsb29yIiwiYWJzIiwibnVtVGhyZWFkcyIsInVuc2hpZnQiLCJOaSIsInByIiwiQmluZGluZ0Vycm9yIiwiSW50ZXJuYWxFcnJvciIsImNvdW50X2VtdmFsX2hhbmRsZXMiLCJleHBvcnRzIiwiZW50cmllcyIsImppIiwiRmliZXJzIiwidGMiLCJnYiIsImliIiwiZW1zY3JpcHRlbl9tYWluX3J1bnRpbWVfdGhyZWFkX2lkIiwidGIiLCJ1YiIsImpiIiwiQ2EiLCJsb2NhdGVGaWxlIiwiaW5zdGFudGlhdGVTdHJlYW1pbmciLCJpbnN0YW5jZSIsIm1vZHVsZSIsIl9PcnRJbml0IiwiRmEiLCJfT3J0R2V0TGFzdEVycm9yIiwiR2EiLCJfT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnMiLCJIYSIsIl9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlciIsIl9PcnRBZGRGcmVlRGltZW5zaW9uT3ZlcnJpZGUiLCJKYSIsIl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkiLCJLYSIsIl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnMiLCJMYSIsIk1hIiwiX09ydFJlbGVhc2VTZXNzaW9uIiwiTmEiLCJfT3J0R2V0SW5wdXRPdXRwdXRDb3VudCIsIl9PcnRHZXRJbnB1dE5hbWUiLCJfT3J0R2V0T3V0cHV0TmFtZSIsIlFhIiwiX09ydEZyZWUiLCJSYSIsIl9PcnRDcmVhdGVUZW5zb3IiLCJfT3J0R2V0VGVuc29yRGF0YSIsIl9PcnRSZWxlYXNlVGVuc29yIiwiVWEiLCJfT3J0Q3JlYXRlUnVuT3B0aW9ucyIsIlZhIiwiX09ydEFkZFJ1bkNvbmZpZ0VudHJ5IiwiV2EiLCJfT3J0UmVsZWFzZVJ1bk9wdGlvbnMiLCJYYSIsIl9PcnRDcmVhdGVCaW5kaW5nIiwiWWEiLCJaYSIsIl9PcnRCaW5kT3V0cHV0IiwiX09ydENsZWFyQm91bmRPdXRwdXRzIiwiX09ydFJlbGVhc2VCaW5kaW5nIiwiYWIiLCJiYiIsImNiIiwiX09ydEVuZFByb2ZpbGluZyIsImRiIiwiX0pzZXBPdXRwdXQiLCJlYiIsIl9Kc2VwR2V0Tm9kZU5hbWUiLCJmYiIsIm1yIiwiX2ZyZWUiLCJoYiIsIl9tYWxsb2MiLCJsYiIsIm1iIiwibmIiLCJvYiIsInBiIiwicWIiLCJyYiIsInNiIiwiZHluQ2FsbF9paSIsIndiIiwieGIiLCJ5YiIsInpiIiwiQWIiLCJRaSIsImNhbGxlZFJ1biIsIl9fX3N0YXJ0X2VtX2pzIiwiX19fc3RvcF9lbV9qcyIsInN0YWNrU2F2ZSIsInN0YWNrUmVzdG9yZSIsInN0YWNrQWxsb2MiLCJzZXRWYWx1ZSIsImVuZHNXaXRoIiwiZ2V0VmFsdWUiLCJVVEY4VG9TdHJpbmciLCJzdHJpbmdUb1VURjgiLCJsZW5ndGhCeXRlc1VURjgiLCJQVFJfU0laRSIsImpwIiwiam4iLCJZcCIsIlpwIiwiUXAiLCJvcmlnaW4iLCJibG9iIiwiY3JlYXRlT2JqZWN0VVJMIiwiWW4iLCJabiIsInpyIiwiWHAiLCJKcCIsIkllIiwiTWVzc2FnZUNoYW5uZWwiLCJwb3J0MSIsInZhbGlkYXRlIiwiaW5pdFRpbWVvdXQiLCJjcm9zc09yaWdpbklzb2xhdGVkIiwid2FzbVBhdGhzIiwibWpzIiwicmV2b2tlT2JqZWN0VVJMIiwicmFjZSIsImtlIiwianQiLCJwZSIsIk9yIiwibG9nU2V2ZXJpdHlMZXZlbCIsImlzSW50ZWdlciIsImxvZ1ZlcmJvc2l0eUxldmVsIiwidGFnIiwiZXh0cmEiLCJXZWFrU2V0IiwiZW0iLCJ0bSIsInJtIiwibm0iLCJzZXNzaW9uIiwidXNlX29ydF9tb2RlbF9ieXRlc19kaXJlY3RseSIsImVuYWJsZU1lbVBhdHRlcm4iLCJkZXZpY2VUeXBlIiwicHJlZmVycmVkTGF5b3V0IiwiZ3JhcGhPcHRpbWl6YXRpb25MZXZlbCIsImV4ZWN1dGlvbk1vZGUiLCJsb2dJZCIsIm9wdGltaXplZE1vZGVsRmlsZVBhdGgiLCJlbmFibGVDcHVNZW1BcmVuYSIsImVuYWJsZVByb2ZpbGluZyIsImVuYWJsZUdyYXBoQ2FwdHVyZSIsImZyZWVEaW1lbnNpb25PdmVycmlkZXMiLCJZdCIsImJ0IiwiQ3QiLCJEciIsIlp0IiwiQnIiLCJNciIsIlFuIiwidGUiLCJyZWR1Y2UiLCJRdCIsIlhuIiwicmVhZEZpbGUiLCJjb2RlIiwiY3JlYXRlUmVhZFN0cmVhbSIsIkJ1ZmZlciIsImNvbmNhdCIsImhlYWRlcnMiLCJwYXJzZUludCIsImJvZHkiLCJnZXRSZWFkZXIiLCJkb25lIiwicmVhZCIsIkJsb2IiLCJvbSIsImltIiwiUnIiLCJhbSIsInVlIiwiZXQiLCJ0b0lTT1N0cmluZyIsIlVyIiwiSm4iLCJOciIsImVvIiwic20iLCJ1bSIsIm5vIiwicm8iLCJkZXZpY2UiLCJjcmVhdGVCdWZmZXIiLCJ1c2FnZSIsIkdQVUJ1ZmZlclVzYWdlIiwiQ09QWV9EU1QiLCJNQVBfUkVBRCIsImdldENvbW1hbmRFbmNvZGVyIiwiZW5kQ29tcHV0ZVBhc3MiLCJjb3B5QnVmZmVyVG9CdWZmZXIiLCJtYXBBc3luYyIsIkdQVU1hcE1vZGUiLCJSRUFEIiwiZ2V0TWFwcGVkUmFuZ2UiLCJkZXN0cm95Iiwic3RvcmFnZUNhY2hlIiwiZnJlZUJ1ZmZlcnMiLCJmcmVlVW5pZm9ybUJ1ZmZlcnMiLCJidWZmZXJzUGVuZGluZyIsImNhcHR1cmVkUGVuZGluZ0J1ZmZlcnMiLCJzZXNzaW9uQ291bnQiLCJieXRlT2Zmc2V0Iiwib3JpZ2luYWxTaXplIiwibWFwcGVkQXRDcmVhdGlvbiIsIk1BUF9XUklURSIsIkNPUFlfU1JDIiwidW5tYXAiLCJjcmVhdGVDb21tYW5kRW5jb2RlciIsImdwdURhdGEiLCJxdWV1ZSIsInN1Ym1pdCIsImZpbmlzaCIsIm1lbWNweSIsInJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIiLCJjYXB0dXJlZENvbW1hbmRMaXN0IiwiY3VycmVudFNlc3Npb25JZCIsImlkIiwidW5yZWdpc3RlckV4dGVybmFsQnVmZmVyIiwiZGVsZXRlIiwiU1RPUkFHRSIsIlVOSUZPUk0iLCJyZWZyZXNoUGVuZGluZ0J1ZmZlcnMiLCJzZXNzaW9uU3RhdHVzIiwib28iLCJyZSIsIlNlIiwiY2FjaGVLZXkiLCJrZXkiLCJzb3J0IiwiaW8iLCJ0dCIsIkF0IiwiVnIiLCJlcyIsInRzIiwib2UiLCJjYWxjTWF0TXVsU2hhcGUiLCJjYWxjU2hhcGUiLCJpc1ZhbGlkQnJvYWRjYXN0IiwiZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZSIsImNvbnZlcnRTaGFwZSIsInNpemVGcm9tRGltZW5zaW9uIiwic2l6ZVRvRGltZW5zaW9uIiwiY29tcHV0ZVN0cmlkZXMiLCJub3JtYWxpemVBeGlzIiwibm9ybWFsaXplQXhlcyIsInNvcnRCYXNlZE9uUGVybSIsInBhZFNoYXBlIiwiYXJlRXF1YWwiLCJldmVyeSIsImFkanVzdFBvb2xBdHRyaWJ1dGVzIiwiYWRqdXN0UGFkc0Jhc2VkT25BdXRvUGFkIiwiYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUiLCJjb21wdXRlUG9vbE91dHB1dFNoYXBlIiwiY29tcHV0ZVNoYXBlSGVscGVyIiwiY29tcHV0ZUNvbnZPdXRwdXRTaGFwZSIsImdldFNoYXBlT2ZHZW1tUmVzdWx0Iiwia3QiLCJzbyIsIl9lIiwiRWUiLCJtZSIsInVvIiwiRXQiLCJGZSIsIldyIiwicnMiLCJMciIsImFvIiwibnMiLCJhZSIsImtleXMiLCJpbmRpY2VzIiwic3RvcmFnZSIsInRlbnNvciIsIm9mZnNldFRvSW5kaWNlcyIsImluZGljZXNUb09mZnNldCIsImJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0Iiwic2V0QnlJbmRpY2VzIiwiZ2V0QnlJbmRpY2VzIiwiaW5kaWNlc0dldCIsInJhbmsiLCJpbXBsIiwidmFsdWVzIiwiaW5kaWNlc1NldCIsInNldEJ5T2Zmc2V0IiwiZ2V0QnlPZmZzZXQiLCJzaGFwZSIsIm5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwIiwibGltaXRzIiwiaW50ZXJuYWxWYXJpYWJsZXMiLCJ2YXJpYWJsZXMiLCJ1bmlmb3JtcyIsInZhcmlhYmxlSW5kZXgiLCJndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzIiwibWFpblN0YXJ0IiwibWF4Q29tcHV0ZVdvcmtncm91cFNpemVYIiwibWF4Q29tcHV0ZVdvcmtncm91cFNpemVZIiwibWF4Q29tcHV0ZVdvcmtncm91cFNpemVaIiwibWF4Q29tcHV0ZUludm9jYXRpb25zUGVyV29ya2dyb3VwIiwiYXBwZW5kVmFyaWFibGVVbmlmb3JtcyIsImRlY2xhcmVWYXJpYWJsZSIsImRlY2xhcmVWYXJpYWJsZXMiLCJyZWdpc3RlckludGVybmFsVmFyaWFibGUiLCJyZWdpc3RlckludGVybmFsVmFyaWFibGVzIiwicmVnaXN0ZXJVbmlmb3JtIiwicmVnaXN0ZXJVbmlmb3JtcyIsInVuaWZvcm1EZWNsYXJhdGlvbiIsImFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbnMiLCJ2YXJpYWJsZXNJbmZvIiwiZG0iLCJvcyIsImxtIiwiY20iLCJwbSIsIm1tIiwiUGUiLCJpcyIsImFzIiwiZHQiLCJuZXdTaGFwZSIsIm5ld1Blcm0iLCJzaGFkZXJDYWNoZSIsImlucHV0RGVwZW5kZW5jaWVzIiwiZ2V0UnVuRGF0YSIsIm91dHB1dHMiLCJkaXNwYXRjaEdyb3VwIiwicHJvZ3JhbVVuaWZvcm1zIiwiZ2V0U2hhZGVyU291cmNlIiwiaGludCIsImNvbXB1dGUiLCJmbSIsImhtIiwiZ20iLCJibSIsInltIiwiX20iLCJ3bSIsInZtIiwiJG0iLCJ4bSIsInJ0Iiwic3MiLCJ1cyIsImRzIiwibHMiLCJjcyIsInBzIiwibXMiLCJmcyIsImhzIiwiZ3MiLCJicyIsIkdyIiwic3VtIiwicHJvZCIsInN1bVNxdWFyZSIsImxvZ1N1bUV4cCIsImwxIiwibDIiLCJsb2dTdW0iLCJsbyIsIm50IiwiU20iLCJIciIsIm90IiwiVG0iLCJJbSIsIkNtIiwiQW0iLCJrbSIsIkVtIiwiUG0iLCJ6bSIsIk9tIiwiRG0iLCJpdCIsInlzIiwiX3MiLCJ3cyIsInZzIiwiJHMiLCJ4cyIsIlNzIiwiVHMiLCJJcyIsIkNzIiwiZ2V0QmlnSW50NjRBcnJheSIsIkFzIiwia3MiLCJFcyIsImNvIiwiUHMiLCJCbSIsInBvIiwiTW0iLCJSbSIsIlVtIiwiUnQiLCJObSIsInpzIiwiRnIiLCJiYXRjaFNpemUiLCJzZXF1ZW5jZUxlbmd0aCIsInBhc3RTZXF1ZW5jZUxlbmd0aCIsImt2U2VxdWVuY2VMZW5ndGgiLCJ0b3RhbFNlcXVlbmNlTGVuZ3RoIiwibWF4U2VxdWVuY2VMZW5ndGgiLCJpbnB1dEhpZGRlblNpemUiLCJoaWRkZW5TaXplIiwidkhpZGRlblNpemUiLCJoZWFkU2l6ZSIsInZIZWFkU2l6ZSIsIm1hc2tUeXBlIiwiYnJvYWRjYXN0UmVzUG9zQmlhcyIsInBhc3NQYXN0SW5LdiIsInFrdkZvcm1hdCIsIm5SZXBzIiwic3FydCIsImdwdURhdGFUeXBlIiwib3V0cHV0Q291bnQiLCJWbSIsIldtIiwiTG0iLCJPcyIsIkRzIiwidmFsaWRhdGVJbnB1dENvbnRlbnQiLCJHbSIsIkhtIiwiQnMiLCJNcyIsIkZtIiwiZmUiLCJScyIsIlVzIiwiTnMiLCJWcyIsIldzIiwiTHMiLCJHcyIsIkhzIiwiRnMiLCJxbSIsInFzIiwiS3MiLCJqcyIsIllzIiwiWHQiLCJacyIsInFyIiwiUXMiLCJYcyIsIkpzIiwiZXUiLCJ0dSIsInJ1IiwibnUiLCJvdSIsIml1IiwiYXUiLCJzdSIsInV1IiwiZHUiLCJsdSIsImN1IiwicHUiLCJtdSIsImZ1IiwibW8iLCJmbyIsImh1IiwiZ3UiLCJidSIsIkttIiwiam0iLCJ5dSIsIktyIiwiZ2V0RmxvYXQzMkFycmF5IiwiZ2V0VWludDE2QXJyYXkiLCJZbSIsIlptIiwid3UiLCJ2dSIsIlFtIiwiWG0iLCJhdCIsIiR1IiwieHUiLCJTdSIsIlR1IiwiSXUiLCJDdSIsIkF1Iiwia3UiLCJFdSIsIlB1IiwienUiLCJzY2FsYXIiLCJ2ZWN0b3IiLCJlZiIsInRmIiwicmYiLCJuZiIsIk91IiwiRHUiLCJCdSIsInFlIiwiS2UiLCJqZSIsImpyIiwieXQiLCJjbGlwTWF4IiwiY2xpcE1pbiIsIkFlIiwiTXUiLCJZciIsIlJ1IiwiVXUiLCJKdCIsIlpyIiwiUXIiLCJvZiIsImFmIiwiaG8iLCJOdSIsInNmIiwiZ28iLCJ1ZiIsImVyIiwiWHIiLCJkZiIsIlZ1IiwiV3UiLCJsZiIsIkx1IiwiSnIiLCJjZiIsIkd1IiwicGYiLCJIdSIsIkZ1IiwicXUiLCJ0cnVuYyIsInRvcCIsImJvdHRvbSIsImxlZnQiLCJyaWdodCIsImZyb250IiwiYmFjayIsInBhZEluZm8iLCJvdXREZXB0aCIsIm91dEhlaWdodCIsIm91dFdpZHRoIiwiZGF0YUZvcm1hdCIsImluRGVwdGgiLCJpbkhlaWdodCIsImluV2lkdGgiLCJpbkNoYW5uZWxzIiwib3V0Q2hhbm5lbHMiLCJzdHJpZGVEZXB0aCIsInN0cmlkZUhlaWdodCIsInN0cmlkZVdpZHRoIiwiZmlsdGVyRGVwdGgiLCJmaWx0ZXJIZWlnaHQiLCJmaWx0ZXJXaWR0aCIsImVmZmVjdGl2ZUZpbHRlckRlcHRoIiwiZWZmZWN0aXZlRmlsdGVySGVpZ2h0IiwiZWZmZWN0aXZlRmlsdGVyV2lkdGgiLCJkaWxhdGlvbkRlcHRoIiwiZGlsYXRpb25IZWlnaHQiLCJkaWxhdGlvbldpZHRoIiwiaW5TaGFwZSIsIm91dFNoYXBlIiwiZmlsdGVyU2hhcGUiLCJLdSIsImp1IiwiWXUiLCJtZiIsImJvIiwiZmYiLCJ5byIsIl9vIiwiWnUiLCJoZiIsImdmIiwid28iLCJRdSIsImtlcm5lbEN1c3RvbURhdGEiLCJ3VCIsImFkYXB0ZXJJbmZvIiwiaXNBcmNoaXRlY3R1cmUiLCJYdSIsIkp1IiwiYmYiLCJ5ZiIsIl9mIiwiZWQiLCJ0ZCIsIndmIiwicmQiLCJ2ZiIsIm5kIiwib2QiLCIkZiIsImFkIiwic2QiLCJnZXRJbnQzMkFycmF5IiwieGYiLCJTZiIsIlRmIiwidWQiLCJkZCIsImxkIiwidm8iLCJlbiIsImNkIiwiSWYiLCJDZiIsIiRvIiwieG8iLCJwZCIsIkFmIiwibWQiLCJmZCIsImhkIiwic3ltYm9sVG9JbmRpY2VzIiwiaW5wdXRJbmRleCIsImFkZFN5bWJvbCIsImhhc0VsbGlwc2lzIiwic3ltYm9sVG9JbmZvIiwibGhzIiwib3V0cHV0RGltcyIsIm1hdGNoIiwicHJvY2Vzc1Rlcm0iLCJjb3VudCIsImVsbGlwc2lzRGltcyIsImRpbVZhbHVlIiwicmhzIiwia2YiLCJnZCIsIkVmIiwiUGYiLCJiZCIsInlkIiwiemYiLCJfZCIsIndkIiwiT2YiLCJEZiIsInZkIiwiJGQiLCJ4ZCIsIkJmIiwiU2QiLCJUZCIsIklkIiwiYmF0Y2hEaW1zIiwiTWYiLCJSZiIsIkNkIiwiQWQiLCJrZCIsIlVmIiwiTmYiLCJFZCIsIlBkIiwiemQiLCJWZiIsIldmIiwiT2QiLCJEZCIsIkJkIiwibHQiLCJfdCIsIlV0IiwiTnQiLCJMZiIsIkdmIiwiSGYiLCJGZiIsInFmIiwiS2YiLCJqZiIsIllmIiwiTWQiLCJSZCIsIlVkIiwiYWxpZ25Db3JuZXJzIiwicGFkZGluZ01vZGUiLCJCZSIsIlhmIiwiVmQiLCJOZCIsIkpmIiwidHIiLCJXZCIsIlNvIiwiZWgiLCJ0aCIsInJoIiwibmgiLCJUbyIsIkxkIiwiR2QiLCJJbyIsIm9oIiwiaWgiLCJIZCIsIkZkIiwicWQiLCJLZCIsImFoIiwic2giLCJqZCIsIllkIiwidWgiLCJkaCIsIlpkIiwiUWQiLCJsaCIsIlhkIiwiSmQiLCJjaCIsInBoIiwibWgiLCJlbCIsInRsIiwicmwiLCJpc1ZlbmRvciIsImZoIiwiaGgiLCJnaCIsImJoIiwieWgiLCJfaCIsIndoIiwidmgiLCJubCIsIm9sIiwidG4iLCJpbCIsImFsIiwic2wiLCJ1bCIsIiRoIiwieGgiLCJkbCIsImxsIiwiY2wiLCJwbCIsIm1sIiwiZmwiLCJobCIsImdsIiwiYmwiLCJ5bCIsIl9sIiwid2wiLCJ2bCIsImNlaWxNb2RlIiwiY291bnRJbmNsdWRlUGFkIiwic3RvcmFnZU9yZGVyIiwiVGgiLCJJaCIsIiRsIiwieGwiLCJTbCIsIkNoIiwiQWgiLCJUbCIsIklsIiwia2giLCJFaCIsIkNsIiwiQWwiLCJrbCIsInJlZHVjdGlvbiIsIlBoIiwiemgiLCJPaCIsIkRoIiwiQmgiLCJNaCIsIlJoIiwiVWgiLCJOaCIsIlZoIiwiV2giLCJFbCIsIkxoIiwiR2giLCJIaCIsIkZoIiwicWgiLCJQbCIsInpsIiwiT2wiLCJyb3VuZCIsIk1BWF9WQUxVRSIsIk1JTl9WQUxVRSIsImN1c3RvbURhdGFCdWZmZXIiLCJLaCIsImpoIiwiRGwiLCJCbCIsIlloIiwiWmgiLCJNbCIsIlJsIiwiUWgiLCJybiIsIlhoIiwiVWwiLCJKaCIsImVnIiwiTmwiLCJWbCIsIldsIiwic2lnbiIsInRnIiwicmciLCJMbCIsIkdsIiwiSGwiLCJGbCIsIm5nIiwib2ciLCJpZyIsInFsIiwiS2wiLCJhZyIsInNnIiwiamwiLCJZbCIsIlpsIiwiUWwiLCJubiIsIlhsIiwicmVwbyIsImF0dHJpYnV0ZXNCb3VuZCIsImdldEFydGlmYWN0Iiwic2V0QXJ0aWZhY3QiLCJwcm9ncmFtSW5mbyIsImdldENvbXB1dGVQYXNzRW5jb2RlciIsIndyaXRlVGltZXN0YW1wIiwicGVuZGluZ0Rpc3BhdGNoTnVtYmVyIiwiYmluZGluZyIsInJlc291cmNlIiwiY3JlYXRlQmluZEdyb3VwIiwibGF5b3V0IiwiY29tcHV0ZVBpcGVsaW5lIiwiZ2V0QmluZEdyb3VwTGF5b3V0IiwibGFiZWwiLCJrZXJuZWxJZCIsImN1cnJlbnRLZXJuZWxJZCIsImJpbmRHcm91cCIsInNldFBpcGVsaW5lIiwic2V0QmluZEdyb3VwIiwiZGlzcGF0Y2hXb3JrZ3JvdXBzIiwibWF4RGlzcGF0Y2hOdW1iZXIiLCJxdWVyeVR5cGUiLCJidWlsZCIsImZlYXR1cmUiLCJleHRlbnNpb24iLCJmZWF0dXJlcyIsImNyZWF0ZVNoYWRlck1vZHVsZSIsImNyZWF0ZUNvbXB1dGVQaXBlbGluZSIsImVudHJ5UG9pbnQiLCJ1bmlmb3JtVmFyaWFibGVzSW5mbyIsIm5vcm1hbGl6ZURpc3BhdGNoR3JvdXBTaXplIiwibWF4Q29tcHV0ZVdvcmtncm91cHNQZXJEaW1lbnNpb24iLCJjYnJ0IiwidWciLCJkZyIsIkNvIiwiQW8iLCJvbiIsIkpsIiwiYXJjaGl0ZWN0dXJlIiwidmVuZG9yIiwic3ViZ3JvdXBzU3VwcG9ydGVkIiwic3ViZ3JvdXBzRjE2U3VwcG9ydGVkIiwibWluU3ViZ3JvdXBTaXplIiwibWF4U3ViZ3JvdXBTaXplIiwic3ViZ3JvdXBTaXplUmFuZ2UiLCJjb21tYW5kRW5jb2RlciIsImNvbXB1dGVQYXNzRW5jb2RlciIsInBlbmRpbmdLZXJuZWxzIiwicGVuZGluZ1F1ZXJpZXMiLCJjYXB0dXJlZFBlbmRpbmdLZXJuZWxzIiwic2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmciLCJjdXJyZW50S2VybmVsQ3VzdG9tRGF0YSIsImluaXRpYWxpemUiLCJyZXF1aXJlZExpbWl0cyIsIm1heENvbXB1dGVXb3JrZ3JvdXBTdG9yYWdlU2l6ZSIsIm1heFN0b3JhZ2VCdWZmZXJCaW5kaW5nU2l6ZSIsIm1heEJ1ZmZlclNpemUiLCJyZXF1aXJlZEZlYXR1cmVzIiwicmVxdWVzdERldmljZSIsImRldmljZUluZm8iLCJpbmZvIiwicmVxdWVzdEFkYXB0ZXJJbmZvIiwiZ3B1RGF0YU1hbmFnZXIiLCJwcm9ncmFtTWFuYWdlciIsImtlcm5lbHMiLCJrZXJuZWxQZXJzaXN0ZW50RGF0YSIsImRlYnVnIiwib251bmNhcHR1cmVkZXJyb3IiLCJHUFVWYWxpZGF0aW9uRXJyb3IiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsInNldFF1ZXJ5VHlwZSIsInF1ZXJ5U2V0IiwidGltZXN0YW1wV3JpdGVzIiwiYmVnaW5uaW5nT2ZQYXNzV3JpdGVJbmRleCIsImVuZE9mUGFzc1dyaXRlSW5kZXgiLCJiZWdpbkNvbXB1dGVQYXNzIiwiZW5kIiwicmVzb2x2ZVF1ZXJ5U2V0IiwicXVlcnlSZXNvbHZlQnVmZmVyIiwia2VybmVsVHlwZSIsImtlcm5lbE5hbWUiLCJwcm9ncmFtTmFtZSIsImlucHV0VGVuc29yVmlld3MiLCJvdXRwdXRUZW5zb3JWaWV3cyIsInF1ZXJ5VGltZUJhc2UiLCJwcm9maWxpbmciLCJvbmRhdGEiLCJ2ZXJzaW9uIiwiaW5wdXRzTWV0YWRhdGEiLCJvdXRwdXRzTWV0YWRhdGEiLCJzdGFydFRpbWUiLCJlbmRUaW1lIiwidGVtcG9yYXJ5RGF0YSIsIndyaXRlQnVmZmVyIiwib2Zmc2V0IiwiYWxsb2MiLCJmcmVlIiwiY3JlYXRlS2VybmVsIiwia2VybmVsRW50cnkiLCJhdHRyaWJ1dGVzIiwicmVsZWFzZUtlcm5lbCIsImNvbXB1dGVLZXJuZWwiLCJwdXNoRXJyb3JTY29wZSIsInBvcEVycm9yU2NvcGUiLCJ1bnJlZ2lzdGVyQnVmZmVycyIsImNyZWF0ZVF1ZXJ5U2V0IiwiUVVFUllfUkVTT0xWRSIsImNhcHR1cmVCZWdpbiIsImNhcHR1cmVFbmQiLCJyZXBsYXkiLCJsZyIsImNnIiwiYW4iLCJzbiIsImtvIiwibWxDb250ZXh0IiwiY29udGV4dCIsInRlbnNvclNoYXBlIiwid3JpdGUiLCJ3cml0ZVRlbnNvciIsInJlYWRUZW5zb3IiLCJjYW5SZXVzZVRlbnNvciIsInRlbnNvck1hbmFnZXIiLCJ3cmFwcGVyIiwidGVuc29yV3JhcHBlciIsInJlbGVhc2VUZW5zb3IiLCJlbnN1cmVUZW5zb3IiLCJhY3RpdmVVcGxvYWQiLCJNTFRlbnNvclVzYWdlIiwiV1JJVEUiLCJnZXRDYWNoZWRUZW5zb3IiLCJ0ZW5zb3JUcmFja2Vyc0J5SWQiLCJmcmVlVGVuc29ycyIsImV4dGVybmFsVGVuc29ycyIsInJlc2VydmVUZW5zb3JJZCIsInJlbGVhc2VUZW5zb3JJZCIsImN1cnJlbnRDb250ZXh0IiwicmVsZWFzZVRlbnNvcnNGb3JTZXNzaW9uIiwicmVnaXN0ZXJUZW5zb3IiLCJjcmVhdGVUZW5zb3IiLCJkaW1lbnNpb25zIiwicmVhZGFibGUiLCJwZyIsInVuIiwibWxDb250ZXh0QnlTZXNzaW9uSWQiLCJzZXNzaW9uSWRzQnlNTENvbnRleHQiLCJtbENvbnRleHRDYWNoZSIsImFjdGl2ZVNlc3Npb25JZCIsIkdQVURldmljZSIsImZpbmRJbmRleCIsImdwdURldmljZSIsImNyZWF0ZUNvbnRleHQiLCJnZXRNTENvbnRleHQiLCJ1cGxvYWRUZW5zb3IiLCJzaG91bGRUcmFuc2ZlclRvTUxUZW5zb3IiLCJkb3dubG9hZFRlbnNvciIsImNvbnN0YW50IiwibWciLCJyciIsIkVvIiwiY3VzdG9tRGF0YU9mZnNldCIsImN1c3RvbURhdGFTaXplIiwib3BLZXJuZWxDb250ZXh0Iiwib3V0cHV0IiwiZmciLCJQdCIsImhnIiwidWMiLCJncHUiLCJhZGFwdGVyIiwicG93ZXJQcmVmZXJlbmNlIiwiZm9yY2VGYWxsYmFja0FkYXB0ZXIiLCJyZXF1ZXN0QWRhcHRlciIsImV4dGVybmFsRGF0YSIsInBhdGgiLCJwcmVmZXJyZWRPdXRwdXRMb2NhdGlvbiIsImhhbmRsZSIsIm91dHB1dFByZWZlcnJlZExvY2F0aW9ucyIsIm91dHB1dFByZWZlcnJlZExvY2F0aW9uc0VuY29kZWQiLCJ6dCIsIkxlIiwibnIiLCJsbiIsImNuIiwiZG4iLCJQbyIsInpvIiwiVnQiLCJXdCIsImJnIiwiT28iLCJnYyIsInlnIiwicG4iLCJmZXRjaE1vZGVsQW5kQ29weVRvV2FzbU1lbW9yeSIsImxvYWRNb2RlbCIsIl9jIiwiT25ueHJ1bnRpbWVXZWJBc3NlbWJseUJhY2tlbmQiLCJtbiIsImluaXRpYWxpemVGbGFncyIsInljIiwid2FzbUJhY2tlbmQiLCJfZyIsIndjIiwic2ltZCIsImNwdXMiLCIkMSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs?ee0f\n");

/***/ })

};
;