"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@imgly";
exports.ids = ["vendor-chunks/@imgly"];
exports.modules = {

/***/ "(ssr)/./node_modules/@imgly/background-removal/dist/index.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@imgly/background-removal/dist/index.mjs ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   alphamask: () => (/* binding */ alphamask),\n/* harmony export */   applySegmentationMask: () => (/* binding */ applySegmentationMask),\n/* harmony export */   preload: () => (/* binding */ preload),\n/* harmony export */   removeBackground: () => (/* binding */ removeBackground),\n/* harmony export */   removeForeground: () => (/* binding */ removeForeground),\n/* harmony export */   segmentForeground: () => (/* binding */ segmentForeground)\n/* harmony export */ });\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod)=>function __require() {\n        return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {\n            exports: {}\n        }).exports, mod), mod.exports;\n    };\nvar __copyProps = (to, from, except, desc)=>{\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n            get: ()=>from[key],\n            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n        });\n    }\n    return to;\n};\nvar __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM\n    // file that has been converted to a CommonJS file using a Babel-\n    // compatible transform (i.e. \"__esModule\" has not been set), then set\n    // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n    isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n        value: mod,\n        enumerable: true\n    }) : target, mod));\n// ../../node_modules/lodash/lodash.js\nvar require_lodash = __commonJS({\n    \"../../node_modules/lodash/lodash.js\" (exports, module) {\n        (function() {\n            var undefined2;\n            var VERSION = \"4.17.21\";\n            var LARGE_ARRAY_SIZE = 200;\n            var CORE_ERROR_TEXT = \"Unsupported core-js use. Try https://npms.io/search?q=ponyfill.\", FUNC_ERROR_TEXT = \"Expected a function\", INVALID_TEMPL_VAR_ERROR_TEXT = \"Invalid `variable` option passed into `_.template`\";\n            var HASH_UNDEFINED = \"__lodash_hash_undefined__\";\n            var MAX_MEMOIZE_SIZE = 500;\n            var PLACEHOLDER = \"__lodash_placeholder__\";\n            var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;\n            var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;\n            var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;\n            var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = \"...\";\n            var HOT_COUNT = 800, HOT_SPAN = 16;\n            var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;\n            var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;\n            var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;\n            var wrapFlags = [\n                [\n                    \"ary\",\n                    WRAP_ARY_FLAG\n                ],\n                [\n                    \"bind\",\n                    WRAP_BIND_FLAG\n                ],\n                [\n                    \"bindKey\",\n                    WRAP_BIND_KEY_FLAG\n                ],\n                [\n                    \"curry\",\n                    WRAP_CURRY_FLAG\n                ],\n                [\n                    \"curryRight\",\n                    WRAP_CURRY_RIGHT_FLAG\n                ],\n                [\n                    \"flip\",\n                    WRAP_FLIP_FLAG\n                ],\n                [\n                    \"partial\",\n                    WRAP_PARTIAL_FLAG\n                ],\n                [\n                    \"partialRight\",\n                    WRAP_PARTIAL_RIGHT_FLAG\n                ],\n                [\n                    \"rearg\",\n                    WRAP_REARG_FLAG\n                ]\n            ];\n            var argsTag = \"[object Arguments]\", arrayTag = \"[object Array]\", asyncTag = \"[object AsyncFunction]\", boolTag = \"[object Boolean]\", dateTag = \"[object Date]\", domExcTag = \"[object DOMException]\", errorTag = \"[object Error]\", funcTag = \"[object Function]\", genTag = \"[object GeneratorFunction]\", mapTag = \"[object Map]\", numberTag = \"[object Number]\", nullTag = \"[object Null]\", objectTag = \"[object Object]\", promiseTag = \"[object Promise]\", proxyTag = \"[object Proxy]\", regexpTag = \"[object RegExp]\", setTag = \"[object Set]\", stringTag = \"[object String]\", symbolTag = \"[object Symbol]\", undefinedTag = \"[object Undefined]\", weakMapTag = \"[object WeakMap]\", weakSetTag = \"[object WeakSet]\";\n            var arrayBufferTag = \"[object ArrayBuffer]\", dataViewTag = \"[object DataView]\", float32Tag = \"[object Float32Array]\", float64Tag = \"[object Float64Array]\", int8Tag = \"[object Int8Array]\", int16Tag = \"[object Int16Array]\", int32Tag = \"[object Int32Array]\", uint8Tag = \"[object Uint8Array]\", uint8ClampedTag = \"[object Uint8ClampedArray]\", uint16Tag = \"[object Uint16Array]\", uint32Tag = \"[object Uint32Array]\";\n            var reEmptyStringLeading = /\\b__p \\+= '';/g, reEmptyStringMiddle = /\\b(__p \\+=) '' \\+/g, reEmptyStringTrailing = /(__e\\(.*?\\)|\\b__t\\)) \\+\\n'';/g;\n            var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>\"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);\n            var reEscape = /<%-([\\s\\S]+?)%>/g, reEvaluate = /<%([\\s\\S]+?)%>/g, reInterpolate = /<%=([\\s\\S]+?)%>/g;\n            var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/, reIsPlainProp = /^\\w*$/, rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n            var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);\n            var reTrimStart = /^\\s+/;\n            var reWhitespace = /\\s/;\n            var reWrapComment = /\\{(?:\\n\\/\\* \\[wrapped with .+\\] \\*\\/)?\\n?/, reWrapDetails = /\\{\\n\\/\\* \\[wrapped with (.+)\\] \\*/, reSplitDetails = /,? & /;\n            var reAsciiWord = /[^\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7f]+/g;\n            var reForbiddenIdentifierChars = /[()=,{}\\[\\]\\/\\s]/;\n            var reEscapeChar = /\\\\(\\\\)?/g;\n            var reEsTemplate = /\\$\\{([^\\\\}]*(?:\\\\.[^\\\\}]*)*)\\}/g;\n            var reFlags = /\\w*$/;\n            var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n            var reIsBinary = /^0b[01]+$/i;\n            var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n            var reIsOctal = /^0o[0-7]+$/i;\n            var reIsUint = /^(?:0|[1-9]\\d*)$/;\n            var reLatin = /[\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\xff\\u0100-\\u017f]/g;\n            var reNoMatch = /($^)/;\n            var reUnescapedString = /['\\n\\r\\u2028\\u2029\\\\]/g;\n            var rsAstralRange = \"\\ud800-\\udfff\", rsComboMarksRange = \"\\\\u0300-\\\\u036f\", reComboHalfMarksRange = \"\\\\ufe20-\\\\ufe2f\", rsComboSymbolsRange = \"\\\\u20d0-\\\\u20ff\", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = \"\\\\u2700-\\\\u27bf\", rsLowerRange = \"a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff\", rsMathOpRange = \"\\\\xac\\\\xb1\\\\xd7\\\\xf7\", rsNonCharRange = \"\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf\", rsPunctuationRange = \"\\\\u2000-\\\\u206f\", rsSpaceRange = \" \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000\", rsUpperRange = \"A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde\", rsVarRange = \"\\\\ufe0e\\\\ufe0f\", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;\n            var rsApos = \"['’]\", rsAstral = \"[\" + rsAstralRange + \"]\", rsBreak = \"[\" + rsBreakRange + \"]\", rsCombo = \"[\" + rsComboRange + \"]\", rsDigits = \"\\\\d+\", rsDingbat = \"[\" + rsDingbatRange + \"]\", rsLower = \"[\" + rsLowerRange + \"]\", rsMisc = \"[^\" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + \"]\", rsFitz = \"\\ud83c[\\udffb-\\udfff]\", rsModifier = \"(?:\" + rsCombo + \"|\" + rsFitz + \")\", rsNonAstral = \"[^\" + rsAstralRange + \"]\", rsRegional = \"(?:\\ud83c[\\udde6-\\uddff]){2}\", rsSurrPair = \"[\\ud800-\\udbff][\\udc00-\\udfff]\", rsUpper = \"[\" + rsUpperRange + \"]\", rsZWJ = \"\\\\u200d\";\n            var rsMiscLower = \"(?:\" + rsLower + \"|\" + rsMisc + \")\", rsMiscUpper = \"(?:\" + rsUpper + \"|\" + rsMisc + \")\", rsOptContrLower = \"(?:\" + rsApos + \"(?:d|ll|m|re|s|t|ve))?\", rsOptContrUpper = \"(?:\" + rsApos + \"(?:D|LL|M|RE|S|T|VE))?\", reOptMod = rsModifier + \"?\", rsOptVar = \"[\" + rsVarRange + \"]?\", rsOptJoin = \"(?:\" + rsZWJ + \"(?:\" + [\n                rsNonAstral,\n                rsRegional,\n                rsSurrPair\n            ].join(\"|\") + \")\" + rsOptVar + reOptMod + \")*\", rsOrdLower = \"\\\\d*(?:1st|2nd|3rd|(?![123])\\\\dth)(?=\\\\b|[A-Z_])\", rsOrdUpper = \"\\\\d*(?:1ST|2ND|3RD|(?![123])\\\\dTH)(?=\\\\b|[a-z_])\", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = \"(?:\" + [\n                rsDingbat,\n                rsRegional,\n                rsSurrPair\n            ].join(\"|\") + \")\" + rsSeq, rsSymbol = \"(?:\" + [\n                rsNonAstral + rsCombo + \"?\",\n                rsCombo,\n                rsRegional,\n                rsSurrPair,\n                rsAstral\n            ].join(\"|\") + \")\";\n            var reApos = RegExp(rsApos, \"g\");\n            var reComboMark = RegExp(rsCombo, \"g\");\n            var reUnicode = RegExp(rsFitz + \"(?=\" + rsFitz + \")|\" + rsSymbol + rsSeq, \"g\");\n            var reUnicodeWord = RegExp([\n                rsUpper + \"?\" + rsLower + \"+\" + rsOptContrLower + \"(?=\" + [\n                    rsBreak,\n                    rsUpper,\n                    \"$\"\n                ].join(\"|\") + \")\",\n                rsMiscUpper + \"+\" + rsOptContrUpper + \"(?=\" + [\n                    rsBreak,\n                    rsUpper + rsMiscLower,\n                    \"$\"\n                ].join(\"|\") + \")\",\n                rsUpper + \"?\" + rsMiscLower + \"+\" + rsOptContrLower,\n                rsUpper + \"+\" + rsOptContrUpper,\n                rsOrdUpper,\n                rsOrdLower,\n                rsDigits,\n                rsEmoji\n            ].join(\"|\"), \"g\");\n            var reHasUnicode = RegExp(\"[\" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + \"]\");\n            var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;\n            var contextProps = [\n                \"Array\",\n                \"Buffer\",\n                \"DataView\",\n                \"Date\",\n                \"Error\",\n                \"Float32Array\",\n                \"Float64Array\",\n                \"Function\",\n                \"Int8Array\",\n                \"Int16Array\",\n                \"Int32Array\",\n                \"Map\",\n                \"Math\",\n                \"Object\",\n                \"Promise\",\n                \"RegExp\",\n                \"Set\",\n                \"String\",\n                \"Symbol\",\n                \"TypeError\",\n                \"Uint8Array\",\n                \"Uint8ClampedArray\",\n                \"Uint16Array\",\n                \"Uint32Array\",\n                \"WeakMap\",\n                \"_\",\n                \"clearTimeout\",\n                \"isFinite\",\n                \"parseInt\",\n                \"setTimeout\"\n            ];\n            var templateCounter = -1;\n            var typedArrayTags = {};\n            typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;\n            typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;\n            var cloneableTags = {};\n            cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\n            cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;\n            var deburredLetters = {\n                // Latin-1 Supplement block.\n                \"\\xc0\": \"A\",\n                \"\\xc1\": \"A\",\n                \"\\xc2\": \"A\",\n                \"\\xc3\": \"A\",\n                \"\\xc4\": \"A\",\n                \"\\xc5\": \"A\",\n                \"\\xe0\": \"a\",\n                \"\\xe1\": \"a\",\n                \"\\xe2\": \"a\",\n                \"\\xe3\": \"a\",\n                \"\\xe4\": \"a\",\n                \"\\xe5\": \"a\",\n                \"\\xc7\": \"C\",\n                \"\\xe7\": \"c\",\n                \"\\xd0\": \"D\",\n                \"\\xf0\": \"d\",\n                \"\\xc8\": \"E\",\n                \"\\xc9\": \"E\",\n                \"\\xca\": \"E\",\n                \"\\xcb\": \"E\",\n                \"\\xe8\": \"e\",\n                \"\\xe9\": \"e\",\n                \"\\xea\": \"e\",\n                \"\\xeb\": \"e\",\n                \"\\xcc\": \"I\",\n                \"\\xcd\": \"I\",\n                \"\\xce\": \"I\",\n                \"\\xcf\": \"I\",\n                \"\\xec\": \"i\",\n                \"\\xed\": \"i\",\n                \"\\xee\": \"i\",\n                \"\\xef\": \"i\",\n                \"\\xd1\": \"N\",\n                \"\\xf1\": \"n\",\n                \"\\xd2\": \"O\",\n                \"\\xd3\": \"O\",\n                \"\\xd4\": \"O\",\n                \"\\xd5\": \"O\",\n                \"\\xd6\": \"O\",\n                \"\\xd8\": \"O\",\n                \"\\xf2\": \"o\",\n                \"\\xf3\": \"o\",\n                \"\\xf4\": \"o\",\n                \"\\xf5\": \"o\",\n                \"\\xf6\": \"o\",\n                \"\\xf8\": \"o\",\n                \"\\xd9\": \"U\",\n                \"\\xda\": \"U\",\n                \"\\xdb\": \"U\",\n                \"\\xdc\": \"U\",\n                \"\\xf9\": \"u\",\n                \"\\xfa\": \"u\",\n                \"\\xfb\": \"u\",\n                \"\\xfc\": \"u\",\n                \"\\xdd\": \"Y\",\n                \"\\xfd\": \"y\",\n                \"\\xff\": \"y\",\n                \"\\xc6\": \"Ae\",\n                \"\\xe6\": \"ae\",\n                \"\\xde\": \"Th\",\n                \"\\xfe\": \"th\",\n                \"\\xdf\": \"ss\",\n                // Latin Extended-A block.\n                \"Ā\": \"A\",\n                \"Ă\": \"A\",\n                \"Ą\": \"A\",\n                \"ā\": \"a\",\n                \"ă\": \"a\",\n                \"ą\": \"a\",\n                \"Ć\": \"C\",\n                \"Ĉ\": \"C\",\n                \"Ċ\": \"C\",\n                \"Č\": \"C\",\n                \"ć\": \"c\",\n                \"ĉ\": \"c\",\n                \"ċ\": \"c\",\n                \"č\": \"c\",\n                \"Ď\": \"D\",\n                \"Đ\": \"D\",\n                \"ď\": \"d\",\n                \"đ\": \"d\",\n                \"Ē\": \"E\",\n                \"Ĕ\": \"E\",\n                \"Ė\": \"E\",\n                \"Ę\": \"E\",\n                \"Ě\": \"E\",\n                \"ē\": \"e\",\n                \"ĕ\": \"e\",\n                \"ė\": \"e\",\n                \"ę\": \"e\",\n                \"ě\": \"e\",\n                \"Ĝ\": \"G\",\n                \"Ğ\": \"G\",\n                \"Ġ\": \"G\",\n                \"Ģ\": \"G\",\n                \"ĝ\": \"g\",\n                \"ğ\": \"g\",\n                \"ġ\": \"g\",\n                \"ģ\": \"g\",\n                \"Ĥ\": \"H\",\n                \"Ħ\": \"H\",\n                \"ĥ\": \"h\",\n                \"ħ\": \"h\",\n                \"Ĩ\": \"I\",\n                \"Ī\": \"I\",\n                \"Ĭ\": \"I\",\n                \"Į\": \"I\",\n                \"İ\": \"I\",\n                \"ĩ\": \"i\",\n                \"ī\": \"i\",\n                \"ĭ\": \"i\",\n                \"į\": \"i\",\n                \"ı\": \"i\",\n                \"Ĵ\": \"J\",\n                \"ĵ\": \"j\",\n                \"Ķ\": \"K\",\n                \"ķ\": \"k\",\n                \"ĸ\": \"k\",\n                \"Ĺ\": \"L\",\n                \"Ļ\": \"L\",\n                \"Ľ\": \"L\",\n                \"Ŀ\": \"L\",\n                \"Ł\": \"L\",\n                \"ĺ\": \"l\",\n                \"ļ\": \"l\",\n                \"ľ\": \"l\",\n                \"ŀ\": \"l\",\n                \"ł\": \"l\",\n                \"Ń\": \"N\",\n                \"Ņ\": \"N\",\n                \"Ň\": \"N\",\n                \"Ŋ\": \"N\",\n                \"ń\": \"n\",\n                \"ņ\": \"n\",\n                \"ň\": \"n\",\n                \"ŋ\": \"n\",\n                \"Ō\": \"O\",\n                \"Ŏ\": \"O\",\n                \"Ő\": \"O\",\n                \"ō\": \"o\",\n                \"ŏ\": \"o\",\n                \"ő\": \"o\",\n                \"Ŕ\": \"R\",\n                \"Ŗ\": \"R\",\n                \"Ř\": \"R\",\n                \"ŕ\": \"r\",\n                \"ŗ\": \"r\",\n                \"ř\": \"r\",\n                \"Ś\": \"S\",\n                \"Ŝ\": \"S\",\n                \"Ş\": \"S\",\n                \"Š\": \"S\",\n                \"ś\": \"s\",\n                \"ŝ\": \"s\",\n                \"ş\": \"s\",\n                \"š\": \"s\",\n                \"Ţ\": \"T\",\n                \"Ť\": \"T\",\n                \"Ŧ\": \"T\",\n                \"ţ\": \"t\",\n                \"ť\": \"t\",\n                \"ŧ\": \"t\",\n                \"Ũ\": \"U\",\n                \"Ū\": \"U\",\n                \"Ŭ\": \"U\",\n                \"Ů\": \"U\",\n                \"Ű\": \"U\",\n                \"Ų\": \"U\",\n                \"ũ\": \"u\",\n                \"ū\": \"u\",\n                \"ŭ\": \"u\",\n                \"ů\": \"u\",\n                \"ű\": \"u\",\n                \"ų\": \"u\",\n                \"Ŵ\": \"W\",\n                \"ŵ\": \"w\",\n                \"Ŷ\": \"Y\",\n                \"ŷ\": \"y\",\n                \"Ÿ\": \"Y\",\n                \"Ź\": \"Z\",\n                \"Ż\": \"Z\",\n                \"Ž\": \"Z\",\n                \"ź\": \"z\",\n                \"ż\": \"z\",\n                \"ž\": \"z\",\n                \"Ĳ\": \"IJ\",\n                \"ĳ\": \"ij\",\n                \"Œ\": \"Oe\",\n                \"œ\": \"oe\",\n                \"ŉ\": \"'n\",\n                \"ſ\": \"s\"\n            };\n            var htmlEscapes = {\n                \"&\": \"&amp;\",\n                \"<\": \"&lt;\",\n                \">\": \"&gt;\",\n                '\"': \"&quot;\",\n                \"'\": \"&#39;\"\n            };\n            var htmlUnescapes = {\n                \"&amp;\": \"&\",\n                \"&lt;\": \"<\",\n                \"&gt;\": \">\",\n                \"&quot;\": '\"',\n                \"&#39;\": \"'\"\n            };\n            var stringEscapes = {\n                \"\\\\\": \"\\\\\",\n                \"'\": \"'\",\n                \"\\n\": \"n\",\n                \"\\r\": \"r\",\n                \"\\u2028\": \"u2028\",\n                \"\\u2029\": \"u2029\"\n            };\n            var freeParseFloat = parseFloat, freeParseInt = parseInt;\n            var freeGlobal = typeof global == \"object\" && global && global.Object === Object && global;\n            var freeSelf = typeof self == \"object\" && self && self.Object === Object && self;\n            var root = freeGlobal || freeSelf || Function(\"return this\")();\n            var freeExports = typeof exports == \"object\" && exports && !exports.nodeType && exports;\n            var freeModule = freeExports && typeof module == \"object\" && module && !module.nodeType && module;\n            var moduleExports = freeModule && freeModule.exports === freeExports;\n            var freeProcess = moduleExports && freeGlobal.process;\n            var nodeUtil = function() {\n                try {\n                    var types = freeModule && freeModule.require && freeModule.require(\"util\").types;\n                    if (types) {\n                        return types;\n                    }\n                    return freeProcess && freeProcess.binding && freeProcess.binding(\"util\");\n                } catch (e) {}\n            }();\n            var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n            function apply(func, thisArg, args) {\n                switch(args.length){\n                    case 0:\n                        return func.call(thisArg);\n                    case 1:\n                        return func.call(thisArg, args[0]);\n                    case 2:\n                        return func.call(thisArg, args[0], args[1]);\n                    case 3:\n                        return func.call(thisArg, args[0], args[1], args[2]);\n                }\n                return func.apply(thisArg, args);\n            }\n            function arrayAggregator(array, setter, iteratee, accumulator) {\n                var index = -1, length = array == null ? 0 : array.length;\n                while(++index < length){\n                    var value = array[index];\n                    setter(accumulator, value, iteratee(value), array);\n                }\n                return accumulator;\n            }\n            function arrayEach(array, iteratee) {\n                var index = -1, length = array == null ? 0 : array.length;\n                while(++index < length){\n                    if (iteratee(array[index], index, array) === false) {\n                        break;\n                    }\n                }\n                return array;\n            }\n            function arrayEachRight(array, iteratee) {\n                var length = array == null ? 0 : array.length;\n                while(length--){\n                    if (iteratee(array[length], length, array) === false) {\n                        break;\n                    }\n                }\n                return array;\n            }\n            function arrayEvery(array, predicate) {\n                var index = -1, length = array == null ? 0 : array.length;\n                while(++index < length){\n                    if (!predicate(array[index], index, array)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            function arrayFilter(array, predicate) {\n                var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];\n                while(++index < length){\n                    var value = array[index];\n                    if (predicate(value, index, array)) {\n                        result[resIndex++] = value;\n                    }\n                }\n                return result;\n            }\n            function arrayIncludes(array, value) {\n                var length = array == null ? 0 : array.length;\n                return !!length && baseIndexOf(array, value, 0) > -1;\n            }\n            function arrayIncludesWith(array, value, comparator) {\n                var index = -1, length = array == null ? 0 : array.length;\n                while(++index < length){\n                    if (comparator(value, array[index])) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n            function arrayMap(array, iteratee) {\n                var index = -1, length = array == null ? 0 : array.length, result = Array(length);\n                while(++index < length){\n                    result[index] = iteratee(array[index], index, array);\n                }\n                return result;\n            }\n            function arrayPush(array, values) {\n                var index = -1, length = values.length, offset = array.length;\n                while(++index < length){\n                    array[offset + index] = values[index];\n                }\n                return array;\n            }\n            function arrayReduce(array, iteratee, accumulator, initAccum) {\n                var index = -1, length = array == null ? 0 : array.length;\n                if (initAccum && length) {\n                    accumulator = array[++index];\n                }\n                while(++index < length){\n                    accumulator = iteratee(accumulator, array[index], index, array);\n                }\n                return accumulator;\n            }\n            function arrayReduceRight(array, iteratee, accumulator, initAccum) {\n                var length = array == null ? 0 : array.length;\n                if (initAccum && length) {\n                    accumulator = array[--length];\n                }\n                while(length--){\n                    accumulator = iteratee(accumulator, array[length], length, array);\n                }\n                return accumulator;\n            }\n            function arraySome(array, predicate) {\n                var index = -1, length = array == null ? 0 : array.length;\n                while(++index < length){\n                    if (predicate(array[index], index, array)) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n            var asciiSize = baseProperty(\"length\");\n            function asciiToArray(string) {\n                return string.split(\"\");\n            }\n            function asciiWords(string) {\n                return string.match(reAsciiWord) || [];\n            }\n            function baseFindKey(collection, predicate, eachFunc) {\n                var result;\n                eachFunc(collection, function(value, key, collection2) {\n                    if (predicate(value, key, collection2)) {\n                        result = key;\n                        return false;\n                    }\n                });\n                return result;\n            }\n            function baseFindIndex(array, predicate, fromIndex, fromRight) {\n                var length = array.length, index = fromIndex + (fromRight ? 1 : -1);\n                while(fromRight ? index-- : ++index < length){\n                    if (predicate(array[index], index, array)) {\n                        return index;\n                    }\n                }\n                return -1;\n            }\n            function baseIndexOf(array, value, fromIndex) {\n                return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);\n            }\n            function baseIndexOfWith(array, value, fromIndex, comparator) {\n                var index = fromIndex - 1, length = array.length;\n                while(++index < length){\n                    if (comparator(array[index], value)) {\n                        return index;\n                    }\n                }\n                return -1;\n            }\n            function baseIsNaN(value) {\n                return value !== value;\n            }\n            function baseMean(array, iteratee) {\n                var length = array == null ? 0 : array.length;\n                return length ? baseSum(array, iteratee) / length : NAN;\n            }\n            function baseProperty(key) {\n                return function(object) {\n                    return object == null ? undefined2 : object[key];\n                };\n            }\n            function basePropertyOf(object) {\n                return function(key) {\n                    return object == null ? undefined2 : object[key];\n                };\n            }\n            function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {\n                eachFunc(collection, function(value, index, collection2) {\n                    accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);\n                });\n                return accumulator;\n            }\n            function baseSortBy(array, comparer) {\n                var length = array.length;\n                array.sort(comparer);\n                while(length--){\n                    array[length] = array[length].value;\n                }\n                return array;\n            }\n            function baseSum(array, iteratee) {\n                var result, index = -1, length = array.length;\n                while(++index < length){\n                    var current = iteratee(array[index]);\n                    if (current !== undefined2) {\n                        result = result === undefined2 ? current : result + current;\n                    }\n                }\n                return result;\n            }\n            function baseTimes(n, iteratee) {\n                var index = -1, result = Array(n);\n                while(++index < n){\n                    result[index] = iteratee(index);\n                }\n                return result;\n            }\n            function baseToPairs(object, props) {\n                return arrayMap(props, function(key) {\n                    return [\n                        key,\n                        object[key]\n                    ];\n                });\n            }\n            function baseTrim(string) {\n                return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, \"\") : string;\n            }\n            function baseUnary(func) {\n                return function(value) {\n                    return func(value);\n                };\n            }\n            function baseValues(object, props) {\n                return arrayMap(props, function(key) {\n                    return object[key];\n                });\n            }\n            function cacheHas(cache, key) {\n                return cache.has(key);\n            }\n            function charsStartIndex(strSymbols, chrSymbols) {\n                var index = -1, length = strSymbols.length;\n                while(++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1){}\n                return index;\n            }\n            function charsEndIndex(strSymbols, chrSymbols) {\n                var index = strSymbols.length;\n                while(index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1){}\n                return index;\n            }\n            function countHolders(array, placeholder) {\n                var length = array.length, result = 0;\n                while(length--){\n                    if (array[length] === placeholder) {\n                        ++result;\n                    }\n                }\n                return result;\n            }\n            var deburrLetter = basePropertyOf(deburredLetters);\n            var escapeHtmlChar = basePropertyOf(htmlEscapes);\n            function escapeStringChar(chr) {\n                return \"\\\\\" + stringEscapes[chr];\n            }\n            function getValue(object, key) {\n                return object == null ? undefined2 : object[key];\n            }\n            function hasUnicode(string) {\n                return reHasUnicode.test(string);\n            }\n            function hasUnicodeWord(string) {\n                return reHasUnicodeWord.test(string);\n            }\n            function iteratorToArray(iterator) {\n                var data, result = [];\n                while(!(data = iterator.next()).done){\n                    result.push(data.value);\n                }\n                return result;\n            }\n            function mapToArray(map) {\n                var index = -1, result = Array(map.size);\n                map.forEach(function(value, key) {\n                    result[++index] = [\n                        key,\n                        value\n                    ];\n                });\n                return result;\n            }\n            function overArg(func, transform) {\n                return function(arg) {\n                    return func(transform(arg));\n                };\n            }\n            function replaceHolders(array, placeholder) {\n                var index = -1, length = array.length, resIndex = 0, result = [];\n                while(++index < length){\n                    var value = array[index];\n                    if (value === placeholder || value === PLACEHOLDER) {\n                        array[index] = PLACEHOLDER;\n                        result[resIndex++] = index;\n                    }\n                }\n                return result;\n            }\n            function setToArray(set) {\n                var index = -1, result = Array(set.size);\n                set.forEach(function(value) {\n                    result[++index] = value;\n                });\n                return result;\n            }\n            function setToPairs(set) {\n                var index = -1, result = Array(set.size);\n                set.forEach(function(value) {\n                    result[++index] = [\n                        value,\n                        value\n                    ];\n                });\n                return result;\n            }\n            function strictIndexOf(array, value, fromIndex) {\n                var index = fromIndex - 1, length = array.length;\n                while(++index < length){\n                    if (array[index] === value) {\n                        return index;\n                    }\n                }\n                return -1;\n            }\n            function strictLastIndexOf(array, value, fromIndex) {\n                var index = fromIndex + 1;\n                while(index--){\n                    if (array[index] === value) {\n                        return index;\n                    }\n                }\n                return index;\n            }\n            function stringSize(string) {\n                return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);\n            }\n            function stringToArray(string) {\n                return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);\n            }\n            function trimmedEndIndex(string) {\n                var index = string.length;\n                while(index-- && reWhitespace.test(string.charAt(index))){}\n                return index;\n            }\n            var unescapeHtmlChar = basePropertyOf(htmlUnescapes);\n            function unicodeSize(string) {\n                var result = reUnicode.lastIndex = 0;\n                while(reUnicode.test(string)){\n                    ++result;\n                }\n                return result;\n            }\n            function unicodeToArray(string) {\n                return string.match(reUnicode) || [];\n            }\n            function unicodeWords(string) {\n                return string.match(reUnicodeWord) || [];\n            }\n            var runInContext = function runInContext2(context) {\n                context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));\n                var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;\n                var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;\n                var coreJsData = context[\"__core-js_shared__\"];\n                var funcToString = funcProto.toString;\n                var hasOwnProperty = objectProto.hasOwnProperty;\n                var idCounter = 0;\n                var maskSrcKey = function() {\n                    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || \"\");\n                    return uid ? \"Symbol(src)_1.\" + uid : \"\";\n                }();\n                var nativeObjectToString = objectProto.toString;\n                var objectCtorString = funcToString.call(Object2);\n                var oldDash = root._;\n                var reIsNative = RegExp2(\"^\" + funcToString.call(hasOwnProperty).replace(reRegExpChar, \"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\");\n                var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;\n                var defineProperty = function() {\n                    try {\n                        var func = getNative(Object2, \"defineProperty\");\n                        func({}, \"\", {});\n                        return func;\n                    } catch (e) {}\n                }();\n                var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;\n                var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;\n                var DataView = getNative(context, \"DataView\"), Map2 = getNative(context, \"Map\"), Promise2 = getNative(context, \"Promise\"), Set2 = getNative(context, \"Set\"), WeakMap2 = getNative(context, \"WeakMap\"), nativeCreate = getNative(Object2, \"create\");\n                var metaMap = WeakMap2 && new WeakMap2();\n                var realNames = {};\n                var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);\n                var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;\n                function lodash(value) {\n                    if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {\n                        if (value instanceof LodashWrapper) {\n                            return value;\n                        }\n                        if (hasOwnProperty.call(value, \"__wrapped__\")) {\n                            return wrapperClone(value);\n                        }\n                    }\n                    return new LodashWrapper(value);\n                }\n                var baseCreate = function() {\n                    function object() {}\n                    return function(proto) {\n                        if (!isObject(proto)) {\n                            return {};\n                        }\n                        if (objectCreate) {\n                            return objectCreate(proto);\n                        }\n                        object.prototype = proto;\n                        var result2 = new object();\n                        object.prototype = undefined2;\n                        return result2;\n                    };\n                }();\n                function baseLodash() {}\n                function LodashWrapper(value, chainAll) {\n                    this.__wrapped__ = value;\n                    this.__actions__ = [];\n                    this.__chain__ = !!chainAll;\n                    this.__index__ = 0;\n                    this.__values__ = undefined2;\n                }\n                lodash.templateSettings = {\n                    /**\n           * Used to detect `data` property values to be HTML-escaped.\n           *\n           * @memberOf _.templateSettings\n           * @type {RegExp}\n           */ \"escape\": reEscape,\n                    /**\n           * Used to detect code to be evaluated.\n           *\n           * @memberOf _.templateSettings\n           * @type {RegExp}\n           */ \"evaluate\": reEvaluate,\n                    /**\n           * Used to detect `data` property values to inject.\n           *\n           * @memberOf _.templateSettings\n           * @type {RegExp}\n           */ \"interpolate\": reInterpolate,\n                    /**\n           * Used to reference the data object in the template text.\n           *\n           * @memberOf _.templateSettings\n           * @type {string}\n           */ \"variable\": \"\",\n                    /**\n           * Used to import variables into the compiled template.\n           *\n           * @memberOf _.templateSettings\n           * @type {Object}\n           */ \"imports\": {\n                        /**\n             * A reference to the `lodash` function.\n             *\n             * @memberOf _.templateSettings.imports\n             * @type {Function}\n             */ \"_\": lodash\n                    }\n                };\n                lodash.prototype = baseLodash.prototype;\n                lodash.prototype.constructor = lodash;\n                LodashWrapper.prototype = baseCreate(baseLodash.prototype);\n                LodashWrapper.prototype.constructor = LodashWrapper;\n                function LazyWrapper(value) {\n                    this.__wrapped__ = value;\n                    this.__actions__ = [];\n                    this.__dir__ = 1;\n                    this.__filtered__ = false;\n                    this.__iteratees__ = [];\n                    this.__takeCount__ = MAX_ARRAY_LENGTH;\n                    this.__views__ = [];\n                }\n                function lazyClone() {\n                    var result2 = new LazyWrapper(this.__wrapped__);\n                    result2.__actions__ = copyArray(this.__actions__);\n                    result2.__dir__ = this.__dir__;\n                    result2.__filtered__ = this.__filtered__;\n                    result2.__iteratees__ = copyArray(this.__iteratees__);\n                    result2.__takeCount__ = this.__takeCount__;\n                    result2.__views__ = copyArray(this.__views__);\n                    return result2;\n                }\n                function lazyReverse() {\n                    if (this.__filtered__) {\n                        var result2 = new LazyWrapper(this);\n                        result2.__dir__ = -1;\n                        result2.__filtered__ = true;\n                    } else {\n                        result2 = this.clone();\n                        result2.__dir__ *= -1;\n                    }\n                    return result2;\n                }\n                function lazyValue() {\n                    var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);\n                    if (!isArr || !isRight && arrLength == length && takeCount == length) {\n                        return baseWrapperValue(array, this.__actions__);\n                    }\n                    var result2 = [];\n                    outer: while(length-- && resIndex < takeCount){\n                        index += dir;\n                        var iterIndex = -1, value = array[index];\n                        while(++iterIndex < iterLength){\n                            var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);\n                            if (type == LAZY_MAP_FLAG) {\n                                value = computed;\n                            } else if (!computed) {\n                                if (type == LAZY_FILTER_FLAG) {\n                                    continue outer;\n                                } else {\n                                    break outer;\n                                }\n                            }\n                        }\n                        result2[resIndex++] = value;\n                    }\n                    return result2;\n                }\n                LazyWrapper.prototype = baseCreate(baseLodash.prototype);\n                LazyWrapper.prototype.constructor = LazyWrapper;\n                function Hash(entries) {\n                    var index = -1, length = entries == null ? 0 : entries.length;\n                    this.clear();\n                    while(++index < length){\n                        var entry = entries[index];\n                        this.set(entry[0], entry[1]);\n                    }\n                }\n                function hashClear() {\n                    this.__data__ = nativeCreate ? nativeCreate(null) : {};\n                    this.size = 0;\n                }\n                function hashDelete(key) {\n                    var result2 = this.has(key) && delete this.__data__[key];\n                    this.size -= result2 ? 1 : 0;\n                    return result2;\n                }\n                function hashGet(key) {\n                    var data = this.__data__;\n                    if (nativeCreate) {\n                        var result2 = data[key];\n                        return result2 === HASH_UNDEFINED ? undefined2 : result2;\n                    }\n                    return hasOwnProperty.call(data, key) ? data[key] : undefined2;\n                }\n                function hashHas(key) {\n                    var data = this.__data__;\n                    return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);\n                }\n                function hashSet(key, value) {\n                    var data = this.__data__;\n                    this.size += this.has(key) ? 0 : 1;\n                    data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;\n                    return this;\n                }\n                Hash.prototype.clear = hashClear;\n                Hash.prototype[\"delete\"] = hashDelete;\n                Hash.prototype.get = hashGet;\n                Hash.prototype.has = hashHas;\n                Hash.prototype.set = hashSet;\n                function ListCache(entries) {\n                    var index = -1, length = entries == null ? 0 : entries.length;\n                    this.clear();\n                    while(++index < length){\n                        var entry = entries[index];\n                        this.set(entry[0], entry[1]);\n                    }\n                }\n                function listCacheClear() {\n                    this.__data__ = [];\n                    this.size = 0;\n                }\n                function listCacheDelete(key) {\n                    var data = this.__data__, index = assocIndexOf(data, key);\n                    if (index < 0) {\n                        return false;\n                    }\n                    var lastIndex = data.length - 1;\n                    if (index == lastIndex) {\n                        data.pop();\n                    } else {\n                        splice.call(data, index, 1);\n                    }\n                    --this.size;\n                    return true;\n                }\n                function listCacheGet(key) {\n                    var data = this.__data__, index = assocIndexOf(data, key);\n                    return index < 0 ? undefined2 : data[index][1];\n                }\n                function listCacheHas(key) {\n                    return assocIndexOf(this.__data__, key) > -1;\n                }\n                function listCacheSet(key, value) {\n                    var data = this.__data__, index = assocIndexOf(data, key);\n                    if (index < 0) {\n                        ++this.size;\n                        data.push([\n                            key,\n                            value\n                        ]);\n                    } else {\n                        data[index][1] = value;\n                    }\n                    return this;\n                }\n                ListCache.prototype.clear = listCacheClear;\n                ListCache.prototype[\"delete\"] = listCacheDelete;\n                ListCache.prototype.get = listCacheGet;\n                ListCache.prototype.has = listCacheHas;\n                ListCache.prototype.set = listCacheSet;\n                function MapCache(entries) {\n                    var index = -1, length = entries == null ? 0 : entries.length;\n                    this.clear();\n                    while(++index < length){\n                        var entry = entries[index];\n                        this.set(entry[0], entry[1]);\n                    }\n                }\n                function mapCacheClear() {\n                    this.size = 0;\n                    this.__data__ = {\n                        \"hash\": new Hash(),\n                        \"map\": new (Map2 || ListCache)(),\n                        \"string\": new Hash()\n                    };\n                }\n                function mapCacheDelete(key) {\n                    var result2 = getMapData(this, key)[\"delete\"](key);\n                    this.size -= result2 ? 1 : 0;\n                    return result2;\n                }\n                function mapCacheGet(key) {\n                    return getMapData(this, key).get(key);\n                }\n                function mapCacheHas(key) {\n                    return getMapData(this, key).has(key);\n                }\n                function mapCacheSet(key, value) {\n                    var data = getMapData(this, key), size2 = data.size;\n                    data.set(key, value);\n                    this.size += data.size == size2 ? 0 : 1;\n                    return this;\n                }\n                MapCache.prototype.clear = mapCacheClear;\n                MapCache.prototype[\"delete\"] = mapCacheDelete;\n                MapCache.prototype.get = mapCacheGet;\n                MapCache.prototype.has = mapCacheHas;\n                MapCache.prototype.set = mapCacheSet;\n                function SetCache(values2) {\n                    var index = -1, length = values2 == null ? 0 : values2.length;\n                    this.__data__ = new MapCache();\n                    while(++index < length){\n                        this.add(values2[index]);\n                    }\n                }\n                function setCacheAdd(value) {\n                    this.__data__.set(value, HASH_UNDEFINED);\n                    return this;\n                }\n                function setCacheHas(value) {\n                    return this.__data__.has(value);\n                }\n                SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\n                SetCache.prototype.has = setCacheHas;\n                function Stack(entries) {\n                    var data = this.__data__ = new ListCache(entries);\n                    this.size = data.size;\n                }\n                function stackClear() {\n                    this.__data__ = new ListCache();\n                    this.size = 0;\n                }\n                function stackDelete(key) {\n                    var data = this.__data__, result2 = data[\"delete\"](key);\n                    this.size = data.size;\n                    return result2;\n                }\n                function stackGet(key) {\n                    return this.__data__.get(key);\n                }\n                function stackHas(key) {\n                    return this.__data__.has(key);\n                }\n                function stackSet(key, value) {\n                    var data = this.__data__;\n                    if (data instanceof ListCache) {\n                        var pairs = data.__data__;\n                        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {\n                            pairs.push([\n                                key,\n                                value\n                            ]);\n                            this.size = ++data.size;\n                            return this;\n                        }\n                        data = this.__data__ = new MapCache(pairs);\n                    }\n                    data.set(key, value);\n                    this.size = data.size;\n                    return this;\n                }\n                Stack.prototype.clear = stackClear;\n                Stack.prototype[\"delete\"] = stackDelete;\n                Stack.prototype.get = stackGet;\n                Stack.prototype.has = stackHas;\n                Stack.prototype.set = stackSet;\n                function arrayLikeKeys(value, inherited) {\n                    var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;\n                    for(var key in value){\n                        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.\n                        (key == \"length\" || // Node.js 0.10 has enumerable non-index properties on buffers.\n                        isBuff && (key == \"offset\" || key == \"parent\") || // PhantomJS 2 has enumerable non-index properties on typed arrays.\n                        isType && (key == \"buffer\" || key == \"byteLength\" || key == \"byteOffset\") || // Skip index properties.\n                        isIndex(key, length)))) {\n                            result2.push(key);\n                        }\n                    }\n                    return result2;\n                }\n                function arraySample(array) {\n                    var length = array.length;\n                    return length ? array[baseRandom(0, length - 1)] : undefined2;\n                }\n                function arraySampleSize(array, n) {\n                    return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));\n                }\n                function arrayShuffle(array) {\n                    return shuffleSelf(copyArray(array));\n                }\n                function assignMergeValue(object, key, value) {\n                    if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {\n                        baseAssignValue(object, key, value);\n                    }\n                }\n                function assignValue(object, key, value) {\n                    var objValue = object[key];\n                    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {\n                        baseAssignValue(object, key, value);\n                    }\n                }\n                function assocIndexOf(array, key) {\n                    var length = array.length;\n                    while(length--){\n                        if (eq(array[length][0], key)) {\n                            return length;\n                        }\n                    }\n                    return -1;\n                }\n                function baseAggregator(collection, setter, iteratee2, accumulator) {\n                    baseEach(collection, function(value, key, collection2) {\n                        setter(accumulator, value, iteratee2(value), collection2);\n                    });\n                    return accumulator;\n                }\n                function baseAssign(object, source) {\n                    return object && copyObject(source, keys(source), object);\n                }\n                function baseAssignIn(object, source) {\n                    return object && copyObject(source, keysIn(source), object);\n                }\n                function baseAssignValue(object, key, value) {\n                    if (key == \"__proto__\" && defineProperty) {\n                        defineProperty(object, key, {\n                            \"configurable\": true,\n                            \"enumerable\": true,\n                            \"value\": value,\n                            \"writable\": true\n                        });\n                    } else {\n                        object[key] = value;\n                    }\n                }\n                function baseAt(object, paths) {\n                    var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;\n                    while(++index < length){\n                        result2[index] = skip ? undefined2 : get(object, paths[index]);\n                    }\n                    return result2;\n                }\n                function baseClamp(number, lower, upper) {\n                    if (number === number) {\n                        if (upper !== undefined2) {\n                            number = number <= upper ? number : upper;\n                        }\n                        if (lower !== undefined2) {\n                            number = number >= lower ? number : lower;\n                        }\n                    }\n                    return number;\n                }\n                function baseClone(value, bitmask, customizer, key, object, stack) {\n                    var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;\n                    if (customizer) {\n                        result2 = object ? customizer(value, key, object, stack) : customizer(value);\n                    }\n                    if (result2 !== undefined2) {\n                        return result2;\n                    }\n                    if (!isObject(value)) {\n                        return value;\n                    }\n                    var isArr = isArray(value);\n                    if (isArr) {\n                        result2 = initCloneArray(value);\n                        if (!isDeep) {\n                            return copyArray(value, result2);\n                        }\n                    } else {\n                        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;\n                        if (isBuffer(value)) {\n                            return cloneBuffer(value, isDeep);\n                        }\n                        if (tag == objectTag || tag == argsTag || isFunc && !object) {\n                            result2 = isFlat || isFunc ? {} : initCloneObject(value);\n                            if (!isDeep) {\n                                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));\n                            }\n                        } else {\n                            if (!cloneableTags[tag]) {\n                                return object ? value : {};\n                            }\n                            result2 = initCloneByTag(value, tag, isDeep);\n                        }\n                    }\n                    stack || (stack = new Stack());\n                    var stacked = stack.get(value);\n                    if (stacked) {\n                        return stacked;\n                    }\n                    stack.set(value, result2);\n                    if (isSet(value)) {\n                        value.forEach(function(subValue) {\n                            result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\n                        });\n                    } else if (isMap(value)) {\n                        value.forEach(function(subValue, key2) {\n                            result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));\n                        });\n                    }\n                    var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;\n                    var props = isArr ? undefined2 : keysFunc(value);\n                    arrayEach(props || value, function(subValue, key2) {\n                        if (props) {\n                            key2 = subValue;\n                            subValue = value[key2];\n                        }\n                        assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));\n                    });\n                    return result2;\n                }\n                function baseConforms(source) {\n                    var props = keys(source);\n                    return function(object) {\n                        return baseConformsTo(object, source, props);\n                    };\n                }\n                function baseConformsTo(object, source, props) {\n                    var length = props.length;\n                    if (object == null) {\n                        return !length;\n                    }\n                    object = Object2(object);\n                    while(length--){\n                        var key = props[length], predicate = source[key], value = object[key];\n                        if (value === undefined2 && !(key in object) || !predicate(value)) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n                function baseDelay(func, wait, args) {\n                    if (typeof func != \"function\") {\n                        throw new TypeError2(FUNC_ERROR_TEXT);\n                    }\n                    return setTimeout(function() {\n                        func.apply(undefined2, args);\n                    }, wait);\n                }\n                function baseDifference(array, values2, iteratee2, comparator) {\n                    var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;\n                    if (!length) {\n                        return result2;\n                    }\n                    if (iteratee2) {\n                        values2 = arrayMap(values2, baseUnary(iteratee2));\n                    }\n                    if (comparator) {\n                        includes2 = arrayIncludesWith;\n                        isCommon = false;\n                    } else if (values2.length >= LARGE_ARRAY_SIZE) {\n                        includes2 = cacheHas;\n                        isCommon = false;\n                        values2 = new SetCache(values2);\n                    }\n                    outer: while(++index < length){\n                        var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);\n                        value = comparator || value !== 0 ? value : 0;\n                        if (isCommon && computed === computed) {\n                            var valuesIndex = valuesLength;\n                            while(valuesIndex--){\n                                if (values2[valuesIndex] === computed) {\n                                    continue outer;\n                                }\n                            }\n                            result2.push(value);\n                        } else if (!includes2(values2, computed, comparator)) {\n                            result2.push(value);\n                        }\n                    }\n                    return result2;\n                }\n                var baseEach = createBaseEach(baseForOwn);\n                var baseEachRight = createBaseEach(baseForOwnRight, true);\n                function baseEvery(collection, predicate) {\n                    var result2 = true;\n                    baseEach(collection, function(value, index, collection2) {\n                        result2 = !!predicate(value, index, collection2);\n                        return result2;\n                    });\n                    return result2;\n                }\n                function baseExtremum(array, iteratee2, comparator) {\n                    var index = -1, length = array.length;\n                    while(++index < length){\n                        var value = array[index], current = iteratee2(value);\n                        if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {\n                            var computed = current, result2 = value;\n                        }\n                    }\n                    return result2;\n                }\n                function baseFill(array, value, start, end) {\n                    var length = array.length;\n                    start = toInteger(start);\n                    if (start < 0) {\n                        start = -start > length ? 0 : length + start;\n                    }\n                    end = end === undefined2 || end > length ? length : toInteger(end);\n                    if (end < 0) {\n                        end += length;\n                    }\n                    end = start > end ? 0 : toLength(end);\n                    while(start < end){\n                        array[start++] = value;\n                    }\n                    return array;\n                }\n                function baseFilter(collection, predicate) {\n                    var result2 = [];\n                    baseEach(collection, function(value, index, collection2) {\n                        if (predicate(value, index, collection2)) {\n                            result2.push(value);\n                        }\n                    });\n                    return result2;\n                }\n                function baseFlatten(array, depth, predicate, isStrict, result2) {\n                    var index = -1, length = array.length;\n                    predicate || (predicate = isFlattenable);\n                    result2 || (result2 = []);\n                    while(++index < length){\n                        var value = array[index];\n                        if (depth > 0 && predicate(value)) {\n                            if (depth > 1) {\n                                baseFlatten(value, depth - 1, predicate, isStrict, result2);\n                            } else {\n                                arrayPush(result2, value);\n                            }\n                        } else if (!isStrict) {\n                            result2[result2.length] = value;\n                        }\n                    }\n                    return result2;\n                }\n                var baseFor = createBaseFor();\n                var baseForRight = createBaseFor(true);\n                function baseForOwn(object, iteratee2) {\n                    return object && baseFor(object, iteratee2, keys);\n                }\n                function baseForOwnRight(object, iteratee2) {\n                    return object && baseForRight(object, iteratee2, keys);\n                }\n                function baseFunctions(object, props) {\n                    return arrayFilter(props, function(key) {\n                        return isFunction(object[key]);\n                    });\n                }\n                function baseGet(object, path) {\n                    path = castPath(path, object);\n                    var index = 0, length = path.length;\n                    while(object != null && index < length){\n                        object = object[toKey(path[index++])];\n                    }\n                    return index && index == length ? object : undefined2;\n                }\n                function baseGetAllKeys(object, keysFunc, symbolsFunc) {\n                    var result2 = keysFunc(object);\n                    return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));\n                }\n                function baseGetTag(value) {\n                    if (value == null) {\n                        return value === undefined2 ? undefinedTag : nullTag;\n                    }\n                    return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);\n                }\n                function baseGt(value, other) {\n                    return value > other;\n                }\n                function baseHas(object, key) {\n                    return object != null && hasOwnProperty.call(object, key);\n                }\n                function baseHasIn(object, key) {\n                    return object != null && key in Object2(object);\n                }\n                function baseInRange(number, start, end) {\n                    return number >= nativeMin(start, end) && number < nativeMax(start, end);\n                }\n                function baseIntersection(arrays, iteratee2, comparator) {\n                    var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];\n                    while(othIndex--){\n                        var array = arrays[othIndex];\n                        if (othIndex && iteratee2) {\n                            array = arrayMap(array, baseUnary(iteratee2));\n                        }\n                        maxLength = nativeMin(array.length, maxLength);\n                        caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;\n                    }\n                    array = arrays[0];\n                    var index = -1, seen = caches[0];\n                    outer: while(++index < length && result2.length < maxLength){\n                        var value = array[index], computed = iteratee2 ? iteratee2(value) : value;\n                        value = comparator || value !== 0 ? value : 0;\n                        if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {\n                            othIndex = othLength;\n                            while(--othIndex){\n                                var cache = caches[othIndex];\n                                if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {\n                                    continue outer;\n                                }\n                            }\n                            if (seen) {\n                                seen.push(computed);\n                            }\n                            result2.push(value);\n                        }\n                    }\n                    return result2;\n                }\n                function baseInverter(object, setter, iteratee2, accumulator) {\n                    baseForOwn(object, function(value, key, object2) {\n                        setter(accumulator, iteratee2(value), key, object2);\n                    });\n                    return accumulator;\n                }\n                function baseInvoke(object, path, args) {\n                    path = castPath(path, object);\n                    object = parent(object, path);\n                    var func = object == null ? object : object[toKey(last(path))];\n                    return func == null ? undefined2 : apply(func, object, args);\n                }\n                function baseIsArguments(value) {\n                    return isObjectLike(value) && baseGetTag(value) == argsTag;\n                }\n                function baseIsArrayBuffer(value) {\n                    return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;\n                }\n                function baseIsDate(value) {\n                    return isObjectLike(value) && baseGetTag(value) == dateTag;\n                }\n                function baseIsEqual(value, other, bitmask, customizer, stack) {\n                    if (value === other) {\n                        return true;\n                    }\n                    if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {\n                        return value !== value && other !== other;\n                    }\n                    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n                }\n                function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n                    var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);\n                    objTag = objTag == argsTag ? objectTag : objTag;\n                    othTag = othTag == argsTag ? objectTag : othTag;\n                    var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;\n                    if (isSameTag && isBuffer(object)) {\n                        if (!isBuffer(other)) {\n                            return false;\n                        }\n                        objIsArr = true;\n                        objIsObj = false;\n                    }\n                    if (isSameTag && !objIsObj) {\n                        stack || (stack = new Stack());\n                        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n                    }\n                    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n                        var objIsWrapped = objIsObj && hasOwnProperty.call(object, \"__wrapped__\"), othIsWrapped = othIsObj && hasOwnProperty.call(other, \"__wrapped__\");\n                        if (objIsWrapped || othIsWrapped) {\n                            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;\n                            stack || (stack = new Stack());\n                            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n                        }\n                    }\n                    if (!isSameTag) {\n                        return false;\n                    }\n                    stack || (stack = new Stack());\n                    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n                }\n                function baseIsMap(value) {\n                    return isObjectLike(value) && getTag(value) == mapTag;\n                }\n                function baseIsMatch(object, source, matchData, customizer) {\n                    var index = matchData.length, length = index, noCustomizer = !customizer;\n                    if (object == null) {\n                        return !length;\n                    }\n                    object = Object2(object);\n                    while(index--){\n                        var data = matchData[index];\n                        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {\n                            return false;\n                        }\n                    }\n                    while(++index < length){\n                        data = matchData[index];\n                        var key = data[0], objValue = object[key], srcValue = data[1];\n                        if (noCustomizer && data[2]) {\n                            if (objValue === undefined2 && !(key in object)) {\n                                return false;\n                            }\n                        } else {\n                            var stack = new Stack();\n                            if (customizer) {\n                                var result2 = customizer(objValue, srcValue, key, object, source, stack);\n                            }\n                            if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {\n                                return false;\n                            }\n                        }\n                    }\n                    return true;\n                }\n                function baseIsNative(value) {\n                    if (!isObject(value) || isMasked(value)) {\n                        return false;\n                    }\n                    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n                    return pattern.test(toSource(value));\n                }\n                function baseIsRegExp(value) {\n                    return isObjectLike(value) && baseGetTag(value) == regexpTag;\n                }\n                function baseIsSet(value) {\n                    return isObjectLike(value) && getTag(value) == setTag;\n                }\n                function baseIsTypedArray(value) {\n                    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n                }\n                function baseIteratee(value) {\n                    if (typeof value == \"function\") {\n                        return value;\n                    }\n                    if (value == null) {\n                        return identity;\n                    }\n                    if (typeof value == \"object\") {\n                        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);\n                    }\n                    return property(value);\n                }\n                function baseKeys(object) {\n                    if (!isPrototype(object)) {\n                        return nativeKeys(object);\n                    }\n                    var result2 = [];\n                    for(var key in Object2(object)){\n                        if (hasOwnProperty.call(object, key) && key != \"constructor\") {\n                            result2.push(key);\n                        }\n                    }\n                    return result2;\n                }\n                function baseKeysIn(object) {\n                    if (!isObject(object)) {\n                        return nativeKeysIn(object);\n                    }\n                    var isProto = isPrototype(object), result2 = [];\n                    for(var key in object){\n                        if (!(key == \"constructor\" && (isProto || !hasOwnProperty.call(object, key)))) {\n                            result2.push(key);\n                        }\n                    }\n                    return result2;\n                }\n                function baseLt(value, other) {\n                    return value < other;\n                }\n                function baseMap(collection, iteratee2) {\n                    var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];\n                    baseEach(collection, function(value, key, collection2) {\n                        result2[++index] = iteratee2(value, key, collection2);\n                    });\n                    return result2;\n                }\n                function baseMatches(source) {\n                    var matchData = getMatchData(source);\n                    if (matchData.length == 1 && matchData[0][2]) {\n                        return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n                    }\n                    return function(object) {\n                        return object === source || baseIsMatch(object, source, matchData);\n                    };\n                }\n                function baseMatchesProperty(path, srcValue) {\n                    if (isKey(path) && isStrictComparable(srcValue)) {\n                        return matchesStrictComparable(toKey(path), srcValue);\n                    }\n                    return function(object) {\n                        var objValue = get(object, path);\n                        return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n                    };\n                }\n                function baseMerge(object, source, srcIndex, customizer, stack) {\n                    if (object === source) {\n                        return;\n                    }\n                    baseFor(source, function(srcValue, key) {\n                        stack || (stack = new Stack());\n                        if (isObject(srcValue)) {\n                            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n                        } else {\n                            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + \"\", object, source, stack) : undefined2;\n                            if (newValue === undefined2) {\n                                newValue = srcValue;\n                            }\n                            assignMergeValue(object, key, newValue);\n                        }\n                    }, keysIn);\n                }\n                function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n                    var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);\n                    if (stacked) {\n                        assignMergeValue(object, key, stacked);\n                        return;\n                    }\n                    var newValue = customizer ? customizer(objValue, srcValue, key + \"\", object, source, stack) : undefined2;\n                    var isCommon = newValue === undefined2;\n                    if (isCommon) {\n                        var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);\n                        newValue = srcValue;\n                        if (isArr || isBuff || isTyped) {\n                            if (isArray(objValue)) {\n                                newValue = objValue;\n                            } else if (isArrayLikeObject(objValue)) {\n                                newValue = copyArray(objValue);\n                            } else if (isBuff) {\n                                isCommon = false;\n                                newValue = cloneBuffer(srcValue, true);\n                            } else if (isTyped) {\n                                isCommon = false;\n                                newValue = cloneTypedArray(srcValue, true);\n                            } else {\n                                newValue = [];\n                            }\n                        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n                            newValue = objValue;\n                            if (isArguments(objValue)) {\n                                newValue = toPlainObject(objValue);\n                            } else if (!isObject(objValue) || isFunction(objValue)) {\n                                newValue = initCloneObject(srcValue);\n                            }\n                        } else {\n                            isCommon = false;\n                        }\n                    }\n                    if (isCommon) {\n                        stack.set(srcValue, newValue);\n                        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n                        stack[\"delete\"](srcValue);\n                    }\n                    assignMergeValue(object, key, newValue);\n                }\n                function baseNth(array, n) {\n                    var length = array.length;\n                    if (!length) {\n                        return;\n                    }\n                    n += n < 0 ? length : 0;\n                    return isIndex(n, length) ? array[n] : undefined2;\n                }\n                function baseOrderBy(collection, iteratees, orders) {\n                    if (iteratees.length) {\n                        iteratees = arrayMap(iteratees, function(iteratee2) {\n                            if (isArray(iteratee2)) {\n                                return function(value) {\n                                    return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);\n                                };\n                            }\n                            return iteratee2;\n                        });\n                    } else {\n                        iteratees = [\n                            identity\n                        ];\n                    }\n                    var index = -1;\n                    iteratees = arrayMap(iteratees, baseUnary(getIteratee()));\n                    var result2 = baseMap(collection, function(value, key, collection2) {\n                        var criteria = arrayMap(iteratees, function(iteratee2) {\n                            return iteratee2(value);\n                        });\n                        return {\n                            \"criteria\": criteria,\n                            \"index\": ++index,\n                            \"value\": value\n                        };\n                    });\n                    return baseSortBy(result2, function(object, other) {\n                        return compareMultiple(object, other, orders);\n                    });\n                }\n                function basePick(object, paths) {\n                    return basePickBy(object, paths, function(value, path) {\n                        return hasIn(object, path);\n                    });\n                }\n                function basePickBy(object, paths, predicate) {\n                    var index = -1, length = paths.length, result2 = {};\n                    while(++index < length){\n                        var path = paths[index], value = baseGet(object, path);\n                        if (predicate(value, path)) {\n                            baseSet(result2, castPath(path, object), value);\n                        }\n                    }\n                    return result2;\n                }\n                function basePropertyDeep(path) {\n                    return function(object) {\n                        return baseGet(object, path);\n                    };\n                }\n                function basePullAll(array, values2, iteratee2, comparator) {\n                    var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;\n                    if (array === values2) {\n                        values2 = copyArray(values2);\n                    }\n                    if (iteratee2) {\n                        seen = arrayMap(array, baseUnary(iteratee2));\n                    }\n                    while(++index < length){\n                        var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;\n                        while((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1){\n                            if (seen !== array) {\n                                splice.call(seen, fromIndex, 1);\n                            }\n                            splice.call(array, fromIndex, 1);\n                        }\n                    }\n                    return array;\n                }\n                function basePullAt(array, indexes) {\n                    var length = array ? indexes.length : 0, lastIndex = length - 1;\n                    while(length--){\n                        var index = indexes[length];\n                        if (length == lastIndex || index !== previous) {\n                            var previous = index;\n                            if (isIndex(index)) {\n                                splice.call(array, index, 1);\n                            } else {\n                                baseUnset(array, index);\n                            }\n                        }\n                    }\n                    return array;\n                }\n                function baseRandom(lower, upper) {\n                    return lower + nativeFloor(nativeRandom() * (upper - lower + 1));\n                }\n                function baseRange(start, end, step, fromRight) {\n                    var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);\n                    while(length--){\n                        result2[fromRight ? length : ++index] = start;\n                        start += step;\n                    }\n                    return result2;\n                }\n                function baseRepeat(string, n) {\n                    var result2 = \"\";\n                    if (!string || n < 1 || n > MAX_SAFE_INTEGER) {\n                        return result2;\n                    }\n                    do {\n                        if (n % 2) {\n                            result2 += string;\n                        }\n                        n = nativeFloor(n / 2);\n                        if (n) {\n                            string += string;\n                        }\n                    }while (n);\n                    return result2;\n                }\n                function baseRest(func, start) {\n                    return setToString(overRest(func, start, identity), func + \"\");\n                }\n                function baseSample(collection) {\n                    return arraySample(values(collection));\n                }\n                function baseSampleSize(collection, n) {\n                    var array = values(collection);\n                    return shuffleSelf(array, baseClamp(n, 0, array.length));\n                }\n                function baseSet(object, path, value, customizer) {\n                    if (!isObject(object)) {\n                        return object;\n                    }\n                    path = castPath(path, object);\n                    var index = -1, length = path.length, lastIndex = length - 1, nested = object;\n                    while(nested != null && ++index < length){\n                        var key = toKey(path[index]), newValue = value;\n                        if (key === \"__proto__\" || key === \"constructor\" || key === \"prototype\") {\n                            return object;\n                        }\n                        if (index != lastIndex) {\n                            var objValue = nested[key];\n                            newValue = customizer ? customizer(objValue, key, nested) : undefined2;\n                            if (newValue === undefined2) {\n                                newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};\n                            }\n                        }\n                        assignValue(nested, key, newValue);\n                        nested = nested[key];\n                    }\n                    return object;\n                }\n                var baseSetData = !metaMap ? identity : function(func, data) {\n                    metaMap.set(func, data);\n                    return func;\n                };\n                var baseSetToString = !defineProperty ? identity : function(func, string) {\n                    return defineProperty(func, \"toString\", {\n                        \"configurable\": true,\n                        \"enumerable\": false,\n                        \"value\": constant(string),\n                        \"writable\": true\n                    });\n                };\n                function baseShuffle(collection) {\n                    return shuffleSelf(values(collection));\n                }\n                function baseSlice(array, start, end) {\n                    var index = -1, length = array.length;\n                    if (start < 0) {\n                        start = -start > length ? 0 : length + start;\n                    }\n                    end = end > length ? length : end;\n                    if (end < 0) {\n                        end += length;\n                    }\n                    length = start > end ? 0 : end - start >>> 0;\n                    start >>>= 0;\n                    var result2 = Array2(length);\n                    while(++index < length){\n                        result2[index] = array[index + start];\n                    }\n                    return result2;\n                }\n                function baseSome(collection, predicate) {\n                    var result2;\n                    baseEach(collection, function(value, index, collection2) {\n                        result2 = predicate(value, index, collection2);\n                        return !result2;\n                    });\n                    return !!result2;\n                }\n                function baseSortedIndex(array, value, retHighest) {\n                    var low = 0, high = array == null ? low : array.length;\n                    if (typeof value == \"number\" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {\n                        while(low < high){\n                            var mid = low + high >>> 1, computed = array[mid];\n                            if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {\n                                low = mid + 1;\n                            } else {\n                                high = mid;\n                            }\n                        }\n                        return high;\n                    }\n                    return baseSortedIndexBy(array, value, identity, retHighest);\n                }\n                function baseSortedIndexBy(array, value, iteratee2, retHighest) {\n                    var low = 0, high = array == null ? 0 : array.length;\n                    if (high === 0) {\n                        return 0;\n                    }\n                    value = iteratee2(value);\n                    var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;\n                    while(low < high){\n                        var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);\n                        if (valIsNaN) {\n                            var setLow = retHighest || othIsReflexive;\n                        } else if (valIsUndefined) {\n                            setLow = othIsReflexive && (retHighest || othIsDefined);\n                        } else if (valIsNull) {\n                            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);\n                        } else if (valIsSymbol) {\n                            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);\n                        } else if (othIsNull || othIsSymbol) {\n                            setLow = false;\n                        } else {\n                            setLow = retHighest ? computed <= value : computed < value;\n                        }\n                        if (setLow) {\n                            low = mid + 1;\n                        } else {\n                            high = mid;\n                        }\n                    }\n                    return nativeMin(high, MAX_ARRAY_INDEX);\n                }\n                function baseSortedUniq(array, iteratee2) {\n                    var index = -1, length = array.length, resIndex = 0, result2 = [];\n                    while(++index < length){\n                        var value = array[index], computed = iteratee2 ? iteratee2(value) : value;\n                        if (!index || !eq(computed, seen)) {\n                            var seen = computed;\n                            result2[resIndex++] = value === 0 ? 0 : value;\n                        }\n                    }\n                    return result2;\n                }\n                function baseToNumber(value) {\n                    if (typeof value == \"number\") {\n                        return value;\n                    }\n                    if (isSymbol(value)) {\n                        return NAN;\n                    }\n                    return +value;\n                }\n                function baseToString(value) {\n                    if (typeof value == \"string\") {\n                        return value;\n                    }\n                    if (isArray(value)) {\n                        return arrayMap(value, baseToString) + \"\";\n                    }\n                    if (isSymbol(value)) {\n                        return symbolToString ? symbolToString.call(value) : \"\";\n                    }\n                    var result2 = value + \"\";\n                    return result2 == \"0\" && 1 / value == -INFINITY ? \"-0\" : result2;\n                }\n                function baseUniq(array, iteratee2, comparator) {\n                    var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;\n                    if (comparator) {\n                        isCommon = false;\n                        includes2 = arrayIncludesWith;\n                    } else if (length >= LARGE_ARRAY_SIZE) {\n                        var set2 = iteratee2 ? null : createSet(array);\n                        if (set2) {\n                            return setToArray(set2);\n                        }\n                        isCommon = false;\n                        includes2 = cacheHas;\n                        seen = new SetCache();\n                    } else {\n                        seen = iteratee2 ? [] : result2;\n                    }\n                    outer: while(++index < length){\n                        var value = array[index], computed = iteratee2 ? iteratee2(value) : value;\n                        value = comparator || value !== 0 ? value : 0;\n                        if (isCommon && computed === computed) {\n                            var seenIndex = seen.length;\n                            while(seenIndex--){\n                                if (seen[seenIndex] === computed) {\n                                    continue outer;\n                                }\n                            }\n                            if (iteratee2) {\n                                seen.push(computed);\n                            }\n                            result2.push(value);\n                        } else if (!includes2(seen, computed, comparator)) {\n                            if (seen !== result2) {\n                                seen.push(computed);\n                            }\n                            result2.push(value);\n                        }\n                    }\n                    return result2;\n                }\n                function baseUnset(object, path) {\n                    path = castPath(path, object);\n                    object = parent(object, path);\n                    return object == null || delete object[toKey(last(path))];\n                }\n                function baseUpdate(object, path, updater, customizer) {\n                    return baseSet(object, path, updater(baseGet(object, path)), customizer);\n                }\n                function baseWhile(array, predicate, isDrop, fromRight) {\n                    var length = array.length, index = fromRight ? length : -1;\n                    while((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)){}\n                    return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);\n                }\n                function baseWrapperValue(value, actions) {\n                    var result2 = value;\n                    if (result2 instanceof LazyWrapper) {\n                        result2 = result2.value();\n                    }\n                    return arrayReduce(actions, function(result3, action) {\n                        return action.func.apply(action.thisArg, arrayPush([\n                            result3\n                        ], action.args));\n                    }, result2);\n                }\n                function baseXor(arrays, iteratee2, comparator) {\n                    var length = arrays.length;\n                    if (length < 2) {\n                        return length ? baseUniq(arrays[0]) : [];\n                    }\n                    var index = -1, result2 = Array2(length);\n                    while(++index < length){\n                        var array = arrays[index], othIndex = -1;\n                        while(++othIndex < length){\n                            if (othIndex != index) {\n                                result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);\n                            }\n                        }\n                    }\n                    return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);\n                }\n                function baseZipObject(props, values2, assignFunc) {\n                    var index = -1, length = props.length, valsLength = values2.length, result2 = {};\n                    while(++index < length){\n                        var value = index < valsLength ? values2[index] : undefined2;\n                        assignFunc(result2, props[index], value);\n                    }\n                    return result2;\n                }\n                function castArrayLikeObject(value) {\n                    return isArrayLikeObject(value) ? value : [];\n                }\n                function castFunction(value) {\n                    return typeof value == \"function\" ? value : identity;\n                }\n                function castPath(value, object) {\n                    if (isArray(value)) {\n                        return value;\n                    }\n                    return isKey(value, object) ? [\n                        value\n                    ] : stringToPath(toString(value));\n                }\n                var castRest = baseRest;\n                function castSlice(array, start, end) {\n                    var length = array.length;\n                    end = end === undefined2 ? length : end;\n                    return !start && end >= length ? array : baseSlice(array, start, end);\n                }\n                var clearTimeout = ctxClearTimeout || function(id) {\n                    return root.clearTimeout(id);\n                };\n                function cloneBuffer(buffer, isDeep) {\n                    if (isDeep) {\n                        return buffer.slice();\n                    }\n                    var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n                    buffer.copy(result2);\n                    return result2;\n                }\n                function cloneArrayBuffer(arrayBuffer) {\n                    var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);\n                    new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));\n                    return result2;\n                }\n                function cloneDataView(dataView, isDeep) {\n                    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n                    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n                }\n                function cloneRegExp(regexp) {\n                    var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n                    result2.lastIndex = regexp.lastIndex;\n                    return result2;\n                }\n                function cloneSymbol(symbol) {\n                    return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};\n                }\n                function cloneTypedArray(typedArray, isDeep) {\n                    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n                    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n                }\n                function compareAscending(value, other) {\n                    if (value !== other) {\n                        var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);\n                        var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);\n                        if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {\n                            return 1;\n                        }\n                        if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {\n                            return -1;\n                        }\n                    }\n                    return 0;\n                }\n                function compareMultiple(object, other, orders) {\n                    var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;\n                    while(++index < length){\n                        var result2 = compareAscending(objCriteria[index], othCriteria[index]);\n                        if (result2) {\n                            if (index >= ordersLength) {\n                                return result2;\n                            }\n                            var order = orders[index];\n                            return result2 * (order == \"desc\" ? -1 : 1);\n                        }\n                    }\n                    return object.index - other.index;\n                }\n                function composeArgs(args, partials, holders, isCurried) {\n                    var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;\n                    while(++leftIndex < leftLength){\n                        result2[leftIndex] = partials[leftIndex];\n                    }\n                    while(++argsIndex < holdersLength){\n                        if (isUncurried || argsIndex < argsLength) {\n                            result2[holders[argsIndex]] = args[argsIndex];\n                        }\n                    }\n                    while(rangeLength--){\n                        result2[leftIndex++] = args[argsIndex++];\n                    }\n                    return result2;\n                }\n                function composeArgsRight(args, partials, holders, isCurried) {\n                    var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;\n                    while(++argsIndex < rangeLength){\n                        result2[argsIndex] = args[argsIndex];\n                    }\n                    var offset = argsIndex;\n                    while(++rightIndex < rightLength){\n                        result2[offset + rightIndex] = partials[rightIndex];\n                    }\n                    while(++holdersIndex < holdersLength){\n                        if (isUncurried || argsIndex < argsLength) {\n                            result2[offset + holders[holdersIndex]] = args[argsIndex++];\n                        }\n                    }\n                    return result2;\n                }\n                function copyArray(source, array) {\n                    var index = -1, length = source.length;\n                    array || (array = Array2(length));\n                    while(++index < length){\n                        array[index] = source[index];\n                    }\n                    return array;\n                }\n                function copyObject(source, props, object, customizer) {\n                    var isNew = !object;\n                    object || (object = {});\n                    var index = -1, length = props.length;\n                    while(++index < length){\n                        var key = props[index];\n                        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;\n                        if (newValue === undefined2) {\n                            newValue = source[key];\n                        }\n                        if (isNew) {\n                            baseAssignValue(object, key, newValue);\n                        } else {\n                            assignValue(object, key, newValue);\n                        }\n                    }\n                    return object;\n                }\n                function copySymbols(source, object) {\n                    return copyObject(source, getSymbols(source), object);\n                }\n                function copySymbolsIn(source, object) {\n                    return copyObject(source, getSymbolsIn(source), object);\n                }\n                function createAggregator(setter, initializer) {\n                    return function(collection, iteratee2) {\n                        var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};\n                        return func(collection, setter, getIteratee(iteratee2, 2), accumulator);\n                    };\n                }\n                function createAssigner(assigner) {\n                    return baseRest(function(object, sources) {\n                        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;\n                        customizer = assigner.length > 3 && typeof customizer == \"function\" ? (length--, customizer) : undefined2;\n                        if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n                            customizer = length < 3 ? undefined2 : customizer;\n                            length = 1;\n                        }\n                        object = Object2(object);\n                        while(++index < length){\n                            var source = sources[index];\n                            if (source) {\n                                assigner(object, source, index, customizer);\n                            }\n                        }\n                        return object;\n                    });\n                }\n                function createBaseEach(eachFunc, fromRight) {\n                    return function(collection, iteratee2) {\n                        if (collection == null) {\n                            return collection;\n                        }\n                        if (!isArrayLike(collection)) {\n                            return eachFunc(collection, iteratee2);\n                        }\n                        var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);\n                        while(fromRight ? index-- : ++index < length){\n                            if (iteratee2(iterable[index], index, iterable) === false) {\n                                break;\n                            }\n                        }\n                        return collection;\n                    };\n                }\n                function createBaseFor(fromRight) {\n                    return function(object, iteratee2, keysFunc) {\n                        var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;\n                        while(length--){\n                            var key = props[fromRight ? length : ++index];\n                            if (iteratee2(iterable[key], key, iterable) === false) {\n                                break;\n                            }\n                        }\n                        return object;\n                    };\n                }\n                function createBind(func, bitmask, thisArg) {\n                    var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);\n                    function wrapper() {\n                        var fn = this && this !== root && this instanceof wrapper ? Ctor : func;\n                        return fn.apply(isBind ? thisArg : this, arguments);\n                    }\n                    return wrapper;\n                }\n                function createCaseFirst(methodName) {\n                    return function(string) {\n                        string = toString(string);\n                        var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;\n                        var chr = strSymbols ? strSymbols[0] : string.charAt(0);\n                        var trailing = strSymbols ? castSlice(strSymbols, 1).join(\"\") : string.slice(1);\n                        return chr[methodName]() + trailing;\n                    };\n                }\n                function createCompounder(callback) {\n                    return function(string) {\n                        return arrayReduce(words(deburr(string).replace(reApos, \"\")), callback, \"\");\n                    };\n                }\n                function createCtor(Ctor) {\n                    return function() {\n                        var args = arguments;\n                        switch(args.length){\n                            case 0:\n                                return new Ctor();\n                            case 1:\n                                return new Ctor(args[0]);\n                            case 2:\n                                return new Ctor(args[0], args[1]);\n                            case 3:\n                                return new Ctor(args[0], args[1], args[2]);\n                            case 4:\n                                return new Ctor(args[0], args[1], args[2], args[3]);\n                            case 5:\n                                return new Ctor(args[0], args[1], args[2], args[3], args[4]);\n                            case 6:\n                                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);\n                            case 7:\n                                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);\n                        }\n                        var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);\n                        return isObject(result2) ? result2 : thisBinding;\n                    };\n                }\n                function createCurry(func, bitmask, arity) {\n                    var Ctor = createCtor(func);\n                    function wrapper() {\n                        var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);\n                        while(index--){\n                            args[index] = arguments[index];\n                        }\n                        var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);\n                        length -= holders.length;\n                        if (length < arity) {\n                            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined2, args, holders, undefined2, undefined2, arity - length);\n                        }\n                        var fn = this && this !== root && this instanceof wrapper ? Ctor : func;\n                        return apply(fn, this, args);\n                    }\n                    return wrapper;\n                }\n                function createFind(findIndexFunc) {\n                    return function(collection, predicate, fromIndex) {\n                        var iterable = Object2(collection);\n                        if (!isArrayLike(collection)) {\n                            var iteratee2 = getIteratee(predicate, 3);\n                            collection = keys(collection);\n                            predicate = function(key) {\n                                return iteratee2(iterable[key], key, iterable);\n                            };\n                        }\n                        var index = findIndexFunc(collection, predicate, fromIndex);\n                        return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;\n                    };\n                }\n                function createFlow(fromRight) {\n                    return flatRest(function(funcs) {\n                        var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;\n                        if (fromRight) {\n                            funcs.reverse();\n                        }\n                        while(index--){\n                            var func = funcs[index];\n                            if (typeof func != \"function\") {\n                                throw new TypeError2(FUNC_ERROR_TEXT);\n                            }\n                            if (prereq && !wrapper && getFuncName(func) == \"wrapper\") {\n                                var wrapper = new LodashWrapper([], true);\n                            }\n                        }\n                        index = wrapper ? index : length;\n                        while(++index < length){\n                            func = funcs[index];\n                            var funcName = getFuncName(func), data = funcName == \"wrapper\" ? getData(func) : undefined2;\n                            if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {\n                                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);\n                            } else {\n                                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);\n                            }\n                        }\n                        return function() {\n                            var args = arguments, value = args[0];\n                            if (wrapper && args.length == 1 && isArray(value)) {\n                                return wrapper.plant(value).value();\n                            }\n                            var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;\n                            while(++index2 < length){\n                                result2 = funcs[index2].call(this, result2);\n                            }\n                            return result2;\n                        };\n                    });\n                }\n                function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {\n                    var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);\n                    function wrapper() {\n                        var length = arguments.length, args = Array2(length), index = length;\n                        while(index--){\n                            args[index] = arguments[index];\n                        }\n                        if (isCurried) {\n                            var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);\n                        }\n                        if (partials) {\n                            args = composeArgs(args, partials, holders, isCurried);\n                        }\n                        if (partialsRight) {\n                            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);\n                        }\n                        length -= holdersCount;\n                        if (isCurried && length < arity) {\n                            var newHolders = replaceHolders(args, placeholder);\n                            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary2, arity - length);\n                        }\n                        var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;\n                        length = args.length;\n                        if (argPos) {\n                            args = reorder(args, argPos);\n                        } else if (isFlip && length > 1) {\n                            args.reverse();\n                        }\n                        if (isAry && ary2 < length) {\n                            args.length = ary2;\n                        }\n                        if (this && this !== root && this instanceof wrapper) {\n                            fn = Ctor || createCtor(fn);\n                        }\n                        return fn.apply(thisBinding, args);\n                    }\n                    return wrapper;\n                }\n                function createInverter(setter, toIteratee) {\n                    return function(object, iteratee2) {\n                        return baseInverter(object, setter, toIteratee(iteratee2), {});\n                    };\n                }\n                function createMathOperation(operator, defaultValue) {\n                    return function(value, other) {\n                        var result2;\n                        if (value === undefined2 && other === undefined2) {\n                            return defaultValue;\n                        }\n                        if (value !== undefined2) {\n                            result2 = value;\n                        }\n                        if (other !== undefined2) {\n                            if (result2 === undefined2) {\n                                return other;\n                            }\n                            if (typeof value == \"string\" || typeof other == \"string\") {\n                                value = baseToString(value);\n                                other = baseToString(other);\n                            } else {\n                                value = baseToNumber(value);\n                                other = baseToNumber(other);\n                            }\n                            result2 = operator(value, other);\n                        }\n                        return result2;\n                    };\n                }\n                function createOver(arrayFunc) {\n                    return flatRest(function(iteratees) {\n                        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));\n                        return baseRest(function(args) {\n                            var thisArg = this;\n                            return arrayFunc(iteratees, function(iteratee2) {\n                                return apply(iteratee2, thisArg, args);\n                            });\n                        });\n                    });\n                }\n                function createPadding(length, chars) {\n                    chars = chars === undefined2 ? \" \" : baseToString(chars);\n                    var charsLength = chars.length;\n                    if (charsLength < 2) {\n                        return charsLength ? baseRepeat(chars, length) : chars;\n                    }\n                    var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));\n                    return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join(\"\") : result2.slice(0, length);\n                }\n                function createPartial(func, bitmask, thisArg, partials) {\n                    var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);\n                    function wrapper() {\n                        var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;\n                        while(++leftIndex < leftLength){\n                            args[leftIndex] = partials[leftIndex];\n                        }\n                        while(argsLength--){\n                            args[leftIndex++] = arguments[++argsIndex];\n                        }\n                        return apply(fn, isBind ? thisArg : this, args);\n                    }\n                    return wrapper;\n                }\n                function createRange(fromRight) {\n                    return function(start, end, step) {\n                        if (step && typeof step != \"number\" && isIterateeCall(start, end, step)) {\n                            end = step = undefined2;\n                        }\n                        start = toFinite(start);\n                        if (end === undefined2) {\n                            end = start;\n                            start = 0;\n                        } else {\n                            end = toFinite(end);\n                        }\n                        step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);\n                        return baseRange(start, end, step, fromRight);\n                    };\n                }\n                function createRelationalOperation(operator) {\n                    return function(value, other) {\n                        if (!(typeof value == \"string\" && typeof other == \"string\")) {\n                            value = toNumber(value);\n                            other = toNumber(other);\n                        }\n                        return operator(value, other);\n                    };\n                }\n                function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {\n                    var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;\n                    bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;\n                    bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);\n                    if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {\n                        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);\n                    }\n                    var newData = [\n                        func,\n                        bitmask,\n                        thisArg,\n                        newPartials,\n                        newHolders,\n                        newPartialsRight,\n                        newHoldersRight,\n                        argPos,\n                        ary2,\n                        arity\n                    ];\n                    var result2 = wrapFunc.apply(undefined2, newData);\n                    if (isLaziable(func)) {\n                        setData(result2, newData);\n                    }\n                    result2.placeholder = placeholder;\n                    return setWrapToString(result2, func, bitmask);\n                }\n                function createRound(methodName) {\n                    var func = Math2[methodName];\n                    return function(number, precision) {\n                        number = toNumber(number);\n                        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);\n                        if (precision && nativeIsFinite(number)) {\n                            var pair = (toString(number) + \"e\").split(\"e\"), value = func(pair[0] + \"e\" + (+pair[1] + precision));\n                            pair = (toString(value) + \"e\").split(\"e\");\n                            return +(pair[0] + \"e\" + (+pair[1] - precision));\n                        }\n                        return func(number);\n                    };\n                }\n                var createSet = !(Set2 && 1 / setToArray(new Set2([\n                    ,\n                    -0\n                ]))[1] == INFINITY) ? noop : function(values2) {\n                    return new Set2(values2);\n                };\n                function createToPairs(keysFunc) {\n                    return function(object) {\n                        var tag = getTag(object);\n                        if (tag == mapTag) {\n                            return mapToArray(object);\n                        }\n                        if (tag == setTag) {\n                            return setToPairs(object);\n                        }\n                        return baseToPairs(object, keysFunc(object));\n                    };\n                }\n                function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {\n                    var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;\n                    if (!isBindKey && typeof func != \"function\") {\n                        throw new TypeError2(FUNC_ERROR_TEXT);\n                    }\n                    var length = partials ? partials.length : 0;\n                    if (!length) {\n                        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);\n                        partials = holders = undefined2;\n                    }\n                    ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);\n                    arity = arity === undefined2 ? arity : toInteger(arity);\n                    length -= holders ? holders.length : 0;\n                    if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {\n                        var partialsRight = partials, holdersRight = holders;\n                        partials = holders = undefined2;\n                    }\n                    var data = isBindKey ? undefined2 : getData(func);\n                    var newData = [\n                        func,\n                        bitmask,\n                        thisArg,\n                        partials,\n                        holders,\n                        partialsRight,\n                        holdersRight,\n                        argPos,\n                        ary2,\n                        arity\n                    ];\n                    if (data) {\n                        mergeData(newData, data);\n                    }\n                    func = newData[0];\n                    bitmask = newData[1];\n                    thisArg = newData[2];\n                    partials = newData[3];\n                    holders = newData[4];\n                    arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);\n                    if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {\n                        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);\n                    }\n                    if (!bitmask || bitmask == WRAP_BIND_FLAG) {\n                        var result2 = createBind(func, bitmask, thisArg);\n                    } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {\n                        result2 = createCurry(func, bitmask, arity);\n                    } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {\n                        result2 = createPartial(func, bitmask, thisArg, partials);\n                    } else {\n                        result2 = createHybrid.apply(undefined2, newData);\n                    }\n                    var setter = data ? baseSetData : setData;\n                    return setWrapToString(setter(result2, newData), func, bitmask);\n                }\n                function customDefaultsAssignIn(objValue, srcValue, key, object) {\n                    if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {\n                        return srcValue;\n                    }\n                    return objValue;\n                }\n                function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {\n                    if (isObject(objValue) && isObject(srcValue)) {\n                        stack.set(srcValue, objValue);\n                        baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);\n                        stack[\"delete\"](srcValue);\n                    }\n                    return objValue;\n                }\n                function customOmitClone(value) {\n                    return isPlainObject(value) ? undefined2 : value;\n                }\n                function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n                    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;\n                    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n                        return false;\n                    }\n                    var arrStacked = stack.get(array);\n                    var othStacked = stack.get(other);\n                    if (arrStacked && othStacked) {\n                        return arrStacked == other && othStacked == array;\n                    }\n                    var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;\n                    stack.set(array, other);\n                    stack.set(other, array);\n                    while(++index < arrLength){\n                        var arrValue = array[index], othValue = other[index];\n                        if (customizer) {\n                            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);\n                        }\n                        if (compared !== undefined2) {\n                            if (compared) {\n                                continue;\n                            }\n                            result2 = false;\n                            break;\n                        }\n                        if (seen) {\n                            if (!arraySome(other, function(othValue2, othIndex) {\n                                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {\n                                    return seen.push(othIndex);\n                                }\n                            })) {\n                                result2 = false;\n                                break;\n                            }\n                        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n                            result2 = false;\n                            break;\n                        }\n                    }\n                    stack[\"delete\"](array);\n                    stack[\"delete\"](other);\n                    return result2;\n                }\n                function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n                    switch(tag){\n                        case dataViewTag:\n                            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {\n                                return false;\n                            }\n                            object = object.buffer;\n                            other = other.buffer;\n                        case arrayBufferTag:\n                            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {\n                                return false;\n                            }\n                            return true;\n                        case boolTag:\n                        case dateTag:\n                        case numberTag:\n                            return eq(+object, +other);\n                        case errorTag:\n                            return object.name == other.name && object.message == other.message;\n                        case regexpTag:\n                        case stringTag:\n                            return object == other + \"\";\n                        case mapTag:\n                            var convert = mapToArray;\n                        case setTag:\n                            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n                            convert || (convert = setToArray);\n                            if (object.size != other.size && !isPartial) {\n                                return false;\n                            }\n                            var stacked = stack.get(object);\n                            if (stacked) {\n                                return stacked == other;\n                            }\n                            bitmask |= COMPARE_UNORDERED_FLAG;\n                            stack.set(object, other);\n                            var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n                            stack[\"delete\"](object);\n                            return result2;\n                        case symbolTag:\n                            if (symbolValueOf) {\n                                return symbolValueOf.call(object) == symbolValueOf.call(other);\n                            }\n                    }\n                    return false;\n                }\n                function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n                    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;\n                    if (objLength != othLength && !isPartial) {\n                        return false;\n                    }\n                    var index = objLength;\n                    while(index--){\n                        var key = objProps[index];\n                        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n                            return false;\n                        }\n                    }\n                    var objStacked = stack.get(object);\n                    var othStacked = stack.get(other);\n                    if (objStacked && othStacked) {\n                        return objStacked == other && othStacked == object;\n                    }\n                    var result2 = true;\n                    stack.set(object, other);\n                    stack.set(other, object);\n                    var skipCtor = isPartial;\n                    while(++index < objLength){\n                        key = objProps[index];\n                        var objValue = object[key], othValue = other[key];\n                        if (customizer) {\n                            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);\n                        }\n                        if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {\n                            result2 = false;\n                            break;\n                        }\n                        skipCtor || (skipCtor = key == \"constructor\");\n                    }\n                    if (result2 && !skipCtor) {\n                        var objCtor = object.constructor, othCtor = other.constructor;\n                        if (objCtor != othCtor && \"constructor\" in object && \"constructor\" in other && !(typeof objCtor == \"function\" && objCtor instanceof objCtor && typeof othCtor == \"function\" && othCtor instanceof othCtor)) {\n                            result2 = false;\n                        }\n                    }\n                    stack[\"delete\"](object);\n                    stack[\"delete\"](other);\n                    return result2;\n                }\n                function flatRest(func) {\n                    return setToString(overRest(func, undefined2, flatten), func + \"\");\n                }\n                function getAllKeys(object) {\n                    return baseGetAllKeys(object, keys, getSymbols);\n                }\n                function getAllKeysIn(object) {\n                    return baseGetAllKeys(object, keysIn, getSymbolsIn);\n                }\n                var getData = !metaMap ? noop : function(func) {\n                    return metaMap.get(func);\n                };\n                function getFuncName(func) {\n                    var result2 = func.name + \"\", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;\n                    while(length--){\n                        var data = array[length], otherFunc = data.func;\n                        if (otherFunc == null || otherFunc == func) {\n                            return data.name;\n                        }\n                    }\n                    return result2;\n                }\n                function getHolder(func) {\n                    var object = hasOwnProperty.call(lodash, \"placeholder\") ? lodash : func;\n                    return object.placeholder;\n                }\n                function getIteratee() {\n                    var result2 = lodash.iteratee || iteratee;\n                    result2 = result2 === iteratee ? baseIteratee : result2;\n                    return arguments.length ? result2(arguments[0], arguments[1]) : result2;\n                }\n                function getMapData(map2, key) {\n                    var data = map2.__data__;\n                    return isKeyable(key) ? data[typeof key == \"string\" ? \"string\" : \"hash\"] : data.map;\n                }\n                function getMatchData(object) {\n                    var result2 = keys(object), length = result2.length;\n                    while(length--){\n                        var key = result2[length], value = object[key];\n                        result2[length] = [\n                            key,\n                            value,\n                            isStrictComparable(value)\n                        ];\n                    }\n                    return result2;\n                }\n                function getNative(object, key) {\n                    var value = getValue(object, key);\n                    return baseIsNative(value) ? value : undefined2;\n                }\n                function getRawTag(value) {\n                    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];\n                    try {\n                        value[symToStringTag] = undefined2;\n                        var unmasked = true;\n                    } catch (e) {}\n                    var result2 = nativeObjectToString.call(value);\n                    if (unmasked) {\n                        if (isOwn) {\n                            value[symToStringTag] = tag;\n                        } else {\n                            delete value[symToStringTag];\n                        }\n                    }\n                    return result2;\n                }\n                var getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n                    if (object == null) {\n                        return [];\n                    }\n                    object = Object2(object);\n                    return arrayFilter(nativeGetSymbols(object), function(symbol) {\n                        return propertyIsEnumerable.call(object, symbol);\n                    });\n                };\n                var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\n                    var result2 = [];\n                    while(object){\n                        arrayPush(result2, getSymbols(object));\n                        object = getPrototype(object);\n                    }\n                    return result2;\n                };\n                var getTag = baseGetTag;\n                if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {\n                    getTag = function(value) {\n                        var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : \"\";\n                        if (ctorString) {\n                            switch(ctorString){\n                                case dataViewCtorString:\n                                    return dataViewTag;\n                                case mapCtorString:\n                                    return mapTag;\n                                case promiseCtorString:\n                                    return promiseTag;\n                                case setCtorString:\n                                    return setTag;\n                                case weakMapCtorString:\n                                    return weakMapTag;\n                            }\n                        }\n                        return result2;\n                    };\n                }\n                function getView(start, end, transforms) {\n                    var index = -1, length = transforms.length;\n                    while(++index < length){\n                        var data = transforms[index], size2 = data.size;\n                        switch(data.type){\n                            case \"drop\":\n                                start += size2;\n                                break;\n                            case \"dropRight\":\n                                end -= size2;\n                                break;\n                            case \"take\":\n                                end = nativeMin(end, start + size2);\n                                break;\n                            case \"takeRight\":\n                                start = nativeMax(start, end - size2);\n                                break;\n                        }\n                    }\n                    return {\n                        \"start\": start,\n                        \"end\": end\n                    };\n                }\n                function getWrapDetails(source) {\n                    var match = source.match(reWrapDetails);\n                    return match ? match[1].split(reSplitDetails) : [];\n                }\n                function hasPath(object, path, hasFunc) {\n                    path = castPath(path, object);\n                    var index = -1, length = path.length, result2 = false;\n                    while(++index < length){\n                        var key = toKey(path[index]);\n                        if (!(result2 = object != null && hasFunc(object, key))) {\n                            break;\n                        }\n                        object = object[key];\n                    }\n                    if (result2 || ++index != length) {\n                        return result2;\n                    }\n                    length = object == null ? 0 : object.length;\n                    return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));\n                }\n                function initCloneArray(array) {\n                    var length = array.length, result2 = new array.constructor(length);\n                    if (length && typeof array[0] == \"string\" && hasOwnProperty.call(array, \"index\")) {\n                        result2.index = array.index;\n                        result2.input = array.input;\n                    }\n                    return result2;\n                }\n                function initCloneObject(object) {\n                    return typeof object.constructor == \"function\" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};\n                }\n                function initCloneByTag(object, tag, isDeep) {\n                    var Ctor = object.constructor;\n                    switch(tag){\n                        case arrayBufferTag:\n                            return cloneArrayBuffer(object);\n                        case boolTag:\n                        case dateTag:\n                            return new Ctor(+object);\n                        case dataViewTag:\n                            return cloneDataView(object, isDeep);\n                        case float32Tag:\n                        case float64Tag:\n                        case int8Tag:\n                        case int16Tag:\n                        case int32Tag:\n                        case uint8Tag:\n                        case uint8ClampedTag:\n                        case uint16Tag:\n                        case uint32Tag:\n                            return cloneTypedArray(object, isDeep);\n                        case mapTag:\n                            return new Ctor();\n                        case numberTag:\n                        case stringTag:\n                            return new Ctor(object);\n                        case regexpTag:\n                            return cloneRegExp(object);\n                        case setTag:\n                            return new Ctor();\n                        case symbolTag:\n                            return cloneSymbol(object);\n                    }\n                }\n                function insertWrapDetails(source, details) {\n                    var length = details.length;\n                    if (!length) {\n                        return source;\n                    }\n                    var lastIndex = length - 1;\n                    details[lastIndex] = (length > 1 ? \"& \" : \"\") + details[lastIndex];\n                    details = details.join(length > 2 ? \", \" : \" \");\n                    return source.replace(reWrapComment, \"{\\n/* [wrapped with \" + details + \"] */\\n\");\n                }\n                function isFlattenable(value) {\n                    return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);\n                }\n                function isIndex(value, length) {\n                    var type = typeof value;\n                    length = length == null ? MAX_SAFE_INTEGER : length;\n                    return !!length && (type == \"number\" || type != \"symbol\" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;\n                }\n                function isIterateeCall(value, index, object) {\n                    if (!isObject(object)) {\n                        return false;\n                    }\n                    var type = typeof index;\n                    if (type == \"number\" ? isArrayLike(object) && isIndex(index, object.length) : type == \"string\" && index in object) {\n                        return eq(object[index], value);\n                    }\n                    return false;\n                }\n                function isKey(value, object) {\n                    if (isArray(value)) {\n                        return false;\n                    }\n                    var type = typeof value;\n                    if (type == \"number\" || type == \"symbol\" || type == \"boolean\" || value == null || isSymbol(value)) {\n                        return true;\n                    }\n                    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);\n                }\n                function isKeyable(value) {\n                    var type = typeof value;\n                    return type == \"string\" || type == \"number\" || type == \"symbol\" || type == \"boolean\" ? value !== \"__proto__\" : value === null;\n                }\n                function isLaziable(func) {\n                    var funcName = getFuncName(func), other = lodash[funcName];\n                    if (typeof other != \"function\" || !(funcName in LazyWrapper.prototype)) {\n                        return false;\n                    }\n                    if (func === other) {\n                        return true;\n                    }\n                    var data = getData(other);\n                    return !!data && func === data[0];\n                }\n                function isMasked(func) {\n                    return !!maskSrcKey && maskSrcKey in func;\n                }\n                var isMaskable = coreJsData ? isFunction : stubFalse;\n                function isPrototype(value) {\n                    var Ctor = value && value.constructor, proto = typeof Ctor == \"function\" && Ctor.prototype || objectProto;\n                    return value === proto;\n                }\n                function isStrictComparable(value) {\n                    return value === value && !isObject(value);\n                }\n                function matchesStrictComparable(key, srcValue) {\n                    return function(object) {\n                        if (object == null) {\n                            return false;\n                        }\n                        return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));\n                    };\n                }\n                function memoizeCapped(func) {\n                    var result2 = memoize2(func, function(key) {\n                        if (cache.size === MAX_MEMOIZE_SIZE) {\n                            cache.clear();\n                        }\n                        return key;\n                    });\n                    var cache = result2.cache;\n                    return result2;\n                }\n                function mergeData(data, source) {\n                    var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);\n                    var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;\n                    if (!(isCommon || isCombo)) {\n                        return data;\n                    }\n                    if (srcBitmask & WRAP_BIND_FLAG) {\n                        data[2] = source[2];\n                        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;\n                    }\n                    var value = source[3];\n                    if (value) {\n                        var partials = data[3];\n                        data[3] = partials ? composeArgs(partials, value, source[4]) : value;\n                        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];\n                    }\n                    value = source[5];\n                    if (value) {\n                        partials = data[5];\n                        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;\n                        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];\n                    }\n                    value = source[7];\n                    if (value) {\n                        data[7] = value;\n                    }\n                    if (srcBitmask & WRAP_ARY_FLAG) {\n                        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);\n                    }\n                    if (data[9] == null) {\n                        data[9] = source[9];\n                    }\n                    data[0] = source[0];\n                    data[1] = newBitmask;\n                    return data;\n                }\n                function nativeKeysIn(object) {\n                    var result2 = [];\n                    if (object != null) {\n                        for(var key in Object2(object)){\n                            result2.push(key);\n                        }\n                    }\n                    return result2;\n                }\n                function objectToString(value) {\n                    return nativeObjectToString.call(value);\n                }\n                function overRest(func, start, transform2) {\n                    start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);\n                    return function() {\n                        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);\n                        while(++index < length){\n                            array[index] = args[start + index];\n                        }\n                        index = -1;\n                        var otherArgs = Array2(start + 1);\n                        while(++index < start){\n                            otherArgs[index] = args[index];\n                        }\n                        otherArgs[start] = transform2(array);\n                        return apply(func, this, otherArgs);\n                    };\n                }\n                function parent(object, path) {\n                    return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));\n                }\n                function reorder(array, indexes) {\n                    var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);\n                    while(length--){\n                        var index = indexes[length];\n                        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;\n                    }\n                    return array;\n                }\n                function safeGet(object, key) {\n                    if (key === \"constructor\" && typeof object[key] === \"function\") {\n                        return;\n                    }\n                    if (key == \"__proto__\") {\n                        return;\n                    }\n                    return object[key];\n                }\n                var setData = shortOut(baseSetData);\n                var setTimeout = ctxSetTimeout || function(func, wait) {\n                    return root.setTimeout(func, wait);\n                };\n                var setToString = shortOut(baseSetToString);\n                function setWrapToString(wrapper, reference, bitmask) {\n                    var source = reference + \"\";\n                    return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));\n                }\n                function shortOut(func) {\n                    var count = 0, lastCalled = 0;\n                    return function() {\n                        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);\n                        lastCalled = stamp;\n                        if (remaining > 0) {\n                            if (++count >= HOT_COUNT) {\n                                return arguments[0];\n                            }\n                        } else {\n                            count = 0;\n                        }\n                        return func.apply(undefined2, arguments);\n                    };\n                }\n                function shuffleSelf(array, size2) {\n                    var index = -1, length = array.length, lastIndex = length - 1;\n                    size2 = size2 === undefined2 ? length : size2;\n                    while(++index < size2){\n                        var rand = baseRandom(index, lastIndex), value = array[rand];\n                        array[rand] = array[index];\n                        array[index] = value;\n                    }\n                    array.length = size2;\n                    return array;\n                }\n                var stringToPath = memoizeCapped(function(string) {\n                    var result2 = [];\n                    if (string.charCodeAt(0) === 46) {\n                        result2.push(\"\");\n                    }\n                    string.replace(rePropName, function(match, number, quote, subString) {\n                        result2.push(quote ? subString.replace(reEscapeChar, \"$1\") : number || match);\n                    });\n                    return result2;\n                });\n                function toKey(value) {\n                    if (typeof value == \"string\" || isSymbol(value)) {\n                        return value;\n                    }\n                    var result2 = value + \"\";\n                    return result2 == \"0\" && 1 / value == -INFINITY ? \"-0\" : result2;\n                }\n                function toSource(func) {\n                    if (func != null) {\n                        try {\n                            return funcToString.call(func);\n                        } catch (e) {}\n                        try {\n                            return func + \"\";\n                        } catch (e) {}\n                    }\n                    return \"\";\n                }\n                function updateWrapDetails(details, bitmask) {\n                    arrayEach(wrapFlags, function(pair) {\n                        var value = \"_.\" + pair[0];\n                        if (bitmask & pair[1] && !arrayIncludes(details, value)) {\n                            details.push(value);\n                        }\n                    });\n                    return details.sort();\n                }\n                function wrapperClone(wrapper) {\n                    if (wrapper instanceof LazyWrapper) {\n                        return wrapper.clone();\n                    }\n                    var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);\n                    result2.__actions__ = copyArray(wrapper.__actions__);\n                    result2.__index__ = wrapper.__index__;\n                    result2.__values__ = wrapper.__values__;\n                    return result2;\n                }\n                function chunk(array, size2, guard) {\n                    if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {\n                        size2 = 1;\n                    } else {\n                        size2 = nativeMax(toInteger(size2), 0);\n                    }\n                    var length = array == null ? 0 : array.length;\n                    if (!length || size2 < 1) {\n                        return [];\n                    }\n                    var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));\n                    while(index < length){\n                        result2[resIndex++] = baseSlice(array, index, index += size2);\n                    }\n                    return result2;\n                }\n                function compact(array) {\n                    var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];\n                    while(++index < length){\n                        var value = array[index];\n                        if (value) {\n                            result2[resIndex++] = value;\n                        }\n                    }\n                    return result2;\n                }\n                function concat() {\n                    var length = arguments.length;\n                    if (!length) {\n                        return [];\n                    }\n                    var args = Array2(length - 1), array = arguments[0], index = length;\n                    while(index--){\n                        args[index - 1] = arguments[index];\n                    }\n                    return arrayPush(isArray(array) ? copyArray(array) : [\n                        array\n                    ], baseFlatten(args, 1));\n                }\n                var difference = baseRest(function(array, values2) {\n                    return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];\n                });\n                var differenceBy = baseRest(function(array, values2) {\n                    var iteratee2 = last(values2);\n                    if (isArrayLikeObject(iteratee2)) {\n                        iteratee2 = undefined2;\n                    }\n                    return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];\n                });\n                var differenceWith = baseRest(function(array, values2) {\n                    var comparator = last(values2);\n                    if (isArrayLikeObject(comparator)) {\n                        comparator = undefined2;\n                    }\n                    return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];\n                });\n                function drop(array, n, guard) {\n                    var length = array == null ? 0 : array.length;\n                    if (!length) {\n                        return [];\n                    }\n                    n = guard || n === undefined2 ? 1 : toInteger(n);\n                    return baseSlice(array, n < 0 ? 0 : n, length);\n                }\n                function dropRight(array, n, guard) {\n                    var length = array == null ? 0 : array.length;\n                    if (!length) {\n                        return [];\n                    }\n                    n = guard || n === undefined2 ? 1 : toInteger(n);\n                    n = length - n;\n                    return baseSlice(array, 0, n < 0 ? 0 : n);\n                }\n                function dropRightWhile(array, predicate) {\n                    return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];\n                }\n                function dropWhile(array, predicate) {\n                    return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];\n                }\n                function fill(array, value, start, end) {\n                    var length = array == null ? 0 : array.length;\n                    if (!length) {\n                        return [];\n                    }\n                    if (start && typeof start != \"number\" && isIterateeCall(array, value, start)) {\n                        start = 0;\n                        end = length;\n                    }\n                    return baseFill(array, value, start, end);\n                }\n                function findIndex(array, predicate, fromIndex) {\n                    var length = array == null ? 0 : array.length;\n                    if (!length) {\n                        return -1;\n                    }\n                    var index = fromIndex == null ? 0 : toInteger(fromIndex);\n                    if (index < 0) {\n                        index = nativeMax(length + index, 0);\n                    }\n                    return baseFindIndex(array, getIteratee(predicate, 3), index);\n                }\n                function findLastIndex(array, predicate, fromIndex) {\n                    var length = array == null ? 0 : array.length;\n                    if (!length) {\n                        return -1;\n                    }\n                    var index = length - 1;\n                    if (fromIndex !== undefined2) {\n                        index = toInteger(fromIndex);\n                        index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);\n                    }\n                    return baseFindIndex(array, getIteratee(predicate, 3), index, true);\n                }\n                function flatten(array) {\n                    var length = array == null ? 0 : array.length;\n                    return length ? baseFlatten(array, 1) : [];\n                }\n                function flattenDeep(array) {\n                    var length = array == null ? 0 : array.length;\n                    return length ? baseFlatten(array, INFINITY) : [];\n                }\n                function flattenDepth(array, depth) {\n                    var length = array == null ? 0 : array.length;\n                    if (!length) {\n                        return [];\n                    }\n                    depth = depth === undefined2 ? 1 : toInteger(depth);\n                    return baseFlatten(array, depth);\n                }\n                function fromPairs(pairs) {\n                    var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};\n                    while(++index < length){\n                        var pair = pairs[index];\n                        result2[pair[0]] = pair[1];\n                    }\n                    return result2;\n                }\n                function head(array) {\n                    return array && array.length ? array[0] : undefined2;\n                }\n                function indexOf(array, value, fromIndex) {\n                    var length = array == null ? 0 : array.length;\n                    if (!length) {\n                        return -1;\n                    }\n                    var index = fromIndex == null ? 0 : toInteger(fromIndex);\n                    if (index < 0) {\n                        index = nativeMax(length + index, 0);\n                    }\n                    return baseIndexOf(array, value, index);\n                }\n                function initial(array) {\n                    var length = array == null ? 0 : array.length;\n                    return length ? baseSlice(array, 0, -1) : [];\n                }\n                var intersection = baseRest(function(arrays) {\n                    var mapped = arrayMap(arrays, castArrayLikeObject);\n                    return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];\n                });\n                var intersectionBy = baseRest(function(arrays) {\n                    var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);\n                    if (iteratee2 === last(mapped)) {\n                        iteratee2 = undefined2;\n                    } else {\n                        mapped.pop();\n                    }\n                    return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];\n                });\n                var intersectionWith = baseRest(function(arrays) {\n                    var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);\n                    comparator = typeof comparator == \"function\" ? comparator : undefined2;\n                    if (comparator) {\n                        mapped.pop();\n                    }\n                    return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];\n                });\n                function join(array, separator) {\n                    return array == null ? \"\" : nativeJoin.call(array, separator);\n                }\n                function last(array) {\n                    var length = array == null ? 0 : array.length;\n                    return length ? array[length - 1] : undefined2;\n                }\n                function lastIndexOf(array, value, fromIndex) {\n                    var length = array == null ? 0 : array.length;\n                    if (!length) {\n                        return -1;\n                    }\n                    var index = length;\n                    if (fromIndex !== undefined2) {\n                        index = toInteger(fromIndex);\n                        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);\n                    }\n                    return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);\n                }\n                function nth(array, n) {\n                    return array && array.length ? baseNth(array, toInteger(n)) : undefined2;\n                }\n                var pull = baseRest(pullAll);\n                function pullAll(array, values2) {\n                    return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;\n                }\n                function pullAllBy(array, values2, iteratee2) {\n                    return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;\n                }\n                function pullAllWith(array, values2, comparator) {\n                    return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;\n                }\n                var pullAt = flatRest(function(array, indexes) {\n                    var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);\n                    basePullAt(array, arrayMap(indexes, function(index) {\n                        return isIndex(index, length) ? +index : index;\n                    }).sort(compareAscending));\n                    return result2;\n                });\n                function remove(array, predicate) {\n                    var result2 = [];\n                    if (!(array && array.length)) {\n                        return result2;\n                    }\n                    var index = -1, indexes = [], length = array.length;\n                    predicate = getIteratee(predicate, 3);\n                    while(++index < length){\n                        var value = array[index];\n                        if (predicate(value, index, array)) {\n                            result2.push(value);\n                            indexes.push(index);\n                        }\n                    }\n                    basePullAt(array, indexes);\n                    return result2;\n                }\n                function reverse(array) {\n                    return array == null ? array : nativeReverse.call(array);\n                }\n                function slice(array, start, end) {\n                    var length = array == null ? 0 : array.length;\n                    if (!length) {\n                        return [];\n                    }\n                    if (end && typeof end != \"number\" && isIterateeCall(array, start, end)) {\n                        start = 0;\n                        end = length;\n                    } else {\n                        start = start == null ? 0 : toInteger(start);\n                        end = end === undefined2 ? length : toInteger(end);\n                    }\n                    return baseSlice(array, start, end);\n                }\n                function sortedIndex(array, value) {\n                    return baseSortedIndex(array, value);\n                }\n                function sortedIndexBy(array, value, iteratee2) {\n                    return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));\n                }\n                function sortedIndexOf(array, value) {\n                    var length = array == null ? 0 : array.length;\n                    if (length) {\n                        var index = baseSortedIndex(array, value);\n                        if (index < length && eq(array[index], value)) {\n                            return index;\n                        }\n                    }\n                    return -1;\n                }\n                function sortedLastIndex(array, value) {\n                    return baseSortedIndex(array, value, true);\n                }\n                function sortedLastIndexBy(array, value, iteratee2) {\n                    return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);\n                }\n                function sortedLastIndexOf(array, value) {\n                    var length = array == null ? 0 : array.length;\n                    if (length) {\n                        var index = baseSortedIndex(array, value, true) - 1;\n                        if (eq(array[index], value)) {\n                            return index;\n                        }\n                    }\n                    return -1;\n                }\n                function sortedUniq(array) {\n                    return array && array.length ? baseSortedUniq(array) : [];\n                }\n                function sortedUniqBy(array, iteratee2) {\n                    return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];\n                }\n                function tail(array) {\n                    var length = array == null ? 0 : array.length;\n                    return length ? baseSlice(array, 1, length) : [];\n                }\n                function take(array, n, guard) {\n                    if (!(array && array.length)) {\n                        return [];\n                    }\n                    n = guard || n === undefined2 ? 1 : toInteger(n);\n                    return baseSlice(array, 0, n < 0 ? 0 : n);\n                }\n                function takeRight(array, n, guard) {\n                    var length = array == null ? 0 : array.length;\n                    if (!length) {\n                        return [];\n                    }\n                    n = guard || n === undefined2 ? 1 : toInteger(n);\n                    n = length - n;\n                    return baseSlice(array, n < 0 ? 0 : n, length);\n                }\n                function takeRightWhile(array, predicate) {\n                    return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];\n                }\n                function takeWhile(array, predicate) {\n                    return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];\n                }\n                var union = baseRest(function(arrays) {\n                    return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));\n                });\n                var unionBy = baseRest(function(arrays) {\n                    var iteratee2 = last(arrays);\n                    if (isArrayLikeObject(iteratee2)) {\n                        iteratee2 = undefined2;\n                    }\n                    return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));\n                });\n                var unionWith = baseRest(function(arrays) {\n                    var comparator = last(arrays);\n                    comparator = typeof comparator == \"function\" ? comparator : undefined2;\n                    return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);\n                });\n                function uniq(array) {\n                    return array && array.length ? baseUniq(array) : [];\n                }\n                function uniqBy(array, iteratee2) {\n                    return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];\n                }\n                function uniqWith(array, comparator) {\n                    comparator = typeof comparator == \"function\" ? comparator : undefined2;\n                    return array && array.length ? baseUniq(array, undefined2, comparator) : [];\n                }\n                function unzip(array) {\n                    if (!(array && array.length)) {\n                        return [];\n                    }\n                    var length = 0;\n                    array = arrayFilter(array, function(group) {\n                        if (isArrayLikeObject(group)) {\n                            length = nativeMax(group.length, length);\n                            return true;\n                        }\n                    });\n                    return baseTimes(length, function(index) {\n                        return arrayMap(array, baseProperty(index));\n                    });\n                }\n                function unzipWith(array, iteratee2) {\n                    if (!(array && array.length)) {\n                        return [];\n                    }\n                    var result2 = unzip(array);\n                    if (iteratee2 == null) {\n                        return result2;\n                    }\n                    return arrayMap(result2, function(group) {\n                        return apply(iteratee2, undefined2, group);\n                    });\n                }\n                var without = baseRest(function(array, values2) {\n                    return isArrayLikeObject(array) ? baseDifference(array, values2) : [];\n                });\n                var xor = baseRest(function(arrays) {\n                    return baseXor(arrayFilter(arrays, isArrayLikeObject));\n                });\n                var xorBy = baseRest(function(arrays) {\n                    var iteratee2 = last(arrays);\n                    if (isArrayLikeObject(iteratee2)) {\n                        iteratee2 = undefined2;\n                    }\n                    return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));\n                });\n                var xorWith = baseRest(function(arrays) {\n                    var comparator = last(arrays);\n                    comparator = typeof comparator == \"function\" ? comparator : undefined2;\n                    return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);\n                });\n                var zip = baseRest(unzip);\n                function zipObject(props, values2) {\n                    return baseZipObject(props || [], values2 || [], assignValue);\n                }\n                function zipObjectDeep(props, values2) {\n                    return baseZipObject(props || [], values2 || [], baseSet);\n                }\n                var zipWith = baseRest(function(arrays) {\n                    var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;\n                    iteratee2 = typeof iteratee2 == \"function\" ? (arrays.pop(), iteratee2) : undefined2;\n                    return unzipWith(arrays, iteratee2);\n                });\n                function chain(value) {\n                    var result2 = lodash(value);\n                    result2.__chain__ = true;\n                    return result2;\n                }\n                function tap(value, interceptor) {\n                    interceptor(value);\n                    return value;\n                }\n                function thru(value, interceptor) {\n                    return interceptor(value);\n                }\n                var wrapperAt = flatRest(function(paths) {\n                    var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {\n                        return baseAt(object, paths);\n                    };\n                    if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {\n                        return this.thru(interceptor);\n                    }\n                    value = value.slice(start, +start + (length ? 1 : 0));\n                    value.__actions__.push({\n                        \"func\": thru,\n                        \"args\": [\n                            interceptor\n                        ],\n                        \"thisArg\": undefined2\n                    });\n                    return new LodashWrapper(value, this.__chain__).thru(function(array) {\n                        if (length && !array.length) {\n                            array.push(undefined2);\n                        }\n                        return array;\n                    });\n                });\n                function wrapperChain() {\n                    return chain(this);\n                }\n                function wrapperCommit() {\n                    return new LodashWrapper(this.value(), this.__chain__);\n                }\n                function wrapperNext() {\n                    if (this.__values__ === undefined2) {\n                        this.__values__ = toArray(this.value());\n                    }\n                    var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];\n                    return {\n                        \"done\": done,\n                        \"value\": value\n                    };\n                }\n                function wrapperToIterator() {\n                    return this;\n                }\n                function wrapperPlant(value) {\n                    var result2, parent2 = this;\n                    while(parent2 instanceof baseLodash){\n                        var clone2 = wrapperClone(parent2);\n                        clone2.__index__ = 0;\n                        clone2.__values__ = undefined2;\n                        if (result2) {\n                            previous.__wrapped__ = clone2;\n                        } else {\n                            result2 = clone2;\n                        }\n                        var previous = clone2;\n                        parent2 = parent2.__wrapped__;\n                    }\n                    previous.__wrapped__ = value;\n                    return result2;\n                }\n                function wrapperReverse() {\n                    var value = this.__wrapped__;\n                    if (value instanceof LazyWrapper) {\n                        var wrapped = value;\n                        if (this.__actions__.length) {\n                            wrapped = new LazyWrapper(this);\n                        }\n                        wrapped = wrapped.reverse();\n                        wrapped.__actions__.push({\n                            \"func\": thru,\n                            \"args\": [\n                                reverse\n                            ],\n                            \"thisArg\": undefined2\n                        });\n                        return new LodashWrapper(wrapped, this.__chain__);\n                    }\n                    return this.thru(reverse);\n                }\n                function wrapperValue() {\n                    return baseWrapperValue(this.__wrapped__, this.__actions__);\n                }\n                var countBy = createAggregator(function(result2, value, key) {\n                    if (hasOwnProperty.call(result2, key)) {\n                        ++result2[key];\n                    } else {\n                        baseAssignValue(result2, key, 1);\n                    }\n                });\n                function every(collection, predicate, guard) {\n                    var func = isArray(collection) ? arrayEvery : baseEvery;\n                    if (guard && isIterateeCall(collection, predicate, guard)) {\n                        predicate = undefined2;\n                    }\n                    return func(collection, getIteratee(predicate, 3));\n                }\n                function filter(collection, predicate) {\n                    var func = isArray(collection) ? arrayFilter : baseFilter;\n                    return func(collection, getIteratee(predicate, 3));\n                }\n                var find = createFind(findIndex);\n                var findLast = createFind(findLastIndex);\n                function flatMap(collection, iteratee2) {\n                    return baseFlatten(map(collection, iteratee2), 1);\n                }\n                function flatMapDeep(collection, iteratee2) {\n                    return baseFlatten(map(collection, iteratee2), INFINITY);\n                }\n                function flatMapDepth(collection, iteratee2, depth) {\n                    depth = depth === undefined2 ? 1 : toInteger(depth);\n                    return baseFlatten(map(collection, iteratee2), depth);\n                }\n                function forEach(collection, iteratee2) {\n                    var func = isArray(collection) ? arrayEach : baseEach;\n                    return func(collection, getIteratee(iteratee2, 3));\n                }\n                function forEachRight(collection, iteratee2) {\n                    var func = isArray(collection) ? arrayEachRight : baseEachRight;\n                    return func(collection, getIteratee(iteratee2, 3));\n                }\n                var groupBy = createAggregator(function(result2, value, key) {\n                    if (hasOwnProperty.call(result2, key)) {\n                        result2[key].push(value);\n                    } else {\n                        baseAssignValue(result2, key, [\n                            value\n                        ]);\n                    }\n                });\n                function includes(collection, value, fromIndex, guard) {\n                    collection = isArrayLike(collection) ? collection : values(collection);\n                    fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;\n                    var length = collection.length;\n                    if (fromIndex < 0) {\n                        fromIndex = nativeMax(length + fromIndex, 0);\n                    }\n                    return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;\n                }\n                var invokeMap = baseRest(function(collection, path, args) {\n                    var index = -1, isFunc = typeof path == \"function\", result2 = isArrayLike(collection) ? Array2(collection.length) : [];\n                    baseEach(collection, function(value) {\n                        result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);\n                    });\n                    return result2;\n                });\n                var keyBy = createAggregator(function(result2, value, key) {\n                    baseAssignValue(result2, key, value);\n                });\n                function map(collection, iteratee2) {\n                    var func = isArray(collection) ? arrayMap : baseMap;\n                    return func(collection, getIteratee(iteratee2, 3));\n                }\n                function orderBy(collection, iteratees, orders, guard) {\n                    if (collection == null) {\n                        return [];\n                    }\n                    if (!isArray(iteratees)) {\n                        iteratees = iteratees == null ? [] : [\n                            iteratees\n                        ];\n                    }\n                    orders = guard ? undefined2 : orders;\n                    if (!isArray(orders)) {\n                        orders = orders == null ? [] : [\n                            orders\n                        ];\n                    }\n                    return baseOrderBy(collection, iteratees, orders);\n                }\n                var partition = createAggregator(function(result2, value, key) {\n                    result2[key ? 0 : 1].push(value);\n                }, function() {\n                    return [\n                        [],\n                        []\n                    ];\n                });\n                function reduce(collection, iteratee2, accumulator) {\n                    var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;\n                    return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);\n                }\n                function reduceRight(collection, iteratee2, accumulator) {\n                    var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;\n                    return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);\n                }\n                function reject(collection, predicate) {\n                    var func = isArray(collection) ? arrayFilter : baseFilter;\n                    return func(collection, negate(getIteratee(predicate, 3)));\n                }\n                function sample(collection) {\n                    var func = isArray(collection) ? arraySample : baseSample;\n                    return func(collection);\n                }\n                function sampleSize(collection, n, guard) {\n                    if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {\n                        n = 1;\n                    } else {\n                        n = toInteger(n);\n                    }\n                    var func = isArray(collection) ? arraySampleSize : baseSampleSize;\n                    return func(collection, n);\n                }\n                function shuffle(collection) {\n                    var func = isArray(collection) ? arrayShuffle : baseShuffle;\n                    return func(collection);\n                }\n                function size(collection) {\n                    if (collection == null) {\n                        return 0;\n                    }\n                    if (isArrayLike(collection)) {\n                        return isString(collection) ? stringSize(collection) : collection.length;\n                    }\n                    var tag = getTag(collection);\n                    if (tag == mapTag || tag == setTag) {\n                        return collection.size;\n                    }\n                    return baseKeys(collection).length;\n                }\n                function some(collection, predicate, guard) {\n                    var func = isArray(collection) ? arraySome : baseSome;\n                    if (guard && isIterateeCall(collection, predicate, guard)) {\n                        predicate = undefined2;\n                    }\n                    return func(collection, getIteratee(predicate, 3));\n                }\n                var sortBy = baseRest(function(collection, iteratees) {\n                    if (collection == null) {\n                        return [];\n                    }\n                    var length = iteratees.length;\n                    if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n                        iteratees = [];\n                    } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n                        iteratees = [\n                            iteratees[0]\n                        ];\n                    }\n                    return baseOrderBy(collection, baseFlatten(iteratees, 1), []);\n                });\n                var now = ctxNow || function() {\n                    return root.Date.now();\n                };\n                function after(n, func) {\n                    if (typeof func != \"function\") {\n                        throw new TypeError2(FUNC_ERROR_TEXT);\n                    }\n                    n = toInteger(n);\n                    return function() {\n                        if (--n < 1) {\n                            return func.apply(this, arguments);\n                        }\n                    };\n                }\n                function ary(func, n, guard) {\n                    n = guard ? undefined2 : n;\n                    n = func && n == null ? func.length : n;\n                    return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);\n                }\n                function before(n, func) {\n                    var result2;\n                    if (typeof func != \"function\") {\n                        throw new TypeError2(FUNC_ERROR_TEXT);\n                    }\n                    n = toInteger(n);\n                    return function() {\n                        if (--n > 0) {\n                            result2 = func.apply(this, arguments);\n                        }\n                        if (n <= 1) {\n                            func = undefined2;\n                        }\n                        return result2;\n                    };\n                }\n                var bind = baseRest(function(func, thisArg, partials) {\n                    var bitmask = WRAP_BIND_FLAG;\n                    if (partials.length) {\n                        var holders = replaceHolders(partials, getHolder(bind));\n                        bitmask |= WRAP_PARTIAL_FLAG;\n                    }\n                    return createWrap(func, bitmask, thisArg, partials, holders);\n                });\n                var bindKey = baseRest(function(object, key, partials) {\n                    var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;\n                    if (partials.length) {\n                        var holders = replaceHolders(partials, getHolder(bindKey));\n                        bitmask |= WRAP_PARTIAL_FLAG;\n                    }\n                    return createWrap(key, bitmask, object, partials, holders);\n                });\n                function curry(func, arity, guard) {\n                    arity = guard ? undefined2 : arity;\n                    var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);\n                    result2.placeholder = curry.placeholder;\n                    return result2;\n                }\n                function curryRight(func, arity, guard) {\n                    arity = guard ? undefined2 : arity;\n                    var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);\n                    result2.placeholder = curryRight.placeholder;\n                    return result2;\n                }\n                function debounce(func, wait, options) {\n                    var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;\n                    if (typeof func != \"function\") {\n                        throw new TypeError2(FUNC_ERROR_TEXT);\n                    }\n                    wait = toNumber(wait) || 0;\n                    if (isObject(options)) {\n                        leading = !!options.leading;\n                        maxing = \"maxWait\" in options;\n                        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n                        trailing = \"trailing\" in options ? !!options.trailing : trailing;\n                    }\n                    function invokeFunc(time) {\n                        var args = lastArgs, thisArg = lastThis;\n                        lastArgs = lastThis = undefined2;\n                        lastInvokeTime = time;\n                        result2 = func.apply(thisArg, args);\n                        return result2;\n                    }\n                    function leadingEdge(time) {\n                        lastInvokeTime = time;\n                        timerId = setTimeout(timerExpired, wait);\n                        return leading ? invokeFunc(time) : result2;\n                    }\n                    function remainingWait(time) {\n                        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;\n                        return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;\n                    }\n                    function shouldInvoke(time) {\n                        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;\n                        return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;\n                    }\n                    function timerExpired() {\n                        var time = now();\n                        if (shouldInvoke(time)) {\n                            return trailingEdge(time);\n                        }\n                        timerId = setTimeout(timerExpired, remainingWait(time));\n                    }\n                    function trailingEdge(time) {\n                        timerId = undefined2;\n                        if (trailing && lastArgs) {\n                            return invokeFunc(time);\n                        }\n                        lastArgs = lastThis = undefined2;\n                        return result2;\n                    }\n                    function cancel() {\n                        if (timerId !== undefined2) {\n                            clearTimeout(timerId);\n                        }\n                        lastInvokeTime = 0;\n                        lastArgs = lastCallTime = lastThis = timerId = undefined2;\n                    }\n                    function flush() {\n                        return timerId === undefined2 ? result2 : trailingEdge(now());\n                    }\n                    function debounced() {\n                        var time = now(), isInvoking = shouldInvoke(time);\n                        lastArgs = arguments;\n                        lastThis = this;\n                        lastCallTime = time;\n                        if (isInvoking) {\n                            if (timerId === undefined2) {\n                                return leadingEdge(lastCallTime);\n                            }\n                            if (maxing) {\n                                clearTimeout(timerId);\n                                timerId = setTimeout(timerExpired, wait);\n                                return invokeFunc(lastCallTime);\n                            }\n                        }\n                        if (timerId === undefined2) {\n                            timerId = setTimeout(timerExpired, wait);\n                        }\n                        return result2;\n                    }\n                    debounced.cancel = cancel;\n                    debounced.flush = flush;\n                    return debounced;\n                }\n                var defer = baseRest(function(func, args) {\n                    return baseDelay(func, 1, args);\n                });\n                var delay = baseRest(function(func, wait, args) {\n                    return baseDelay(func, toNumber(wait) || 0, args);\n                });\n                function flip(func) {\n                    return createWrap(func, WRAP_FLIP_FLAG);\n                }\n                function memoize2(func, resolver) {\n                    if (typeof func != \"function\" || resolver != null && typeof resolver != \"function\") {\n                        throw new TypeError2(FUNC_ERROR_TEXT);\n                    }\n                    var memoized = function() {\n                        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;\n                        if (cache.has(key)) {\n                            return cache.get(key);\n                        }\n                        var result2 = func.apply(this, args);\n                        memoized.cache = cache.set(key, result2) || cache;\n                        return result2;\n                    };\n                    memoized.cache = new (memoize2.Cache || MapCache)();\n                    return memoized;\n                }\n                memoize2.Cache = MapCache;\n                function negate(predicate) {\n                    if (typeof predicate != \"function\") {\n                        throw new TypeError2(FUNC_ERROR_TEXT);\n                    }\n                    return function() {\n                        var args = arguments;\n                        switch(args.length){\n                            case 0:\n                                return !predicate.call(this);\n                            case 1:\n                                return !predicate.call(this, args[0]);\n                            case 2:\n                                return !predicate.call(this, args[0], args[1]);\n                            case 3:\n                                return !predicate.call(this, args[0], args[1], args[2]);\n                        }\n                        return !predicate.apply(this, args);\n                    };\n                }\n                function once(func) {\n                    return before(2, func);\n                }\n                var overArgs = castRest(function(func, transforms) {\n                    transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));\n                    var funcsLength = transforms.length;\n                    return baseRest(function(args) {\n                        var index = -1, length = nativeMin(args.length, funcsLength);\n                        while(++index < length){\n                            args[index] = transforms[index].call(this, args[index]);\n                        }\n                        return apply(func, this, args);\n                    });\n                });\n                var partial = baseRest(function(func, partials) {\n                    var holders = replaceHolders(partials, getHolder(partial));\n                    return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);\n                });\n                var partialRight = baseRest(function(func, partials) {\n                    var holders = replaceHolders(partials, getHolder(partialRight));\n                    return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);\n                });\n                var rearg = flatRest(function(func, indexes) {\n                    return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);\n                });\n                function rest(func, start) {\n                    if (typeof func != \"function\") {\n                        throw new TypeError2(FUNC_ERROR_TEXT);\n                    }\n                    start = start === undefined2 ? start : toInteger(start);\n                    return baseRest(func, start);\n                }\n                function spread(func, start) {\n                    if (typeof func != \"function\") {\n                        throw new TypeError2(FUNC_ERROR_TEXT);\n                    }\n                    start = start == null ? 0 : nativeMax(toInteger(start), 0);\n                    return baseRest(function(args) {\n                        var array = args[start], otherArgs = castSlice(args, 0, start);\n                        if (array) {\n                            arrayPush(otherArgs, array);\n                        }\n                        return apply(func, this, otherArgs);\n                    });\n                }\n                function throttle(func, wait, options) {\n                    var leading = true, trailing = true;\n                    if (typeof func != \"function\") {\n                        throw new TypeError2(FUNC_ERROR_TEXT);\n                    }\n                    if (isObject(options)) {\n                        leading = \"leading\" in options ? !!options.leading : leading;\n                        trailing = \"trailing\" in options ? !!options.trailing : trailing;\n                    }\n                    return debounce(func, wait, {\n                        \"leading\": leading,\n                        \"maxWait\": wait,\n                        \"trailing\": trailing\n                    });\n                }\n                function unary(func) {\n                    return ary(func, 1);\n                }\n                function wrap(value, wrapper) {\n                    return partial(castFunction(wrapper), value);\n                }\n                function castArray() {\n                    if (!arguments.length) {\n                        return [];\n                    }\n                    var value = arguments[0];\n                    return isArray(value) ? value : [\n                        value\n                    ];\n                }\n                function clone(value) {\n                    return baseClone(value, CLONE_SYMBOLS_FLAG);\n                }\n                function cloneWith(value, customizer) {\n                    customizer = typeof customizer == \"function\" ? customizer : undefined2;\n                    return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);\n                }\n                function cloneDeep(value) {\n                    return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);\n                }\n                function cloneDeepWith(value, customizer) {\n                    customizer = typeof customizer == \"function\" ? customizer : undefined2;\n                    return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);\n                }\n                function conformsTo(object, source) {\n                    return source == null || baseConformsTo(object, source, keys(source));\n                }\n                function eq(value, other) {\n                    return value === other || value !== value && other !== other;\n                }\n                var gt = createRelationalOperation(baseGt);\n                var gte = createRelationalOperation(function(value, other) {\n                    return value >= other;\n                });\n                var isArguments = baseIsArguments(function() {\n                    return arguments;\n                }()) ? baseIsArguments : function(value) {\n                    return isObjectLike(value) && hasOwnProperty.call(value, \"callee\") && !propertyIsEnumerable.call(value, \"callee\");\n                };\n                var isArray = Array2.isArray;\n                var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;\n                function isArrayLike(value) {\n                    return value != null && isLength(value.length) && !isFunction(value);\n                }\n                function isArrayLikeObject(value) {\n                    return isObjectLike(value) && isArrayLike(value);\n                }\n                function isBoolean(value) {\n                    return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;\n                }\n                var isBuffer = nativeIsBuffer || stubFalse;\n                var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;\n                function isElement(value) {\n                    return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);\n                }\n                function isEmpty(value) {\n                    if (value == null) {\n                        return true;\n                    }\n                    if (isArrayLike(value) && (isArray(value) || typeof value == \"string\" || typeof value.splice == \"function\" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {\n                        return !value.length;\n                    }\n                    var tag = getTag(value);\n                    if (tag == mapTag || tag == setTag) {\n                        return !value.size;\n                    }\n                    if (isPrototype(value)) {\n                        return !baseKeys(value).length;\n                    }\n                    for(var key in value){\n                        if (hasOwnProperty.call(value, key)) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n                function isEqual(value, other) {\n                    return baseIsEqual(value, other);\n                }\n                function isEqualWith(value, other, customizer) {\n                    customizer = typeof customizer == \"function\" ? customizer : undefined2;\n                    var result2 = customizer ? customizer(value, other) : undefined2;\n                    return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;\n                }\n                function isError(value) {\n                    if (!isObjectLike(value)) {\n                        return false;\n                    }\n                    var tag = baseGetTag(value);\n                    return tag == errorTag || tag == domExcTag || typeof value.message == \"string\" && typeof value.name == \"string\" && !isPlainObject(value);\n                }\n                function isFinite2(value) {\n                    return typeof value == \"number\" && nativeIsFinite(value);\n                }\n                function isFunction(value) {\n                    if (!isObject(value)) {\n                        return false;\n                    }\n                    var tag = baseGetTag(value);\n                    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n                }\n                function isInteger(value) {\n                    return typeof value == \"number\" && value == toInteger(value);\n                }\n                function isLength(value) {\n                    return typeof value == \"number\" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n                }\n                function isObject(value) {\n                    var type = typeof value;\n                    return value != null && (type == \"object\" || type == \"function\");\n                }\n                function isObjectLike(value) {\n                    return value != null && typeof value == \"object\";\n                }\n                var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n                function isMatch(object, source) {\n                    return object === source || baseIsMatch(object, source, getMatchData(source));\n                }\n                function isMatchWith(object, source, customizer) {\n                    customizer = typeof customizer == \"function\" ? customizer : undefined2;\n                    return baseIsMatch(object, source, getMatchData(source), customizer);\n                }\n                function isNaN2(value) {\n                    return isNumber(value) && value != +value;\n                }\n                function isNative(value) {\n                    if (isMaskable(value)) {\n                        throw new Error2(CORE_ERROR_TEXT);\n                    }\n                    return baseIsNative(value);\n                }\n                function isNull(value) {\n                    return value === null;\n                }\n                function isNil(value) {\n                    return value == null;\n                }\n                function isNumber(value) {\n                    return typeof value == \"number\" || isObjectLike(value) && baseGetTag(value) == numberTag;\n                }\n                function isPlainObject(value) {\n                    if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n                        return false;\n                    }\n                    var proto = getPrototype(value);\n                    if (proto === null) {\n                        return true;\n                    }\n                    var Ctor = hasOwnProperty.call(proto, \"constructor\") && proto.constructor;\n                    return typeof Ctor == \"function\" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;\n                }\n                var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;\n                function isSafeInteger(value) {\n                    return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;\n                }\n                var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n                function isString(value) {\n                    return typeof value == \"string\" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;\n                }\n                function isSymbol(value) {\n                    return typeof value == \"symbol\" || isObjectLike(value) && baseGetTag(value) == symbolTag;\n                }\n                var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n                function isUndefined(value) {\n                    return value === undefined2;\n                }\n                function isWeakMap(value) {\n                    return isObjectLike(value) && getTag(value) == weakMapTag;\n                }\n                function isWeakSet(value) {\n                    return isObjectLike(value) && baseGetTag(value) == weakSetTag;\n                }\n                var lt = createRelationalOperation(baseLt);\n                var lte = createRelationalOperation(function(value, other) {\n                    return value <= other;\n                });\n                function toArray(value) {\n                    if (!value) {\n                        return [];\n                    }\n                    if (isArrayLike(value)) {\n                        return isString(value) ? stringToArray(value) : copyArray(value);\n                    }\n                    if (symIterator && value[symIterator]) {\n                        return iteratorToArray(value[symIterator]());\n                    }\n                    var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;\n                    return func(value);\n                }\n                function toFinite(value) {\n                    if (!value) {\n                        return value === 0 ? value : 0;\n                    }\n                    value = toNumber(value);\n                    if (value === INFINITY || value === -INFINITY) {\n                        var sign = value < 0 ? -1 : 1;\n                        return sign * MAX_INTEGER;\n                    }\n                    return value === value ? value : 0;\n                }\n                function toInteger(value) {\n                    var result2 = toFinite(value), remainder = result2 % 1;\n                    return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;\n                }\n                function toLength(value) {\n                    return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;\n                }\n                function toNumber(value) {\n                    if (typeof value == \"number\") {\n                        return value;\n                    }\n                    if (isSymbol(value)) {\n                        return NAN;\n                    }\n                    if (isObject(value)) {\n                        var other = typeof value.valueOf == \"function\" ? value.valueOf() : value;\n                        value = isObject(other) ? other + \"\" : other;\n                    }\n                    if (typeof value != \"string\") {\n                        return value === 0 ? value : +value;\n                    }\n                    value = baseTrim(value);\n                    var isBinary = reIsBinary.test(value);\n                    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;\n                }\n                function toPlainObject(value) {\n                    return copyObject(value, keysIn(value));\n                }\n                function toSafeInteger(value) {\n                    return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;\n                }\n                function toString(value) {\n                    return value == null ? \"\" : baseToString(value);\n                }\n                var assign = createAssigner(function(object, source) {\n                    if (isPrototype(source) || isArrayLike(source)) {\n                        copyObject(source, keys(source), object);\n                        return;\n                    }\n                    for(var key in source){\n                        if (hasOwnProperty.call(source, key)) {\n                            assignValue(object, key, source[key]);\n                        }\n                    }\n                });\n                var assignIn = createAssigner(function(object, source) {\n                    copyObject(source, keysIn(source), object);\n                });\n                var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {\n                    copyObject(source, keysIn(source), object, customizer);\n                });\n                var assignWith = createAssigner(function(object, source, srcIndex, customizer) {\n                    copyObject(source, keys(source), object, customizer);\n                });\n                var at = flatRest(baseAt);\n                function create(prototype, properties) {\n                    var result2 = baseCreate(prototype);\n                    return properties == null ? result2 : baseAssign(result2, properties);\n                }\n                var defaults = baseRest(function(object, sources) {\n                    object = Object2(object);\n                    var index = -1;\n                    var length = sources.length;\n                    var guard = length > 2 ? sources[2] : undefined2;\n                    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n                        length = 1;\n                    }\n                    while(++index < length){\n                        var source = sources[index];\n                        var props = keysIn(source);\n                        var propsIndex = -1;\n                        var propsLength = props.length;\n                        while(++propsIndex < propsLength){\n                            var key = props[propsIndex];\n                            var value = object[key];\n                            if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {\n                                object[key] = source[key];\n                            }\n                        }\n                    }\n                    return object;\n                });\n                var defaultsDeep = baseRest(function(args) {\n                    args.push(undefined2, customDefaultsMerge);\n                    return apply(mergeWith, undefined2, args);\n                });\n                function findKey(object, predicate) {\n                    return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);\n                }\n                function findLastKey(object, predicate) {\n                    return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);\n                }\n                function forIn(object, iteratee2) {\n                    return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);\n                }\n                function forInRight(object, iteratee2) {\n                    return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);\n                }\n                function forOwn(object, iteratee2) {\n                    return object && baseForOwn(object, getIteratee(iteratee2, 3));\n                }\n                function forOwnRight(object, iteratee2) {\n                    return object && baseForOwnRight(object, getIteratee(iteratee2, 3));\n                }\n                function functions(object) {\n                    return object == null ? [] : baseFunctions(object, keys(object));\n                }\n                function functionsIn(object) {\n                    return object == null ? [] : baseFunctions(object, keysIn(object));\n                }\n                function get(object, path, defaultValue) {\n                    var result2 = object == null ? undefined2 : baseGet(object, path);\n                    return result2 === undefined2 ? defaultValue : result2;\n                }\n                function has(object, path) {\n                    return object != null && hasPath(object, path, baseHas);\n                }\n                function hasIn(object, path) {\n                    return object != null && hasPath(object, path, baseHasIn);\n                }\n                var invert = createInverter(function(result2, value, key) {\n                    if (value != null && typeof value.toString != \"function\") {\n                        value = nativeObjectToString.call(value);\n                    }\n                    result2[value] = key;\n                }, constant(identity));\n                var invertBy = createInverter(function(result2, value, key) {\n                    if (value != null && typeof value.toString != \"function\") {\n                        value = nativeObjectToString.call(value);\n                    }\n                    if (hasOwnProperty.call(result2, value)) {\n                        result2[value].push(key);\n                    } else {\n                        result2[value] = [\n                            key\n                        ];\n                    }\n                }, getIteratee);\n                var invoke = baseRest(baseInvoke);\n                function keys(object) {\n                    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n                }\n                function keysIn(object) {\n                    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n                }\n                function mapKeys(object, iteratee2) {\n                    var result2 = {};\n                    iteratee2 = getIteratee(iteratee2, 3);\n                    baseForOwn(object, function(value, key, object2) {\n                        baseAssignValue(result2, iteratee2(value, key, object2), value);\n                    });\n                    return result2;\n                }\n                function mapValues(object, iteratee2) {\n                    var result2 = {};\n                    iteratee2 = getIteratee(iteratee2, 3);\n                    baseForOwn(object, function(value, key, object2) {\n                        baseAssignValue(result2, key, iteratee2(value, key, object2));\n                    });\n                    return result2;\n                }\n                var merge = createAssigner(function(object, source, srcIndex) {\n                    baseMerge(object, source, srcIndex);\n                });\n                var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {\n                    baseMerge(object, source, srcIndex, customizer);\n                });\n                var omit = flatRest(function(object, paths) {\n                    var result2 = {};\n                    if (object == null) {\n                        return result2;\n                    }\n                    var isDeep = false;\n                    paths = arrayMap(paths, function(path) {\n                        path = castPath(path, object);\n                        isDeep || (isDeep = path.length > 1);\n                        return path;\n                    });\n                    copyObject(object, getAllKeysIn(object), result2);\n                    if (isDeep) {\n                        result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);\n                    }\n                    var length = paths.length;\n                    while(length--){\n                        baseUnset(result2, paths[length]);\n                    }\n                    return result2;\n                });\n                function omitBy(object, predicate) {\n                    return pickBy(object, negate(getIteratee(predicate)));\n                }\n                var pick = flatRest(function(object, paths) {\n                    return object == null ? {} : basePick(object, paths);\n                });\n                function pickBy(object, predicate) {\n                    if (object == null) {\n                        return {};\n                    }\n                    var props = arrayMap(getAllKeysIn(object), function(prop) {\n                        return [\n                            prop\n                        ];\n                    });\n                    predicate = getIteratee(predicate);\n                    return basePickBy(object, props, function(value, path) {\n                        return predicate(value, path[0]);\n                    });\n                }\n                function result(object, path, defaultValue) {\n                    path = castPath(path, object);\n                    var index = -1, length = path.length;\n                    if (!length) {\n                        length = 1;\n                        object = undefined2;\n                    }\n                    while(++index < length){\n                        var value = object == null ? undefined2 : object[toKey(path[index])];\n                        if (value === undefined2) {\n                            index = length;\n                            value = defaultValue;\n                        }\n                        object = isFunction(value) ? value.call(object) : value;\n                    }\n                    return object;\n                }\n                function set(object, path, value) {\n                    return object == null ? object : baseSet(object, path, value);\n                }\n                function setWith(object, path, value, customizer) {\n                    customizer = typeof customizer == \"function\" ? customizer : undefined2;\n                    return object == null ? object : baseSet(object, path, value, customizer);\n                }\n                var toPairs = createToPairs(keys);\n                var toPairsIn = createToPairs(keysIn);\n                function transform(object, iteratee2, accumulator) {\n                    var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);\n                    iteratee2 = getIteratee(iteratee2, 4);\n                    if (accumulator == null) {\n                        var Ctor = object && object.constructor;\n                        if (isArrLike) {\n                            accumulator = isArr ? new Ctor() : [];\n                        } else if (isObject(object)) {\n                            accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};\n                        } else {\n                            accumulator = {};\n                        }\n                    }\n                    (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {\n                        return iteratee2(accumulator, value, index, object2);\n                    });\n                    return accumulator;\n                }\n                function unset(object, path) {\n                    return object == null ? true : baseUnset(object, path);\n                }\n                function update(object, path, updater) {\n                    return object == null ? object : baseUpdate(object, path, castFunction(updater));\n                }\n                function updateWith(object, path, updater, customizer) {\n                    customizer = typeof customizer == \"function\" ? customizer : undefined2;\n                    return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);\n                }\n                function values(object) {\n                    return object == null ? [] : baseValues(object, keys(object));\n                }\n                function valuesIn(object) {\n                    return object == null ? [] : baseValues(object, keysIn(object));\n                }\n                function clamp(number, lower, upper) {\n                    if (upper === undefined2) {\n                        upper = lower;\n                        lower = undefined2;\n                    }\n                    if (upper !== undefined2) {\n                        upper = toNumber(upper);\n                        upper = upper === upper ? upper : 0;\n                    }\n                    if (lower !== undefined2) {\n                        lower = toNumber(lower);\n                        lower = lower === lower ? lower : 0;\n                    }\n                    return baseClamp(toNumber(number), lower, upper);\n                }\n                function inRange(number, start, end) {\n                    start = toFinite(start);\n                    if (end === undefined2) {\n                        end = start;\n                        start = 0;\n                    } else {\n                        end = toFinite(end);\n                    }\n                    number = toNumber(number);\n                    return baseInRange(number, start, end);\n                }\n                function random(lower, upper, floating) {\n                    if (floating && typeof floating != \"boolean\" && isIterateeCall(lower, upper, floating)) {\n                        upper = floating = undefined2;\n                    }\n                    if (floating === undefined2) {\n                        if (typeof upper == \"boolean\") {\n                            floating = upper;\n                            upper = undefined2;\n                        } else if (typeof lower == \"boolean\") {\n                            floating = lower;\n                            lower = undefined2;\n                        }\n                    }\n                    if (lower === undefined2 && upper === undefined2) {\n                        lower = 0;\n                        upper = 1;\n                    } else {\n                        lower = toFinite(lower);\n                        if (upper === undefined2) {\n                            upper = lower;\n                            lower = 0;\n                        } else {\n                            upper = toFinite(upper);\n                        }\n                    }\n                    if (lower > upper) {\n                        var temp = lower;\n                        lower = upper;\n                        upper = temp;\n                    }\n                    if (floating || lower % 1 || upper % 1) {\n                        var rand = nativeRandom();\n                        return nativeMin(lower + rand * (upper - lower + freeParseFloat(\"1e-\" + ((rand + \"\").length - 1))), upper);\n                    }\n                    return baseRandom(lower, upper);\n                }\n                var camelCase = createCompounder(function(result2, word, index) {\n                    word = word.toLowerCase();\n                    return result2 + (index ? capitalize(word) : word);\n                });\n                function capitalize(string) {\n                    return upperFirst(toString(string).toLowerCase());\n                }\n                function deburr(string) {\n                    string = toString(string);\n                    return string && string.replace(reLatin, deburrLetter).replace(reComboMark, \"\");\n                }\n                function endsWith(string, target, position) {\n                    string = toString(string);\n                    target = baseToString(target);\n                    var length = string.length;\n                    position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);\n                    var end = position;\n                    position -= target.length;\n                    return position >= 0 && string.slice(position, end) == target;\n                }\n                function escape(string) {\n                    string = toString(string);\n                    return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;\n                }\n                function escapeRegExp(string) {\n                    string = toString(string);\n                    return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, \"\\\\$&\") : string;\n                }\n                var kebabCase = createCompounder(function(result2, word, index) {\n                    return result2 + (index ? \"-\" : \"\") + word.toLowerCase();\n                });\n                var lowerCase = createCompounder(function(result2, word, index) {\n                    return result2 + (index ? \" \" : \"\") + word.toLowerCase();\n                });\n                var lowerFirst = createCaseFirst(\"toLowerCase\");\n                function pad(string, length, chars) {\n                    string = toString(string);\n                    length = toInteger(length);\n                    var strLength = length ? stringSize(string) : 0;\n                    if (!length || strLength >= length) {\n                        return string;\n                    }\n                    var mid = (length - strLength) / 2;\n                    return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);\n                }\n                function padEnd(string, length, chars) {\n                    string = toString(string);\n                    length = toInteger(length);\n                    var strLength = length ? stringSize(string) : 0;\n                    return length && strLength < length ? string + createPadding(length - strLength, chars) : string;\n                }\n                function padStart(string, length, chars) {\n                    string = toString(string);\n                    length = toInteger(length);\n                    var strLength = length ? stringSize(string) : 0;\n                    return length && strLength < length ? createPadding(length - strLength, chars) + string : string;\n                }\n                function parseInt2(string, radix, guard) {\n                    if (guard || radix == null) {\n                        radix = 0;\n                    } else if (radix) {\n                        radix = +radix;\n                    }\n                    return nativeParseInt(toString(string).replace(reTrimStart, \"\"), radix || 0);\n                }\n                function repeat(string, n, guard) {\n                    if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {\n                        n = 1;\n                    } else {\n                        n = toInteger(n);\n                    }\n                    return baseRepeat(toString(string), n);\n                }\n                function replace() {\n                    var args = arguments, string = toString(args[0]);\n                    return args.length < 3 ? string : string.replace(args[1], args[2]);\n                }\n                var snakeCase = createCompounder(function(result2, word, index) {\n                    return result2 + (index ? \"_\" : \"\") + word.toLowerCase();\n                });\n                function split(string, separator, limit) {\n                    if (limit && typeof limit != \"number\" && isIterateeCall(string, separator, limit)) {\n                        separator = limit = undefined2;\n                    }\n                    limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;\n                    if (!limit) {\n                        return [];\n                    }\n                    string = toString(string);\n                    if (string && (typeof separator == \"string\" || separator != null && !isRegExp(separator))) {\n                        separator = baseToString(separator);\n                        if (!separator && hasUnicode(string)) {\n                            return castSlice(stringToArray(string), 0, limit);\n                        }\n                    }\n                    return string.split(separator, limit);\n                }\n                var startCase = createCompounder(function(result2, word, index) {\n                    return result2 + (index ? \" \" : \"\") + upperFirst(word);\n                });\n                function startsWith(string, target, position) {\n                    string = toString(string);\n                    position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);\n                    target = baseToString(target);\n                    return string.slice(position, position + target.length) == target;\n                }\n                function template(string, options, guard) {\n                    var settings = lodash.templateSettings;\n                    if (guard && isIterateeCall(string, options, guard)) {\n                        options = undefined2;\n                    }\n                    string = toString(string);\n                    options = assignInWith({}, options, settings, customDefaultsAssignIn);\n                    var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);\n                    var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = \"__p += '\";\n                    var reDelimiters = RegExp2((options.escape || reNoMatch).source + \"|\" + interpolate.source + \"|\" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + \"|\" + (options.evaluate || reNoMatch).source + \"|$\", \"g\");\n                    var sourceURL = \"//# sourceURL=\" + (hasOwnProperty.call(options, \"sourceURL\") ? (options.sourceURL + \"\").replace(/\\s/g, \" \") : \"lodash.templateSources[\" + ++templateCounter + \"]\") + \"\\n\";\n                    string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {\n                        interpolateValue || (interpolateValue = esTemplateValue);\n                        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);\n                        if (escapeValue) {\n                            isEscaping = true;\n                            source += \"' +\\n__e(\" + escapeValue + \") +\\n'\";\n                        }\n                        if (evaluateValue) {\n                            isEvaluating = true;\n                            source += \"';\\n\" + evaluateValue + \";\\n__p += '\";\n                        }\n                        if (interpolateValue) {\n                            source += \"' +\\n((__t = (\" + interpolateValue + \")) == null ? '' : __t) +\\n'\";\n                        }\n                        index = offset + match.length;\n                        return match;\n                    });\n                    source += \"';\\n\";\n                    var variable = hasOwnProperty.call(options, \"variable\") && options.variable;\n                    if (!variable) {\n                        source = \"with (obj) {\\n\" + source + \"\\n}\\n\";\n                    } else if (reForbiddenIdentifierChars.test(variable)) {\n                        throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);\n                    }\n                    source = (isEvaluating ? source.replace(reEmptyStringLeading, \"\") : source).replace(reEmptyStringMiddle, \"$1\").replace(reEmptyStringTrailing, \"$1;\");\n                    source = \"function(\" + (variable || \"obj\") + \") {\\n\" + (variable ? \"\" : \"obj || (obj = {});\\n\") + \"var __t, __p = ''\" + (isEscaping ? \", __e = _.escape\" : \"\") + (isEvaluating ? \", __j = Array.prototype.join;\\nfunction print() { __p += __j.call(arguments, '') }\\n\" : \";\\n\") + source + \"return __p\\n}\";\n                    var result2 = attempt(function() {\n                        return Function2(importsKeys, sourceURL + \"return \" + source).apply(undefined2, importsValues);\n                    });\n                    result2.source = source;\n                    if (isError(result2)) {\n                        throw result2;\n                    }\n                    return result2;\n                }\n                function toLower(value) {\n                    return toString(value).toLowerCase();\n                }\n                function toUpper(value) {\n                    return toString(value).toUpperCase();\n                }\n                function trim(string, chars, guard) {\n                    string = toString(string);\n                    if (string && (guard || chars === undefined2)) {\n                        return baseTrim(string);\n                    }\n                    if (!string || !(chars = baseToString(chars))) {\n                        return string;\n                    }\n                    var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;\n                    return castSlice(strSymbols, start, end).join(\"\");\n                }\n                function trimEnd(string, chars, guard) {\n                    string = toString(string);\n                    if (string && (guard || chars === undefined2)) {\n                        return string.slice(0, trimmedEndIndex(string) + 1);\n                    }\n                    if (!string || !(chars = baseToString(chars))) {\n                        return string;\n                    }\n                    var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;\n                    return castSlice(strSymbols, 0, end).join(\"\");\n                }\n                function trimStart(string, chars, guard) {\n                    string = toString(string);\n                    if (string && (guard || chars === undefined2)) {\n                        return string.replace(reTrimStart, \"\");\n                    }\n                    if (!string || !(chars = baseToString(chars))) {\n                        return string;\n                    }\n                    var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));\n                    return castSlice(strSymbols, start).join(\"\");\n                }\n                function truncate(string, options) {\n                    var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;\n                    if (isObject(options)) {\n                        var separator = \"separator\" in options ? options.separator : separator;\n                        length = \"length\" in options ? toInteger(options.length) : length;\n                        omission = \"omission\" in options ? baseToString(options.omission) : omission;\n                    }\n                    string = toString(string);\n                    var strLength = string.length;\n                    if (hasUnicode(string)) {\n                        var strSymbols = stringToArray(string);\n                        strLength = strSymbols.length;\n                    }\n                    if (length >= strLength) {\n                        return string;\n                    }\n                    var end = length - stringSize(omission);\n                    if (end < 1) {\n                        return omission;\n                    }\n                    var result2 = strSymbols ? castSlice(strSymbols, 0, end).join(\"\") : string.slice(0, end);\n                    if (separator === undefined2) {\n                        return result2 + omission;\n                    }\n                    if (strSymbols) {\n                        end += result2.length - end;\n                    }\n                    if (isRegExp(separator)) {\n                        if (string.slice(end).search(separator)) {\n                            var match, substring = result2;\n                            if (!separator.global) {\n                                separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + \"g\");\n                            }\n                            separator.lastIndex = 0;\n                            while(match = separator.exec(substring)){\n                                var newEnd = match.index;\n                            }\n                            result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);\n                        }\n                    } else if (string.indexOf(baseToString(separator), end) != end) {\n                        var index = result2.lastIndexOf(separator);\n                        if (index > -1) {\n                            result2 = result2.slice(0, index);\n                        }\n                    }\n                    return result2 + omission;\n                }\n                function unescape(string) {\n                    string = toString(string);\n                    return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;\n                }\n                var upperCase = createCompounder(function(result2, word, index) {\n                    return result2 + (index ? \" \" : \"\") + word.toUpperCase();\n                });\n                var upperFirst = createCaseFirst(\"toUpperCase\");\n                function words(string, pattern, guard) {\n                    string = toString(string);\n                    pattern = guard ? undefined2 : pattern;\n                    if (pattern === undefined2) {\n                        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);\n                    }\n                    return string.match(pattern) || [];\n                }\n                var attempt = baseRest(function(func, args) {\n                    try {\n                        return apply(func, undefined2, args);\n                    } catch (e) {\n                        return isError(e) ? e : new Error2(e);\n                    }\n                });\n                var bindAll = flatRest(function(object, methodNames) {\n                    arrayEach(methodNames, function(key) {\n                        key = toKey(key);\n                        baseAssignValue(object, key, bind(object[key], object));\n                    });\n                    return object;\n                });\n                function cond(pairs) {\n                    var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();\n                    pairs = !length ? [] : arrayMap(pairs, function(pair) {\n                        if (typeof pair[1] != \"function\") {\n                            throw new TypeError2(FUNC_ERROR_TEXT);\n                        }\n                        return [\n                            toIteratee(pair[0]),\n                            pair[1]\n                        ];\n                    });\n                    return baseRest(function(args) {\n                        var index = -1;\n                        while(++index < length){\n                            var pair = pairs[index];\n                            if (apply(pair[0], this, args)) {\n                                return apply(pair[1], this, args);\n                            }\n                        }\n                    });\n                }\n                function conforms(source) {\n                    return baseConforms(baseClone(source, CLONE_DEEP_FLAG));\n                }\n                function constant(value) {\n                    return function() {\n                        return value;\n                    };\n                }\n                function defaultTo(value, defaultValue) {\n                    return value == null || value !== value ? defaultValue : value;\n                }\n                var flow = createFlow();\n                var flowRight = createFlow(true);\n                function identity(value) {\n                    return value;\n                }\n                function iteratee(func) {\n                    return baseIteratee(typeof func == \"function\" ? func : baseClone(func, CLONE_DEEP_FLAG));\n                }\n                function matches(source) {\n                    return baseMatches(baseClone(source, CLONE_DEEP_FLAG));\n                }\n                function matchesProperty(path, srcValue) {\n                    return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));\n                }\n                var method = baseRest(function(path, args) {\n                    return function(object) {\n                        return baseInvoke(object, path, args);\n                    };\n                });\n                var methodOf = baseRest(function(object, args) {\n                    return function(path) {\n                        return baseInvoke(object, path, args);\n                    };\n                });\n                function mixin(object, source, options) {\n                    var props = keys(source), methodNames = baseFunctions(source, props);\n                    if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {\n                        options = source;\n                        source = object;\n                        object = this;\n                        methodNames = baseFunctions(source, keys(source));\n                    }\n                    var chain2 = !(isObject(options) && \"chain\" in options) || !!options.chain, isFunc = isFunction(object);\n                    arrayEach(methodNames, function(methodName) {\n                        var func = source[methodName];\n                        object[methodName] = func;\n                        if (isFunc) {\n                            object.prototype[methodName] = function() {\n                                var chainAll = this.__chain__;\n                                if (chain2 || chainAll) {\n                                    var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);\n                                    actions.push({\n                                        \"func\": func,\n                                        \"args\": arguments,\n                                        \"thisArg\": object\n                                    });\n                                    result2.__chain__ = chainAll;\n                                    return result2;\n                                }\n                                return func.apply(object, arrayPush([\n                                    this.value()\n                                ], arguments));\n                            };\n                        }\n                    });\n                    return object;\n                }\n                function noConflict() {\n                    if (root._ === this) {\n                        root._ = oldDash;\n                    }\n                    return this;\n                }\n                function noop() {}\n                function nthArg(n) {\n                    n = toInteger(n);\n                    return baseRest(function(args) {\n                        return baseNth(args, n);\n                    });\n                }\n                var over = createOver(arrayMap);\n                var overEvery = createOver(arrayEvery);\n                var overSome = createOver(arraySome);\n                function property(path) {\n                    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n                }\n                function propertyOf(object) {\n                    return function(path) {\n                        return object == null ? undefined2 : baseGet(object, path);\n                    };\n                }\n                var range = createRange();\n                var rangeRight = createRange(true);\n                function stubArray() {\n                    return [];\n                }\n                function stubFalse() {\n                    return false;\n                }\n                function stubObject() {\n                    return {};\n                }\n                function stubString() {\n                    return \"\";\n                }\n                function stubTrue() {\n                    return true;\n                }\n                function times(n, iteratee2) {\n                    n = toInteger(n);\n                    if (n < 1 || n > MAX_SAFE_INTEGER) {\n                        return [];\n                    }\n                    var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);\n                    iteratee2 = getIteratee(iteratee2);\n                    n -= MAX_ARRAY_LENGTH;\n                    var result2 = baseTimes(length, iteratee2);\n                    while(++index < n){\n                        iteratee2(index);\n                    }\n                    return result2;\n                }\n                function toPath(value) {\n                    if (isArray(value)) {\n                        return arrayMap(value, toKey);\n                    }\n                    return isSymbol(value) ? [\n                        value\n                    ] : copyArray(stringToPath(toString(value)));\n                }\n                function uniqueId(prefix) {\n                    var id = ++idCounter;\n                    return toString(prefix) + id;\n                }\n                var add = createMathOperation(function(augend, addend) {\n                    return augend + addend;\n                }, 0);\n                var ceil = createRound(\"ceil\");\n                var divide = createMathOperation(function(dividend, divisor) {\n                    return dividend / divisor;\n                }, 1);\n                var floor = createRound(\"floor\");\n                function max(array) {\n                    return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;\n                }\n                function maxBy(array, iteratee2) {\n                    return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;\n                }\n                function mean(array) {\n                    return baseMean(array, identity);\n                }\n                function meanBy(array, iteratee2) {\n                    return baseMean(array, getIteratee(iteratee2, 2));\n                }\n                function min(array) {\n                    return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;\n                }\n                function minBy(array, iteratee2) {\n                    return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;\n                }\n                var multiply = createMathOperation(function(multiplier, multiplicand) {\n                    return multiplier * multiplicand;\n                }, 1);\n                var round = createRound(\"round\");\n                var subtract = createMathOperation(function(minuend, subtrahend) {\n                    return minuend - subtrahend;\n                }, 0);\n                function sum(array) {\n                    return array && array.length ? baseSum(array, identity) : 0;\n                }\n                function sumBy(array, iteratee2) {\n                    return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;\n                }\n                lodash.after = after;\n                lodash.ary = ary;\n                lodash.assign = assign;\n                lodash.assignIn = assignIn;\n                lodash.assignInWith = assignInWith;\n                lodash.assignWith = assignWith;\n                lodash.at = at;\n                lodash.before = before;\n                lodash.bind = bind;\n                lodash.bindAll = bindAll;\n                lodash.bindKey = bindKey;\n                lodash.castArray = castArray;\n                lodash.chain = chain;\n                lodash.chunk = chunk;\n                lodash.compact = compact;\n                lodash.concat = concat;\n                lodash.cond = cond;\n                lodash.conforms = conforms;\n                lodash.constant = constant;\n                lodash.countBy = countBy;\n                lodash.create = create;\n                lodash.curry = curry;\n                lodash.curryRight = curryRight;\n                lodash.debounce = debounce;\n                lodash.defaults = defaults;\n                lodash.defaultsDeep = defaultsDeep;\n                lodash.defer = defer;\n                lodash.delay = delay;\n                lodash.difference = difference;\n                lodash.differenceBy = differenceBy;\n                lodash.differenceWith = differenceWith;\n                lodash.drop = drop;\n                lodash.dropRight = dropRight;\n                lodash.dropRightWhile = dropRightWhile;\n                lodash.dropWhile = dropWhile;\n                lodash.fill = fill;\n                lodash.filter = filter;\n                lodash.flatMap = flatMap;\n                lodash.flatMapDeep = flatMapDeep;\n                lodash.flatMapDepth = flatMapDepth;\n                lodash.flatten = flatten;\n                lodash.flattenDeep = flattenDeep;\n                lodash.flattenDepth = flattenDepth;\n                lodash.flip = flip;\n                lodash.flow = flow;\n                lodash.flowRight = flowRight;\n                lodash.fromPairs = fromPairs;\n                lodash.functions = functions;\n                lodash.functionsIn = functionsIn;\n                lodash.groupBy = groupBy;\n                lodash.initial = initial;\n                lodash.intersection = intersection;\n                lodash.intersectionBy = intersectionBy;\n                lodash.intersectionWith = intersectionWith;\n                lodash.invert = invert;\n                lodash.invertBy = invertBy;\n                lodash.invokeMap = invokeMap;\n                lodash.iteratee = iteratee;\n                lodash.keyBy = keyBy;\n                lodash.keys = keys;\n                lodash.keysIn = keysIn;\n                lodash.map = map;\n                lodash.mapKeys = mapKeys;\n                lodash.mapValues = mapValues;\n                lodash.matches = matches;\n                lodash.matchesProperty = matchesProperty;\n                lodash.memoize = memoize2;\n                lodash.merge = merge;\n                lodash.mergeWith = mergeWith;\n                lodash.method = method;\n                lodash.methodOf = methodOf;\n                lodash.mixin = mixin;\n                lodash.negate = negate;\n                lodash.nthArg = nthArg;\n                lodash.omit = omit;\n                lodash.omitBy = omitBy;\n                lodash.once = once;\n                lodash.orderBy = orderBy;\n                lodash.over = over;\n                lodash.overArgs = overArgs;\n                lodash.overEvery = overEvery;\n                lodash.overSome = overSome;\n                lodash.partial = partial;\n                lodash.partialRight = partialRight;\n                lodash.partition = partition;\n                lodash.pick = pick;\n                lodash.pickBy = pickBy;\n                lodash.property = property;\n                lodash.propertyOf = propertyOf;\n                lodash.pull = pull;\n                lodash.pullAll = pullAll;\n                lodash.pullAllBy = pullAllBy;\n                lodash.pullAllWith = pullAllWith;\n                lodash.pullAt = pullAt;\n                lodash.range = range;\n                lodash.rangeRight = rangeRight;\n                lodash.rearg = rearg;\n                lodash.reject = reject;\n                lodash.remove = remove;\n                lodash.rest = rest;\n                lodash.reverse = reverse;\n                lodash.sampleSize = sampleSize;\n                lodash.set = set;\n                lodash.setWith = setWith;\n                lodash.shuffle = shuffle;\n                lodash.slice = slice;\n                lodash.sortBy = sortBy;\n                lodash.sortedUniq = sortedUniq;\n                lodash.sortedUniqBy = sortedUniqBy;\n                lodash.split = split;\n                lodash.spread = spread;\n                lodash.tail = tail;\n                lodash.take = take;\n                lodash.takeRight = takeRight;\n                lodash.takeRightWhile = takeRightWhile;\n                lodash.takeWhile = takeWhile;\n                lodash.tap = tap;\n                lodash.throttle = throttle;\n                lodash.thru = thru;\n                lodash.toArray = toArray;\n                lodash.toPairs = toPairs;\n                lodash.toPairsIn = toPairsIn;\n                lodash.toPath = toPath;\n                lodash.toPlainObject = toPlainObject;\n                lodash.transform = transform;\n                lodash.unary = unary;\n                lodash.union = union;\n                lodash.unionBy = unionBy;\n                lodash.unionWith = unionWith;\n                lodash.uniq = uniq;\n                lodash.uniqBy = uniqBy;\n                lodash.uniqWith = uniqWith;\n                lodash.unset = unset;\n                lodash.unzip = unzip;\n                lodash.unzipWith = unzipWith;\n                lodash.update = update;\n                lodash.updateWith = updateWith;\n                lodash.values = values;\n                lodash.valuesIn = valuesIn;\n                lodash.without = without;\n                lodash.words = words;\n                lodash.wrap = wrap;\n                lodash.xor = xor;\n                lodash.xorBy = xorBy;\n                lodash.xorWith = xorWith;\n                lodash.zip = zip;\n                lodash.zipObject = zipObject;\n                lodash.zipObjectDeep = zipObjectDeep;\n                lodash.zipWith = zipWith;\n                lodash.entries = toPairs;\n                lodash.entriesIn = toPairsIn;\n                lodash.extend = assignIn;\n                lodash.extendWith = assignInWith;\n                mixin(lodash, lodash);\n                lodash.add = add;\n                lodash.attempt = attempt;\n                lodash.camelCase = camelCase;\n                lodash.capitalize = capitalize;\n                lodash.ceil = ceil;\n                lodash.clamp = clamp;\n                lodash.clone = clone;\n                lodash.cloneDeep = cloneDeep;\n                lodash.cloneDeepWith = cloneDeepWith;\n                lodash.cloneWith = cloneWith;\n                lodash.conformsTo = conformsTo;\n                lodash.deburr = deburr;\n                lodash.defaultTo = defaultTo;\n                lodash.divide = divide;\n                lodash.endsWith = endsWith;\n                lodash.eq = eq;\n                lodash.escape = escape;\n                lodash.escapeRegExp = escapeRegExp;\n                lodash.every = every;\n                lodash.find = find;\n                lodash.findIndex = findIndex;\n                lodash.findKey = findKey;\n                lodash.findLast = findLast;\n                lodash.findLastIndex = findLastIndex;\n                lodash.findLastKey = findLastKey;\n                lodash.floor = floor;\n                lodash.forEach = forEach;\n                lodash.forEachRight = forEachRight;\n                lodash.forIn = forIn;\n                lodash.forInRight = forInRight;\n                lodash.forOwn = forOwn;\n                lodash.forOwnRight = forOwnRight;\n                lodash.get = get;\n                lodash.gt = gt;\n                lodash.gte = gte;\n                lodash.has = has;\n                lodash.hasIn = hasIn;\n                lodash.head = head;\n                lodash.identity = identity;\n                lodash.includes = includes;\n                lodash.indexOf = indexOf;\n                lodash.inRange = inRange;\n                lodash.invoke = invoke;\n                lodash.isArguments = isArguments;\n                lodash.isArray = isArray;\n                lodash.isArrayBuffer = isArrayBuffer;\n                lodash.isArrayLike = isArrayLike;\n                lodash.isArrayLikeObject = isArrayLikeObject;\n                lodash.isBoolean = isBoolean;\n                lodash.isBuffer = isBuffer;\n                lodash.isDate = isDate;\n                lodash.isElement = isElement;\n                lodash.isEmpty = isEmpty;\n                lodash.isEqual = isEqual;\n                lodash.isEqualWith = isEqualWith;\n                lodash.isError = isError;\n                lodash.isFinite = isFinite2;\n                lodash.isFunction = isFunction;\n                lodash.isInteger = isInteger;\n                lodash.isLength = isLength;\n                lodash.isMap = isMap;\n                lodash.isMatch = isMatch;\n                lodash.isMatchWith = isMatchWith;\n                lodash.isNaN = isNaN2;\n                lodash.isNative = isNative;\n                lodash.isNil = isNil;\n                lodash.isNull = isNull;\n                lodash.isNumber = isNumber;\n                lodash.isObject = isObject;\n                lodash.isObjectLike = isObjectLike;\n                lodash.isPlainObject = isPlainObject;\n                lodash.isRegExp = isRegExp;\n                lodash.isSafeInteger = isSafeInteger;\n                lodash.isSet = isSet;\n                lodash.isString = isString;\n                lodash.isSymbol = isSymbol;\n                lodash.isTypedArray = isTypedArray;\n                lodash.isUndefined = isUndefined;\n                lodash.isWeakMap = isWeakMap;\n                lodash.isWeakSet = isWeakSet;\n                lodash.join = join;\n                lodash.kebabCase = kebabCase;\n                lodash.last = last;\n                lodash.lastIndexOf = lastIndexOf;\n                lodash.lowerCase = lowerCase;\n                lodash.lowerFirst = lowerFirst;\n                lodash.lt = lt;\n                lodash.lte = lte;\n                lodash.max = max;\n                lodash.maxBy = maxBy;\n                lodash.mean = mean;\n                lodash.meanBy = meanBy;\n                lodash.min = min;\n                lodash.minBy = minBy;\n                lodash.stubArray = stubArray;\n                lodash.stubFalse = stubFalse;\n                lodash.stubObject = stubObject;\n                lodash.stubString = stubString;\n                lodash.stubTrue = stubTrue;\n                lodash.multiply = multiply;\n                lodash.nth = nth;\n                lodash.noConflict = noConflict;\n                lodash.noop = noop;\n                lodash.now = now;\n                lodash.pad = pad;\n                lodash.padEnd = padEnd;\n                lodash.padStart = padStart;\n                lodash.parseInt = parseInt2;\n                lodash.random = random;\n                lodash.reduce = reduce;\n                lodash.reduceRight = reduceRight;\n                lodash.repeat = repeat;\n                lodash.replace = replace;\n                lodash.result = result;\n                lodash.round = round;\n                lodash.runInContext = runInContext2;\n                lodash.sample = sample;\n                lodash.size = size;\n                lodash.snakeCase = snakeCase;\n                lodash.some = some;\n                lodash.sortedIndex = sortedIndex;\n                lodash.sortedIndexBy = sortedIndexBy;\n                lodash.sortedIndexOf = sortedIndexOf;\n                lodash.sortedLastIndex = sortedLastIndex;\n                lodash.sortedLastIndexBy = sortedLastIndexBy;\n                lodash.sortedLastIndexOf = sortedLastIndexOf;\n                lodash.startCase = startCase;\n                lodash.startsWith = startsWith;\n                lodash.subtract = subtract;\n                lodash.sum = sum;\n                lodash.sumBy = sumBy;\n                lodash.template = template;\n                lodash.times = times;\n                lodash.toFinite = toFinite;\n                lodash.toInteger = toInteger;\n                lodash.toLength = toLength;\n                lodash.toLower = toLower;\n                lodash.toNumber = toNumber;\n                lodash.toSafeInteger = toSafeInteger;\n                lodash.toString = toString;\n                lodash.toUpper = toUpper;\n                lodash.trim = trim;\n                lodash.trimEnd = trimEnd;\n                lodash.trimStart = trimStart;\n                lodash.truncate = truncate;\n                lodash.unescape = unescape;\n                lodash.uniqueId = uniqueId;\n                lodash.upperCase = upperCase;\n                lodash.upperFirst = upperFirst;\n                lodash.each = forEach;\n                lodash.eachRight = forEachRight;\n                lodash.first = head;\n                mixin(lodash, function() {\n                    var source = {};\n                    baseForOwn(lodash, function(func, methodName) {\n                        if (!hasOwnProperty.call(lodash.prototype, methodName)) {\n                            source[methodName] = func;\n                        }\n                    });\n                    return source;\n                }(), {\n                    \"chain\": false\n                });\n                lodash.VERSION = VERSION;\n                arrayEach([\n                    \"bind\",\n                    \"bindKey\",\n                    \"curry\",\n                    \"curryRight\",\n                    \"partial\",\n                    \"partialRight\"\n                ], function(methodName) {\n                    lodash[methodName].placeholder = lodash;\n                });\n                arrayEach([\n                    \"drop\",\n                    \"take\"\n                ], function(methodName, index) {\n                    LazyWrapper.prototype[methodName] = function(n) {\n                        n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);\n                        var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();\n                        if (result2.__filtered__) {\n                            result2.__takeCount__ = nativeMin(n, result2.__takeCount__);\n                        } else {\n                            result2.__views__.push({\n                                \"size\": nativeMin(n, MAX_ARRAY_LENGTH),\n                                \"type\": methodName + (result2.__dir__ < 0 ? \"Right\" : \"\")\n                            });\n                        }\n                        return result2;\n                    };\n                    LazyWrapper.prototype[methodName + \"Right\"] = function(n) {\n                        return this.reverse()[methodName](n).reverse();\n                    };\n                });\n                arrayEach([\n                    \"filter\",\n                    \"map\",\n                    \"takeWhile\"\n                ], function(methodName, index) {\n                    var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;\n                    LazyWrapper.prototype[methodName] = function(iteratee2) {\n                        var result2 = this.clone();\n                        result2.__iteratees__.push({\n                            \"iteratee\": getIteratee(iteratee2, 3),\n                            \"type\": type\n                        });\n                        result2.__filtered__ = result2.__filtered__ || isFilter;\n                        return result2;\n                    };\n                });\n                arrayEach([\n                    \"head\",\n                    \"last\"\n                ], function(methodName, index) {\n                    var takeName = \"take\" + (index ? \"Right\" : \"\");\n                    LazyWrapper.prototype[methodName] = function() {\n                        return this[takeName](1).value()[0];\n                    };\n                });\n                arrayEach([\n                    \"initial\",\n                    \"tail\"\n                ], function(methodName, index) {\n                    var dropName = \"drop\" + (index ? \"\" : \"Right\");\n                    LazyWrapper.prototype[methodName] = function() {\n                        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);\n                    };\n                });\n                LazyWrapper.prototype.compact = function() {\n                    return this.filter(identity);\n                };\n                LazyWrapper.prototype.find = function(predicate) {\n                    return this.filter(predicate).head();\n                };\n                LazyWrapper.prototype.findLast = function(predicate) {\n                    return this.reverse().find(predicate);\n                };\n                LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {\n                    if (typeof path == \"function\") {\n                        return new LazyWrapper(this);\n                    }\n                    return this.map(function(value) {\n                        return baseInvoke(value, path, args);\n                    });\n                });\n                LazyWrapper.prototype.reject = function(predicate) {\n                    return this.filter(negate(getIteratee(predicate)));\n                };\n                LazyWrapper.prototype.slice = function(start, end) {\n                    start = toInteger(start);\n                    var result2 = this;\n                    if (result2.__filtered__ && (start > 0 || end < 0)) {\n                        return new LazyWrapper(result2);\n                    }\n                    if (start < 0) {\n                        result2 = result2.takeRight(-start);\n                    } else if (start) {\n                        result2 = result2.drop(start);\n                    }\n                    if (end !== undefined2) {\n                        end = toInteger(end);\n                        result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);\n                    }\n                    return result2;\n                };\n                LazyWrapper.prototype.takeRightWhile = function(predicate) {\n                    return this.reverse().takeWhile(predicate).reverse();\n                };\n                LazyWrapper.prototype.toArray = function() {\n                    return this.take(MAX_ARRAY_LENGTH);\n                };\n                baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n                    var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? \"take\" + (methodName == \"last\" ? \"Right\" : \"\") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);\n                    if (!lodashFunc) {\n                        return;\n                    }\n                    lodash.prototype[methodName] = function() {\n                        var value = this.__wrapped__, args = isTaker ? [\n                            1\n                        ] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);\n                        var interceptor = function(value2) {\n                            var result3 = lodashFunc.apply(lodash, arrayPush([\n                                value2\n                            ], args));\n                            return isTaker && chainAll ? result3[0] : result3;\n                        };\n                        if (useLazy && checkIteratee && typeof iteratee2 == \"function\" && iteratee2.length != 1) {\n                            isLazy = useLazy = false;\n                        }\n                        var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;\n                        if (!retUnwrapped && useLazy) {\n                            value = onlyLazy ? value : new LazyWrapper(this);\n                            var result2 = func.apply(value, args);\n                            result2.__actions__.push({\n                                \"func\": thru,\n                                \"args\": [\n                                    interceptor\n                                ],\n                                \"thisArg\": undefined2\n                            });\n                            return new LodashWrapper(result2, chainAll);\n                        }\n                        if (isUnwrapped && onlyLazy) {\n                            return func.apply(this, args);\n                        }\n                        result2 = this.thru(interceptor);\n                        return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;\n                    };\n                });\n                arrayEach([\n                    \"pop\",\n                    \"push\",\n                    \"shift\",\n                    \"sort\",\n                    \"splice\",\n                    \"unshift\"\n                ], function(methodName) {\n                    var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? \"tap\" : \"thru\", retUnwrapped = /^(?:pop|shift)$/.test(methodName);\n                    lodash.prototype[methodName] = function() {\n                        var args = arguments;\n                        if (retUnwrapped && !this.__chain__) {\n                            var value = this.value();\n                            return func.apply(isArray(value) ? value : [], args);\n                        }\n                        return this[chainName](function(value2) {\n                            return func.apply(isArray(value2) ? value2 : [], args);\n                        });\n                    };\n                });\n                baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n                    var lodashFunc = lodash[methodName];\n                    if (lodashFunc) {\n                        var key = lodashFunc.name + \"\";\n                        if (!hasOwnProperty.call(realNames, key)) {\n                            realNames[key] = [];\n                        }\n                        realNames[key].push({\n                            \"name\": methodName,\n                            \"func\": lodashFunc\n                        });\n                    }\n                });\n                realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [\n                    {\n                        \"name\": \"wrapper\",\n                        \"func\": undefined2\n                    }\n                ];\n                LazyWrapper.prototype.clone = lazyClone;\n                LazyWrapper.prototype.reverse = lazyReverse;\n                LazyWrapper.prototype.value = lazyValue;\n                lodash.prototype.at = wrapperAt;\n                lodash.prototype.chain = wrapperChain;\n                lodash.prototype.commit = wrapperCommit;\n                lodash.prototype.next = wrapperNext;\n                lodash.prototype.plant = wrapperPlant;\n                lodash.prototype.reverse = wrapperReverse;\n                lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;\n                lodash.prototype.first = lodash.prototype.head;\n                if (symIterator) {\n                    lodash.prototype[symIterator] = wrapperToIterator;\n                }\n                return lodash;\n            };\n            var _ = runInContext();\n            if (typeof define == \"function\" && typeof define.amd == \"object\" && define.amd) {\n                root._ = _;\n                define(function() {\n                    return _;\n                });\n            } else if (freeModule) {\n                (freeModule.exports = _)._ = _;\n                freeExports._ = _;\n            } else {\n                root._ = _;\n            }\n        }).call(exports);\n    }\n});\n// ../../node_modules/iota-array/iota.js\nvar require_iota = __commonJS({\n    \"../../node_modules/iota-array/iota.js\" (exports, module) {\n        \"use strict\";\n        function iota(n) {\n            var result = new Array(n);\n            for(var i = 0; i < n; ++i){\n                result[i] = i;\n            }\n            return result;\n        }\n        module.exports = iota;\n    }\n});\n// ../../node_modules/is-buffer/index.js\nvar require_is_buffer = __commonJS({\n    \"../../node_modules/is-buffer/index.js\" (exports, module) {\n        module.exports = function(obj) {\n            return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);\n        };\n        function isBuffer(obj) {\n            return !!obj.constructor && typeof obj.constructor.isBuffer === \"function\" && obj.constructor.isBuffer(obj);\n        }\n        function isSlowBuffer(obj) {\n            return typeof obj.readFloatLE === \"function\" && typeof obj.slice === \"function\" && isBuffer(obj.slice(0, 0));\n        }\n    }\n});\n// ../../node_modules/ndarray/ndarray.js\nvar require_ndarray = __commonJS({\n    \"../../node_modules/ndarray/ndarray.js\" (exports, module) {\n        var iota = require_iota();\n        var isBuffer = require_is_buffer();\n        var hasTypedArrays = typeof Float64Array !== \"undefined\";\n        function compare1st(a, b) {\n            return a[0] - b[0];\n        }\n        function order() {\n            var stride = this.stride;\n            var terms = new Array(stride.length);\n            var i;\n            for(i = 0; i < terms.length; ++i){\n                terms[i] = [\n                    Math.abs(stride[i]),\n                    i\n                ];\n            }\n            terms.sort(compare1st);\n            var result = new Array(terms.length);\n            for(i = 0; i < result.length; ++i){\n                result[i] = terms[i][1];\n            }\n            return result;\n        }\n        function compileConstructor(dtype, dimension) {\n            var className = [\n                \"View\",\n                dimension,\n                \"d\",\n                dtype\n            ].join(\"\");\n            if (dimension < 0) {\n                className = \"View_Nil\" + dtype;\n            }\n            var useGetters = dtype === \"generic\";\n            if (dimension === -1) {\n                var code = \"function \" + className + \"(a){this.data=a;};var proto=\" + className + \".prototype;proto.dtype='\" + dtype + \"';proto.index=function(){return -1};proto.size=0;proto.dimension=-1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function(){return new \" + className + \"(this.data);};proto.get=proto.set=function(){};proto.pick=function(){return null};return function construct_\" + className + \"(a){return new \" + className + \"(a);}\";\n                var procedure = new Function(code);\n                return procedure();\n            } else if (dimension === 0) {\n                var code = \"function \" + className + \"(a,d) {this.data = a;this.offset = d};var proto=\" + className + \".prototype;proto.dtype='\" + dtype + \"';proto.index=function(){return this.offset};proto.dimension=0;proto.size=1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function \" + className + \"_copy() {return new \" + className + \"(this.data,this.offset)};proto.pick=function \" + className + \"_pick(){return TrivialArray(this.data);};proto.valueOf=proto.get=function \" + className + \"_get(){return \" + (useGetters ? \"this.data.get(this.offset)\" : \"this.data[this.offset]\") + \"};proto.set=function \" + className + \"_set(v){return \" + (useGetters ? \"this.data.set(this.offset,v)\" : \"this.data[this.offset]=v\") + \"};return function construct_\" + className + \"(a,b,c,d){return new \" + className + \"(a,d)}\";\n                var procedure = new Function(\"TrivialArray\", code);\n                return procedure(CACHED_CONSTRUCTORS[dtype][0]);\n            }\n            var code = [\n                \"'use strict'\"\n            ];\n            var indices = iota(dimension);\n            var args = indices.map(function(i2) {\n                return \"i\" + i2;\n            });\n            var index_str = \"this.offset+\" + indices.map(function(i2) {\n                return \"this.stride[\" + i2 + \"]*i\" + i2;\n            }).join(\"+\");\n            var shapeArg = indices.map(function(i2) {\n                return \"b\" + i2;\n            }).join(\",\");\n            var strideArg = indices.map(function(i2) {\n                return \"c\" + i2;\n            }).join(\",\");\n            code.push(\"function \" + className + \"(a,\" + shapeArg + \",\" + strideArg + \",d){this.data=a\", \"this.shape=[\" + shapeArg + \"]\", \"this.stride=[\" + strideArg + \"]\", \"this.offset=d|0}\", \"var proto=\" + className + \".prototype\", \"proto.dtype='\" + dtype + \"'\", \"proto.dimension=\" + dimension);\n            code.push(\"Object.defineProperty(proto,'size',{get:function \" + className + \"_size(){return \" + indices.map(function(i2) {\n                return \"this.shape[\" + i2 + \"]\";\n            }).join(\"*\"), \"}})\");\n            if (dimension === 1) {\n                code.push(\"proto.order=[0]\");\n            } else {\n                code.push(\"Object.defineProperty(proto,'order',{get:\");\n                if (dimension < 4) {\n                    code.push(\"function \" + className + \"_order(){\");\n                    if (dimension === 2) {\n                        code.push(\"return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})\");\n                    } else if (dimension === 3) {\n                        code.push(\"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);if(s0>s1){if(s1>s2){return [2,1,0];}else if(s0>s2){return [1,2,0];}else{return [1,0,2];}}else if(s0>s2){return [2,0,1];}else if(s2>s1){return [0,1,2];}else{return [0,2,1];}}})\");\n                    }\n                } else {\n                    code.push(\"ORDER})\");\n                }\n            }\n            code.push(\"proto.set=function \" + className + \"_set(\" + args.join(\",\") + \",v){\");\n            if (useGetters) {\n                code.push(\"return this.data.set(\" + index_str + \",v)}\");\n            } else {\n                code.push(\"return this.data[\" + index_str + \"]=v}\");\n            }\n            code.push(\"proto.get=function \" + className + \"_get(\" + args.join(\",\") + \"){\");\n            if (useGetters) {\n                code.push(\"return this.data.get(\" + index_str + \")}\");\n            } else {\n                code.push(\"return this.data[\" + index_str + \"]}\");\n            }\n            code.push(\"proto.index=function \" + className + \"_index(\", args.join(), \"){return \" + index_str + \"}\");\n            code.push(\"proto.hi=function \" + className + \"_hi(\" + args.join(\",\") + \"){return new \" + className + \"(this.data,\" + indices.map(function(i2) {\n                return [\n                    \"(typeof i\",\n                    i2,\n                    \"!=='number'||i\",\n                    i2,\n                    \"<0)?this.shape[\",\n                    i2,\n                    \"]:i\",\n                    i2,\n                    \"|0\"\n                ].join(\"\");\n            }).join(\",\") + \",\" + indices.map(function(i2) {\n                return \"this.stride[\" + i2 + \"]\";\n            }).join(\",\") + \",this.offset)}\");\n            var a_vars = indices.map(function(i2) {\n                return \"a\" + i2 + \"=this.shape[\" + i2 + \"]\";\n            });\n            var c_vars = indices.map(function(i2) {\n                return \"c\" + i2 + \"=this.stride[\" + i2 + \"]\";\n            });\n            code.push(\"proto.lo=function \" + className + \"_lo(\" + args.join(\",\") + \"){var b=this.offset,d=0,\" + a_vars.join(\",\") + \",\" + c_vars.join(\",\"));\n            for(var i = 0; i < dimension; ++i){\n                code.push(\"if(typeof i\" + i + \"==='number'&&i\" + i + \">=0){d=i\" + i + \"|0;b+=c\" + i + \"*d;a\" + i + \"-=d}\");\n            }\n            code.push(\"return new \" + className + \"(this.data,\" + indices.map(function(i2) {\n                return \"a\" + i2;\n            }).join(\",\") + \",\" + indices.map(function(i2) {\n                return \"c\" + i2;\n            }).join(\",\") + \",b)}\");\n            code.push(\"proto.step=function \" + className + \"_step(\" + args.join(\",\") + \"){var \" + indices.map(function(i2) {\n                return \"a\" + i2 + \"=this.shape[\" + i2 + \"]\";\n            }).join(\",\") + \",\" + indices.map(function(i2) {\n                return \"b\" + i2 + \"=this.stride[\" + i2 + \"]\";\n            }).join(\",\") + \",c=this.offset,d=0,ceil=Math.ceil\");\n            for(var i = 0; i < dimension; ++i){\n                code.push(\"if(typeof i\" + i + \"==='number'){d=i\" + i + \"|0;if(d<0){c+=b\" + i + \"*(a\" + i + \"-1);a\" + i + \"=ceil(-a\" + i + \"/d)}else{a\" + i + \"=ceil(a\" + i + \"/d)}b\" + i + \"*=d}\");\n            }\n            code.push(\"return new \" + className + \"(this.data,\" + indices.map(function(i2) {\n                return \"a\" + i2;\n            }).join(\",\") + \",\" + indices.map(function(i2) {\n                return \"b\" + i2;\n            }).join(\",\") + \",c)}\");\n            var tShape = new Array(dimension);\n            var tStride = new Array(dimension);\n            for(var i = 0; i < dimension; ++i){\n                tShape[i] = \"a[i\" + i + \"]\";\n                tStride[i] = \"b[i\" + i + \"]\";\n            }\n            code.push(\"proto.transpose=function \" + className + \"_transpose(\" + args + \"){\" + args.map(function(n, idx) {\n                return n + \"=(\" + n + \"===undefined?\" + idx + \":\" + n + \"|0)\";\n            }).join(\";\"), \"var a=this.shape,b=this.stride;return new \" + className + \"(this.data,\" + tShape.join(\",\") + \",\" + tStride.join(\",\") + \",this.offset)}\");\n            code.push(\"proto.pick=function \" + className + \"_pick(\" + args + \"){var a=[],b=[],c=this.offset\");\n            for(var i = 0; i < dimension; ++i){\n                code.push(\"if(typeof i\" + i + \"==='number'&&i\" + i + \">=0){c=(c+this.stride[\" + i + \"]*i\" + i + \")|0}else{a.push(this.shape[\" + i + \"]);b.push(this.stride[\" + i + \"])}\");\n            }\n            code.push(\"var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}\");\n            code.push(\"return function construct_\" + className + \"(data,shape,stride,offset){return new \" + className + \"(data,\" + indices.map(function(i2) {\n                return \"shape[\" + i2 + \"]\";\n            }).join(\",\") + \",\" + indices.map(function(i2) {\n                return \"stride[\" + i2 + \"]\";\n            }).join(\",\") + \",offset)}\");\n            var procedure = new Function(\"CTOR_LIST\", \"ORDER\", code.join(\"\\n\"));\n            return procedure(CACHED_CONSTRUCTORS[dtype], order);\n        }\n        function arrayDType(data) {\n            if (isBuffer(data)) {\n                return \"buffer\";\n            }\n            if (hasTypedArrays) {\n                switch(Object.prototype.toString.call(data)){\n                    case \"[object Float64Array]\":\n                        return \"float64\";\n                    case \"[object Float32Array]\":\n                        return \"float32\";\n                    case \"[object Int8Array]\":\n                        return \"int8\";\n                    case \"[object Int16Array]\":\n                        return \"int16\";\n                    case \"[object Int32Array]\":\n                        return \"int32\";\n                    case \"[object Uint8Array]\":\n                        return \"uint8\";\n                    case \"[object Uint16Array]\":\n                        return \"uint16\";\n                    case \"[object Uint32Array]\":\n                        return \"uint32\";\n                    case \"[object Uint8ClampedArray]\":\n                        return \"uint8_clamped\";\n                    case \"[object BigInt64Array]\":\n                        return \"bigint64\";\n                    case \"[object BigUint64Array]\":\n                        return \"biguint64\";\n                }\n            }\n            if (Array.isArray(data)) {\n                return \"array\";\n            }\n            return \"generic\";\n        }\n        var CACHED_CONSTRUCTORS = {\n            \"float32\": [],\n            \"float64\": [],\n            \"int8\": [],\n            \"int16\": [],\n            \"int32\": [],\n            \"uint8\": [],\n            \"uint16\": [],\n            \"uint32\": [],\n            \"array\": [],\n            \"uint8_clamped\": [],\n            \"bigint64\": [],\n            \"biguint64\": [],\n            \"buffer\": [],\n            \"generic\": []\n        };\n        function wrappedNDArrayCtor(data, shape, stride, offset) {\n            if (data === void 0) {\n                var ctor = CACHED_CONSTRUCTORS.array[0];\n                return ctor([]);\n            } else if (typeof data === \"number\") {\n                data = [\n                    data\n                ];\n            }\n            if (shape === void 0) {\n                shape = [\n                    data.length\n                ];\n            }\n            var d = shape.length;\n            if (stride === void 0) {\n                stride = new Array(d);\n                for(var i = d - 1, sz = 1; i >= 0; --i){\n                    stride[i] = sz;\n                    sz *= shape[i];\n                }\n            }\n            if (offset === void 0) {\n                offset = 0;\n                for(var i = 0; i < d; ++i){\n                    if (stride[i] < 0) {\n                        offset -= (shape[i] - 1) * stride[i];\n                    }\n                }\n            }\n            var dtype = arrayDType(data);\n            var ctor_list = CACHED_CONSTRUCTORS[dtype];\n            while(ctor_list.length <= d + 1){\n                ctor_list.push(compileConstructor(dtype, ctor_list.length - 1));\n            }\n            var ctor = ctor_list[d + 1];\n            return ctor(data, shape, stride, offset);\n        }\n        module.exports = wrappedNDArrayCtor;\n    }\n});\n// src/api/v1.ts\nvar import_lodash = __toESM(require_lodash());\n// src/utils.ts\nvar import_ndarray2 = __toESM(require_ndarray());\n// src/MimeType.ts\nvar MimeType = class _MimeType {\n    constructor(type, params){\n        this.type = \"application/octet-stream\";\n        this.params = {};\n        this.type = type;\n        this.params = params;\n    }\n    toString() {\n        const paramsStr = [];\n        for(const key in this.params){\n            const value = this.params[key];\n            paramsStr.push(`${key}=${value}`);\n        }\n        return [\n            this.type,\n            ...paramsStr\n        ].join(\";\");\n    }\n    static create(type, params) {\n        return new _MimeType(type, params);\n    }\n    isIdentical(other) {\n        return this.type === other.type && this.params === other.params;\n    }\n    isEqual(other) {\n        return this.type === other.type;\n    }\n    static fromString(mimeType) {\n        const [type, ...paramsArr] = mimeType.split(\";\");\n        const params = {};\n        for (const param of paramsArr){\n            const [key, value] = param.split(\"=\");\n            params[key.trim()] = value.trim();\n        }\n        return new _MimeType(type, params);\n    }\n};\n// src/codecs.ts\nvar import_ndarray = __toESM(require_ndarray());\nasync function imageDecode(blob) {\n    const mime = MimeType.fromString(blob.type);\n    switch(mime.type){\n        case \"image/x-alpha8\":\n            {\n                const width = parseInt(mime.params[\"width\"]);\n                const height = parseInt(mime.params[\"height\"]);\n                return (0, import_ndarray.default)(new Uint8Array(await blob.arrayBuffer()), [\n                    height,\n                    width,\n                    1\n                ]);\n            }\n        case \"image/x-rgba8\":\n            {\n                const width = parseInt(mime.params[\"width\"]);\n                const height = parseInt(mime.params[\"height\"]);\n                return (0, import_ndarray.default)(new Uint8Array(await blob.arrayBuffer()), [\n                    height,\n                    width,\n                    4\n                ]);\n            }\n        case \"application/octet-stream\":\n        case `image/png`:\n        case `image/jpeg`:\n        case `image/jpg`:\n        case `image/webp`:\n            {\n                const imageBitmap = await createImageBitmap(blob);\n                const imageData = imageBitmapToImageData(imageBitmap);\n                return (0, import_ndarray.default)(new Uint8Array(imageData.data), [\n                    imageData.height,\n                    imageData.width,\n                    4\n                ]);\n            }\n        default:\n            throw new Error(`Invalid format: ${mime.type} with params: ${mime.params}`);\n    }\n}\nasync function imageEncode(imageTensor, quality = 0.8, format = \"image/png\") {\n    const [height, width, channels] = imageTensor.shape;\n    switch(format){\n        case \"image/x-alpha8\":\n        case \"image/x-rgba8\":\n            {\n                const mime = MimeType.create(format, {\n                    width: width.toString(),\n                    height: height.toString()\n                });\n                return new Blob([\n                    imageTensor.data\n                ], {\n                    type: mime.toString()\n                });\n            }\n        case `image/png`:\n        case `image/jpeg`:\n        case `image/webp`:\n            {\n                const imageData = new ImageData(new Uint8ClampedArray(imageTensor.data), width, height);\n                var canvas = createCanvas(imageData.width, imageData.height);\n                var ctx = canvas.getContext(\"2d\");\n                ctx.putImageData(imageData, 0, 0);\n                return canvas.convertToBlob({\n                    quality,\n                    type: format\n                });\n            }\n        default:\n            throw new Error(`Invalid format: ${format}`);\n    }\n}\n// src/url.ts\nfunction isAbsoluteURI(url) {\n    const regExp = new RegExp(\"^(?:[a-z+]+:)?//\", \"i\");\n    return regExp.test(url);\n}\nfunction ensureAbsoluteURI(url, baseUrl) {\n    if (isAbsoluteURI(url)) {\n        return url;\n    } else {\n        return new URL(url, baseUrl).href;\n    }\n}\n// src/utils.ts\nfunction imageBitmapToImageData(imageBitmap) {\n    var canvas = createCanvas(imageBitmap.width, imageBitmap.height);\n    var ctx = canvas.getContext(\"2d\");\n    ctx.drawImage(imageBitmap, 0, 0);\n    return ctx.getImageData(0, 0, canvas.width, canvas.height);\n}\nfunction createTypeArray(length) {\n    if (typeof Uint8Array !== \"undefined\") {\n        return new Uint8Array(length);\n    } else if (typeof Uint8ClampedArray !== \"undefined\") {\n        return new Uint8ClampedArray(length);\n    } else if (typeof Uint16Array !== \"undefined\") {\n        return new Uint16Array(length);\n    } else if (typeof Uint32Array !== \"undefined\") {\n        return new Uint32Array(length);\n    } else if (typeof Float32Array !== \"undefined\") {\n        return new Float32Array(length);\n    } else if (typeof Float64Array !== \"undefined\") {\n        return new Float64Array(length);\n    } else {\n        throw new Error(\"TypedArray not supported\");\n    }\n}\nfunction tensorResizeBilinear(imageTensor, newWidth, newHeight, proportional = false) {\n    const [srcHeight, srcWidth, srcChannels] = imageTensor.shape;\n    let scaleX = srcWidth / newWidth;\n    let scaleY = srcHeight / newHeight;\n    if (proportional) {\n        const downscaling = Math.max(scaleX, scaleY) > 1;\n        scaleX = scaleY = downscaling ? Math.max(scaleX, scaleY) : Math.min(scaleX, scaleY);\n    }\n    const resizedImageData = (0, import_ndarray2.default)(createTypeArray(srcChannels * newWidth * newHeight), [\n        newHeight,\n        newWidth,\n        srcChannels\n    ]);\n    for(let y = 0; y < newHeight; y++){\n        for(let x = 0; x < newWidth; x++){\n            const srcX = x * scaleX;\n            const srcY = y * scaleY;\n            const x1 = Math.max(Math.floor(srcX), 0);\n            const x2 = Math.min(Math.ceil(srcX), srcWidth - 1);\n            const y1 = Math.max(Math.floor(srcY), 0);\n            const y2 = Math.min(Math.ceil(srcY), srcHeight - 1);\n            const dx = srcX - x1;\n            const dy = srcY - y1;\n            for(let c = 0; c < srcChannels; c++){\n                const p1 = imageTensor.get(y1, x1, c);\n                const p2 = imageTensor.get(y1, x2, c);\n                const p3 = imageTensor.get(y2, x1, c);\n                const p4 = imageTensor.get(y2, x2, c);\n                const interpolatedValue = (1 - dx) * (1 - dy) * p1 + dx * (1 - dy) * p2 + (1 - dx) * dy * p3 + dx * dy * p4;\n                resizedImageData.set(y, x, c, interpolatedValue);\n            }\n        }\n    }\n    return resizedImageData;\n}\nfunction tensorHWCtoBCHW(imageTensor, mean = [\n    128,\n    128,\n    128\n], std = [\n    256,\n    256,\n    256\n]) {\n    var imageBufferData = imageTensor.data;\n    const [srcHeight, srcWidth, srcChannels] = imageTensor.shape;\n    const stride = srcHeight * srcWidth;\n    const float32Data = new Float32Array(3 * stride);\n    for(let i = 0, j = 0; i < imageBufferData.length; i += 4, j += 1){\n        float32Data[j] = (imageBufferData[i] - mean[0]) / std[0];\n        float32Data[j + stride] = (imageBufferData[i + 1] - mean[1]) / std[1];\n        float32Data[j + stride + stride] = (imageBufferData[i + 2] - mean[2]) / std[2];\n    }\n    return (0, import_ndarray2.default)(float32Data, [\n        1,\n        3,\n        srcHeight,\n        srcWidth\n    ]);\n}\nasync function imageSourceToImageData(image, config) {\n    if (typeof image === \"string\") {\n        image = ensureAbsoluteURI(image, config.publicPath);\n        image = new URL(image);\n    }\n    if (image instanceof URL) {\n        const response = await fetch(image, {});\n        image = await response.blob();\n    }\n    if (image instanceof ArrayBuffer || ArrayBuffer.isView(image)) {\n        image = new Blob([\n            image\n        ]);\n    }\n    if (image instanceof Blob) {\n        image = await imageDecode(image);\n    }\n    return image;\n}\nfunction convertFloat32ToUint8(float32Array) {\n    const uint8Array = new Uint8Array(float32Array.data.length);\n    for(let i = 0; i < float32Array.data.length; i++){\n        uint8Array[i] = float32Array.data[i] * 255;\n    }\n    return (0, import_ndarray2.default)(uint8Array, float32Array.shape);\n}\nfunction createCanvas(width, height) {\n    let canvas = void 0;\n    if (typeof OffscreenCanvas !== \"undefined\") {\n        canvas = new OffscreenCanvas(width, height);\n    } else {\n        canvas = document.createElement(\"canvas\");\n    }\n    if (!canvas) {\n        throw new Error(`Canvas nor OffscreenCanvas are available in the current context.`);\n    }\n    return canvas;\n}\n// src/onnx.ts\nvar import_ndarray3 = __toESM(require_ndarray());\n// src/capabilities.js\nvar webgpu = async ()=>{\n    if (navigator.gpu === void 0) return false;\n    const adapter = await navigator.gpu.requestAdapter();\n    return adapter !== null;\n};\nvar maxNumThreads = ()=>navigator.hardwareConcurrency ?? 4;\n// src/resource.ts\nasync function loadAsUrl(url, config) {\n    return URL.createObjectURL(await loadAsBlob(url, config));\n}\nasync function loadAsBlob(key, config) {\n    const resourceUrl = new URL(\"resources.json\", config.publicPath);\n    const resourceResponse = await fetch(resourceUrl);\n    if (!resourceResponse.ok) {\n        throw new Error(`Resource metadata not found. Ensure that the config.publicPath is configured correctly.`);\n    }\n    const resourceMap = await resourceResponse.json();\n    const entry = resourceMap[key];\n    if (!entry) {\n        throw new Error(`Resource ${key} not found. Ensure that the config.publicPath is configured correctly.`);\n    }\n    const chunks = entry.chunks;\n    let downloadedSize = 0;\n    const responses = chunks.map(async (chunk)=>{\n        const chunkSize = chunk.offsets[1] - chunk.offsets[0];\n        const url = config.publicPath ? new URL(chunk.name, config.publicPath).toString() : chunk.name;\n        const response = await fetch(url, config.fetchArgs);\n        const blob = await response.blob();\n        if (chunkSize !== blob.size) {\n            throw new Error(`Failed to fetch ${key} with size ${chunkSize} but got ${blob.size}`);\n        }\n        if (config.progress) {\n            downloadedSize += chunkSize;\n            config.progress(`fetch:${key}`, downloadedSize, entry.size);\n        }\n        return blob;\n    });\n    const allChunkData = await Promise.all(responses);\n    const data = new Blob(allChunkData, {\n        type: entry.mime\n    });\n    if (data.size !== entry.size) {\n        throw new Error(`Failed to fetch ${key} with size ${entry.size} but got ${data.size}`);\n    }\n    return data;\n}\n// src/onnx.ts\nvar ort = null;\nvar getOrt = async (useWebGPU)=>{\n    if (ort !== null) {\n        return ort;\n    }\n    if (useWebGPU) {\n        ort = (await __webpack_require__.e(/*! import() */ \"vendor-chunks/onnxruntime-web\").then(__webpack_require__.bind(__webpack_require__, /*! onnxruntime-web/webgpu */ \"(ssr)/./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs?ee0f\"))).default;\n    } else {\n        ort = (await Promise.all(/*! import() */[__webpack_require__.e(\"vendor-chunks/onnxruntime-web\"), __webpack_require__.e(\"vendor-chunks/onnxruntime-common\")]).then(__webpack_require__.bind(__webpack_require__, /*! onnxruntime-web */ \"(ssr)/./node_modules/onnxruntime-web/dist/ort.node.min.mjs?1960\"))).default;\n    }\n    return ort;\n};\nasync function createOnnxSession(model, config) {\n    const useWebGPU = config.device === \"gpu\" && await webgpu();\n    const proxyToWorker = useWebGPU && config.proxyToWorker;\n    const executionProviders = [\n        useWebGPU ? \"webgpu\" : \"wasm\"\n    ];\n    const ort2 = await getOrt(useWebGPU);\n    if (config.debug) {\n        console.debug(\"\tUsing WebGPU:\", useWebGPU);\n        console.debug(\"\tProxy to Worker:\", proxyToWorker);\n        ort2.env.debug = true;\n        ort2.env.logLevel = \"verbose\";\n    }\n    ort2.env.wasm.numThreads = maxNumThreads();\n    ort2.env.wasm.proxy = proxyToWorker;\n    const baseFilePath = useWebGPU ? \"/onnxruntime-web/ort-wasm-simd-threaded.jsep\" : \"/onnxruntime-web/ort-wasm-simd-threaded\";\n    const wasmPath = await loadAsUrl(`${baseFilePath}.wasm`, config);\n    const mjsPath = await loadAsUrl(`${baseFilePath}.mjs`, config);\n    ort2.env.wasm.wasmPaths = {\n        mjs: mjsPath,\n        wasm: wasmPath\n    };\n    if (config.debug) {\n        console.debug(\"ort.env.wasm:\", ort2.env.wasm);\n    }\n    const ortConfig = {\n        executionProviders,\n        graphOptimizationLevel: \"all\",\n        executionMode: \"parallel\",\n        enableCpuMemArena: true\n    };\n    const session = await ort2.InferenceSession.create(model, ortConfig).catch((e)=>{\n        throw new Error(`Failed to create session: \"${e}\". Please check if the publicPath is set correctly.`);\n    });\n    return session;\n}\nasync function runOnnxSession(session, inputs, outputs, config) {\n    const useWebGPU = config.device === \"gpu\" && await webgpu();\n    const ort2 = await getOrt(useWebGPU);\n    const feeds = {};\n    for (const [key, tensor] of inputs){\n        feeds[key] = new ort2.Tensor(\"float32\", new Float32Array(tensor.data), tensor.shape);\n    }\n    const outputData = await session.run(feeds, {});\n    const outputKVPairs = [];\n    for (const key of outputs){\n        const output = outputData[key];\n        const shape = output.dims;\n        const data = output.data;\n        const tensor = (0, import_ndarray3.default)(data, shape);\n        outputKVPairs.push(tensor);\n    }\n    return outputKVPairs;\n}\n// ../../node_modules/zod/lib/index.mjs\nvar util;\n(function(util2) {\n    util2.assertEqual = (val)=>val;\n    function assertIs(_arg) {}\n    util2.assertIs = assertIs;\n    function assertNever(_x) {\n        throw new Error();\n    }\n    util2.assertNever = assertNever;\n    util2.arrayToEnum = (items)=>{\n        const obj = {};\n        for (const item of items){\n            obj[item] = item;\n        }\n        return obj;\n    };\n    util2.getValidEnumValues = (obj)=>{\n        const validKeys = util2.objectKeys(obj).filter((k)=>typeof obj[obj[k]] !== \"number\");\n        const filtered = {};\n        for (const k of validKeys){\n            filtered[k] = obj[k];\n        }\n        return util2.objectValues(filtered);\n    };\n    util2.objectValues = (obj)=>{\n        return util2.objectKeys(obj).map(function(e) {\n            return obj[e];\n        });\n    };\n    util2.objectKeys = typeof Object.keys === \"function\" ? (obj)=>Object.keys(obj) : (object)=>{\n        const keys = [];\n        for(const key in object){\n            if (Object.prototype.hasOwnProperty.call(object, key)) {\n                keys.push(key);\n            }\n        }\n        return keys;\n    };\n    util2.find = (arr, checker)=>{\n        for (const item of arr){\n            if (checker(item)) return item;\n        }\n        return void 0;\n    };\n    util2.isInteger = typeof Number.isInteger === \"function\" ? (val)=>Number.isInteger(val) : (val)=>typeof val === \"number\" && isFinite(val) && Math.floor(val) === val;\n    function joinValues(array, separator = \" | \") {\n        return array.map((val)=>typeof val === \"string\" ? `'${val}'` : val).join(separator);\n    }\n    util2.joinValues = joinValues;\n    util2.jsonStringifyReplacer = (_, value)=>{\n        if (typeof value === \"bigint\") {\n            return value.toString();\n        }\n        return value;\n    };\n})(util || (util = {}));\nvar objectUtil;\n(function(objectUtil2) {\n    objectUtil2.mergeShapes = (first, second)=>{\n        return {\n            ...first,\n            ...second\n        };\n    };\n})(objectUtil || (objectUtil = {}));\nvar ZodParsedType = util.arrayToEnum([\n    \"string\",\n    \"nan\",\n    \"number\",\n    \"integer\",\n    \"float\",\n    \"boolean\",\n    \"date\",\n    \"bigint\",\n    \"symbol\",\n    \"function\",\n    \"undefined\",\n    \"null\",\n    \"array\",\n    \"object\",\n    \"unknown\",\n    \"promise\",\n    \"void\",\n    \"never\",\n    \"map\",\n    \"set\"\n]);\nvar getParsedType = (data)=>{\n    const t = typeof data;\n    switch(t){\n        case \"undefined\":\n            return ZodParsedType.undefined;\n        case \"string\":\n            return ZodParsedType.string;\n        case \"number\":\n            return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;\n        case \"boolean\":\n            return ZodParsedType.boolean;\n        case \"function\":\n            return ZodParsedType.function;\n        case \"bigint\":\n            return ZodParsedType.bigint;\n        case \"symbol\":\n            return ZodParsedType.symbol;\n        case \"object\":\n            if (Array.isArray(data)) {\n                return ZodParsedType.array;\n            }\n            if (data === null) {\n                return ZodParsedType.null;\n            }\n            if (data.then && typeof data.then === \"function\" && data.catch && typeof data.catch === \"function\") {\n                return ZodParsedType.promise;\n            }\n            if (typeof Map !== \"undefined\" && data instanceof Map) {\n                return ZodParsedType.map;\n            }\n            if (typeof Set !== \"undefined\" && data instanceof Set) {\n                return ZodParsedType.set;\n            }\n            if (typeof Date !== \"undefined\" && data instanceof Date) {\n                return ZodParsedType.date;\n            }\n            return ZodParsedType.object;\n        default:\n            return ZodParsedType.unknown;\n    }\n};\nvar ZodIssueCode = util.arrayToEnum([\n    \"invalid_type\",\n    \"invalid_literal\",\n    \"custom\",\n    \"invalid_union\",\n    \"invalid_union_discriminator\",\n    \"invalid_enum_value\",\n    \"unrecognized_keys\",\n    \"invalid_arguments\",\n    \"invalid_return_type\",\n    \"invalid_date\",\n    \"invalid_string\",\n    \"too_small\",\n    \"too_big\",\n    \"invalid_intersection_types\",\n    \"not_multiple_of\",\n    \"not_finite\"\n]);\nvar quotelessJson = (obj)=>{\n    const json = JSON.stringify(obj, null, 2);\n    return json.replace(/\"([^\"]+)\":/g, \"$1:\");\n};\nvar ZodError = class _ZodError extends Error {\n    constructor(issues){\n        super();\n        this.issues = [];\n        this.addIssue = (sub)=>{\n            this.issues = [\n                ...this.issues,\n                sub\n            ];\n        };\n        this.addIssues = (subs = [])=>{\n            this.issues = [\n                ...this.issues,\n                ...subs\n            ];\n        };\n        const actualProto = new.target.prototype;\n        if (Object.setPrototypeOf) {\n            Object.setPrototypeOf(this, actualProto);\n        } else {\n            this.__proto__ = actualProto;\n        }\n        this.name = \"ZodError\";\n        this.issues = issues;\n    }\n    get errors() {\n        return this.issues;\n    }\n    format(_mapper) {\n        const mapper = _mapper || function(issue) {\n            return issue.message;\n        };\n        const fieldErrors = {\n            _errors: []\n        };\n        const processError = (error)=>{\n            for (const issue of error.issues){\n                if (issue.code === \"invalid_union\") {\n                    issue.unionErrors.map(processError);\n                } else if (issue.code === \"invalid_return_type\") {\n                    processError(issue.returnTypeError);\n                } else if (issue.code === \"invalid_arguments\") {\n                    processError(issue.argumentsError);\n                } else if (issue.path.length === 0) {\n                    fieldErrors._errors.push(mapper(issue));\n                } else {\n                    let curr = fieldErrors;\n                    let i = 0;\n                    while(i < issue.path.length){\n                        const el = issue.path[i];\n                        const terminal = i === issue.path.length - 1;\n                        if (!terminal) {\n                            curr[el] = curr[el] || {\n                                _errors: []\n                            };\n                        } else {\n                            curr[el] = curr[el] || {\n                                _errors: []\n                            };\n                            curr[el]._errors.push(mapper(issue));\n                        }\n                        curr = curr[el];\n                        i++;\n                    }\n                }\n            }\n        };\n        processError(this);\n        return fieldErrors;\n    }\n    static assert(value) {\n        if (!(value instanceof _ZodError)) {\n            throw new Error(`Not a ZodError: ${value}`);\n        }\n    }\n    toString() {\n        return this.message;\n    }\n    get message() {\n        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);\n    }\n    get isEmpty() {\n        return this.issues.length === 0;\n    }\n    flatten(mapper = (issue)=>issue.message) {\n        const fieldErrors = {};\n        const formErrors = [];\n        for (const sub of this.issues){\n            if (sub.path.length > 0) {\n                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];\n                fieldErrors[sub.path[0]].push(mapper(sub));\n            } else {\n                formErrors.push(mapper(sub));\n            }\n        }\n        return {\n            formErrors,\n            fieldErrors\n        };\n    }\n    get formErrors() {\n        return this.flatten();\n    }\n};\nZodError.create = (issues)=>{\n    const error = new ZodError(issues);\n    return error;\n};\nvar errorMap = (issue, _ctx)=>{\n    let message;\n    switch(issue.code){\n        case ZodIssueCode.invalid_type:\n            if (issue.received === ZodParsedType.undefined) {\n                message = \"Required\";\n            } else {\n                message = `Expected ${issue.expected}, received ${issue.received}`;\n            }\n            break;\n        case ZodIssueCode.invalid_literal:\n            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;\n            break;\n        case ZodIssueCode.unrecognized_keys:\n            message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, \", \")}`;\n            break;\n        case ZodIssueCode.invalid_union:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_union_discriminator:\n            message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;\n            break;\n        case ZodIssueCode.invalid_enum_value:\n            message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;\n            break;\n        case ZodIssueCode.invalid_arguments:\n            message = `Invalid function arguments`;\n            break;\n        case ZodIssueCode.invalid_return_type:\n            message = `Invalid function return type`;\n            break;\n        case ZodIssueCode.invalid_date:\n            message = `Invalid date`;\n            break;\n        case ZodIssueCode.invalid_string:\n            if (typeof issue.validation === \"object\") {\n                if (\"includes\" in issue.validation) {\n                    message = `Invalid input: must include \"${issue.validation.includes}\"`;\n                    if (typeof issue.validation.position === \"number\") {\n                        message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;\n                    }\n                } else if (\"startsWith\" in issue.validation) {\n                    message = `Invalid input: must start with \"${issue.validation.startsWith}\"`;\n                } else if (\"endsWith\" in issue.validation) {\n                    message = `Invalid input: must end with \"${issue.validation.endsWith}\"`;\n                } else {\n                    util.assertNever(issue.validation);\n                }\n            } else if (issue.validation !== \"regex\") {\n                message = `Invalid ${issue.validation}`;\n            } else {\n                message = \"Invalid\";\n            }\n            break;\n        case ZodIssueCode.too_small:\n            if (issue.type === \"array\") message = `Array must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;\n            else if (issue.type === \"string\") message = `String must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;\n            else if (issue.type === \"number\") message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;\n            else if (issue.type === \"date\") message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;\n            else message = \"Invalid input\";\n            break;\n        case ZodIssueCode.too_big:\n            if (issue.type === \"array\") message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;\n            else if (issue.type === \"string\") message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;\n            else if (issue.type === \"number\") message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"bigint\") message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"date\") message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;\n            else message = \"Invalid input\";\n            break;\n        case ZodIssueCode.custom:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_intersection_types:\n            message = `Intersection results could not be merged`;\n            break;\n        case ZodIssueCode.not_multiple_of:\n            message = `Number must be a multiple of ${issue.multipleOf}`;\n            break;\n        case ZodIssueCode.not_finite:\n            message = \"Number must be finite\";\n            break;\n        default:\n            message = _ctx.defaultError;\n            util.assertNever(issue);\n    }\n    return {\n        message\n    };\n};\nvar overrideErrorMap = errorMap;\nfunction setErrorMap(map) {\n    overrideErrorMap = map;\n}\nfunction getErrorMap() {\n    return overrideErrorMap;\n}\nvar makeIssue = (params)=>{\n    const { data, path, errorMaps, issueData } = params;\n    const fullPath = [\n        ...path,\n        ...issueData.path || []\n    ];\n    const fullIssue = {\n        ...issueData,\n        path: fullPath\n    };\n    if (issueData.message !== void 0) {\n        return {\n            ...issueData,\n            path: fullPath,\n            message: issueData.message\n        };\n    }\n    let errorMessage = \"\";\n    const maps = errorMaps.filter((m)=>!!m).slice().reverse();\n    for (const map of maps){\n        errorMessage = map(fullIssue, {\n            data,\n            defaultError: errorMessage\n        }).message;\n    }\n    return {\n        ...issueData,\n        path: fullPath,\n        message: errorMessage\n    };\n};\nvar EMPTY_PATH = [];\nfunction addIssueToContext(ctx, issueData) {\n    const overrideMap = getErrorMap();\n    const issue = makeIssue({\n        issueData,\n        data: ctx.data,\n        path: ctx.path,\n        errorMaps: [\n            ctx.common.contextualErrorMap,\n            ctx.schemaErrorMap,\n            overrideMap,\n            overrideMap === errorMap ? void 0 : errorMap\n        ].filter((x)=>!!x)\n    });\n    ctx.common.issues.push(issue);\n}\nvar ParseStatus = class _ParseStatus {\n    constructor(){\n        this.value = \"valid\";\n    }\n    dirty() {\n        if (this.value === \"valid\") this.value = \"dirty\";\n    }\n    abort() {\n        if (this.value !== \"aborted\") this.value = \"aborted\";\n    }\n    static mergeArray(status, results) {\n        const arrayValue = [];\n        for (const s of results){\n            if (s.status === \"aborted\") return INVALID;\n            if (s.status === \"dirty\") status.dirty();\n            arrayValue.push(s.value);\n        }\n        return {\n            status: status.value,\n            value: arrayValue\n        };\n    }\n    static async mergeObjectAsync(status, pairs) {\n        const syncPairs = [];\n        for (const pair of pairs){\n            const key = await pair.key;\n            const value = await pair.value;\n            syncPairs.push({\n                key,\n                value\n            });\n        }\n        return _ParseStatus.mergeObjectSync(status, syncPairs);\n    }\n    static mergeObjectSync(status, pairs) {\n        const finalObject = {};\n        for (const pair of pairs){\n            const { key, value } = pair;\n            if (key.status === \"aborted\") return INVALID;\n            if (value.status === \"aborted\") return INVALID;\n            if (key.status === \"dirty\") status.dirty();\n            if (value.status === \"dirty\") status.dirty();\n            if (key.value !== \"__proto__\" && (typeof value.value !== \"undefined\" || pair.alwaysSet)) {\n                finalObject[key.value] = value.value;\n            }\n        }\n        return {\n            status: status.value,\n            value: finalObject\n        };\n    }\n};\nvar INVALID = Object.freeze({\n    status: \"aborted\"\n});\nvar DIRTY = (value)=>({\n        status: \"dirty\",\n        value\n    });\nvar OK = (value)=>({\n        status: \"valid\",\n        value\n    });\nvar isAborted = (x)=>x.status === \"aborted\";\nvar isDirty = (x)=>x.status === \"dirty\";\nvar isValid = (x)=>x.status === \"valid\";\nvar isAsync = (x)=>typeof Promise !== \"undefined\" && x instanceof Promise;\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n}\nvar errorUtil;\n(function(errorUtil2) {\n    errorUtil2.errToObj = (message)=>typeof message === \"string\" ? {\n            message\n        } : message || {};\n    errorUtil2.toString = (message)=>typeof message === \"string\" ? message : message === null || message === void 0 ? void 0 : message.message;\n})(errorUtil || (errorUtil = {}));\nvar _ZodEnum_cache;\nvar _ZodNativeEnum_cache;\nvar ParseInputLazyPath = class {\n    constructor(parent, value, path, key){\n        this._cachedPath = [];\n        this.parent = parent;\n        this.data = value;\n        this._path = path;\n        this._key = key;\n    }\n    get path() {\n        if (!this._cachedPath.length) {\n            if (this._key instanceof Array) {\n                this._cachedPath.push(...this._path, ...this._key);\n            } else {\n                this._cachedPath.push(...this._path, this._key);\n            }\n        }\n        return this._cachedPath;\n    }\n};\nvar handleResult = (ctx, result)=>{\n    if (isValid(result)) {\n        return {\n            success: true,\n            data: result.value\n        };\n    } else {\n        if (!ctx.common.issues.length) {\n            throw new Error(\"Validation failed but no issues detected.\");\n        }\n        return {\n            success: false,\n            get error () {\n                if (this._error) return this._error;\n                const error = new ZodError(ctx.common.issues);\n                this._error = error;\n                return this._error;\n            }\n        };\n    }\n};\nfunction processCreateParams(params) {\n    if (!params) return {};\n    const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;\n    if (errorMap2 && (invalid_type_error || required_error)) {\n        throw new Error(`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\n    }\n    if (errorMap2) return {\n        errorMap: errorMap2,\n        description\n    };\n    const customMap = (iss, ctx)=>{\n        var _a, _b;\n        const { message } = params;\n        if (iss.code === \"invalid_enum_value\") {\n            return {\n                message: message !== null && message !== void 0 ? message : ctx.defaultError\n            };\n        }\n        if (typeof ctx.data === \"undefined\") {\n            return {\n                message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError\n            };\n        }\n        if (iss.code !== \"invalid_type\") return {\n            message: ctx.defaultError\n        };\n        return {\n            message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError\n        };\n    };\n    return {\n        errorMap: customMap,\n        description\n    };\n}\nvar ZodType = class {\n    constructor(def){\n        this.spa = this.safeParseAsync;\n        this._def = def;\n        this.parse = this.parse.bind(this);\n        this.safeParse = this.safeParse.bind(this);\n        this.parseAsync = this.parseAsync.bind(this);\n        this.safeParseAsync = this.safeParseAsync.bind(this);\n        this.spa = this.spa.bind(this);\n        this.refine = this.refine.bind(this);\n        this.refinement = this.refinement.bind(this);\n        this.superRefine = this.superRefine.bind(this);\n        this.optional = this.optional.bind(this);\n        this.nullable = this.nullable.bind(this);\n        this.nullish = this.nullish.bind(this);\n        this.array = this.array.bind(this);\n        this.promise = this.promise.bind(this);\n        this.or = this.or.bind(this);\n        this.and = this.and.bind(this);\n        this.transform = this.transform.bind(this);\n        this.brand = this.brand.bind(this);\n        this.default = this.default.bind(this);\n        this.catch = this.catch.bind(this);\n        this.describe = this.describe.bind(this);\n        this.pipe = this.pipe.bind(this);\n        this.readonly = this.readonly.bind(this);\n        this.isNullable = this.isNullable.bind(this);\n        this.isOptional = this.isOptional.bind(this);\n    }\n    get description() {\n        return this._def.description;\n    }\n    _getType(input) {\n        return getParsedType(input.data);\n    }\n    _getOrReturnCtx(input, ctx) {\n        return ctx || {\n            common: input.parent.common,\n            data: input.data,\n            parsedType: getParsedType(input.data),\n            schemaErrorMap: this._def.errorMap,\n            path: input.path,\n            parent: input.parent\n        };\n    }\n    _processInputParams(input) {\n        return {\n            status: new ParseStatus(),\n            ctx: {\n                common: input.parent.common,\n                data: input.data,\n                parsedType: getParsedType(input.data),\n                schemaErrorMap: this._def.errorMap,\n                path: input.path,\n                parent: input.parent\n            }\n        };\n    }\n    _parseSync(input) {\n        const result = this._parse(input);\n        if (isAsync(result)) {\n            throw new Error(\"Synchronous parse encountered promise.\");\n        }\n        return result;\n    }\n    _parseAsync(input) {\n        const result = this._parse(input);\n        return Promise.resolve(result);\n    }\n    parse(data, params) {\n        const result = this.safeParse(data, params);\n        if (result.success) return result.data;\n        throw result.error;\n    }\n    safeParse(data, params) {\n        var _a;\n        const ctx = {\n            common: {\n                issues: [],\n                async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,\n                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap\n            },\n            path: (params === null || params === void 0 ? void 0 : params.path) || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data)\n        };\n        const result = this._parseSync({\n            data,\n            path: ctx.path,\n            parent: ctx\n        });\n        return handleResult(ctx, result);\n    }\n    async parseAsync(data, params) {\n        const result = await this.safeParseAsync(data, params);\n        if (result.success) return result.data;\n        throw result.error;\n    }\n    async safeParseAsync(data, params) {\n        const ctx = {\n            common: {\n                issues: [],\n                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,\n                async: true\n            },\n            path: (params === null || params === void 0 ? void 0 : params.path) || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data)\n        };\n        const maybeAsyncResult = this._parse({\n            data,\n            path: ctx.path,\n            parent: ctx\n        });\n        const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));\n        return handleResult(ctx, result);\n    }\n    refine(check, message) {\n        const getIssueProperties = (val)=>{\n            if (typeof message === \"string\" || typeof message === \"undefined\") {\n                return {\n                    message\n                };\n            } else if (typeof message === \"function\") {\n                return message(val);\n            } else {\n                return message;\n            }\n        };\n        return this._refinement((val, ctx)=>{\n            const result = check(val);\n            const setError = ()=>ctx.addIssue({\n                    code: ZodIssueCode.custom,\n                    ...getIssueProperties(val)\n                });\n            if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n                return result.then((data)=>{\n                    if (!data) {\n                        setError();\n                        return false;\n                    } else {\n                        return true;\n                    }\n                });\n            }\n            if (!result) {\n                setError();\n                return false;\n            } else {\n                return true;\n            }\n        });\n    }\n    refinement(check, refinementData) {\n        return this._refinement((val, ctx)=>{\n            if (!check(val)) {\n                ctx.addIssue(typeof refinementData === \"function\" ? refinementData(val, ctx) : refinementData);\n                return false;\n            } else {\n                return true;\n            }\n        });\n    }\n    _refinement(refinement) {\n        return new ZodEffects({\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: {\n                type: \"refinement\",\n                refinement\n            }\n        });\n    }\n    superRefine(refinement) {\n        return this._refinement(refinement);\n    }\n    optional() {\n        return ZodOptional.create(this, this._def);\n    }\n    nullable() {\n        return ZodNullable.create(this, this._def);\n    }\n    nullish() {\n        return this.nullable().optional();\n    }\n    array() {\n        return ZodArray.create(this, this._def);\n    }\n    promise() {\n        return ZodPromise.create(this, this._def);\n    }\n    or(option) {\n        return ZodUnion.create([\n            this,\n            option\n        ], this._def);\n    }\n    and(incoming) {\n        return ZodIntersection.create(this, incoming, this._def);\n    }\n    transform(transform) {\n        return new ZodEffects({\n            ...processCreateParams(this._def),\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: {\n                type: \"transform\",\n                transform\n            }\n        });\n    }\n    default(def) {\n        const defaultValueFunc = typeof def === \"function\" ? def : ()=>def;\n        return new ZodDefault({\n            ...processCreateParams(this._def),\n            innerType: this,\n            defaultValue: defaultValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodDefault\n        });\n    }\n    brand() {\n        return new ZodBranded({\n            typeName: ZodFirstPartyTypeKind.ZodBranded,\n            type: this,\n            ...processCreateParams(this._def)\n        });\n    }\n    catch(def) {\n        const catchValueFunc = typeof def === \"function\" ? def : ()=>def;\n        return new ZodCatch({\n            ...processCreateParams(this._def),\n            innerType: this,\n            catchValue: catchValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodCatch\n        });\n    }\n    describe(description) {\n        const This = this.constructor;\n        return new This({\n            ...this._def,\n            description\n        });\n    }\n    pipe(target) {\n        return ZodPipeline.create(this, target);\n    }\n    readonly() {\n        return ZodReadonly.create(this);\n    }\n    isOptional() {\n        return this.safeParse(void 0).success;\n    }\n    isNullable() {\n        return this.safeParse(null).success;\n    }\n};\nvar cuidRegex = /^c[^\\s-]{8,}$/i;\nvar cuid2Regex = /^[0-9a-z]+$/;\nvar ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;\nvar uuidRegex = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/i;\nvar nanoidRegex = /^[a-z0-9_-]{21}$/i;\nvar durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\\d+Y)|(?:[-+]?\\d+[.,]\\d+Y$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:(?:[-+]?\\d+W)|(?:[-+]?\\d+[.,]\\d+W$))?(?:(?:[-+]?\\d+D)|(?:[-+]?\\d+[.,]\\d+D$))?(?:T(?=[\\d+-])(?:(?:[-+]?\\d+H)|(?:[-+]?\\d+[.,]\\d+H$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:[-+]?\\d+(?:[.,]\\d+)?S)?)??$/;\nvar emailRegex = /^(?!\\.)(?!.*\\.\\.)([A-Z0-9_'+\\-\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i;\nvar _emojiRegex = `^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$`;\nvar emojiRegex;\nvar ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;\nvar ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;\nvar base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;\nvar dateRegexSource = `((\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\\\d|30)|(02)-(0[1-9]|1\\\\d|2[0-8])))`;\nvar dateRegex = new RegExp(`^${dateRegexSource}$`);\nfunction timeRegexSource(args) {\n    let regex = `([01]\\\\d|2[0-3]):[0-5]\\\\d:[0-5]\\\\d`;\n    if (args.precision) {\n        regex = `${regex}\\\\.\\\\d{${args.precision}}`;\n    } else if (args.precision == null) {\n        regex = `${regex}(\\\\.\\\\d+)?`;\n    }\n    return regex;\n}\nfunction timeRegex(args) {\n    return new RegExp(`^${timeRegexSource(args)}$`);\n}\nfunction datetimeRegex(args) {\n    let regex = `${dateRegexSource}T${timeRegexSource(args)}`;\n    const opts = [];\n    opts.push(args.local ? `Z?` : `Z`);\n    if (args.offset) opts.push(`([+-]\\\\d{2}:?\\\\d{2})`);\n    regex = `${regex}(${opts.join(\"|\")})`;\n    return new RegExp(`^${regex}$`);\n}\nfunction isValidIP(ip, version) {\n    if ((version === \"v4\" || !version) && ipv4Regex.test(ip)) {\n        return true;\n    }\n    if ((version === \"v6\" || !version) && ipv6Regex.test(ip)) {\n        return true;\n    }\n    return false;\n}\nvar ZodString = class _ZodString extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = String(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.string) {\n            const ctx2 = this._getOrReturnCtx(input);\n            addIssueToContext(ctx2, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.string,\n                received: ctx2.parsedType\n            });\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = void 0;\n        for (const check of this._def.checks){\n            if (check.kind === \"min\") {\n                if (input.data.length < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"max\") {\n                if (input.data.length > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"length\") {\n                const tooBig = input.data.length > check.value;\n                const tooSmall = input.data.length < check.value;\n                if (tooBig || tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    if (tooBig) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_big,\n                            maximum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message\n                        });\n                    } else if (tooSmall) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_small,\n                            minimum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message\n                        });\n                    }\n                    status.dirty();\n                }\n            } else if (check.kind === \"email\") {\n                if (!emailRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"email\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"emoji\") {\n                if (!emojiRegex) {\n                    emojiRegex = new RegExp(_emojiRegex, \"u\");\n                }\n                if (!emojiRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"emoji\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"uuid\") {\n                if (!uuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"uuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"nanoid\") {\n                if (!nanoidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"nanoid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"cuid\") {\n                if (!cuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"cuid2\") {\n                if (!cuid2Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid2\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"ulid\") {\n                if (!ulidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ulid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"url\") {\n                try {\n                    new URL(input.data);\n                } catch (_a) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"url\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"regex\") {\n                check.regex.lastIndex = 0;\n                const testResult = check.regex.test(input.data);\n                if (!testResult) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"regex\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"trim\") {\n                input.data = input.data.trim();\n            } else if (check.kind === \"includes\") {\n                if (!input.data.includes(check.value, check.position)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: {\n                            includes: check.value,\n                            position: check.position\n                        },\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"toLowerCase\") {\n                input.data = input.data.toLowerCase();\n            } else if (check.kind === \"toUpperCase\") {\n                input.data = input.data.toUpperCase();\n            } else if (check.kind === \"startsWith\") {\n                if (!input.data.startsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: {\n                            startsWith: check.value\n                        },\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"endsWith\") {\n                if (!input.data.endsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: {\n                            endsWith: check.value\n                        },\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"datetime\") {\n                const regex = datetimeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"datetime\",\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"date\") {\n                const regex = dateRegex;\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"date\",\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"time\") {\n                const regex = timeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"time\",\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"duration\") {\n                if (!durationRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"duration\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"ip\") {\n                if (!isValidIP(input.data, check.version)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ip\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"base64\") {\n                if (!base64Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"base64\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else {\n                util.assertNever(check);\n            }\n        }\n        return {\n            status: status.value,\n            value: input.data\n        };\n    }\n    _regex(regex, validation, message) {\n        return this.refinement((data)=>regex.test(data), {\n            validation,\n            code: ZodIssueCode.invalid_string,\n            ...errorUtil.errToObj(message)\n        });\n    }\n    _addCheck(check) {\n        return new _ZodString({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                check\n            ]\n        });\n    }\n    email(message) {\n        return this._addCheck({\n            kind: \"email\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    url(message) {\n        return this._addCheck({\n            kind: \"url\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    emoji(message) {\n        return this._addCheck({\n            kind: \"emoji\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    uuid(message) {\n        return this._addCheck({\n            kind: \"uuid\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    nanoid(message) {\n        return this._addCheck({\n            kind: \"nanoid\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    cuid(message) {\n        return this._addCheck({\n            kind: \"cuid\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    cuid2(message) {\n        return this._addCheck({\n            kind: \"cuid2\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    ulid(message) {\n        return this._addCheck({\n            kind: \"ulid\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    base64(message) {\n        return this._addCheck({\n            kind: \"base64\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    ip(options) {\n        return this._addCheck({\n            kind: \"ip\",\n            ...errorUtil.errToObj(options)\n        });\n    }\n    datetime(options) {\n        var _a, _b;\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"datetime\",\n                precision: null,\n                offset: false,\n                local: false,\n                message: options\n            });\n        }\n        return this._addCheck({\n            kind: \"datetime\",\n            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === \"undefined\" ? null : options === null || options === void 0 ? void 0 : options.precision,\n            offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,\n            local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,\n            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)\n        });\n    }\n    date(message) {\n        return this._addCheck({\n            kind: \"date\",\n            message\n        });\n    }\n    time(options) {\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"time\",\n                precision: null,\n                message: options\n            });\n        }\n        return this._addCheck({\n            kind: \"time\",\n            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === \"undefined\" ? null : options === null || options === void 0 ? void 0 : options.precision,\n            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)\n        });\n    }\n    duration(message) {\n        return this._addCheck({\n            kind: \"duration\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    regex(regex, message) {\n        return this._addCheck({\n            kind: \"regex\",\n            regex,\n            ...errorUtil.errToObj(message)\n        });\n    }\n    includes(value, options) {\n        return this._addCheck({\n            kind: \"includes\",\n            value,\n            position: options === null || options === void 0 ? void 0 : options.position,\n            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)\n        });\n    }\n    startsWith(value, message) {\n        return this._addCheck({\n            kind: \"startsWith\",\n            value,\n            ...errorUtil.errToObj(message)\n        });\n    }\n    endsWith(value, message) {\n        return this._addCheck({\n            kind: \"endsWith\",\n            value,\n            ...errorUtil.errToObj(message)\n        });\n    }\n    min(minLength, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minLength,\n            ...errorUtil.errToObj(message)\n        });\n    }\n    max(maxLength, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxLength,\n            ...errorUtil.errToObj(message)\n        });\n    }\n    length(len, message) {\n        return this._addCheck({\n            kind: \"length\",\n            value: len,\n            ...errorUtil.errToObj(message)\n        });\n    }\n    /**\n   * @deprecated Use z.string().min(1) instead.\n   * @see {@link ZodString.min}\n   */ nonempty(message) {\n        return this.min(1, errorUtil.errToObj(message));\n    }\n    trim() {\n        return new _ZodString({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind: \"trim\"\n                }\n            ]\n        });\n    }\n    toLowerCase() {\n        return new _ZodString({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind: \"toLowerCase\"\n                }\n            ]\n        });\n    }\n    toUpperCase() {\n        return new _ZodString({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind: \"toUpperCase\"\n                }\n            ]\n        });\n    }\n    get isDatetime() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"datetime\");\n    }\n    get isDate() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"date\");\n    }\n    get isTime() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"time\");\n    }\n    get isDuration() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"duration\");\n    }\n    get isEmail() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"email\");\n    }\n    get isURL() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"url\");\n    }\n    get isEmoji() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"emoji\");\n    }\n    get isUUID() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"uuid\");\n    }\n    get isNANOID() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"nanoid\");\n    }\n    get isCUID() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"cuid\");\n    }\n    get isCUID2() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"cuid2\");\n    }\n    get isULID() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"ulid\");\n    }\n    get isIP() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"ip\");\n    }\n    get isBase64() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"base64\");\n    }\n    get minLength() {\n        let min = null;\n        for (const ch of this._def.checks){\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min) min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxLength() {\n        let max = null;\n        for (const ch of this._def.checks){\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max) max = ch.value;\n            }\n        }\n        return max;\n    }\n};\nZodString.create = (params)=>{\n    var _a;\n    return new ZodString({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodString,\n        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,\n        ...processCreateParams(params)\n    });\n};\nfunction floatSafeRemainder(val, step) {\n    const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n    const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n    const valInt = parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n    const stepInt = parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n    return valInt % stepInt / Math.pow(10, decCount);\n}\nvar ZodNumber = class _ZodNumber extends ZodType {\n    constructor(){\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n        this.step = this.multipleOf;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Number(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.number) {\n            const ctx2 = this._getOrReturnCtx(input);\n            addIssueToContext(ctx2, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.number,\n                received: ctx2.parsedType\n            });\n            return INVALID;\n        }\n        let ctx = void 0;\n        const status = new ParseStatus();\n        for (const check of this._def.checks){\n            if (check.kind === \"int\") {\n                if (!util.isInteger(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_type,\n                        expected: \"integer\",\n                        received: \"float\",\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"min\") {\n                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"max\") {\n                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"multipleOf\") {\n                if (floatSafeRemainder(input.data, check.value) !== 0) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"finite\") {\n                if (!Number.isFinite(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_finite,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else {\n                util.assertNever(check);\n            }\n        }\n        return {\n            status: status.value,\n            value: input.data\n        };\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new _ZodNumber({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message)\n                }\n            ]\n        });\n    }\n    _addCheck(check) {\n        return new _ZodNumber({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                check\n            ]\n        });\n    }\n    int(message) {\n        return this._addCheck({\n            kind: \"int\",\n            message: errorUtil.toString(message)\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message)\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message)\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message)\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message)\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value,\n            message: errorUtil.toString(message)\n        });\n    }\n    finite(message) {\n        return this._addCheck({\n            kind: \"finite\",\n            message: errorUtil.toString(message)\n        });\n    }\n    safe(message) {\n        return this._addCheck({\n            kind: \"min\",\n            inclusive: true,\n            value: Number.MIN_SAFE_INTEGER,\n            message: errorUtil.toString(message)\n        })._addCheck({\n            kind: \"max\",\n            inclusive: true,\n            value: Number.MAX_SAFE_INTEGER,\n            message: errorUtil.toString(message)\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks){\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min) min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks){\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max) max = ch.value;\n            }\n        }\n        return max;\n    }\n    get isInt() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"int\" || ch.kind === \"multipleOf\" && util.isInteger(ch.value));\n    }\n    get isFinite() {\n        let max = null, min = null;\n        for (const ch of this._def.checks){\n            if (ch.kind === \"finite\" || ch.kind === \"int\" || ch.kind === \"multipleOf\") {\n                return true;\n            } else if (ch.kind === \"min\") {\n                if (min === null || ch.value > min) min = ch.value;\n            } else if (ch.kind === \"max\") {\n                if (max === null || ch.value < max) max = ch.value;\n            }\n        }\n        return Number.isFinite(min) && Number.isFinite(max);\n    }\n};\nZodNumber.create = (params)=>{\n    return new ZodNumber({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodNumber,\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n        ...processCreateParams(params)\n    });\n};\nvar ZodBigInt = class _ZodBigInt extends ZodType {\n    constructor(){\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = BigInt(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.bigint) {\n            const ctx2 = this._getOrReturnCtx(input);\n            addIssueToContext(ctx2, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.bigint,\n                received: ctx2.parsedType\n            });\n            return INVALID;\n        }\n        let ctx = void 0;\n        const status = new ParseStatus();\n        for (const check of this._def.checks){\n            if (check.kind === \"min\") {\n                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        type: \"bigint\",\n                        minimum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"max\") {\n                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        type: \"bigint\",\n                        maximum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"multipleOf\") {\n                if (input.data % check.value !== BigInt(0)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else {\n                util.assertNever(check);\n            }\n        }\n        return {\n            status: status.value,\n            value: input.data\n        };\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new _ZodBigInt({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message)\n                }\n            ]\n        });\n    }\n    _addCheck(check) {\n        return new _ZodBigInt({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                check\n            ]\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message)\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message)\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message)\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message)\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value,\n            message: errorUtil.toString(message)\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks){\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min) min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks){\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max) max = ch.value;\n            }\n        }\n        return max;\n    }\n};\nZodBigInt.create = (params)=>{\n    var _a;\n    return new ZodBigInt({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodBigInt,\n        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,\n        ...processCreateParams(params)\n    });\n};\nvar ZodBoolean = class extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Boolean(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.boolean) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.boolean,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n};\nZodBoolean.create = (params)=>{\n    return new ZodBoolean({\n        typeName: ZodFirstPartyTypeKind.ZodBoolean,\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n        ...processCreateParams(params)\n    });\n};\nvar ZodDate = class _ZodDate extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = new Date(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.date) {\n            const ctx2 = this._getOrReturnCtx(input);\n            addIssueToContext(ctx2, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.date,\n                received: ctx2.parsedType\n            });\n            return INVALID;\n        }\n        if (isNaN(input.data.getTime())) {\n            const ctx2 = this._getOrReturnCtx(input);\n            addIssueToContext(ctx2, {\n                code: ZodIssueCode.invalid_date\n            });\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = void 0;\n        for (const check of this._def.checks){\n            if (check.kind === \"min\") {\n                if (input.data.getTime() < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        minimum: check.value,\n                        type: \"date\"\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"max\") {\n                if (input.data.getTime() > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        maximum: check.value,\n                        type: \"date\"\n                    });\n                    status.dirty();\n                }\n            } else {\n                util.assertNever(check);\n            }\n        }\n        return {\n            status: status.value,\n            value: new Date(input.data.getTime())\n        };\n    }\n    _addCheck(check) {\n        return new _ZodDate({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                check\n            ]\n        });\n    }\n    min(minDate, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minDate.getTime(),\n            message: errorUtil.toString(message)\n        });\n    }\n    max(maxDate, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxDate.getTime(),\n            message: errorUtil.toString(message)\n        });\n    }\n    get minDate() {\n        let min = null;\n        for (const ch of this._def.checks){\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min) min = ch.value;\n            }\n        }\n        return min != null ? new Date(min) : null;\n    }\n    get maxDate() {\n        let max = null;\n        for (const ch of this._def.checks){\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max) max = ch.value;\n            }\n        }\n        return max != null ? new Date(max) : null;\n    }\n};\nZodDate.create = (params)=>{\n    return new ZodDate({\n        checks: [],\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n        typeName: ZodFirstPartyTypeKind.ZodDate,\n        ...processCreateParams(params)\n    });\n};\nvar ZodSymbol = class extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.symbol) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.symbol,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n};\nZodSymbol.create = (params)=>{\n    return new ZodSymbol({\n        typeName: ZodFirstPartyTypeKind.ZodSymbol,\n        ...processCreateParams(params)\n    });\n};\nvar ZodUndefined = class extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.undefined,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n};\nZodUndefined.create = (params)=>{\n    return new ZodUndefined({\n        typeName: ZodFirstPartyTypeKind.ZodUndefined,\n        ...processCreateParams(params)\n    });\n};\nvar ZodNull = class extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.null) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.null,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n};\nZodNull.create = (params)=>{\n    return new ZodNull({\n        typeName: ZodFirstPartyTypeKind.ZodNull,\n        ...processCreateParams(params)\n    });\n};\nvar ZodAny = class extends ZodType {\n    constructor(){\n        super(...arguments);\n        this._any = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n};\nZodAny.create = (params)=>{\n    return new ZodAny({\n        typeName: ZodFirstPartyTypeKind.ZodAny,\n        ...processCreateParams(params)\n    });\n};\nvar ZodUnknown = class extends ZodType {\n    constructor(){\n        super(...arguments);\n        this._unknown = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n};\nZodUnknown.create = (params)=>{\n    return new ZodUnknown({\n        typeName: ZodFirstPartyTypeKind.ZodUnknown,\n        ...processCreateParams(params)\n    });\n};\nvar ZodNever = class extends ZodType {\n    _parse(input) {\n        const ctx = this._getOrReturnCtx(input);\n        addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.never,\n            received: ctx.parsedType\n        });\n        return INVALID;\n    }\n};\nZodNever.create = (params)=>{\n    return new ZodNever({\n        typeName: ZodFirstPartyTypeKind.ZodNever,\n        ...processCreateParams(params)\n    });\n};\nvar ZodVoid = class extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.void,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n};\nZodVoid.create = (params)=>{\n    return new ZodVoid({\n        typeName: ZodFirstPartyTypeKind.ZodVoid,\n        ...processCreateParams(params)\n    });\n};\nvar ZodArray = class _ZodArray extends ZodType {\n    _parse(input) {\n        const { ctx, status } = this._processInputParams(input);\n        const def = this._def;\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        if (def.exactLength !== null) {\n            const tooBig = ctx.data.length > def.exactLength.value;\n            const tooSmall = ctx.data.length < def.exactLength.value;\n            if (tooBig || tooSmall) {\n                addIssueToContext(ctx, {\n                    code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,\n                    minimum: tooSmall ? def.exactLength.value : void 0,\n                    maximum: tooBig ? def.exactLength.value : void 0,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: true,\n                    message: def.exactLength.message\n                });\n                status.dirty();\n            }\n        }\n        if (def.minLength !== null) {\n            if (ctx.data.length < def.minLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minLength.message\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxLength !== null) {\n            if (ctx.data.length > def.maxLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxLength.message\n                });\n                status.dirty();\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.all([\n                ...ctx.data\n            ].map((item, i)=>{\n                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n            })).then((result2)=>{\n                return ParseStatus.mergeArray(status, result2);\n            });\n        }\n        const result = [\n            ...ctx.data\n        ].map((item, i)=>{\n            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n        });\n        return ParseStatus.mergeArray(status, result);\n    }\n    get element() {\n        return this._def.type;\n    }\n    min(minLength, message) {\n        return new _ZodArray({\n            ...this._def,\n            minLength: {\n                value: minLength,\n                message: errorUtil.toString(message)\n            }\n        });\n    }\n    max(maxLength, message) {\n        return new _ZodArray({\n            ...this._def,\n            maxLength: {\n                value: maxLength,\n                message: errorUtil.toString(message)\n            }\n        });\n    }\n    length(len, message) {\n        return new _ZodArray({\n            ...this._def,\n            exactLength: {\n                value: len,\n                message: errorUtil.toString(message)\n            }\n        });\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n};\nZodArray.create = (schema, params)=>{\n    return new ZodArray({\n        type: schema,\n        minLength: null,\n        maxLength: null,\n        exactLength: null,\n        typeName: ZodFirstPartyTypeKind.ZodArray,\n        ...processCreateParams(params)\n    });\n};\nfunction deepPartialify(schema) {\n    if (schema instanceof ZodObject) {\n        const newShape = {};\n        for(const key in schema.shape){\n            const fieldSchema = schema.shape[key];\n            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));\n        }\n        return new ZodObject({\n            ...schema._def,\n            shape: ()=>newShape\n        });\n    } else if (schema instanceof ZodArray) {\n        return new ZodArray({\n            ...schema._def,\n            type: deepPartialify(schema.element)\n        });\n    } else if (schema instanceof ZodOptional) {\n        return ZodOptional.create(deepPartialify(schema.unwrap()));\n    } else if (schema instanceof ZodNullable) {\n        return ZodNullable.create(deepPartialify(schema.unwrap()));\n    } else if (schema instanceof ZodTuple) {\n        return ZodTuple.create(schema.items.map((item)=>deepPartialify(item)));\n    } else {\n        return schema;\n    }\n}\nvar ZodObject = class _ZodObject extends ZodType {\n    constructor(){\n        super(...arguments);\n        this._cached = null;\n        this.nonstrict = this.passthrough;\n        this.augment = this.extend;\n    }\n    _getCached() {\n        if (this._cached !== null) return this._cached;\n        const shape = this._def.shape();\n        const keys = util.objectKeys(shape);\n        return this._cached = {\n            shape,\n            keys\n        };\n    }\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.object) {\n            const ctx2 = this._getOrReturnCtx(input);\n            addIssueToContext(ctx2, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx2.parsedType\n            });\n            return INVALID;\n        }\n        const { status, ctx } = this._processInputParams(input);\n        const { shape, keys: shapeKeys } = this._getCached();\n        const extraKeys = [];\n        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === \"strip\")) {\n            for(const key in ctx.data){\n                if (!shapeKeys.includes(key)) {\n                    extraKeys.push(key);\n                }\n            }\n        }\n        const pairs = [];\n        for (const key of shapeKeys){\n            const keyValidator = shape[key];\n            const value = ctx.data[key];\n            pairs.push({\n                key: {\n                    status: \"valid\",\n                    value: key\n                },\n                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n                alwaysSet: key in ctx.data\n            });\n        }\n        if (this._def.catchall instanceof ZodNever) {\n            const unknownKeys = this._def.unknownKeys;\n            if (unknownKeys === \"passthrough\") {\n                for (const key of extraKeys){\n                    pairs.push({\n                        key: {\n                            status: \"valid\",\n                            value: key\n                        },\n                        value: {\n                            status: \"valid\",\n                            value: ctx.data[key]\n                        }\n                    });\n                }\n            } else if (unknownKeys === \"strict\") {\n                if (extraKeys.length > 0) {\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.unrecognized_keys,\n                        keys: extraKeys\n                    });\n                    status.dirty();\n                }\n            } else if (unknownKeys === \"strip\") ;\n            else {\n                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);\n            }\n        } else {\n            const catchall = this._def.catchall;\n            for (const key of extraKeys){\n                const value = ctx.data[key];\n                pairs.push({\n                    key: {\n                        status: \"valid\",\n                        value: key\n                    },\n                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n                    alwaysSet: key in ctx.data\n                });\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.resolve().then(async ()=>{\n                const syncPairs = [];\n                for (const pair of pairs){\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    syncPairs.push({\n                        key,\n                        value,\n                        alwaysSet: pair.alwaysSet\n                    });\n                }\n                return syncPairs;\n            }).then((syncPairs)=>{\n                return ParseStatus.mergeObjectSync(status, syncPairs);\n            });\n        } else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get shape() {\n        return this._def.shape();\n    }\n    strict(message) {\n        errorUtil.errToObj;\n        return new _ZodObject({\n            ...this._def,\n            unknownKeys: \"strict\",\n            ...message !== void 0 ? {\n                errorMap: (issue, ctx)=>{\n                    var _a, _b, _c, _d;\n                    const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;\n                    if (issue.code === \"unrecognized_keys\") return {\n                        message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError\n                    };\n                    return {\n                        message: defaultError\n                    };\n                }\n            } : {}\n        });\n    }\n    strip() {\n        return new _ZodObject({\n            ...this._def,\n            unknownKeys: \"strip\"\n        });\n    }\n    passthrough() {\n        return new _ZodObject({\n            ...this._def,\n            unknownKeys: \"passthrough\"\n        });\n    }\n    // const AugmentFactory =\n    //   <Def extends ZodObjectDef>(def: Def) =>\n    //   <Augmentation extends ZodRawShape>(\n    //     augmentation: Augmentation\n    //   ): ZodObject<\n    //     extendShape<ReturnType<Def[\"shape\"]>, Augmentation>,\n    //     Def[\"unknownKeys\"],\n    //     Def[\"catchall\"]\n    //   > => {\n    //     return new ZodObject({\n    //       ...def,\n    //       shape: () => ({\n    //         ...def.shape(),\n    //         ...augmentation,\n    //       }),\n    //     }) as any;\n    //   };\n    extend(augmentation) {\n        return new _ZodObject({\n            ...this._def,\n            shape: ()=>({\n                    ...this._def.shape(),\n                    ...augmentation\n                })\n        });\n    }\n    /**\n   * Prior to zod@1.0.12 there was a bug in the\n   * inferred type of merged objects. Please\n   * upgrade if you are experiencing issues.\n   */ merge(merging) {\n        const merged = new _ZodObject({\n            unknownKeys: merging._def.unknownKeys,\n            catchall: merging._def.catchall,\n            shape: ()=>({\n                    ...this._def.shape(),\n                    ...merging._def.shape()\n                }),\n            typeName: ZodFirstPartyTypeKind.ZodObject\n        });\n        return merged;\n    }\n    // merge<\n    //   Incoming extends AnyZodObject,\n    //   Augmentation extends Incoming[\"shape\"],\n    //   NewOutput extends {\n    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_output\"]\n    //       : k extends keyof Output\n    //       ? Output[k]\n    //       : never;\n    //   },\n    //   NewInput extends {\n    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_input\"]\n    //       : k extends keyof Input\n    //       ? Input[k]\n    //       : never;\n    //   }\n    // >(\n    //   merging: Incoming\n    // ): ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"],\n    //   NewOutput,\n    //   NewInput\n    // > {\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    setKey(key, schema) {\n        return this.augment({\n            [key]: schema\n        });\n    }\n    // merge<Incoming extends AnyZodObject>(\n    //   merging: Incoming\n    // ): //ZodObject<T & Incoming[\"_shape\"], UnknownKeys, Catchall> = (merging) => {\n    // ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"]\n    // > {\n    //   // const mergedShape = objectUtil.mergeShapes(\n    //   //   this._def.shape(),\n    //   //   merging._def.shape()\n    //   // );\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    catchall(index) {\n        return new _ZodObject({\n            ...this._def,\n            catchall: index\n        });\n    }\n    pick(mask) {\n        const shape = {};\n        util.objectKeys(mask).forEach((key)=>{\n            if (mask[key] && this.shape[key]) {\n                shape[key] = this.shape[key];\n            }\n        });\n        return new _ZodObject({\n            ...this._def,\n            shape: ()=>shape\n        });\n    }\n    omit(mask) {\n        const shape = {};\n        util.objectKeys(this.shape).forEach((key)=>{\n            if (!mask[key]) {\n                shape[key] = this.shape[key];\n            }\n        });\n        return new _ZodObject({\n            ...this._def,\n            shape: ()=>shape\n        });\n    }\n    /**\n   * @deprecated\n   */ deepPartial() {\n        return deepPartialify(this);\n    }\n    partial(mask) {\n        const newShape = {};\n        util.objectKeys(this.shape).forEach((key)=>{\n            const fieldSchema = this.shape[key];\n            if (mask && !mask[key]) {\n                newShape[key] = fieldSchema;\n            } else {\n                newShape[key] = fieldSchema.optional();\n            }\n        });\n        return new _ZodObject({\n            ...this._def,\n            shape: ()=>newShape\n        });\n    }\n    required(mask) {\n        const newShape = {};\n        util.objectKeys(this.shape).forEach((key)=>{\n            if (mask && !mask[key]) {\n                newShape[key] = this.shape[key];\n            } else {\n                const fieldSchema = this.shape[key];\n                let newField = fieldSchema;\n                while(newField instanceof ZodOptional){\n                    newField = newField._def.innerType;\n                }\n                newShape[key] = newField;\n            }\n        });\n        return new _ZodObject({\n            ...this._def,\n            shape: ()=>newShape\n        });\n    }\n    keyof() {\n        return createZodEnum(util.objectKeys(this.shape));\n    }\n};\nZodObject.create = (shape, params)=>{\n    return new ZodObject({\n        shape: ()=>shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params)\n    });\n};\nZodObject.strictCreate = (shape, params)=>{\n    return new ZodObject({\n        shape: ()=>shape,\n        unknownKeys: \"strict\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params)\n    });\n};\nZodObject.lazycreate = (shape, params)=>{\n    return new ZodObject({\n        shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params)\n    });\n};\nvar ZodUnion = class extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const options = this._def.options;\n        function handleResults(results) {\n            for (const result of results){\n                if (result.result.status === \"valid\") {\n                    return result.result;\n                }\n            }\n            for (const result of results){\n                if (result.result.status === \"dirty\") {\n                    ctx.common.issues.push(...result.ctx.common.issues);\n                    return result.result;\n                }\n            }\n            const unionErrors = results.map((result)=>new ZodError(result.ctx.common.issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return Promise.all(options.map(async (option)=>{\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: []\n                    },\n                    parent: null\n                };\n                return {\n                    result: await option._parseAsync({\n                        data: ctx.data,\n                        path: ctx.path,\n                        parent: childCtx\n                    }),\n                    ctx: childCtx\n                };\n            })).then(handleResults);\n        } else {\n            let dirty = void 0;\n            const issues = [];\n            for (const option of options){\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: []\n                    },\n                    parent: null\n                };\n                const result = option._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: childCtx\n                });\n                if (result.status === \"valid\") {\n                    return result;\n                } else if (result.status === \"dirty\" && !dirty) {\n                    dirty = {\n                        result,\n                        ctx: childCtx\n                    };\n                }\n                if (childCtx.common.issues.length) {\n                    issues.push(childCtx.common.issues);\n                }\n            }\n            if (dirty) {\n                ctx.common.issues.push(...dirty.ctx.common.issues);\n                return dirty.result;\n            }\n            const unionErrors = issues.map((issues2)=>new ZodError(issues2));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors\n            });\n            return INVALID;\n        }\n    }\n    get options() {\n        return this._def.options;\n    }\n};\nZodUnion.create = (types, params)=>{\n    return new ZodUnion({\n        options: types,\n        typeName: ZodFirstPartyTypeKind.ZodUnion,\n        ...processCreateParams(params)\n    });\n};\nvar getDiscriminator = (type)=>{\n    if (type instanceof ZodLazy) {\n        return getDiscriminator(type.schema);\n    } else if (type instanceof ZodEffects) {\n        return getDiscriminator(type.innerType());\n    } else if (type instanceof ZodLiteral) {\n        return [\n            type.value\n        ];\n    } else if (type instanceof ZodEnum) {\n        return type.options;\n    } else if (type instanceof ZodNativeEnum) {\n        return util.objectValues(type.enum);\n    } else if (type instanceof ZodDefault) {\n        return getDiscriminator(type._def.innerType);\n    } else if (type instanceof ZodUndefined) {\n        return [\n            void 0\n        ];\n    } else if (type instanceof ZodNull) {\n        return [\n            null\n        ];\n    } else if (type instanceof ZodOptional) {\n        return [\n            void 0,\n            ...getDiscriminator(type.unwrap())\n        ];\n    } else if (type instanceof ZodNullable) {\n        return [\n            null,\n            ...getDiscriminator(type.unwrap())\n        ];\n    } else if (type instanceof ZodBranded) {\n        return getDiscriminator(type.unwrap());\n    } else if (type instanceof ZodReadonly) {\n        return getDiscriminator(type.unwrap());\n    } else if (type instanceof ZodCatch) {\n        return getDiscriminator(type._def.innerType);\n    } else {\n        return [];\n    }\n};\nvar ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        const discriminator = this.discriminator;\n        const discriminatorValue = ctx.data[discriminator];\n        const option = this.optionsMap.get(discriminatorValue);\n        if (!option) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union_discriminator,\n                options: Array.from(this.optionsMap.keys()),\n                path: [\n                    discriminator\n                ]\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return option._parseAsync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx\n            });\n        } else {\n            return option._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx\n            });\n        }\n    }\n    get discriminator() {\n        return this._def.discriminator;\n    }\n    get options() {\n        return this._def.options;\n    }\n    get optionsMap() {\n        return this._def.optionsMap;\n    }\n    /**\n   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.\n   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must\n   * have a different value for each object in the union.\n   * @param discriminator the name of the discriminator property\n   * @param types an array of object schemas\n   * @param params\n   */ static create(discriminator, options, params) {\n        const optionsMap = /* @__PURE__ */ new Map();\n        for (const type of options){\n            const discriminatorValues = getDiscriminator(type.shape[discriminator]);\n            if (!discriminatorValues.length) {\n                throw new Error(`A discriminator value for key \\`${discriminator}\\` could not be extracted from all schema options`);\n            }\n            for (const value of discriminatorValues){\n                if (optionsMap.has(value)) {\n                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);\n                }\n                optionsMap.set(value, type);\n            }\n        }\n        return new _ZodDiscriminatedUnion({\n            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\n            discriminator,\n            options,\n            optionsMap,\n            ...processCreateParams(params)\n        });\n    }\n};\nfunction mergeValues(a, b) {\n    const aType = getParsedType(a);\n    const bType = getParsedType(b);\n    if (a === b) {\n        return {\n            valid: true,\n            data: a\n        };\n    } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {\n        const bKeys = util.objectKeys(b);\n        const sharedKeys = util.objectKeys(a).filter((key)=>bKeys.indexOf(key) !== -1);\n        const newObj = {\n            ...a,\n            ...b\n        };\n        for (const key of sharedKeys){\n            const sharedValue = mergeValues(a[key], b[key]);\n            if (!sharedValue.valid) {\n                return {\n                    valid: false\n                };\n            }\n            newObj[key] = sharedValue.data;\n        }\n        return {\n            valid: true,\n            data: newObj\n        };\n    } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {\n        if (a.length !== b.length) {\n            return {\n                valid: false\n            };\n        }\n        const newArray = [];\n        for(let index = 0; index < a.length; index++){\n            const itemA = a[index];\n            const itemB = b[index];\n            const sharedValue = mergeValues(itemA, itemB);\n            if (!sharedValue.valid) {\n                return {\n                    valid: false\n                };\n            }\n            newArray.push(sharedValue.data);\n        }\n        return {\n            valid: true,\n            data: newArray\n        };\n    } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {\n        return {\n            valid: true,\n            data: a\n        };\n    } else {\n        return {\n            valid: false\n        };\n    }\n}\nvar ZodIntersection = class extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const handleParsed = (parsedLeft, parsedRight)=>{\n            if (isAborted(parsedLeft) || isAborted(parsedRight)) {\n                return INVALID;\n            }\n            const merged = mergeValues(parsedLeft.value, parsedRight.value);\n            if (!merged.valid) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.invalid_intersection_types\n                });\n                return INVALID;\n            }\n            if (isDirty(parsedLeft) || isDirty(parsedRight)) {\n                status.dirty();\n            }\n            return {\n                status: status.value,\n                value: merged.data\n            };\n        };\n        if (ctx.common.async) {\n            return Promise.all([\n                this._def.left._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx\n                }),\n                this._def.right._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx\n                })\n            ]).then(([left, right])=>handleParsed(left, right));\n        } else {\n            return handleParsed(this._def.left._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx\n            }), this._def.right._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx\n            }));\n        }\n    }\n};\nZodIntersection.create = (left, right, params)=>{\n    return new ZodIntersection({\n        left,\n        right,\n        typeName: ZodFirstPartyTypeKind.ZodIntersection,\n        ...processCreateParams(params)\n    });\n};\nvar ZodTuple = class _ZodTuple extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        if (ctx.data.length < this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_small,\n                minimum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\"\n            });\n            return INVALID;\n        }\n        const rest = this._def.rest;\n        if (!rest && ctx.data.length > this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_big,\n                maximum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\"\n            });\n            status.dirty();\n        }\n        const items = [\n            ...ctx.data\n        ].map((item, itemIndex)=>{\n            const schema = this._def.items[itemIndex] || this._def.rest;\n            if (!schema) return null;\n            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\n        }).filter((x)=>!!x);\n        if (ctx.common.async) {\n            return Promise.all(items).then((results)=>{\n                return ParseStatus.mergeArray(status, results);\n            });\n        } else {\n            return ParseStatus.mergeArray(status, items);\n        }\n    }\n    get items() {\n        return this._def.items;\n    }\n    rest(rest) {\n        return new _ZodTuple({\n            ...this._def,\n            rest\n        });\n    }\n};\nZodTuple.create = (schemas, params)=>{\n    if (!Array.isArray(schemas)) {\n        throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\n    }\n    return new ZodTuple({\n        items: schemas,\n        typeName: ZodFirstPartyTypeKind.ZodTuple,\n        rest: null,\n        ...processCreateParams(params)\n    });\n};\nvar ZodRecord = class _ZodRecord extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        const pairs = [];\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        for(const key in ctx.data){\n            pairs.push({\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\n                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),\n                alwaysSet: key in ctx.data\n            });\n        }\n        if (ctx.common.async) {\n            return ParseStatus.mergeObjectAsync(status, pairs);\n        } else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get element() {\n        return this._def.valueType;\n    }\n    static create(first, second, third) {\n        if (second instanceof ZodType) {\n            return new _ZodRecord({\n                keyType: first,\n                valueType: second,\n                typeName: ZodFirstPartyTypeKind.ZodRecord,\n                ...processCreateParams(third)\n            });\n        }\n        return new _ZodRecord({\n            keyType: ZodString.create(),\n            valueType: first,\n            typeName: ZodFirstPartyTypeKind.ZodRecord,\n            ...processCreateParams(second)\n        });\n    }\n};\nvar ZodMap = class extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.map) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.map,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        const pairs = [\n            ...ctx.data.entries()\n        ].map(([key, value], index)=>{\n            return {\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [\n                    index,\n                    \"key\"\n                ])),\n                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [\n                    index,\n                    \"value\"\n                ]))\n            };\n        });\n        if (ctx.common.async) {\n            const finalMap = /* @__PURE__ */ new Map();\n            return Promise.resolve().then(async ()=>{\n                for (const pair of pairs){\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    if (key.status === \"aborted\" || value.status === \"aborted\") {\n                        return INVALID;\n                    }\n                    if (key.status === \"dirty\" || value.status === \"dirty\") {\n                        status.dirty();\n                    }\n                    finalMap.set(key.value, value.value);\n                }\n                return {\n                    status: status.value,\n                    value: finalMap\n                };\n            });\n        } else {\n            const finalMap = /* @__PURE__ */ new Map();\n            for (const pair of pairs){\n                const key = pair.key;\n                const value = pair.value;\n                if (key.status === \"aborted\" || value.status === \"aborted\") {\n                    return INVALID;\n                }\n                if (key.status === \"dirty\" || value.status === \"dirty\") {\n                    status.dirty();\n                }\n                finalMap.set(key.value, value.value);\n            }\n            return {\n                status: status.value,\n                value: finalMap\n            };\n        }\n    }\n};\nZodMap.create = (keyType, valueType, params)=>{\n    return new ZodMap({\n        valueType,\n        keyType,\n        typeName: ZodFirstPartyTypeKind.ZodMap,\n        ...processCreateParams(params)\n    });\n};\nvar ZodSet = class _ZodSet extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.set) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.set,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        const def = this._def;\n        if (def.minSize !== null) {\n            if (ctx.data.size < def.minSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minSize.message\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxSize !== null) {\n            if (ctx.data.size > def.maxSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxSize.message\n                });\n                status.dirty();\n            }\n        }\n        const valueType = this._def.valueType;\n        function finalizeSet(elements2) {\n            const parsedSet = /* @__PURE__ */ new Set();\n            for (const element of elements2){\n                if (element.status === \"aborted\") return INVALID;\n                if (element.status === \"dirty\") status.dirty();\n                parsedSet.add(element.value);\n            }\n            return {\n                status: status.value,\n                value: parsedSet\n            };\n        }\n        const elements = [\n            ...ctx.data.values()\n        ].map((item, i)=>valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));\n        if (ctx.common.async) {\n            return Promise.all(elements).then((elements2)=>finalizeSet(elements2));\n        } else {\n            return finalizeSet(elements);\n        }\n    }\n    min(minSize, message) {\n        return new _ZodSet({\n            ...this._def,\n            minSize: {\n                value: minSize,\n                message: errorUtil.toString(message)\n            }\n        });\n    }\n    max(maxSize, message) {\n        return new _ZodSet({\n            ...this._def,\n            maxSize: {\n                value: maxSize,\n                message: errorUtil.toString(message)\n            }\n        });\n    }\n    size(size, message) {\n        return this.min(size, message).max(size, message);\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n};\nZodSet.create = (valueType, params)=>{\n    return new ZodSet({\n        valueType,\n        minSize: null,\n        maxSize: null,\n        typeName: ZodFirstPartyTypeKind.ZodSet,\n        ...processCreateParams(params)\n    });\n};\nvar ZodFunction = class _ZodFunction extends ZodType {\n    constructor(){\n        super(...arguments);\n        this.validate = this.implement;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.function) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.function,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        function makeArgsIssue(args, error) {\n            return makeIssue({\n                data: args,\n                path: ctx.path,\n                errorMaps: [\n                    ctx.common.contextualErrorMap,\n                    ctx.schemaErrorMap,\n                    getErrorMap(),\n                    errorMap\n                ].filter((x)=>!!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_arguments,\n                    argumentsError: error\n                }\n            });\n        }\n        function makeReturnsIssue(returns, error) {\n            return makeIssue({\n                data: returns,\n                path: ctx.path,\n                errorMaps: [\n                    ctx.common.contextualErrorMap,\n                    ctx.schemaErrorMap,\n                    getErrorMap(),\n                    errorMap\n                ].filter((x)=>!!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_return_type,\n                    returnTypeError: error\n                }\n            });\n        }\n        const params = {\n            errorMap: ctx.common.contextualErrorMap\n        };\n        const fn = ctx.data;\n        if (this._def.returns instanceof ZodPromise) {\n            const me = this;\n            return OK(async function(...args) {\n                const error = new ZodError([]);\n                const parsedArgs = await me._def.args.parseAsync(args, params).catch((e)=>{\n                    error.addIssue(makeArgsIssue(args, e));\n                    throw error;\n                });\n                const result = await Reflect.apply(fn, this, parsedArgs);\n                const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e)=>{\n                    error.addIssue(makeReturnsIssue(result, e));\n                    throw error;\n                });\n                return parsedReturns;\n            });\n        } else {\n            const me = this;\n            return OK(function(...args) {\n                const parsedArgs = me._def.args.safeParse(args, params);\n                if (!parsedArgs.success) {\n                    throw new ZodError([\n                        makeArgsIssue(args, parsedArgs.error)\n                    ]);\n                }\n                const result = Reflect.apply(fn, this, parsedArgs.data);\n                const parsedReturns = me._def.returns.safeParse(result, params);\n                if (!parsedReturns.success) {\n                    throw new ZodError([\n                        makeReturnsIssue(result, parsedReturns.error)\n                    ]);\n                }\n                return parsedReturns.data;\n            });\n        }\n    }\n    parameters() {\n        return this._def.args;\n    }\n    returnType() {\n        return this._def.returns;\n    }\n    args(...items) {\n        return new _ZodFunction({\n            ...this._def,\n            args: ZodTuple.create(items).rest(ZodUnknown.create())\n        });\n    }\n    returns(returnType) {\n        return new _ZodFunction({\n            ...this._def,\n            returns: returnType\n        });\n    }\n    implement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    strictImplement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    static create(args, returns, params) {\n        return new _ZodFunction({\n            args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),\n            returns: returns || ZodUnknown.create(),\n            typeName: ZodFirstPartyTypeKind.ZodFunction,\n            ...processCreateParams(params)\n        });\n    }\n};\nvar ZodLazy = class extends ZodType {\n    get schema() {\n        return this._def.getter();\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const lazySchema = this._def.getter();\n        return lazySchema._parse({\n            data: ctx.data,\n            path: ctx.path,\n            parent: ctx\n        });\n    }\n};\nZodLazy.create = (getter, params)=>{\n    return new ZodLazy({\n        getter,\n        typeName: ZodFirstPartyTypeKind.ZodLazy,\n        ...processCreateParams(params)\n    });\n};\nvar ZodLiteral = class extends ZodType {\n    _parse(input) {\n        if (input.data !== this._def.value) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_literal,\n                expected: this._def.value\n            });\n            return INVALID;\n        }\n        return {\n            status: \"valid\",\n            value: input.data\n        };\n    }\n    get value() {\n        return this._def.value;\n    }\n};\nZodLiteral.create = (value, params)=>{\n    return new ZodLiteral({\n        value,\n        typeName: ZodFirstPartyTypeKind.ZodLiteral,\n        ...processCreateParams(params)\n    });\n};\nfunction createZodEnum(values, params) {\n    return new ZodEnum({\n        values,\n        typeName: ZodFirstPartyTypeKind.ZodEnum,\n        ...processCreateParams(params)\n    });\n}\nvar ZodEnum = class _ZodEnum extends ZodType {\n    constructor(){\n        super(...arguments);\n        _ZodEnum_cache.set(this, void 0);\n    }\n    _parse(input) {\n        if (typeof input.data !== \"string\") {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type\n            });\n            return INVALID;\n        }\n        if (!__classPrivateFieldGet(this, _ZodEnum_cache, \"f\")) {\n            __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), \"f\");\n        }\n        if (!__classPrivateFieldGet(this, _ZodEnum_cache, \"f\").has(input.data)) {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get options() {\n        return this._def.values;\n    }\n    get enum() {\n        const enumValues = {};\n        for (const val of this._def.values){\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Values() {\n        const enumValues = {};\n        for (const val of this._def.values){\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Enum() {\n        const enumValues = {};\n        for (const val of this._def.values){\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    extract(values, newDef = this._def) {\n        return _ZodEnum.create(values, {\n            ...this._def,\n            ...newDef\n        });\n    }\n    exclude(values, newDef = this._def) {\n        return _ZodEnum.create(this.options.filter((opt)=>!values.includes(opt)), {\n            ...this._def,\n            ...newDef\n        });\n    }\n};\n_ZodEnum_cache = /* @__PURE__ */ new WeakMap();\nZodEnum.create = createZodEnum;\nvar ZodNativeEnum = class extends ZodType {\n    constructor(){\n        super(...arguments);\n        _ZodNativeEnum_cache.set(this, void 0);\n    }\n    _parse(input) {\n        const nativeEnumValues = util.getValidEnumValues(this._def.values);\n        const ctx = this._getOrReturnCtx(input);\n        if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type\n            });\n            return INVALID;\n        }\n        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, \"f\")) {\n            __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), \"f\");\n        }\n        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, \"f\").has(input.data)) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get enum() {\n        return this._def.values;\n    }\n};\n_ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();\nZodNativeEnum.create = (values, params)=>{\n    return new ZodNativeEnum({\n        values,\n        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,\n        ...processCreateParams(params)\n    });\n};\nvar ZodPromise = class extends ZodType {\n    unwrap() {\n        return this._def.type;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.promise,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);\n        return OK(promisified.then((data)=>{\n            return this._def.type.parseAsync(data, {\n                path: ctx.path,\n                errorMap: ctx.common.contextualErrorMap\n            });\n        }));\n    }\n};\nZodPromise.create = (schema, params)=>{\n    return new ZodPromise({\n        type: schema,\n        typeName: ZodFirstPartyTypeKind.ZodPromise,\n        ...processCreateParams(params)\n    });\n};\nvar ZodEffects = class extends ZodType {\n    innerType() {\n        return this._def.schema;\n    }\n    sourceType() {\n        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const effect = this._def.effect || null;\n        const checkCtx = {\n            addIssue: (arg)=>{\n                addIssueToContext(ctx, arg);\n                if (arg.fatal) {\n                    status.abort();\n                } else {\n                    status.dirty();\n                }\n            },\n            get path () {\n                return ctx.path;\n            }\n        };\n        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\n        if (effect.type === \"preprocess\") {\n            const processed = effect.transform(ctx.data, checkCtx);\n            if (ctx.common.async) {\n                return Promise.resolve(processed).then(async (processed2)=>{\n                    if (status.value === \"aborted\") return INVALID;\n                    const result = await this._def.schema._parseAsync({\n                        data: processed2,\n                        path: ctx.path,\n                        parent: ctx\n                    });\n                    if (result.status === \"aborted\") return INVALID;\n                    if (result.status === \"dirty\") return DIRTY(result.value);\n                    if (status.value === \"dirty\") return DIRTY(result.value);\n                    return result;\n                });\n            } else {\n                if (status.value === \"aborted\") return INVALID;\n                const result = this._def.schema._parseSync({\n                    data: processed,\n                    path: ctx.path,\n                    parent: ctx\n                });\n                if (result.status === \"aborted\") return INVALID;\n                if (result.status === \"dirty\") return DIRTY(result.value);\n                if (status.value === \"dirty\") return DIRTY(result.value);\n                return result;\n            }\n        }\n        if (effect.type === \"refinement\") {\n            const executeRefinement = (acc)=>{\n                const result = effect.refinement(acc, checkCtx);\n                if (ctx.common.async) {\n                    return Promise.resolve(result);\n                }\n                if (result instanceof Promise) {\n                    throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n                }\n                return acc;\n            };\n            if (ctx.common.async === false) {\n                const inner = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx\n                });\n                if (inner.status === \"aborted\") return INVALID;\n                if (inner.status === \"dirty\") status.dirty();\n                executeRefinement(inner.value);\n                return {\n                    status: status.value,\n                    value: inner.value\n                };\n            } else {\n                return this._def.schema._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx\n                }).then((inner)=>{\n                    if (inner.status === \"aborted\") return INVALID;\n                    if (inner.status === \"dirty\") status.dirty();\n                    return executeRefinement(inner.value).then(()=>{\n                        return {\n                            status: status.value,\n                            value: inner.value\n                        };\n                    });\n                });\n            }\n        }\n        if (effect.type === \"transform\") {\n            if (ctx.common.async === false) {\n                const base = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx\n                });\n                if (!isValid(base)) return base;\n                const result = effect.transform(base.value, checkCtx);\n                if (result instanceof Promise) {\n                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);\n                }\n                return {\n                    status: status.value,\n                    value: result\n                };\n            } else {\n                return this._def.schema._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx\n                }).then((base)=>{\n                    if (!isValid(base)) return base;\n                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result)=>({\n                            status: status.value,\n                            value: result\n                        }));\n                });\n            }\n        }\n        util.assertNever(effect);\n    }\n};\nZodEffects.create = (schema, effect, params)=>{\n    return new ZodEffects({\n        schema,\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        effect,\n        ...processCreateParams(params)\n    });\n};\nZodEffects.createWithPreprocess = (preprocess, schema, params)=>{\n    return new ZodEffects({\n        schema,\n        effect: {\n            type: \"preprocess\",\n            transform: preprocess\n        },\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        ...processCreateParams(params)\n    });\n};\nvar ZodOptional = class extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.undefined) {\n            return OK(void 0);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n};\nZodOptional.create = (type, params)=>{\n    return new ZodOptional({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodOptional,\n        ...processCreateParams(params)\n    });\n};\nvar ZodNullable = class extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.null) {\n            return OK(null);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n};\nZodNullable.create = (type, params)=>{\n    return new ZodNullable({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodNullable,\n        ...processCreateParams(params)\n    });\n};\nvar ZodDefault = class extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        let data = ctx.data;\n        if (ctx.parsedType === ZodParsedType.undefined) {\n            data = this._def.defaultValue();\n        }\n        return this._def.innerType._parse({\n            data,\n            path: ctx.path,\n            parent: ctx\n        });\n    }\n    removeDefault() {\n        return this._def.innerType;\n    }\n};\nZodDefault.create = (type, params)=>{\n    return new ZodDefault({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodDefault,\n        defaultValue: typeof params.default === \"function\" ? params.default : ()=>params.default,\n        ...processCreateParams(params)\n    });\n};\nvar ZodCatch = class extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const newCtx = {\n            ...ctx,\n            common: {\n                ...ctx.common,\n                issues: []\n            }\n        };\n        const result = this._def.innerType._parse({\n            data: newCtx.data,\n            path: newCtx.path,\n            parent: {\n                ...newCtx\n            }\n        });\n        if (isAsync(result)) {\n            return result.then((result2)=>{\n                return {\n                    status: \"valid\",\n                    value: result2.status === \"valid\" ? result2.value : this._def.catchValue({\n                        get error () {\n                            return new ZodError(newCtx.common.issues);\n                        },\n                        input: newCtx.data\n                    })\n                };\n            });\n        } else {\n            return {\n                status: \"valid\",\n                value: result.status === \"valid\" ? result.value : this._def.catchValue({\n                    get error () {\n                        return new ZodError(newCtx.common.issues);\n                    },\n                    input: newCtx.data\n                })\n            };\n        }\n    }\n    removeCatch() {\n        return this._def.innerType;\n    }\n};\nZodCatch.create = (type, params)=>{\n    return new ZodCatch({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodCatch,\n        catchValue: typeof params.catch === \"function\" ? params.catch : ()=>params.catch,\n        ...processCreateParams(params)\n    });\n};\nvar ZodNaN = class extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.nan) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.nan,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        return {\n            status: \"valid\",\n            value: input.data\n        };\n    }\n};\nZodNaN.create = (params)=>{\n    return new ZodNaN({\n        typeName: ZodFirstPartyTypeKind.ZodNaN,\n        ...processCreateParams(params)\n    });\n};\nvar BRAND = Symbol(\"zod_brand\");\nvar ZodBranded = class extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const data = ctx.data;\n        return this._def.type._parse({\n            data,\n            path: ctx.path,\n            parent: ctx\n        });\n    }\n    unwrap() {\n        return this._def.type;\n    }\n};\nvar ZodPipeline = class _ZodPipeline extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.common.async) {\n            const handleAsync = async ()=>{\n                const inResult = await this._def.in._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx\n                });\n                if (inResult.status === \"aborted\") return INVALID;\n                if (inResult.status === \"dirty\") {\n                    status.dirty();\n                    return DIRTY(inResult.value);\n                } else {\n                    return this._def.out._parseAsync({\n                        data: inResult.value,\n                        path: ctx.path,\n                        parent: ctx\n                    });\n                }\n            };\n            return handleAsync();\n        } else {\n            const inResult = this._def.in._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx\n            });\n            if (inResult.status === \"aborted\") return INVALID;\n            if (inResult.status === \"dirty\") {\n                status.dirty();\n                return {\n                    status: \"dirty\",\n                    value: inResult.value\n                };\n            } else {\n                return this._def.out._parseSync({\n                    data: inResult.value,\n                    path: ctx.path,\n                    parent: ctx\n                });\n            }\n        }\n    }\n    static create(a, b) {\n        return new _ZodPipeline({\n            in: a,\n            out: b,\n            typeName: ZodFirstPartyTypeKind.ZodPipeline\n        });\n    }\n};\nvar ZodReadonly = class extends ZodType {\n    _parse(input) {\n        const result = this._def.innerType._parse(input);\n        const freeze = (data)=>{\n            if (isValid(data)) {\n                data.value = Object.freeze(data.value);\n            }\n            return data;\n        };\n        return isAsync(result) ? result.then((data)=>freeze(data)) : freeze(result);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n};\nZodReadonly.create = (type, params)=>{\n    return new ZodReadonly({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodReadonly,\n        ...processCreateParams(params)\n    });\n};\nfunction custom(check, params = {}, fatal) {\n    if (check) return ZodAny.create().superRefine((data, ctx)=>{\n        var _a, _b;\n        if (!check(data)) {\n            const p = typeof params === \"function\" ? params(data) : typeof params === \"string\" ? {\n                message: params\n            } : params;\n            const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;\n            const p2 = typeof p === \"string\" ? {\n                message: p\n            } : p;\n            ctx.addIssue({\n                code: \"custom\",\n                ...p2,\n                fatal: _fatal\n            });\n        }\n    });\n    return ZodAny.create();\n}\nvar late = {\n    object: ZodObject.lazycreate\n};\nvar ZodFirstPartyTypeKind;\n(function(ZodFirstPartyTypeKind2) {\n    ZodFirstPartyTypeKind2[\"ZodString\"] = \"ZodString\";\n    ZodFirstPartyTypeKind2[\"ZodNumber\"] = \"ZodNumber\";\n    ZodFirstPartyTypeKind2[\"ZodNaN\"] = \"ZodNaN\";\n    ZodFirstPartyTypeKind2[\"ZodBigInt\"] = \"ZodBigInt\";\n    ZodFirstPartyTypeKind2[\"ZodBoolean\"] = \"ZodBoolean\";\n    ZodFirstPartyTypeKind2[\"ZodDate\"] = \"ZodDate\";\n    ZodFirstPartyTypeKind2[\"ZodSymbol\"] = \"ZodSymbol\";\n    ZodFirstPartyTypeKind2[\"ZodUndefined\"] = \"ZodUndefined\";\n    ZodFirstPartyTypeKind2[\"ZodNull\"] = \"ZodNull\";\n    ZodFirstPartyTypeKind2[\"ZodAny\"] = \"ZodAny\";\n    ZodFirstPartyTypeKind2[\"ZodUnknown\"] = \"ZodUnknown\";\n    ZodFirstPartyTypeKind2[\"ZodNever\"] = \"ZodNever\";\n    ZodFirstPartyTypeKind2[\"ZodVoid\"] = \"ZodVoid\";\n    ZodFirstPartyTypeKind2[\"ZodArray\"] = \"ZodArray\";\n    ZodFirstPartyTypeKind2[\"ZodObject\"] = \"ZodObject\";\n    ZodFirstPartyTypeKind2[\"ZodUnion\"] = \"ZodUnion\";\n    ZodFirstPartyTypeKind2[\"ZodDiscriminatedUnion\"] = \"ZodDiscriminatedUnion\";\n    ZodFirstPartyTypeKind2[\"ZodIntersection\"] = \"ZodIntersection\";\n    ZodFirstPartyTypeKind2[\"ZodTuple\"] = \"ZodTuple\";\n    ZodFirstPartyTypeKind2[\"ZodRecord\"] = \"ZodRecord\";\n    ZodFirstPartyTypeKind2[\"ZodMap\"] = \"ZodMap\";\n    ZodFirstPartyTypeKind2[\"ZodSet\"] = \"ZodSet\";\n    ZodFirstPartyTypeKind2[\"ZodFunction\"] = \"ZodFunction\";\n    ZodFirstPartyTypeKind2[\"ZodLazy\"] = \"ZodLazy\";\n    ZodFirstPartyTypeKind2[\"ZodLiteral\"] = \"ZodLiteral\";\n    ZodFirstPartyTypeKind2[\"ZodEnum\"] = \"ZodEnum\";\n    ZodFirstPartyTypeKind2[\"ZodEffects\"] = \"ZodEffects\";\n    ZodFirstPartyTypeKind2[\"ZodNativeEnum\"] = \"ZodNativeEnum\";\n    ZodFirstPartyTypeKind2[\"ZodOptional\"] = \"ZodOptional\";\n    ZodFirstPartyTypeKind2[\"ZodNullable\"] = \"ZodNullable\";\n    ZodFirstPartyTypeKind2[\"ZodDefault\"] = \"ZodDefault\";\n    ZodFirstPartyTypeKind2[\"ZodCatch\"] = \"ZodCatch\";\n    ZodFirstPartyTypeKind2[\"ZodPromise\"] = \"ZodPromise\";\n    ZodFirstPartyTypeKind2[\"ZodBranded\"] = \"ZodBranded\";\n    ZodFirstPartyTypeKind2[\"ZodPipeline\"] = \"ZodPipeline\";\n    ZodFirstPartyTypeKind2[\"ZodReadonly\"] = \"ZodReadonly\";\n})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));\nvar instanceOfType = (cls, params = {\n    message: `Input not instance of ${cls.name}`\n})=>custom((data)=>data instanceof cls, params);\nvar stringType = ZodString.create;\nvar numberType = ZodNumber.create;\nvar nanType = ZodNaN.create;\nvar bigIntType = ZodBigInt.create;\nvar booleanType = ZodBoolean.create;\nvar dateType = ZodDate.create;\nvar symbolType = ZodSymbol.create;\nvar undefinedType = ZodUndefined.create;\nvar nullType = ZodNull.create;\nvar anyType = ZodAny.create;\nvar unknownType = ZodUnknown.create;\nvar neverType = ZodNever.create;\nvar voidType = ZodVoid.create;\nvar arrayType = ZodArray.create;\nvar objectType = ZodObject.create;\nvar strictObjectType = ZodObject.strictCreate;\nvar unionType = ZodUnion.create;\nvar discriminatedUnionType = ZodDiscriminatedUnion.create;\nvar intersectionType = ZodIntersection.create;\nvar tupleType = ZodTuple.create;\nvar recordType = ZodRecord.create;\nvar mapType = ZodMap.create;\nvar setType = ZodSet.create;\nvar functionType = ZodFunction.create;\nvar lazyType = ZodLazy.create;\nvar literalType = ZodLiteral.create;\nvar enumType = ZodEnum.create;\nvar nativeEnumType = ZodNativeEnum.create;\nvar promiseType = ZodPromise.create;\nvar effectsType = ZodEffects.create;\nvar optionalType = ZodOptional.create;\nvar nullableType = ZodNullable.create;\nvar preprocessType = ZodEffects.createWithPreprocess;\nvar pipelineType = ZodPipeline.create;\nvar ostring = ()=>stringType().optional();\nvar onumber = ()=>numberType().optional();\nvar oboolean = ()=>booleanType().optional();\nvar coerce = {\n    string: (arg)=>ZodString.create({\n            ...arg,\n            coerce: true\n        }),\n    number: (arg)=>ZodNumber.create({\n            ...arg,\n            coerce: true\n        }),\n    boolean: (arg)=>ZodBoolean.create({\n            ...arg,\n            coerce: true\n        }),\n    bigint: (arg)=>ZodBigInt.create({\n            ...arg,\n            coerce: true\n        }),\n    date: (arg)=>ZodDate.create({\n            ...arg,\n            coerce: true\n        })\n};\nvar NEVER = INVALID;\nvar z = /* @__PURE__ */ Object.freeze({\n    __proto__: null,\n    defaultErrorMap: errorMap,\n    setErrorMap,\n    getErrorMap,\n    makeIssue,\n    EMPTY_PATH,\n    addIssueToContext,\n    ParseStatus,\n    INVALID,\n    DIRTY,\n    OK,\n    isAborted,\n    isDirty,\n    isValid,\n    isAsync,\n    get util () {\n        return util;\n    },\n    get objectUtil () {\n        return objectUtil;\n    },\n    ZodParsedType,\n    getParsedType,\n    ZodType,\n    datetimeRegex,\n    ZodString,\n    ZodNumber,\n    ZodBigInt,\n    ZodBoolean,\n    ZodDate,\n    ZodSymbol,\n    ZodUndefined,\n    ZodNull,\n    ZodAny,\n    ZodUnknown,\n    ZodNever,\n    ZodVoid,\n    ZodArray,\n    ZodObject,\n    ZodUnion,\n    ZodDiscriminatedUnion,\n    ZodIntersection,\n    ZodTuple,\n    ZodRecord,\n    ZodMap,\n    ZodSet,\n    ZodFunction,\n    ZodLazy,\n    ZodLiteral,\n    ZodEnum,\n    ZodNativeEnum,\n    ZodPromise,\n    ZodEffects,\n    ZodTransformer: ZodEffects,\n    ZodOptional,\n    ZodNullable,\n    ZodDefault,\n    ZodCatch,\n    ZodNaN,\n    BRAND,\n    ZodBranded,\n    ZodPipeline,\n    ZodReadonly,\n    custom,\n    Schema: ZodType,\n    ZodSchema: ZodType,\n    late,\n    get ZodFirstPartyTypeKind () {\n        return ZodFirstPartyTypeKind;\n    },\n    coerce,\n    any: anyType,\n    array: arrayType,\n    bigint: bigIntType,\n    boolean: booleanType,\n    date: dateType,\n    discriminatedUnion: discriminatedUnionType,\n    effect: effectsType,\n    \"enum\": enumType,\n    \"function\": functionType,\n    \"instanceof\": instanceOfType,\n    intersection: intersectionType,\n    lazy: lazyType,\n    literal: literalType,\n    map: mapType,\n    nan: nanType,\n    nativeEnum: nativeEnumType,\n    never: neverType,\n    \"null\": nullType,\n    nullable: nullableType,\n    number: numberType,\n    object: objectType,\n    oboolean,\n    onumber,\n    optional: optionalType,\n    ostring,\n    pipeline: pipelineType,\n    preprocess: preprocessType,\n    promise: promiseType,\n    record: recordType,\n    set: setType,\n    strictObject: strictObjectType,\n    string: stringType,\n    symbol: symbolType,\n    transformer: effectsType,\n    tuple: tupleType,\n    \"undefined\": undefinedType,\n    union: unionType,\n    unknown: unknownType,\n    \"void\": voidType,\n    NEVER,\n    ZodIssueCode,\n    quotelessJson,\n    ZodError\n});\n// package.json\nvar package_default = {\n    name: \"@imgly/background-removal\",\n    version: \"1.5.8\",\n    description: \"Background Removal in the Browser\",\n    keywords: [\n        \"background-removal\",\n        \"client-side\",\n        \"data-privacy\",\n        \"image-segmentation\",\n        \"image-matting\",\n        \"onnx\"\n    ],\n    repository: {\n        type: \"git\",\n        url: \"git+https://github.com/imgly/background-removal-js.git\"\n    },\n    license: \"SEE LICENSE IN LICENSE.md\",\n    author: {\n        name: \"IMG.LY GmbH\",\n        email: \"support@img.ly\",\n        url: \"https://img.ly\"\n    },\n    bugs: {\n        email: \"support@img.ly\"\n    },\n    source: \"./src/index.ts\",\n    main: \"./dist/index.cjs\",\n    module: \"./dist/index.mjs\",\n    types: \"./dist/src/index.d.ts\",\n    exports: {\n        \".\": {\n            require: \"./dist/index.cjs\",\n            import: \"./dist/index.mjs\",\n            types: \"./dist/src/index.d.ts\"\n        }\n    },\n    homepage: \"https://img.ly/showcases/cesdk/web/background-removal\",\n    files: [\n        \"LICENSE.md\",\n        \"README.md\",\n        \"CHANGELOG.md\",\n        \"ThirdPartyLicenses.json\",\n        \"dist/\",\n        \"bin/\"\n    ],\n    scripts: {\n        start: \"npm run watch\",\n        clean: \"npx rimraf dist\",\n        test: \"true\",\n        resources: \"node ../../scripts/package-resources.mjs\",\n        \"changelog:create\": \"node ../../scripts/changelog/changelog-create.mjs\",\n        \"changelog:generate\": \"node ../../scripts/changelog/changelog-generate.mjs\",\n        build: \"npm run clean && npm run types && npm run resources && npm run changelog:generate && node scripts/build.mjs\",\n        types: \" npx tsc --declaration --emitDeclarationOnly --declarationDir dist --declarationMap\",\n        watch: \"npm run clean && npm run resources && npm run changelog:generate && node scripts/watch.mjs\",\n        \"publish:latest\": \"npm publish --tag latest --access public\",\n        \"publish:next\": \"npm publish --tag next --access public\",\n        \"package:pack\": \"npm pack . --pack-destination ../../releases\",\n        lint: \"npx prettier --write .\"\n    },\n    dependencies: {\n        \"lodash-es\": \"^4.17.21\",\n        ndarray: \"~1.0.0\",\n        zod: \"^3.23.8\"\n    },\n    peerDependencies: {\n        \"onnxruntime-web\": \"1.21.0-dev.20250114-228dd16893\"\n    },\n    devDependencies: {\n        \"@types/lodash-es\": \"^4.17.12\",\n        \"@types/ndarray\": \"~1.0.14\",\n        \"@types/node\": \"~20.3.0\",\n        assert: \"~2.0.0\",\n        esbuild: \"~0.18.0\",\n        glob: \"~10.3.0\",\n        \"npm-dts\": \"~1.3.0\",\n        process: \"~0.11.0\",\n        \"ts-loader\": \"~9.4.0\",\n        tslib: \"~2.5.0\",\n        typescript: \"~5.1.0\",\n        util: \"~0.12.0\",\n        webpack: \"~5.85.0\",\n        \"webpack-cli\": \"~5.1.0\"\n    },\n    bundleDependencies: []\n};\n// src/schema.ts\nvar ConfigSchema = z.object({\n    publicPath: z.string().optional().describe(\"The public path to the wasm files and the onnx model.\").default(\"https://staticimgly.com/@imgly/background-removal-data/${PACKAGE_VERSION}/dist/\").transform((val)=>{\n        return val.replace(\"${PACKAGE_NAME}\", package_default.name).replace(\"${PACKAGE_VERSION}\", package_default.version);\n    }),\n    debug: z.boolean().default(false).describe(\"Whether to enable debug logging.\"),\n    rescale: z.boolean().default(true).describe(\"Whether to rescale the image.\"),\n    device: z.enum([\n        \"cpu\",\n        \"gpu\"\n    ]).default(\"cpu\").describe(\"The device to run the model on.\"),\n    proxyToWorker: z.boolean().default(false).describe(\"Whether to proxy inference to a web worker.\"),\n    fetchArgs: z.any().default({}).describe(\"Arguments to pass to fetch when loading the model.\"),\n    progress: z.function().args(z.string(), z.number(), z.number()).returns(z.void()).describe(\"Progress callback.\").optional(),\n    model: z.preprocess((val)=>{\n        switch(val){\n            case \"large\":\n                return \"isnet\";\n            case \"small\":\n                return \"isnet_quint8\";\n            case \"medium\":\n                return \"isnet_fp16\";\n            default:\n                return val;\n        }\n    }, z.enum([\n        \"isnet\",\n        \"isnet_fp16\",\n        \"isnet_quint8\"\n    ])).default(\"medium\"),\n    output: z.object({\n        format: z.enum([\n            \"image/png\",\n            \"image/jpeg\",\n            \"image/webp\",\n            \"image/x-rgba8\",\n            \"image/x-alpha8\"\n        ]).default(\"image/png\"),\n        quality: z.number().default(0.8)\n    }).default({})\n}).default({}).transform((config)=>{\n    if (config.debug) console.log(\"Config:\", config);\n    if (config.debug && !config.progress) {\n        config.progress = config.progress ?? ((key, current, total)=>{\n            console.debug(`Downloading ${key}: ${current} of ${total}`);\n        });\n        if (!crossOriginIsolated) {\n            if (config.debug) console.debug(\"Cross-Origin-Isolated is not enabled. Performance will be degraded. Please see  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer.\");\n        }\n    }\n    return config;\n});\nfunction validateConfig(configuration) {\n    return ConfigSchema.parse(configuration ?? {});\n}\n// src/inference.ts\nvar import_ndarray4 = __toESM(require_ndarray());\nasync function initBase(config) {\n    if (config.debug) console.debug(\"Loading model...\", config.model);\n    const model = config.model;\n    const blob = await loadAsBlob(`/models/${model}`, config);\n    const arrayBuffer = await blob.arrayBuffer();\n    const session = await createOnnxSession(arrayBuffer, config);\n    return session;\n}\nasync function initInference(config) {\n    config = validateConfig(config);\n    const base = await initBase(config);\n    return {\n        config,\n        session: {\n            base\n        }\n    };\n}\nasync function runInference(imageTensor, config, session) {\n    const resolution = 1024;\n    const [srcHeight, srcWidth, srcChannels] = imageTensor.shape;\n    const keepAspect = false;\n    let resizedImageTensor = tensorResizeBilinear(imageTensor, resolution, resolution, keepAspect);\n    const inputTensor = tensorHWCtoBCHW(resizedImageTensor);\n    let predictionsDict = await runOnnxSession(session.base, [\n        [\n            \"input\",\n            inputTensor\n        ]\n    ], [\n        \"output\"\n    ], config);\n    let alphamask2 = (0, import_ndarray4.default)(predictionsDict[0].data, [\n        resolution,\n        resolution,\n        1\n    ]);\n    let alphamaskU8 = convertFloat32ToUint8(alphamask2);\n    if (config.rescale) {\n        alphamaskU8 = tensorResizeBilinear(alphamaskU8, srcWidth, srcHeight, keepAspect);\n        return [\n            alphamaskU8,\n            imageTensor\n        ];\n    } else {\n        return [\n            alphamaskU8,\n            resizedImageTensor\n        ];\n    }\n}\n// src/api/v1.ts\nvar init = (0, import_lodash.memoize)(initInference, (config)=>JSON.stringify(config));\nasync function preload(configuration) {\n    await init(configuration);\n    return;\n}\nasync function removeBackground(image, configuration) {\n    const { config, session } = await init(configuration);\n    if (config.progress) config.progress(\"compute:decode\", 0, 4);\n    const inputImageTensor = await imageSourceToImageData(image, config);\n    config.progress?.(\"compute:inference\", 1, 4);\n    const [alphamask2, imageTensor] = await runInference(inputImageTensor, config, session);\n    config.progress?.(\"compute:mask\", 2, 4);\n    const outImageTensor = imageTensor;\n    const [width, height] = outImageTensor.shape;\n    const stride = width * height;\n    for(let i = 0; i < stride; i += 1){\n        outImageTensor.data[4 * i + 3] = alphamask2.data[i];\n    }\n    config.progress?.(\"compute:encode\", 3, 4);\n    const outImage = await imageEncode(outImageTensor, config.output.quality, config.output.format);\n    config.progress?.(\"compute:encode\", 4, 4);\n    return outImage;\n}\nasync function removeForeground(image, configuration) {\n    const { config, session } = await init(configuration);\n    const imageTensor = await imageSourceToImageData(image, config);\n    const [alphamask2, imageInput] = await runInference(imageTensor, config, session);\n    const outImageTensor = imageInput;\n    const [width, height, channels] = outImageTensor.shape;\n    const stride = width * height;\n    for(let i = 0; i < stride; i += 1){\n        outImageTensor.data[4 * i + 3] = 255 - alphamask2.data[i];\n    }\n    const outImage = await imageEncode(outImageTensor, config.output.quality, config.output.format);\n    return outImage;\n}\nvar alphamask = segmentForeground;\nasync function segmentForeground(image, configuration) {\n    const { config, session } = await init(configuration);\n    const imageTensor = await imageSourceToImageData(image, config);\n    let [height, width, channels] = imageTensor.shape;\n    const [alphamask2, imageInput] = await runInference(imageTensor, config, session);\n    const stride = width * height;\n    const outImageTensor = imageTensor;\n    for(let i = 0; i < stride; i += 1){\n        const index = 4 * i;\n        let alpha = alphamask2.data[i];\n        outImageTensor.data[index] = 255;\n        outImageTensor.data[index + 1] = 255;\n        outImageTensor.data[index + 2] = 255;\n        outImageTensor.data[index + 3] = alpha;\n    }\n    const outImage = await imageEncode(outImageTensor, config.output.quality, config.output.format);\n    return outImage;\n}\nasync function applySegmentationMask(image, mask, config) {\n    config = validateConfig(config);\n    const imageTensor = await imageSourceToImageData(image, config);\n    const [imageHeight, imageWidth, imageChannels] = imageTensor.shape;\n    const maskTensor = await imageSourceToImageData(mask, config);\n    const [maskHeight, maskWidth, maskChannels] = maskTensor.shape;\n    const alphaMask = maskHeight !== imageHeight || maskWidth !== imageWidth ? tensorResizeBilinear(maskTensor, imageWidth, imageHeight) : maskTensor;\n    const stride = imageWidth * imageHeight;\n    for(let i = 0; i < stride; i += 1){\n        const idxImage = imageChannels * i;\n        const idxMask = maskChannels * i;\n        imageTensor.data[idxImage + 3] = alphaMask.data[idxMask + 3];\n    }\n    const outImage = await imageEncode(imageTensor, config.output.quality, config.output.format);\n    return outImage;\n}\n /*! Bundled license information:\n\nlodash/lodash.js:\n  (**\n   * @license\n   * Lodash <https://lodash.com/>\n   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>\n   * Released under MIT license <https://lodash.com/license>\n   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n   *)\n\nis-buffer/index.js:\n  (*!\n   * Determine if an object is a Buffer\n   *\n   * @author   Feross Aboukhadijeh <https://feross.org>\n   * @license  MIT\n   *)\n*/  //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGltZ2x5L2JhY2tncm91bmQtcmVtb3ZhbC9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQSxJQUFJQSxXQUFXQyxPQUFPQyxNQUFNO0FBQzVCLElBQUlDLFlBQVlGLE9BQU9HLGNBQWM7QUFDckMsSUFBSUMsbUJBQW1CSixPQUFPSyx3QkFBd0I7QUFDdEQsSUFBSUMsb0JBQW9CTixPQUFPTyxtQkFBbUI7QUFDbEQsSUFBSUMsZUFBZVIsT0FBT1MsY0FBYztBQUN4QyxJQUFJQyxlQUFlVixPQUFPVyxTQUFTLENBQUNDLGNBQWM7QUFDbEQsSUFBSUMsYUFBYSxDQUFDQyxJQUFJQyxNQUFRLFNBQVNDO1FBQ3JDLE9BQU9ELE9BQU8sQ0FBQyxHQUFHRCxFQUFFLENBQUNSLGtCQUFrQlEsR0FBRyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUNDLE1BQU07WUFBRUUsU0FBUyxDQUFDO1FBQUUsR0FBR0EsT0FBTyxFQUFFRixNQUFNQSxJQUFJRSxPQUFPO0lBQ3BHO0FBQ0EsSUFBSUMsY0FBYyxDQUFDQyxJQUFJQyxNQUFNQyxRQUFRQztJQUNuQyxJQUFJRixRQUFRLE9BQU9BLFNBQVMsWUFBWSxPQUFPQSxTQUFTLFlBQVk7UUFDbEUsS0FBSyxJQUFJRyxPQUFPakIsa0JBQWtCYyxNQUNoQyxJQUFJLENBQUNWLGFBQWFjLElBQUksQ0FBQ0wsSUFBSUksUUFBUUEsUUFBUUYsUUFDekNuQixVQUFVaUIsSUFBSUksS0FBSztZQUFFRSxLQUFLLElBQU1MLElBQUksQ0FBQ0csSUFBSTtZQUFFRyxZQUFZLENBQUVKLENBQUFBLE9BQU9sQixpQkFBaUJnQixNQUFNRyxJQUFHLEtBQU1ELEtBQUtJLFVBQVU7UUFBQztJQUN0SDtJQUNBLE9BQU9QO0FBQ1Q7QUFDQSxJQUFJUSxVQUFVLENBQUNaLEtBQUthLFlBQVlDLFNBQVlBLENBQUFBLFNBQVNkLE9BQU8sT0FBT2hCLFNBQVNTLGFBQWFPLFFBQVEsQ0FBQyxHQUFHRyxZ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UixRQUFRO2dCQUNSLFFBQVE7Z0JBQ1IsUUFBUTtnQkFDUixRQUFRO2dCQUNSLFFBQVE7Z0JBQ1IsUUFBUTtnQkFDUixRQUFRO2dCQUNSLFFBQVE7Z0JBQ1IsUUFBUTtnQkFDUixRQUFRO2dCQUNSLFFBQVE7Z0JBQ1IsUUFBUTtnQkFDUixRQUFRO2dCQUNSLFFBQVE7Z0JBQ1IsUUFBUTtnQkFDUixRQUFRO2dCQUNSLFFBQVE7Z0JBQ1IsUUFBUTtnQkFDUixRQUFRO2dCQUNSLFFBQVE7Z0JBQ1IsUUFBUTtnQkFDUixRQUFRO2dCQUNSLFFBQVE7Z0JBQ1IsUUFBUTtnQkFDUixRQUFRO2dCQUNSLFFBQVE7Z0JBQ1IsUUFBUTtnQkFDUixRQUFRO2dCQUNSLFFBQVE7Z0JBQ1IsUUFBUTtnQkFDUixRQUFRO2dCQUNSLFFBQVE7Z0JBQ1IsUUFBUTtnQkFDUixRQUFRO2dCQUNSLFFBQVE7Z0JBQ1IsUUFBUTtnQkFDUixRQUFRO2dCQUNSLFFBQVE7Z0JBQ1IsUUFBUTtnQkFDUixRQUFRO2dCQUNSLFFBQVE7Z0JBQ1IsUUFBUTtnQkFDUixRQUFRO2dCQUNSLFFBQVE7Z0JBQ1IsMEJBQTBCO2dCQUMxQixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtB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NXdCO1FBQ2pDLE1BQU1teEIsVUFBVUgsZUFBZWh4QjtRQUMvQitELFlBQVk1Z0MsSUFBSSxDQUFDK3RELFdBQVcsRUFBRSxHQUFHRCxVQUFVOXRELElBQUksQ0FBQ2d1RCxVQUFVLEVBQUU7SUFDOUQ7SUFDQSxNQUFNaEIsV0FBVyxNQUFNcnNCLFlBQ3JCQyxhQUNBNEQsT0FBTzBFLE1BQU0sQ0FBQ3JJLE9BQU8sRUFDckIyRCxPQUFPMEUsTUFBTSxDQUFDcEksTUFBTTtJQUV0QixPQUFPa3NCO0FBQ1Q7QUFRRSxDQUNGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBbUJBLElBQ0Esa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGV4dC1iZWhpbmQtaW1hZ2UvLi9ub2RlX21vZHVsZXMvQGltZ2x5L2JhY2tncm91bmQtcmVtb3ZhbC9kaXN0L2luZGV4Lm1qcz9iOWMyIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19jb21tb25KUyA9IChjYiwgbW9kKSA9PiBmdW5jdGlvbiBfX3JlcXVpcmUoKSB7XG4gIHJldHVybiBtb2QgfHwgKDAsIGNiW19fZ2V0T3duUHJvcE5hbWVzKGNiKVswXV0pKChtb2QgPSB7IGV4cG9ydHM6IHt9IH0pLmV4cG9ydHMsIG1vZCksIG1vZC5leHBvcnRzO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvRVNNID0gKG1vZCwgaXNOb2RlTW9kZSwgdGFyZ2V0KSA9PiAodGFyZ2V0ID0gbW9kICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kKSkgOiB7fSwgX19jb3B5UHJvcHMoXG4gIC8vIElmIHRoZSBpbXBvcnRlciBpcyBpbiBub2RlIGNvbXBhdGliaWxpdHkgbW9kZSBvciB0aGlzIGlzIG5vdCBhbiBFU01cbiAgLy8gZmlsZSB0aGF0IGhhcyBiZWVuIGNvbnZlcnRlZCB0byBhIENvbW1vbkpTIGZpbGUgdXNpbmcgYSBCYWJlbC1cbiAgLy8gY29tcGF0aWJsZSB0cmFuc2Zvcm0gKGkuZS4gXCJfX2VzTW9kdWxlXCIgaGFzIG5vdCBiZWVuIHNldCksIHRoZW4gc2V0XG4gIC8vIFwiZGVmYXVsdFwiIHRvIHRoZSBDb21tb25KUyBcIm1vZHVsZS5leHBvcnRzXCIgZm9yIG5vZGUgY29tcGF0aWJpbGl0eS5cbiAgaXNOb2RlTW9kZSB8fCAhbW9kIHx8ICFtb2QuX19lc01vZHVsZSA/IF9fZGVmUHJvcCh0YXJnZXQsIFwiZGVmYXVsdFwiLCB7IHZhbHVlOiBtb2QsIGVudW1lcmFibGU6IHRydWUgfSkgOiB0YXJnZXQsXG4gIG1vZFxuKSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvbG9kYXNoLmpzXG52YXIgcmVxdWlyZV9sb2Rhc2ggPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL2xvZGFzaC5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIChmdW5jdGlvbigpIHtcbiAgICAgIHZhciB1bmRlZmluZWQyO1xuICAgICAgdmFyIFZFUlNJT04gPSBcIjQuMTcuMjFcIjtcbiAgICAgIHZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuICAgICAgdmFyIENPUkVfRVJST1JfVEVYVCA9IFwiVW5zdXBwb3J0ZWQgY29yZS1qcyB1c2UuIFRyeSBodHRwczovL25wbXMuaW8vc2VhcmNoP3E9cG9ueWZpbGwuXCIsIEZVTkNfRVJST1JfVEVYVCA9IFwiRXhwZWN0ZWQgYSBmdW5jdGlvblwiLCBJTlZBTElEX1RFTVBMX1ZBUl9FUlJPUl9URVhUID0gXCJJbnZhbGlkIGB2YXJpYWJsZWAgb3B0aW9uIHBhc3NlZCBpbnRvIGBfLnRlbXBsYXRlYFwiO1xuICAgICAgdmFyIEhBU0hfVU5ERUZJTkVEID0gXCJfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fXCI7XG4gICAgICB2YXIgTUFYX01FTU9JWkVfU0laRSA9IDUwMDtcbiAgICAgIHZhciBQTEFDRUhPTERFUiA9IFwiX19sb2Rhc2hfcGxhY2Vob2xkZXJfX1wiO1xuICAgICAgdmFyIENMT05FX0RFRVBfRkxBRyA9IDEsIENMT05FX0ZMQVRfRkxBRyA9IDIsIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG4gICAgICB2YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLCBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcbiAgICAgIHZhciBXUkFQX0JJTkRfRkxBRyA9IDEsIFdSQVBfQklORF9LRVlfRkxBRyA9IDIsIFdSQVBfQ1VSUllfQk9VTkRfRkxBRyA9IDQsIFdSQVBfQ1VSUllfRkxBRyA9IDgsIFdSQVBfQ1VSUllfUklHSFRfRkxBRyA9IDE2LCBXUkFQX1BBUlRJQUxfRkxBRyA9IDMyLCBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyA9IDY0LCBXUkFQX0FSWV9GTEFHID0gMTI4LCBXUkFQX1JFQVJHX0ZMQUcgPSAyNTYsIFdSQVBfRkxJUF9GTEFHID0gNTEyO1xuICAgICAgdmFyIERFRkFVTFRfVFJVTkNfTEVOR1RIID0gMzAsIERFRkFVTFRfVFJVTkNfT01JU1NJT04gPSBcIi4uLlwiO1xuICAgICAgdmFyIEhPVF9DT1VOVCA9IDgwMCwgSE9UX1NQQU4gPSAxNjtcbiAgICAgIHZhciBMQVpZX0ZJTFRFUl9GTEFHID0gMSwgTEFaWV9NQVBfRkxBRyA9IDIsIExBWllfV0hJTEVfRkxBRyA9IDM7XG4gICAgICB2YXIgSU5GSU5JVFkgPSAxIC8gMCwgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTEsIE1BWF9JTlRFR0VSID0gMTc5NzY5MzEzNDg2MjMxNTdlMjkyLCBOQU4gPSAwIC8gMDtcbiAgICAgIHZhciBNQVhfQVJSQVlfTEVOR1RIID0gNDI5NDk2NzI5NSwgTUFYX0FSUkFZX0lOREVYID0gTUFYX0FSUkFZX0xFTkdUSCAtIDEsIEhBTEZfTUFYX0FSUkFZX0xFTkdUSCA9IE1BWF9BUlJBWV9MRU5HVEggPj4+IDE7XG4gICAgICB2YXIgd3JhcEZsYWdzID0gW1xuICAgICAgICBbXCJhcnlcIiwgV1JBUF9BUllfRkxBR10sXG4gICAgICAgIFtcImJpbmRcIiwgV1JBUF9CSU5EX0ZMQUddLFxuICAgICAgICBbXCJiaW5kS2V5XCIsIFdSQVBfQklORF9LRVlfRkxBR10sXG4gICAgICAgIFtcImN1cnJ5XCIsIFdSQVBfQ1VSUllfRkxBR10sXG4gICAgICAgIFtcImN1cnJ5UmlnaHRcIiwgV1JBUF9DVVJSWV9SSUdIVF9GTEFHXSxcbiAgICAgICAgW1wiZmxpcFwiLCBXUkFQX0ZMSVBfRkxBR10sXG4gICAgICAgIFtcInBhcnRpYWxcIiwgV1JBUF9QQVJUSUFMX0ZMQUddLFxuICAgICAgICBbXCJwYXJ0aWFsUmlnaHRcIiwgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUddLFxuICAgICAgICBbXCJyZWFyZ1wiLCBXUkFQX1JFQVJHX0ZMQUddXG4gICAgICBdO1xuICAgICAgdmFyIGFyZ3NUYWcgPSBcIltvYmplY3QgQXJndW1lbnRzXVwiLCBhcnJheVRhZyA9IFwiW29iamVjdCBBcnJheV1cIiwgYXN5bmNUYWcgPSBcIltvYmplY3QgQXN5bmNGdW5jdGlvbl1cIiwgYm9vbFRhZyA9IFwiW29iamVjdCBCb29sZWFuXVwiLCBkYXRlVGFnID0gXCJbb2JqZWN0IERhdGVdXCIsIGRvbUV4Y1RhZyA9IFwiW29iamVjdCBET01FeGNlcHRpb25dXCIsIGVycm9yVGFnID0gXCJbb2JqZWN0IEVycm9yXVwiLCBmdW5jVGFnID0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiLCBnZW5UYWcgPSBcIltvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dXCIsIG1hcFRhZyA9IFwiW29iamVjdCBNYXBdXCIsIG51bWJlclRhZyA9IFwiW29iamVjdCBOdW1iZXJdXCIsIG51bGxUYWcgPSBcIltvYmplY3QgTnVsbF1cIiwgb2JqZWN0VGFnID0gXCJbb2JqZWN0IE9iamVjdF1cIiwgcHJvbWlzZVRhZyA9IFwiW29iamVjdCBQcm9taXNlXVwiLCBwcm94eVRhZyA9IFwiW29iamVjdCBQcm94eV1cIiwgcmVnZXhwVGFnID0gXCJbb2JqZWN0IFJlZ0V4cF1cIiwgc2V0VGFnID0gXCJbb2JqZWN0IFNldF1cIiwgc3RyaW5nVGFnID0gXCJbb2JqZWN0IFN0cmluZ11cIiwgc3ltYm9sVGFnID0gXCJbb2JqZWN0IFN5bWJvbF1cIiwgdW5kZWZpbmVkVGFnID0gXCJbb2JqZWN0IFVuZGVmaW5lZF1cIiwgd2Vha01hcFRhZyA9IFwiW29iamVjdCBXZWFrTWFwXVwiLCB3ZWFrU2V0VGFnID0gXCJbb2JqZWN0IFdlYWtTZXRdXCI7XG4gICAgICB2YXIgYXJyYXlCdWZmZXJUYWcgPSBcIltvYmplY3QgQXJyYXlCdWZmZXJdXCIsIGRhdGFWaWV3VGFnID0gXCJbb2JqZWN0IERhdGFWaWV3XVwiLCBmbG9hdDMyVGFnID0gXCJbb2JqZWN0IEZsb2F0MzJBcnJheV1cIiwgZmxvYXQ2NFRhZyA9IFwiW29iamVjdCBGbG9hdDY0QXJyYXldXCIsIGludDhUYWcgPSBcIltvYmplY3QgSW50OEFycmF5XVwiLCBpbnQxNlRhZyA9IFwiW29iamVjdCBJbnQxNkFycmF5XVwiLCBpbnQzMlRhZyA9IFwiW29iamVjdCBJbnQzMkFycmF5XVwiLCB1aW50OFRhZyA9IFwiW29iamVjdCBVaW50OEFycmF5XVwiLCB1aW50OENsYW1wZWRUYWcgPSBcIltvYmplY3QgVWludDhDbGFtcGVkQXJyYXldXCIsIHVpbnQxNlRhZyA9IFwiW29iamVjdCBVaW50MTZBcnJheV1cIiwgdWludDMyVGFnID0gXCJbb2JqZWN0IFVpbnQzMkFycmF5XVwiO1xuICAgICAgdmFyIHJlRW1wdHlTdHJpbmdMZWFkaW5nID0gL1xcYl9fcCBcXCs9ICcnOy9nLCByZUVtcHR5U3RyaW5nTWlkZGxlID0gL1xcYihfX3AgXFwrPSkgJycgXFwrL2csIHJlRW1wdHlTdHJpbmdUcmFpbGluZyA9IC8oX19lXFwoLio/XFwpfFxcYl9fdFxcKSkgXFwrXFxuJyc7L2c7XG4gICAgICB2YXIgcmVFc2NhcGVkSHRtbCA9IC8mKD86YW1wfGx0fGd0fHF1b3R8IzM5KTsvZywgcmVVbmVzY2FwZWRIdG1sID0gL1smPD5cIiddL2csIHJlSGFzRXNjYXBlZEh0bWwgPSBSZWdFeHAocmVFc2NhcGVkSHRtbC5zb3VyY2UpLCByZUhhc1VuZXNjYXBlZEh0bWwgPSBSZWdFeHAocmVVbmVzY2FwZWRIdG1sLnNvdXJjZSk7XG4gICAgICB2YXIgcmVFc2NhcGUgPSAvPCUtKFtcXHNcXFNdKz8pJT4vZywgcmVFdmFsdWF0ZSA9IC88JShbXFxzXFxTXSs/KSU+L2csIHJlSW50ZXJwb2xhdGUgPSAvPCU9KFtcXHNcXFNdKz8pJT4vZztcbiAgICAgIHZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLCByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC8sIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG4gICAgICB2YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nLCByZUhhc1JlZ0V4cENoYXIgPSBSZWdFeHAocmVSZWdFeHBDaGFyLnNvdXJjZSk7XG4gICAgICB2YXIgcmVUcmltU3RhcnQgPSAvXlxccysvO1xuICAgICAgdmFyIHJlV2hpdGVzcGFjZSA9IC9cXHMvO1xuICAgICAgdmFyIHJlV3JhcENvbW1lbnQgPSAvXFx7KD86XFxuXFwvXFwqIFxcW3dyYXBwZWQgd2l0aCAuK1xcXSBcXCpcXC8pP1xcbj8vLCByZVdyYXBEZXRhaWxzID0gL1xce1xcblxcL1xcKiBcXFt3cmFwcGVkIHdpdGggKC4rKVxcXSBcXCovLCByZVNwbGl0RGV0YWlscyA9IC8sPyAmIC87XG4gICAgICB2YXIgcmVBc2NpaVdvcmQgPSAvW15cXHgwMC1cXHgyZlxceDNhLVxceDQwXFx4NWItXFx4NjBcXHg3Yi1cXHg3Zl0rL2c7XG4gICAgICB2YXIgcmVGb3JiaWRkZW5JZGVudGlmaWVyQ2hhcnMgPSAvWygpPSx7fVxcW1xcXVxcL1xcc10vO1xuICAgICAgdmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuICAgICAgdmFyIHJlRXNUZW1wbGF0ZSA9IC9cXCRcXHsoW15cXFxcfV0qKD86XFxcXC5bXlxcXFx9XSopKilcXH0vZztcbiAgICAgIHZhciByZUZsYWdzID0gL1xcdyokLztcbiAgICAgIHZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG4gICAgICB2YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcbiAgICAgIHZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuICAgICAgdmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG4gICAgICB2YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuICAgICAgdmFyIHJlTGF0aW4gPSAvW1xceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHhmZlxcdTAxMDAtXFx1MDE3Zl0vZztcbiAgICAgIHZhciByZU5vTWF0Y2ggPSAvKCReKS87XG4gICAgICB2YXIgcmVVbmVzY2FwZWRTdHJpbmcgPSAvWydcXG5cXHJcXHUyMDI4XFx1MjAyOVxcXFxdL2c7XG4gICAgICB2YXIgcnNBc3RyYWxSYW5nZSA9IFwiXFxcXHVkODAwLVxcXFx1ZGZmZlwiLCByc0NvbWJvTWFya3NSYW5nZSA9IFwiXFxcXHUwMzAwLVxcXFx1MDM2ZlwiLCByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSBcIlxcXFx1ZmUyMC1cXFxcdWZlMmZcIiwgcnNDb21ib1N5bWJvbHNSYW5nZSA9IFwiXFxcXHUyMGQwLVxcXFx1MjBmZlwiLCByc0NvbWJvUmFuZ2UgPSByc0NvbWJvTWFya3NSYW5nZSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UsIHJzRGluZ2JhdFJhbmdlID0gXCJcXFxcdTI3MDAtXFxcXHUyN2JmXCIsIHJzTG93ZXJSYW5nZSA9IFwiYS16XFxcXHhkZi1cXFxceGY2XFxcXHhmOC1cXFxceGZmXCIsIHJzTWF0aE9wUmFuZ2UgPSBcIlxcXFx4YWNcXFxceGIxXFxcXHhkN1xcXFx4ZjdcIiwgcnNOb25DaGFyUmFuZ2UgPSBcIlxcXFx4MDAtXFxcXHgyZlxcXFx4M2EtXFxcXHg0MFxcXFx4NWItXFxcXHg2MFxcXFx4N2ItXFxcXHhiZlwiLCByc1B1bmN0dWF0aW9uUmFuZ2UgPSBcIlxcXFx1MjAwMC1cXFxcdTIwNmZcIiwgcnNTcGFjZVJhbmdlID0gXCIgXFxcXHRcXFxceDBiXFxcXGZcXFxceGEwXFxcXHVmZWZmXFxcXG5cXFxcclxcXFx1MjAyOFxcXFx1MjAyOVxcXFx1MTY4MFxcXFx1MTgwZVxcXFx1MjAwMFxcXFx1MjAwMVxcXFx1MjAwMlxcXFx1MjAwM1xcXFx1MjAwNFxcXFx1MjAwNVxcXFx1MjAwNlxcXFx1MjAwN1xcXFx1MjAwOFxcXFx1MjAwOVxcXFx1MjAwYVxcXFx1MjAyZlxcXFx1MjA1ZlxcXFx1MzAwMFwiLCByc1VwcGVyUmFuZ2UgPSBcIkEtWlxcXFx4YzAtXFxcXHhkNlxcXFx4ZDgtXFxcXHhkZVwiLCByc1ZhclJhbmdlID0gXCJcXFxcdWZlMGVcXFxcdWZlMGZcIiwgcnNCcmVha1JhbmdlID0gcnNNYXRoT3BSYW5nZSArIHJzTm9uQ2hhclJhbmdlICsgcnNQdW5jdHVhdGlvblJhbmdlICsgcnNTcGFjZVJhbmdlO1xuICAgICAgdmFyIHJzQXBvcyA9IFwiWydcXHUyMDE5XVwiLCByc0FzdHJhbCA9IFwiW1wiICsgcnNBc3RyYWxSYW5nZSArIFwiXVwiLCByc0JyZWFrID0gXCJbXCIgKyByc0JyZWFrUmFuZ2UgKyBcIl1cIiwgcnNDb21ibyA9IFwiW1wiICsgcnNDb21ib1JhbmdlICsgXCJdXCIsIHJzRGlnaXRzID0gXCJcXFxcZCtcIiwgcnNEaW5nYmF0ID0gXCJbXCIgKyByc0RpbmdiYXRSYW5nZSArIFwiXVwiLCByc0xvd2VyID0gXCJbXCIgKyByc0xvd2VyUmFuZ2UgKyBcIl1cIiwgcnNNaXNjID0gXCJbXlwiICsgcnNBc3RyYWxSYW5nZSArIHJzQnJlYWtSYW5nZSArIHJzRGlnaXRzICsgcnNEaW5nYmF0UmFuZ2UgKyByc0xvd2VyUmFuZ2UgKyByc1VwcGVyUmFuZ2UgKyBcIl1cIiwgcnNGaXR6ID0gXCJcXFxcdWQ4M2NbXFxcXHVkZmZiLVxcXFx1ZGZmZl1cIiwgcnNNb2RpZmllciA9IFwiKD86XCIgKyByc0NvbWJvICsgXCJ8XCIgKyByc0ZpdHogKyBcIilcIiwgcnNOb25Bc3RyYWwgPSBcIlteXCIgKyByc0FzdHJhbFJhbmdlICsgXCJdXCIsIHJzUmVnaW9uYWwgPSBcIig/OlxcXFx1ZDgzY1tcXFxcdWRkZTYtXFxcXHVkZGZmXSl7Mn1cIiwgcnNTdXJyUGFpciA9IFwiW1xcXFx1ZDgwMC1cXFxcdWRiZmZdW1xcXFx1ZGMwMC1cXFxcdWRmZmZdXCIsIHJzVXBwZXIgPSBcIltcIiArIHJzVXBwZXJSYW5nZSArIFwiXVwiLCByc1pXSiA9IFwiXFxcXHUyMDBkXCI7XG4gICAgICB2YXIgcnNNaXNjTG93ZXIgPSBcIig/OlwiICsgcnNMb3dlciArIFwifFwiICsgcnNNaXNjICsgXCIpXCIsIHJzTWlzY1VwcGVyID0gXCIoPzpcIiArIHJzVXBwZXIgKyBcInxcIiArIHJzTWlzYyArIFwiKVwiLCByc09wdENvbnRyTG93ZXIgPSBcIig/OlwiICsgcnNBcG9zICsgXCIoPzpkfGxsfG18cmV8c3x0fHZlKSk/XCIsIHJzT3B0Q29udHJVcHBlciA9IFwiKD86XCIgKyByc0Fwb3MgKyBcIig/OkR8TEx8TXxSRXxTfFR8VkUpKT9cIiwgcmVPcHRNb2QgPSByc01vZGlmaWVyICsgXCI/XCIsIHJzT3B0VmFyID0gXCJbXCIgKyByc1ZhclJhbmdlICsgXCJdP1wiLCByc09wdEpvaW4gPSBcIig/OlwiICsgcnNaV0ogKyBcIig/OlwiICsgW3JzTm9uQXN0cmFsLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKFwifFwiKSArIFwiKVwiICsgcnNPcHRWYXIgKyByZU9wdE1vZCArIFwiKSpcIiwgcnNPcmRMb3dlciA9IFwiXFxcXGQqKD86MXN0fDJuZHwzcmR8KD8hWzEyM10pXFxcXGR0aCkoPz1cXFxcYnxbQS1aX10pXCIsIHJzT3JkVXBwZXIgPSBcIlxcXFxkKig/OjFTVHwyTkR8M1JEfCg/IVsxMjNdKVxcXFxkVEgpKD89XFxcXGJ8W2Etel9dKVwiLCByc1NlcSA9IHJzT3B0VmFyICsgcmVPcHRNb2QgKyByc09wdEpvaW4sIHJzRW1vamkgPSBcIig/OlwiICsgW3JzRGluZ2JhdCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbihcInxcIikgKyBcIilcIiArIHJzU2VxLCByc1N5bWJvbCA9IFwiKD86XCIgKyBbcnNOb25Bc3RyYWwgKyByc0NvbWJvICsgXCI/XCIsIHJzQ29tYm8sIHJzUmVnaW9uYWwsIHJzU3VyclBhaXIsIHJzQXN0cmFsXS5qb2luKFwifFwiKSArIFwiKVwiO1xuICAgICAgdmFyIHJlQXBvcyA9IFJlZ0V4cChyc0Fwb3MsIFwiZ1wiKTtcbiAgICAgIHZhciByZUNvbWJvTWFyayA9IFJlZ0V4cChyc0NvbWJvLCBcImdcIik7XG4gICAgICB2YXIgcmVVbmljb2RlID0gUmVnRXhwKHJzRml0eiArIFwiKD89XCIgKyByc0ZpdHogKyBcIil8XCIgKyByc1N5bWJvbCArIHJzU2VxLCBcImdcIik7XG4gICAgICB2YXIgcmVVbmljb2RlV29yZCA9IFJlZ0V4cChbXG4gICAgICAgIHJzVXBwZXIgKyBcIj9cIiArIHJzTG93ZXIgKyBcIitcIiArIHJzT3B0Q29udHJMb3dlciArIFwiKD89XCIgKyBbcnNCcmVhaywgcnNVcHBlciwgXCIkXCJdLmpvaW4oXCJ8XCIpICsgXCIpXCIsXG4gICAgICAgIHJzTWlzY1VwcGVyICsgXCIrXCIgKyByc09wdENvbnRyVXBwZXIgKyBcIig/PVwiICsgW3JzQnJlYWssIHJzVXBwZXIgKyByc01pc2NMb3dlciwgXCIkXCJdLmpvaW4oXCJ8XCIpICsgXCIpXCIsXG4gICAgICAgIHJzVXBwZXIgKyBcIj9cIiArIHJzTWlzY0xvd2VyICsgXCIrXCIgKyByc09wdENvbnRyTG93ZXIsXG4gICAgICAgIHJzVXBwZXIgKyBcIitcIiArIHJzT3B0Q29udHJVcHBlcixcbiAgICAgICAgcnNPcmRVcHBlcixcbiAgICAgICAgcnNPcmRMb3dlcixcbiAgICAgICAgcnNEaWdpdHMsXG4gICAgICAgIHJzRW1vamlcbiAgICAgIF0uam9pbihcInxcIiksIFwiZ1wiKTtcbiAgICAgIHZhciByZUhhc1VuaWNvZGUgPSBSZWdFeHAoXCJbXCIgKyByc1pXSiArIHJzQXN0cmFsUmFuZ2UgKyByc0NvbWJvUmFuZ2UgKyByc1ZhclJhbmdlICsgXCJdXCIpO1xuICAgICAgdmFyIHJlSGFzVW5pY29kZVdvcmQgPSAvW2Etel1bQS1aXXxbQS1aXXsyfVthLXpdfFswLTldW2EtekEtWl18W2EtekEtWl1bMC05XXxbXmEtekEtWjAtOSBdLztcbiAgICAgIHZhciBjb250ZXh0UHJvcHMgPSBbXG4gICAgICAgIFwiQXJyYXlcIixcbiAgICAgICAgXCJCdWZmZXJcIixcbiAgICAgICAgXCJEYXRhVmlld1wiLFxuICAgICAgICBcIkRhdGVcIixcbiAgICAgICAgXCJFcnJvclwiLFxuICAgICAgICBcIkZsb2F0MzJBcnJheVwiLFxuICAgICAgICBcIkZsb2F0NjRBcnJheVwiLFxuICAgICAgICBcIkZ1bmN0aW9uXCIsXG4gICAgICAgIFwiSW50OEFycmF5XCIsXG4gICAgICAgIFwiSW50MTZBcnJheVwiLFxuICAgICAgICBcIkludDMyQXJyYXlcIixcbiAgICAgICAgXCJNYXBcIixcbiAgICAgICAgXCJNYXRoXCIsXG4gICAgICAgIFwiT2JqZWN0XCIsXG4gICAgICAgIFwiUHJvbWlzZVwiLFxuICAgICAgICBcIlJlZ0V4cFwiLFxuICAgICAgICBcIlNldFwiLFxuICAgICAgICBcIlN0cmluZ1wiLFxuICAgICAgICBcIlN5bWJvbFwiLFxuICAgICAgICBcIlR5cGVFcnJvclwiLFxuICAgICAgICBcIlVpbnQ4QXJyYXlcIixcbiAgICAgICAgXCJVaW50OENsYW1wZWRBcnJheVwiLFxuICAgICAgICBcIlVpbnQxNkFycmF5XCIsXG4gICAgICAgIFwiVWludDMyQXJyYXlcIixcbiAgICAgICAgXCJXZWFrTWFwXCIsXG4gICAgICAgIFwiX1wiLFxuICAgICAgICBcImNsZWFyVGltZW91dFwiLFxuICAgICAgICBcImlzRmluaXRlXCIsXG4gICAgICAgIFwicGFyc2VJbnRcIixcbiAgICAgICAgXCJzZXRUaW1lb3V0XCJcbiAgICAgIF07XG4gICAgICB2YXIgdGVtcGxhdGVDb3VudGVyID0gLTE7XG4gICAgICB2YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbiAgICAgIHR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG4gICAgICB0eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPSB0eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9IHR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID0gdHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG4gICAgICB2YXIgY2xvbmVhYmxlVGFncyA9IHt9O1xuICAgICAgY2xvbmVhYmxlVGFnc1thcmdzVGFnXSA9IGNsb25lYWJsZVRhZ3NbYXJyYXlUYWddID0gY2xvbmVhYmxlVGFnc1thcnJheUJ1ZmZlclRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGFWaWV3VGFnXSA9IGNsb25lYWJsZVRhZ3NbYm9vbFRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGVUYWddID0gY2xvbmVhYmxlVGFnc1tmbG9hdDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZmxvYXQ2NFRhZ10gPSBjbG9uZWFibGVUYWdzW2ludDhUYWddID0gY2xvbmVhYmxlVGFnc1tpbnQxNlRhZ10gPSBjbG9uZWFibGVUYWdzW2ludDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbbWFwVGFnXSA9IGNsb25lYWJsZVRhZ3NbbnVtYmVyVGFnXSA9IGNsb25lYWJsZVRhZ3Nbb2JqZWN0VGFnXSA9IGNsb25lYWJsZVRhZ3NbcmVnZXhwVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc2V0VGFnXSA9IGNsb25lYWJsZVRhZ3Nbc3RyaW5nVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc3ltYm9sVGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDhUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50OENsYW1wZWRUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50MTZUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbiAgICAgIGNsb25lYWJsZVRhZ3NbZXJyb3JUYWddID0gY2xvbmVhYmxlVGFnc1tmdW5jVGFnXSA9IGNsb25lYWJsZVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcbiAgICAgIHZhciBkZWJ1cnJlZExldHRlcnMgPSB7XG4gICAgICAgIC8vIExhdGluLTEgU3VwcGxlbWVudCBibG9jay5cbiAgICAgICAgXCJcXHhDMFwiOiBcIkFcIixcbiAgICAgICAgXCJcXHhDMVwiOiBcIkFcIixcbiAgICAgICAgXCJcXHhDMlwiOiBcIkFcIixcbiAgICAgICAgXCJcXHhDM1wiOiBcIkFcIixcbiAgICAgICAgXCJcXHhDNFwiOiBcIkFcIixcbiAgICAgICAgXCJcXHhDNVwiOiBcIkFcIixcbiAgICAgICAgXCJcXHhFMFwiOiBcImFcIixcbiAgICAgICAgXCJcXHhFMVwiOiBcImFcIixcbiAgICAgICAgXCJcXHhFMlwiOiBcImFcIixcbiAgICAgICAgXCJcXHhFM1wiOiBcImFcIixcbiAgICAgICAgXCJcXHhFNFwiOiBcImFcIixcbiAgICAgICAgXCJcXHhFNVwiOiBcImFcIixcbiAgICAgICAgXCJcXHhDN1wiOiBcIkNcIixcbiAgICAgICAgXCJcXHhFN1wiOiBcImNcIixcbiAgICAgICAgXCJcXHhEMFwiOiBcIkRcIixcbiAgICAgICAgXCJcXHhGMFwiOiBcImRcIixcbiAgICAgICAgXCJcXHhDOFwiOiBcIkVcIixcbiAgICAgICAgXCJcXHhDOVwiOiBcIkVcIixcbiAgICAgICAgXCJcXHhDQVwiOiBcIkVcIixcbiAgICAgICAgXCJcXHhDQlwiOiBcIkVcIixcbiAgICAgICAgXCJcXHhFOFwiOiBcImVcIixcbiAgICAgICAgXCJcXHhFOVwiOiBcImVcIixcbiAgICAgICAgXCJcXHhFQVwiOiBcImVcIixcbiAgICAgICAgXCJcXHhFQlwiOiBcImVcIixcbiAgICAgICAgXCJcXHhDQ1wiOiBcIklcIixcbiAgICAgICAgXCJcXHhDRFwiOiBcIklcIixcbiAgICAgICAgXCJcXHhDRVwiOiBcIklcIixcbiAgICAgICAgXCJcXHhDRlwiOiBcIklcIixcbiAgICAgICAgXCJcXHhFQ1wiOiBcImlcIixcbiAgICAgICAgXCJcXHhFRFwiOiBcImlcIixcbiAgICAgICAgXCJcXHhFRVwiOiBcImlcIixcbiAgICAgICAgXCJcXHhFRlwiOiBcImlcIixcbiAgICAgICAgXCJcXHhEMVwiOiBcIk5cIixcbiAgICAgICAgXCJcXHhGMVwiOiBcIm5cIixcbiAgICAgICAgXCJcXHhEMlwiOiBcIk9cIixcbiAgICAgICAgXCJcXHhEM1wiOiBcIk9cIixcbiAgICAgICAgXCJcXHhENFwiOiBcIk9cIixcbiAgICAgICAgXCJcXHhENVwiOiBcIk9cIixcbiAgICAgICAgXCJcXHhENlwiOiBcIk9cIixcbiAgICAgICAgXCJcXHhEOFwiOiBcIk9cIixcbiAgICAgICAgXCJcXHhGMlwiOiBcIm9cIixcbiAgICAgICAgXCJcXHhGM1wiOiBcIm9cIixcbiAgICAgICAgXCJcXHhGNFwiOiBcIm9cIixcbiAgICAgICAgXCJcXHhGNVwiOiBcIm9cIixcbiAgICAgICAgXCJcXHhGNlwiOiBcIm9cIixcbiAgICAgICAgXCJcXHhGOFwiOiBcIm9cIixcbiAgICAgICAgXCJcXHhEOVwiOiBcIlVcIixcbiAgICAgICAgXCJcXHhEQVwiOiBcIlVcIixcbiAgICAgICAgXCJcXHhEQlwiOiBcIlVcIixcbiAgICAgICAgXCJcXHhEQ1wiOiBcIlVcIixcbiAgICAgICAgXCJcXHhGOVwiOiBcInVcIixcbiAgICAgICAgXCJcXHhGQVwiOiBcInVcIixcbiAgICAgICAgXCJcXHhGQlwiOiBcInVcIixcbiAgICAgICAgXCJcXHhGQ1wiOiBcInVcIixcbiAgICAgICAgXCJcXHhERFwiOiBcIllcIixcbiAgICAgICAgXCJcXHhGRFwiOiBcInlcIixcbiAgICAgICAgXCJcXHhGRlwiOiBcInlcIixcbiAgICAgICAgXCJcXHhDNlwiOiBcIkFlXCIsXG4gICAgICAgIFwiXFx4RTZcIjogXCJhZVwiLFxuICAgICAgICBcIlxceERFXCI6IFwiVGhcIixcbiAgICAgICAgXCJcXHhGRVwiOiBcInRoXCIsXG4gICAgICAgIFwiXFx4REZcIjogXCJzc1wiLFxuICAgICAgICAvLyBMYXRpbiBFeHRlbmRlZC1BIGJsb2NrLlxuICAgICAgICBcIlxcdTAxMDBcIjogXCJBXCIsXG4gICAgICAgIFwiXFx1MDEwMlwiOiBcIkFcIixcbiAgICAgICAgXCJcXHUwMTA0XCI6IFwiQVwiLFxuICAgICAgICBcIlxcdTAxMDFcIjogXCJhXCIsXG4gICAgICAgIFwiXFx1MDEwM1wiOiBcImFcIixcbiAgICAgICAgXCJcXHUwMTA1XCI6IFwiYVwiLFxuICAgICAgICBcIlxcdTAxMDZcIjogXCJDXCIsXG4gICAgICAgIFwiXFx1MDEwOFwiOiBcIkNcIixcbiAgICAgICAgXCJcXHUwMTBBXCI6IFwiQ1wiLFxuICAgICAgICBcIlxcdTAxMENcIjogXCJDXCIsXG4gICAgICAgIFwiXFx1MDEwN1wiOiBcImNcIixcbiAgICAgICAgXCJcXHUwMTA5XCI6IFwiY1wiLFxuICAgICAgICBcIlxcdTAxMEJcIjogXCJjXCIsXG4gICAgICAgIFwiXFx1MDEwRFwiOiBcImNcIixcbiAgICAgICAgXCJcXHUwMTBFXCI6IFwiRFwiLFxuICAgICAgICBcIlxcdTAxMTBcIjogXCJEXCIsXG4gICAgICAgIFwiXFx1MDEwRlwiOiBcImRcIixcbiAgICAgICAgXCJcXHUwMTExXCI6IFwiZFwiLFxuICAgICAgICBcIlxcdTAxMTJcIjogXCJFXCIsXG4gICAgICAgIFwiXFx1MDExNFwiOiBcIkVcIixcbiAgICAgICAgXCJcXHUwMTE2XCI6IFwiRVwiLFxuICAgICAgICBcIlxcdTAxMThcIjogXCJFXCIsXG4gICAgICAgIFwiXFx1MDExQVwiOiBcIkVcIixcbiAgICAgICAgXCJcXHUwMTEzXCI6IFwiZVwiLFxuICAgICAgICBcIlxcdTAxMTVcIjogXCJlXCIsXG4gICAgICAgIFwiXFx1MDExN1wiOiBcImVcIixcbiAgICAgICAgXCJcXHUwMTE5XCI6IFwiZVwiLFxuICAgICAgICBcIlxcdTAxMUJcIjogXCJlXCIsXG4gICAgICAgIFwiXFx1MDExQ1wiOiBcIkdcIixcbiAgICAgICAgXCJcXHUwMTFFXCI6IFwiR1wiLFxuICAgICAgICBcIlxcdTAxMjBcIjogXCJHXCIsXG4gICAgICAgIFwiXFx1MDEyMlwiOiBcIkdcIixcbiAgICAgICAgXCJcXHUwMTFEXCI6IFwiZ1wiLFxuICAgICAgICBcIlxcdTAxMUZcIjogXCJnXCIsXG4gICAgICAgIFwiXFx1MDEyMVwiOiBcImdcIixcbiAgICAgICAgXCJcXHUwMTIzXCI6IFwiZ1wiLFxuICAgICAgICBcIlxcdTAxMjRcIjogXCJIXCIsXG4gICAgICAgIFwiXFx1MDEyNlwiOiBcIkhcIixcbiAgICAgICAgXCJcXHUwMTI1XCI6IFwiaFwiLFxuICAgICAgICBcIlxcdTAxMjdcIjogXCJoXCIsXG4gICAgICAgIFwiXFx1MDEyOFwiOiBcIklcIixcbiAgICAgICAgXCJcXHUwMTJBXCI6IFwiSVwiLFxuICAgICAgICBcIlxcdTAxMkNcIjogXCJJXCIsXG4gICAgICAgIFwiXFx1MDEyRVwiOiBcIklcIixcbiAgICAgICAgXCJcXHUwMTMwXCI6IFwiSVwiLFxuICAgICAgICBcIlxcdTAxMjlcIjogXCJpXCIsXG4gICAgICAgIFwiXFx1MDEyQlwiOiBcImlcIixcbiAgICAgICAgXCJcXHUwMTJEXCI6IFwiaVwiLFxuICAgICAgICBcIlxcdTAxMkZcIjogXCJpXCIsXG4gICAgICAgIFwiXFx1MDEzMVwiOiBcImlcIixcbiAgICAgICAgXCJcXHUwMTM0XCI6IFwiSlwiLFxuICAgICAgICBcIlxcdTAxMzVcIjogXCJqXCIsXG4gICAgICAgIFwiXFx1MDEzNlwiOiBcIktcIixcbiAgICAgICAgXCJcXHUwMTM3XCI6IFwia1wiLFxuICAgICAgICBcIlxcdTAxMzhcIjogXCJrXCIsXG4gICAgICAgIFwiXFx1MDEzOVwiOiBcIkxcIixcbiAgICAgICAgXCJcXHUwMTNCXCI6IFwiTFwiLFxuICAgICAgICBcIlxcdTAxM0RcIjogXCJMXCIsXG4gICAgICAgIFwiXFx1MDEzRlwiOiBcIkxcIixcbiAgICAgICAgXCJcXHUwMTQxXCI6IFwiTFwiLFxuICAgICAgICBcIlxcdTAxM0FcIjogXCJsXCIsXG4gICAgICAgIFwiXFx1MDEzQ1wiOiBcImxcIixcbiAgICAgICAgXCJcXHUwMTNFXCI6IFwibFwiLFxuICAgICAgICBcIlxcdTAxNDBcIjogXCJsXCIsXG4gICAgICAgIFwiXFx1MDE0MlwiOiBcImxcIixcbiAgICAgICAgXCJcXHUwMTQzXCI6IFwiTlwiLFxuICAgICAgICBcIlxcdTAxNDVcIjogXCJOXCIsXG4gICAgICAgIFwiXFx1MDE0N1wiOiBcIk5cIixcbiAgICAgICAgXCJcXHUwMTRBXCI6IFwiTlwiLFxuICAgICAgICBcIlxcdTAxNDRcIjogXCJuXCIsXG4gICAgICAgIFwiXFx1MDE0NlwiOiBcIm5cIixcbiAgICAgICAgXCJcXHUwMTQ4XCI6IFwiblwiLFxuICAgICAgICBcIlxcdTAxNEJcIjogXCJuXCIsXG4gICAgICAgIFwiXFx1MDE0Q1wiOiBcIk9cIixcbiAgICAgICAgXCJcXHUwMTRFXCI6IFwiT1wiLFxuICAgICAgICBcIlxcdTAxNTBcIjogXCJPXCIsXG4gICAgICAgIFwiXFx1MDE0RFwiOiBcIm9cIixcbiAgICAgICAgXCJcXHUwMTRGXCI6IFwib1wiLFxuICAgICAgICBcIlxcdTAxNTFcIjogXCJvXCIsXG4gICAgICAgIFwiXFx1MDE1NFwiOiBcIlJcIixcbiAgICAgICAgXCJcXHUwMTU2XCI6IFwiUlwiLFxuICAgICAgICBcIlxcdTAxNThcIjogXCJSXCIsXG4gICAgICAgIFwiXFx1MDE1NVwiOiBcInJcIixcbiAgICAgICAgXCJcXHUwMTU3XCI6IFwiclwiLFxuICAgICAgICBcIlxcdTAxNTlcIjogXCJyXCIsXG4gICAgICAgIFwiXFx1MDE1QVwiOiBcIlNcIixcbiAgICAgICAgXCJcXHUwMTVDXCI6IFwiU1wiLFxuICAgICAgICBcIlxcdTAxNUVcIjogXCJTXCIsXG4gICAgICAgIFwiXFx1MDE2MFwiOiBcIlNcIixcbiAgICAgICAgXCJcXHUwMTVCXCI6IFwic1wiLFxuICAgICAgICBcIlxcdTAxNURcIjogXCJzXCIsXG4gICAgICAgIFwiXFx1MDE1RlwiOiBcInNcIixcbiAgICAgICAgXCJcXHUwMTYxXCI6IFwic1wiLFxuICAgICAgICBcIlxcdTAxNjJcIjogXCJUXCIsXG4gICAgICAgIFwiXFx1MDE2NFwiOiBcIlRcIixcbiAgICAgICAgXCJcXHUwMTY2XCI6IFwiVFwiLFxuICAgICAgICBcIlxcdTAxNjNcIjogXCJ0XCIsXG4gICAgICAgIFwiXFx1MDE2NVwiOiBcInRcIixcbiAgICAgICAgXCJcXHUwMTY3XCI6IFwidFwiLFxuICAgICAgICBcIlxcdTAxNjhcIjogXCJVXCIsXG4gICAgICAgIFwiXFx1MDE2QVwiOiBcIlVcIixcbiAgICAgICAgXCJcXHUwMTZDXCI6IFwiVVwiLFxuICAgICAgICBcIlxcdTAxNkVcIjogXCJVXCIsXG4gICAgICAgIFwiXFx1MDE3MFwiOiBcIlVcIixcbiAgICAgICAgXCJcXHUwMTcyXCI6IFwiVVwiLFxuICAgICAgICBcIlxcdTAxNjlcIjogXCJ1XCIsXG4gICAgICAgIFwiXFx1MDE2QlwiOiBcInVcIixcbiAgICAgICAgXCJcXHUwMTZEXCI6IFwidVwiLFxuICAgICAgICBcIlxcdTAxNkZcIjogXCJ1XCIsXG4gICAgICAgIFwiXFx1MDE3MVwiOiBcInVcIixcbiAgICAgICAgXCJcXHUwMTczXCI6IFwidVwiLFxuICAgICAgICBcIlxcdTAxNzRcIjogXCJXXCIsXG4gICAgICAgIFwiXFx1MDE3NVwiOiBcIndcIixcbiAgICAgICAgXCJcXHUwMTc2XCI6IFwiWVwiLFxuICAgICAgICBcIlxcdTAxNzdcIjogXCJ5XCIsXG4gICAgICAgIFwiXFx1MDE3OFwiOiBcIllcIixcbiAgICAgICAgXCJcXHUwMTc5XCI6IFwiWlwiLFxuICAgICAgICBcIlxcdTAxN0JcIjogXCJaXCIsXG4gICAgICAgIFwiXFx1MDE3RFwiOiBcIlpcIixcbiAgICAgICAgXCJcXHUwMTdBXCI6IFwielwiLFxuICAgICAgICBcIlxcdTAxN0NcIjogXCJ6XCIsXG4gICAgICAgIFwiXFx1MDE3RVwiOiBcInpcIixcbiAgICAgICAgXCJcXHUwMTMyXCI6IFwiSUpcIixcbiAgICAgICAgXCJcXHUwMTMzXCI6IFwiaWpcIixcbiAgICAgICAgXCJcXHUwMTUyXCI6IFwiT2VcIixcbiAgICAgICAgXCJcXHUwMTUzXCI6IFwib2VcIixcbiAgICAgICAgXCJcXHUwMTQ5XCI6IFwiJ25cIixcbiAgICAgICAgXCJcXHUwMTdGXCI6IFwic1wiXG4gICAgICB9O1xuICAgICAgdmFyIGh0bWxFc2NhcGVzID0ge1xuICAgICAgICBcIiZcIjogXCImYW1wO1wiLFxuICAgICAgICBcIjxcIjogXCImbHQ7XCIsXG4gICAgICAgIFwiPlwiOiBcIiZndDtcIixcbiAgICAgICAgJ1wiJzogXCImcXVvdDtcIixcbiAgICAgICAgXCInXCI6IFwiJiMzOTtcIlxuICAgICAgfTtcbiAgICAgIHZhciBodG1sVW5lc2NhcGVzID0ge1xuICAgICAgICBcIiZhbXA7XCI6IFwiJlwiLFxuICAgICAgICBcIiZsdDtcIjogXCI8XCIsXG4gICAgICAgIFwiJmd0O1wiOiBcIj5cIixcbiAgICAgICAgXCImcXVvdDtcIjogJ1wiJyxcbiAgICAgICAgXCImIzM5O1wiOiBcIidcIlxuICAgICAgfTtcbiAgICAgIHZhciBzdHJpbmdFc2NhcGVzID0ge1xuICAgICAgICBcIlxcXFxcIjogXCJcXFxcXCIsXG4gICAgICAgIFwiJ1wiOiBcIidcIixcbiAgICAgICAgXCJcXG5cIjogXCJuXCIsXG4gICAgICAgIFwiXFxyXCI6IFwiclwiLFxuICAgICAgICBcIlxcdTIwMjhcIjogXCJ1MjAyOFwiLFxuICAgICAgICBcIlxcdTIwMjlcIjogXCJ1MjAyOVwiXG4gICAgICB9O1xuICAgICAgdmFyIGZyZWVQYXJzZUZsb2F0ID0gcGFyc2VGbG9hdCwgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG4gICAgICB2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gXCJvYmplY3RcIiAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcbiAgICAgIHZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09IFwib2JqZWN0XCIgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG4gICAgICB2YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xuICAgICAgdmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG4gICAgICB2YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIiAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG4gICAgICB2YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcbiAgICAgIHZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuICAgICAgdmFyIG5vZGVVdGlsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIHR5cGVzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlKFwidXRpbFwiKS50eXBlcztcbiAgICAgICAgICBpZiAodHlwZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlcztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZyhcInV0aWxcIik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuICAgICAgfSgpO1xuICAgICAgdmFyIG5vZGVJc0FycmF5QnVmZmVyID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNBcnJheUJ1ZmZlciwgbm9kZUlzRGF0ZSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzRGF0ZSwgbm9kZUlzTWFwID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNNYXAsIG5vZGVJc1JlZ0V4cCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzUmVnRXhwLCBub2RlSXNTZXQgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1NldCwgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcbiAgICAgIGZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTtcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBhcnJheUFnZ3JlZ2F0b3IoYXJyYXksIHNldHRlciwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLCBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgICAgc2V0dGVyKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaXRlcmF0ZWUodmFsdWUpLCBhcnJheSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSwgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBhcnJheUVhY2hSaWdodChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbbGVuZ3RoXSwgbGVuZ3RoLCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYXJyYXlFdmVyeShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLCBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAoIXByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLCBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCwgcmVzSW5kZXggPSAwLCByZXN1bHQgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBhcnJheUluY2x1ZGVzKGFycmF5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICAgIHJldHVybiAhIWxlbmd0aCAmJiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIDApID4gLTE7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBhcnJheUluY2x1ZGVzV2l0aChhcnJheSwgdmFsdWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmIChjb21wYXJhdG9yKHZhbHVlLCBhcnJheVtpbmRleF0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLCBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCwgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSwgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCwgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYXJyYXlSZWR1Y2UoYXJyYXksIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLCBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgaWYgKGluaXRBY2N1bSAmJiBsZW5ndGgpIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IGFycmF5WysraW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgYWNjdW11bGF0b3IgPSBpdGVyYXRlZShhY2N1bXVsYXRvciwgYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGFycmF5UmVkdWNlUmlnaHQoYXJyYXksIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgaWYgKGluaXRBY2N1bSAmJiBsZW5ndGgpIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IGFycmF5Wy0tbGVuZ3RoXTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtsZW5ndGhdLCBsZW5ndGgsIGFycmF5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSwgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgYXNjaWlTaXplID0gYmFzZVByb3BlcnR5KFwibGVuZ3RoXCIpO1xuICAgICAgZnVuY3Rpb24gYXNjaWlUb0FycmF5KHN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyaW5nLnNwbGl0KFwiXCIpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYXNjaWlXb3JkcyhzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5tYXRjaChyZUFzY2lpV29yZCkgfHwgW107XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBiYXNlRmluZEtleShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGVhY2hGdW5jKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24yKSB7XG4gICAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uMikpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGtleTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYmFzZUZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgsIGZyb21SaWdodCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLCBpbmRleCA9IGZyb21JbmRleCArIChmcm9tUmlnaHQgPyAxIDogLTEpO1xuICAgICAgICB3aGlsZSAoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkgOiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXNOYU4sIGZyb21JbmRleCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBiYXNlSW5kZXhPZldpdGgoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgsIGNvbXBhcmF0b3IpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmIChjb21wYXJhdG9yKGFycmF5W2luZGV4XSwgdmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGJhc2VJc05hTih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYmFzZU1lYW4oYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VTdW0oYXJyYXksIGl0ZXJhdGVlKSAvIGxlbmd0aCA6IE5BTjtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZDIgOiBvYmplY3Rba2V5XTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGJhc2VQcm9wZXJ0eU9mKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkMiA6IG9iamVjdFtrZXldO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYmFzZVJlZHVjZShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgZWFjaEZ1bmMpIHtcbiAgICAgICAgZWFjaEZ1bmMoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uMikge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0gaW5pdEFjY3VtID8gKGluaXRBY2N1bSA9IGZhbHNlLCB2YWx1ZSkgOiBpdGVyYXRlZShhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uMik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBiYXNlU29ydEJ5KGFycmF5LCBjb21wYXJlcikge1xuICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICBhcnJheS5zb3J0KGNvbXBhcmVyKTtcbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgYXJyYXlbbGVuZ3RoXSA9IGFycmF5W2xlbmd0aF0udmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYmFzZVN1bShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCwgaW5kZXggPSAtMSwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciBjdXJyZW50ID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdKTtcbiAgICAgICAgICBpZiAoY3VycmVudCAhPT0gdW5kZWZpbmVkMikge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ID09PSB1bmRlZmluZWQyID8gY3VycmVudCA6IHJlc3VsdCArIGN1cnJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsIHJlc3VsdCA9IEFycmF5KG4pO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICAgICAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBiYXNlVG9QYWlycyhvYmplY3QsIHByb3BzKSB7XG4gICAgICAgIHJldHVybiBhcnJheU1hcChwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIFtrZXksIG9iamVjdFtrZXldXTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBiYXNlVHJpbShzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZyA/IHN0cmluZy5zbGljZSgwLCB0cmltbWVkRW5kSW5kZXgoc3RyaW5nKSArIDEpLnJlcGxhY2UocmVUcmltU3RhcnQsIFwiXCIpIDogc3RyaW5nO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYmFzZVZhbHVlcyhvYmplY3QsIHByb3BzKSB7XG4gICAgICAgIHJldHVybiBhcnJheU1hcChwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdFtrZXldO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGNhY2hlSGFzKGNhY2hlLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlLmhhcyhrZXkpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gY2hhcnNTdGFydEluZGV4KHN0clN5bWJvbHMsIGNoclN5bWJvbHMpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IHN0clN5bWJvbHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiBiYXNlSW5kZXhPZihjaHJTeW1ib2xzLCBzdHJTeW1ib2xzW2luZGV4XSwgMCkgPiAtMSkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGNoYXJzRW5kSW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scykge1xuICAgICAgICB2YXIgaW5kZXggPSBzdHJTeW1ib2xzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGluZGV4LS0gJiYgYmFzZUluZGV4T2YoY2hyU3ltYm9scywgc3RyU3ltYm9sc1tpbmRleF0sIDApID4gLTEpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBjb3VudEhvbGRlcnMoYXJyYXksIHBsYWNlaG9sZGVyKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsIHJlc3VsdCA9IDA7XG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgIGlmIChhcnJheVtsZW5ndGhdID09PSBwbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgKytyZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICB2YXIgZGVidXJyTGV0dGVyID0gYmFzZVByb3BlcnR5T2YoZGVidXJyZWRMZXR0ZXJzKTtcbiAgICAgIHZhciBlc2NhcGVIdG1sQ2hhciA9IGJhc2VQcm9wZXJ0eU9mKGh0bWxFc2NhcGVzKTtcbiAgICAgIGZ1bmN0aW9uIGVzY2FwZVN0cmluZ0NoYXIoY2hyKSB7XG4gICAgICAgIHJldHVybiBcIlxcXFxcIiArIHN0cmluZ0VzY2FwZXNbY2hyXTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZDIgOiBvYmplY3Rba2V5XTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGhhc1VuaWNvZGUoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiByZUhhc1VuaWNvZGUudGVzdChzdHJpbmcpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gaGFzVW5pY29kZVdvcmQoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiByZUhhc1VuaWNvZGVXb3JkLnRlc3Qoc3RyaW5nKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGl0ZXJhdG9yVG9BcnJheShpdGVyYXRvcikge1xuICAgICAgICB2YXIgZGF0YSwgcmVzdWx0ID0gW107XG4gICAgICAgIHdoaWxlICghKGRhdGEgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChkYXRhLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbWFwVG9BcnJheShtYXApIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcbiAgICAgICAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcmVwbGFjZUhvbGRlcnMoYXJyYXksIHBsYWNlaG9sZGVyKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLCBsZW5ndGggPSBhcnJheS5sZW5ndGgsIHJlc0luZGV4ID0gMCwgcmVzdWx0ID0gW107XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gcGxhY2Vob2xkZXIgfHwgdmFsdWUgPT09IFBMQUNFSE9MREVSKSB7XG4gICAgICAgICAgICBhcnJheVtpbmRleF0gPSBQTEFDRUhPTERFUjtcbiAgICAgICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IGluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcbiAgICAgICAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBzZXRUb1BhaXJzKHNldCkge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSwgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuICAgICAgICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHJlc3VsdFsrK2luZGV4XSA9IFt2YWx1ZSwgdmFsdWVdO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHN0cmljdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHN0cmljdExhc3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgICAgIHZhciBpbmRleCA9IGZyb21JbmRleCArIDE7XG4gICAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gc3RyaW5nU2l6ZShzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIGhhc1VuaWNvZGUoc3RyaW5nKSA/IHVuaWNvZGVTaXplKHN0cmluZykgOiBhc2NpaVNpemUoc3RyaW5nKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHN0cmluZ1RvQXJyYXkoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBoYXNVbmljb2RlKHN0cmluZykgPyB1bmljb2RlVG9BcnJheShzdHJpbmcpIDogYXNjaWlUb0FycmF5KHN0cmluZyk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB0cmltbWVkRW5kSW5kZXgoc3RyaW5nKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHN0cmluZy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpbmRleC0tICYmIHJlV2hpdGVzcGFjZS50ZXN0KHN0cmluZy5jaGFyQXQoaW5kZXgpKSkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICAgIHZhciB1bmVzY2FwZUh0bWxDaGFyID0gYmFzZVByb3BlcnR5T2YoaHRtbFVuZXNjYXBlcyk7XG4gICAgICBmdW5jdGlvbiB1bmljb2RlU2l6ZShzdHJpbmcpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlVW5pY29kZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAocmVVbmljb2RlLnRlc3Qoc3RyaW5nKSkge1xuICAgICAgICAgICsrcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB1bmljb2RlVG9BcnJheShzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5tYXRjaChyZVVuaWNvZGUpIHx8IFtdO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdW5pY29kZVdvcmRzKHN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlVW5pY29kZVdvcmQpIHx8IFtdO1xuICAgICAgfVxuICAgICAgdmFyIHJ1bkluQ29udGV4dCA9IGZ1bmN0aW9uIHJ1bkluQ29udGV4dDIoY29udGV4dCkge1xuICAgICAgICBjb250ZXh0ID0gY29udGV4dCA9PSBudWxsID8gcm9vdCA6IF8uZGVmYXVsdHMocm9vdC5PYmplY3QoKSwgY29udGV4dCwgXy5waWNrKHJvb3QsIGNvbnRleHRQcm9wcykpO1xuICAgICAgICB2YXIgQXJyYXkyID0gY29udGV4dC5BcnJheSwgRGF0ZTIgPSBjb250ZXh0LkRhdGUsIEVycm9yMiA9IGNvbnRleHQuRXJyb3IsIEZ1bmN0aW9uMiA9IGNvbnRleHQuRnVuY3Rpb24sIE1hdGgyID0gY29udGV4dC5NYXRoLCBPYmplY3QyID0gY29udGV4dC5PYmplY3QsIFJlZ0V4cDIgPSBjb250ZXh0LlJlZ0V4cCwgU3RyaW5nMiA9IGNvbnRleHQuU3RyaW5nLCBUeXBlRXJyb3IyID0gY29udGV4dC5UeXBlRXJyb3I7XG4gICAgICAgIHZhciBhcnJheVByb3RvID0gQXJyYXkyLnByb3RvdHlwZSwgZnVuY1Byb3RvID0gRnVuY3Rpb24yLnByb3RvdHlwZSwgb2JqZWN0UHJvdG8gPSBPYmplY3QyLnByb3RvdHlwZTtcbiAgICAgICAgdmFyIGNvcmVKc0RhdGEgPSBjb250ZXh0W1wiX19jb3JlLWpzX3NoYXJlZF9fXCJdO1xuICAgICAgICB2YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuICAgICAgICB2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcbiAgICAgICAgdmFyIGlkQ291bnRlciA9IDA7XG4gICAgICAgIHZhciBtYXNrU3JjS2V5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8IFwiXCIpO1xuICAgICAgICAgIHJldHVybiB1aWQgPyBcIlN5bWJvbChzcmMpXzEuXCIgKyB1aWQgOiBcIlwiO1xuICAgICAgICB9KCk7XG4gICAgICAgIHZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuICAgICAgICB2YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdDIpO1xuICAgICAgICB2YXIgb2xkRGFzaCA9IHJvb3QuXztcbiAgICAgICAgdmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAyKFxuICAgICAgICAgIFwiXlwiICsgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCBcIlxcXFwkJlwiKS5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCBcIiQxLio/XCIpICsgXCIkXCJcbiAgICAgICAgKTtcbiAgICAgICAgdmFyIEJ1ZmZlcjIgPSBtb2R1bGVFeHBvcnRzID8gY29udGV4dC5CdWZmZXIgOiB1bmRlZmluZWQyLCBTeW1ib2wyID0gY29udGV4dC5TeW1ib2wsIFVpbnQ4QXJyYXkyID0gY29udGV4dC5VaW50OEFycmF5LCBhbGxvY1Vuc2FmZSA9IEJ1ZmZlcjIgPyBCdWZmZXIyLmFsbG9jVW5zYWZlIDogdW5kZWZpbmVkMiwgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QyLmdldFByb3RvdHlwZU9mLCBPYmplY3QyKSwgb2JqZWN0Q3JlYXRlID0gT2JqZWN0Mi5jcmVhdGUsIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGUsIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlLCBzcHJlYWRhYmxlU3ltYm9sID0gU3ltYm9sMiA/IFN5bWJvbDIuaXNDb25jYXRTcHJlYWRhYmxlIDogdW5kZWZpbmVkMiwgc3ltSXRlcmF0b3IgPSBTeW1ib2wyID8gU3ltYm9sMi5pdGVyYXRvciA6IHVuZGVmaW5lZDIsIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sMiA/IFN5bWJvbDIudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQyO1xuICAgICAgICB2YXIgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0MiwgXCJkZWZpbmVQcm9wZXJ0eVwiKTtcbiAgICAgICAgICAgIGZ1bmMoe30sIFwiXCIsIHt9KTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB9XG4gICAgICAgIH0oKTtcbiAgICAgICAgdmFyIGN0eENsZWFyVGltZW91dCA9IGNvbnRleHQuY2xlYXJUaW1lb3V0ICE9PSByb290LmNsZWFyVGltZW91dCAmJiBjb250ZXh0LmNsZWFyVGltZW91dCwgY3R4Tm93ID0gRGF0ZTIgJiYgRGF0ZTIubm93ICE9PSByb290LkRhdGUubm93ICYmIERhdGUyLm5vdywgY3R4U2V0VGltZW91dCA9IGNvbnRleHQuc2V0VGltZW91dCAhPT0gcm9vdC5zZXRUaW1lb3V0ICYmIGNvbnRleHQuc2V0VGltZW91dDtcbiAgICAgICAgdmFyIG5hdGl2ZUNlaWwgPSBNYXRoMi5jZWlsLCBuYXRpdmVGbG9vciA9IE1hdGgyLmZsb29yLCBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0Mi5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyMiA/IEJ1ZmZlcjIuaXNCdWZmZXIgOiB1bmRlZmluZWQyLCBuYXRpdmVJc0Zpbml0ZSA9IGNvbnRleHQuaXNGaW5pdGUsIG5hdGl2ZUpvaW4gPSBhcnJheVByb3RvLmpvaW4sIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdDIua2V5cywgT2JqZWN0MiksIG5hdGl2ZU1heCA9IE1hdGgyLm1heCwgbmF0aXZlTWluID0gTWF0aDIubWluLCBuYXRpdmVOb3cgPSBEYXRlMi5ub3csIG5hdGl2ZVBhcnNlSW50ID0gY29udGV4dC5wYXJzZUludCwgbmF0aXZlUmFuZG9tID0gTWF0aDIucmFuZG9tLCBuYXRpdmVSZXZlcnNlID0gYXJyYXlQcm90by5yZXZlcnNlO1xuICAgICAgICB2YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUoY29udGV4dCwgXCJEYXRhVmlld1wiKSwgTWFwMiA9IGdldE5hdGl2ZShjb250ZXh0LCBcIk1hcFwiKSwgUHJvbWlzZTIgPSBnZXROYXRpdmUoY29udGV4dCwgXCJQcm9taXNlXCIpLCBTZXQyID0gZ2V0TmF0aXZlKGNvbnRleHQsIFwiU2V0XCIpLCBXZWFrTWFwMiA9IGdldE5hdGl2ZShjb250ZXh0LCBcIldlYWtNYXBcIiksIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QyLCBcImNyZWF0ZVwiKTtcbiAgICAgICAgdmFyIG1ldGFNYXAgPSBXZWFrTWFwMiAmJiBuZXcgV2Vha01hcDIoKTtcbiAgICAgICAgdmFyIHJlYWxOYW1lcyA9IHt9O1xuICAgICAgICB2YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLCBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwMiksIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZTIpLCBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0MiksIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcDIpO1xuICAgICAgICB2YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wyID8gU3ltYm9sMi5wcm90b3R5cGUgOiB1bmRlZmluZWQyLCBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkMiwgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkMjtcbiAgICAgICAgZnVuY3Rpb24gbG9kYXNoKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzQXJyYXkodmFsdWUpICYmICEodmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExvZGFzaFdyYXBwZXIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIFwiX193cmFwcGVkX19cIikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZXJDbG9uZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJhc2VDcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBmdW5jdGlvbiBvYmplY3QoKSB7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgICAgICAgICAgaWYgKCFpc09iamVjdChwcm90bykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdENyZWF0ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0Q3JlYXRlKHByb3RvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9iamVjdC5wcm90b3R5cGUgPSBwcm90bztcbiAgICAgICAgICAgIHZhciByZXN1bHQyID0gbmV3IG9iamVjdCgpO1xuICAgICAgICAgICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDI7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgICB9O1xuICAgICAgICB9KCk7XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VMb2Rhc2goKSB7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gTG9kYXNoV3JhcHBlcih2YWx1ZSwgY2hhaW5BbGwpIHtcbiAgICAgICAgICB0aGlzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5fX2FjdGlvbnNfXyA9IFtdO1xuICAgICAgICAgIHRoaXMuX19jaGFpbl9fID0gISFjaGFpbkFsbDtcbiAgICAgICAgICB0aGlzLl9faW5kZXhfXyA9IDA7XG4gICAgICAgICAgdGhpcy5fX3ZhbHVlc19fID0gdW5kZWZpbmVkMjtcbiAgICAgICAgfVxuICAgICAgICBsb2Rhc2gudGVtcGxhdGVTZXR0aW5ncyA9IHtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGJlIEhUTUwtZXNjYXBlZC5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAgICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgICAgICAgICAqL1xuICAgICAgICAgIFwiZXNjYXBlXCI6IHJlRXNjYXBlLFxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGNvZGUgdG8gYmUgZXZhbHVhdGVkLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICAgICAqIEB0eXBlIHtSZWdFeHB9XG4gICAgICAgICAgICovXG4gICAgICAgICAgXCJldmFsdWF0ZVwiOiByZUV2YWx1YXRlLFxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gaW5qZWN0LlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICAgICAqIEB0eXBlIHtSZWdFeHB9XG4gICAgICAgICAgICovXG4gICAgICAgICAgXCJpbnRlcnBvbGF0ZVwiOiByZUludGVycG9sYXRlLFxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFVzZWQgdG8gcmVmZXJlbmNlIHRoZSBkYXRhIG9iamVjdCBpbiB0aGUgdGVtcGxhdGUgdGV4dC5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgICAqL1xuICAgICAgICAgIFwidmFyaWFibGVcIjogXCJcIixcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBVc2VkIHRvIGltcG9ydCB2YXJpYWJsZXMgaW50byB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBcImltcG9ydHNcIjoge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzXG4gICAgICAgICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiX1wiOiBsb2Rhc2hcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGxvZGFzaC5wcm90b3R5cGUgPSBiYXNlTG9kYXNoLnByb3RvdHlwZTtcbiAgICAgICAgbG9kYXNoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGxvZGFzaDtcbiAgICAgICAgTG9kYXNoV3JhcHBlci5wcm90b3R5cGUgPSBiYXNlQ3JlYXRlKGJhc2VMb2Rhc2gucHJvdG90eXBlKTtcbiAgICAgICAgTG9kYXNoV3JhcHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMb2Rhc2hXcmFwcGVyO1xuICAgICAgICBmdW5jdGlvbiBMYXp5V3JhcHBlcih2YWx1ZSkge1xuICAgICAgICAgIHRoaXMuX193cmFwcGVkX18gPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLl9fYWN0aW9uc19fID0gW107XG4gICAgICAgICAgdGhpcy5fX2Rpcl9fID0gMTtcbiAgICAgICAgICB0aGlzLl9fZmlsdGVyZWRfXyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuX19pdGVyYXRlZXNfXyA9IFtdO1xuICAgICAgICAgIHRoaXMuX190YWtlQ291bnRfXyA9IE1BWF9BUlJBWV9MRU5HVEg7XG4gICAgICAgICAgdGhpcy5fX3ZpZXdzX18gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsYXp5Q2xvbmUoKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdDIgPSBuZXcgTGF6eVdyYXBwZXIodGhpcy5fX3dyYXBwZWRfXyk7XG4gICAgICAgICAgcmVzdWx0Mi5fX2FjdGlvbnNfXyA9IGNvcHlBcnJheSh0aGlzLl9fYWN0aW9uc19fKTtcbiAgICAgICAgICByZXN1bHQyLl9fZGlyX18gPSB0aGlzLl9fZGlyX187XG4gICAgICAgICAgcmVzdWx0Mi5fX2ZpbHRlcmVkX18gPSB0aGlzLl9fZmlsdGVyZWRfXztcbiAgICAgICAgICByZXN1bHQyLl9faXRlcmF0ZWVzX18gPSBjb3B5QXJyYXkodGhpcy5fX2l0ZXJhdGVlc19fKTtcbiAgICAgICAgICByZXN1bHQyLl9fdGFrZUNvdW50X18gPSB0aGlzLl9fdGFrZUNvdW50X187XG4gICAgICAgICAgcmVzdWx0Mi5fX3ZpZXdzX18gPSBjb3B5QXJyYXkodGhpcy5fX3ZpZXdzX18pO1xuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGxhenlSZXZlcnNlKCkge1xuICAgICAgICAgIGlmICh0aGlzLl9fZmlsdGVyZWRfXykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDIgPSBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICAgICAgICByZXN1bHQyLl9fZGlyX18gPSAtMTtcbiAgICAgICAgICAgIHJlc3VsdDIuX19maWx0ZXJlZF9fID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgICAgIHJlc3VsdDIuX19kaXJfXyAqPSAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbGF6eVZhbHVlKCkge1xuICAgICAgICAgIHZhciBhcnJheSA9IHRoaXMuX193cmFwcGVkX18udmFsdWUoKSwgZGlyID0gdGhpcy5fX2Rpcl9fLCBpc0FyciA9IGlzQXJyYXkoYXJyYXkpLCBpc1JpZ2h0ID0gZGlyIDwgMCwgYXJyTGVuZ3RoID0gaXNBcnIgPyBhcnJheS5sZW5ndGggOiAwLCB2aWV3ID0gZ2V0VmlldygwLCBhcnJMZW5ndGgsIHRoaXMuX192aWV3c19fKSwgc3RhcnQgPSB2aWV3LnN0YXJ0LCBlbmQgPSB2aWV3LmVuZCwgbGVuZ3RoID0gZW5kIC0gc3RhcnQsIGluZGV4ID0gaXNSaWdodCA/IGVuZCA6IHN0YXJ0IC0gMSwgaXRlcmF0ZWVzID0gdGhpcy5fX2l0ZXJhdGVlc19fLCBpdGVyTGVuZ3RoID0gaXRlcmF0ZWVzLmxlbmd0aCwgcmVzSW5kZXggPSAwLCB0YWtlQ291bnQgPSBuYXRpdmVNaW4obGVuZ3RoLCB0aGlzLl9fdGFrZUNvdW50X18pO1xuICAgICAgICAgIGlmICghaXNBcnIgfHwgIWlzUmlnaHQgJiYgYXJyTGVuZ3RoID09IGxlbmd0aCAmJiB0YWtlQ291bnQgPT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gYmFzZVdyYXBwZXJWYWx1ZShhcnJheSwgdGhpcy5fX2FjdGlvbnNfXyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZXN1bHQyID0gW107XG4gICAgICAgICAgb3V0ZXI6XG4gICAgICAgICAgICB3aGlsZSAobGVuZ3RoLS0gJiYgcmVzSW5kZXggPCB0YWtlQ291bnQpIHtcbiAgICAgICAgICAgICAgaW5kZXggKz0gZGlyO1xuICAgICAgICAgICAgICB2YXIgaXRlckluZGV4ID0gLTEsIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICAgICAgICB3aGlsZSAoKytpdGVySW5kZXggPCBpdGVyTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBpdGVyYXRlZXNbaXRlckluZGV4XSwgaXRlcmF0ZWUyID0gZGF0YS5pdGVyYXRlZSwgdHlwZSA9IGRhdGEudHlwZSwgY29tcHV0ZWQgPSBpdGVyYXRlZTIodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09IExBWllfTUFQX0ZMQUcpIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gY29tcHV0ZWQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09IExBWllfRklMVEVSX0ZMQUcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0MltyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZSA9IGJhc2VDcmVhdGUoYmFzZUxvZGFzaC5wcm90b3R5cGUpO1xuICAgICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMYXp5V3JhcHBlcjtcbiAgICAgICAgZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcbiAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgICAgICAgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICAgICAgICAgIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gICAgICAgICAgdmFyIHJlc3VsdDIgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gICAgICAgICAgdGhpcy5zaXplIC09IHJlc3VsdDIgPyAxIDogMDtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgICAgICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0MiA9IGRhdGFba2V5XTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQyID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZDIgOiByZXN1bHQyO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkMjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgICAgICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gZGF0YVtrZXldICE9PSB1bmRlZmluZWQyIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgICAgICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICAgICAgICAgIGRhdGFba2V5XSA9IG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkMiA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG4gICAgICAgIEhhc2gucHJvdG90eXBlW1wiZGVsZXRlXCJdID0gaGFzaERlbGV0ZTtcbiAgICAgICAgSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbiAgICAgICAgSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbiAgICAgICAgSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcbiAgICAgICAgZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSAtMSwgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuICAgICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgICAgICAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YV9fID0gW107XG4gICAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLCBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgICAgICAgICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgICBkYXRhLnBvcCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC0tdGhpcy5zaXplO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG4gICAgICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZDIgOiBkYXRhW2luZGV4XVsxXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG4gICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgKyt0aGlzLnNpemU7XG4gICAgICAgICAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuICAgICAgICBMaXN0Q2FjaGUucHJvdG90eXBlW1wiZGVsZXRlXCJdID0gbGlzdENhY2hlRGVsZXRlO1xuICAgICAgICBMaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbiAgICAgICAgTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG4gICAgICAgIExpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuICAgICAgICBmdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcbiAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgICAgICAgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgICAgIHRoaXMuX19kYXRhX18gPSB7XG4gICAgICAgICAgICBcImhhc2hcIjogbmV3IEhhc2goKSxcbiAgICAgICAgICAgIFwibWFwXCI6IG5ldyAoTWFwMiB8fCBMaXN0Q2FjaGUpKCksXG4gICAgICAgICAgICBcInN0cmluZ1wiOiBuZXcgSGFzaCgpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IGdldE1hcERhdGEodGhpcywga2V5KVtcImRlbGV0ZVwiXShrZXkpO1xuICAgICAgICAgIHRoaXMuc2l6ZSAtPSByZXN1bHQyID8gMSA6IDA7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSwgc2l6ZTIgPSBkYXRhLnNpemU7XG4gICAgICAgICAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplMiA/IDAgOiAxO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIE1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG4gICAgICAgIE1hcENhY2hlLnByb3RvdHlwZVtcImRlbGV0ZVwiXSA9IG1hcENhY2hlRGVsZXRlO1xuICAgICAgICBNYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG4gICAgICAgIE1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbiAgICAgICAgTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuICAgICAgICBmdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMyKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IHZhbHVlczIgPT0gbnVsbCA/IDAgOiB2YWx1ZXMyLmxlbmd0aDtcbiAgICAgICAgICB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKCk7XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkKHZhbHVlczJbaW5kZXhdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNldENhY2hlSGFzKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBTZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBzZXRDYWNoZUFkZDtcbiAgICAgICAgU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuICAgICAgICBmdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgICAgICAgICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZSgpO1xuICAgICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLCByZXN1bHQyID0gZGF0YVtcImRlbGV0ZVwiXShrZXkpO1xuICAgICAgICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgICAgICAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgICAgICAgICAgaWYgKCFNYXAyIHx8IHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSB7XG4gICAgICAgICAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgICAgICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcbiAgICAgICAgU3RhY2sucHJvdG90eXBlW1wiZGVsZXRlXCJdID0gc3RhY2tEZWxldGU7XG4gICAgICAgIFN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcbiAgICAgICAgU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuICAgICAgICBTdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG4gICAgICAgIGZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICAgICAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLCBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLCBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSwgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLCByZXN1bHQyID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcyKSA6IFtdLCBsZW5ndGggPSByZXN1bHQyLmxlbmd0aDtcbiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmICEoc2tpcEluZGV4ZXMgJiYgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICAgKGtleSA9PSBcImxlbmd0aFwiIHx8IC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAgaXNCdWZmICYmIChrZXkgPT0gXCJvZmZzZXRcIiB8fCBrZXkgPT0gXCJwYXJlbnRcIikgfHwgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAgaXNUeXBlICYmIChrZXkgPT0gXCJidWZmZXJcIiB8fCBrZXkgPT0gXCJieXRlTGVuZ3RoXCIgfHwga2V5ID09IFwiYnl0ZU9mZnNldFwiKSB8fCAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKSkpKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhcnJheVNhbXBsZShhcnJheSkge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIGxlbmd0aCA/IGFycmF5W2Jhc2VSYW5kb20oMCwgbGVuZ3RoIC0gMSldIDogdW5kZWZpbmVkMjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhcnJheVNhbXBsZVNpemUoYXJyYXksIG4pIHtcbiAgICAgICAgICByZXR1cm4gc2h1ZmZsZVNlbGYoY29weUFycmF5KGFycmF5KSwgYmFzZUNsYW1wKG4sIDAsIGFycmF5Lmxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFycmF5U2h1ZmZsZShhcnJheSkge1xuICAgICAgICAgIHJldHVybiBzaHVmZmxlU2VsZihjb3B5QXJyYXkoYXJyYXkpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkMiAmJiAhZXEob2JqZWN0W2tleV0sIHZhbHVlKSB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkMiAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG4gICAgICAgICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDIgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlQWdncmVnYXRvcihjb2xsZWN0aW9uLCBzZXR0ZXIsIGl0ZXJhdGVlMiwgYWNjdW11bGF0b3IpIHtcbiAgICAgICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uMikge1xuICAgICAgICAgICAgc2V0dGVyKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaXRlcmF0ZWUyKHZhbHVlKSwgY29sbGVjdGlvbjIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlQXNzaWduKG9iamVjdCwgc291cmNlKSB7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VBc3NpZ25JbihvYmplY3QsIHNvdXJjZSkge1xuICAgICAgICAgIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgICBpZiAoa2V5ID09IFwiX19wcm90b19fXCIgJiYgZGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICAgICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG4gICAgICAgICAgICAgIFwiY29uZmlndXJhYmxlXCI6IHRydWUsXG4gICAgICAgICAgICAgIFwiZW51bWVyYWJsZVwiOiB0cnVlLFxuICAgICAgICAgICAgICBcInZhbHVlXCI6IHZhbHVlLFxuICAgICAgICAgICAgICBcIndyaXRhYmxlXCI6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlQXQob2JqZWN0LCBwYXRocykge1xuICAgICAgICAgIHZhciBpbmRleCA9IC0xLCBsZW5ndGggPSBwYXRocy5sZW5ndGgsIHJlc3VsdDIgPSBBcnJheTIobGVuZ3RoKSwgc2tpcCA9IG9iamVjdCA9PSBudWxsO1xuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQyW2luZGV4XSA9IHNraXAgPyB1bmRlZmluZWQyIDogZ2V0KG9iamVjdCwgcGF0aHNbaW5kZXhdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZUNsYW1wKG51bWJlciwgbG93ZXIsIHVwcGVyKSB7XG4gICAgICAgICAgaWYgKG51bWJlciA9PT0gbnVtYmVyKSB7XG4gICAgICAgICAgICBpZiAodXBwZXIgIT09IHVuZGVmaW5lZDIpIHtcbiAgICAgICAgICAgICAgbnVtYmVyID0gbnVtYmVyIDw9IHVwcGVyID8gbnVtYmVyIDogdXBwZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobG93ZXIgIT09IHVuZGVmaW5lZDIpIHtcbiAgICAgICAgICAgICAgbnVtYmVyID0gbnVtYmVyID49IGxvd2VyID8gbnVtYmVyIDogbG93ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZUNsb25lKHZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIG9iamVjdCwgc3RhY2spIHtcbiAgICAgICAgICB2YXIgcmVzdWx0MiwgaXNEZWVwID0gYml0bWFzayAmIENMT05FX0RFRVBfRkxBRywgaXNGbGF0ID0gYml0bWFzayAmIENMT05FX0ZMQVRfRkxBRywgaXNGdWxsID0gYml0bWFzayAmIENMT05FX1NZTUJPTFNfRkxBRztcbiAgICAgICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICAgICAgcmVzdWx0MiA9IG9iamVjdCA/IGN1c3RvbWl6ZXIodmFsdWUsIGtleSwgb2JqZWN0LCBzdGFjaykgOiBjdXN0b21pemVyKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDIgIT09IHVuZGVmaW5lZDIpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgICAgICAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBpbml0Q2xvbmVBcnJheSh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICAgICAgICByZXR1cm4gY29weUFycmF5KHZhbHVlLCByZXN1bHQyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSksIGlzRnVuYyA9IHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG4gICAgICAgICAgICBpZiAoaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjbG9uZUJ1ZmZlcih2YWx1ZSwgaXNEZWVwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YWcgPT0gb2JqZWN0VGFnIHx8IHRhZyA9PSBhcmdzVGFnIHx8IGlzRnVuYyAmJiAhb2JqZWN0KSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBpc0ZsYXQgfHwgaXNGdW5jID8ge30gOiBpbml0Q2xvbmVPYmplY3QodmFsdWUpO1xuICAgICAgICAgICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0ZsYXQgPyBjb3B5U3ltYm9sc0luKHZhbHVlLCBiYXNlQXNzaWduSW4ocmVzdWx0MiwgdmFsdWUpKSA6IGNvcHlTeW1ib2xzKHZhbHVlLCBiYXNlQXNzaWduKHJlc3VsdDIsIHZhbHVlKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICghY2xvbmVhYmxlVGFnc1t0YWddKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdCA/IHZhbHVlIDoge307XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0MiA9IGluaXRDbG9uZUJ5VGFnKHZhbHVlLCB0YWcsIGlzRGVlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjaygpKTtcbiAgICAgICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldCh2YWx1ZSk7XG4gICAgICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFja2VkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdGFjay5zZXQodmFsdWUsIHJlc3VsdDIpO1xuICAgICAgICAgIGlmIChpc1NldCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUpIHtcbiAgICAgICAgICAgICAgcmVzdWx0Mi5hZGQoYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdWJWYWx1ZSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzTWFwKHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbihzdWJWYWx1ZSwga2V5Mikge1xuICAgICAgICAgICAgICByZXN1bHQyLnNldChrZXkyLCBiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleTIsIHZhbHVlLCBzdGFjaykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBrZXlzRnVuYyA9IGlzRnVsbCA/IGlzRmxhdCA/IGdldEFsbEtleXNJbiA6IGdldEFsbEtleXMgOiBpc0ZsYXQgPyBrZXlzSW4gOiBrZXlzO1xuICAgICAgICAgIHZhciBwcm9wcyA9IGlzQXJyID8gdW5kZWZpbmVkMiA6IGtleXNGdW5jKHZhbHVlKTtcbiAgICAgICAgICBhcnJheUVhY2gocHJvcHMgfHwgdmFsdWUsIGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkyKSB7XG4gICAgICAgICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgICAgICAga2V5MiA9IHN1YlZhbHVlO1xuICAgICAgICAgICAgICBzdWJWYWx1ZSA9IHZhbHVlW2tleTJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzaWduVmFsdWUocmVzdWx0Miwga2V5MiwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXkyLCB2YWx1ZSwgc3RhY2spKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlQ29uZm9ybXMoc291cmNlKSB7XG4gICAgICAgICAgdmFyIHByb3BzID0ga2V5cyhzb3VyY2UpO1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBiYXNlQ29uZm9ybXNUbyhvYmplY3QsIHNvdXJjZSwgcHJvcHMpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZUNvbmZvcm1zVG8ob2JqZWN0LCBzb3VyY2UsIHByb3BzKSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcbiAgICAgICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAhbGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvYmplY3QgPSBPYmplY3QyKG9iamVjdCk7XG4gICAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gcHJvcHNbbGVuZ3RoXSwgcHJlZGljYXRlID0gc291cmNlW2tleV0sIHZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZDIgJiYgIShrZXkgaW4gb2JqZWN0KSB8fCAhcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VEZWxheShmdW5jLCB3YWl0LCBhcmdzKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBmdW5jICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjIoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmdW5jLmFwcGx5KHVuZGVmaW5lZDIsIGFyZ3MpO1xuICAgICAgICAgIH0sIHdhaXQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VEaWZmZXJlbmNlKGFycmF5LCB2YWx1ZXMyLCBpdGVyYXRlZTIsIGNvbXBhcmF0b3IpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSAtMSwgaW5jbHVkZXMyID0gYXJyYXlJbmNsdWRlcywgaXNDb21tb24gPSB0cnVlLCBsZW5ndGggPSBhcnJheS5sZW5ndGgsIHJlc3VsdDIgPSBbXSwgdmFsdWVzTGVuZ3RoID0gdmFsdWVzMi5sZW5ndGg7XG4gICAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXRlcmF0ZWUyKSB7XG4gICAgICAgICAgICB2YWx1ZXMyID0gYXJyYXlNYXAodmFsdWVzMiwgYmFzZVVuYXJ5KGl0ZXJhdGVlMikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29tcGFyYXRvcikge1xuICAgICAgICAgICAgaW5jbHVkZXMyID0gYXJyYXlJbmNsdWRlc1dpdGg7XG4gICAgICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVzMi5sZW5ndGggPj0gTEFSR0VfQVJSQVlfU0laRSkge1xuICAgICAgICAgICAgaW5jbHVkZXMyID0gY2FjaGVIYXM7XG4gICAgICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICAgICAgdmFsdWVzMiA9IG5ldyBTZXRDYWNoZSh2YWx1ZXMyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ZXI6XG4gICAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sIGNvbXB1dGVkID0gaXRlcmF0ZWUyID09IG51bGwgPyB2YWx1ZSA6IGl0ZXJhdGVlMih2YWx1ZSk7XG4gICAgICAgICAgICAgIHZhbHVlID0gY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCA/IHZhbHVlIDogMDtcbiAgICAgICAgICAgICAgaWYgKGlzQ29tbW9uICYmIGNvbXB1dGVkID09PSBjb21wdXRlZCkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZXNJbmRleCA9IHZhbHVlc0xlbmd0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAodmFsdWVzSW5kZXgtLSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlczJbdmFsdWVzSW5kZXhdID09PSBjb21wdXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0Mi5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICghaW5jbHVkZXMyKHZhbHVlczIsIGNvbXB1dGVkLCBjb21wYXJhdG9yKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdDIucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmFzZUVhY2ggPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duKTtcbiAgICAgICAgdmFyIGJhc2VFYWNoUmlnaHQgPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duUmlnaHQsIHRydWUpO1xuICAgICAgICBmdW5jdGlvbiBiYXNlRXZlcnkoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdDIgPSB0cnVlO1xuICAgICAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbjIpIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSAhIXByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24yKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VFeHRyZW11bShhcnJheSwgaXRlcmF0ZWUyLCBjb21wYXJhdG9yKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLCBjdXJyZW50ID0gaXRlcmF0ZWUyKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50ICE9IG51bGwgJiYgKGNvbXB1dGVkID09PSB1bmRlZmluZWQyID8gY3VycmVudCA9PT0gY3VycmVudCAmJiAhaXNTeW1ib2woY3VycmVudCkgOiBjb21wYXJhdG9yKGN1cnJlbnQsIGNvbXB1dGVkKSkpIHtcbiAgICAgICAgICAgICAgdmFyIGNvbXB1dGVkID0gY3VycmVudCwgcmVzdWx0MiA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlRmlsbChhcnJheSwgdmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICAgIHN0YXJ0ID0gdG9JbnRlZ2VyKHN0YXJ0KTtcbiAgICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICBzdGFydCA9IC1zdGFydCA+IGxlbmd0aCA/IDAgOiBsZW5ndGggKyBzdGFydDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZW5kID0gZW5kID09PSB1bmRlZmluZWQyIHx8IGVuZCA+IGxlbmd0aCA/IGxlbmd0aCA6IHRvSW50ZWdlcihlbmQpO1xuICAgICAgICAgIGlmIChlbmQgPCAwKSB7XG4gICAgICAgICAgICBlbmQgKz0gbGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbmQgPSBzdGFydCA+IGVuZCA/IDAgOiB0b0xlbmd0aChlbmQpO1xuICAgICAgICAgIHdoaWxlIChzdGFydCA8IGVuZCkge1xuICAgICAgICAgICAgYXJyYXlbc3RhcnQrK10gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VGaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdDIgPSBbXTtcbiAgICAgICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24yKSB7XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbjIpKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZUZsYXR0ZW4oYXJyYXksIGRlcHRoLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQyKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICBwcmVkaWNhdGUgfHwgKHByZWRpY2F0ZSA9IGlzRmxhdHRlbmFibGUpO1xuICAgICAgICAgIHJlc3VsdDIgfHwgKHJlc3VsdDIgPSBbXSk7XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgICAgIGlmIChkZXB0aCA+IDAgJiYgcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgICBpZiAoZGVwdGggPiAxKSB7XG4gICAgICAgICAgICAgICAgYmFzZUZsYXR0ZW4odmFsdWUsIGRlcHRoIC0gMSwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0Mik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJyYXlQdXNoKHJlc3VsdDIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICghaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MltyZXN1bHQyLmxlbmd0aF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJhc2VGb3IgPSBjcmVhdGVCYXNlRm9yKCk7XG4gICAgICAgIHZhciBiYXNlRm9yUmlnaHQgPSBjcmVhdGVCYXNlRm9yKHRydWUpO1xuICAgICAgICBmdW5jdGlvbiBiYXNlRm9yT3duKG9iamVjdCwgaXRlcmF0ZWUyKSB7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUyLCBrZXlzKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlRm9yT3duUmlnaHQob2JqZWN0LCBpdGVyYXRlZTIpIHtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3JSaWdodChvYmplY3QsIGl0ZXJhdGVlMiwga2V5cyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZUZ1bmN0aW9ucyhvYmplY3QsIHByb3BzKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5RmlsdGVyKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKG9iamVjdFtrZXldKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuICAgICAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICAgICAgICAgIHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgb2JqZWN0ID0gb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXgrK10pXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCA/IG9iamVjdCA6IHVuZGVmaW5lZDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IGtleXNGdW5jKG9iamVjdCk7XG4gICAgICAgICAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdDIgOiBhcnJheVB1c2gocmVzdWx0Miwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZDIgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0Mih2YWx1ZSkgPyBnZXRSYXdUYWcodmFsdWUpIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VHdCh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUgPiBvdGhlcjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlSGFzKG9iamVjdCwga2V5KSB7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VIYXNJbihvYmplY3QsIGtleSkge1xuICAgICAgICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0MihvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VJblJhbmdlKG51bWJlciwgc3RhcnQsIGVuZCkge1xuICAgICAgICAgIHJldHVybiBudW1iZXIgPj0gbmF0aXZlTWluKHN0YXJ0LCBlbmQpICYmIG51bWJlciA8IG5hdGl2ZU1heChzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlSW50ZXJzZWN0aW9uKGFycmF5cywgaXRlcmF0ZWUyLCBjb21wYXJhdG9yKSB7XG4gICAgICAgICAgdmFyIGluY2x1ZGVzMiA9IGNvbXBhcmF0b3IgPyBhcnJheUluY2x1ZGVzV2l0aCA6IGFycmF5SW5jbHVkZXMsIGxlbmd0aCA9IGFycmF5c1swXS5sZW5ndGgsIG90aExlbmd0aCA9IGFycmF5cy5sZW5ndGgsIG90aEluZGV4ID0gb3RoTGVuZ3RoLCBjYWNoZXMgPSBBcnJheTIob3RoTGVuZ3RoKSwgbWF4TGVuZ3RoID0gSW5maW5pdHksIHJlc3VsdDIgPSBbXTtcbiAgICAgICAgICB3aGlsZSAob3RoSW5kZXgtLSkge1xuICAgICAgICAgICAgdmFyIGFycmF5ID0gYXJyYXlzW290aEluZGV4XTtcbiAgICAgICAgICAgIGlmIChvdGhJbmRleCAmJiBpdGVyYXRlZTIpIHtcbiAgICAgICAgICAgICAgYXJyYXkgPSBhcnJheU1hcChhcnJheSwgYmFzZVVuYXJ5KGl0ZXJhdGVlMikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWF4TGVuZ3RoID0gbmF0aXZlTWluKGFycmF5Lmxlbmd0aCwgbWF4TGVuZ3RoKTtcbiAgICAgICAgICAgIGNhY2hlc1tvdGhJbmRleF0gPSAhY29tcGFyYXRvciAmJiAoaXRlcmF0ZWUyIHx8IGxlbmd0aCA+PSAxMjAgJiYgYXJyYXkubGVuZ3RoID49IDEyMCkgPyBuZXcgU2V0Q2FjaGUob3RoSW5kZXggJiYgYXJyYXkpIDogdW5kZWZpbmVkMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXJyYXkgPSBhcnJheXNbMF07XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIHNlZW4gPSBjYWNoZXNbMF07XG4gICAgICAgICAgb3V0ZXI6XG4gICAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiByZXN1bHQyLmxlbmd0aCA8IG1heExlbmd0aCkge1xuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sIGNvbXB1dGVkID0gaXRlcmF0ZWUyID8gaXRlcmF0ZWUyKHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICAgICAgICB2YWx1ZSA9IGNvbXBhcmF0b3IgfHwgdmFsdWUgIT09IDAgPyB2YWx1ZSA6IDA7XG4gICAgICAgICAgICAgIGlmICghKHNlZW4gPyBjYWNoZUhhcyhzZWVuLCBjb21wdXRlZCkgOiBpbmNsdWRlczIocmVzdWx0MiwgY29tcHV0ZWQsIGNvbXBhcmF0b3IpKSkge1xuICAgICAgICAgICAgICAgIG90aEluZGV4ID0gb3RoTGVuZ3RoO1xuICAgICAgICAgICAgICAgIHdoaWxlICgtLW90aEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY2FjaGUgPSBjYWNoZXNbb3RoSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgaWYgKCEoY2FjaGUgPyBjYWNoZUhhcyhjYWNoZSwgY29tcHV0ZWQpIDogaW5jbHVkZXMyKGFycmF5c1tvdGhJbmRleF0sIGNvbXB1dGVkLCBjb21wYXJhdG9yKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZWVuKSB7XG4gICAgICAgICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQyLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZUludmVydGVyKG9iamVjdCwgc2V0dGVyLCBpdGVyYXRlZTIsIGFjY3VtdWxhdG9yKSB7XG4gICAgICAgICAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdDIpIHtcbiAgICAgICAgICAgIHNldHRlcihhY2N1bXVsYXRvciwgaXRlcmF0ZWUyKHZhbHVlKSwga2V5LCBvYmplY3QyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZUludm9rZShvYmplY3QsIHBhdGgsIGFyZ3MpIHtcbiAgICAgICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgICAgICAgICBvYmplY3QgPSBwYXJlbnQob2JqZWN0LCBwYXRoKTtcbiAgICAgICAgICB2YXIgZnVuYyA9IG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogb2JqZWN0W3RvS2V5KGxhc3QocGF0aCkpXTtcbiAgICAgICAgICByZXR1cm4gZnVuYyA9PSBudWxsID8gdW5kZWZpbmVkMiA6IGFwcGx5KGZ1bmMsIG9iamVjdCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlSXNBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFycmF5QnVmZmVyVGFnO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VJc0RhdGUodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBkYXRlVGFnO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgICAgICAgICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAhaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBiYXNlSXNFcXVhbCwgc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gICAgICAgICAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLCBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLCBvYmpUYWcgPSBvYmpJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG9iamVjdCksIG90aFRhZyA9IG90aElzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob3RoZXIpO1xuICAgICAgICAgIG9ialRhZyA9IG9ialRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb2JqVGFnO1xuICAgICAgICAgIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuICAgICAgICAgIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcsIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZywgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcbiAgICAgICAgICBpZiAoaXNTYW1lVGFnICYmIGlzQnVmZmVyKG9iamVjdCkpIHtcbiAgICAgICAgICAgIGlmICghaXNCdWZmZXIob3RoZXIpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICAgICAgICAgIG9iaklzT2JqID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgICAgICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2soKSk7XG4gICAgICAgICAgICByZXR1cm4gb2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSA6IGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHKSkge1xuICAgICAgICAgICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBcIl9fd3JhcHBlZF9fXCIpLCBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBcIl9fd3JhcHBlZF9fXCIpO1xuICAgICAgICAgICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgICAgICAgICAgdmFyIG9ialVud3JhcHBlZCA9IG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LCBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG4gICAgICAgICAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjaygpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWlzU2FtZVRhZykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2soKSk7XG4gICAgICAgICAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlSXNNYXAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IG1hcFRhZztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhLCBjdXN0b21pemVyKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gbWF0Y2hEYXRhLmxlbmd0aCwgbGVuZ3RoID0gaW5kZXgsIG5vQ3VzdG9taXplciA9ICFjdXN0b21pemVyO1xuICAgICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuICFsZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9iamVjdCA9IE9iamVjdDIob2JqZWN0KTtcbiAgICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdID8gZGF0YVsxXSAhPT0gb2JqZWN0W2RhdGFbMF1dIDogIShkYXRhWzBdIGluIG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgICAgICAgICB2YXIga2V5ID0gZGF0YVswXSwgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSwgc3JjVmFsdWUgPSBkYXRhWzFdO1xuICAgICAgICAgICAgaWYgKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKSB7XG4gICAgICAgICAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkMiAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgc3RhY2sgPSBuZXcgU3RhY2soKTtcbiAgICAgICAgICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MiA9IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjayk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCEocmVzdWx0MiA9PT0gdW5kZWZpbmVkMiA/IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHLCBjdXN0b21pemVyLCBzdGFjaykgOiByZXN1bHQyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgICAgICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gICAgICAgICAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VJc1JlZ0V4cCh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHJlZ2V4cFRhZztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlSXNTZXQodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IHNldFRhZztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlSXRlcmF0ZWUodmFsdWUpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGlkZW50aXR5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0FycmF5KHZhbHVlKSA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKSA6IGJhc2VNYXRjaGVzKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgICAgICAgICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZXN1bHQyID0gW107XG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIE9iamVjdDIob2JqZWN0KSkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgICAgICAgICAgcmVzdWx0Mi5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VLZXlzSW4ob2JqZWN0KSB7XG4gICAgICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpc1Byb3RvID0gaXNQcm90b3R5cGUob2JqZWN0KSwgcmVzdWx0MiA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgIGlmICghKGtleSA9PSBcImNvbnN0cnVjdG9yXCIgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgICAgICAgICAgcmVzdWx0Mi5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VMdCh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUgPCBvdGhlcjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlTWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlMikge1xuICAgICAgICAgIHZhciBpbmRleCA9IC0xLCByZXN1bHQyID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheTIoY29sbGVjdGlvbi5sZW5ndGgpIDogW107XG4gICAgICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbjIpIHtcbiAgICAgICAgICAgIHJlc3VsdDJbKytpbmRleF0gPSBpdGVyYXRlZTIodmFsdWUsIGtleSwgY29sbGVjdGlvbjIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VNYXRjaGVzKHNvdXJjZSkge1xuICAgICAgICAgIHZhciBtYXRjaERhdGEgPSBnZXRNYXRjaERhdGEoc291cmNlKTtcbiAgICAgICAgICBpZiAobWF0Y2hEYXRhLmxlbmd0aCA9PSAxICYmIG1hdGNoRGF0YVswXVsyXSkge1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKG1hdGNoRGF0YVswXVswXSwgbWF0Y2hEYXRhWzBdWzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICAgICAgICAgIGlmIChpc0tleShwYXRoKSAmJiBpc1N0cmljdENvbXBhcmFibGUoc3JjVmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgICAgdmFyIG9ialZhbHVlID0gZ2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICAgICAgICByZXR1cm4gb2JqVmFsdWUgPT09IHVuZGVmaW5lZDIgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlID8gaGFzSW4ob2JqZWN0LCBwYXRoKSA6IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gICAgICAgICAgaWYgKG9iamVjdCA9PT0gc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGJhc2VGb3Ioc291cmNlLCBmdW5jdGlvbihzcmNWYWx1ZSwga2V5KSB7XG4gICAgICAgICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2soKSk7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3Qoc3JjVmFsdWUpKSB7XG4gICAgICAgICAgICAgIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIGJhc2VNZXJnZSwgY3VzdG9taXplciwgc3RhY2spO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIoc2FmZUdldChvYmplY3QsIGtleSksIHNyY1ZhbHVlLCBrZXkgKyBcIlwiLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spIDogdW5kZWZpbmVkMjtcbiAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQyKSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwga2V5c0luKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBtZXJnZUZ1bmMsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gICAgICAgICAgdmFyIG9ialZhbHVlID0gc2FmZUdldChvYmplY3QsIGtleSksIHNyY1ZhbHVlID0gc2FmZUdldChzb3VyY2UsIGtleSksIHN0YWNrZWQgPSBzdGFjay5nZXQoc3JjVmFsdWUpO1xuICAgICAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBzdGFja2VkKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXkgKyBcIlwiLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spIDogdW5kZWZpbmVkMjtcbiAgICAgICAgICB2YXIgaXNDb21tb24gPSBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkMjtcbiAgICAgICAgICBpZiAoaXNDb21tb24pIHtcbiAgICAgICAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkoc3JjVmFsdWUpLCBpc0J1ZmYgPSAhaXNBcnIgJiYgaXNCdWZmZXIoc3JjVmFsdWUpLCBpc1R5cGVkID0gIWlzQXJyICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHNyY1ZhbHVlKTtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgICAgICAgICBpZiAoaXNBcnIgfHwgaXNCdWZmIHx8IGlzVHlwZWQpIHtcbiAgICAgICAgICAgICAgaWYgKGlzQXJyYXkob2JqVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5TGlrZU9iamVjdChvYmpWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IGNvcHlBcnJheShvYmpWYWx1ZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNCdWZmKSB7XG4gICAgICAgICAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IGNsb25lQnVmZmVyKHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc1R5cGVkKSB7XG4gICAgICAgICAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IGNsb25lVHlwZWRBcnJheShzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBbXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHNyY1ZhbHVlKSB8fCBpc0FyZ3VtZW50cyhzcmNWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgICAgICAgICAgaWYgKGlzQXJndW1lbnRzKG9ialZhbHVlKSkge1xuICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gdG9QbGFpbk9iamVjdChvYmpWYWx1ZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWlzT2JqZWN0KG9ialZhbHVlKSB8fCBpc0Z1bmN0aW9uKG9ialZhbHVlKSkge1xuICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gaW5pdENsb25lT2JqZWN0KHNyY1ZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQ29tbW9uKSB7XG4gICAgICAgICAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIG1lcmdlRnVuYyhuZXdWYWx1ZSwgc3JjVmFsdWUsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgICAgICAgICBzdGFja1tcImRlbGV0ZVwiXShzcmNWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlTnRoKGFycmF5LCBuKSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuICs9IG4gPCAwID8gbGVuZ3RoIDogMDtcbiAgICAgICAgICByZXR1cm4gaXNJbmRleChuLCBsZW5ndGgpID8gYXJyYXlbbl0gOiB1bmRlZmluZWQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzKSB7XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGl0ZXJhdGVlcyA9IGFycmF5TWFwKGl0ZXJhdGVlcywgZnVuY3Rpb24oaXRlcmF0ZWUyKSB7XG4gICAgICAgICAgICAgIGlmIChpc0FycmF5KGl0ZXJhdGVlMikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlR2V0KHZhbHVlLCBpdGVyYXRlZTIubGVuZ3RoID09PSAxID8gaXRlcmF0ZWUyWzBdIDogaXRlcmF0ZWUyKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBpdGVyYXRlZTI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlcmF0ZWVzID0gW2lkZW50aXR5XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgICAgaXRlcmF0ZWVzID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBiYXNlVW5hcnkoZ2V0SXRlcmF0ZWUoKSkpO1xuICAgICAgICAgIHZhciByZXN1bHQyID0gYmFzZU1hcChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uMikge1xuICAgICAgICAgICAgdmFyIGNyaXRlcmlhID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBmdW5jdGlvbihpdGVyYXRlZTIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdGVlMih2YWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7IFwiY3JpdGVyaWFcIjogY3JpdGVyaWEsIFwiaW5kZXhcIjogKytpbmRleCwgXCJ2YWx1ZVwiOiB2YWx1ZSB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBiYXNlU29ydEJ5KHJlc3VsdDIsIGZ1bmN0aW9uKG9iamVjdCwgb3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlUGljayhvYmplY3QsIHBhdGhzKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VQaWNrQnkob2JqZWN0LCBwYXRocywgZnVuY3Rpb24odmFsdWUsIHBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBoYXNJbihvYmplY3QsIHBhdGgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VQaWNrQnkob2JqZWN0LCBwYXRocywgcHJlZGljYXRlKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCwgcmVzdWx0MiA9IHt9O1xuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgcGF0aCA9IHBhdGhzW2luZGV4XSwgdmFsdWUgPSBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBwYXRoKSkge1xuICAgICAgICAgICAgICBiYXNlU2V0KHJlc3VsdDIsIGNhc3RQYXRoKHBhdGgsIG9iamVjdCksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZVByb3BlcnR5RGVlcChwYXRoKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VQdWxsQWxsKGFycmF5LCB2YWx1ZXMyLCBpdGVyYXRlZTIsIGNvbXBhcmF0b3IpIHtcbiAgICAgICAgICB2YXIgaW5kZXhPZjIgPSBjb21wYXJhdG9yID8gYmFzZUluZGV4T2ZXaXRoIDogYmFzZUluZGV4T2YsIGluZGV4ID0gLTEsIGxlbmd0aCA9IHZhbHVlczIubGVuZ3RoLCBzZWVuID0gYXJyYXk7XG4gICAgICAgICAgaWYgKGFycmF5ID09PSB2YWx1ZXMyKSB7XG4gICAgICAgICAgICB2YWx1ZXMyID0gY29weUFycmF5KHZhbHVlczIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXRlcmF0ZWUyKSB7XG4gICAgICAgICAgICBzZWVuID0gYXJyYXlNYXAoYXJyYXksIGJhc2VVbmFyeShpdGVyYXRlZTIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBmcm9tSW5kZXggPSAwLCB2YWx1ZSA9IHZhbHVlczJbaW5kZXhdLCBjb21wdXRlZCA9IGl0ZXJhdGVlMiA/IGl0ZXJhdGVlMih2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgICAgIHdoaWxlICgoZnJvbUluZGV4ID0gaW5kZXhPZjIoc2VlbiwgY29tcHV0ZWQsIGZyb21JbmRleCwgY29tcGFyYXRvcikpID4gLTEpIHtcbiAgICAgICAgICAgICAgaWYgKHNlZW4gIT09IGFycmF5KSB7XG4gICAgICAgICAgICAgICAgc3BsaWNlLmNhbGwoc2VlbiwgZnJvbUluZGV4LCAxKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzcGxpY2UuY2FsbChhcnJheSwgZnJvbUluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VQdWxsQXQoYXJyYXksIGluZGV4ZXMpIHtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBpbmRleGVzLmxlbmd0aCA6IDAsIGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG4gICAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBpbmRleGVzW2xlbmd0aF07XG4gICAgICAgICAgICBpZiAobGVuZ3RoID09IGxhc3RJbmRleCB8fCBpbmRleCAhPT0gcHJldmlvdXMpIHtcbiAgICAgICAgICAgICAgdmFyIHByZXZpb3VzID0gaW5kZXg7XG4gICAgICAgICAgICAgIGlmIChpc0luZGV4KGluZGV4KSkge1xuICAgICAgICAgICAgICAgIHNwbGljZS5jYWxsKGFycmF5LCBpbmRleCwgMSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYmFzZVVuc2V0KGFycmF5LCBpbmRleCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VSYW5kb20obG93ZXIsIHVwcGVyKSB7XG4gICAgICAgICAgcmV0dXJuIGxvd2VyICsgbmF0aXZlRmxvb3IobmF0aXZlUmFuZG9tKCkgKiAodXBwZXIgLSBsb3dlciArIDEpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlUmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCwgZnJvbVJpZ2h0KSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IG5hdGl2ZU1heChuYXRpdmVDZWlsKChlbmQgLSBzdGFydCkgLyAoc3RlcCB8fCAxKSksIDApLCByZXN1bHQyID0gQXJyYXkyKGxlbmd0aCk7XG4gICAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgICByZXN1bHQyW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdID0gc3RhcnQ7XG4gICAgICAgICAgICBzdGFydCArPSBzdGVwO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlUmVwZWF0KHN0cmluZywgbikge1xuICAgICAgICAgIHZhciByZXN1bHQyID0gXCJcIjtcbiAgICAgICAgICBpZiAoIXN0cmluZyB8fCBuIDwgMSB8fCBuID4gTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChuICUgMikge1xuICAgICAgICAgICAgICByZXN1bHQyICs9IHN0cmluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG4gPSBuYXRpdmVGbG9vcihuIC8gMik7XG4gICAgICAgICAgICBpZiAobikge1xuICAgICAgICAgICAgICBzdHJpbmcgKz0gc3RyaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKG4pO1xuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gICAgICAgICAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eSksIGZ1bmMgKyBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlU2FtcGxlKGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gYXJyYXlTYW1wbGUodmFsdWVzKGNvbGxlY3Rpb24pKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlU2FtcGxlU2l6ZShjb2xsZWN0aW9uLCBuKSB7XG4gICAgICAgICAgdmFyIGFycmF5ID0gdmFsdWVzKGNvbGxlY3Rpb24pO1xuICAgICAgICAgIHJldHVybiBzaHVmZmxlU2VsZihhcnJheSwgYmFzZUNsYW1wKG4sIDAsIGFycmF5Lmxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcikge1xuICAgICAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IHBhdGgubGVuZ3RoLCBsYXN0SW5kZXggPSBsZW5ndGggLSAxLCBuZXN0ZWQgPSBvYmplY3Q7XG4gICAgICAgICAgd2hpbGUgKG5lc3RlZCAhPSBudWxsICYmICsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSksIG5ld1ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcIl9fcHJvdG9fX1wiIHx8IGtleSA9PT0gXCJjb25zdHJ1Y3RvclwiIHx8IGtleSA9PT0gXCJwcm90b3R5cGVcIikge1xuICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluZGV4ICE9IGxhc3RJbmRleCkge1xuICAgICAgICAgICAgICB2YXIgb2JqVmFsdWUgPSBuZXN0ZWRba2V5XTtcbiAgICAgICAgICAgICAgbmV3VmFsdWUgPSBjdXN0b21pemVyID8gY3VzdG9taXplcihvYmpWYWx1ZSwga2V5LCBuZXN0ZWQpIDogdW5kZWZpbmVkMjtcbiAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQyKSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBpc09iamVjdChvYmpWYWx1ZSkgPyBvYmpWYWx1ZSA6IGlzSW5kZXgocGF0aFtpbmRleCArIDFdKSA/IFtdIDoge307XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2lnblZhbHVlKG5lc3RlZCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICBuZXN0ZWQgPSBuZXN0ZWRba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmFzZVNldERhdGEgPSAhbWV0YU1hcCA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgZGF0YSkge1xuICAgICAgICAgIG1ldGFNYXAuc2V0KGZ1bmMsIGRhdGEpO1xuICAgICAgICAgIHJldHVybiBmdW5jO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgYmFzZVNldFRvU3RyaW5nID0gIWRlZmluZVByb3BlcnR5ID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBzdHJpbmcpIHtcbiAgICAgICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkoZnVuYywgXCJ0b1N0cmluZ1wiLCB7XG4gICAgICAgICAgICBcImNvbmZpZ3VyYWJsZVwiOiB0cnVlLFxuICAgICAgICAgICAgXCJlbnVtZXJhYmxlXCI6IGZhbHNlLFxuICAgICAgICAgICAgXCJ2YWx1ZVwiOiBjb25zdGFudChzdHJpbmcpLFxuICAgICAgICAgICAgXCJ3cml0YWJsZVwiOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VTaHVmZmxlKGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gc2h1ZmZsZVNlbGYodmFsdWVzKGNvbGxlY3Rpb24pKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSAtMSwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gLXN0YXJ0ID4gbGVuZ3RoID8gMCA6IGxlbmd0aCArIHN0YXJ0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbmQgPSBlbmQgPiBsZW5ndGggPyBsZW5ndGggOiBlbmQ7XG4gICAgICAgICAgaWYgKGVuZCA8IDApIHtcbiAgICAgICAgICAgIGVuZCArPSBsZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxlbmd0aCA9IHN0YXJ0ID4gZW5kID8gMCA6IGVuZCAtIHN0YXJ0ID4+PiAwO1xuICAgICAgICAgIHN0YXJ0ID4+Pj0gMDtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IEFycmF5MihsZW5ndGgpO1xuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQyW2luZGV4XSA9IGFycmF5W2luZGV4ICsgc3RhcnRdO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlU29tZShjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0MjtcbiAgICAgICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24yKSB7XG4gICAgICAgICAgICByZXN1bHQyID0gcHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbjIpO1xuICAgICAgICAgICAgcmV0dXJuICFyZXN1bHQyO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiAhIXJlc3VsdDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSwgcmV0SGlnaGVzdCkge1xuICAgICAgICAgIHZhciBsb3cgPSAwLCBoaWdoID0gYXJyYXkgPT0gbnVsbCA/IGxvdyA6IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIgJiYgdmFsdWUgPT09IHZhbHVlICYmIGhpZ2ggPD0gSEFMRl9NQVhfQVJSQVlfTEVOR1RIKSB7XG4gICAgICAgICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICAgICAgICB2YXIgbWlkID0gbG93ICsgaGlnaCA+Pj4gMSwgY29tcHV0ZWQgPSBhcnJheVttaWRdO1xuICAgICAgICAgICAgICBpZiAoY29tcHV0ZWQgIT09IG51bGwgJiYgIWlzU3ltYm9sKGNvbXB1dGVkKSAmJiAocmV0SGlnaGVzdCA/IGNvbXB1dGVkIDw9IHZhbHVlIDogY29tcHV0ZWQgPCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBoaWdoO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBpZGVudGl0eSwgcmV0SGlnaGVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBpdGVyYXRlZTIsIHJldEhpZ2hlc3QpIHtcbiAgICAgICAgICB2YXIgbG93ID0gMCwgaGlnaCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgICAgIGlmIChoaWdoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWUgPSBpdGVyYXRlZTIodmFsdWUpO1xuICAgICAgICAgIHZhciB2YWxJc05hTiA9IHZhbHVlICE9PSB2YWx1ZSwgdmFsSXNOdWxsID0gdmFsdWUgPT09IG51bGwsIHZhbElzU3ltYm9sID0gaXNTeW1ib2wodmFsdWUpLCB2YWxJc1VuZGVmaW5lZCA9IHZhbHVlID09PSB1bmRlZmluZWQyO1xuICAgICAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgICAgICB2YXIgbWlkID0gbmF0aXZlRmxvb3IoKGxvdyArIGhpZ2gpIC8gMiksIGNvbXB1dGVkID0gaXRlcmF0ZWUyKGFycmF5W21pZF0pLCBvdGhJc0RlZmluZWQgPSBjb21wdXRlZCAhPT0gdW5kZWZpbmVkMiwgb3RoSXNOdWxsID0gY29tcHV0ZWQgPT09IG51bGwsIG90aElzUmVmbGV4aXZlID0gY29tcHV0ZWQgPT09IGNvbXB1dGVkLCBvdGhJc1N5bWJvbCA9IGlzU3ltYm9sKGNvbXB1dGVkKTtcbiAgICAgICAgICAgIGlmICh2YWxJc05hTikge1xuICAgICAgICAgICAgICB2YXIgc2V0TG93ID0gcmV0SGlnaGVzdCB8fCBvdGhJc1JlZmxleGl2ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsSXNVbmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgc2V0TG93ID0gb3RoSXNSZWZsZXhpdmUgJiYgKHJldEhpZ2hlc3QgfHwgb3RoSXNEZWZpbmVkKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsSXNOdWxsKSB7XG4gICAgICAgICAgICAgIHNldExvdyA9IG90aElzUmVmbGV4aXZlICYmIG90aElzRGVmaW5lZCAmJiAocmV0SGlnaGVzdCB8fCAhb3RoSXNOdWxsKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsSXNTeW1ib2wpIHtcbiAgICAgICAgICAgICAgc2V0TG93ID0gb3RoSXNSZWZsZXhpdmUgJiYgb3RoSXNEZWZpbmVkICYmICFvdGhJc051bGwgJiYgKHJldEhpZ2hlc3QgfHwgIW90aElzU3ltYm9sKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3RoSXNOdWxsIHx8IG90aElzU3ltYm9sKSB7XG4gICAgICAgICAgICAgIHNldExvdyA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2V0TG93ID0gcmV0SGlnaGVzdCA/IGNvbXB1dGVkIDw9IHZhbHVlIDogY29tcHV0ZWQgPCB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZXRMb3cpIHtcbiAgICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuYXRpdmVNaW4oaGlnaCwgTUFYX0FSUkFZX0lOREVYKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlU29ydGVkVW5pcShhcnJheSwgaXRlcmF0ZWUyKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCwgcmVzSW5kZXggPSAwLCByZXN1bHQyID0gW107XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSwgY29tcHV0ZWQgPSBpdGVyYXRlZTIgPyBpdGVyYXRlZTIodmFsdWUpIDogdmFsdWU7XG4gICAgICAgICAgICBpZiAoIWluZGV4IHx8ICFlcShjb21wdXRlZCwgc2VlbikpIHtcbiAgICAgICAgICAgICAgdmFyIHNlZW4gPSBjb21wdXRlZDtcbiAgICAgICAgICAgICAgcmVzdWx0MltyZXNJbmRleCsrXSA9IHZhbHVlID09PSAwID8gMCA6IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlVG9OdW1iZXIodmFsdWUpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5BTjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICt2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyBcIlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6IFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZXN1bHQyID0gdmFsdWUgKyBcIlwiO1xuICAgICAgICAgIHJldHVybiByZXN1bHQyID09IFwiMFwiICYmIDEgLyB2YWx1ZSA9PSAtSU5GSU5JVFkgPyBcIi0wXCIgOiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VVbmlxKGFycmF5LCBpdGVyYXRlZTIsIGNvbXBhcmF0b3IpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSAtMSwgaW5jbHVkZXMyID0gYXJyYXlJbmNsdWRlcywgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLCBpc0NvbW1vbiA9IHRydWUsIHJlc3VsdDIgPSBbXSwgc2VlbiA9IHJlc3VsdDI7XG4gICAgICAgICAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICAgICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgICAgICBpbmNsdWRlczIgPSBhcnJheUluY2x1ZGVzV2l0aDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxlbmd0aCA+PSBMQVJHRV9BUlJBWV9TSVpFKSB7XG4gICAgICAgICAgICB2YXIgc2V0MiA9IGl0ZXJhdGVlMiA/IG51bGwgOiBjcmVhdGVTZXQoYXJyYXkpO1xuICAgICAgICAgICAgaWYgKHNldDIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNldFRvQXJyYXkoc2V0Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICAgICAgaW5jbHVkZXMyID0gY2FjaGVIYXM7XG4gICAgICAgICAgICBzZWVuID0gbmV3IFNldENhY2hlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlZW4gPSBpdGVyYXRlZTIgPyBbXSA6IHJlc3VsdDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dGVyOlxuICAgICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLCBjb21wdXRlZCA9IGl0ZXJhdGVlMiA/IGl0ZXJhdGVlMih2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgICAgICAgdmFsdWUgPSBjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwID8gdmFsdWUgOiAwO1xuICAgICAgICAgICAgICBpZiAoaXNDb21tb24gJiYgY29tcHV0ZWQgPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlZW5JbmRleCA9IHNlZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzZWVuSW5kZXgtLSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHNlZW5bc2VlbkluZGV4XSA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpdGVyYXRlZTIpIHtcbiAgICAgICAgICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdDIucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWluY2x1ZGVzMihzZWVuLCBjb21wdXRlZCwgY29tcGFyYXRvcikpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VlbiAhPT0gcmVzdWx0Mikge1xuICAgICAgICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0Mi5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VVbnNldChvYmplY3QsIHBhdGgpIHtcbiAgICAgICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgICAgICAgICBvYmplY3QgPSBwYXJlbnQob2JqZWN0LCBwYXRoKTtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgfHwgZGVsZXRlIG9iamVjdFt0b0tleShsYXN0KHBhdGgpKV07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZVVwZGF0ZShvYmplY3QsIHBhdGgsIHVwZGF0ZXIsIGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgICByZXR1cm4gYmFzZVNldChvYmplY3QsIHBhdGgsIHVwZGF0ZXIoYmFzZUdldChvYmplY3QsIHBhdGgpKSwgY3VzdG9taXplcik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZVdoaWxlKGFycmF5LCBwcmVkaWNhdGUsIGlzRHJvcCwgZnJvbVJpZ2h0KSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCwgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMTtcbiAgICAgICAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSAmJiBwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpc0Ryb3AgPyBiYXNlU2xpY2UoYXJyYXksIGZyb21SaWdodCA/IDAgOiBpbmRleCwgZnJvbVJpZ2h0ID8gaW5kZXggKyAxIDogbGVuZ3RoKSA6IGJhc2VTbGljZShhcnJheSwgZnJvbVJpZ2h0ID8gaW5kZXggKyAxIDogMCwgZnJvbVJpZ2h0ID8gbGVuZ3RoIDogaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VXcmFwcGVyVmFsdWUodmFsdWUsIGFjdGlvbnMpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IHZhbHVlO1xuICAgICAgICAgIGlmIChyZXN1bHQyIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSByZXN1bHQyLnZhbHVlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhcnJheVJlZHVjZShhY3Rpb25zLCBmdW5jdGlvbihyZXN1bHQzLCBhY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb24uZnVuYy5hcHBseShhY3Rpb24udGhpc0FyZywgYXJyYXlQdXNoKFtyZXN1bHQzXSwgYWN0aW9uLmFyZ3MpKTtcbiAgICAgICAgICB9LCByZXN1bHQyKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlWG9yKGFycmF5cywgaXRlcmF0ZWUyLCBjb21wYXJhdG9yKSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGFycmF5cy5sZW5ndGg7XG4gICAgICAgICAgaWYgKGxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlVW5pcShhcnJheXNbMF0pIDogW107XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpbmRleCA9IC0xLCByZXN1bHQyID0gQXJyYXkyKGxlbmd0aCk7XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBhcnJheSA9IGFycmF5c1tpbmRleF0sIG90aEluZGV4ID0gLTE7XG4gICAgICAgICAgICB3aGlsZSAoKytvdGhJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICBpZiAob3RoSW5kZXggIT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQyW2luZGV4XSA9IGJhc2VEaWZmZXJlbmNlKHJlc3VsdDJbaW5kZXhdIHx8IGFycmF5LCBhcnJheXNbb3RoSW5kZXhdLCBpdGVyYXRlZTIsIGNvbXBhcmF0b3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihyZXN1bHQyLCAxKSwgaXRlcmF0ZWUyLCBjb21wYXJhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlWmlwT2JqZWN0KHByb3BzLCB2YWx1ZXMyLCBhc3NpZ25GdW5jKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IHByb3BzLmxlbmd0aCwgdmFsc0xlbmd0aCA9IHZhbHVlczIubGVuZ3RoLCByZXN1bHQyID0ge307XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGluZGV4IDwgdmFsc0xlbmd0aCA/IHZhbHVlczJbaW5kZXhdIDogdW5kZWZpbmVkMjtcbiAgICAgICAgICAgIGFzc2lnbkZ1bmMocmVzdWx0MiwgcHJvcHNbaW5kZXhdLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNhc3RBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpID8gdmFsdWUgOiBbXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjYXN0RnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09IFwiZnVuY3Rpb25cIiA/IHZhbHVlIDogaWRlbnRpdHk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUsIG9iamVjdCkge1xuICAgICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhc3RSZXN0ID0gYmFzZVJlc3Q7XG4gICAgICAgIGZ1bmN0aW9uIGNhc3RTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICAgICAgZW5kID0gZW5kID09PSB1bmRlZmluZWQyID8gbGVuZ3RoIDogZW5kO1xuICAgICAgICAgIHJldHVybiAhc3RhcnQgJiYgZW5kID49IGxlbmd0aCA/IGFycmF5IDogYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2xlYXJUaW1lb3V0ID0gY3R4Q2xlYXJUaW1lb3V0IHx8IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgcmV0dXJuIHJvb3QuY2xlYXJUaW1lb3V0KGlkKTtcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcbiAgICAgICAgICBpZiAoaXNEZWVwKSB7XG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyLnNsaWNlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBsZW5ndGggPSBidWZmZXIubGVuZ3RoLCByZXN1bHQyID0gYWxsb2NVbnNhZmUgPyBhbGxvY1Vuc2FmZShsZW5ndGgpIDogbmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuICAgICAgICAgIGJ1ZmZlci5jb3B5KHJlc3VsdDIpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICBuZXcgVWludDhBcnJheTIocmVzdWx0Mikuc2V0KG5ldyBVaW50OEFycmF5MihhcnJheUJ1ZmZlcikpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNsb25lRGF0YVZpZXcoZGF0YVZpZXcsIGlzRGVlcCkge1xuICAgICAgICAgIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKGRhdGFWaWV3LmJ1ZmZlcikgOiBkYXRhVmlldy5idWZmZXI7XG4gICAgICAgICAgcmV0dXJuIG5ldyBkYXRhVmlldy5jb25zdHJ1Y3RvcihidWZmZXIsIGRhdGFWaWV3LmJ5dGVPZmZzZXQsIGRhdGFWaWV3LmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNsb25lUmVnRXhwKHJlZ2V4cCkge1xuICAgICAgICAgIHZhciByZXN1bHQyID0gbmV3IHJlZ2V4cC5jb25zdHJ1Y3RvcihyZWdleHAuc291cmNlLCByZUZsYWdzLmV4ZWMocmVnZXhwKSk7XG4gICAgICAgICAgcmVzdWx0Mi5sYXN0SW5kZXggPSByZWdleHAubGFzdEluZGV4O1xuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNsb25lU3ltYm9sKHN5bWJvbCkge1xuICAgICAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mID8gT2JqZWN0MihzeW1ib2xWYWx1ZU9mLmNhbGwoc3ltYm9sKSkgOiB7fTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjbG9uZVR5cGVkQXJyYXkodHlwZWRBcnJheSwgaXNEZWVwKSB7XG4gICAgICAgICAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIodHlwZWRBcnJheS5idWZmZXIpIDogdHlwZWRBcnJheS5idWZmZXI7XG4gICAgICAgICAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY29tcGFyZUFzY2VuZGluZyh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IG90aGVyKSB7XG4gICAgICAgICAgICB2YXIgdmFsSXNEZWZpbmVkID0gdmFsdWUgIT09IHVuZGVmaW5lZDIsIHZhbElzTnVsbCA9IHZhbHVlID09PSBudWxsLCB2YWxJc1JlZmxleGl2ZSA9IHZhbHVlID09PSB2YWx1ZSwgdmFsSXNTeW1ib2wgPSBpc1N5bWJvbCh2YWx1ZSk7XG4gICAgICAgICAgICB2YXIgb3RoSXNEZWZpbmVkID0gb3RoZXIgIT09IHVuZGVmaW5lZDIsIG90aElzTnVsbCA9IG90aGVyID09PSBudWxsLCBvdGhJc1JlZmxleGl2ZSA9IG90aGVyID09PSBvdGhlciwgb3RoSXNTeW1ib2wgPSBpc1N5bWJvbChvdGhlcik7XG4gICAgICAgICAgICBpZiAoIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wgJiYgIXZhbElzU3ltYm9sICYmIHZhbHVlID4gb3RoZXIgfHwgdmFsSXNTeW1ib2wgJiYgb3RoSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlICYmICFvdGhJc051bGwgJiYgIW90aElzU3ltYm9sIHx8IHZhbElzTnVsbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUgfHwgIXZhbElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSB8fCAhdmFsSXNSZWZsZXhpdmUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXZhbElzTnVsbCAmJiAhdmFsSXNTeW1ib2wgJiYgIW90aElzU3ltYm9sICYmIHZhbHVlIDwgb3RoZXIgfHwgb3RoSXNTeW1ib2wgJiYgdmFsSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlICYmICF2YWxJc051bGwgJiYgIXZhbElzU3ltYm9sIHx8IG90aElzTnVsbCAmJiB2YWxJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUgfHwgIW90aElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSB8fCAhb3RoSXNSZWZsZXhpdmUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIG9iakNyaXRlcmlhID0gb2JqZWN0LmNyaXRlcmlhLCBvdGhDcml0ZXJpYSA9IG90aGVyLmNyaXRlcmlhLCBsZW5ndGggPSBvYmpDcml0ZXJpYS5sZW5ndGgsIG9yZGVyc0xlbmd0aCA9IG9yZGVycy5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQyID0gY29tcGFyZUFzY2VuZGluZyhvYmpDcml0ZXJpYVtpbmRleF0sIG90aENyaXRlcmlhW2luZGV4XSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0Mikge1xuICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gb3JkZXJzTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIG9yZGVyID0gb3JkZXJzW2luZGV4XTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDIgKiAob3JkZXIgPT0gXCJkZXNjXCIgPyAtMSA6IDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb2JqZWN0LmluZGV4IC0gb3RoZXIuaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY29tcG9zZUFyZ3MoYXJncywgcGFydGlhbHMsIGhvbGRlcnMsIGlzQ3VycmllZCkge1xuICAgICAgICAgIHZhciBhcmdzSW5kZXggPSAtMSwgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoLCBob2xkZXJzTGVuZ3RoID0gaG9sZGVycy5sZW5ndGgsIGxlZnRJbmRleCA9IC0xLCBsZWZ0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLCByYW5nZUxlbmd0aCA9IG5hdGl2ZU1heChhcmdzTGVuZ3RoIC0gaG9sZGVyc0xlbmd0aCwgMCksIHJlc3VsdDIgPSBBcnJheTIobGVmdExlbmd0aCArIHJhbmdlTGVuZ3RoKSwgaXNVbmN1cnJpZWQgPSAhaXNDdXJyaWVkO1xuICAgICAgICAgIHdoaWxlICgrK2xlZnRJbmRleCA8IGxlZnRMZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdDJbbGVmdEluZGV4XSA9IHBhcnRpYWxzW2xlZnRJbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlICgrK2FyZ3NJbmRleCA8IGhvbGRlcnNMZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChpc1VuY3VycmllZCB8fCBhcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDJbaG9sZGVyc1thcmdzSW5kZXhdXSA9IGFyZ3NbYXJnc0luZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKHJhbmdlTGVuZ3RoLS0pIHtcbiAgICAgICAgICAgIHJlc3VsdDJbbGVmdEluZGV4KytdID0gYXJnc1thcmdzSW5kZXgrK107XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNvbXBvc2VBcmdzUmlnaHQoYXJncywgcGFydGlhbHMsIGhvbGRlcnMsIGlzQ3VycmllZCkge1xuICAgICAgICAgIHZhciBhcmdzSW5kZXggPSAtMSwgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoLCBob2xkZXJzSW5kZXggPSAtMSwgaG9sZGVyc0xlbmd0aCA9IGhvbGRlcnMubGVuZ3RoLCByaWdodEluZGV4ID0gLTEsIHJpZ2h0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLCByYW5nZUxlbmd0aCA9IG5hdGl2ZU1heChhcmdzTGVuZ3RoIC0gaG9sZGVyc0xlbmd0aCwgMCksIHJlc3VsdDIgPSBBcnJheTIocmFuZ2VMZW5ndGggKyByaWdodExlbmd0aCksIGlzVW5jdXJyaWVkID0gIWlzQ3VycmllZDtcbiAgICAgICAgICB3aGlsZSAoKythcmdzSW5kZXggPCByYW5nZUxlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0MlthcmdzSW5kZXhdID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gYXJnc0luZGV4O1xuICAgICAgICAgIHdoaWxlICgrK3JpZ2h0SW5kZXggPCByaWdodExlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0MltvZmZzZXQgKyByaWdodEluZGV4XSA9IHBhcnRpYWxzW3JpZ2h0SW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAoKytob2xkZXJzSW5kZXggPCBob2xkZXJzTGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaXNVbmN1cnJpZWQgfHwgYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xuICAgICAgICAgICAgICByZXN1bHQyW29mZnNldCArIGhvbGRlcnNbaG9sZGVyc0luZGV4XV0gPSBhcmdzW2FyZ3NJbmRleCsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSAtMSwgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgICAgICAgICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheTIobGVuZ3RoKSk7XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICAgICAgICAgIHZhciBpc05ldyA9ICFvYmplY3Q7XG4gICAgICAgICAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSkgOiB1bmRlZmluZWQyO1xuICAgICAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQyKSB7XG4gICAgICAgICAgICAgIG5ld1ZhbHVlID0gc291cmNlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNOZXcpIHtcbiAgICAgICAgICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNvcHlTeW1ib2xzKHNvdXJjZSwgb2JqZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzKHNvdXJjZSksIG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY29weVN5bWJvbHNJbihzb3VyY2UsIG9iamVjdCkge1xuICAgICAgICAgIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9sc0luKHNvdXJjZSksIG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlQWdncmVnYXRvcihzZXR0ZXIsIGluaXRpYWxpemVyKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlMikge1xuICAgICAgICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlBZ2dyZWdhdG9yIDogYmFzZUFnZ3JlZ2F0b3IsIGFjY3VtdWxhdG9yID0gaW5pdGlhbGl6ZXIgPyBpbml0aWFsaXplcigpIDoge307XG4gICAgICAgICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBzZXR0ZXIsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlMiwgMiksIGFjY3VtdWxhdG9yKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLCBjdXN0b21pemVyID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQyLCBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkMjtcbiAgICAgICAgICAgIGN1c3RvbWl6ZXIgPSBhc3NpZ25lci5sZW5ndGggPiAzICYmIHR5cGVvZiBjdXN0b21pemVyID09IFwiZnVuY3Rpb25cIiA/IChsZW5ndGgtLSwgY3VzdG9taXplcikgOiB1bmRlZmluZWQyO1xuICAgICAgICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoIDwgMyA/IHVuZGVmaW5lZDIgOiBjdXN0b21pemVyO1xuICAgICAgICAgICAgICBsZW5ndGggPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqZWN0ID0gT2JqZWN0MihvYmplY3QpO1xuICAgICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGluZGV4LCBjdXN0b21pemVyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVCYXNlRWFjaChlYWNoRnVuYywgZnJvbVJpZ2h0KSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlMikge1xuICAgICAgICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGgsIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTEsIGl0ZXJhYmxlID0gT2JqZWN0Mihjb2xsZWN0aW9uKTtcbiAgICAgICAgICAgIHdoaWxlIChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICBpZiAoaXRlcmF0ZWUyKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlMiwga2V5c0Z1bmMpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IC0xLCBpdGVyYWJsZSA9IE9iamVjdDIob2JqZWN0KSwgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLCBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdO1xuICAgICAgICAgICAgICBpZiAoaXRlcmF0ZWUyKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlQmluZChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnKSB7XG4gICAgICAgICAgdmFyIGlzQmluZCA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRywgQ3RvciA9IGNyZWF0ZUN0b3IoZnVuYyk7XG4gICAgICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgICAgIHZhciBmbiA9IHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlciA/IEN0b3IgOiBmdW5jO1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVDYXNlRmlyc3QobWV0aG9kTmFtZSkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICAgICAgICB2YXIgc3RyU3ltYm9scyA9IGhhc1VuaWNvZGUoc3RyaW5nKSA/IHN0cmluZ1RvQXJyYXkoc3RyaW5nKSA6IHVuZGVmaW5lZDI7XG4gICAgICAgICAgICB2YXIgY2hyID0gc3RyU3ltYm9scyA/IHN0clN5bWJvbHNbMF0gOiBzdHJpbmcuY2hhckF0KDApO1xuICAgICAgICAgICAgdmFyIHRyYWlsaW5nID0gc3RyU3ltYm9scyA/IGNhc3RTbGljZShzdHJTeW1ib2xzLCAxKS5qb2luKFwiXCIpIDogc3RyaW5nLnNsaWNlKDEpO1xuICAgICAgICAgICAgcmV0dXJuIGNoclttZXRob2ROYW1lXSgpICsgdHJhaWxpbmc7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVDb21wb3VuZGVyKGNhbGxiYWNrKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5UmVkdWNlKHdvcmRzKGRlYnVycihzdHJpbmcpLnJlcGxhY2UocmVBcG9zLCBcIlwiKSksIGNhbGxiYWNrLCBcIlwiKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUN0b3IoQ3Rvcikge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDdG9yKCk7XG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSk7XG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSk7XG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSwgYXJnc1s1XSk7XG4gICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSwgYXJnc1s1XSwgYXJnc1s2XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdGhpc0JpbmRpbmcgPSBiYXNlQ3JlYXRlKEN0b3IucHJvdG90eXBlKSwgcmVzdWx0MiA9IEN0b3IuYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdDIpID8gcmVzdWx0MiA6IHRoaXNCaW5kaW5nO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlQ3VycnkoZnVuYywgYml0bWFzaywgYXJpdHkpIHtcbiAgICAgICAgICB2YXIgQ3RvciA9IGNyZWF0ZUN0b3IoZnVuYyk7XG4gICAgICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkyKGxlbmd0aCksIGluZGV4ID0gbGVuZ3RoLCBwbGFjZWhvbGRlciA9IGdldEhvbGRlcih3cmFwcGVyKTtcbiAgICAgICAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgICAgICAgIGFyZ3NbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBob2xkZXJzID0gbGVuZ3RoIDwgMyAmJiBhcmdzWzBdICE9PSBwbGFjZWhvbGRlciAmJiBhcmdzW2xlbmd0aCAtIDFdICE9PSBwbGFjZWhvbGRlciA/IFtdIDogcmVwbGFjZUhvbGRlcnMoYXJncywgcGxhY2Vob2xkZXIpO1xuICAgICAgICAgICAgbGVuZ3RoIC09IGhvbGRlcnMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGxlbmd0aCA8IGFyaXR5KSB7XG4gICAgICAgICAgICAgIHJldHVybiBjcmVhdGVSZWN1cnJ5KFxuICAgICAgICAgICAgICAgIGZ1bmMsXG4gICAgICAgICAgICAgICAgYml0bWFzayxcbiAgICAgICAgICAgICAgICBjcmVhdGVIeWJyaWQsXG4gICAgICAgICAgICAgICAgd3JhcHBlci5wbGFjZWhvbGRlcixcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQyLFxuICAgICAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICAgICAgaG9sZGVycyxcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQyLFxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZDIsXG4gICAgICAgICAgICAgICAgYXJpdHkgLSBsZW5ndGhcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmbiA9IHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlciA/IEN0b3IgOiBmdW5jO1xuICAgICAgICAgICAgcmV0dXJuIGFwcGx5KGZuLCB0aGlzLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlRmluZChmaW5kSW5kZXhGdW5jKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gICAgICAgICAgICB2YXIgaXRlcmFibGUgPSBPYmplY3QyKGNvbGxlY3Rpb24pO1xuICAgICAgICAgICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgICAgICAgICB2YXIgaXRlcmF0ZWUyID0gZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKTtcbiAgICAgICAgICAgICAgY29sbGVjdGlvbiA9IGtleXMoY29sbGVjdGlvbik7XG4gICAgICAgICAgICAgIHByZWRpY2F0ZSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVyYXRlZTIoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBmaW5kSW5kZXhGdW5jKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZnJvbUluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiBpbmRleCA+IC0xID8gaXRlcmFibGVbaXRlcmF0ZWUyID8gY29sbGVjdGlvbltpbmRleF0gOiBpbmRleF0gOiB1bmRlZmluZWQyO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlRmxvdyhmcm9tUmlnaHQpIHtcbiAgICAgICAgICByZXR1cm4gZmxhdFJlc3QoZnVuY3Rpb24oZnVuY3MpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBmdW5jcy5sZW5ndGgsIGluZGV4ID0gbGVuZ3RoLCBwcmVyZXEgPSBMb2Rhc2hXcmFwcGVyLnByb3RvdHlwZS50aHJ1O1xuICAgICAgICAgICAgaWYgKGZyb21SaWdodCkge1xuICAgICAgICAgICAgICBmdW5jcy5yZXZlcnNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICAgICAgICB2YXIgZnVuYyA9IGZ1bmNzW2luZGV4XTtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmdW5jICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IyKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHByZXJlcSAmJiAhd3JhcHBlciAmJiBnZXRGdW5jTmFtZShmdW5jKSA9PSBcIndyYXBwZXJcIikge1xuICAgICAgICAgICAgICAgIHZhciB3cmFwcGVyID0gbmV3IExvZGFzaFdyYXBwZXIoW10sIHRydWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmRleCA9IHdyYXBwZXIgPyBpbmRleCA6IGxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGZ1bmMgPSBmdW5jc1tpbmRleF07XG4gICAgICAgICAgICAgIHZhciBmdW5jTmFtZSA9IGdldEZ1bmNOYW1lKGZ1bmMpLCBkYXRhID0gZnVuY05hbWUgPT0gXCJ3cmFwcGVyXCIgPyBnZXREYXRhKGZ1bmMpIDogdW5kZWZpbmVkMjtcbiAgICAgICAgICAgICAgaWYgKGRhdGEgJiYgaXNMYXppYWJsZShkYXRhWzBdKSAmJiBkYXRhWzFdID09IChXUkFQX0FSWV9GTEFHIHwgV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9QQVJUSUFMX0ZMQUcgfCBXUkFQX1JFQVJHX0ZMQUcpICYmICFkYXRhWzRdLmxlbmd0aCAmJiBkYXRhWzldID09IDEpIHtcbiAgICAgICAgICAgICAgICB3cmFwcGVyID0gd3JhcHBlcltnZXRGdW5jTmFtZShkYXRhWzBdKV0uYXBwbHkod3JhcHBlciwgZGF0YVszXSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgd3JhcHBlciA9IGZ1bmMubGVuZ3RoID09IDEgJiYgaXNMYXppYWJsZShmdW5jKSA/IHdyYXBwZXJbZnVuY05hbWVdKCkgOiB3cmFwcGVyLnRocnUoZnVuYyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsIHZhbHVlID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgaWYgKHdyYXBwZXIgJiYgYXJncy5sZW5ndGggPT0gMSAmJiBpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVyLnBsYW50KHZhbHVlKS52YWx1ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBpbmRleDIgPSAwLCByZXN1bHQyID0gbGVuZ3RoID8gZnVuY3NbaW5kZXgyXS5hcHBseSh0aGlzLCBhcmdzKSA6IHZhbHVlO1xuICAgICAgICAgICAgICB3aGlsZSAoKytpbmRleDIgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQyID0gZnVuY3NbaW5kZXgyXS5jYWxsKHRoaXMsIHJlc3VsdDIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVIeWJyaWQoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCwgYXJnUG9zLCBhcnkyLCBhcml0eSkge1xuICAgICAgICAgIHZhciBpc0FyeSA9IGJpdG1hc2sgJiBXUkFQX0FSWV9GTEFHLCBpc0JpbmQgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcsIGlzQmluZEtleSA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfS0VZX0ZMQUcsIGlzQ3VycmllZCA9IGJpdG1hc2sgJiAoV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9DVVJSWV9SSUdIVF9GTEFHKSwgaXNGbGlwID0gYml0bWFzayAmIFdSQVBfRkxJUF9GTEFHLCBDdG9yID0gaXNCaW5kS2V5ID8gdW5kZWZpbmVkMiA6IGNyZWF0ZUN0b3IoZnVuYyk7XG4gICAgICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkyKGxlbmd0aCksIGluZGV4ID0gbGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgICAgICAgYXJnc1tpbmRleF0gPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzQ3VycmllZCkge1xuICAgICAgICAgICAgICB2YXIgcGxhY2Vob2xkZXIgPSBnZXRIb2xkZXIod3JhcHBlciksIGhvbGRlcnNDb3VudCA9IGNvdW50SG9sZGVycyhhcmdzLCBwbGFjZWhvbGRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFydGlhbHMpIHtcbiAgICAgICAgICAgICAgYXJncyA9IGNvbXBvc2VBcmdzKGFyZ3MsIHBhcnRpYWxzLCBob2xkZXJzLCBpc0N1cnJpZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcnRpYWxzUmlnaHQpIHtcbiAgICAgICAgICAgICAgYXJncyA9IGNvbXBvc2VBcmdzUmlnaHQoYXJncywgcGFydGlhbHNSaWdodCwgaG9sZGVyc1JpZ2h0LCBpc0N1cnJpZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGVuZ3RoIC09IGhvbGRlcnNDb3VudDtcbiAgICAgICAgICAgIGlmIChpc0N1cnJpZWQgJiYgbGVuZ3RoIDwgYXJpdHkpIHtcbiAgICAgICAgICAgICAgdmFyIG5ld0hvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhhcmdzLCBwbGFjZWhvbGRlcik7XG4gICAgICAgICAgICAgIHJldHVybiBjcmVhdGVSZWN1cnJ5KFxuICAgICAgICAgICAgICAgIGZ1bmMsXG4gICAgICAgICAgICAgICAgYml0bWFzayxcbiAgICAgICAgICAgICAgICBjcmVhdGVIeWJyaWQsXG4gICAgICAgICAgICAgICAgd3JhcHBlci5wbGFjZWhvbGRlcixcbiAgICAgICAgICAgICAgICB0aGlzQXJnLFxuICAgICAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICAgICAgbmV3SG9sZGVycyxcbiAgICAgICAgICAgICAgICBhcmdQb3MsXG4gICAgICAgICAgICAgICAgYXJ5MixcbiAgICAgICAgICAgICAgICBhcml0eSAtIGxlbmd0aFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRoaXNCaW5kaW5nID0gaXNCaW5kID8gdGhpc0FyZyA6IHRoaXMsIGZuID0gaXNCaW5kS2V5ID8gdGhpc0JpbmRpbmdbZnVuY10gOiBmdW5jO1xuICAgICAgICAgICAgbGVuZ3RoID0gYXJncy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoYXJnUG9zKSB7XG4gICAgICAgICAgICAgIGFyZ3MgPSByZW9yZGVyKGFyZ3MsIGFyZ1Bvcyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzRmxpcCAmJiBsZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgIGFyZ3MucmV2ZXJzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzQXJ5ICYmIGFyeTIgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgYXJncy5sZW5ndGggPSBhcnkyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikge1xuICAgICAgICAgICAgICBmbiA9IEN0b3IgfHwgY3JlYXRlQ3Rvcihmbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVJbnZlcnRlcihzZXR0ZXIsIHRvSXRlcmF0ZWUpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZTIpIHtcbiAgICAgICAgICAgIHJldHVybiBiYXNlSW52ZXJ0ZXIob2JqZWN0LCBzZXR0ZXIsIHRvSXRlcmF0ZWUoaXRlcmF0ZWUyKSwge30pO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlTWF0aE9wZXJhdGlvbihvcGVyYXRvciwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDI7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZDIgJiYgb3RoZXIgPT09IHVuZGVmaW5lZDIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkMikge1xuICAgICAgICAgICAgICByZXN1bHQyID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3RoZXIgIT09IHVuZGVmaW5lZDIpIHtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdDIgPT09IHVuZGVmaW5lZDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBvdGhlciA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBiYXNlVG9TdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgICAgIG90aGVyID0gYmFzZVRvU3RyaW5nKG90aGVyKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGJhc2VUb051bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgb3RoZXIgPSBiYXNlVG9OdW1iZXIob3RoZXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBvcGVyYXRvcih2YWx1ZSwgb3RoZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVPdmVyKGFycmF5RnVuYykge1xuICAgICAgICAgIHJldHVybiBmbGF0UmVzdChmdW5jdGlvbihpdGVyYXRlZXMpIHtcbiAgICAgICAgICAgIGl0ZXJhdGVlcyA9IGFycmF5TWFwKGl0ZXJhdGVlcywgYmFzZVVuYXJ5KGdldEl0ZXJhdGVlKCkpKTtcbiAgICAgICAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgICAgICAgIHZhciB0aGlzQXJnID0gdGhpcztcbiAgICAgICAgICAgICAgcmV0dXJuIGFycmF5RnVuYyhpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcHBseShpdGVyYXRlZTIsIHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVBhZGRpbmcobGVuZ3RoLCBjaGFycykge1xuICAgICAgICAgIGNoYXJzID0gY2hhcnMgPT09IHVuZGVmaW5lZDIgPyBcIiBcIiA6IGJhc2VUb1N0cmluZyhjaGFycyk7XG4gICAgICAgICAgdmFyIGNoYXJzTGVuZ3RoID0gY2hhcnMubGVuZ3RoO1xuICAgICAgICAgIGlmIChjaGFyc0xlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFyc0xlbmd0aCA/IGJhc2VSZXBlYXQoY2hhcnMsIGxlbmd0aCkgOiBjaGFycztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJlc3VsdDIgPSBiYXNlUmVwZWF0KGNoYXJzLCBuYXRpdmVDZWlsKGxlbmd0aCAvIHN0cmluZ1NpemUoY2hhcnMpKSk7XG4gICAgICAgICAgcmV0dXJuIGhhc1VuaWNvZGUoY2hhcnMpID8gY2FzdFNsaWNlKHN0cmluZ1RvQXJyYXkocmVzdWx0MiksIDAsIGxlbmd0aCkuam9pbihcIlwiKSA6IHJlc3VsdDIuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVQYXJ0aWFsKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzKSB7XG4gICAgICAgICAgdmFyIGlzQmluZCA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRywgQ3RvciA9IGNyZWF0ZUN0b3IoZnVuYyk7XG4gICAgICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgICAgIHZhciBhcmdzSW5kZXggPSAtMSwgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsIGxlZnRJbmRleCA9IC0xLCBsZWZ0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLCBhcmdzID0gQXJyYXkyKGxlZnRMZW5ndGggKyBhcmdzTGVuZ3RoKSwgZm4gPSB0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIgPyBDdG9yIDogZnVuYztcbiAgICAgICAgICAgIHdoaWxlICgrK2xlZnRJbmRleCA8IGxlZnRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgYXJnc1tsZWZ0SW5kZXhdID0gcGFydGlhbHNbbGVmdEluZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChhcmdzTGVuZ3RoLS0pIHtcbiAgICAgICAgICAgICAgYXJnc1tsZWZ0SW5kZXgrK10gPSBhcmd1bWVudHNbKythcmdzSW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFwcGx5KGZuLCBpc0JpbmQgPyB0aGlzQXJnIDogdGhpcywgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVJhbmdlKGZyb21SaWdodCkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbihzdGFydCwgZW5kLCBzdGVwKSB7XG4gICAgICAgICAgICBpZiAoc3RlcCAmJiB0eXBlb2Ygc3RlcCAhPSBcIm51bWJlclwiICYmIGlzSXRlcmF0ZWVDYWxsKHN0YXJ0LCBlbmQsIHN0ZXApKSB7XG4gICAgICAgICAgICAgIGVuZCA9IHN0ZXAgPSB1bmRlZmluZWQyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnQgPSB0b0Zpbml0ZShzdGFydCk7XG4gICAgICAgICAgICBpZiAoZW5kID09PSB1bmRlZmluZWQyKSB7XG4gICAgICAgICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbmQgPSB0b0Zpbml0ZShlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RlcCA9IHN0ZXAgPT09IHVuZGVmaW5lZDIgPyBzdGFydCA8IGVuZCA/IDEgOiAtMSA6IHRvRmluaXRlKHN0ZXApO1xuICAgICAgICAgICAgcmV0dXJuIGJhc2VSYW5nZShzdGFydCwgZW5kLCBzdGVwLCBmcm9tUmlnaHQpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihvcGVyYXRvcikge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgICAgIGlmICghKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBvdGhlciA9PSBcInN0cmluZ1wiKSkge1xuICAgICAgICAgICAgICB2YWx1ZSA9IHRvTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgICAgb3RoZXIgPSB0b051bWJlcihvdGhlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3BlcmF0b3IodmFsdWUsIG90aGVyKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVJlY3VycnkoZnVuYywgYml0bWFzaywgd3JhcEZ1bmMsIHBsYWNlaG9sZGVyLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgYXJnUG9zLCBhcnkyLCBhcml0eSkge1xuICAgICAgICAgIHZhciBpc0N1cnJ5ID0gYml0bWFzayAmIFdSQVBfQ1VSUllfRkxBRywgbmV3SG9sZGVycyA9IGlzQ3VycnkgPyBob2xkZXJzIDogdW5kZWZpbmVkMiwgbmV3SG9sZGVyc1JpZ2h0ID0gaXNDdXJyeSA/IHVuZGVmaW5lZDIgOiBob2xkZXJzLCBuZXdQYXJ0aWFscyA9IGlzQ3VycnkgPyBwYXJ0aWFscyA6IHVuZGVmaW5lZDIsIG5ld1BhcnRpYWxzUmlnaHQgPSBpc0N1cnJ5ID8gdW5kZWZpbmVkMiA6IHBhcnRpYWxzO1xuICAgICAgICAgIGJpdG1hc2sgfD0gaXNDdXJyeSA/IFdSQVBfUEFSVElBTF9GTEFHIDogV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUc7XG4gICAgICAgICAgYml0bWFzayAmPSB+KGlzQ3VycnkgPyBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyA6IFdSQVBfUEFSVElBTF9GTEFHKTtcbiAgICAgICAgICBpZiAoIShiaXRtYXNrICYgV1JBUF9DVVJSWV9CT1VORF9GTEFHKSkge1xuICAgICAgICAgICAgYml0bWFzayAmPSB+KFdSQVBfQklORF9GTEFHIHwgV1JBUF9CSU5EX0tFWV9GTEFHKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG5ld0RhdGEgPSBbXG4gICAgICAgICAgICBmdW5jLFxuICAgICAgICAgICAgYml0bWFzayxcbiAgICAgICAgICAgIHRoaXNBcmcsXG4gICAgICAgICAgICBuZXdQYXJ0aWFscyxcbiAgICAgICAgICAgIG5ld0hvbGRlcnMsXG4gICAgICAgICAgICBuZXdQYXJ0aWFsc1JpZ2h0LFxuICAgICAgICAgICAgbmV3SG9sZGVyc1JpZ2h0LFxuICAgICAgICAgICAgYXJnUG9zLFxuICAgICAgICAgICAgYXJ5MixcbiAgICAgICAgICAgIGFyaXR5XG4gICAgICAgICAgXTtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IHdyYXBGdW5jLmFwcGx5KHVuZGVmaW5lZDIsIG5ld0RhdGEpO1xuICAgICAgICAgIGlmIChpc0xhemlhYmxlKGZ1bmMpKSB7XG4gICAgICAgICAgICBzZXREYXRhKHJlc3VsdDIsIG5ld0RhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQyLnBsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXI7XG4gICAgICAgICAgcmV0dXJuIHNldFdyYXBUb1N0cmluZyhyZXN1bHQyLCBmdW5jLCBiaXRtYXNrKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVSb3VuZChtZXRob2ROYW1lKSB7XG4gICAgICAgICAgdmFyIGZ1bmMgPSBNYXRoMlttZXRob2ROYW1lXTtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24obnVtYmVyLCBwcmVjaXNpb24pIHtcbiAgICAgICAgICAgIG51bWJlciA9IHRvTnVtYmVyKG51bWJlcik7XG4gICAgICAgICAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24gPT0gbnVsbCA/IDAgOiBuYXRpdmVNaW4odG9JbnRlZ2VyKHByZWNpc2lvbiksIDI5Mik7XG4gICAgICAgICAgICBpZiAocHJlY2lzaW9uICYmIG5hdGl2ZUlzRmluaXRlKG51bWJlcikpIHtcbiAgICAgICAgICAgICAgdmFyIHBhaXIgPSAodG9TdHJpbmcobnVtYmVyKSArIFwiZVwiKS5zcGxpdChcImVcIiksIHZhbHVlID0gZnVuYyhwYWlyWzBdICsgXCJlXCIgKyAoK3BhaXJbMV0gKyBwcmVjaXNpb24pKTtcbiAgICAgICAgICAgICAgcGFpciA9ICh0b1N0cmluZyh2YWx1ZSkgKyBcImVcIikuc3BsaXQoXCJlXCIpO1xuICAgICAgICAgICAgICByZXR1cm4gKyhwYWlyWzBdICsgXCJlXCIgKyAoK3BhaXJbMV0gLSBwcmVjaXNpb24pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmdW5jKG51bWJlcik7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3JlYXRlU2V0ID0gIShTZXQyICYmIDEgLyBzZXRUb0FycmF5KG5ldyBTZXQyKFssIC0wXSkpWzFdID09IElORklOSVRZKSA/IG5vb3AgOiBmdW5jdGlvbih2YWx1ZXMyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBTZXQyKHZhbHVlczIpO1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBjcmVhdGVUb1BhaXJzKGtleXNGdW5jKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgICAgdmFyIHRhZyA9IGdldFRhZyhvYmplY3QpO1xuICAgICAgICAgICAgaWYgKHRhZyA9PSBtYXBUYWcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG1hcFRvQXJyYXkob2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YWcgPT0gc2V0VGFnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZXRUb1BhaXJzKG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYmFzZVRvUGFpcnMob2JqZWN0LCBrZXlzRnVuYyhvYmplY3QpKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVdyYXAoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIGFyZ1BvcywgYXJ5MiwgYXJpdHkpIHtcbiAgICAgICAgICB2YXIgaXNCaW5kS2V5ID0gYml0bWFzayAmIFdSQVBfQklORF9LRVlfRkxBRztcbiAgICAgICAgICBpZiAoIWlzQmluZEtleSAmJiB0eXBlb2YgZnVuYyAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IyKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBsZW5ndGggPSBwYXJ0aWFscyA/IHBhcnRpYWxzLmxlbmd0aCA6IDA7XG4gICAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIGJpdG1hc2sgJj0gfihXUkFQX1BBUlRJQUxfRkxBRyB8IFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHKTtcbiAgICAgICAgICAgIHBhcnRpYWxzID0gaG9sZGVycyA9IHVuZGVmaW5lZDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFyeTIgPSBhcnkyID09PSB1bmRlZmluZWQyID8gYXJ5MiA6IG5hdGl2ZU1heCh0b0ludGVnZXIoYXJ5MiksIDApO1xuICAgICAgICAgIGFyaXR5ID0gYXJpdHkgPT09IHVuZGVmaW5lZDIgPyBhcml0eSA6IHRvSW50ZWdlcihhcml0eSk7XG4gICAgICAgICAgbGVuZ3RoIC09IGhvbGRlcnMgPyBob2xkZXJzLmxlbmd0aCA6IDA7XG4gICAgICAgICAgaWYgKGJpdG1hc2sgJiBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRykge1xuICAgICAgICAgICAgdmFyIHBhcnRpYWxzUmlnaHQgPSBwYXJ0aWFscywgaG9sZGVyc1JpZ2h0ID0gaG9sZGVycztcbiAgICAgICAgICAgIHBhcnRpYWxzID0gaG9sZGVycyA9IHVuZGVmaW5lZDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBkYXRhID0gaXNCaW5kS2V5ID8gdW5kZWZpbmVkMiA6IGdldERhdGEoZnVuYyk7XG4gICAgICAgICAgdmFyIG5ld0RhdGEgPSBbXG4gICAgICAgICAgICBmdW5jLFxuICAgICAgICAgICAgYml0bWFzayxcbiAgICAgICAgICAgIHRoaXNBcmcsXG4gICAgICAgICAgICBwYXJ0aWFscyxcbiAgICAgICAgICAgIGhvbGRlcnMsXG4gICAgICAgICAgICBwYXJ0aWFsc1JpZ2h0LFxuICAgICAgICAgICAgaG9sZGVyc1JpZ2h0LFxuICAgICAgICAgICAgYXJnUG9zLFxuICAgICAgICAgICAgYXJ5MixcbiAgICAgICAgICAgIGFyaXR5XG4gICAgICAgICAgXTtcbiAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgbWVyZ2VEYXRhKG5ld0RhdGEsIGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jID0gbmV3RGF0YVswXTtcbiAgICAgICAgICBiaXRtYXNrID0gbmV3RGF0YVsxXTtcbiAgICAgICAgICB0aGlzQXJnID0gbmV3RGF0YVsyXTtcbiAgICAgICAgICBwYXJ0aWFscyA9IG5ld0RhdGFbM107XG4gICAgICAgICAgaG9sZGVycyA9IG5ld0RhdGFbNF07XG4gICAgICAgICAgYXJpdHkgPSBuZXdEYXRhWzldID0gbmV3RGF0YVs5XSA9PT0gdW5kZWZpbmVkMiA/IGlzQmluZEtleSA/IDAgOiBmdW5jLmxlbmd0aCA6IG5hdGl2ZU1heChuZXdEYXRhWzldIC0gbGVuZ3RoLCAwKTtcbiAgICAgICAgICBpZiAoIWFyaXR5ICYmIGJpdG1hc2sgJiAoV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9DVVJSWV9SSUdIVF9GTEFHKSkge1xuICAgICAgICAgICAgYml0bWFzayAmPSB+KFdSQVBfQ1VSUllfRkxBRyB8IFdSQVBfQ1VSUllfUklHSFRfRkxBRyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghYml0bWFzayB8fCBiaXRtYXNrID09IFdSQVBfQklORF9GTEFHKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0MiA9IGNyZWF0ZUJpbmQoZnVuYywgYml0bWFzaywgdGhpc0FyZyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChiaXRtYXNrID09IFdSQVBfQ1VSUllfRkxBRyB8fCBiaXRtYXNrID09IFdSQVBfQ1VSUllfUklHSFRfRkxBRykge1xuICAgICAgICAgICAgcmVzdWx0MiA9IGNyZWF0ZUN1cnJ5KGZ1bmMsIGJpdG1hc2ssIGFyaXR5KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKChiaXRtYXNrID09IFdSQVBfUEFSVElBTF9GTEFHIHx8IGJpdG1hc2sgPT0gKFdSQVBfQklORF9GTEFHIHwgV1JBUF9QQVJUSUFMX0ZMQUcpKSAmJiAhaG9sZGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBjcmVhdGVQYXJ0aWFsKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MiA9IGNyZWF0ZUh5YnJpZC5hcHBseSh1bmRlZmluZWQyLCBuZXdEYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHNldHRlciA9IGRhdGEgPyBiYXNlU2V0RGF0YSA6IHNldERhdGE7XG4gICAgICAgICAgcmV0dXJuIHNldFdyYXBUb1N0cmluZyhzZXR0ZXIocmVzdWx0MiwgbmV3RGF0YSksIGZ1bmMsIGJpdG1hc2spO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGN1c3RvbURlZmF1bHRzQXNzaWduSW4ob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkMiB8fCBlcShvYmpWYWx1ZSwgb2JqZWN0UHJvdG9ba2V5XSkgJiYgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3JjVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvYmpWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjdXN0b21EZWZhdWx0c01lcmdlKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spIHtcbiAgICAgICAgICBpZiAoaXNPYmplY3Qob2JqVmFsdWUpICYmIGlzT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgICAgICAgICAgc3RhY2suc2V0KHNyY1ZhbHVlLCBvYmpWYWx1ZSk7XG4gICAgICAgICAgICBiYXNlTWVyZ2Uob2JqVmFsdWUsIHNyY1ZhbHVlLCB1bmRlZmluZWQyLCBjdXN0b21EZWZhdWx0c01lcmdlLCBzdGFjayk7XG4gICAgICAgICAgICBzdGFja1tcImRlbGV0ZVwiXShzcmNWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvYmpWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjdXN0b21PbWl0Q2xvbmUodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaXNQbGFpbk9iamVjdCh2YWx1ZSkgPyB1bmRlZmluZWQyIDogdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gICAgICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRywgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLCBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG4gICAgICAgICAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgYXJyU3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gICAgICAgICAgdmFyIG90aFN0YWNrZWQgPSBzdGFjay5nZXQob3RoZXIpO1xuICAgICAgICAgIGlmIChhcnJTdGFja2VkICYmIG90aFN0YWNrZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnJTdGFja2VkID09IG90aGVyICYmIG90aFN0YWNrZWQgPT0gYXJyYXk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpbmRleCA9IC0xLCByZXN1bHQyID0gdHJ1ZSwgc2VlbiA9IGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHID8gbmV3IFNldENhY2hlKCkgOiB1bmRlZmluZWQyO1xuICAgICAgICAgIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICAgICAgICAgIHN0YWNrLnNldChvdGhlciwgYXJyYXkpO1xuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgYXJyVmFsdWUgPSBhcnJheVtpbmRleF0sIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKSA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29tcGFyZWQgIT09IHVuZGVmaW5lZDIpIHtcbiAgICAgICAgICAgICAgaWYgKGNvbXBhcmVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0MiA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWVuKSB7XG4gICAgICAgICAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZTIsIG90aEluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjYWNoZUhhcyhzZWVuLCBvdGhJbmRleCkgJiYgKGFyclZhbHVlID09PSBvdGhWYWx1ZTIgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZTIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIShhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKSkge1xuICAgICAgICAgICAgICByZXN1bHQyID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzdGFja1tcImRlbGV0ZVwiXShhcnJheSk7XG4gICAgICAgICAgc3RhY2tbXCJkZWxldGVcIl0ob3RoZXIpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gICAgICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICAgICAgICAgIGlmIChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoIHx8IG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgICAgICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG4gICAgICAgICAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgICAgICAgICBpZiAob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCB8fCAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5MihvYmplY3QpLCBuZXcgVWludDhBcnJheTIob3RoZXIpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGNhc2UgYm9vbFRhZzpcbiAgICAgICAgICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgICAgICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgICAgICAgICByZXR1cm4gZXEoK29iamVjdCwgK290aGVyKTtcbiAgICAgICAgICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICAgICAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG4gICAgICAgICAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgICAgICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0ID09IG90aGVyICsgXCJcIjtcbiAgICAgICAgICAgIGNhc2UgbWFwVGFnOlxuICAgICAgICAgICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG4gICAgICAgICAgICBjYXNlIHNldFRhZzpcbiAgICAgICAgICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRztcbiAgICAgICAgICAgICAgY29udmVydCB8fCAoY29udmVydCA9IHNldFRvQXJyYXkpO1xuICAgICAgICAgICAgICBpZiAob2JqZWN0LnNpemUgIT0gb3RoZXIuc2l6ZSAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICAgICAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYml0bWFzayB8PSBDT01QQVJFX1VOT1JERVJFRF9GTEFHO1xuICAgICAgICAgICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQyID0gZXF1YWxBcnJheXMoY29udmVydChvYmplY3QpLCBjb252ZXJ0KG90aGVyKSwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICAgICAgICAgIHN0YWNrW1wiZGVsZXRlXCJdKG9iamVjdCk7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICAgICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICAgICAgICAgIGlmIChzeW1ib2xWYWx1ZU9mKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gICAgICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRywgb2JqUHJvcHMgPSBnZXRBbGxLZXlzKG9iamVjdCksIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCwgb3RoUHJvcHMgPSBnZXRBbGxLZXlzKG90aGVyKSwgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuICAgICAgICAgIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKCEoaXNQYXJ0aWFsID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgb2JqU3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgICAgIHZhciBvdGhTdGFja2VkID0gc3RhY2suZ2V0KG90aGVyKTtcbiAgICAgICAgICBpZiAob2JqU3RhY2tlZCAmJiBvdGhTdGFja2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqU3RhY2tlZCA9PSBvdGhlciAmJiBvdGhTdGFja2VkID09IG9iamVjdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJlc3VsdDIgPSB0cnVlO1xuICAgICAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgICAgICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG4gICAgICAgICAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAgICAgICAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgICAgICAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSwgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuICAgICAgICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsID8gY3VzdG9taXplcihvdGhWYWx1ZSwgb2JqVmFsdWUsIGtleSwgb3RoZXIsIG9iamVjdCwgc3RhY2spIDogY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUsIGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZDIgPyBvYmpWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIDogY29tcGFyZWQpKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gXCJjb25zdHJ1Y3RvclwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDIgJiYgIXNraXBDdG9yKSB7XG4gICAgICAgICAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3Rvciwgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJiAoXCJjb25zdHJ1Y3RvclwiIGluIG9iamVjdCAmJiBcImNvbnN0cnVjdG9yXCIgaW4gb3RoZXIpICYmICEodHlwZW9mIG9iakN0b3IgPT0gXCJmdW5jdGlvblwiICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmIHR5cGVvZiBvdGhDdG9yID09IFwiZnVuY3Rpb25cIiAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MiA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzdGFja1tcImRlbGV0ZVwiXShvYmplY3QpO1xuICAgICAgICAgIHN0YWNrW1wiZGVsZXRlXCJdKG90aGVyKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmbGF0UmVzdChmdW5jKSB7XG4gICAgICAgICAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHVuZGVmaW5lZDIsIGZsYXR0ZW4pLCBmdW5jICsgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0QWxsS2V5cyhvYmplY3QpIHtcbiAgICAgICAgICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRBbGxLZXlzSW4ob2JqZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0luLCBnZXRTeW1ib2xzSW4pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBnZXREYXRhID0gIW1ldGFNYXAgPyBub29wIDogZnVuY3Rpb24oZnVuYykge1xuICAgICAgICAgIHJldHVybiBtZXRhTWFwLmdldChmdW5jKTtcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gZ2V0RnVuY05hbWUoZnVuYykge1xuICAgICAgICAgIHZhciByZXN1bHQyID0gZnVuYy5uYW1lICsgXCJcIiwgYXJyYXkgPSByZWFsTmFtZXNbcmVzdWx0Ml0sIGxlbmd0aCA9IGhhc093blByb3BlcnR5LmNhbGwocmVhbE5hbWVzLCByZXN1bHQyKSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IGFycmF5W2xlbmd0aF0sIG90aGVyRnVuYyA9IGRhdGEuZnVuYztcbiAgICAgICAgICAgIGlmIChvdGhlckZ1bmMgPT0gbnVsbCB8fCBvdGhlckZ1bmMgPT0gZnVuYykge1xuICAgICAgICAgICAgICByZXR1cm4gZGF0YS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRIb2xkZXIoZnVuYykge1xuICAgICAgICAgIHZhciBvYmplY3QgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKGxvZGFzaCwgXCJwbGFjZWhvbGRlclwiKSA/IGxvZGFzaCA6IGZ1bmM7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdC5wbGFjZWhvbGRlcjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRJdGVyYXRlZSgpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IGxvZGFzaC5pdGVyYXRlZSB8fCBpdGVyYXRlZTtcbiAgICAgICAgICByZXN1bHQyID0gcmVzdWx0MiA9PT0gaXRlcmF0ZWUgPyBiYXNlSXRlcmF0ZWUgOiByZXN1bHQyO1xuICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gcmVzdWx0Mihhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSkgOiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldE1hcERhdGEobWFwMiwga2V5KSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSBtYXAyLl9fZGF0YV9fO1xuICAgICAgICAgIHJldHVybiBpc0tleWFibGUoa2V5KSA/IGRhdGFbdHlwZW9mIGtleSA9PSBcInN0cmluZ1wiID8gXCJzdHJpbmdcIiA6IFwiaGFzaFwiXSA6IGRhdGEubWFwO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IGtleXMob2JqZWN0KSwgbGVuZ3RoID0gcmVzdWx0Mi5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gcmVzdWx0MltsZW5ndGhdLCB2YWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgICAgICAgcmVzdWx0MltsZW5ndGhdID0gW2tleSwgdmFsdWUsIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSldO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gICAgICAgICAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLCB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDI7XG4gICAgICAgICAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJlc3VsdDIgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICAgICAgICBpZiAodW5tYXNrZWQpIHtcbiAgICAgICAgICAgIGlmIChpc093bikge1xuICAgICAgICAgICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZ2V0U3ltYm9scyA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIG9iamVjdCA9IE9iamVjdDIob2JqZWN0KTtcbiAgICAgICAgICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGdldFN5bWJvbHNJbiA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgICAgdmFyIHJlc3VsdDIgPSBbXTtcbiAgICAgICAgICB3aGlsZSAob2JqZWN0KSB7XG4gICAgICAgICAgICBhcnJheVB1c2gocmVzdWx0MiwgZ2V0U3ltYm9scyhvYmplY3QpKTtcbiAgICAgICAgICAgIG9iamVjdCA9IGdldFByb3RvdHlwZShvYmplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG4gICAgICAgIGlmIChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnIHx8IE1hcDIgJiYgZ2V0VGFnKG5ldyBNYXAyKCkpICE9IG1hcFRhZyB8fCBQcm9taXNlMiAmJiBnZXRUYWcoUHJvbWlzZTIucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnIHx8IFNldDIgJiYgZ2V0VGFnKG5ldyBTZXQyKCkpICE9IHNldFRhZyB8fCBXZWFrTWFwMiAmJiBnZXRUYWcobmV3IFdlYWtNYXAyKCkpICE9IHdlYWtNYXBUYWcpIHtcbiAgICAgICAgICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDIgPSBiYXNlR2V0VGFnKHZhbHVlKSwgQ3RvciA9IHJlc3VsdDIgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQyLCBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogXCJcIjtcbiAgICAgICAgICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICAgICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFWaWV3VGFnO1xuICAgICAgICAgICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBtYXBUYWc7XG4gICAgICAgICAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICAgICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzZXRUYWc7XG4gICAgICAgICAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzpcbiAgICAgICAgICAgICAgICAgIHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldFZpZXcoc3RhcnQsIGVuZCwgdHJhbnNmb3Jtcykge1xuICAgICAgICAgIHZhciBpbmRleCA9IC0xLCBsZW5ndGggPSB0cmFuc2Zvcm1zLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB0cmFuc2Zvcm1zW2luZGV4XSwgc2l6ZTIgPSBkYXRhLnNpemU7XG4gICAgICAgICAgICBzd2l0Y2ggKGRhdGEudHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFwiZHJvcFwiOlxuICAgICAgICAgICAgICAgIHN0YXJ0ICs9IHNpemUyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiZHJvcFJpZ2h0XCI6XG4gICAgICAgICAgICAgICAgZW5kIC09IHNpemUyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwidGFrZVwiOlxuICAgICAgICAgICAgICAgIGVuZCA9IG5hdGl2ZU1pbihlbmQsIHN0YXJ0ICsgc2l6ZTIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwidGFrZVJpZ2h0XCI6XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQsIGVuZCAtIHNpemUyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHsgXCJzdGFydFwiOiBzdGFydCwgXCJlbmRcIjogZW5kIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0V3JhcERldGFpbHMoc291cmNlKSB7XG4gICAgICAgICAgdmFyIG1hdGNoID0gc291cmNlLm1hdGNoKHJlV3JhcERldGFpbHMpO1xuICAgICAgICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdLnNwbGl0KHJlU3BsaXREZXRhaWxzKSA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gICAgICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IHBhdGgubGVuZ3RoLCByZXN1bHQyID0gZmFsc2U7XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgICAgICAgICBpZiAoIShyZXN1bHQyID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQyIHx8ICsraW5kZXggIT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSAmJiAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGluaXRDbG9uZUFycmF5KGFycmF5KSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCwgcmVzdWx0MiA9IG5ldyBhcnJheS5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuICAgICAgICAgIGlmIChsZW5ndGggJiYgdHlwZW9mIGFycmF5WzBdID09IFwic3RyaW5nXCIgJiYgaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgXCJpbmRleFwiKSkge1xuICAgICAgICAgICAgcmVzdWx0Mi5pbmRleCA9IGFycmF5LmluZGV4O1xuICAgICAgICAgICAgcmVzdWx0Mi5pbnB1dCA9IGFycmF5LmlucHV0O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgPT0gXCJmdW5jdGlvblwiICYmICFpc1Byb3RvdHlwZShvYmplY3QpID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSkgOiB7fTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpbml0Q2xvbmVCeVRhZyhvYmplY3QsIHRhZywgaXNEZWVwKSB7XG4gICAgICAgICAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gICAgICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICAgICAgICAgIHJldHVybiBjbG9uZUFycmF5QnVmZmVyKG9iamVjdCk7XG4gICAgICAgICAgICBjYXNlIGJvb2xUYWc6XG4gICAgICAgICAgICBjYXNlIGRhdGVUYWc6XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgQ3Rvcigrb2JqZWN0KTtcbiAgICAgICAgICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICAgICAgICAgIHJldHVybiBjbG9uZURhdGFWaWV3KG9iamVjdCwgaXNEZWVwKTtcbiAgICAgICAgICAgIGNhc2UgZmxvYXQzMlRhZzpcbiAgICAgICAgICAgIGNhc2UgZmxvYXQ2NFRhZzpcbiAgICAgICAgICAgIGNhc2UgaW50OFRhZzpcbiAgICAgICAgICAgIGNhc2UgaW50MTZUYWc6XG4gICAgICAgICAgICBjYXNlIGludDMyVGFnOlxuICAgICAgICAgICAgY2FzZSB1aW50OFRhZzpcbiAgICAgICAgICAgIGNhc2UgdWludDhDbGFtcGVkVGFnOlxuICAgICAgICAgICAgY2FzZSB1aW50MTZUYWc6XG4gICAgICAgICAgICBjYXNlIHVpbnQzMlRhZzpcbiAgICAgICAgICAgICAgcmV0dXJuIGNsb25lVHlwZWRBcnJheShvYmplY3QsIGlzRGVlcCk7XG4gICAgICAgICAgICBjYXNlIG1hcFRhZzpcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDdG9yKCk7XG4gICAgICAgICAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgICAgICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgICAgICAgICByZXR1cm4gbmV3IEN0b3Iob2JqZWN0KTtcbiAgICAgICAgICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgICAgICAgICAgICByZXR1cm4gY2xvbmVSZWdFeHAob2JqZWN0KTtcbiAgICAgICAgICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgICAgICAgICByZXR1cm4gbmV3IEN0b3IoKTtcbiAgICAgICAgICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgICAgICAgICByZXR1cm4gY2xvbmVTeW1ib2wob2JqZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaW5zZXJ0V3JhcERldGFpbHMoc291cmNlLCBkZXRhaWxzKSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGRldGFpbHMubGVuZ3RoO1xuICAgICAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gc291cmNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcbiAgICAgICAgICBkZXRhaWxzW2xhc3RJbmRleF0gPSAobGVuZ3RoID4gMSA/IFwiJiBcIiA6IFwiXCIpICsgZGV0YWlsc1tsYXN0SW5kZXhdO1xuICAgICAgICAgIGRldGFpbHMgPSBkZXRhaWxzLmpvaW4obGVuZ3RoID4gMiA/IFwiLCBcIiA6IFwiIFwiKTtcbiAgICAgICAgICByZXR1cm4gc291cmNlLnJlcGxhY2UocmVXcmFwQ29tbWVudCwgXCJ7XFxuLyogW3dyYXBwZWQgd2l0aCBcIiArIGRldGFpbHMgKyBcIl0gKi9cXG5cIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNGbGF0dGVuYWJsZSh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBpc0FycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkgfHwgISEoc3ByZWFkYWJsZVN5bWJvbCAmJiB2YWx1ZSAmJiB2YWx1ZVtzcHJlYWRhYmxlU3ltYm9sXSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICAgICAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICAgICAgICAgIHJldHVybiAhIWxlbmd0aCAmJiAodHlwZSA9PSBcIm51bWJlclwiIHx8IHR5cGUgIT0gXCJzeW1ib2xcIiAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkgJiYgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gICAgICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICAgICAgICAgIGlmICh0eXBlID09IFwibnVtYmVyXCIgPyBpc0FycmF5TGlrZShvYmplY3QpICYmIGlzSW5kZXgoaW5kZXgsIG9iamVjdC5sZW5ndGgpIDogdHlwZSA9PSBcInN0cmluZ1wiICYmIGluZGV4IGluIG9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGVxKG9iamVjdFtpbmRleF0sIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICAgICAgaWYgKHR5cGUgPT0gXCJudW1iZXJcIiB8fCB0eXBlID09IFwic3ltYm9sXCIgfHwgdHlwZSA9PSBcImJvb2xlYW5cIiB8fCB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHwgb2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0MihvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICAgICAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgICAgIHJldHVybiB0eXBlID09IFwic3RyaW5nXCIgfHwgdHlwZSA9PSBcIm51bWJlclwiIHx8IHR5cGUgPT0gXCJzeW1ib2xcIiB8fCB0eXBlID09IFwiYm9vbGVhblwiID8gdmFsdWUgIT09IFwiX19wcm90b19fXCIgOiB2YWx1ZSA9PT0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0xhemlhYmxlKGZ1bmMpIHtcbiAgICAgICAgICB2YXIgZnVuY05hbWUgPSBnZXRGdW5jTmFtZShmdW5jKSwgb3RoZXIgPSBsb2Rhc2hbZnVuY05hbWVdO1xuICAgICAgICAgIGlmICh0eXBlb2Ygb3RoZXIgIT0gXCJmdW5jdGlvblwiIHx8ICEoZnVuY05hbWUgaW4gTGF6eVdyYXBwZXIucHJvdG90eXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZnVuYyA9PT0gb3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZGF0YSA9IGdldERhdGEob3RoZXIpO1xuICAgICAgICAgIHJldHVybiAhIWRhdGEgJiYgZnVuYyA9PT0gZGF0YVswXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gICAgICAgICAgcmV0dXJuICEhbWFza1NyY0tleSAmJiBtYXNrU3JjS2V5IGluIGZ1bmM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlzTWFza2FibGUgPSBjb3JlSnNEYXRhID8gaXNGdW5jdGlvbiA6IHN0dWJGYWxzZTtcbiAgICAgICAgZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgICAgICAgICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLCBwcm90byA9IHR5cGVvZiBDdG9yID09IFwiZnVuY3Rpb25cIiAmJiBDdG9yLnByb3RvdHlwZSB8fCBvYmplY3RQcm90bztcbiAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgJiYgIWlzT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShrZXksIHNyY1ZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmplY3Rba2V5XSA9PT0gc3JjVmFsdWUgJiYgKHNyY1ZhbHVlICE9PSB1bmRlZmluZWQyIHx8IGtleSBpbiBPYmplY3QyKG9iamVjdCkpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdDIgPSBtZW1vaXplMihmdW5jLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICAgICAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBjYWNoZSA9IHJlc3VsdDIuY2FjaGU7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWVyZ2VEYXRhKGRhdGEsIHNvdXJjZSkge1xuICAgICAgICAgIHZhciBiaXRtYXNrID0gZGF0YVsxXSwgc3JjQml0bWFzayA9IHNvdXJjZVsxXSwgbmV3Qml0bWFzayA9IGJpdG1hc2sgfCBzcmNCaXRtYXNrLCBpc0NvbW1vbiA9IG5ld0JpdG1hc2sgPCAoV1JBUF9CSU5EX0ZMQUcgfCBXUkFQX0JJTkRfS0VZX0ZMQUcgfCBXUkFQX0FSWV9GTEFHKTtcbiAgICAgICAgICB2YXIgaXNDb21ibyA9IHNyY0JpdG1hc2sgPT0gV1JBUF9BUllfRkxBRyAmJiBiaXRtYXNrID09IFdSQVBfQ1VSUllfRkxBRyB8fCBzcmNCaXRtYXNrID09IFdSQVBfQVJZX0ZMQUcgJiYgYml0bWFzayA9PSBXUkFQX1JFQVJHX0ZMQUcgJiYgZGF0YVs3XS5sZW5ndGggPD0gc291cmNlWzhdIHx8IHNyY0JpdG1hc2sgPT0gKFdSQVBfQVJZX0ZMQUcgfCBXUkFQX1JFQVJHX0ZMQUcpICYmIHNvdXJjZVs3XS5sZW5ndGggPD0gc291cmNlWzhdICYmIGJpdG1hc2sgPT0gV1JBUF9DVVJSWV9GTEFHO1xuICAgICAgICAgIGlmICghKGlzQ29tbW9uIHx8IGlzQ29tYm8pKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNyY0JpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRykge1xuICAgICAgICAgICAgZGF0YVsyXSA9IHNvdXJjZVsyXTtcbiAgICAgICAgICAgIG5ld0JpdG1hc2sgfD0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHID8gMCA6IFdSQVBfQ1VSUllfQk9VTkRfRkxBRztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHZhbHVlID0gc291cmNlWzNdO1xuICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHBhcnRpYWxzID0gZGF0YVszXTtcbiAgICAgICAgICAgIGRhdGFbM10gPSBwYXJ0aWFscyA/IGNvbXBvc2VBcmdzKHBhcnRpYWxzLCB2YWx1ZSwgc291cmNlWzRdKSA6IHZhbHVlO1xuICAgICAgICAgICAgZGF0YVs0XSA9IHBhcnRpYWxzID8gcmVwbGFjZUhvbGRlcnMoZGF0YVszXSwgUExBQ0VIT0xERVIpIDogc291cmNlWzRdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZSA9IHNvdXJjZVs1XTtcbiAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHBhcnRpYWxzID0gZGF0YVs1XTtcbiAgICAgICAgICAgIGRhdGFbNV0gPSBwYXJ0aWFscyA/IGNvbXBvc2VBcmdzUmlnaHQocGFydGlhbHMsIHZhbHVlLCBzb3VyY2VbNl0pIDogdmFsdWU7XG4gICAgICAgICAgICBkYXRhWzZdID0gcGFydGlhbHMgPyByZXBsYWNlSG9sZGVycyhkYXRhWzVdLCBQTEFDRUhPTERFUikgOiBzb3VyY2VbNl07XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbHVlID0gc291cmNlWzddO1xuICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgZGF0YVs3XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3JjQml0bWFzayAmIFdSQVBfQVJZX0ZMQUcpIHtcbiAgICAgICAgICAgIGRhdGFbOF0gPSBkYXRhWzhdID09IG51bGwgPyBzb3VyY2VbOF0gOiBuYXRpdmVNaW4oZGF0YVs4XSwgc291cmNlWzhdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRhdGFbOV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgZGF0YVs5XSA9IHNvdXJjZVs5XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YVswXSA9IHNvdXJjZVswXTtcbiAgICAgICAgICBkYXRhWzFdID0gbmV3Qml0bWFzaztcbiAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gICAgICAgICAgdmFyIHJlc3VsdDIgPSBbXTtcbiAgICAgICAgICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBPYmplY3QyKG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgcmVzdWx0Mi5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCB0cmFuc2Zvcm0yKSB7XG4gICAgICAgICAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZDIgPyBmdW5jLmxlbmd0aCAtIDEgOiBzdGFydCwgMCk7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsIGluZGV4ID0gLTEsIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSwgYXJyYXkgPSBBcnJheTIobGVuZ3RoKTtcbiAgICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICAgICAgdmFyIG90aGVyQXJncyA9IEFycmF5MihzdGFydCArIDEpO1xuICAgICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgICAgICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdGhlckFyZ3Nbc3RhcnRdID0gdHJhbnNmb3JtMihhcnJheSk7XG4gICAgICAgICAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHBhcmVudChvYmplY3QsIHBhdGgpIHtcbiAgICAgICAgICByZXR1cm4gcGF0aC5sZW5ndGggPCAyID8gb2JqZWN0IDogYmFzZUdldChvYmplY3QsIGJhc2VTbGljZShwYXRoLCAwLCAtMSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlb3JkZXIoYXJyYXksIGluZGV4ZXMpIHtcbiAgICAgICAgICB2YXIgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLCBsZW5ndGggPSBuYXRpdmVNaW4oaW5kZXhlcy5sZW5ndGgsIGFyckxlbmd0aCksIG9sZEFycmF5ID0gY29weUFycmF5KGFycmF5KTtcbiAgICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGluZGV4ZXNbbGVuZ3RoXTtcbiAgICAgICAgICAgIGFycmF5W2xlbmd0aF0gPSBpc0luZGV4KGluZGV4LCBhcnJMZW5ndGgpID8gb2xkQXJyYXlbaW5kZXhdIDogdW5kZWZpbmVkMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNhZmVHZXQob2JqZWN0LCBrZXkpIHtcbiAgICAgICAgICBpZiAoa2V5ID09PSBcImNvbnN0cnVjdG9yXCIgJiYgdHlwZW9mIG9iamVjdFtrZXldID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGtleSA9PSBcIl9fcHJvdG9fX1wiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvYmplY3Rba2V5XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2V0RGF0YSA9IHNob3J0T3V0KGJhc2VTZXREYXRhKTtcbiAgICAgICAgdmFyIHNldFRpbWVvdXQgPSBjdHhTZXRUaW1lb3V0IHx8IGZ1bmN0aW9uKGZ1bmMsIHdhaXQpIHtcbiAgICAgICAgICByZXR1cm4gcm9vdC5zZXRUaW1lb3V0KGZ1bmMsIHdhaXQpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgc2V0VG9TdHJpbmcgPSBzaG9ydE91dChiYXNlU2V0VG9TdHJpbmcpO1xuICAgICAgICBmdW5jdGlvbiBzZXRXcmFwVG9TdHJpbmcod3JhcHBlciwgcmVmZXJlbmNlLCBiaXRtYXNrKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IHJlZmVyZW5jZSArIFwiXCI7XG4gICAgICAgICAgcmV0dXJuIHNldFRvU3RyaW5nKHdyYXBwZXIsIGluc2VydFdyYXBEZXRhaWxzKHNvdXJjZSwgdXBkYXRlV3JhcERldGFpbHMoZ2V0V3JhcERldGFpbHMoc291cmNlKSwgYml0bWFzaykpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzaG9ydE91dChmdW5jKSB7XG4gICAgICAgICAgdmFyIGNvdW50ID0gMCwgbGFzdENhbGxlZCA9IDA7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHN0YW1wID0gbmF0aXZlTm93KCksIHJlbWFpbmluZyA9IEhPVF9TUEFOIC0gKHN0YW1wIC0gbGFzdENhbGxlZCk7XG4gICAgICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICAgICAgICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgICAgICAgICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb3VudCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQyLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2h1ZmZsZVNlbGYoYXJyYXksIHNpemUyKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCwgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcbiAgICAgICAgICBzaXplMiA9IHNpemUyID09PSB1bmRlZmluZWQyID8gbGVuZ3RoIDogc2l6ZTI7XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBzaXplMikge1xuICAgICAgICAgICAgdmFyIHJhbmQgPSBiYXNlUmFuZG9tKGluZGV4LCBsYXN0SW5kZXgpLCB2YWx1ZSA9IGFycmF5W3JhbmRdO1xuICAgICAgICAgICAgYXJyYXlbcmFuZF0gPSBhcnJheVtpbmRleF07XG4gICAgICAgICAgICBhcnJheVtpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXJyYXkubGVuZ3RoID0gc2l6ZTI7XG4gICAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICAgIHZhciByZXN1bHQyID0gW107XG4gICAgICAgICAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KDApID09PSA0Nikge1xuICAgICAgICAgICAgcmVzdWx0Mi5wdXNoKFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG4gICAgICAgICAgICByZXN1bHQyLnB1c2gocXVvdGUgPyBzdWJTdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsIFwiJDFcIikgOiBudW1iZXIgfHwgbWF0Y2gpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZXN1bHQyID0gdmFsdWUgKyBcIlwiO1xuICAgICAgICAgIHJldHVybiByZXN1bHQyID09IFwiMFwiICYmIDEgLyB2YWx1ZSA9PSAtSU5GSU5JVFkgPyBcIi0wXCIgOiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgICAgICAgICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZnVuYyArIFwiXCI7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVdyYXBEZXRhaWxzKGRldGFpbHMsIGJpdG1hc2spIHtcbiAgICAgICAgICBhcnJheUVhY2god3JhcEZsYWdzLCBmdW5jdGlvbihwYWlyKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBcIl8uXCIgKyBwYWlyWzBdO1xuICAgICAgICAgICAgaWYgKGJpdG1hc2sgJiBwYWlyWzFdICYmICFhcnJheUluY2x1ZGVzKGRldGFpbHMsIHZhbHVlKSkge1xuICAgICAgICAgICAgICBkZXRhaWxzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBkZXRhaWxzLnNvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB3cmFwcGVyQ2xvbmUod3JhcHBlcikge1xuICAgICAgICAgIGlmICh3cmFwcGVyIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB3cmFwcGVyLmNsb25lKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZXN1bHQyID0gbmV3IExvZGFzaFdyYXBwZXIod3JhcHBlci5fX3dyYXBwZWRfXywgd3JhcHBlci5fX2NoYWluX18pO1xuICAgICAgICAgIHJlc3VsdDIuX19hY3Rpb25zX18gPSBjb3B5QXJyYXkod3JhcHBlci5fX2FjdGlvbnNfXyk7XG4gICAgICAgICAgcmVzdWx0Mi5fX2luZGV4X18gPSB3cmFwcGVyLl9faW5kZXhfXztcbiAgICAgICAgICByZXN1bHQyLl9fdmFsdWVzX18gPSB3cmFwcGVyLl9fdmFsdWVzX187XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2h1bmsoYXJyYXksIHNpemUyLCBndWFyZCkge1xuICAgICAgICAgIGlmIChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBzaXplMiwgZ3VhcmQpIDogc2l6ZTIgPT09IHVuZGVmaW5lZDIpIHtcbiAgICAgICAgICAgIHNpemUyID0gMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2l6ZTIgPSBuYXRpdmVNYXgodG9JbnRlZ2VyKHNpemUyKSwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICBpZiAoIWxlbmd0aCB8fCBzaXplMiA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGluZGV4ID0gMCwgcmVzSW5kZXggPSAwLCByZXN1bHQyID0gQXJyYXkyKG5hdGl2ZUNlaWwobGVuZ3RoIC8gc2l6ZTIpKTtcbiAgICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdDJbcmVzSW5kZXgrK10gPSBiYXNlU2xpY2UoYXJyYXksIGluZGV4LCBpbmRleCArPSBzaXplMik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNvbXBhY3QoYXJyYXkpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSAtMSwgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsIHJlc0luZGV4ID0gMCwgcmVzdWx0MiA9IFtdO1xuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MltyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjb25jYXQoKSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheTIobGVuZ3RoIC0gMSksIGFycmF5ID0gYXJndW1lbnRzWzBdLCBpbmRleCA9IGxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICAgICAgYXJnc1tpbmRleCAtIDFdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGFycmF5UHVzaChpc0FycmF5KGFycmF5KSA/IGNvcHlBcnJheShhcnJheSkgOiBbYXJyYXldLCBiYXNlRmxhdHRlbihhcmdzLCAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRpZmZlcmVuY2UgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheSwgdmFsdWVzMikge1xuICAgICAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdChhcnJheSkgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgYmFzZUZsYXR0ZW4odmFsdWVzMiwgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpKSA6IFtdO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGRpZmZlcmVuY2VCeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMyKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdGVlMiA9IGxhc3QodmFsdWVzMik7XG4gICAgICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGl0ZXJhdGVlMikpIHtcbiAgICAgICAgICAgIGl0ZXJhdGVlMiA9IHVuZGVmaW5lZDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdChhcnJheSkgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgYmFzZUZsYXR0ZW4odmFsdWVzMiwgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpLCBnZXRJdGVyYXRlZShpdGVyYXRlZTIsIDIpKSA6IFtdO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGRpZmZlcmVuY2VXaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXksIHZhbHVlczIpIHtcbiAgICAgICAgICB2YXIgY29tcGFyYXRvciA9IGxhc3QodmFsdWVzMik7XG4gICAgICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGNvbXBhcmF0b3IpKSB7XG4gICAgICAgICAgICBjb21wYXJhdG9yID0gdW5kZWZpbmVkMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KSA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCBiYXNlRmxhdHRlbih2YWx1ZXMyLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSksIHVuZGVmaW5lZDIsIGNvbXBhcmF0b3IpIDogW107XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiBkcm9wKGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuID0gZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkMiA/IDEgOiB0b0ludGVnZXIobik7XG4gICAgICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgbiA8IDAgPyAwIDogbiwgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkcm9wUmlnaHQoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIG4gPSBndWFyZCB8fCBuID09PSB1bmRlZmluZWQyID8gMSA6IHRvSW50ZWdlcihuKTtcbiAgICAgICAgICBuID0gbGVuZ3RoIC0gbjtcbiAgICAgICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCAwLCBuIDwgMCA/IDAgOiBuKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkcm9wUmlnaHRXaGlsZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5ICYmIGFycmF5Lmxlbmd0aCA/IGJhc2VXaGlsZShhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgdHJ1ZSwgdHJ1ZSkgOiBbXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkcm9wV2hpbGUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgICAgIHJldHVybiBhcnJheSAmJiBhcnJheS5sZW5ndGggPyBiYXNlV2hpbGUoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIHRydWUpIDogW107XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZmlsbChhcnJheSwgdmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXJ0ICYmIHR5cGVvZiBzdGFydCAhPSBcIm51bWJlclwiICYmIGlzSXRlcmF0ZWVDYWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQpKSB7XG4gICAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiYXNlRmlsbChhcnJheSwgdmFsdWUsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGluZGV4ID0gZnJvbUluZGV4ID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgaW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYmFzZUZpbmRJbmRleChhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZpbmRMYXN0SW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpbmRleCA9IGxlbmd0aCAtIDE7XG4gICAgICAgICAgaWYgKGZyb21JbmRleCAhPT0gdW5kZWZpbmVkMikge1xuICAgICAgICAgICAgaW5kZXggPSB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgICAgICAgICAgIGluZGV4ID0gZnJvbUluZGV4IDwgMCA/IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMCkgOiBuYXRpdmVNaW4oaW5kZXgsIGxlbmd0aCAtIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYmFzZUZpbmRJbmRleChhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgaW5kZXgsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXkpIHtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCAxKSA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZsYXR0ZW5EZWVwKGFycmF5KSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlRmxhdHRlbihhcnJheSwgSU5GSU5JVFkpIDogW107XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZmxhdHRlbkRlcHRoKGFycmF5LCBkZXB0aCkge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZXB0aCA9IGRlcHRoID09PSB1bmRlZmluZWQyID8gMSA6IHRvSW50ZWdlcihkZXB0aCk7XG4gICAgICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZnJvbVBhaXJzKHBhaXJzKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IHBhaXJzID09IG51bGwgPyAwIDogcGFpcnMubGVuZ3RoLCByZXN1bHQyID0ge307XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBwYWlyID0gcGFpcnNbaW5kZXhdO1xuICAgICAgICAgICAgcmVzdWx0MltwYWlyWzBdXSA9IHBhaXJbMV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGhlYWQoYXJyYXkpIHtcbiAgICAgICAgICByZXR1cm4gYXJyYXkgJiYgYXJyYXkubGVuZ3RoID8gYXJyYXlbMF0gOiB1bmRlZmluZWQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGluZGV4ID0gZnJvbUluZGV4ID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgaW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaW5pdGlhbChhcnJheSkge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZVNsaWNlKGFycmF5LCAwLCAtMSkgOiBbXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW50ZXJzZWN0aW9uID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICAgICAgdmFyIG1hcHBlZCA9IGFycmF5TWFwKGFycmF5cywgY2FzdEFycmF5TGlrZU9iamVjdCk7XG4gICAgICAgICAgcmV0dXJuIG1hcHBlZC5sZW5ndGggJiYgbWFwcGVkWzBdID09PSBhcnJheXNbMF0gPyBiYXNlSW50ZXJzZWN0aW9uKG1hcHBlZCkgOiBbXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBpbnRlcnNlY3Rpb25CeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgICAgIHZhciBpdGVyYXRlZTIgPSBsYXN0KGFycmF5cyksIG1hcHBlZCA9IGFycmF5TWFwKGFycmF5cywgY2FzdEFycmF5TGlrZU9iamVjdCk7XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlMiA9PT0gbGFzdChtYXBwZWQpKSB7XG4gICAgICAgICAgICBpdGVyYXRlZTIgPSB1bmRlZmluZWQyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXBwZWQucG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtYXBwZWQubGVuZ3RoICYmIG1hcHBlZFswXSA9PT0gYXJyYXlzWzBdID8gYmFzZUludGVyc2VjdGlvbihtYXBwZWQsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlMiwgMikpIDogW107XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgaW50ZXJzZWN0aW9uV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgICAgIHZhciBjb21wYXJhdG9yID0gbGFzdChhcnJheXMpLCBtYXBwZWQgPSBhcnJheU1hcChhcnJheXMsIGNhc3RBcnJheUxpa2VPYmplY3QpO1xuICAgICAgICAgIGNvbXBhcmF0b3IgPSB0eXBlb2YgY29tcGFyYXRvciA9PSBcImZ1bmN0aW9uXCIgPyBjb21wYXJhdG9yIDogdW5kZWZpbmVkMjtcbiAgICAgICAgICBpZiAoY29tcGFyYXRvcikge1xuICAgICAgICAgICAgbWFwcGVkLnBvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWFwcGVkLmxlbmd0aCAmJiBtYXBwZWRbMF0gPT09IGFycmF5c1swXSA/IGJhc2VJbnRlcnNlY3Rpb24obWFwcGVkLCB1bmRlZmluZWQyLCBjb21wYXJhdG9yKSA6IFtdO1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gam9pbihhcnJheSwgc2VwYXJhdG9yKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5ID09IG51bGwgPyBcIlwiIDogbmF0aXZlSm9pbi5jYWxsKGFycmF5LCBzZXBhcmF0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGxhc3QoYXJyYXkpIHtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIGxlbmd0aCA/IGFycmF5W2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkMjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsYXN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaW5kZXggPSBsZW5ndGg7XG4gICAgICAgICAgaWYgKGZyb21JbmRleCAhPT0gdW5kZWZpbmVkMikge1xuICAgICAgICAgICAgaW5kZXggPSB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgICAgICAgICAgIGluZGV4ID0gaW5kZXggPCAwID8gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKSA6IG5hdGl2ZU1pbihpbmRleCwgbGVuZ3RoIC0gMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPyBzdHJpY3RMYXN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGluZGV4KSA6IGJhc2VGaW5kSW5kZXgoYXJyYXksIGJhc2VJc05hTiwgaW5kZXgsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG50aChhcnJheSwgbikge1xuICAgICAgICAgIHJldHVybiBhcnJheSAmJiBhcnJheS5sZW5ndGggPyBiYXNlTnRoKGFycmF5LCB0b0ludGVnZXIobikpIDogdW5kZWZpbmVkMjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHVsbCA9IGJhc2VSZXN0KHB1bGxBbGwpO1xuICAgICAgICBmdW5jdGlvbiBwdWxsQWxsKGFycmF5LCB2YWx1ZXMyKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5ICYmIGFycmF5Lmxlbmd0aCAmJiB2YWx1ZXMyICYmIHZhbHVlczIubGVuZ3RoID8gYmFzZVB1bGxBbGwoYXJyYXksIHZhbHVlczIpIDogYXJyYXk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcHVsbEFsbEJ5KGFycmF5LCB2YWx1ZXMyLCBpdGVyYXRlZTIpIHtcbiAgICAgICAgICByZXR1cm4gYXJyYXkgJiYgYXJyYXkubGVuZ3RoICYmIHZhbHVlczIgJiYgdmFsdWVzMi5sZW5ndGggPyBiYXNlUHVsbEFsbChhcnJheSwgdmFsdWVzMiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUyLCAyKSkgOiBhcnJheTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBwdWxsQWxsV2l0aChhcnJheSwgdmFsdWVzMiwgY29tcGFyYXRvcikge1xuICAgICAgICAgIHJldHVybiBhcnJheSAmJiBhcnJheS5sZW5ndGggJiYgdmFsdWVzMiAmJiB2YWx1ZXMyLmxlbmd0aCA/IGJhc2VQdWxsQWxsKGFycmF5LCB2YWx1ZXMyLCB1bmRlZmluZWQyLCBjb21wYXJhdG9yKSA6IGFycmF5O1xuICAgICAgICB9XG4gICAgICAgIHZhciBwdWxsQXQgPSBmbGF0UmVzdChmdW5jdGlvbihhcnJheSwgaW5kZXhlcykge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCwgcmVzdWx0MiA9IGJhc2VBdChhcnJheSwgaW5kZXhlcyk7XG4gICAgICAgICAgYmFzZVB1bGxBdChhcnJheSwgYXJyYXlNYXAoaW5kZXhlcywgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0luZGV4KGluZGV4LCBsZW5ndGgpID8gK2luZGV4IDogaW5kZXg7XG4gICAgICAgICAgfSkuc29ydChjb21wYXJlQXNjZW5kaW5nKSk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiByZW1vdmUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgICAgIHZhciByZXN1bHQyID0gW107XG4gICAgICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpbmRleCA9IC0xLCBpbmRleGVzID0gW10sIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICBwcmVkaWNhdGUgPSBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpO1xuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgIGluZGV4ZXMucHVzaChpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJhc2VQdWxsQXQoYXJyYXksIGluZGV4ZXMpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJldmVyc2UoYXJyYXkpIHtcbiAgICAgICAgICByZXR1cm4gYXJyYXkgPT0gbnVsbCA/IGFycmF5IDogbmF0aXZlUmV2ZXJzZS5jYWxsKGFycmF5KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZW5kICYmIHR5cGVvZiBlbmQgIT0gXCJudW1iZXJcIiAmJiBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgc3RhcnQsIGVuZCkpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgICAgIGVuZCA9IGxlbmd0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhcnQgPSBzdGFydCA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihzdGFydCk7XG4gICAgICAgICAgICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZDIgPyBsZW5ndGggOiB0b0ludGVnZXIoZW5kKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc29ydGVkSW5kZXgoYXJyYXksIHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBpdGVyYXRlZTIpIHtcbiAgICAgICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBnZXRJdGVyYXRlZShpdGVyYXRlZTIsIDIpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzb3J0ZWRJbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA8IGxlbmd0aCAmJiBlcShhcnJheVtpbmRleF0sIHZhbHVlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzb3J0ZWRMYXN0SW5kZXgoYXJyYXksIHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNvcnRlZExhc3RJbmRleEJ5KGFycmF5LCB2YWx1ZSwgaXRlcmF0ZWUyKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleEJ5KGFycmF5LCB2YWx1ZSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUyLCAyKSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc29ydGVkTGFzdEluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUsIHRydWUpIC0gMTtcbiAgICAgICAgICAgIGlmIChlcShhcnJheVtpbmRleF0sIHZhbHVlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzb3J0ZWRVbmlxKGFycmF5KSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5ICYmIGFycmF5Lmxlbmd0aCA/IGJhc2VTb3J0ZWRVbmlxKGFycmF5KSA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNvcnRlZFVuaXFCeShhcnJheSwgaXRlcmF0ZWUyKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5ICYmIGFycmF5Lmxlbmd0aCA/IGJhc2VTb3J0ZWRVbmlxKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZTIsIDIpKSA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRhaWwoYXJyYXkpIHtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VTbGljZShhcnJheSwgMSwgbGVuZ3RoKSA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRha2UoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuID0gZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkMiA/IDEgOiB0b0ludGVnZXIobik7XG4gICAgICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgMCwgbiA8IDAgPyAwIDogbik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdGFrZVJpZ2h0KGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuID0gZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkMiA/IDEgOiB0b0ludGVnZXIobik7XG4gICAgICAgICAgbiA9IGxlbmd0aCAtIG47XG4gICAgICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgbiA8IDAgPyAwIDogbiwgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB0YWtlUmlnaHRXaGlsZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5ICYmIGFycmF5Lmxlbmd0aCA/IGJhc2VXaGlsZShhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgZmFsc2UsIHRydWUpIDogW107XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdGFrZVdoaWxlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgICAgICByZXR1cm4gYXJyYXkgJiYgYXJyYXkubGVuZ3RoID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKSA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1bmlvbiA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcnJheXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgdW5pb25CeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgICAgIHZhciBpdGVyYXRlZTIgPSBsYXN0KGFycmF5cyk7XG4gICAgICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGl0ZXJhdGVlMikpIHtcbiAgICAgICAgICAgIGl0ZXJhdGVlMiA9IHVuZGVmaW5lZDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcnJheXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUyLCAyKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgdW5pb25XaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICAgICAgdmFyIGNvbXBhcmF0b3IgPSBsYXN0KGFycmF5cyk7XG4gICAgICAgICAgY29tcGFyYXRvciA9IHR5cGVvZiBjb21wYXJhdG9yID09IFwiZnVuY3Rpb25cIiA/IGNvbXBhcmF0b3IgOiB1bmRlZmluZWQyO1xuICAgICAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcnJheXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSwgdW5kZWZpbmVkMiwgY29tcGFyYXRvcik7XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiB1bmlxKGFycmF5KSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5ICYmIGFycmF5Lmxlbmd0aCA/IGJhc2VVbmlxKGFycmF5KSA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHVuaXFCeShhcnJheSwgaXRlcmF0ZWUyKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5ICYmIGFycmF5Lmxlbmd0aCA/IGJhc2VVbmlxKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZTIsIDIpKSA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHVuaXFXaXRoKGFycmF5LCBjb21wYXJhdG9yKSB7XG4gICAgICAgICAgY29tcGFyYXRvciA9IHR5cGVvZiBjb21wYXJhdG9yID09IFwiZnVuY3Rpb25cIiA/IGNvbXBhcmF0b3IgOiB1bmRlZmluZWQyO1xuICAgICAgICAgIHJldHVybiBhcnJheSAmJiBhcnJheS5sZW5ndGggPyBiYXNlVW5pcShhcnJheSwgdW5kZWZpbmVkMiwgY29tcGFyYXRvcikgOiBbXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB1bnppcChhcnJheSkge1xuICAgICAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgICAgICAgYXJyYXkgPSBhcnJheUZpbHRlcihhcnJheSwgZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgICAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChncm91cCkpIHtcbiAgICAgICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGdyb3VwLmxlbmd0aCwgbGVuZ3RoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIGJhc2VUaW1lcyhsZW5ndGgsIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXlNYXAoYXJyYXksIGJhc2VQcm9wZXJ0eShpbmRleCkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHVuemlwV2l0aChhcnJheSwgaXRlcmF0ZWUyKSB7XG4gICAgICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IHVuemlwKGFycmF5KTtcbiAgICAgICAgICBpZiAoaXRlcmF0ZWUyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYXJyYXlNYXAocmVzdWx0MiwgZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgICAgICAgIHJldHVybiBhcHBseShpdGVyYXRlZTIsIHVuZGVmaW5lZDIsIGdyb3VwKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2l0aG91dCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMyKSB7XG4gICAgICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KSA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCB2YWx1ZXMyKSA6IFtdO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHhvciA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgICAgIHJldHVybiBiYXNlWG9yKGFycmF5RmlsdGVyKGFycmF5cywgaXNBcnJheUxpa2VPYmplY3QpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB4b3JCeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgICAgIHZhciBpdGVyYXRlZTIgPSBsYXN0KGFycmF5cyk7XG4gICAgICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGl0ZXJhdGVlMikpIHtcbiAgICAgICAgICAgIGl0ZXJhdGVlMiA9IHVuZGVmaW5lZDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiYXNlWG9yKGFycmF5RmlsdGVyKGFycmF5cywgaXNBcnJheUxpa2VPYmplY3QpLCBnZXRJdGVyYXRlZShpdGVyYXRlZTIsIDIpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB4b3JXaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICAgICAgdmFyIGNvbXBhcmF0b3IgPSBsYXN0KGFycmF5cyk7XG4gICAgICAgICAgY29tcGFyYXRvciA9IHR5cGVvZiBjb21wYXJhdG9yID09IFwiZnVuY3Rpb25cIiA/IGNvbXBhcmF0b3IgOiB1bmRlZmluZWQyO1xuICAgICAgICAgIHJldHVybiBiYXNlWG9yKGFycmF5RmlsdGVyKGFycmF5cywgaXNBcnJheUxpa2VPYmplY3QpLCB1bmRlZmluZWQyLCBjb21wYXJhdG9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB6aXAgPSBiYXNlUmVzdCh1bnppcCk7XG4gICAgICAgIGZ1bmN0aW9uIHppcE9iamVjdChwcm9wcywgdmFsdWVzMikge1xuICAgICAgICAgIHJldHVybiBiYXNlWmlwT2JqZWN0KHByb3BzIHx8IFtdLCB2YWx1ZXMyIHx8IFtdLCBhc3NpZ25WYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gemlwT2JqZWN0RGVlcChwcm9wcywgdmFsdWVzMikge1xuICAgICAgICAgIHJldHVybiBiYXNlWmlwT2JqZWN0KHByb3BzIHx8IFtdLCB2YWx1ZXMyIHx8IFtdLCBiYXNlU2V0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgemlwV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBhcnJheXMubGVuZ3RoLCBpdGVyYXRlZTIgPSBsZW5ndGggPiAxID8gYXJyYXlzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkMjtcbiAgICAgICAgICBpdGVyYXRlZTIgPSB0eXBlb2YgaXRlcmF0ZWUyID09IFwiZnVuY3Rpb25cIiA/IChhcnJheXMucG9wKCksIGl0ZXJhdGVlMikgOiB1bmRlZmluZWQyO1xuICAgICAgICAgIHJldHVybiB1bnppcFdpdGgoYXJyYXlzLCBpdGVyYXRlZTIpO1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gY2hhaW4odmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IGxvZGFzaCh2YWx1ZSk7XG4gICAgICAgICAgcmVzdWx0Mi5fX2NoYWluX18gPSB0cnVlO1xuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRhcCh2YWx1ZSwgaW50ZXJjZXB0b3IpIHtcbiAgICAgICAgICBpbnRlcmNlcHRvcih2YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRocnUodmFsdWUsIGludGVyY2VwdG9yKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyY2VwdG9yKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd3JhcHBlckF0ID0gZmxhdFJlc3QoZnVuY3Rpb24ocGF0aHMpIHtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gcGF0aHMubGVuZ3RoLCBzdGFydCA9IGxlbmd0aCA/IHBhdGhzWzBdIDogMCwgdmFsdWUgPSB0aGlzLl9fd3JhcHBlZF9fLCBpbnRlcmNlcHRvciA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGJhc2VBdChvYmplY3QsIHBhdGhzKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChsZW5ndGggPiAxIHx8IHRoaXMuX19hY3Rpb25zX18ubGVuZ3RoIHx8ICEodmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikgfHwgIWlzSW5kZXgoc3RhcnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50aHJ1KGludGVyY2VwdG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZShzdGFydCwgK3N0YXJ0ICsgKGxlbmd0aCA/IDEgOiAwKSk7XG4gICAgICAgICAgdmFsdWUuX19hY3Rpb25zX18ucHVzaCh7XG4gICAgICAgICAgICBcImZ1bmNcIjogdGhydSxcbiAgICAgICAgICAgIFwiYXJnc1wiOiBbaW50ZXJjZXB0b3JdLFxuICAgICAgICAgICAgXCJ0aGlzQXJnXCI6IHVuZGVmaW5lZDJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIodmFsdWUsIHRoaXMuX19jaGFpbl9fKS50aHJ1KGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICAgICAgICBpZiAobGVuZ3RoICYmICFhcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgYXJyYXkucHVzaCh1bmRlZmluZWQyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZ1bmN0aW9uIHdyYXBwZXJDaGFpbigpIHtcbiAgICAgICAgICByZXR1cm4gY2hhaW4odGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gd3JhcHBlckNvbW1pdCgpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIodGhpcy52YWx1ZSgpLCB0aGlzLl9fY2hhaW5fXyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gd3JhcHBlck5leHQoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX192YWx1ZXNfXyA9PT0gdW5kZWZpbmVkMikge1xuICAgICAgICAgICAgdGhpcy5fX3ZhbHVlc19fID0gdG9BcnJheSh0aGlzLnZhbHVlKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZG9uZSA9IHRoaXMuX19pbmRleF9fID49IHRoaXMuX192YWx1ZXNfXy5sZW5ndGgsIHZhbHVlID0gZG9uZSA/IHVuZGVmaW5lZDIgOiB0aGlzLl9fdmFsdWVzX19bdGhpcy5fX2luZGV4X18rK107XG4gICAgICAgICAgcmV0dXJuIHsgXCJkb25lXCI6IGRvbmUsIFwidmFsdWVcIjogdmFsdWUgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB3cmFwcGVyVG9JdGVyYXRvcigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB3cmFwcGVyUGxhbnQodmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0MiwgcGFyZW50MiA9IHRoaXM7XG4gICAgICAgICAgd2hpbGUgKHBhcmVudDIgaW5zdGFuY2VvZiBiYXNlTG9kYXNoKSB7XG4gICAgICAgICAgICB2YXIgY2xvbmUyID0gd3JhcHBlckNsb25lKHBhcmVudDIpO1xuICAgICAgICAgICAgY2xvbmUyLl9faW5kZXhfXyA9IDA7XG4gICAgICAgICAgICBjbG9uZTIuX192YWx1ZXNfXyA9IHVuZGVmaW5lZDI7XG4gICAgICAgICAgICBpZiAocmVzdWx0Mikge1xuICAgICAgICAgICAgICBwcmV2aW91cy5fX3dyYXBwZWRfXyA9IGNsb25lMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBjbG9uZTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJldmlvdXMgPSBjbG9uZTI7XG4gICAgICAgICAgICBwYXJlbnQyID0gcGFyZW50Mi5fX3dyYXBwZWRfXztcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJldmlvdXMuX193cmFwcGVkX18gPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB3cmFwcGVyUmV2ZXJzZSgpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9fd3JhcHBlZF9fO1xuICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB7XG4gICAgICAgICAgICB2YXIgd3JhcHBlZCA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX19hY3Rpb25zX18ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHdyYXBwZWQgPSBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cmFwcGVkID0gd3JhcHBlZC5yZXZlcnNlKCk7XG4gICAgICAgICAgICB3cmFwcGVkLl9fYWN0aW9uc19fLnB1c2goe1xuICAgICAgICAgICAgICBcImZ1bmNcIjogdGhydSxcbiAgICAgICAgICAgICAgXCJhcmdzXCI6IFtyZXZlcnNlXSxcbiAgICAgICAgICAgICAgXCJ0aGlzQXJnXCI6IHVuZGVmaW5lZDJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHdyYXBwZWQsIHRoaXMuX19jaGFpbl9fKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMudGhydShyZXZlcnNlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB3cmFwcGVyVmFsdWUoKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VXcmFwcGVyVmFsdWUodGhpcy5fX3dyYXBwZWRfXywgdGhpcy5fX2FjdGlvbnNfXyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvdW50QnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdDIsIHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQyLCBrZXkpKSB7XG4gICAgICAgICAgICArK3Jlc3VsdDJba2V5XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdDIsIGtleSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gZXZlcnkoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBndWFyZCkge1xuICAgICAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RXZlcnkgOiBiYXNlRXZlcnk7XG4gICAgICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpKSB7XG4gICAgICAgICAgICBwcmVkaWNhdGUgPSB1bmRlZmluZWQyO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlGaWx0ZXIgOiBiYXNlRmlsdGVyO1xuICAgICAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmaW5kID0gY3JlYXRlRmluZChmaW5kSW5kZXgpO1xuICAgICAgICB2YXIgZmluZExhc3QgPSBjcmVhdGVGaW5kKGZpbmRMYXN0SW5kZXgpO1xuICAgICAgICBmdW5jdGlvbiBmbGF0TWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlMikge1xuICAgICAgICAgIHJldHVybiBiYXNlRmxhdHRlbihtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUyKSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZmxhdE1hcERlZXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUyKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZTIpLCBJTkZJTklUWSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZmxhdE1hcERlcHRoKGNvbGxlY3Rpb24sIGl0ZXJhdGVlMiwgZGVwdGgpIHtcbiAgICAgICAgICBkZXB0aCA9IGRlcHRoID09PSB1bmRlZmluZWQyID8gMSA6IHRvSW50ZWdlcihkZXB0aCk7XG4gICAgICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZTIpLCBkZXB0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZm9yRWFjaChjb2xsZWN0aW9uLCBpdGVyYXRlZTIpIHtcbiAgICAgICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUVhY2ggOiBiYXNlRWFjaDtcbiAgICAgICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZTIsIDMpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmb3JFYWNoUmlnaHQoY29sbGVjdGlvbiwgaXRlcmF0ZWUyKSB7XG4gICAgICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlFYWNoUmlnaHQgOiBiYXNlRWFjaFJpZ2h0O1xuICAgICAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlMiwgMykpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBncm91cEJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQyLCB2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0Miwga2V5KSkge1xuICAgICAgICAgICAgcmVzdWx0MltrZXldLnB1c2godmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0Miwga2V5LCBbdmFsdWVdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiBpbmNsdWRlcyhjb2xsZWN0aW9uLCB2YWx1ZSwgZnJvbUluZGV4LCBndWFyZCkge1xuICAgICAgICAgIGNvbGxlY3Rpb24gPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IGNvbGxlY3Rpb24gOiB2YWx1ZXMoY29sbGVjdGlvbik7XG4gICAgICAgICAgZnJvbUluZGV4ID0gZnJvbUluZGV4ICYmICFndWFyZCA/IHRvSW50ZWdlcihmcm9tSW5kZXgpIDogMDtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG4gICAgICAgICAgaWYgKGZyb21JbmRleCA8IDApIHtcbiAgICAgICAgICAgIGZyb21JbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBmcm9tSW5kZXgsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaXNTdHJpbmcoY29sbGVjdGlvbikgPyBmcm9tSW5kZXggPD0gbGVuZ3RoICYmIGNvbGxlY3Rpb24uaW5kZXhPZih2YWx1ZSwgZnJvbUluZGV4KSA+IC0xIDogISFsZW5ndGggJiYgYmFzZUluZGV4T2YoY29sbGVjdGlvbiwgdmFsdWUsIGZyb21JbmRleCkgPiAtMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW52b2tlTWFwID0gYmFzZVJlc3QoZnVuY3Rpb24oY29sbGVjdGlvbiwgcGF0aCwgYXJncykge1xuICAgICAgICAgIHZhciBpbmRleCA9IC0xLCBpc0Z1bmMgPSB0eXBlb2YgcGF0aCA9PSBcImZ1bmN0aW9uXCIsIHJlc3VsdDIgPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IEFycmF5Mihjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcbiAgICAgICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmVzdWx0MlsrK2luZGV4XSA9IGlzRnVuYyA/IGFwcGx5KHBhdGgsIHZhbHVlLCBhcmdzKSA6IGJhc2VJbnZva2UodmFsdWUsIHBhdGgsIGFyZ3MpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGtleUJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQyLCB2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdDIsIGtleSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gbWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlMikge1xuICAgICAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5TWFwIDogYmFzZU1hcDtcbiAgICAgICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZTIsIDMpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzLCBndWFyZCkge1xuICAgICAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpc0FycmF5KGl0ZXJhdGVlcykpIHtcbiAgICAgICAgICAgIGl0ZXJhdGVlcyA9IGl0ZXJhdGVlcyA9PSBudWxsID8gW10gOiBbaXRlcmF0ZWVzXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3JkZXJzID0gZ3VhcmQgPyB1bmRlZmluZWQyIDogb3JkZXJzO1xuICAgICAgICAgIGlmICghaXNBcnJheShvcmRlcnMpKSB7XG4gICAgICAgICAgICBvcmRlcnMgPSBvcmRlcnMgPT0gbnVsbCA/IFtdIDogW29yZGVyc107XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBpdGVyYXRlZXMsIG9yZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcnRpdGlvbiA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0MiwgdmFsdWUsIGtleSkge1xuICAgICAgICAgIHJlc3VsdDJba2V5ID8gMCA6IDFdLnB1c2godmFsdWUpO1xuICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gW1tdLCBbXV07XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiByZWR1Y2UoY29sbGVjdGlvbiwgaXRlcmF0ZWUyLCBhY2N1bXVsYXRvcikge1xuICAgICAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5UmVkdWNlIDogYmFzZVJlZHVjZSwgaW5pdEFjY3VtID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUyLCA0KSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgYmFzZUVhY2gpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNvbGxlY3Rpb24sIGl0ZXJhdGVlMiwgYWNjdW11bGF0b3IpIHtcbiAgICAgICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVJlZHVjZVJpZ2h0IDogYmFzZVJlZHVjZSwgaW5pdEFjY3VtID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUyLCA0KSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgYmFzZUVhY2hSaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RmlsdGVyIDogYmFzZUZpbHRlcjtcbiAgICAgICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBuZWdhdGUoZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNhbXBsZShjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTYW1wbGUgOiBiYXNlU2FtcGxlO1xuICAgICAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNhbXBsZVNpemUoY29sbGVjdGlvbiwgbiwgZ3VhcmQpIHtcbiAgICAgICAgICBpZiAoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBuLCBndWFyZCkgOiBuID09PSB1bmRlZmluZWQyKSB7XG4gICAgICAgICAgICBuID0gMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTYW1wbGVTaXplIDogYmFzZVNhbXBsZVNpemU7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgbik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2h1ZmZsZShjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTaHVmZmxlIDogYmFzZVNodWZmbGU7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2l6ZShjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzU3RyaW5nKGNvbGxlY3Rpb24pID8gc3RyaW5nU2l6ZShjb2xsZWN0aW9uKSA6IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdGFnID0gZ2V0VGFnKGNvbGxlY3Rpb24pO1xuICAgICAgICAgIGlmICh0YWcgPT0gbWFwVGFnIHx8IHRhZyA9PSBzZXRUYWcpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0aW9uLnNpemU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiYXNlS2V5cyhjb2xsZWN0aW9uKS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc29tZShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGd1YXJkKSB7XG4gICAgICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTb21lIDogYmFzZVNvbWU7XG4gICAgICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpKSB7XG4gICAgICAgICAgICBwcmVkaWNhdGUgPSB1bmRlZmluZWQyO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc29ydEJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWVzKSB7XG4gICAgICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbGVuZ3RoID0gaXRlcmF0ZWVzLmxlbmd0aDtcbiAgICAgICAgICBpZiAobGVuZ3RoID4gMSAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBpdGVyYXRlZXNbMF0sIGl0ZXJhdGVlc1sxXSkpIHtcbiAgICAgICAgICAgIGl0ZXJhdGVlcyA9IFtdO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGVuZ3RoID4gMiAmJiBpc0l0ZXJhdGVlQ2FsbChpdGVyYXRlZXNbMF0sIGl0ZXJhdGVlc1sxXSwgaXRlcmF0ZWVzWzJdKSkge1xuICAgICAgICAgICAgaXRlcmF0ZWVzID0gW2l0ZXJhdGVlc1swXV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBiYXNlRmxhdHRlbihpdGVyYXRlZXMsIDEpLCBbXSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbm93ID0gY3R4Tm93IHx8IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiByb290LkRhdGUubm93KCk7XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIGFmdGVyKG4sIGZ1bmMpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yMihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICgtLW4gPCAxKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhcnkoZnVuYywgbiwgZ3VhcmQpIHtcbiAgICAgICAgICBuID0gZ3VhcmQgPyB1bmRlZmluZWQyIDogbjtcbiAgICAgICAgICBuID0gZnVuYyAmJiBuID09IG51bGwgPyBmdW5jLmxlbmd0aCA6IG47XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9BUllfRkxBRywgdW5kZWZpbmVkMiwgdW5kZWZpbmVkMiwgdW5kZWZpbmVkMiwgdW5kZWZpbmVkMiwgbik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmVmb3JlKG4sIGZ1bmMpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0MjtcbiAgICAgICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yMihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICgtLW4gPiAwKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobiA8PSAxKSB7XG4gICAgICAgICAgICAgIGZ1bmMgPSB1bmRlZmluZWQyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmluZCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHRoaXNBcmcsIHBhcnRpYWxzKSB7XG4gICAgICAgICAgdmFyIGJpdG1hc2sgPSBXUkFQX0JJTkRfRkxBRztcbiAgICAgICAgICBpZiAocGFydGlhbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBnZXRIb2xkZXIoYmluZCkpO1xuICAgICAgICAgICAgYml0bWFzayB8PSBXUkFQX1BBUlRJQUxfRkxBRztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGJpbmRLZXkgPSBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIGtleSwgcGFydGlhbHMpIHtcbiAgICAgICAgICB2YXIgYml0bWFzayA9IFdSQVBfQklORF9GTEFHIHwgV1JBUF9CSU5EX0tFWV9GTEFHO1xuICAgICAgICAgIGlmIChwYXJ0aWFscy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGdldEhvbGRlcihiaW5kS2V5KSk7XG4gICAgICAgICAgICBiaXRtYXNrIHw9IFdSQVBfUEFSVElBTF9GTEFHO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY3JlYXRlV3JhcChrZXksIGJpdG1hc2ssIG9iamVjdCwgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gY3VycnkoZnVuYywgYXJpdHksIGd1YXJkKSB7XG4gICAgICAgICAgYXJpdHkgPSBndWFyZCA/IHVuZGVmaW5lZDIgOiBhcml0eTtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9DVVJSWV9GTEFHLCB1bmRlZmluZWQyLCB1bmRlZmluZWQyLCB1bmRlZmluZWQyLCB1bmRlZmluZWQyLCB1bmRlZmluZWQyLCBhcml0eSk7XG4gICAgICAgICAgcmVzdWx0Mi5wbGFjZWhvbGRlciA9IGN1cnJ5LnBsYWNlaG9sZGVyO1xuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGN1cnJ5UmlnaHQoZnVuYywgYXJpdHksIGd1YXJkKSB7XG4gICAgICAgICAgYXJpdHkgPSBndWFyZCA/IHVuZGVmaW5lZDIgOiBhcml0eTtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9DVVJSWV9SSUdIVF9GTEFHLCB1bmRlZmluZWQyLCB1bmRlZmluZWQyLCB1bmRlZmluZWQyLCB1bmRlZmluZWQyLCB1bmRlZmluZWQyLCBhcml0eSk7XG4gICAgICAgICAgcmVzdWx0Mi5wbGFjZWhvbGRlciA9IGN1cnJ5UmlnaHQucGxhY2Vob2xkZXI7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgICAgICAgIHZhciBsYXN0QXJncywgbGFzdFRoaXMsIG1heFdhaXQsIHJlc3VsdDIsIHRpbWVySWQsIGxhc3RDYWxsVGltZSwgbGFzdEludm9rZVRpbWUgPSAwLCBsZWFkaW5nID0gZmFsc2UsIG1heGluZyA9IGZhbHNlLCB0cmFpbGluZyA9IHRydWU7XG4gICAgICAgICAgaWYgKHR5cGVvZiBmdW5jICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjIoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2FpdCA9IHRvTnVtYmVyKHdhaXQpIHx8IDA7XG4gICAgICAgICAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgICAgICBsZWFkaW5nID0gISFvcHRpb25zLmxlYWRpbmc7XG4gICAgICAgICAgICBtYXhpbmcgPSBcIm1heFdhaXRcIiBpbiBvcHRpb25zO1xuICAgICAgICAgICAgbWF4V2FpdCA9IG1heGluZyA/IG5hdGl2ZU1heCh0b051bWJlcihvcHRpb25zLm1heFdhaXQpIHx8IDAsIHdhaXQpIDogbWF4V2FpdDtcbiAgICAgICAgICAgIHRyYWlsaW5nID0gXCJ0cmFpbGluZ1wiIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gaW52b2tlRnVuYyh0aW1lKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IGxhc3RBcmdzLCB0aGlzQXJnID0gbGFzdFRoaXM7XG4gICAgICAgICAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkMjtcbiAgICAgICAgICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIGxlYWRpbmdFZGdlKHRpbWUpIHtcbiAgICAgICAgICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAgICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgICAgICByZXR1cm4gbGVhZGluZyA/IGludm9rZUZ1bmModGltZSkgOiByZXN1bHQyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiByZW1haW5pbmdXYWl0KHRpbWUpIHtcbiAgICAgICAgICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsIHRpbWVXYWl0aW5nID0gd2FpdCAtIHRpbWVTaW5jZUxhc3RDYWxsO1xuICAgICAgICAgICAgcmV0dXJuIG1heGluZyA/IG5hdGl2ZU1pbih0aW1lV2FpdGluZywgbWF4V2FpdCAtIHRpbWVTaW5jZUxhc3RJbnZva2UpIDogdGltZVdhaXRpbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XG4gICAgICAgICAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLCB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lO1xuICAgICAgICAgICAgcmV0dXJuIGxhc3RDYWxsVGltZSA9PT0gdW5kZWZpbmVkMiB8fCB0aW1lU2luY2VMYXN0Q2FsbCA+PSB3YWl0IHx8IHRpbWVTaW5jZUxhc3RDYWxsIDwgMCB8fCBtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiB0aW1lckV4cGlyZWQoKSB7XG4gICAgICAgICAgICB2YXIgdGltZSA9IG5vdygpO1xuICAgICAgICAgICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gdHJhaWxpbmdFZGdlKHRpbWUpIHtcbiAgICAgICAgICAgIHRpbWVySWQgPSB1bmRlZmluZWQyO1xuICAgICAgICAgICAgaWYgKHRyYWlsaW5nICYmIGxhc3RBcmdzKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDI7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgICAgICAgICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZDIpIHtcbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdEludm9rZVRpbWUgPSAwO1xuICAgICAgICAgICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aW1lcklkID09PSB1bmRlZmluZWQyID8gcmVzdWx0MiA6IHRyYWlsaW5nRWRnZShub3coKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICAgICAgICAgIHZhciB0aW1lID0gbm93KCksIGlzSW52b2tpbmcgPSBzaG91bGRJbnZva2UodGltZSk7XG4gICAgICAgICAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIGxhc3RUaGlzID0gdGhpcztcbiAgICAgICAgICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG4gICAgICAgICAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgICAgICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgICAgICAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW52b2tlRnVuYyhsYXN0Q2FsbFRpbWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkMikge1xuICAgICAgICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gICAgICAgICAgZGVib3VuY2VkLmZsdXNoID0gZmx1c2g7XG4gICAgICAgICAgcmV0dXJuIGRlYm91bmNlZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVmZXIgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBhcmdzKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VEZWxheShmdW5jLCAxLCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBkZWxheSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIGFyZ3MpIHtcbiAgICAgICAgICByZXR1cm4gYmFzZURlbGF5KGZ1bmMsIHRvTnVtYmVyKHdhaXQpIHx8IDAsIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gZmxpcChmdW5jKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9GTElQX0ZMQUcpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1lbW9pemUyKGZ1bmMsIHJlc29sdmVyKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBmdW5jICE9IFwiZnVuY3Rpb25cIiB8fCByZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IyKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLCBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuICAgICAgICAgICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXN1bHQyID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0MikgfHwgY2FjaGU7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgICB9O1xuICAgICAgICAgIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplMi5DYWNoZSB8fCBNYXBDYWNoZSkoKTtcbiAgICAgICAgICByZXR1cm4gbWVtb2l6ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgbWVtb2l6ZTIuQ2FjaGUgPSBNYXBDYWNoZTtcbiAgICAgICAgZnVuY3Rpb24gbmVnYXRlKHByZWRpY2F0ZSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgcHJlZGljYXRlICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjIoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzLCBhcmdzWzBdKTtcbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICFwcmVkaWNhdGUuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvbmNlKGZ1bmMpIHtcbiAgICAgICAgICByZXR1cm4gYmVmb3JlKDIsIGZ1bmMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdmVyQXJncyA9IGNhc3RSZXN0KGZ1bmN0aW9uKGZ1bmMsIHRyYW5zZm9ybXMpIHtcbiAgICAgICAgICB0cmFuc2Zvcm1zID0gdHJhbnNmb3Jtcy5sZW5ndGggPT0gMSAmJiBpc0FycmF5KHRyYW5zZm9ybXNbMF0pID8gYXJyYXlNYXAodHJhbnNmb3Jtc1swXSwgYmFzZVVuYXJ5KGdldEl0ZXJhdGVlKCkpKSA6IGFycmF5TWFwKGJhc2VGbGF0dGVuKHRyYW5zZm9ybXMsIDEpLCBiYXNlVW5hcnkoZ2V0SXRlcmF0ZWUoKSkpO1xuICAgICAgICAgIHZhciBmdW5jc0xlbmd0aCA9IHRyYW5zZm9ybXMubGVuZ3RoO1xuICAgICAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSAtMSwgbGVuZ3RoID0gbmF0aXZlTWluKGFyZ3MubGVuZ3RoLCBmdW5jc0xlbmd0aCk7XG4gICAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICBhcmdzW2luZGV4XSA9IHRyYW5zZm9ybXNbaW5kZXhdLmNhbGwodGhpcywgYXJnc1tpbmRleF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIGFyZ3MpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHBhcnRpYWwgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBwYXJ0aWFscykge1xuICAgICAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGdldEhvbGRlcihwYXJ0aWFsKSk7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9QQVJUSUFMX0ZMQUcsIHVuZGVmaW5lZDIsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBwYXJ0aWFsUmlnaHQgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBwYXJ0aWFscykge1xuICAgICAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGdldEhvbGRlcihwYXJ0aWFsUmlnaHQpKTtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRywgdW5kZWZpbmVkMiwgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHJlYXJnID0gZmxhdFJlc3QoZnVuY3Rpb24oZnVuYywgaW5kZXhlcykge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfUkVBUkdfRkxBRywgdW5kZWZpbmVkMiwgdW5kZWZpbmVkMiwgdW5kZWZpbmVkMiwgaW5kZXhlcyk7XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiByZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBmdW5jICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjIoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhcnQgPSBzdGFydCA9PT0gdW5kZWZpbmVkMiA/IHN0YXJ0IDogdG9JbnRlZ2VyKHN0YXJ0KTtcbiAgICAgICAgICByZXR1cm4gYmFzZVJlc3QoZnVuYywgc3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNwcmVhZChmdW5jLCBzdGFydCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IyKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXJ0ID0gc3RhcnQgPT0gbnVsbCA/IDAgOiBuYXRpdmVNYXgodG9JbnRlZ2VyKHN0YXJ0KSwgMCk7XG4gICAgICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgICAgIHZhciBhcnJheSA9IGFyZ3Nbc3RhcnRdLCBvdGhlckFyZ3MgPSBjYXN0U2xpY2UoYXJncywgMCwgc3RhcnQpO1xuICAgICAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgICAgIGFycmF5UHVzaChvdGhlckFyZ3MsIGFycmF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICAgICAgICB2YXIgbGVhZGluZyA9IHRydWUsIHRyYWlsaW5nID0gdHJ1ZTtcbiAgICAgICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yMihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgICAgIGxlYWRpbmcgPSBcImxlYWRpbmdcIiBpbiBvcHRpb25zID8gISFvcHRpb25zLmxlYWRpbmcgOiBsZWFkaW5nO1xuICAgICAgICAgICAgdHJhaWxpbmcgPSBcInRyYWlsaW5nXCIgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZGVib3VuY2UoZnVuYywgd2FpdCwge1xuICAgICAgICAgICAgXCJsZWFkaW5nXCI6IGxlYWRpbmcsXG4gICAgICAgICAgICBcIm1heFdhaXRcIjogd2FpdCxcbiAgICAgICAgICAgIFwidHJhaWxpbmdcIjogdHJhaWxpbmdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB1bmFyeShmdW5jKSB7XG4gICAgICAgICAgcmV0dXJuIGFyeShmdW5jLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB3cmFwKHZhbHVlLCB3cmFwcGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnRpYWwoY2FzdEZ1bmN0aW9uKHdyYXBwZXIpLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2FzdEFycmF5KCkge1xuICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdmFsdWUgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNsb25lKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfU1lNQk9MU19GTEFHKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjbG9uZVdpdGgodmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gXCJmdW5jdGlvblwiID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDI7XG4gICAgICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfU1lNQk9MU19GTEFHLCBjdXN0b21pemVyKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjbG9uZURlZXAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9ERUVQX0ZMQUcgfCBDTE9ORV9TWU1CT0xTX0ZMQUcpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNsb25lRGVlcFdpdGgodmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gXCJmdW5jdGlvblwiID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDI7XG4gICAgICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfREVFUF9GTEFHIHwgQ0xPTkVfU1lNQk9MU19GTEFHLCBjdXN0b21pemVyKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjb25mb3Jtc1RvKG9iamVjdCwgc291cmNlKSB7XG4gICAgICAgICAgcmV0dXJuIHNvdXJjZSA9PSBudWxsIHx8IGJhc2VDb25mb3Jtc1RvKG9iamVjdCwgc291cmNlLCBrZXlzKHNvdXJjZSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZ3QgPSBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKGJhc2VHdCk7XG4gICAgICAgIHZhciBndGUgPSBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAgICAgIHJldHVybiB2YWx1ZSA+PSBvdGhlcjtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gYXJndW1lbnRzO1xuICAgICAgICB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBcImNhbGxlZVwiKSAmJiAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgXCJjYWxsZWVcIik7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBpc0FycmF5ID0gQXJyYXkyLmlzQXJyYXk7XG4gICAgICAgIHZhciBpc0FycmF5QnVmZmVyID0gbm9kZUlzQXJyYXlCdWZmZXIgPyBiYXNlVW5hcnkobm9kZUlzQXJyYXlCdWZmZXIpIDogYmFzZUlzQXJyYXlCdWZmZXI7XG4gICAgICAgIGZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSBmYWxzZSB8fCBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGJvb2xUYWc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuICAgICAgICB2YXIgaXNEYXRlID0gbm9kZUlzRGF0ZSA/IGJhc2VVbmFyeShub2RlSXNEYXRlKSA6IGJhc2VJc0RhdGU7XG4gICAgICAgIGZ1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIHZhbHVlLm5vZGVUeXBlID09PSAxICYmICFpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNBcnJheUxpa2UodmFsdWUpICYmIChpc0FycmF5KHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUuc3BsaWNlID09IFwiZnVuY3Rpb25cIiB8fCBpc0J1ZmZlcih2YWx1ZSkgfHwgaXNUeXBlZEFycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gIXZhbHVlLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSk7XG4gICAgICAgICAgaWYgKHRhZyA9PSBtYXBUYWcgfHwgdGFnID09IHNldFRhZykge1xuICAgICAgICAgICAgcmV0dXJuICF2YWx1ZS5zaXplO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNQcm90b3R5cGUodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gIWJhc2VLZXlzKHZhbHVlKS5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0VxdWFsKHZhbHVlLCBvdGhlcikge1xuICAgICAgICAgIHJldHVybiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzRXF1YWxXaXRoKHZhbHVlLCBvdGhlciwgY3VzdG9taXplcikge1xuICAgICAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSBcImZ1bmN0aW9uXCIgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkMjtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKHZhbHVlLCBvdGhlcikgOiB1bmRlZmluZWQyO1xuICAgICAgICAgIHJldHVybiByZXN1bHQyID09PSB1bmRlZmluZWQyID8gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCB1bmRlZmluZWQyLCBjdXN0b21pemVyKSA6ICEhcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0Vycm9yKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gdGFnID09IGVycm9yVGFnIHx8IHRhZyA9PSBkb21FeGNUYWcgfHwgdHlwZW9mIHZhbHVlLm1lc3NhZ2UgPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgdmFsdWUubmFtZSA9PSBcInN0cmluZ1wiICYmICFpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0Zpbml0ZTIodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIgJiYgbmF0aXZlSXNGaW5pdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0ludGVnZXIodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIgJiYgdmFsdWUgPT0gdG9JbnRlZ2VyKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIiAmJiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSBcIm9iamVjdFwiIHx8IHR5cGUgPT0gXCJmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNNYXAgPSBub2RlSXNNYXAgPyBiYXNlVW5hcnkobm9kZUlzTWFwKSA6IGJhc2VJc01hcDtcbiAgICAgICAgZnVuY3Rpb24gaXNNYXRjaChvYmplY3QsIHNvdXJjZSkge1xuICAgICAgICAgIHJldHVybiBvYmplY3QgPT09IHNvdXJjZSB8fCBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgZ2V0TWF0Y2hEYXRhKHNvdXJjZSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzTWF0Y2hXaXRoKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyKSB7XG4gICAgICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09IFwiZnVuY3Rpb25cIiA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQyO1xuICAgICAgICAgIHJldHVybiBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgZ2V0TWF0Y2hEYXRhKHNvdXJjZSksIGN1c3RvbWl6ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzTmFOMih2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBpc051bWJlcih2YWx1ZSkgJiYgdmFsdWUgIT0gK3ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzTmF0aXZlKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKGlzTWFza2FibGUodmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IyKENPUkVfRVJST1JfVEVYVCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzTnVsbCh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc05pbCh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSBcIm51bWJlclwiIHx8IGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gbnVtYmVyVGFnO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgICAgICAgICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gICAgICAgICAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCBcImNvbnN0cnVjdG9yXCIpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICAgICAgICAgIHJldHVybiB0eXBlb2YgQ3RvciA9PSBcImZ1bmN0aW9uXCIgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiYgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZztcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNSZWdFeHAgPSBub2RlSXNSZWdFeHAgPyBiYXNlVW5hcnkobm9kZUlzUmVnRXhwKSA6IGJhc2VJc1JlZ0V4cDtcbiAgICAgICAgZnVuY3Rpb24gaXNTYWZlSW50ZWdlcih2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBpc0ludGVnZXIodmFsdWUpICYmIHZhbHVlID49IC1NQVhfU0FGRV9JTlRFR0VSICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlzU2V0ID0gbm9kZUlzU2V0ID8gYmFzZVVuYXJ5KG5vZGVJc1NldCkgOiBiYXNlSXNTZXQ7XG4gICAgICAgIGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiIHx8ICFpc0FycmF5KHZhbHVlKSAmJiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN0cmluZ1RhZztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gXCJzeW1ib2xcIiB8fCBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZztcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG4gICAgICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzV2Vha01hcCh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gd2Vha01hcFRhZztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc1dlYWtTZXQodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSB3ZWFrU2V0VGFnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsdCA9IGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oYmFzZUx0KTtcbiAgICAgICAgdmFyIGx0ZSA9IGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlIDw9IG90aGVyO1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSkge1xuICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzU3RyaW5nKHZhbHVlKSA/IHN0cmluZ1RvQXJyYXkodmFsdWUpIDogY29weUFycmF5KHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN5bUl0ZXJhdG9yICYmIHZhbHVlW3N5bUl0ZXJhdG9yXSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVG9BcnJheSh2YWx1ZVtzeW1JdGVyYXRvcl0oKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpLCBmdW5jID0gdGFnID09IG1hcFRhZyA/IG1hcFRvQXJyYXkgOiB0YWcgPT0gc2V0VGFnID8gc2V0VG9BcnJheSA6IHZhbHVlcztcbiAgICAgICAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdG9GaW5pdGUodmFsdWUpIHtcbiAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gSU5GSU5JVFkgfHwgdmFsdWUgPT09IC1JTkZJTklUWSkge1xuICAgICAgICAgICAgdmFyIHNpZ24gPSB2YWx1ZSA8IDAgPyAtMSA6IDE7XG4gICAgICAgICAgICByZXR1cm4gc2lnbiAqIE1BWF9JTlRFR0VSO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gdmFsdWUgOiAwO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRvSW50ZWdlcih2YWx1ZSkge1xuICAgICAgICAgIHZhciByZXN1bHQyID0gdG9GaW5pdGUodmFsdWUpLCByZW1haW5kZXIgPSByZXN1bHQyICUgMTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0MiA9PT0gcmVzdWx0MiA/IHJlbWFpbmRlciA/IHJlc3VsdDIgLSByZW1haW5kZXIgOiByZXN1bHQyIDogMDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB0b0xlbmd0aCh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZSA/IGJhc2VDbGFtcCh0b0ludGVnZXIodmFsdWUpLCAwLCBNQVhfQVJSQVlfTEVOR1RIKSA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5BTjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gXCJmdW5jdGlvblwiID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgICAgICAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IG90aGVyICsgXCJcIiA6IG90aGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZSA9IGJhc2VUcmltKHZhbHVlKTtcbiAgICAgICAgICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICAgICAgICAgIHJldHVybiBpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpIDogcmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB0b1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGNvcHlPYmplY3QodmFsdWUsIGtleXNJbih2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRvU2FmZUludGVnZXIodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUgPyBiYXNlQ2xhbXAodG9JbnRlZ2VyKHZhbHVlKSwgLU1BWF9TQUZFX0lOVEVHRVIsIE1BWF9TQUZFX0lOVEVHRVIpIDogdmFsdWUgPT09IDAgPyB2YWx1ZSA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhc3NpZ24gPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSkge1xuICAgICAgICAgIGlmIChpc1Byb3RvdHlwZShzb3VyY2UpIHx8IGlzQXJyYXlMaWtlKHNvdXJjZSkpIHtcbiAgICAgICAgICAgIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBhc3NpZ25JbiA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlKSB7XG4gICAgICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGFzc2lnbkluV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICAgICAgICAgIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0LCBjdXN0b21pemVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBhc3NpZ25XaXRoID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKSB7XG4gICAgICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0LCBjdXN0b21pemVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBhdCA9IGZsYXRSZXN0KGJhc2VBdCk7XG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZShwcm90b3R5cGUsIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IGJhc2VDcmVhdGUocHJvdG90eXBlKTtcbiAgICAgICAgICByZXR1cm4gcHJvcGVydGllcyA9PSBudWxsID8gcmVzdWx0MiA6IGJhc2VBc3NpZ24ocmVzdWx0MiwgcHJvcGVydGllcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlZmF1bHRzID0gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgICAgICAgb2JqZWN0ID0gT2JqZWN0MihvYmplY3QpO1xuICAgICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICAgIHZhciBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aDtcbiAgICAgICAgICB2YXIgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDI7XG4gICAgICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgICAgICAgbGVuZ3RoID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IGtleXNJbihzb3VyY2UpO1xuICAgICAgICAgICAgdmFyIHByb3BzSW5kZXggPSAtMTtcbiAgICAgICAgICAgIHZhciBwcm9wc0xlbmd0aCA9IHByb3BzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgrK3Byb3BzSW5kZXggPCBwcm9wc0xlbmd0aCkge1xuICAgICAgICAgICAgICB2YXIga2V5ID0gcHJvcHNbcHJvcHNJbmRleF07XG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZDIgfHwgZXEodmFsdWUsIG9iamVjdFByb3RvW2tleV0pICYmICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICAgICAgICAgIG9iamVjdFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBkZWZhdWx0c0RlZXAgPSBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgICAgYXJncy5wdXNoKHVuZGVmaW5lZDIsIGN1c3RvbURlZmF1bHRzTWVyZ2UpO1xuICAgICAgICAgIHJldHVybiBhcHBseShtZXJnZVdpdGgsIHVuZGVmaW5lZDIsIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gZmluZEtleShvYmplY3QsIHByZWRpY2F0ZSkge1xuICAgICAgICAgIHJldHVybiBiYXNlRmluZEtleShvYmplY3QsIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGJhc2VGb3JPd24pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZpbmRMYXN0S2V5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VGaW5kS2V5KG9iamVjdCwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgYmFzZUZvck93blJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmb3JJbihvYmplY3QsIGl0ZXJhdGVlMikge1xuICAgICAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VGb3Iob2JqZWN0LCBnZXRJdGVyYXRlZShpdGVyYXRlZTIsIDMpLCBrZXlzSW4pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZvckluUmlnaHQob2JqZWN0LCBpdGVyYXRlZTIpIHtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlRm9yUmlnaHQob2JqZWN0LCBnZXRJdGVyYXRlZShpdGVyYXRlZTIsIDMpLCBrZXlzSW4pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZvck93bihvYmplY3QsIGl0ZXJhdGVlMikge1xuICAgICAgICAgIHJldHVybiBvYmplY3QgJiYgYmFzZUZvck93bihvYmplY3QsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlMiwgMykpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZvck93blJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUyKSB7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yT3duUmlnaHQob2JqZWN0LCBnZXRJdGVyYXRlZShpdGVyYXRlZTIsIDMpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmdW5jdGlvbnMob2JqZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlRnVuY3Rpb25zKG9iamVjdCwga2V5cyhvYmplY3QpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmdW5jdGlvbnNJbihvYmplY3QpIHtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VGdW5jdGlvbnMob2JqZWN0LCBrZXlzSW4ob2JqZWN0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdDIgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZDIgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDIgPT09IHVuZGVmaW5lZDIgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGhhcyhvYmplY3QsIHBhdGgpIHtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXMpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICAgICAgICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhc0luKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW52ZXJ0ID0gY3JlYXRlSW52ZXJ0ZXIoZnVuY3Rpb24ocmVzdWx0MiwgdmFsdWUsIGtleSkge1xuICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZS50b1N0cmluZyAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdDJbdmFsdWVdID0ga2V5O1xuICAgICAgICB9LCBjb25zdGFudChpZGVudGl0eSkpO1xuICAgICAgICB2YXIgaW52ZXJ0QnkgPSBjcmVhdGVJbnZlcnRlcihmdW5jdGlvbihyZXN1bHQyLCB2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdmFsdWUgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0MiwgdmFsdWUpKSB7XG4gICAgICAgICAgICByZXN1bHQyW3ZhbHVlXS5wdXNoKGtleSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDJbdmFsdWVdID0gW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9LCBnZXRJdGVyYXRlZSk7XG4gICAgICAgIHZhciBpbnZva2UgPSBiYXNlUmVzdChiYXNlSW52b2tlKTtcbiAgICAgICAgZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgICAgICAgICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICAgICAgICAgIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1hcEtleXMob2JqZWN0LCBpdGVyYXRlZTIpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IHt9O1xuICAgICAgICAgIGl0ZXJhdGVlMiA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlMiwgMyk7XG4gICAgICAgICAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdDIpIHtcbiAgICAgICAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQyLCBpdGVyYXRlZTIodmFsdWUsIGtleSwgb2JqZWN0MiksIHZhbHVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtYXBWYWx1ZXMob2JqZWN0LCBpdGVyYXRlZTIpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IHt9O1xuICAgICAgICAgIGl0ZXJhdGVlMiA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlMiwgMyk7XG4gICAgICAgICAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdDIpIHtcbiAgICAgICAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQyLCBrZXksIGl0ZXJhdGVlMih2YWx1ZSwga2V5LCBvYmplY3QyKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1lcmdlID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KSB7XG4gICAgICAgICAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbWVyZ2VXaXRoID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKSB7XG4gICAgICAgICAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcik7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgb21pdCA9IGZsYXRSZXN0KGZ1bmN0aW9uKG9iamVjdCwgcGF0aHMpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IHt9O1xuICAgICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpc0RlZXAgPSBmYWxzZTtcbiAgICAgICAgICBwYXRocyA9IGFycmF5TWFwKHBhdGhzLCBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgICAgICAgICAgIGlzRGVlcCB8fCAoaXNEZWVwID0gcGF0aC5sZW5ndGggPiAxKTtcbiAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvcHlPYmplY3Qob2JqZWN0LCBnZXRBbGxLZXlzSW4ob2JqZWN0KSwgcmVzdWx0Mik7XG4gICAgICAgICAgaWYgKGlzRGVlcCkge1xuICAgICAgICAgICAgcmVzdWx0MiA9IGJhc2VDbG9uZShyZXN1bHQyLCBDTE9ORV9ERUVQX0ZMQUcgfCBDTE9ORV9GTEFUX0ZMQUcgfCBDTE9ORV9TWU1CT0xTX0ZMQUcsIGN1c3RvbU9taXRDbG9uZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBsZW5ndGggPSBwYXRocy5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgICBiYXNlVW5zZXQocmVzdWx0MiwgcGF0aHNbbGVuZ3RoXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gb21pdEJ5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIHBpY2tCeShvYmplY3QsIG5lZ2F0ZShnZXRJdGVyYXRlZShwcmVkaWNhdGUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBpY2sgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIHBhdGhzKSB7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8ge30gOiBiYXNlUGljayhvYmplY3QsIHBhdGhzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZ1bmN0aW9uIHBpY2tCeShvYmplY3QsIHByZWRpY2F0ZSkge1xuICAgICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcHJvcHMgPSBhcnJheU1hcChnZXRBbGxLZXlzSW4ob2JqZWN0KSwgZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICAgICAgcmV0dXJuIFtwcm9wXTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwcmVkaWNhdGUgPSBnZXRJdGVyYXRlZShwcmVkaWNhdGUpO1xuICAgICAgICAgIHJldHVybiBiYXNlUGlja0J5KG9iamVjdCwgcHJvcHMsIGZ1bmN0aW9uKHZhbHVlLCBwYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJlZGljYXRlKHZhbHVlLCBwYXRoWzBdKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZXN1bHQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgICAgICAgICB2YXIgaW5kZXggPSAtMSwgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG4gICAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IDE7XG4gICAgICAgICAgICBvYmplY3QgPSB1bmRlZmluZWQyO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQyIDogb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXhdKV07XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZDIpIHtcbiAgICAgICAgICAgICAgaW5kZXggPSBsZW5ndGg7XG4gICAgICAgICAgICAgIHZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqZWN0ID0gaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZS5jYWxsKG9iamVjdCkgOiB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0V2l0aChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKSB7XG4gICAgICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09IFwiZnVuY3Rpb25cIiA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQyO1xuICAgICAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRvUGFpcnMgPSBjcmVhdGVUb1BhaXJzKGtleXMpO1xuICAgICAgICB2YXIgdG9QYWlyc0luID0gY3JlYXRlVG9QYWlycyhrZXlzSW4pO1xuICAgICAgICBmdW5jdGlvbiB0cmFuc2Zvcm0ob2JqZWN0LCBpdGVyYXRlZTIsIGFjY3VtdWxhdG9yKSB7XG4gICAgICAgICAgdmFyIGlzQXJyID0gaXNBcnJheShvYmplY3QpLCBpc0Fyckxpa2UgPSBpc0FyciB8fCBpc0J1ZmZlcihvYmplY3QpIHx8IGlzVHlwZWRBcnJheShvYmplY3QpO1xuICAgICAgICAgIGl0ZXJhdGVlMiA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlMiwgNCk7XG4gICAgICAgICAgaWYgKGFjY3VtdWxhdG9yID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBDdG9yID0gb2JqZWN0ICYmIG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIGlmIChpc0Fyckxpa2UpIHtcbiAgICAgICAgICAgICAgYWNjdW11bGF0b3IgPSBpc0FyciA/IG5ldyBDdG9yKCkgOiBbXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICAgICAgICBhY2N1bXVsYXRvciA9IGlzRnVuY3Rpb24oQ3RvcikgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKSA6IHt9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYWNjdW11bGF0b3IgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgKGlzQXJyTGlrZSA/IGFycmF5RWFjaCA6IGJhc2VGb3JPd24pKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBvYmplY3QyKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlcmF0ZWUyKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIG9iamVjdDIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB1bnNldChvYmplY3QsIHBhdGgpIHtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB0cnVlIDogYmFzZVVuc2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlKG9iamVjdCwgcGF0aCwgdXBkYXRlcikge1xuICAgICAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VVcGRhdGUob2JqZWN0LCBwYXRoLCBjYXN0RnVuY3Rpb24odXBkYXRlcikpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVdpdGgob2JqZWN0LCBwYXRoLCB1cGRhdGVyLCBjdXN0b21pemVyKSB7XG4gICAgICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09IFwiZnVuY3Rpb25cIiA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQyO1xuICAgICAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VVcGRhdGUob2JqZWN0LCBwYXRoLCBjYXN0RnVuY3Rpb24odXBkYXRlciksIGN1c3RvbWl6ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZhbHVlcyhvYmplY3QpIHtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VWYWx1ZXMob2JqZWN0LCBrZXlzKG9iamVjdCkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZhbHVlc0luKG9iamVjdCkge1xuICAgICAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZVZhbHVlcyhvYmplY3QsIGtleXNJbihvYmplY3QpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjbGFtcChudW1iZXIsIGxvd2VyLCB1cHBlcikge1xuICAgICAgICAgIGlmICh1cHBlciA9PT0gdW5kZWZpbmVkMikge1xuICAgICAgICAgICAgdXBwZXIgPSBsb3dlcjtcbiAgICAgICAgICAgIGxvd2VyID0gdW5kZWZpbmVkMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHVwcGVyICE9PSB1bmRlZmluZWQyKSB7XG4gICAgICAgICAgICB1cHBlciA9IHRvTnVtYmVyKHVwcGVyKTtcbiAgICAgICAgICAgIHVwcGVyID0gdXBwZXIgPT09IHVwcGVyID8gdXBwZXIgOiAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobG93ZXIgIT09IHVuZGVmaW5lZDIpIHtcbiAgICAgICAgICAgIGxvd2VyID0gdG9OdW1iZXIobG93ZXIpO1xuICAgICAgICAgICAgbG93ZXIgPSBsb3dlciA9PT0gbG93ZXIgPyBsb3dlciA6IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiYXNlQ2xhbXAodG9OdW1iZXIobnVtYmVyKSwgbG93ZXIsIHVwcGVyKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpblJhbmdlKG51bWJlciwgc3RhcnQsIGVuZCkge1xuICAgICAgICAgIHN0YXJ0ID0gdG9GaW5pdGUoc3RhcnQpO1xuICAgICAgICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZDIpIHtcbiAgICAgICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbmQgPSB0b0Zpbml0ZShlbmQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBudW1iZXIgPSB0b051bWJlcihudW1iZXIpO1xuICAgICAgICAgIHJldHVybiBiYXNlSW5SYW5nZShudW1iZXIsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJhbmRvbShsb3dlciwgdXBwZXIsIGZsb2F0aW5nKSB7XG4gICAgICAgICAgaWYgKGZsb2F0aW5nICYmIHR5cGVvZiBmbG9hdGluZyAhPSBcImJvb2xlYW5cIiAmJiBpc0l0ZXJhdGVlQ2FsbChsb3dlciwgdXBwZXIsIGZsb2F0aW5nKSkge1xuICAgICAgICAgICAgdXBwZXIgPSBmbG9hdGluZyA9IHVuZGVmaW5lZDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmbG9hdGluZyA9PT0gdW5kZWZpbmVkMikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB1cHBlciA9PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICBmbG9hdGluZyA9IHVwcGVyO1xuICAgICAgICAgICAgICB1cHBlciA9IHVuZGVmaW5lZDI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsb3dlciA9PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICBmbG9hdGluZyA9IGxvd2VyO1xuICAgICAgICAgICAgICBsb3dlciA9IHVuZGVmaW5lZDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsb3dlciA9PT0gdW5kZWZpbmVkMiAmJiB1cHBlciA9PT0gdW5kZWZpbmVkMikge1xuICAgICAgICAgICAgbG93ZXIgPSAwO1xuICAgICAgICAgICAgdXBwZXIgPSAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb3dlciA9IHRvRmluaXRlKGxvd2VyKTtcbiAgICAgICAgICAgIGlmICh1cHBlciA9PT0gdW5kZWZpbmVkMikge1xuICAgICAgICAgICAgICB1cHBlciA9IGxvd2VyO1xuICAgICAgICAgICAgICBsb3dlciA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB1cHBlciA9IHRvRmluaXRlKHVwcGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxvd2VyID4gdXBwZXIpIHtcbiAgICAgICAgICAgIHZhciB0ZW1wID0gbG93ZXI7XG4gICAgICAgICAgICBsb3dlciA9IHVwcGVyO1xuICAgICAgICAgICAgdXBwZXIgPSB0ZW1wO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZmxvYXRpbmcgfHwgbG93ZXIgJSAxIHx8IHVwcGVyICUgMSkge1xuICAgICAgICAgICAgdmFyIHJhbmQgPSBuYXRpdmVSYW5kb20oKTtcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVNaW4obG93ZXIgKyByYW5kICogKHVwcGVyIC0gbG93ZXIgKyBmcmVlUGFyc2VGbG9hdChcIjFlLVwiICsgKChyYW5kICsgXCJcIikubGVuZ3RoIC0gMSkpKSwgdXBwZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYmFzZVJhbmRvbShsb3dlciwgdXBwZXIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjYW1lbENhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdDIsIHdvcmQsIGluZGV4KSB7XG4gICAgICAgICAgd29yZCA9IHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0MiArIChpbmRleCA/IGNhcGl0YWxpemUod29yZCkgOiB3b3JkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyaW5nKSB7XG4gICAgICAgICAgcmV0dXJuIHVwcGVyRmlyc3QodG9TdHJpbmcoc3RyaW5nKS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkZWJ1cnIoc3RyaW5nKSB7XG4gICAgICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgICAgICByZXR1cm4gc3RyaW5nICYmIHN0cmluZy5yZXBsYWNlKHJlTGF0aW4sIGRlYnVyckxldHRlcikucmVwbGFjZShyZUNvbWJvTWFyaywgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZW5kc1dpdGgoc3RyaW5nLCB0YXJnZXQsIHBvc2l0aW9uKSB7XG4gICAgICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgICAgICB0YXJnZXQgPSBiYXNlVG9TdHJpbmcodGFyZ2V0KTtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uID09PSB1bmRlZmluZWQyID8gbGVuZ3RoIDogYmFzZUNsYW1wKHRvSW50ZWdlcihwb3NpdGlvbiksIDAsIGxlbmd0aCk7XG4gICAgICAgICAgdmFyIGVuZCA9IHBvc2l0aW9uO1xuICAgICAgICAgIHBvc2l0aW9uIC09IHRhcmdldC5sZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIHBvc2l0aW9uID49IDAgJiYgc3RyaW5nLnNsaWNlKHBvc2l0aW9uLCBlbmQpID09IHRhcmdldDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBlc2NhcGUoc3RyaW5nKSB7XG4gICAgICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgICAgICByZXR1cm4gc3RyaW5nICYmIHJlSGFzVW5lc2NhcGVkSHRtbC50ZXN0KHN0cmluZykgPyBzdHJpbmcucmVwbGFjZShyZVVuZXNjYXBlZEh0bWwsIGVzY2FwZUh0bWxDaGFyKSA6IHN0cmluZztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyaW5nKSB7XG4gICAgICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgICAgICByZXR1cm4gc3RyaW5nICYmIHJlSGFzUmVnRXhwQ2hhci50ZXN0KHN0cmluZykgPyBzdHJpbmcucmVwbGFjZShyZVJlZ0V4cENoYXIsIFwiXFxcXCQmXCIpIDogc3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZWJhYkNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdDIsIHdvcmQsIGluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDIgKyAoaW5kZXggPyBcIi1cIiA6IFwiXCIpICsgd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGxvd2VyQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0Miwgd29yZCwgaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0MiArIChpbmRleCA/IFwiIFwiIDogXCJcIikgKyB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbG93ZXJGaXJzdCA9IGNyZWF0ZUNhc2VGaXJzdChcInRvTG93ZXJDYXNlXCIpO1xuICAgICAgICBmdW5jdGlvbiBwYWQoc3RyaW5nLCBsZW5ndGgsIGNoYXJzKSB7XG4gICAgICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgICAgICBsZW5ndGggPSB0b0ludGVnZXIobGVuZ3RoKTtcbiAgICAgICAgICB2YXIgc3RyTGVuZ3RoID0gbGVuZ3RoID8gc3RyaW5nU2l6ZShzdHJpbmcpIDogMDtcbiAgICAgICAgICBpZiAoIWxlbmd0aCB8fCBzdHJMZW5ndGggPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbWlkID0gKGxlbmd0aCAtIHN0ckxlbmd0aCkgLyAyO1xuICAgICAgICAgIHJldHVybiBjcmVhdGVQYWRkaW5nKG5hdGl2ZUZsb29yKG1pZCksIGNoYXJzKSArIHN0cmluZyArIGNyZWF0ZVBhZGRpbmcobmF0aXZlQ2VpbChtaWQpLCBjaGFycyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcGFkRW5kKHN0cmluZywgbGVuZ3RoLCBjaGFycykge1xuICAgICAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICAgICAgbGVuZ3RoID0gdG9JbnRlZ2VyKGxlbmd0aCk7XG4gICAgICAgICAgdmFyIHN0ckxlbmd0aCA9IGxlbmd0aCA/IHN0cmluZ1NpemUoc3RyaW5nKSA6IDA7XG4gICAgICAgICAgcmV0dXJuIGxlbmd0aCAmJiBzdHJMZW5ndGggPCBsZW5ndGggPyBzdHJpbmcgKyBjcmVhdGVQYWRkaW5nKGxlbmd0aCAtIHN0ckxlbmd0aCwgY2hhcnMpIDogc3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHBhZFN0YXJ0KHN0cmluZywgbGVuZ3RoLCBjaGFycykge1xuICAgICAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICAgICAgbGVuZ3RoID0gdG9JbnRlZ2VyKGxlbmd0aCk7XG4gICAgICAgICAgdmFyIHN0ckxlbmd0aCA9IGxlbmd0aCA/IHN0cmluZ1NpemUoc3RyaW5nKSA6IDA7XG4gICAgICAgICAgcmV0dXJuIGxlbmd0aCAmJiBzdHJMZW5ndGggPCBsZW5ndGggPyBjcmVhdGVQYWRkaW5nKGxlbmd0aCAtIHN0ckxlbmd0aCwgY2hhcnMpICsgc3RyaW5nIDogc3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlSW50MihzdHJpbmcsIHJhZGl4LCBndWFyZCkge1xuICAgICAgICAgIGlmIChndWFyZCB8fCByYWRpeCA9PSBudWxsKSB7XG4gICAgICAgICAgICByYWRpeCA9IDA7XG4gICAgICAgICAgfSBlbHNlIGlmIChyYWRpeCkge1xuICAgICAgICAgICAgcmFkaXggPSArcmFkaXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuYXRpdmVQYXJzZUludCh0b1N0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVUcmltU3RhcnQsIFwiXCIpLCByYWRpeCB8fCAwKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZXBlYXQoc3RyaW5nLCBuLCBndWFyZCkge1xuICAgICAgICAgIGlmIChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgbiwgZ3VhcmQpIDogbiA9PT0gdW5kZWZpbmVkMikge1xuICAgICAgICAgICAgbiA9IDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiYXNlUmVwZWF0KHRvU3RyaW5nKHN0cmluZyksIG4pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlcGxhY2UoKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsIHN0cmluZyA9IHRvU3RyaW5nKGFyZ3NbMF0pO1xuICAgICAgICAgIHJldHVybiBhcmdzLmxlbmd0aCA8IDMgPyBzdHJpbmcgOiBzdHJpbmcucmVwbGFjZShhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc25ha2VDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQyLCB3b3JkLCBpbmRleCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQyICsgKGluZGV4ID8gXCJfXCIgOiBcIlwiKSArIHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZ1bmN0aW9uIHNwbGl0KHN0cmluZywgc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgICAgIGlmIChsaW1pdCAmJiB0eXBlb2YgbGltaXQgIT0gXCJudW1iZXJcIiAmJiBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIHNlcGFyYXRvciwgbGltaXQpKSB7XG4gICAgICAgICAgICBzZXBhcmF0b3IgPSBsaW1pdCA9IHVuZGVmaW5lZDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxpbWl0ID0gbGltaXQgPT09IHVuZGVmaW5lZDIgPyBNQVhfQVJSQVlfTEVOR1RIIDogbGltaXQgPj4+IDA7XG4gICAgICAgICAgaWYgKCFsaW1pdCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgICAgIGlmIChzdHJpbmcgJiYgKHR5cGVvZiBzZXBhcmF0b3IgPT0gXCJzdHJpbmdcIiB8fCBzZXBhcmF0b3IgIT0gbnVsbCAmJiAhaXNSZWdFeHAoc2VwYXJhdG9yKSkpIHtcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IGJhc2VUb1N0cmluZyhzZXBhcmF0b3IpO1xuICAgICAgICAgICAgaWYgKCFzZXBhcmF0b3IgJiYgaGFzVW5pY29kZShzdHJpbmcpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjYXN0U2xpY2Uoc3RyaW5nVG9BcnJheShzdHJpbmcpLCAwLCBsaW1pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzdHJpbmcuc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXJ0Q2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0Miwgd29yZCwgaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0MiArIChpbmRleCA/IFwiIFwiIDogXCJcIikgKyB1cHBlckZpcnN0KHdvcmQpO1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gc3RhcnRzV2l0aChzdHJpbmcsIHRhcmdldCwgcG9zaXRpb24pIHtcbiAgICAgICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gPT0gbnVsbCA/IDAgOiBiYXNlQ2xhbXAodG9JbnRlZ2VyKHBvc2l0aW9uKSwgMCwgc3RyaW5nLmxlbmd0aCk7XG4gICAgICAgICAgdGFyZ2V0ID0gYmFzZVRvU3RyaW5nKHRhcmdldCk7XG4gICAgICAgICAgcmV0dXJuIHN0cmluZy5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyB0YXJnZXQubGVuZ3RoKSA9PSB0YXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdGVtcGxhdGUoc3RyaW5nLCBvcHRpb25zLCBndWFyZCkge1xuICAgICAgICAgIHZhciBzZXR0aW5ncyA9IGxvZGFzaC50ZW1wbGF0ZVNldHRpbmdzO1xuICAgICAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIG9wdGlvbnMsIGd1YXJkKSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHVuZGVmaW5lZDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICAgICAgb3B0aW9ucyA9IGFzc2lnbkluV2l0aCh7fSwgb3B0aW9ucywgc2V0dGluZ3MsIGN1c3RvbURlZmF1bHRzQXNzaWduSW4pO1xuICAgICAgICAgIHZhciBpbXBvcnRzID0gYXNzaWduSW5XaXRoKHt9LCBvcHRpb25zLmltcG9ydHMsIHNldHRpbmdzLmltcG9ydHMsIGN1c3RvbURlZmF1bHRzQXNzaWduSW4pLCBpbXBvcnRzS2V5cyA9IGtleXMoaW1wb3J0cyksIGltcG9ydHNWYWx1ZXMgPSBiYXNlVmFsdWVzKGltcG9ydHMsIGltcG9ydHNLZXlzKTtcbiAgICAgICAgICB2YXIgaXNFc2NhcGluZywgaXNFdmFsdWF0aW5nLCBpbmRleCA9IDAsIGludGVycG9sYXRlID0gb3B0aW9ucy5pbnRlcnBvbGF0ZSB8fCByZU5vTWF0Y2gsIHNvdXJjZSA9IFwiX19wICs9ICdcIjtcbiAgICAgICAgICB2YXIgcmVEZWxpbWl0ZXJzID0gUmVnRXhwMihcbiAgICAgICAgICAgIChvcHRpb25zLmVzY2FwZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArIFwifFwiICsgaW50ZXJwb2xhdGUuc291cmNlICsgXCJ8XCIgKyAoaW50ZXJwb2xhdGUgPT09IHJlSW50ZXJwb2xhdGUgPyByZUVzVGVtcGxhdGUgOiByZU5vTWF0Y2gpLnNvdXJjZSArIFwifFwiICsgKG9wdGlvbnMuZXZhbHVhdGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyBcInwkXCIsXG4gICAgICAgICAgICBcImdcIlxuICAgICAgICAgICk7XG4gICAgICAgICAgdmFyIHNvdXJjZVVSTCA9IFwiLy8jIHNvdXJjZVVSTD1cIiArIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIFwic291cmNlVVJMXCIpID8gKG9wdGlvbnMuc291cmNlVVJMICsgXCJcIikucmVwbGFjZSgvXFxzL2csIFwiIFwiKSA6IFwibG9kYXNoLnRlbXBsYXRlU291cmNlc1tcIiArICsrdGVtcGxhdGVDb3VudGVyICsgXCJdXCIpICsgXCJcXG5cIjtcbiAgICAgICAgICBzdHJpbmcucmVwbGFjZShyZURlbGltaXRlcnMsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGVWYWx1ZSwgaW50ZXJwb2xhdGVWYWx1ZSwgZXNUZW1wbGF0ZVZhbHVlLCBldmFsdWF0ZVZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgICAgIGludGVycG9sYXRlVmFsdWUgfHwgKGludGVycG9sYXRlVmFsdWUgPSBlc1RlbXBsYXRlVmFsdWUpO1xuICAgICAgICAgICAgc291cmNlICs9IHN0cmluZy5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKHJlVW5lc2NhcGVkU3RyaW5nLCBlc2NhcGVTdHJpbmdDaGFyKTtcbiAgICAgICAgICAgIGlmIChlc2NhcGVWYWx1ZSkge1xuICAgICAgICAgICAgICBpc0VzY2FwaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgc291cmNlICs9IFwiJyArXFxuX19lKFwiICsgZXNjYXBlVmFsdWUgKyBcIikgK1xcbidcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChldmFsdWF0ZVZhbHVlKSB7XG4gICAgICAgICAgICAgIGlzRXZhbHVhdGluZyA9IHRydWU7XG4gICAgICAgICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZVZhbHVlICsgXCI7XFxuX19wICs9ICdcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbnRlcnBvbGF0ZVZhbHVlKSB7XG4gICAgICAgICAgICAgIHNvdXJjZSArPSBcIicgK1xcbigoX190ID0gKFwiICsgaW50ZXJwb2xhdGVWYWx1ZSArIFwiKSkgPT0gbnVsbCA/ICcnIDogX190KSArXFxuJ1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc291cmNlICs9IFwiJztcXG5cIjtcbiAgICAgICAgICB2YXIgdmFyaWFibGUgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIFwidmFyaWFibGVcIikgJiYgb3B0aW9ucy52YXJpYWJsZTtcbiAgICAgICAgICBpZiAoIXZhcmlhYmxlKSB7XG4gICAgICAgICAgICBzb3VyY2UgPSBcIndpdGggKG9iaikge1xcblwiICsgc291cmNlICsgXCJcXG59XFxuXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChyZUZvcmJpZGRlbklkZW50aWZpZXJDaGFycy50ZXN0KHZhcmlhYmxlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yMihJTlZBTElEX1RFTVBMX1ZBUl9FUlJPUl9URVhUKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc291cmNlID0gKGlzRXZhbHVhdGluZyA/IHNvdXJjZS5yZXBsYWNlKHJlRW1wdHlTdHJpbmdMZWFkaW5nLCBcIlwiKSA6IHNvdXJjZSkucmVwbGFjZShyZUVtcHR5U3RyaW5nTWlkZGxlLCBcIiQxXCIpLnJlcGxhY2UocmVFbXB0eVN0cmluZ1RyYWlsaW5nLCBcIiQxO1wiKTtcbiAgICAgICAgICBzb3VyY2UgPSBcImZ1bmN0aW9uKFwiICsgKHZhcmlhYmxlIHx8IFwib2JqXCIpICsgXCIpIHtcXG5cIiArICh2YXJpYWJsZSA/IFwiXCIgOiBcIm9iaiB8fCAob2JqID0ge30pO1xcblwiKSArIFwidmFyIF9fdCwgX19wID0gJydcIiArIChpc0VzY2FwaW5nID8gXCIsIF9fZSA9IF8uZXNjYXBlXCIgOiBcIlwiKSArIChpc0V2YWx1YXRpbmcgPyBcIiwgX19qID0gQXJyYXkucHJvdG90eXBlLmpvaW47XFxuZnVuY3Rpb24gcHJpbnQoKSB7IF9fcCArPSBfX2ouY2FsbChhcmd1bWVudHMsICcnKSB9XFxuXCIgOiBcIjtcXG5cIikgKyBzb3VyY2UgKyBcInJldHVybiBfX3BcXG59XCI7XG4gICAgICAgICAgdmFyIHJlc3VsdDIgPSBhdHRlbXB0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uMihpbXBvcnRzS2V5cywgc291cmNlVVJMICsgXCJyZXR1cm4gXCIgKyBzb3VyY2UpLmFwcGx5KHVuZGVmaW5lZDIsIGltcG9ydHNWYWx1ZXMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlc3VsdDIuc291cmNlID0gc291cmNlO1xuICAgICAgICAgIGlmIChpc0Vycm9yKHJlc3VsdDIpKSB7XG4gICAgICAgICAgICB0aHJvdyByZXN1bHQyO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB0b0xvd2VyKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHRvU3RyaW5nKHZhbHVlKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRvVXBwZXIodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdG9TdHJpbmcodmFsdWUpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdHJpbShzdHJpbmcsIGNoYXJzLCBndWFyZCkge1xuICAgICAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICAgICAgaWYgKHN0cmluZyAmJiAoZ3VhcmQgfHwgY2hhcnMgPT09IHVuZGVmaW5lZDIpKSB7XG4gICAgICAgICAgICByZXR1cm4gYmFzZVRyaW0oc3RyaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFzdHJpbmcgfHwgIShjaGFycyA9IGJhc2VUb1N0cmluZyhjaGFycykpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgc3RyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoc3RyaW5nKSwgY2hyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoY2hhcnMpLCBzdGFydCA9IGNoYXJzU3RhcnRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSwgZW5kID0gY2hhcnNFbmRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSArIDE7XG4gICAgICAgICAgcmV0dXJuIGNhc3RTbGljZShzdHJTeW1ib2xzLCBzdGFydCwgZW5kKS5qb2luKFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRyaW1FbmQoc3RyaW5nLCBjaGFycywgZ3VhcmQpIHtcbiAgICAgICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgICAgIGlmIChzdHJpbmcgJiYgKGd1YXJkIHx8IGNoYXJzID09PSB1bmRlZmluZWQyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5zbGljZSgwLCB0cmltbWVkRW5kSW5kZXgoc3RyaW5nKSArIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXN0cmluZyB8fCAhKGNoYXJzID0gYmFzZVRvU3RyaW5nKGNoYXJzKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBzdHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShzdHJpbmcpLCBlbmQgPSBjaGFyc0VuZEluZGV4KHN0clN5bWJvbHMsIHN0cmluZ1RvQXJyYXkoY2hhcnMpKSArIDE7XG4gICAgICAgICAgcmV0dXJuIGNhc3RTbGljZShzdHJTeW1ib2xzLCAwLCBlbmQpLmpvaW4oXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdHJpbVN0YXJ0KHN0cmluZywgY2hhcnMsIGd1YXJkKSB7XG4gICAgICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgICAgICBpZiAoc3RyaW5nICYmIChndWFyZCB8fCBjaGFycyA9PT0gdW5kZWZpbmVkMikpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShyZVRyaW1TdGFydCwgXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghc3RyaW5nIHx8ICEoY2hhcnMgPSBiYXNlVG9TdHJpbmcoY2hhcnMpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHN0clN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KHN0cmluZyksIHN0YXJ0ID0gY2hhcnNTdGFydEluZGV4KHN0clN5bWJvbHMsIHN0cmluZ1RvQXJyYXkoY2hhcnMpKTtcbiAgICAgICAgICByZXR1cm4gY2FzdFNsaWNlKHN0clN5bWJvbHMsIHN0YXJ0KS5qb2luKFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRydW5jYXRlKHN0cmluZywgb3B0aW9ucykge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBERUZBVUxUX1RSVU5DX0xFTkdUSCwgb21pc3Npb24gPSBERUZBVUxUX1RSVU5DX09NSVNTSU9OO1xuICAgICAgICAgIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICAgICAgdmFyIHNlcGFyYXRvciA9IFwic2VwYXJhdG9yXCIgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc2VwYXJhdG9yIDogc2VwYXJhdG9yO1xuICAgICAgICAgICAgbGVuZ3RoID0gXCJsZW5ndGhcIiBpbiBvcHRpb25zID8gdG9JbnRlZ2VyKG9wdGlvbnMubGVuZ3RoKSA6IGxlbmd0aDtcbiAgICAgICAgICAgIG9taXNzaW9uID0gXCJvbWlzc2lvblwiIGluIG9wdGlvbnMgPyBiYXNlVG9TdHJpbmcob3B0aW9ucy5vbWlzc2lvbikgOiBvbWlzc2lvbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgICAgICB2YXIgc3RyTGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgICAgICBpZiAoaGFzVW5pY29kZShzdHJpbmcpKSB7XG4gICAgICAgICAgICB2YXIgc3RyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoc3RyaW5nKTtcbiAgICAgICAgICAgIHN0ckxlbmd0aCA9IHN0clN5bWJvbHMubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobGVuZ3RoID49IHN0ckxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCAtIHN0cmluZ1NpemUob21pc3Npb24pO1xuICAgICAgICAgIGlmIChlbmQgPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gb21pc3Npb247XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZXN1bHQyID0gc3RyU3ltYm9scyA/IGNhc3RTbGljZShzdHJTeW1ib2xzLCAwLCBlbmQpLmpvaW4oXCJcIikgOiBzdHJpbmcuc2xpY2UoMCwgZW5kKTtcbiAgICAgICAgICBpZiAoc2VwYXJhdG9yID09PSB1bmRlZmluZWQyKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0MiArIG9taXNzaW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RyU3ltYm9scykge1xuICAgICAgICAgICAgZW5kICs9IHJlc3VsdDIubGVuZ3RoIC0gZW5kO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNSZWdFeHAoc2VwYXJhdG9yKSkge1xuICAgICAgICAgICAgaWYgKHN0cmluZy5zbGljZShlbmQpLnNlYXJjaChzZXBhcmF0b3IpKSB7XG4gICAgICAgICAgICAgIHZhciBtYXRjaCwgc3Vic3RyaW5nID0gcmVzdWx0MjtcbiAgICAgICAgICAgICAgaWYgKCFzZXBhcmF0b3IuZ2xvYmFsKSB7XG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yID0gUmVnRXhwMihzZXBhcmF0b3Iuc291cmNlLCB0b1N0cmluZyhyZUZsYWdzLmV4ZWMoc2VwYXJhdG9yKSkgKyBcImdcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc2VwYXJhdG9yLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICAgIHdoaWxlIChtYXRjaCA9IHNlcGFyYXRvci5leGVjKHN1YnN0cmluZykpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3RW5kID0gbWF0Y2guaW5kZXg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0MiA9IHJlc3VsdDIuc2xpY2UoMCwgbmV3RW5kID09PSB1bmRlZmluZWQyID8gZW5kIDogbmV3RW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHN0cmluZy5pbmRleE9mKGJhc2VUb1N0cmluZyhzZXBhcmF0b3IpLCBlbmQpICE9IGVuZCkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gcmVzdWx0Mi5sYXN0SW5kZXhPZihzZXBhcmF0b3IpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MiA9IHJlc3VsdDIuc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0MiArIG9taXNzaW9uO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHVuZXNjYXBlKHN0cmluZykge1xuICAgICAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICAgICAgcmV0dXJuIHN0cmluZyAmJiByZUhhc0VzY2FwZWRIdG1sLnRlc3Qoc3RyaW5nKSA/IHN0cmluZy5yZXBsYWNlKHJlRXNjYXBlZEh0bWwsIHVuZXNjYXBlSHRtbENoYXIpIDogc3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1cHBlckNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdDIsIHdvcmQsIGluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDIgKyAoaW5kZXggPyBcIiBcIiA6IFwiXCIpICsgd29yZC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHVwcGVyRmlyc3QgPSBjcmVhdGVDYXNlRmlyc3QoXCJ0b1VwcGVyQ2FzZVwiKTtcbiAgICAgICAgZnVuY3Rpb24gd29yZHMoc3RyaW5nLCBwYXR0ZXJuLCBndWFyZCkge1xuICAgICAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICAgICAgcGF0dGVybiA9IGd1YXJkID8gdW5kZWZpbmVkMiA6IHBhdHRlcm47XG4gICAgICAgICAgaWYgKHBhdHRlcm4gPT09IHVuZGVmaW5lZDIpIHtcbiAgICAgICAgICAgIHJldHVybiBoYXNVbmljb2RlV29yZChzdHJpbmcpID8gdW5pY29kZVdvcmRzKHN0cmluZykgOiBhc2NpaVdvcmRzKHN0cmluZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzdHJpbmcubWF0Y2gocGF0dGVybikgfHwgW107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGF0dGVtcHQgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBhcmdzKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhcHBseShmdW5jLCB1bmRlZmluZWQyLCBhcmdzKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNFcnJvcihlKSA/IGUgOiBuZXcgRXJyb3IyKGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBiaW5kQWxsID0gZmxhdFJlc3QoZnVuY3Rpb24ob2JqZWN0LCBtZXRob2ROYW1lcykge1xuICAgICAgICAgIGFycmF5RWFjaChtZXRob2ROYW1lcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBrZXkgPSB0b0tleShrZXkpO1xuICAgICAgICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBiaW5kKG9iamVjdFtrZXldLCBvYmplY3QpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gY29uZChwYWlycykge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBwYWlycyA9PSBudWxsID8gMCA6IHBhaXJzLmxlbmd0aCwgdG9JdGVyYXRlZSA9IGdldEl0ZXJhdGVlKCk7XG4gICAgICAgICAgcGFpcnMgPSAhbGVuZ3RoID8gW10gOiBhcnJheU1hcChwYWlycywgZnVuY3Rpb24ocGFpcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYWlyWzFdICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yMihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFt0b0l0ZXJhdGVlKHBhaXJbMF0pLCBwYWlyWzFdXTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICB2YXIgcGFpciA9IHBhaXJzW2luZGV4XTtcbiAgICAgICAgICAgICAgaWYgKGFwcGx5KHBhaXJbMF0sIHRoaXMsIGFyZ3MpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcGx5KHBhaXJbMV0sIHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY29uZm9ybXMoc291cmNlKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VDb25mb3JtcyhiYXNlQ2xvbmUoc291cmNlLCBDTE9ORV9ERUVQX0ZMQUcpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGRlZmF1bHRUbyh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlID09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlID8gZGVmYXVsdFZhbHVlIDogdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZsb3cgPSBjcmVhdGVGbG93KCk7XG4gICAgICAgIHZhciBmbG93UmlnaHQgPSBjcmVhdGVGbG93KHRydWUpO1xuICAgICAgICBmdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpdGVyYXRlZShmdW5jKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VJdGVyYXRlZSh0eXBlb2YgZnVuYyA9PSBcImZ1bmN0aW9uXCIgPyBmdW5jIDogYmFzZUNsb25lKGZ1bmMsIENMT05FX0RFRVBfRkxBRykpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1hdGNoZXMoc291cmNlKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VNYXRjaGVzKGJhc2VDbG9uZShzb3VyY2UsIENMT05FX0RFRVBfRkxBRykpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICAgICAgICAgIHJldHVybiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsIGJhc2VDbG9uZShzcmNWYWx1ZSwgQ0xPTkVfREVFUF9GTEFHKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1ldGhvZCA9IGJhc2VSZXN0KGZ1bmN0aW9uKHBhdGgsIGFyZ3MpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gYmFzZUludm9rZShvYmplY3QsIHBhdGgsIGFyZ3MpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbWV0aG9kT2YgPSBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIGFyZ3MpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGJhc2VJbnZva2Uob2JqZWN0LCBwYXRoLCBhcmdzKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gbWl4aW4ob2JqZWN0LCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICB2YXIgcHJvcHMgPSBrZXlzKHNvdXJjZSksIG1ldGhvZE5hbWVzID0gYmFzZUZ1bmN0aW9ucyhzb3VyY2UsIHByb3BzKTtcbiAgICAgICAgICBpZiAob3B0aW9ucyA9PSBudWxsICYmICEoaXNPYmplY3Qoc291cmNlKSAmJiAobWV0aG9kTmFtZXMubGVuZ3RoIHx8ICFwcm9wcy5sZW5ndGgpKSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHNvdXJjZTtcbiAgICAgICAgICAgIHNvdXJjZSA9IG9iamVjdDtcbiAgICAgICAgICAgIG9iamVjdCA9IHRoaXM7XG4gICAgICAgICAgICBtZXRob2ROYW1lcyA9IGJhc2VGdW5jdGlvbnMoc291cmNlLCBrZXlzKHNvdXJjZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgY2hhaW4yID0gIShpc09iamVjdChvcHRpb25zKSAmJiBcImNoYWluXCIgaW4gb3B0aW9ucykgfHwgISFvcHRpb25zLmNoYWluLCBpc0Z1bmMgPSBpc0Z1bmN0aW9uKG9iamVjdCk7XG4gICAgICAgICAgYXJyYXlFYWNoKG1ldGhvZE5hbWVzLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICAgICAgICB2YXIgZnVuYyA9IHNvdXJjZVttZXRob2ROYW1lXTtcbiAgICAgICAgICAgIG9iamVjdFttZXRob2ROYW1lXSA9IGZ1bmM7XG4gICAgICAgICAgICBpZiAoaXNGdW5jKSB7XG4gICAgICAgICAgICAgIG9iamVjdC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hhaW5BbGwgPSB0aGlzLl9fY2hhaW5fXztcbiAgICAgICAgICAgICAgICBpZiAoY2hhaW4yIHx8IGNoYWluQWxsKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MiA9IG9iamVjdCh0aGlzLl9fd3JhcHBlZF9fKSwgYWN0aW9ucyA9IHJlc3VsdDIuX19hY3Rpb25zX18gPSBjb3B5QXJyYXkodGhpcy5fX2FjdGlvbnNfXyk7XG4gICAgICAgICAgICAgICAgICBhY3Rpb25zLnB1c2goeyBcImZ1bmNcIjogZnVuYywgXCJhcmdzXCI6IGFyZ3VtZW50cywgXCJ0aGlzQXJnXCI6IG9iamVjdCB9KTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdDIuX19jaGFpbl9fID0gY2hhaW5BbGw7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkob2JqZWN0LCBhcnJheVB1c2goW3RoaXMudmFsdWUoKV0sIGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbm9Db25mbGljdCgpIHtcbiAgICAgICAgICBpZiAocm9vdC5fID09PSB0aGlzKSB7XG4gICAgICAgICAgICByb290Ll8gPSBvbGREYXNoO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBub29wKCkge1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG50aEFyZyhuKSB7XG4gICAgICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIGJhc2VOdGgoYXJncywgbik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG92ZXIgPSBjcmVhdGVPdmVyKGFycmF5TWFwKTtcbiAgICAgICAgdmFyIG92ZXJFdmVyeSA9IGNyZWF0ZU92ZXIoYXJyYXlFdmVyeSk7XG4gICAgICAgIHZhciBvdmVyU29tZSA9IGNyZWF0ZU92ZXIoYXJyYXlTb21lKTtcbiAgICAgICAgZnVuY3Rpb24gcHJvcGVydHkocGF0aCkge1xuICAgICAgICAgIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eSh0b0tleShwYXRoKSkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHByb3BlcnR5T2Yob2JqZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZDIgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmFuZ2UgPSBjcmVhdGVSYW5nZSgpO1xuICAgICAgICB2YXIgcmFuZ2VSaWdodCA9IGNyZWF0ZVJhbmdlKHRydWUpO1xuICAgICAgICBmdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc3R1Yk9iamVjdCgpIHtcbiAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc3R1YlN0cmluZygpIHtcbiAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzdHViVHJ1ZSgpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB0aW1lcyhuLCBpdGVyYXRlZTIpIHtcbiAgICAgICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgICAgIGlmIChuIDwgMSB8fCBuID4gTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaW5kZXggPSBNQVhfQVJSQVlfTEVOR1RILCBsZW5ndGggPSBuYXRpdmVNaW4obiwgTUFYX0FSUkFZX0xFTkdUSCk7XG4gICAgICAgICAgaXRlcmF0ZWUyID0gZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUyKTtcbiAgICAgICAgICBuIC09IE1BWF9BUlJBWV9MRU5HVEg7XG4gICAgICAgICAgdmFyIHJlc3VsdDIgPSBiYXNlVGltZXMobGVuZ3RoLCBpdGVyYXRlZTIpO1xuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgICAgICAgICAgaXRlcmF0ZWUyKGluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdG9QYXRoKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIHRvS2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGlzU3ltYm9sKHZhbHVlKSA/IFt2YWx1ZV0gOiBjb3B5QXJyYXkoc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHVuaXF1ZUlkKHByZWZpeCkge1xuICAgICAgICAgIHZhciBpZCA9ICsraWRDb3VudGVyO1xuICAgICAgICAgIHJldHVybiB0b1N0cmluZyhwcmVmaXgpICsgaWQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFkZCA9IGNyZWF0ZU1hdGhPcGVyYXRpb24oZnVuY3Rpb24oYXVnZW5kLCBhZGRlbmQpIHtcbiAgICAgICAgICByZXR1cm4gYXVnZW5kICsgYWRkZW5kO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgdmFyIGNlaWwgPSBjcmVhdGVSb3VuZChcImNlaWxcIik7XG4gICAgICAgIHZhciBkaXZpZGUgPSBjcmVhdGVNYXRoT3BlcmF0aW9uKGZ1bmN0aW9uKGRpdmlkZW5kLCBkaXZpc29yKSB7XG4gICAgICAgICAgcmV0dXJuIGRpdmlkZW5kIC8gZGl2aXNvcjtcbiAgICAgICAgfSwgMSk7XG4gICAgICAgIHZhciBmbG9vciA9IGNyZWF0ZVJvdW5kKFwiZmxvb3JcIik7XG4gICAgICAgIGZ1bmN0aW9uIG1heChhcnJheSkge1xuICAgICAgICAgIHJldHVybiBhcnJheSAmJiBhcnJheS5sZW5ndGggPyBiYXNlRXh0cmVtdW0oYXJyYXksIGlkZW50aXR5LCBiYXNlR3QpIDogdW5kZWZpbmVkMjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtYXhCeShhcnJheSwgaXRlcmF0ZWUyKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5ICYmIGFycmF5Lmxlbmd0aCA/IGJhc2VFeHRyZW11bShhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUyLCAyKSwgYmFzZUd0KSA6IHVuZGVmaW5lZDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWVhbihhcnJheSkge1xuICAgICAgICAgIHJldHVybiBiYXNlTWVhbihhcnJheSwgaWRlbnRpdHkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1lYW5CeShhcnJheSwgaXRlcmF0ZWUyKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VNZWFuKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZTIsIDIpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtaW4oYXJyYXkpIHtcbiAgICAgICAgICByZXR1cm4gYXJyYXkgJiYgYXJyYXkubGVuZ3RoID8gYmFzZUV4dHJlbXVtKGFycmF5LCBpZGVudGl0eSwgYmFzZUx0KSA6IHVuZGVmaW5lZDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWluQnkoYXJyYXksIGl0ZXJhdGVlMikge1xuICAgICAgICAgIHJldHVybiBhcnJheSAmJiBhcnJheS5sZW5ndGggPyBiYXNlRXh0cmVtdW0oYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlMiwgMiksIGJhc2VMdCkgOiB1bmRlZmluZWQyO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtdWx0aXBseSA9IGNyZWF0ZU1hdGhPcGVyYXRpb24oZnVuY3Rpb24obXVsdGlwbGllciwgbXVsdGlwbGljYW5kKSB7XG4gICAgICAgICAgcmV0dXJuIG11bHRpcGxpZXIgKiBtdWx0aXBsaWNhbmQ7XG4gICAgICAgIH0sIDEpO1xuICAgICAgICB2YXIgcm91bmQgPSBjcmVhdGVSb3VuZChcInJvdW5kXCIpO1xuICAgICAgICB2YXIgc3VidHJhY3QgPSBjcmVhdGVNYXRoT3BlcmF0aW9uKGZ1bmN0aW9uKG1pbnVlbmQsIHN1YnRyYWhlbmQpIHtcbiAgICAgICAgICByZXR1cm4gbWludWVuZCAtIHN1YnRyYWhlbmQ7XG4gICAgICAgIH0sIDApO1xuICAgICAgICBmdW5jdGlvbiBzdW0oYXJyYXkpIHtcbiAgICAgICAgICByZXR1cm4gYXJyYXkgJiYgYXJyYXkubGVuZ3RoID8gYmFzZVN1bShhcnJheSwgaWRlbnRpdHkpIDogMDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzdW1CeShhcnJheSwgaXRlcmF0ZWUyKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5ICYmIGFycmF5Lmxlbmd0aCA/IGJhc2VTdW0oYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlMiwgMikpIDogMDtcbiAgICAgICAgfVxuICAgICAgICBsb2Rhc2guYWZ0ZXIgPSBhZnRlcjtcbiAgICAgICAgbG9kYXNoLmFyeSA9IGFyeTtcbiAgICAgICAgbG9kYXNoLmFzc2lnbiA9IGFzc2lnbjtcbiAgICAgICAgbG9kYXNoLmFzc2lnbkluID0gYXNzaWduSW47XG4gICAgICAgIGxvZGFzaC5hc3NpZ25JbldpdGggPSBhc3NpZ25JbldpdGg7XG4gICAgICAgIGxvZGFzaC5hc3NpZ25XaXRoID0gYXNzaWduV2l0aDtcbiAgICAgICAgbG9kYXNoLmF0ID0gYXQ7XG4gICAgICAgIGxvZGFzaC5iZWZvcmUgPSBiZWZvcmU7XG4gICAgICAgIGxvZGFzaC5iaW5kID0gYmluZDtcbiAgICAgICAgbG9kYXNoLmJpbmRBbGwgPSBiaW5kQWxsO1xuICAgICAgICBsb2Rhc2guYmluZEtleSA9IGJpbmRLZXk7XG4gICAgICAgIGxvZGFzaC5jYXN0QXJyYXkgPSBjYXN0QXJyYXk7XG4gICAgICAgIGxvZGFzaC5jaGFpbiA9IGNoYWluO1xuICAgICAgICBsb2Rhc2guY2h1bmsgPSBjaHVuaztcbiAgICAgICAgbG9kYXNoLmNvbXBhY3QgPSBjb21wYWN0O1xuICAgICAgICBsb2Rhc2guY29uY2F0ID0gY29uY2F0O1xuICAgICAgICBsb2Rhc2guY29uZCA9IGNvbmQ7XG4gICAgICAgIGxvZGFzaC5jb25mb3JtcyA9IGNvbmZvcm1zO1xuICAgICAgICBsb2Rhc2guY29uc3RhbnQgPSBjb25zdGFudDtcbiAgICAgICAgbG9kYXNoLmNvdW50QnkgPSBjb3VudEJ5O1xuICAgICAgICBsb2Rhc2guY3JlYXRlID0gY3JlYXRlO1xuICAgICAgICBsb2Rhc2guY3VycnkgPSBjdXJyeTtcbiAgICAgICAgbG9kYXNoLmN1cnJ5UmlnaHQgPSBjdXJyeVJpZ2h0O1xuICAgICAgICBsb2Rhc2guZGVib3VuY2UgPSBkZWJvdW5jZTtcbiAgICAgICAgbG9kYXNoLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4gICAgICAgIGxvZGFzaC5kZWZhdWx0c0RlZXAgPSBkZWZhdWx0c0RlZXA7XG4gICAgICAgIGxvZGFzaC5kZWZlciA9IGRlZmVyO1xuICAgICAgICBsb2Rhc2guZGVsYXkgPSBkZWxheTtcbiAgICAgICAgbG9kYXNoLmRpZmZlcmVuY2UgPSBkaWZmZXJlbmNlO1xuICAgICAgICBsb2Rhc2guZGlmZmVyZW5jZUJ5ID0gZGlmZmVyZW5jZUJ5O1xuICAgICAgICBsb2Rhc2guZGlmZmVyZW5jZVdpdGggPSBkaWZmZXJlbmNlV2l0aDtcbiAgICAgICAgbG9kYXNoLmRyb3AgPSBkcm9wO1xuICAgICAgICBsb2Rhc2guZHJvcFJpZ2h0ID0gZHJvcFJpZ2h0O1xuICAgICAgICBsb2Rhc2guZHJvcFJpZ2h0V2hpbGUgPSBkcm9wUmlnaHRXaGlsZTtcbiAgICAgICAgbG9kYXNoLmRyb3BXaGlsZSA9IGRyb3BXaGlsZTtcbiAgICAgICAgbG9kYXNoLmZpbGwgPSBmaWxsO1xuICAgICAgICBsb2Rhc2guZmlsdGVyID0gZmlsdGVyO1xuICAgICAgICBsb2Rhc2guZmxhdE1hcCA9IGZsYXRNYXA7XG4gICAgICAgIGxvZGFzaC5mbGF0TWFwRGVlcCA9IGZsYXRNYXBEZWVwO1xuICAgICAgICBsb2Rhc2guZmxhdE1hcERlcHRoID0gZmxhdE1hcERlcHRoO1xuICAgICAgICBsb2Rhc2guZmxhdHRlbiA9IGZsYXR0ZW47XG4gICAgICAgIGxvZGFzaC5mbGF0dGVuRGVlcCA9IGZsYXR0ZW5EZWVwO1xuICAgICAgICBsb2Rhc2guZmxhdHRlbkRlcHRoID0gZmxhdHRlbkRlcHRoO1xuICAgICAgICBsb2Rhc2guZmxpcCA9IGZsaXA7XG4gICAgICAgIGxvZGFzaC5mbG93ID0gZmxvdztcbiAgICAgICAgbG9kYXNoLmZsb3dSaWdodCA9IGZsb3dSaWdodDtcbiAgICAgICAgbG9kYXNoLmZyb21QYWlycyA9IGZyb21QYWlycztcbiAgICAgICAgbG9kYXNoLmZ1bmN0aW9ucyA9IGZ1bmN0aW9ucztcbiAgICAgICAgbG9kYXNoLmZ1bmN0aW9uc0luID0gZnVuY3Rpb25zSW47XG4gICAgICAgIGxvZGFzaC5ncm91cEJ5ID0gZ3JvdXBCeTtcbiAgICAgICAgbG9kYXNoLmluaXRpYWwgPSBpbml0aWFsO1xuICAgICAgICBsb2Rhc2guaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uO1xuICAgICAgICBsb2Rhc2guaW50ZXJzZWN0aW9uQnkgPSBpbnRlcnNlY3Rpb25CeTtcbiAgICAgICAgbG9kYXNoLmludGVyc2VjdGlvbldpdGggPSBpbnRlcnNlY3Rpb25XaXRoO1xuICAgICAgICBsb2Rhc2guaW52ZXJ0ID0gaW52ZXJ0O1xuICAgICAgICBsb2Rhc2guaW52ZXJ0QnkgPSBpbnZlcnRCeTtcbiAgICAgICAgbG9kYXNoLmludm9rZU1hcCA9IGludm9rZU1hcDtcbiAgICAgICAgbG9kYXNoLml0ZXJhdGVlID0gaXRlcmF0ZWU7XG4gICAgICAgIGxvZGFzaC5rZXlCeSA9IGtleUJ5O1xuICAgICAgICBsb2Rhc2gua2V5cyA9IGtleXM7XG4gICAgICAgIGxvZGFzaC5rZXlzSW4gPSBrZXlzSW47XG4gICAgICAgIGxvZGFzaC5tYXAgPSBtYXA7XG4gICAgICAgIGxvZGFzaC5tYXBLZXlzID0gbWFwS2V5cztcbiAgICAgICAgbG9kYXNoLm1hcFZhbHVlcyA9IG1hcFZhbHVlcztcbiAgICAgICAgbG9kYXNoLm1hdGNoZXMgPSBtYXRjaGVzO1xuICAgICAgICBsb2Rhc2gubWF0Y2hlc1Byb3BlcnR5ID0gbWF0Y2hlc1Byb3BlcnR5O1xuICAgICAgICBsb2Rhc2gubWVtb2l6ZSA9IG1lbW9pemUyO1xuICAgICAgICBsb2Rhc2gubWVyZ2UgPSBtZXJnZTtcbiAgICAgICAgbG9kYXNoLm1lcmdlV2l0aCA9IG1lcmdlV2l0aDtcbiAgICAgICAgbG9kYXNoLm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgICAgbG9kYXNoLm1ldGhvZE9mID0gbWV0aG9kT2Y7XG4gICAgICAgIGxvZGFzaC5taXhpbiA9IG1peGluO1xuICAgICAgICBsb2Rhc2gubmVnYXRlID0gbmVnYXRlO1xuICAgICAgICBsb2Rhc2gubnRoQXJnID0gbnRoQXJnO1xuICAgICAgICBsb2Rhc2gub21pdCA9IG9taXQ7XG4gICAgICAgIGxvZGFzaC5vbWl0QnkgPSBvbWl0Qnk7XG4gICAgICAgIGxvZGFzaC5vbmNlID0gb25jZTtcbiAgICAgICAgbG9kYXNoLm9yZGVyQnkgPSBvcmRlckJ5O1xuICAgICAgICBsb2Rhc2gub3ZlciA9IG92ZXI7XG4gICAgICAgIGxvZGFzaC5vdmVyQXJncyA9IG92ZXJBcmdzO1xuICAgICAgICBsb2Rhc2gub3ZlckV2ZXJ5ID0gb3ZlckV2ZXJ5O1xuICAgICAgICBsb2Rhc2gub3ZlclNvbWUgPSBvdmVyU29tZTtcbiAgICAgICAgbG9kYXNoLnBhcnRpYWwgPSBwYXJ0aWFsO1xuICAgICAgICBsb2Rhc2gucGFydGlhbFJpZ2h0ID0gcGFydGlhbFJpZ2h0O1xuICAgICAgICBsb2Rhc2gucGFydGl0aW9uID0gcGFydGl0aW9uO1xuICAgICAgICBsb2Rhc2gucGljayA9IHBpY2s7XG4gICAgICAgIGxvZGFzaC5waWNrQnkgPSBwaWNrQnk7XG4gICAgICAgIGxvZGFzaC5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgICAgICBsb2Rhc2gucHJvcGVydHlPZiA9IHByb3BlcnR5T2Y7XG4gICAgICAgIGxvZGFzaC5wdWxsID0gcHVsbDtcbiAgICAgICAgbG9kYXNoLnB1bGxBbGwgPSBwdWxsQWxsO1xuICAgICAgICBsb2Rhc2gucHVsbEFsbEJ5ID0gcHVsbEFsbEJ5O1xuICAgICAgICBsb2Rhc2gucHVsbEFsbFdpdGggPSBwdWxsQWxsV2l0aDtcbiAgICAgICAgbG9kYXNoLnB1bGxBdCA9IHB1bGxBdDtcbiAgICAgICAgbG9kYXNoLnJhbmdlID0gcmFuZ2U7XG4gICAgICAgIGxvZGFzaC5yYW5nZVJpZ2h0ID0gcmFuZ2VSaWdodDtcbiAgICAgICAgbG9kYXNoLnJlYXJnID0gcmVhcmc7XG4gICAgICAgIGxvZGFzaC5yZWplY3QgPSByZWplY3Q7XG4gICAgICAgIGxvZGFzaC5yZW1vdmUgPSByZW1vdmU7XG4gICAgICAgIGxvZGFzaC5yZXN0ID0gcmVzdDtcbiAgICAgICAgbG9kYXNoLnJldmVyc2UgPSByZXZlcnNlO1xuICAgICAgICBsb2Rhc2guc2FtcGxlU2l6ZSA9IHNhbXBsZVNpemU7XG4gICAgICAgIGxvZGFzaC5zZXQgPSBzZXQ7XG4gICAgICAgIGxvZGFzaC5zZXRXaXRoID0gc2V0V2l0aDtcbiAgICAgICAgbG9kYXNoLnNodWZmbGUgPSBzaHVmZmxlO1xuICAgICAgICBsb2Rhc2guc2xpY2UgPSBzbGljZTtcbiAgICAgICAgbG9kYXNoLnNvcnRCeSA9IHNvcnRCeTtcbiAgICAgICAgbG9kYXNoLnNvcnRlZFVuaXEgPSBzb3J0ZWRVbmlxO1xuICAgICAgICBsb2Rhc2guc29ydGVkVW5pcUJ5ID0gc29ydGVkVW5pcUJ5O1xuICAgICAgICBsb2Rhc2guc3BsaXQgPSBzcGxpdDtcbiAgICAgICAgbG9kYXNoLnNwcmVhZCA9IHNwcmVhZDtcbiAgICAgICAgbG9kYXNoLnRhaWwgPSB0YWlsO1xuICAgICAgICBsb2Rhc2gudGFrZSA9IHRha2U7XG4gICAgICAgIGxvZGFzaC50YWtlUmlnaHQgPSB0YWtlUmlnaHQ7XG4gICAgICAgIGxvZGFzaC50YWtlUmlnaHRXaGlsZSA9IHRha2VSaWdodFdoaWxlO1xuICAgICAgICBsb2Rhc2gudGFrZVdoaWxlID0gdGFrZVdoaWxlO1xuICAgICAgICBsb2Rhc2gudGFwID0gdGFwO1xuICAgICAgICBsb2Rhc2gudGhyb3R0bGUgPSB0aHJvdHRsZTtcbiAgICAgICAgbG9kYXNoLnRocnUgPSB0aHJ1O1xuICAgICAgICBsb2Rhc2gudG9BcnJheSA9IHRvQXJyYXk7XG4gICAgICAgIGxvZGFzaC50b1BhaXJzID0gdG9QYWlycztcbiAgICAgICAgbG9kYXNoLnRvUGFpcnNJbiA9IHRvUGFpcnNJbjtcbiAgICAgICAgbG9kYXNoLnRvUGF0aCA9IHRvUGF0aDtcbiAgICAgICAgbG9kYXNoLnRvUGxhaW5PYmplY3QgPSB0b1BsYWluT2JqZWN0O1xuICAgICAgICBsb2Rhc2gudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgICAgICBsb2Rhc2gudW5hcnkgPSB1bmFyeTtcbiAgICAgICAgbG9kYXNoLnVuaW9uID0gdW5pb247XG4gICAgICAgIGxvZGFzaC51bmlvbkJ5ID0gdW5pb25CeTtcbiAgICAgICAgbG9kYXNoLnVuaW9uV2l0aCA9IHVuaW9uV2l0aDtcbiAgICAgICAgbG9kYXNoLnVuaXEgPSB1bmlxO1xuICAgICAgICBsb2Rhc2gudW5pcUJ5ID0gdW5pcUJ5O1xuICAgICAgICBsb2Rhc2gudW5pcVdpdGggPSB1bmlxV2l0aDtcbiAgICAgICAgbG9kYXNoLnVuc2V0ID0gdW5zZXQ7XG4gICAgICAgIGxvZGFzaC51bnppcCA9IHVuemlwO1xuICAgICAgICBsb2Rhc2gudW56aXBXaXRoID0gdW56aXBXaXRoO1xuICAgICAgICBsb2Rhc2gudXBkYXRlID0gdXBkYXRlO1xuICAgICAgICBsb2Rhc2gudXBkYXRlV2l0aCA9IHVwZGF0ZVdpdGg7XG4gICAgICAgIGxvZGFzaC52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgICAgIGxvZGFzaC52YWx1ZXNJbiA9IHZhbHVlc0luO1xuICAgICAgICBsb2Rhc2gud2l0aG91dCA9IHdpdGhvdXQ7XG4gICAgICAgIGxvZGFzaC53b3JkcyA9IHdvcmRzO1xuICAgICAgICBsb2Rhc2gud3JhcCA9IHdyYXA7XG4gICAgICAgIGxvZGFzaC54b3IgPSB4b3I7XG4gICAgICAgIGxvZGFzaC54b3JCeSA9IHhvckJ5O1xuICAgICAgICBsb2Rhc2gueG9yV2l0aCA9IHhvcldpdGg7XG4gICAgICAgIGxvZGFzaC56aXAgPSB6aXA7XG4gICAgICAgIGxvZGFzaC56aXBPYmplY3QgPSB6aXBPYmplY3Q7XG4gICAgICAgIGxvZGFzaC56aXBPYmplY3REZWVwID0gemlwT2JqZWN0RGVlcDtcbiAgICAgICAgbG9kYXNoLnppcFdpdGggPSB6aXBXaXRoO1xuICAgICAgICBsb2Rhc2guZW50cmllcyA9IHRvUGFpcnM7XG4gICAgICAgIGxvZGFzaC5lbnRyaWVzSW4gPSB0b1BhaXJzSW47XG4gICAgICAgIGxvZGFzaC5leHRlbmQgPSBhc3NpZ25JbjtcbiAgICAgICAgbG9kYXNoLmV4dGVuZFdpdGggPSBhc3NpZ25JbldpdGg7XG4gICAgICAgIG1peGluKGxvZGFzaCwgbG9kYXNoKTtcbiAgICAgICAgbG9kYXNoLmFkZCA9IGFkZDtcbiAgICAgICAgbG9kYXNoLmF0dGVtcHQgPSBhdHRlbXB0O1xuICAgICAgICBsb2Rhc2guY2FtZWxDYXNlID0gY2FtZWxDYXNlO1xuICAgICAgICBsb2Rhc2guY2FwaXRhbGl6ZSA9IGNhcGl0YWxpemU7XG4gICAgICAgIGxvZGFzaC5jZWlsID0gY2VpbDtcbiAgICAgICAgbG9kYXNoLmNsYW1wID0gY2xhbXA7XG4gICAgICAgIGxvZGFzaC5jbG9uZSA9IGNsb25lO1xuICAgICAgICBsb2Rhc2guY2xvbmVEZWVwID0gY2xvbmVEZWVwO1xuICAgICAgICBsb2Rhc2guY2xvbmVEZWVwV2l0aCA9IGNsb25lRGVlcFdpdGg7XG4gICAgICAgIGxvZGFzaC5jbG9uZVdpdGggPSBjbG9uZVdpdGg7XG4gICAgICAgIGxvZGFzaC5jb25mb3Jtc1RvID0gY29uZm9ybXNUbztcbiAgICAgICAgbG9kYXNoLmRlYnVyciA9IGRlYnVycjtcbiAgICAgICAgbG9kYXNoLmRlZmF1bHRUbyA9IGRlZmF1bHRUbztcbiAgICAgICAgbG9kYXNoLmRpdmlkZSA9IGRpdmlkZTtcbiAgICAgICAgbG9kYXNoLmVuZHNXaXRoID0gZW5kc1dpdGg7XG4gICAgICAgIGxvZGFzaC5lcSA9IGVxO1xuICAgICAgICBsb2Rhc2guZXNjYXBlID0gZXNjYXBlO1xuICAgICAgICBsb2Rhc2guZXNjYXBlUmVnRXhwID0gZXNjYXBlUmVnRXhwO1xuICAgICAgICBsb2Rhc2guZXZlcnkgPSBldmVyeTtcbiAgICAgICAgbG9kYXNoLmZpbmQgPSBmaW5kO1xuICAgICAgICBsb2Rhc2guZmluZEluZGV4ID0gZmluZEluZGV4O1xuICAgICAgICBsb2Rhc2guZmluZEtleSA9IGZpbmRLZXk7XG4gICAgICAgIGxvZGFzaC5maW5kTGFzdCA9IGZpbmRMYXN0O1xuICAgICAgICBsb2Rhc2guZmluZExhc3RJbmRleCA9IGZpbmRMYXN0SW5kZXg7XG4gICAgICAgIGxvZGFzaC5maW5kTGFzdEtleSA9IGZpbmRMYXN0S2V5O1xuICAgICAgICBsb2Rhc2guZmxvb3IgPSBmbG9vcjtcbiAgICAgICAgbG9kYXNoLmZvckVhY2ggPSBmb3JFYWNoO1xuICAgICAgICBsb2Rhc2guZm9yRWFjaFJpZ2h0ID0gZm9yRWFjaFJpZ2h0O1xuICAgICAgICBsb2Rhc2guZm9ySW4gPSBmb3JJbjtcbiAgICAgICAgbG9kYXNoLmZvckluUmlnaHQgPSBmb3JJblJpZ2h0O1xuICAgICAgICBsb2Rhc2guZm9yT3duID0gZm9yT3duO1xuICAgICAgICBsb2Rhc2guZm9yT3duUmlnaHQgPSBmb3JPd25SaWdodDtcbiAgICAgICAgbG9kYXNoLmdldCA9IGdldDtcbiAgICAgICAgbG9kYXNoLmd0ID0gZ3Q7XG4gICAgICAgIGxvZGFzaC5ndGUgPSBndGU7XG4gICAgICAgIGxvZGFzaC5oYXMgPSBoYXM7XG4gICAgICAgIGxvZGFzaC5oYXNJbiA9IGhhc0luO1xuICAgICAgICBsb2Rhc2guaGVhZCA9IGhlYWQ7XG4gICAgICAgIGxvZGFzaC5pZGVudGl0eSA9IGlkZW50aXR5O1xuICAgICAgICBsb2Rhc2guaW5jbHVkZXMgPSBpbmNsdWRlcztcbiAgICAgICAgbG9kYXNoLmluZGV4T2YgPSBpbmRleE9mO1xuICAgICAgICBsb2Rhc2guaW5SYW5nZSA9IGluUmFuZ2U7XG4gICAgICAgIGxvZGFzaC5pbnZva2UgPSBpbnZva2U7XG4gICAgICAgIGxvZGFzaC5pc0FyZ3VtZW50cyA9IGlzQXJndW1lbnRzO1xuICAgICAgICBsb2Rhc2guaXNBcnJheSA9IGlzQXJyYXk7XG4gICAgICAgIGxvZGFzaC5pc0FycmF5QnVmZmVyID0gaXNBcnJheUJ1ZmZlcjtcbiAgICAgICAgbG9kYXNoLmlzQXJyYXlMaWtlID0gaXNBcnJheUxpa2U7XG4gICAgICAgIGxvZGFzaC5pc0FycmF5TGlrZU9iamVjdCA9IGlzQXJyYXlMaWtlT2JqZWN0O1xuICAgICAgICBsb2Rhc2guaXNCb29sZWFuID0gaXNCb29sZWFuO1xuICAgICAgICBsb2Rhc2guaXNCdWZmZXIgPSBpc0J1ZmZlcjtcbiAgICAgICAgbG9kYXNoLmlzRGF0ZSA9IGlzRGF0ZTtcbiAgICAgICAgbG9kYXNoLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbiAgICAgICAgbG9kYXNoLmlzRW1wdHkgPSBpc0VtcHR5O1xuICAgICAgICBsb2Rhc2guaXNFcXVhbCA9IGlzRXF1YWw7XG4gICAgICAgIGxvZGFzaC5pc0VxdWFsV2l0aCA9IGlzRXF1YWxXaXRoO1xuICAgICAgICBsb2Rhc2guaXNFcnJvciA9IGlzRXJyb3I7XG4gICAgICAgIGxvZGFzaC5pc0Zpbml0ZSA9IGlzRmluaXRlMjtcbiAgICAgICAgbG9kYXNoLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuICAgICAgICBsb2Rhc2guaXNJbnRlZ2VyID0gaXNJbnRlZ2VyO1xuICAgICAgICBsb2Rhc2guaXNMZW5ndGggPSBpc0xlbmd0aDtcbiAgICAgICAgbG9kYXNoLmlzTWFwID0gaXNNYXA7XG4gICAgICAgIGxvZGFzaC5pc01hdGNoID0gaXNNYXRjaDtcbiAgICAgICAgbG9kYXNoLmlzTWF0Y2hXaXRoID0gaXNNYXRjaFdpdGg7XG4gICAgICAgIGxvZGFzaC5pc05hTiA9IGlzTmFOMjtcbiAgICAgICAgbG9kYXNoLmlzTmF0aXZlID0gaXNOYXRpdmU7XG4gICAgICAgIGxvZGFzaC5pc05pbCA9IGlzTmlsO1xuICAgICAgICBsb2Rhc2guaXNOdWxsID0gaXNOdWxsO1xuICAgICAgICBsb2Rhc2guaXNOdW1iZXIgPSBpc051bWJlcjtcbiAgICAgICAgbG9kYXNoLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG4gICAgICAgIGxvZGFzaC5pc09iamVjdExpa2UgPSBpc09iamVjdExpa2U7XG4gICAgICAgIGxvZGFzaC5pc1BsYWluT2JqZWN0ID0gaXNQbGFpbk9iamVjdDtcbiAgICAgICAgbG9kYXNoLmlzUmVnRXhwID0gaXNSZWdFeHA7XG4gICAgICAgIGxvZGFzaC5pc1NhZmVJbnRlZ2VyID0gaXNTYWZlSW50ZWdlcjtcbiAgICAgICAgbG9kYXNoLmlzU2V0ID0gaXNTZXQ7XG4gICAgICAgIGxvZGFzaC5pc1N0cmluZyA9IGlzU3RyaW5nO1xuICAgICAgICBsb2Rhc2guaXNTeW1ib2wgPSBpc1N5bWJvbDtcbiAgICAgICAgbG9kYXNoLmlzVHlwZWRBcnJheSA9IGlzVHlwZWRBcnJheTtcbiAgICAgICAgbG9kYXNoLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG4gICAgICAgIGxvZGFzaC5pc1dlYWtNYXAgPSBpc1dlYWtNYXA7XG4gICAgICAgIGxvZGFzaC5pc1dlYWtTZXQgPSBpc1dlYWtTZXQ7XG4gICAgICAgIGxvZGFzaC5qb2luID0gam9pbjtcbiAgICAgICAgbG9kYXNoLmtlYmFiQ2FzZSA9IGtlYmFiQ2FzZTtcbiAgICAgICAgbG9kYXNoLmxhc3QgPSBsYXN0O1xuICAgICAgICBsb2Rhc2gubGFzdEluZGV4T2YgPSBsYXN0SW5kZXhPZjtcbiAgICAgICAgbG9kYXNoLmxvd2VyQ2FzZSA9IGxvd2VyQ2FzZTtcbiAgICAgICAgbG9kYXNoLmxvd2VyRmlyc3QgPSBsb3dlckZpcnN0O1xuICAgICAgICBsb2Rhc2gubHQgPSBsdDtcbiAgICAgICAgbG9kYXNoLmx0ZSA9IGx0ZTtcbiAgICAgICAgbG9kYXNoLm1heCA9IG1heDtcbiAgICAgICAgbG9kYXNoLm1heEJ5ID0gbWF4Qnk7XG4gICAgICAgIGxvZGFzaC5tZWFuID0gbWVhbjtcbiAgICAgICAgbG9kYXNoLm1lYW5CeSA9IG1lYW5CeTtcbiAgICAgICAgbG9kYXNoLm1pbiA9IG1pbjtcbiAgICAgICAgbG9kYXNoLm1pbkJ5ID0gbWluQnk7XG4gICAgICAgIGxvZGFzaC5zdHViQXJyYXkgPSBzdHViQXJyYXk7XG4gICAgICAgIGxvZGFzaC5zdHViRmFsc2UgPSBzdHViRmFsc2U7XG4gICAgICAgIGxvZGFzaC5zdHViT2JqZWN0ID0gc3R1Yk9iamVjdDtcbiAgICAgICAgbG9kYXNoLnN0dWJTdHJpbmcgPSBzdHViU3RyaW5nO1xuICAgICAgICBsb2Rhc2guc3R1YlRydWUgPSBzdHViVHJ1ZTtcbiAgICAgICAgbG9kYXNoLm11bHRpcGx5ID0gbXVsdGlwbHk7XG4gICAgICAgIGxvZGFzaC5udGggPSBudGg7XG4gICAgICAgIGxvZGFzaC5ub0NvbmZsaWN0ID0gbm9Db25mbGljdDtcbiAgICAgICAgbG9kYXNoLm5vb3AgPSBub29wO1xuICAgICAgICBsb2Rhc2gubm93ID0gbm93O1xuICAgICAgICBsb2Rhc2gucGFkID0gcGFkO1xuICAgICAgICBsb2Rhc2gucGFkRW5kID0gcGFkRW5kO1xuICAgICAgICBsb2Rhc2gucGFkU3RhcnQgPSBwYWRTdGFydDtcbiAgICAgICAgbG9kYXNoLnBhcnNlSW50ID0gcGFyc2VJbnQyO1xuICAgICAgICBsb2Rhc2gucmFuZG9tID0gcmFuZG9tO1xuICAgICAgICBsb2Rhc2gucmVkdWNlID0gcmVkdWNlO1xuICAgICAgICBsb2Rhc2gucmVkdWNlUmlnaHQgPSByZWR1Y2VSaWdodDtcbiAgICAgICAgbG9kYXNoLnJlcGVhdCA9IHJlcGVhdDtcbiAgICAgICAgbG9kYXNoLnJlcGxhY2UgPSByZXBsYWNlO1xuICAgICAgICBsb2Rhc2gucmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICBsb2Rhc2gucm91bmQgPSByb3VuZDtcbiAgICAgICAgbG9kYXNoLnJ1bkluQ29udGV4dCA9IHJ1bkluQ29udGV4dDI7XG4gICAgICAgIGxvZGFzaC5zYW1wbGUgPSBzYW1wbGU7XG4gICAgICAgIGxvZGFzaC5zaXplID0gc2l6ZTtcbiAgICAgICAgbG9kYXNoLnNuYWtlQ2FzZSA9IHNuYWtlQ2FzZTtcbiAgICAgICAgbG9kYXNoLnNvbWUgPSBzb21lO1xuICAgICAgICBsb2Rhc2guc29ydGVkSW5kZXggPSBzb3J0ZWRJbmRleDtcbiAgICAgICAgbG9kYXNoLnNvcnRlZEluZGV4QnkgPSBzb3J0ZWRJbmRleEJ5O1xuICAgICAgICBsb2Rhc2guc29ydGVkSW5kZXhPZiA9IHNvcnRlZEluZGV4T2Y7XG4gICAgICAgIGxvZGFzaC5zb3J0ZWRMYXN0SW5kZXggPSBzb3J0ZWRMYXN0SW5kZXg7XG4gICAgICAgIGxvZGFzaC5zb3J0ZWRMYXN0SW5kZXhCeSA9IHNvcnRlZExhc3RJbmRleEJ5O1xuICAgICAgICBsb2Rhc2guc29ydGVkTGFzdEluZGV4T2YgPSBzb3J0ZWRMYXN0SW5kZXhPZjtcbiAgICAgICAgbG9kYXNoLnN0YXJ0Q2FzZSA9IHN0YXJ0Q2FzZTtcbiAgICAgICAgbG9kYXNoLnN0YXJ0c1dpdGggPSBzdGFydHNXaXRoO1xuICAgICAgICBsb2Rhc2guc3VidHJhY3QgPSBzdWJ0cmFjdDtcbiAgICAgICAgbG9kYXNoLnN1bSA9IHN1bTtcbiAgICAgICAgbG9kYXNoLnN1bUJ5ID0gc3VtQnk7XG4gICAgICAgIGxvZGFzaC50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgICAgICBsb2Rhc2gudGltZXMgPSB0aW1lcztcbiAgICAgICAgbG9kYXNoLnRvRmluaXRlID0gdG9GaW5pdGU7XG4gICAgICAgIGxvZGFzaC50b0ludGVnZXIgPSB0b0ludGVnZXI7XG4gICAgICAgIGxvZGFzaC50b0xlbmd0aCA9IHRvTGVuZ3RoO1xuICAgICAgICBsb2Rhc2gudG9Mb3dlciA9IHRvTG93ZXI7XG4gICAgICAgIGxvZGFzaC50b051bWJlciA9IHRvTnVtYmVyO1xuICAgICAgICBsb2Rhc2gudG9TYWZlSW50ZWdlciA9IHRvU2FmZUludGVnZXI7XG4gICAgICAgIGxvZGFzaC50b1N0cmluZyA9IHRvU3RyaW5nO1xuICAgICAgICBsb2Rhc2gudG9VcHBlciA9IHRvVXBwZXI7XG4gICAgICAgIGxvZGFzaC50cmltID0gdHJpbTtcbiAgICAgICAgbG9kYXNoLnRyaW1FbmQgPSB0cmltRW5kO1xuICAgICAgICBsb2Rhc2gudHJpbVN0YXJ0ID0gdHJpbVN0YXJ0O1xuICAgICAgICBsb2Rhc2gudHJ1bmNhdGUgPSB0cnVuY2F0ZTtcbiAgICAgICAgbG9kYXNoLnVuZXNjYXBlID0gdW5lc2NhcGU7XG4gICAgICAgIGxvZGFzaC51bmlxdWVJZCA9IHVuaXF1ZUlkO1xuICAgICAgICBsb2Rhc2gudXBwZXJDYXNlID0gdXBwZXJDYXNlO1xuICAgICAgICBsb2Rhc2gudXBwZXJGaXJzdCA9IHVwcGVyRmlyc3Q7XG4gICAgICAgIGxvZGFzaC5lYWNoID0gZm9yRWFjaDtcbiAgICAgICAgbG9kYXNoLmVhY2hSaWdodCA9IGZvckVhY2hSaWdodDtcbiAgICAgICAgbG9kYXNoLmZpcnN0ID0gaGVhZDtcbiAgICAgICAgbWl4aW4obG9kYXNoLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgc291cmNlID0ge307XG4gICAgICAgICAgYmFzZUZvck93bihsb2Rhc2gsIGZ1bmN0aW9uKGZ1bmMsIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChsb2Rhc2gucHJvdG90eXBlLCBtZXRob2ROYW1lKSkge1xuICAgICAgICAgICAgICBzb3VyY2VbbWV0aG9kTmFtZV0gPSBmdW5jO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICAgIH0oKSwgeyBcImNoYWluXCI6IGZhbHNlIH0pO1xuICAgICAgICBsb2Rhc2guVkVSU0lPTiA9IFZFUlNJT047XG4gICAgICAgIGFycmF5RWFjaChbXCJiaW5kXCIsIFwiYmluZEtleVwiLCBcImN1cnJ5XCIsIFwiY3VycnlSaWdodFwiLCBcInBhcnRpYWxcIiwgXCJwYXJ0aWFsUmlnaHRcIl0sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgICBsb2Rhc2hbbWV0aG9kTmFtZV0ucGxhY2Vob2xkZXIgPSBsb2Rhc2g7XG4gICAgICAgIH0pO1xuICAgICAgICBhcnJheUVhY2goW1wiZHJvcFwiLCBcInRha2VcIl0sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24obikge1xuICAgICAgICAgICAgbiA9IG4gPT09IHVuZGVmaW5lZDIgPyAxIDogbmF0aXZlTWF4KHRvSW50ZWdlcihuKSwgMCk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0MiA9IHRoaXMuX19maWx0ZXJlZF9fICYmICFpbmRleCA/IG5ldyBMYXp5V3JhcHBlcih0aGlzKSA6IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQyLl9fZmlsdGVyZWRfXykge1xuICAgICAgICAgICAgICByZXN1bHQyLl9fdGFrZUNvdW50X18gPSBuYXRpdmVNaW4obiwgcmVzdWx0Mi5fX3Rha2VDb3VudF9fKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIuX192aWV3c19fLnB1c2goe1xuICAgICAgICAgICAgICAgIFwic2l6ZVwiOiBuYXRpdmVNaW4obiwgTUFYX0FSUkFZX0xFTkdUSCksXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IG1ldGhvZE5hbWUgKyAocmVzdWx0Mi5fX2Rpcl9fIDwgMCA/IFwiUmlnaHRcIiA6IFwiXCIpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZSArIFwiUmlnaHRcIl0gPSBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKClbbWV0aG9kTmFtZV0obikucmV2ZXJzZSgpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBhcnJheUVhY2goW1wiZmlsdGVyXCIsIFwibWFwXCIsIFwidGFrZVdoaWxlXCJdLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgICAgIHZhciB0eXBlID0gaW5kZXggKyAxLCBpc0ZpbHRlciA9IHR5cGUgPT0gTEFaWV9GSUxURVJfRkxBRyB8fCB0eXBlID09IExBWllfV0hJTEVfRkxBRztcbiAgICAgICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbihpdGVyYXRlZTIpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQyID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgcmVzdWx0Mi5fX2l0ZXJhdGVlc19fLnB1c2goe1xuICAgICAgICAgICAgICBcIml0ZXJhdGVlXCI6IGdldEl0ZXJhdGVlKGl0ZXJhdGVlMiwgMyksXG4gICAgICAgICAgICAgIFwidHlwZVwiOiB0eXBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlc3VsdDIuX19maWx0ZXJlZF9fID0gcmVzdWx0Mi5fX2ZpbHRlcmVkX18gfHwgaXNGaWx0ZXI7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgYXJyYXlFYWNoKFtcImhlYWRcIiwgXCJsYXN0XCJdLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgICAgIHZhciB0YWtlTmFtZSA9IFwidGFrZVwiICsgKGluZGV4ID8gXCJSaWdodFwiIDogXCJcIik7XG4gICAgICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1t0YWtlTmFtZV0oMSkudmFsdWUoKVswXTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgYXJyYXlFYWNoKFtcImluaXRpYWxcIiwgXCJ0YWlsXCJdLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgICAgIHZhciBkcm9wTmFtZSA9IFwiZHJvcFwiICsgKGluZGV4ID8gXCJcIiA6IFwiUmlnaHRcIik7XG4gICAgICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fX2ZpbHRlcmVkX18gPyBuZXcgTGF6eVdyYXBwZXIodGhpcykgOiB0aGlzW2Ryb3BOYW1lXSgxKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmNvbXBhY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIoaWRlbnRpdHkpO1xuICAgICAgICB9O1xuICAgICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlcihwcmVkaWNhdGUpLmhlYWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmZpbmRMYXN0ID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpLmZpbmQocHJlZGljYXRlKTtcbiAgICAgICAgfTtcbiAgICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmludm9rZU1hcCA9IGJhc2VSZXN0KGZ1bmN0aW9uKHBhdGgsIGFyZ3MpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHBhdGggPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExhenlXcmFwcGVyKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBiYXNlSW52b2tlKHZhbHVlLCBwYXRoLCBhcmdzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5yZWplY3QgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIobmVnYXRlKGdldEl0ZXJhdGVlKHByZWRpY2F0ZSkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgICAgIHN0YXJ0ID0gdG9JbnRlZ2VyKHN0YXJ0KTtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IHRoaXM7XG4gICAgICAgICAgaWYgKHJlc3VsdDIuX19maWx0ZXJlZF9fICYmIChzdGFydCA+IDAgfHwgZW5kIDwgMCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGF6eVdyYXBwZXIocmVzdWx0Mik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSByZXN1bHQyLnRha2VSaWdodCgtc3RhcnQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhcnQpIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSByZXN1bHQyLmRyb3Aoc3RhcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZW5kICE9PSB1bmRlZmluZWQyKSB7XG4gICAgICAgICAgICBlbmQgPSB0b0ludGVnZXIoZW5kKTtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBlbmQgPCAwID8gcmVzdWx0Mi5kcm9wUmlnaHQoLWVuZCkgOiByZXN1bHQyLnRha2UoZW5kIC0gc3RhcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfTtcbiAgICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnRha2VSaWdodFdoaWxlID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpLnRha2VXaGlsZShwcmVkaWNhdGUpLnJldmVyc2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50YWtlKE1BWF9BUlJBWV9MRU5HVEgpO1xuICAgICAgICB9O1xuICAgICAgICBiYXNlRm9yT3duKExhenlXcmFwcGVyLnByb3RvdHlwZSwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgICAgIHZhciBjaGVja0l0ZXJhdGVlID0gL14oPzpmaWx0ZXJ8ZmluZHxtYXB8cmVqZWN0KXxXaGlsZSQvLnRlc3QobWV0aG9kTmFtZSksIGlzVGFrZXIgPSAvXig/OmhlYWR8bGFzdCkkLy50ZXN0KG1ldGhvZE5hbWUpLCBsb2Rhc2hGdW5jID0gbG9kYXNoW2lzVGFrZXIgPyBcInRha2VcIiArIChtZXRob2ROYW1lID09IFwibGFzdFwiID8gXCJSaWdodFwiIDogXCJcIikgOiBtZXRob2ROYW1lXSwgcmV0VW53cmFwcGVkID0gaXNUYWtlciB8fCAvXmZpbmQvLnRlc3QobWV0aG9kTmFtZSk7XG4gICAgICAgICAgaWYgKCFsb2Rhc2hGdW5jKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX193cmFwcGVkX18sIGFyZ3MgPSBpc1Rha2VyID8gWzFdIDogYXJndW1lbnRzLCBpc0xhenkgPSB2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyLCBpdGVyYXRlZTIgPSBhcmdzWzBdLCB1c2VMYXp5ID0gaXNMYXp5IHx8IGlzQXJyYXkodmFsdWUpO1xuICAgICAgICAgICAgdmFyIGludGVyY2VwdG9yID0gZnVuY3Rpb24odmFsdWUyKSB7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQzID0gbG9kYXNoRnVuYy5hcHBseShsb2Rhc2gsIGFycmF5UHVzaChbdmFsdWUyXSwgYXJncykpO1xuICAgICAgICAgICAgICByZXR1cm4gaXNUYWtlciAmJiBjaGFpbkFsbCA/IHJlc3VsdDNbMF0gOiByZXN1bHQzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh1c2VMYXp5ICYmIGNoZWNrSXRlcmF0ZWUgJiYgdHlwZW9mIGl0ZXJhdGVlMiA9PSBcImZ1bmN0aW9uXCIgJiYgaXRlcmF0ZWUyLmxlbmd0aCAhPSAxKSB7XG4gICAgICAgICAgICAgIGlzTGF6eSA9IHVzZUxhenkgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjaGFpbkFsbCA9IHRoaXMuX19jaGFpbl9fLCBpc0h5YnJpZCA9ICEhdGhpcy5fX2FjdGlvbnNfXy5sZW5ndGgsIGlzVW53cmFwcGVkID0gcmV0VW53cmFwcGVkICYmICFjaGFpbkFsbCwgb25seUxhenkgPSBpc0xhenkgJiYgIWlzSHlicmlkO1xuICAgICAgICAgICAgaWYgKCFyZXRVbndyYXBwZWQgJiYgdXNlTGF6eSkge1xuICAgICAgICAgICAgICB2YWx1ZSA9IG9ubHlMYXp5ID8gdmFsdWUgOiBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQyID0gZnVuYy5hcHBseSh2YWx1ZSwgYXJncyk7XG4gICAgICAgICAgICAgIHJlc3VsdDIuX19hY3Rpb25zX18ucHVzaCh7IFwiZnVuY1wiOiB0aHJ1LCBcImFyZ3NcIjogW2ludGVyY2VwdG9yXSwgXCJ0aGlzQXJnXCI6IHVuZGVmaW5lZDIgfSk7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcihyZXN1bHQyLCBjaGFpbkFsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNVbndyYXBwZWQgJiYgb25seUxhenkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQyID0gdGhpcy50aHJ1KGludGVyY2VwdG9yKTtcbiAgICAgICAgICAgIHJldHVybiBpc1Vud3JhcHBlZCA/IGlzVGFrZXIgPyByZXN1bHQyLnZhbHVlKClbMF0gOiByZXN1bHQyLnZhbHVlKCkgOiByZXN1bHQyO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBhcnJheUVhY2goW1wicG9wXCIsIFwicHVzaFwiLCBcInNoaWZ0XCIsIFwic29ydFwiLCBcInNwbGljZVwiLCBcInVuc2hpZnRcIl0sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgICB2YXIgZnVuYyA9IGFycmF5UHJvdG9bbWV0aG9kTmFtZV0sIGNoYWluTmFtZSA9IC9eKD86cHVzaHxzb3J0fHVuc2hpZnQpJC8udGVzdChtZXRob2ROYW1lKSA/IFwidGFwXCIgOiBcInRocnVcIiwgcmV0VW53cmFwcGVkID0gL14oPzpwb3B8c2hpZnQpJC8udGVzdChtZXRob2ROYW1lKTtcbiAgICAgICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIGlmIChyZXRVbndyYXBwZWQgJiYgIXRoaXMuX19jaGFpbl9fKSB7XG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWUoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFtdLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzW2NoYWluTmFtZV0oZnVuY3Rpb24odmFsdWUyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KGlzQXJyYXkodmFsdWUyKSA/IHZhbHVlMiA6IFtdLCBhcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBiYXNlRm9yT3duKExhenlXcmFwcGVyLnByb3RvdHlwZSwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgICAgIHZhciBsb2Rhc2hGdW5jID0gbG9kYXNoW21ldGhvZE5hbWVdO1xuICAgICAgICAgIGlmIChsb2Rhc2hGdW5jKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gbG9kYXNoRnVuYy5uYW1lICsgXCJcIjtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChyZWFsTmFtZXMsIGtleSkpIHtcbiAgICAgICAgICAgICAgcmVhbE5hbWVzW2tleV0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWxOYW1lc1trZXldLnB1c2goeyBcIm5hbWVcIjogbWV0aG9kTmFtZSwgXCJmdW5jXCI6IGxvZGFzaEZ1bmMgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmVhbE5hbWVzW2NyZWF0ZUh5YnJpZCh1bmRlZmluZWQyLCBXUkFQX0JJTkRfS0VZX0ZMQUcpLm5hbWVdID0gW3tcbiAgICAgICAgICBcIm5hbWVcIjogXCJ3cmFwcGVyXCIsXG4gICAgICAgICAgXCJmdW5jXCI6IHVuZGVmaW5lZDJcbiAgICAgICAgfV07XG4gICAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5jbG9uZSA9IGxhenlDbG9uZTtcbiAgICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnJldmVyc2UgPSBsYXp5UmV2ZXJzZTtcbiAgICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnZhbHVlID0gbGF6eVZhbHVlO1xuICAgICAgICBsb2Rhc2gucHJvdG90eXBlLmF0ID0gd3JhcHBlckF0O1xuICAgICAgICBsb2Rhc2gucHJvdG90eXBlLmNoYWluID0gd3JhcHBlckNoYWluO1xuICAgICAgICBsb2Rhc2gucHJvdG90eXBlLmNvbW1pdCA9IHdyYXBwZXJDb21taXQ7XG4gICAgICAgIGxvZGFzaC5wcm90b3R5cGUubmV4dCA9IHdyYXBwZXJOZXh0O1xuICAgICAgICBsb2Rhc2gucHJvdG90eXBlLnBsYW50ID0gd3JhcHBlclBsYW50O1xuICAgICAgICBsb2Rhc2gucHJvdG90eXBlLnJldmVyc2UgPSB3cmFwcGVyUmV2ZXJzZTtcbiAgICAgICAgbG9kYXNoLnByb3RvdHlwZS50b0pTT04gPSBsb2Rhc2gucHJvdG90eXBlLnZhbHVlT2YgPSBsb2Rhc2gucHJvdG90eXBlLnZhbHVlID0gd3JhcHBlclZhbHVlO1xuICAgICAgICBsb2Rhc2gucHJvdG90eXBlLmZpcnN0ID0gbG9kYXNoLnByb3RvdHlwZS5oZWFkO1xuICAgICAgICBpZiAoc3ltSXRlcmF0b3IpIHtcbiAgICAgICAgICBsb2Rhc2gucHJvdG90eXBlW3N5bUl0ZXJhdG9yXSA9IHdyYXBwZXJUb0l0ZXJhdG9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2Rhc2g7XG4gICAgICB9O1xuICAgICAgdmFyIF8gPSBydW5JbkNvbnRleHQoKTtcbiAgICAgIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PSBcIm9iamVjdFwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgcm9vdC5fID0gXztcbiAgICAgICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBfO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoZnJlZU1vZHVsZSkge1xuICAgICAgICAoZnJlZU1vZHVsZS5leHBvcnRzID0gXykuXyA9IF87XG4gICAgICAgIGZyZWVFeHBvcnRzLl8gPSBfO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5fID0gXztcbiAgICAgIH1cbiAgICB9KS5jYWxsKGV4cG9ydHMpO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2lvdGEtYXJyYXkvaW90YS5qc1xudmFyIHJlcXVpcmVfaW90YSA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy9pb3RhLWFycmF5L2lvdGEuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBmdW5jdGlvbiBpb3RhKG4pIHtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkobik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICByZXN1bHRbaV0gPSBpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpb3RhO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qc1xudmFyIHJlcXVpcmVfaXNfYnVmZmVyID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgKGlzQnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikgfHwgISFvYmouX2lzQnVmZmVyKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGlzQnVmZmVyKG9iaikge1xuICAgICAgcmV0dXJuICEhb2JqLmNvbnN0cnVjdG9yICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNTbG93QnVmZmVyKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmoucmVhZEZsb2F0TEUgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygb2JqLnNsaWNlID09PSBcImZ1bmN0aW9uXCIgJiYgaXNCdWZmZXIob2JqLnNsaWNlKDAsIDApKTtcbiAgICB9XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvbmRhcnJheS9uZGFycmF5LmpzXG52YXIgcmVxdWlyZV9uZGFycmF5ID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzL25kYXJyYXkvbmRhcnJheS5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIHZhciBpb3RhID0gcmVxdWlyZV9pb3RhKCk7XG4gICAgdmFyIGlzQnVmZmVyID0gcmVxdWlyZV9pc19idWZmZXIoKTtcbiAgICB2YXIgaGFzVHlwZWRBcnJheXMgPSB0eXBlb2YgRmxvYXQ2NEFycmF5ICE9PSBcInVuZGVmaW5lZFwiO1xuICAgIGZ1bmN0aW9uIGNvbXBhcmUxc3QoYSwgYikge1xuICAgICAgcmV0dXJuIGFbMF0gLSBiWzBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvcmRlcigpIHtcbiAgICAgIHZhciBzdHJpZGUgPSB0aGlzLnN0cmlkZTtcbiAgICAgIHZhciB0ZXJtcyA9IG5ldyBBcnJheShzdHJpZGUubGVuZ3RoKTtcbiAgICAgIHZhciBpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHRlcm1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHRlcm1zW2ldID0gW01hdGguYWJzKHN0cmlkZVtpXSksIGldO1xuICAgICAgfVxuICAgICAgdGVybXMuc29ydChjb21wYXJlMXN0KTtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkodGVybXMubGVuZ3RoKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcmVzdWx0W2ldID0gdGVybXNbaV1bMV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21waWxlQ29uc3RydWN0b3IoZHR5cGUsIGRpbWVuc2lvbikge1xuICAgICAgdmFyIGNsYXNzTmFtZSA9IFtcIlZpZXdcIiwgZGltZW5zaW9uLCBcImRcIiwgZHR5cGVdLmpvaW4oXCJcIik7XG4gICAgICBpZiAoZGltZW5zaW9uIDwgMCkge1xuICAgICAgICBjbGFzc05hbWUgPSBcIlZpZXdfTmlsXCIgKyBkdHlwZTtcbiAgICAgIH1cbiAgICAgIHZhciB1c2VHZXR0ZXJzID0gZHR5cGUgPT09IFwiZ2VuZXJpY1wiO1xuICAgICAgaWYgKGRpbWVuc2lvbiA9PT0gLTEpIHtcbiAgICAgICAgdmFyIGNvZGUgPSBcImZ1bmN0aW9uIFwiICsgY2xhc3NOYW1lICsgXCIoYSl7dGhpcy5kYXRhPWE7fTt2YXIgcHJvdG89XCIgKyBjbGFzc05hbWUgKyBcIi5wcm90b3R5cGU7cHJvdG8uZHR5cGU9J1wiICsgZHR5cGUgKyBcIic7cHJvdG8uaW5kZXg9ZnVuY3Rpb24oKXtyZXR1cm4gLTF9O3Byb3RvLnNpemU9MDtwcm90by5kaW1lbnNpb249LTE7cHJvdG8uc2hhcGU9cHJvdG8uc3RyaWRlPXByb3RvLm9yZGVyPVtdO3Byb3RvLmxvPXByb3RvLmhpPXByb3RvLnRyYW5zcG9zZT1wcm90by5zdGVwPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBcIiArIGNsYXNzTmFtZSArIFwiKHRoaXMuZGF0YSk7fTtwcm90by5nZXQ9cHJvdG8uc2V0PWZ1bmN0aW9uKCl7fTtwcm90by5waWNrPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9O3JldHVybiBmdW5jdGlvbiBjb25zdHJ1Y3RfXCIgKyBjbGFzc05hbWUgKyBcIihhKXtyZXR1cm4gbmV3IFwiICsgY2xhc3NOYW1lICsgXCIoYSk7fVwiO1xuICAgICAgICB2YXIgcHJvY2VkdXJlID0gbmV3IEZ1bmN0aW9uKGNvZGUpO1xuICAgICAgICByZXR1cm4gcHJvY2VkdXJlKCk7XG4gICAgICB9IGVsc2UgaWYgKGRpbWVuc2lvbiA9PT0gMCkge1xuICAgICAgICB2YXIgY29kZSA9IFwiZnVuY3Rpb24gXCIgKyBjbGFzc05hbWUgKyBcIihhLGQpIHt0aGlzLmRhdGEgPSBhO3RoaXMub2Zmc2V0ID0gZH07dmFyIHByb3RvPVwiICsgY2xhc3NOYW1lICsgXCIucHJvdG90eXBlO3Byb3RvLmR0eXBlPSdcIiArIGR0eXBlICsgXCInO3Byb3RvLmluZGV4PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub2Zmc2V0fTtwcm90by5kaW1lbnNpb249MDtwcm90by5zaXplPTE7cHJvdG8uc2hhcGU9cHJvdG8uc3RyaWRlPXByb3RvLm9yZGVyPVtdO3Byb3RvLmxvPXByb3RvLmhpPXByb3RvLnRyYW5zcG9zZT1wcm90by5zdGVwPWZ1bmN0aW9uIFwiICsgY2xhc3NOYW1lICsgXCJfY29weSgpIHtyZXR1cm4gbmV3IFwiICsgY2xhc3NOYW1lICsgXCIodGhpcy5kYXRhLHRoaXMub2Zmc2V0KX07cHJvdG8ucGljaz1mdW5jdGlvbiBcIiArIGNsYXNzTmFtZSArIFwiX3BpY2soKXtyZXR1cm4gVHJpdmlhbEFycmF5KHRoaXMuZGF0YSk7fTtwcm90by52YWx1ZU9mPXByb3RvLmdldD1mdW5jdGlvbiBcIiArIGNsYXNzTmFtZSArIFwiX2dldCgpe3JldHVybiBcIiArICh1c2VHZXR0ZXJzID8gXCJ0aGlzLmRhdGEuZ2V0KHRoaXMub2Zmc2V0KVwiIDogXCJ0aGlzLmRhdGFbdGhpcy5vZmZzZXRdXCIpICsgXCJ9O3Byb3RvLnNldD1mdW5jdGlvbiBcIiArIGNsYXNzTmFtZSArIFwiX3NldCh2KXtyZXR1cm4gXCIgKyAodXNlR2V0dGVycyA/IFwidGhpcy5kYXRhLnNldCh0aGlzLm9mZnNldCx2KVwiIDogXCJ0aGlzLmRhdGFbdGhpcy5vZmZzZXRdPXZcIikgKyBcIn07cmV0dXJuIGZ1bmN0aW9uIGNvbnN0cnVjdF9cIiArIGNsYXNzTmFtZSArIFwiKGEsYixjLGQpe3JldHVybiBuZXcgXCIgKyBjbGFzc05hbWUgKyBcIihhLGQpfVwiO1xuICAgICAgICB2YXIgcHJvY2VkdXJlID0gbmV3IEZ1bmN0aW9uKFwiVHJpdmlhbEFycmF5XCIsIGNvZGUpO1xuICAgICAgICByZXR1cm4gcHJvY2VkdXJlKENBQ0hFRF9DT05TVFJVQ1RPUlNbZHR5cGVdWzBdKTtcbiAgICAgIH1cbiAgICAgIHZhciBjb2RlID0gW1wiJ3VzZSBzdHJpY3QnXCJdO1xuICAgICAgdmFyIGluZGljZXMgPSBpb3RhKGRpbWVuc2lvbik7XG4gICAgICB2YXIgYXJncyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgIHJldHVybiBcImlcIiArIGkyO1xuICAgICAgfSk7XG4gICAgICB2YXIgaW5kZXhfc3RyID0gXCJ0aGlzLm9mZnNldCtcIiArIGluZGljZXMubWFwKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgIHJldHVybiBcInRoaXMuc3RyaWRlW1wiICsgaTIgKyBcIl0qaVwiICsgaTI7XG4gICAgICB9KS5qb2luKFwiK1wiKTtcbiAgICAgIHZhciBzaGFwZUFyZyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgIHJldHVybiBcImJcIiArIGkyO1xuICAgICAgfSkuam9pbihcIixcIik7XG4gICAgICB2YXIgc3RyaWRlQXJnID0gaW5kaWNlcy5tYXAoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgcmV0dXJuIFwiY1wiICsgaTI7XG4gICAgICB9KS5qb2luKFwiLFwiKTtcbiAgICAgIGNvZGUucHVzaChcbiAgICAgICAgXCJmdW5jdGlvbiBcIiArIGNsYXNzTmFtZSArIFwiKGEsXCIgKyBzaGFwZUFyZyArIFwiLFwiICsgc3RyaWRlQXJnICsgXCIsZCl7dGhpcy5kYXRhPWFcIixcbiAgICAgICAgXCJ0aGlzLnNoYXBlPVtcIiArIHNoYXBlQXJnICsgXCJdXCIsXG4gICAgICAgIFwidGhpcy5zdHJpZGU9W1wiICsgc3RyaWRlQXJnICsgXCJdXCIsXG4gICAgICAgIFwidGhpcy5vZmZzZXQ9ZHwwfVwiLFxuICAgICAgICBcInZhciBwcm90bz1cIiArIGNsYXNzTmFtZSArIFwiLnByb3RvdHlwZVwiLFxuICAgICAgICBcInByb3RvLmR0eXBlPSdcIiArIGR0eXBlICsgXCInXCIsXG4gICAgICAgIFwicHJvdG8uZGltZW5zaW9uPVwiICsgZGltZW5zaW9uXG4gICAgICApO1xuICAgICAgY29kZS5wdXNoKFxuICAgICAgICBcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywnc2l6ZScse2dldDpmdW5jdGlvbiBcIiArIGNsYXNzTmFtZSArIFwiX3NpemUoKXtyZXR1cm4gXCIgKyBpbmRpY2VzLm1hcChmdW5jdGlvbihpMikge1xuICAgICAgICAgIHJldHVybiBcInRoaXMuc2hhcGVbXCIgKyBpMiArIFwiXVwiO1xuICAgICAgICB9KS5qb2luKFwiKlwiKSxcbiAgICAgICAgXCJ9fSlcIlxuICAgICAgKTtcbiAgICAgIGlmIChkaW1lbnNpb24gPT09IDEpIHtcbiAgICAgICAgY29kZS5wdXNoKFwicHJvdG8ub3JkZXI9WzBdXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29kZS5wdXNoKFwiT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCdvcmRlcicse2dldDpcIik7XG4gICAgICAgIGlmIChkaW1lbnNpb24gPCA0KSB7XG4gICAgICAgICAgY29kZS5wdXNoKFwiZnVuY3Rpb24gXCIgKyBjbGFzc05hbWUgKyBcIl9vcmRlcigpe1wiKTtcbiAgICAgICAgICBpZiAoZGltZW5zaW9uID09PSAyKSB7XG4gICAgICAgICAgICBjb2RlLnB1c2goXCJyZXR1cm4gKE1hdGguYWJzKHRoaXMuc3RyaWRlWzBdKT5NYXRoLmFicyh0aGlzLnN0cmlkZVsxXSkpP1sxLDBdOlswLDFdfX0pXCIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZGltZW5zaW9uID09PSAzKSB7XG4gICAgICAgICAgICBjb2RlLnB1c2goXG4gICAgICAgICAgICAgIFwidmFyIHMwPU1hdGguYWJzKHRoaXMuc3RyaWRlWzBdKSxzMT1NYXRoLmFicyh0aGlzLnN0cmlkZVsxXSksczI9TWF0aC5hYnModGhpcy5zdHJpZGVbMl0pO2lmKHMwPnMxKXtpZihzMT5zMil7cmV0dXJuIFsyLDEsMF07fWVsc2UgaWYoczA+czIpe3JldHVybiBbMSwyLDBdO31lbHNle3JldHVybiBbMSwwLDJdO319ZWxzZSBpZihzMD5zMil7cmV0dXJuIFsyLDAsMV07fWVsc2UgaWYoczI+czEpe3JldHVybiBbMCwxLDJdO31lbHNle3JldHVybiBbMCwyLDFdO319fSlcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29kZS5wdXNoKFwiT1JERVJ9KVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29kZS5wdXNoKFxuICAgICAgICBcInByb3RvLnNldD1mdW5jdGlvbiBcIiArIGNsYXNzTmFtZSArIFwiX3NldChcIiArIGFyZ3Muam9pbihcIixcIikgKyBcIix2KXtcIlxuICAgICAgKTtcbiAgICAgIGlmICh1c2VHZXR0ZXJzKSB7XG4gICAgICAgIGNvZGUucHVzaChcInJldHVybiB0aGlzLmRhdGEuc2V0KFwiICsgaW5kZXhfc3RyICsgXCIsdil9XCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29kZS5wdXNoKFwicmV0dXJuIHRoaXMuZGF0YVtcIiArIGluZGV4X3N0ciArIFwiXT12fVwiKTtcbiAgICAgIH1cbiAgICAgIGNvZGUucHVzaChcInByb3RvLmdldD1mdW5jdGlvbiBcIiArIGNsYXNzTmFtZSArIFwiX2dldChcIiArIGFyZ3Muam9pbihcIixcIikgKyBcIil7XCIpO1xuICAgICAgaWYgKHVzZUdldHRlcnMpIHtcbiAgICAgICAgY29kZS5wdXNoKFwicmV0dXJuIHRoaXMuZGF0YS5nZXQoXCIgKyBpbmRleF9zdHIgKyBcIil9XCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29kZS5wdXNoKFwicmV0dXJuIHRoaXMuZGF0YVtcIiArIGluZGV4X3N0ciArIFwiXX1cIik7XG4gICAgICB9XG4gICAgICBjb2RlLnB1c2goXG4gICAgICAgIFwicHJvdG8uaW5kZXg9ZnVuY3Rpb24gXCIgKyBjbGFzc05hbWUgKyBcIl9pbmRleChcIixcbiAgICAgICAgYXJncy5qb2luKCksXG4gICAgICAgIFwiKXtyZXR1cm4gXCIgKyBpbmRleF9zdHIgKyBcIn1cIlxuICAgICAgKTtcbiAgICAgIGNvZGUucHVzaChcInByb3RvLmhpPWZ1bmN0aW9uIFwiICsgY2xhc3NOYW1lICsgXCJfaGkoXCIgKyBhcmdzLmpvaW4oXCIsXCIpICsgXCIpe3JldHVybiBuZXcgXCIgKyBjbGFzc05hbWUgKyBcIih0aGlzLmRhdGEsXCIgKyBpbmRpY2VzLm1hcChmdW5jdGlvbihpMikge1xuICAgICAgICByZXR1cm4gW1wiKHR5cGVvZiBpXCIsIGkyLCBcIiE9PSdudW1iZXInfHxpXCIsIGkyLCBcIjwwKT90aGlzLnNoYXBlW1wiLCBpMiwgXCJdOmlcIiwgaTIsIFwifDBcIl0uam9pbihcIlwiKTtcbiAgICAgIH0pLmpvaW4oXCIsXCIpICsgXCIsXCIgKyBpbmRpY2VzLm1hcChmdW5jdGlvbihpMikge1xuICAgICAgICByZXR1cm4gXCJ0aGlzLnN0cmlkZVtcIiArIGkyICsgXCJdXCI7XG4gICAgICB9KS5qb2luKFwiLFwiKSArIFwiLHRoaXMub2Zmc2V0KX1cIik7XG4gICAgICB2YXIgYV92YXJzID0gaW5kaWNlcy5tYXAoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgcmV0dXJuIFwiYVwiICsgaTIgKyBcIj10aGlzLnNoYXBlW1wiICsgaTIgKyBcIl1cIjtcbiAgICAgIH0pO1xuICAgICAgdmFyIGNfdmFycyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgIHJldHVybiBcImNcIiArIGkyICsgXCI9dGhpcy5zdHJpZGVbXCIgKyBpMiArIFwiXVwiO1xuICAgICAgfSk7XG4gICAgICBjb2RlLnB1c2goXCJwcm90by5sbz1mdW5jdGlvbiBcIiArIGNsYXNzTmFtZSArIFwiX2xvKFwiICsgYXJncy5qb2luKFwiLFwiKSArIFwiKXt2YXIgYj10aGlzLm9mZnNldCxkPTAsXCIgKyBhX3ZhcnMuam9pbihcIixcIikgKyBcIixcIiArIGNfdmFycy5qb2luKFwiLFwiKSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbWVuc2lvbjsgKytpKSB7XG4gICAgICAgIGNvZGUucHVzaChcbiAgICAgICAgICBcImlmKHR5cGVvZiBpXCIgKyBpICsgXCI9PT0nbnVtYmVyJyYmaVwiICsgaSArIFwiPj0wKXtkPWlcIiArIGkgKyBcInwwO2IrPWNcIiArIGkgKyBcIipkO2FcIiArIGkgKyBcIi09ZH1cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29kZS5wdXNoKFwicmV0dXJuIG5ldyBcIiArIGNsYXNzTmFtZSArIFwiKHRoaXMuZGF0YSxcIiArIGluZGljZXMubWFwKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgIHJldHVybiBcImFcIiArIGkyO1xuICAgICAgfSkuam9pbihcIixcIikgKyBcIixcIiArIGluZGljZXMubWFwKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgIHJldHVybiBcImNcIiArIGkyO1xuICAgICAgfSkuam9pbihcIixcIikgKyBcIixiKX1cIik7XG4gICAgICBjb2RlLnB1c2goXCJwcm90by5zdGVwPWZ1bmN0aW9uIFwiICsgY2xhc3NOYW1lICsgXCJfc3RlcChcIiArIGFyZ3Muam9pbihcIixcIikgKyBcIil7dmFyIFwiICsgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgcmV0dXJuIFwiYVwiICsgaTIgKyBcIj10aGlzLnNoYXBlW1wiICsgaTIgKyBcIl1cIjtcbiAgICAgIH0pLmpvaW4oXCIsXCIpICsgXCIsXCIgKyBpbmRpY2VzLm1hcChmdW5jdGlvbihpMikge1xuICAgICAgICByZXR1cm4gXCJiXCIgKyBpMiArIFwiPXRoaXMuc3RyaWRlW1wiICsgaTIgKyBcIl1cIjtcbiAgICAgIH0pLmpvaW4oXCIsXCIpICsgXCIsYz10aGlzLm9mZnNldCxkPTAsY2VpbD1NYXRoLmNlaWxcIik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbWVuc2lvbjsgKytpKSB7XG4gICAgICAgIGNvZGUucHVzaChcbiAgICAgICAgICBcImlmKHR5cGVvZiBpXCIgKyBpICsgXCI9PT0nbnVtYmVyJyl7ZD1pXCIgKyBpICsgXCJ8MDtpZihkPDApe2MrPWJcIiArIGkgKyBcIiooYVwiICsgaSArIFwiLTEpO2FcIiArIGkgKyBcIj1jZWlsKC1hXCIgKyBpICsgXCIvZCl9ZWxzZXthXCIgKyBpICsgXCI9Y2VpbChhXCIgKyBpICsgXCIvZCl9YlwiICsgaSArIFwiKj1kfVwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb2RlLnB1c2goXCJyZXR1cm4gbmV3IFwiICsgY2xhc3NOYW1lICsgXCIodGhpcy5kYXRhLFwiICsgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgcmV0dXJuIFwiYVwiICsgaTI7XG4gICAgICB9KS5qb2luKFwiLFwiKSArIFwiLFwiICsgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgcmV0dXJuIFwiYlwiICsgaTI7XG4gICAgICB9KS5qb2luKFwiLFwiKSArIFwiLGMpfVwiKTtcbiAgICAgIHZhciB0U2hhcGUgPSBuZXcgQXJyYXkoZGltZW5zaW9uKTtcbiAgICAgIHZhciB0U3RyaWRlID0gbmV3IEFycmF5KGRpbWVuc2lvbik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbWVuc2lvbjsgKytpKSB7XG4gICAgICAgIHRTaGFwZVtpXSA9IFwiYVtpXCIgKyBpICsgXCJdXCI7XG4gICAgICAgIHRTdHJpZGVbaV0gPSBcImJbaVwiICsgaSArIFwiXVwiO1xuICAgICAgfVxuICAgICAgY29kZS5wdXNoKFxuICAgICAgICBcInByb3RvLnRyYW5zcG9zZT1mdW5jdGlvbiBcIiArIGNsYXNzTmFtZSArIFwiX3RyYW5zcG9zZShcIiArIGFyZ3MgKyBcIil7XCIgKyBhcmdzLm1hcChmdW5jdGlvbihuLCBpZHgpIHtcbiAgICAgICAgICByZXR1cm4gbiArIFwiPShcIiArIG4gKyBcIj09PXVuZGVmaW5lZD9cIiArIGlkeCArIFwiOlwiICsgbiArIFwifDApXCI7XG4gICAgICAgIH0pLmpvaW4oXCI7XCIpLFxuICAgICAgICBcInZhciBhPXRoaXMuc2hhcGUsYj10aGlzLnN0cmlkZTtyZXR1cm4gbmV3IFwiICsgY2xhc3NOYW1lICsgXCIodGhpcy5kYXRhLFwiICsgdFNoYXBlLmpvaW4oXCIsXCIpICsgXCIsXCIgKyB0U3RyaWRlLmpvaW4oXCIsXCIpICsgXCIsdGhpcy5vZmZzZXQpfVwiXG4gICAgICApO1xuICAgICAgY29kZS5wdXNoKFwicHJvdG8ucGljaz1mdW5jdGlvbiBcIiArIGNsYXNzTmFtZSArIFwiX3BpY2soXCIgKyBhcmdzICsgXCIpe3ZhciBhPVtdLGI9W10sYz10aGlzLm9mZnNldFwiKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGltZW5zaW9uOyArK2kpIHtcbiAgICAgICAgY29kZS5wdXNoKFwiaWYodHlwZW9mIGlcIiArIGkgKyBcIj09PSdudW1iZXInJiZpXCIgKyBpICsgXCI+PTApe2M9KGMrdGhpcy5zdHJpZGVbXCIgKyBpICsgXCJdKmlcIiArIGkgKyBcIil8MH1lbHNle2EucHVzaCh0aGlzLnNoYXBlW1wiICsgaSArIFwiXSk7Yi5wdXNoKHRoaXMuc3RyaWRlW1wiICsgaSArIFwiXSl9XCIpO1xuICAgICAgfVxuICAgICAgY29kZS5wdXNoKFwidmFyIGN0b3I9Q1RPUl9MSVNUW2EubGVuZ3RoKzFdO3JldHVybiBjdG9yKHRoaXMuZGF0YSxhLGIsYyl9XCIpO1xuICAgICAgY29kZS5wdXNoKFwicmV0dXJuIGZ1bmN0aW9uIGNvbnN0cnVjdF9cIiArIGNsYXNzTmFtZSArIFwiKGRhdGEsc2hhcGUsc3RyaWRlLG9mZnNldCl7cmV0dXJuIG5ldyBcIiArIGNsYXNzTmFtZSArIFwiKGRhdGEsXCIgKyBpbmRpY2VzLm1hcChmdW5jdGlvbihpMikge1xuICAgICAgICByZXR1cm4gXCJzaGFwZVtcIiArIGkyICsgXCJdXCI7XG4gICAgICB9KS5qb2luKFwiLFwiKSArIFwiLFwiICsgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgcmV0dXJuIFwic3RyaWRlW1wiICsgaTIgKyBcIl1cIjtcbiAgICAgIH0pLmpvaW4oXCIsXCIpICsgXCIsb2Zmc2V0KX1cIik7XG4gICAgICB2YXIgcHJvY2VkdXJlID0gbmV3IEZ1bmN0aW9uKFwiQ1RPUl9MSVNUXCIsIFwiT1JERVJcIiwgY29kZS5qb2luKFwiXFxuXCIpKTtcbiAgICAgIHJldHVybiBwcm9jZWR1cmUoQ0FDSEVEX0NPTlNUUlVDVE9SU1tkdHlwZV0sIG9yZGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXJyYXlEVHlwZShkYXRhKSB7XG4gICAgICBpZiAoaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuIFwiYnVmZmVyXCI7XG4gICAgICB9XG4gICAgICBpZiAoaGFzVHlwZWRBcnJheXMpIHtcbiAgICAgICAgc3dpdGNoIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZGF0YSkpIHtcbiAgICAgICAgICBjYXNlIFwiW29iamVjdCBGbG9hdDY0QXJyYXldXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJmbG9hdDY0XCI7XG4gICAgICAgICAgY2FzZSBcIltvYmplY3QgRmxvYXQzMkFycmF5XVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiZmxvYXQzMlwiO1xuICAgICAgICAgIGNhc2UgXCJbb2JqZWN0IEludDhBcnJheV1cIjpcbiAgICAgICAgICAgIHJldHVybiBcImludDhcIjtcbiAgICAgICAgICBjYXNlIFwiW29iamVjdCBJbnQxNkFycmF5XVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiaW50MTZcIjtcbiAgICAgICAgICBjYXNlIFwiW29iamVjdCBJbnQzMkFycmF5XVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiaW50MzJcIjtcbiAgICAgICAgICBjYXNlIFwiW29iamVjdCBVaW50OEFycmF5XVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwidWludDhcIjtcbiAgICAgICAgICBjYXNlIFwiW29iamVjdCBVaW50MTZBcnJheV1cIjpcbiAgICAgICAgICAgIHJldHVybiBcInVpbnQxNlwiO1xuICAgICAgICAgIGNhc2UgXCJbb2JqZWN0IFVpbnQzMkFycmF5XVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwidWludDMyXCI7XG4gICAgICAgICAgY2FzZSBcIltvYmplY3QgVWludDhDbGFtcGVkQXJyYXldXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJ1aW50OF9jbGFtcGVkXCI7XG4gICAgICAgICAgY2FzZSBcIltvYmplY3QgQmlnSW50NjRBcnJheV1cIjpcbiAgICAgICAgICAgIHJldHVybiBcImJpZ2ludDY0XCI7XG4gICAgICAgICAgY2FzZSBcIltvYmplY3QgQmlnVWludDY0QXJyYXldXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJiaWd1aW50NjRcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuIFwiYXJyYXlcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcImdlbmVyaWNcIjtcbiAgICB9XG4gICAgdmFyIENBQ0hFRF9DT05TVFJVQ1RPUlMgPSB7XG4gICAgICBcImZsb2F0MzJcIjogW10sXG4gICAgICBcImZsb2F0NjRcIjogW10sXG4gICAgICBcImludDhcIjogW10sXG4gICAgICBcImludDE2XCI6IFtdLFxuICAgICAgXCJpbnQzMlwiOiBbXSxcbiAgICAgIFwidWludDhcIjogW10sXG4gICAgICBcInVpbnQxNlwiOiBbXSxcbiAgICAgIFwidWludDMyXCI6IFtdLFxuICAgICAgXCJhcnJheVwiOiBbXSxcbiAgICAgIFwidWludDhfY2xhbXBlZFwiOiBbXSxcbiAgICAgIFwiYmlnaW50NjRcIjogW10sXG4gICAgICBcImJpZ3VpbnQ2NFwiOiBbXSxcbiAgICAgIFwiYnVmZmVyXCI6IFtdLFxuICAgICAgXCJnZW5lcmljXCI6IFtdXG4gICAgfTtcbiAgICBmdW5jdGlvbiB3cmFwcGVkTkRBcnJheUN0b3IoZGF0YSwgc2hhcGUsIHN0cmlkZSwgb2Zmc2V0KSB7XG4gICAgICBpZiAoZGF0YSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHZhciBjdG9yID0gQ0FDSEVEX0NPTlNUUlVDVE9SUy5hcnJheVswXTtcbiAgICAgICAgcmV0dXJuIGN0b3IoW10pO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBkYXRhID0gW2RhdGFdO1xuICAgICAgfVxuICAgICAgaWYgKHNoYXBlID09PSB2b2lkIDApIHtcbiAgICAgICAgc2hhcGUgPSBbZGF0YS5sZW5ndGhdO1xuICAgICAgfVxuICAgICAgdmFyIGQgPSBzaGFwZS5sZW5ndGg7XG4gICAgICBpZiAoc3RyaWRlID09PSB2b2lkIDApIHtcbiAgICAgICAgc3RyaWRlID0gbmV3IEFycmF5KGQpO1xuICAgICAgICBmb3IgKHZhciBpID0gZCAtIDEsIHN6ID0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICBzdHJpZGVbaV0gPSBzejtcbiAgICAgICAgICBzeiAqPSBzaGFwZVtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9mZnNldCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZDsgKytpKSB7XG4gICAgICAgICAgaWYgKHN0cmlkZVtpXSA8IDApIHtcbiAgICAgICAgICAgIG9mZnNldCAtPSAoc2hhcGVbaV0gLSAxKSAqIHN0cmlkZVtpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBkdHlwZSA9IGFycmF5RFR5cGUoZGF0YSk7XG4gICAgICB2YXIgY3Rvcl9saXN0ID0gQ0FDSEVEX0NPTlNUUlVDVE9SU1tkdHlwZV07XG4gICAgICB3aGlsZSAoY3Rvcl9saXN0Lmxlbmd0aCA8PSBkICsgMSkge1xuICAgICAgICBjdG9yX2xpc3QucHVzaChjb21waWxlQ29uc3RydWN0b3IoZHR5cGUsIGN0b3JfbGlzdC5sZW5ndGggLSAxKSk7XG4gICAgICB9XG4gICAgICB2YXIgY3RvciA9IGN0b3JfbGlzdFtkICsgMV07XG4gICAgICByZXR1cm4gY3RvcihkYXRhLCBzaGFwZSwgc3RyaWRlLCBvZmZzZXQpO1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHdyYXBwZWROREFycmF5Q3RvcjtcbiAgfVxufSk7XG5cbi8vIHNyYy9hcGkvdjEudHNcbnZhciBpbXBvcnRfbG9kYXNoID0gX190b0VTTShyZXF1aXJlX2xvZGFzaCgpKTtcblxuLy8gc3JjL3V0aWxzLnRzXG52YXIgaW1wb3J0X25kYXJyYXkyID0gX190b0VTTShyZXF1aXJlX25kYXJyYXkoKSk7XG5cbi8vIHNyYy9NaW1lVHlwZS50c1xudmFyIE1pbWVUeXBlID0gY2xhc3MgX01pbWVUeXBlIHtcbiAgY29uc3RydWN0b3IodHlwZSwgcGFyYW1zKSB7XG4gICAgdGhpcy50eXBlID0gXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIjtcbiAgICB0aGlzLnBhcmFtcyA9IHt9O1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgY29uc3QgcGFyYW1zU3RyID0gW107XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5wYXJhbXMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5wYXJhbXNba2V5XTtcbiAgICAgIHBhcmFtc1N0ci5wdXNoKGAke2tleX09JHt2YWx1ZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIFt0aGlzLnR5cGUsIC4uLnBhcmFtc1N0cl0uam9pbihcIjtcIik7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZSh0eXBlLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IF9NaW1lVHlwZSh0eXBlLCBwYXJhbXMpO1xuICB9XG4gIGlzSWRlbnRpY2FsKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gb3RoZXIudHlwZSAmJiB0aGlzLnBhcmFtcyA9PT0gb3RoZXIucGFyYW1zO1xuICB9XG4gIGlzRXF1YWwob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlID09PSBvdGhlci50eXBlO1xuICB9XG4gIHN0YXRpYyBmcm9tU3RyaW5nKG1pbWVUeXBlKSB7XG4gICAgY29uc3QgW3R5cGUsIC4uLnBhcmFtc0Fycl0gPSBtaW1lVHlwZS5zcGxpdChcIjtcIik7XG4gICAgY29uc3QgcGFyYW1zID0ge307XG4gICAgZm9yIChjb25zdCBwYXJhbSBvZiBwYXJhbXNBcnIpIHtcbiAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IHBhcmFtLnNwbGl0KFwiPVwiKTtcbiAgICAgIHBhcmFtc1trZXkudHJpbSgpXSA9IHZhbHVlLnRyaW0oKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfTWltZVR5cGUodHlwZSwgcGFyYW1zKTtcbiAgfVxufTtcblxuLy8gc3JjL2NvZGVjcy50c1xudmFyIGltcG9ydF9uZGFycmF5ID0gX190b0VTTShyZXF1aXJlX25kYXJyYXkoKSk7XG5hc3luYyBmdW5jdGlvbiBpbWFnZURlY29kZShibG9iKSB7XG4gIGNvbnN0IG1pbWUgPSBNaW1lVHlwZS5mcm9tU3RyaW5nKGJsb2IudHlwZSk7XG4gIHN3aXRjaCAobWltZS50eXBlKSB7XG4gICAgY2FzZSBcImltYWdlL3gtYWxwaGE4XCI6IHtcbiAgICAgIGNvbnN0IHdpZHRoID0gcGFyc2VJbnQobWltZS5wYXJhbXNbXCJ3aWR0aFwiXSk7XG4gICAgICBjb25zdCBoZWlnaHQgPSBwYXJzZUludChtaW1lLnBhcmFtc1tcImhlaWdodFwiXSk7XG4gICAgICByZXR1cm4gKDAsIGltcG9ydF9uZGFycmF5LmRlZmF1bHQpKG5ldyBVaW50OEFycmF5KGF3YWl0IGJsb2IuYXJyYXlCdWZmZXIoKSksIFtcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgMVxuICAgICAgXSk7XG4gICAgfVxuICAgIGNhc2UgXCJpbWFnZS94LXJnYmE4XCI6IHtcbiAgICAgIGNvbnN0IHdpZHRoID0gcGFyc2VJbnQobWltZS5wYXJhbXNbXCJ3aWR0aFwiXSk7XG4gICAgICBjb25zdCBoZWlnaHQgPSBwYXJzZUludChtaW1lLnBhcmFtc1tcImhlaWdodFwiXSk7XG4gICAgICByZXR1cm4gKDAsIGltcG9ydF9uZGFycmF5LmRlZmF1bHQpKG5ldyBVaW50OEFycmF5KGF3YWl0IGJsb2IuYXJyYXlCdWZmZXIoKSksIFtcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgNFxuICAgICAgXSk7XG4gICAgfVxuICAgIGNhc2UgXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIjpcbiAgICBjYXNlIGBpbWFnZS9wbmdgOlxuICAgIGNhc2UgYGltYWdlL2pwZWdgOlxuICAgIGNhc2UgYGltYWdlL2pwZ2A6XG4gICAgY2FzZSBgaW1hZ2Uvd2VicGA6IHtcbiAgICAgIGNvbnN0IGltYWdlQml0bWFwID0gYXdhaXQgY3JlYXRlSW1hZ2VCaXRtYXAoYmxvYik7XG4gICAgICBjb25zdCBpbWFnZURhdGEgPSBpbWFnZUJpdG1hcFRvSW1hZ2VEYXRhKGltYWdlQml0bWFwKTtcbiAgICAgIHJldHVybiAoMCwgaW1wb3J0X25kYXJyYXkuZGVmYXVsdCkobmV3IFVpbnQ4QXJyYXkoaW1hZ2VEYXRhLmRhdGEpLCBbXG4gICAgICAgIGltYWdlRGF0YS5oZWlnaHQsXG4gICAgICAgIGltYWdlRGF0YS53aWR0aCxcbiAgICAgICAgNFxuICAgICAgXSk7XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIGZvcm1hdDogJHttaW1lLnR5cGV9IHdpdGggcGFyYW1zOiAke21pbWUucGFyYW1zfWBcbiAgICAgICk7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGltYWdlRW5jb2RlKGltYWdlVGVuc29yLCBxdWFsaXR5ID0gMC44LCBmb3JtYXQgPSBcImltYWdlL3BuZ1wiKSB7XG4gIGNvbnN0IFtoZWlnaHQsIHdpZHRoLCBjaGFubmVsc10gPSBpbWFnZVRlbnNvci5zaGFwZTtcbiAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICBjYXNlIFwiaW1hZ2UveC1hbHBoYThcIjpcbiAgICBjYXNlIFwiaW1hZ2UveC1yZ2JhOFwiOiB7XG4gICAgICBjb25zdCBtaW1lID0gTWltZVR5cGUuY3JlYXRlKGZvcm1hdCwge1xuICAgICAgICB3aWR0aDogd2lkdGgudG9TdHJpbmcoKSxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQudG9TdHJpbmcoKVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IEJsb2IoW2ltYWdlVGVuc29yLmRhdGFdLCB7IHR5cGU6IG1pbWUudG9TdHJpbmcoKSB9KTtcbiAgICB9XG4gICAgY2FzZSBgaW1hZ2UvcG5nYDpcbiAgICBjYXNlIGBpbWFnZS9qcGVnYDpcbiAgICBjYXNlIGBpbWFnZS93ZWJwYDoge1xuICAgICAgY29uc3QgaW1hZ2VEYXRhID0gbmV3IEltYWdlRGF0YShcbiAgICAgICAgbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGltYWdlVGVuc29yLmRhdGEpLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICApO1xuICAgICAgdmFyIGNhbnZhcyA9IGNyZWF0ZUNhbnZhcyhpbWFnZURhdGEud2lkdGgsIGltYWdlRGF0YS5oZWlnaHQpO1xuICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICBjdHgucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG4gICAgICByZXR1cm4gY2FudmFzLmNvbnZlcnRUb0Jsb2IoeyBxdWFsaXR5LCB0eXBlOiBmb3JtYXQgfSk7XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZm9ybWF0OiAke2Zvcm1hdH1gKTtcbiAgfVxufVxuXG4vLyBzcmMvdXJsLnRzXG5mdW5jdGlvbiBpc0Fic29sdXRlVVJJKHVybCkge1xuICBjb25zdCByZWdFeHAgPSBuZXcgUmVnRXhwKFwiXig/OlthLXorXSs6KT8vL1wiLCBcImlcIik7XG4gIHJldHVybiByZWdFeHAudGVzdCh1cmwpO1xufVxuZnVuY3Rpb24gZW5zdXJlQWJzb2x1dGVVUkkodXJsLCBiYXNlVXJsKSB7XG4gIGlmIChpc0Fic29sdXRlVVJJKHVybCkpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgVVJMKHVybCwgYmFzZVVybCkuaHJlZjtcbiAgfVxufVxuXG4vLyBzcmMvdXRpbHMudHNcbmZ1bmN0aW9uIGltYWdlQml0bWFwVG9JbWFnZURhdGEoaW1hZ2VCaXRtYXApIHtcbiAgdmFyIGNhbnZhcyA9IGNyZWF0ZUNhbnZhcyhpbWFnZUJpdG1hcC53aWR0aCwgaW1hZ2VCaXRtYXAuaGVpZ2h0KTtcbiAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gIGN0eC5kcmF3SW1hZ2UoaW1hZ2VCaXRtYXAsIDAsIDApO1xuICByZXR1cm4gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xufVxuZnVuY3Rpb24gY3JlYXRlVHlwZUFycmF5KGxlbmd0aCkge1xuICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGxlbmd0aCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIFVpbnQxNkFycmF5ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50MTZBcnJheShsZW5ndGgpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBVaW50MzJBcnJheSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBuZXcgVWludDMyQXJyYXkobGVuZ3RoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgRmxvYXQzMkFycmF5ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkobGVuZ3RoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgRmxvYXQ2NEFycmF5ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIG5ldyBGbG9hdDY0QXJyYXkobGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUeXBlZEFycmF5IG5vdCBzdXBwb3J0ZWRcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIHRlbnNvclJlc2l6ZUJpbGluZWFyKGltYWdlVGVuc29yLCBuZXdXaWR0aCwgbmV3SGVpZ2h0LCBwcm9wb3J0aW9uYWwgPSBmYWxzZSkge1xuICBjb25zdCBbc3JjSGVpZ2h0LCBzcmNXaWR0aCwgc3JjQ2hhbm5lbHNdID0gaW1hZ2VUZW5zb3Iuc2hhcGU7XG4gIGxldCBzY2FsZVggPSBzcmNXaWR0aCAvIG5ld1dpZHRoO1xuICBsZXQgc2NhbGVZID0gc3JjSGVpZ2h0IC8gbmV3SGVpZ2h0O1xuICBpZiAocHJvcG9ydGlvbmFsKSB7XG4gICAgY29uc3QgZG93bnNjYWxpbmcgPSBNYXRoLm1heChzY2FsZVgsIHNjYWxlWSkgPiAxO1xuICAgIHNjYWxlWCA9IHNjYWxlWSA9IGRvd25zY2FsaW5nID8gTWF0aC5tYXgoc2NhbGVYLCBzY2FsZVkpIDogTWF0aC5taW4oc2NhbGVYLCBzY2FsZVkpO1xuICB9XG4gIGNvbnN0IHJlc2l6ZWRJbWFnZURhdGEgPSAoMCwgaW1wb3J0X25kYXJyYXkyLmRlZmF1bHQpKFxuICAgIGNyZWF0ZVR5cGVBcnJheShzcmNDaGFubmVscyAqIG5ld1dpZHRoICogbmV3SGVpZ2h0KSxcbiAgICBbbmV3SGVpZ2h0LCBuZXdXaWR0aCwgc3JjQ2hhbm5lbHNdXG4gICk7XG4gIGZvciAobGV0IHkgPSAwOyB5IDwgbmV3SGVpZ2h0OyB5KyspIHtcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG5ld1dpZHRoOyB4KyspIHtcbiAgICAgIGNvbnN0IHNyY1ggPSB4ICogc2NhbGVYO1xuICAgICAgY29uc3Qgc3JjWSA9IHkgKiBzY2FsZVk7XG4gICAgICBjb25zdCB4MSA9IE1hdGgubWF4KE1hdGguZmxvb3Ioc3JjWCksIDApO1xuICAgICAgY29uc3QgeDIgPSBNYXRoLm1pbihNYXRoLmNlaWwoc3JjWCksIHNyY1dpZHRoIC0gMSk7XG4gICAgICBjb25zdCB5MSA9IE1hdGgubWF4KE1hdGguZmxvb3Ioc3JjWSksIDApO1xuICAgICAgY29uc3QgeTIgPSBNYXRoLm1pbihNYXRoLmNlaWwoc3JjWSksIHNyY0hlaWdodCAtIDEpO1xuICAgICAgY29uc3QgZHggPSBzcmNYIC0geDE7XG4gICAgICBjb25zdCBkeSA9IHNyY1kgLSB5MTtcbiAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgc3JjQ2hhbm5lbHM7IGMrKykge1xuICAgICAgICBjb25zdCBwMSA9IGltYWdlVGVuc29yLmdldCh5MSwgeDEsIGMpO1xuICAgICAgICBjb25zdCBwMiA9IGltYWdlVGVuc29yLmdldCh5MSwgeDIsIGMpO1xuICAgICAgICBjb25zdCBwMyA9IGltYWdlVGVuc29yLmdldCh5MiwgeDEsIGMpO1xuICAgICAgICBjb25zdCBwNCA9IGltYWdlVGVuc29yLmdldCh5MiwgeDIsIGMpO1xuICAgICAgICBjb25zdCBpbnRlcnBvbGF0ZWRWYWx1ZSA9ICgxIC0gZHgpICogKDEgLSBkeSkgKiBwMSArIGR4ICogKDEgLSBkeSkgKiBwMiArICgxIC0gZHgpICogZHkgKiBwMyArIGR4ICogZHkgKiBwNDtcbiAgICAgICAgcmVzaXplZEltYWdlRGF0YS5zZXQoeSwgeCwgYywgaW50ZXJwb2xhdGVkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzaXplZEltYWdlRGF0YTtcbn1cbmZ1bmN0aW9uIHRlbnNvckhXQ3RvQkNIVyhpbWFnZVRlbnNvciwgbWVhbiA9IFsxMjgsIDEyOCwgMTI4XSwgc3RkID0gWzI1NiwgMjU2LCAyNTZdKSB7XG4gIHZhciBpbWFnZUJ1ZmZlckRhdGEgPSBpbWFnZVRlbnNvci5kYXRhO1xuICBjb25zdCBbc3JjSGVpZ2h0LCBzcmNXaWR0aCwgc3JjQ2hhbm5lbHNdID0gaW1hZ2VUZW5zb3Iuc2hhcGU7XG4gIGNvbnN0IHN0cmlkZSA9IHNyY0hlaWdodCAqIHNyY1dpZHRoO1xuICBjb25zdCBmbG9hdDMyRGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoMyAqIHN0cmlkZSk7XG4gIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IGltYWdlQnVmZmVyRGF0YS5sZW5ndGg7IGkgKz0gNCwgaiArPSAxKSB7XG4gICAgZmxvYXQzMkRhdGFbal0gPSAoaW1hZ2VCdWZmZXJEYXRhW2ldIC0gbWVhblswXSkgLyBzdGRbMF07XG4gICAgZmxvYXQzMkRhdGFbaiArIHN0cmlkZV0gPSAoaW1hZ2VCdWZmZXJEYXRhW2kgKyAxXSAtIG1lYW5bMV0pIC8gc3RkWzFdO1xuICAgIGZsb2F0MzJEYXRhW2ogKyBzdHJpZGUgKyBzdHJpZGVdID0gKGltYWdlQnVmZmVyRGF0YVtpICsgMl0gLSBtZWFuWzJdKSAvIHN0ZFsyXTtcbiAgfVxuICByZXR1cm4gKDAsIGltcG9ydF9uZGFycmF5Mi5kZWZhdWx0KShmbG9hdDMyRGF0YSwgWzEsIDMsIHNyY0hlaWdodCwgc3JjV2lkdGhdKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGltYWdlU291cmNlVG9JbWFnZURhdGEoaW1hZ2UsIGNvbmZpZykge1xuICBpZiAodHlwZW9mIGltYWdlID09PSBcInN0cmluZ1wiKSB7XG4gICAgaW1hZ2UgPSBlbnN1cmVBYnNvbHV0ZVVSSShpbWFnZSwgY29uZmlnLnB1YmxpY1BhdGgpO1xuICAgIGltYWdlID0gbmV3IFVSTChpbWFnZSk7XG4gIH1cbiAgaWYgKGltYWdlIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChpbWFnZSwge30pO1xuICAgIGltYWdlID0gYXdhaXQgcmVzcG9uc2UuYmxvYigpO1xuICB9XG4gIGlmIChpbWFnZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyhpbWFnZSkpIHtcbiAgICBpbWFnZSA9IG5ldyBCbG9iKFtpbWFnZV0pO1xuICB9XG4gIGlmIChpbWFnZSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICBpbWFnZSA9IGF3YWl0IGltYWdlRGVjb2RlKGltYWdlKTtcbiAgfVxuICByZXR1cm4gaW1hZ2U7XG59XG5mdW5jdGlvbiBjb252ZXJ0RmxvYXQzMlRvVWludDgoZmxvYXQzMkFycmF5KSB7XG4gIGNvbnN0IHVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShmbG9hdDMyQXJyYXkuZGF0YS5sZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGZsb2F0MzJBcnJheS5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgdWludDhBcnJheVtpXSA9IGZsb2F0MzJBcnJheS5kYXRhW2ldICogMjU1O1xuICB9XG4gIHJldHVybiAoMCwgaW1wb3J0X25kYXJyYXkyLmRlZmF1bHQpKHVpbnQ4QXJyYXksIGZsb2F0MzJBcnJheS5zaGFwZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCkge1xuICBsZXQgY2FudmFzID0gdm9pZCAwO1xuICBpZiAodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMod2lkdGgsIGhlaWdodCk7XG4gIH0gZWxzZSB7XG4gICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgfVxuICBpZiAoIWNhbnZhcykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBDYW52YXMgbm9yIE9mZnNjcmVlbkNhbnZhcyBhcmUgYXZhaWxhYmxlIGluIHRoZSBjdXJyZW50IGNvbnRleHQuYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGNhbnZhcztcbn1cblxuLy8gc3JjL29ubngudHNcbnZhciBpbXBvcnRfbmRhcnJheTMgPSBfX3RvRVNNKHJlcXVpcmVfbmRhcnJheSgpKTtcblxuLy8gc3JjL2NhcGFiaWxpdGllcy5qc1xudmFyIHdlYmdwdSA9IGFzeW5jICgpID0+IHtcbiAgaWYgKG5hdmlnYXRvci5ncHUgPT09IHZvaWQgMClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGFkYXB0ZXIgPSBhd2FpdCBuYXZpZ2F0b3IuZ3B1LnJlcXVlc3RBZGFwdGVyKCk7XG4gIHJldHVybiBhZGFwdGVyICE9PSBudWxsO1xufTtcbnZhciBtYXhOdW1UaHJlYWRzID0gKCkgPT4gbmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3kgPz8gNDtcblxuLy8gc3JjL3Jlc291cmNlLnRzXG5hc3luYyBmdW5jdGlvbiBsb2FkQXNVcmwodXJsLCBjb25maWcpIHtcbiAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwoYXdhaXQgbG9hZEFzQmxvYih1cmwsIGNvbmZpZykpO1xufVxuYXN5bmMgZnVuY3Rpb24gbG9hZEFzQmxvYihrZXksIGNvbmZpZykge1xuICBjb25zdCByZXNvdXJjZVVybCA9IG5ldyBVUkwoXCJyZXNvdXJjZXMuanNvblwiLCBjb25maWcucHVibGljUGF0aCk7XG4gIGNvbnN0IHJlc291cmNlUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChyZXNvdXJjZVVybCk7XG4gIGlmICghcmVzb3VyY2VSZXNwb25zZS5vaykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBSZXNvdXJjZSBtZXRhZGF0YSBub3QgZm91bmQuIEVuc3VyZSB0aGF0IHRoZSBjb25maWcucHVibGljUGF0aCBpcyBjb25maWd1cmVkIGNvcnJlY3RseS5gXG4gICAgKTtcbiAgfVxuICBjb25zdCByZXNvdXJjZU1hcCA9IGF3YWl0IHJlc291cmNlUmVzcG9uc2UuanNvbigpO1xuICBjb25zdCBlbnRyeSA9IHJlc291cmNlTWFwW2tleV07XG4gIGlmICghZW50cnkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgUmVzb3VyY2UgJHtrZXl9IG5vdCBmb3VuZC4gRW5zdXJlIHRoYXQgdGhlIGNvbmZpZy5wdWJsaWNQYXRoIGlzIGNvbmZpZ3VyZWQgY29ycmVjdGx5LmBcbiAgICApO1xuICB9XG4gIGNvbnN0IGNodW5rcyA9IGVudHJ5LmNodW5rcztcbiAgbGV0IGRvd25sb2FkZWRTaXplID0gMDtcbiAgY29uc3QgcmVzcG9uc2VzID0gY2h1bmtzLm1hcChhc3luYyAoY2h1bmspID0+IHtcbiAgICBjb25zdCBjaHVua1NpemUgPSBjaHVuay5vZmZzZXRzWzFdIC0gY2h1bmsub2Zmc2V0c1swXTtcbiAgICBjb25zdCB1cmwgPSBjb25maWcucHVibGljUGF0aCA/IG5ldyBVUkwoY2h1bmsubmFtZSwgY29uZmlnLnB1YmxpY1BhdGgpLnRvU3RyaW5nKCkgOiBjaHVuay5uYW1lO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCBjb25maWcuZmV0Y2hBcmdzKTtcbiAgICBjb25zdCBibG9iID0gYXdhaXQgcmVzcG9uc2UuYmxvYigpO1xuICAgIGlmIChjaHVua1NpemUgIT09IGJsb2Iuc2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRmFpbGVkIHRvIGZldGNoICR7a2V5fSB3aXRoIHNpemUgJHtjaHVua1NpemV9IGJ1dCBnb3QgJHtibG9iLnNpemV9YFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5wcm9ncmVzcykge1xuICAgICAgZG93bmxvYWRlZFNpemUgKz0gY2h1bmtTaXplO1xuICAgICAgY29uZmlnLnByb2dyZXNzKGBmZXRjaDoke2tleX1gLCBkb3dubG9hZGVkU2l6ZSwgZW50cnkuc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiBibG9iO1xuICB9KTtcbiAgY29uc3QgYWxsQ2h1bmtEYXRhID0gYXdhaXQgUHJvbWlzZS5hbGwocmVzcG9uc2VzKTtcbiAgY29uc3QgZGF0YSA9IG5ldyBCbG9iKGFsbENodW5rRGF0YSwgeyB0eXBlOiBlbnRyeS5taW1lIH0pO1xuICBpZiAoZGF0YS5zaXplICE9PSBlbnRyeS5zaXplKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEZhaWxlZCB0byBmZXRjaCAke2tleX0gd2l0aCBzaXplICR7ZW50cnkuc2l6ZX0gYnV0IGdvdCAke2RhdGEuc2l6ZX1gXG4gICAgKTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxuLy8gc3JjL29ubngudHNcbnZhciBvcnQgPSBudWxsO1xudmFyIGdldE9ydCA9IGFzeW5jICh1c2VXZWJHUFUpID0+IHtcbiAgaWYgKG9ydCAhPT0gbnVsbCkge1xuICAgIHJldHVybiBvcnQ7XG4gIH1cbiAgaWYgKHVzZVdlYkdQVSkge1xuICAgIG9ydCA9IChhd2FpdCBpbXBvcnQoXCJvbm54cnVudGltZS13ZWIvd2ViZ3B1XCIpKS5kZWZhdWx0O1xuICB9IGVsc2Uge1xuICAgIG9ydCA9IChhd2FpdCBpbXBvcnQoXCJvbm54cnVudGltZS13ZWJcIikpLmRlZmF1bHQ7XG4gIH1cbiAgcmV0dXJuIG9ydDtcbn07XG5hc3luYyBmdW5jdGlvbiBjcmVhdGVPbm54U2Vzc2lvbihtb2RlbCwgY29uZmlnKSB7XG4gIGNvbnN0IHVzZVdlYkdQVSA9IGNvbmZpZy5kZXZpY2UgPT09IFwiZ3B1XCIgJiYgYXdhaXQgd2ViZ3B1KCk7XG4gIGNvbnN0IHByb3h5VG9Xb3JrZXIgPSB1c2VXZWJHUFUgJiYgY29uZmlnLnByb3h5VG9Xb3JrZXI7XG4gIGNvbnN0IGV4ZWN1dGlvblByb3ZpZGVycyA9IFt1c2VXZWJHUFUgPyBcIndlYmdwdVwiIDogXCJ3YXNtXCJdO1xuICBjb25zdCBvcnQyID0gYXdhaXQgZ2V0T3J0KHVzZVdlYkdQVSk7XG4gIGlmIChjb25maWcuZGVidWcpIHtcbiAgICBjb25zb2xlLmRlYnVnKFwiXHRVc2luZyBXZWJHUFU6XCIsIHVzZVdlYkdQVSk7XG4gICAgY29uc29sZS5kZWJ1ZyhcIlx0UHJveHkgdG8gV29ya2VyOlwiLCBwcm94eVRvV29ya2VyKTtcbiAgICBvcnQyLmVudi5kZWJ1ZyA9IHRydWU7XG4gICAgb3J0Mi5lbnYubG9nTGV2ZWwgPSBcInZlcmJvc2VcIjtcbiAgfVxuICBvcnQyLmVudi53YXNtLm51bVRocmVhZHMgPSBtYXhOdW1UaHJlYWRzKCk7XG4gIG9ydDIuZW52Lndhc20ucHJveHkgPSBwcm94eVRvV29ya2VyO1xuICBjb25zdCBiYXNlRmlsZVBhdGggPSB1c2VXZWJHUFUgPyBcIi9vbm54cnVudGltZS13ZWIvb3J0LXdhc20tc2ltZC10aHJlYWRlZC5qc2VwXCIgOiBcIi9vbm54cnVudGltZS13ZWIvb3J0LXdhc20tc2ltZC10aHJlYWRlZFwiO1xuICBjb25zdCB3YXNtUGF0aCA9IGF3YWl0IGxvYWRBc1VybChgJHtiYXNlRmlsZVBhdGh9Lndhc21gLCBjb25maWcpO1xuICBjb25zdCBtanNQYXRoID0gYXdhaXQgbG9hZEFzVXJsKGAke2Jhc2VGaWxlUGF0aH0ubWpzYCwgY29uZmlnKTtcbiAgb3J0Mi5lbnYud2FzbS53YXNtUGF0aHMgPSB7XG4gICAgbWpzOiBtanNQYXRoLFxuICAgIHdhc206IHdhc21QYXRoXG4gIH07XG4gIGlmIChjb25maWcuZGVidWcpIHtcbiAgICBjb25zb2xlLmRlYnVnKFwib3J0LmVudi53YXNtOlwiLCBvcnQyLmVudi53YXNtKTtcbiAgfVxuICBjb25zdCBvcnRDb25maWcgPSB7XG4gICAgZXhlY3V0aW9uUHJvdmlkZXJzLFxuICAgIGdyYXBoT3B0aW1pemF0aW9uTGV2ZWw6IFwiYWxsXCIsXG4gICAgZXhlY3V0aW9uTW9kZTogXCJwYXJhbGxlbFwiLFxuICAgIGVuYWJsZUNwdU1lbUFyZW5hOiB0cnVlXG4gIH07XG4gIGNvbnN0IHNlc3Npb24gPSBhd2FpdCBvcnQyLkluZmVyZW5jZVNlc3Npb24uY3JlYXRlKG1vZGVsLCBvcnRDb25maWcpLmNhdGNoKFxuICAgIChlKSA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBGYWlsZWQgdG8gY3JlYXRlIHNlc3Npb246IFwiJHtlfVwiLiBQbGVhc2UgY2hlY2sgaWYgdGhlIHB1YmxpY1BhdGggaXMgc2V0IGNvcnJlY3RseS5gXG4gICAgICApO1xuICAgIH1cbiAgKTtcbiAgcmV0dXJuIHNlc3Npb247XG59XG5hc3luYyBmdW5jdGlvbiBydW5Pbm54U2Vzc2lvbihzZXNzaW9uLCBpbnB1dHMsIG91dHB1dHMsIGNvbmZpZykge1xuICBjb25zdCB1c2VXZWJHUFUgPSBjb25maWcuZGV2aWNlID09PSBcImdwdVwiICYmIGF3YWl0IHdlYmdwdSgpO1xuICBjb25zdCBvcnQyID0gYXdhaXQgZ2V0T3J0KHVzZVdlYkdQVSk7XG4gIGNvbnN0IGZlZWRzID0ge307XG4gIGZvciAoY29uc3QgW2tleSwgdGVuc29yXSBvZiBpbnB1dHMpIHtcbiAgICBmZWVkc1trZXldID0gbmV3IG9ydDIuVGVuc29yKFxuICAgICAgXCJmbG9hdDMyXCIsXG4gICAgICBuZXcgRmxvYXQzMkFycmF5KHRlbnNvci5kYXRhKSxcbiAgICAgIHRlbnNvci5zaGFwZVxuICAgICk7XG4gIH1cbiAgY29uc3Qgb3V0cHV0RGF0YSA9IGF3YWl0IHNlc3Npb24ucnVuKGZlZWRzLCB7fSk7XG4gIGNvbnN0IG91dHB1dEtWUGFpcnMgPSBbXTtcbiAgZm9yIChjb25zdCBrZXkgb2Ygb3V0cHV0cykge1xuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dERhdGFba2V5XTtcbiAgICBjb25zdCBzaGFwZSA9IG91dHB1dC5kaW1zO1xuICAgIGNvbnN0IGRhdGEgPSBvdXRwdXQuZGF0YTtcbiAgICBjb25zdCB0ZW5zb3IgPSAoMCwgaW1wb3J0X25kYXJyYXkzLmRlZmF1bHQpKGRhdGEsIHNoYXBlKTtcbiAgICBvdXRwdXRLVlBhaXJzLnB1c2godGVuc29yKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0S1ZQYWlycztcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3pvZC9saWIvaW5kZXgubWpzXG52YXIgdXRpbDtcbihmdW5jdGlvbih1dGlsMikge1xuICB1dGlsMi5hc3NlcnRFcXVhbCA9ICh2YWwpID0+IHZhbDtcbiAgZnVuY3Rpb24gYXNzZXJ0SXMoX2FyZykge1xuICB9XG4gIHV0aWwyLmFzc2VydElzID0gYXNzZXJ0SXM7XG4gIGZ1bmN0aW9uIGFzc2VydE5ldmVyKF94KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gIH1cbiAgdXRpbDIuYXNzZXJ0TmV2ZXIgPSBhc3NlcnROZXZlcjtcbiAgdXRpbDIuYXJyYXlUb0VudW0gPSAoaXRlbXMpID0+IHtcbiAgICBjb25zdCBvYmogPSB7fTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgIG9ialtpdGVtXSA9IGl0ZW07XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH07XG4gIHV0aWwyLmdldFZhbGlkRW51bVZhbHVlcyA9IChvYmopID0+IHtcbiAgICBjb25zdCB2YWxpZEtleXMgPSB1dGlsMi5vYmplY3RLZXlzKG9iaikuZmlsdGVyKChrKSA9PiB0eXBlb2Ygb2JqW29ialtrXV0gIT09IFwibnVtYmVyXCIpO1xuICAgIGNvbnN0IGZpbHRlcmVkID0ge307XG4gICAgZm9yIChjb25zdCBrIG9mIHZhbGlkS2V5cykge1xuICAgICAgZmlsdGVyZWRba10gPSBvYmpba107XG4gICAgfVxuICAgIHJldHVybiB1dGlsMi5vYmplY3RWYWx1ZXMoZmlsdGVyZWQpO1xuICB9O1xuICB1dGlsMi5vYmplY3RWYWx1ZXMgPSAob2JqKSA9PiB7XG4gICAgcmV0dXJuIHV0aWwyLm9iamVjdEtleXMob2JqKS5tYXAoZnVuY3Rpb24oZSkge1xuICAgICAgcmV0dXJuIG9ialtlXTtcbiAgICB9KTtcbiAgfTtcbiAgdXRpbDIub2JqZWN0S2V5cyA9IHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gXCJmdW5jdGlvblwiID8gKG9iaikgPT4gT2JqZWN0LmtleXMob2JqKSA6IChvYmplY3QpID0+IHtcbiAgICBjb25zdCBrZXlzID0gW107XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtleXM7XG4gIH07XG4gIHV0aWwyLmZpbmQgPSAoYXJyLCBjaGVja2VyKSA9PiB7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGFycikge1xuICAgICAgaWYgKGNoZWNrZXIoaXRlbSkpXG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9O1xuICB1dGlsMi5pc0ludGVnZXIgPSB0eXBlb2YgTnVtYmVyLmlzSW50ZWdlciA9PT0gXCJmdW5jdGlvblwiID8gKHZhbCkgPT4gTnVtYmVyLmlzSW50ZWdlcih2YWwpIDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiAmJiBpc0Zpbml0ZSh2YWwpICYmIE1hdGguZmxvb3IodmFsKSA9PT0gdmFsO1xuICBmdW5jdGlvbiBqb2luVmFsdWVzKGFycmF5LCBzZXBhcmF0b3IgPSBcIiB8IFwiKSB7XG4gICAgcmV0dXJuIGFycmF5Lm1hcCgodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiID8gYCcke3ZhbH0nYCA6IHZhbCkuam9pbihzZXBhcmF0b3IpO1xuICB9XG4gIHV0aWwyLmpvaW5WYWx1ZXMgPSBqb2luVmFsdWVzO1xuICB1dGlsMi5qc29uU3RyaW5naWZ5UmVwbGFjZXIgPSAoXywgdmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiKSB7XG4gICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufSkodXRpbCB8fCAodXRpbCA9IHt9KSk7XG52YXIgb2JqZWN0VXRpbDtcbihmdW5jdGlvbihvYmplY3RVdGlsMikge1xuICBvYmplY3RVdGlsMi5tZXJnZVNoYXBlcyA9IChmaXJzdCwgc2Vjb25kKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmZpcnN0LFxuICAgICAgLi4uc2Vjb25kXG4gICAgICAvLyBzZWNvbmQgb3ZlcndyaXRlcyBmaXJzdFxuICAgIH07XG4gIH07XG59KShvYmplY3RVdGlsIHx8IChvYmplY3RVdGlsID0ge30pKTtcbnZhciBab2RQYXJzZWRUeXBlID0gdXRpbC5hcnJheVRvRW51bShbXG4gIFwic3RyaW5nXCIsXG4gIFwibmFuXCIsXG4gIFwibnVtYmVyXCIsXG4gIFwiaW50ZWdlclwiLFxuICBcImZsb2F0XCIsXG4gIFwiYm9vbGVhblwiLFxuICBcImRhdGVcIixcbiAgXCJiaWdpbnRcIixcbiAgXCJzeW1ib2xcIixcbiAgXCJmdW5jdGlvblwiLFxuICBcInVuZGVmaW5lZFwiLFxuICBcIm51bGxcIixcbiAgXCJhcnJheVwiLFxuICBcIm9iamVjdFwiLFxuICBcInVua25vd25cIixcbiAgXCJwcm9taXNlXCIsXG4gIFwidm9pZFwiLFxuICBcIm5ldmVyXCIsXG4gIFwibWFwXCIsXG4gIFwic2V0XCJcbl0pO1xudmFyIGdldFBhcnNlZFR5cGUgPSAoZGF0YSkgPT4ge1xuICBjb25zdCB0ID0gdHlwZW9mIGRhdGE7XG4gIHN3aXRjaCAodCkge1xuICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZDtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5zdHJpbmc7XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgcmV0dXJuIGlzTmFOKGRhdGEpID8gWm9kUGFyc2VkVHlwZS5uYW4gOiBab2RQYXJzZWRUeXBlLm51bWJlcjtcbiAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuYm9vbGVhbjtcbiAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmZ1bmN0aW9uO1xuICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmJpZ2ludDtcbiAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5zeW1ib2w7XG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuYXJyYXk7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5udWxsO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEudGhlbiAmJiB0eXBlb2YgZGF0YS50aGVuID09PSBcImZ1bmN0aW9uXCIgJiYgZGF0YS5jYXRjaCAmJiB0eXBlb2YgZGF0YS5jYXRjaCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnByb21pc2U7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIE1hcCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkYXRhIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLm1hcDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgU2V0ICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuc2V0O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBEYXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmRhdGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5vYmplY3Q7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnVua25vd247XG4gIH1cbn07XG52YXIgWm9kSXNzdWVDb2RlID0gdXRpbC5hcnJheVRvRW51bShbXG4gIFwiaW52YWxpZF90eXBlXCIsXG4gIFwiaW52YWxpZF9saXRlcmFsXCIsXG4gIFwiY3VzdG9tXCIsXG4gIFwiaW52YWxpZF91bmlvblwiLFxuICBcImludmFsaWRfdW5pb25fZGlzY3JpbWluYXRvclwiLFxuICBcImludmFsaWRfZW51bV92YWx1ZVwiLFxuICBcInVucmVjb2duaXplZF9rZXlzXCIsXG4gIFwiaW52YWxpZF9hcmd1bWVudHNcIixcbiAgXCJpbnZhbGlkX3JldHVybl90eXBlXCIsXG4gIFwiaW52YWxpZF9kYXRlXCIsXG4gIFwiaW52YWxpZF9zdHJpbmdcIixcbiAgXCJ0b29fc21hbGxcIixcbiAgXCJ0b29fYmlnXCIsXG4gIFwiaW52YWxpZF9pbnRlcnNlY3Rpb25fdHlwZXNcIixcbiAgXCJub3RfbXVsdGlwbGVfb2ZcIixcbiAgXCJub3RfZmluaXRlXCJcbl0pO1xudmFyIHF1b3RlbGVzc0pzb24gPSAob2JqKSA9PiB7XG4gIGNvbnN0IGpzb24gPSBKU09OLnN0cmluZ2lmeShvYmosIG51bGwsIDIpO1xuICByZXR1cm4ganNvbi5yZXBsYWNlKC9cIihbXlwiXSspXCI6L2csIFwiJDE6XCIpO1xufTtcbnZhciBab2RFcnJvciA9IGNsYXNzIF9ab2RFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoaXNzdWVzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmlzc3VlcyA9IFtdO1xuICAgIHRoaXMuYWRkSXNzdWUgPSAoc3ViKSA9PiB7XG4gICAgICB0aGlzLmlzc3VlcyA9IFsuLi50aGlzLmlzc3Vlcywgc3ViXTtcbiAgICB9O1xuICAgIHRoaXMuYWRkSXNzdWVzID0gKHN1YnMgPSBbXSkgPT4ge1xuICAgICAgdGhpcy5pc3N1ZXMgPSBbLi4udGhpcy5pc3N1ZXMsIC4uLnN1YnNdO1xuICAgIH07XG4gICAgY29uc3QgYWN0dWFsUHJvdG8gPSBuZXcudGFyZ2V0LnByb3RvdHlwZTtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgYWN0dWFsUHJvdG8pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9fcHJvdG9fXyA9IGFjdHVhbFByb3RvO1xuICAgIH1cbiAgICB0aGlzLm5hbWUgPSBcIlpvZEVycm9yXCI7XG4gICAgdGhpcy5pc3N1ZXMgPSBpc3N1ZXM7XG4gIH1cbiAgZ2V0IGVycm9ycygpIHtcbiAgICByZXR1cm4gdGhpcy5pc3N1ZXM7XG4gIH1cbiAgZm9ybWF0KF9tYXBwZXIpIHtcbiAgICBjb25zdCBtYXBwZXIgPSBfbWFwcGVyIHx8IGZ1bmN0aW9uKGlzc3VlKSB7XG4gICAgICByZXR1cm4gaXNzdWUubWVzc2FnZTtcbiAgICB9O1xuICAgIGNvbnN0IGZpZWxkRXJyb3JzID0geyBfZXJyb3JzOiBbXSB9O1xuICAgIGNvbnN0IHByb2Nlc3NFcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBlcnJvci5pc3N1ZXMpIHtcbiAgICAgICAgaWYgKGlzc3VlLmNvZGUgPT09IFwiaW52YWxpZF91bmlvblwiKSB7XG4gICAgICAgICAgaXNzdWUudW5pb25FcnJvcnMubWFwKHByb2Nlc3NFcnJvcik7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNzdWUuY29kZSA9PT0gXCJpbnZhbGlkX3JldHVybl90eXBlXCIpIHtcbiAgICAgICAgICBwcm9jZXNzRXJyb3IoaXNzdWUucmV0dXJuVHlwZUVycm9yKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc3N1ZS5jb2RlID09PSBcImludmFsaWRfYXJndW1lbnRzXCIpIHtcbiAgICAgICAgICBwcm9jZXNzRXJyb3IoaXNzdWUuYXJndW1lbnRzRXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzc3VlLnBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZmllbGRFcnJvcnMuX2Vycm9ycy5wdXNoKG1hcHBlcihpc3N1ZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBjdXJyID0gZmllbGRFcnJvcnM7XG4gICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgIHdoaWxlIChpIDwgaXNzdWUucGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsID0gaXNzdWUucGF0aFtpXTtcbiAgICAgICAgICAgIGNvbnN0IHRlcm1pbmFsID0gaSA9PT0gaXNzdWUucGF0aC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgaWYgKCF0ZXJtaW5hbCkge1xuICAgICAgICAgICAgICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IHsgX2Vycm9yczogW10gfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGN1cnJbZWxdID0gY3VycltlbF0gfHwgeyBfZXJyb3JzOiBbXSB9O1xuICAgICAgICAgICAgICBjdXJyW2VsXS5fZXJyb3JzLnB1c2gobWFwcGVyKGlzc3VlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyID0gY3VycltlbF07XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBwcm9jZXNzRXJyb3IodGhpcyk7XG4gICAgcmV0dXJuIGZpZWxkRXJyb3JzO1xuICB9XG4gIHN0YXRpYyBhc3NlcnQodmFsdWUpIHtcbiAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIF9ab2RFcnJvcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm90IGEgWm9kRXJyb3I6ICR7dmFsdWV9YCk7XG4gICAgfVxuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XG4gIH1cbiAgZ2V0IG1lc3NhZ2UoKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuaXNzdWVzLCB1dGlsLmpzb25TdHJpbmdpZnlSZXBsYWNlciwgMik7XG4gIH1cbiAgZ2V0IGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNzdWVzLmxlbmd0aCA9PT0gMDtcbiAgfVxuICBmbGF0dGVuKG1hcHBlciA9IChpc3N1ZSkgPT4gaXNzdWUubWVzc2FnZSkge1xuICAgIGNvbnN0IGZpZWxkRXJyb3JzID0ge307XG4gICAgY29uc3QgZm9ybUVycm9ycyA9IFtdO1xuICAgIGZvciAoY29uc3Qgc3ViIG9mIHRoaXMuaXNzdWVzKSB7XG4gICAgICBpZiAoc3ViLnBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICBmaWVsZEVycm9yc1tzdWIucGF0aFswXV0gPSBmaWVsZEVycm9yc1tzdWIucGF0aFswXV0gfHwgW107XG4gICAgICAgIGZpZWxkRXJyb3JzW3N1Yi5wYXRoWzBdXS5wdXNoKG1hcHBlcihzdWIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcm1FcnJvcnMucHVzaChtYXBwZXIoc3ViKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGZvcm1FcnJvcnMsIGZpZWxkRXJyb3JzIH07XG4gIH1cbiAgZ2V0IGZvcm1FcnJvcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmxhdHRlbigpO1xuICB9XG59O1xuWm9kRXJyb3IuY3JlYXRlID0gKGlzc3VlcykgPT4ge1xuICBjb25zdCBlcnJvciA9IG5ldyBab2RFcnJvcihpc3N1ZXMpO1xuICByZXR1cm4gZXJyb3I7XG59O1xudmFyIGVycm9yTWFwID0gKGlzc3VlLCBfY3R4KSA9PiB7XG4gIGxldCBtZXNzYWdlO1xuICBzd2l0Y2ggKGlzc3VlLmNvZGUpIHtcbiAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGU6XG4gICAgICBpZiAoaXNzdWUucmVjZWl2ZWQgPT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBcIlJlcXVpcmVkXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXNzYWdlID0gYEV4cGVjdGVkICR7aXNzdWUuZXhwZWN0ZWR9LCByZWNlaXZlZCAke2lzc3VlLnJlY2VpdmVkfWA7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2xpdGVyYWw6XG4gICAgICBtZXNzYWdlID0gYEludmFsaWQgbGl0ZXJhbCB2YWx1ZSwgZXhwZWN0ZWQgJHtKU09OLnN0cmluZ2lmeShpc3N1ZS5leHBlY3RlZCwgdXRpbC5qc29uU3RyaW5naWZ5UmVwbGFjZXIpfWA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFpvZElzc3VlQ29kZS51bnJlY29nbml6ZWRfa2V5czpcbiAgICAgIG1lc3NhZ2UgPSBgVW5yZWNvZ25pemVkIGtleShzKSBpbiBvYmplY3Q6ICR7dXRpbC5qb2luVmFsdWVzKGlzc3VlLmtleXMsIFwiLCBcIil9YDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb246XG4gICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXRgO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbl9kaXNjcmltaW5hdG9yOlxuICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGRpc2NyaW1pbmF0b3IgdmFsdWUuIEV4cGVjdGVkICR7dXRpbC5qb2luVmFsdWVzKGlzc3VlLm9wdGlvbnMpfWA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2VudW1fdmFsdWU6XG4gICAgICBtZXNzYWdlID0gYEludmFsaWQgZW51bSB2YWx1ZS4gRXhwZWN0ZWQgJHt1dGlsLmpvaW5WYWx1ZXMoaXNzdWUub3B0aW9ucyl9LCByZWNlaXZlZCAnJHtpc3N1ZS5yZWNlaXZlZH0nYDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfYXJndW1lbnRzOlxuICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGZ1bmN0aW9uIGFyZ3VtZW50c2A7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3JldHVybl90eXBlOlxuICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGZ1bmN0aW9uIHJldHVybiB0eXBlYDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfZGF0ZTpcbiAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBkYXRlYDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nOlxuICAgICAgaWYgKHR5cGVvZiBpc3N1ZS52YWxpZGF0aW9uID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmIChcImluY2x1ZGVzXCIgaW4gaXNzdWUudmFsaWRhdGlvbikge1xuICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dDogbXVzdCBpbmNsdWRlIFwiJHtpc3N1ZS52YWxpZGF0aW9uLmluY2x1ZGVzfVwiYDtcbiAgICAgICAgICBpZiAodHlwZW9mIGlzc3VlLnZhbGlkYXRpb24ucG9zaXRpb24gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgJHttZXNzYWdlfSBhdCBvbmUgb3IgbW9yZSBwb3NpdGlvbnMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICR7aXNzdWUudmFsaWRhdGlvbi5wb3NpdGlvbn1gO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChcInN0YXJ0c1dpdGhcIiBpbiBpc3N1ZS52YWxpZGF0aW9uKSB7XG4gICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0OiBtdXN0IHN0YXJ0IHdpdGggXCIke2lzc3VlLnZhbGlkYXRpb24uc3RhcnRzV2l0aH1cImA7XG4gICAgICAgIH0gZWxzZSBpZiAoXCJlbmRzV2l0aFwiIGluIGlzc3VlLnZhbGlkYXRpb24pIHtcbiAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXQ6IG11c3QgZW5kIHdpdGggXCIke2lzc3VlLnZhbGlkYXRpb24uZW5kc1dpdGh9XCJgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoaXNzdWUudmFsaWRhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNzdWUudmFsaWRhdGlvbiAhPT0gXCJyZWdleFwiKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCAke2lzc3VlLnZhbGlkYXRpb259YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lc3NhZ2UgPSBcIkludmFsaWRcIjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWm9kSXNzdWVDb2RlLnRvb19zbWFsbDpcbiAgICAgIGlmIChpc3N1ZS50eXBlID09PSBcImFycmF5XCIpXG4gICAgICAgIG1lc3NhZ2UgPSBgQXJyYXkgbXVzdCBjb250YWluICR7aXNzdWUuZXhhY3QgPyBcImV4YWN0bHlcIiA6IGlzc3VlLmluY2x1c2l2ZSA/IGBhdCBsZWFzdGAgOiBgbW9yZSB0aGFuYH0gJHtpc3N1ZS5taW5pbXVtfSBlbGVtZW50KHMpYDtcbiAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwic3RyaW5nXCIpXG4gICAgICAgIG1lc3NhZ2UgPSBgU3RyaW5nIG11c3QgY29udGFpbiAke2lzc3VlLmV4YWN0ID8gXCJleGFjdGx5XCIgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbGVhc3RgIDogYG92ZXJgfSAke2lzc3VlLm1pbmltdW19IGNoYXJhY3RlcihzKWA7XG4gICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcIm51bWJlclwiKVxuICAgICAgICBtZXNzYWdlID0gYE51bWJlciBtdXN0IGJlICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseSBlcXVhbCB0byBgIDogaXNzdWUuaW5jbHVzaXZlID8gYGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgIDogYGdyZWF0ZXIgdGhhbiBgfSR7aXNzdWUubWluaW11bX1gO1xuICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJkYXRlXCIpXG4gICAgICAgIG1lc3NhZ2UgPSBgRGF0ZSBtdXN0IGJlICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseSBlcXVhbCB0byBgIDogaXNzdWUuaW5jbHVzaXZlID8gYGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgIDogYGdyZWF0ZXIgdGhhbiBgfSR7bmV3IERhdGUoTnVtYmVyKGlzc3VlLm1pbmltdW0pKX1gO1xuICAgICAgZWxzZVxuICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkIGlucHV0XCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFpvZElzc3VlQ29kZS50b29fYmlnOlxuICAgICAgaWYgKGlzc3VlLnR5cGUgPT09IFwiYXJyYXlcIilcbiAgICAgICAgbWVzc2FnZSA9IGBBcnJheSBtdXN0IGNvbnRhaW4gJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5YCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBhdCBtb3N0YCA6IGBsZXNzIHRoYW5gfSAke2lzc3VlLm1heGltdW19IGVsZW1lbnQocylgO1xuICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgbWVzc2FnZSA9IGBTdHJpbmcgbXVzdCBjb250YWluICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseWAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbW9zdGAgOiBgdW5kZXJgfSAke2lzc3VlLm1heGltdW19IGNoYXJhY3RlcihzKWA7XG4gICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcIm51bWJlclwiKVxuICAgICAgICBtZXNzYWdlID0gYE51bWJlciBtdXN0IGJlICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseWAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgbGVzcyB0aGFuIG9yIGVxdWFsIHRvYCA6IGBsZXNzIHRoYW5gfSAke2lzc3VlLm1heGltdW19YDtcbiAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwiYmlnaW50XCIpXG4gICAgICAgIG1lc3NhZ2UgPSBgQmlnSW50IG11c3QgYmUgJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5YCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBsZXNzIHRoYW4gb3IgZXF1YWwgdG9gIDogYGxlc3MgdGhhbmB9ICR7aXNzdWUubWF4aW11bX1gO1xuICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJkYXRlXCIpXG4gICAgICAgIG1lc3NhZ2UgPSBgRGF0ZSBtdXN0IGJlICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseWAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgc21hbGxlciB0aGFuIG9yIGVxdWFsIHRvYCA6IGBzbWFsbGVyIHRoYW5gfSAke25ldyBEYXRlKE51bWJlcihpc3N1ZS5tYXhpbXVtKSl9YDtcbiAgICAgIGVsc2VcbiAgICAgICAgbWVzc2FnZSA9IFwiSW52YWxpZCBpbnB1dFwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBab2RJc3N1ZUNvZGUuY3VzdG9tOlxuICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0YDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfaW50ZXJzZWN0aW9uX3R5cGVzOlxuICAgICAgbWVzc2FnZSA9IGBJbnRlcnNlY3Rpb24gcmVzdWx0cyBjb3VsZCBub3QgYmUgbWVyZ2VkYDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWm9kSXNzdWVDb2RlLm5vdF9tdWx0aXBsZV9vZjpcbiAgICAgIG1lc3NhZ2UgPSBgTnVtYmVyIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAke2lzc3VlLm11bHRpcGxlT2Z9YDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWm9kSXNzdWVDb2RlLm5vdF9maW5pdGU6XG4gICAgICBtZXNzYWdlID0gXCJOdW1iZXIgbXVzdCBiZSBmaW5pdGVcIjtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBtZXNzYWdlID0gX2N0eC5kZWZhdWx0RXJyb3I7XG4gICAgICB1dGlsLmFzc2VydE5ldmVyKGlzc3VlKTtcbiAgfVxuICByZXR1cm4geyBtZXNzYWdlIH07XG59O1xudmFyIG92ZXJyaWRlRXJyb3JNYXAgPSBlcnJvck1hcDtcbmZ1bmN0aW9uIHNldEVycm9yTWFwKG1hcCkge1xuICBvdmVycmlkZUVycm9yTWFwID0gbWFwO1xufVxuZnVuY3Rpb24gZ2V0RXJyb3JNYXAoKSB7XG4gIHJldHVybiBvdmVycmlkZUVycm9yTWFwO1xufVxudmFyIG1ha2VJc3N1ZSA9IChwYXJhbXMpID0+IHtcbiAgY29uc3QgeyBkYXRhLCBwYXRoLCBlcnJvck1hcHMsIGlzc3VlRGF0YSB9ID0gcGFyYW1zO1xuICBjb25zdCBmdWxsUGF0aCA9IFsuLi5wYXRoLCAuLi5pc3N1ZURhdGEucGF0aCB8fCBbXV07XG4gIGNvbnN0IGZ1bGxJc3N1ZSA9IHtcbiAgICAuLi5pc3N1ZURhdGEsXG4gICAgcGF0aDogZnVsbFBhdGhcbiAgfTtcbiAgaWYgKGlzc3VlRGF0YS5tZXNzYWdlICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uaXNzdWVEYXRhLFxuICAgICAgcGF0aDogZnVsbFBhdGgsXG4gICAgICBtZXNzYWdlOiBpc3N1ZURhdGEubWVzc2FnZVxuICAgIH07XG4gIH1cbiAgbGV0IGVycm9yTWVzc2FnZSA9IFwiXCI7XG4gIGNvbnN0IG1hcHMgPSBlcnJvck1hcHMuZmlsdGVyKChtKSA9PiAhIW0pLnNsaWNlKCkucmV2ZXJzZSgpO1xuICBmb3IgKGNvbnN0IG1hcCBvZiBtYXBzKSB7XG4gICAgZXJyb3JNZXNzYWdlID0gbWFwKGZ1bGxJc3N1ZSwgeyBkYXRhLCBkZWZhdWx0RXJyb3I6IGVycm9yTWVzc2FnZSB9KS5tZXNzYWdlO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uaXNzdWVEYXRhLFxuICAgIHBhdGg6IGZ1bGxQYXRoLFxuICAgIG1lc3NhZ2U6IGVycm9yTWVzc2FnZVxuICB9O1xufTtcbnZhciBFTVBUWV9QQVRIID0gW107XG5mdW5jdGlvbiBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIGlzc3VlRGF0YSkge1xuICBjb25zdCBvdmVycmlkZU1hcCA9IGdldEVycm9yTWFwKCk7XG4gIGNvbnN0IGlzc3VlID0gbWFrZUlzc3VlKHtcbiAgICBpc3N1ZURhdGEsXG4gICAgZGF0YTogY3R4LmRhdGEsXG4gICAgcGF0aDogY3R4LnBhdGgsXG4gICAgZXJyb3JNYXBzOiBbXG4gICAgICBjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCxcbiAgICAgIGN0eC5zY2hlbWFFcnJvck1hcCxcbiAgICAgIG92ZXJyaWRlTWFwLFxuICAgICAgb3ZlcnJpZGVNYXAgPT09IGVycm9yTWFwID8gdm9pZCAwIDogZXJyb3JNYXBcbiAgICAgIC8vIHRoZW4gZ2xvYmFsIGRlZmF1bHQgbWFwXG4gICAgXS5maWx0ZXIoKHgpID0+ICEheClcbiAgfSk7XG4gIGN0eC5jb21tb24uaXNzdWVzLnB1c2goaXNzdWUpO1xufVxudmFyIFBhcnNlU3RhdHVzID0gY2xhc3MgX1BhcnNlU3RhdHVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy52YWx1ZSA9IFwidmFsaWRcIjtcbiAgfVxuICBkaXJ0eSgpIHtcbiAgICBpZiAodGhpcy52YWx1ZSA9PT0gXCJ2YWxpZFwiKVxuICAgICAgdGhpcy52YWx1ZSA9IFwiZGlydHlcIjtcbiAgfVxuICBhYm9ydCgpIHtcbiAgICBpZiAodGhpcy52YWx1ZSAhPT0gXCJhYm9ydGVkXCIpXG4gICAgICB0aGlzLnZhbHVlID0gXCJhYm9ydGVkXCI7XG4gIH1cbiAgc3RhdGljIG1lcmdlQXJyYXkoc3RhdHVzLCByZXN1bHRzKSB7XG4gICAgY29uc3QgYXJyYXlWYWx1ZSA9IFtdO1xuICAgIGZvciAoY29uc3QgcyBvZiByZXN1bHRzKSB7XG4gICAgICBpZiAocy5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgIGlmIChzLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgIGFycmF5VmFsdWUucHVzaChzLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBhcnJheVZhbHVlIH07XG4gIH1cbiAgc3RhdGljIGFzeW5jIG1lcmdlT2JqZWN0QXN5bmMoc3RhdHVzLCBwYWlycykge1xuICAgIGNvbnN0IHN5bmNQYWlycyA9IFtdO1xuICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgY29uc3Qga2V5ID0gYXdhaXQgcGFpci5rZXk7XG4gICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHBhaXIudmFsdWU7XG4gICAgICBzeW5jUGFpcnMucHVzaCh7XG4gICAgICAgIGtleSxcbiAgICAgICAgdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gX1BhcnNlU3RhdHVzLm1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHN5bmNQYWlycyk7XG4gIH1cbiAgc3RhdGljIG1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHBhaXJzKSB7XG4gICAgY29uc3QgZmluYWxPYmplY3QgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcbiAgICAgIGNvbnN0IHsga2V5LCB2YWx1ZSB9ID0gcGFpcjtcbiAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICBpZiAodmFsdWUuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgIGlmICh2YWx1ZS5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICBpZiAoa2V5LnZhbHVlICE9PSBcIl9fcHJvdG9fX1wiICYmICh0eXBlb2YgdmFsdWUudmFsdWUgIT09IFwidW5kZWZpbmVkXCIgfHwgcGFpci5hbHdheXNTZXQpKSB7XG4gICAgICAgIGZpbmFsT2JqZWN0W2tleS52YWx1ZV0gPSB2YWx1ZS52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBmaW5hbE9iamVjdCB9O1xuICB9XG59O1xudmFyIElOVkFMSUQgPSBPYmplY3QuZnJlZXplKHtcbiAgc3RhdHVzOiBcImFib3J0ZWRcIlxufSk7XG52YXIgRElSVFkgPSAodmFsdWUpID0+ICh7IHN0YXR1czogXCJkaXJ0eVwiLCB2YWx1ZSB9KTtcbnZhciBPSyA9ICh2YWx1ZSkgPT4gKHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlIH0pO1xudmFyIGlzQWJvcnRlZCA9ICh4KSA9PiB4LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCI7XG52YXIgaXNEaXJ0eSA9ICh4KSA9PiB4LnN0YXR1cyA9PT0gXCJkaXJ0eVwiO1xudmFyIGlzVmFsaWQgPSAoeCkgPT4geC5zdGF0dXMgPT09IFwidmFsaWRcIjtcbnZhciBpc0FzeW5jID0gKHgpID0+IHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiICYmIHggaW5zdGFuY2VvZiBQcm9taXNlO1xuZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG59XG5mdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgaWYgKGtpbmQgPT09IFwibVwiKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gIGlmIChraW5kID09PSBcImFcIiAmJiAhZilcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gIHJldHVybiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpLCB2YWx1ZTtcbn1cbnZhciBlcnJvclV0aWw7XG4oZnVuY3Rpb24oZXJyb3JVdGlsMikge1xuICBlcnJvclV0aWwyLmVyclRvT2JqID0gKG1lc3NhZ2UpID0+IHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiID8geyBtZXNzYWdlIH0gOiBtZXNzYWdlIHx8IHt9O1xuICBlcnJvclV0aWwyLnRvU3RyaW5nID0gKG1lc3NhZ2UpID0+IHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiID8gbWVzc2FnZSA6IG1lc3NhZ2UgPT09IG51bGwgfHwgbWVzc2FnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWVzc2FnZS5tZXNzYWdlO1xufSkoZXJyb3JVdGlsIHx8IChlcnJvclV0aWwgPSB7fSkpO1xudmFyIF9ab2RFbnVtX2NhY2hlO1xudmFyIF9ab2ROYXRpdmVFbnVtX2NhY2hlO1xudmFyIFBhcnNlSW5wdXRMYXp5UGF0aCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IocGFyZW50LCB2YWx1ZSwgcGF0aCwga2V5KSB7XG4gICAgdGhpcy5fY2FjaGVkUGF0aCA9IFtdO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMuZGF0YSA9IHZhbHVlO1xuICAgIHRoaXMuX3BhdGggPSBwYXRoO1xuICAgIHRoaXMuX2tleSA9IGtleTtcbiAgfVxuICBnZXQgcGF0aCgpIHtcbiAgICBpZiAoIXRoaXMuX2NhY2hlZFBhdGgubGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5fa2V5IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgdGhpcy5fY2FjaGVkUGF0aC5wdXNoKC4uLnRoaXMuX3BhdGgsIC4uLnRoaXMuX2tleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jYWNoZWRQYXRoLnB1c2goLi4udGhpcy5fcGF0aCwgdGhpcy5fa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZFBhdGg7XG4gIH1cbn07XG52YXIgaGFuZGxlUmVzdWx0ID0gKGN0eCwgcmVzdWx0KSA9PiB7XG4gIGlmIChpc1ZhbGlkKHJlc3VsdCkpIHtcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBkYXRhOiByZXN1bHQudmFsdWUgfTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWN0eC5jb21tb24uaXNzdWVzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsaWRhdGlvbiBmYWlsZWQgYnV0IG5vIGlzc3VlcyBkZXRlY3RlZC5cIik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGdldCBlcnJvcigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Vycm9yKVxuICAgICAgICAgIHJldHVybiB0aGlzLl9lcnJvcjtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgWm9kRXJyb3IoY3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICB0aGlzLl9lcnJvciA9IGVycm9yO1xuICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3I7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIHByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSB7XG4gIGlmICghcGFyYW1zKVxuICAgIHJldHVybiB7fTtcbiAgY29uc3QgeyBlcnJvck1hcDogZXJyb3JNYXAyLCBpbnZhbGlkX3R5cGVfZXJyb3IsIHJlcXVpcmVkX2Vycm9yLCBkZXNjcmlwdGlvbiB9ID0gcGFyYW1zO1xuICBpZiAoZXJyb3JNYXAyICYmIChpbnZhbGlkX3R5cGVfZXJyb3IgfHwgcmVxdWlyZWRfZXJyb3IpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCB1c2UgXCJpbnZhbGlkX3R5cGVfZXJyb3JcIiBvciBcInJlcXVpcmVkX2Vycm9yXCIgaW4gY29uanVuY3Rpb24gd2l0aCBjdXN0b20gZXJyb3IgbWFwLmApO1xuICB9XG4gIGlmIChlcnJvck1hcDIpXG4gICAgcmV0dXJuIHsgZXJyb3JNYXA6IGVycm9yTWFwMiwgZGVzY3JpcHRpb24gfTtcbiAgY29uc3QgY3VzdG9tTWFwID0gKGlzcywgY3R4KSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCB7IG1lc3NhZ2UgfSA9IHBhcmFtcztcbiAgICBpZiAoaXNzLmNvZGUgPT09IFwiaW52YWxpZF9lbnVtX3ZhbHVlXCIpIHtcbiAgICAgIHJldHVybiB7IG1lc3NhZ2U6IG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6IGN0eC5kZWZhdWx0RXJyb3IgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjdHguZGF0YSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHsgbWVzc2FnZTogKF9hID0gbWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgPyBtZXNzYWdlIDogcmVxdWlyZWRfZXJyb3IpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGN0eC5kZWZhdWx0RXJyb3IgfTtcbiAgICB9XG4gICAgaWYgKGlzcy5jb2RlICE9PSBcImludmFsaWRfdHlwZVwiKVxuICAgICAgcmV0dXJuIHsgbWVzc2FnZTogY3R4LmRlZmF1bHRFcnJvciB9O1xuICAgIHJldHVybiB7IG1lc3NhZ2U6IChfYiA9IG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6IGludmFsaWRfdHlwZV9lcnJvcikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogY3R4LmRlZmF1bHRFcnJvciB9O1xuICB9O1xuICByZXR1cm4geyBlcnJvck1hcDogY3VzdG9tTWFwLCBkZXNjcmlwdGlvbiB9O1xufVxudmFyIFpvZFR5cGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGRlZikge1xuICAgIHRoaXMuc3BhID0gdGhpcy5zYWZlUGFyc2VBc3luYztcbiAgICB0aGlzLl9kZWYgPSBkZWY7XG4gICAgdGhpcy5wYXJzZSA9IHRoaXMucGFyc2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLnNhZmVQYXJzZSA9IHRoaXMuc2FmZVBhcnNlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5wYXJzZUFzeW5jID0gdGhpcy5wYXJzZUFzeW5jLmJpbmQodGhpcyk7XG4gICAgdGhpcy5zYWZlUGFyc2VBc3luYyA9IHRoaXMuc2FmZVBhcnNlQXN5bmMuYmluZCh0aGlzKTtcbiAgICB0aGlzLnNwYSA9IHRoaXMuc3BhLmJpbmQodGhpcyk7XG4gICAgdGhpcy5yZWZpbmUgPSB0aGlzLnJlZmluZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMucmVmaW5lbWVudCA9IHRoaXMucmVmaW5lbWVudC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuc3VwZXJSZWZpbmUgPSB0aGlzLnN1cGVyUmVmaW5lLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vcHRpb25hbCA9IHRoaXMub3B0aW9uYWwuYmluZCh0aGlzKTtcbiAgICB0aGlzLm51bGxhYmxlID0gdGhpcy5udWxsYWJsZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMubnVsbGlzaCA9IHRoaXMubnVsbGlzaC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuYXJyYXkgPSB0aGlzLmFycmF5LmJpbmQodGhpcyk7XG4gICAgdGhpcy5wcm9taXNlID0gdGhpcy5wcm9taXNlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vciA9IHRoaXMub3IuYmluZCh0aGlzKTtcbiAgICB0aGlzLmFuZCA9IHRoaXMuYW5kLmJpbmQodGhpcyk7XG4gICAgdGhpcy50cmFuc2Zvcm0gPSB0aGlzLnRyYW5zZm9ybS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuYnJhbmQgPSB0aGlzLmJyYW5kLmJpbmQodGhpcyk7XG4gICAgdGhpcy5kZWZhdWx0ID0gdGhpcy5kZWZhdWx0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5jYXRjaCA9IHRoaXMuY2F0Y2guYmluZCh0aGlzKTtcbiAgICB0aGlzLmRlc2NyaWJlID0gdGhpcy5kZXNjcmliZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMucGlwZSA9IHRoaXMucGlwZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMucmVhZG9ubHkgPSB0aGlzLnJlYWRvbmx5LmJpbmQodGhpcyk7XG4gICAgdGhpcy5pc051bGxhYmxlID0gdGhpcy5pc051bGxhYmxlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5pc09wdGlvbmFsID0gdGhpcy5pc09wdGlvbmFsLmJpbmQodGhpcyk7XG4gIH1cbiAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuZGVzY3JpcHRpb247XG4gIH1cbiAgX2dldFR5cGUoaW5wdXQpIHtcbiAgICByZXR1cm4gZ2V0UGFyc2VkVHlwZShpbnB1dC5kYXRhKTtcbiAgfVxuICBfZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCkge1xuICAgIHJldHVybiBjdHggfHwge1xuICAgICAgY29tbW9uOiBpbnB1dC5wYXJlbnQuY29tbW9uLFxuICAgICAgZGF0YTogaW5wdXQuZGF0YSxcbiAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoaW5wdXQuZGF0YSksXG4gICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgcGF0aDogaW5wdXQucGF0aCxcbiAgICAgIHBhcmVudDogaW5wdXQucGFyZW50XG4gICAgfTtcbiAgfVxuICBfcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1czogbmV3IFBhcnNlU3RhdHVzKCksXG4gICAgICBjdHg6IHtcbiAgICAgICAgY29tbW9uOiBpbnB1dC5wYXJlbnQuY29tbW9uLFxuICAgICAgICBkYXRhOiBpbnB1dC5kYXRhLFxuICAgICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGlucHV0LmRhdGEpLFxuICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICBwYXRoOiBpbnB1dC5wYXRoLFxuICAgICAgICBwYXJlbnQ6IGlucHV0LnBhcmVudFxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgX3BhcnNlU3luYyhpbnB1dCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlKGlucHV0KTtcbiAgICBpZiAoaXNBc3luYyhyZXN1bHQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTeW5jaHJvbm91cyBwYXJzZSBlbmNvdW50ZXJlZCBwcm9taXNlLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBfcGFyc2VBc3luYyhpbnB1dCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlKGlucHV0KTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gIH1cbiAgcGFyc2UoZGF0YSwgcGFyYW1zKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5zYWZlUGFyc2UoZGF0YSwgcGFyYW1zKTtcbiAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpXG4gICAgICByZXR1cm4gcmVzdWx0LmRhdGE7XG4gICAgdGhyb3cgcmVzdWx0LmVycm9yO1xuICB9XG4gIHNhZmVQYXJzZShkYXRhLCBwYXJhbXMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgY3R4ID0ge1xuICAgICAgY29tbW9uOiB7XG4gICAgICAgIGlzc3VlczogW10sXG4gICAgICAgIGFzeW5jOiAoX2EgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYXN5bmMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlLFxuICAgICAgICBjb250ZXh0dWFsRXJyb3JNYXA6IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5lcnJvck1hcFxuICAgICAgfSxcbiAgICAgIHBhdGg6IChwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMucGF0aCkgfHwgW10sXG4gICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgZGF0YSxcbiAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoZGF0YSlcbiAgICB9O1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlU3luYyh7IGRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KTtcbiAgICByZXR1cm4gaGFuZGxlUmVzdWx0KGN0eCwgcmVzdWx0KTtcbiAgfVxuICBhc3luYyBwYXJzZUFzeW5jKGRhdGEsIHBhcmFtcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuc2FmZVBhcnNlQXN5bmMoZGF0YSwgcGFyYW1zKTtcbiAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpXG4gICAgICByZXR1cm4gcmVzdWx0LmRhdGE7XG4gICAgdGhyb3cgcmVzdWx0LmVycm9yO1xuICB9XG4gIGFzeW5jIHNhZmVQYXJzZUFzeW5jKGRhdGEsIHBhcmFtcykge1xuICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgIGNvbW1vbjoge1xuICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICBjb250ZXh0dWFsRXJyb3JNYXA6IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5lcnJvck1hcCxcbiAgICAgICAgYXN5bmM6IHRydWVcbiAgICAgIH0sXG4gICAgICBwYXRoOiAocGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLnBhdGgpIHx8IFtdLFxuICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgIGRhdGEsXG4gICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGRhdGEpXG4gICAgfTtcbiAgICBjb25zdCBtYXliZUFzeW5jUmVzdWx0ID0gdGhpcy5fcGFyc2UoeyBkYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgKGlzQXN5bmMobWF5YmVBc3luY1Jlc3VsdCkgPyBtYXliZUFzeW5jUmVzdWx0IDogUHJvbWlzZS5yZXNvbHZlKG1heWJlQXN5bmNSZXN1bHQpKTtcbiAgICByZXR1cm4gaGFuZGxlUmVzdWx0KGN0eCwgcmVzdWx0KTtcbiAgfVxuICByZWZpbmUoY2hlY2ssIG1lc3NhZ2UpIHtcbiAgICBjb25zdCBnZXRJc3N1ZVByb3BlcnRpZXMgPSAodmFsKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIG1lc3NhZ2UgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIHsgbWVzc2FnZSB9O1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlKHZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB0aGlzLl9yZWZpbmVtZW50KCh2YWwsIGN0eCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gY2hlY2sodmFsKTtcbiAgICAgIGNvbnN0IHNldEVycm9yID0gKCkgPT4gY3R4LmFkZElzc3VlKHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmN1c3RvbSxcbiAgICAgICAgLi4uZ2V0SXNzdWVQcm9wZXJ0aWVzKHZhbClcbiAgICAgIH0pO1xuICAgICAgaWYgKHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiICYmIHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICBzZXRFcnJvcigpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgc2V0RXJyb3IoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmVmaW5lbWVudChjaGVjaywgcmVmaW5lbWVudERhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVmaW5lbWVudCgodmFsLCBjdHgpID0+IHtcbiAgICAgIGlmICghY2hlY2sodmFsKSkge1xuICAgICAgICBjdHguYWRkSXNzdWUodHlwZW9mIHJlZmluZW1lbnREYXRhID09PSBcImZ1bmN0aW9uXCIgPyByZWZpbmVtZW50RGF0YSh2YWwsIGN0eCkgOiByZWZpbmVtZW50RGF0YSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF9yZWZpbmVtZW50KHJlZmluZW1lbnQpIHtcbiAgICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xuICAgICAgc2NoZW1hOiB0aGlzLFxuICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzLFxuICAgICAgZWZmZWN0OiB7IHR5cGU6IFwicmVmaW5lbWVudFwiLCByZWZpbmVtZW50IH1cbiAgICB9KTtcbiAgfVxuICBzdXBlclJlZmluZShyZWZpbmVtZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlZmluZW1lbnQocmVmaW5lbWVudCk7XG4gIH1cbiAgb3B0aW9uYWwoKSB7XG4gICAgcmV0dXJuIFpvZE9wdGlvbmFsLmNyZWF0ZSh0aGlzLCB0aGlzLl9kZWYpO1xuICB9XG4gIG51bGxhYmxlKCkge1xuICAgIHJldHVybiBab2ROdWxsYWJsZS5jcmVhdGUodGhpcywgdGhpcy5fZGVmKTtcbiAgfVxuICBudWxsaXNoKCkge1xuICAgIHJldHVybiB0aGlzLm51bGxhYmxlKCkub3B0aW9uYWwoKTtcbiAgfVxuICBhcnJheSgpIHtcbiAgICByZXR1cm4gWm9kQXJyYXkuY3JlYXRlKHRoaXMsIHRoaXMuX2RlZik7XG4gIH1cbiAgcHJvbWlzZSgpIHtcbiAgICByZXR1cm4gWm9kUHJvbWlzZS5jcmVhdGUodGhpcywgdGhpcy5fZGVmKTtcbiAgfVxuICBvcihvcHRpb24pIHtcbiAgICByZXR1cm4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBvcHRpb25dLCB0aGlzLl9kZWYpO1xuICB9XG4gIGFuZChpbmNvbWluZykge1xuICAgIHJldHVybiBab2RJbnRlcnNlY3Rpb24uY3JlYXRlKHRoaXMsIGluY29taW5nLCB0aGlzLl9kZWYpO1xuICB9XG4gIHRyYW5zZm9ybSh0cmFuc2Zvcm0pIHtcbiAgICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xuICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlzLl9kZWYpLFxuICAgICAgc2NoZW1hOiB0aGlzLFxuICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzLFxuICAgICAgZWZmZWN0OiB7IHR5cGU6IFwidHJhbnNmb3JtXCIsIHRyYW5zZm9ybSB9XG4gICAgfSk7XG4gIH1cbiAgZGVmYXVsdChkZWYpIHtcbiAgICBjb25zdCBkZWZhdWx0VmFsdWVGdW5jID0gdHlwZW9mIGRlZiA9PT0gXCJmdW5jdGlvblwiID8gZGVmIDogKCkgPT4gZGVmO1xuICAgIHJldHVybiBuZXcgWm9kRGVmYXVsdCh7XG4gICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXMuX2RlZiksXG4gICAgICBpbm5lclR5cGU6IHRoaXMsXG4gICAgICBkZWZhdWx0VmFsdWU6IGRlZmF1bHRWYWx1ZUZ1bmMsXG4gICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZERlZmF1bHRcbiAgICB9KTtcbiAgfVxuICBicmFuZCgpIHtcbiAgICByZXR1cm4gbmV3IFpvZEJyYW5kZWQoe1xuICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RCcmFuZGVkLFxuICAgICAgdHlwZTogdGhpcyxcbiAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcy5fZGVmKVxuICAgIH0pO1xuICB9XG4gIGNhdGNoKGRlZikge1xuICAgIGNvbnN0IGNhdGNoVmFsdWVGdW5jID0gdHlwZW9mIGRlZiA9PT0gXCJmdW5jdGlvblwiID8gZGVmIDogKCkgPT4gZGVmO1xuICAgIHJldHVybiBuZXcgWm9kQ2F0Y2goe1xuICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlzLl9kZWYpLFxuICAgICAgaW5uZXJUeXBlOiB0aGlzLFxuICAgICAgY2F0Y2hWYWx1ZTogY2F0Y2hWYWx1ZUZ1bmMsXG4gICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZENhdGNoXG4gICAgfSk7XG4gIH1cbiAgZGVzY3JpYmUoZGVzY3JpcHRpb24pIHtcbiAgICBjb25zdCBUaGlzID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gbmV3IFRoaXMoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgZGVzY3JpcHRpb25cbiAgICB9KTtcbiAgfVxuICBwaXBlKHRhcmdldCkge1xuICAgIHJldHVybiBab2RQaXBlbGluZS5jcmVhdGUodGhpcywgdGFyZ2V0KTtcbiAgfVxuICByZWFkb25seSgpIHtcbiAgICByZXR1cm4gWm9kUmVhZG9ubHkuY3JlYXRlKHRoaXMpO1xuICB9XG4gIGlzT3B0aW9uYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2FmZVBhcnNlKHZvaWQgMCkuc3VjY2VzcztcbiAgfVxuICBpc051bGxhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnNhZmVQYXJzZShudWxsKS5zdWNjZXNzO1xuICB9XG59O1xudmFyIGN1aWRSZWdleCA9IC9eY1teXFxzLV17OCx9JC9pO1xudmFyIGN1aWQyUmVnZXggPSAvXlswLTlhLXpdKyQvO1xudmFyIHVsaWRSZWdleCA9IC9eWzAtOUEtSEpLTU5QLVRWLVpdezI2fSQvO1xudmFyIHV1aWRSZWdleCA9IC9eWzAtOWEtZkEtRl17OH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17MTJ9JC9pO1xudmFyIG5hbm9pZFJlZ2V4ID0gL15bYS16MC05Xy1dezIxfSQvaTtcbnZhciBkdXJhdGlvblJlZ2V4ID0gL15bLStdP1AoPyEkKSg/Oig/OlstK10/XFxkK1kpfCg/OlstK10/XFxkK1suLF1cXGQrWSQpKT8oPzooPzpbLStdP1xcZCtNKXwoPzpbLStdP1xcZCtbLixdXFxkK00kKSk/KD86KD86Wy0rXT9cXGQrVyl8KD86Wy0rXT9cXGQrWy4sXVxcZCtXJCkpPyg/Oig/OlstK10/XFxkK0QpfCg/OlstK10/XFxkK1suLF1cXGQrRCQpKT8oPzpUKD89W1xcZCstXSkoPzooPzpbLStdP1xcZCtIKXwoPzpbLStdP1xcZCtbLixdXFxkK0gkKSk/KD86KD86Wy0rXT9cXGQrTSl8KD86Wy0rXT9cXGQrWy4sXVxcZCtNJCkpPyg/OlstK10/XFxkKyg/OlsuLF1cXGQrKT9TKT8pPz8kLztcbnZhciBlbWFpbFJlZ2V4ID0gL14oPyFcXC4pKD8hLipcXC5cXC4pKFtBLVowLTlfJytcXC1cXC5dKilbQS1aMC05XystXUAoW0EtWjAtOV1bQS1aMC05XFwtXSpcXC4pK1tBLVpdezIsfSQvaTtcbnZhciBfZW1vamlSZWdleCA9IGBeKFxcXFxwe0V4dGVuZGVkX1BpY3RvZ3JhcGhpY318XFxcXHB7RW1vamlfQ29tcG9uZW50fSkrJGA7XG52YXIgZW1vamlSZWdleDtcbnZhciBpcHY0UmVnZXggPSAvXig/Oig/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSlcXC4pezN9KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKSQvO1xudmFyIGlwdjZSZWdleCA9IC9eKChbYS1mMC05XXsxLDR9Oil7N318OjooW2EtZjAtOV17MSw0fTopezAsNn18KFthLWYwLTldezEsNH06KXsxfTooW2EtZjAtOV17MSw0fTopezAsNX18KFthLWYwLTldezEsNH06KXsyfTooW2EtZjAtOV17MSw0fTopezAsNH18KFthLWYwLTldezEsNH06KXszfTooW2EtZjAtOV17MSw0fTopezAsM318KFthLWYwLTldezEsNH06KXs0fTooW2EtZjAtOV17MSw0fTopezAsMn18KFthLWYwLTldezEsNH06KXs1fTooW2EtZjAtOV17MSw0fTopezAsMX0pKFthLWYwLTldezEsNH18KCgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpXFwuKXszfSgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpKSQvO1xudmFyIGJhc2U2NFJlZ2V4ID0gL14oWzAtOWEtekEtWisvXXs0fSkqKChbMC05YS16QS1aKy9dezJ9PT0pfChbMC05YS16QS1aKy9dezN9PSkpPyQvO1xudmFyIGRhdGVSZWdleFNvdXJjZSA9IGAoKFxcXFxkXFxcXGRbMjQ2OF1bMDQ4XXxcXFxcZFxcXFxkWzEzNTc5XVsyNl18XFxcXGRcXFxcZDBbNDhdfFswMjQ2OF1bMDQ4XTAwfFsxMzU3OV1bMjZdMDApLTAyLTI5fFxcXFxkezR9LSgoMFsxMzU3OF18MVswMl0pLSgwWzEtOV18WzEyXVxcXFxkfDNbMDFdKXwoMFs0NjldfDExKS0oMFsxLTldfFsxMl1cXFxcZHwzMCl8KDAyKS0oMFsxLTldfDFcXFxcZHwyWzAtOF0pKSlgO1xudmFyIGRhdGVSZWdleCA9IG5ldyBSZWdFeHAoYF4ke2RhdGVSZWdleFNvdXJjZX0kYCk7XG5mdW5jdGlvbiB0aW1lUmVnZXhTb3VyY2UoYXJncykge1xuICBsZXQgcmVnZXggPSBgKFswMV1cXFxcZHwyWzAtM10pOlswLTVdXFxcXGQ6WzAtNV1cXFxcZGA7XG4gIGlmIChhcmdzLnByZWNpc2lvbikge1xuICAgIHJlZ2V4ID0gYCR7cmVnZXh9XFxcXC5cXFxcZHske2FyZ3MucHJlY2lzaW9ufX1gO1xuICB9IGVsc2UgaWYgKGFyZ3MucHJlY2lzaW9uID09IG51bGwpIHtcbiAgICByZWdleCA9IGAke3JlZ2V4fShcXFxcLlxcXFxkKyk/YDtcbiAgfVxuICByZXR1cm4gcmVnZXg7XG59XG5mdW5jdGlvbiB0aW1lUmVnZXgoYXJncykge1xuICByZXR1cm4gbmV3IFJlZ0V4cChgXiR7dGltZVJlZ2V4U291cmNlKGFyZ3MpfSRgKTtcbn1cbmZ1bmN0aW9uIGRhdGV0aW1lUmVnZXgoYXJncykge1xuICBsZXQgcmVnZXggPSBgJHtkYXRlUmVnZXhTb3VyY2V9VCR7dGltZVJlZ2V4U291cmNlKGFyZ3MpfWA7XG4gIGNvbnN0IG9wdHMgPSBbXTtcbiAgb3B0cy5wdXNoKGFyZ3MubG9jYWwgPyBgWj9gIDogYFpgKTtcbiAgaWYgKGFyZ3Mub2Zmc2V0KVxuICAgIG9wdHMucHVzaChgKFsrLV1cXFxcZHsyfTo/XFxcXGR7Mn0pYCk7XG4gIHJlZ2V4ID0gYCR7cmVnZXh9KCR7b3B0cy5qb2luKFwifFwiKX0pYDtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoYF4ke3JlZ2V4fSRgKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRJUChpcCwgdmVyc2lvbikge1xuICBpZiAoKHZlcnNpb24gPT09IFwidjRcIiB8fCAhdmVyc2lvbikgJiYgaXB2NFJlZ2V4LnRlc3QoaXApKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKCh2ZXJzaW9uID09PSBcInY2XCIgfHwgIXZlcnNpb24pICYmIGlwdjZSZWdleC50ZXN0KGlwKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbnZhciBab2RTdHJpbmcgPSBjbGFzcyBfWm9kU3RyaW5nIGV4dGVuZHMgWm9kVHlwZSB7XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XG4gICAgICBpbnB1dC5kYXRhID0gU3RyaW5nKGlucHV0LmRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuc3RyaW5nKSB7XG4gICAgICBjb25zdCBjdHgyID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4Miwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5zdHJpbmcsXG4gICAgICAgIHJlY2VpdmVkOiBjdHgyLnBhcnNlZFR5cGVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBQYXJzZVN0YXR1cygpO1xuICAgIGxldCBjdHggPSB2b2lkIDA7XG4gICAgZm9yIChjb25zdCBjaGVjayBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICBpZiAoY2hlY2sua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICBpZiAoaW5wdXQuZGF0YS5sZW5ndGggPCBjaGVjay52YWx1ZSkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgIGlmIChpbnB1dC5kYXRhLmxlbmd0aCA+IGNoZWNrLnZhbHVlKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImxlbmd0aFwiKSB7XG4gICAgICAgIGNvbnN0IHRvb0JpZyA9IGlucHV0LmRhdGEubGVuZ3RoID4gY2hlY2sudmFsdWU7XG4gICAgICAgIGNvbnN0IHRvb1NtYWxsID0gaW5wdXQuZGF0YS5sZW5ndGggPCBjaGVjay52YWx1ZTtcbiAgICAgICAgaWYgKHRvb0JpZyB8fCB0b29TbWFsbCkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGlmICh0b29CaWcpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgZXhhY3Q6IHRydWUsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAodG9vU21hbGwpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICBleGFjdDogdHJ1ZSxcbiAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZW1haWxcIikge1xuICAgICAgICBpZiAoIWVtYWlsUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJlbWFpbFwiLFxuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZW1vamlcIikge1xuICAgICAgICBpZiAoIWVtb2ppUmVnZXgpIHtcbiAgICAgICAgICBlbW9qaVJlZ2V4ID0gbmV3IFJlZ0V4cChfZW1vamlSZWdleCwgXCJ1XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZW1vamlSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uOiBcImVtb2ppXCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ1dWlkXCIpIHtcbiAgICAgICAgaWYgKCF1dWlkUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ1dWlkXCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJuYW5vaWRcIikge1xuICAgICAgICBpZiAoIW5hbm9pZFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb246IFwibmFub2lkXCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJjdWlkXCIpIHtcbiAgICAgICAgaWYgKCFjdWlkUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJjdWlkXCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJjdWlkMlwiKSB7XG4gICAgICAgIGlmICghY3VpZDJSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uOiBcImN1aWQyXCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ1bGlkXCIpIHtcbiAgICAgICAgaWYgKCF1bGlkUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ1bGlkXCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ1cmxcIikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG5ldyBVUkwoaW5wdXQuZGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uOiBcInVybFwiLFxuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwicmVnZXhcIikge1xuICAgICAgICBjaGVjay5yZWdleC5sYXN0SW5kZXggPSAwO1xuICAgICAgICBjb25zdCB0ZXN0UmVzdWx0ID0gY2hlY2sucmVnZXgudGVzdChpbnB1dC5kYXRhKTtcbiAgICAgICAgaWYgKCF0ZXN0UmVzdWx0KSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uOiBcInJlZ2V4XCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ0cmltXCIpIHtcbiAgICAgICAgaW5wdXQuZGF0YSA9IGlucHV0LmRhdGEudHJpbSgpO1xuICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImluY2x1ZGVzXCIpIHtcbiAgICAgICAgaWYgKCFpbnB1dC5kYXRhLmluY2x1ZGVzKGNoZWNrLnZhbHVlLCBjaGVjay5wb3NpdGlvbikpIHtcbiAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgIHZhbGlkYXRpb246IHsgaW5jbHVkZXM6IGNoZWNrLnZhbHVlLCBwb3NpdGlvbjogY2hlY2sucG9zaXRpb24gfSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInRvTG93ZXJDYXNlXCIpIHtcbiAgICAgICAgaW5wdXQuZGF0YSA9IGlucHV0LmRhdGEudG9Mb3dlckNhc2UoKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ0b1VwcGVyQ2FzZVwiKSB7XG4gICAgICAgIGlucHV0LmRhdGEgPSBpbnB1dC5kYXRhLnRvVXBwZXJDYXNlKCk7XG4gICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwic3RhcnRzV2l0aFwiKSB7XG4gICAgICAgIGlmICghaW5wdXQuZGF0YS5zdGFydHNXaXRoKGNoZWNrLnZhbHVlKSkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgdmFsaWRhdGlvbjogeyBzdGFydHNXaXRoOiBjaGVjay52YWx1ZSB9LFxuICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZW5kc1dpdGhcIikge1xuICAgICAgICBpZiAoIWlucHV0LmRhdGEuZW5kc1dpdGgoY2hlY2sudmFsdWUpKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICB2YWxpZGF0aW9uOiB7IGVuZHNXaXRoOiBjaGVjay52YWx1ZSB9LFxuICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZGF0ZXRpbWVcIikge1xuICAgICAgICBjb25zdCByZWdleCA9IGRhdGV0aW1lUmVnZXgoY2hlY2spO1xuICAgICAgICBpZiAoIXJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgIHZhbGlkYXRpb246IFwiZGF0ZXRpbWVcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImRhdGVcIikge1xuICAgICAgICBjb25zdCByZWdleCA9IGRhdGVSZWdleDtcbiAgICAgICAgaWYgKCFyZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICB2YWxpZGF0aW9uOiBcImRhdGVcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInRpbWVcIikge1xuICAgICAgICBjb25zdCByZWdleCA9IHRpbWVSZWdleChjaGVjayk7XG4gICAgICAgIGlmICghcmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ0aW1lXCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJkdXJhdGlvblwiKSB7XG4gICAgICAgIGlmICghZHVyYXRpb25SZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uOiBcImR1cmF0aW9uXCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJpcFwiKSB7XG4gICAgICAgIGlmICghaXNWYWxpZElQKGlucHV0LmRhdGEsIGNoZWNrLnZlcnNpb24pKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uOiBcImlwXCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJiYXNlNjRcIikge1xuICAgICAgICBpZiAoIWJhc2U2NFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb246IFwiYmFzZTY0XCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgfVxuICBfcmVnZXgocmVnZXgsIHZhbGlkYXRpb24sIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5yZWZpbmVtZW50KChkYXRhKSA9PiByZWdleC50ZXN0KGRhdGEpLCB7XG4gICAgICB2YWxpZGF0aW9uLFxuICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgX2FkZENoZWNrKGNoZWNrKSB7XG4gICAgcmV0dXJuIG5ldyBfWm9kU3RyaW5nKHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXVxuICAgIH0pO1xuICB9XG4gIGVtYWlsKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImVtYWlsXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgfVxuICB1cmwobWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwidXJsXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgfVxuICBlbW9qaShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJlbW9qaVwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gIH1cbiAgdXVpZChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJ1dWlkXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgfVxuICBuYW5vaWQobWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwibmFub2lkXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgfVxuICBjdWlkKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImN1aWRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICB9XG4gIGN1aWQyKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImN1aWQyXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgfVxuICB1bGlkKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcInVsaWRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICB9XG4gIGJhc2U2NChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJiYXNlNjRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICB9XG4gIGlwKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImlwXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihvcHRpb25zKSB9KTtcbiAgfVxuICBkYXRldGltZShvcHRpb25zKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgIGtpbmQ6IFwiZGF0ZXRpbWVcIixcbiAgICAgICAgcHJlY2lzaW9uOiBudWxsLFxuICAgICAgICBvZmZzZXQ6IGZhbHNlLFxuICAgICAgICBsb2NhbDogZmFsc2UsXG4gICAgICAgIG1lc3NhZ2U6IG9wdGlvbnNcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJkYXRldGltZVwiLFxuICAgICAgcHJlY2lzaW9uOiB0eXBlb2YgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmVjaXNpb24pID09PSBcInVuZGVmaW5lZFwiID8gbnVsbCA6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmVjaXNpb24sXG4gICAgICBvZmZzZXQ6IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vZmZzZXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlLFxuICAgICAgbG9jYWw6IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5sb2NhbCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2UsXG4gICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgZGF0ZShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJkYXRlXCIsIG1lc3NhZ2UgfSk7XG4gIH1cbiAgdGltZShvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICBraW5kOiBcInRpbWVcIixcbiAgICAgICAgcHJlY2lzaW9uOiBudWxsLFxuICAgICAgICBtZXNzYWdlOiBvcHRpb25zXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwidGltZVwiLFxuICAgICAgcHJlY2lzaW9uOiB0eXBlb2YgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmVjaXNpb24pID09PSBcInVuZGVmaW5lZFwiID8gbnVsbCA6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmVjaXNpb24sXG4gICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgZHVyYXRpb24obWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiZHVyYXRpb25cIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICB9XG4gIHJlZ2V4KHJlZ2V4LCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwicmVnZXhcIixcbiAgICAgIHJlZ2V4LFxuICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgaW5jbHVkZXModmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJpbmNsdWRlc1wiLFxuICAgICAgdmFsdWUsXG4gICAgICBwb3NpdGlvbjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnBvc2l0aW9uLFxuICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tZXNzYWdlKVxuICAgIH0pO1xuICB9XG4gIHN0YXJ0c1dpdGgodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJzdGFydHNXaXRoXCIsXG4gICAgICB2YWx1ZSxcbiAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKVxuICAgIH0pO1xuICB9XG4gIGVuZHNXaXRoKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwiZW5kc1dpdGhcIixcbiAgICAgIHZhbHVlLFxuICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgbWluKG1pbkxlbmd0aCwgbWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgdmFsdWU6IG1pbkxlbmd0aCxcbiAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKVxuICAgIH0pO1xuICB9XG4gIG1heChtYXhMZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJtYXhcIixcbiAgICAgIHZhbHVlOiBtYXhMZW5ndGgsXG4gICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSlcbiAgICB9KTtcbiAgfVxuICBsZW5ndGgobGVuLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibGVuZ3RoXCIsXG4gICAgICB2YWx1ZTogbGVuLFxuICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB6LnN0cmluZygpLm1pbigxKSBpbnN0ZWFkLlxuICAgKiBAc2VlIHtAbGluayBab2RTdHJpbmcubWlufVxuICAgKi9cbiAgbm9uZW1wdHkobWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLm1pbigxLCBlcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkpO1xuICB9XG4gIHRyaW0oKSB7XG4gICAgcmV0dXJuIG5ldyBfWm9kU3RyaW5nKHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIHsga2luZDogXCJ0cmltXCIgfV1cbiAgICB9KTtcbiAgfVxuICB0b0xvd2VyQ2FzZSgpIHtcbiAgICByZXR1cm4gbmV3IF9ab2RTdHJpbmcoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgeyBraW5kOiBcInRvTG93ZXJDYXNlXCIgfV1cbiAgICB9KTtcbiAgfVxuICB0b1VwcGVyQ2FzZSgpIHtcbiAgICByZXR1cm4gbmV3IF9ab2RTdHJpbmcoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgeyBraW5kOiBcInRvVXBwZXJDYXNlXCIgfV1cbiAgICB9KTtcbiAgfVxuICBnZXQgaXNEYXRldGltZSgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImRhdGV0aW1lXCIpO1xuICB9XG4gIGdldCBpc0RhdGUoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJkYXRlXCIpO1xuICB9XG4gIGdldCBpc1RpbWUoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJ0aW1lXCIpO1xuICB9XG4gIGdldCBpc0R1cmF0aW9uKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiZHVyYXRpb25cIik7XG4gIH1cbiAgZ2V0IGlzRW1haWwoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJlbWFpbFwiKTtcbiAgfVxuICBnZXQgaXNVUkwoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJ1cmxcIik7XG4gIH1cbiAgZ2V0IGlzRW1vamkoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJlbW9qaVwiKTtcbiAgfVxuICBnZXQgaXNVVUlEKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwidXVpZFwiKTtcbiAgfVxuICBnZXQgaXNOQU5PSUQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJuYW5vaWRcIik7XG4gIH1cbiAgZ2V0IGlzQ1VJRCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImN1aWRcIik7XG4gIH1cbiAgZ2V0IGlzQ1VJRDIoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJjdWlkMlwiKTtcbiAgfVxuICBnZXQgaXNVTElEKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwidWxpZFwiKTtcbiAgfVxuICBnZXQgaXNJUCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImlwXCIpO1xuICB9XG4gIGdldCBpc0Jhc2U2NCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImJhc2U2NFwiKTtcbiAgfVxuICBnZXQgbWluTGVuZ3RoKCkge1xuICAgIGxldCBtaW4gPSBudWxsO1xuICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcbiAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1pbjtcbiAgfVxuICBnZXQgbWF4TGVuZ3RoKCkge1xuICAgIGxldCBtYXggPSBudWxsO1xuICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcbiAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1heDtcbiAgfVxufTtcblpvZFN0cmluZy5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gIHZhciBfYTtcbiAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xuICAgIGNoZWNrczogW10sXG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RTdHJpbmcsXG4gICAgY29lcmNlOiAoX2EgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuY29lcmNlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZSxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xuZnVuY3Rpb24gZmxvYXRTYWZlUmVtYWluZGVyKHZhbCwgc3RlcCkge1xuICBjb25zdCB2YWxEZWNDb3VudCA9ICh2YWwudG9TdHJpbmcoKS5zcGxpdChcIi5cIilbMV0gfHwgXCJcIikubGVuZ3RoO1xuICBjb25zdCBzdGVwRGVjQ291bnQgPSAoc3RlcC50b1N0cmluZygpLnNwbGl0KFwiLlwiKVsxXSB8fCBcIlwiKS5sZW5ndGg7XG4gIGNvbnN0IGRlY0NvdW50ID0gdmFsRGVjQ291bnQgPiBzdGVwRGVjQ291bnQgPyB2YWxEZWNDb3VudCA6IHN0ZXBEZWNDb3VudDtcbiAgY29uc3QgdmFsSW50ID0gcGFyc2VJbnQodmFsLnRvRml4ZWQoZGVjQ291bnQpLnJlcGxhY2UoXCIuXCIsIFwiXCIpKTtcbiAgY29uc3Qgc3RlcEludCA9IHBhcnNlSW50KHN0ZXAudG9GaXhlZChkZWNDb3VudCkucmVwbGFjZShcIi5cIiwgXCJcIikpO1xuICByZXR1cm4gdmFsSW50ICUgc3RlcEludCAvIE1hdGgucG93KDEwLCBkZWNDb3VudCk7XG59XG52YXIgWm9kTnVtYmVyID0gY2xhc3MgX1pvZE51bWJlciBleHRlbmRzIFpvZFR5cGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMubWluID0gdGhpcy5ndGU7XG4gICAgdGhpcy5tYXggPSB0aGlzLmx0ZTtcbiAgICB0aGlzLnN0ZXAgPSB0aGlzLm11bHRpcGxlT2Y7XG4gIH1cbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UpIHtcbiAgICAgIGlucHV0LmRhdGEgPSBOdW1iZXIoaW5wdXQuZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5udW1iZXIpIHtcbiAgICAgIGNvbnN0IGN0eDIgPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgyLCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm51bWJlcixcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eDIucGFyc2VkVHlwZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgbGV0IGN0eCA9IHZvaWQgMDtcbiAgICBjb25zdCBzdGF0dXMgPSBuZXcgUGFyc2VTdGF0dXMoKTtcbiAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgIGlmIChjaGVjay5raW5kID09PSBcImludFwiKSB7XG4gICAgICAgIGlmICghdXRpbC5pc0ludGVnZXIoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICBleHBlY3RlZDogXCJpbnRlZ2VyXCIsXG4gICAgICAgICAgICByZWNlaXZlZDogXCJmbG9hdFwiLFxuICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgY29uc3QgdG9vU21hbGwgPSBjaGVjay5pbmNsdXNpdmUgPyBpbnB1dC5kYXRhIDwgY2hlY2sudmFsdWUgOiBpbnB1dC5kYXRhIDw9IGNoZWNrLnZhbHVlO1xuICAgICAgICBpZiAodG9vU21hbGwpIHtcbiAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IGNoZWNrLmluY2x1c2l2ZSxcbiAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgIGNvbnN0IHRvb0JpZyA9IGNoZWNrLmluY2x1c2l2ZSA/IGlucHV0LmRhdGEgPiBjaGVjay52YWx1ZSA6IGlucHV0LmRhdGEgPj0gY2hlY2sudmFsdWU7XG4gICAgICAgIGlmICh0b29CaWcpIHtcbiAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXG4gICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtdWx0aXBsZU9mXCIpIHtcbiAgICAgICAgaWYgKGZsb2F0U2FmZVJlbWFpbmRlcihpbnB1dC5kYXRhLCBjaGVjay52YWx1ZSkgIT09IDApIHtcbiAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5ub3RfbXVsdGlwbGVfb2YsXG4gICAgICAgICAgICBtdWx0aXBsZU9mOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImZpbml0ZVwiKSB7XG4gICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUubm90X2Zpbml0ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXRpbC5hc3NlcnROZXZlcihjaGVjayk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICB9XG4gIGd0ZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICB9XG4gIGd0KHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtaW5cIiwgdmFsdWUsIGZhbHNlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICB9XG4gIGx0ZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICB9XG4gIGx0KHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtYXhcIiwgdmFsdWUsIGZhbHNlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICB9XG4gIHNldExpbWl0KGtpbmQsIHZhbHVlLCBpbmNsdXNpdmUsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbmV3IF9ab2ROdW1iZXIoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgY2hlY2tzOiBbXG4gICAgICAgIC4uLnRoaXMuX2RlZi5jaGVja3MsXG4gICAgICAgIHtcbiAgICAgICAgICBraW5kLFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGluY2x1c2l2ZSxcbiAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSlcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0pO1xuICB9XG4gIF9hZGRDaGVjayhjaGVjaykge1xuICAgIHJldHVybiBuZXcgX1pvZE51bWJlcih7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCBjaGVja11cbiAgICB9KTtcbiAgfVxuICBpbnQobWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcImludFwiLFxuICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgcG9zaXRpdmUobWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgdmFsdWU6IDAsXG4gICAgICBpbmNsdXNpdmU6IGZhbHNlLFxuICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgbmVnYXRpdmUobWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgdmFsdWU6IDAsXG4gICAgICBpbmNsdXNpdmU6IGZhbHNlLFxuICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgbm9ucG9zaXRpdmUobWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgdmFsdWU6IDAsXG4gICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSlcbiAgICB9KTtcbiAgfVxuICBub25uZWdhdGl2ZShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICB2YWx1ZTogMCxcbiAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKVxuICAgIH0pO1xuICB9XG4gIG11bHRpcGxlT2YodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJtdWx0aXBsZU9mXCIsXG4gICAgICB2YWx1ZSxcbiAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKVxuICAgIH0pO1xuICB9XG4gIGZpbml0ZShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwiZmluaXRlXCIsXG4gICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSlcbiAgICB9KTtcbiAgfVxuICBzYWZlKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJtaW5cIixcbiAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUixcbiAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKVxuICAgIH0pLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgdmFsdWU6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgZ2V0IG1pblZhbHVlKCkge1xuICAgIGxldCBtaW4gPSBudWxsO1xuICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcbiAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1pbjtcbiAgfVxuICBnZXQgbWF4VmFsdWUoKSB7XG4gICAgbGV0IG1heCA9IG51bGw7XG4gICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KVxuICAgICAgICAgIG1heCA9IGNoLnZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF4O1xuICB9XG4gIGdldCBpc0ludCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImludFwiIHx8IGNoLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiICYmIHV0aWwuaXNJbnRlZ2VyKGNoLnZhbHVlKSk7XG4gIH1cbiAgZ2V0IGlzRmluaXRlKCkge1xuICAgIGxldCBtYXggPSBudWxsLCBtaW4gPSBudWxsO1xuICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgaWYgKGNoLmtpbmQgPT09IFwiZmluaXRlXCIgfHwgY2gua2luZCA9PT0gXCJpbnRcIiB8fCBjaC5raW5kID09PSBcIm11bHRpcGxlT2ZcIikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxuICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgIGlmIChtYXggPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgpXG4gICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUobWluKSAmJiBOdW1iZXIuaXNGaW5pdGUobWF4KTtcbiAgfVxufTtcblpvZE51bWJlci5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kTnVtYmVyKHtcbiAgICBjaGVja3M6IFtdLFxuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTnVtYmVyLFxuICAgIGNvZXJjZTogKHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5jb2VyY2UpIHx8IGZhbHNlLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG52YXIgWm9kQmlnSW50ID0gY2xhc3MgX1pvZEJpZ0ludCBleHRlbmRzIFpvZFR5cGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMubWluID0gdGhpcy5ndGU7XG4gICAgdGhpcy5tYXggPSB0aGlzLmx0ZTtcbiAgfVxuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgaW5wdXQuZGF0YSA9IEJpZ0ludChpbnB1dC5kYXRhKTtcbiAgICB9XG4gICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmJpZ2ludCkge1xuICAgICAgY29uc3QgY3R4MiA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eDIsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuYmlnaW50LFxuICAgICAgICByZWNlaXZlZDogY3R4Mi5wYXJzZWRUeXBlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgICBsZXQgY3R4ID0gdm9pZCAwO1xuICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBQYXJzZVN0YXR1cygpO1xuICAgIGZvciAoY29uc3QgY2hlY2sgb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgaWYgKGNoZWNrLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgY29uc3QgdG9vU21hbGwgPSBjaGVjay5pbmNsdXNpdmUgPyBpbnB1dC5kYXRhIDwgY2hlY2sudmFsdWUgOiBpbnB1dC5kYXRhIDw9IGNoZWNrLnZhbHVlO1xuICAgICAgICBpZiAodG9vU21hbGwpIHtcbiAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICB0eXBlOiBcImJpZ2ludFwiLFxuICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IGNoZWNrLmluY2x1c2l2ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgIGNvbnN0IHRvb0JpZyA9IGNoZWNrLmluY2x1c2l2ZSA/IGlucHV0LmRhdGEgPiBjaGVjay52YWx1ZSA6IGlucHV0LmRhdGEgPj0gY2hlY2sudmFsdWU7XG4gICAgICAgIGlmICh0b29CaWcpIHtcbiAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgdHlwZTogXCJiaWdpbnRcIixcbiAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtdWx0aXBsZU9mXCIpIHtcbiAgICAgICAgaWYgKGlucHV0LmRhdGEgJSBjaGVjay52YWx1ZSAhPT0gQmlnSW50KDApKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUubm90X211bHRpcGxlX29mLFxuICAgICAgICAgICAgbXVsdGlwbGVPZjogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgfVxuICBndGUodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1pblwiLCB2YWx1ZSwgdHJ1ZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgfVxuICBndCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCBmYWxzZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgfVxuICBsdGUodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCB2YWx1ZSwgdHJ1ZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgfVxuICBsdCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCBmYWxzZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgfVxuICBzZXRMaW1pdChraW5kLCB2YWx1ZSwgaW5jbHVzaXZlLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG5ldyBfWm9kQmlnSW50KHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIGNoZWNrczogW1xuICAgICAgICAuLi50aGlzLl9kZWYuY2hlY2tzLFxuICAgICAgICB7XG4gICAgICAgICAga2luZCxcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBpbmNsdXNpdmUsXG4gICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9KTtcbiAgfVxuICBfYWRkQ2hlY2soY2hlY2spIHtcbiAgICByZXR1cm4gbmV3IF9ab2RCaWdJbnQoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdXG4gICAgfSk7XG4gIH1cbiAgcG9zaXRpdmUobWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcbiAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSlcbiAgICB9KTtcbiAgfVxuICBuZWdhdGl2ZShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICB2YWx1ZTogQmlnSW50KDApLFxuICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcbiAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKVxuICAgIH0pO1xuICB9XG4gIG5vbnBvc2l0aXZlKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJtYXhcIixcbiAgICAgIHZhbHVlOiBCaWdJbnQoMCksXG4gICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSlcbiAgICB9KTtcbiAgfVxuICBub25uZWdhdGl2ZShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICB2YWx1ZTogQmlnSW50KDApLFxuICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgbXVsdGlwbGVPZih2YWx1ZSwgbWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm11bHRpcGxlT2ZcIixcbiAgICAgIHZhbHVlLFxuICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgZ2V0IG1pblZhbHVlKCkge1xuICAgIGxldCBtaW4gPSBudWxsO1xuICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcbiAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1pbjtcbiAgfVxuICBnZXQgbWF4VmFsdWUoKSB7XG4gICAgbGV0IG1heCA9IG51bGw7XG4gICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KVxuICAgICAgICAgIG1heCA9IGNoLnZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF4O1xuICB9XG59O1xuWm9kQmlnSW50LmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgdmFyIF9hO1xuICByZXR1cm4gbmV3IFpvZEJpZ0ludCh7XG4gICAgY2hlY2tzOiBbXSxcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEJpZ0ludCxcbiAgICBjb2VyY2U6IChfYSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5jb2VyY2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG52YXIgWm9kQm9vbGVhbiA9IGNsYXNzIGV4dGVuZHMgWm9kVHlwZSB7XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XG4gICAgICBpbnB1dC5kYXRhID0gQm9vbGVhbihpbnB1dC5kYXRhKTtcbiAgICB9XG4gICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmJvb2xlYW4pIHtcbiAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5ib29sZWFuLFxuICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgfVxufTtcblpvZEJvb2xlYW4uY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZEJvb2xlYW4oe1xuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQm9vbGVhbixcbiAgICBjb2VyY2U6IChwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuY29lcmNlKSB8fCBmYWxzZSxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xudmFyIFpvZERhdGUgPSBjbGFzcyBfWm9kRGF0ZSBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgaW5wdXQuZGF0YSA9IG5ldyBEYXRlKGlucHV0LmRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuZGF0ZSkge1xuICAgICAgY29uc3QgY3R4MiA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eDIsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuZGF0ZSxcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eDIucGFyc2VkVHlwZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgaWYgKGlzTmFOKGlucHV0LmRhdGEuZ2V0VGltZSgpKSkge1xuICAgICAgY29uc3QgY3R4MiA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eDIsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfZGF0ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgY29uc3Qgc3RhdHVzID0gbmV3IFBhcnNlU3RhdHVzKCk7XG4gICAgbGV0IGN0eCA9IHZvaWQgMDtcbiAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgIGlmIChjaGVjay5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgIGlmIChpbnB1dC5kYXRhLmdldFRpbWUoKSA8IGNoZWNrLnZhbHVlKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgdHlwZTogXCJkYXRlXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgIGlmIChpbnB1dC5kYXRhLmdldFRpbWUoKSA+IGNoZWNrLnZhbHVlKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICBtYXhpbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgIHR5cGU6IFwiZGF0ZVwiXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzOiBzdGF0dXMudmFsdWUsXG4gICAgICB2YWx1ZTogbmV3IERhdGUoaW5wdXQuZGF0YS5nZXRUaW1lKCkpXG4gICAgfTtcbiAgfVxuICBfYWRkQ2hlY2soY2hlY2spIHtcbiAgICByZXR1cm4gbmV3IF9ab2REYXRlKHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXVxuICAgIH0pO1xuICB9XG4gIG1pbihtaW5EYXRlLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICB2YWx1ZTogbWluRGF0ZS5nZXRUaW1lKCksXG4gICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSlcbiAgICB9KTtcbiAgfVxuICBtYXgobWF4RGF0ZSwgbWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgdmFsdWU6IG1heERhdGUuZ2V0VGltZSgpLFxuICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgZ2V0IG1pbkRhdGUoKSB7XG4gICAgbGV0IG1pbiA9IG51bGw7XG4gICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxuICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWluICE9IG51bGwgPyBuZXcgRGF0ZShtaW4pIDogbnVsbDtcbiAgfVxuICBnZXQgbWF4RGF0ZSgpIHtcbiAgICBsZXQgbWF4ID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgIGlmIChtYXggPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgpXG4gICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXggIT0gbnVsbCA/IG5ldyBEYXRlKG1heCkgOiBudWxsO1xuICB9XG59O1xuWm9kRGF0ZS5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kRGF0ZSh7XG4gICAgY2hlY2tzOiBbXSxcbiAgICBjb2VyY2U6IChwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuY29lcmNlKSB8fCBmYWxzZSxcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZERhdGUsXG4gICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufTtcbnZhciBab2RTeW1ib2wgPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuc3ltYm9sKSB7XG4gICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuc3ltYm9sLFxuICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgfVxufTtcblpvZFN5bWJvbC5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kU3ltYm9sKHtcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFN5bWJvbCxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xudmFyIFpvZFVuZGVmaW5lZCA9IGNsYXNzIGV4dGVuZHMgWm9kVHlwZSB7XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS51bmRlZmluZWQsXG4gICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICB9XG59O1xuWm9kVW5kZWZpbmVkLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgcmV0dXJuIG5ldyBab2RVbmRlZmluZWQoe1xuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVW5kZWZpbmVkLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG52YXIgWm9kTnVsbCA9IGNsYXNzIGV4dGVuZHMgWm9kVHlwZSB7XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5udWxsKSB7XG4gICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubnVsbCxcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gIH1cbn07XG5ab2ROdWxsLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgcmV0dXJuIG5ldyBab2ROdWxsKHtcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE51bGwsXG4gICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufTtcbnZhciBab2RBbnkgPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuX2FueSA9IHRydWU7XG4gIH1cbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICB9XG59O1xuWm9kQW55LmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgcmV0dXJuIG5ldyBab2RBbnkoe1xuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQW55LFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG52YXIgWm9kVW5rbm93biA9IGNsYXNzIGV4dGVuZHMgWm9kVHlwZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5fdW5rbm93biA9IHRydWU7XG4gIH1cbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICB9XG59O1xuWm9kVW5rbm93bi5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kVW5rbm93bih7XG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RVbmtub3duLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG52YXIgWm9kTmV2ZXIgPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubmV2ZXIsXG4gICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGVcbiAgICB9KTtcbiAgICByZXR1cm4gSU5WQUxJRDtcbiAgfVxufTtcblpvZE5ldmVyLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgcmV0dXJuIG5ldyBab2ROZXZlcih7XG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROZXZlcixcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xudmFyIFpvZFZvaWQgPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUudm9pZCxcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gIH1cbn07XG5ab2RWb2lkLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgcmV0dXJuIG5ldyBab2RWb2lkKHtcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFZvaWQsXG4gICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufTtcbnZhciBab2RBcnJheSA9IGNsYXNzIF9ab2RBcnJheSBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCB7IGN0eCwgc3RhdHVzIH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgIGNvbnN0IGRlZiA9IHRoaXMuX2RlZjtcbiAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuYXJyYXkpIHtcbiAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5hcnJheSxcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgICBpZiAoZGVmLmV4YWN0TGVuZ3RoICE9PSBudWxsKSB7XG4gICAgICBjb25zdCB0b29CaWcgPSBjdHguZGF0YS5sZW5ndGggPiBkZWYuZXhhY3RMZW5ndGgudmFsdWU7XG4gICAgICBjb25zdCB0b29TbWFsbCA9IGN0eC5kYXRhLmxlbmd0aCA8IGRlZi5leGFjdExlbmd0aC52YWx1ZTtcbiAgICAgIGlmICh0b29CaWcgfHwgdG9vU21hbGwpIHtcbiAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgY29kZTogdG9vQmlnID8gWm9kSXNzdWVDb2RlLnRvb19iaWcgOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgIG1pbmltdW06IHRvb1NtYWxsID8gZGVmLmV4YWN0TGVuZ3RoLnZhbHVlIDogdm9pZCAwLFxuICAgICAgICAgIG1heGltdW06IHRvb0JpZyA/IGRlZi5leGFjdExlbmd0aC52YWx1ZSA6IHZvaWQgMCxcbiAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgIGV4YWN0OiB0cnVlLFxuICAgICAgICAgIG1lc3NhZ2U6IGRlZi5leGFjdExlbmd0aC5tZXNzYWdlXG4gICAgICAgIH0pO1xuICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlZi5taW5MZW5ndGggIT09IG51bGwpIHtcbiAgICAgIGlmIChjdHguZGF0YS5sZW5ndGggPCBkZWYubWluTGVuZ3RoLnZhbHVlKSB7XG4gICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgbWluaW11bTogZGVmLm1pbkxlbmd0aC52YWx1ZSxcbiAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICBtZXNzYWdlOiBkZWYubWluTGVuZ3RoLm1lc3NhZ2VcbiAgICAgICAgfSk7XG4gICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVmLm1heExlbmd0aCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGN0eC5kYXRhLmxlbmd0aCA+IGRlZi5tYXhMZW5ndGgudmFsdWUpIHtcbiAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgbWF4aW11bTogZGVmLm1heExlbmd0aC52YWx1ZSxcbiAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICBtZXNzYWdlOiBkZWYubWF4TGVuZ3RoLm1lc3NhZ2VcbiAgICAgICAgfSk7XG4gICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFsuLi5jdHguZGF0YV0ubWFwKChpdGVtLCBpKSA9PiB7XG4gICAgICAgIHJldHVybiBkZWYudHlwZS5fcGFyc2VBc3luYyhuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGkpKTtcbiAgICAgIH0pKS50aGVuKChyZXN1bHQyKSA9PiB7XG4gICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0Mik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gWy4uLmN0eC5kYXRhXS5tYXAoKGl0ZW0sIGkpID0+IHtcbiAgICAgIHJldHVybiBkZWYudHlwZS5fcGFyc2VTeW5jKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBpdGVtLCBjdHgucGF0aCwgaSkpO1xuICAgIH0pO1xuICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0KTtcbiAgfVxuICBnZXQgZWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGU7XG4gIH1cbiAgbWluKG1pbkxlbmd0aCwgbWVzc2FnZSkge1xuICAgIHJldHVybiBuZXcgX1pvZEFycmF5KHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIG1pbkxlbmd0aDogeyB2YWx1ZTogbWluTGVuZ3RoLCBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfVxuICAgIH0pO1xuICB9XG4gIG1heChtYXhMZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbmV3IF9ab2RBcnJheSh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBtYXhMZW5ndGg6IHsgdmFsdWU6IG1heExlbmd0aCwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH1cbiAgICB9KTtcbiAgfVxuICBsZW5ndGgobGVuLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG5ldyBfWm9kQXJyYXkoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgZXhhY3RMZW5ndGg6IHsgdmFsdWU6IGxlbiwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH1cbiAgICB9KTtcbiAgfVxuICBub25lbXB0eShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMubWluKDEsIG1lc3NhZ2UpO1xuICB9XG59O1xuWm9kQXJyYXkuY3JlYXRlID0gKHNjaGVtYSwgcGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kQXJyYXkoe1xuICAgIHR5cGU6IHNjaGVtYSxcbiAgICBtaW5MZW5ndGg6IG51bGwsXG4gICAgbWF4TGVuZ3RoOiBudWxsLFxuICAgIGV4YWN0TGVuZ3RoOiBudWxsLFxuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQXJyYXksXG4gICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufTtcbmZ1bmN0aW9uIGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYSkge1xuICBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kT2JqZWN0KSB7XG4gICAgY29uc3QgbmV3U2hhcGUgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEuc2hhcGUpIHtcbiAgICAgIGNvbnN0IGZpZWxkU2NoZW1hID0gc2NoZW1hLnNoYXBlW2tleV07XG4gICAgICBuZXdTaGFwZVtrZXldID0gWm9kT3B0aW9uYWwuY3JlYXRlKGRlZXBQYXJ0aWFsaWZ5KGZpZWxkU2NoZW1hKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgIC4uLnNjaGVtYS5fZGVmLFxuICAgICAgc2hhcGU6ICgpID0+IG5ld1NoYXBlXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kQXJyYXkpIHtcbiAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgIC4uLnNjaGVtYS5fZGVmLFxuICAgICAgdHlwZTogZGVlcFBhcnRpYWxpZnkoc2NoZW1hLmVsZW1lbnQpXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kT3B0aW9uYWwpIHtcbiAgICByZXR1cm4gWm9kT3B0aW9uYWwuY3JlYXRlKGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYS51bndyYXAoKSkpO1xuICB9IGVsc2UgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFpvZE51bGxhYmxlKSB7XG4gICAgcmV0dXJuIFpvZE51bGxhYmxlLmNyZWF0ZShkZWVwUGFydGlhbGlmeShzY2hlbWEudW53cmFwKCkpKTtcbiAgfSBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RUdXBsZSkge1xuICAgIHJldHVybiBab2RUdXBsZS5jcmVhdGUoc2NoZW1hLml0ZW1zLm1hcCgoaXRlbSkgPT4gZGVlcFBhcnRpYWxpZnkoaXRlbSkpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc2NoZW1hO1xuICB9XG59XG52YXIgWm9kT2JqZWN0ID0gY2xhc3MgX1pvZE9iamVjdCBleHRlbmRzIFpvZFR5cGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuX2NhY2hlZCA9IG51bGw7XG4gICAgdGhpcy5ub25zdHJpY3QgPSB0aGlzLnBhc3N0aHJvdWdoO1xuICAgIHRoaXMuYXVnbWVudCA9IHRoaXMuZXh0ZW5kO1xuICB9XG4gIF9nZXRDYWNoZWQoKSB7XG4gICAgaWYgKHRoaXMuX2NhY2hlZCAhPT0gbnVsbClcbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZWQ7XG4gICAgY29uc3Qgc2hhcGUgPSB0aGlzLl9kZWYuc2hhcGUoKTtcbiAgICBjb25zdCBrZXlzID0gdXRpbC5vYmplY3RLZXlzKHNoYXBlKTtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkID0geyBzaGFwZSwga2V5cyB9O1xuICB9XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgIGNvbnN0IGN0eDIgPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgyLCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm9iamVjdCxcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eDIucGFyc2VkVHlwZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICBjb25zdCB7IHNoYXBlLCBrZXlzOiBzaGFwZUtleXMgfSA9IHRoaXMuX2dldENhY2hlZCgpO1xuICAgIGNvbnN0IGV4dHJhS2V5cyA9IFtdO1xuICAgIGlmICghKHRoaXMuX2RlZi5jYXRjaGFsbCBpbnN0YW5jZW9mIFpvZE5ldmVyICYmIHRoaXMuX2RlZi51bmtub3duS2V5cyA9PT0gXCJzdHJpcFwiKSkge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gY3R4LmRhdGEpIHtcbiAgICAgICAgaWYgKCFzaGFwZUtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgIGV4dHJhS2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcGFpcnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBzaGFwZUtleXMpIHtcbiAgICAgIGNvbnN0IGtleVZhbGlkYXRvciA9IHNoYXBlW2tleV07XG4gICAgICBjb25zdCB2YWx1ZSA9IGN0eC5kYXRhW2tleV07XG4gICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAga2V5OiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZToga2V5IH0sXG4gICAgICAgIHZhbHVlOiBrZXlWYWxpZGF0b3IuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIGtleSkpLFxuICAgICAgICBhbHdheXNTZXQ6IGtleSBpbiBjdHguZGF0YVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9kZWYuY2F0Y2hhbGwgaW5zdGFuY2VvZiBab2ROZXZlcikge1xuICAgICAgY29uc3QgdW5rbm93bktleXMgPSB0aGlzLl9kZWYudW5rbm93bktleXM7XG4gICAgICBpZiAodW5rbm93bktleXMgPT09IFwicGFzc3Rocm91Z2hcIikge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBleHRyYUtleXMpIHtcbiAgICAgICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAgICAgIGtleTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGtleSB9LFxuICAgICAgICAgICAgdmFsdWU6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBjdHguZGF0YVtrZXldIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh1bmtub3duS2V5cyA9PT0gXCJzdHJpY3RcIikge1xuICAgICAgICBpZiAoZXh0cmFLZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS51bnJlY29nbml6ZWRfa2V5cyxcbiAgICAgICAgICAgIGtleXM6IGV4dHJhS2V5c1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHVua25vd25LZXlzID09PSBcInN0cmlwXCIpXG4gICAgICAgIDtcbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludGVybmFsIFpvZE9iamVjdCBlcnJvcjogaW52YWxpZCB1bmtub3duS2V5cyB2YWx1ZS5gKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY2F0Y2hhbGwgPSB0aGlzLl9kZWYuY2F0Y2hhbGw7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBleHRyYUtleXMpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBjdHguZGF0YVtrZXldO1xuICAgICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAgICBrZXk6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBrZXkgfSxcbiAgICAgICAgICB2YWx1ZTogY2F0Y2hhbGwuX3BhcnNlKFxuICAgICAgICAgICAgbmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIHZhbHVlLCBjdHgucGF0aCwga2V5KVxuICAgICAgICAgICAgLy8sIGN0eC5jaGlsZChrZXkpLCB2YWx1ZSwgZ2V0UGFyc2VkVHlwZSh2YWx1ZSlcbiAgICAgICAgICApLFxuICAgICAgICAgIGFsd2F5c1NldDoga2V5IGluIGN0eC5kYXRhXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBzeW5jUGFpcnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgcGFpci5rZXk7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBwYWlyLnZhbHVlO1xuICAgICAgICAgIHN5bmNQYWlycy5wdXNoKHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgYWx3YXlzU2V0OiBwYWlyLmFsd2F5c1NldFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzeW5jUGFpcnM7XG4gICAgICB9KS50aGVuKChzeW5jUGFpcnMpID0+IHtcbiAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHN5bmNQYWlycyk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHBhaXJzKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHNoYXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuc2hhcGUoKTtcbiAgfVxuICBzdHJpY3QobWVzc2FnZSkge1xuICAgIGVycm9yVXRpbC5lcnJUb09iajtcbiAgICByZXR1cm4gbmV3IF9ab2RPYmplY3Qoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgdW5rbm93bktleXM6IFwic3RyaWN0XCIsXG4gICAgICAuLi5tZXNzYWdlICE9PSB2b2lkIDAgPyB7XG4gICAgICAgIGVycm9yTWFwOiAoaXNzdWUsIGN0eCkgPT4ge1xuICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgICBjb25zdCBkZWZhdWx0RXJyb3IgPSAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLl9kZWYpLmVycm9yTWFwKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgaXNzdWUsIGN0eCkubWVzc2FnZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogY3R4LmRlZmF1bHRFcnJvcjtcbiAgICAgICAgICBpZiAoaXNzdWUuY29kZSA9PT0gXCJ1bnJlY29nbml6ZWRfa2V5c1wiKVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogKF9kID0gZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLm1lc3NhZ2UpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGRlZmF1bHRFcnJvclxuICAgICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWVzc2FnZTogZGVmYXVsdEVycm9yXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSA6IHt9XG4gICAgfSk7XG4gIH1cbiAgc3RyaXAoKSB7XG4gICAgcmV0dXJuIG5ldyBfWm9kT2JqZWN0KHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIHVua25vd25LZXlzOiBcInN0cmlwXCJcbiAgICB9KTtcbiAgfVxuICBwYXNzdGhyb3VnaCgpIHtcbiAgICByZXR1cm4gbmV3IF9ab2RPYmplY3Qoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgdW5rbm93bktleXM6IFwicGFzc3Rocm91Z2hcIlxuICAgIH0pO1xuICB9XG4gIC8vIGNvbnN0IEF1Z21lbnRGYWN0b3J5ID1cbiAgLy8gICA8RGVmIGV4dGVuZHMgWm9kT2JqZWN0RGVmPihkZWY6IERlZikgPT5cbiAgLy8gICA8QXVnbWVudGF0aW9uIGV4dGVuZHMgWm9kUmF3U2hhcGU+KFxuICAvLyAgICAgYXVnbWVudGF0aW9uOiBBdWdtZW50YXRpb25cbiAgLy8gICApOiBab2RPYmplY3Q8XG4gIC8vICAgICBleHRlbmRTaGFwZTxSZXR1cm5UeXBlPERlZltcInNoYXBlXCJdPiwgQXVnbWVudGF0aW9uPixcbiAgLy8gICAgIERlZltcInVua25vd25LZXlzXCJdLFxuICAvLyAgICAgRGVmW1wiY2F0Y2hhbGxcIl1cbiAgLy8gICA+ID0+IHtcbiAgLy8gICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgLy8gICAgICAgLi4uZGVmLFxuICAvLyAgICAgICBzaGFwZTogKCkgPT4gKHtcbiAgLy8gICAgICAgICAuLi5kZWYuc2hhcGUoKSxcbiAgLy8gICAgICAgICAuLi5hdWdtZW50YXRpb24sXG4gIC8vICAgICAgIH0pLFxuICAvLyAgICAgfSkgYXMgYW55O1xuICAvLyAgIH07XG4gIGV4dGVuZChhdWdtZW50YXRpb24pIHtcbiAgICByZXR1cm4gbmV3IF9ab2RPYmplY3Qoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgc2hhcGU6ICgpID0+ICh7XG4gICAgICAgIC4uLnRoaXMuX2RlZi5zaGFwZSgpLFxuICAgICAgICAuLi5hdWdtZW50YXRpb25cbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFByaW9yIHRvIHpvZEAxLjAuMTIgdGhlcmUgd2FzIGEgYnVnIGluIHRoZVxuICAgKiBpbmZlcnJlZCB0eXBlIG9mIG1lcmdlZCBvYmplY3RzLiBQbGVhc2VcbiAgICogdXBncmFkZSBpZiB5b3UgYXJlIGV4cGVyaWVuY2luZyBpc3N1ZXMuXG4gICAqL1xuICBtZXJnZShtZXJnaW5nKSB7XG4gICAgY29uc3QgbWVyZ2VkID0gbmV3IF9ab2RPYmplY3Qoe1xuICAgICAgdW5rbm93bktleXM6IG1lcmdpbmcuX2RlZi51bmtub3duS2V5cyxcbiAgICAgIGNhdGNoYWxsOiBtZXJnaW5nLl9kZWYuY2F0Y2hhbGwsXG4gICAgICBzaGFwZTogKCkgPT4gKHtcbiAgICAgICAgLi4udGhpcy5fZGVmLnNoYXBlKCksXG4gICAgICAgIC4uLm1lcmdpbmcuX2RlZi5zaGFwZSgpXG4gICAgICB9KSxcbiAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0XG4gICAgfSk7XG4gICAgcmV0dXJuIG1lcmdlZDtcbiAgfVxuICAvLyBtZXJnZTxcbiAgLy8gICBJbmNvbWluZyBleHRlbmRzIEFueVpvZE9iamVjdCxcbiAgLy8gICBBdWdtZW50YXRpb24gZXh0ZW5kcyBJbmNvbWluZ1tcInNoYXBlXCJdLFxuICAvLyAgIE5ld091dHB1dCBleHRlbmRzIHtcbiAgLy8gICAgIFtrIGluIGtleW9mIEF1Z21lbnRhdGlvbiB8IGtleW9mIE91dHB1dF06IGsgZXh0ZW5kcyBrZXlvZiBBdWdtZW50YXRpb25cbiAgLy8gICAgICAgPyBBdWdtZW50YXRpb25ba11bXCJfb3V0cHV0XCJdXG4gIC8vICAgICAgIDogayBleHRlbmRzIGtleW9mIE91dHB1dFxuICAvLyAgICAgICA/IE91dHB1dFtrXVxuICAvLyAgICAgICA6IG5ldmVyO1xuICAvLyAgIH0sXG4gIC8vICAgTmV3SW5wdXQgZXh0ZW5kcyB7XG4gIC8vICAgICBbayBpbiBrZXlvZiBBdWdtZW50YXRpb24gfCBrZXlvZiBJbnB1dF06IGsgZXh0ZW5kcyBrZXlvZiBBdWdtZW50YXRpb25cbiAgLy8gICAgICAgPyBBdWdtZW50YXRpb25ba11bXCJfaW5wdXRcIl1cbiAgLy8gICAgICAgOiBrIGV4dGVuZHMga2V5b2YgSW5wdXRcbiAgLy8gICAgICAgPyBJbnB1dFtrXVxuICAvLyAgICAgICA6IG5ldmVyO1xuICAvLyAgIH1cbiAgLy8gPihcbiAgLy8gICBtZXJnaW5nOiBJbmNvbWluZ1xuICAvLyApOiBab2RPYmplY3Q8XG4gIC8vICAgZXh0ZW5kU2hhcGU8VCwgUmV0dXJuVHlwZTxJbmNvbWluZ1tcIl9kZWZcIl1bXCJzaGFwZVwiXT4+LFxuICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcInVua25vd25LZXlzXCJdLFxuICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcImNhdGNoYWxsXCJdLFxuICAvLyAgIE5ld091dHB1dCxcbiAgLy8gICBOZXdJbnB1dFxuICAvLyA+IHtcbiAgLy8gICBjb25zdCBtZXJnZWQ6IGFueSA9IG5ldyBab2RPYmplY3Qoe1xuICAvLyAgICAgdW5rbm93bktleXM6IG1lcmdpbmcuX2RlZi51bmtub3duS2V5cyxcbiAgLy8gICAgIGNhdGNoYWxsOiBtZXJnaW5nLl9kZWYuY2F0Y2hhbGwsXG4gIC8vICAgICBzaGFwZTogKCkgPT5cbiAgLy8gICAgICAgb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyh0aGlzLl9kZWYuc2hhcGUoKSwgbWVyZ2luZy5fZGVmLnNoYXBlKCkpLFxuICAvLyAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gIC8vICAgfSkgYXMgYW55O1xuICAvLyAgIHJldHVybiBtZXJnZWQ7XG4gIC8vIH1cbiAgc2V0S2V5KGtleSwgc2NoZW1hKSB7XG4gICAgcmV0dXJuIHRoaXMuYXVnbWVudCh7IFtrZXldOiBzY2hlbWEgfSk7XG4gIH1cbiAgLy8gbWVyZ2U8SW5jb21pbmcgZXh0ZW5kcyBBbnlab2RPYmplY3Q+KFxuICAvLyAgIG1lcmdpbmc6IEluY29taW5nXG4gIC8vICk6IC8vWm9kT2JqZWN0PFQgJiBJbmNvbWluZ1tcIl9zaGFwZVwiXSwgVW5rbm93bktleXMsIENhdGNoYWxsPiA9IChtZXJnaW5nKSA9PiB7XG4gIC8vIFpvZE9iamVjdDxcbiAgLy8gICBleHRlbmRTaGFwZTxULCBSZXR1cm5UeXBlPEluY29taW5nW1wiX2RlZlwiXVtcInNoYXBlXCJdPj4sXG4gIC8vICAgSW5jb21pbmdbXCJfZGVmXCJdW1widW5rbm93bktleXNcIl0sXG4gIC8vICAgSW5jb21pbmdbXCJfZGVmXCJdW1wiY2F0Y2hhbGxcIl1cbiAgLy8gPiB7XG4gIC8vICAgLy8gY29uc3QgbWVyZ2VkU2hhcGUgPSBvYmplY3RVdGlsLm1lcmdlU2hhcGVzKFxuICAvLyAgIC8vICAgdGhpcy5fZGVmLnNoYXBlKCksXG4gIC8vICAgLy8gICBtZXJnaW5nLl9kZWYuc2hhcGUoKVxuICAvLyAgIC8vICk7XG4gIC8vICAgY29uc3QgbWVyZ2VkOiBhbnkgPSBuZXcgWm9kT2JqZWN0KHtcbiAgLy8gICAgIHVua25vd25LZXlzOiBtZXJnaW5nLl9kZWYudW5rbm93bktleXMsXG4gIC8vICAgICBjYXRjaGFsbDogbWVyZ2luZy5fZGVmLmNhdGNoYWxsLFxuICAvLyAgICAgc2hhcGU6ICgpID0+XG4gIC8vICAgICAgIG9iamVjdFV0aWwubWVyZ2VTaGFwZXModGhpcy5fZGVmLnNoYXBlKCksIG1lcmdpbmcuX2RlZi5zaGFwZSgpKSxcbiAgLy8gICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAvLyAgIH0pIGFzIGFueTtcbiAgLy8gICByZXR1cm4gbWVyZ2VkO1xuICAvLyB9XG4gIGNhdGNoYWxsKGluZGV4KSB7XG4gICAgcmV0dXJuIG5ldyBfWm9kT2JqZWN0KHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIGNhdGNoYWxsOiBpbmRleFxuICAgIH0pO1xuICB9XG4gIHBpY2sobWFzaykge1xuICAgIGNvbnN0IHNoYXBlID0ge307XG4gICAgdXRpbC5vYmplY3RLZXlzKG1hc2spLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgaWYgKG1hc2tba2V5XSAmJiB0aGlzLnNoYXBlW2tleV0pIHtcbiAgICAgICAgc2hhcGVba2V5XSA9IHRoaXMuc2hhcGVba2V5XTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IF9ab2RPYmplY3Qoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgc2hhcGU6ICgpID0+IHNoYXBlXG4gICAgfSk7XG4gIH1cbiAgb21pdChtYXNrKSB7XG4gICAgY29uc3Qgc2hhcGUgPSB7fTtcbiAgICB1dGlsLm9iamVjdEtleXModGhpcy5zaGFwZSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBpZiAoIW1hc2tba2V5XSkge1xuICAgICAgICBzaGFwZVtrZXldID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgX1pvZE9iamVjdCh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBzaGFwZTogKCkgPT4gc2hhcGVcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGRlZXBQYXJ0aWFsKCkge1xuICAgIHJldHVybiBkZWVwUGFydGlhbGlmeSh0aGlzKTtcbiAgfVxuICBwYXJ0aWFsKG1hc2spIHtcbiAgICBjb25zdCBuZXdTaGFwZSA9IHt9O1xuICAgIHV0aWwub2JqZWN0S2V5cyh0aGlzLnNoYXBlKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGNvbnN0IGZpZWxkU2NoZW1hID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgaWYgKG1hc2sgJiYgIW1hc2tba2V5XSkge1xuICAgICAgICBuZXdTaGFwZVtrZXldID0gZmllbGRTY2hlbWE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdTaGFwZVtrZXldID0gZmllbGRTY2hlbWEub3B0aW9uYWwoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IF9ab2RPYmplY3Qoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgc2hhcGU6ICgpID0+IG5ld1NoYXBlXG4gICAgfSk7XG4gIH1cbiAgcmVxdWlyZWQobWFzaykge1xuICAgIGNvbnN0IG5ld1NoYXBlID0ge307XG4gICAgdXRpbC5vYmplY3RLZXlzKHRoaXMuc2hhcGUpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgaWYgKG1hc2sgJiYgIW1hc2tba2V5XSkge1xuICAgICAgICBuZXdTaGFwZVtrZXldID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZmllbGRTY2hlbWEgPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgIGxldCBuZXdGaWVsZCA9IGZpZWxkU2NoZW1hO1xuICAgICAgICB3aGlsZSAobmV3RmllbGQgaW5zdGFuY2VvZiBab2RPcHRpb25hbCkge1xuICAgICAgICAgIG5ld0ZpZWxkID0gbmV3RmllbGQuX2RlZi5pbm5lclR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgbmV3U2hhcGVba2V5XSA9IG5ld0ZpZWxkO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgX1pvZE9iamVjdCh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBzaGFwZTogKCkgPT4gbmV3U2hhcGVcbiAgICB9KTtcbiAgfVxuICBrZXlvZigpIHtcbiAgICByZXR1cm4gY3JlYXRlWm9kRW51bSh1dGlsLm9iamVjdEtleXModGhpcy5zaGFwZSkpO1xuICB9XG59O1xuWm9kT2JqZWN0LmNyZWF0ZSA9IChzaGFwZSwgcGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICBzaGFwZTogKCkgPT4gc2hhcGUsXG4gICAgdW5rbm93bktleXM6IFwic3RyaXBcIixcbiAgICBjYXRjaGFsbDogWm9kTmV2ZXIuY3JlYXRlKCksXG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufTtcblpvZE9iamVjdC5zdHJpY3RDcmVhdGUgPSAoc2hhcGUsIHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgc2hhcGU6ICgpID0+IHNoYXBlLFxuICAgIHVua25vd25LZXlzOiBcInN0cmljdFwiLFxuICAgIGNhdGNoYWxsOiBab2ROZXZlci5jcmVhdGUoKSxcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xuWm9kT2JqZWN0LmxhenljcmVhdGUgPSAoc2hhcGUsIHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgc2hhcGUsXG4gICAgdW5rbm93bktleXM6IFwic3RyaXBcIixcbiAgICBjYXRjaGFsbDogWm9kTmV2ZXIuY3JlYXRlKCksXG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufTtcbnZhciBab2RVbmlvbiA9IGNsYXNzIGV4dGVuZHMgWm9kVHlwZSB7XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9kZWYub3B0aW9ucztcbiAgICBmdW5jdGlvbiBoYW5kbGVSZXN1bHRzKHJlc3VsdHMpIHtcbiAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICAgICAgaWYgKHJlc3VsdC5yZXN1bHQuc3RhdHVzID09PSBcInZhbGlkXCIpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICBpZiAocmVzdWx0LnJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgIGN0eC5jb21tb24uaXNzdWVzLnB1c2goLi4ucmVzdWx0LmN0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgdW5pb25FcnJvcnMgPSByZXN1bHRzLm1hcCgocmVzdWx0KSA9PiBuZXcgWm9kRXJyb3IocmVzdWx0LmN0eC5jb21tb24uaXNzdWVzKSk7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb24sXG4gICAgICAgIHVuaW9uRXJyb3JzXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKG9wdGlvbnMubWFwKGFzeW5jIChvcHRpb24pID0+IHtcbiAgICAgICAgY29uc3QgY2hpbGRDdHggPSB7XG4gICAgICAgICAgLi4uY3R4LFxuICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgLi4uY3R4LmNvbW1vbixcbiAgICAgICAgICAgIGlzc3VlczogW11cbiAgICAgICAgICB9LFxuICAgICAgICAgIHBhcmVudDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc3VsdDogYXdhaXQgb3B0aW9uLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICBwYXJlbnQ6IGNoaWxkQ3R4XG4gICAgICAgICAgfSksXG4gICAgICAgICAgY3R4OiBjaGlsZEN0eFxuICAgICAgICB9O1xuICAgICAgfSkpLnRoZW4oaGFuZGxlUmVzdWx0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBkaXJ0eSA9IHZvaWQgMDtcbiAgICAgIGNvbnN0IGlzc3VlcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBvcHRpb24gb2Ygb3B0aW9ucykge1xuICAgICAgICBjb25zdCBjaGlsZEN0eCA9IHtcbiAgICAgICAgICAuLi5jdHgsXG4gICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAuLi5jdHguY29tbW9uLFxuICAgICAgICAgICAgaXNzdWVzOiBbXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcGFyZW50OiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG9wdGlvbi5fcGFyc2VTeW5jKHtcbiAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICBwYXJlbnQ6IGNoaWxkQ3R4XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJ2YWxpZFwiKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIgJiYgIWRpcnR5KSB7XG4gICAgICAgICAgZGlydHkgPSB7IHJlc3VsdCwgY3R4OiBjaGlsZEN0eCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZEN0eC5jb21tb24uaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICAgIGlzc3Vlcy5wdXNoKGNoaWxkQ3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZGlydHkpIHtcbiAgICAgICAgY3R4LmNvbW1vbi5pc3N1ZXMucHVzaCguLi5kaXJ0eS5jdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgIHJldHVybiBkaXJ0eS5yZXN1bHQ7XG4gICAgICB9XG4gICAgICBjb25zdCB1bmlvbkVycm9ycyA9IGlzc3Vlcy5tYXAoKGlzc3VlczIpID0+IG5ldyBab2RFcnJvcihpc3N1ZXMyKSk7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb24sXG4gICAgICAgIHVuaW9uRXJyb3JzXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgfVxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLm9wdGlvbnM7XG4gIH1cbn07XG5ab2RVbmlvbi5jcmVhdGUgPSAodHlwZXMsIHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZFVuaW9uKHtcbiAgICBvcHRpb25zOiB0eXBlcyxcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFVuaW9uLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG52YXIgZ2V0RGlzY3JpbWluYXRvciA9ICh0eXBlKSA9PiB7XG4gIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTGF6eSkge1xuICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUuc2NoZW1hKTtcbiAgfSBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kRWZmZWN0cykge1xuICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUuaW5uZXJUeXBlKCkpO1xuICB9IGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RMaXRlcmFsKSB7XG4gICAgcmV0dXJuIFt0eXBlLnZhbHVlXTtcbiAgfSBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kRW51bSkge1xuICAgIHJldHVybiB0eXBlLm9wdGlvbnM7XG4gIH0gZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZE5hdGl2ZUVudW0pIHtcbiAgICByZXR1cm4gdXRpbC5vYmplY3RWYWx1ZXModHlwZS5lbnVtKTtcbiAgfSBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kRGVmYXVsdCkge1xuICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUuX2RlZi5pbm5lclR5cGUpO1xuICB9IGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RVbmRlZmluZWQpIHtcbiAgICByZXR1cm4gW3ZvaWQgMF07XG4gIH0gZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZE51bGwpIHtcbiAgICByZXR1cm4gW251bGxdO1xuICB9IGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RPcHRpb25hbCkge1xuICAgIHJldHVybiBbdm9pZCAwLCAuLi5nZXREaXNjcmltaW5hdG9yKHR5cGUudW53cmFwKCkpXTtcbiAgfSBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTnVsbGFibGUpIHtcbiAgICByZXR1cm4gW251bGwsIC4uLmdldERpc2NyaW1pbmF0b3IodHlwZS51bndyYXAoKSldO1xuICB9IGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RCcmFuZGVkKSB7XG4gICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS51bndyYXAoKSk7XG4gIH0gZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZFJlYWRvbmx5KSB7XG4gICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS51bndyYXAoKSk7XG4gIH0gZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZENhdGNoKSB7XG4gICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS5fZGVmLmlubmVyVHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59O1xudmFyIFpvZERpc2NyaW1pbmF0ZWRVbmlvbiA9IGNsYXNzIF9ab2REaXNjcmltaW5hdGVkVW5pb24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm9iamVjdCkge1xuICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm9iamVjdCxcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgICBjb25zdCBkaXNjcmltaW5hdG9yID0gdGhpcy5kaXNjcmltaW5hdG9yO1xuICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JWYWx1ZSA9IGN0eC5kYXRhW2Rpc2NyaW1pbmF0b3JdO1xuICAgIGNvbnN0IG9wdGlvbiA9IHRoaXMub3B0aW9uc01hcC5nZXQoZGlzY3JpbWluYXRvclZhbHVlKTtcbiAgICBpZiAoIW9wdGlvbikge1xuICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uX2Rpc2NyaW1pbmF0b3IsXG4gICAgICAgIG9wdGlvbnM6IEFycmF5LmZyb20odGhpcy5vcHRpb25zTWFwLmtleXMoKSksXG4gICAgICAgIHBhdGg6IFtkaXNjcmltaW5hdG9yXVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgIHJldHVybiBvcHRpb24uX3BhcnNlQXN5bmMoe1xuICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgIHBhcmVudDogY3R4XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9wdGlvbi5fcGFyc2VTeW5jKHtcbiAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICBwYXJlbnQ6IGN0eFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGdldCBkaXNjcmltaW5hdG9yKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuZGlzY3JpbWluYXRvcjtcbiAgfVxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLm9wdGlvbnM7XG4gIH1cbiAgZ2V0IG9wdGlvbnNNYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5vcHRpb25zTWFwO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY29uc3RydWN0b3Igb2YgdGhlIGRpc2NyaW1pbmF0ZWQgdW5pb24gc2NoZW1hLiBJdHMgYmVoYXZpb3VyIGlzIHZlcnkgc2ltaWxhciB0byB0aGF0IG9mIHRoZSBub3JtYWwgei51bmlvbigpIGNvbnN0cnVjdG9yLlxuICAgKiBIb3dldmVyLCBpdCBvbmx5IGFsbG93cyBhIHVuaW9uIG9mIG9iamVjdHMsIGFsbCBvZiB3aGljaCBuZWVkIHRvIHNoYXJlIGEgZGlzY3JpbWluYXRvciBwcm9wZXJ0eS4gVGhpcyBwcm9wZXJ0eSBtdXN0XG4gICAqIGhhdmUgYSBkaWZmZXJlbnQgdmFsdWUgZm9yIGVhY2ggb2JqZWN0IGluIHRoZSB1bmlvbi5cbiAgICogQHBhcmFtIGRpc2NyaW1pbmF0b3IgdGhlIG5hbWUgb2YgdGhlIGRpc2NyaW1pbmF0b3IgcHJvcGVydHlcbiAgICogQHBhcmFtIHR5cGVzIGFuIGFycmF5IG9mIG9iamVjdCBzY2hlbWFzXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICovXG4gIHN0YXRpYyBjcmVhdGUoZGlzY3JpbWluYXRvciwgb3B0aW9ucywgcGFyYW1zKSB7XG4gICAgY29uc3Qgb3B0aW9uc01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCB0eXBlIG9mIG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JWYWx1ZXMgPSBnZXREaXNjcmltaW5hdG9yKHR5cGUuc2hhcGVbZGlzY3JpbWluYXRvcl0pO1xuICAgICAgaWYgKCFkaXNjcmltaW5hdG9yVmFsdWVzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEgZGlzY3JpbWluYXRvciB2YWx1ZSBmb3Iga2V5IFxcYCR7ZGlzY3JpbWluYXRvcn1cXGAgY291bGQgbm90IGJlIGV4dHJhY3RlZCBmcm9tIGFsbCBzY2hlbWEgb3B0aW9uc2ApO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBkaXNjcmltaW5hdG9yVmFsdWVzKSB7XG4gICAgICAgIGlmIChvcHRpb25zTWFwLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERpc2NyaW1pbmF0b3IgcHJvcGVydHkgJHtTdHJpbmcoZGlzY3JpbWluYXRvcil9IGhhcyBkdXBsaWNhdGUgdmFsdWUgJHtTdHJpbmcodmFsdWUpfWApO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnNNYXAuc2V0KHZhbHVlLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfWm9kRGlzY3JpbWluYXRlZFVuaW9uKHtcbiAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRGlzY3JpbWluYXRlZFVuaW9uLFxuICAgICAgZGlzY3JpbWluYXRvcixcbiAgICAgIG9wdGlvbnMsXG4gICAgICBvcHRpb25zTWFwLFxuICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gICAgfSk7XG4gIH1cbn07XG5mdW5jdGlvbiBtZXJnZVZhbHVlcyhhLCBiKSB7XG4gIGNvbnN0IGFUeXBlID0gZ2V0UGFyc2VkVHlwZShhKTtcbiAgY29uc3QgYlR5cGUgPSBnZXRQYXJzZWRUeXBlKGIpO1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBhIH07XG4gIH0gZWxzZSBpZiAoYVR5cGUgPT09IFpvZFBhcnNlZFR5cGUub2JqZWN0ICYmIGJUeXBlID09PSBab2RQYXJzZWRUeXBlLm9iamVjdCkge1xuICAgIGNvbnN0IGJLZXlzID0gdXRpbC5vYmplY3RLZXlzKGIpO1xuICAgIGNvbnN0IHNoYXJlZEtleXMgPSB1dGlsLm9iamVjdEtleXMoYSkuZmlsdGVyKChrZXkpID0+IGJLZXlzLmluZGV4T2Yoa2V5KSAhPT0gLTEpO1xuICAgIGNvbnN0IG5ld09iaiA9IHsgLi4uYSwgLi4uYiB9O1xuICAgIGZvciAoY29uc3Qga2V5IG9mIHNoYXJlZEtleXMpIHtcbiAgICAgIGNvbnN0IHNoYXJlZFZhbHVlID0gbWVyZ2VWYWx1ZXMoYVtrZXldLCBiW2tleV0pO1xuICAgICAgaWYgKCFzaGFyZWRWYWx1ZS52YWxpZCkge1xuICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgICAgIH1cbiAgICAgIG5ld09ialtrZXldID0gc2hhcmVkVmFsdWUuZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IG5ld09iaiB9O1xuICB9IGVsc2UgaWYgKGFUeXBlID09PSBab2RQYXJzZWRUeXBlLmFycmF5ICYmIGJUeXBlID09PSBab2RQYXJzZWRUeXBlLmFycmF5KSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIGNvbnN0IG5ld0FycmF5ID0gW107XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGEubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBjb25zdCBpdGVtQSA9IGFbaW5kZXhdO1xuICAgICAgY29uc3QgaXRlbUIgPSBiW2luZGV4XTtcbiAgICAgIGNvbnN0IHNoYXJlZFZhbHVlID0gbWVyZ2VWYWx1ZXMoaXRlbUEsIGl0ZW1CKTtcbiAgICAgIGlmICghc2hhcmVkVmFsdWUudmFsaWQpIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlIH07XG4gICAgICB9XG4gICAgICBuZXdBcnJheS5wdXNoKHNoYXJlZFZhbHVlLmRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZGF0YTogbmV3QXJyYXkgfTtcbiAgfSBlbHNlIGlmIChhVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5kYXRlICYmIGJUeXBlID09PSBab2RQYXJzZWRUeXBlLmRhdGUgJiYgK2EgPT09ICtiKSB7XG4gICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IGEgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgfVxufVxudmFyIFpvZEludGVyc2VjdGlvbiA9IGNsYXNzIGV4dGVuZHMgWm9kVHlwZSB7XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgY29uc3QgaGFuZGxlUGFyc2VkID0gKHBhcnNlZExlZnQsIHBhcnNlZFJpZ2h0KSA9PiB7XG4gICAgICBpZiAoaXNBYm9ydGVkKHBhcnNlZExlZnQpIHx8IGlzQWJvcnRlZChwYXJzZWRSaWdodCkpIHtcbiAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICB9XG4gICAgICBjb25zdCBtZXJnZWQgPSBtZXJnZVZhbHVlcyhwYXJzZWRMZWZ0LnZhbHVlLCBwYXJzZWRSaWdodC52YWx1ZSk7XG4gICAgICBpZiAoIW1lcmdlZC52YWxpZCkge1xuICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9pbnRlcnNlY3Rpb25fdHlwZXNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGlydHkocGFyc2VkTGVmdCkgfHwgaXNEaXJ0eShwYXJzZWRSaWdodCkpIHtcbiAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IG1lcmdlZC5kYXRhIH07XG4gICAgfTtcbiAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgdGhpcy5fZGVmLmxlZnQuX3BhcnNlQXN5bmMoe1xuICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgIHBhcmVudDogY3R4XG4gICAgICAgIH0pLFxuICAgICAgICB0aGlzLl9kZWYucmlnaHQuX3BhcnNlQXN5bmMoe1xuICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgIHBhcmVudDogY3R4XG4gICAgICAgIH0pXG4gICAgICBdKS50aGVuKChbbGVmdCwgcmlnaHRdKSA9PiBoYW5kbGVQYXJzZWQobGVmdCwgcmlnaHQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGhhbmRsZVBhcnNlZCh0aGlzLl9kZWYubGVmdC5fcGFyc2VTeW5jKHtcbiAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICBwYXJlbnQ6IGN0eFxuICAgICAgfSksIHRoaXMuX2RlZi5yaWdodC5fcGFyc2VTeW5jKHtcbiAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICBwYXJlbnQ6IGN0eFxuICAgICAgfSkpO1xuICAgIH1cbiAgfVxufTtcblpvZEludGVyc2VjdGlvbi5jcmVhdGUgPSAobGVmdCwgcmlnaHQsIHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZEludGVyc2VjdGlvbih7XG4gICAgbGVmdCxcbiAgICByaWdodCxcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEludGVyc2VjdGlvbixcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xudmFyIFpvZFR1cGxlID0gY2xhc3MgX1pvZFR1cGxlIGV4dGVuZHMgWm9kVHlwZSB7XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmFycmF5KSB7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuYXJyYXksXG4gICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgaWYgKGN0eC5kYXRhLmxlbmd0aCA8IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgpIHtcbiAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICBtaW5pbXVtOiB0aGlzLl9kZWYuaXRlbXMubGVuZ3RoLFxuICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgdHlwZTogXCJhcnJheVwiXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgICBjb25zdCByZXN0ID0gdGhpcy5fZGVmLnJlc3Q7XG4gICAgaWYgKCFyZXN0ICYmIGN0eC5kYXRhLmxlbmd0aCA+IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgpIHtcbiAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgbWF4aW11bTogdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCxcbiAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgIHR5cGU6IFwiYXJyYXlcIlxuICAgICAgfSk7XG4gICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICB9XG4gICAgY29uc3QgaXRlbXMgPSBbLi4uY3R4LmRhdGFdLm1hcCgoaXRlbSwgaXRlbUluZGV4KSA9PiB7XG4gICAgICBjb25zdCBzY2hlbWEgPSB0aGlzLl9kZWYuaXRlbXNbaXRlbUluZGV4XSB8fCB0aGlzLl9kZWYucmVzdDtcbiAgICAgIGlmICghc2NoZW1hKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIHJldHVybiBzY2hlbWEuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBpdGVtLCBjdHgucGF0aCwgaXRlbUluZGV4KSk7XG4gICAgfSkuZmlsdGVyKCh4KSA9PiAhIXgpO1xuICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoaXRlbXMpLnRoZW4oKHJlc3VsdHMpID0+IHtcbiAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlQXJyYXkoc3RhdHVzLCByZXN1bHRzKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIGl0ZW1zKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGl0ZW1zKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuaXRlbXM7XG4gIH1cbiAgcmVzdChyZXN0KSB7XG4gICAgcmV0dXJuIG5ldyBfWm9kVHVwbGUoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgcmVzdFxuICAgIH0pO1xuICB9XG59O1xuWm9kVHVwbGUuY3JlYXRlID0gKHNjaGVtYXMsIHBhcmFtcykgPT4ge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbXVzdCBwYXNzIGFuIGFycmF5IG9mIHNjaGVtYXMgdG8gei50dXBsZShbIC4uLiBdKVwiKTtcbiAgfVxuICByZXR1cm4gbmV3IFpvZFR1cGxlKHtcbiAgICBpdGVtczogc2NoZW1hcyxcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFR1cGxlLFxuICAgIHJlc3Q6IG51bGwsXG4gICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufTtcbnZhciBab2RSZWNvcmQgPSBjbGFzcyBfWm9kUmVjb3JkIGV4dGVuZHMgWm9kVHlwZSB7XG4gIGdldCBrZXlTY2hlbWEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5rZXlUeXBlO1xuICB9XG4gIGdldCB2YWx1ZVNjaGVtYSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgfVxuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5vYmplY3QsXG4gICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgY29uc3QgcGFpcnMgPSBbXTtcbiAgICBjb25zdCBrZXlUeXBlID0gdGhpcy5fZGVmLmtleVR5cGU7XG4gICAgY29uc3QgdmFsdWVUeXBlID0gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjdHguZGF0YSkge1xuICAgICAgcGFpcnMucHVzaCh7XG4gICAgICAgIGtleToga2V5VHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGtleSwgY3R4LnBhdGgsIGtleSkpLFxuICAgICAgICB2YWx1ZTogdmFsdWVUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgY3R4LmRhdGFba2V5XSwgY3R4LnBhdGgsIGtleSkpLFxuICAgICAgICBhbHdheXNTZXQ6IGtleSBpbiBjdHguZGF0YVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RBc3luYyhzdGF0dXMsIHBhaXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHBhaXJzKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZShmaXJzdCwgc2Vjb25kLCB0aGlyZCkge1xuICAgIGlmIChzZWNvbmQgaW5zdGFuY2VvZiBab2RUeXBlKSB7XG4gICAgICByZXR1cm4gbmV3IF9ab2RSZWNvcmQoe1xuICAgICAgICBrZXlUeXBlOiBmaXJzdCxcbiAgICAgICAgdmFsdWVUeXBlOiBzZWNvbmQsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUmVjb3JkLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXJkKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgX1pvZFJlY29yZCh7XG4gICAgICBrZXlUeXBlOiBab2RTdHJpbmcuY3JlYXRlKCksXG4gICAgICB2YWx1ZVR5cGU6IGZpcnN0LFxuICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RSZWNvcmQsXG4gICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHNlY29uZClcbiAgICB9KTtcbiAgfVxufTtcbnZhciBab2RNYXAgPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xuICBnZXQga2V5U2NoZW1hKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYua2V5VHlwZTtcbiAgfVxuICBnZXQgdmFsdWVTY2hlbWEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gIH1cbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubWFwKSB7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubWFwLFxuICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIGNvbnN0IGtleVR5cGUgPSB0aGlzLl9kZWYua2V5VHlwZTtcbiAgICBjb25zdCB2YWx1ZVR5cGUgPSB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgIGNvbnN0IHBhaXJzID0gWy4uLmN0eC5kYXRhLmVudHJpZXMoKV0ubWFwKChba2V5LCB2YWx1ZV0sIGluZGV4KSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBrZXk6IGtleVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBrZXksIGN0eC5wYXRoLCBbaW5kZXgsIFwia2V5XCJdKSksXG4gICAgICAgIHZhbHVlOiB2YWx1ZVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIFtpbmRleCwgXCJ2YWx1ZVwiXSkpXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICBjb25zdCBmaW5hbE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihhc3luYyAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IHBhaXIua2V5O1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgcGFpci52YWx1ZTtcbiAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImFib3J0ZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImRpcnR5XCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmaW5hbE1hcC5zZXQoa2V5LnZhbHVlLCB2YWx1ZS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBmaW5hbE1hcCB9O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZpbmFsTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICBjb25zdCBrZXkgPSBwYWlyLmtleTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwYWlyLnZhbHVlO1xuICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImFib3J0ZWRcIikge1xuICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImRpcnR5XCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbE1hcC5zZXQoa2V5LnZhbHVlLCB2YWx1ZS52YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGZpbmFsTWFwIH07XG4gICAgfVxuICB9XG59O1xuWm9kTWFwLmNyZWF0ZSA9IChrZXlUeXBlLCB2YWx1ZVR5cGUsIHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZE1hcCh7XG4gICAgdmFsdWVUeXBlLFxuICAgIGtleVR5cGUsXG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RNYXAsXG4gICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufTtcbnZhciBab2RTZXQgPSBjbGFzcyBfWm9kU2V0IGV4dGVuZHMgWm9kVHlwZSB7XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnNldCkge1xuICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnNldCxcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgICBjb25zdCBkZWYgPSB0aGlzLl9kZWY7XG4gICAgaWYgKGRlZi5taW5TaXplICE9PSBudWxsKSB7XG4gICAgICBpZiAoY3R4LmRhdGEuc2l6ZSA8IGRlZi5taW5TaXplLnZhbHVlKSB7XG4gICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgbWluaW11bTogZGVmLm1pblNpemUudmFsdWUsXG4gICAgICAgICAgdHlwZTogXCJzZXRcIixcbiAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgIG1lc3NhZ2U6IGRlZi5taW5TaXplLm1lc3NhZ2VcbiAgICAgICAgfSk7XG4gICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVmLm1heFNpemUgIT09IG51bGwpIHtcbiAgICAgIGlmIChjdHguZGF0YS5zaXplID4gZGVmLm1heFNpemUudmFsdWUpIHtcbiAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgbWF4aW11bTogZGVmLm1heFNpemUudmFsdWUsXG4gICAgICAgICAgdHlwZTogXCJzZXRcIixcbiAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgIG1lc3NhZ2U6IGRlZi5tYXhTaXplLm1lc3NhZ2VcbiAgICAgICAgfSk7XG4gICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB2YWx1ZVR5cGUgPSB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgIGZ1bmN0aW9uIGZpbmFsaXplU2V0KGVsZW1lbnRzMikge1xuICAgICAgY29uc3QgcGFyc2VkU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50czIpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgaWYgKGVsZW1lbnQuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIHBhcnNlZFNldC5hZGQoZWxlbWVudC52YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IHBhcnNlZFNldCB9O1xuICAgIH1cbiAgICBjb25zdCBlbGVtZW50cyA9IFsuLi5jdHguZGF0YS52YWx1ZXMoKV0ubWFwKChpdGVtLCBpKSA9PiB2YWx1ZVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBpdGVtLCBjdHgucGF0aCwgaSkpKTtcbiAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGVsZW1lbnRzKS50aGVuKChlbGVtZW50czIpID0+IGZpbmFsaXplU2V0KGVsZW1lbnRzMikpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmluYWxpemVTZXQoZWxlbWVudHMpO1xuICAgIH1cbiAgfVxuICBtaW4obWluU2l6ZSwgbWVzc2FnZSkge1xuICAgIHJldHVybiBuZXcgX1pvZFNldCh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBtaW5TaXplOiB7IHZhbHVlOiBtaW5TaXplLCBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfVxuICAgIH0pO1xuICB9XG4gIG1heChtYXhTaXplLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG5ldyBfWm9kU2V0KHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIG1heFNpemU6IHsgdmFsdWU6IG1heFNpemUsIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9XG4gICAgfSk7XG4gIH1cbiAgc2l6ZShzaXplLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMubWluKHNpemUsIG1lc3NhZ2UpLm1heChzaXplLCBtZXNzYWdlKTtcbiAgfVxuICBub25lbXB0eShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMubWluKDEsIG1lc3NhZ2UpO1xuICB9XG59O1xuWm9kU2V0LmNyZWF0ZSA9ICh2YWx1ZVR5cGUsIHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZFNldCh7XG4gICAgdmFsdWVUeXBlLFxuICAgIG1pblNpemU6IG51bGwsXG4gICAgbWF4U2l6ZTogbnVsbCxcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFNldCxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xudmFyIFpvZEZ1bmN0aW9uID0gY2xhc3MgX1pvZEZ1bmN0aW9uIGV4dGVuZHMgWm9kVHlwZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy52YWxpZGF0ZSA9IHRoaXMuaW1wbGVtZW50O1xuICB9XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5mdW5jdGlvbikge1xuICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmZ1bmN0aW9uLFxuICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VBcmdzSXNzdWUoYXJncywgZXJyb3IpIHtcbiAgICAgIHJldHVybiBtYWtlSXNzdWUoe1xuICAgICAgICBkYXRhOiBhcmdzLFxuICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgZXJyb3JNYXBzOiBbXG4gICAgICAgICAgY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsXG4gICAgICAgICAgY3R4LnNjaGVtYUVycm9yTWFwLFxuICAgICAgICAgIGdldEVycm9yTWFwKCksXG4gICAgICAgICAgZXJyb3JNYXBcbiAgICAgICAgXS5maWx0ZXIoKHgpID0+ICEheCksXG4gICAgICAgIGlzc3VlRGF0YToge1xuICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2FyZ3VtZW50cyxcbiAgICAgICAgICBhcmd1bWVudHNFcnJvcjogZXJyb3JcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VSZXR1cm5zSXNzdWUocmV0dXJucywgZXJyb3IpIHtcbiAgICAgIHJldHVybiBtYWtlSXNzdWUoe1xuICAgICAgICBkYXRhOiByZXR1cm5zLFxuICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgZXJyb3JNYXBzOiBbXG4gICAgICAgICAgY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsXG4gICAgICAgICAgY3R4LnNjaGVtYUVycm9yTWFwLFxuICAgICAgICAgIGdldEVycm9yTWFwKCksXG4gICAgICAgICAgZXJyb3JNYXBcbiAgICAgICAgXS5maWx0ZXIoKHgpID0+ICEheCksXG4gICAgICAgIGlzc3VlRGF0YToge1xuICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3JldHVybl90eXBlLFxuICAgICAgICAgIHJldHVyblR5cGVFcnJvcjogZXJyb3JcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHBhcmFtcyA9IHsgZXJyb3JNYXA6IGN0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwIH07XG4gICAgY29uc3QgZm4gPSBjdHguZGF0YTtcbiAgICBpZiAodGhpcy5fZGVmLnJldHVybnMgaW5zdGFuY2VvZiBab2RQcm9taXNlKSB7XG4gICAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgICByZXR1cm4gT0soYXN5bmMgZnVuY3Rpb24oLi4uYXJncykge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBab2RFcnJvcihbXSk7XG4gICAgICAgIGNvbnN0IHBhcnNlZEFyZ3MgPSBhd2FpdCBtZS5fZGVmLmFyZ3MucGFyc2VBc3luYyhhcmdzLCBwYXJhbXMpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgZXJyb3IuYWRkSXNzdWUobWFrZUFyZ3NJc3N1ZShhcmdzLCBlKSk7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBSZWZsZWN0LmFwcGx5KGZuLCB0aGlzLCBwYXJzZWRBcmdzKTtcbiAgICAgICAgY29uc3QgcGFyc2VkUmV0dXJucyA9IGF3YWl0IG1lLl9kZWYucmV0dXJucy5fZGVmLnR5cGUucGFyc2VBc3luYyhyZXN1bHQsIHBhcmFtcykuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICBlcnJvci5hZGRJc3N1ZShtYWtlUmV0dXJuc0lzc3VlKHJlc3VsdCwgZSkpO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBhcnNlZFJldHVybnM7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbWUgPSB0aGlzO1xuICAgICAgcmV0dXJuIE9LKGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkQXJncyA9IG1lLl9kZWYuYXJncy5zYWZlUGFyc2UoYXJncywgcGFyYW1zKTtcbiAgICAgICAgaWYgKCFwYXJzZWRBcmdzLnN1Y2Nlc3MpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgWm9kRXJyb3IoW21ha2VBcmdzSXNzdWUoYXJncywgcGFyc2VkQXJncy5lcnJvcildKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LmFwcGx5KGZuLCB0aGlzLCBwYXJzZWRBcmdzLmRhdGEpO1xuICAgICAgICBjb25zdCBwYXJzZWRSZXR1cm5zID0gbWUuX2RlZi5yZXR1cm5zLnNhZmVQYXJzZShyZXN1bHQsIHBhcmFtcyk7XG4gICAgICAgIGlmICghcGFyc2VkUmV0dXJucy5zdWNjZXNzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFpvZEVycm9yKFttYWtlUmV0dXJuc0lzc3VlKHJlc3VsdCwgcGFyc2VkUmV0dXJucy5lcnJvcildKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VkUmV0dXJucy5kYXRhO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHBhcmFtZXRlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5hcmdzO1xuICB9XG4gIHJldHVyblR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5yZXR1cm5zO1xuICB9XG4gIGFyZ3MoLi4uaXRlbXMpIHtcbiAgICByZXR1cm4gbmV3IF9ab2RGdW5jdGlvbih7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBhcmdzOiBab2RUdXBsZS5jcmVhdGUoaXRlbXMpLnJlc3QoWm9kVW5rbm93bi5jcmVhdGUoKSlcbiAgICB9KTtcbiAgfVxuICByZXR1cm5zKHJldHVyblR5cGUpIHtcbiAgICByZXR1cm4gbmV3IF9ab2RGdW5jdGlvbih7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICByZXR1cm5zOiByZXR1cm5UeXBlXG4gICAgfSk7XG4gIH1cbiAgaW1wbGVtZW50KGZ1bmMpIHtcbiAgICBjb25zdCB2YWxpZGF0ZWRGdW5jID0gdGhpcy5wYXJzZShmdW5jKTtcbiAgICByZXR1cm4gdmFsaWRhdGVkRnVuYztcbiAgfVxuICBzdHJpY3RJbXBsZW1lbnQoZnVuYykge1xuICAgIGNvbnN0IHZhbGlkYXRlZEZ1bmMgPSB0aGlzLnBhcnNlKGZ1bmMpO1xuICAgIHJldHVybiB2YWxpZGF0ZWRGdW5jO1xuICB9XG4gIHN0YXRpYyBjcmVhdGUoYXJncywgcmV0dXJucywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBfWm9kRnVuY3Rpb24oe1xuICAgICAgYXJnczogYXJncyA/IGFyZ3MgOiBab2RUdXBsZS5jcmVhdGUoW10pLnJlc3QoWm9kVW5rbm93bi5jcmVhdGUoKSksXG4gICAgICByZXR1cm5zOiByZXR1cm5zIHx8IFpvZFVua25vd24uY3JlYXRlKCksXG4gICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEZ1bmN0aW9uLFxuICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gICAgfSk7XG4gIH1cbn07XG52YXIgWm9kTGF6eSA9IGNsYXNzIGV4dGVuZHMgWm9kVHlwZSB7XG4gIGdldCBzY2hlbWEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5nZXR0ZXIoKTtcbiAgfVxuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICBjb25zdCBsYXp5U2NoZW1hID0gdGhpcy5fZGVmLmdldHRlcigpO1xuICAgIHJldHVybiBsYXp5U2NoZW1hLl9wYXJzZSh7IGRhdGE6IGN0eC5kYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSk7XG4gIH1cbn07XG5ab2RMYXp5LmNyZWF0ZSA9IChnZXR0ZXIsIHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZExhenkoe1xuICAgIGdldHRlcixcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZExhenksXG4gICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufTtcbnZhciBab2RMaXRlcmFsID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgaWYgKGlucHV0LmRhdGEgIT09IHRoaXMuX2RlZi52YWx1ZSkge1xuICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIHJlY2VpdmVkOiBjdHguZGF0YSxcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfbGl0ZXJhbCxcbiAgICAgICAgZXhwZWN0ZWQ6IHRoaXMuX2RlZi52YWx1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gIH1cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWU7XG4gIH1cbn07XG5ab2RMaXRlcmFsLmNyZWF0ZSA9ICh2YWx1ZSwgcGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kTGl0ZXJhbCh7XG4gICAgdmFsdWUsXG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RMaXRlcmFsLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG5mdW5jdGlvbiBjcmVhdGVab2RFbnVtKHZhbHVlcywgcGFyYW1zKSB7XG4gIHJldHVybiBuZXcgWm9kRW51bSh7XG4gICAgdmFsdWVzLFxuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRW51bSxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59XG52YXIgWm9kRW51bSA9IGNsYXNzIF9ab2RFbnVtIGV4dGVuZHMgWm9kVHlwZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX1pvZEVudW1fY2FjaGUuc2V0KHRoaXMsIHZvaWQgMCk7XG4gIH1cbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dC5kYXRhICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICBjb25zdCBleHBlY3RlZFZhbHVlcyA9IHRoaXMuX2RlZi52YWx1ZXM7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgZXhwZWN0ZWQ6IHV0aWwuam9pblZhbHVlcyhleHBlY3RlZFZhbHVlcyksXG4gICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9ab2RFbnVtX2NhY2hlLCBcImZcIikpIHtcbiAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1pvZEVudW1fY2FjaGUsIG5ldyBTZXQodGhpcy5fZGVmLnZhbHVlcyksIFwiZlwiKTtcbiAgICB9XG4gICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9ab2RFbnVtX2NhY2hlLCBcImZcIikuaGFzKGlucHV0LmRhdGEpKSB7XG4gICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICBjb25zdCBleHBlY3RlZFZhbHVlcyA9IHRoaXMuX2RlZi52YWx1ZXM7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eC5kYXRhLFxuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9lbnVtX3ZhbHVlLFxuICAgICAgICBvcHRpb25zOiBleHBlY3RlZFZhbHVlc1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICB9XG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVzO1xuICB9XG4gIGdldCBlbnVtKCkge1xuICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHZhbCBvZiB0aGlzLl9kZWYudmFsdWVzKSB7XG4gICAgICBlbnVtVmFsdWVzW3ZhbF0gPSB2YWw7XG4gICAgfVxuICAgIHJldHVybiBlbnVtVmFsdWVzO1xuICB9XG4gIGdldCBWYWx1ZXMoKSB7XG4gICAgY29uc3QgZW51bVZhbHVlcyA9IHt9O1xuICAgIGZvciAoY29uc3QgdmFsIG9mIHRoaXMuX2RlZi52YWx1ZXMpIHtcbiAgICAgIGVudW1WYWx1ZXNbdmFsXSA9IHZhbDtcbiAgICB9XG4gICAgcmV0dXJuIGVudW1WYWx1ZXM7XG4gIH1cbiAgZ2V0IEVudW0oKSB7XG4gICAgY29uc3QgZW51bVZhbHVlcyA9IHt9O1xuICAgIGZvciAoY29uc3QgdmFsIG9mIHRoaXMuX2RlZi52YWx1ZXMpIHtcbiAgICAgIGVudW1WYWx1ZXNbdmFsXSA9IHZhbDtcbiAgICB9XG4gICAgcmV0dXJuIGVudW1WYWx1ZXM7XG4gIH1cbiAgZXh0cmFjdCh2YWx1ZXMsIG5ld0RlZiA9IHRoaXMuX2RlZikge1xuICAgIHJldHVybiBfWm9kRW51bS5jcmVhdGUodmFsdWVzLCB7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAuLi5uZXdEZWZcbiAgICB9KTtcbiAgfVxuICBleGNsdWRlKHZhbHVlcywgbmV3RGVmID0gdGhpcy5fZGVmKSB7XG4gICAgcmV0dXJuIF9ab2RFbnVtLmNyZWF0ZSh0aGlzLm9wdGlvbnMuZmlsdGVyKChvcHQpID0+ICF2YWx1ZXMuaW5jbHVkZXMob3B0KSksIHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIC4uLm5ld0RlZlxuICAgIH0pO1xuICB9XG59O1xuX1pvZEVudW1fY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcblpvZEVudW0uY3JlYXRlID0gY3JlYXRlWm9kRW51bTtcbnZhciBab2ROYXRpdmVFbnVtID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfWm9kTmF0aXZlRW51bV9jYWNoZS5zZXQodGhpcywgdm9pZCAwKTtcbiAgfVxuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCBuYXRpdmVFbnVtVmFsdWVzID0gdXRpbC5nZXRWYWxpZEVudW1WYWx1ZXModGhpcy5fZGVmLnZhbHVlcyk7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5zdHJpbmcgJiYgY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubnVtYmVyKSB7XG4gICAgICBjb25zdCBleHBlY3RlZFZhbHVlcyA9IHV0aWwub2JqZWN0VmFsdWVzKG5hdGl2ZUVudW1WYWx1ZXMpO1xuICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIGV4cGVjdGVkOiB1dGlsLmpvaW5WYWx1ZXMoZXhwZWN0ZWRWYWx1ZXMpLFxuICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfWm9kTmF0aXZlRW51bV9jYWNoZSwgXCJmXCIpKSB7XG4gICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9ab2ROYXRpdmVFbnVtX2NhY2hlLCBuZXcgU2V0KHV0aWwuZ2V0VmFsaWRFbnVtVmFsdWVzKHRoaXMuX2RlZi52YWx1ZXMpKSwgXCJmXCIpO1xuICAgIH1cbiAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1pvZE5hdGl2ZUVudW1fY2FjaGUsIFwiZlwiKS5oYXMoaW5wdXQuZGF0YSkpIHtcbiAgICAgIGNvbnN0IGV4cGVjdGVkVmFsdWVzID0gdXRpbC5vYmplY3RWYWx1ZXMobmF0aXZlRW51bVZhbHVlcyk7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eC5kYXRhLFxuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9lbnVtX3ZhbHVlLFxuICAgICAgICBvcHRpb25zOiBleHBlY3RlZFZhbHVlc1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICB9XG4gIGdldCBlbnVtKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVzO1xuICB9XG59O1xuX1pvZE5hdGl2ZUVudW1fY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcblpvZE5hdGl2ZUVudW0uY3JlYXRlID0gKHZhbHVlcywgcGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kTmF0aXZlRW51bSh7XG4gICAgdmFsdWVzLFxuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTmF0aXZlRW51bSxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xudmFyIFpvZFByb21pc2UgPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xuICB1bndyYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi50eXBlO1xuICB9XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5wcm9taXNlICYmIGN0eC5jb21tb24uYXN5bmMgPT09IGZhbHNlKSB7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUucHJvbWlzZSxcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgICBjb25zdCBwcm9taXNpZmllZCA9IGN0eC5wYXJzZWRUeXBlID09PSBab2RQYXJzZWRUeXBlLnByb21pc2UgPyBjdHguZGF0YSA6IFByb21pc2UucmVzb2x2ZShjdHguZGF0YSk7XG4gICAgcmV0dXJuIE9LKHByb21pc2lmaWVkLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZS5wYXJzZUFzeW5jKGRhdGEsIHtcbiAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgIGVycm9yTWFwOiBjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcFxuICAgICAgfSk7XG4gICAgfSkpO1xuICB9XG59O1xuWm9kUHJvbWlzZS5jcmVhdGUgPSAoc2NoZW1hLCBwYXJhbXMpID0+IHtcbiAgcmV0dXJuIG5ldyBab2RQcm9taXNlKHtcbiAgICB0eXBlOiBzY2hlbWEsXG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RQcm9taXNlLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG52YXIgWm9kRWZmZWN0cyA9IGNsYXNzIGV4dGVuZHMgWm9kVHlwZSB7XG4gIGlubmVyVHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYTtcbiAgfVxuICBzb3VyY2VUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hLl9kZWYudHlwZU5hbWUgPT09IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzID8gdGhpcy5fZGVmLnNjaGVtYS5zb3VyY2VUeXBlKCkgOiB0aGlzLl9kZWYuc2NoZW1hO1xuICB9XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgY29uc3QgZWZmZWN0ID0gdGhpcy5fZGVmLmVmZmVjdCB8fCBudWxsO1xuICAgIGNvbnN0IGNoZWNrQ3R4ID0ge1xuICAgICAgYWRkSXNzdWU6IChhcmcpID0+IHtcbiAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCBhcmcpO1xuICAgICAgICBpZiAoYXJnLmZhdGFsKSB7XG4gICAgICAgICAgc3RhdHVzLmFib3J0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBnZXQgcGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIGN0eC5wYXRoO1xuICAgICAgfVxuICAgIH07XG4gICAgY2hlY2tDdHguYWRkSXNzdWUgPSBjaGVja0N0eC5hZGRJc3N1ZS5iaW5kKGNoZWNrQ3R4KTtcbiAgICBpZiAoZWZmZWN0LnR5cGUgPT09IFwicHJlcHJvY2Vzc1wiKSB7XG4gICAgICBjb25zdCBwcm9jZXNzZWQgPSBlZmZlY3QudHJhbnNmb3JtKGN0eC5kYXRhLCBjaGVja0N0eCk7XG4gICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHByb2Nlc3NlZCkudGhlbihhc3luYyAocHJvY2Vzc2VkMikgPT4ge1xuICAgICAgICAgIGlmIChzdGF0dXMudmFsdWUgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICBkYXRhOiBwcm9jZXNzZWQyLFxuICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICBwYXJlbnQ6IGN0eFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICByZXR1cm4gRElSVFkocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICBpZiAoc3RhdHVzLnZhbHVlID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICByZXR1cm4gRElSVFkocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzdGF0dXMudmFsdWUgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZVN5bmMoe1xuICAgICAgICAgIGRhdGE6IHByb2Nlc3NlZCxcbiAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICBwYXJlbnQ6IGN0eFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgIHJldHVybiBESVJUWShyZXN1bHQudmFsdWUpO1xuICAgICAgICBpZiAoc3RhdHVzLnZhbHVlID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgcmV0dXJuIERJUlRZKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlZmZlY3QudHlwZSA9PT0gXCJyZWZpbmVtZW50XCIpIHtcbiAgICAgIGNvbnN0IGV4ZWN1dGVSZWZpbmVtZW50ID0gKGFjYykgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBlZmZlY3QucmVmaW5lbWVudChhY2MsIGNoZWNrQ3R4KTtcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBc3luYyByZWZpbmVtZW50IGVuY291bnRlcmVkIGR1cmluZyBzeW5jaHJvbm91cyBwYXJzZSBvcGVyYXRpb24uIFVzZSAucGFyc2VBc3luYyBpbnN0ZWFkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfTtcbiAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jID09PSBmYWxzZSkge1xuICAgICAgICBjb25zdCBpbm5lciA9IHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlU3luYyh7XG4gICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgcGFyZW50OiBjdHhcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpbm5lci5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIGV4ZWN1dGVSZWZpbmVtZW50KGlubmVyLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBpbm5lci52YWx1ZSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlQXN5bmMoeyBkYXRhOiBjdHguZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pLnRoZW4oKGlubmVyKSA9PiB7XG4gICAgICAgICAgaWYgKGlubmVyLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICByZXR1cm4gZXhlY3V0ZVJlZmluZW1lbnQoaW5uZXIudmFsdWUpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBpbm5lci52YWx1ZSB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVmZmVjdC50eXBlID09PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgYmFzZSA9IHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlU3luYyh7XG4gICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgcGFyZW50OiBjdHhcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghaXNWYWxpZChiYXNlKSlcbiAgICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZWZmZWN0LnRyYW5zZm9ybShiYXNlLnZhbHVlLCBjaGVja0N0eCk7XG4gICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBc3luY2hyb25vdXMgdHJhbnNmb3JtIGVuY291bnRlcmVkIGR1cmluZyBzeW5jaHJvbm91cyBwYXJzZSBvcGVyYXRpb24uIFVzZSAucGFyc2VBc3luYyBpbnN0ZWFkLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogcmVzdWx0IH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VBc3luYyh7IGRhdGE6IGN0eC5kYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSkudGhlbigoYmFzZSkgPT4ge1xuICAgICAgICAgIGlmICghaXNWYWxpZChiYXNlKSlcbiAgICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZWZmZWN0LnRyYW5zZm9ybShiYXNlLnZhbHVlLCBjaGVja0N0eCkpLnRoZW4oKHJlc3VsdCkgPT4gKHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiByZXN1bHQgfSkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdXRpbC5hc3NlcnROZXZlcihlZmZlY3QpO1xuICB9XG59O1xuWm9kRWZmZWN0cy5jcmVhdGUgPSAoc2NoZW1hLCBlZmZlY3QsIHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xuICAgIHNjaGVtYSxcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXG4gICAgZWZmZWN0LFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG5ab2RFZmZlY3RzLmNyZWF0ZVdpdGhQcmVwcm9jZXNzID0gKHByZXByb2Nlc3MsIHNjaGVtYSwgcGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kRWZmZWN0cyh7XG4gICAgc2NoZW1hLFxuICAgIGVmZmVjdDogeyB0eXBlOiBcInByZXByb2Nlc3NcIiwgdHJhbnNmb3JtOiBwcmVwcm9jZXNzIH0sXG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG52YXIgWm9kT3B0aW9uYWwgPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgaWYgKHBhcnNlZFR5cGUgPT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gT0sodm9pZCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKGlucHV0KTtcbiAgfVxuICB1bndyYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XG4gIH1cbn07XG5ab2RPcHRpb25hbC5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kT3B0aW9uYWwoe1xuICAgIGlubmVyVHlwZTogdHlwZSxcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9wdGlvbmFsLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG52YXIgWm9kTnVsbGFibGUgPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgaWYgKHBhcnNlZFR5cGUgPT09IFpvZFBhcnNlZFR5cGUubnVsbCkge1xuICAgICAgcmV0dXJuIE9LKG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoaW5wdXQpO1xuICB9XG4gIHVud3JhcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgfVxufTtcblpvZE51bGxhYmxlLmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcbiAgcmV0dXJuIG5ldyBab2ROdWxsYWJsZSh7XG4gICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTnVsbGFibGUsXG4gICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufTtcbnZhciBab2REZWZhdWx0ID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgbGV0IGRhdGEgPSBjdHguZGF0YTtcbiAgICBpZiAoY3R4LnBhcnNlZFR5cGUgPT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICBkYXRhID0gdGhpcy5fZGVmLmRlZmF1bHRWYWx1ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2Uoe1xuICAgICAgZGF0YSxcbiAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgcGFyZW50OiBjdHhcbiAgICB9KTtcbiAgfVxuICByZW1vdmVEZWZhdWx0KCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICB9XG59O1xuWm9kRGVmYXVsdC5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kRGVmYXVsdCh7XG4gICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRGVmYXVsdCxcbiAgICBkZWZhdWx0VmFsdWU6IHR5cGVvZiBwYXJhbXMuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiID8gcGFyYW1zLmRlZmF1bHQgOiAoKSA9PiBwYXJhbXMuZGVmYXVsdCxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xudmFyIFpvZENhdGNoID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgY29uc3QgbmV3Q3R4ID0ge1xuICAgICAgLi4uY3R4LFxuICAgICAgY29tbW9uOiB7XG4gICAgICAgIC4uLmN0eC5jb21tb24sXG4gICAgICAgIGlzc3VlczogW11cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKHtcbiAgICAgIGRhdGE6IG5ld0N0eC5kYXRhLFxuICAgICAgcGF0aDogbmV3Q3R4LnBhdGgsXG4gICAgICBwYXJlbnQ6IHtcbiAgICAgICAgLi4ubmV3Q3R4XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGlzQXN5bmMocmVzdWx0KSkge1xuICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChyZXN1bHQyKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhdHVzOiBcInZhbGlkXCIsXG4gICAgICAgICAgdmFsdWU6IHJlc3VsdDIuc3RhdHVzID09PSBcInZhbGlkXCIgPyByZXN1bHQyLnZhbHVlIDogdGhpcy5fZGVmLmNhdGNoVmFsdWUoe1xuICAgICAgICAgICAgZ2V0IGVycm9yKCkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IFpvZEVycm9yKG5ld0N0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbnB1dDogbmV3Q3R4LmRhdGFcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogXCJ2YWxpZFwiLFxuICAgICAgICB2YWx1ZTogcmVzdWx0LnN0YXR1cyA9PT0gXCJ2YWxpZFwiID8gcmVzdWx0LnZhbHVlIDogdGhpcy5fZGVmLmNhdGNoVmFsdWUoe1xuICAgICAgICAgIGdldCBlcnJvcigpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgWm9kRXJyb3IobmV3Q3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgaW5wdXQ6IG5ld0N0eC5kYXRhXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICByZW1vdmVDYXRjaCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgfVxufTtcblpvZENhdGNoLmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcbiAgcmV0dXJuIG5ldyBab2RDYXRjaCh7XG4gICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQ2F0Y2gsXG4gICAgY2F0Y2hWYWx1ZTogdHlwZW9mIHBhcmFtcy5jYXRjaCA9PT0gXCJmdW5jdGlvblwiID8gcGFyYW1zLmNhdGNoIDogKCkgPT4gcGFyYW1zLmNhdGNoLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG52YXIgWm9kTmFOID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm5hbikge1xuICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm5hbixcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgICByZXR1cm4geyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgfVxufTtcblpvZE5hTi5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kTmFOKHtcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE5hTixcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xudmFyIEJSQU5EID0gU3ltYm9sKFwiem9kX2JyYW5kXCIpO1xudmFyIFpvZEJyYW5kZWQgPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICBjb25zdCBkYXRhID0gY3R4LmRhdGE7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi50eXBlLl9wYXJzZSh7XG4gICAgICBkYXRhLFxuICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICBwYXJlbnQ6IGN0eFxuICAgIH0pO1xuICB9XG4gIHVud3JhcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGU7XG4gIH1cbn07XG52YXIgWm9kUGlwZWxpbmUgPSBjbGFzcyBfWm9kUGlwZWxpbmUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgY29uc3QgaGFuZGxlQXN5bmMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGluUmVzdWx0ID0gYXdhaXQgdGhpcy5fZGVmLmluLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICBwYXJlbnQ6IGN0eFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGluUmVzdWx0LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIGlmIChpblJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgIHJldHVybiBESVJUWShpblJlc3VsdC52YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5vdXQuX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgZGF0YTogaW5SZXN1bHQudmFsdWUsXG4gICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgIHBhcmVudDogY3R4XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gaGFuZGxlQXN5bmMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaW5SZXN1bHQgPSB0aGlzLl9kZWYuaW4uX3BhcnNlU3luYyh7XG4gICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgcGFyZW50OiBjdHhcbiAgICAgIH0pO1xuICAgICAgaWYgKGluUmVzdWx0LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgaWYgKGluUmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSB7XG4gICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YXR1czogXCJkaXJ0eVwiLFxuICAgICAgICAgIHZhbHVlOiBpblJlc3VsdC52YWx1ZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5vdXQuX3BhcnNlU3luYyh7XG4gICAgICAgICAgZGF0YTogaW5SZXN1bHQudmFsdWUsXG4gICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgcGFyZW50OiBjdHhcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN0YXRpYyBjcmVhdGUoYSwgYikge1xuICAgIHJldHVybiBuZXcgX1pvZFBpcGVsaW5lKHtcbiAgICAgIGluOiBhLFxuICAgICAgb3V0OiBiLFxuICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RQaXBlbGluZVxuICAgIH0pO1xuICB9XG59O1xudmFyIFpvZFJlYWRvbmx5ID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoaW5wdXQpO1xuICAgIGNvbnN0IGZyZWV6ZSA9IChkYXRhKSA9PiB7XG4gICAgICBpZiAoaXNWYWxpZChkYXRhKSkge1xuICAgICAgICBkYXRhLnZhbHVlID0gT2JqZWN0LmZyZWV6ZShkYXRhLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG4gICAgcmV0dXJuIGlzQXN5bmMocmVzdWx0KSA/IHJlc3VsdC50aGVuKChkYXRhKSA9PiBmcmVlemUoZGF0YSkpIDogZnJlZXplKHJlc3VsdCk7XG4gIH1cbiAgdW53cmFwKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICB9XG59O1xuWm9kUmVhZG9ubHkuY3JlYXRlID0gKHR5cGUsIHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZFJlYWRvbmx5KHtcbiAgICBpbm5lclR5cGU6IHR5cGUsXG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RSZWFkb25seSxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xuZnVuY3Rpb24gY3VzdG9tKGNoZWNrLCBwYXJhbXMgPSB7fSwgZmF0YWwpIHtcbiAgaWYgKGNoZWNrKVxuICAgIHJldHVybiBab2RBbnkuY3JlYXRlKCkuc3VwZXJSZWZpbmUoKGRhdGEsIGN0eCkgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGlmICghY2hlY2soZGF0YSkpIHtcbiAgICAgICAgY29uc3QgcCA9IHR5cGVvZiBwYXJhbXMgPT09IFwiZnVuY3Rpb25cIiA/IHBhcmFtcyhkYXRhKSA6IHR5cGVvZiBwYXJhbXMgPT09IFwic3RyaW5nXCIgPyB7IG1lc3NhZ2U6IHBhcmFtcyB9IDogcGFyYW1zO1xuICAgICAgICBjb25zdCBfZmF0YWwgPSAoX2IgPSAoX2EgPSBwLmZhdGFsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYXRhbCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdHJ1ZTtcbiAgICAgICAgY29uc3QgcDIgPSB0eXBlb2YgcCA9PT0gXCJzdHJpbmdcIiA/IHsgbWVzc2FnZTogcCB9IDogcDtcbiAgICAgICAgY3R4LmFkZElzc3VlKHsgY29kZTogXCJjdXN0b21cIiwgLi4ucDIsIGZhdGFsOiBfZmF0YWwgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIHJldHVybiBab2RBbnkuY3JlYXRlKCk7XG59XG52YXIgbGF0ZSA9IHtcbiAgb2JqZWN0OiBab2RPYmplY3QubGF6eWNyZWF0ZVxufTtcbnZhciBab2RGaXJzdFBhcnR5VHlwZUtpbmQ7XG4oZnVuY3Rpb24oWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMikge1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kU3RyaW5nXCJdID0gXCJab2RTdHJpbmdcIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZE51bWJlclwiXSA9IFwiWm9kTnVtYmVyXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2ROYU5cIl0gPSBcIlpvZE5hTlwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kQmlnSW50XCJdID0gXCJab2RCaWdJbnRcIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZEJvb2xlYW5cIl0gPSBcIlpvZEJvb2xlYW5cIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZERhdGVcIl0gPSBcIlpvZERhdGVcIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZFN5bWJvbFwiXSA9IFwiWm9kU3ltYm9sXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RVbmRlZmluZWRcIl0gPSBcIlpvZFVuZGVmaW5lZFwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kTnVsbFwiXSA9IFwiWm9kTnVsbFwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kQW55XCJdID0gXCJab2RBbnlcIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZFVua25vd25cIl0gPSBcIlpvZFVua25vd25cIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZE5ldmVyXCJdID0gXCJab2ROZXZlclwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kVm9pZFwiXSA9IFwiWm9kVm9pZFwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kQXJyYXlcIl0gPSBcIlpvZEFycmF5XCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RPYmplY3RcIl0gPSBcIlpvZE9iamVjdFwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kVW5pb25cIl0gPSBcIlpvZFVuaW9uXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2REaXNjcmltaW5hdGVkVW5pb25cIl0gPSBcIlpvZERpc2NyaW1pbmF0ZWRVbmlvblwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kSW50ZXJzZWN0aW9uXCJdID0gXCJab2RJbnRlcnNlY3Rpb25cIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZFR1cGxlXCJdID0gXCJab2RUdXBsZVwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kUmVjb3JkXCJdID0gXCJab2RSZWNvcmRcIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZE1hcFwiXSA9IFwiWm9kTWFwXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RTZXRcIl0gPSBcIlpvZFNldFwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kRnVuY3Rpb25cIl0gPSBcIlpvZEZ1bmN0aW9uXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RMYXp5XCJdID0gXCJab2RMYXp5XCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RMaXRlcmFsXCJdID0gXCJab2RMaXRlcmFsXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RFbnVtXCJdID0gXCJab2RFbnVtXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RFZmZlY3RzXCJdID0gXCJab2RFZmZlY3RzXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2ROYXRpdmVFbnVtXCJdID0gXCJab2ROYXRpdmVFbnVtXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RPcHRpb25hbFwiXSA9IFwiWm9kT3B0aW9uYWxcIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZE51bGxhYmxlXCJdID0gXCJab2ROdWxsYWJsZVwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kRGVmYXVsdFwiXSA9IFwiWm9kRGVmYXVsdFwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kQ2F0Y2hcIl0gPSBcIlpvZENhdGNoXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RQcm9taXNlXCJdID0gXCJab2RQcm9taXNlXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RCcmFuZGVkXCJdID0gXCJab2RCcmFuZGVkXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RQaXBlbGluZVwiXSA9IFwiWm9kUGlwZWxpbmVcIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZFJlYWRvbmx5XCJdID0gXCJab2RSZWFkb25seVwiO1xufSkoWm9kRmlyc3RQYXJ0eVR5cGVLaW5kIHx8IChab2RGaXJzdFBhcnR5VHlwZUtpbmQgPSB7fSkpO1xudmFyIGluc3RhbmNlT2ZUeXBlID0gKGNscywgcGFyYW1zID0ge1xuICBtZXNzYWdlOiBgSW5wdXQgbm90IGluc3RhbmNlIG9mICR7Y2xzLm5hbWV9YFxufSkgPT4gY3VzdG9tKChkYXRhKSA9PiBkYXRhIGluc3RhbmNlb2YgY2xzLCBwYXJhbXMpO1xudmFyIHN0cmluZ1R5cGUgPSBab2RTdHJpbmcuY3JlYXRlO1xudmFyIG51bWJlclR5cGUgPSBab2ROdW1iZXIuY3JlYXRlO1xudmFyIG5hblR5cGUgPSBab2ROYU4uY3JlYXRlO1xudmFyIGJpZ0ludFR5cGUgPSBab2RCaWdJbnQuY3JlYXRlO1xudmFyIGJvb2xlYW5UeXBlID0gWm9kQm9vbGVhbi5jcmVhdGU7XG52YXIgZGF0ZVR5cGUgPSBab2REYXRlLmNyZWF0ZTtcbnZhciBzeW1ib2xUeXBlID0gWm9kU3ltYm9sLmNyZWF0ZTtcbnZhciB1bmRlZmluZWRUeXBlID0gWm9kVW5kZWZpbmVkLmNyZWF0ZTtcbnZhciBudWxsVHlwZSA9IFpvZE51bGwuY3JlYXRlO1xudmFyIGFueVR5cGUgPSBab2RBbnkuY3JlYXRlO1xudmFyIHVua25vd25UeXBlID0gWm9kVW5rbm93bi5jcmVhdGU7XG52YXIgbmV2ZXJUeXBlID0gWm9kTmV2ZXIuY3JlYXRlO1xudmFyIHZvaWRUeXBlID0gWm9kVm9pZC5jcmVhdGU7XG52YXIgYXJyYXlUeXBlID0gWm9kQXJyYXkuY3JlYXRlO1xudmFyIG9iamVjdFR5cGUgPSBab2RPYmplY3QuY3JlYXRlO1xudmFyIHN0cmljdE9iamVjdFR5cGUgPSBab2RPYmplY3Quc3RyaWN0Q3JlYXRlO1xudmFyIHVuaW9uVHlwZSA9IFpvZFVuaW9uLmNyZWF0ZTtcbnZhciBkaXNjcmltaW5hdGVkVW5pb25UeXBlID0gWm9kRGlzY3JpbWluYXRlZFVuaW9uLmNyZWF0ZTtcbnZhciBpbnRlcnNlY3Rpb25UeXBlID0gWm9kSW50ZXJzZWN0aW9uLmNyZWF0ZTtcbnZhciB0dXBsZVR5cGUgPSBab2RUdXBsZS5jcmVhdGU7XG52YXIgcmVjb3JkVHlwZSA9IFpvZFJlY29yZC5jcmVhdGU7XG52YXIgbWFwVHlwZSA9IFpvZE1hcC5jcmVhdGU7XG52YXIgc2V0VHlwZSA9IFpvZFNldC5jcmVhdGU7XG52YXIgZnVuY3Rpb25UeXBlID0gWm9kRnVuY3Rpb24uY3JlYXRlO1xudmFyIGxhenlUeXBlID0gWm9kTGF6eS5jcmVhdGU7XG52YXIgbGl0ZXJhbFR5cGUgPSBab2RMaXRlcmFsLmNyZWF0ZTtcbnZhciBlbnVtVHlwZSA9IFpvZEVudW0uY3JlYXRlO1xudmFyIG5hdGl2ZUVudW1UeXBlID0gWm9kTmF0aXZlRW51bS5jcmVhdGU7XG52YXIgcHJvbWlzZVR5cGUgPSBab2RQcm9taXNlLmNyZWF0ZTtcbnZhciBlZmZlY3RzVHlwZSA9IFpvZEVmZmVjdHMuY3JlYXRlO1xudmFyIG9wdGlvbmFsVHlwZSA9IFpvZE9wdGlvbmFsLmNyZWF0ZTtcbnZhciBudWxsYWJsZVR5cGUgPSBab2ROdWxsYWJsZS5jcmVhdGU7XG52YXIgcHJlcHJvY2Vzc1R5cGUgPSBab2RFZmZlY3RzLmNyZWF0ZVdpdGhQcmVwcm9jZXNzO1xudmFyIHBpcGVsaW5lVHlwZSA9IFpvZFBpcGVsaW5lLmNyZWF0ZTtcbnZhciBvc3RyaW5nID0gKCkgPT4gc3RyaW5nVHlwZSgpLm9wdGlvbmFsKCk7XG52YXIgb251bWJlciA9ICgpID0+IG51bWJlclR5cGUoKS5vcHRpb25hbCgpO1xudmFyIG9ib29sZWFuID0gKCkgPT4gYm9vbGVhblR5cGUoKS5vcHRpb25hbCgpO1xudmFyIGNvZXJjZSA9IHtcbiAgc3RyaW5nOiAoYXJnKSA9PiBab2RTdHJpbmcuY3JlYXRlKHsgLi4uYXJnLCBjb2VyY2U6IHRydWUgfSksXG4gIG51bWJlcjogKGFyZykgPT4gWm9kTnVtYmVyLmNyZWF0ZSh7IC4uLmFyZywgY29lcmNlOiB0cnVlIH0pLFxuICBib29sZWFuOiAoYXJnKSA9PiBab2RCb29sZWFuLmNyZWF0ZSh7XG4gICAgLi4uYXJnLFxuICAgIGNvZXJjZTogdHJ1ZVxuICB9KSxcbiAgYmlnaW50OiAoYXJnKSA9PiBab2RCaWdJbnQuY3JlYXRlKHsgLi4uYXJnLCBjb2VyY2U6IHRydWUgfSksXG4gIGRhdGU6IChhcmcpID0+IFpvZERhdGUuY3JlYXRlKHsgLi4uYXJnLCBjb2VyY2U6IHRydWUgfSlcbn07XG52YXIgTkVWRVIgPSBJTlZBTElEO1xudmFyIHogPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgZGVmYXVsdEVycm9yTWFwOiBlcnJvck1hcCxcbiAgc2V0RXJyb3JNYXAsXG4gIGdldEVycm9yTWFwLFxuICBtYWtlSXNzdWUsXG4gIEVNUFRZX1BBVEgsXG4gIGFkZElzc3VlVG9Db250ZXh0LFxuICBQYXJzZVN0YXR1cyxcbiAgSU5WQUxJRCxcbiAgRElSVFksXG4gIE9LLFxuICBpc0Fib3J0ZWQsXG4gIGlzRGlydHksXG4gIGlzVmFsaWQsXG4gIGlzQXN5bmMsXG4gIGdldCB1dGlsKCkge1xuICAgIHJldHVybiB1dGlsO1xuICB9LFxuICBnZXQgb2JqZWN0VXRpbCgpIHtcbiAgICByZXR1cm4gb2JqZWN0VXRpbDtcbiAgfSxcbiAgWm9kUGFyc2VkVHlwZSxcbiAgZ2V0UGFyc2VkVHlwZSxcbiAgWm9kVHlwZSxcbiAgZGF0ZXRpbWVSZWdleCxcbiAgWm9kU3RyaW5nLFxuICBab2ROdW1iZXIsXG4gIFpvZEJpZ0ludCxcbiAgWm9kQm9vbGVhbixcbiAgWm9kRGF0ZSxcbiAgWm9kU3ltYm9sLFxuICBab2RVbmRlZmluZWQsXG4gIFpvZE51bGwsXG4gIFpvZEFueSxcbiAgWm9kVW5rbm93bixcbiAgWm9kTmV2ZXIsXG4gIFpvZFZvaWQsXG4gIFpvZEFycmF5LFxuICBab2RPYmplY3QsXG4gIFpvZFVuaW9uLFxuICBab2REaXNjcmltaW5hdGVkVW5pb24sXG4gIFpvZEludGVyc2VjdGlvbixcbiAgWm9kVHVwbGUsXG4gIFpvZFJlY29yZCxcbiAgWm9kTWFwLFxuICBab2RTZXQsXG4gIFpvZEZ1bmN0aW9uLFxuICBab2RMYXp5LFxuICBab2RMaXRlcmFsLFxuICBab2RFbnVtLFxuICBab2ROYXRpdmVFbnVtLFxuICBab2RQcm9taXNlLFxuICBab2RFZmZlY3RzLFxuICBab2RUcmFuc2Zvcm1lcjogWm9kRWZmZWN0cyxcbiAgWm9kT3B0aW9uYWwsXG4gIFpvZE51bGxhYmxlLFxuICBab2REZWZhdWx0LFxuICBab2RDYXRjaCxcbiAgWm9kTmFOLFxuICBCUkFORCxcbiAgWm9kQnJhbmRlZCxcbiAgWm9kUGlwZWxpbmUsXG4gIFpvZFJlYWRvbmx5LFxuICBjdXN0b20sXG4gIFNjaGVtYTogWm9kVHlwZSxcbiAgWm9kU2NoZW1hOiBab2RUeXBlLFxuICBsYXRlLFxuICBnZXQgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kKCkge1xuICAgIHJldHVybiBab2RGaXJzdFBhcnR5VHlwZUtpbmQ7XG4gIH0sXG4gIGNvZXJjZSxcbiAgYW55OiBhbnlUeXBlLFxuICBhcnJheTogYXJyYXlUeXBlLFxuICBiaWdpbnQ6IGJpZ0ludFR5cGUsXG4gIGJvb2xlYW46IGJvb2xlYW5UeXBlLFxuICBkYXRlOiBkYXRlVHlwZSxcbiAgZGlzY3JpbWluYXRlZFVuaW9uOiBkaXNjcmltaW5hdGVkVW5pb25UeXBlLFxuICBlZmZlY3Q6IGVmZmVjdHNUeXBlLFxuICBcImVudW1cIjogZW51bVR5cGUsXG4gIFwiZnVuY3Rpb25cIjogZnVuY3Rpb25UeXBlLFxuICBcImluc3RhbmNlb2ZcIjogaW5zdGFuY2VPZlR5cGUsXG4gIGludGVyc2VjdGlvbjogaW50ZXJzZWN0aW9uVHlwZSxcbiAgbGF6eTogbGF6eVR5cGUsXG4gIGxpdGVyYWw6IGxpdGVyYWxUeXBlLFxuICBtYXA6IG1hcFR5cGUsXG4gIG5hbjogbmFuVHlwZSxcbiAgbmF0aXZlRW51bTogbmF0aXZlRW51bVR5cGUsXG4gIG5ldmVyOiBuZXZlclR5cGUsXG4gIFwibnVsbFwiOiBudWxsVHlwZSxcbiAgbnVsbGFibGU6IG51bGxhYmxlVHlwZSxcbiAgbnVtYmVyOiBudW1iZXJUeXBlLFxuICBvYmplY3Q6IG9iamVjdFR5cGUsXG4gIG9ib29sZWFuLFxuICBvbnVtYmVyLFxuICBvcHRpb25hbDogb3B0aW9uYWxUeXBlLFxuICBvc3RyaW5nLFxuICBwaXBlbGluZTogcGlwZWxpbmVUeXBlLFxuICBwcmVwcm9jZXNzOiBwcmVwcm9jZXNzVHlwZSxcbiAgcHJvbWlzZTogcHJvbWlzZVR5cGUsXG4gIHJlY29yZDogcmVjb3JkVHlwZSxcbiAgc2V0OiBzZXRUeXBlLFxuICBzdHJpY3RPYmplY3Q6IHN0cmljdE9iamVjdFR5cGUsXG4gIHN0cmluZzogc3RyaW5nVHlwZSxcbiAgc3ltYm9sOiBzeW1ib2xUeXBlLFxuICB0cmFuc2Zvcm1lcjogZWZmZWN0c1R5cGUsXG4gIHR1cGxlOiB0dXBsZVR5cGUsXG4gIFwidW5kZWZpbmVkXCI6IHVuZGVmaW5lZFR5cGUsXG4gIHVuaW9uOiB1bmlvblR5cGUsXG4gIHVua25vd246IHVua25vd25UeXBlLFxuICBcInZvaWRcIjogdm9pZFR5cGUsXG4gIE5FVkVSLFxuICBab2RJc3N1ZUNvZGUsXG4gIHF1b3RlbGVzc0pzb24sXG4gIFpvZEVycm9yXG59KTtcblxuLy8gcGFja2FnZS5qc29uXG52YXIgcGFja2FnZV9kZWZhdWx0ID0ge1xuICBuYW1lOiBcIkBpbWdseS9iYWNrZ3JvdW5kLXJlbW92YWxcIixcbiAgdmVyc2lvbjogXCIxLjUuOFwiLFxuICBkZXNjcmlwdGlvbjogXCJCYWNrZ3JvdW5kIFJlbW92YWwgaW4gdGhlIEJyb3dzZXJcIixcbiAga2V5d29yZHM6IFtcbiAgICBcImJhY2tncm91bmQtcmVtb3ZhbFwiLFxuICAgIFwiY2xpZW50LXNpZGVcIixcbiAgICBcImRhdGEtcHJpdmFjeVwiLFxuICAgIFwiaW1hZ2Utc2VnbWVudGF0aW9uXCIsXG4gICAgXCJpbWFnZS1tYXR0aW5nXCIsXG4gICAgXCJvbm54XCJcbiAgXSxcbiAgcmVwb3NpdG9yeToge1xuICAgIHR5cGU6IFwiZ2l0XCIsXG4gICAgdXJsOiBcImdpdCtodHRwczovL2dpdGh1Yi5jb20vaW1nbHkvYmFja2dyb3VuZC1yZW1vdmFsLWpzLmdpdFwiXG4gIH0sXG4gIGxpY2Vuc2U6IFwiU0VFIExJQ0VOU0UgSU4gTElDRU5TRS5tZFwiLFxuICBhdXRob3I6IHtcbiAgICBuYW1lOiBcIklNRy5MWSBHbWJIXCIsXG4gICAgZW1haWw6IFwic3VwcG9ydEBpbWcubHlcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9pbWcubHlcIlxuICB9LFxuICBidWdzOiB7XG4gICAgZW1haWw6IFwic3VwcG9ydEBpbWcubHlcIlxuICB9LFxuICBzb3VyY2U6IFwiLi9zcmMvaW5kZXgudHNcIixcbiAgbWFpbjogXCIuL2Rpc3QvaW5kZXguY2pzXCIsXG4gIG1vZHVsZTogXCIuL2Rpc3QvaW5kZXgubWpzXCIsXG4gIHR5cGVzOiBcIi4vZGlzdC9zcmMvaW5kZXguZC50c1wiLFxuICBleHBvcnRzOiB7XG4gICAgXCIuXCI6IHtcbiAgICAgIHJlcXVpcmU6IFwiLi9kaXN0L2luZGV4LmNqc1wiLFxuICAgICAgaW1wb3J0OiBcIi4vZGlzdC9pbmRleC5tanNcIixcbiAgICAgIHR5cGVzOiBcIi4vZGlzdC9zcmMvaW5kZXguZC50c1wiXG4gICAgfVxuICB9LFxuICBob21lcGFnZTogXCJodHRwczovL2ltZy5seS9zaG93Y2FzZXMvY2VzZGsvd2ViL2JhY2tncm91bmQtcmVtb3ZhbFwiLFxuICBmaWxlczogW1xuICAgIFwiTElDRU5TRS5tZFwiLFxuICAgIFwiUkVBRE1FLm1kXCIsXG4gICAgXCJDSEFOR0VMT0cubWRcIixcbiAgICBcIlRoaXJkUGFydHlMaWNlbnNlcy5qc29uXCIsXG4gICAgXCJkaXN0L1wiLFxuICAgIFwiYmluL1wiXG4gIF0sXG4gIHNjcmlwdHM6IHtcbiAgICBzdGFydDogXCJucG0gcnVuIHdhdGNoXCIsXG4gICAgY2xlYW46IFwibnB4IHJpbXJhZiBkaXN0XCIsXG4gICAgdGVzdDogXCJ0cnVlXCIsXG4gICAgcmVzb3VyY2VzOiBcIm5vZGUgLi4vLi4vc2NyaXB0cy9wYWNrYWdlLXJlc291cmNlcy5tanNcIixcbiAgICBcImNoYW5nZWxvZzpjcmVhdGVcIjogXCJub2RlIC4uLy4uL3NjcmlwdHMvY2hhbmdlbG9nL2NoYW5nZWxvZy1jcmVhdGUubWpzXCIsXG4gICAgXCJjaGFuZ2Vsb2c6Z2VuZXJhdGVcIjogXCJub2RlIC4uLy4uL3NjcmlwdHMvY2hhbmdlbG9nL2NoYW5nZWxvZy1nZW5lcmF0ZS5tanNcIixcbiAgICBidWlsZDogXCJucG0gcnVuIGNsZWFuICYmIG5wbSBydW4gdHlwZXMgJiYgbnBtIHJ1biByZXNvdXJjZXMgJiYgbnBtIHJ1biBjaGFuZ2Vsb2c6Z2VuZXJhdGUgJiYgbm9kZSBzY3JpcHRzL2J1aWxkLm1qc1wiLFxuICAgIHR5cGVzOiBcIiBucHggdHNjIC0tZGVjbGFyYXRpb24gLS1lbWl0RGVjbGFyYXRpb25Pbmx5IC0tZGVjbGFyYXRpb25EaXIgZGlzdCAtLWRlY2xhcmF0aW9uTWFwXCIsXG4gICAgd2F0Y2g6IFwibnBtIHJ1biBjbGVhbiAmJiBucG0gcnVuIHJlc291cmNlcyAmJiBucG0gcnVuIGNoYW5nZWxvZzpnZW5lcmF0ZSAmJiBub2RlIHNjcmlwdHMvd2F0Y2gubWpzXCIsXG4gICAgXCJwdWJsaXNoOmxhdGVzdFwiOiBcIm5wbSBwdWJsaXNoIC0tdGFnIGxhdGVzdCAtLWFjY2VzcyBwdWJsaWNcIixcbiAgICBcInB1Ymxpc2g6bmV4dFwiOiBcIm5wbSBwdWJsaXNoIC0tdGFnIG5leHQgLS1hY2Nlc3MgcHVibGljXCIsXG4gICAgXCJwYWNrYWdlOnBhY2tcIjogXCJucG0gcGFjayAuIC0tcGFjay1kZXN0aW5hdGlvbiAuLi8uLi9yZWxlYXNlc1wiLFxuICAgIGxpbnQ6IFwibnB4IHByZXR0aWVyIC0td3JpdGUgLlwiXG4gIH0sXG4gIGRlcGVuZGVuY2llczoge1xuICAgIFwibG9kYXNoLWVzXCI6IFwiXjQuMTcuMjFcIixcbiAgICBuZGFycmF5OiBcIn4xLjAuMFwiLFxuICAgIHpvZDogXCJeMy4yMy44XCJcbiAgfSxcbiAgcGVlckRlcGVuZGVuY2llczoge1xuICAgIFwib25ueHJ1bnRpbWUtd2ViXCI6IFwiMS4yMS4wLWRldi4yMDI1MDExNC0yMjhkZDE2ODkzXCJcbiAgfSxcbiAgZGV2RGVwZW5kZW5jaWVzOiB7XG4gICAgXCJAdHlwZXMvbG9kYXNoLWVzXCI6IFwiXjQuMTcuMTJcIixcbiAgICBcIkB0eXBlcy9uZGFycmF5XCI6IFwifjEuMC4xNFwiLFxuICAgIFwiQHR5cGVzL25vZGVcIjogXCJ+MjAuMy4wXCIsXG4gICAgYXNzZXJ0OiBcIn4yLjAuMFwiLFxuICAgIGVzYnVpbGQ6IFwifjAuMTguMFwiLFxuICAgIGdsb2I6IFwifjEwLjMuMFwiLFxuICAgIFwibnBtLWR0c1wiOiBcIn4xLjMuMFwiLFxuICAgIHByb2Nlc3M6IFwifjAuMTEuMFwiLFxuICAgIFwidHMtbG9hZGVyXCI6IFwifjkuNC4wXCIsXG4gICAgdHNsaWI6IFwifjIuNS4wXCIsXG4gICAgdHlwZXNjcmlwdDogXCJ+NS4xLjBcIixcbiAgICB1dGlsOiBcIn4wLjEyLjBcIixcbiAgICB3ZWJwYWNrOiBcIn41Ljg1LjBcIixcbiAgICBcIndlYnBhY2stY2xpXCI6IFwifjUuMS4wXCJcbiAgfSxcbiAgYnVuZGxlRGVwZW5kZW5jaWVzOiBbXVxufTtcblxuLy8gc3JjL3NjaGVtYS50c1xudmFyIENvbmZpZ1NjaGVtYSA9IHoub2JqZWN0KHtcbiAgcHVibGljUGF0aDogei5zdHJpbmcoKS5vcHRpb25hbCgpLmRlc2NyaWJlKFwiVGhlIHB1YmxpYyBwYXRoIHRvIHRoZSB3YXNtIGZpbGVzIGFuZCB0aGUgb25ueCBtb2RlbC5cIikuZGVmYXVsdChcbiAgICBcImh0dHBzOi8vc3RhdGljaW1nbHkuY29tL0BpbWdseS9iYWNrZ3JvdW5kLXJlbW92YWwtZGF0YS8ke1BBQ0tBR0VfVkVSU0lPTn0vZGlzdC9cIlxuICApLnRyYW5zZm9ybSgodmFsKSA9PiB7XG4gICAgcmV0dXJuIHZhbC5yZXBsYWNlKFwiJHtQQUNLQUdFX05BTUV9XCIsIHBhY2thZ2VfZGVmYXVsdC5uYW1lKS5yZXBsYWNlKFwiJHtQQUNLQUdFX1ZFUlNJT059XCIsIHBhY2thZ2VfZGVmYXVsdC52ZXJzaW9uKTtcbiAgfSksXG4gIGRlYnVnOiB6LmJvb2xlYW4oKS5kZWZhdWx0KGZhbHNlKS5kZXNjcmliZShcIldoZXRoZXIgdG8gZW5hYmxlIGRlYnVnIGxvZ2dpbmcuXCIpLFxuICByZXNjYWxlOiB6LmJvb2xlYW4oKS5kZWZhdWx0KHRydWUpLmRlc2NyaWJlKFwiV2hldGhlciB0byByZXNjYWxlIHRoZSBpbWFnZS5cIiksXG4gIGRldmljZTogei5lbnVtKFtcImNwdVwiLCBcImdwdVwiXSkuZGVmYXVsdChcImNwdVwiKS5kZXNjcmliZShcIlRoZSBkZXZpY2UgdG8gcnVuIHRoZSBtb2RlbCBvbi5cIiksXG4gIHByb3h5VG9Xb3JrZXI6IHouYm9vbGVhbigpLmRlZmF1bHQoZmFsc2UpLmRlc2NyaWJlKFwiV2hldGhlciB0byBwcm94eSBpbmZlcmVuY2UgdG8gYSB3ZWIgd29ya2VyLlwiKSxcbiAgZmV0Y2hBcmdzOiB6LmFueSgpLmRlZmF1bHQoe30pLmRlc2NyaWJlKFwiQXJndW1lbnRzIHRvIHBhc3MgdG8gZmV0Y2ggd2hlbiBsb2FkaW5nIHRoZSBtb2RlbC5cIiksXG4gIHByb2dyZXNzOiB6LmZ1bmN0aW9uKCkuYXJncyh6LnN0cmluZygpLCB6Lm51bWJlcigpLCB6Lm51bWJlcigpKS5yZXR1cm5zKHoudm9pZCgpKS5kZXNjcmliZShcIlByb2dyZXNzIGNhbGxiYWNrLlwiKS5vcHRpb25hbCgpLFxuICBtb2RlbDogei5wcmVwcm9jZXNzKFxuICAgICh2YWwpID0+IHtcbiAgICAgIHN3aXRjaCAodmFsKSB7XG4gICAgICAgIGNhc2UgXCJsYXJnZVwiOlxuICAgICAgICAgIHJldHVybiBcImlzbmV0XCI7XG4gICAgICAgIGNhc2UgXCJzbWFsbFwiOlxuICAgICAgICAgIHJldHVybiBcImlzbmV0X3F1aW50OFwiO1xuICAgICAgICBjYXNlIFwibWVkaXVtXCI6XG4gICAgICAgICAgcmV0dXJuIFwiaXNuZXRfZnAxNlwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9XG4gICAgfSxcbiAgICB6LmVudW0oW1wiaXNuZXRcIiwgXCJpc25ldF9mcDE2XCIsIFwiaXNuZXRfcXVpbnQ4XCJdKVxuICApLmRlZmF1bHQoXCJtZWRpdW1cIiksXG4gIG91dHB1dDogei5vYmplY3Qoe1xuICAgIGZvcm1hdDogei5lbnVtKFtcbiAgICAgIFwiaW1hZ2UvcG5nXCIsXG4gICAgICBcImltYWdlL2pwZWdcIixcbiAgICAgIFwiaW1hZ2Uvd2VicFwiLFxuICAgICAgXCJpbWFnZS94LXJnYmE4XCIsXG4gICAgICBcImltYWdlL3gtYWxwaGE4XCJcbiAgICBdKS5kZWZhdWx0KFwiaW1hZ2UvcG5nXCIpLFxuICAgIHF1YWxpdHk6IHoubnVtYmVyKCkuZGVmYXVsdCgwLjgpXG4gIH0pLmRlZmF1bHQoe30pXG59KS5kZWZhdWx0KHt9KS50cmFuc2Zvcm0oKGNvbmZpZykgPT4ge1xuICBpZiAoY29uZmlnLmRlYnVnKVxuICAgIGNvbnNvbGUubG9nKFwiQ29uZmlnOlwiLCBjb25maWcpO1xuICBpZiAoY29uZmlnLmRlYnVnICYmICFjb25maWcucHJvZ3Jlc3MpIHtcbiAgICBjb25maWcucHJvZ3Jlc3MgPSBjb25maWcucHJvZ3Jlc3MgPz8gKChrZXksIGN1cnJlbnQsIHRvdGFsKSA9PiB7XG4gICAgICBjb25zb2xlLmRlYnVnKGBEb3dubG9hZGluZyAke2tleX06ICR7Y3VycmVudH0gb2YgJHt0b3RhbH1gKTtcbiAgICB9KTtcbiAgICBpZiAoIWNyb3NzT3JpZ2luSXNvbGF0ZWQpIHtcbiAgICAgIGlmIChjb25maWcuZGVidWcpXG4gICAgICAgIGNvbnNvbGUuZGVidWcoXG4gICAgICAgICAgXCJDcm9zcy1PcmlnaW4tSXNvbGF0ZWQgaXMgbm90IGVuYWJsZWQuIFBlcmZvcm1hbmNlIHdpbGwgYmUgZGVncmFkZWQuIFBsZWFzZSBzZWUgIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1NoYXJlZEFycmF5QnVmZmVyLlwiXG4gICAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb25maWc7XG59KTtcbmZ1bmN0aW9uIHZhbGlkYXRlQ29uZmlnKGNvbmZpZ3VyYXRpb24pIHtcbiAgcmV0dXJuIENvbmZpZ1NjaGVtYS5wYXJzZShjb25maWd1cmF0aW9uID8/IHt9KTtcbn1cblxuLy8gc3JjL2luZmVyZW5jZS50c1xudmFyIGltcG9ydF9uZGFycmF5NCA9IF9fdG9FU00ocmVxdWlyZV9uZGFycmF5KCkpO1xuYXN5bmMgZnVuY3Rpb24gaW5pdEJhc2UoY29uZmlnKSB7XG4gIGlmIChjb25maWcuZGVidWcpXG4gICAgY29uc29sZS5kZWJ1ZyhcIkxvYWRpbmcgbW9kZWwuLi5cIiwgY29uZmlnLm1vZGVsKTtcbiAgY29uc3QgbW9kZWwgPSBjb25maWcubW9kZWw7XG4gIGNvbnN0IGJsb2IgPSBhd2FpdCBsb2FkQXNCbG9iKGAvbW9kZWxzLyR7bW9kZWx9YCwgY29uZmlnKTtcbiAgY29uc3QgYXJyYXlCdWZmZXIgPSBhd2FpdCBibG9iLmFycmF5QnVmZmVyKCk7XG4gIGNvbnN0IHNlc3Npb24gPSBhd2FpdCBjcmVhdGVPbm54U2Vzc2lvbihhcnJheUJ1ZmZlciwgY29uZmlnKTtcbiAgcmV0dXJuIHNlc3Npb247XG59XG5hc3luYyBmdW5jdGlvbiBpbml0SW5mZXJlbmNlKGNvbmZpZykge1xuICBjb25maWcgPSB2YWxpZGF0ZUNvbmZpZyhjb25maWcpO1xuICBjb25zdCBiYXNlID0gYXdhaXQgaW5pdEJhc2UoY29uZmlnKTtcbiAgcmV0dXJuIHsgY29uZmlnLCBzZXNzaW9uOiB7IGJhc2UgfSB9O1xufVxuYXN5bmMgZnVuY3Rpb24gcnVuSW5mZXJlbmNlKGltYWdlVGVuc29yLCBjb25maWcsIHNlc3Npb24pIHtcbiAgY29uc3QgcmVzb2x1dGlvbiA9IDEwMjQ7XG4gIGNvbnN0IFtzcmNIZWlnaHQsIHNyY1dpZHRoLCBzcmNDaGFubmVsc10gPSBpbWFnZVRlbnNvci5zaGFwZTtcbiAgY29uc3Qga2VlcEFzcGVjdCA9IGZhbHNlO1xuICBsZXQgcmVzaXplZEltYWdlVGVuc29yID0gdGVuc29yUmVzaXplQmlsaW5lYXIoXG4gICAgaW1hZ2VUZW5zb3IsXG4gICAgcmVzb2x1dGlvbixcbiAgICByZXNvbHV0aW9uLFxuICAgIGtlZXBBc3BlY3RcbiAgKTtcbiAgY29uc3QgaW5wdXRUZW5zb3IgPSB0ZW5zb3JIV0N0b0JDSFcocmVzaXplZEltYWdlVGVuc29yKTtcbiAgbGV0IHByZWRpY3Rpb25zRGljdCA9IGF3YWl0IHJ1bk9ubnhTZXNzaW9uKFxuICAgIHNlc3Npb24uYmFzZSxcbiAgICBbW1wiaW5wdXRcIiwgaW5wdXRUZW5zb3JdXSxcbiAgICBbXCJvdXRwdXRcIl0sXG4gICAgY29uZmlnXG4gICk7XG4gIGxldCBhbHBoYW1hc2syID0gKDAsIGltcG9ydF9uZGFycmF5NC5kZWZhdWx0KShwcmVkaWN0aW9uc0RpY3RbMF0uZGF0YSwgW3Jlc29sdXRpb24sIHJlc29sdXRpb24sIDFdKTtcbiAgbGV0IGFscGhhbWFza1U4ID0gY29udmVydEZsb2F0MzJUb1VpbnQ4KGFscGhhbWFzazIpO1xuICBpZiAoY29uZmlnLnJlc2NhbGUpIHtcbiAgICBhbHBoYW1hc2tVOCA9IHRlbnNvclJlc2l6ZUJpbGluZWFyKFxuICAgICAgYWxwaGFtYXNrVTgsXG4gICAgICBzcmNXaWR0aCxcbiAgICAgIHNyY0hlaWdodCxcbiAgICAgIGtlZXBBc3BlY3RcbiAgICApO1xuICAgIHJldHVybiBbYWxwaGFtYXNrVTgsIGltYWdlVGVuc29yXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW2FscGhhbWFza1U4LCByZXNpemVkSW1hZ2VUZW5zb3JdO1xuICB9XG59XG5cbi8vIHNyYy9hcGkvdjEudHNcbnZhciBpbml0ID0gKDAsIGltcG9ydF9sb2Rhc2gubWVtb2l6ZSkoaW5pdEluZmVyZW5jZSwgKGNvbmZpZykgPT4gSlNPTi5zdHJpbmdpZnkoY29uZmlnKSk7XG5hc3luYyBmdW5jdGlvbiBwcmVsb2FkKGNvbmZpZ3VyYXRpb24pIHtcbiAgYXdhaXQgaW5pdChjb25maWd1cmF0aW9uKTtcbiAgcmV0dXJuO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVtb3ZlQmFja2dyb3VuZChpbWFnZSwgY29uZmlndXJhdGlvbikge1xuICBjb25zdCB7IGNvbmZpZywgc2Vzc2lvbiB9ID0gYXdhaXQgaW5pdChjb25maWd1cmF0aW9uKTtcbiAgaWYgKGNvbmZpZy5wcm9ncmVzcylcbiAgICBjb25maWcucHJvZ3Jlc3MoXCJjb21wdXRlOmRlY29kZVwiLCAwLCA0KTtcbiAgY29uc3QgaW5wdXRJbWFnZVRlbnNvciA9IGF3YWl0IGltYWdlU291cmNlVG9JbWFnZURhdGEoaW1hZ2UsIGNvbmZpZyk7XG4gIGNvbmZpZy5wcm9ncmVzcz8uKFwiY29tcHV0ZTppbmZlcmVuY2VcIiwgMSwgNCk7XG4gIGNvbnN0IFthbHBoYW1hc2syLCBpbWFnZVRlbnNvcl0gPSBhd2FpdCBydW5JbmZlcmVuY2UoXG4gICAgaW5wdXRJbWFnZVRlbnNvcixcbiAgICBjb25maWcsXG4gICAgc2Vzc2lvblxuICApO1xuICBjb25maWcucHJvZ3Jlc3M/LihcImNvbXB1dGU6bWFza1wiLCAyLCA0KTtcbiAgY29uc3Qgb3V0SW1hZ2VUZW5zb3IgPSBpbWFnZVRlbnNvcjtcbiAgY29uc3QgW3dpZHRoLCBoZWlnaHRdID0gb3V0SW1hZ2VUZW5zb3Iuc2hhcGU7XG4gIGNvbnN0IHN0cmlkZSA9IHdpZHRoICogaGVpZ2h0O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmlkZTsgaSArPSAxKSB7XG4gICAgb3V0SW1hZ2VUZW5zb3IuZGF0YVs0ICogaSArIDNdID0gYWxwaGFtYXNrMi5kYXRhW2ldO1xuICB9XG4gIGNvbmZpZy5wcm9ncmVzcz8uKFwiY29tcHV0ZTplbmNvZGVcIiwgMywgNCk7XG4gIGNvbnN0IG91dEltYWdlID0gYXdhaXQgaW1hZ2VFbmNvZGUoXG4gICAgb3V0SW1hZ2VUZW5zb3IsXG4gICAgY29uZmlnLm91dHB1dC5xdWFsaXR5LFxuICAgIGNvbmZpZy5vdXRwdXQuZm9ybWF0XG4gICk7XG4gIGNvbmZpZy5wcm9ncmVzcz8uKFwiY29tcHV0ZTplbmNvZGVcIiwgNCwgNCk7XG4gIHJldHVybiBvdXRJbWFnZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHJlbW92ZUZvcmVncm91bmQoaW1hZ2UsIGNvbmZpZ3VyYXRpb24pIHtcbiAgY29uc3QgeyBjb25maWcsIHNlc3Npb24gfSA9IGF3YWl0IGluaXQoY29uZmlndXJhdGlvbik7XG4gIGNvbnN0IGltYWdlVGVuc29yID0gYXdhaXQgaW1hZ2VTb3VyY2VUb0ltYWdlRGF0YShpbWFnZSwgY29uZmlnKTtcbiAgY29uc3QgW2FscGhhbWFzazIsIGltYWdlSW5wdXRdID0gYXdhaXQgcnVuSW5mZXJlbmNlKFxuICAgIGltYWdlVGVuc29yLFxuICAgIGNvbmZpZyxcbiAgICBzZXNzaW9uXG4gICk7XG4gIGNvbnN0IG91dEltYWdlVGVuc29yID0gaW1hZ2VJbnB1dDtcbiAgY29uc3QgW3dpZHRoLCBoZWlnaHQsIGNoYW5uZWxzXSA9IG91dEltYWdlVGVuc29yLnNoYXBlO1xuICBjb25zdCBzdHJpZGUgPSB3aWR0aCAqIGhlaWdodDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpZGU7IGkgKz0gMSkge1xuICAgIG91dEltYWdlVGVuc29yLmRhdGFbNCAqIGkgKyAzXSA9IDI1NSAtIGFscGhhbWFzazIuZGF0YVtpXTtcbiAgfVxuICBjb25zdCBvdXRJbWFnZSA9IGF3YWl0IGltYWdlRW5jb2RlKFxuICAgIG91dEltYWdlVGVuc29yLFxuICAgIGNvbmZpZy5vdXRwdXQucXVhbGl0eSxcbiAgICBjb25maWcub3V0cHV0LmZvcm1hdFxuICApO1xuICByZXR1cm4gb3V0SW1hZ2U7XG59XG52YXIgYWxwaGFtYXNrID0gc2VnbWVudEZvcmVncm91bmQ7XG5hc3luYyBmdW5jdGlvbiBzZWdtZW50Rm9yZWdyb3VuZChpbWFnZSwgY29uZmlndXJhdGlvbikge1xuICBjb25zdCB7IGNvbmZpZywgc2Vzc2lvbiB9ID0gYXdhaXQgaW5pdChjb25maWd1cmF0aW9uKTtcbiAgY29uc3QgaW1hZ2VUZW5zb3IgPSBhd2FpdCBpbWFnZVNvdXJjZVRvSW1hZ2VEYXRhKGltYWdlLCBjb25maWcpO1xuICBsZXQgW2hlaWdodCwgd2lkdGgsIGNoYW5uZWxzXSA9IGltYWdlVGVuc29yLnNoYXBlO1xuICBjb25zdCBbYWxwaGFtYXNrMiwgaW1hZ2VJbnB1dF0gPSBhd2FpdCBydW5JbmZlcmVuY2UoXG4gICAgaW1hZ2VUZW5zb3IsXG4gICAgY29uZmlnLFxuICAgIHNlc3Npb25cbiAgKTtcbiAgY29uc3Qgc3RyaWRlID0gd2lkdGggKiBoZWlnaHQ7XG4gIGNvbnN0IG91dEltYWdlVGVuc29yID0gaW1hZ2VUZW5zb3I7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaWRlOyBpICs9IDEpIHtcbiAgICBjb25zdCBpbmRleCA9IDQgKiBpO1xuICAgIGxldCBhbHBoYSA9IGFscGhhbWFzazIuZGF0YVtpXTtcbiAgICBvdXRJbWFnZVRlbnNvci5kYXRhW2luZGV4XSA9IDI1NTtcbiAgICBvdXRJbWFnZVRlbnNvci5kYXRhW2luZGV4ICsgMV0gPSAyNTU7XG4gICAgb3V0SW1hZ2VUZW5zb3IuZGF0YVtpbmRleCArIDJdID0gMjU1O1xuICAgIG91dEltYWdlVGVuc29yLmRhdGFbaW5kZXggKyAzXSA9IGFscGhhO1xuICB9XG4gIGNvbnN0IG91dEltYWdlID0gYXdhaXQgaW1hZ2VFbmNvZGUoXG4gICAgb3V0SW1hZ2VUZW5zb3IsXG4gICAgY29uZmlnLm91dHB1dC5xdWFsaXR5LFxuICAgIGNvbmZpZy5vdXRwdXQuZm9ybWF0XG4gICk7XG4gIHJldHVybiBvdXRJbWFnZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGFwcGx5U2VnbWVudGF0aW9uTWFzayhpbWFnZSwgbWFzaywgY29uZmlnKSB7XG4gIGNvbmZpZyA9IHZhbGlkYXRlQ29uZmlnKGNvbmZpZyk7XG4gIGNvbnN0IGltYWdlVGVuc29yID0gYXdhaXQgaW1hZ2VTb3VyY2VUb0ltYWdlRGF0YShpbWFnZSwgY29uZmlnKTtcbiAgY29uc3QgW2ltYWdlSGVpZ2h0LCBpbWFnZVdpZHRoLCBpbWFnZUNoYW5uZWxzXSA9IGltYWdlVGVuc29yLnNoYXBlO1xuICBjb25zdCBtYXNrVGVuc29yID0gYXdhaXQgaW1hZ2VTb3VyY2VUb0ltYWdlRGF0YShtYXNrLCBjb25maWcpO1xuICBjb25zdCBbbWFza0hlaWdodCwgbWFza1dpZHRoLCBtYXNrQ2hhbm5lbHNdID0gbWFza1RlbnNvci5zaGFwZTtcbiAgY29uc3QgYWxwaGFNYXNrID0gbWFza0hlaWdodCAhPT0gaW1hZ2VIZWlnaHQgfHwgbWFza1dpZHRoICE9PSBpbWFnZVdpZHRoID8gdGVuc29yUmVzaXplQmlsaW5lYXIobWFza1RlbnNvciwgaW1hZ2VXaWR0aCwgaW1hZ2VIZWlnaHQpIDogbWFza1RlbnNvcjtcbiAgY29uc3Qgc3RyaWRlID0gaW1hZ2VXaWR0aCAqIGltYWdlSGVpZ2h0O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmlkZTsgaSArPSAxKSB7XG4gICAgY29uc3QgaWR4SW1hZ2UgPSBpbWFnZUNoYW5uZWxzICogaTtcbiAgICBjb25zdCBpZHhNYXNrID0gbWFza0NoYW5uZWxzICogaTtcbiAgICBpbWFnZVRlbnNvci5kYXRhW2lkeEltYWdlICsgM10gPSBhbHBoYU1hc2suZGF0YVtpZHhNYXNrICsgM107XG4gIH1cbiAgY29uc3Qgb3V0SW1hZ2UgPSBhd2FpdCBpbWFnZUVuY29kZShcbiAgICBpbWFnZVRlbnNvcixcbiAgICBjb25maWcub3V0cHV0LnF1YWxpdHksXG4gICAgY29uZmlnLm91dHB1dC5mb3JtYXRcbiAgKTtcbiAgcmV0dXJuIG91dEltYWdlO1xufVxuZXhwb3J0IHtcbiAgYWxwaGFtYXNrLFxuICBhcHBseVNlZ21lbnRhdGlvbk1hc2ssXG4gIHByZWxvYWQsXG4gIHJlbW92ZUJhY2tncm91bmQsXG4gIHJlbW92ZUZvcmVncm91bmQsXG4gIHNlZ21lbnRGb3JlZ3JvdW5kXG59O1xuLyohIEJ1bmRsZWQgbGljZW5zZSBpbmZvcm1hdGlvbjpcblxubG9kYXNoL2xvZGFzaC5qczpcbiAgKCoqXG4gICAqIEBsaWNlbnNlXG4gICAqIExvZGFzaCA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAgICogQ29weXJpZ2h0IE9wZW5KUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vb3BlbmpzZi5vcmcvPlxuICAgKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gICAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gICAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICAgKilcblxuaXMtYnVmZmVyL2luZGV4LmpzOlxuICAoKiFcbiAgICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlclxuICAgKlxuICAgKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICAgKiBAbGljZW5zZSAgTUlUXG4gICAqKVxuKi9cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6WyJfX2NyZWF0ZSIsIk9iamVjdCIsImNyZWF0ZSIsIl9fZGVmUHJvcCIsImRlZmluZVByb3BlcnR5IiwiX19nZXRPd25Qcm9wRGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9fZ2V0T3duUHJvcE5hbWVzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIl9fZ2V0UHJvdG9PZiIsImdldFByb3RvdHlwZU9mIiwiX19oYXNPd25Qcm9wIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJfX2NvbW1vbkpTIiwiY2IiLCJtb2QiLCJfX3JlcXVpcmUiLCJleHBvcnRzIiwiX19jb3B5UHJvcHMiLCJ0byIsImZyb20iLCJleGNlcHQiLCJkZXNjIiwia2V5IiwiY2FsbCIsImdldCIsImVudW1lcmFibGUiLCJfX3RvRVNNIiwiaXNOb2RlTW9kZSIsInRhcmdldCIsIl9fZXNNb2R1bGUiLCJ2YWx1ZSIsInJlcXVpcmVfbG9kYXNoIiwibW9kdWxlIiwidW5kZWZpbmVkMiIsIlZFUlNJT04iLCJMQVJHRV9BUlJBWV9TSVpFIiwiQ09SRV9FUlJPUl9URVhUIiwiRlVOQ19FUlJPUl9URVhUIiwiSU5WQUxJRF9URU1QTF9WQVJfRVJST1JfVEVYVCIsIkhBU0hfVU5ERUZJTkVEIiwiTUFYX01FTU9JWkVfU0laRSIsIlBMQUNFSE9MREVSIiwiQ0xPTkVfREVFUF9GTEFHIiwiQ0xPTkVfRkxBVF9GTEFHIiwiQ0xPTkVfU1lNQk9MU19GTEFHIiwiQ09NUEFSRV9QQVJUSUFMX0ZMQUciLCJDT01QQVJFX1VOT1JERVJFRF9GTEFHIiwiV1JBUF9CSU5EX0ZMQUciLCJXUkFQX0JJTkRfS0VZX0ZMQUciLCJXUkFQX0NVUlJZX0JPVU5EX0ZMQUciLCJXUkFQX0NVUlJZX0ZMQUciLCJXUkFQX0NVUlJZX1JJR0hUX0ZMQUciLCJXUkFQX1BBUlRJQUxfRkxBRyIsIldSQVBfUEFSVElBTF9SSUdIVF9GTEFHIiwiV1JBUF9BUllfRkxBRyIsIldSQVBfUkVBUkdfRkxBRyIsIldSQVBfRkxJUF9GTEFHIiwiREVGQVVMVF9UUlVOQ19MRU5HVEgiLCJERUZBVUxUX1RSVU5DX09NSVNTSU9OIiwiSE9UX0NPVU5UIiwiSE9UX1NQQU4iLCJMQVpZX0ZJTFRFUl9GTEFHIiwiTEFaWV9NQVBfRkxBRyIsIkxBWllfV0hJTEVfRkxBRyIsIklORklOSVRZIiwiTUFYX1NBRkVfSU5URUdFUiIsIk1BWF9JTlRFR0VSIiwiTkFOIiwiTUFYX0FSUkFZX0xFTkdUSCIsIk1BWF9BUlJBWV9JTkRFWCIsIkhBTEZfTUFYX0FSUkFZX0xFTkdUSCIsIndyYXBGbGFncyIsImFyZ3NUYWciLCJhcnJheVRhZyIsImFzeW5jVGFnIiwiYm9vbFRhZyIsImRhdGVUYWciLCJkb21FeGNUYWciLCJlcnJvclRhZyIsImZ1bmNUYWciLCJnZW5UYWciLCJtYXBUYWciLCJudW1iZXJUYWciLCJudWxsVGFnIiwib2JqZWN0VGFnIiwicHJvbWlzZVRhZyIsInByb3h5VGFnIiwicmVnZXhwVGFnIiwic2V0VGFnIiwic3RyaW5nVGFnIiwic3ltYm9sVGFnIiwidW5kZWZpbmVkVGFnIiwid2Vha01hcFRhZyIsIndlYWtTZXRUYWciLCJhcnJheUJ1ZmZlclRhZyIsImRhdGFWaWV3VGFnIiwiZmxvYXQzMlRhZyIsImZsb2F0NjRUYWciLCJpbnQ4VGFnIiwiaW50MTZUYWciLCJpbnQzMlRhZyIsInVpbnQ4VGFnIiwidWludDhDbGFtcGVkVGFnIiwidWludDE2VGFnIiwidWludDMyVGFnIiwicmVFbXB0eVN0cmluZ0xlYWRpbmciLCJyZUVtcHR5U3RyaW5nTWlkZGxlIiwicmVFbXB0eVN0cmluZ1RyYWlsaW5nIiwicmVFc2NhcGVkSHRtbCIsInJlVW5lc2NhcGVkSHRtbCIsInJlSGFzRXNjYXBlZEh0bWwiLCJSZWdFeHAiLCJzb3VyY2UiLCJyZUhhc1VuZXNjYXBlZEh0bWwiLCJyZUVzY2FwZSIsInJlRXZhbHVhdGUiLCJyZUludGVycG9sYXRlIiwicmVJc0RlZXBQcm9wIiwicmVJc1BsYWluUHJvcCIsInJlUHJvcE5hbWUiLCJyZVJlZ0V4cENoYXIiLCJyZUhhc1JlZ0V4cENoYXIiLCJyZVRyaW1TdGFydCIsInJlV2hpdGVzcGFjZSIsInJlV3JhcENvbW1lbnQiLCJyZVdyYXBEZXRhaWxzIiwicmVTcGxpdERldGFpbHMiLCJyZUFzY2lpV29yZCIsInJlRm9yYmlkZGVuSWRlbnRpZmllckNoYXJzIiwicmVFc2NhcGVDaGFyIiwicmVFc1RlbXBsYXRlIiwicmVGbGFncyIsInJlSXNCYWRIZXgiLCJyZUlzQmluYXJ5IiwicmVJc0hvc3RDdG9yIiwicmVJc09jdGFsIiwicmVJc1VpbnQiLCJyZUxhdGluIiwicmVOb01hdGNoIiwicmVVbmVzY2FwZWRTdHJpbmciLCJyc0FzdHJhbFJhbmdlIiwicnNDb21ib01hcmtzUmFuZ2UiLCJyZUNvbWJvSGFsZk1hcmtzUmFuZ2UiLCJyc0NvbWJvU3ltYm9sc1JhbmdlIiwicnNDb21ib1JhbmdlIiwicnNEaW5nYmF0UmFuZ2UiLCJyc0xvd2VyUmFuZ2UiLCJyc01hdGhPcFJhbmdlIiwicnNOb25DaGFyUmFuZ2UiLCJyc1B1bmN0dWF0aW9uUmFuZ2UiLCJyc1NwYWNlUmFuZ2UiLCJyc1VwcGVyUmFuZ2UiLCJyc1ZhclJhbmdlIiwicnNCcmVha1JhbmdlIiwicnNBcG9zIiwicnNBc3RyYWwiLCJyc0JyZWFrIiwicnNDb21ibyIsInJzRGlnaXRzIiwicnNEaW5nYmF0IiwicnNMb3dlciIsInJzTWlzYyIsInJzRml0eiIsInJzTW9kaWZpZXIiLCJyc05vbkFzdHJhbCIsInJzUmVnaW9uYWwiLCJyc1N1cnJQYWlyIiwicnNVcHBlciIsInJzWldKIiwicnNNaXNjTG93ZXIiLCJyc01pc2NVcHBlciIsInJzT3B0Q29udHJMb3dlciIsInJzT3B0Q29udHJVcHBlciIsInJlT3B0TW9kIiwicnNPcHRWYXIiLCJyc09wdEpvaW4iLCJqb2luIiwicnNPcmRMb3dlciIsInJzT3JkVXBwZXIiLCJyc1NlcSIsInJzRW1vamkiLCJyc1N5bWJvbCIsInJlQXBvcyIsInJlQ29tYm9NYXJrIiwicmVVbmljb2RlIiwicmVVbmljb2RlV29yZCIsInJlSGFzVW5pY29kZSIsInJlSGFzVW5pY29kZVdvcmQiLCJjb250ZXh0UHJvcHMiLCJ0ZW1wbGF0ZUNvdW50ZXIiLCJ0eXBlZEFycmF5VGFncyIsImNsb25lYWJsZVRhZ3MiLCJkZWJ1cnJlZExldHRlcnMiLCJodG1sRXNjYXBlcyIsImh0bWxVbmVzY2FwZXMiLCJzdHJpbmdFc2NhcGVzIiwiZnJlZVBhcnNlRmxvYXQiLCJwYXJzZUZsb2F0IiwiZnJlZVBhcnNlSW50IiwicGFyc2VJbnQiLCJmcmVlR2xvYmFsIiwiZ2xvYmFsIiwiZnJlZVNlbGYiLCJzZWxmIiwicm9vdCIsIkZ1bmN0aW9uIiwiZnJlZUV4cG9ydHMiLCJub2RlVHlwZSIsImZyZWVNb2R1bGUiLCJtb2R1bGVFeHBvcnRzIiwiZnJlZVByb2Nlc3MiLCJwcm9jZXNzIiwibm9kZVV0aWwiLCJ0eXBlcyIsInJlcXVpcmUiLCJiaW5kaW5nIiwiZSIsIm5vZGVJc0FycmF5QnVmZmVyIiwiaXNBcnJheUJ1ZmZlciIsIm5vZGVJc0RhdGUiLCJpc0RhdGUiLCJub2RlSXNNYXAiLCJpc01hcCIsIm5vZGVJc1JlZ0V4cCIsImlzUmVnRXhwIiwibm9kZUlzU2V0IiwiaXNTZXQiLCJub2RlSXNUeXBlZEFycmF5IiwiaXNUeXBlZEFycmF5IiwiYXBwbHkiLCJmdW5jIiwidGhpc0FyZyIsImFyZ3MiLCJsZW5ndGgiLCJhcnJheUFnZ3JlZ2F0b3IiLCJhcnJheSIsInNldHRlciIsIml0ZXJhdGVlIiwiYWNjdW11bGF0b3IiLCJpbmRleCIsImFycmF5RWFjaCIsImFycmF5RWFjaFJpZ2h0IiwiYXJyYXlFdmVyeSIsInByZWRpY2F0ZSIsImFycmF5RmlsdGVyIiwicmVzSW5kZXgiLCJyZXN1bHQiLCJhcnJheUluY2x1ZGVzIiwiYmFzZUluZGV4T2YiLCJhcnJheUluY2x1ZGVzV2l0aCIsImNvbXBhcmF0b3IiLCJhcnJheU1hcCIsIkFycmF5IiwiYXJyYXlQdXNoIiwidmFsdWVzIiwib2Zmc2V0IiwiYXJyYXlSZWR1Y2UiLCJpbml0QWNjdW0iLCJhcnJheVJlZHVjZVJpZ2h0IiwiYXJyYXlTb21lIiwiYXNjaWlTaXplIiwiYmFzZVByb3BlcnR5IiwiYXNjaWlUb0FycmF5Iiwic3RyaW5nIiwic3BsaXQiLCJhc2NpaVdvcmRzIiwibWF0Y2giLCJiYXNlRmluZEtleSIsImNvbGxlY3Rpb24iLCJlYWNoRnVuYyIsImNvbGxlY3Rpb24yIiwiYmFzZUZpbmRJbmRleCIsImZyb21JbmRleCIsImZyb21SaWdodCIsInN0cmljdEluZGV4T2YiLCJiYXNlSXNOYU4iLCJiYXNlSW5kZXhPZldpdGgiLCJiYXNlTWVhbiIsImJhc2VTdW0iLCJvYmplY3QiLCJiYXNlUHJvcGVydHlPZiIsImJhc2VSZWR1Y2UiLCJiYXNlU29ydEJ5IiwiY29tcGFyZXIiLCJzb3J0IiwiY3VycmVudCIsImJhc2VUaW1lcyIsIm4iLCJiYXNlVG9QYWlycyIsInByb3BzIiwiYmFzZVRyaW0iLCJzbGljZSIsInRyaW1tZWRFbmRJbmRleCIsInJlcGxhY2UiLCJiYXNlVW5hcnkiLCJiYXNlVmFsdWVzIiwiY2FjaGVIYXMiLCJjYWNoZSIsImhhcyIsImNoYXJzU3RhcnRJbmRleCIsInN0clN5bWJvbHMiLCJjaHJTeW1ib2xzIiwiY2hhcnNFbmRJbmRleCIsImNvdW50SG9sZGVycyIsInBsYWNlaG9sZGVyIiwiZGVidXJyTGV0dGVyIiwiZXNjYXBlSHRtbENoYXIiLCJlc2NhcGVTdHJpbmdDaGFyIiwiY2hyIiwiZ2V0VmFsdWUiLCJoYXNVbmljb2RlIiwidGVzdCIsImhhc1VuaWNvZGVXb3JkIiwiaXRlcmF0b3JUb0FycmF5IiwiaXRlcmF0b3IiLCJkYXRhIiwibmV4dCIsImRvbmUiLCJwdXNoIiwibWFwVG9BcnJheSIsIm1hcCIsInNpemUiLCJmb3JFYWNoIiwib3ZlckFyZyIsInRyYW5zZm9ybSIsImFyZyIsInJlcGxhY2VIb2xkZXJzIiwic2V0VG9BcnJheSIsInNldCIsInNldFRvUGFpcnMiLCJzdHJpY3RMYXN0SW5kZXhPZiIsInN0cmluZ1NpemUiLCJ1bmljb2RlU2l6ZSIsInN0cmluZ1RvQXJyYXkiLCJ1bmljb2RlVG9BcnJheSIsImNoYXJBdCIsInVuZXNjYXBlSHRtbENoYXIiLCJsYXN0SW5kZXgiLCJ1bmljb2RlV29yZHMiLCJydW5JbkNvbnRleHQiLCJydW5JbkNvbnRleHQyIiwiY29udGV4dCIsIl8iLCJkZWZhdWx0cyIsInBpY2siLCJBcnJheTIiLCJEYXRlMiIsIkRhdGUiLCJFcnJvcjIiLCJFcnJvciIsIkZ1bmN0aW9uMiIsIk1hdGgyIiwiTWF0aCIsIk9iamVjdDIiLCJSZWdFeHAyIiwiU3RyaW5nMiIsIlN0cmluZyIsIlR5cGVFcnJvcjIiLCJUeXBlRXJyb3IiLCJhcnJheVByb3RvIiwiZnVuY1Byb3RvIiwib2JqZWN0UHJvdG8iLCJjb3JlSnNEYXRhIiwiZnVuY1RvU3RyaW5nIiwidG9TdHJpbmciLCJpZENvdW50ZXIiLCJtYXNrU3JjS2V5IiwidWlkIiwiZXhlYyIsImtleXMiLCJJRV9QUk9UTyIsIm5hdGl2ZU9iamVjdFRvU3RyaW5nIiwib2JqZWN0Q3RvclN0cmluZyIsIm9sZERhc2giLCJyZUlzTmF0aXZlIiwiQnVmZmVyMiIsIkJ1ZmZlciIsIlN5bWJvbDIiLCJTeW1ib2wiLCJVaW50OEFycmF5MiIsIlVpbnQ4QXJyYXkiLCJhbGxvY1Vuc2FmZSIsImdldFByb3RvdHlwZSIsIm9iamVjdENyZWF0ZSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwic3BsaWNlIiwic3ByZWFkYWJsZVN5bWJvbCIsImlzQ29uY2F0U3ByZWFkYWJsZSIsInN5bUl0ZXJhdG9yIiwic3ltVG9TdHJpbmdUYWciLCJ0b1N0cmluZ1RhZyIsImdldE5hdGl2ZSIsImN0eENsZWFyVGltZW91dCIsImNsZWFyVGltZW91dCIsImN0eE5vdyIsIm5vdyIsImN0eFNldFRpbWVvdXQiLCJzZXRUaW1lb3V0IiwibmF0aXZlQ2VpbCIsImNlaWwiLCJuYXRpdmVGbG9vciIsImZsb29yIiwibmF0aXZlR2V0U3ltYm9scyIsImdldE93blByb3BlcnR5U3ltYm9scyIsIm5hdGl2ZUlzQnVmZmVyIiwiaXNCdWZmZXIiLCJuYXRpdmVJc0Zpbml0ZSIsImlzRmluaXRlIiwibmF0aXZlSm9pbiIsIm5hdGl2ZUtleXMiLCJuYXRpdmVNYXgiLCJtYXgiLCJuYXRpdmVNaW4iLCJtaW4iLCJuYXRpdmVOb3ciLCJuYXRpdmVQYXJzZUludCIsIm5hdGl2ZVJhbmRvbSIsInJhbmRvbSIsIm5hdGl2ZVJldmVyc2UiLCJyZXZlcnNlIiwiRGF0YVZpZXciLCJNYXAyIiwiUHJvbWlzZTIiLCJTZXQyIiwiV2Vha01hcDIiLCJuYXRpdmVDcmVhdGUiLCJtZXRhTWFwIiwicmVhbE5hbWVzIiwiZGF0YVZpZXdDdG9yU3RyaW5nIiwidG9Tb3VyY2UiLCJtYXBDdG9yU3RyaW5nIiwicHJvbWlzZUN0b3JTdHJpbmciLCJzZXRDdG9yU3RyaW5nIiwid2Vha01hcEN0b3JTdHJpbmciLCJzeW1ib2xQcm90byIsInN5bWJvbFZhbHVlT2YiLCJ2YWx1ZU9mIiwic3ltYm9sVG9TdHJpbmciLCJsb2Rhc2giLCJpc09iamVjdExpa2UiLCJpc0FycmF5IiwiTGF6eVdyYXBwZXIiLCJMb2Rhc2hXcmFwcGVyIiwid3JhcHBlckNsb25lIiwiYmFzZUNyZWF0ZSIsInByb3RvIiwiaXNPYmplY3QiLCJyZXN1bHQyIiwiYmFzZUxvZGFzaCIsImNoYWluQWxsIiwiX193cmFwcGVkX18iLCJfX2FjdGlvbnNfXyIsIl9fY2hhaW5fXyIsIl9faW5kZXhfXyIsIl9fdmFsdWVzX18iLCJ0ZW1wbGF0ZVNldHRpbmdzIiwiY29uc3RydWN0b3IiLCJfX2Rpcl9fIiwiX19maWx0ZXJlZF9fIiwiX19pdGVyYXRlZXNfXyIsIl9fdGFrZUNvdW50X18iLCJfX3ZpZXdzX18iLCJsYXp5Q2xvbmUiLCJjb3B5QXJyYXkiLCJsYXp5UmV2ZXJzZSIsImNsb25lIiwibGF6eVZhbHVlIiwiZGlyIiwiaXNBcnIiLCJpc1JpZ2h0IiwiYXJyTGVuZ3RoIiwidmlldyIsImdldFZpZXciLCJzdGFydCIsImVuZCIsIml0ZXJhdGVlcyIsIml0ZXJMZW5ndGgiLCJ0YWtlQ291bnQiLCJiYXNlV3JhcHBlclZhbHVlIiwib3V0ZXIiLCJpdGVySW5kZXgiLCJpdGVyYXRlZTIiLCJ0eXBlIiwiY29tcHV0ZWQiLCJIYXNoIiwiZW50cmllcyIsImNsZWFyIiwiZW50cnkiLCJoYXNoQ2xlYXIiLCJfX2RhdGFfXyIsImhhc2hEZWxldGUiLCJoYXNoR2V0IiwiaGFzaEhhcyIsImhhc2hTZXQiLCJMaXN0Q2FjaGUiLCJsaXN0Q2FjaGVDbGVhciIsImxpc3RDYWNoZURlbGV0ZSIsImFzc29jSW5kZXhPZiIsInBvcCIsImxpc3RDYWNoZUdldCIsImxpc3RDYWNoZUhhcyIsImxpc3RDYWNoZVNldCIsIk1hcENhY2hlIiwibWFwQ2FjaGVDbGVhciIsIm1hcENhY2hlRGVsZXRlIiwiZ2V0TWFwRGF0YSIsIm1hcENhY2hlR2V0IiwibWFwQ2FjaGVIYXMiLCJtYXBDYWNoZVNldCIsInNpemUyIiwiU2V0Q2FjaGUiLCJ2YWx1ZXMyIiwiYWRkIiwic2V0Q2FjaGVBZGQiLCJzZXRDYWNoZUhhcyIsIlN0YWNrIiwic3RhY2tDbGVhciIsInN0YWNrRGVsZXRlIiwic3RhY2tHZXQiLCJzdGFja0hhcyIsInN0YWNrU2V0IiwicGFpcnMiLCJhcnJheUxpa2VLZXlzIiwiaW5oZXJpdGVkIiwiaXNBcmciLCJpc0FyZ3VtZW50cyIsImlzQnVmZiIsImlzVHlwZSIsInNraXBJbmRleGVzIiwiaXNJbmRleCIsImFycmF5U2FtcGxlIiwiYmFzZVJhbmRvbSIsImFycmF5U2FtcGxlU2l6ZSIsInNodWZmbGVTZWxmIiwiYmFzZUNsYW1wIiwiYXJyYXlTaHVmZmxlIiwiYXNzaWduTWVyZ2VWYWx1ZSIsImVxIiwiYmFzZUFzc2lnblZhbHVlIiwiYXNzaWduVmFsdWUiLCJvYmpWYWx1ZSIsImJhc2VBZ2dyZWdhdG9yIiwiYmFzZUVhY2giLCJiYXNlQXNzaWduIiwiY29weU9iamVjdCIsImJhc2VBc3NpZ25JbiIsImtleXNJbiIsImJhc2VBdCIsInBhdGhzIiwic2tpcCIsIm51bWJlciIsImxvd2VyIiwidXBwZXIiLCJiYXNlQ2xvbmUiLCJiaXRtYXNrIiwiY3VzdG9taXplciIsInN0YWNrIiwiaXNEZWVwIiwiaXNGbGF0IiwiaXNGdWxsIiwiaW5pdENsb25lQXJyYXkiLCJ0YWciLCJnZXRUYWciLCJpc0Z1bmMiLCJjbG9uZUJ1ZmZlciIsImluaXRDbG9uZU9iamVjdCIsImNvcHlTeW1ib2xzSW4iLCJjb3B5U3ltYm9scyIsImluaXRDbG9uZUJ5VGFnIiwic3RhY2tlZCIsInN1YlZhbHVlIiwia2V5MiIsImtleXNGdW5jIiwiZ2V0QWxsS2V5c0luIiwiZ2V0QWxsS2V5cyIsImJhc2VDb25mb3JtcyIsImJhc2VDb25mb3Jtc1RvIiwiYmFzZURlbGF5Iiwid2FpdCIsImJhc2VEaWZmZXJlbmNlIiwiaW5jbHVkZXMyIiwiaXNDb21tb24iLCJ2YWx1ZXNMZW5ndGgiLCJ2YWx1ZXNJbmRleCIsImNyZWF0ZUJhc2VFYWNoIiwiYmFzZUZvck93biIsImJhc2VFYWNoUmlnaHQiLCJiYXNlRm9yT3duUmlnaHQiLCJiYXNlRXZlcnkiLCJiYXNlRXh0cmVtdW0iLCJpc1N5bWJvbCIsImJhc2VGaWxsIiwidG9JbnRlZ2VyIiwidG9MZW5ndGgiLCJiYXNlRmlsdGVyIiwiYmFzZUZsYXR0ZW4iLCJkZXB0aCIsImlzU3RyaWN0IiwiaXNGbGF0dGVuYWJsZSIsImJhc2VGb3IiLCJjcmVhdGVCYXNlRm9yIiwiYmFzZUZvclJpZ2h0IiwiYmFzZUZ1bmN0aW9ucyIsImlzRnVuY3Rpb24iLCJiYXNlR2V0IiwicGF0aCIsImNhc3RQYXRoIiwidG9LZXkiLCJiYXNlR2V0QWxsS2V5cyIsInN5bWJvbHNGdW5jIiwiYmFzZUdldFRhZyIsImdldFJhd1RhZyIsIm9iamVjdFRvU3RyaW5nIiwiYmFzZUd0Iiwib3RoZXIiLCJiYXNlSGFzIiwiYmFzZUhhc0luIiwiYmFzZUluUmFuZ2UiLCJiYXNlSW50ZXJzZWN0aW9uIiwiYXJyYXlzIiwib3RoTGVuZ3RoIiwib3RoSW5kZXgiLCJjYWNoZXMiLCJtYXhMZW5ndGgiLCJJbmZpbml0eSIsInNlZW4iLCJiYXNlSW52ZXJ0ZXIiLCJvYmplY3QyIiwiYmFzZUludm9rZSIsInBhcmVudCIsImxhc3QiLCJiYXNlSXNBcmd1bWVudHMiLCJiYXNlSXNBcnJheUJ1ZmZlciIsImJhc2VJc0RhdGUiLCJiYXNlSXNFcXVhbCIsImJhc2VJc0VxdWFsRGVlcCIsImVxdWFsRnVuYyIsIm9iaklzQXJyIiwib3RoSXNBcnIiLCJvYmpUYWciLCJvdGhUYWciLCJvYmpJc09iaiIsIm90aElzT2JqIiwiaXNTYW1lVGFnIiwiZXF1YWxBcnJheXMiLCJlcXVhbEJ5VGFnIiwib2JqSXNXcmFwcGVkIiwib3RoSXNXcmFwcGVkIiwib2JqVW53cmFwcGVkIiwib3RoVW53cmFwcGVkIiwiZXF1YWxPYmplY3RzIiwiYmFzZUlzTWFwIiwiYmFzZUlzTWF0Y2giLCJtYXRjaERhdGEiLCJub0N1c3RvbWl6ZXIiLCJzcmNWYWx1ZSIsImJhc2VJc05hdGl2ZSIsImlzTWFza2VkIiwicGF0dGVybiIsImJhc2VJc1JlZ0V4cCIsImJhc2VJc1NldCIsImJhc2VJc1R5cGVkQXJyYXkiLCJpc0xlbmd0aCIsImJhc2VJdGVyYXRlZSIsImlkZW50aXR5IiwiYmFzZU1hdGNoZXNQcm9wZXJ0eSIsImJhc2VNYXRjaGVzIiwicHJvcGVydHkiLCJiYXNlS2V5cyIsImlzUHJvdG90eXBlIiwiYmFzZUtleXNJbiIsIm5hdGl2ZUtleXNJbiIsImlzUHJvdG8iLCJiYXNlTHQiLCJiYXNlTWFwIiwiaXNBcnJheUxpa2UiLCJnZXRNYXRjaERhdGEiLCJtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSIsImlzS2V5IiwiaXNTdHJpY3RDb21wYXJhYmxlIiwiaGFzSW4iLCJiYXNlTWVyZ2UiLCJzcmNJbmRleCIsImJhc2VNZXJnZURlZXAiLCJuZXdWYWx1ZSIsInNhZmVHZXQiLCJtZXJnZUZ1bmMiLCJpc1R5cGVkIiwiaXNBcnJheUxpa2VPYmplY3QiLCJjbG9uZVR5cGVkQXJyYXkiLCJpc1BsYWluT2JqZWN0IiwidG9QbGFpbk9iamVjdCIsImJhc2VOdGgiLCJiYXNlT3JkZXJCeSIsIm9yZGVycyIsImdldEl0ZXJhdGVlIiwiY3JpdGVyaWEiLCJjb21wYXJlTXVsdGlwbGUiLCJiYXNlUGljayIsImJhc2VQaWNrQnkiLCJiYXNlU2V0IiwiYmFzZVByb3BlcnR5RGVlcCIsImJhc2VQdWxsQWxsIiwiaW5kZXhPZjIiLCJiYXNlUHVsbEF0IiwiaW5kZXhlcyIsInByZXZpb3VzIiwiYmFzZVVuc2V0IiwiYmFzZVJhbmdlIiwic3RlcCIsImJhc2VSZXBlYXQiLCJiYXNlUmVzdCIsInNldFRvU3RyaW5nIiwib3ZlclJlc3QiLCJiYXNlU2FtcGxlIiwiYmFzZVNhbXBsZVNpemUiLCJuZXN0ZWQiLCJiYXNlU2V0RGF0YSIsImJhc2VTZXRUb1N0cmluZyIsImNvbnN0YW50IiwiYmFzZVNodWZmbGUiLCJiYXNlU2xpY2UiLCJiYXNlU29tZSIsImJhc2VTb3J0ZWRJbmRleCIsInJldEhpZ2hlc3QiLCJsb3ciLCJoaWdoIiwibWlkIiwiYmFzZVNvcnRlZEluZGV4QnkiLCJ2YWxJc05hTiIsInZhbElzTnVsbCIsInZhbElzU3ltYm9sIiwidmFsSXNVbmRlZmluZWQiLCJvdGhJc0RlZmluZWQiLCJvdGhJc051bGwiLCJvdGhJc1JlZmxleGl2ZSIsIm90aElzU3ltYm9sIiwic2V0TG93IiwiYmFzZVNvcnRlZFVuaXEiLCJiYXNlVG9OdW1iZXIiLCJiYXNlVG9TdHJpbmciLCJiYXNlVW5pcSIsInNldDIiLCJjcmVhdGVTZXQiLCJzZWVuSW5kZXgiLCJiYXNlVXBkYXRlIiwidXBkYXRlciIsImJhc2VXaGlsZSIsImlzRHJvcCIsImFjdGlvbnMiLCJyZXN1bHQzIiwiYWN0aW9uIiwiYmFzZVhvciIsImJhc2VaaXBPYmplY3QiLCJhc3NpZ25GdW5jIiwidmFsc0xlbmd0aCIsImNhc3RBcnJheUxpa2VPYmplY3QiLCJjYXN0RnVuY3Rpb24iLCJzdHJpbmdUb1BhdGgiLCJjYXN0UmVzdCIsImNhc3RTbGljZSIsImlkIiwiYnVmZmVyIiwiY29weSIsImNsb25lQXJyYXlCdWZmZXIiLCJhcnJheUJ1ZmZlciIsImJ5dGVMZW5ndGgiLCJjbG9uZURhdGFWaWV3IiwiZGF0YVZpZXciLCJieXRlT2Zmc2V0IiwiY2xvbmVSZWdFeHAiLCJyZWdleHAiLCJjbG9uZVN5bWJvbCIsInN5bWJvbCIsInR5cGVkQXJyYXkiLCJjb21wYXJlQXNjZW5kaW5nIiwidmFsSXNEZWZpbmVkIiwidmFsSXNSZWZsZXhpdmUiLCJvYmpDcml0ZXJpYSIsIm90aENyaXRlcmlhIiwib3JkZXJzTGVuZ3RoIiwib3JkZXIiLCJjb21wb3NlQXJncyIsInBhcnRpYWxzIiwiaG9sZGVycyIsImlzQ3VycmllZCIsImFyZ3NJbmRleCIsImFyZ3NMZW5ndGgiLCJob2xkZXJzTGVuZ3RoIiwibGVmdEluZGV4IiwibGVmdExlbmd0aCIsInJhbmdlTGVuZ3RoIiwiaXNVbmN1cnJpZWQiLCJjb21wb3NlQXJnc1JpZ2h0IiwiaG9sZGVyc0luZGV4IiwicmlnaHRJbmRleCIsInJpZ2h0TGVuZ3RoIiwiaXNOZXciLCJnZXRTeW1ib2xzIiwiZ2V0U3ltYm9sc0luIiwiY3JlYXRlQWdncmVnYXRvciIsImluaXRpYWxpemVyIiwiY3JlYXRlQXNzaWduZXIiLCJhc3NpZ25lciIsInNvdXJjZXMiLCJndWFyZCIsImlzSXRlcmF0ZWVDYWxsIiwiaXRlcmFibGUiLCJjcmVhdGVCaW5kIiwiaXNCaW5kIiwiQ3RvciIsImNyZWF0ZUN0b3IiLCJ3cmFwcGVyIiwiZm4iLCJhcmd1bWVudHMiLCJjcmVhdGVDYXNlRmlyc3QiLCJtZXRob2ROYW1lIiwidHJhaWxpbmciLCJjcmVhdGVDb21wb3VuZGVyIiwiY2FsbGJhY2siLCJ3b3JkcyIsImRlYnVyciIsInRoaXNCaW5kaW5nIiwiY3JlYXRlQ3VycnkiLCJhcml0eSIsImdldEhvbGRlciIsImNyZWF0ZVJlY3VycnkiLCJjcmVhdGVIeWJyaWQiLCJjcmVhdGVGaW5kIiwiZmluZEluZGV4RnVuYyIsImNyZWF0ZUZsb3ciLCJmbGF0UmVzdCIsImZ1bmNzIiwicHJlcmVxIiwidGhydSIsImdldEZ1bmNOYW1lIiwiZnVuY05hbWUiLCJnZXREYXRhIiwiaXNMYXppYWJsZSIsInBsYW50IiwiaW5kZXgyIiwicGFydGlhbHNSaWdodCIsImhvbGRlcnNSaWdodCIsImFyZ1BvcyIsImFyeTIiLCJpc0FyeSIsImlzQmluZEtleSIsImlzRmxpcCIsImhvbGRlcnNDb3VudCIsIm5ld0hvbGRlcnMiLCJyZW9yZGVyIiwiY3JlYXRlSW52ZXJ0ZXIiLCJ0b0l0ZXJhdGVlIiwiY3JlYXRlTWF0aE9wZXJhdGlvbiIsIm9wZXJhdG9yIiwiZGVmYXVsdFZhbHVlIiwiY3JlYXRlT3ZlciIsImFycmF5RnVuYyIsImNyZWF0ZVBhZGRpbmciLCJjaGFycyIsImNoYXJzTGVuZ3RoIiwiY3JlYXRlUGFydGlhbCIsImNyZWF0ZVJhbmdlIiwidG9GaW5pdGUiLCJjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uIiwidG9OdW1iZXIiLCJ3cmFwRnVuYyIsImlzQ3VycnkiLCJuZXdIb2xkZXJzUmlnaHQiLCJuZXdQYXJ0aWFscyIsIm5ld1BhcnRpYWxzUmlnaHQiLCJuZXdEYXRhIiwic2V0RGF0YSIsInNldFdyYXBUb1N0cmluZyIsImNyZWF0ZVJvdW5kIiwicHJlY2lzaW9uIiwicGFpciIsIm5vb3AiLCJjcmVhdGVUb1BhaXJzIiwiY3JlYXRlV3JhcCIsIm1lcmdlRGF0YSIsImN1c3RvbURlZmF1bHRzQXNzaWduSW4iLCJjdXN0b21EZWZhdWx0c01lcmdlIiwiY3VzdG9tT21pdENsb25lIiwiaXNQYXJ0aWFsIiwiYXJyU3RhY2tlZCIsIm90aFN0YWNrZWQiLCJhcnJWYWx1ZSIsIm90aFZhbHVlIiwiY29tcGFyZWQiLCJvdGhWYWx1ZTIiLCJuYW1lIiwibWVzc2FnZSIsImNvbnZlcnQiLCJvYmpQcm9wcyIsIm9iakxlbmd0aCIsIm90aFByb3BzIiwib2JqU3RhY2tlZCIsInNraXBDdG9yIiwib2JqQ3RvciIsIm90aEN0b3IiLCJmbGF0dGVuIiwib3RoZXJGdW5jIiwibWFwMiIsImlzS2V5YWJsZSIsImlzT3duIiwidW5tYXNrZWQiLCJzdHViQXJyYXkiLCJBcnJheUJ1ZmZlciIsInJlc29sdmUiLCJjdG9yU3RyaW5nIiwidHJhbnNmb3JtcyIsImdldFdyYXBEZXRhaWxzIiwiaGFzUGF0aCIsImhhc0Z1bmMiLCJpbnB1dCIsImluc2VydFdyYXBEZXRhaWxzIiwiZGV0YWlscyIsImlzTWFza2FibGUiLCJzdHViRmFsc2UiLCJtZW1vaXplQ2FwcGVkIiwibWVtb2l6ZTIiLCJzcmNCaXRtYXNrIiwibmV3Qml0bWFzayIsImlzQ29tYm8iLCJ0cmFuc2Zvcm0yIiwib3RoZXJBcmdzIiwib2xkQXJyYXkiLCJzaG9ydE91dCIsInJlZmVyZW5jZSIsInVwZGF0ZVdyYXBEZXRhaWxzIiwiY291bnQiLCJsYXN0Q2FsbGVkIiwic3RhbXAiLCJyZW1haW5pbmciLCJyYW5kIiwiY2hhckNvZGVBdCIsInF1b3RlIiwic3ViU3RyaW5nIiwiY2h1bmsiLCJjb21wYWN0IiwiY29uY2F0IiwiZGlmZmVyZW5jZSIsImRpZmZlcmVuY2VCeSIsImRpZmZlcmVuY2VXaXRoIiwiZHJvcCIsImRyb3BSaWdodCIsImRyb3BSaWdodFdoaWxlIiwiZHJvcFdoaWxlIiwiZmlsbCIsImZpbmRJbmRleCIsImZpbmRMYXN0SW5kZXgiLCJmbGF0dGVuRGVlcCIsImZsYXR0ZW5EZXB0aCIsImZyb21QYWlycyIsImhlYWQiLCJpbmRleE9mIiwiaW5pdGlhbCIsImludGVyc2VjdGlvbiIsIm1hcHBlZCIsImludGVyc2VjdGlvbkJ5IiwiaW50ZXJzZWN0aW9uV2l0aCIsInNlcGFyYXRvciIsImxhc3RJbmRleE9mIiwibnRoIiwicHVsbCIsInB1bGxBbGwiLCJwdWxsQWxsQnkiLCJwdWxsQWxsV2l0aCIsInB1bGxBdCIsInJlbW92ZSIsInNvcnRlZEluZGV4Iiwic29ydGVkSW5kZXhCeSIsInNvcnRlZEluZGV4T2YiLCJzb3J0ZWRMYXN0SW5kZXgiLCJzb3J0ZWRMYXN0SW5kZXhCeSIsInNvcnRlZExhc3RJbmRleE9mIiwic29ydGVkVW5pcSIsInNvcnRlZFVuaXFCeSIsInRhaWwiLCJ0YWtlIiwidGFrZVJpZ2h0IiwidGFrZVJpZ2h0V2hpbGUiLCJ0YWtlV2hpbGUiLCJ1bmlvbiIsInVuaW9uQnkiLCJ1bmlvbldpdGgiLCJ1bmlxIiwidW5pcUJ5IiwidW5pcVdpdGgiLCJ1bnppcCIsImdyb3VwIiwidW56aXBXaXRoIiwid2l0aG91dCIsInhvciIsInhvckJ5IiwieG9yV2l0aCIsInppcCIsInppcE9iamVjdCIsInppcE9iamVjdERlZXAiLCJ6aXBXaXRoIiwiY2hhaW4iLCJ0YXAiLCJpbnRlcmNlcHRvciIsIndyYXBwZXJBdCIsIndyYXBwZXJDaGFpbiIsIndyYXBwZXJDb21taXQiLCJ3cmFwcGVyTmV4dCIsInRvQXJyYXkiLCJ3cmFwcGVyVG9JdGVyYXRvciIsIndyYXBwZXJQbGFudCIsInBhcmVudDIiLCJjbG9uZTIiLCJ3cmFwcGVyUmV2ZXJzZSIsIndyYXBwZWQiLCJ3cmFwcGVyVmFsdWUiLCJjb3VudEJ5IiwiZXZlcnkiLCJmaWx0ZXIiLCJmaW5kIiwiZmluZExhc3QiLCJmbGF0TWFwIiwiZmxhdE1hcERlZXAiLCJmbGF0TWFwRGVwdGgiLCJmb3JFYWNoUmlnaHQiLCJncm91cEJ5IiwiaW5jbHVkZXMiLCJpc1N0cmluZyIsImludm9rZU1hcCIsImtleUJ5Iiwib3JkZXJCeSIsInBhcnRpdGlvbiIsInJlZHVjZSIsInJlZHVjZVJpZ2h0IiwicmVqZWN0IiwibmVnYXRlIiwic2FtcGxlIiwic2FtcGxlU2l6ZSIsInNodWZmbGUiLCJzb21lIiwic29ydEJ5IiwiYWZ0ZXIiLCJhcnkiLCJiZWZvcmUiLCJiaW5kIiwiYmluZEtleSIsImN1cnJ5IiwiY3VycnlSaWdodCIsImRlYm91bmNlIiwib3B0aW9ucyIsImxhc3RBcmdzIiwibGFzdFRoaXMiLCJtYXhXYWl0IiwidGltZXJJZCIsImxhc3RDYWxsVGltZSIsImxhc3RJbnZva2VUaW1lIiwibGVhZGluZyIsIm1heGluZyIsImludm9rZUZ1bmMiLCJ0aW1lIiwibGVhZGluZ0VkZ2UiLCJ0aW1lckV4cGlyZWQiLCJyZW1haW5pbmdXYWl0IiwidGltZVNpbmNlTGFzdENhbGwiLCJ0aW1lU2luY2VMYXN0SW52b2tlIiwidGltZVdhaXRpbmciLCJzaG91bGRJbnZva2UiLCJ0cmFpbGluZ0VkZ2UiLCJjYW5jZWwiLCJmbHVzaCIsImRlYm91bmNlZCIsImlzSW52b2tpbmciLCJkZWZlciIsImRlbGF5IiwiZmxpcCIsInJlc29sdmVyIiwibWVtb2l6ZWQiLCJDYWNoZSIsIm9uY2UiLCJvdmVyQXJncyIsImZ1bmNzTGVuZ3RoIiwicGFydGlhbCIsInBhcnRpYWxSaWdodCIsInJlYXJnIiwicmVzdCIsInNwcmVhZCIsInRocm90dGxlIiwidW5hcnkiLCJ3cmFwIiwiY2FzdEFycmF5IiwiY2xvbmVXaXRoIiwiY2xvbmVEZWVwIiwiY2xvbmVEZWVwV2l0aCIsImNvbmZvcm1zVG8iLCJndCIsImd0ZSIsImlzQm9vbGVhbiIsImlzRWxlbWVudCIsImlzRW1wdHkiLCJpc0VxdWFsIiwiaXNFcXVhbFdpdGgiLCJpc0Vycm9yIiwiaXNGaW5pdGUyIiwiaXNJbnRlZ2VyIiwiaXNNYXRjaCIsImlzTWF0Y2hXaXRoIiwiaXNOYU4yIiwiaXNOdW1iZXIiLCJpc05hdGl2ZSIsImlzTnVsbCIsImlzTmlsIiwiaXNTYWZlSW50ZWdlciIsImlzVW5kZWZpbmVkIiwiaXNXZWFrTWFwIiwiaXNXZWFrU2V0IiwibHQiLCJsdGUiLCJzaWduIiwicmVtYWluZGVyIiwiaXNCaW5hcnkiLCJ0b1NhZmVJbnRlZ2VyIiwiYXNzaWduIiwiYXNzaWduSW4iLCJhc3NpZ25JbldpdGgiLCJhc3NpZ25XaXRoIiwiYXQiLCJwcm9wZXJ0aWVzIiwicHJvcHNJbmRleCIsInByb3BzTGVuZ3RoIiwiZGVmYXVsdHNEZWVwIiwibWVyZ2VXaXRoIiwiZmluZEtleSIsImZpbmRMYXN0S2V5IiwiZm9ySW4iLCJmb3JJblJpZ2h0IiwiZm9yT3duIiwiZm9yT3duUmlnaHQiLCJmdW5jdGlvbnMiLCJmdW5jdGlvbnNJbiIsImludmVydCIsImludmVydEJ5IiwiaW52b2tlIiwibWFwS2V5cyIsIm1hcFZhbHVlcyIsIm1lcmdlIiwib21pdCIsIm9taXRCeSIsInBpY2tCeSIsInByb3AiLCJzZXRXaXRoIiwidG9QYWlycyIsInRvUGFpcnNJbiIsImlzQXJyTGlrZSIsInVuc2V0IiwidXBkYXRlIiwidXBkYXRlV2l0aCIsInZhbHVlc0luIiwiY2xhbXAiLCJpblJhbmdlIiwiZmxvYXRpbmciLCJ0ZW1wIiwiY2FtZWxDYXNlIiwid29yZCIsInRvTG93ZXJDYXNlIiwiY2FwaXRhbGl6ZSIsInVwcGVyRmlyc3QiLCJlbmRzV2l0aCIsInBvc2l0aW9uIiwiZXNjYXBlIiwiZXNjYXBlUmVnRXhwIiwia2ViYWJDYXNlIiwibG93ZXJDYXNlIiwibG93ZXJGaXJzdCIsInBhZCIsInN0ckxlbmd0aCIsInBhZEVuZCIsInBhZFN0YXJ0IiwicGFyc2VJbnQyIiwicmFkaXgiLCJyZXBlYXQiLCJzbmFrZUNhc2UiLCJsaW1pdCIsInN0YXJ0Q2FzZSIsInN0YXJ0c1dpdGgiLCJ0ZW1wbGF0ZSIsInNldHRpbmdzIiwiaW1wb3J0cyIsImltcG9ydHNLZXlzIiwiaW1wb3J0c1ZhbHVlcyIsImlzRXNjYXBpbmciLCJpc0V2YWx1YXRpbmciLCJpbnRlcnBvbGF0ZSIsInJlRGVsaW1pdGVycyIsImV2YWx1YXRlIiwic291cmNlVVJMIiwiZXNjYXBlVmFsdWUiLCJpbnRlcnBvbGF0ZVZhbHVlIiwiZXNUZW1wbGF0ZVZhbHVlIiwiZXZhbHVhdGVWYWx1ZSIsInZhcmlhYmxlIiwiYXR0ZW1wdCIsInRvTG93ZXIiLCJ0b1VwcGVyIiwidG9VcHBlckNhc2UiLCJ0cmltIiwidHJpbUVuZCIsInRyaW1TdGFydCIsInRydW5jYXRlIiwib21pc3Npb24iLCJzZWFyY2giLCJzdWJzdHJpbmciLCJuZXdFbmQiLCJ1bmVzY2FwZSIsInVwcGVyQ2FzZSIsImJpbmRBbGwiLCJtZXRob2ROYW1lcyIsImNvbmQiLCJjb25mb3JtcyIsImRlZmF1bHRUbyIsImZsb3ciLCJmbG93UmlnaHQiLCJtYXRjaGVzIiwibWF0Y2hlc1Byb3BlcnR5IiwibWV0aG9kIiwibWV0aG9kT2YiLCJtaXhpbiIsImNoYWluMiIsIm5vQ29uZmxpY3QiLCJudGhBcmciLCJvdmVyIiwib3ZlckV2ZXJ5Iiwib3ZlclNvbWUiLCJwcm9wZXJ0eU9mIiwicmFuZ2UiLCJyYW5nZVJpZ2h0Iiwic3R1Yk9iamVjdCIsInN0dWJTdHJpbmciLCJzdHViVHJ1ZSIsInRpbWVzIiwidG9QYXRoIiwidW5pcXVlSWQiLCJwcmVmaXgiLCJhdWdlbmQiLCJhZGRlbmQiLCJkaXZpZGUiLCJkaXZpZGVuZCIsImRpdmlzb3IiLCJtYXhCeSIsIm1lYW4iLCJtZWFuQnkiLCJtaW5CeSIsIm11bHRpcGx5IiwibXVsdGlwbGllciIsIm11bHRpcGxpY2FuZCIsInJvdW5kIiwic3VidHJhY3QiLCJtaW51ZW5kIiwic3VidHJhaGVuZCIsInN1bSIsInN1bUJ5IiwibWVtb2l6ZSIsImVudHJpZXNJbiIsImV4dGVuZCIsImV4dGVuZFdpdGgiLCJpc05hTiIsImVhY2giLCJlYWNoUmlnaHQiLCJmaXJzdCIsImlzRmlsdGVyIiwidGFrZU5hbWUiLCJkcm9wTmFtZSIsImNoZWNrSXRlcmF0ZWUiLCJpc1Rha2VyIiwibG9kYXNoRnVuYyIsInJldFVud3JhcHBlZCIsImlzTGF6eSIsInVzZUxhenkiLCJ2YWx1ZTIiLCJpc0h5YnJpZCIsImlzVW53cmFwcGVkIiwib25seUxhenkiLCJjaGFpbk5hbWUiLCJjb21taXQiLCJ0b0pTT04iLCJkZWZpbmUiLCJhbWQiLCJyZXF1aXJlX2lvdGEiLCJpb3RhIiwiaSIsInJlcXVpcmVfaXNfYnVmZmVyIiwib2JqIiwiaXNTbG93QnVmZmVyIiwiX2lzQnVmZmVyIiwicmVhZEZsb2F0TEUiLCJyZXF1aXJlX25kYXJyYXkiLCJoYXNUeXBlZEFycmF5cyIsIkZsb2F0NjRBcnJheSIsImNvbXBhcmUxc3QiLCJhIiwiYiIsInN0cmlkZSIsInRlcm1zIiwiYWJzIiwiY29tcGlsZUNvbnN0cnVjdG9yIiwiZHR5cGUiLCJkaW1lbnNpb24iLCJjbGFzc05hbWUiLCJ1c2VHZXR0ZXJzIiwiY29kZSIsInByb2NlZHVyZSIsIkNBQ0hFRF9DT05TVFJVQ1RPUlMiLCJpbmRpY2VzIiwiaTIiLCJpbmRleF9zdHIiLCJzaGFwZUFyZyIsInN0cmlkZUFyZyIsImFfdmFycyIsImNfdmFycyIsInRTaGFwZSIsInRTdHJpZGUiLCJpZHgiLCJhcnJheURUeXBlIiwid3JhcHBlZE5EQXJyYXlDdG9yIiwic2hhcGUiLCJjdG9yIiwiZCIsInN6IiwiY3Rvcl9saXN0IiwiaW1wb3J0X2xvZGFzaCIsImltcG9ydF9uZGFycmF5MiIsIk1pbWVUeXBlIiwiX01pbWVUeXBlIiwicGFyYW1zIiwicGFyYW1zU3RyIiwiaXNJZGVudGljYWwiLCJmcm9tU3RyaW5nIiwibWltZVR5cGUiLCJwYXJhbXNBcnIiLCJwYXJhbSIsImltcG9ydF9uZGFycmF5IiwiaW1hZ2VEZWNvZGUiLCJibG9iIiwibWltZSIsIndpZHRoIiwiaGVpZ2h0IiwiZGVmYXVsdCIsImltYWdlQml0bWFwIiwiY3JlYXRlSW1hZ2VCaXRtYXAiLCJpbWFnZURhdGEiLCJpbWFnZUJpdG1hcFRvSW1hZ2VEYXRhIiwiaW1hZ2VFbmNvZGUiLCJpbWFnZVRlbnNvciIsInF1YWxpdHkiLCJmb3JtYXQiLCJjaGFubmVscyIsIkJsb2IiLCJJbWFnZURhdGEiLCJVaW50OENsYW1wZWRBcnJheSIsImNhbnZhcyIsImNyZWF0ZUNhbnZhcyIsImN0eCIsImdldENvbnRleHQiLCJwdXRJbWFnZURhdGEiLCJjb252ZXJ0VG9CbG9iIiwiaXNBYnNvbHV0ZVVSSSIsInVybCIsInJlZ0V4cCIsImVuc3VyZUFic29sdXRlVVJJIiwiYmFzZVVybCIsIlVSTCIsImhyZWYiLCJkcmF3SW1hZ2UiLCJnZXRJbWFnZURhdGEiLCJjcmVhdGVUeXBlQXJyYXkiLCJVaW50MTZBcnJheSIsIlVpbnQzMkFycmF5IiwiRmxvYXQzMkFycmF5IiwidGVuc29yUmVzaXplQmlsaW5lYXIiLCJuZXdXaWR0aCIsIm5ld0hlaWdodCIsInByb3BvcnRpb25hbCIsInNyY0hlaWdodCIsInNyY1dpZHRoIiwic3JjQ2hhbm5lbHMiLCJzY2FsZVgiLCJzY2FsZVkiLCJkb3duc2NhbGluZyIsInJlc2l6ZWRJbWFnZURhdGEiLCJ5IiwieCIsInNyY1giLCJzcmNZIiwieDEiLCJ4MiIsInkxIiwieTIiLCJkeCIsImR5IiwiYyIsInAxIiwicDIiLCJwMyIsInA0IiwiaW50ZXJwb2xhdGVkVmFsdWUiLCJ0ZW5zb3JIV0N0b0JDSFciLCJzdGQiLCJpbWFnZUJ1ZmZlckRhdGEiLCJmbG9hdDMyRGF0YSIsImoiLCJpbWFnZVNvdXJjZVRvSW1hZ2VEYXRhIiwiaW1hZ2UiLCJjb25maWciLCJwdWJsaWNQYXRoIiwicmVzcG9uc2UiLCJmZXRjaCIsImlzVmlldyIsImNvbnZlcnRGbG9hdDMyVG9VaW50OCIsImZsb2F0MzJBcnJheSIsInVpbnQ4QXJyYXkiLCJPZmZzY3JlZW5DYW52YXMiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJpbXBvcnRfbmRhcnJheTMiLCJ3ZWJncHUiLCJuYXZpZ2F0b3IiLCJncHUiLCJhZGFwdGVyIiwicmVxdWVzdEFkYXB0ZXIiLCJtYXhOdW1UaHJlYWRzIiwiaGFyZHdhcmVDb25jdXJyZW5jeSIsImxvYWRBc1VybCIsImNyZWF0ZU9iamVjdFVSTCIsImxvYWRBc0Jsb2IiLCJyZXNvdXJjZVVybCIsInJlc291cmNlUmVzcG9uc2UiLCJvayIsInJlc291cmNlTWFwIiwianNvbiIsImNodW5rcyIsImRvd25sb2FkZWRTaXplIiwicmVzcG9uc2VzIiwiY2h1bmtTaXplIiwib2Zmc2V0cyIsImZldGNoQXJncyIsInByb2dyZXNzIiwiYWxsQ2h1bmtEYXRhIiwiUHJvbWlzZSIsImFsbCIsIm9ydCIsImdldE9ydCIsInVzZVdlYkdQVSIsImNyZWF0ZU9ubnhTZXNzaW9uIiwibW9kZWwiLCJkZXZpY2UiLCJwcm94eVRvV29ya2VyIiwiZXhlY3V0aW9uUHJvdmlkZXJzIiwib3J0MiIsImRlYnVnIiwiY29uc29sZSIsImVudiIsImxvZ0xldmVsIiwid2FzbSIsIm51bVRocmVhZHMiLCJwcm94eSIsImJhc2VGaWxlUGF0aCIsIndhc21QYXRoIiwibWpzUGF0aCIsIndhc21QYXRocyIsIm1qcyIsIm9ydENvbmZpZyIsImdyYXBoT3B0aW1pemF0aW9uTGV2ZWwiLCJleGVjdXRpb25Nb2RlIiwiZW5hYmxlQ3B1TWVtQXJlbmEiLCJzZXNzaW9uIiwiSW5mZXJlbmNlU2Vzc2lvbiIsImNhdGNoIiwicnVuT25ueFNlc3Npb24iLCJpbnB1dHMiLCJvdXRwdXRzIiwiZmVlZHMiLCJ0ZW5zb3IiLCJUZW5zb3IiLCJvdXRwdXREYXRhIiwicnVuIiwib3V0cHV0S1ZQYWlycyIsIm91dHB1dCIsImRpbXMiLCJ1dGlsIiwidXRpbDIiLCJhc3NlcnRFcXVhbCIsInZhbCIsImFzc2VydElzIiwiX2FyZyIsImFzc2VydE5ldmVyIiwiX3giLCJhcnJheVRvRW51bSIsIml0ZW1zIiwiaXRlbSIsImdldFZhbGlkRW51bVZhbHVlcyIsInZhbGlkS2V5cyIsIm9iamVjdEtleXMiLCJrIiwiZmlsdGVyZWQiLCJvYmplY3RWYWx1ZXMiLCJhcnIiLCJjaGVja2VyIiwiTnVtYmVyIiwiam9pblZhbHVlcyIsImpzb25TdHJpbmdpZnlSZXBsYWNlciIsIm9iamVjdFV0aWwiLCJvYmplY3RVdGlsMiIsIm1lcmdlU2hhcGVzIiwic2Vjb25kIiwiWm9kUGFyc2VkVHlwZSIsImdldFBhcnNlZFR5cGUiLCJ0IiwidW5kZWZpbmVkIiwibmFuIiwiYm9vbGVhbiIsImZ1bmN0aW9uIiwiYmlnaW50IiwibnVsbCIsInRoZW4iLCJwcm9taXNlIiwiTWFwIiwiU2V0IiwiZGF0ZSIsInVua25vd24iLCJab2RJc3N1ZUNvZGUiLCJxdW90ZWxlc3NKc29uIiwiSlNPTiIsInN0cmluZ2lmeSIsIlpvZEVycm9yIiwiX1pvZEVycm9yIiwiaXNzdWVzIiwiYWRkSXNzdWUiLCJzdWIiLCJhZGRJc3N1ZXMiLCJzdWJzIiwiYWN0dWFsUHJvdG8iLCJzZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsImVycm9ycyIsIl9tYXBwZXIiLCJtYXBwZXIiLCJpc3N1ZSIsImZpZWxkRXJyb3JzIiwiX2Vycm9ycyIsInByb2Nlc3NFcnJvciIsImVycm9yIiwidW5pb25FcnJvcnMiLCJyZXR1cm5UeXBlRXJyb3IiLCJhcmd1bWVudHNFcnJvciIsImN1cnIiLCJlbCIsInRlcm1pbmFsIiwiYXNzZXJ0IiwiZm9ybUVycm9ycyIsImVycm9yTWFwIiwiX2N0eCIsImludmFsaWRfdHlwZSIsInJlY2VpdmVkIiwiZXhwZWN0ZWQiLCJpbnZhbGlkX2xpdGVyYWwiLCJ1bnJlY29nbml6ZWRfa2V5cyIsImludmFsaWRfdW5pb24iLCJpbnZhbGlkX3VuaW9uX2Rpc2NyaW1pbmF0b3IiLCJpbnZhbGlkX2VudW1fdmFsdWUiLCJpbnZhbGlkX2FyZ3VtZW50cyIsImludmFsaWRfcmV0dXJuX3R5cGUiLCJpbnZhbGlkX2RhdGUiLCJpbnZhbGlkX3N0cmluZyIsInZhbGlkYXRpb24iLCJ0b29fc21hbGwiLCJleGFjdCIsImluY2x1c2l2ZSIsIm1pbmltdW0iLCJ0b29fYmlnIiwibWF4aW11bSIsImN1c3RvbSIsImludmFsaWRfaW50ZXJzZWN0aW9uX3R5cGVzIiwibm90X211bHRpcGxlX29mIiwibXVsdGlwbGVPZiIsIm5vdF9maW5pdGUiLCJkZWZhdWx0RXJyb3IiLCJvdmVycmlkZUVycm9yTWFwIiwic2V0RXJyb3JNYXAiLCJnZXRFcnJvck1hcCIsIm1ha2VJc3N1ZSIsImVycm9yTWFwcyIsImlzc3VlRGF0YSIsImZ1bGxQYXRoIiwiZnVsbElzc3VlIiwiZXJyb3JNZXNzYWdlIiwibWFwcyIsIm0iLCJFTVBUWV9QQVRIIiwiYWRkSXNzdWVUb0NvbnRleHQiLCJvdmVycmlkZU1hcCIsImNvbW1vbiIsImNvbnRleHR1YWxFcnJvck1hcCIsInNjaGVtYUVycm9yTWFwIiwiUGFyc2VTdGF0dXMiLCJfUGFyc2VTdGF0dXMiLCJkaXJ0eSIsImFib3J0IiwibWVyZ2VBcnJheSIsInN0YXR1cyIsInJlc3VsdHMiLCJhcnJheVZhbHVlIiwicyIsIklOVkFMSUQiLCJtZXJnZU9iamVjdEFzeW5jIiwic3luY1BhaXJzIiwibWVyZ2VPYmplY3RTeW5jIiwiZmluYWxPYmplY3QiLCJhbHdheXNTZXQiLCJmcmVlemUiLCJESVJUWSIsIk9LIiwiaXNBYm9ydGVkIiwiaXNEaXJ0eSIsImlzVmFsaWQiLCJpc0FzeW5jIiwiX19jbGFzc1ByaXZhdGVGaWVsZEdldCIsInJlY2VpdmVyIiwic3RhdGUiLCJraW5kIiwiZiIsIl9fY2xhc3NQcml2YXRlRmllbGRTZXQiLCJlcnJvclV0aWwiLCJlcnJvclV0aWwyIiwiZXJyVG9PYmoiLCJfWm9kRW51bV9jYWNoZSIsIl9ab2ROYXRpdmVFbnVtX2NhY2hlIiwiUGFyc2VJbnB1dExhenlQYXRoIiwiX2NhY2hlZFBhdGgiLCJfcGF0aCIsIl9rZXkiLCJoYW5kbGVSZXN1bHQiLCJzdWNjZXNzIiwiX2Vycm9yIiwicHJvY2Vzc0NyZWF0ZVBhcmFtcyIsImVycm9yTWFwMiIsImludmFsaWRfdHlwZV9lcnJvciIsInJlcXVpcmVkX2Vycm9yIiwiZGVzY3JpcHRpb24iLCJjdXN0b21NYXAiLCJpc3MiLCJfYSIsIl9iIiwiWm9kVHlwZSIsImRlZiIsInNwYSIsInNhZmVQYXJzZUFzeW5jIiwiX2RlZiIsInBhcnNlIiwic2FmZVBhcnNlIiwicGFyc2VBc3luYyIsInJlZmluZSIsInJlZmluZW1lbnQiLCJzdXBlclJlZmluZSIsIm9wdGlvbmFsIiwibnVsbGFibGUiLCJudWxsaXNoIiwib3IiLCJhbmQiLCJicmFuZCIsImRlc2NyaWJlIiwicGlwZSIsInJlYWRvbmx5IiwiaXNOdWxsYWJsZSIsImlzT3B0aW9uYWwiLCJfZ2V0VHlwZSIsIl9nZXRPclJldHVybkN0eCIsInBhcnNlZFR5cGUiLCJfcHJvY2Vzc0lucHV0UGFyYW1zIiwiX3BhcnNlU3luYyIsIl9wYXJzZSIsIl9wYXJzZUFzeW5jIiwiYXN5bmMiLCJtYXliZUFzeW5jUmVzdWx0IiwiY2hlY2siLCJnZXRJc3N1ZVByb3BlcnRpZXMiLCJfcmVmaW5lbWVudCIsInNldEVycm9yIiwicmVmaW5lbWVudERhdGEiLCJab2RFZmZlY3RzIiwic2NoZW1hIiwidHlwZU5hbWUiLCJab2RGaXJzdFBhcnR5VHlwZUtpbmQiLCJlZmZlY3QiLCJab2RPcHRpb25hbCIsIlpvZE51bGxhYmxlIiwiWm9kQXJyYXkiLCJab2RQcm9taXNlIiwib3B0aW9uIiwiWm9kVW5pb24iLCJpbmNvbWluZyIsIlpvZEludGVyc2VjdGlvbiIsImRlZmF1bHRWYWx1ZUZ1bmMiLCJab2REZWZhdWx0IiwiaW5uZXJUeXBlIiwiWm9kQnJhbmRlZCIsImNhdGNoVmFsdWVGdW5jIiwiWm9kQ2F0Y2giLCJjYXRjaFZhbHVlIiwiVGhpcyIsIlpvZFBpcGVsaW5lIiwiWm9kUmVhZG9ubHkiLCJjdWlkUmVnZXgiLCJjdWlkMlJlZ2V4IiwidWxpZFJlZ2V4IiwidXVpZFJlZ2V4IiwibmFub2lkUmVnZXgiLCJkdXJhdGlvblJlZ2V4IiwiZW1haWxSZWdleCIsIl9lbW9qaVJlZ2V4IiwiZW1vamlSZWdleCIsImlwdjRSZWdleCIsImlwdjZSZWdleCIsImJhc2U2NFJlZ2V4IiwiZGF0ZVJlZ2V4U291cmNlIiwiZGF0ZVJlZ2V4IiwidGltZVJlZ2V4U291cmNlIiwicmVnZXgiLCJ0aW1lUmVnZXgiLCJkYXRldGltZVJlZ2V4Iiwib3B0cyIsImxvY2FsIiwiaXNWYWxpZElQIiwiaXAiLCJ2ZXJzaW9uIiwiWm9kU3RyaW5nIiwiX1pvZFN0cmluZyIsImNvZXJjZSIsImN0eDIiLCJjaGVja3MiLCJ0b29CaWciLCJ0b29TbWFsbCIsInRlc3RSZXN1bHQiLCJfcmVnZXgiLCJfYWRkQ2hlY2siLCJlbWFpbCIsImVtb2ppIiwidXVpZCIsIm5hbm9pZCIsImN1aWQiLCJjdWlkMiIsInVsaWQiLCJiYXNlNjQiLCJkYXRldGltZSIsImR1cmF0aW9uIiwibWluTGVuZ3RoIiwibGVuIiwibm9uZW1wdHkiLCJpc0RhdGV0aW1lIiwiY2giLCJpc1RpbWUiLCJpc0R1cmF0aW9uIiwiaXNFbWFpbCIsImlzVVJMIiwiaXNFbW9qaSIsImlzVVVJRCIsImlzTkFOT0lEIiwiaXNDVUlEIiwiaXNDVUlEMiIsImlzVUxJRCIsImlzSVAiLCJpc0Jhc2U2NCIsImZsb2F0U2FmZVJlbWFpbmRlciIsInZhbERlY0NvdW50Iiwic3RlcERlY0NvdW50IiwiZGVjQ291bnQiLCJ2YWxJbnQiLCJ0b0ZpeGVkIiwic3RlcEludCIsInBvdyIsIlpvZE51bWJlciIsIl9ab2ROdW1iZXIiLCJzZXRMaW1pdCIsImludCIsInBvc2l0aXZlIiwibmVnYXRpdmUiLCJub25wb3NpdGl2ZSIsIm5vbm5lZ2F0aXZlIiwiZmluaXRlIiwic2FmZSIsIk1JTl9TQUZFX0lOVEVHRVIiLCJtaW5WYWx1ZSIsIm1heFZhbHVlIiwiaXNJbnQiLCJab2RCaWdJbnQiLCJfWm9kQmlnSW50IiwiQmlnSW50IiwiWm9kQm9vbGVhbiIsIkJvb2xlYW4iLCJab2REYXRlIiwiX1pvZERhdGUiLCJnZXRUaW1lIiwibWluRGF0ZSIsIm1heERhdGUiLCJab2RTeW1ib2wiLCJab2RVbmRlZmluZWQiLCJab2ROdWxsIiwiWm9kQW55IiwiX2FueSIsIlpvZFVua25vd24iLCJfdW5rbm93biIsIlpvZE5ldmVyIiwibmV2ZXIiLCJab2RWb2lkIiwidm9pZCIsIl9ab2RBcnJheSIsImV4YWN0TGVuZ3RoIiwiZWxlbWVudCIsImRlZXBQYXJ0aWFsaWZ5IiwiWm9kT2JqZWN0IiwibmV3U2hhcGUiLCJmaWVsZFNjaGVtYSIsInVud3JhcCIsIlpvZFR1cGxlIiwiX1pvZE9iamVjdCIsIl9jYWNoZWQiLCJub25zdHJpY3QiLCJwYXNzdGhyb3VnaCIsImF1Z21lbnQiLCJfZ2V0Q2FjaGVkIiwic2hhcGVLZXlzIiwiZXh0cmFLZXlzIiwiY2F0Y2hhbGwiLCJ1bmtub3duS2V5cyIsImtleVZhbGlkYXRvciIsInN0cmljdCIsIl9jIiwiX2QiLCJzdHJpcCIsImF1Z21lbnRhdGlvbiIsIm1lcmdpbmciLCJtZXJnZWQiLCJzZXRLZXkiLCJtYXNrIiwiZGVlcFBhcnRpYWwiLCJyZXF1aXJlZCIsIm5ld0ZpZWxkIiwia2V5b2YiLCJjcmVhdGVab2RFbnVtIiwic3RyaWN0Q3JlYXRlIiwibGF6eWNyZWF0ZSIsImhhbmRsZVJlc3VsdHMiLCJjaGlsZEN0eCIsImlzc3VlczIiLCJnZXREaXNjcmltaW5hdG9yIiwiWm9kTGF6eSIsIlpvZExpdGVyYWwiLCJab2RFbnVtIiwiWm9kTmF0aXZlRW51bSIsImVudW0iLCJab2REaXNjcmltaW5hdGVkVW5pb24iLCJfWm9kRGlzY3JpbWluYXRlZFVuaW9uIiwiZGlzY3JpbWluYXRvciIsImRpc2NyaW1pbmF0b3JWYWx1ZSIsIm9wdGlvbnNNYXAiLCJkaXNjcmltaW5hdG9yVmFsdWVzIiwibWVyZ2VWYWx1ZXMiLCJhVHlwZSIsImJUeXBlIiwidmFsaWQiLCJiS2V5cyIsInNoYXJlZEtleXMiLCJuZXdPYmoiLCJzaGFyZWRWYWx1ZSIsIm5ld0FycmF5IiwiaXRlbUEiLCJpdGVtQiIsImhhbmRsZVBhcnNlZCIsInBhcnNlZExlZnQiLCJwYXJzZWRSaWdodCIsImxlZnQiLCJyaWdodCIsIl9ab2RUdXBsZSIsIml0ZW1JbmRleCIsInNjaGVtYXMiLCJab2RSZWNvcmQiLCJfWm9kUmVjb3JkIiwia2V5U2NoZW1hIiwia2V5VHlwZSIsInZhbHVlU2NoZW1hIiwidmFsdWVUeXBlIiwidGhpcmQiLCJab2RNYXAiLCJmaW5hbE1hcCIsIlpvZFNldCIsIl9ab2RTZXQiLCJtaW5TaXplIiwibWF4U2l6ZSIsImZpbmFsaXplU2V0IiwiZWxlbWVudHMyIiwicGFyc2VkU2V0IiwiZWxlbWVudHMiLCJab2RGdW5jdGlvbiIsIl9ab2RGdW5jdGlvbiIsInZhbGlkYXRlIiwiaW1wbGVtZW50IiwibWFrZUFyZ3NJc3N1ZSIsIm1ha2VSZXR1cm5zSXNzdWUiLCJyZXR1cm5zIiwibWUiLCJwYXJzZWRBcmdzIiwiUmVmbGVjdCIsInBhcnNlZFJldHVybnMiLCJwYXJhbWV0ZXJzIiwicmV0dXJuVHlwZSIsInZhbGlkYXRlZEZ1bmMiLCJzdHJpY3RJbXBsZW1lbnQiLCJnZXR0ZXIiLCJsYXp5U2NoZW1hIiwiX1pvZEVudW0iLCJleHBlY3RlZFZhbHVlcyIsImVudW1WYWx1ZXMiLCJWYWx1ZXMiLCJFbnVtIiwiZXh0cmFjdCIsIm5ld0RlZiIsImV4Y2x1ZGUiLCJvcHQiLCJXZWFrTWFwIiwibmF0aXZlRW51bVZhbHVlcyIsInByb21pc2lmaWVkIiwic291cmNlVHlwZSIsImNoZWNrQ3R4IiwiZmF0YWwiLCJwcm9jZXNzZWQiLCJwcm9jZXNzZWQyIiwiZXhlY3V0ZVJlZmluZW1lbnQiLCJhY2MiLCJpbm5lciIsImJhc2UiLCJjcmVhdGVXaXRoUHJlcHJvY2VzcyIsInByZXByb2Nlc3MiLCJyZW1vdmVEZWZhdWx0IiwibmV3Q3R4IiwicmVtb3ZlQ2F0Y2giLCJab2ROYU4iLCJCUkFORCIsIl9ab2RQaXBlbGluZSIsImhhbmRsZUFzeW5jIiwiaW5SZXN1bHQiLCJpbiIsIm91dCIsInAiLCJfZmF0YWwiLCJsYXRlIiwiWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMiIsImluc3RhbmNlT2ZUeXBlIiwiY2xzIiwic3RyaW5nVHlwZSIsIm51bWJlclR5cGUiLCJuYW5UeXBlIiwiYmlnSW50VHlwZSIsImJvb2xlYW5UeXBlIiwiZGF0ZVR5cGUiLCJzeW1ib2xUeXBlIiwidW5kZWZpbmVkVHlwZSIsIm51bGxUeXBlIiwiYW55VHlwZSIsInVua25vd25UeXBlIiwibmV2ZXJUeXBlIiwidm9pZFR5cGUiLCJhcnJheVR5cGUiLCJvYmplY3RUeXBlIiwic3RyaWN0T2JqZWN0VHlwZSIsInVuaW9uVHlwZSIsImRpc2NyaW1pbmF0ZWRVbmlvblR5cGUiLCJpbnRlcnNlY3Rpb25UeXBlIiwidHVwbGVUeXBlIiwicmVjb3JkVHlwZSIsIm1hcFR5cGUiLCJzZXRUeXBlIiwiZnVuY3Rpb25UeXBlIiwibGF6eVR5cGUiLCJsaXRlcmFsVHlwZSIsImVudW1UeXBlIiwibmF0aXZlRW51bVR5cGUiLCJwcm9taXNlVHlwZSIsImVmZmVjdHNUeXBlIiwib3B0aW9uYWxUeXBlIiwibnVsbGFibGVUeXBlIiwicHJlcHJvY2Vzc1R5cGUiLCJwaXBlbGluZVR5cGUiLCJvc3RyaW5nIiwib251bWJlciIsIm9ib29sZWFuIiwiTkVWRVIiLCJ6IiwiZGVmYXVsdEVycm9yTWFwIiwiWm9kVHJhbnNmb3JtZXIiLCJTY2hlbWEiLCJab2RTY2hlbWEiLCJhbnkiLCJkaXNjcmltaW5hdGVkVW5pb24iLCJsYXp5IiwibGl0ZXJhbCIsIm5hdGl2ZUVudW0iLCJwaXBlbGluZSIsInJlY29yZCIsInN0cmljdE9iamVjdCIsInRyYW5zZm9ybWVyIiwidHVwbGUiLCJwYWNrYWdlX2RlZmF1bHQiLCJrZXl3b3JkcyIsInJlcG9zaXRvcnkiLCJsaWNlbnNlIiwiYXV0aG9yIiwiYnVncyIsIm1haW4iLCJpbXBvcnQiLCJob21lcGFnZSIsImZpbGVzIiwic2NyaXB0cyIsImNsZWFuIiwicmVzb3VyY2VzIiwiYnVpbGQiLCJ3YXRjaCIsImxpbnQiLCJkZXBlbmRlbmNpZXMiLCJuZGFycmF5Iiwiem9kIiwicGVlckRlcGVuZGVuY2llcyIsImRldkRlcGVuZGVuY2llcyIsImVzYnVpbGQiLCJnbG9iIiwidHNsaWIiLCJ0eXBlc2NyaXB0Iiwid2VicGFjayIsImJ1bmRsZURlcGVuZGVuY2llcyIsIkNvbmZpZ1NjaGVtYSIsInJlc2NhbGUiLCJsb2ciLCJ0b3RhbCIsImNyb3NzT3JpZ2luSXNvbGF0ZWQiLCJ2YWxpZGF0ZUNvbmZpZyIsImNvbmZpZ3VyYXRpb24iLCJpbXBvcnRfbmRhcnJheTQiLCJpbml0QmFzZSIsImluaXRJbmZlcmVuY2UiLCJydW5JbmZlcmVuY2UiLCJyZXNvbHV0aW9uIiwia2VlcEFzcGVjdCIsInJlc2l6ZWRJbWFnZVRlbnNvciIsImlucHV0VGVuc29yIiwicHJlZGljdGlvbnNEaWN0IiwiYWxwaGFtYXNrMiIsImFscGhhbWFza1U4IiwiaW5pdCIsInByZWxvYWQiLCJyZW1vdmVCYWNrZ3JvdW5kIiwiaW5wdXRJbWFnZVRlbnNvciIsIm91dEltYWdlVGVuc29yIiwib3V0SW1hZ2UiLCJyZW1vdmVGb3JlZ3JvdW5kIiwiaW1hZ2VJbnB1dCIsImFscGhhbWFzayIsInNlZ21lbnRGb3JlZ3JvdW5kIiwiYWxwaGEiLCJhcHBseVNlZ21lbnRhdGlvbk1hc2siLCJpbWFnZUhlaWdodCIsImltYWdlV2lkdGgiLCJpbWFnZUNoYW5uZWxzIiwibWFza1RlbnNvciIsIm1hc2tIZWlnaHQiLCJtYXNrV2lkdGgiLCJtYXNrQ2hhbm5lbHMiLCJhbHBoYU1hc2siLCJpZHhJbWFnZSIsImlkeE1hc2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@imgly/background-removal/dist/index.mjs\n");

/***/ })

};
;