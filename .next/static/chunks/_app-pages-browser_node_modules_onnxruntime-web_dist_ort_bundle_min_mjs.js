"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_onnxruntime-web_dist_ort_bundle_min_mjs"],{

/***/ "(app-pages-browser)/./node_modules/onnxruntime-web/dist/ort.bundle.min.mjs?4b98":
/*!**************************************************************!*\
  !*** ./node_modules/onnxruntime-web/dist/ort.bundle.min.mjs ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/media/ort.bundle.min.c42263fb.mjs";

/***/ }),

/***/ "(app-pages-browser)/./node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm":
/*!****************************************************************************!*\
  !*** ./node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm ***!
  \****************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/media/ort-wasm-simd-threaded.jsep.da7a4538.wasm";

/***/ }),

/***/ "(app-pages-browser)/./node_modules/onnxruntime-web/dist/ort.bundle.min.mjs?3f47":
/*!**************************************************************!*\
  !*** ./node_modules/onnxruntime-web/dist/ort.bundle.min.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InferenceSession: function() { return /* binding */ Fp; },\n/* harmony export */   TRACE: function() { return /* binding */ wr; },\n/* harmony export */   TRACE_FUNC_BEGIN: function() { return /* binding */ Ue; },\n/* harmony export */   TRACE_FUNC_END: function() { return /* binding */ De; },\n/* harmony export */   Tensor: function() { return /* binding */ He; },\n/* harmony export */   \"default\": function() { return /* binding */ $1; },\n/* harmony export */   env: function() { return /* binding */ ve; },\n/* harmony export */   registerBackend: function() { return /* binding */ St; }\n/* harmony export */ });\n/*!\n * ONNX Runtime Web v1.21.0-dev.20250114-228dd16893\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */ var Un = Object.defineProperty;\nvar Vp = Object.getOwnPropertyDescriptor;\nvar Wp = Object.getOwnPropertyNames;\nvar Lp = Object.prototype.hasOwnProperty;\nvar Nn = ((e1)=>typeof require < \"u\" ? require : typeof Proxy < \"u\" ? new Proxy(e1, {\n        get: (t, r)=>(typeof require < \"u\" ? require : t)[r]\n    }) : e1)(function(e1) {\n    if (typeof require < \"u\") return require.apply(this, arguments);\n    throw Error('Dynamic require of \"' + e1 + '\" is not supported');\n});\nvar U = (e1, t)=>()=>(e1 && (t = e1(e1 = 0)), t);\nvar Ft = (e1, t)=>{\n    for(var r in t)Un(e1, r, {\n        get: t[r],\n        enumerable: !0\n    });\n}, Gp = (e1, t, r, n)=>{\n    if (t && typeof t == \"object\" || typeof t == \"function\") for (let o of Wp(t))!Lp.call(e1, o) && o !== r && Un(e1, o, {\n        get: ()=>t[o],\n        enumerable: !(n = Vp(t, o)) || n.enumerable\n    });\n    return e1;\n};\nvar br = (e1)=>Gp(Un({}, \"__esModule\", {\n        value: !0\n    }), e1);\nvar yr, xt, St, Hp, Ji, Vn = U(()=>{\n    \"use strict\";\n    yr = new Map, xt = [], St = (e1, t, r)=>{\n        if (t && typeof t.init == \"function\" && typeof t.createInferenceSessionHandler == \"function\") {\n            let n = yr.get(e1);\n            if (n === void 0) yr.set(e1, {\n                backend: t,\n                priority: r\n            });\n            else {\n                if (n.priority > r) return;\n                if (n.priority === r && n.backend !== t) throw new Error('cannot register backend \"'.concat(e1, '\" using priority ').concat(r));\n            }\n            if (r >= 0) {\n                let o = xt.indexOf(e1);\n                o !== -1 && xt.splice(o, 1);\n                for(let i = 0; i < xt.length; i++)if (yr.get(xt[i]).priority <= r) {\n                    xt.splice(i, 0, e1);\n                    return;\n                }\n                xt.push(e1);\n            }\n            return;\n        }\n        throw new TypeError(\"not a valid backend\");\n    }, Hp = async (e1)=>{\n        let t = yr.get(e1);\n        if (!t) return \"backend not found.\";\n        if (t.initialized) return t.backend;\n        if (t.aborted) return t.error;\n        {\n            let r = !!t.initPromise;\n            try {\n                return r || (t.initPromise = t.backend.init(e1)), await t.initPromise, t.initialized = !0, t.backend;\n            } catch (n) {\n                return r || (t.error = \"\".concat(n), t.aborted = !0), t.error;\n            } finally{\n                delete t.initPromise;\n            }\n        }\n    }, Ji = async (e1)=>{\n        let t = e1.executionProviders || [], r = t.map((l)=>typeof l == \"string\" ? l : l.name), n = r.length === 0 ? xt : r, o, i = [], a = new Set;\n        for (let l of n){\n            let p = await Hp(l);\n            typeof p == \"string\" ? i.push({\n                name: l,\n                err: p\n            }) : (o || (o = p), o === p && a.add(l));\n        }\n        if (!o) throw new Error(\"no available backend found. ERR: \".concat(i.map((l)=>\"[\".concat(l.name, \"] \").concat(l.err)).join(\", \")));\n        for (let { name: l, err: p } of i)r.includes(l) && console.warn('removing requested execution provider \"'.concat(l, '\" from session options because it is not available: ').concat(p));\n        let d = t.filter((l)=>a.has(typeof l == \"string\" ? l : l.name));\n        return [\n            o,\n            new Proxy(e1, {\n                get: (l, p)=>p === \"executionProviders\" ? d : Reflect.get(l, p)\n            })\n        ];\n    };\n});\nvar ea = U(()=>{\n    \"use strict\";\n    Vn();\n});\nvar ta, ra = U(()=>{\n    \"use strict\";\n    ta = \"1.21.0-dev.20241212-1f88284f96\";\n});\nvar na, Re, Wn = U(()=>{\n    \"use strict\";\n    ra();\n    na = \"warning\", Re = {\n        wasm: {},\n        webgl: {},\n        webgpu: {},\n        versions: {\n            common: ta\n        },\n        set logLevel (e){\n            if (e !== void 0) {\n                if (typeof e != \"string\" || [\n                    \"verbose\",\n                    \"info\",\n                    \"warning\",\n                    \"error\",\n                    \"fatal\"\n                ].indexOf(e) === -1) throw new Error(\"Unsupported logging level: \".concat(e));\n                na = e;\n            }\n        },\n        get logLevel () {\n            return na;\n        }\n    };\n    Object.defineProperty(Re, \"logLevel\", {\n        enumerable: !0\n    });\n});\nvar ve, oa = U(()=>{\n    \"use strict\";\n    Wn();\n    ve = Re;\n});\nvar ia, aa, sa = U(()=>{\n    \"use strict\";\n    ia = (e1, t)=>{\n        let r = typeof document < \"u\" ? document.createElement(\"canvas\") : new OffscreenCanvas(1, 1);\n        r.width = e1.dims[3], r.height = e1.dims[2];\n        let n = r.getContext(\"2d\");\n        if (n != null) {\n            let o, i;\n            (t === null || t === void 0 ? void 0 : t.tensorLayout) !== void 0 && t.tensorLayout === \"NHWC\" ? (o = e1.dims[2], i = e1.dims[3]) : (o = e1.dims[3], i = e1.dims[2]);\n            let a = (t === null || t === void 0 ? void 0 : t.format) !== void 0 ? t.format : \"RGB\", d = t === null || t === void 0 ? void 0 : t.norm, l, p;\n            d === void 0 || d.mean === void 0 ? l = [\n                255,\n                255,\n                255,\n                255\n            ] : typeof d.mean == \"number\" ? l = [\n                d.mean,\n                d.mean,\n                d.mean,\n                d.mean\n            ] : (l = [\n                d.mean[0],\n                d.mean[1],\n                d.mean[2],\n                0\n            ], d.mean[3] !== void 0 && (l[3] = d.mean[3])), d === void 0 || d.bias === void 0 ? p = [\n                0,\n                0,\n                0,\n                0\n            ] : typeof d.bias == \"number\" ? p = [\n                d.bias,\n                d.bias,\n                d.bias,\n                d.bias\n            ] : (p = [\n                d.bias[0],\n                d.bias[1],\n                d.bias[2],\n                0\n            ], d.bias[3] !== void 0 && (p[3] = d.bias[3]));\n            let m = i * o, u = 0, h = m, _ = m * 2, y = -1;\n            a === \"RGBA\" ? (u = 0, h = m, _ = m * 2, y = m * 3) : a === \"RGB\" ? (u = 0, h = m, _ = m * 2) : a === \"RBG\" && (u = 0, _ = m, h = m * 2);\n            for(let g = 0; g < i; g++)for(let x = 0; x < o; x++){\n                let $ = (e1.data[u++] - p[0]) * l[0], v = (e1.data[h++] - p[1]) * l[1], S = (e1.data[_++] - p[2]) * l[2], T = y === -1 ? 255 : (e1.data[y++] - p[3]) * l[3];\n                n.fillStyle = \"rgba(\" + $ + \",\" + v + \",\" + S + \",\" + T + \")\", n.fillRect(x, g, 1, 1);\n            }\n            if (\"toDataURL\" in r) return r.toDataURL();\n            throw new Error(\"toDataURL is not supported\");\n        } else throw new Error(\"Can not access image data\");\n    }, aa = (e1, t)=>{\n        let r = typeof document < \"u\" ? document.createElement(\"canvas\").getContext(\"2d\") : new OffscreenCanvas(1, 1).getContext(\"2d\"), n;\n        if (r != null) {\n            let o, i, a;\n            (t === null || t === void 0 ? void 0 : t.tensorLayout) !== void 0 && t.tensorLayout === \"NHWC\" ? (o = e1.dims[2], i = e1.dims[1], a = e1.dims[3]) : (o = e1.dims[3], i = e1.dims[2], a = e1.dims[1]);\n            let d = t !== void 0 && t.format !== void 0 ? t.format : \"RGB\", l = t === null || t === void 0 ? void 0 : t.norm, p, m;\n            l === void 0 || l.mean === void 0 ? p = [\n                255,\n                255,\n                255,\n                255\n            ] : typeof l.mean == \"number\" ? p = [\n                l.mean,\n                l.mean,\n                l.mean,\n                l.mean\n            ] : (p = [\n                l.mean[0],\n                l.mean[1],\n                l.mean[2],\n                255\n            ], l.mean[3] !== void 0 && (p[3] = l.mean[3])), l === void 0 || l.bias === void 0 ? m = [\n                0,\n                0,\n                0,\n                0\n            ] : typeof l.bias == \"number\" ? m = [\n                l.bias,\n                l.bias,\n                l.bias,\n                l.bias\n            ] : (m = [\n                l.bias[0],\n                l.bias[1],\n                l.bias[2],\n                0\n            ], l.bias[3] !== void 0 && (m[3] = l.bias[3]));\n            let u = i * o;\n            if (t !== void 0 && (t.format !== void 0 && a === 4 && t.format !== \"RGBA\" || a === 3 && t.format !== \"RGB\" && t.format !== \"BGR\")) throw new Error(\"Tensor format doesn't match input tensor dims\");\n            let h = 4, _ = 0, y = 1, g = 2, x = 3, $ = 0, v = u, S = u * 2, T = -1;\n            d === \"RGBA\" ? ($ = 0, v = u, S = u * 2, T = u * 3) : d === \"RGB\" ? ($ = 0, v = u, S = u * 2) : d === \"RBG\" && ($ = 0, S = u, v = u * 2), n = r.createImageData(o, i);\n            for(let A = 0; A < i * o; _ += h, y += h, g += h, x += h, A++)n.data[_] = (e1.data[$++] - m[0]) * p[0], n.data[y] = (e1.data[v++] - m[1]) * p[1], n.data[g] = (e1.data[S++] - m[2]) * p[2], n.data[x] = T === -1 ? 255 : (e1.data[T++] - m[3]) * p[3];\n        } else throw new Error(\"Can not access image data\");\n        return n;\n    };\n});\nvar Ln, ua, da, la, ca, pa, ma = U(()=>{\n    \"use strict\";\n    _r();\n    Ln = (e1, t)=>{\n        if (e1 === void 0) throw new Error(\"Image buffer must be defined\");\n        if (t.height === void 0 || t.width === void 0) throw new Error(\"Image height and width must be defined\");\n        if (t.tensorLayout === \"NHWC\") throw new Error(\"NHWC Tensor layout is not supported yet\");\n        var _t_norm;\n        let { height: r, width: n } = t, o = (_t_norm = t.norm) !== null && _t_norm !== void 0 ? _t_norm : {\n            mean: 255,\n            bias: 0\n        }, i, a;\n        var _o_mean_, _o_bias_;\n        typeof o.mean == \"number\" ? i = [\n            o.mean,\n            o.mean,\n            o.mean,\n            o.mean\n        ] : i = [\n            o.mean[0],\n            o.mean[1],\n            o.mean[2],\n            (_o_mean_ = o.mean[3]) !== null && _o_mean_ !== void 0 ? _o_mean_ : 255\n        ], typeof o.bias == \"number\" ? a = [\n            o.bias,\n            o.bias,\n            o.bias,\n            o.bias\n        ] : a = [\n            o.bias[0],\n            o.bias[1],\n            o.bias[2],\n            (_o_bias_ = o.bias[3]) !== null && _o_bias_ !== void 0 ? _o_bias_ : 0\n        ];\n        let d = t.format !== void 0 ? t.format : \"RGBA\", l = t.tensorFormat !== void 0 && t.tensorFormat !== void 0 ? t.tensorFormat : \"RGB\", p = r * n, m = l === \"RGBA\" ? new Float32Array(p * 4) : new Float32Array(p * 3), u = 4, h = 0, _ = 1, y = 2, g = 3, x = 0, $ = p, v = p * 2, S = -1;\n        d === \"RGB\" && (u = 3, h = 0, _ = 1, y = 2, g = -1), l === \"RGBA\" ? S = p * 3 : l === \"RBG\" ? (x = 0, v = p, $ = p * 2) : l === \"BGR\" && (v = 0, $ = p, x = p * 2);\n        for(let A = 0; A < p; A++, h += u, y += u, _ += u, g += u)m[x++] = (e1[h] + a[0]) / i[0], m[$++] = (e1[_] + a[1]) / i[1], m[v++] = (e1[y] + a[2]) / i[2], S !== -1 && g !== -1 && (m[S++] = (e1[g] + a[3]) / i[3]);\n        return l === \"RGBA\" ? new ze(\"float32\", m, [\n            1,\n            4,\n            r,\n            n\n        ]) : new ze(\"float32\", m, [\n            1,\n            3,\n            r,\n            n\n        ]);\n    }, ua = async (e1, t)=>{\n        let r = typeof HTMLImageElement < \"u\" && e1 instanceof HTMLImageElement, n = typeof ImageData < \"u\" && e1 instanceof ImageData, o = typeof ImageBitmap < \"u\" && e1 instanceof ImageBitmap, i = typeof e1 == \"string\", a, d = t !== null && t !== void 0 ? t : {}, l = ()=>{\n            if (typeof document < \"u\") return document.createElement(\"canvas\");\n            if (typeof OffscreenCanvas < \"u\") return new OffscreenCanvas(1, 1);\n            throw new Error(\"Canvas is not supported\");\n        }, p = (m)=>typeof HTMLCanvasElement < \"u\" && m instanceof HTMLCanvasElement || m instanceof OffscreenCanvas ? m.getContext(\"2d\") : null;\n        if (r) {\n            let m = l();\n            m.width = e1.width, m.height = e1.height;\n            let u = p(m);\n            if (u != null) {\n                let h = e1.height, _ = e1.width;\n                if (t !== void 0 && t.resizedHeight !== void 0 && t.resizedWidth !== void 0 && (h = t.resizedHeight, _ = t.resizedWidth), t !== void 0) {\n                    if (d = t, t.tensorFormat !== void 0) throw new Error(\"Image input config format must be RGBA for HTMLImageElement\");\n                    d.tensorFormat = \"RGBA\", d.height = h, d.width = _;\n                } else d.tensorFormat = \"RGBA\", d.height = h, d.width = _;\n                u.drawImage(e1, 0, 0), a = u.getImageData(0, 0, _, h).data;\n            } else throw new Error(\"Can not access image data\");\n        } else if (n) {\n            let m, u;\n            if (t !== void 0 && t.resizedWidth !== void 0 && t.resizedHeight !== void 0 ? (m = t.resizedHeight, u = t.resizedWidth) : (m = e1.height, u = e1.width), t !== void 0 && (d = t), d.format = \"RGBA\", d.height = m, d.width = u, t !== void 0) {\n                let h = l();\n                h.width = u, h.height = m;\n                let _ = p(h);\n                if (_ != null) _.putImageData(e1, 0, 0), a = _.getImageData(0, 0, u, m).data;\n                else throw new Error(\"Can not access image data\");\n            } else a = e1.data;\n        } else if (o) {\n            if (t === void 0) throw new Error(\"Please provide image config with format for Imagebitmap\");\n            let m = l();\n            m.width = e1.width, m.height = e1.height;\n            let u = p(m);\n            if (u != null) {\n                let h = e1.height, _ = e1.width;\n                return u.drawImage(e1, 0, 0, _, h), a = u.getImageData(0, 0, _, h).data, d.height = h, d.width = _, Ln(a, d);\n            } else throw new Error(\"Can not access image data\");\n        } else {\n            if (i) return new Promise((m, u)=>{\n                let h = l(), _ = p(h);\n                if (!e1 || !_) return u();\n                let y = new Image;\n                y.crossOrigin = \"Anonymous\", y.src = e1, y.onload = ()=>{\n                    h.width = y.width, h.height = y.height, _.drawImage(y, 0, 0, h.width, h.height);\n                    let g = _.getImageData(0, 0, h.width, h.height);\n                    d.height = h.height, d.width = h.width, m(Ln(g.data, d));\n                };\n            });\n            throw new Error(\"Input data provided is not supported - aborted tensor creation\");\n        }\n        if (a !== void 0) return Ln(a, d);\n        throw new Error(\"Input data provided is not supported - aborted tensor creation\");\n    }, da = (e1, t)=>{\n        let { width: r, height: n, download: o, dispose: i } = t, a = [\n            1,\n            n,\n            r,\n            4\n        ];\n        return new ze({\n            location: \"texture\",\n            type: \"float32\",\n            texture: e1,\n            dims: a,\n            download: o,\n            dispose: i\n        });\n    }, la = (e1, t)=>{\n        let { dataType: r, dims: n, download: o, dispose: i } = t;\n        return new ze({\n            location: \"gpu-buffer\",\n            type: r !== null && r !== void 0 ? r : \"float32\",\n            gpuBuffer: e1,\n            dims: n,\n            download: o,\n            dispose: i\n        });\n    }, ca = (e1, t)=>{\n        let { dataType: r, dims: n, download: o, dispose: i } = t;\n        return new ze({\n            location: \"ml-tensor\",\n            type: r !== null && r !== void 0 ? r : \"float32\",\n            mlTensor: e1,\n            dims: n,\n            download: o,\n            dispose: i\n        });\n    }, pa = (e1, t, r)=>new ze({\n            location: \"cpu-pinned\",\n            type: e1,\n            data: t,\n            dims: r !== null && r !== void 0 ? r : [\n                t.length\n            ]\n        });\n});\nvar Tt, qt, fa, ha, ga = U(()=>{\n    \"use strict\";\n    Tt = new Map([\n        [\n            \"float32\",\n            Float32Array\n        ],\n        [\n            \"uint8\",\n            Uint8Array\n        ],\n        [\n            \"int8\",\n            Int8Array\n        ],\n        [\n            \"uint16\",\n            Uint16Array\n        ],\n        [\n            \"int16\",\n            Int16Array\n        ],\n        [\n            \"int32\",\n            Int32Array\n        ],\n        [\n            \"bool\",\n            Uint8Array\n        ],\n        [\n            \"float64\",\n            Float64Array\n        ],\n        [\n            \"uint32\",\n            Uint32Array\n        ],\n        [\n            \"int4\",\n            Uint8Array\n        ],\n        [\n            \"uint4\",\n            Uint8Array\n        ]\n    ]), qt = new Map([\n        [\n            Float32Array,\n            \"float32\"\n        ],\n        [\n            Uint8Array,\n            \"uint8\"\n        ],\n        [\n            Int8Array,\n            \"int8\"\n        ],\n        [\n            Uint16Array,\n            \"uint16\"\n        ],\n        [\n            Int16Array,\n            \"int16\"\n        ],\n        [\n            Int32Array,\n            \"int32\"\n        ],\n        [\n            Float64Array,\n            \"float64\"\n        ],\n        [\n            Uint32Array,\n            \"uint32\"\n        ]\n    ]), fa = !1, ha = ()=>{\n        if (!fa) {\n            fa = !0;\n            let e1 = typeof BigInt64Array < \"u\" && BigInt64Array.from, t = typeof BigUint64Array < \"u\" && BigUint64Array.from, r = typeof Float16Array < \"u\" && Float16Array.from;\n            e1 && (Tt.set(\"int64\", BigInt64Array), qt.set(BigInt64Array, \"int64\")), t && (Tt.set(\"uint64\", BigUint64Array), qt.set(BigUint64Array, \"uint64\")), r ? (Tt.set(\"float16\", Float16Array), qt.set(Float16Array, \"float16\")) : Tt.set(\"float16\", Uint16Array);\n        }\n    };\n});\nvar ba, ya, _a = U(()=>{\n    \"use strict\";\n    _r();\n    ba = (e1)=>{\n        let t = 1;\n        for(let r = 0; r < e1.length; r++){\n            let n = e1[r];\n            if (typeof n != \"number\" || !Number.isSafeInteger(n)) throw new TypeError(\"dims[\".concat(r, \"] must be an integer, got: \").concat(n));\n            if (n < 0) throw new RangeError(\"dims[\".concat(r, \"] must be a non-negative integer, got: \").concat(n));\n            t *= n;\n        }\n        return t;\n    }, ya = (e1, t)=>{\n        switch(e1.location){\n            case \"cpu\":\n                return new ze(e1.type, e1.data, t);\n            case \"cpu-pinned\":\n                return new ze({\n                    location: \"cpu-pinned\",\n                    data: e1.data,\n                    type: e1.type,\n                    dims: t\n                });\n            case \"texture\":\n                return new ze({\n                    location: \"texture\",\n                    texture: e1.texture,\n                    type: e1.type,\n                    dims: t\n                });\n            case \"gpu-buffer\":\n                return new ze({\n                    location: \"gpu-buffer\",\n                    gpuBuffer: e1.gpuBuffer,\n                    type: e1.type,\n                    dims: t\n                });\n            case \"ml-tensor\":\n                return new ze({\n                    location: \"ml-tensor\",\n                    mlTensor: e1.mlTensor,\n                    type: e1.type,\n                    dims: t\n                });\n            default:\n                throw new Error(\"tensorReshape: tensor location \".concat(e1.location, \" is not supported\"));\n        }\n    };\n});\nvar ze, _r = U(()=>{\n    \"use strict\";\n    sa();\n    ma();\n    ga();\n    _a();\n    ze = class {\n        static async fromImage(t, r) {\n            return ua(t, r);\n        }\n        static fromTexture(t, r) {\n            return da(t, r);\n        }\n        static fromGpuBuffer(t, r) {\n            return la(t, r);\n        }\n        static fromMLTensor(t, r) {\n            return ca(t, r);\n        }\n        static fromPinnedBuffer(t, r, n) {\n            return pa(t, r, n);\n        }\n        toDataURL(t) {\n            return ia(this, t);\n        }\n        toImageData(t) {\n            return aa(this, t);\n        }\n        get data() {\n            if (this.ensureValid(), !this.cpuData) throw new Error(\"The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.\");\n            return this.cpuData;\n        }\n        get location() {\n            return this.dataLocation;\n        }\n        get texture() {\n            if (this.ensureValid(), !this.gpuTextureData) throw new Error(\"The data is not stored as a WebGL texture.\");\n            return this.gpuTextureData;\n        }\n        get gpuBuffer() {\n            if (this.ensureValid(), !this.gpuBufferData) throw new Error(\"The data is not stored as a WebGPU buffer.\");\n            return this.gpuBufferData;\n        }\n        get mlTensor() {\n            if (this.ensureValid(), !this.mlTensorData) throw new Error(\"The data is not stored as a WebNN MLTensor.\");\n            return this.mlTensorData;\n        }\n        async getData(t) {\n            switch(this.ensureValid(), this.dataLocation){\n                case \"cpu\":\n                case \"cpu-pinned\":\n                    return this.data;\n                case \"texture\":\n                case \"gpu-buffer\":\n                case \"ml-tensor\":\n                    {\n                        if (!this.downloader) throw new Error(\"The current tensor is not created with a specified data downloader.\");\n                        if (this.isDownloading) throw new Error(\"The current tensor is being downloaded.\");\n                        try {\n                            this.isDownloading = !0;\n                            let r = await this.downloader();\n                            return this.downloader = void 0, this.dataLocation = \"cpu\", this.cpuData = r, t && this.disposer && (this.disposer(), this.disposer = void 0), r;\n                        } finally{\n                            this.isDownloading = !1;\n                        }\n                    }\n                default:\n                    throw new Error(\"cannot get data from location: \".concat(this.dataLocation));\n            }\n        }\n        dispose() {\n            if (this.isDownloading) throw new Error(\"The current tensor is being downloaded.\");\n            this.disposer && (this.disposer(), this.disposer = void 0), this.cpuData = void 0, this.gpuTextureData = void 0, this.gpuBufferData = void 0, this.mlTensorData = void 0, this.downloader = void 0, this.isDownloading = void 0, this.dataLocation = \"none\";\n        }\n        ensureValid() {\n            if (this.dataLocation === \"none\") throw new Error(\"The tensor is disposed.\");\n        }\n        reshape(t) {\n            if (this.ensureValid(), this.downloader || this.disposer) throw new Error(\"Cannot reshape a tensor that owns GPU resource.\");\n            return ya(this, t);\n        }\n        constructor(t, r, n){\n            ha();\n            let o, i;\n            if (typeof t == \"object\" && \"location\" in t) switch(this.dataLocation = t.location, o = t.type, i = t.dims, t.location){\n                case \"cpu-pinned\":\n                    {\n                        let d = Tt.get(o);\n                        if (!d) throw new TypeError('unsupported type \"'.concat(o, '\" to create tensor from pinned buffer'));\n                        if (!(t.data instanceof d)) throw new TypeError(\"buffer should be of type \".concat(d.name));\n                        this.cpuData = t.data;\n                        break;\n                    }\n                case \"texture\":\n                    {\n                        if (o !== \"float32\") throw new TypeError('unsupported type \"'.concat(o, '\" to create tensor from texture'));\n                        this.gpuTextureData = t.texture, this.downloader = t.download, this.disposer = t.dispose;\n                        break;\n                    }\n                case \"gpu-buffer\":\n                    {\n                        if (o !== \"float32\" && o !== \"float16\" && o !== \"int32\" && o !== \"int64\" && o !== \"uint32\" && o !== \"uint8\" && o !== \"bool\" && o !== \"uint4\" && o !== \"int4\") throw new TypeError('unsupported type \"'.concat(o, '\" to create tensor from gpu buffer'));\n                        this.gpuBufferData = t.gpuBuffer, this.downloader = t.download, this.disposer = t.dispose;\n                        break;\n                    }\n                case \"ml-tensor\":\n                    {\n                        if (o !== \"float32\" && o !== \"float16\" && o !== \"int32\" && o !== \"int64\" && o !== \"uint32\" && o !== \"uint64\" && o !== \"int8\" && o !== \"uint8\" && o !== \"bool\" && o !== \"uint4\" && o !== \"int4\") throw new TypeError('unsupported type \"'.concat(o, '\" to create tensor from MLTensor'));\n                        this.mlTensorData = t.mlTensor, this.downloader = t.download, this.disposer = t.dispose;\n                        break;\n                    }\n                default:\n                    throw new Error(\"Tensor constructor: unsupported location '\".concat(this.dataLocation, \"'\"));\n            }\n            else {\n                let d, l;\n                if (typeof t == \"string\") if (o = t, l = n, t === \"string\") {\n                    if (!Array.isArray(r)) throw new TypeError(\"A string tensor's data must be a string array.\");\n                    d = r;\n                } else {\n                    let p = Tt.get(t);\n                    if (p === void 0) throw new TypeError(\"Unsupported tensor type: \".concat(t, \".\"));\n                    if (Array.isArray(r)) {\n                        if (t === \"float16\" && p === Uint16Array || t === \"uint4\" || t === \"int4\") throw new TypeError(\"Creating a \".concat(t, \" tensor from number array is not supported. Please use \").concat(p.name, \" as data.\"));\n                        t === \"uint64\" || t === \"int64\" ? d = p.from(r, BigInt) : d = p.from(r);\n                    } else if (r instanceof p) d = r;\n                    else if (r instanceof Uint8ClampedArray) if (t === \"uint8\") d = Uint8Array.from(r);\n                    else throw new TypeError(\"A Uint8ClampedArray tensor's data must be type of uint8\");\n                    else throw new TypeError(\"A \".concat(o, \" tensor's data must be type of \").concat(p));\n                }\n                else if (l = r, Array.isArray(t)) {\n                    if (t.length === 0) throw new TypeError(\"Tensor type cannot be inferred from an empty array.\");\n                    let p = typeof t[0];\n                    if (p === \"string\") o = \"string\", d = t;\n                    else if (p === \"boolean\") o = \"bool\", d = Uint8Array.from(t);\n                    else throw new TypeError(\"Invalid element type of data array: \".concat(p, \".\"));\n                } else if (t instanceof Uint8ClampedArray) o = \"uint8\", d = Uint8Array.from(t);\n                else {\n                    let p = qt.get(t.constructor);\n                    if (p === void 0) throw new TypeError(\"Unsupported type for tensor data: \".concat(t.constructor, \".\"));\n                    o = p, d = t;\n                }\n                if (l === void 0) l = [\n                    d.length\n                ];\n                else if (!Array.isArray(l)) throw new TypeError(\"A tensor's dims must be a number array\");\n                i = l, this.cpuData = d, this.dataLocation = \"cpu\";\n            }\n            let a = ba(i);\n            if (this.cpuData && a !== this.cpuData.length && !((o === \"uint4\" || o === \"int4\") && Math.ceil(a / 2) === this.cpuData.length)) throw new Error(\"Tensor's size(\".concat(a, \") does not match data length(\").concat(this.cpuData.length, \").\"));\n            this.type = o, this.dims = i, this.size = a;\n        }\n    };\n});\nvar He, Gn = U(()=>{\n    \"use strict\";\n    _r();\n    He = ze;\n});\nvar wr, wa, Ue, De, Hn = U(()=>{\n    \"use strict\";\n    Wn();\n    wr = (e1, t)=>{\n        (typeof Re.trace > \"u\" ? !Re.wasm.trace : !Re.trace) || console.timeStamp(\"\".concat(e1, \"::ORT::\").concat(t));\n    }, wa = (e1, t)=>{\n        var _stack;\n        let r = ((_stack = new Error().stack) === null || _stack === void 0 ? void 0 : _stack.split(/\\r\\n|\\r|\\n/g)) || [], n = !1;\n        for(let o = 0; o < r.length; o++){\n            if (n && !r[o].includes(\"TRACE_FUNC\")) {\n                let i = \"FUNC_\".concat(e1, \"::\").concat(r[o].trim().split(\" \")[1]);\n                t && (i += \"::\".concat(t)), wr(\"CPU\", i);\n                return;\n            }\n            r[o].includes(\"TRACE_FUNC\") && (n = !0);\n        }\n    }, Ue = (e1)=>{\n        (typeof Re.trace > \"u\" ? !Re.wasm.trace : !Re.trace) || wa(\"BEGIN\", e1);\n    }, De = (e1)=>{\n        (typeof Re.trace > \"u\" ? !Re.wasm.trace : !Re.trace) || wa(\"END\", e1);\n    };\n});\nvar vr, va = U(()=>{\n    \"use strict\";\n    Vn();\n    Gn();\n    Hn();\n    vr = class e1 {\n        async run(t, r, n) {\n            Ue();\n            let o = {}, i = {};\n            if (typeof t != \"object\" || t === null || t instanceof He || Array.isArray(t)) throw new TypeError(\"'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.\");\n            let a = !0;\n            if (typeof r == \"object\") {\n                if (r === null) throw new TypeError(\"Unexpected argument[1]: cannot be null.\");\n                if (r instanceof He) throw new TypeError(\"'fetches' cannot be a Tensor\");\n                if (Array.isArray(r)) {\n                    if (r.length === 0) throw new TypeError(\"'fetches' cannot be an empty array.\");\n                    a = !1;\n                    for (let p of r){\n                        if (typeof p != \"string\") throw new TypeError(\"'fetches' must be a string array or an object.\");\n                        if (this.outputNames.indexOf(p) === -1) throw new RangeError(\"'fetches' contains invalid output name: \".concat(p, \".\"));\n                        o[p] = null;\n                    }\n                    if (typeof n == \"object\" && n !== null) i = n;\n                    else if (typeof n < \"u\") throw new TypeError(\"'options' must be an object.\");\n                } else {\n                    let p = !1, m = Object.getOwnPropertyNames(r);\n                    for (let u of this.outputNames)if (m.indexOf(u) !== -1) {\n                        let h = r[u];\n                        (h === null || h instanceof He) && (p = !0, a = !1, o[u] = h);\n                    }\n                    if (p) {\n                        if (typeof n == \"object\" && n !== null) i = n;\n                        else if (typeof n < \"u\") throw new TypeError(\"'options' must be an object.\");\n                    } else i = r;\n                }\n            } else if (typeof r < \"u\") throw new TypeError(\"Unexpected argument[1]: must be 'fetches' or 'options'.\");\n            for (let p of this.inputNames)if (typeof t[p] > \"u\") throw new Error(\"input '\".concat(p, \"' is missing in 'feeds'.\"));\n            if (a) for (let p of this.outputNames)o[p] = null;\n            let d = await this.handler.run(t, o, i), l = {};\n            for(let p in d)if (Object.hasOwnProperty.call(d, p)) {\n                let m = d[p];\n                m instanceof He ? l[p] = m : l[p] = new He(m.type, m.data, m.dims);\n            }\n            return De(), l;\n        }\n        async release() {\n            return this.handler.dispose();\n        }\n        static async create(t, r, n, o) {\n            Ue();\n            let i, a = {};\n            if (typeof t == \"string\") {\n                if (i = t, typeof r == \"object\" && r !== null) a = r;\n                else if (typeof r < \"u\") throw new TypeError(\"'options' must be an object.\");\n            } else if (t instanceof Uint8Array) {\n                if (i = t, typeof r == \"object\" && r !== null) a = r;\n                else if (typeof r < \"u\") throw new TypeError(\"'options' must be an object.\");\n            } else if (t instanceof ArrayBuffer || typeof SharedArrayBuffer < \"u\" && t instanceof SharedArrayBuffer) {\n                let m = t, u = 0, h = t.byteLength;\n                if (typeof r == \"object\" && r !== null) a = r;\n                else if (typeof r == \"number\") {\n                    if (u = r, !Number.isSafeInteger(u)) throw new RangeError(\"'byteOffset' must be an integer.\");\n                    if (u < 0 || u >= m.byteLength) throw new RangeError(\"'byteOffset' is out of range [0, \".concat(m.byteLength, \").\"));\n                    if (h = t.byteLength - u, typeof n == \"number\") {\n                        if (h = n, !Number.isSafeInteger(h)) throw new RangeError(\"'byteLength' must be an integer.\");\n                        if (h <= 0 || u + h > m.byteLength) throw new RangeError(\"'byteLength' is out of range (0, \".concat(m.byteLength - u, \"].\"));\n                        if (typeof o == \"object\" && o !== null) a = o;\n                        else if (typeof o < \"u\") throw new TypeError(\"'options' must be an object.\");\n                    } else if (typeof n < \"u\") throw new TypeError(\"'byteLength' must be a number.\");\n                } else if (typeof r < \"u\") throw new TypeError(\"'options' must be an object.\");\n                i = new Uint8Array(m, u, h);\n            } else throw new TypeError(\"Unexpected argument[0]: must be 'path' or 'buffer'.\");\n            let [d, l] = await Ji(a), p = await d.createInferenceSessionHandler(i, l);\n            return De(), new e1(p);\n        }\n        startProfiling() {\n            this.handler.startProfiling();\n        }\n        endProfiling() {\n            this.handler.endProfiling();\n        }\n        get inputNames() {\n            return this.handler.inputNames;\n        }\n        get outputNames() {\n            return this.handler.outputNames;\n        }\n        constructor(t){\n            this.handler = t;\n        }\n    };\n});\nvar Fp, $a = U(()=>{\n    \"use strict\";\n    va();\n    Fp = vr;\n});\nvar xa = U(()=>{\n    \"use strict\";\n});\nvar Sa = U(_c1 = ()=>{\n    \"use strict\";\n});\n_c2 = Sa;\nvar Ta = U(_c3 = ()=>{\n    \"use strict\";\n});\n_c4 = Ta;\nvar Ia = U(_c5 = ()=>{\n    \"use strict\";\n});\n_c6 = Ia;\nvar Fn = {};\nFt(Fn, {\n    InferenceSession: ()=>Fp,\n    TRACE: ()=>wr,\n    TRACE_FUNC_BEGIN: ()=>Ue,\n    TRACE_FUNC_END: ()=>De,\n    Tensor: ()=>He,\n    env: ()=>ve,\n    registerBackend: ()=>St\n});\nvar We = U(_c7 = ()=>{\n    \"use strict\";\n    ea();\n    oa();\n    $a();\n    Gn();\n    xa();\n    Sa();\n    Hn();\n    Ta();\n    Ia();\n});\n_c8 = We;\nvar $r = U(()=>{\n    \"use strict\";\n});\nvar Ea = {};\nFt(Ea, {\n    default: ()=>qp\n});\nvar Aa, ka, qp, Pa = U(()=>{\n    \"use strict\";\n    var _globalThis_self;\n    qn();\n    gt();\n    xr();\n    Aa = \"ort-wasm-proxy-worker\", ka = ((_globalThis_self = globalThis.self) === null || _globalThis_self === void 0 ? void 0 : _globalThis_self.name) === Aa;\n    ka && (self.onmessage = (e1)=>{\n        let { type: t, in: r } = e1.data;\n        try {\n            switch(t){\n                case \"init-wasm\":\n                    Sr(r.wasm).then(()=>{\n                        Tr(r).then(()=>{\n                            postMessage({\n                                type: t\n                            });\n                        }, (n)=>{\n                            postMessage({\n                                type: t,\n                                err: n\n                            });\n                        });\n                    }, (n)=>{\n                        postMessage({\n                            type: t,\n                            err: n\n                        });\n                    });\n                    break;\n                case \"init-ep\":\n                    {\n                        let { epName: n, env: o } = r;\n                        Ir(o, n).then(()=>{\n                            postMessage({\n                                type: t\n                            });\n                        }, (i)=>{\n                            postMessage({\n                                type: t,\n                                err: i\n                            });\n                        });\n                        break;\n                    }\n                case \"copy-from\":\n                    {\n                        let { buffer: n } = r, o = Kt(n);\n                        postMessage({\n                            type: t,\n                            out: o\n                        });\n                        break;\n                    }\n                case \"create\":\n                    {\n                        let { model: n, options: o } = r;\n                        Cr(n, o).then((i)=>{\n                            postMessage({\n                                type: t,\n                                out: i\n                            });\n                        }, (i)=>{\n                            postMessage({\n                                type: t,\n                                err: i\n                            });\n                        });\n                        break;\n                    }\n                case \"release\":\n                    Ar(r), postMessage({\n                        type: t\n                    });\n                    break;\n                case \"run\":\n                    {\n                        let { sessionId: n, inputIndices: o, inputs: i, outputIndices: a, options: d } = r;\n                        kr(n, o, i, a, new Array(a.length).fill(null), d).then((l)=>{\n                            l.some((p)=>p[3] !== \"cpu\") ? postMessage({\n                                type: t,\n                                err: \"Proxy does not support non-cpu tensor location.\"\n                            }) : postMessage({\n                                type: t,\n                                out: l\n                            }, Pr([\n                                ...i,\n                                ...l\n                            ]));\n                        }, (l)=>{\n                            postMessage({\n                                type: t,\n                                err: l\n                            });\n                        });\n                        break;\n                    }\n                case \"end-profiling\":\n                    Er(r), postMessage({\n                        type: t\n                    });\n                    break;\n                default:\n            }\n        } catch (n) {\n            postMessage({\n                type: t,\n                err: n\n            });\n        }\n    });\n    qp = ka ? null : (e1)=>new Worker(e1 !== null && e1 !== void 0 ? e1 : Ne, {\n            type: \"module\",\n            name: Aa\n        });\n});\nvar Oa = {};\nFt(Oa, {\n    default: ()=>Kp\n});\nvar Kn, za, Kp, Da = U(()=>{\n    \"use strict\";\n    var _globalThis_self;\n    za = (Kn = \"file:///Users/amityadav/Desktop/Text-Behind%20Image/node_modules/onnxruntime-web/dist/ort.bundle.min.mjs\", async function() {\n        let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        function t() {\n            return se.buffer != J.buffer && ye(), J;\n        }\n        function r() {\n            return se.buffer != J.buffer && ye(), ne;\n        }\n        function n() {\n            return se.buffer != J.buffer && ye(), be;\n        }\n        function o() {\n            return se.buffer != J.buffer && ye(), Oe;\n        }\n        function i() {\n            return se.buffer != J.buffer && ye(), $e;\n        }\n        function a() {\n            return se.buffer != J.buffer && ye(), le;\n        }\n        function d() {\n            return se.buffer != J.buffer && ye(), W;\n        }\n        function l() {\n            return se.buffer != J.buffer && ye(), Ge;\n        }\n        var p, m, u = Object.assign({}, e1), h = new Promise((s, c)=>{\n            p = s, m = c;\n        }), _ = \"object\" == \"object\", y = typeof importScripts == \"function\", g = y && self.name == \"em-pthread\";\n        u.mountExternalData = (s, c)=>{\n            s.startsWith(\"./\") && (s = s.substring(2)), (u.Fb || (u.Fb = new Map)).set(s, c);\n        }, u.unmountExternalData = ()=>{\n            delete u.Fb;\n        };\n        var _globalThis_SharedArrayBuffer;\n        var x = (_globalThis_SharedArrayBuffer = globalThis.SharedArrayBuffer) !== null && _globalThis_SharedArrayBuffer !== void 0 ? _globalThis_SharedArrayBuffer : new WebAssembly.Memory({\n            initial: 0,\n            maximum: 0,\n            shared: !0\n        }).buffer.constructor;\n        let $ = ()=>{\n            let s = (f, b, w)=>function() {\n                    for(var _len = arguments.length, I = new Array(_len), _key = 0; _key < _len; _key++){\n                        I[_key] = arguments[_key];\n                    }\n                    let O = Xe, B = b === null || b === void 0 ? void 0 : b();\n                    I = f(...I);\n                    let L = b === null || b === void 0 ? void 0 : b();\n                    return B !== L && (f = L, w(B), b = w = null), Xe != O ? new Promise((H, X)=>{\n                        En = {\n                            resolve: H,\n                            reject: X\n                        };\n                    }) : I;\n                }, c = (f)=>async function() {\n                    for(var _len = arguments.length, b = new Array(_len), _key = 0; _key < _len; _key++){\n                        b[_key] = arguments[_key];\n                    }\n                    try {\n                        var _u_Hb;\n                        if (u.Gb) throw Error(\"Session already started\");\n                        let w = u.Gb = {\n                            hc: b[0],\n                            errors: []\n                        }, I = await f(...b);\n                        if (u.Gb !== w) throw Error(\"Session mismatch\");\n                        (_u_Hb = u.Hb) === null || _u_Hb === void 0 ? void 0 : _u_Hb.flush();\n                        let O = w.errors;\n                        if (0 < O.length) {\n                            let B = await Promise.all(O);\n                            if (B = B.filter((L)=>L), 0 < B.length) throw Error(B.join(\"\\n\"));\n                        }\n                        return I;\n                    } finally{\n                        u.Gb = null;\n                    }\n                };\n            u._OrtCreateSession = s(u._OrtCreateSession, ()=>u._OrtCreateSession, (f)=>u._OrtCreateSession = f), u._OrtRun = c(s(u._OrtRun, ()=>u._OrtRun, (f)=>u._OrtRun = f)), u._OrtRunWithBinding = c(s(u._OrtRunWithBinding, ()=>u._OrtRunWithBinding, (f)=>u._OrtRunWithBinding = f)), u._OrtBindInput = s(u._OrtBindInput, ()=>u._OrtBindInput, (f)=>u._OrtBindInput = f), $ = void 0;\n        };\n        u.jsepInit = (s, c)=>{\n            if ($ === null || $ === void 0 ? void 0 : $(), s === \"webgpu\") {\n                [u.Hb, u.Vb, u.Zb, u.Ob, u.Yb, u.kb, u.$b, u.cc, u.Wb, u.Xb, u.ac] = c;\n                let f = u.Hb;\n                u.jsepRegisterBuffer = (b, w, I, O)=>f.registerBuffer(b, w, I, O), u.jsepGetBuffer = (b)=>f.getBuffer(b), u.jsepCreateDownloader = (b, w, I)=>f.createDownloader(b, w, I), u.jsepOnCreateSession = (b)=>{\n                    f.onCreateSession(b);\n                }, u.jsepOnReleaseSession = (b)=>{\n                    f.onReleaseSession(b);\n                }, u.jsepOnRunStart = (b)=>f.onRunStart(b), u.dc = (b, w)=>{\n                    f.upload(b, w);\n                };\n            } else if (s === \"webnn\") {\n                [u.Hb, u.bc, u.Pb, u.jsepEnsureTensor, u.ec, u.jsepDownloadTensor] = c, u.jsepReleaseTensorId = u.Pb;\n                let f = u.Hb;\n                u.jsepOnRunStart = (b)=>f.onRunStart(b), u.jsepRegisterMLContext = (b, w)=>{\n                    f.registerMLContext(b, w);\n                }, u.jsepOnReleaseSession = (b)=>{\n                    f.onReleaseSession(b);\n                }, u.jsepCreateMLTensorDownloader = (b, w)=>f.createMLTensorDownloader(b, w), u.jsepRegisterMLTensor = (b, w, I)=>f.registerMLTensor(b, w, I), u.jsepCreateMLContext = (b)=>f.createMLContext(b), u.jsepRegisterMLConstant = (b, w, I, O, B)=>f.registerMLConstant(b, w, I, O, B, u.Fb);\n            }\n        };\n        var v, S, T = Object.assign({}, u), A = \"./this.program\", k = (s, c)=>{\n            throw c;\n        }, P = \"\";\n        (_ || y) && (y ? P = self.location.href : typeof document < \"u\" && document.currentScript && (P = document.currentScript.src), Kn && (P = Kn), P = P.startsWith(\"blob:\") ? \"\" : P.substr(0, P.replace(/[?#].*/, \"\").lastIndexOf(\"/\") + 1), y && (S = (s)=>{\n            var c = new XMLHttpRequest;\n            return c.open(\"GET\", s, !1), c.responseType = \"arraybuffer\", c.send(null), new Uint8Array(c.response);\n        }), v = (s, c, f)=>{\n            var b = new XMLHttpRequest;\n            b.open(\"GET\", s, !0), b.responseType = \"arraybuffer\", b.onload = ()=>{\n                b.status == 200 || b.status == 0 && b.response ? c(b.response) : f();\n            }, b.onerror = f, b.send(null);\n        });\n        var D, R = console.log.bind(console), G = console.error.bind(console), K = R, j = G;\n        if (Object.assign(u, T), T = null, g) {\n            let s = function(c) {\n                try {\n                    var f = c.data, b = f.cmd;\n                    if (b === \"load\") {\n                        let w = [];\n                        self.onmessage = (I)=>w.push(I), self.startWorker = ()=>{\n                            postMessage({\n                                cmd: \"loaded\"\n                            });\n                            for (let I of w)s(I);\n                            self.onmessage = s;\n                        };\n                        for (let I of f.handlers)u[I] && !u[I].proxy || (u[I] = function() {\n                            for(var _len = arguments.length, O = new Array(_len), _key = 0; _key < _len; _key++){\n                                O[_key] = arguments[_key];\n                            }\n                            postMessage({\n                                Nb: \"callHandler\",\n                                pc: I,\n                                args: O\n                            });\n                        }, I == \"print\" && (K = u[I]), I == \"printErr\" && (j = u[I]));\n                        se = f.wasmMemory, ye(), V(f.wasmModule);\n                    } else if (b === \"run\") {\n                        Dn(f.pthread_ptr, 0, 0, 1, 0, 0), An(f.pthread_ptr), xc(), Ho(), Q || (Wi(), Q = !0);\n                        try {\n                            Sc(f.start_routine, f.arg);\n                        } catch (w) {\n                            if (w != \"unwind\") throw w;\n                        }\n                    } else b === \"cancel\" ? Mt() && hr(-1) : f.target !== \"setimmediate\" && (b === \"checkMailbox\" ? Q && ir() : b && (j(\"worker: received unknown command \".concat(b)), j(f)));\n                } catch (w) {\n                    throw Li(), w;\n                }\n            };\n            var wg = s, V, Q = !1;\n            j = function() {\n                for(var _len = arguments.length, c = new Array(_len), _key = 0; _key < _len; _key++){\n                    c[_key] = arguments[_key];\n                }\n                c = c.join(\" \"), console.error(c);\n            }, self.alert = function() {\n                for(var _len = arguments.length, c = new Array(_len), _key = 0; _key < _len; _key++){\n                    c[_key] = arguments[_key];\n                }\n                postMessage({\n                    Nb: \"alert\",\n                    text: c.join(\" \"),\n                    rc: Mt()\n                });\n            }, u.instantiateWasm = (c, f)=>new Promise((b)=>{\n                    V = (w)=>{\n                        w = new WebAssembly.Instance(w, No()), f(w), b();\n                    };\n                }), self.onunhandledrejection = (c)=>{\n                throw c.reason || c;\n            }, self.onmessage = s;\n        }\n        u.wasmBinary && (D = u.wasmBinary);\n        var se, Y, ee, J, ne, be, Oe, $e, le, W, q, he, Ge, we = !1;\n        function ye() {\n            var s = se.buffer;\n            u.HEAP8 = J = new Int8Array(s), u.HEAP16 = be = new Int16Array(s), u.HEAPU8 = ne = new Uint8Array(s), u.HEAPU16 = Oe = new Uint16Array(s), u.HEAP32 = $e = new Int32Array(s), u.HEAPU32 = le = new Uint32Array(s), u.HEAPF32 = W = new Float32Array(s), u.HEAPF64 = Ge = new Float64Array(s), u.HEAP64 = q = new BigInt64Array(s), u.HEAPU64 = he = new BigUint64Array(s);\n        }\n        if (!g) {\n            if (!((se = new WebAssembly.Memory({\n                initial: 256,\n                maximum: 65536,\n                shared: !0\n            })).buffer instanceof x)) throw j(\"requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag\"), Error(\"bad memory\");\n            ye();\n        }\n        var Ye = [], Lt = [], fn = [], Gt = 0, hn = null, Ht = null;\n        function Do() {\n            if (--Gt == 0 && (hn !== null && (clearInterval(hn), hn = null), Ht)) {\n                var s = Ht;\n                Ht = null, s();\n            }\n        }\n        function ct(s) {\n            throw j(s = \"Aborted(\" + s + \")\"), we = !0, ee = 1, s = new WebAssembly.RuntimeError(s + \". Build with -sASSERTIONS for more info.\"), m(s), s;\n        }\n        var gn, Bo = (s)=>s.startsWith(\"data:application/octet-stream;base64,\"), Mo = (s)=>s.startsWith(\"file://\");\n        function Ro(s) {\n            if (s == gn && D) return new Uint8Array(D);\n            if (S) return S(s);\n            throw \"both async and sync fetching of the wasm failed\";\n        }\n        function Uo(s, c, f) {\n            return (function(b) {\n                if (!D && (_ || y)) {\n                    if (typeof fetch == \"function\" && !Mo(b)) return fetch(b, {\n                        credentials: \"same-origin\"\n                    }).then((w)=>{\n                        if (!w.ok) throw \"failed to load wasm binary file at '\".concat(b, \"'\");\n                        return w.arrayBuffer();\n                    }).catch(()=>Ro(b));\n                    if (v) return new Promise((w, I)=>{\n                        v(b, (O)=>w(new Uint8Array(O)), I);\n                    });\n                }\n                return Promise.resolve().then(()=>Ro(b));\n            })(s).then((b)=>WebAssembly.instantiate(b, c)).then(f, (b)=>{\n                j(\"failed to asynchronously prepare wasm: \".concat(b)), ct(b);\n            });\n        }\n        function No() {\n            return {\n                a: {\n                    O: $c,\n                    Aa: vc,\n                    b: Ic,\n                    aa: jo,\n                    B: Qo,\n                    qa: Xo,\n                    Y: ei,\n                    _: ti,\n                    ra: ri,\n                    oa: ni,\n                    ha: oi,\n                    na: ii,\n                    L: ai,\n                    Z: si,\n                    W: ui,\n                    pa: di,\n                    X: li,\n                    va: Cc,\n                    F: kc,\n                    Q: Ec,\n                    P: zc,\n                    E: Dc,\n                    u: Bc,\n                    q: Mc,\n                    G: Rc,\n                    A: Hc,\n                    R: Fc,\n                    ua: qc,\n                    ka: Kc,\n                    U: jc,\n                    ba: Yc,\n                    H: Zc,\n                    ja: An,\n                    ta: Qc,\n                    t: Xc,\n                    Ba: Jc,\n                    x: rp,\n                    n: np,\n                    l: ip,\n                    c: In,\n                    o: ap,\n                    j: dp,\n                    w: lp,\n                    p: cp,\n                    f: pp,\n                    s: mp,\n                    m: fp,\n                    e: hp,\n                    k: gp,\n                    i: bp,\n                    h: yp,\n                    d: _p,\n                    ea: wp,\n                    fa: vp,\n                    ga: $p,\n                    ca: Si,\n                    da: Ti,\n                    T: xp,\n                    g: Sp,\n                    D: Tp,\n                    I: Ip,\n                    M: Cp,\n                    y: Ap,\n                    sa: kp,\n                    V: Ep,\n                    v: Ci,\n                    z: Pp,\n                    N: zp,\n                    S: Op,\n                    za: Dp,\n                    ya: Bp,\n                    la: Ei,\n                    ma: Pi,\n                    $: vn,\n                    C: zi,\n                    K: Oi,\n                    ia: Di,\n                    J: Bi,\n                    a: se,\n                    xa: wn,\n                    wa: Ui,\n                    r: Up\n                }\n            };\n        }\n        var bn = {\n            913700: (s, c, f, b, w)=>{\n                if (u === void 0 || !u.Fb) return 1;\n                if ((s = Ce(Number(s >>> 0))).startsWith(\"./\") && (s = s.substring(2)), !(s = u.Fb.get(s))) return 2;\n                if (c = Number(c >>> 0), f = Number(f >>> 0), b = Number(b >>> 0), c + f > s.byteLength) return 3;\n                try {\n                    let I = s.subarray(c, c + f);\n                    switch(w){\n                        case 0:\n                            r().set(I, b >>> 0);\n                            break;\n                        case 1:\n                            u.dc(b, I);\n                            break;\n                        default:\n                            return 4;\n                    }\n                    return 0;\n                } catch (e1) {\n                    return 4;\n                }\n            },\n            914415: (s, c, f)=>{\n                u.ec(s, r().subarray(c >>> 0, c + f >>> 0));\n            },\n            914478: ()=>u.bc(),\n            914519: (s)=>{\n                u.Pb(s);\n            },\n            914555: ()=>{\n                u.Wb();\n            },\n            914586: ()=>{\n                u.Xb();\n            },\n            914615: ()=>{\n                u.ac();\n            },\n            914640: (s)=>u.Vb(s),\n            914673: (s)=>u.Zb(s),\n            914705: (s, c, f)=>{\n                u.Ob(Number(s), Number(c), Number(f), !0);\n            },\n            914768: (s, c, f)=>{\n                u.Ob(Number(s), Number(c), Number(f));\n            },\n            914825: ()=>typeof wasmOffsetConverter < \"u\",\n            914882: (s)=>{\n                u.kb(\"Abs\", s, void 0);\n            },\n            914933: (s)=>{\n                u.kb(\"Neg\", s, void 0);\n            },\n            914984: (s)=>{\n                u.kb(\"Floor\", s, void 0);\n            },\n            915037: (s)=>{\n                u.kb(\"Ceil\", s, void 0);\n            },\n            915089: (s)=>{\n                u.kb(\"Reciprocal\", s, void 0);\n            },\n            915147: (s)=>{\n                u.kb(\"Sqrt\", s, void 0);\n            },\n            915199: (s)=>{\n                u.kb(\"Exp\", s, void 0);\n            },\n            915250: (s)=>{\n                u.kb(\"Erf\", s, void 0);\n            },\n            915301: (s)=>{\n                u.kb(\"Sigmoid\", s, void 0);\n            },\n            915356: (s, c, f)=>{\n                u.kb(\"HardSigmoid\", s, {\n                    alpha: c,\n                    beta: f\n                });\n            },\n            915435: (s)=>{\n                u.kb(\"Log\", s, void 0);\n            },\n            915486: (s)=>{\n                u.kb(\"Sin\", s, void 0);\n            },\n            915537: (s)=>{\n                u.kb(\"Cos\", s, void 0);\n            },\n            915588: (s)=>{\n                u.kb(\"Tan\", s, void 0);\n            },\n            915639: (s)=>{\n                u.kb(\"Asin\", s, void 0);\n            },\n            915691: (s)=>{\n                u.kb(\"Acos\", s, void 0);\n            },\n            915743: (s)=>{\n                u.kb(\"Atan\", s, void 0);\n            },\n            915795: (s)=>{\n                u.kb(\"Sinh\", s, void 0);\n            },\n            915847: (s)=>{\n                u.kb(\"Cosh\", s, void 0);\n            },\n            915899: (s)=>{\n                u.kb(\"Asinh\", s, void 0);\n            },\n            915952: (s)=>{\n                u.kb(\"Acosh\", s, void 0);\n            },\n            916005: (s)=>{\n                u.kb(\"Atanh\", s, void 0);\n            },\n            916058: (s)=>{\n                u.kb(\"Tanh\", s, void 0);\n            },\n            916110: (s)=>{\n                u.kb(\"Not\", s, void 0);\n            },\n            916161: (s, c, f)=>{\n                u.kb(\"Clip\", s, {\n                    min: c,\n                    max: f\n                });\n            },\n            916230: (s)=>{\n                u.kb(\"Clip\", s, void 0);\n            },\n            916282: (s, c)=>{\n                u.kb(\"Elu\", s, {\n                    alpha: c\n                });\n            },\n            916340: (s)=>{\n                u.kb(\"Gelu\", s, void 0);\n            },\n            916392: (s)=>{\n                u.kb(\"Relu\", s, void 0);\n            },\n            916444: (s, c)=>{\n                u.kb(\"LeakyRelu\", s, {\n                    alpha: c\n                });\n            },\n            916508: (s, c)=>{\n                u.kb(\"ThresholdedRelu\", s, {\n                    alpha: c\n                });\n            },\n            916578: (s, c)=>{\n                u.kb(\"Cast\", s, {\n                    to: c\n                });\n            },\n            916636: (s)=>{\n                u.kb(\"Add\", s, void 0);\n            },\n            916687: (s)=>{\n                u.kb(\"Sub\", s, void 0);\n            },\n            916738: (s)=>{\n                u.kb(\"Mul\", s, void 0);\n            },\n            916789: (s)=>{\n                u.kb(\"Div\", s, void 0);\n            },\n            916840: (s)=>{\n                u.kb(\"Pow\", s, void 0);\n            },\n            916891: (s)=>{\n                u.kb(\"Equal\", s, void 0);\n            },\n            916944: (s)=>{\n                u.kb(\"Greater\", s, void 0);\n            },\n            916999: (s)=>{\n                u.kb(\"GreaterOrEqual\", s, void 0);\n            },\n            917061: (s)=>{\n                u.kb(\"Less\", s, void 0);\n            },\n            917113: (s)=>{\n                u.kb(\"LessOrEqual\", s, void 0);\n            },\n            917172: (s, c, f, b, w)=>{\n                u.kb(\"ReduceMean\", s, {\n                    keepDims: !!c,\n                    noopWithEmptyAxes: !!f,\n                    axes: b ? Array.from(i().subarray(Number(b) >>> 0, Number(w) >>> 0)) : []\n                });\n            },\n            917347: (s, c, f, b, w)=>{\n                u.kb(\"ReduceMax\", s, {\n                    keepDims: !!c,\n                    noopWithEmptyAxes: !!f,\n                    axes: b ? Array.from(i().subarray(Number(b) >>> 0, Number(w) >>> 0)) : []\n                });\n            },\n            917521: (s, c, f, b, w)=>{\n                u.kb(\"ReduceMin\", s, {\n                    keepDims: !!c,\n                    noopWithEmptyAxes: !!f,\n                    axes: b ? Array.from(i().subarray(Number(b) >>> 0, Number(w) >>> 0)) : []\n                });\n            },\n            917695: (s, c, f, b, w)=>{\n                u.kb(\"ReduceProd\", s, {\n                    keepDims: !!c,\n                    noopWithEmptyAxes: !!f,\n                    axes: b ? Array.from(i().subarray(Number(b) >>> 0, Number(w) >>> 0)) : []\n                });\n            },\n            917870: (s, c, f, b, w)=>{\n                u.kb(\"ReduceSum\", s, {\n                    keepDims: !!c,\n                    noopWithEmptyAxes: !!f,\n                    axes: b ? Array.from(i().subarray(Number(b) >>> 0, Number(w) >>> 0)) : []\n                });\n            },\n            918044: (s, c, f, b, w)=>{\n                u.kb(\"ReduceL1\", s, {\n                    keepDims: !!c,\n                    noopWithEmptyAxes: !!f,\n                    axes: b ? Array.from(i().subarray(Number(b) >>> 0, Number(w) >>> 0)) : []\n                });\n            },\n            918217: (s, c, f, b, w)=>{\n                u.kb(\"ReduceL2\", s, {\n                    keepDims: !!c,\n                    noopWithEmptyAxes: !!f,\n                    axes: b ? Array.from(i().subarray(Number(b) >>> 0, Number(w) >>> 0)) : []\n                });\n            },\n            918390: (s, c, f, b, w)=>{\n                u.kb(\"ReduceLogSum\", s, {\n                    keepDims: !!c,\n                    noopWithEmptyAxes: !!f,\n                    axes: b ? Array.from(i().subarray(Number(b) >>> 0, Number(w) >>> 0)) : []\n                });\n            },\n            918567: (s, c, f, b, w)=>{\n                u.kb(\"ReduceSumSquare\", s, {\n                    keepDims: !!c,\n                    noopWithEmptyAxes: !!f,\n                    axes: b ? Array.from(i().subarray(Number(b) >>> 0, Number(w) >>> 0)) : []\n                });\n            },\n            918747: (s, c, f, b, w)=>{\n                u.kb(\"ReduceLogSumExp\", s, {\n                    keepDims: !!c,\n                    noopWithEmptyAxes: !!f,\n                    axes: b ? Array.from(i().subarray(Number(b) >>> 0, Number(w) >>> 0)) : []\n                });\n            },\n            918927: (s)=>{\n                u.kb(\"Where\", s, void 0);\n            },\n            918980: (s, c, f)=>{\n                u.kb(\"Transpose\", s, {\n                    perm: c ? Array.from(i().subarray(Number(c) >>> 0, Number(f) >>> 0)) : []\n                });\n            },\n            919104: (s, c, f, b)=>{\n                u.kb(\"DepthToSpace\", s, {\n                    blocksize: c,\n                    mode: Ce(f),\n                    format: b ? \"NHWC\" : \"NCHW\"\n                });\n            },\n            919237: (s, c, f, b)=>{\n                u.kb(\"DepthToSpace\", s, {\n                    blocksize: c,\n                    mode: Ce(f),\n                    format: b ? \"NHWC\" : \"NCHW\"\n                });\n            },\n            919370: (s, c, f, b, w, I, O, B, L, H, X, ce, ge, z, de)=>{\n                u.kb(\"ConvTranspose\", s, {\n                    format: L ? \"NHWC\" : \"NCHW\",\n                    autoPad: c,\n                    dilations: [\n                        f\n                    ],\n                    group: b,\n                    kernelShape: [\n                        w\n                    ],\n                    pads: [\n                        I,\n                        O\n                    ],\n                    strides: [\n                        B\n                    ],\n                    wIsConst: ()=>!!t()[H >>> 0],\n                    outputPadding: X ? Array.from(i().subarray(Number(X) >>> 0, Number(ce) >>> 0)) : [],\n                    outputShape: ge ? Array.from(i().subarray(Number(ge) >>> 0, Number(z) >>> 0)) : [],\n                    activation: Ce(de)\n                });\n            },\n            919803: (s, c, f, b, w, I, O, B, L, H, X, ce, ge, z)=>{\n                u.kb(\"ConvTranspose\", s, {\n                    format: B ? \"NHWC\" : \"NCHW\",\n                    autoPad: c,\n                    dilations: Array.from(i().subarray(Number(f) >>> 0, 2 + (Number(f) >>> 0) >>> 0)),\n                    group: b,\n                    kernelShape: Array.from(i().subarray(Number(w) >>> 0, 2 + (Number(w) >>> 0) >>> 0)),\n                    pads: Array.from(i().subarray(Number(I) >>> 0, 4 + (Number(I) >>> 0) >>> 0)),\n                    strides: Array.from(i().subarray(Number(O) >>> 0, 2 + (Number(O) >>> 0) >>> 0)),\n                    wIsConst: ()=>!!t()[L >>> 0],\n                    outputPadding: H ? Array.from(i().subarray(Number(H) >>> 0, Number(X) >>> 0)) : [],\n                    outputShape: ce ? Array.from(i().subarray(Number(ce) >>> 0, Number(ge) >>> 0)) : [],\n                    activation: Ce(z)\n                });\n            },\n            920464: (s, c, f, b, w, I, O, B, L, H, X, ce, ge, z, de)=>{\n                u.kb(\"ConvTranspose\", s, {\n                    format: L ? \"NHWC\" : \"NCHW\",\n                    autoPad: c,\n                    dilations: [\n                        f\n                    ],\n                    group: b,\n                    kernelShape: [\n                        w\n                    ],\n                    pads: [\n                        I,\n                        O\n                    ],\n                    strides: [\n                        B\n                    ],\n                    wIsConst: ()=>!!t()[H >>> 0],\n                    outputPadding: X ? Array.from(i().subarray(Number(X) >>> 0, Number(ce) >>> 0)) : [],\n                    outputShape: ge ? Array.from(i().subarray(Number(ge) >>> 0, Number(z) >>> 0)) : [],\n                    activation: Ce(de)\n                });\n            },\n            920897: (s, c, f, b, w, I, O, B, L, H, X, ce, ge, z)=>{\n                u.kb(\"ConvTranspose\", s, {\n                    format: B ? \"NHWC\" : \"NCHW\",\n                    autoPad: c,\n                    dilations: Array.from(i().subarray(Number(f) >>> 0, 2 + (Number(f) >>> 0) >>> 0)),\n                    group: b,\n                    kernelShape: Array.from(i().subarray(Number(w) >>> 0, 2 + (Number(w) >>> 0) >>> 0)),\n                    pads: Array.from(i().subarray(Number(I) >>> 0, 4 + (Number(I) >>> 0) >>> 0)),\n                    strides: Array.from(i().subarray(Number(O) >>> 0, 2 + (Number(O) >>> 0) >>> 0)),\n                    wIsConst: ()=>!!t()[L >>> 0],\n                    outputPadding: H ? Array.from(i().subarray(Number(H) >>> 0, Number(X) >>> 0)) : [],\n                    outputShape: ce ? Array.from(i().subarray(Number(ce) >>> 0, Number(ge) >>> 0)) : [],\n                    activation: Ce(z)\n                });\n            },\n            921558: (s, c)=>{\n                u.kb(\"GlobalAveragePool\", s, {\n                    format: c ? \"NHWC\" : \"NCHW\"\n                });\n            },\n            921649: (s, c, f, b, w, I, O, B, L, H, X, ce, ge, z)=>{\n                u.kb(\"AveragePool\", s, {\n                    format: z ? \"NHWC\" : \"NCHW\",\n                    auto_pad: c,\n                    ceil_mode: f,\n                    count_include_pad: b,\n                    storage_order: w,\n                    dilations: I ? Array.from(i().subarray(Number(I) >>> 0, Number(O) >>> 0)) : [],\n                    kernel_shape: B ? Array.from(i().subarray(Number(B) >>> 0, Number(L) >>> 0)) : [],\n                    pads: H ? Array.from(i().subarray(Number(H) >>> 0, Number(X) >>> 0)) : [],\n                    strides: ce ? Array.from(i().subarray(Number(ce) >>> 0, Number(ge) >>> 0)) : []\n                });\n            },\n            922128: (s, c)=>{\n                u.kb(\"GlobalAveragePool\", s, {\n                    format: c ? \"NHWC\" : \"NCHW\"\n                });\n            },\n            922219: (s, c, f, b, w, I, O, B, L, H, X, ce, ge, z)=>{\n                u.kb(\"AveragePool\", s, {\n                    format: z ? \"NHWC\" : \"NCHW\",\n                    auto_pad: c,\n                    ceil_mode: f,\n                    count_include_pad: b,\n                    storage_order: w,\n                    dilations: I ? Array.from(i().subarray(Number(I) >>> 0, Number(O) >>> 0)) : [],\n                    kernel_shape: B ? Array.from(i().subarray(Number(B) >>> 0, Number(L) >>> 0)) : [],\n                    pads: H ? Array.from(i().subarray(Number(H) >>> 0, Number(X) >>> 0)) : [],\n                    strides: ce ? Array.from(i().subarray(Number(ce) >>> 0, Number(ge) >>> 0)) : []\n                });\n            },\n            922698: (s, c)=>{\n                u.kb(\"GlobalMaxPool\", s, {\n                    format: c ? \"NHWC\" : \"NCHW\"\n                });\n            },\n            922785: (s, c, f, b, w, I, O, B, L, H, X, ce, ge, z)=>{\n                u.kb(\"MaxPool\", s, {\n                    format: z ? \"NHWC\" : \"NCHW\",\n                    auto_pad: c,\n                    ceil_mode: f,\n                    count_include_pad: b,\n                    storage_order: w,\n                    dilations: I ? Array.from(i().subarray(Number(I) >>> 0, Number(O) >>> 0)) : [],\n                    kernel_shape: B ? Array.from(i().subarray(Number(B) >>> 0, Number(L) >>> 0)) : [],\n                    pads: H ? Array.from(i().subarray(Number(H) >>> 0, Number(X) >>> 0)) : [],\n                    strides: ce ? Array.from(i().subarray(Number(ce) >>> 0, Number(ge) >>> 0)) : []\n                });\n            },\n            923260: (s, c)=>{\n                u.kb(\"GlobalMaxPool\", s, {\n                    format: c ? \"NHWC\" : \"NCHW\"\n                });\n            },\n            923347: (s, c, f, b, w, I, O, B, L, H, X, ce, ge, z)=>{\n                u.kb(\"MaxPool\", s, {\n                    format: z ? \"NHWC\" : \"NCHW\",\n                    auto_pad: c,\n                    ceil_mode: f,\n                    count_include_pad: b,\n                    storage_order: w,\n                    dilations: I ? Array.from(i().subarray(Number(I) >>> 0, Number(O) >>> 0)) : [],\n                    kernel_shape: B ? Array.from(i().subarray(Number(B) >>> 0, Number(L) >>> 0)) : [],\n                    pads: H ? Array.from(i().subarray(Number(H) >>> 0, Number(X) >>> 0)) : [],\n                    strides: ce ? Array.from(i().subarray(Number(ce) >>> 0, Number(ge) >>> 0)) : []\n                });\n            },\n            923822: (s, c, f, b, w)=>{\n                u.kb(\"Gemm\", s, {\n                    alpha: c,\n                    beta: f,\n                    transA: b,\n                    transB: w\n                });\n            },\n            923926: (s)=>{\n                u.kb(\"MatMul\", s, void 0);\n            },\n            923980: (s, c, f, b)=>{\n                u.kb(\"ArgMax\", s, {\n                    keepDims: !!c,\n                    selectLastIndex: !!f,\n                    axis: b\n                });\n            },\n            924088: (s, c, f, b)=>{\n                u.kb(\"ArgMin\", s, {\n                    keepDims: !!c,\n                    selectLastIndex: !!f,\n                    axis: b\n                });\n            },\n            924196: (s, c)=>{\n                u.kb(\"Softmax\", s, {\n                    axis: c\n                });\n            },\n            924259: (s, c)=>{\n                u.kb(\"Concat\", s, {\n                    axis: c\n                });\n            },\n            924319: (s, c, f, b, w)=>{\n                u.kb(\"Split\", s, {\n                    axis: c,\n                    numOutputs: f,\n                    splitSizes: b ? Array.from(i().subarray(Number(b) >>> 0, Number(w) >>> 0)) : []\n                });\n            },\n            924475: (s)=>{\n                u.kb(\"Expand\", s, void 0);\n            },\n            924529: (s, c)=>{\n                u.kb(\"Gather\", s, {\n                    axis: Number(c)\n                });\n            },\n            924600: (s, c)=>{\n                u.kb(\"GatherElements\", s, {\n                    axis: Number(c)\n                });\n            },\n            924679: (s, c)=>{\n                u.kb(\"GatherND\", s, {\n                    batch_dims: Number(c)\n                });\n            },\n            924758: (s, c, f, b, w, I, O, B, L, H, X)=>{\n                u.kb(\"Resize\", s, {\n                    antialias: c,\n                    axes: f ? Array.from(i().subarray(Number(f) >>> 0, Number(b) >>> 0)) : [],\n                    coordinateTransformMode: Ce(w),\n                    cubicCoeffA: I,\n                    excludeOutside: O,\n                    extrapolationValue: B,\n                    keepAspectRatioPolicy: Ce(L),\n                    mode: Ce(H),\n                    nearestMode: Ce(X)\n                });\n            },\n            925120: (s, c, f, b, w, I, O)=>{\n                u.kb(\"Slice\", s, {\n                    starts: c ? Array.from(i().subarray(Number(c) >>> 0, Number(f) >>> 0)) : [],\n                    ends: b ? Array.from(i().subarray(Number(b) >>> 0, Number(w) >>> 0)) : [],\n                    axes: I ? Array.from(i().subarray(Number(I) >>> 0, Number(O) >>> 0)) : []\n                });\n            },\n            925384: (s)=>{\n                u.kb(\"Tile\", s, void 0);\n            },\n            925436: (s, c, f)=>{\n                u.kb(\"InstanceNormalization\", s, {\n                    epsilon: c,\n                    format: f ? \"NHWC\" : \"NCHW\"\n                });\n            },\n            925550: (s, c, f)=>{\n                u.kb(\"InstanceNormalization\", s, {\n                    epsilon: c,\n                    format: f ? \"NHWC\" : \"NCHW\"\n                });\n            },\n            925664: (s)=>{\n                u.kb(\"Range\", s, void 0);\n            },\n            925717: (s, c)=>{\n                u.kb(\"Einsum\", s, {\n                    equation: Ce(c)\n                });\n            },\n            925798: (s, c, f, b, w)=>{\n                u.kb(\"Pad\", s, {\n                    mode: c,\n                    value: f,\n                    pads: b ? Array.from(i().subarray(Number(b) >>> 0, Number(w) >>> 0)) : []\n                });\n            },\n            925941: (s, c, f, b, w, I)=>{\n                u.kb(\"BatchNormalization\", s, {\n                    epsilon: c,\n                    momentum: f,\n                    spatial: !!w,\n                    trainingMode: !!b,\n                    format: I ? \"NHWC\" : \"NCHW\"\n                });\n            },\n            926110: (s, c, f, b, w, I)=>{\n                u.kb(\"BatchNormalization\", s, {\n                    epsilon: c,\n                    momentum: f,\n                    spatial: !!w,\n                    trainingMode: !!b,\n                    format: I ? \"NHWC\" : \"NCHW\"\n                });\n            },\n            926279: (s, c, f)=>{\n                u.kb(\"CumSum\", s, {\n                    exclusive: Number(c),\n                    reverse: Number(f)\n                });\n            },\n            926376: (s, c, f)=>{\n                u.kb(\"DequantizeLinear\", s, {\n                    axis: c,\n                    blockSize: f\n                });\n            },\n            926466: (s, c, f, b, w)=>{\n                u.kb(\"GridSample\", s, {\n                    align_corners: c,\n                    mode: Ce(f),\n                    padding_mode: Ce(b),\n                    format: w ? \"NHWC\" : \"NCHW\"\n                });\n            },\n            926636: (s, c, f, b, w)=>{\n                u.kb(\"GridSample\", s, {\n                    align_corners: c,\n                    mode: Ce(f),\n                    padding_mode: Ce(b),\n                    format: w ? \"NHWC\" : \"NCHW\"\n                });\n            },\n            926806: (s, c, f, b, w, I, O, B, L)=>{\n                u.kb(\"Attention\", s, {\n                    numHeads: c,\n                    isUnidirectional: f,\n                    maskFilterValue: b,\n                    scale: w,\n                    doRotary: I,\n                    qkvHiddenSizes: O ? Array.from(i().subarray(Number(B) >>> 0, Number(B) + O >>> 0)) : [],\n                    pastPresentShareBuffer: !!L\n                });\n            },\n            927078: (s)=>{\n                u.kb(\"BiasAdd\", s, void 0);\n            },\n            927133: (s)=>{\n                u.kb(\"BiasSplitGelu\", s, void 0);\n            },\n            927194: (s)=>{\n                u.kb(\"FastGelu\", s, void 0);\n            },\n            927250: (s, c, f, b, w, I, O, B, L, H, X, ce, ge, z, de, Te)=>{\n                u.kb(\"Conv\", s, {\n                    format: ce ? \"NHWC\" : \"NCHW\",\n                    auto_pad: c,\n                    dilations: f ? Array.from(i().subarray(Number(f) >>> 0, Number(b) >>> 0)) : [],\n                    group: w,\n                    kernel_shape: I ? Array.from(i().subarray(Number(I) >>> 0, Number(O) >>> 0)) : [],\n                    pads: B ? Array.from(i().subarray(Number(B) >>> 0, Number(L) >>> 0)) : [],\n                    strides: H ? Array.from(i().subarray(Number(H) >>> 0, Number(X) >>> 0)) : [],\n                    w_is_const: ()=>!!t()[Number(ge) >>> 0],\n                    activation: Ce(z),\n                    activation_params: de ? Array.from(d().subarray(Number(de) >>> 0, Number(Te) >>> 0)) : []\n                });\n            },\n            927834: (s)=>{\n                u.kb(\"Gelu\", s, void 0);\n            },\n            927886: (s, c, f, b, w, I, O, B, L)=>{\n                u.kb(\"GroupQueryAttention\", s, {\n                    numHeads: c,\n                    kvNumHeads: f,\n                    scale: b,\n                    softcap: w,\n                    doRotary: I,\n                    rotaryInterleaved: O,\n                    smoothSoftmax: B,\n                    localWindowSize: L\n                });\n            },\n            928103: (s, c, f, b)=>{\n                u.kb(\"LayerNormalization\", s, {\n                    axis: c,\n                    epsilon: f,\n                    simplified: !!b\n                });\n            },\n            928214: (s, c, f, b)=>{\n                u.kb(\"LayerNormalization\", s, {\n                    axis: c,\n                    epsilon: f,\n                    simplified: !!b\n                });\n            },\n            928325: (s, c, f, b, w, I)=>{\n                u.kb(\"MatMulNBits\", s, {\n                    k: c,\n                    n: f,\n                    accuracyLevel: b,\n                    bits: w,\n                    blockSize: I\n                });\n            },\n            928452: (s, c, f, b, w, I)=>{\n                u.kb(\"MultiHeadAttention\", s, {\n                    numHeads: c,\n                    isUnidirectional: f,\n                    maskFilterValue: b,\n                    scale: w,\n                    doRotary: I\n                });\n            },\n            928611: (s, c)=>{\n                u.kb(\"QuickGelu\", s, {\n                    alpha: c\n                });\n            },\n            928675: (s, c, f, b, w)=>{\n                u.kb(\"RotaryEmbedding\", s, {\n                    interleaved: !!c,\n                    numHeads: f,\n                    rotaryEmbeddingDim: b,\n                    scale: w\n                });\n            },\n            928814: (s, c, f)=>{\n                u.kb(\"SkipLayerNormalization\", s, {\n                    epsilon: c,\n                    simplified: !!f\n                });\n            },\n            928916: (s, c, f)=>{\n                u.kb(\"SkipLayerNormalization\", s, {\n                    epsilon: c,\n                    simplified: !!f\n                });\n            },\n            929018: (s, c, f, b)=>{\n                u.kb(\"GatherBlockQuantized\", s, {\n                    gatherAxis: c,\n                    quantizeAxis: f,\n                    blockSize: b\n                });\n            },\n            929139: (s)=>{\n                u.$b(s);\n            },\n            929173: (s, c)=>u.cc(Number(s), Number(c), u.Gb.hc, u.Gb.errors)\n        };\n        function vc(s, c, f) {\n            return _i(async ()=>{\n                await u.Yb(Number(s), Number(c), Number(f));\n            });\n        }\n        function $c() {\n            return typeof wasmOffsetConverter < \"u\";\n        }\n        function yn(s) {\n            this.name = \"ExitStatus\", this.message = \"Program terminated with exit(\".concat(s, \")\"), this.status = s;\n        }\n        var _n = (s)=>{\n            s.terminate(), s.onmessage = ()=>{};\n        }, Vo = (s)=>{\n            pt.length == 0 && (qo(), Fo(pt[0]));\n            var c = pt.pop();\n            if (!c) return 6;\n            vt.push(c), Ze[s.Bb] = c, c.Bb = s.Bb;\n            var f = {\n                cmd: \"run\",\n                start_routine: s.ic,\n                arg: s.Rb,\n                pthread_ptr: s.Bb\n            };\n            return c.postMessage(f, s.nc), 0;\n        }, wt = 0, xe = function(s, c) {\n            for(var _len = arguments.length, f = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){\n                f[_key - 2] = arguments[_key];\n            }\n            for(var b = 2 * f.length, w = Rn(), I = Mn(8 * b), O = I >>> 3, B = 0; B < f.length; B++){\n                var L = f[B];\n                typeof L == \"bigint\" ? (q[O + 2 * B] = 1n, q[O + 2 * B + 1] = L) : (q[O + 2 * B] = 0n, l()[O + 2 * B + 1 >>> 0] = L);\n            }\n            return s = Gi(s, 0, b, I, c), gr(w), s;\n        };\n        function wn(s) {\n            if (g) return xe(0, 1, s);\n            if (ee = s, !(0 < wt)) {\n                for (var c of vt)_n(c);\n                for (c of pt)_n(c);\n                pt = [], vt = [], Ze = [], we = !0;\n            }\n            k(s, new yn(s));\n        }\n        function Wo(s) {\n            if (g) return xe(1, 0, s);\n            vn(s);\n        }\n        var vn = (s)=>{\n            if (ee = s, g) throw Wo(s), \"unwind\";\n            wn(s);\n        }, pt = [], vt = [], Lo = [], Ze = {}, Go = (s)=>{\n            var c = s.Bb;\n            delete Ze[c], pt.push(s), vt.splice(vt.indexOf(s), 1), s.Bb = 0, Bn(c);\n        };\n        function Ho() {\n            Lo.forEach((s)=>s());\n        }\n        var Fo = (s)=>new Promise((c)=>{\n                s.onmessage = (w)=>{\n                    var I = (w = w.data).cmd;\n                    if (w.targetThread && w.targetThread != Mt()) {\n                        var O = Ze[w.targetThread];\n                        O ? O.postMessage(w, w.transferList) : j('Internal error! Worker sent a message \"'.concat(I, '\" to target pthread ').concat(w.targetThread, \", but that thread no longer exists!\"));\n                    } else I === \"checkMailbox\" ? ir() : I === \"spawnThread\" ? Vo(w) : I === \"cleanupThread\" ? Go(Ze[w.thread]) : I === \"killThread\" ? (w = w.thread, I = Ze[w], delete Ze[w], _n(I), Bn(w), vt.splice(vt.indexOf(I), 1), I.Bb = 0) : I === \"cancelThread\" ? Ze[w.thread].postMessage({\n                        cmd: \"cancel\"\n                    }) : I === \"loaded\" ? (s.loaded = !0, c(s)) : I === \"alert\" ? alert(\"Thread \".concat(w.threadId, \": \").concat(w.text)) : w.target === \"setimmediate\" ? s.postMessage(w) : I === \"callHandler\" ? u[w.handler](...w.args) : I && j(\"worker sent an unknown command \".concat(I));\n                }, s.onerror = (w)=>{\n                    throw j(\"worker sent an error! \".concat(w.filename, \":\").concat(w.lineno, \": \").concat(w.message)), w;\n                };\n                var f, b = [];\n                for (f of [])u.hasOwnProperty(f) && b.push(f);\n                s.postMessage({\n                    cmd: \"load\",\n                    handlers: b,\n                    wasmMemory: se,\n                    wasmModule: Y\n                });\n            });\n        function qo() {\n            var s = new Worker(\"file:///Users/amityadav/Desktop/Text-Behind%20Image/node_modules/onnxruntime-web/dist/ort.bundle.min.mjs\".startsWith(\"file:\") ? /* asset import */ new __webpack_require__.U(__webpack_require__(/*! ort.bundle.min.mjs */ \"(app-pages-browser)/./node_modules/onnxruntime-web/dist/ort.bundle.min.mjs?4b98\")) : new URL(\"file:///Users/amityadav/Desktop/Text-Behind%20Image/node_modules/onnxruntime-web/dist/ort.bundle.min.mjs\"), {\n                type: \"module\",\n                workerData: \"em-pthread\",\n                name: \"em-pthread\"\n            });\n            pt.push(s);\n        }\n        var or = (s)=>{\n            for(; 0 < s.length;)s.shift()(u);\n        }, xc = ()=>{\n            var s = Mt(), c = a()[s + 52 >>> 2 >>> 0];\n            s = a()[s + 56 >>> 2 >>> 0], Fi(c, c - s), gr(c);\n        }, Sc = (s, c)=>{\n            wt = 0, s = qi(s, c), 0 < wt ? ee = s : hr(s);\n        };\n        class Tc {\n            constructor(c){\n                this.Kb = c - 24;\n            }\n        }\n        function Ic(s, c, f) {\n            var b = new Tc(s >>>= 0);\n            throw c >>>= 0, f >>>= 0, a()[b.Kb + 16 >>> 2 >>> 0] = 0, a()[b.Kb + 4 >>> 2 >>> 0] = c, a()[b.Kb + 8 >>> 2 >>> 0] = f, s;\n        }\n        function Ko(s, c, f, b) {\n            return g ? xe(2, 1, s, c, f, b) : jo(s, c, f, b);\n        }\n        function jo(s, c, f, b) {\n            if (s >>>= 0, c >>>= 0, f >>>= 0, b >>>= 0, x === void 0) return j(\"Current environment does not support SharedArrayBuffer, pthreads are not available!\"), 6;\n            var w = [];\n            return g && w.length === 0 ? Ko(s, c, f, b) : (s = {\n                ic: f,\n                Bb: s,\n                Rb: b,\n                nc: w\n            }, g ? (s.Nb = \"spawnThread\", postMessage(s, w), 0) : Vo(s));\n        }\n        var Yo = typeof TextDecoder < \"u\" ? new TextDecoder(\"utf8\") : void 0, Zo = (s, c, f)=>{\n            var b = (c >>>= 0) + f;\n            for(f = c; s[f] && !(f >= b);)++f;\n            if (16 < f - c && s.buffer && Yo) return Yo.decode(s.buffer instanceof x ? s.slice(c, f) : s.subarray(c, f));\n            for(b = \"\"; c < f;){\n                var w = s[c++];\n                if (128 & w) {\n                    var I = 63 & s[c++];\n                    if ((224 & w) == 192) b += String.fromCharCode((31 & w) << 6 | I);\n                    else {\n                        var O = 63 & s[c++];\n                        65536 > (w = (240 & w) == 224 ? (15 & w) << 12 | I << 6 | O : (7 & w) << 18 | I << 12 | O << 6 | 63 & s[c++]) ? b += String.fromCharCode(w) : (w -= 65536, b += String.fromCharCode(55296 | w >> 10, 56320 | 1023 & w));\n                    }\n                } else b += String.fromCharCode(w);\n            }\n            return b;\n        }, Ce = (s, c)=>(s >>>= 0) ? Zo(r(), s, c) : \"\";\n        function Qo(s, c, f) {\n            return g ? xe(3, 1, s, c, f) : 0;\n        }\n        function Xo(s, c) {\n            if (g) return xe(4, 1, s, c);\n        }\n        var $n = (s)=>{\n            for(var c = 0, f = 0; f < s.length; ++f){\n                var b = s.charCodeAt(f);\n                127 >= b ? c++ : 2047 >= b ? c += 2 : 55296 <= b && 57343 >= b ? (c += 4, ++f) : c += 3;\n            }\n            return c;\n        }, Jo = (s, c, f, b)=>{\n            if (!(0 < b)) return 0;\n            var w = f >>>= 0;\n            b = f + b - 1;\n            for(var I = 0; I < s.length; ++I){\n                var O = s.charCodeAt(I);\n                if (55296 <= O && 57343 >= O && (O = 65536 + ((1023 & O) << 10) | 1023 & s.charCodeAt(++I)), 127 >= O) {\n                    if (f >= b) break;\n                    c[f++ >>> 0] = O;\n                } else {\n                    if (2047 >= O) {\n                        if (f + 1 >= b) break;\n                        c[f++ >>> 0] = 192 | O >> 6;\n                    } else {\n                        if (65535 >= O) {\n                            if (f + 2 >= b) break;\n                            c[f++ >>> 0] = 224 | O >> 12;\n                        } else {\n                            if (f + 3 >= b) break;\n                            c[f++ >>> 0] = 240 | O >> 18, c[f++ >>> 0] = 128 | O >> 12 & 63;\n                        }\n                        c[f++ >>> 0] = 128 | O >> 6 & 63;\n                    }\n                    c[f++ >>> 0] = 128 | 63 & O;\n                }\n            }\n            return c[f >>> 0] = 0, f - w;\n        }, Ot = (s, c, f)=>Jo(s, r(), c, f);\n        function ei(s, c) {\n            if (g) return xe(5, 1, s, c);\n        }\n        function ti(s, c, f) {\n            if (g) return xe(6, 1, s, c, f);\n        }\n        function ri(s, c, f) {\n            return g ? xe(7, 1, s, c, f) : 0;\n        }\n        function ni(s, c) {\n            if (g) return xe(8, 1, s, c);\n        }\n        function oi(s, c, f) {\n            if (g) return xe(9, 1, s, c, f);\n        }\n        function ii(s, c, f, b) {\n            if (g) return xe(10, 1, s, c, f, b);\n        }\n        function ai(s, c, f, b) {\n            if (g) return xe(11, 1, s, c, f, b);\n        }\n        function si(s, c, f, b) {\n            if (g) return xe(12, 1, s, c, f, b);\n        }\n        function ui(s) {\n            if (g) return xe(13, 1, s);\n        }\n        function di(s, c) {\n            if (g) return xe(14, 1, s, c);\n        }\n        function li(s, c, f) {\n            if (g) return xe(15, 1, s, c, f);\n        }\n        var ci, mt, Cc = ()=>{\n            ct(\"\");\n        }, Qe = (s)=>{\n            for(var c = \"\"; r()[s >>> 0];)c += ci[r()[s++ >>> 0]];\n            return c;\n        }, xn = {}, Sn = {}, Ac = {};\n        function st(s, c) {\n            let f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n            if (!(\"argPackAdvance\" in c)) throw new TypeError(\"registerType registeredInstance requires argPackAdvance\");\n            return function(b, w) {\n                let I = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n                var O = w.name;\n                if (!b) throw new mt('type \"'.concat(O, '\" must have a positive integer typeid pointer'));\n                if (Sn.hasOwnProperty(b)) {\n                    if (I.Tb) return;\n                    throw new mt(\"Cannot register type '\".concat(O, \"' twice\"));\n                }\n                Sn[b] = w, delete Ac[b], xn.hasOwnProperty(b) && (w = xn[b], delete xn[b], w.forEach((B)=>B()));\n            }(s, c, f);\n        }\n        var pi = (s, c, f)=>{\n            switch(c){\n                case 1:\n                    return f ? (b)=>t()[b >>> 0] : (b)=>r()[b >>> 0];\n                case 2:\n                    return f ? (b)=>n()[b >>> 1 >>> 0] : (b)=>o()[b >>> 1 >>> 0];\n                case 4:\n                    return f ? (b)=>i()[b >>> 2 >>> 0] : (b)=>a()[b >>> 2 >>> 0];\n                case 8:\n                    return f ? (b)=>q[b >>> 3] : (b)=>he[b >>> 3];\n                default:\n                    throw new TypeError(\"invalid integer width (\".concat(c, \"): \").concat(s));\n            }\n        };\n        function kc(s, c, f) {\n            f >>>= 0, st(s >>>= 0, {\n                name: c = Qe(c >>> 0),\n                fromWireType: (b)=>b,\n                toWireType: function(b, w) {\n                    if (typeof w != \"bigint\" && typeof w != \"number\") throw w = w === null ? \"null\" : (b = typeof w) == \"object\" || b === \"array\" || b === \"function\" ? w.toString() : \"\" + w, new TypeError('Cannot convert \"'.concat(w, '\" to ').concat(this.name));\n                    return typeof w == \"number\" && (w = BigInt(w)), w;\n                },\n                argPackAdvance: ft,\n                readValueFromPointer: pi(c, f, c.indexOf(\"u\") == -1),\n                Eb: null\n            });\n        }\n        var ft = 8;\n        function Ec(s, c, f, b) {\n            st(s >>>= 0, {\n                name: c = Qe(c >>> 0),\n                fromWireType: function(w) {\n                    return !!w;\n                },\n                toWireType: function(w, I) {\n                    return I ? f : b;\n                },\n                argPackAdvance: ft,\n                readValueFromPointer: function(w) {\n                    return this.fromWireType(r()[w >>> 0]);\n                },\n                Eb: null\n            });\n        }\n        var Tn = [], ut = [];\n        function In(s) {\n            9 < (s >>>= 0) && --ut[s + 1] == 0 && (ut[s] = void 0, Tn.push(s));\n        }\n        var Me = (s)=>{\n            if (!s) throw new mt(\"Cannot use deleted val. handle = \" + s);\n            return ut[s];\n        }, Ve = (s)=>{\n            switch(s){\n                case void 0:\n                    return 2;\n                case null:\n                    return 4;\n                case !0:\n                    return 6;\n                case !1:\n                    return 8;\n                default:\n                    let c = Tn.pop() || ut.length;\n                    return ut[c] = s, ut[c + 1] = 1, c;\n            }\n        };\n        function Cn(s) {\n            return this.fromWireType(a()[s >>> 2 >>> 0]);\n        }\n        var Pc = {\n            name: \"emscripten::val\",\n            fromWireType: (s)=>{\n                var c = Me(s);\n                return In(s), c;\n            },\n            toWireType: (s, c)=>Ve(c),\n            argPackAdvance: ft,\n            readValueFromPointer: Cn,\n            Eb: null\n        };\n        function zc(s) {\n            return st(s >>> 0, Pc);\n        }\n        var Oc = (s, c)=>{\n            switch(c){\n                case 4:\n                    return function(f) {\n                        return this.fromWireType(d()[f >>> 2 >>> 0]);\n                    };\n                case 8:\n                    return function(f) {\n                        return this.fromWireType(l()[f >>> 3 >>> 0]);\n                    };\n                default:\n                    throw new TypeError(\"invalid float width (\".concat(c, \"): \").concat(s));\n            }\n        };\n        function Dc(s, c, f) {\n            f >>>= 0, st(s >>>= 0, {\n                name: c = Qe(c >>> 0),\n                fromWireType: (b)=>b,\n                toWireType: (b, w)=>w,\n                argPackAdvance: ft,\n                readValueFromPointer: Oc(c, f),\n                Eb: null\n            });\n        }\n        function Bc(s, c, f, b, w) {\n            if (s >>>= 0, f >>>= 0, c = Qe(c >>> 0), w === -1 && (w = 4294967295), w = (B)=>B, b === 0) {\n                var I = 32 - 8 * f;\n                w = (B)=>B << I >>> I;\n            }\n            var O = c.includes(\"unsigned\") ? function(B, L) {\n                return L >>> 0;\n            } : function(B, L) {\n                return L;\n            };\n            st(s, {\n                name: c,\n                fromWireType: w,\n                toWireType: O,\n                argPackAdvance: ft,\n                readValueFromPointer: pi(c, f, b !== 0),\n                Eb: null\n            });\n        }\n        function Mc(s, c, f) {\n            function b(I) {\n                var O = a()[I >>> 2 >>> 0];\n                return I = a()[I + 4 >>> 2 >>> 0], new w(t().buffer, I, O);\n            }\n            var w = [\n                Int8Array,\n                Uint8Array,\n                Int16Array,\n                Uint16Array,\n                Int32Array,\n                Uint32Array,\n                Float32Array,\n                Float64Array,\n                BigInt64Array,\n                BigUint64Array\n            ][c];\n            st(s >>>= 0, {\n                name: f = Qe(f >>> 0),\n                fromWireType: b,\n                argPackAdvance: ft,\n                readValueFromPointer: b\n            }, {\n                Tb: !0\n            });\n        }\n        function Rc(s, c) {\n            s >>>= 0;\n            var f = (c = Qe(c >>> 0)) === \"std::string\";\n            st(s, {\n                name: c,\n                fromWireType: function(b) {\n                    var w = a()[b >>> 2 >>> 0], I = b + 4;\n                    if (f) for(var O = I, B = 0; B <= w; ++B){\n                        var L = I + B;\n                        if (B == w || r()[L >>> 0] == 0) {\n                            if (O = Ce(O, L - O), H === void 0) var H = O;\n                            else H += String.fromCharCode(0), H += O;\n                            O = L + 1;\n                        }\n                    }\n                    else {\n                        for(H = Array(w), B = 0; B < w; ++B)H[B] = String.fromCharCode(r()[I + B >>> 0]);\n                        H = H.join(\"\");\n                    }\n                    return Je(b), H;\n                },\n                toWireType: function(b, w) {\n                    w instanceof ArrayBuffer && (w = new Uint8Array(w));\n                    var I = typeof w == \"string\";\n                    if (!(I || w instanceof Uint8Array || w instanceof Uint8ClampedArray || w instanceof Int8Array)) throw new mt(\"Cannot pass non-string to std::string\");\n                    var O = f && I ? $n(w) : w.length, B = fr(4 + O + 1), L = B + 4;\n                    if (a()[B >>> 2 >>> 0] = O, f && I) Ot(w, L, O + 1);\n                    else if (I) for(I = 0; I < O; ++I){\n                        var H = w.charCodeAt(I);\n                        if (255 < H) throw Je(L), new mt(\"String has UTF-16 code units that do not fit in 8 bits\");\n                        r()[L + I >>> 0] = H;\n                    }\n                    else for(I = 0; I < O; ++I)r()[L + I >>> 0] = w[I];\n                    return b !== null && b.push(Je, B), B;\n                },\n                argPackAdvance: ft,\n                readValueFromPointer: Cn,\n                Eb (b) {\n                    Je(b);\n                }\n            });\n        }\n        var mi = typeof TextDecoder < \"u\" ? new TextDecoder(\"utf-16le\") : void 0, Uc = (s, c)=>{\n            for(var f = s >> 1, b = f + c / 2; !(f >= b) && o()[f >>> 0];)++f;\n            if (32 < (f <<= 1) - s && mi) return mi.decode(r().slice(s, f));\n            for(f = \"\", b = 0; !(b >= c / 2); ++b){\n                var w = n()[s + 2 * b >>> 1 >>> 0];\n                if (w == 0) break;\n                f += String.fromCharCode(w);\n            }\n            return f;\n        }, Nc = (s, c, f)=>{\n            if (f !== null && f !== void 0 ? f : f = 2147483647, 2 > f) return 0;\n            var b = c;\n            f = (f -= 2) < 2 * s.length ? f / 2 : s.length;\n            for(var w = 0; w < f; ++w){\n                var I = s.charCodeAt(w);\n                n()[c >>> 1 >>> 0] = I, c += 2;\n            }\n            return n()[c >>> 1 >>> 0] = 0, c - b;\n        }, Vc = (s)=>2 * s.length, Wc = (s, c)=>{\n            for(var f = 0, b = \"\"; !(f >= c / 4);){\n                var w = i()[s + 4 * f >>> 2 >>> 0];\n                if (w == 0) break;\n                ++f, 65536 <= w ? (w -= 65536, b += String.fromCharCode(55296 | w >> 10, 56320 | 1023 & w)) : b += String.fromCharCode(w);\n            }\n            return b;\n        }, Lc = (s, c, f)=>{\n            if (c >>>= 0, f !== null && f !== void 0 ? f : f = 2147483647, 4 > f) return 0;\n            var b = c;\n            f = b + f - 4;\n            for(var w = 0; w < s.length; ++w){\n                var I = s.charCodeAt(w);\n                if (55296 <= I && 57343 >= I && (I = 65536 + ((1023 & I) << 10) | 1023 & s.charCodeAt(++w)), i()[c >>> 2 >>> 0] = I, (c += 4) + 4 > f) break;\n            }\n            return i()[c >>> 2 >>> 0] = 0, c - b;\n        }, Gc = (s)=>{\n            for(var c = 0, f = 0; f < s.length; ++f){\n                var b = s.charCodeAt(f);\n                55296 <= b && 57343 >= b && ++f, c += 4;\n            }\n            return c;\n        };\n        function Hc(s, c, f) {\n            if (s >>>= 0, c >>>= 0, f = Qe(f >>>= 0), c === 2) var b = Uc, w = Nc, I = Vc, O = (B)=>o()[B >>> 1 >>> 0];\n            else c === 4 && (b = Wc, w = Lc, I = Gc, O = (B)=>a()[B >>> 2 >>> 0]);\n            st(s, {\n                name: f,\n                fromWireType: (B)=>{\n                    for(var L, H = a()[B >>> 2 >>> 0], X = B + 4, ce = 0; ce <= H; ++ce){\n                        var ge = B + 4 + ce * c;\n                        ce != H && O(ge) != 0 || (X = b(X, ge - X), L === void 0 ? L = X : (L += String.fromCharCode(0), L += X), X = ge + c);\n                    }\n                    return Je(B), L;\n                },\n                toWireType: (B, L)=>{\n                    if (typeof L != \"string\") throw new mt(\"Cannot pass non-string to C++ string type \".concat(f));\n                    var H = I(L), X = fr(4 + H + c);\n                    return a()[X >>> 2 >>> 0] = H / c, w(L, X + 4, H + c), B !== null && B.push(Je, X), X;\n                },\n                argPackAdvance: ft,\n                readValueFromPointer: Cn,\n                Eb (B) {\n                    Je(B);\n                }\n            });\n        }\n        function Fc(s, c) {\n            st(s >>>= 0, {\n                Ub: !0,\n                name: c = Qe(c >>> 0),\n                argPackAdvance: 0,\n                fromWireType: ()=>{},\n                toWireType: ()=>{}\n            });\n        }\n        var qc = ()=>1;\n        function Kc(s) {\n            Dn(s >>> 0, !y, 1, !_, 131072, !1), Ho();\n        }\n        var fi = (s)=>{\n            if (!we) try {\n                if (s(), !(0 < wt)) try {\n                    g ? hr(ee) : vn(ee);\n                } catch (c) {\n                    c instanceof yn || c == \"unwind\" || k(1, c);\n                }\n            } catch (c) {\n                c instanceof yn || c == \"unwind\" || k(1, c);\n            }\n        };\n        function An(s) {\n            s >>>= 0, typeof Atomics.oc == \"function\" && (Atomics.oc(i(), s >>> 2, s).value.then(ir), s += 128, Atomics.store(i(), s >>> 2, 1));\n        }\n        var ir = ()=>{\n            var s = Mt();\n            s && (An(s), fi(Hi));\n        };\n        function jc(s, c) {\n            (s >>>= 0) == c >>> 0 ? setTimeout(ir) : g ? postMessage({\n                targetThread: s,\n                cmd: \"checkMailbox\"\n            }) : (s = Ze[s]) && s.postMessage({\n                cmd: \"checkMailbox\"\n            });\n        }\n        var kn = [];\n        function Yc(s, c, f, b, w) {\n            for(c >>>= 0, b /= 2, kn.length = b, f = w >>> 0 >>> 3, w = 0; w < b; w++)kn[w] = q[f + 2 * w] ? q[f + 2 * w + 1] : l()[f + 2 * w + 1 >>> 0];\n            return (c ? bn[c] : Np[s])(...kn);\n        }\n        function Zc(s) {\n            s >>>= 0, g ? postMessage({\n                cmd: \"cleanupThread\",\n                thread: s\n            }) : Go(Ze[s]);\n        }\n        function Qc(s) {}\n        var ar = (s, c)=>{\n            var f = Sn[s];\n            if (f === void 0) throw s = Vi(s), f = Qe(s), Je(s), new mt(\"\".concat(c, \" has unknown type \").concat(f));\n            return f;\n        }, hi = (s, c, f)=>{\n            var b = [];\n            return s = s.toWireType(b, f), b.length && (a()[c >>> 2 >>> 0] = Ve(b)), s;\n        };\n        function Xc(s, c, f) {\n            return c >>>= 0, f >>>= 0, s = Me(s >>> 0), c = ar(c, \"emval::as\"), hi(c, f, s);\n        }\n        function Jc(s, c) {\n            return c >>>= 0, s = Me(s >>> 0), (c = ar(c, \"emval::as\")).toWireType(null, s);\n        }\n        var sr = (s)=>{\n            try {\n                s();\n            } catch (c) {\n                ct(c);\n            }\n        }, ht = 0, Xe = null, gi = 0, ur = [], bi = {}, yi = {}, ep = 0, En = null, tp = [];\n        function _i(s) {\n            return function(c) {\n                if (!we) {\n                    if (ht === 0) {\n                        var f = !1, b = !1;\n                        c(function() {\n                            let w = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;\n                            if (!we && (gi = w, f = !0, b)) {\n                                ht = 2, sr(()=>Yi(Xe)), typeof Browser < \"u\" && Browser.Lb.Sb && Browser.Lb.resume(), w = !1;\n                                try {\n                                    var I = function() {\n                                        var L = i()[Xe + 8 >>> 2 >>> 0];\n                                        return L = Z[yi[L]], --wt, L();\n                                    }();\n                                } catch (L) {\n                                    I = L, w = !0;\n                                }\n                                var O = !1;\n                                if (!Xe) {\n                                    var B = En;\n                                    B && (En = null, (w ? B.reject : B.resolve)(I), O = !0);\n                                }\n                                if (w && !O) throw I;\n                            }\n                        }), b = !0, f || (ht = 1, Xe = function() {\n                            var w = fr(65548), I = w + 12;\n                            a()[w >>> 2 >>> 0] = I, a()[w + 4 >>> 2 >>> 0] = I + 65536, I = ur[0];\n                            var O = bi[I];\n                            return O === void 0 && (O = ep++, bi[I] = O, yi[O] = I), I = O, i()[w + 8 >>> 2 >>> 0] = I, w;\n                        }(), typeof Browser < \"u\" && Browser.Lb.Sb && Browser.Lb.pause(), sr(()=>Ki(Xe)));\n                    } else ht === 2 ? (ht = 0, sr(Zi), Je(Xe), Xe = null, tp.forEach(fi)) : ct(\"invalid state: \".concat(ht));\n                    return gi;\n                }\n            }((c)=>{\n                s().then(c);\n            });\n        }\n        function rp(s) {\n            return s >>>= 0, _i(()=>(s = Me(s)).then(Ve));\n        }\n        var dr = [];\n        function np(s, c, f, b) {\n            return f >>>= 0, b >>>= 0, (s = dr[s >>> 0])(null, c = Me(c >>> 0), f, b);\n        }\n        var op = {}, lr = (s)=>{\n            var c = op[s];\n            return c === void 0 ? Qe(s) : c;\n        };\n        function ip(s, c, f, b, w) {\n            return f >>>= 0, b >>>= 0, w >>>= 0, (s = dr[s >>> 0])(c = Me(c >>> 0), c[f = lr(f)], b, w);\n        }\n        var wi = ()=>typeof globalThis == \"object\" ? globalThis : Function(\"return this\")();\n        function ap(s) {\n            return (s >>>= 0) == 0 ? Ve(wi()) : (s = lr(s), Ve(wi()[s]));\n        }\n        var sp = (s)=>{\n            var c = dr.length;\n            return dr.push(s), c;\n        }, up = (s, c)=>{\n            for(var f = Array(s), b = 0; b < s; ++b)f[b] = ar(a()[c + 4 * b >>> 2 >>> 0], \"parameter \" + b);\n            return f;\n        }, vi = (s, c)=>Object.defineProperty(c, \"name\", {\n                value: s\n            });\n        function dp(s, c, f) {\n            var b = (c = up(s, c >>> 0)).shift();\n            s--;\n            var w = \"return function (obj, func, destructorsRef, args) {\\n\", I = 0, O = [];\n            f === 0 && O.push(\"obj\");\n            for(var B = [\n                \"retType\"\n            ], L = [\n                b\n            ], H = 0; H < s; ++H)O.push(\"arg\" + H), B.push(\"argType\" + H), L.push(c[H]), w += \"  var arg\".concat(H, \" = argType\").concat(H, \".readValueFromPointer(args\").concat(I ? \"+\" + I : \"\", \");\\n\"), I += c[H].argPackAdvance;\n            return w += \"  var rv = \".concat(f === 1 ? \"new func\" : \"func.call\", \"(\").concat(O.join(\", \"), \");\\n\"), b.Ub || (B.push(\"emval_returnValue\"), L.push(hi), w += \"  return emval_returnValue(retType, destructorsRef, rv);\\n\"), B.push(w + \"};\\n\"), s = (function(X) {\n                var ce = Function;\n                if (!(ce instanceof Function)) throw new TypeError(\"new_ called with constructor type \".concat(typeof ce, \" which is not a function\"));\n                var ge = vi(ce.name || \"unknownFunctionName\", function() {});\n                return ge.prototype = ce.prototype, ge = new ge, (X = ce.apply(ge, X)) instanceof Object ? X : ge;\n            })(B)(...L), f = \"methodCaller<(\".concat(c.map((X)=>X.name).join(\", \"), \") => \").concat(b.name, \">\"), sp(vi(f, s));\n        }\n        function lp(s) {\n            return s = lr(s >>> 0), Ve(u[s]);\n        }\n        function cp(s, c) {\n            return c >>>= 0, s = Me(s >>> 0), c = Me(c), Ve(s[c]);\n        }\n        function pp(s) {\n            9 < (s >>>= 0) && (ut[s + 1] += 1);\n        }\n        function mp() {\n            return Ve([]);\n        }\n        function fp(s) {\n            s = Me(s >>> 0);\n            for(var c = Array(s.length), f = 0; f < s.length; f++)c[f] = s[f];\n            return Ve(c);\n        }\n        function hp(s) {\n            return Ve(lr(s >>> 0));\n        }\n        function gp() {\n            return Ve({});\n        }\n        function bp(s) {\n            for(var c = Me(s >>>= 0); c.length;){\n                var f = c.pop();\n                c.pop()(f);\n            }\n            In(s);\n        }\n        function yp(s, c, f) {\n            c >>>= 0, f >>>= 0, s = Me(s >>> 0), c = Me(c), f = Me(f), s[c] = f;\n        }\n        function _p(s, c) {\n            return c >>>= 0, s = (s = ar(s >>> 0, \"_emval_take_value\")).readValueFromPointer(c), Ve(s);\n        }\n        function wp(s, c) {\n            s = -9007199254740992 > s || 9007199254740992 < s ? NaN : Number(s), c >>>= 0, s = new Date(1e3 * s), i()[c >>> 2 >>> 0] = s.getUTCSeconds(), i()[c + 4 >>> 2 >>> 0] = s.getUTCMinutes(), i()[c + 8 >>> 2 >>> 0] = s.getUTCHours(), i()[c + 12 >>> 2 >>> 0] = s.getUTCDate(), i()[c + 16 >>> 2 >>> 0] = s.getUTCMonth(), i()[c + 20 >>> 2 >>> 0] = s.getUTCFullYear() - 1900, i()[c + 24 >>> 2 >>> 0] = s.getUTCDay(), s = (s.getTime() - Date.UTC(s.getUTCFullYear(), 0, 1, 0, 0, 0, 0)) / 864e5 | 0, i()[c + 28 >>> 2 >>> 0] = s;\n        }\n        var Dt = (s)=>s % 4 == 0 && (s % 100 != 0 || s % 400 == 0), $i = [\n            0,\n            31,\n            60,\n            91,\n            121,\n            152,\n            182,\n            213,\n            244,\n            274,\n            305,\n            335\n        ], xi = [\n            0,\n            31,\n            59,\n            90,\n            120,\n            151,\n            181,\n            212,\n            243,\n            273,\n            304,\n            334\n        ];\n        function vp(s, c) {\n            s = -9007199254740992 > s || 9007199254740992 < s ? NaN : Number(s), c >>>= 0, s = new Date(1e3 * s), i()[c >>> 2 >>> 0] = s.getSeconds(), i()[c + 4 >>> 2 >>> 0] = s.getMinutes(), i()[c + 8 >>> 2 >>> 0] = s.getHours(), i()[c + 12 >>> 2 >>> 0] = s.getDate(), i()[c + 16 >>> 2 >>> 0] = s.getMonth(), i()[c + 20 >>> 2 >>> 0] = s.getFullYear() - 1900, i()[c + 24 >>> 2 >>> 0] = s.getDay();\n            var f = (Dt(s.getFullYear()) ? $i : xi)[s.getMonth()] + s.getDate() - 1 | 0;\n            i()[c + 28 >>> 2 >>> 0] = f, i()[c + 36 >>> 2 >>> 0] = -60 * s.getTimezoneOffset(), f = new Date(s.getFullYear(), 6, 1).getTimezoneOffset();\n            var b = new Date(s.getFullYear(), 0, 1).getTimezoneOffset();\n            s = 0 | (f != b && s.getTimezoneOffset() == Math.min(b, f)), i()[c + 32 >>> 2 >>> 0] = s;\n        }\n        function $p(s) {\n            s >>>= 0;\n            var c = new Date(i()[s + 20 >>> 2 >>> 0] + 1900, i()[s + 16 >>> 2 >>> 0], i()[s + 12 >>> 2 >>> 0], i()[s + 8 >>> 2 >>> 0], i()[s + 4 >>> 2 >>> 0], i()[s >>> 2 >>> 0], 0), f = i()[s + 32 >>> 2 >>> 0], b = c.getTimezoneOffset(), w = new Date(c.getFullYear(), 6, 1).getTimezoneOffset(), I = new Date(c.getFullYear(), 0, 1).getTimezoneOffset(), O = Math.min(I, w);\n            return 0 > f ? i()[s + 32 >>> 2 >>> 0] = +(w != I && O == b) : 0 < f != (O == b) && (w = Math.max(I, w), c.setTime(c.getTime() + 6e4 * ((0 < f ? O : w) - b))), i()[s + 24 >>> 2 >>> 0] = c.getDay(), f = (Dt(c.getFullYear()) ? $i : xi)[c.getMonth()] + c.getDate() - 1 | 0, i()[s + 28 >>> 2 >>> 0] = f, i()[s >>> 2 >>> 0] = c.getSeconds(), i()[s + 4 >>> 2 >>> 0] = c.getMinutes(), i()[s + 8 >>> 2 >>> 0] = c.getHours(), i()[s + 12 >>> 2 >>> 0] = c.getDate(), i()[s + 16 >>> 2 >>> 0] = c.getMonth(), i()[s + 20 >>> 2 >>> 0] = c.getYear(), s = c.getTime(), BigInt(isNaN(s) ? -1 : s / 1e3);\n        }\n        function Si(s, c, f, b, w, I, O) {\n            return g ? xe(16, 1, s, c, f, b, w, I, O) : -52;\n        }\n        function Ti(s, c, f, b, w, I) {\n            if (g) return xe(17, 1, s, c, f, b, w, I);\n        }\n        function xp(s, c, f, b) {\n            s >>>= 0, c >>>= 0, f >>>= 0, b >>>= 0;\n            var w = new Date().getFullYear(), I = new Date(w, 0, 1), O = new Date(w, 6, 1);\n            w = I.getTimezoneOffset();\n            var B = O.getTimezoneOffset(), L = Math.max(w, B);\n            a()[s >>> 2 >>> 0] = 60 * L, i()[c >>> 2 >>> 0] = +(w != B), I = (s = (H)=>H.toLocaleTimeString(void 0, {\n                    hour12: !1,\n                    timeZoneName: \"short\"\n                }).split(\" \")[1])(I), O = s(O), B < w ? (Ot(I, f, 17), Ot(O, b, 17)) : (Ot(I, b, 17), Ot(O, f, 17));\n        }\n        var Pn = [], Ii = (s, c)=>{\n            Pn.length = 0;\n            for(var f; f = r()[s++ >>> 0];){\n                var b = f != 105;\n                c += (b &= f != 112) && c % 8 ? 4 : 0, Pn.push(f == 112 ? a()[c >>> 2 >>> 0] : f == 106 ? q[c >>> 3] : f == 105 ? i()[c >>> 2 >>> 0] : l()[c >>> 3 >>> 0]), c += b ? 8 : 4;\n            }\n            return Pn;\n        };\n        function Sp(s, c, f) {\n            return s >>>= 0, c = Ii(c >>> 0, f >>> 0), bn[s](...c);\n        }\n        function Tp(s, c, f) {\n            return s >>>= 0, c = Ii(c >>> 0, f >>> 0), bn[s](...c);\n        }\n        var Ip = ()=>{}, Cp = ()=>Date.now();\n        function Ap(s, c) {\n            return j(Ce(s >>> 0, c >>> 0));\n        }\n        var Ci, kp = ()=>{\n            throw wt += 1, \"unwind\";\n        };\n        function Ep() {\n            return 4294901760;\n        }\n        Ci = ()=>performance.timeOrigin + performance.now();\n        var Pp = ()=>navigator.hardwareConcurrency;\n        function zp() {\n            return ct(\"Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER\"), 0;\n        }\n        function Op(s) {\n            s >>>= 0;\n            var c = r().length;\n            if (s <= c || 4294901760 < s) return !1;\n            for(var f = 1; 4 >= f; f *= 2){\n                var b = c * (1 + .2 / f);\n                b = Math.min(b, s + 100663296);\n                var w = Math;\n                b = Math.max(s, b);\n                e: {\n                    w = (w.min.call(w, 4294901760, b + (65536 - b % 65536) % 65536) - se.buffer.byteLength + 65535) / 65536;\n                    try {\n                        se.grow(w), ye();\n                        var I = 1;\n                        break e;\n                    } catch (e1) {}\n                    I = void 0;\n                }\n                if (I) return !0;\n            }\n            return !1;\n        }\n        var cr = ()=>(ct(\"Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER\"), 0), Bt = {}, Ai = (s)=>{\n            s.forEach((c)=>{\n                var f = cr();\n                f && (Bt[f] = c);\n            });\n        };\n        function Dp() {\n            var s = Error().stack.toString().split(\"\\n\");\n            return s[0] == \"Error\" && s.shift(), Ai(s), Bt.Qb = cr(), Bt.fc = s, Bt.Qb;\n        }\n        function Bp(s, c, f) {\n            if (s >>>= 0, c >>>= 0, Bt.Qb == s) var b = Bt.fc;\n            else (b = Error().stack.toString().split(\"\\n\"))[0] == \"Error\" && b.shift(), Ai(b);\n            for(var w = 3; b[w] && cr() != s;)++w;\n            for(s = 0; s < f && b[s + w]; ++s)i()[c + 4 * s >>> 2 >>> 0] = cr();\n            return s;\n        }\n        var zn, On = {}, ki = ()=>{\n            if (!zn) {\n                var s, c = {\n                    USER: \"web_user\",\n                    LOGNAME: \"web_user\",\n                    PATH: \"/\",\n                    PWD: \"/\",\n                    HOME: \"/home/web_user\",\n                    LANG: (typeof navigator == \"object\" && navigator.languages && navigator.languages[0] || \"C\").replace(\"-\", \"_\") + \".UTF-8\",\n                    _: A || \"./this.program\"\n                };\n                for(s in On)On[s] === void 0 ? delete c[s] : c[s] = On[s];\n                var f = [];\n                for(s in c)f.push(\"\".concat(s, \"=\").concat(c[s]));\n                zn = f;\n            }\n            return zn;\n        };\n        function Ei(s, c) {\n            if (g) return xe(18, 1, s, c);\n            s >>>= 0, c >>>= 0;\n            var f = 0;\n            return ki().forEach((b, w)=>{\n                var I = c + f;\n                for(w = a()[s + 4 * w >>> 2 >>> 0] = I, I = 0; I < b.length; ++I)t()[w++ >>> 0] = b.charCodeAt(I);\n                t()[w >>> 0] = 0, f += b.length + 1;\n            }), 0;\n        }\n        function Pi(s, c) {\n            if (g) return xe(19, 1, s, c);\n            s >>>= 0, c >>>= 0;\n            var f = ki();\n            a()[s >>> 2 >>> 0] = f.length;\n            var b = 0;\n            return f.forEach((w)=>b += w.length + 1), a()[c >>> 2 >>> 0] = b, 0;\n        }\n        function zi(s) {\n            return g ? xe(20, 1, s) : 52;\n        }\n        function Oi(s, c, f, b) {\n            return g ? xe(21, 1, s, c, f, b) : 52;\n        }\n        function Di(s, c, f, b) {\n            return g ? xe(22, 1, s, c, f, b) : 70;\n        }\n        var Mp = [\n            null,\n            [],\n            []\n        ];\n        function Bi(s, c, f, b) {\n            if (g) return xe(23, 1, s, c, f, b);\n            c >>>= 0, f >>>= 0, b >>>= 0;\n            for(var w = 0, I = 0; I < f; I++){\n                var O = a()[c >>> 2 >>> 0], B = a()[c + 4 >>> 2 >>> 0];\n                c += 8;\n                for(var L = 0; L < B; L++){\n                    var H = r()[O + L >>> 0], X = Mp[s];\n                    H === 0 || H === 10 ? ((s === 1 ? K : j)(Zo(X, 0)), X.length = 0) : X.push(H);\n                }\n                w += B;\n            }\n            return a()[b >>> 2 >>> 0] = w, 0;\n        }\n        var Mi = [\n            31,\n            29,\n            31,\n            30,\n            31,\n            30,\n            31,\n            31,\n            30,\n            31,\n            30,\n            31\n        ], Ri = [\n            31,\n            28,\n            31,\n            30,\n            31,\n            30,\n            31,\n            31,\n            30,\n            31,\n            30,\n            31\n        ], Rp = (s, c)=>{\n            t().set(s, c >>> 0);\n        };\n        function Ui(s, c, f, b) {\n            function w(z, de, Te) {\n                for(z = typeof z == \"number\" ? z.toString() : z || \"\"; z.length < de;)z = Te[0] + z;\n                return z;\n            }\n            function I(z, de) {\n                return w(z, de, \"0\");\n            }\n            function O(z, de) {\n                function Te(Xi) {\n                    return 0 > Xi ? -1 : 0 < Xi ? 1 : 0;\n                }\n                var $t;\n                return ($t = Te(z.getFullYear() - de.getFullYear())) === 0 && ($t = Te(z.getMonth() - de.getMonth())) === 0 && ($t = Te(z.getDate() - de.getDate())), $t;\n            }\n            function B(z) {\n                switch(z.getDay()){\n                    case 0:\n                        return new Date(z.getFullYear() - 1, 11, 29);\n                    case 1:\n                        return z;\n                    case 2:\n                        return new Date(z.getFullYear(), 0, 3);\n                    case 3:\n                        return new Date(z.getFullYear(), 0, 2);\n                    case 4:\n                        return new Date(z.getFullYear(), 0, 1);\n                    case 5:\n                        return new Date(z.getFullYear() - 1, 11, 31);\n                    case 6:\n                        return new Date(z.getFullYear() - 1, 11, 30);\n                }\n            }\n            function L(z) {\n                var de = z.Cb;\n                for(z = new Date(new Date(z.Db + 1900, 0, 1).getTime()); 0 < de;){\n                    var Te = z.getMonth(), $t = (Dt(z.getFullYear()) ? Mi : Ri)[Te];\n                    if (!(de > $t - z.getDate())) {\n                        z.setDate(z.getDate() + de);\n                        break;\n                    }\n                    de -= $t - z.getDate() + 1, z.setDate(1), 11 > Te ? z.setMonth(Te + 1) : (z.setMonth(0), z.setFullYear(z.getFullYear() + 1));\n                }\n                return Te = new Date(z.getFullYear() + 1, 0, 4), de = B(new Date(z.getFullYear(), 0, 4)), Te = B(Te), 0 >= O(de, z) ? 0 >= O(Te, z) ? z.getFullYear() + 1 : z.getFullYear() : z.getFullYear() - 1;\n            }\n            s >>>= 0, c >>>= 0, f >>>= 0, b >>>= 0;\n            var H = a()[b + 40 >>> 2 >>> 0];\n            for(var X in b = {\n                lc: i()[b >>> 2 >>> 0],\n                kc: i()[b + 4 >>> 2 >>> 0],\n                Ib: i()[b + 8 >>> 2 >>> 0],\n                Mb: i()[b + 12 >>> 2 >>> 0],\n                Jb: i()[b + 16 >>> 2 >>> 0],\n                Db: i()[b + 20 >>> 2 >>> 0],\n                vb: i()[b + 24 >>> 2 >>> 0],\n                Cb: i()[b + 28 >>> 2 >>> 0],\n                sc: i()[b + 32 >>> 2 >>> 0],\n                jc: i()[b + 36 >>> 2 >>> 0],\n                mc: H ? Ce(H) : \"\"\n            }, f = Ce(f), H = {\n                \"%c\": \"%a %b %d %H:%M:%S %Y\",\n                \"%D\": \"%m/%d/%y\",\n                \"%F\": \"%Y-%m-%d\",\n                \"%h\": \"%b\",\n                \"%r\": \"%I:%M:%S %p\",\n                \"%R\": \"%H:%M\",\n                \"%T\": \"%H:%M:%S\",\n                \"%x\": \"%m/%d/%y\",\n                \"%X\": \"%H:%M:%S\",\n                \"%Ec\": \"%c\",\n                \"%EC\": \"%C\",\n                \"%Ex\": \"%m/%d/%y\",\n                \"%EX\": \"%H:%M:%S\",\n                \"%Ey\": \"%y\",\n                \"%EY\": \"%Y\",\n                \"%Od\": \"%d\",\n                \"%Oe\": \"%e\",\n                \"%OH\": \"%H\",\n                \"%OI\": \"%I\",\n                \"%Om\": \"%m\",\n                \"%OM\": \"%M\",\n                \"%OS\": \"%S\",\n                \"%Ou\": \"%u\",\n                \"%OU\": \"%U\",\n                \"%OV\": \"%V\",\n                \"%Ow\": \"%w\",\n                \"%OW\": \"%W\",\n                \"%Oy\": \"%y\"\n            })f = f.replace(new RegExp(X, \"g\"), H[X]);\n            var ce = \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"), ge = \"January February March April May June July August September October November December\".split(\" \");\n            for(X in H = {\n                \"%a\": (z)=>ce[z.vb].substring(0, 3),\n                \"%A\": (z)=>ce[z.vb],\n                \"%b\": (z)=>ge[z.Jb].substring(0, 3),\n                \"%B\": (z)=>ge[z.Jb],\n                \"%C\": (z)=>I((z.Db + 1900) / 100 | 0, 2),\n                \"%d\": (z)=>I(z.Mb, 2),\n                \"%e\": (z)=>w(z.Mb, 2, \" \"),\n                \"%g\": (z)=>L(z).toString().substring(2),\n                \"%G\": L,\n                \"%H\": (z)=>I(z.Ib, 2),\n                \"%I\": (z)=>((z = z.Ib) == 0 ? z = 12 : 12 < z && (z -= 12), I(z, 2)),\n                \"%j\": (z)=>{\n                    for(var de = 0, Te = 0; Te <= z.Jb - 1; de += (Dt(z.Db + 1900) ? Mi : Ri)[Te++]);\n                    return I(z.Mb + de, 3);\n                },\n                \"%m\": (z)=>I(z.Jb + 1, 2),\n                \"%M\": (z)=>I(z.kc, 2),\n                \"%n\": ()=>\"\\n\",\n                \"%p\": (z)=>0 <= z.Ib && 12 > z.Ib ? \"AM\" : \"PM\",\n                \"%S\": (z)=>I(z.lc, 2),\n                \"%t\": ()=>\"\t\",\n                \"%u\": (z)=>z.vb || 7,\n                \"%U\": (z)=>I(Math.floor((z.Cb + 7 - z.vb) / 7), 2),\n                \"%V\": (z)=>{\n                    var de = Math.floor((z.Cb + 7 - (z.vb + 6) % 7) / 7);\n                    if (2 >= (z.vb + 371 - z.Cb - 2) % 7 && de++, de) de == 53 && ((Te = (z.vb + 371 - z.Cb) % 7) == 4 || Te == 3 && Dt(z.Db) || (de = 1));\n                    else {\n                        de = 52;\n                        var Te = (z.vb + 7 - z.Cb - 1) % 7;\n                        (Te == 4 || Te == 5 && Dt(z.Db % 400 - 1)) && de++;\n                    }\n                    return I(de, 2);\n                },\n                \"%w\": (z)=>z.vb,\n                \"%W\": (z)=>I(Math.floor((z.Cb + 7 - (z.vb + 6) % 7) / 7), 2),\n                \"%y\": (z)=>(z.Db + 1900).toString().substring(2),\n                \"%Y\": (z)=>z.Db + 1900,\n                \"%z\": (z)=>{\n                    var de = 0 <= (z = z.jc);\n                    return z = Math.abs(z) / 60, (de ? \"+\" : \"-\") + (\"0000\" + (z / 60 * 100 + z % 60)).slice(-4);\n                },\n                \"%Z\": (z)=>z.mc,\n                \"%%\": ()=>\"%\"\n            }, f = f.replace(/%%/g, \"\\x00\\x00\"), H)f.includes(X) && (f = f.replace(new RegExp(X, \"g\"), H[X](b)));\n            return X = function(z) {\n                var de = Array($n(z) + 1);\n                return Jo(z, de, 0, de.length), de;\n            }(f = f.replace(/\\0\\0/g, \"%\")), X.length > c ? 0 : (Rp(X, s), X.length - 1);\n        }\n        function Up(s, c, f, b) {\n            return Ui(s >>> 0, c >>> 0, f >>> 0, b >>> 0);\n        }\n        g || function() {\n            for(var s = u.numThreads - 1; s--;)qo();\n            Ye.unshift(()=>{\n                Gt++, function(c) {\n                    g ? c() : Promise.all(pt.map(Fo)).then(c);\n                }(()=>Do());\n            });\n        }();\n        for(var Ni = Array(256), pr = 0; 256 > pr; ++pr)Ni[pr] = String.fromCharCode(pr);\n        ci = Ni, mt = u.BindingError = class extends Error {\n            constructor(s){\n                super(s), this.name = \"BindingError\";\n            }\n        }, u.InternalError = class extends Error {\n            constructor(s){\n                super(s), this.name = \"InternalError\";\n            }\n        }, ut.push(0, 1, void 0, 1, null, 1, !0, 1, !1, 1), u.count_emval_handles = ()=>ut.length / 2 - 5 - Tn.length;\n        var Np = [\n            wn,\n            Wo,\n            Ko,\n            Qo,\n            Xo,\n            ei,\n            ti,\n            ri,\n            ni,\n            oi,\n            ii,\n            ai,\n            si,\n            ui,\n            di,\n            li,\n            Si,\n            Ti,\n            Ei,\n            Pi,\n            zi,\n            Oi,\n            Di,\n            Bi\n        ], Z = function() {\n            function s(f, b) {\n                return Z = f.exports, Z = function() {\n                    var w = Z, I = {};\n                    for (let [O, B] of Object.entries(w))I[O] = typeof B == \"function\" ? function() {\n                        for(var _len = arguments.length, L = new Array(_len), _key = 0; _key < _len; _key++){\n                            L[_key] = arguments[_key];\n                        }\n                        ur.push(O);\n                        try {\n                            return B(...L);\n                        } finally{\n                            we || (ur.pop(), Xe && ht === 1 && ur.length === 0 && (ht = 0, wt += 1, sr(ji), typeof Fibers < \"u\" && Fibers.tc()));\n                        }\n                    } : B;\n                    return I;\n                }(), Z = function() {\n                    var w = Z, I = (B)=>(L)=>B(L) >>> 0, O = (B)=>()=>B() >>> 0;\n                    return (w = Object.assign({}, w)).Da = I(w.Da), w.gb = O(w.gb), w.ib = I(w.ib), w.emscripten_main_runtime_thread_id = O(w.emscripten_main_runtime_thread_id), w.tb = I(w.tb), w.ub = O(w.ub), w;\n                }(), Lo.push(Z.jb), Lt.unshift(Z.Ca), Y = b, Do(), Z;\n            }\n            var c = No();\n            if (Gt++, u.instantiateWasm) try {\n                return u.instantiateWasm(c, s);\n            } catch (f) {\n                j(\"Module.instantiateWasm callback failed with error: \".concat(f)), m(f);\n            }\n            return gn || (gn = u.locateFile ? Bo(\"ort-wasm-simd-threaded.jsep.wasm\") ? \"ort-wasm-simd-threaded.jsep.wasm\" : u.locateFile ? u.locateFile(\"ort-wasm-simd-threaded.jsep.wasm\", P) : P + \"ort-wasm-simd-threaded.jsep.wasm\" : /* asset import */ new __webpack_require__.U(__webpack_require__(/*! ort-wasm-simd-threaded.jsep.wasm */ \"(app-pages-browser)/./node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm\")).href), (function(f, b) {\n                var w = gn;\n                return D || typeof WebAssembly.instantiateStreaming != \"function\" || Bo(w) || Mo(w) || typeof fetch != \"function\" ? Uo(w, f, b) : fetch(w, {\n                    credentials: \"same-origin\"\n                }).then((I)=>WebAssembly.instantiateStreaming(I, f).then(b, function(O) {\n                        return j(\"wasm streaming compile failed: \".concat(O)), j(\"falling back to ArrayBuffer instantiation\"), Uo(w, f, b);\n                    }));\n            })(c, function(f) {\n                s(f.instance, f.module);\n            }).catch(m), {};\n        }(), Vi = (s)=>(Vi = Z.Da)(s), Wi = ()=>(Wi = Z.Ea)();\n        u._OrtInit = (s, c)=>(u._OrtInit = Z.Fa)(s, c), u._OrtGetLastError = (s, c)=>(u._OrtGetLastError = Z.Ga)(s, c), u._OrtCreateSessionOptions = (s, c, f, b, w, I, O, B, L, H)=>(u._OrtCreateSessionOptions = Z.Ha)(s, c, f, b, w, I, O, B, L, H), u._OrtAppendExecutionProvider = (s, c)=>(u._OrtAppendExecutionProvider = Z.Ia)(s, c), u._OrtAddFreeDimensionOverride = (s, c, f)=>(u._OrtAddFreeDimensionOverride = Z.Ja)(s, c, f), u._OrtAddSessionConfigEntry = (s, c, f)=>(u._OrtAddSessionConfigEntry = Z.Ka)(s, c, f), u._OrtReleaseSessionOptions = (s)=>(u._OrtReleaseSessionOptions = Z.La)(s), u._OrtCreateSession = (s, c, f)=>(u._OrtCreateSession = Z.Ma)(s, c, f), u._OrtReleaseSession = (s)=>(u._OrtReleaseSession = Z.Na)(s), u._OrtGetInputOutputCount = (s, c, f)=>(u._OrtGetInputOutputCount = Z.Oa)(s, c, f), u._OrtGetInputName = (s, c)=>(u._OrtGetInputName = Z.Pa)(s, c), u._OrtGetOutputName = (s, c)=>(u._OrtGetOutputName = Z.Qa)(s, c), u._OrtFree = (s)=>(u._OrtFree = Z.Ra)(s), u._OrtCreateTensor = (s, c, f, b, w, I)=>(u._OrtCreateTensor = Z.Sa)(s, c, f, b, w, I), u._OrtGetTensorData = (s, c, f, b, w)=>(u._OrtGetTensorData = Z.Ta)(s, c, f, b, w), u._OrtReleaseTensor = (s)=>(u._OrtReleaseTensor = Z.Ua)(s), u._OrtCreateRunOptions = (s, c, f, b)=>(u._OrtCreateRunOptions = Z.Va)(s, c, f, b), u._OrtAddRunConfigEntry = (s, c, f)=>(u._OrtAddRunConfigEntry = Z.Wa)(s, c, f), u._OrtReleaseRunOptions = (s)=>(u._OrtReleaseRunOptions = Z.Xa)(s), u._OrtCreateBinding = (s)=>(u._OrtCreateBinding = Z.Ya)(s), u._OrtBindInput = (s, c, f)=>(u._OrtBindInput = Z.Za)(s, c, f), u._OrtBindOutput = (s, c, f, b)=>(u._OrtBindOutput = Z._a)(s, c, f, b), u._OrtClearBoundOutputs = (s)=>(u._OrtClearBoundOutputs = Z.$a)(s), u._OrtReleaseBinding = (s)=>(u._OrtReleaseBinding = Z.ab)(s), u._OrtRunWithBinding = (s, c, f, b, w)=>(u._OrtRunWithBinding = Z.bb)(s, c, f, b, w), u._OrtRun = (s, c, f, b, w, I, O, B)=>(u._OrtRun = Z.cb)(s, c, f, b, w, I, O, B), u._OrtEndProfiling = (s)=>(u._OrtEndProfiling = Z.db)(s), u._JsepOutput = (s, c, f)=>(u._JsepOutput = Z.eb)(s, c, f), u._JsepGetNodeName = (s)=>(u._JsepGetNodeName = Z.fb)(s);\n        var mr, Mt = ()=>(Mt = Z.gb)(), Je = u._free = (s)=>(Je = u._free = Z.hb)(s), fr = u._malloc = (s)=>(fr = u._malloc = Z.ib)(s), Dn = (s, c, f, b, w, I)=>(Dn = Z.lb)(s, c, f, b, w, I), Li = ()=>(Li = Z.mb)(), Gi = (s, c, f, b, w)=>(Gi = Z.nb)(s, c, f, b, w), Bn = (s)=>(Bn = Z.ob)(s), hr = (s)=>(hr = Z.pb)(s), Hi = ()=>(Hi = Z.qb)(), Fi = (s, c)=>(Fi = Z.rb)(s, c), gr = (s)=>(gr = Z.sb)(s), Mn = (s)=>(Mn = Z.tb)(s), Rn = ()=>(Rn = Z.ub)(), qi = u.dynCall_ii = (s, c)=>(qi = u.dynCall_ii = Z.wb)(s, c), Ki = (s)=>(Ki = Z.xb)(s), ji = ()=>(ji = Z.yb)(), Yi = (s)=>(Yi = Z.zb)(s), Zi = ()=>(Zi = Z.Ab)();\n        function Qi() {\n            0 < Gt || (g ? (p(u), g || or(Lt), startWorker(u)) : (or(Ye), 0 < Gt || mr || (mr = !0, u.calledRun = !0, we || (g || or(Lt), p(u), g || or(fn)))));\n        }\n        return u.___start_em_js = 929301, u.___stop_em_js = 929547, u.stackSave = ()=>Rn(), u.stackRestore = (s)=>gr(s), u.stackAlloc = (s)=>Mn(s), u.setValue = function(s, c) {\n            let f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"i8\";\n            switch(f.endsWith(\"*\") && (f = \"*\"), f){\n                case \"i1\":\n                case \"i8\":\n                    t()[s >>> 0] = c;\n                    break;\n                case \"i16\":\n                    n()[s >>> 1 >>> 0] = c;\n                    break;\n                case \"i32\":\n                    i()[s >>> 2 >>> 0] = c;\n                    break;\n                case \"i64\":\n                    q[s >>> 3] = BigInt(c);\n                    break;\n                case \"float\":\n                    d()[s >>> 2 >>> 0] = c;\n                    break;\n                case \"double\":\n                    l()[s >>> 3 >>> 0] = c;\n                    break;\n                case \"*\":\n                    a()[s >>> 2 >>> 0] = c;\n                    break;\n                default:\n                    ct(\"invalid type for setValue: \".concat(f));\n            }\n        }, u.getValue = function(s) {\n            let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"i8\";\n            switch(c.endsWith(\"*\") && (c = \"*\"), c){\n                case \"i1\":\n                case \"i8\":\n                    return t()[s >>> 0];\n                case \"i16\":\n                    return n()[s >>> 1 >>> 0];\n                case \"i32\":\n                    return i()[s >>> 2 >>> 0];\n                case \"i64\":\n                    return q[s >>> 3];\n                case \"float\":\n                    return d()[s >>> 2 >>> 0];\n                case \"double\":\n                    return l()[s >>> 3 >>> 0];\n                case \"*\":\n                    return a()[s >>> 2 >>> 0];\n                default:\n                    ct(\"invalid type for getValue: \".concat(c));\n            }\n        }, u.UTF8ToString = Ce, u.stringToUTF8 = Ot, u.lengthBytesUTF8 = $n, Ht = function s() {\n            mr || Qi(), mr || (Ht = s);\n        }, Qi(), u.PTR_SIZE = 4, h;\n    }), Kp = za;\n    ((_globalThis_self = globalThis.self) === null || _globalThis_self === void 0 ? void 0 : _globalThis_self.name) === \"em-pthread\" && za();\n});\nvar Ra, jp, Ne, Ua, jn, Yp, Zp, Na, Qp, Ba, Va, Ma, Wa, xr = U(()=>{\n    \"use strict\";\n    $r();\n    Ra =  false || typeof location > \"u\" ? void 0 : location.origin, jp = ()=>{\n        var _url;\n        if (true) return ((_url = \"file:///Users/amityadav/Desktop/Text-Behind%20Image/node_modules/onnxruntime-web/dist/ort.bundle.min.mjs\") === null || _url === void 0 ? void 0 : _url.startsWith(\"file:\")) ? new URL(/* asset import */ new __webpack_require__.U(__webpack_require__(/*! ort.bundle.min.mjs */ \"(app-pages-browser)/./node_modules/onnxruntime-web/dist/ort.bundle.min.mjs?4b98\")).href, Ra).href : \"file:///Users/amityadav/Desktop/Text-Behind%20Image/node_modules/onnxruntime-web/dist/ort.bundle.min.mjs\";\n    }, Ne = jp(), Ua = ()=>{\n        if (Ne && !Ne.startsWith(\"blob:\")) return Ne.substring(0, Ne.lastIndexOf(\"/\") + 1);\n    }, jn = (e1, t)=>{\n        try {\n            let r = t !== null && t !== void 0 ? t : Ne;\n            return (r ? new URL(e1, r) : new URL(e1)).origin === Ra;\n        } catch (e1) {\n            return !1;\n        }\n    }, Yp = (e1, t)=>{\n        let r = t !== null && t !== void 0 ? t : Ne;\n        try {\n            return (r ? new URL(e1, r) : new URL(e1)).href;\n        } catch (e1) {\n            return;\n        }\n    }, Zp = (e1, t)=>\"\".concat(t !== null && t !== void 0 ? t : \"./\").concat(e1), Na = async (e1)=>{\n        let r = await (await fetch(e1, {\n            credentials: \"same-origin\"\n        })).blob();\n        return URL.createObjectURL(r);\n    }, Qp = async (e1)=>(await import(/*webpackIgnore:true*/ e1)).default, Ba = (Pa(), br(Ea)).default, Va = async ()=>{\n        if (!Ne) throw new Error(\"Failed to load proxy worker: cannot determine the script source URL.\");\n        if (jn(Ne)) return [\n            void 0,\n            Ba()\n        ];\n        let e1 = await Na(Ne);\n        return [\n            e1,\n            Ba(e1)\n        ];\n    }, Ma = (Da(), br(Oa)).default, Wa = async (e1, t, r)=>{\n        if (!e1 && !t && Ma && Ne && jn(Ne)) return [\n            void 0,\n            Ma\n        ];\n        {\n            let n = \"ort-wasm-simd-threaded.jsep.mjs\", o = e1 !== null && e1 !== void 0 ? e1 : Yp(n, t), i =  true && r && o && !jn(o, t), a = i ? await Na(o) : o !== null && o !== void 0 ? o : Zp(n, t);\n            return [\n                i ? a : void 0,\n                await Qp(a)\n            ];\n        }\n    };\n});\nvar Yn, Zn, zr, La, Xp, Jp, Sr, Ie, gt = U(()=>{\n    \"use strict\";\n    xr();\n    Zn = !1, zr = !1, La = !1, Xp = ()=>{\n        if (typeof SharedArrayBuffer > \"u\") return !1;\n        try {\n            return typeof MessageChannel < \"u\" && new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)), WebAssembly.validate(new Uint8Array([\n                0,\n                97,\n                115,\n                109,\n                1,\n                0,\n                0,\n                0,\n                1,\n                4,\n                1,\n                96,\n                0,\n                0,\n                3,\n                2,\n                1,\n                0,\n                5,\n                4,\n                1,\n                3,\n                1,\n                1,\n                10,\n                11,\n                1,\n                9,\n                0,\n                65,\n                0,\n                254,\n                16,\n                2,\n                0,\n                26,\n                11\n            ]));\n        } catch (e1) {\n            return !1;\n        }\n    }, Jp = ()=>{\n        try {\n            return WebAssembly.validate(new Uint8Array([\n                0,\n                97,\n                115,\n                109,\n                1,\n                0,\n                0,\n                0,\n                1,\n                4,\n                1,\n                96,\n                0,\n                0,\n                3,\n                2,\n                1,\n                0,\n                10,\n                30,\n                1,\n                28,\n                0,\n                65,\n                0,\n                253,\n                15,\n                253,\n                12,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                253,\n                186,\n                1,\n                26,\n                11\n            ]));\n        } catch (e1) {\n            return !1;\n        }\n    }, Sr = async (e1)=>{\n        if (Zn) return Promise.resolve();\n        if (zr) throw new Error(\"multiple calls to 'initializeWebAssembly()' detected.\");\n        if (La) throw new Error(\"previous call to 'initializeWebAssembly()' failed.\");\n        zr = !0;\n        let t = e1.initTimeout, r = e1.numThreads;\n        if (!Jp()) throw new Error(\"WebAssembly SIMD is not supported in the current environment.\");\n        let n = Xp();\n        r > 1 && !n && (typeof self < \"u\" && !self.crossOriginIsolated && console.warn(\"env.wasm.numThreads is set to \" + r + \", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info.\"), console.warn(\"WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading.\"), e1.numThreads = r = 1);\n        var _a_href, _l_href;\n        let o = e1.wasmPaths, i = typeof o == \"string\" ? o : void 0, a = o === null || o === void 0 ? void 0 : o.mjs, d = (_a_href = a === null || a === void 0 ? void 0 : a.href) !== null && _a_href !== void 0 ? _a_href : a, l = o === null || o === void 0 ? void 0 : o.wasm, p = (_l_href = l === null || l === void 0 ? void 0 : l.href) !== null && _l_href !== void 0 ? _l_href : l, m = e1.wasmBinary, [u, h] = await Wa(d, i, r > 1), _ = !1, y = [];\n        if (t > 0 && y.push(new Promise((g)=>{\n            setTimeout(()=>{\n                _ = !0, g();\n            }, t);\n        })), y.push(new Promise((g, x)=>{\n            let $ = {\n                numThreads: r\n            };\n            if (m) $.wasmBinary = m;\n            else if (p || i) $.locateFile = (v)=>p !== null && p !== void 0 ? p : i + v;\n            else if (d && d.indexOf(\"blob:\") !== 0) $.locateFile = (v)=>new URL(v, d).href;\n            else if (u) {\n                let v = Ua();\n                v && ($.locateFile = (S)=>v + S);\n            }\n            h($).then((v)=>{\n                zr = !1, Zn = !0, Yn = v, g(), u && URL.revokeObjectURL(u);\n            }, (v)=>{\n                zr = !1, La = !0, x(v);\n            });\n        })), await Promise.race(y), _) throw new Error(\"WebAssembly backend initializing failed due to timeout: \".concat(t, \"ms\"));\n    }, Ie = ()=>{\n        if (Zn && Yn) return Yn;\n        throw new Error(\"WebAssembly is not initialized yet.\");\n    };\n});\nvar ke, jt, pe, Or = U(()=>{\n    \"use strict\";\n    gt();\n    ke = (e1, t)=>{\n        let r = Ie(), n = r.lengthBytesUTF8(e1) + 1, o = r._malloc(n);\n        return r.stringToUTF8(e1, o, n), t.push(o), o;\n    }, jt = (e1, t, r, n)=>{\n        if (typeof e1 == \"object\" && e1 !== null) {\n            if (r.has(e1)) throw new Error(\"Circular reference in options\");\n            r.add(e1);\n        }\n        Object.entries(e1).forEach((param)=>{\n            let [o, i] = param;\n            let a = t ? t + o : o;\n            if (typeof i == \"object\") jt(i, a + \".\", r, n);\n            else if (typeof i == \"string\" || typeof i == \"number\") n(a, i.toString());\n            else if (typeof i == \"boolean\") n(a, i ? \"1\" : \"0\");\n            else throw new Error(\"Can't handle extra config type: \".concat(typeof i));\n        });\n    }, pe = (e1)=>{\n        let t = Ie(), r = t.stackSave();\n        try {\n            let n = t.PTR_SIZE, o = t.stackAlloc(2 * n);\n            t._OrtGetLastError(o, o + n);\n            let i = Number(t.getValue(o, n === 4 ? \"i32\" : \"i64\")), a = t.getValue(o + n, \"*\"), d = a ? t.UTF8ToString(a) : \"\";\n            throw new Error(\"\".concat(e1, \" ERROR_CODE: \").concat(i, \", ERROR_MESSAGE: \").concat(d));\n        } finally{\n            t.stackRestore(r);\n        }\n    };\n});\nvar Ga, Ha = U(()=>{\n    \"use strict\";\n    gt();\n    Or();\n    Ga = (e1)=>{\n        let t = Ie(), r = 0, n = [], o = e1 || {};\n        try {\n            if ((e1 === null || e1 === void 0 ? void 0 : e1.logSeverityLevel) === void 0) o.logSeverityLevel = 2;\n            else if (typeof e1.logSeverityLevel != \"number\" || !Number.isInteger(e1.logSeverityLevel) || e1.logSeverityLevel < 0 || e1.logSeverityLevel > 4) throw new Error(\"log serverity level is not valid: \".concat(e1.logSeverityLevel));\n            if ((e1 === null || e1 === void 0 ? void 0 : e1.logVerbosityLevel) === void 0) o.logVerbosityLevel = 0;\n            else if (typeof e1.logVerbosityLevel != \"number\" || !Number.isInteger(e1.logVerbosityLevel)) throw new Error(\"log verbosity level is not valid: \".concat(e1.logVerbosityLevel));\n            (e1 === null || e1 === void 0 ? void 0 : e1.terminate) === void 0 && (o.terminate = !1);\n            let i = 0;\n            return (e1 === null || e1 === void 0 ? void 0 : e1.tag) !== void 0 && (i = ke(e1.tag, n)), r = t._OrtCreateRunOptions(o.logSeverityLevel, o.logVerbosityLevel, !!o.terminate, i), r === 0 && pe(\"Can't create run options.\"), (e1 === null || e1 === void 0 ? void 0 : e1.extra) !== void 0 && jt(e1.extra, \"\", new WeakSet, (a, d)=>{\n                let l = ke(a, n), p = ke(d, n);\n                t._OrtAddRunConfigEntry(r, l, p) !== 0 && pe(\"Can't set a run config entry: \".concat(a, \" - \").concat(d, \".\"));\n            }), [\n                r,\n                n\n            ];\n        } catch (i) {\n            throw r !== 0 && t._OrtReleaseRunOptions(r), n.forEach((a)=>t._free(a)), i;\n        }\n    };\n});\nvar em, tm, rm, nm, Fa, qa = U(()=>{\n    \"use strict\";\n    gt();\n    Or();\n    em = (e1)=>{\n        switch(e1){\n            case \"disabled\":\n                return 0;\n            case \"basic\":\n                return 1;\n            case \"extended\":\n                return 2;\n            case \"all\":\n                return 99;\n            default:\n                throw new Error(\"unsupported graph optimization level: \".concat(e1));\n        }\n    }, tm = (e1)=>{\n        switch(e1){\n            case \"sequential\":\n                return 0;\n            case \"parallel\":\n                return 1;\n            default:\n                throw new Error(\"unsupported execution mode: \".concat(e1));\n        }\n    }, rm = (e1)=>{\n        e1.extra || (e1.extra = {}), e1.extra.session || (e1.extra.session = {});\n        let t = e1.extra.session;\n        t.use_ort_model_bytes_directly || (t.use_ort_model_bytes_directly = \"1\"), e1.executionProviders && e1.executionProviders.some((r)=>(typeof r == \"string\" ? r : r.name) === \"webgpu\") && (e1.enableMemPattern = !1);\n    }, nm = (e1, t, r)=>{\n        for (let n of t){\n            let o = typeof n == \"string\" ? n : n.name;\n            switch(o){\n                case \"webnn\":\n                    if (o = \"WEBNN\", typeof n != \"string\") {\n                        let d = n === null || n === void 0 ? void 0 : n.deviceType;\n                        if (d) {\n                            let l = ke(\"deviceType\", r), p = ke(d, r);\n                            Ie()._OrtAddSessionConfigEntry(e1, l, p) !== 0 && pe(\"Can't set a session config entry: 'deviceType' - \".concat(d, \".\"));\n                        }\n                    }\n                    break;\n                case \"webgpu\":\n                    if (o = \"JS\", typeof n != \"string\") {\n                        let a = n;\n                        if (a === null || a === void 0 ? void 0 : a.preferredLayout) {\n                            if (a.preferredLayout !== \"NCHW\" && a.preferredLayout !== \"NHWC\") throw new Error(\"preferredLayout must be either 'NCHW' or 'NHWC': \".concat(a.preferredLayout));\n                            let d = ke(\"preferredLayout\", r), l = ke(a.preferredLayout, r);\n                            Ie()._OrtAddSessionConfigEntry(e1, d, l) !== 0 && pe(\"Can't set a session config entry: 'preferredLayout' - \".concat(a.preferredLayout, \".\"));\n                        }\n                    }\n                    break;\n                case \"wasm\":\n                case \"cpu\":\n                    continue;\n                default:\n                    throw new Error(\"not supported execution provider: \".concat(o));\n            }\n            let i = ke(o, r);\n            Ie()._OrtAppendExecutionProvider(e1, i) !== 0 && pe(\"Can't append execution provider: \".concat(o, \".\"));\n        }\n    }, Fa = (e1)=>{\n        let t = Ie(), r = 0, n = [], o = e1 || {};\n        rm(o);\n        try {\n            var _o_graphOptimizationLevel, _o_executionMode, _o_logSeverityLevel;\n            let i = em((_o_graphOptimizationLevel = o.graphOptimizationLevel) !== null && _o_graphOptimizationLevel !== void 0 ? _o_graphOptimizationLevel : \"all\"), a = tm((_o_executionMode = o.executionMode) !== null && _o_executionMode !== void 0 ? _o_executionMode : \"sequential\"), d = typeof o.logId == \"string\" ? ke(o.logId, n) : 0, l = (_o_logSeverityLevel = o.logSeverityLevel) !== null && _o_logSeverityLevel !== void 0 ? _o_logSeverityLevel : 2;\n            if (!Number.isInteger(l) || l < 0 || l > 4) throw new Error(\"log serverity level is not valid: \".concat(l));\n            var _o_logVerbosityLevel;\n            let p = (_o_logVerbosityLevel = o.logVerbosityLevel) !== null && _o_logVerbosityLevel !== void 0 ? _o_logVerbosityLevel : 0;\n            if (!Number.isInteger(p) || p < 0 || p > 4) throw new Error(\"log verbosity level is not valid: \".concat(p));\n            let m = typeof o.optimizedModelFilePath == \"string\" ? ke(o.optimizedModelFilePath, n) : 0;\n            if (r = t._OrtCreateSessionOptions(i, !!o.enableCpuMemArena, !!o.enableMemPattern, a, !!o.enableProfiling, 0, d, l, p, m), r === 0 && pe(\"Can't create session options.\"), o.executionProviders && nm(r, o.executionProviders, n), o.enableGraphCapture !== void 0) {\n                if (typeof o.enableGraphCapture != \"boolean\") throw new Error(\"enableGraphCapture must be a boolean value: \".concat(o.enableGraphCapture));\n                let u = ke(\"enableGraphCapture\", n), h = ke(o.enableGraphCapture.toString(), n);\n                t._OrtAddSessionConfigEntry(r, u, h) !== 0 && pe(\"Can't set a session config entry: 'enableGraphCapture' - \".concat(o.enableGraphCapture, \".\"));\n            }\n            if (o.freeDimensionOverrides) for (let [u, h] of Object.entries(o.freeDimensionOverrides)){\n                if (typeof u != \"string\") throw new Error(\"free dimension override name must be a string: \".concat(u));\n                if (typeof h != \"number\" || !Number.isInteger(h) || h < 0) throw new Error(\"free dimension override value must be a non-negative integer: \".concat(h));\n                let _ = ke(u, n);\n                t._OrtAddFreeDimensionOverride(r, _, h) !== 0 && pe(\"Can't set a free dimension override: \".concat(u, \" - \").concat(h, \".\"));\n            }\n            return o.extra !== void 0 && jt(o.extra, \"\", new WeakSet, (u, h)=>{\n                let _ = ke(u, n), y = ke(h, n);\n                t._OrtAddSessionConfigEntry(r, _, y) !== 0 && pe(\"Can't set a session config entry: \".concat(u, \" - \").concat(h, \".\"));\n            }), [\n                r,\n                n\n            ];\n        } catch (i) {\n            throw r !== 0 && t._OrtReleaseSessionOptions(r) !== 0 && pe(\"Can't release session options.\"), n.forEach((a)=>t._free(a)), i;\n        }\n    };\n});\nvar Yt, bt, Ct, Dr, Zt, Br, Mr, Qn, te = U(()=>{\n    \"use strict\";\n    Yt = (e1)=>{\n        switch(e1){\n            case \"int8\":\n                return 3;\n            case \"uint8\":\n                return 2;\n            case \"bool\":\n                return 9;\n            case \"int16\":\n                return 5;\n            case \"uint16\":\n                return 4;\n            case \"int32\":\n                return 6;\n            case \"uint32\":\n                return 12;\n            case \"float16\":\n                return 10;\n            case \"float32\":\n                return 1;\n            case \"float64\":\n                return 11;\n            case \"string\":\n                return 8;\n            case \"int64\":\n                return 7;\n            case \"uint64\":\n                return 13;\n            case \"int4\":\n                return 22;\n            case \"uint4\":\n                return 21;\n            default:\n                throw new Error(\"unsupported data type: \".concat(e1));\n        }\n    }, bt = (e1)=>{\n        switch(e1){\n            case 3:\n                return \"int8\";\n            case 2:\n                return \"uint8\";\n            case 9:\n                return \"bool\";\n            case 5:\n                return \"int16\";\n            case 4:\n                return \"uint16\";\n            case 6:\n                return \"int32\";\n            case 12:\n                return \"uint32\";\n            case 10:\n                return \"float16\";\n            case 1:\n                return \"float32\";\n            case 11:\n                return \"float64\";\n            case 8:\n                return \"string\";\n            case 7:\n                return \"int64\";\n            case 13:\n                return \"uint64\";\n            case 22:\n                return \"int4\";\n            case 21:\n                return \"uint4\";\n            default:\n                throw new Error(\"unsupported data type: \".concat(e1));\n        }\n    }, Ct = (e1, t)=>{\n        let r = [\n            -1,\n            4,\n            1,\n            1,\n            2,\n            2,\n            4,\n            8,\n            -1,\n            1,\n            2,\n            8,\n            4,\n            8,\n            -1,\n            -1,\n            -1,\n            -1,\n            -1,\n            -1,\n            -1,\n            .5,\n            .5\n        ][e1], n = typeof t == \"number\" ? t : t.reduce((o, i)=>o * i, 1);\n        return r > 0 ? Math.ceil(n * r) : void 0;\n    }, Dr = (e1)=>{\n        switch(e1){\n            case \"float16\":\n                return typeof Float16Array < \"u\" && Float16Array.from ? Float16Array : Uint16Array;\n            case \"float32\":\n                return Float32Array;\n            case \"uint8\":\n                return Uint8Array;\n            case \"int8\":\n                return Int8Array;\n            case \"uint16\":\n                return Uint16Array;\n            case \"int16\":\n                return Int16Array;\n            case \"int32\":\n                return Int32Array;\n            case \"bool\":\n                return Uint8Array;\n            case \"float64\":\n                return Float64Array;\n            case \"uint32\":\n                return Uint32Array;\n            case \"int64\":\n                return BigInt64Array;\n            case \"uint64\":\n                return BigUint64Array;\n            default:\n                throw new Error(\"unsupported type: \".concat(e1));\n        }\n    }, Zt = (e1)=>{\n        switch(e1){\n            case \"verbose\":\n                return 0;\n            case \"info\":\n                return 1;\n            case \"warning\":\n                return 2;\n            case \"error\":\n                return 3;\n            case \"fatal\":\n                return 4;\n            default:\n                throw new Error(\"unsupported logging level: \".concat(e1));\n        }\n    }, Br = (e1)=>e1 === \"float32\" || e1 === \"float16\" || e1 === \"int32\" || e1 === \"int64\" || e1 === \"uint32\" || e1 === \"uint8\" || e1 === \"bool\" || e1 === \"uint4\" || e1 === \"int4\", Mr = (e1)=>e1 === \"float32\" || e1 === \"float16\" || e1 === \"int32\" || e1 === \"int64\" || e1 === \"uint32\" || e1 === \"uint64\" || e1 === \"int8\" || e1 === \"uint8\" || e1 === \"bool\" || e1 === \"uint4\" || e1 === \"int4\", Qn = (e1)=>{\n        switch(e1){\n            case \"none\":\n                return 0;\n            case \"cpu\":\n                return 1;\n            case \"cpu-pinned\":\n                return 2;\n            case \"texture\":\n                return 3;\n            case \"gpu-buffer\":\n                return 4;\n            case \"ml-tensor\":\n                return 5;\n            default:\n                throw new Error(\"unsupported data location: \".concat(e1));\n        }\n    };\n});\nvar Qt, Xn = U(()=>{\n    \"use strict\";\n    $r();\n    Qt = async (e1)=>{\n        if (typeof e1 == \"string\") if (false) {}\n        else {\n            let t = await fetch(e1);\n            if (!t.ok) throw new Error(\"failed to load external data file: \".concat(e1));\n            let r = t.headers.get(\"Content-Length\"), n = r ? parseInt(r, 10) : 0;\n            if (n < 1073741824) return new Uint8Array(await t.arrayBuffer());\n            {\n                if (!t.body) throw new Error(\"failed to load external data file: \".concat(e1, \", no response body.\"));\n                let o = t.body.getReader(), i;\n                try {\n                    i = new ArrayBuffer(n);\n                } catch (d) {\n                    if (d instanceof RangeError) {\n                        let l = Math.ceil(n / 65536);\n                        i = new WebAssembly.Memory({\n                            initial: l,\n                            maximum: l\n                        }).buffer;\n                    } else throw d;\n                }\n                let a = 0;\n                for(;;){\n                    let { done: d, value: l } = await o.read();\n                    if (d) break;\n                    let p = l.byteLength;\n                    new Uint8Array(i, a, p).set(l), a += p;\n                }\n                return new Uint8Array(i, 0, n);\n            }\n        }\n        else return e1 instanceof Blob ? new Uint8Array(await e1.arrayBuffer()) : e1 instanceof Uint8Array ? e1 : new Uint8Array(e1);\n    };\n});\nvar om, im, Ka, ja, Rr, am, ue, et = U(()=>{\n    \"use strict\";\n    te();\n    om = [\n        \"V\",\n        \"I\",\n        \"W\",\n        \"E\",\n        \"F\"\n    ], im = (e1, t)=>{\n        console.log(\"[\".concat(om[e1], \",\").concat(new Date().toISOString(), \"]\").concat(t));\n    }, Rr = (e1, t)=>{\n        Ka = e1, ja = t;\n    }, am = (e1, t)=>{\n        let r = Zt(e1), n = Zt(Ka);\n        r >= n && im(r, typeof t == \"function\" ? t() : t);\n    }, ue = function() {\n        for(var _len = arguments.length, e1 = new Array(_len), _key = 0; _key < _len; _key++){\n            e1[_key] = arguments[_key];\n        }\n        ja && am(...e1);\n    };\n});\nvar Ur, Jn = U(()=>{\n    \"use strict\";\n    te();\n    Ur = (e1, t)=>new (Dr(t))(e1);\n});\nvar Nr = U(_c9 = ()=>{\n    \"use strict\";\n});\n_c10 = Nr;\nvar Ya, eo, to, sm, um, Za, no, ro, Xa, Ja = U(()=>{\n    \"use strict\";\n    et();\n    Nr();\n    Ya = new Map([\n        [\n            64,\n            250\n        ],\n        [\n            128,\n            200\n        ],\n        [\n            256,\n            200\n        ],\n        [\n            512,\n            200\n        ],\n        [\n            2048,\n            230\n        ],\n        [\n            4096,\n            200\n        ],\n        [\n            8192,\n            50\n        ],\n        [\n            16384,\n            50\n        ],\n        [\n            32768,\n            50\n        ],\n        [\n            65536,\n            50\n        ],\n        [\n            131072,\n            50\n        ],\n        [\n            262144,\n            50\n        ],\n        [\n            524288,\n            50\n        ],\n        [\n            1048576,\n            50\n        ],\n        [\n            2097152,\n            30\n        ],\n        [\n            4194304,\n            20\n        ],\n        [\n            8388608,\n            10\n        ],\n        [\n            12582912,\n            10\n        ],\n        [\n            16777216,\n            10\n        ],\n        [\n            26214400,\n            15\n        ],\n        [\n            33554432,\n            22\n        ],\n        [\n            44236800,\n            2\n        ],\n        [\n            58982400,\n            6\n        ],\n        [\n            67108864,\n            6\n        ],\n        [\n            134217728,\n            6\n        ],\n        [\n            167772160,\n            6\n        ]\n    ]), eo = [], to = (e1)=>Math.ceil(Number(e1) / 16) * 16, sm = (e1)=>{\n        for(let t = 0; t < eo.length; t++){\n            let r = eo[t];\n            if (e1 <= r) return r;\n        }\n        return Math.ceil(e1 / 16) * 16;\n    }, um = 1, Za = ()=>um++, no = async (e1, t, r, n)=>{\n        let o = to(r), i = e1.device.createBuffer({\n            size: o,\n            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n        });\n        try {\n            let a = e1.getCommandEncoder();\n            e1.endComputePass(), a.copyBufferToBuffer(t, 0, i, 0, o), e1.flush(), await i.mapAsync(GPUMapMode.READ);\n            let d = i.getMappedRange();\n            if (n) {\n                let l = n();\n                return l.set(new Uint8Array(d, 0, r)), l;\n            } else return new Uint8Array(d.slice(0, r));\n        } finally{\n            i.destroy();\n        }\n    }, ro = class {\n        upload(t, r) {\n            let n = r.buffer, o = r.byteOffset, i = r.byteLength, a = to(i), d = this.storageCache.get(t);\n            if (!d) throw new Error(\"gpu data for uploading does not exist\");\n            if (Number(d.originalSize) !== i) throw new Error(\"inconsistent data size. gpu data size=\".concat(d.originalSize, \", data size=\").concat(i));\n            let l = this.backend.device.createBuffer({\n                mappedAtCreation: !0,\n                size: a,\n                usage: GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC\n            }), p = l.getMappedRange();\n            new Uint8Array(p).set(new Uint8Array(n, o, i)), l.unmap();\n            let m = this.backend.device.createCommandEncoder();\n            m.copyBufferToBuffer(l, 0, d.gpuData.buffer, 0, a), this.backend.device.queue.submit([\n                m.finish()\n            ]), l.destroy(), ue(\"verbose\", ()=>\"[WebGPU] GpuDataManager.upload(id=\".concat(t, \")\"));\n        }\n        memcpy(t, r) {\n            let n = this.storageCache.get(t);\n            if (!n) throw new Error(\"source gpu data for memcpy does not exist\");\n            let o = this.storageCache.get(r);\n            if (!o) throw new Error(\"destination gpu data for memcpy does not exist\");\n            if (n.originalSize !== o.originalSize) throw new Error(\"inconsistent source and destination gpu data size\");\n            let i = to(n.originalSize), a = this.backend.getCommandEncoder();\n            this.backend.endComputePass(), a.copyBufferToBuffer(n.gpuData.buffer, 0, o.gpuData.buffer, 0, i);\n        }\n        registerExternalBuffer(t, r, n) {\n            let o;\n            if (n) {\n                if (o = n[0], t === n[1]) return ue(\"verbose\", ()=>\"[WebGPU] GpuDataManager.registerExternalBuffer(size=\".concat(r, \") => id=\").concat(o, \", buffer is the same, skip.\")), o;\n                if (this.backend.capturedCommandList.has(this.backend.currentSessionId)) throw new Error(\"Registering a different external buffer under graph capture mode is not supported yet.\\n             Please use the previous external buffer!\");\n            } else o = Za();\n            return this.storageCache.set(o, {\n                gpuData: {\n                    id: o,\n                    type: 0,\n                    buffer: t\n                },\n                originalSize: r\n            }), ue(\"verbose\", ()=>\"[WebGPU] GpuDataManager.registerExternalBuffer(size=\".concat(r, \") => id=\").concat(o, \", registered.\")), o;\n        }\n        unregisterExternalBuffer(t) {\n            t !== void 0 && (this.storageCache.delete(t), ue(\"verbose\", ()=>\"[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=\".concat(t)));\n        }\n        create(t) {\n            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST;\n            let n = sm(t), o, i = (r & GPUBufferUsage.STORAGE) === GPUBufferUsage.STORAGE, a = (r & GPUBufferUsage.UNIFORM) === GPUBufferUsage.UNIFORM;\n            if (i || a) {\n                let p = (i ? this.freeBuffers : this.freeUniformBuffers).get(n);\n                p ? p.length > 0 ? o = p.pop() : o = this.backend.device.createBuffer({\n                    size: n,\n                    usage: r\n                }) : o = this.backend.device.createBuffer({\n                    size: n,\n                    usage: r\n                });\n            } else o = this.backend.device.createBuffer({\n                size: n,\n                usage: r\n            });\n            let d = {\n                id: Za(),\n                type: 0,\n                buffer: o\n            };\n            return this.storageCache.set(d.id, {\n                gpuData: d,\n                originalSize: Number(t)\n            }), ue(\"verbose\", ()=>\"[WebGPU] GpuDataManager.create(size=\".concat(t, \") => id=\").concat(d.id)), d;\n        }\n        get(t) {\n            var _this_storageCache_get;\n            return (_this_storageCache_get = this.storageCache.get(t)) === null || _this_storageCache_get === void 0 ? void 0 : _this_storageCache_get.gpuData;\n        }\n        release(t) {\n            let r = typeof t == \"bigint\" ? Number(t) : t, n = this.storageCache.get(r);\n            if (!n) {\n                if (this.storageCache.size === 0) return 0;\n                throw new Error(\"releasing data does not exist\");\n            }\n            return ue(\"verbose\", ()=>\"[WebGPU] GpuDataManager.release(id=\".concat(r, \"), gpuDataId=\").concat(n.gpuData.id)), this.storageCache.delete(r), this.buffersPending.push(n.gpuData.buffer), n.originalSize;\n        }\n        async download(t, r) {\n            let n = this.storageCache.get(Number(t));\n            if (!n) throw new Error(\"data does not exist\");\n            await no(this.backend, n.gpuData.buffer, n.originalSize, r);\n        }\n        refreshPendingBuffers() {\n            if (this.buffersPending.length !== 0) if (this.backend.sessionStatus === \"default\") {\n                for (let t of this.buffersPending){\n                    let r = Ya.get(t.size);\n                    if ((t.usage & GPUBufferUsage.STORAGE) === GPUBufferUsage.STORAGE) {\n                        let n = this.freeBuffers.get(t.size) || [];\n                        r === void 0 || n.length >= r ? t.destroy() : n.push(t);\n                    } else if ((t.usage & GPUBufferUsage.UNIFORM) === GPUBufferUsage.UNIFORM) {\n                        let n = this.freeUniformBuffers.get(t.size) || [];\n                        r === void 0 || n.length >= r ? t.destroy() : n.push(t);\n                    } else t.destroy();\n                }\n                this.buffersPending = [];\n            } else {\n                let t = this.capturedPendingBuffers.get(this.backend.currentSessionId);\n                t || (t = [], this.capturedPendingBuffers.set(this.backend.currentSessionId, t));\n                for (let r of this.buffersPending)t.push(r);\n                this.buffersPending = [];\n            }\n        }\n        dispose() {\n            this.freeBuffers.forEach((t)=>{\n                t.forEach((r)=>{\n                    r.destroy();\n                });\n            }), this.freeUniformBuffers.forEach((t)=>{\n                t.forEach((r)=>{\n                    r.destroy();\n                });\n            }), this.storageCache.forEach((t)=>{\n                t.gpuData.buffer.destroy();\n            }), this.capturedPendingBuffers.forEach((t)=>{\n                t.forEach((r)=>{\n                    r.destroy();\n                });\n            }), this.storageCache = new Map, this.freeBuffers = new Map, this.freeUniformBuffers = new Map, this.capturedPendingBuffers = new Map;\n        }\n        onCreateSession() {\n            this.sessionCount += 1;\n        }\n        onReleaseSession(t) {\n            let r = this.capturedPendingBuffers.get(t);\n            r && (r.forEach((n)=>{\n                n.destroy();\n            }), this.capturedPendingBuffers.delete(t)), this.sessionCount -= 1, this.sessionCount === 0 && (ue(\"warning\", ()=>\"[WebGPU] Clearing webgpu buffer cache\"), this.storageCache.forEach((n)=>{\n                n.gpuData.buffer.destroy();\n            }), this.storageCache = new Map);\n        }\n        constructor(t){\n            this.backend = t;\n            this.storageCache = new Map, this.freeBuffers = new Map, this.freeUniformBuffers = new Map, this.buffersPending = [], this.capturedPendingBuffers = new Map;\n            for (let [r] of Ya)eo.push(r), this.freeBuffers.set(r, []), this.freeUniformBuffers.set(r, []);\n            this.sessionCount = 0;\n        }\n    }, Xa = function() {\n        for(var _len = arguments.length, e1 = new Array(_len), _key = 0; _key < _len; _key++){\n            e1[_key] = arguments[_key];\n        }\n        return new ro(...e1);\n    };\n});\nvar oo, re, Se = U(()=>{\n    \"use strict\";\n    oo = class {\n        get cacheKey() {\n            return this.key || (this.key = Object.getOwnPropertyNames(this).sort().map((t)=>\"\".concat(this[t])).join(\";\")), this.key;\n        }\n        constructor(t){\n            Object.assign(this, t);\n        }\n    }, re = (e1)=>new oo(e1);\n});\nvar io, tt, C, At, Vr, es, ts, oe = U(()=>{\n    \"use strict\";\n    io = class {\n        static calcMatMulShape(t, r) {\n            return t[1] !== r[0] ? void 0 : [\n                t[0],\n                r[1]\n            ];\n        }\n    }, tt = class {\n        static calcShape(t, r) {\n            let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;\n            let o = t.length, i = r.length;\n            if (o === 0) return r;\n            if (i === 0) return t;\n            let a = Math.max(t.length, r.length), d = new Array(a);\n            if (n) {\n                if (o < 2 || i < 2) return;\n                let l = io.calcMatMulShape([\n                    t[o - 2],\n                    t[o - 1]\n                ], [\n                    r[i - 2],\n                    r[i - 1]\n                ]);\n                if (l === void 0) return;\n                [d[a - 2], d[a - 1]] = l;\n            }\n            for(let l = n ? 3 : 1; l <= a; l++){\n                let p = o - l < 0 ? 1 : t[o - l], m = i - l < 0 ? 1 : r[i - l];\n                if (p !== m && p > 1 && m > 1) return;\n                let u = Math.max(p, m);\n                if (p && m) d[a - l] = Math.max(p, m);\n                else {\n                    if (u > 1) return;\n                    d[a - l] = 0;\n                }\n            }\n            return d;\n        }\n        static isValidBroadcast(t, r) {\n            let n = t.length, o = r.length;\n            if (n > o) return !1;\n            for(let i = 1; i <= n; i++)if (t[n - i] !== 1 && t[n - i] !== r[o - i]) return !1;\n            return !0;\n        }\n    }, C = class e1 {\n        static size(t) {\n            return e1.getSizeFromDimensionRange(t, 0, t.length);\n        }\n        static convertShape(t) {\n            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 4;\n            let n = t.length;\n            if (n === 0) return [];\n            let o = new Array(n), i = n - 1;\n            for(; i >= 0;){\n                if (t[i] % r === 0) {\n                    o[i] = t[i] / r;\n                    break;\n                }\n                if (r % t[i] !== 0) throw new Error(\"cannot convert shape\");\n                o[i] = 1, r /= t[i], i--;\n            }\n            for(i--; i >= 0; i--)o[i] = t[i];\n            return o;\n        }\n        static sizeFromDimension(t, r) {\n            if (r < 0 || r > t.length) throw new Error(\"invalid dimension of \".concat(r, \" for sizeFromDimension as Tensor has \").concat(t.length, \" dimensions.\"));\n            return e1.getSizeFromDimensionRange(t, r, t.length);\n        }\n        static sizeToDimension(t, r) {\n            if (r < 0 || r > t.length) throw new Error(\"invalid dimension of \".concat(r, \" for sizeToDimension as Tensor has \").concat(t.length, \" dimensions.\"));\n            return e1.getSizeFromDimensionRange(t, 0, r);\n        }\n        static getSizeFromDimensionRange(t, r, n) {\n            let o = 1;\n            for(let i = r; i < n; i++){\n                if (t[i] < 0) throw new Error(\"cannot get valid size from specified dimension range. Most likely the range contains negative values in them.\");\n                o *= Number(t[i]);\n            }\n            return o;\n        }\n        static computeStrides(t) {\n            let r = t.length;\n            if (r === 0) return [];\n            if (r === 1) return [\n                1\n            ];\n            let n = new Array(r);\n            n[r - 1] = 1, n[r - 2] = t[r - 1];\n            for(let o = r - 3; o >= 0; --o)n[o] = n[o + 1] * t[o + 1];\n            return n;\n        }\n        static normalizeAxis(t, r) {\n            if (t < -r && t >= r) throw new Error(\"unsupported axis for this operation.\");\n            return t < 0 ? t + r : t;\n        }\n        static normalizeAxes(t, r) {\n            return t.map((n)=>this.normalizeAxis(n, r !== null && r !== void 0 ? r : t.length));\n        }\n        static sortBasedOnPerm(t, r) {\n            return r ? r.map((n)=>t[n]) : t.slice().reverse();\n        }\n        static padShape(t, r) {\n            let n = t.length;\n            return t.map((o, i)=>o + r[i] + r[i + n]);\n        }\n        static areEqual(t, r) {\n            return t.length !== r.length ? !1 : t.every((n, o)=>n === r[o]);\n        }\n    }, At = class e1 {\n        static adjustPoolAttributes(t, r, n, o, i, a) {\n            if (!t && n.length !== r.length - 2) throw new Error(\"length of specified kernel shapes should be 2 less than length of input dimensions\");\n            if (t) for(let d = 0; d < r.length - 2; d++)d >= n.length ? n.push(r[d + 2]) : n[d] = r[d + 2];\n            for(let d = 0; d < n.length; d++)if (d < o.length) {\n                if (o[d] < 0) throw new Error(\"strides should be greater than or equal to 1\");\n            } else o.push(1);\n            for(let d = 0; d < n.length; d++)if (d < i.length) {\n                if (i[d] < 0) throw new Error(\"dilations should be greater than or equal to 1\");\n            } else i.push(1);\n            for(let d = 0; d < n.length * 2; d++)if (d < a.length) {\n                if (a[d] < 0) throw new Error(\"pad should be greater than or equal to 1\");\n            } else a.push(0);\n            for(let d = 0; d < n.length; d++){\n                if (n[d] <= 0) throw new Error(\"kernel shapes need to be greater than 0\");\n                if (a[d] >= n[d] || a[d + n.length] >= n[d]) throw new Error(\"pads should be smaller than kernel\");\n            }\n        }\n        static adjustPadsBasedOnAutoPad(t, r, n, o, i, a, d) {\n            if (d) {\n                if (i.length !== 2 * (t.length - 2)) throw new Error(\"length of pads should be twice the length of data dimensions\");\n                if (r.length !== t.length - 2) throw new Error(\"length of strides should be the length of data dimensions\");\n                if (o.length !== t.length - 2) throw new Error(\"length of kernel shapes should be the length of data dimensions\");\n                for(let l = 0; l < t.length - 2; l++)e1.adjustPadAndReturnShape(t[l + (a ? 1 : 2)], r[l], n[l], o[l], i, l, l + t.length - 2, d);\n            }\n        }\n        static computePoolOutputShape(t, r, n, o, i, a, d) {\n            if (r.length <= 0) throw new Error(\"input shape must be of size greater than 0\");\n            let l = [\n                r[0],\n                r[1]\n            ];\n            return e1.computeShapeHelper(t, r, l, n, o, i, a, d), l;\n        }\n        static computeConvOutputShape(t, r, n, o, i, a, d) {\n            if (t.length <= 0 || r.length <= 0) throw new Error(\"invalid input tensor dims or invalid filter tensor dims\");\n            let l = [\n                t[0],\n                r[0]\n            ];\n            return e1.computeShapeHelper(!1, t, l, n, o, i, a, d), l;\n        }\n        static computeShapeHelper(t, r, n, o, i, a, d, l) {\n            if (t) for(let p = 0; p < r.length - 2; p++)n.push(1);\n            else for(let p = 0; p < r.length - 2; p++)n.push(e1.adjustPadAndReturnShape(r[p + 2], o[p], i[p], a[p], d, p, p + r.length - 2, l));\n        }\n        static adjustPadAndReturnShape(t, r, n, o, i, a, d, l) {\n            let p = n * (o - 1) + 1;\n            if (l && l !== \"NOTSET\") switch(l){\n                case \"VALID\":\n                    return i[a] = 0, i[d] = 0, Math.floor((t - p) / r + 1);\n                case \"SAME_LOWER\":\n                case \"SAME_UPPER\":\n                    if (n !== 1) throw new Error(\"Dilation not supported for SAME_UPPER or SAME_LOWER\");\n                    {\n                        let u = ((t + r - 1) / r - 1) * r + o - t;\n                        return i[a] = Math.floor(l === \"SAME_LOWER\" ? (u + 1) / 2 : u / 2), i[d] = u - i[a], Math.floor((t + u - o) / r + 1);\n                    }\n                default:\n                    throw new Error(\"Unsupported AutoPad type\");\n            }\n            else return Math.floor((t + i[a] + i[d] - p) / r + 1);\n        }\n    }, Vr = class {\n        static getShapeOfGemmResult(t, r, n, o, i) {\n            if (t.length !== 2 || n.length !== 2) throw new Error(\"shape need to be of size 2\");\n            let a, d, l;\n            r ? (a = t[1], d = t[0]) : (a = t[0], d = t[1]);\n            let p = -1;\n            if (o ? (l = n[0], p = 1) : (l = n[1], p = 0), n[p] !== d) throw new Error(\"dimension mismatch\");\n            if (a <= 0 || l <= 0 || d <= 0) throw new Error(\"invalid shape specified\");\n            if (i && !tt.isValidBroadcast(i, [\n                a,\n                l\n            ])) throw new Error(\"gemm: invalid bias shape for broadcast\");\n            return [\n                a,\n                l,\n                d\n            ];\n        }\n    }, es = -34028234663852886e22, ts = 34028234663852886e22;\n});\nvar kt, so, _e, Ee, N, me, uo, Et, Fe, F, Wr, E, M, rs, Lr, ao, ns, ae = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    kt = 64, so = (e1, t)=>{\n        if (t === 3) throw new Error(\"vec3 has same alignment as vec4, use vec4 instead\");\n        switch(Number(e1)){\n            case 10:\n                return t > 1 ? \"vec\".concat(t, \"<f16>\") : \"f16\";\n            case 1:\n                return t > 1 ? \"vec\".concat(t, \"<f32>\") : \"f32\";\n            case 6:\n                return t > 1 ? \"vec\".concat(t, \"<i32>\") : \"i32\";\n            case 12:\n                return t > 1 ? \"vec\".concat(t, \"<u32>\") : \"u32\";\n            case 7:\n                if (t > 1) throw new Error(\"currently not supported vecX of uint64 yet\");\n                return [\n                    \"vec2<u32>\",\n                    \"i32\"\n                ];\n            case 13:\n                if (t > 1) throw new Error(\"currently not supported vecX of uint64 yet\");\n                return [\n                    \"vec2<u32>\",\n                    \"u32\"\n                ];\n            case 9:\n                if (t !== 4) throw new Error(\"bool must be vec4\");\n                return [\n                    \"u32\",\n                    \"vec4<bool>\"\n                ];\n            case 22:\n                return \"i32\";\n            case 21:\n                return \"u32\";\n            default:\n                throw new Error(\"Unknown data type: \".concat(e1));\n        }\n    }, _e = function(e1) {\n        let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n        let r = so(e1, t);\n        return typeof r == \"string\" ? r : r[0];\n    }, Ee = function(e1) {\n        let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n        let r = so(e1, t);\n        return typeof r == \"string\" ? r : r[1];\n    }, N = function() {\n        for(var _len = arguments.length, e1 = new Array(_len), _key = 0; _key < _len; _key++){\n            e1[_key] = arguments[_key];\n        }\n        let t = [];\n        return e1.forEach((r)=>{\n            r.length !== 0 && t.push({\n                type: 12,\n                data: r\n            }, {\n                type: 12,\n                data: C.computeStrides(r)\n            });\n        }), t;\n    }, me = (e1)=>e1 % 4 === 0 ? 4 : e1 % 2 === 0 ? 2 : 1, uo = function() {\n        let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"f32\", t = arguments.length > 1 ? arguments[1] : void 0, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"0\";\n        return !t || t === 1 ? \"\".concat(e1, \"(\").concat(r, \")\") : \"vec\".concat(t, \"<\").concat(e1, \">(\").concat(r, \")\");\n    }, Et = (e1, t, r)=>e1 === \"f32\" ? r : t === 1 ? \"f32(\".concat(r, \")\") : \"vec\".concat(t, \"<f32>(\").concat(r, \")\"), Fe = (e1, t)=>t === 4 ? \"(\".concat(e1, \".x + \").concat(e1, \".y + \").concat(e1, \".z + \").concat(e1, \".w)\") : t === 2 ? \"(\".concat(e1, \".x + \").concat(e1, \".y)\") : t === 3 ? \"(\".concat(e1, \".x + \").concat(e1, \".y + \").concat(e1, \".z)\") : e1, F = (e1, t, r, n)=>e1.startsWith(\"uniforms.\") && r > 4 ? typeof t == \"string\" ? n === \"f16\" ? \"\".concat(e1, \"[(\").concat(t, \") / 8][(\").concat(t, \") % 8 / 4][(\").concat(t, \") % 8 % 4]\") : \"\".concat(e1, \"[(\").concat(t, \") / 4][(\").concat(t, \") % 4]\") : n === \"f16\" ? \"\".concat(e1, \"[\").concat(Math.floor(t / 8), \"][\").concat(Math.floor(t % 8 / 4), \"][\").concat(t % 8 % 4, \"]\") : \"\".concat(e1, \"[\").concat(Math.floor(t / 4), \"][\").concat(t % 4, \"]\") : r > 1 ? \"\".concat(e1, \"[\").concat(t, \"]\") : e1, Wr = (e1, t, r, n, o)=>{\n        let i = typeof r == \"number\", a = i ? r : r.length, d = [\n            ...new Array(a).keys()\n        ], l = a < 2 ? \"u32\" : a <= 4 ? \"vec\".concat(a, \"<u32>\") : \"array<u32, \".concat(a, \">\"), p = so(t, o), m = typeof p == \"string\" ? p : p[1], u = typeof p == \"string\" ? p : p[0], h = {\n            indices: l,\n            value: m,\n            storage: u,\n            tensor: t\n        }, _ = (W)=>typeof W == \"string\" ? W : \"\".concat(W, \"u\"), y = {\n            offsetToIndices: !1,\n            indicesToOffset: !1,\n            broadcastedIndicesToOffset: !1,\n            set: !1,\n            setByIndices: !1,\n            get: !1,\n            getByIndices: !1\n        }, g = i ? \"uniforms.\" : \"\", x = \"\".concat(g).concat(e1, \"_shape\"), $ = \"\".concat(g).concat(e1, \"_strides\"), v = \"\";\n        for(let W = 0; W < a - 1; W++)v += \"\\n    let dim\".concat(W, \" = current / \").concat(F($, W, a), \";\\n    let rest\").concat(W, \" = current % \").concat(F($, W, a), \";\\n    indices[\").concat(W, \"] = dim\").concat(W, \";\\n    current = rest\").concat(W, \";\\n    \");\n        v += \"indices[\".concat(a - 1, \"] = current;\");\n        let S = a < 2 ? \"\" : \"\\n  fn o2i_\".concat(e1, \"(offset: u32) -> \").concat(h.indices, \" {\\n    var indices: \").concat(h.indices, \";\\n    var current = offset;\\n    \").concat(v, \"\\n    return indices;\\n  }\"), T = (W)=>(y.offsetToIndices = !0, a < 2 ? W : \"o2i_\".concat(e1, \"(\").concat(W, \")\")), A = [];\n        if (a >= 2) for(let W = a - 1; W >= 0; W--)A.push(\"\".concat(F($, W, a), \" * (indices[\").concat(W, \"])\"));\n        let k = a < 2 ? \"\" : \"\\n  fn i2o_\".concat(e1, \"(indices: \").concat(h.indices, \") -> u32 {\\n    return \").concat(A.join(\"+\"), \";\\n  }\"), P = (W)=>(y.indicesToOffset = !0, a < 2 ? W : \"i2o_\".concat(e1, \"(\").concat(W, \")\")), D = function() {\n            for(var _len = arguments.length, W = new Array(_len), _key = 0; _key < _len; _key++){\n                W[_key] = arguments[_key];\n            }\n            return a === 0 ? \"0u\" : \"\".concat(h.indices, \"(\").concat(W.map(_).join(\",\"), \")\");\n        }, R = (W, q)=>a < 2 ? \"\".concat(W) : \"\".concat(F(W, q, a)), G = (W, q, he)=>a < 2 ? \"\".concat(W, \"=\").concat(he, \";\") : \"\".concat(F(W, q, a), \"=\").concat(he, \";\"), K = {}, j = (W, q)=>{\n            y.broadcastedIndicesToOffset = !0;\n            let he = \"\".concat(q.name, \"broadcastedIndicesTo\").concat(e1, \"Offset\");\n            if (he in K) return \"\".concat(he, \"(\").concat(W, \")\");\n            let Ge = [];\n            for(let we = a - 1; we >= 0; we--){\n                let ye = q.indicesGet(\"outputIndices\", we + q.rank - a);\n                Ge.push(\"\".concat(R($, we), \" * (\").concat(ye, \" % \").concat(R(x, we), \")\"));\n            }\n            return K[he] = \"fn \".concat(he, \"(outputIndices: \").concat(q.type.indices, \") -> u32 {\\n             return \").concat(Ge.length > 0 ? Ge.join(\"+\") : \"0u\", \";\\n           }\"), \"\".concat(he, \"(\").concat(W, \")\");\n        }, V = (W, q)=>(()=>{\n                if (h.storage === h.value) return \"\".concat(e1, \"[\").concat(W, \"]=\").concat(q, \";\");\n                if (h.storage === \"vec2<u32>\" && h.value === \"i32\") return \"\".concat(e1, \"[\").concat(W, \"]=vec2<u32>(u32(\").concat(q, \"), select(0u, 0xFFFFFFFFu, \").concat(q, \" < 0));\");\n                if (h.storage === \"vec2<u32>\" && h.value === \"u32\") return \"\".concat(e1, \"[\").concat(W, \"]=vec2<u32>(u32(\").concat(q, \"), 0u);\");\n                if (h.storage === \"u32\" && h.value === \"vec4<bool>\") return \"\".concat(e1, \"[\").concat(W, \"]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(\").concat(q, \"));\");\n                throw new Error(\"not supported combination of storage type \".concat(h.storage, \" and value type \").concat(h.value, \" yet\"));\n            })(), Q = (W)=>(()=>{\n                if (h.storage === h.value) return \"\".concat(e1, \"[\").concat(W, \"]\");\n                if (h.storage === \"vec2<u32>\" && h.value === \"i32\") return \"i32(\".concat(e1, \"[\").concat(W, \"].x)\");\n                if (h.storage === \"vec2<u32>\" && h.value === \"u32\") return \"u32(\".concat(e1, \"[\").concat(W, \"].x)\");\n                if (h.storage === \"u32\" && h.value === \"vec4<bool>\") return \"vec4<bool>(bool(\".concat(e1, \"[\").concat(W, \"] & 0xFFu), bool(\").concat(e1, \"[\").concat(W, \"] & 0xFF00u), bool(\").concat(e1, \"[\").concat(W, \"] & 0xFF0000u), bool(\").concat(e1, \"[\").concat(W, \"] & 0xFF000000u))\");\n                throw new Error(\"not supported combination of storage type \".concat(h.storage, \" and value type \").concat(h.value, \" yet\"));\n            })(), se = a < 2 ? \"\" : \"\\n  fn get_\".concat(e1, \"ByIndices(indices: \").concat(h.indices, \") -> \").concat(m, \" {\\n    return \").concat(Q(\"i2o_\".concat(e1, \"(indices)\")), \";\\n  }\"), Y = a < 2 ? \"\" : (()=>{\n            let W = d.map((he)=>\"d\".concat(he, \": u32\")).join(\", \"), q = d.map((he)=>\"d\".concat(he)).join(\", \");\n            return \"\\n  fn get_\".concat(e1, \"(\").concat(W, \") -> \").concat(m, \" {\\n    return get_\").concat(e1, \"ByIndices(\").concat(D(q), \");\\n  }\");\n        })(), ee = function() {\n            for(var _len = arguments.length, W = new Array(_len), _key = 0; _key < _len; _key++){\n                W[_key] = arguments[_key];\n            }\n            if (W.length !== a) throw new Error(\"indices length must be \".concat(a));\n            let q = W.map(_).join(\",\");\n            return a === 0 ? Q(\"0u\") : a === 1 ? Q(q[0]) : (y.get = !0, y.getByIndices = !0, y.indicesToOffset = !0, \"get_\".concat(e1, \"(\").concat(q, \")\"));\n        }, J = (W)=>a < 2 ? Q(W) : (y.getByIndices = !0, y.indicesToOffset = !0, \"get_\".concat(e1, \"ByIndices(\").concat(W, \")\")), ne = a < 2 ? \"\" : \"\\n  fn set_\".concat(e1, \"ByIndices(indices: \").concat(h.indices, \", value: \").concat(m, \") {\\n    \").concat(V(\"i2o_\".concat(e1, \"(indices)\"), \"value\"), \"\\n  }\"), be = a < 2 ? \"\" : (()=>{\n            let W = d.map((he)=>\"d\".concat(he, \": u32\")).join(\", \"), q = d.map((he)=>\"d\".concat(he)).join(\", \");\n            return \"\\n  fn set_\".concat(e1, \"(\").concat(W, \", value: \").concat(m, \") {\\n    set_\").concat(e1, \"ByIndices(\").concat(D(q), \", value);\\n  }\");\n        })();\n        return {\n            impl: ()=>{\n                let W = [], q = !1;\n                return y.offsetToIndices && (W.push(S), q = !0), y.indicesToOffset && (W.push(k), q = !0), y.broadcastedIndicesToOffset && (Object.values(K).forEach((he)=>W.push(he)), q = !0), y.set && (W.push(be), q = !0), y.setByIndices && (W.push(ne), q = !0), y.get && (W.push(Y), q = !0), y.getByIndices && (W.push(se), q = !0), !i && q && W.unshift(\"const \".concat(x, \" = \").concat(h.indices, \"(\").concat(r.join(\",\"), \");\"), \"const \".concat($, \" = \").concat(h.indices, \"(\").concat(C.computeStrides(r).join(\",\"), \");\")), W.join(\"\\n\");\n            },\n            type: h,\n            offsetToIndices: T,\n            indicesToOffset: P,\n            broadcastedIndicesToOffset: j,\n            indices: D,\n            indicesGet: R,\n            indicesSet: G,\n            set: function() {\n                for(var _len = arguments.length, W = new Array(_len), _key = 0; _key < _len; _key++){\n                    W[_key] = arguments[_key];\n                }\n                if (W.length !== a + 1) throw new Error(\"indices length must be \".concat(a));\n                let q = W[a];\n                if (typeof q != \"string\") throw new Error(\"value must be string\");\n                let he = W.slice(0, a).map(_).join(\",\");\n                return a === 0 ? V(\"0u\", q) : a === 1 ? V(he[0], q) : (y.set = !0, y.setByIndices = !0, y.indicesToOffset = !0, \"set_\".concat(e1, \"(\").concat(he, \", \").concat(q, \")\"));\n            },\n            setByOffset: V,\n            setByIndices: (W, q)=>a < 2 ? V(W, q) : (y.setByIndices = !0, y.indicesToOffset = !0, \"set_\".concat(e1, \"ByIndices(\").concat(W, \", \").concat(q, \");\")),\n            get: ee,\n            getByOffset: Q,\n            getByIndices: J,\n            usage: n,\n            name: e1,\n            strides: $,\n            shape: x,\n            rank: a\n        };\n    }, E = function(e1, t, r) {\n        let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;\n        return Wr(e1, t, r, \"input\", n);\n    }, M = function(e1, t, r) {\n        let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;\n        return Wr(e1, t, r, \"output\", n);\n    }, rs = (e1, t, r)=>Wr(e1, t, r, \"atomicOutput\", 1), Lr = function(e1, t, r) {\n        let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;\n        return Wr(e1, t, r, \"internal\", n);\n    }, ao = class {\n        guardAgainstOutOfBoundsWorkgroupSizes(t) {\n            return \"if (global_idx >= \".concat(typeof t == \"number\" ? \"\".concat(t, \"u\") : t, \") { return; }\");\n        }\n        mainStart() {\n            let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : kt;\n            let r = typeof t == \"number\" ? t : t[0], n = typeof t == \"number\" ? 1 : t[1], o = typeof t == \"number\" ? 1 : t[2];\n            if (r > this.limits.maxComputeWorkgroupSizeX || n > this.limits.maxComputeWorkgroupSizeY || o > this.limits.maxComputeWorkgroupSizeZ) throw new Error(\"workgroup size [\".concat(r, \", \").concat(n, \", \").concat(o, \"] exceeds the maximum workgroup size [\").concat(this.limits.maxComputeWorkgroupSizeX, \", \").concat(this.limits.maxComputeWorkgroupSizeY, \", \").concat(this.limits.maxComputeWorkgroupSizeZ, \"].\"));\n            if (r * n * o > this.limits.maxComputeInvocationsPerWorkgroup) throw new Error(\"workgroup size [\".concat(r, \", \").concat(n, \", \").concat(o, \"] exceeds the maximum workgroup invocations \").concat(this.limits.maxComputeInvocationsPerWorkgroup, \".\"));\n            let i = this.normalizedDispatchGroup[1] === 1 && this.normalizedDispatchGroup[2] === 1, a = i ? \"@builtin(global_invocation_id) global_id : vec3<u32>,\\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\\n    @builtin(local_invocation_index) local_idx : u32,\\n    @builtin(local_invocation_id) local_id : vec3<u32>\" : \"@builtin(global_invocation_id) global_id : vec3<u32>,\\n                                             @builtin(local_invocation_id) local_id : vec3<u32>,\\n    @builtin(local_invocation_index) local_idx : u32,\\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\\n    @builtin(num_workgroups) num_workgroups : vec3<u32>\", d = i ? \"let global_idx = global_id.x;\\n         let workgroup_index = workgroup_id.x;\" : \"let workgroup_index = workgroup_id.z * num_workgroups[0] * num_workgroups[1] +\\n             workgroup_id.y * num_workgroups[0] + workgroup_id.x;\\n         let global_idx = workgroup_index * \".concat(r * n * o, \"u + local_idx;\");\n            return \"@compute @workgroup_size(\".concat(r, \", \").concat(n, \", \").concat(o, \")\\n  fn main(\").concat(a, \") {\\n    \").concat(d, \"\\n  \");\n        }\n        appendVariableUniforms(t) {\n            t.rank !== 0 && (t.shape.startsWith(\"uniforms.\") && this.uniforms.push({\n                name: t.shape.replace(\"uniforms.\", \"\"),\n                type: \"u32\",\n                length: t.rank\n            }), t.strides.startsWith(\"uniforms.\") && this.uniforms.push({\n                name: t.strides.replace(\"uniforms.\", \"\"),\n                type: \"u32\",\n                length: t.rank\n            }));\n        }\n        declareVariable(t, r) {\n            if (t.usage === \"internal\") throw new Error(\"cannot use internal variable with declareVariable(). use registerInternalVariables() instead.\");\n            this.variables.push(t), this.appendVariableUniforms(t);\n            let n = t.usage === \"input\" ? \"read\" : \"read_write\", o = t.usage === \"atomicOutput\" ? \"atomic<i32>\" : t.type.storage;\n            return \"@group(0) @binding(\".concat(r, \") var<storage, \").concat(n, \"> \").concat(t.name, \": array<\").concat(o, \">;\");\n        }\n        declareVariables() {\n            for(var _len = arguments.length, t = new Array(_len), _key = 0; _key < _len; _key++){\n                t[_key] = arguments[_key];\n            }\n            return t.map((r)=>this.declareVariable(r, this.variableIndex++)).join(\"\\n\");\n        }\n        registerInternalVariable(t) {\n            if (t.usage !== \"internal\") throw new Error(\"cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.\");\n            this.internalVariables.push(t), this.appendVariableUniforms(t);\n        }\n        registerInternalVariables() {\n            for(var _len = arguments.length, t = new Array(_len), _key = 0; _key < _len; _key++){\n                t[_key] = arguments[_key];\n            }\n            return t.forEach((r)=>this.registerInternalVariable(r)), this;\n        }\n        registerUniform(t, r) {\n            let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;\n            return this.uniforms.push({\n                name: t,\n                type: r,\n                length: n\n            }), this;\n        }\n        registerUniforms(t) {\n            return this.uniforms = this.uniforms.concat(t), this;\n        }\n        uniformDeclaration() {\n            if (this.uniforms.length === 0) return \"\";\n            let t = [];\n            for (let { name: r, type: n, length: o } of this.uniforms)if (o && o > 4) n === \"f16\" ? t.push(\"@align(16) \".concat(r, \":array<mat2x4<\").concat(n, \">, \").concat(Math.ceil(o / 8), \">\")) : t.push(\"\".concat(r, \":array<vec4<\").concat(n, \">, \").concat(Math.ceil(o / 4), \">\"));\n            else {\n                let i = o == null || o === 1 ? n : \"vec\".concat(o, \"<\").concat(n, \">\");\n                t.push(\"\".concat(r, \":\").concat(i));\n            }\n            return \"\\n      struct Uniforms { \".concat(t.join(\", \"), \" };\\n      @group(0) @binding(\").concat(this.variableIndex, \") var<uniform> uniforms: Uniforms;\");\n        }\n        get additionalImplementations() {\n            return this.uniformDeclaration() + this.variables.map((t)=>t.impl()).join(\"\\n\") + this.internalVariables.map((t)=>t.impl()).join(\"\\n\");\n        }\n        get variablesInfo() {\n            if (this.uniforms.length === 0) return;\n            let t = (r)=>[\n                    12,\n                    10,\n                    1,\n                    6\n                ][[\n                    \"u32\",\n                    \"f16\",\n                    \"f32\",\n                    \"i32\"\n                ].indexOf(r)];\n            return this.uniforms.map((r)=>{\n                var _r_length;\n                return [\n                    t(r.type),\n                    (_r_length = r.length) !== null && _r_length !== void 0 ? _r_length : 1\n                ];\n            });\n        }\n        constructor(t, r){\n            this.normalizedDispatchGroup = t;\n            this.limits = r;\n            this.internalVariables = [];\n            this.variables = [];\n            this.uniforms = [];\n            this.variableIndex = 0;\n        }\n    }, ns = (e1, t)=>new ao(e1, t);\n});\nvar dm, os, lm, cm, pm, mm, Pe, is, as, dt = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    dm = (e1, t)=>{\n        if (!e1 || e1.length !== 1) throw new Error(\"Transpose requires 1 input.\");\n        if (t.length !== 0 && t.length !== e1[0].dims.length) throw new Error(\"perm size \".concat(t.length, \" does not match input rank \").concat(e1[0].dims.length));\n    }, os = (e1, t)=>t.length !== 0 ? t : [\n            ...new Array(e1).keys()\n        ].reverse(), lm = (e1, t)=>C.sortBasedOnPerm(e1, os(e1.length, t)), cm = (e1, t, r, n)=>{\n        let o = \"fn perm(i: \".concat(n.type.indices, \") -> \").concat(r.type.indices, \" {\\n    var a: \").concat(r.type.indices, \";\");\n        for(let i = 0; i < t; ++i)o += \"a[\".concat(e1[i], \"]=i[\").concat(i, \"];\");\n        return o += \"return a;}\";\n    }, pm = (e1, t)=>{\n        let r = [], n = [];\n        for(let o = 0; o < e1.length; ++o)e1[o] !== 1 && r.push(e1[o]), e1[t[o]] !== 1 && n.push(t[o]);\n        return {\n            newShape: r,\n            newPerm: n\n        };\n    }, mm = (e1, t)=>{\n        let r = 0;\n        for(let n = 0; n < e1.length; ++n)if (t[e1[n]] !== 1) {\n            if (e1[n] < r) return !1;\n            r = e1[n];\n        }\n        return !0;\n    }, Pe = (e1, t)=>{\n        let r = e1.dataType, n = e1.dims.length, o = os(n, t), i = lm(e1.dims, o), a = e1.dims, d = i, l = n < 2 || mm(o, e1.dims), p;\n        if (l) return p = (g)=>{\n            let x = E(\"input\", r, a, 4), $ = M(\"output\", r, d, 4);\n            return \"\\n  \".concat(g.registerUniform(\"output_size\", \"u32\").declareVariables(x, $), \"\\n  \").concat(g.mainStart(), \"\\n    \").concat(g.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\"), \"\\n    output[global_idx] = input[global_idx];\\n  }\");\n        }, {\n            name: \"TransposeCopy\",\n            shaderCache: {\n                inputDependencies: [\n                    \"type\"\n                ]\n            },\n            getRunData: ()=>{\n                let g = C.size(i);\n                return {\n                    outputs: [\n                        {\n                            dims: i,\n                            dataType: e1.dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(g / 64 / 4)\n                    },\n                    programUniforms: [\n                        {\n                            type: 12,\n                            data: Math.ceil(g / 4)\n                        }\n                    ]\n                };\n            },\n            getShaderSource: p\n        };\n        let { newShape: m, newPerm: u } = pm(e1.dims, o), h = C.areEqual(u, [\n            2,\n            3,\n            1\n        ]), _ = C.areEqual(u, [\n            3,\n            1,\n            2\n        ]);\n        if (m.length === 2 || h || _) {\n            a = h ? [\n                m[0],\n                m[1] * m[2]\n            ] : _ ? [\n                m[0] * m[1],\n                m[2]\n            ] : m, d = [\n                a[1],\n                a[0]\n            ];\n            let g = 16;\n            return p = (x)=>{\n                let $ = E(\"a\", r, a.length), v = M(\"output\", r, d.length);\n                return \"\\n  \".concat(x.registerUniform(\"output_size\", \"u32\").declareVariables($, v), \"\\n  var<workgroup> tile : array<array<\").concat(v.type.value, \", \").concat(g + 1, \">, \").concat(g, \">;\\n  \").concat(x.mainStart([\n                    g,\n                    g,\n                    1\n                ]), \"\\n    let stride = (uniforms.output_shape[1] - 1) / \").concat(g, \" + 1;\\n    let workgroup_id_x = workgroup_index % stride;\\n    let workgroup_id_y = workgroup_index / stride;\\n    let input_col = workgroup_id_y * \").concat(g, \"u + local_id.x;\\n    let input_row = workgroup_id_x * \").concat(g, \"u + local_id.y;\\n    if (input_row < uniforms.a_shape[0] && input_col < uniforms.a_shape[1]) {\\n      tile[local_id.y][local_id.x] = \").concat($.getByIndices(\"\".concat($.type.indices, \"(input_row, input_col)\")), \";\\n    }\\n    workgroupBarrier();\\n\\n    let output_col = workgroup_id_x * \").concat(g, \"u + local_id.x;\\n    let output_row = workgroup_id_y * \").concat(g, \"u + local_id.y;\\n    if (output_row < uniforms.output_shape[0] && output_col < uniforms.output_shape[1]) {\\n      \").concat(v.setByIndices(\"\".concat(v.type.indices, \"(output_row, output_col)\"), \"tile[local_id.x][local_id.y]\"), \"\\n    }\\n  }\");\n            }, {\n                name: \"TransposeShared\",\n                shaderCache: {\n                    inputDependencies: [\n                        \"type\"\n                    ]\n                },\n                getRunData: ()=>{\n                    let x = C.size(i);\n                    return {\n                        outputs: [\n                            {\n                                dims: i,\n                                dataType: e1.dataType\n                            }\n                        ],\n                        dispatchGroup: {\n                            x: Math.ceil(d[1] / g),\n                            y: Math.ceil(d[0] / g)\n                        },\n                        programUniforms: [\n                            {\n                                type: 12,\n                                data: x\n                            },\n                            ...N(a, d)\n                        ]\n                    };\n                },\n                getShaderSource: p\n            };\n        }\n        return p = (g)=>{\n            let x = E(\"a\", r, a.length), $ = M(\"output\", r, d.length);\n            return \"\\n  \".concat(g.registerUniform(\"output_size\", \"u32\").declareVariables(x, $), \"\\n\\n  \").concat(cm(o, n, x, $), \"\\n\\n  \").concat(g.mainStart(), \"\\n    \").concat(g.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\"), \"\\n\\n    let indices = \").concat($.offsetToIndices(\"global_idx\"), \";\\n    let aIndices = perm(indices);\\n\\n    \").concat($.setByOffset(\"global_idx\", x.getByIndices(\"aIndices\")), \"\\n  }\");\n        }, {\n            name: \"Transpose\",\n            shaderCache: {\n                hint: \"\".concat(t),\n                inputDependencies: [\n                    \"rank\"\n                ]\n            },\n            getRunData: ()=>{\n                let g = C.size(i);\n                return {\n                    outputs: [\n                        {\n                            dims: i,\n                            dataType: e1.dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(g / 64)\n                    },\n                    programUniforms: [\n                        {\n                            type: 12,\n                            data: g\n                        },\n                        ...N(a, d)\n                    ]\n                };\n            },\n            getShaderSource: p\n        };\n    }, is = (e1, t)=>{\n        dm(e1.inputs, t.perm), e1.compute(Pe(e1.inputs[0], t.perm));\n    }, as = (e1)=>re({\n            perm: e1.perm\n        });\n});\nvar fm, hm, gm, bm, ym, _m, wm, vm, $m, xm, rt, ss, us, ds, ls, cs, ps, ms, fs, hs, gs, bs = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    ae();\n    Gr();\n    dt();\n    fm = {\n        max: \"select(bestValue, candidate, candidate > bestValue)\",\n        min: \"select(bestValue, candidate, candidate < bestValue)\",\n        mean: \"bestValue + candidate\",\n        sum: \"bestValue + candidate\",\n        prod: \"bestValue * candidate\",\n        sumSquare: \"bestValue + candidate * candidate\",\n        logSumExp: \"bestValue + exp(candidate)\",\n        l1: \"bestValue + abs(candidate)\",\n        l2: \"bestValue + candidate * candidate\",\n        logSum: \"bestValue + candidate\"\n    }, hm = {\n        max: \"select(bestValue, candidate, candidate > bestValue)\",\n        min: \"select(bestValue, candidate, candidate < bestValue)\",\n        mean: \"bestValue + candidate\",\n        sum: \"bestValue + candidate\",\n        prod: \"bestValue * candidate\",\n        sumSquare: \"bestValue + candidate\",\n        logSumExp: \"bestValue + candidate\",\n        l1: \"bestValue + candidate\",\n        l2: \"bestValue + candidate\",\n        logSum: \"bestValue + candidate\"\n    }, gm = {\n        max: \"_A[offset]\",\n        min: \"_A[offset]\",\n        mean: \"0\",\n        sum: \"0\",\n        prod: \"1\",\n        sumSquare: \"0\",\n        logSumExp: \"0\",\n        l1: \"0\",\n        l2: \"0\",\n        logSum: \"0\"\n    }, bm = {\n        max: \"bestValue\",\n        min: \"bestValue\",\n        sum: \"bestValue\",\n        prod: \"bestValue\",\n        sumSquare: \"bestValue\",\n        logSumExp: \"log(bestValue)\",\n        l1: \"bestValue\",\n        l2: \"sqrt(bestValue)\",\n        logSum: \"log(bestValue)\"\n    }, ym = (e1, t)=>{\n        let r = [];\n        for(let n = t - e1; n < t; ++n)r.push(n);\n        return r;\n    }, _m = (e1, t)=>{\n        let r = [], n = e1.length;\n        for(let i = 0; i < n; i++)t.indexOf(i) === -1 && r.push(e1[i]);\n        let o = t.map((i)=>e1[i]);\n        return [\n            r,\n            o\n        ];\n    }, wm = (e1, t)=>{\n        let r = e1.length + t.length, n = [], o = 0;\n        for(let i = 0; i < r; i++)t.indexOf(i) === -1 ? n.push(e1[o++]) : n.push(1);\n        return n;\n    }, vm = (e1, t)=>{\n        for(let r = 0; r < e1.length; ++r)if (e1[e1.length - r - 1] !== t - 1 - r) return !1;\n        return !0;\n    }, $m = (e1, t)=>{\n        let r = [];\n        if (!vm(e1, t)) {\n            for(let n = 0; n < t; ++n)e1.indexOf(n) === -1 && r.push(n);\n            e1.forEach((n)=>r.push(n));\n        }\n        return r;\n    }, xm = (e1, t, r, n, o, i, a)=>{\n        let d = r[0].dims, l = C.size(i), p = C.size(a), m = E(\"_A\", r[0].dataType, d), u = M(\"output\", o, i), h = 64;\n        l === 1 && (h = 256);\n        let _ = \"\\n          var<workgroup> aBestValues : array<f32, \".concat(h, \">;\\n       \"), y = (g)=>\"\\n        \".concat(g.registerUniform(\"reduceSize\", \"u32\").declareVariables(m, u), \"\\n        \").concat(_, \"\\n        fn DIV_CEIL(a : u32, b : u32) -> u32 {\\n          return ((a - 1u) / b + 1u);\\n         }\\n         \").concat(g.mainStart(h), \"\\n\\n          let outputIndex = global_idx / \").concat(h, \";\\n          let offset = outputIndex * uniforms.reduceSize;\\n\\n          var bestValue = f32(\").concat(gm[n], \");\\n          let Length = uniforms.reduceSize;\\n          for (var k = local_idx; k < Length; k = k + \").concat(h, \") {\\n           let candidate = f32(\").concat(m.getByOffset(\"offset + k\"), \");\\n           bestValue = \").concat(fm[n], \";\\n          }\\n          aBestValues[local_idx] = bestValue;\\n          workgroupBarrier();\\n\\n         var reduceSize = min(Length, \").concat(h, \"u);\\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\\n             currentSize = reduceSize / 2u) {\\n           let interval = DIV_CEIL(reduceSize, 2u);\\n           if (local_idx < currentSize) {\\n            let candidate = aBestValues[local_idx + interval];\\n            bestValue = \").concat(hm[n], \";\\n            aBestValues[local_idx] = bestValue;\\n           }\\n           reduceSize = interval;\\n           workgroupBarrier();\\n         }\\n\\n         if (local_idx == 0u) {\\n          \").concat(u.setByOffset(\"outputIndex\", \"\".concat(n === \"mean\" ? \"\".concat(u.type.storage, \"(bestValue / f32(uniforms.reduceSize))\") : \"\".concat(u.type.storage, \"(\").concat(bm[n], \")\"))), \";\\n         }\\n        }\");\n        return {\n            name: e1,\n            shaderCache: {\n                hint: \"\".concat(t, \";\").concat(h),\n                inputDependencies: [\n                    \"type\"\n                ]\n            },\n            getShaderSource: y,\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: i,\n                            dataType: o\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: l\n                    },\n                    programUniforms: [\n                        {\n                            type: 12,\n                            data: p\n                        }\n                    ]\n                })\n        };\n    }, rt = (e1, t, r, n)=>{\n        let o = e1.inputs.length === 1 ? r : lo(e1.inputs, r), i = o.axes;\n        i.length === 0 && !o.noopWithEmptyAxes && (i = e1.inputs[0].dims.map((_, y)=>y));\n        let a = C.normalizeAxes(i, e1.inputs[0].dims.length), d = a, l = e1.inputs[0], p = $m(d, e1.inputs[0].dims.length);\n        p.length > 0 && (l = e1.compute(Pe(e1.inputs[0], p), {\n            inputs: [\n                0\n            ],\n            outputs: [\n                -1\n            ]\n        })[0], d = ym(d.length, l.dims.length));\n        let [m, u] = _m(l.dims, d), h = m;\n        o.keepDims && (h = wm(m, a)), e1.compute(xm(t, o.cacheKey, [\n            l\n        ], n, e1.inputs[0].dataType, h, u), {\n            inputs: [\n                l\n            ]\n        });\n    }, ss = (e1, t)=>{\n        rt(e1, \"ReduceMeanShared\", t, \"mean\");\n    }, us = (e1, t)=>{\n        rt(e1, \"ReduceL1Shared\", t, \"l1\");\n    }, ds = (e1, t)=>{\n        rt(e1, \"ReduceL2Shared\", t, \"l2\");\n    }, ls = (e1, t)=>{\n        rt(e1, \"ReduceLogSumExpShared\", t, \"logSumExp\");\n    }, cs = (e1, t)=>{\n        rt(e1, \"ReduceMaxShared\", t, \"max\");\n    }, ps = (e1, t)=>{\n        rt(e1, \"ReduceMinShared\", t, \"min\");\n    }, ms = (e1, t)=>{\n        rt(e1, \"ReduceProdShared\", t, \"prod\");\n    }, fs = (e1, t)=>{\n        rt(e1, \"ReduceSumShared\", t, \"sum\");\n    }, hs = (e1, t)=>{\n        rt(e1, \"ReduceSumSquareShared\", t, \"sumSquare\");\n    }, gs = (e1, t)=>{\n        rt(e1, \"ReduceLogSumShared\", t, \"logSum\");\n    };\n});\nvar nt, Sm, Hr, lo, ot, Tm, Im, Cm, Am, km, Em, Pm, zm, Om, Dm, it, ys, _s, ws, vs, $s, xs, Ss, Ts, Is, Cs, Gr = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    bs();\n    nt = (e1)=>{\n        if (!e1 || e1.length === 0 || e1.length > 2) throw new Error(\"Reduce op requires 1 or 2 inputs.\");\n        if (e1.length === 2 && e1[1].dims.length !== 1) throw new Error(\"Invalid axes input dims.\");\n    }, Sm = (e1)=>[\n            \"\",\n            \"\",\n            \"var value = \".concat(e1.getByIndices(\"input_indices\"), \";\"),\n            \"\"\n        ], Hr = function(e1, t, r, n, o, i) {\n        let a = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : !1, d = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : !1;\n        let l = [], p = r[0].dims, m = p.length, u = C.normalizeAxes(o, m), h = !d && u.length === 0;\n        p.forEach((x, $)=>{\n            h || u.indexOf($) >= 0 ? a && l.push(1) : l.push(x);\n        });\n        let _ = l.length, y = C.size(l);\n        return {\n            name: e1,\n            shaderCache: t,\n            getShaderSource: (x)=>{\n                let $ = [], v = E(\"_A\", r[0].dataType, m), S = M(\"output\", i, _), T = n(v, S, u), A = T[2];\n                for(let k = 0, P = 0; k < m; k++)h || u.indexOf(k) >= 0 ? (a && P++, A = \"for(var j\".concat(k, \": u32 = 0; j\").concat(k, \" < \").concat(p[k], \"; j\").concat(k, \"++) {\\n                  \").concat(T[2].includes(\"last_index\") ? \"let last_index = j\".concat(k, \";\") : \"\", \"\\n                  \").concat(v.indicesSet(\"input_indices\", k, \"j\".concat(k)), \"\\n                  \").concat(A, \"\\n                }\")) : ($.push(\"\".concat(v.indicesSet(\"input_indices\", k, S.indicesGet(\"output_indices\", P)), \";\")), P++);\n                return \"\\n\\n        \".concat(x.registerUniform(\"output_size\", \"u32\").declareVariables(v, S), \"\\n\\n        \").concat(x.mainStart(), \"\\n          \").concat(x.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\"), \"\\n          var input_indices: \").concat(v.type.indices, \";\\n          let output_indices = \").concat(S.offsetToIndices(\"global_idx\"), \";\\n\\n          \").concat($.join(\"\\n\"), \"\\n          \").concat(T[0], \"       // init ops for reduce max/min\\n          \").concat(T[1], \"\\n          \").concat(A, \"\\n          \").concat(T[3], \"\\n          \").concat(T.length === 4 ? S.setByOffset(\"global_idx\", \"value\") : T.slice(4).join(\"\\n\"), \"\\n        }\");\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: l,\n                            dataType: i\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(y / 64)\n                    },\n                    programUniforms: [\n                        {\n                            type: 12,\n                            data: y\n                        },\n                        ...N(p, l)\n                    ]\n                })\n        };\n    }, lo = (e1, t)=>{\n        let r = [];\n        return e1[1].dims[0] > 0 && e1[1].getBigInt64Array().forEach((n)=>r.push(Number(n))), re({\n            axes: r,\n            keepDims: t.keepDims,\n            noopWithEmptyAxes: t.noopWithEmptyAxes\n        });\n    }, ot = (e1, t, r, n)=>{\n        let o = e1.inputs, i = o.length === 1 ? r : lo(o, r);\n        e1.compute(Hr(t, {\n            hint: i.cacheKey,\n            inputDependencies: [\n                \"rank\"\n            ]\n        }, [\n            o[0]\n        ], i.noopWithEmptyAxes && i.axes.length === 0 ? Sm : n, i.axes, o[0].dataType, i.keepDims, i.noopWithEmptyAxes), {\n            inputs: [\n                0\n            ]\n        });\n    }, Tm = (e1, t)=>{\n        nt(e1.inputs), ot(e1, \"ReduceLogSum\", t, (n, o)=>[\n                \"var value = \".concat(o.type.storage, \"(0);\"),\n                \"\",\n                \"value += \".concat(n.getByIndices(\"input_indices\"), \";\"),\n                \"value = log(value);\"\n            ]);\n    }, Im = (e1, t)=>{\n        nt(e1.inputs), ot(e1, \"ReduceL1\", t, (n, o)=>[\n                \"var value = \".concat(o.type.storage, \"(0);\"),\n                \"\",\n                \"value += abs(\".concat(n.getByIndices(\"input_indices\"), \");\"),\n                \"\"\n            ]);\n    }, Cm = (e1, t)=>{\n        nt(e1.inputs), ot(e1, \"ReduceL2\", t, (n, o)=>[\n                \"var t = \".concat(o.type.value, \"(0); var value = \").concat(o.type.value, \"(0);\"),\n                \"\",\n                \"t = \".concat(n.getByIndices(\"input_indices\"), \"; value += (t * t);\"),\n                \"value = sqrt(value);\"\n            ]);\n    }, Am = (e1, t)=>{\n        nt(e1.inputs), ot(e1, \"ReduceLogSumExp\", t, (n, o)=>[\n                \"var value = \".concat(o.type.storage, \"(0);\"),\n                \"\",\n                \"value += exp(\".concat(n.getByIndices(\"input_indices\"), \");\"),\n                \"value = log(value);\"\n            ]);\n    }, km = (e1, t)=>{\n        nt(e1.inputs), ot(e1, \"ReduceMax\", t, (n, o, i)=>{\n            let a = [];\n            for(let d = 0; d < n.rank; d++)(i.indexOf(d) >= 0 || i.length === 0) && a.push(n.indicesSet(\"input_indices\", d, 0));\n            return [\n                \"\".concat(a.join(\"\\n\")),\n                \"var value = \".concat(n.getByIndices(\"input_indices\"), \";\"),\n                \"value = max(value, \".concat(n.getByIndices(\"input_indices\"), \");\"),\n                \"\"\n            ];\n        });\n    }, Em = (e1, t)=>{\n        nt(e1.inputs), ot(e1, \"ReduceMean\", t, (n, o, i)=>{\n            let a = 1;\n            for(let d = 0; d < n.rank; d++)(i.indexOf(d) >= 0 || i.length === 0) && (a *= e1.inputs[0].dims[d]);\n            return [\n                \"var sum = f32(0);\",\n                \"\",\n                \"sum += f32(\".concat(n.getByIndices(\"input_indices\"), \");\"),\n                \"let value = \".concat(o.type.value, \"(sum / \").concat(a, \");\")\n            ];\n        });\n    }, Pm = (e1, t)=>{\n        nt(e1.inputs), ot(e1, \"ReduceMin\", t, (n, o, i)=>{\n            let a = [];\n            for(let d = 0; d < n.rank; d++)(i.indexOf(d) >= 0 || i.length === 0) && a.push(\"input_indices[\".concat(d, \"] = 0;\"));\n            return [\n                \"\".concat(a.join(\"\\n\")),\n                \"var value = \".concat(n.getByIndices(\"input_indices\"), \";\"),\n                \"value = min(value, \".concat(n.getByIndices(\"input_indices\"), \");\"),\n                \"\"\n            ];\n        });\n    }, zm = (e1, t)=>{\n        nt(e1.inputs), ot(e1, \"ReduceProd\", t, (n, o)=>[\n                \"var value = \".concat(o.type.storage, \"(1);\"),\n                \"\",\n                \"value *= \".concat(n.getByIndices(\"input_indices\"), \";\"),\n                \"\"\n            ]);\n    }, Om = (e1, t)=>{\n        nt(e1.inputs), ot(e1, \"ReduceSum\", t, (n, o)=>[\n                \"var value = \".concat(o.type.storage, \"(0);\"),\n                \"\",\n                \"value += \".concat(n.getByIndices(\"input_indices\"), \";\"),\n                \"\"\n            ]);\n    }, Dm = (e1, t)=>{\n        nt(e1.inputs), ot(e1, \"ReduceSumSquare\", t, (n, o)=>[\n                \"var t = \".concat(o.type.value, \"(0); var value = \").concat(o.type.value, \"(0);\"),\n                \"\",\n                \"t = \".concat(n.getByIndices(\"input_indices\"), \"; value += t * t;\"),\n                \"\"\n            ]);\n    }, it = (e1, t, r)=>{\n        if (t.length === 0) return r;\n        let n = 1, o = 1;\n        for(let i = 0; i < t.length; i++)t.indexOf(i) === -1 ? n *= e1[i] : o *= e1[i];\n        return o < 32 && n > 1024;\n    }, ys = (e1, t)=>{\n        it(e1.inputs[0].dims, t.axes, t.noopWithEmptyAxes) ? Em(e1, t) : ss(e1, t);\n    }, _s = (e1, t)=>{\n        it(e1.inputs[0].dims, t.axes, t.noopWithEmptyAxes) ? Im(e1, t) : us(e1, t);\n    }, ws = (e1, t)=>{\n        it(e1.inputs[0].dims, t.axes, t.noopWithEmptyAxes) ? Cm(e1, t) : ds(e1, t);\n    }, vs = (e1, t)=>{\n        it(e1.inputs[0].dims, t.axes, t.noopWithEmptyAxes) ? Am(e1, t) : ls(e1, t);\n    }, $s = (e1, t)=>{\n        it(e1.inputs[0].dims, t.axes, t.noopWithEmptyAxes) ? km(e1, t) : cs(e1, t);\n    }, xs = (e1, t)=>{\n        it(e1.inputs[0].dims, t.axes, t.noopWithEmptyAxes) ? Pm(e1, t) : ps(e1, t);\n    }, Ss = (e1, t)=>{\n        it(e1.inputs[0].dims, t.axes, t.noopWithEmptyAxes) ? zm(e1, t) : ms(e1, t);\n    }, Ts = (e1, t)=>{\n        it(e1.inputs[0].dims, t.axes, t.noopWithEmptyAxes) ? Om(e1, t) : fs(e1, t);\n    }, Is = (e1, t)=>{\n        it(e1.inputs[0].dims, t.axes, t.noopWithEmptyAxes) ? Dm(e1, t) : hs(e1, t);\n    }, Cs = (e1, t)=>{\n        it(e1.inputs[0].dims, t.axes, t.noopWithEmptyAxes) ? Tm(e1, t) : gs(e1, t);\n    };\n});\nvar As, ks, Es, co, Ps = U(()=>{\n    \"use strict\";\n    te();\n    Se();\n    Gr();\n    As = (e1)=>{\n        if (!e1 || e1.length === 0 || e1.length > 2) throw new Error(\"ArgMinMaxOp op requires 1 or 2 inputs.\");\n        if (e1[0].dataType !== 1) throw new Error(\"Invalid input type.\");\n    }, ks = (e1, t)=>{\n        As(e1.inputs);\n        let r = (n, o, i)=>{\n            let a = [];\n            for(let d = 0; d < n.rank; d++)(i.indexOf(d) >= 0 || i.length === 0) && a.push(\"input_indices[\".concat(d, \"] = 0;\"));\n            return [\n                \"\".concat(a.join(\"\\n\")),\n                \"var value = \".concat(n.getByIndices(\"input_indices\"), \";\\nvar best_index : i32 = 0;\"),\n                \"if (\".concat(n.getByIndices(\"input_indices\"), \" \").concat(t.selectLastIndex > 0 ? \"<=\" : \"<\", \" value) {\\n         value = \").concat(n.getByIndices(\"input_indices\"), \";\\n         best_index = i32(last_index);\\n       }\"),\n                \"\",\n                o.setByOffset(\"global_idx\", \"best_index\")\n            ];\n        };\n        e1.compute(Hr(\"ArgMin\", {\n            hint: t.cacheKey,\n            inputDependencies: [\n                \"rank\"\n            ]\n        }, [\n            e1.inputs[0]\n        ], r, [\n            t.axis\n        ], 7, t.keepDims), {\n            inputs: [\n                0\n            ]\n        });\n    }, Es = (e1, t)=>{\n        As(e1.inputs);\n        let r = (n, o, i)=>{\n            let a = [];\n            for(let d = 0; d < n.rank; d++)(i.indexOf(d) >= 0 || i.length === 0) && a.push(\"input_indices[\".concat(d, \"] = 0;\"));\n            return [\n                \"\".concat(a.join(\"\\n\")),\n                \"var value = \".concat(n.getByIndices(\"input_indices\"), \";\\nvar best_index : i32 = 0;\"),\n                \"if (\".concat(n.getByIndices(\"input_indices\"), \" \").concat(t.selectLastIndex > 0 ? \">=\" : \">\", \" value) {\\n         value = \").concat(n.getByIndices(\"input_indices\"), \";\\n         best_index = i32(last_index);\\n       }\"),\n                \"\",\n                o.setByOffset(\"global_idx\", \"best_index\")\n            ];\n        };\n        e1.compute(Hr(\"argMax\", {\n            hint: t.cacheKey,\n            inputDependencies: [\n                \"rank\"\n            ]\n        }, [\n            e1.inputs[0]\n        ], r, [\n            t.axis\n        ], 7, t.keepDims), {\n            inputs: [\n                0\n            ]\n        });\n    }, co = (e1)=>re(e1);\n});\nvar Bm, po, Mm, Rm, Um, Rt, Nm, zs, Fr = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Nr();\n    ae();\n    Bm = (e1, t)=>{\n        let r = e1[0], n = e1[1], o = e1[2], i = e1[3], a = e1[4], d = e1[5];\n        if (a && d) throw new Error(\"Attention cannot have both past and attention_bias\");\n        if (r.dims.length !== 3) throw new Error('Input \"input\" must have 3 dimensions');\n        let l = r.dims[0], p = r.dims[1], m = r.dims[2];\n        if (o.dims.length !== 1) throw new Error('Input \"bias\" is expected to have 1 dimensions');\n        if (n.dims.length !== 2) throw new Error('Input \"weights\" is expected to have 2 dimensions');\n        if (n.dims[0] !== m) throw new Error(\"Input 1 dimension 0 should have same length as dimension 2 of input 0\");\n        if (o.dims[0] !== n.dims[1]) throw new Error('Input \"bias\" dimension 0 should have same length as dimension 1 of input \"weights\"');\n        let u = o.dims[0] / 3, h = u, _ = h;\n        if (t.qkvHiddenSizes.length > 0) {\n            if (t.qkvHiddenSizes.length !== 3) throw new Error(\"qkv_hidden_sizes attribute should have 3 elements\");\n            for (let S of t.qkvHiddenSizes)if (S % t.numHeads !== 0) throw new Error(\"qkv_hidden_sizes should be divisible by num_heads\");\n            u = t.qkvHiddenSizes[0], h = t.qkvHiddenSizes[1], _ = t.qkvHiddenSizes[2];\n        }\n        let y = p;\n        if (u !== h) throw new Error(\"qkv_hidden_sizes first element should be same as the second\");\n        if (o.dims[0] !== u + h + _) throw new Error('Input \"bias\" dimension 0 should have same length as sum of Q/K/V hidden sizes');\n        let g = 0;\n        if (a) {\n            if (h !== _) throw new Error('Input \"past\" expect k_hidden_size == v_hidden_size');\n            if (a.dims.length !== 5) throw new Error('Input \"past\" must have 5 dimensions');\n            if (a.dims[0] !== 2) throw new Error('Input \"past\" first dimension must be 2');\n            if (a.dims[1] !== l) throw new Error('Input \"past\" second dimension must be batch_size');\n            if (a.dims[2] !== t.numHeads) throw new Error('Input \"past\" third dimension must be num_heads');\n            if (a.dims[4] !== h / t.numHeads) throw new Error('Input \"past\" fifth dimension must be k_hidden_size / num_heads');\n            t.pastPresentShareBuffer || (g = a.dims[3]);\n        }\n        let x = y + g, $ = -1, v = 0;\n        if (i) throw new Error(\"Mask not supported\");\n        if (a) throw new Error(\"past is not supported\");\n        if (d) {\n            if (d.dims.length !== 4) throw new Error('Input \"attention_bias\" must have 4 dimensions');\n            if (d.dims[0] !== l || d.dims[1] !== t.numHeads || d.dims[2] !== p || d.dims[3] !== x) throw new Error('Expect \"attention_bias\" shape (batch_size, num_heads, sequence_length, total_sequence_length)');\n        }\n        return {\n            batchSize: l,\n            sequenceLength: p,\n            pastSequenceLength: g,\n            kvSequenceLength: y,\n            totalSequenceLength: x,\n            maxSequenceLength: $,\n            inputHiddenSize: m,\n            hiddenSize: u,\n            vHiddenSize: _,\n            headSize: Math.floor(u / t.numHeads),\n            vHeadSize: Math.floor(_ / t.numHeads),\n            numHeads: t.numHeads,\n            isUnidirectional: !1,\n            pastPresentShareBuffer: !1,\n            maskFilterValue: t.maskFilterValue,\n            maskType: v,\n            scale: t.scale,\n            broadcastResPosBias: !1,\n            passPastInKv: !1,\n            qkvFormat: 1\n        };\n    }, po = (e1, t, r)=>t && e1 ? \"\\n      let total_sequence_length_input = u32(\".concat(t.getByOffset(\"0\"), \");\\n      let present_sequence_length = max(total_sequence_length_input, uniforms.past_sequence_length);\\n      let is_subsequent_prompt: bool = sequence_length > 1 && sequence_length != total_sequence_length_input;\\n      let is_first_prompt: bool = is_subsequent_prompt == false && sequence_length == total_sequence_length_input;\\n      total_sequence_length = u32(\").concat(e1 === null || e1 === void 0 ? void 0 : e1.getByOffset(\"batchIdx\"), \") + 1;\\n      var past_sequence_length: u32 = 0;\\n      if (is_first_prompt == false) {\\n        past_sequence_length = total_sequence_length - sequence_length;\\n      }\\n       \") : \"\\n    \".concat(r ? \"let past_sequence_length = uniforms.past_sequence_length\" : \"\", \";\\n    let present_sequence_length = total_sequence_length;\\n    \"), Mm = (e1, t, r, n, o, i, a, d)=>{\n        let l = me(a ? 1 : i), p = 64, m = i / l;\n        m < p && (p = 32);\n        let u = Math.ceil(i / l / p), h = [\n            {\n                type: 12,\n                data: t\n            },\n            {\n                type: 12,\n                data: r\n            },\n            {\n                type: 12,\n                data: n\n            },\n            {\n                type: 12,\n                data: o\n            },\n            {\n                type: 12,\n                data: m\n            },\n            {\n                type: 12,\n                data: u\n            }\n        ], _ = _e(e1.dataType, l), y = Ee(1, l), g = [\n            \"type\"\n        ];\n        a && g.push(\"type\"), d && g.push(\"type\");\n        let x = ($)=>{\n            let v = M(\"x\", e1.dataType, e1.dims, l), S = [\n                v\n            ], T = a ? E(\"seq_lens\", a.dataType, a.dims) : void 0;\n            T && S.push(T);\n            let A = d ? E(\"total_sequence_length_input\", d.dataType, d.dims) : void 0;\n            A && S.push(A);\n            let k = Ee(e1.dataType), P = [\n                {\n                    name: \"batch_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"num_heads\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"past_sequence_length\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"sequence_length\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"total_sequence_length\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"elements_per_thread\",\n                    type: \"u32\"\n                }\n            ];\n            return \"\\n  var<workgroup> thread_max: array<f32, \".concat(p, \">;\\n  var<workgroup> thread_sum: array<f32, \").concat(p, \">;\\n  \").concat($.registerUniforms(P).declareVariables(...S), \"\\n  \").concat($.mainStart([\n                p,\n                1,\n                1\n            ]), \"\\n    let batchIdx = workgroup_id.z / uniforms.num_heads;\\n    let headIdx = workgroup_id.z % uniforms.num_heads;\\n    let sequence_length = uniforms.sequence_length;\\n    var total_sequence_length = uniforms.total_sequence_length;\\n    \").concat(po(T, A, !1), \"\\n    let local_offset = local_idx * uniforms.elements_per_thread;\\n    let offset = (global_idx / \").concat(p, \") * uniforms.total_sequence_length + local_offset;\\n    let seq_causal_length = \").concat(a ? \"u32(past_sequence_length + workgroup_id.y + 1)\" : \"total_sequence_length\", \";\\n    var thread_max_vector = \").concat(y, \"(-3.402823e+38f);\\n    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\\n      thread_max_vector = max(\").concat(y, \"(x[offset + i]), thread_max_vector);\\n    }\\n    thread_max[local_idx] = \").concat((()=>{\n                switch(l){\n                    case 1:\n                        return \"thread_max_vector\";\n                    case 2:\n                        return \"max(thread_max_vector.x, thread_max_vector.y)\";\n                    case 4:\n                        return \"max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))\";\n                    default:\n                        throw new Error(\"Unsupported components: \".concat(l));\n                }\n            })(), \";\\n    workgroupBarrier();\\n\\n    var max_value =  f32(-3.402823e+38f);\\n    for (var i = 0u; i < \").concat(p, \"; i++) {\\n      max_value = max(thread_max[i], max_value);\\n    }\\n\\n    var sum_vector = \").concat(y, \"(0);\\n    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\\n      sum_vector += exp(\").concat(y, \"(x[offset + i]) - max_value);\\n    }\\n    thread_sum[local_idx] = \").concat((()=>{\n                switch(l){\n                    case 1:\n                        return \"sum_vector\";\n                    case 2:\n                        return \"sum_vector.x + sum_vector.y\";\n                    case 4:\n                        return \"sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w\";\n                    default:\n                        throw new Error(\"Unsupported components: \".concat(l));\n                }\n            })(), \";\\n    workgroupBarrier();\\n\\n    var sum: f32 = 0;\\n    for (var i = 0u; i < \").concat(p, \"; i++) {\\n      sum += thread_sum[i];\\n    }\\n\\n    if (sum == 0) {\\n      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\\n        x[offset + i] = \").concat(v.type.value, \"(\").concat(k, \"(1.0) / \").concat(k, \"(seq_causal_length));\\n      }\\n    } else {\\n      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\\n        var f32input = \").concat(y, \"(x[offset + i]);\\n        x[offset + i] = \").concat(v.type.value, \"(exp(f32input - max_value) / sum);\\n      }\\n    }\\n      \").concat(a ? \"\\n        for (var total_seq_id: u32 = seq_causal_length; total_seq_id + local_offset < uniforms.total_sequence_length; total_seq_id++) {\\n          x[offset + total_seq_id] = \".concat(v.type.value, \"(\").concat(k, \"(0));\\n        }\") : \"\", \";\\n  }\");\n        };\n        return {\n            name: \"AttentionProbsSoftmax\",\n            shaderCache: {\n                hint: \"\".concat(p, \";\").concat(_, \";\").concat(l),\n                inputDependencies: g\n            },\n            getShaderSource: x,\n            getRunData: ()=>({\n                    outputs: [],\n                    dispatchGroup: {\n                        x: Math.ceil(i / p),\n                        y: o,\n                        z: t * r\n                    },\n                    programUniforms: h\n                })\n        };\n    }, Rm = (e1, t, r, n, o, i, a, d, l)=>{\n        let p = a + i.kvSequenceLength, m = [\n            i.batchSize,\n            i.numHeads,\n            i.sequenceLength,\n            p\n        ], u = e1 > 1 && n, h = i.kvNumHeads ? i.kvNumHeads : i.numHeads, _ = u ? [\n            i.batchSize,\n            h,\n            p,\n            i.headSize\n        ] : void 0, y = i.nReps ? i.nReps : 1, g = i.scale === 0 ? 1 / Math.sqrt(i.headSize) : i.scale, x = me(i.headSize), $ = i.headSize / x, v = 12, S = {\n            x: Math.ceil(p / v),\n            y: Math.ceil(i.sequenceLength / v),\n            z: i.batchSize * i.numHeads\n        }, T = [\n            {\n                type: 12,\n                data: i.sequenceLength\n            },\n            {\n                type: 12,\n                data: $\n            },\n            {\n                type: 12,\n                data: p\n            },\n            {\n                type: 12,\n                data: i.numHeads\n            },\n            {\n                type: 12,\n                data: i.headSize\n            },\n            {\n                type: 1,\n                data: g\n            },\n            {\n                type: 12,\n                data: a\n            },\n            {\n                type: 12,\n                data: i.kvSequenceLength\n            },\n            {\n                type: 12,\n                data: y\n            }\n        ], A = u && n && C.size(n.dims) > 0, k = [\n            \"type\",\n            \"type\"\n        ];\n        A && k.push(\"type\"), o && k.push(\"type\"), d && k.push(\"type\"), l && k.push(\"type\");\n        let P = [\n            {\n                dims: m,\n                dataType: t.dataType,\n                gpuDataType: 0\n            }\n        ];\n        u && P.push({\n            dims: _,\n            dataType: t.dataType,\n            gpuDataType: 0\n        });\n        let D = (R)=>{\n            let G = E(\"q\", t.dataType, t.dims, x), K = E(\"key\", r.dataType, r.dims, x), j = [\n                G,\n                K\n            ];\n            if (A) {\n                let ne = E(\"past_key\", n.dataType, n.dims, x);\n                j.push(ne);\n            }\n            o && j.push(E(\"attention_bias\", o.dataType, o.dims));\n            let V = d ? E(\"seq_lens\", d.dataType, d.dims) : void 0;\n            V && j.push(V);\n            let Q = l ? E(\"total_sequence_length_input\", l.dataType, l.dims) : void 0;\n            Q && j.push(Q);\n            let se = M(\"output\", t.dataType, m), Y = [\n                se\n            ];\n            u && Y.push(M(\"present_key\", t.dataType, _, x));\n            let ee = Ee(1, x), J = [\n                {\n                    name: \"M\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"K\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"N\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"num_heads\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"head_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"alpha\",\n                    type: \"f32\"\n                },\n                {\n                    name: \"past_sequence_length\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"kv_sequence_length\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"n_reps\",\n                    type: \"u32\"\n                }\n            ];\n            return \"\\n  const TILE_SIZE = \".concat(v, \"u;\\n\\n  var<workgroup> tileQ: array<\").concat(G.type.storage, \", \").concat(v * v, \">;\\n  var<workgroup> tileK: array<\").concat(G.type.storage, \", \").concat(v * v, \">;\\n  \").concat(R.registerUniforms(J).declareVariables(...j, ...Y), \"\\n  \").concat(R.mainStart([\n                v,\n                v,\n                1\n            ]), \"\\n    // x holds the N and y holds the M\\n    let headIdx = workgroup_id.z % uniforms.num_heads;\\n    let kvHeadIdx = \").concat(y === 1 ? \"headIdx\" : \"headIdx / uniforms.n_reps\", \";\\n    let kv_num_heads = \").concat(y === 1 ? \"uniforms.num_heads\" : \"uniforms.num_heads / uniforms.n_reps\", \";\\n    let batchIdx = workgroup_id.z / uniforms.num_heads;\\n    let m = workgroup_id.y * TILE_SIZE;\\n    let n = workgroup_id.x * TILE_SIZE;\\n    let sequence_length = uniforms.M;\\n    var total_sequence_length = uniforms.N;\\n    \").concat(po(V, Q, !0), \"\\n    let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx;\\n    let qOffset = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;\\n    \").concat(A && u ? \"let pastKeyOffset = absKvHeadIdx * uniforms.past_sequence_length * uniforms.K;\" : \"\", \";\\n    let kOffset = absKvHeadIdx * uniforms.kv_sequence_length * uniforms.K;\\n    \").concat(u ? \"let presentKeyOffset = absKvHeadIdx * uniforms.N * uniforms.K;\" : \"\", \"\\n    var value = \").concat(ee, \"(0);\\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\\n      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {\\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];\\n      }\\n      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {\\n        var idx = TILE_SIZE * local_id.y + local_id.x;\\n      \").concat((()=>A && u ? \"\\n              if (n + local_id.y < past_sequence_length) {\\n                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];\\n              } else if (n + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {\\n                tileK[idx] = key[kOffset + (n + local_id.y - past_sequence_length) * uniforms.K + w + local_id.x];\\n              }\" : \"\\n          if (n + local_id.y < uniforms.kv_sequence_length) {\\n            tileK[idx] = key[kOffset + (n + local_id.y) * uniforms.K + w + local_id.x];\\n          }\")(), \"\\n      \").concat(u ? \"if (n + local_id.y < present_sequence_length) {\\n        present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];\\n      }\" : \"\", \"\\n      }\\n      workgroupBarrier();\\n\\n      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {\\n          value += \").concat(ee, \"(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);\\n      }\\n\\n      workgroupBarrier();\\n    }\\n\\n    if (global_id.y < uniforms.M && global_id.x < total_sequence_length) {\\n      let headOffset = workgroup_id.z * uniforms.M * uniforms.N;\\n      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;\\n      var sum: f32 = \").concat((()=>{\n                switch(x){\n                    case 1:\n                        return \"value\";\n                    case 2:\n                        return \"value.x + value.y\";\n                    case 4:\n                        return \"value.x + value.y + value.z + value.w\";\n                    default:\n                        throw new Error(\"Unsupported components: \".concat(x));\n                }\n            })(), \";\\n        output[outputIdx] = \").concat(se.type.value, \" (sum * uniforms.alpha) + \").concat(o ? \"attention_bias[outputIdx]\" : \"0.0\", \";\\n    }\\n  }\");\n        };\n        return {\n            name: \"AttentionProbs\",\n            shaderCache: {\n                hint: \"\".concat(x, \";\").concat(o !== void 0, \";\").concat(n !== void 0, \";\").concat(e1),\n                inputDependencies: k\n            },\n            getRunData: ()=>({\n                    outputs: P,\n                    dispatchGroup: S,\n                    programUniforms: T\n                }),\n            getShaderSource: D\n        };\n    }, Um = function(e1, t, r, n, o, i) {\n        let a = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : void 0, d = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : void 0;\n        let l = i + o.kvSequenceLength, p = o.nReps ? o.nReps : 1, m = o.vHiddenSize * p, u = e1 > 1 && n, h = o.kvNumHeads ? o.kvNumHeads : o.numHeads, _ = u ? [\n            o.batchSize,\n            h,\n            l,\n            o.headSize\n        ] : void 0, y = [\n            o.batchSize,\n            o.sequenceLength,\n            m\n        ], g = 12, x = {\n            x: Math.ceil(o.vHeadSize / g),\n            y: Math.ceil(o.sequenceLength / g),\n            z: o.batchSize * o.numHeads\n        }, $ = [\n            {\n                type: 12,\n                data: o.sequenceLength\n            },\n            {\n                type: 12,\n                data: l\n            },\n            {\n                type: 12,\n                data: o.vHeadSize\n            },\n            {\n                type: 12,\n                data: o.numHeads\n            },\n            {\n                type: 12,\n                data: o.headSize\n            },\n            {\n                type: 12,\n                data: m\n            },\n            {\n                type: 12,\n                data: i\n            },\n            {\n                type: 12,\n                data: o.kvSequenceLength\n            },\n            {\n                type: 12,\n                data: p\n            }\n        ], v = u && n && C.size(n.dims) > 0, S = [\n            \"type\",\n            \"type\"\n        ];\n        v && S.push(\"type\"), a && S.push(\"type\"), d && S.push(\"type\");\n        let T = [\n            {\n                dims: y,\n                dataType: t.dataType,\n                gpuDataType: 0\n            }\n        ];\n        u && T.push({\n            dims: _,\n            dataType: t.dataType,\n            gpuDataType: 0\n        });\n        let A = (k)=>{\n            let P = E(\"probs\", t.dataType, t.dims), D = E(\"v\", r.dataType, r.dims), R = [\n                P,\n                D\n            ];\n            v && R.push(E(\"past_value\", n.dataType, n.dims));\n            let G = a ? E(\"seq_lens\", a.dataType, a.dims) : void 0;\n            a && R.push(G);\n            let K = d ? E(\"total_sequence_length_input\", d.dataType, d.dims) : void 0;\n            d && R.push(K);\n            let V = [\n                M(\"output\", t.dataType, y)\n            ];\n            u && V.push(M(\"present_value\", t.dataType, _));\n            let Q = [\n                {\n                    name: \"M\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"K\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"N\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"num_heads\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"head_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"v_hidden_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"past_sequence_length\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"kv_sequence_length\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"n_reps\",\n                    type: \"u32\"\n                }\n            ];\n            return \"\\n  const TILE_SIZE = \".concat(g, \"u;\\n  var<workgroup> tileQ: array<\").concat(P.type.value, \", \").concat(g * g, \">;\\n  var<workgroup> tileV: array<\").concat(P.type.value, \", \").concat(g * g, \">;\\n  \").concat(k.registerUniforms(Q).declareVariables(...R, ...V), \"\\n  \").concat(k.mainStart([\n                g,\n                g,\n                1\n            ]), \"\\n   let headIdx = workgroup_id.z % uniforms.num_heads;\\n   let batchIdx = workgroup_id.z / uniforms.num_heads;\\n   let kvHeadIdx = \").concat(p === 1 ? \"headIdx\" : \"headIdx / uniforms.n_reps\", \";\\n   let kv_num_heads = \").concat(p === 1 ? \"uniforms.num_heads\" : \"uniforms.num_heads / uniforms.n_reps\", \";\\n   let m = global_id.y;\\n   let n = global_id.x;\\n   let sequence_length = uniforms.M;\\n   var total_sequence_length = uniforms.K;\\n   \").concat(po(G, K, !0), \"\\n   let offsetA = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;\\n   let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx; // kvHeadIdx is relative to the batch\\n   \").concat(v && u ? \"let pastValueOffset = absKvHeadIdx * uniforms.N * uniforms.past_sequence_length + n;\" : \"\", \";\\n   let vOffset = absKvHeadIdx * uniforms.N * uniforms.kv_sequence_length + n;\\n   \").concat(u ? \"let presentValueOffset = absKvHeadIdx * uniforms.N * uniforms.K + n;\" : \"\", \"\\n   var value = \").concat(P.type.storage, \"(0);\\n   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\\n      if (m < uniforms.M && w + local_id.x < uniforms.K) {\\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];\\n      }\\n      if (n < uniforms.N && w + local_id.y < uniforms.K) {\\n        var idx = TILE_SIZE * local_id.y + local_id.x;\\n        \").concat((()=>v && u ? \"\\n        if (w + local_id.y < past_sequence_length) {\\n          tileV[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];\\n        } else if (w + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {\\n          tileV[idx] = v[vOffset + (w + local_id.y - past_sequence_length) * uniforms.N];\\n        }\\n      \" : \"\\n            if (w + local_id.y < uniforms.kv_sequence_length) {\\n              tileV[idx] = v[vOffset + (w + local_id.y) * uniforms.N];\\n            }\")(), \"\\n        \").concat(u ? \"\\n            if (w + local_id.y < present_sequence_length) {\\n          present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileV[idx];\\n        }\" : \"\", \"\\n      }\\n     workgroupBarrier();\\n     for (var k: u32 = 0u; k < TILE_SIZE && w+k < total_sequence_length; k++) {\\n       value += tileQ[TILE_SIZE * local_id.y + k] * tileV[TILE_SIZE * k + local_id.x];\\n     }\\n     workgroupBarrier();\\n   }\\n\\n   // we need to transpose output from BNSH_v to BSND_v\\n   if (m < uniforms.M && n < uniforms.N) {\\n     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size\\n       + headIdx * uniforms.N + n;\\n     output[outputIdx] = value;\\n   }\\n  }\");\n        };\n        return {\n            name: \"AttentionScore\",\n            shaderCache: {\n                hint: \"\".concat(n !== void 0, \";\").concat(e1),\n                inputDependencies: S\n            },\n            getRunData: ()=>({\n                    outputs: T,\n                    dispatchGroup: x,\n                    programUniforms: $\n                }),\n            getShaderSource: A\n        };\n    }, Rt = function(e1, t, r, n, o, i, a, d, l, p) {\n        let m = arguments.length > 10 && arguments[10] !== void 0 ? arguments[10] : void 0, u = arguments.length > 11 && arguments[11] !== void 0 ? arguments[11] : void 0;\n        let h = Math.min(e1.outputCount, 1 + (a ? 1 : 0) + (d ? 1 : 0)), _ = h > 1 ? p.pastSequenceLength : 0, y = _ + p.kvSequenceLength, g = l && C.size(l.dims) > 0 ? l : void 0, x = [\n            t,\n            r\n        ];\n        h > 1 && a && C.size(a.dims) > 0 && x.push(a), g && x.push(g), m && x.push(m), u && x.push(u);\n        let $ = e1.compute(Rm(h, t, r, a, g, p, _, m, u), {\n            inputs: x,\n            outputs: h > 1 ? [\n                -1,\n                1\n            ] : [\n                -1\n            ]\n        })[0];\n        e1.compute(Mm($, p.batchSize, p.numHeads, _, p.sequenceLength, y, m, u), {\n            inputs: m && u ? [\n                $,\n                m,\n                u\n            ] : [\n                $\n            ],\n            outputs: []\n        });\n        let v = [\n            $,\n            n\n        ];\n        h > 1 && d && C.size(d.dims) > 0 && v.push(d), m && v.push(m), u && v.push(u), e1.compute(Um(h, $, n, d, p, _, m, u), {\n            inputs: v,\n            outputs: h > 1 ? [\n                0,\n                2\n            ] : [\n                0\n            ]\n        });\n    }, Nm = (e1, t)=>{\n        let r = [\n            t.batchSize,\n            t.numHeads,\n            t.sequenceLength,\n            t.headSize\n        ], n = t.sequenceLength, o = t.inputHiddenSize, i = t.headSize, a = 12, d = {\n            x: Math.ceil(t.headSize / a),\n            y: Math.ceil(t.sequenceLength / a),\n            z: t.batchSize * t.numHeads\n        }, l = [\n            e1.inputs[0],\n            e1.inputs[1],\n            e1.inputs[2]\n        ], p = [\n            {\n                type: 12,\n                data: n\n            },\n            {\n                type: 12,\n                data: o\n            },\n            {\n                type: 12,\n                data: i\n            },\n            {\n                type: 12,\n                data: t.numHeads\n            },\n            {\n                type: 12,\n                data: t.headSize\n            },\n            {\n                type: 12,\n                data: t.hiddenSize\n            },\n            {\n                type: 12,\n                data: t.hiddenSize + t.hiddenSize + t.vHiddenSize\n            }\n        ], m = (u)=>{\n            let h = M(\"output_q\", l[0].dataType, r), _ = M(\"output_k\", l[0].dataType, r), y = M(\"output_v\", l[0].dataType, r), g = E(\"input\", l[0].dataType, l[0].dims), x = E(\"weight\", l[1].dataType, l[1].dims), $ = E(\"bias\", l[2].dataType, l[2].dims), v = g.type.storage, S = [\n                {\n                    name: \"M\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"K\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"N\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"num_heads\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"head_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"hidden_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"ldb\",\n                    type: \"u32\"\n                }\n            ];\n            return \"\\n  const TILE_SIZE = \".concat(a, \"u;\\n  var<workgroup> tileInput: array<\").concat(v, \", \").concat(a * a, \">;\\n  var<workgroup> tileWeightQ: array<\").concat(v, \", \").concat(a * a, \">;\\n  var<workgroup> tileWeightK: array<\").concat(v, \", \").concat(a * a, \">;\\n  var<workgroup> tileWeightV: array<\").concat(v, \", \").concat(a * a, \">;\\n  \").concat(u.registerUniforms(S).declareVariables(g, x, $, h, _, y), \"\\n  \").concat(u.mainStart([\n                a,\n                a,\n                1\n            ]), \"\\n    let batchIndex = workgroup_id.z / uniforms.num_heads;\\n    let headNumber = workgroup_id.z % uniforms.num_heads;\\n    let m = global_id.y;\\n    let n = global_id.x;\\n\\n    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;\\n    let biasOffsetQ = headNumber * uniforms.head_size;\\n    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;\\n    let biasOffsetV = uniforms.hidden_size + biasOffsetK;\\n\\n    var valueQ = \").concat(v, \"(0);\\n    var valueK = \").concat(v, \"(0);\\n    var valueV = \").concat(v, \"(0);\\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\\n      if (m < uniforms.M && w + local_id.x < uniforms.K) {\\n        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];\\n      }\\n      if (n < uniforms.N && w + local_id.y < uniforms.K) {\\n        let offset = n + (w + local_id.y) * uniforms.ldb;\\n        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];\\n        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];\\n        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];\\n      }\\n      workgroupBarrier();\\n      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {\\n        let inputTileOffset = TILE_SIZE * local_id.y + k;\\n        let weightTileOffset = TILE_SIZE * k + local_id.x;\\n        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];\\n        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];\\n        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];\\n      }\\n\\n      workgroupBarrier();\\n    }\\n\\n    let headOffset = (m * uniforms.N + n) % uniforms.head_size;\\n    valueQ += bias[headOffset + biasOffsetQ];\\n    valueK += bias[headOffset + biasOffsetK];\\n    valueV += bias[headOffset + biasOffsetV];\\n\\n    let offset = workgroup_id.z * uniforms.M * uniforms.N;\\n    if (m < uniforms.M && n < uniforms.N) {\\n      let outputIdx = offset + m * uniforms.N + n;\\n      output_q[outputIdx] = valueQ;\\n      output_k[outputIdx] = valueK;\\n      output_v[outputIdx] = valueV;\\n    }\\n  }\");\n        };\n        return e1.compute({\n            name: \"AttentionPrepare\",\n            shaderCache: {\n                inputDependencies: [\n                    \"type\",\n                    \"type\",\n                    \"type\"\n                ]\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: r,\n                            dataType: e1.inputs[0].dataType,\n                            gpuDataType: 0\n                        },\n                        {\n                            dims: r,\n                            dataType: e1.inputs[0].dataType,\n                            gpuDataType: 0\n                        },\n                        {\n                            dims: r,\n                            dataType: e1.inputs[0].dataType,\n                            gpuDataType: 0\n                        }\n                    ],\n                    dispatchGroup: d,\n                    programUniforms: p\n                }),\n            getShaderSource: m\n        }, {\n            inputs: l,\n            outputs: [\n                -1,\n                -1,\n                -1\n            ]\n        });\n    }, zs = (e1, t)=>{\n        let r = Bm(e1.inputs, t), [n, o, i] = Nm(e1, r);\n        return Rt(e1, n, o, i, e1.inputs[4], void 0, void 0, void 0, e1.inputs[5], r);\n    };\n});\nvar Vm, Wm, Lm, Os, Ds = U(()=>{\n    \"use strict\";\n    We();\n    te();\n    oe();\n    Se();\n    ae();\n    Vm = (e1, t)=>{\n        if (!e1 || e1.length !== 5) throw new Error(\"BatchNormalization requires 5 inputs\");\n        let r = (n, o, i)=>{\n            let a = o.length;\n            if (a !== n.length) throw new Error(\"\".concat(i, \": num dimensions != \").concat(a));\n            o.forEach((d, l)=>{\n                if (d !== n[l]) throw new Error(\"\".concat(i, \": dim[\").concat(l, \"] do not match\"));\n            });\n        };\n        if (e1[0].dims.length > 1) {\n            let n = t.format === \"NHWC\" ? t.spatial ? e1[0].dims.slice(-1) : e1[0].dims.slice(-1).concat(e1[0].dims.slice(1, e1[0].dims.length - 1)) : e1[0].dims.slice(1, t.spatial ? 2 : void 0);\n            r(e1[1].dims, n, \"Invalid input scale\"), r(e1[2].dims, n, \"Invalid input B\"), r(e1[3].dims, n, \"Invalid input mean\"), r(e1[4].dims, n, \"Invalid input var\");\n        } else r(e1[1].dims, [\n            1\n        ], \"Invalid input scale\"), r(e1[2].dims, [\n            1\n        ], \"Invalid input B\"), r(e1[3].dims, [\n            1\n        ], \"Invalid input mean\"), r(e1[4].dims, [\n            1\n        ], \"Invalid input var\");\n    }, Wm = (e1, t)=>{\n        let { epsilon: r, spatial: n, format: o } = t, i = e1[0].dims, a = n ? me(i[i.length - 1]) : 1, d = o === \"NHWC\" && i.length > 1 ? a : 1, l = C.size(i) / a, p = n, m = p ? i.length : i, u = E(\"x\", e1[0].dataType, e1[0].dims, a), h = E(\"scale\", e1[1].dataType, e1[1].dims, d), _ = E(\"bias\", e1[2].dataType, e1[2].dims, d), y = E(\"inputMean\", e1[3].dataType, e1[3].dims, d), g = E(\"inputVar\", e1[4].dataType, e1[4].dims, d), x = M(\"y\", e1[0].dataType, m, a), $ = ()=>{\n            let S = \"\";\n            if (n) S = \"let cOffset = \".concat(i.length === 1 ? \"0u\" : o === \"NHWC\" ? \"outputIndices[\".concat(i.length - 1, \"] / \").concat(a) : \"outputIndices[1]\", \";\");\n            else if (o === \"NCHW\") S = \"\\n            \".concat(x.indicesSet(\"outputIndices\", \"0\", \"0\"), \"\\n            let cOffset = \").concat(x.indicesToOffset(\"outputIndices\"), \";\");\n            else {\n                S = \"var cIndices = \".concat(h.type.indices, \"(0);\\n                       cIndices[0] = outputIndices[\").concat(i.length - 1, \"];\");\n                for(let T = 1; T < h.rank; T++)S += \"cIndices[\".concat(T, \"] = outputIndices[\").concat(T, \"];\");\n                S += \"let cOffset = \".concat(h.indicesToOffset(\"cIndices\"), \";\");\n            }\n            return S;\n        }, v = (S)=>\"\\n  const epsilon = \".concat(r, \";\\n  \").concat(S.registerUniform(\"outputSize\", \"u32\").declareVariables(u, h, _, y, g, x), \"\\n  \").concat(S.mainStart(), \"\\n  \").concat(S.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\"), \"\\n    var outputIndices = \").concat(x.offsetToIndices(\"global_idx * \".concat(a)), \";\\n    \").concat($(), \"\\n    let scale = \").concat(h.getByOffset(\"cOffset\"), \";\\n    let bias = \").concat(_.getByOffset(\"cOffset\"), \";\\n    let inputMean = \").concat(y.getByOffset(\"cOffset\"), \";\\n    let inputVar = \").concat(g.getByOffset(\"cOffset\"), \";\\n    let x = \").concat(u.getByOffset(\"global_idx\"), \";\\n    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;\\n    \").concat(x.setByOffset(\"global_idx\", \"value\"), \"\\n  }\");\n        return {\n            name: \"BatchNormalization\",\n            shaderCache: {\n                hint: \"\".concat(t.epsilon, \"_\").concat(t.format, \"_\").concat(n, \"_\").concat(a),\n                inputDependencies: p ? [\n                    \"rank\",\n                    \"type\",\n                    \"type\",\n                    \"type\",\n                    \"type\"\n                ] : void 0\n            },\n            getShaderSource: v,\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: e1[0].dims,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(l / 64)\n                    },\n                    programUniforms: p ? [\n                        {\n                            type: 12,\n                            data: l\n                        },\n                        ...N(i)\n                    ] : [\n                        {\n                            type: 12,\n                            data: l\n                        }\n                    ]\n                })\n        };\n    }, Lm = (e1)=>re(e1), Os = (e1, t)=>{\n        let { inputs: r, outputCount: n } = e1, o = Lm({\n            ...t,\n            outputCount: n\n        });\n        if (ve.webgpu.validateInputContent && Vm(r, o), t.trainingMode) throw new Error(\"BatchNormalization trainingMode is not supported yet.\");\n        e1.compute(Wm(r, o));\n    };\n});\nvar Gm, Hm, Bs, Ms = U(()=>{\n    \"use strict\";\n    oe();\n    ae();\n    Gm = (e1)=>{\n        if (e1[0].dims.length !== 3) throw new Error(\"input should have 3 dimensions\");\n        if (![\n            320,\n            640,\n            1280\n        ].includes(e1[0].dims[2])) throw new Error(\"number of channels should be 320, 640 or 1280\");\n        if (e1[1].dims.length !== 1) throw new Error(\"bias is expected to have 1 dimensions\");\n        if (e1[0].dims[2] !== e1[1].dims[0]) throw new Error(\"last dimension of input and bias are not the same\");\n    }, Hm = (e1)=>{\n        let t = e1[0].dims, r = e1[0].dims[2], n = C.size(t) / 4, o = e1[0].dataType, i = E(\"input\", o, t, 4), a = E(\"bias\", o, [\n            r\n        ], 4), d = E(\"residual\", o, t, 4), l = M(\"output\", o, t, 4);\n        return {\n            name: \"BiasAdd\",\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: t,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(n / 64)\n                    }\n                }),\n            getShaderSource: (m)=>\"\\n  const channels = \".concat(r, \"u / 4;\\n  \").concat(m.declareVariables(i, a, d, l), \"\\n\\n  \").concat(m.mainStart(), \"\\n    \").concat(m.guardAgainstOutOfBoundsWorkgroupSizes(n), \"\\n    let value = \").concat(i.getByOffset(\"global_idx\"), \"\\n      + \").concat(a.getByOffset(\"global_idx % channels\"), \" + \").concat(d.getByOffset(\"global_idx\"), \";\\n    \").concat(l.setByOffset(\"global_idx\", \"value\"), \"\\n  }\")\n        };\n    }, Bs = (e1)=>{\n        Gm(e1.inputs), e1.compute(Hm(e1.inputs));\n    };\n});\nvar Fm, fe, Rs, Us, Ns, Vs, Ws, Ls, Gs, Hs, Fs, qm, qs, Ks, js, Ys, Xt, Zs, qr, Qs, Xs, Js, eu, tu, ru, nu, ou, iu, au, su, uu, du, lu, cu, pu, mu, fu, mo, fo, hu, gu, bu, Km, jm, yu, Kr = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    Fm = (e1, t, r, n, o, i, a)=>{\n        let d = Math.ceil(t / 4), l = \"\";\n        typeof o == \"string\" ? l = \"\".concat(o, \"(a)\") : l = o(\"a\");\n        let p = E(\"inputData\", r, [\n            d\n        ], 4), m = M(\"outputData\", n, [\n            d\n        ], 4), u = [\n            {\n                name: \"vec_size\",\n                type: \"u32\"\n            }\n        ];\n        return a && u.push(...a), \"\\n      \".concat(e1.registerUniforms(u).declareVariables(p, m), \"\\n\\n  \").concat(i !== null && i !== void 0 ? i : \"\", \"\\n\\n  \").concat(e1.mainStart(), \"\\n    \").concat(e1.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.vec_size\"), \"\\n\\n    let a = \").concat(p.getByOffset(\"global_idx\"), \";\\n    \").concat(m.setByOffset(\"global_idx\", l), \"\\n  }\");\n    }, fe = function(e1, t, r, n, o) {\n        let i = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : e1.dataType, a = arguments.length > 6 ? arguments[6] : void 0, d = arguments.length > 7 ? arguments[7] : void 0;\n        let l = [\n            {\n                type: 12,\n                data: Math.ceil(C.size(e1.dims) / 4)\n            }\n        ];\n        return a && l.push(...a), {\n            name: t,\n            shaderCache: {\n                hint: o,\n                inputDependencies: [\n                    \"type\"\n                ]\n            },\n            getShaderSource: (p)=>Fm(p, C.size(e1.dims), e1.dataType, i, r, n, d),\n            getRunData: (p)=>({\n                    outputs: [\n                        {\n                            dims: e1.dims,\n                            dataType: i\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(C.size(p[0].dims) / 64 / 4)\n                    },\n                    programUniforms: l\n                })\n        };\n    }, Rs = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Abs\", \"abs\"));\n    }, Us = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Acos\", \"acos\"));\n    }, Ns = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Acosh\", \"acosh\"));\n    }, Vs = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Asin\", \"asin\"));\n    }, Ws = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Asinh\", \"asinh\"));\n    }, Ls = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Atan\", \"atan\"));\n    }, Gs = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Atanh\", \"atanh\"));\n    }, Hs = (e1)=>re(e1), Fs = (e1, t)=>{\n        let r;\n        switch(t.to){\n            case 10:\n                r = \"vec4<f16>\";\n                break;\n            case 1:\n                r = \"vec4<f32>\";\n                break;\n            case 12:\n                r = \"vec4<u32>\";\n                break;\n            case 6:\n                r = \"vec4<i32>\";\n                break;\n            case 9:\n                r = \"vec4<bool>\";\n                break;\n            default:\n                throw new RangeError(\"not supported type (specified in attribute 'to' from 'Cast' operator): \".concat(t.to));\n        }\n        e1.compute(fe(e1.inputs[0], \"Cast\", r, void 0, t.cacheKey, t.to));\n    }, qm = (e1)=>{\n        let t, r, n = e1.length >= 2 && e1[1].data !== 0, o = e1.length >= 3 && e1[2].data !== 0;\n        switch(e1[0].dataType){\n            case 1:\n                t = n ? e1[1].getFloat32Array()[0] : -34028234663852886e22, r = o ? e1[2].getFloat32Array()[0] : 34028234663852886e22;\n                break;\n            case 10:\n                t = n ? e1[1].getUint16Array()[0] : 64511, r = o ? e1[2].getUint16Array()[0] : 31743;\n                break;\n            default:\n                throw new Error(\"Unsupport data type\");\n        }\n        return re({\n            min: t,\n            max: r\n        });\n    }, qs = (e1, t)=>{\n        let r = t || qm(e1.inputs), n = Ee(e1.inputs[0].dataType);\n        e1.compute(fe(e1.inputs[0], \"Clip\", (o)=>\"clamp(\".concat(o, \", vec4<\").concat(n, \">(uniforms.min), vec4<\").concat(n, \">(uniforms.max))\"), void 0, r.cacheKey, void 0, [\n            {\n                type: e1.inputs[0].dataType,\n                data: r.min\n            },\n            {\n                type: e1.inputs[0].dataType,\n                data: r.max\n            }\n        ], [\n            {\n                name: \"min\",\n                type: n\n            },\n            {\n                name: \"max\",\n                type: n\n            }\n        ]), {\n            inputs: [\n                0\n            ]\n        });\n    }, Ks = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Ceil\", \"ceil\"));\n    }, js = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Cos\", \"cos\"));\n    }, Ys = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Cosh\", \"cosh\"));\n    }, Xt = (e1)=>re(e1), Zs = (e1, t)=>{\n        let r = Ee(e1.inputs[0].dataType);\n        e1.compute(fe(e1.inputs[0], \"Elu\", (n)=>\"elu_vf32(\".concat(n, \")\"), \"\\n  const elu_alpha_ = \".concat(r, \"(\").concat(t.alpha, \");\\n\\n  fn elu_f32(a: \").concat(r, \") -> \").concat(r, \" {\\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\\n  }\\n\\n  fn elu_vf32(v: vec4<\").concat(r, \">) -> vec4<\").concat(r, \"> {\\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\\n  }\"), t.cacheKey));\n    }, qr = function() {\n        let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"f32\";\n        return \"\\nconst r0: \".concat(e1, \" = 0.3275911;\\nconst r1: \").concat(e1, \" = 0.254829592;\\nconst r2: \").concat(e1, \" = -0.284496736;\\nconst r3: \").concat(e1, \" = 1.421413741;\\nconst r4: \").concat(e1, \" = -1.453152027;\\nconst r5: \").concat(e1, \" = 1.061405429;\\n\\nfn erf_vf32(v: vec4<\").concat(e1, \">) -> vec4<\").concat(e1, \"> {\\n  let absv = abs(v);\\n  let x = 1.0 / (1.0 + r0 * absv);\\n  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\\n}\");\n    }, Qs = (e1)=>{\n        let t = Ee(e1.inputs[0].dataType);\n        e1.compute(fe(e1.inputs[0], \"Erf\", (r)=>\"erf_vf32(\".concat(r, \")\"), qr(t)));\n    }, Xs = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Exp\", \"exp\"));\n    }, Js = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Floor\", \"floor\"));\n    }, eu = (e1)=>{\n        let t = Ee(e1.inputs[0].dataType);\n        e1.compute(fe(e1.inputs[0], \"Gelu\", (r)=>\"0.5 * \".concat(r, \" * (1.0 + erf_vf32(\").concat(r, \" * 0.7071067811865475))\"), qr(t)));\n    }, tu = (e1, t)=>{\n        let r = Ee(e1.inputs[0].dataType);\n        e1.compute(fe(e1.inputs[0], \"LeakyRelu\", (n)=>\"select(leaky_relu_alpha_ * \".concat(n, \", \").concat(n, \", \").concat(n, \" >= vec4<\").concat(r, \">(0.0))\"), \"const leaky_relu_alpha_ = \".concat(r, \"(\").concat(t.alpha, \");\"), t.cacheKey));\n    }, ru = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Not\", (t)=>\"!\".concat(t)));\n    }, nu = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Neg\", (t)=>\"-\".concat(t)));\n    }, ou = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Reciprocal\", (t)=>\"1.0/\".concat(t)));\n    }, iu = (e1)=>{\n        let t = Ee(e1.inputs[0].dataType);\n        e1.compute(fe(e1.inputs[0], \"Relu\", (r)=>\"select(vec4<\".concat(t, \">(0.0), \").concat(r, \", \").concat(r, \" > vec4<\").concat(t, \">(0.0))\")));\n    }, au = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Sigmoid\", (t)=>\"(1.0 / (1.0 + exp(-\".concat(t, \")))\")));\n    }, su = (e1)=>re(e1), uu = (e1, t)=>{\n        let r = Ee(e1.inputs[0].dataType);\n        e1.compute(fe(e1.inputs[0], \"HardSigmoid\", (n)=>\"max(vec4<\".concat(r, \">(0.0), min(vec4<\").concat(r, \">(1.0), \").concat(t.alpha, \" * \").concat(n, \" + vec4<\").concat(r, \">(\").concat(t.beta, \")))\"), void 0, t.cacheKey));\n    }, du = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Sin\", \"sin\"));\n    }, lu = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Sinh\", \"sinh\"));\n    }, cu = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Sqrt\", \"sqrt\"));\n    }, pu = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Tan\", \"tan\"));\n    }, mu = (e1)=>\"sign(\".concat(e1, \") * (1 - exp(-2 * abs(\").concat(e1, \"))) / (1 + exp(-2 * abs(\").concat(e1, \")))\"), fu = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Tanh\", mu));\n    }, mo = function() {\n        let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"f32\";\n        return \"\\nconst fast_gelu_a: \".concat(e1, \" = 0.5;\\nconst fast_gelu_b: \").concat(e1, \" = 0.7978845608028654;\\nconst fast_gelu_c: \").concat(e1, \" = 0.035677408136300125;\\n\\nfn tanh_v(v: vec4<\").concat(e1, \">) -> vec4<\").concat(e1, \"> {\\n  return \").concat(mu(\"v\"), \";\\n}\\n\");\n    }, fo = (e1)=>\"(fast_gelu_a + fast_gelu_a * tanh_v(\".concat(e1, \" * (fast_gelu_c * \").concat(e1, \" * \").concat(e1, \" + fast_gelu_b))) * \").concat(e1), hu = (e1)=>{\n        let t = Ee(e1.inputs[0].dataType);\n        e1.compute(fe(e1.inputs[0], \"FastGelu\", fo, mo(t), void 0, e1.inputs[0].dataType));\n    }, gu = (e1, t)=>{\n        let r = Ee(e1.inputs[0].dataType);\n        return e1.compute(fe(e1.inputs[0], \"ThresholdedRelu\", (n)=>\"select(vec4<\".concat(r, \">(0.0), \").concat(n, \", \").concat(n, \" > thresholded_relu_alpha_)\"), \"const thresholded_relu_alpha_ = vec4<\".concat(r, \">(\").concat(t.alpha, \");\"), t.cacheKey)), 0;\n    }, bu = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Log\", \"log\"));\n    }, Km = (e1, t)=>\"\\nconst alpha = vec4<\".concat(e1, \">(\").concat(t, \");\\nconst one = \").concat(e1, \"(1.0);\\nconst zero = \").concat(e1, \"(0.0);\\n\\nfn quick_gelu_impl(x: vec4<\").concat(e1, \">) -> vec4<\").concat(e1, \"> {\\n  let v = x *alpha;\\n  var x1 : vec4<\").concat(e1, \">;\\n  for (var i = 0; i < 4; i = i + 1) {\\n    if (v[i] >= zero) {\\n      x1[i] = one / (one + exp(-v[i]));\\n    } else {\\n      x1[i] = one - one / (one + exp(v[i]));\\n    }\\n  }\\n  return x * x1;\\n}\\n\"), jm = (e1)=>\"quick_gelu_impl(\".concat(e1, \")\"), yu = (e1, t)=>{\n        let r = Ee(e1.inputs[0].dataType);\n        e1.compute(fe(e1.inputs[0], \"QuickGelu\", jm, Km(r, t.alpha), t.cacheKey, e1.inputs[0].dataType));\n    };\n});\nvar Ym, Zm, wu, vu = U(()=>{\n    \"use strict\";\n    oe();\n    ae();\n    Kr();\n    Ym = (e1)=>{\n        if (e1[0].dims.length !== 3) throw new Error(\"input should have 3 dimensions\");\n        if (![\n            2560,\n            5120,\n            10240\n        ].includes(e1[0].dims[2])) throw new Error(\"hidden state should be 2560, 5120 or 10240\");\n        if (e1[1].dims.length !== 1) throw new Error(\"bias is expected to have 1 dimensions\");\n        if (e1[0].dims[2] !== e1[1].dims[0]) throw new Error(\"last dimension of input and bias are not the same\");\n    }, Zm = (e1)=>{\n        let t = e1[0].dims.slice();\n        t[2] = t[2] / 2;\n        let r = E(\"input\", e1[0].dataType, e1[0].dims, 4), n = E(\"bias\", e1[0].dataType, [\n            e1[0].dims[2]\n        ], 4), o = M(\"output\", e1[0].dataType, t, 4), i = C.size(t) / 4, a = _e(e1[0].dataType);\n        return {\n            name: \"BiasSplitGelu\",\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: t,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(i / 64)\n                    }\n                }),\n            getShaderSource: (l)=>\"\\n  const M_SQRT2 = sqrt(2.0);\\n  const halfChannels = \".concat(e1[0].dims[2] / 4 / 2, \"u;\\n\\n  \").concat(l.declareVariables(r, n, o), \"\\n\\n  \").concat(qr(a), \"\\n\\n  \").concat(l.mainStart(), \"\\n    \").concat(l.guardAgainstOutOfBoundsWorkgroupSizes(i), \"\\n    let biasIdx = global_idx % halfChannels;\\n    let batchIndex = global_idx / halfChannels;\\n    let inputOffset = biasIdx + batchIndex * halfChannels * 2;\\n    let valueLeft = input[inputOffset] + bias[biasIdx];\\n    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];\\n    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);\\n\\n    \").concat(o.setByOffset(\"global_idx\", \"valueLeft * geluRight\"), \"\\n  }\")\n        };\n    }, wu = (e1)=>{\n        Ym(e1.inputs), e1.compute(Zm(e1.inputs));\n    };\n});\nvar Qm, Xm, at, $u, xu, Su, Tu, Iu, Cu, Au, ku, Eu, Pu, zu = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    ae();\n    Qm = (e1, t, r, n, o, i, a, d, l, p, m, u)=>{\n        let h, _;\n        typeof d == \"string\" ? h = _ = (v, S)=>\"\".concat(d, \"((\").concat(v, \"),(\").concat(S, \"))\") : typeof d == \"function\" ? h = _ = d : (h = d.scalar, _ = d.vector);\n        let y = M(\"outputData\", m, n.length, 4), g = E(\"aData\", l, t.length, 4), x = E(\"bData\", p, r.length, 4), $;\n        if (o) if (i) {\n            let v = C.size(t) === 1, S = C.size(r) === 1, T = t.length > 0 && t[t.length - 1] % 4 === 0, A = r.length > 0 && r[r.length - 1] % 4 === 0;\n            v || S ? $ = y.setByOffset(\"global_idx\", _(v ? \"\".concat(g.type.value, \"(\").concat(g.getByOffset(\"0\"), \".x)\") : g.getByOffset(\"global_idx\"), S ? \"\".concat(x.type.value, \"(\").concat(x.getByOffset(\"0\"), \".x)\") : x.getByOffset(\"global_idx\"))) : $ = \"\\n            let outputIndices = \".concat(y.offsetToIndices(\"global_idx * 4u\"), \";\\n            let offsetA = \").concat(g.broadcastedIndicesToOffset(\"outputIndices\", y), \";\\n            let offsetB = \").concat(x.broadcastedIndicesToOffset(\"outputIndices\", y), \";\\n            \").concat(y.setByOffset(\"global_idx\", _(a || T ? g.getByOffset(\"offsetA / 4u\") : \"\".concat(g.type.value, \"(\").concat(g.getByOffset(\"offsetA / 4u\"), \"[offsetA % 4u])\"), a || A ? x.getByOffset(\"offsetB / 4u\") : \"\".concat(x.type.value, \"(\").concat(x.getByOffset(\"offsetB / 4u\"), \"[offsetB % 4u])\"))), \"\\n          \");\n        } else $ = y.setByOffset(\"global_idx\", _(g.getByOffset(\"global_idx\"), x.getByOffset(\"global_idx\")));\n        else {\n            if (!i) throw new Error(\"no necessary to use scalar implementation for element-wise binary op implementation.\");\n            let v = function(S, T) {\n                let A = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"\";\n                let k = \"aData[indexA\".concat(T, \"][componentA\").concat(T, \"]\"), P = \"bData[indexB\".concat(T, \"][componentB\").concat(T, \"]\");\n                return \"\\n            let outputIndices\".concat(T, \" = \").concat(y.offsetToIndices(\"global_idx * 4u + \".concat(T, \"u\")), \";\\n            let offsetA\").concat(T, \" = \").concat(g.broadcastedIndicesToOffset(\"outputIndices\".concat(T), y), \";\\n            let offsetB\").concat(T, \" = \").concat(x.broadcastedIndicesToOffset(\"outputIndices\".concat(T), y), \";\\n            let indexA\").concat(T, \" = offsetA\").concat(T, \" / 4u;\\n            let indexB\").concat(T, \" = offsetB\").concat(T, \" / 4u;\\n            let componentA\").concat(T, \" = offsetA\").concat(T, \" % 4u;\\n            let componentB\").concat(T, \" = offsetB\").concat(T, \" % 4u;\\n            \").concat(S, \"[\").concat(T, \"] = \").concat(A, \"(\").concat(h(k, P), \");\\n          \");\n            };\n            m === 9 ? $ = \"\\n            var data = vec4<u32>(0);\\n            \".concat(v(\"data\", 0, \"u32\"), \"\\n            \").concat(v(\"data\", 1, \"u32\"), \"\\n            \").concat(v(\"data\", 2, \"u32\"), \"\\n            \").concat(v(\"data\", 3, \"u32\"), \"\\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));\") : $ = \"\\n            \".concat(v(\"outputData[global_idx]\", 0), \"\\n            \").concat(v(\"outputData[global_idx]\", 1), \"\\n            \").concat(v(\"outputData[global_idx]\", 2), \"\\n            \").concat(v(\"outputData[global_idx]\", 3), \"\\n          \");\n        }\n        return \"\\n        \".concat(e1.registerUniform(\"vec_size\", \"u32\").declareVariables(g, x, y), \"\\n\\n        \").concat(u !== null && u !== void 0 ? u : \"\", \"\\n\\n        \").concat(e1.mainStart(), \"\\n        \").concat(e1.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.vec_size\"), \"\\n        \").concat($, \"\\n      }\");\n    }, Xm = function(e1, t, r, n, o, i) {\n        let a = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : r.dataType;\n        let d = r.dims.map((g)=>{\n            var _Number;\n            return (_Number = Number(g)) !== null && _Number !== void 0 ? _Number : 1;\n        }), l = n.dims.map((g)=>{\n            var _Number;\n            return (_Number = Number(g)) !== null && _Number !== void 0 ? _Number : 1;\n        }), p = !C.areEqual(d, l), m = d, u = C.size(d), h = !1, _ = !1, y = [\n            p\n        ];\n        if (p) {\n            let g = tt.calcShape(d, l, !1);\n            if (!g) throw new Error(\"Can't perform binary op on the given tensors\");\n            m = g.slice(), u = C.size(m);\n            let x = C.size(d) === 1, $ = C.size(l) === 1, v = d.length > 0 && d[d.length - 1] % 4 === 0, S = l.length > 0 && l[l.length - 1] % 4 === 0;\n            y.push(x), y.push($), y.push(v), y.push(S);\n            let T = 1;\n            for(let A = 1; A < m.length; A++){\n                let k = d[d.length - A], P = l[l.length - A];\n                if (k === P) T *= k;\n                else break;\n            }\n            T % 4 === 0 ? (_ = !0, h = !0) : (x || $ || v || S) && (h = !0);\n        } else h = !0;\n        return y.push(h), {\n            name: e1,\n            shaderCache: {\n                hint: t + y.map((g)=>g.toString()).join(\"_\"),\n                inputDependencies: [\n                    \"rank\",\n                    \"rank\"\n                ]\n            },\n            getShaderSource: (g)=>Qm(g, d, l, m, h, p, _, o, r.dataType, n.dataType, a, i),\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: m,\n                            dataType: a\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(u / 64 / 4)\n                    },\n                    programUniforms: [\n                        {\n                            type: 12,\n                            data: Math.ceil(C.size(m) / 4)\n                        },\n                        ...N(d, l, m)\n                    ]\n                })\n        };\n    }, at = (e1, t, r, n, o, i)=>{\n        e1.compute(Xm(t, o !== null && o !== void 0 ? o : \"\", e1.inputs[0], e1.inputs[1], r, n, i));\n    }, $u = (e1)=>{\n        at(e1, \"Add\", (t, r)=>\"\".concat(t, \"+\").concat(r));\n    }, xu = (e1)=>{\n        at(e1, \"Div\", (t, r)=>\"\".concat(t, \"/\").concat(r));\n    }, Su = (e1)=>{\n        at(e1, \"Equal\", {\n            scalar: (t, r)=>\"u32(\".concat(t, \"==\").concat(r, \")\"),\n            vector: (t, r)=>\"vec4<u32>(\".concat(t, \"==\").concat(r, \")\")\n        }, void 0, void 0, 9);\n    }, Tu = (e1)=>{\n        at(e1, \"Mul\", (t, r)=>\"\".concat(t, \"*\").concat(r));\n    }, Iu = (e1)=>{\n        let t = E(\"input\", e1.inputs[0].dataType, e1.inputs[0].dims).type.value;\n        at(e1, \"Pow\", {\n            scalar: (n, o)=>\"pow_custom(\".concat(n, \",\").concat(o, \")\"),\n            vector: (n, o)=>\"pow_vector_custom(\".concat(n, \",\").concat(o, \")\")\n        }, \"\\n    fn pow_custom(a : \".concat(t, \", b : \").concat(t, \") -> \").concat(t, \" {\\n      if (b == \").concat(t, \"(0.0)) {\\n        return \").concat(t, \"(1.0);\\n      } else if (a < \").concat(t, \"(0.0) && f32(b) != floor(f32(b))) {\\n        return \").concat(t, \"(pow(f32(a), f32(b))); // NaN\\n      }\\n      return select(sign(a), \").concat(t, \"(1.0), round(f32(abs(b) % \").concat(t, \"(2.0))) != 1.0) * \").concat(t, \"(\").concat(t === \"i32\" ? \"round\" : \"\", \"(pow(f32(abs(a)), f32(b))));\\n    }\\n    fn pow_vector_custom(a : vec4<\").concat(t, \">, b : vec4<\").concat(t, \">) -> vec4<\").concat(t, \"> {\\n      // TODO: implement vectorized pow\\n      return vec4<\").concat(t, \">(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));\\n    }\\n      \"));\n    }, Cu = (e1)=>{\n        at(e1, \"Sub\", (t, r)=>\"\".concat(t, \"-\").concat(r));\n    }, Au = (e1)=>{\n        at(e1, \"Greater\", {\n            scalar: (t, r)=>\"u32(\".concat(t, \">\").concat(r, \")\"),\n            vector: (t, r)=>\"vec4<u32>(\".concat(t, \">\").concat(r, \")\")\n        }, void 0, void 0, 9);\n    }, ku = (e1)=>{\n        at(e1, \"Less\", {\n            scalar: (t, r)=>\"u32(\".concat(t, \"<\").concat(r, \")\"),\n            vector: (t, r)=>\"vec4<u32>(\".concat(t, \"<\").concat(r, \")\")\n        }, void 0, void 0, 9);\n    }, Eu = (e1)=>{\n        at(e1, \"GreaterOrEqual\", {\n            scalar: (t, r)=>\"u32(\".concat(t, \">=\").concat(r, \")\"),\n            vector: (t, r)=>\"vec4<u32>(\".concat(t, \">=\").concat(r, \")\")\n        }, void 0, void 0, 9);\n    }, Pu = (e1)=>{\n        at(e1, \"LessOrEqual\", {\n            scalar: (t, r)=>\"u32(\".concat(t, \"<=\").concat(r, \")\"),\n            vector: (t, r)=>\"vec4<u32>(\".concat(t, \"<=\").concat(r, \")\")\n        }, void 0, void 0, 9);\n    };\n});\nvar ef, tf, rf, nf, Ou, Du, Bu = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    ef = (e1, t)=>{\n        if (!e1 || e1.length < 1) throw new Error(\"too few inputs\");\n        let r = 0, n = e1[r], o = n.dataType, i = n.dims.length;\n        e1.forEach((a, d)=>{\n            if (d !== r) {\n                if (a.dataType !== o) throw new Error(\"input tensors should be one type\");\n                if (a.dims.length !== i) throw new Error(\"input tensors should have the same shape\");\n                a.dims.forEach((l, p)=>{\n                    if (p !== t && l !== n.dims[p]) throw new Error(\"non concat dimensions must match\");\n                });\n            }\n        });\n    }, tf = (e1, t)=>\"\\n  fn calculateInputIndex(index: u32) -> u32 {\\n    let sizeInConcatAxis = array<u32, \".concat(e1, \"u>(\").concat(t, \");\\n    for (var i: u32 = 0u; i < \").concat(e1, \"; i += 1u ) {\\n      if (index < sizeInConcatAxis[i]) {\\n        return i;\\n      }\\n    }\\n    return \").concat(e1, \"u;\\n  }\"), rf = (e1, t)=>{\n        let r = e1.length, n = [];\n        for(let o = 0; o < r; ++o){\n            let i = t.setByOffset(\"global_idx\", e1[o].getByIndices(\"indices\"));\n            r === 1 ? n.push(i) : o === 0 ? n.push(\"if (inputIndex == \".concat(o, \"u) { \").concat(i, \" }\")) : o === r - 1 ? n.push(\"else { \".concat(i, \" }\")) : n.push(\"else if (inputIndex == \".concat(o, \") { \").concat(i, \" }\"));\n        }\n        return n.join(\"\\n\");\n    }, nf = (e1, t, r, n)=>{\n        let o = C.size(r), i = new Array(e1.length), a = new Array(e1.length), d = 0, l = [], p = [], m = [\n            {\n                type: 12,\n                data: o\n            }\n        ];\n        for(let g = 0; g < e1.length; ++g)d += e1[g].dims[t], i[g] = d, p.push(e1[g].dims.length), a[g] = E(\"input\".concat(g), n, p[g]), l.push(\"rank\"), m.push({\n            type: 12,\n            data: i[g]\n        });\n        for(let g = 0; g < e1.length; ++g)m.push(...N(e1[g].dims));\n        m.push(...N(r));\n        let u = M(\"output\", n, r.length), h = u.indicesGet(\"indices\", t), _ = Array.from(Array(i.length).keys()).map((g)=>\"uniforms.sizeInConcatAxis\".concat(g)).join(\",\"), y = (g)=>\"\\n\\n  \".concat((()=>{\n                g.registerUniform(\"outputSize\", \"u32\");\n                for(let x = 0; x < e1.length; x++)g.registerUniform(\"sizeInConcatAxis\".concat(x), \"u32\");\n                return g.declareVariables(...a, u);\n            })(), \"\\n\\n  \").concat(tf(i.length, _), \"\\n\\n  \").concat(g.mainStart(), \"\\n    \").concat(g.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\"), \"\\n\\n    var indices = \").concat(u.offsetToIndices(\"global_idx\"), \";\\n\\n    let inputIndex = calculateInputIndex(\").concat(h, \");\\n    if (inputIndex != 0u) {\\n      let sizeInConcatAxis = array<u32, \").concat(i.length, \"u>(\").concat(_, \");\\n      \").concat(h, \" -= sizeInConcatAxis[inputIndex - 1u];\\n    }\\n\\n    \").concat(rf(a, u), \"\\n  }\");\n        return {\n            name: \"Concat\",\n            shaderCache: {\n                hint: \"\".concat(t),\n                inputDependencies: l\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: r,\n                            dataType: n\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(o / 64)\n                    },\n                    programUniforms: m\n                }),\n            getShaderSource: y\n        };\n    }, Ou = (e1, t)=>{\n        let r = e1.inputs, n = r[0].dims, o = C.normalizeAxis(t.axis, n.length);\n        ef(r, o);\n        let i = n.slice();\n        i[o] = r.reduce((d, l)=>d + (l.dims.length > o ? l.dims[o] : 0), 0);\n        let a = r.filter((d)=>C.size(d.dims) > 0);\n        e1.compute(nf(a, o, i, r[0].dataType), {\n            inputs: a\n        });\n    }, Du = (e1)=>re({\n            axis: e1.axis\n        });\n});\nvar qe, Ke, je, jr, yt = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    qe = function(e1, t) {\n        let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"f32\";\n        switch(e1.activation){\n            case \"Relu\":\n                return \"value = max(value, \".concat(t, \"(0.0));\");\n            case \"Sigmoid\":\n                return \"value = (\".concat(t, \"(1.0) / (\").concat(t, \"(1.0) + exp(-value)));\");\n            case \"Clip\":\n                return \"value = clamp(value, \".concat(t, \"(\").concat(r, \"(uniforms.clip_min)), \").concat(t, \"(\").concat(r, \"(uniforms.clip_max)));\");\n            case \"HardSigmoid\":\n                return \"value = max(\".concat(t, \"(0.0), min(\").concat(t, \"(1.0), \").concat(r, \"(uniforms.alpha) * value + \").concat(r, \"(uniforms.beta)));\");\n            case \"LeakyRelu\":\n                return \"value = select(\".concat(r, \"(uniforms.alpha) * value, value, value >= \").concat(t, \"(0.0));\");\n            case \"Tanh\":\n                return \"let e2x = exp(-2.0 * abs(value));\\n              value = sign(value) * (1.0 - e2x) / (1.0 + e2x);\\n        \";\n            case \"\":\n                return \"\";\n            default:\n                throw new Error(\"Unsupported activation \".concat(e1.activation));\n        }\n    }, Ke = (e1, t)=>{\n        e1.activation === \"Clip\" ? t.push({\n            type: 1,\n            data: e1.clipMax\n        }, {\n            type: 1,\n            data: e1.clipMin\n        }) : e1.activation === \"HardSigmoid\" ? t.push({\n            type: 1,\n            data: e1.alpha\n        }, {\n            type: 1,\n            data: e1.beta\n        }) : e1.activation === \"LeakyRelu\" && t.push({\n            type: 1,\n            data: e1.alpha\n        });\n    }, je = (e1, t)=>{\n        e1.activation === \"Clip\" ? t.push({\n            name: \"clip_max\",\n            type: \"f32\"\n        }, {\n            name: \"clip_min\",\n            type: \"f32\"\n        }) : e1.activation === \"HardSigmoid\" ? t.push({\n            name: \"alpha\",\n            type: \"f32\"\n        }, {\n            name: \"beta\",\n            type: \"f32\"\n        }) : e1.activation === \"LeakyRelu\" && t.push({\n            name: \"alpha\",\n            type: \"f32\"\n        });\n    }, jr = (e1)=>{\n        let t = (e1 === null || e1 === void 0 ? void 0 : e1.activation) || \"\";\n        if (t === \"HardSigmoid\") {\n            let [r, n] = (e1 === null || e1 === void 0 ? void 0 : e1.activation_params) || [\n                .2,\n                .5\n            ];\n            return {\n                activation: t,\n                alpha: r,\n                beta: n\n            };\n        } else if (t === \"Clip\") {\n            let [r, n] = (e1 === null || e1 === void 0 ? void 0 : e1.activation_params) || [\n                es,\n                ts\n            ];\n            return {\n                activation: t,\n                clipMax: n,\n                clipMin: r\n            };\n        } else if (t === \"LeakyRelu\") {\n            let [r] = (e1 === null || e1 === void 0 ? void 0 : e1.activation_params) || [\n                .01\n            ];\n            return {\n                activation: t,\n                alpha: r\n            };\n        }\n        return {\n            activation: t\n        };\n    };\n});\nvar Ae, Mu, Yr = U(()=>{\n    \"use strict\";\n    Ae = (e1, t)=>{\n        switch(e1){\n            case 1:\n                return t;\n            case 2:\n                return \"vec2<\".concat(t, \">\");\n            case 3:\n                return \"vec3<\".concat(t, \">\");\n            case 4:\n                return \"vec4<\".concat(t, \">\");\n            default:\n                throw new Error(\"\".concat(e1, \"-component is not supported.\"));\n        }\n    }, Mu = (e1)=>\"\\n      \".concat(e1 ? \"value = value + getBiasByOutputCoords(coords);\" : \"\", \"\\n      \");\n});\nvar Ru, Uu = U(()=>{\n    \"use strict\";\n    Ru = (e1)=>\"\\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\\n  return dot(coords, vec4<i32>(\\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\\n}\\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\\n  return dot(coords, vec4<i32>(\\n    i32(\".concat(e1, \".x), i32(\").concat(e1, \".y), i32(\").concat(e1, \".z), 1));\\n}\\n\");\n});\nvar Jt, Zr, Qr = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    ae();\n    yt();\n    Jt = (e1, t, r, n, o)=>{\n        let i = n - r;\n        return \"\\n      \".concat(Array.from({\n            length: r\n        }).map((a, d)=>\"\\n      if (\".concat(F(t.shape, d, t.rank), \" != 1) {\\n        \").concat(t.indicesSet(e1, d, F(o, d + i, n)), \"\\n      } else {\\n        \").concat(t.indicesSet(e1, d, 0), \"\\n      }\")).join(\"\"), \"\\n\");\n    }, Zr = function(e1, t, r, n) {\n        let o = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1, i = arguments.length > 5 ? arguments[5] : void 0;\n        let a = e1[0].dims, d = e1[1].dims, l = a[a.length - 2], p = d[d.length - 1], m = a[a.length - 1], u = me(p), h = me(m), _ = me(l), y = C.size(r) / u / _, g = e1.length > 2, x = n ? n.slice(0, -2) : r.slice(0, -2), v = [\n            C.size(x),\n            l,\n            p\n        ], S = [\n            {\n                type: 12,\n                data: y\n            },\n            {\n                type: 12,\n                data: l\n            },\n            {\n                type: 12,\n                data: p\n            },\n            {\n                type: 12,\n                data: m\n            }\n        ];\n        Ke(t, S), S.push(...N(x, a, d)), g && S.push(...N(e1[2].dims)), S.push(...N(v));\n        let T = (A)=>{\n            let k = Lr(\"batch_dims\", e1[0].dataType, x.length), P = E(\"a\", e1[0].dataType, a.length, h), D = E(\"b\", e1[1].dataType, d.length, u), R = M(\"output\", e1[0].dataType, v.length, u), G = _e(R.type.tensor), K = qe(t, R.type.value, G), j = [\n                P,\n                D\n            ], V = \"\";\n            if (g) {\n                let Y = o ? u : 1;\n                j.push(E(\"bias\", e1[2].dataType, e1[2].dims.length, Y)), V = \"\".concat(o ? \"value += bias[col / \".concat(Y, \"];\") : \"value += \".concat(R.type.value, \"(bias[row + i]);\"));\n            }\n            let Q = [\n                {\n                    name: \"output_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"M\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"N\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"K\",\n                    type: \"u32\"\n                }\n            ];\n            je(t, Q);\n            let se = ()=>{\n                let Y = \"var a_data: \".concat(P.type.value, \";\");\n                for(let ee = 0; ee < h; ee++)Y += \"\\n              let b_data\".concat(ee, \" = b[(b_offset + (k + \").concat(ee, \") * uniforms.N + col) / \").concat(u, \"];\");\n                for(let ee = 0; ee < _; ee++){\n                    Y += \"a_data = a[(a_offset + (row + \".concat(ee, \") * uniforms.K + k) / \").concat(h, \"];\");\n                    for(let J = 0; J < h; J++)Y += \"\\n            values[\".concat(ee, \"] = fma(\").concat(D.type.value, \"(a_data\").concat(h === 1 ? \"\" : \"[\".concat(J, \"]\"), \"), b_data\").concat(J, \", values[\").concat(ee, \"]);\\n\");\n                }\n                return Y;\n            };\n            return \"\\n  \".concat(A.registerUniforms(Q).registerInternalVariables(k).declareVariables(...j, R), \"\\n  \").concat(A.mainStart(), \"\\n    \").concat(A.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\"), \"\\n    let col = (global_idx % (uniforms.N / \").concat(u, \")) * \").concat(u, \";\\n    var index1 = global_idx / (uniforms.N / \").concat(u, \");\\n    let stride1 = uniforms.M / \").concat(_, \";\\n    let row = (index1 % stride1) * \").concat(_, \";\\n    let batch = index1 / stride1;\\n\\n    \").concat(r.length === 2 ? \"\" : \"let batch_indices = \".concat(k.offsetToIndices(\"batch\"), \";\"), \"\\n\\n    var a_indices: \").concat(P.type.indices, \";\\n    \").concat(Jt(\"a_indices\", P, P.rank - 2, k.rank, \"batch_indices\"), \"\\n    \").concat(P.indicesSet(\"a_indices\", P.rank - 2, 0), \"\\n    \").concat(P.indicesSet(\"a_indices\", P.rank - 1, 0), \"\\n    let a_offset = \").concat(P.indicesToOffset(\"a_indices\"), \";\\n\\n    var b_indices: \").concat(D.type.indices, \";\\n    \").concat(Jt(\"b_indices\", D, D.rank - 2, k.rank, \"batch_indices\"), \"\\n    \").concat(D.indicesSet(\"b_indices\", D.rank - 2, 0), \"\\n    \").concat(D.indicesSet(\"b_indices\", D.rank - 1, 0), \"\\n    let b_offset = \").concat(D.indicesToOffset(\"b_indices\"), \";\\n    var values: array<\").concat(R.type.value, \", \").concat(_, \">;\\n    for (var k: u32 = 0u; k < uniforms.K; k = k + \").concat(h, \") {\\n      \").concat(se(), \"\\n    }\\n    for (var i = 0u; i < \").concat(_, \"u; i++) {\\n      var value = values[i];\\n      \").concat(V, \"\\n      \").concat(K, \"\\n      let cur_indices = \").concat(R.type.indices, \"(batch, row + i, col);\\n      let offset = \").concat(R.indicesToOffset(\"cur_indices\"), \";\\n      \").concat(R.setByOffset(\"offset / \".concat(u), \"value\"), \";\\n    }\\n  }\\n  \");\n        };\n        return {\n            name: \"MatMulNaive\",\n            shaderCache: {\n                hint: \"\".concat(t.activation, \";\").concat(u, \";\").concat(h, \";\").concat(_, \";\").concat(o),\n                inputDependencies: g ? [\n                    \"rank\",\n                    \"rank\",\n                    \"rank\"\n                ] : [\n                    \"rank\",\n                    \"rank\"\n                ]\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: i ? i(r) : r,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(y / 64)\n                    },\n                    programUniforms: S\n                }),\n            getShaderSource: T\n        };\n    };\n});\nvar of, af, ho, Nu, sf, go, uf, er, Xr = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    ae();\n    yt();\n    Qr();\n    Yr();\n    of = (e1, t)=>e1 ? \"\\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\\n          kStart + inputRow,\\n          globalRowStart / innerElementSize + inputCol\".concat(t ? \", batchIndices\" : \"\", \");\\n        \") : \"\\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\\n          globalRow + innerRow,\\n          kStart / innerElementSize + inputCol\".concat(t ? \", batchIndices\" : \"\", \");\\n        \"), af = (e1, t)=>e1 ? \"\\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\\n        \".concat(t === 3 ? \"\" : \"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];\", \"\\n        for (var i = 0; i < rowPerThread; i = i + 1) {\\n          acc[i] = BCached0 * ACached0[i] + acc[i];\\n          acc[i] = BCached1 * ACached1[i] + acc[i];\\n          acc[i] = BCached2 * ACached2[i] + acc[i];\\n          \").concat(t === 3 ? \"\" : \"acc[i] = BCached3 * ACached3[i] + acc[i];\", \"\\n        }\") : \"\\n        for (var i = 0; i < rowPerThread; i = i + 1) {\\n          let ACached = mm_Asub[tileRow + i][k];\\n          acc[i] = BCached0 * ACached.x + acc[i];\\n          acc[i] = BCached1 * ACached.y + acc[i];\\n          acc[i] = BCached2 * ACached.z + acc[i];\\n          \".concat(t === 3 ? \"\" : \"acc[i] = BCached3 * ACached.w + acc[i];\", \"\\n        }\"), ho = function(e1, t) {\n        let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"f32\", n = arguments.length > 3 ? arguments[3] : void 0, o = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1, i = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 32, a = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : !1, d = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : 32;\n        let l = t[1] * e1[1], p = t[0] * e1[0], m = o ? l : i, u = o ? i : l, h = m / t[0], _ = i / t[1];\n        if (!((o && h === 4 && e1[1] === 4 || !o && (h === 3 || h === 4)) && m % t[0] === 0 && i % t[1] === 0 && e1[0] === 4)) throw new Error(\"If transposeA \".concat(o, \" is true, innerElementSize \").concat(h, \" and workPerThread[1] \").concat(e1[1], \" must be 4.\\n      Otherwise, innerElementSize \").concat(h, \" must be 3 or 4.\\n  tileAWidth \").concat(m, \" must be divisible by workgroupSize[0]\").concat(t[0], \". tileInner \").concat(i, \" must be divisible by workgroupSize[1] \").concat(t[1], \". colPerThread \").concat(e1[0], \" must be 4.\"));\n        return \"\\nvar<workgroup> mm_Asub: array<array<vec\".concat(h, \"<\").concat(r, \">, \").concat(m / h, \">, \").concat(u, \">;\\nvar<workgroup> mm_Bsub: array<array<vec4<\").concat(r, \">, \").concat(p / e1[0], \">, \").concat(i, \">;\\n\\nconst rowPerThread = \").concat(e1[1], \";\\nconst colPerThread = \").concat(e1[0], \";\\nconst innerElementSize = \").concat(h, \";\\nconst tileInner = \").concat(i, \";\\n\\n@compute @workgroup_size(\").concat(t[0], \", \").concat(t[1], \", \").concat(t[2], \")\\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\\n        @builtin(global_invocation_id) globalId : vec3<u32>,\\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\\n  let localRow = i32(localId.y);\\n  let tileRow = localRow * rowPerThread;\\n  let tileCol = i32(localId.x);\\n\\n  let globalRow =i32(globalId.y) * rowPerThread;\\n  let globalCol = i32(globalId.x);\\n  let batch = \").concat(a ? \"0\" : \"i32(globalId.z)\", \";\\n  \").concat(n ? \"let batchIndices = \".concat(n.offsetToIndices(\"u32(batch)\"), \";\") : \"\", \"\\n  let globalRowStart = i32(workgroupId.y) * \").concat(l, \";\\n\\n  let num_tiles = \").concat(a ? \"\".concat(Math.ceil(d / i)) : \"(uniforms.dim_inner - 1) / tileInner + 1\", \";\\n  var kStart = \").concat(a ? \"i32(globalId.z) * \".concat(d) : \"0\", \";\\n\\n  var acc: array<vec4<\").concat(r, \">, rowPerThread>;\\n\\n  // Loop over shared dimension.\\n  let tileRowB = localRow * \").concat(_, \";\\n  for (var t = 0; t < num_tiles; t = t + 1) {\\n      // Load one tile of A into local memory.\\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\\n          let inputRow = tileRow + innerRow;\\n          let inputCol = tileCol;\\n          \").concat(of(o, n), \"\\n      }\\n\\n      // Load one tile of B into local memory.\\n      for (var innerRow = 0; innerRow < \").concat(_, \"; innerRow = innerRow + 1) {\\n          let inputRow = tileRowB + innerRow;\\n          let inputCol = tileCol;\\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol\").concat(n ? \", batchIndices\" : \"\", \");\\n      }\\n      kStart = kStart + tileInner;\\n      workgroupBarrier();\\n\\n      // Compute acc values for a single thread.\\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\\n          \").concat(h === 3 ? \"\" : \"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];\", \"\\n\\n          \").concat(af(o, h), \"\\n      }\\n\\n      workgroupBarrier();\\n  }\\n\\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\\n  }\\n}\");\n    }, Nu = (e1, t)=>e1 ? \"\\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\\n              kStart + inputRow,\\n              globalRowStart + inputCol\".concat(t ? \", batchIndices\" : \"\", \");\\n            \") : \"\\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\\n              globalRowStart + inputRow,\\n              kStart + inputCol\".concat(t ? \", batchIndices\" : \"\", \");\\n            \"), sf = (e1)=>e1 ? \"let ACached = mm_Asub[k][tileRow + innerRow];\" : \"let ACached = mm_Asub[tileRow + innerRow][k];\", go = function(e1, t) {\n        let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"f32\", n = arguments.length > 3 ? arguments[3] : void 0, o = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1, i = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 32, a = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : !1, d = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : 32, l = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : !1;\n        let p = e1[1] * t[1], m = e1[0] * t[0], u = o ? p : i, h = o ? i : p;\n        if (!(h % t[1] === 0 && u % t[0] === 0 && i % t[1] === 0)) throw new Error(\"tileAHight \".concat(h, \" must be divisible by workgroupSize[1]\").concat(t[1], \", tileAWidth \").concat(u, \" must be divisible by workgroupSize[0]\").concat(t[0], \", tileInner \").concat(i, \" must be divisible by workgroupSize[1]\").concat(t[1]));\n        let _ = h / t[1], y = u / t[0], g = i / t[1], x = l ? \"\\n    let localRow = i32(localId.y);\\n    let localCol = i32(localId.x);\\n    let globalRowStart = i32(workgroupId.y) * \".concat(p, \";\\n    let globalColStart = i32(workgroupId.x) * \").concat(m, \";\\n\\n    // Loop over shared dimension.\\n    for (var t = 0; t < num_tiles; t = t + 1) {\\n      // Load one tile of A into local memory.\\n      for (var inputRow = localRow; inputRow < \").concat(h, \"; inputRow = inputRow + \").concat(t[1], \") {\\n        for (var inputCol = localCol; inputCol < \").concat(u, \"; inputCol = inputCol + \").concat(t[0], \") {\\n          \").concat(Nu(o, n), \"\\n        }\\n      }\\n      // Load one tile of B into local memory.\\n      for (var inputRow = localRow; inputRow < \").concat(i, \"; inputRow = inputRow + \").concat(t[1], \") {\\n            for (var inputCol = localCol; inputCol < \").concat(m, \"; inputCol = inputCol + \").concat(t[0], \") {\\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\\n            kStart + inputRow,\\n            globalColStart + inputCol\").concat(n ? \", batchIndices\" : \"\", \");\\n        }\\n      }\\n      kStart = kStart + tileInner;\\n      workgroupBarrier();\\n\\n      // Compute acc values for a single thread.\\n      var BCached : array<\").concat(r, \", colPerThread>;\\n      for (var k = 0; k < tileInner; k = k + 1) {\\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\\n          BCached[inner] = mm_Bsub[k][localCol + inner * \").concat(t[0], \"];\\n        }\\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\\n          let ACached = \").concat(o ? \"mm_Asub[k][localRow + innerRow * \".concat(t[1], \"];\") : \"mm_Asub[localRow + innerRow * \".concat(t[1], \"][k];\"), \"\\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\\n                ACached * BCached[innerCol];\\n          }\\n        }\\n      }\\n      workgroupBarrier();\\n    }\\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\\n      let gRow = globalRowStart + localRow + innerRow * \").concat(t[1], \";\\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\\n        let gCol = globalColStart + localCol + innerCol * \").concat(t[0], \";\\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\\n      }\\n    }\\n    \") : \"\\nlet tileRow = i32(localId.y) * rowPerThread;\\nlet tileCol = i32(localId.x) * colPerThread;\\n\\nlet globalRow = i32(globalId.y) * rowPerThread;\\nlet globalCol = i32(globalId.x) * colPerThread;\\nlet globalRowStart = i32(workgroupId.y) * \".concat(p, \";\\n\\nlet tileRowA = i32(localId.y) * \").concat(_, \";\\nlet tileColA = i32(localId.x) * \").concat(y, \";\\nlet tileRowB = i32(localId.y) * \").concat(g, \";\\n// Loop over shared dimension.\\nfor (var t = 0; t < num_tiles; t = t + 1) {\\n  // Load one tile of A into local memory.\\n  for (var innerRow = 0; innerRow < \").concat(_, \"; innerRow = innerRow + 1) {\\n    for (var innerCol = 0; innerCol < \").concat(y, \"; innerCol = innerCol + 1) {\\n      let inputRow = tileRowA + innerRow;\\n      let inputCol = tileColA + innerCol;\\n      \").concat(Nu(o, n), \"\\n    }\\n  }\\n\\n  // Load one tile of B into local memory.\\n  for (var innerRow = 0; innerRow < \").concat(g, \"; innerRow = innerRow + 1) {\\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\\n      let inputRow = tileRowB + innerRow;\\n      let inputCol = tileCol + innerCol;\\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\\n        kStart + inputRow,\\n        globalCol + innerCol\").concat(n ? \", batchIndices\" : \"\", \");\\n    }\\n  }\\n  kStart = kStart + tileInner;\\n  workgroupBarrier();\\n\\n  // Compute acc values for a single thread.\\n  var BCached : array<\").concat(r, \", colPerThread>;\\n  for (var k = 0; k < tileInner; k = k + 1) {\\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\\n    }\\n\\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\\n      \").concat(sf(o), \"\\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\\n      }\\n    }\\n  }\\n\\n  workgroupBarrier();\\n}\\n\\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\\n        acc[innerRow][innerCol]);\\n  }\\n}\\n\");\n        return \"\\n  var<workgroup> mm_Asub : array<array<\".concat(r, \", \").concat(u, \">, \").concat(h, \">;\\n  var<workgroup> mm_Bsub : array<array<\").concat(r, \", \").concat(m, \">, \").concat(i, \">;\\n  const rowPerThread = \").concat(e1[1], \";\\n  const colPerThread = \").concat(e1[0], \";\\n  const tileInner = \").concat(i, \";\\n\\n@compute @workgroup_size(\").concat(t[0], \", \").concat(t[1], \", \").concat(t[2], \")\\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\\n        @builtin(global_invocation_id) globalId : vec3<u32>,\\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\\n    let batch = \").concat(a ? \"0\" : \"i32(globalId.z)\", \";\\n    \").concat(n ? \"let batchIndices = \".concat(n.offsetToIndices(\"u32(batch)\"), \";\") : \"\", \"\\n    let num_tiles = \").concat(a ? \"\".concat(Math.ceil(d / i)) : \"(uniforms.dim_inner - 1) / tileInner + 1\", \";\\n    var kStart = \").concat(a ? \"i32(globalId.z) * \".concat(d) : \"0\", \";\\n\\n    var acc : array<array<\").concat(r, \", colPerThread>, rowPerThread>;\\n    \").concat(x, \"\\n  }\\n\");\n    }, uf = function(e1, t, r, n) {\n        let o = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1;\n        let [i, a, d, l] = n, p = _e(n[0].type.tensor);\n        return \"\\n    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: \".concat(i.type.indices, \") -> \").concat(Ae(e1, p), \" {\\n      var value = \").concat(Ae(e1, p), \"(0.0);\\n      let col = colIn * \").concat(e1, \";\\n      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)\\n      {\\n        var aIndices: \").concat(a.type.indices, \";\\n        \").concat(Jt(\"aIndices\", a, a.rank - 2, i.rank, \"batchIndices\"), \"\\n        \").concat(a.indicesSet(\"aIndices\", a.rank - 2, \"u32(row)\"), \"\\n        \").concat(a.indicesSet(\"aIndices\", a.rank - 1, \"u32(colIn)\"), \"\\n        value = \").concat(a.getByIndices(\"aIndices\"), \";\\n      }\\n      return value;\\n    }\\n\\n    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: \").concat(i.type.indices, \") -> \").concat(Ae(e1, p), \" {\\n      var value = \").concat(Ae(e1, p), \"(0.0);\\n      let col = colIn * \").concat(e1, \";\\n      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)\\n      {\\n        var bIndices: \").concat(d.type.indices, \";\\n        \").concat(Jt(\"bIndices\", d, d.rank - 2, i.rank, \"batchIndices\"), \"\\n        \").concat(d.indicesSet(\"bIndices\", d.rank - 2, \"u32(row)\"), \"\\n        \").concat(d.indicesSet(\"bIndices\", d.rank - 1, \"u32(colIn)\"), \"\\n        value = \").concat(d.getByIndices(\"bIndices\"), \";\\n      }\\n      return value;\\n    }\\n\\n    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: \").concat(Ae(e1, p), \") {\\n      let col = colIn * \").concat(e1, \";\\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {\\n        var value = valueIn;\\n        let coords = vec3<i32>(batch, row, colIn);\\n        \").concat(t ? \"value = value + \".concat(o ? \"bias[colIn]\" : \"\".concat(Ae(e1, p), \"(bias[row])\"), \";\") : \"\", \"\\n        \").concat(r, \"\\n        \").concat(l.setByIndices(\"vec3<u32>(coords)\", \"value\"), \"\\n      }\\n    }\\n    \");\n    }, er = function(e1, t, r, n) {\n        let o = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1, i = arguments.length > 5 ? arguments[5] : void 0;\n        let a = e1[0].dims, d = e1[1].dims, l = a.slice(0, -2), p = d.slice(0, -2), m = n ? n.slice(0, -2) : r.slice(0, -2), u = C.size(m), h = a[a.length - 2], _ = a[a.length - 1], y = d[d.length - 1], g = _ % 4 === 0 && y % 4 === 0, x = h <= 8 ? [\n            4,\n            1,\n            1\n        ] : [\n            4,\n            4,\n            1\n        ], $ = [\n            8,\n            8,\n            1\n        ], v = [\n            Math.ceil(y / $[0] / x[0]),\n            Math.ceil(h / $[1] / x[1]),\n            Math.ceil(u / $[2] / x[2])\n        ], S = g ? 4 : 1, T = [\n            ...l,\n            h,\n            _ / S\n        ], A = T.length, k = [\n            ...p,\n            _,\n            y / S\n        ], P = k.length, D = [\n            u,\n            h,\n            y / S\n        ], R = [\n            {\n                type: 6,\n                data: h\n            },\n            {\n                type: 6,\n                data: y\n            },\n            {\n                type: 6,\n                data: _\n            }\n        ];\n        Ke(t, R), R.push(...N(m, T, k));\n        let G = [\n            \"rank\",\n            \"rank\"\n        ], K = e1.length > 2;\n        K && (R.push(...N(e1[2].dims)), G.push(\"rank\")), R.push(...N(D));\n        let j = (V)=>{\n            let Q = m.length, se = Lr(\"batchDims\", e1[0].dataType, Q, 1), Y = _e(e1[0].dataType), ee = E(\"a\", e1[0].dataType, A, S), J = E(\"b\", e1[1].dataType, P, S), ne = M(\"result\", e1[0].dataType, D.length, S), be = [\n                ee,\n                J\n            ];\n            if (K) {\n                let q = o ? S : 1;\n                be.push(E(\"bias\", e1[2].dataType, e1[2].dims.length, q));\n            }\n            let Oe = [\n                {\n                    name: \"dim_a_outer\",\n                    type: \"i32\"\n                },\n                {\n                    name: \"dim_b_outer\",\n                    type: \"i32\"\n                },\n                {\n                    name: \"dim_inner\",\n                    type: \"i32\"\n                }\n            ];\n            je(t, Oe);\n            let $e = _e(ne.type.tensor), le = qe(t, ne.type.value, $e), W = uf(S, K, le, [\n                se,\n                ee,\n                J,\n                ne\n            ], o);\n            return \"\\n  \".concat(V.registerUniforms(Oe).registerInternalVariables(se).declareVariables(...be, ne), \"\\n  \").concat(W, \"\\n  \").concat(g ? ho(x, $, Y, se) : go(x, $, Y, se), \"\\n                   \");\n        };\n        return {\n            name: \"MatMul\",\n            shaderCache: {\n                hint: \"\".concat(x, \";\").concat(t.activation, \";\").concat(g, \";\").concat(o),\n                inputDependencies: G\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: i ? i(r) : r,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: v[0],\n                        y: v[1],\n                        z: v[2]\n                    },\n                    programUniforms: R\n                }),\n            getShaderSource: j\n        };\n    };\n});\nvar df, Vu, Wu = U(()=>{\n    \"use strict\";\n    te();\n    et();\n    ae();\n    yt();\n    Yr();\n    Uu();\n    Xr();\n    df = function(e1, t, r, n) {\n        let o = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1, i = arguments.length > 5 ? arguments[5] : void 0, a = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 4, d = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : 4, l = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : 4, p = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : \"f32\";\n        let m = (G)=>{\n            switch(G){\n                case 1:\n                    return \"resData = x[xIndex];\";\n                case 3:\n                    return \"resData = vec3<\".concat(p, \">(x[xIndex], x[xIndex + 1], x[xIndex + 2]);\");\n                case 4:\n                    return \"resData = x[xIndex / 4];\";\n                default:\n                    throw new Error(\"innerElementSize \".concat(G, \" is not supported.\"));\n            }\n        }, u = (G)=>{\n            switch(G){\n                case 1:\n                    return \"return w[row * i32(uniforms.w_shape[3]) + colIn];\";\n                case 4:\n                    return \"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];\";\n                default:\n                    throw new Error(\"innerElementSize \".concat(G, \" is not supported.\"));\n            }\n        }, h = e1 ? \"\\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\\n    \" : \"\\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\\n    \", _ = e1 ? \"\\n    let coords = vec4<i32>(\\n      batch,\\n      row / outWidth,\\n      row % outWidth,\\n      col);\\n    \" : \"\\n    let coords = vec4<i32>(\\n      batch,\\n      row,\\n      col / outWidth,\\n      col % outWidth);\\n    \", y = e1 ? \"i32(uniforms.x_shape[1])\" : \"i32(uniforms.x_shape[2])\", g = e1 ? \"i32(uniforms.x_shape[2])\" : \"i32(uniforms.x_shape[3])\", x = e1 ? \"row\" : \"col\", $ = e1 ? \"col\" : \"row\", v = \"\\n    let inChannels = i32(uniforms.w_shape[2]);\\n    let outWidth = \".concat(e1 ? \"i32(uniforms.result_shape[2])\" : \"i32(uniforms.result_shape[3])\", \";\\n    let outRow = \").concat(x, \" / outWidth;\\n    let outCol = \").concat(x, \" % outWidth;\\n\\n    let WRow = \").concat($, \" / (i32(uniforms.w_shape[1]) * inChannels);\\n    let WCol = \").concat($, \" / inChannels % i32(uniforms.w_shape[1]);\\n    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];\\n    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];\\n    let xCh = \").concat($, \" % inChannels;\\n    var resData = \").concat(Ae(a, p), \"(0.0);\\n    // The bounds checking is always needed since we use it to pad zero for\\n    // the 'same' padding type.\\n    if (xRow >= 0 && xRow < \").concat(y, \" && xCol >= 0 && xCol < \").concat(g, \") {\\n      \").concat(h, \"\\n      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));\\n      \").concat(m(a), \"\\n    }\\n    return resData;\"), S = e1 ? t && n ? \"\\n    let col = colIn * \".concat(a, \";\\n    \").concat(v) : \"\\n    let col = colIn * \".concat(a, \";\\n    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {\\n      \").concat(v, \"\\n    }\\n    return \").concat(Ae(a, p), \"(0.0);\") : n && r ? \"\\n    let col = colIn * \".concat(a, \";\\n    \").concat(v) : \"\\n    let col = colIn * \".concat(a, \";\\n    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {\\n      \").concat(v, \"\\n    }\\n    return \").concat(Ae(a, p), \"(0.0);\"), T = e1 ? n && r ? u(d) : \"\\n    let col = colIn * \".concat(d, \";\\n    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {\\n      \").concat(u(d), \"\\n    }\\n    return \").concat(Ae(d, p), \"(0.0);\") : \"\\n    let col = colIn * \".concat(d, \";\\n    if (row < uniforms.dim_inner && col < uniforms.dim_a_outer) {\\n      \").concat(u(d), \"\\n    }\\n    return \").concat(Ae(d, p), \"(0.0);\"), A = Ae(l, p), k = e1 ? Ae(a, p) : Ae(d, p), P = e1 ? Ae(d, p) : Ae(a, p), D = qe(i, A, p);\n        return \"\\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> \".concat(k, \" {\\n      \").concat(e1 ? S : T, \"\\n    }\\n\\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> \").concat(P, \" {\\n      \").concat(e1 ? T : S, \"\\n    }\\n\\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : \").concat(A, \") {\\n      let col = colIn * \").concat(l, \";\\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)\\n      {\\n      var value = valueIn;\\n      let outWidth = \").concat(e1 ? \"i32(uniforms.result_shape[2])\" : \"i32(uniforms.result_shape[3])\", \";\\n      \").concat(_, \"\\n      \").concat(Mu(o), \"\\n      \").concat(D, \"\\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\\n      }\\n    }\");\n    }, Vu = (e1, t, r, n, o, i, a, d, l)=>{\n        let p = t.format === \"NHWC\", m = p ? e1[0].dims[3] : e1[0].dims[1], u = r[0], h = p ? r[2] : r[3], _ = p ? r[1] : r[2], y = p ? r[3] : r[1], g = p && (m % 4 === 0 || m % 3 === 0) && y % 4 === 0, x = p ? y : h * _, $ = p ? h * _ : y, v = [\n            8,\n            8,\n            1\n        ], S = n <= 8 ? [\n            4,\n            1,\n            1\n        ] : [\n            4,\n            4,\n            1\n        ], T = [\n            Math.ceil(x / v[0] / S[0]),\n            Math.ceil($ / v[1] / S[1]),\n            Math.ceil(u / v[2] / S[2])\n        ];\n        ue(\"verbose\", ()=>\"[conv2d_mm_webgpu] dispatch = \".concat(T));\n        let A = g ? p && m % 4 !== 0 ? 3 : 4 : 1, k = v[1] * S[1], P = v[0] * S[0], D = Math.max(v[0] * A, v[1]), R = n % k === 0, G = o % P === 0, K = i % D === 0, j = g ? [\n            A,\n            4,\n            4\n        ] : [\n            1,\n            1,\n            1\n        ], V = [\n            {\n                type: 6,\n                data: n\n            },\n            {\n                type: 6,\n                data: o\n            },\n            {\n                type: 6,\n                data: i\n            },\n            {\n                type: 6,\n                data: [\n                    t.pads[0],\n                    t.pads[1]\n                ]\n            },\n            {\n                type: 6,\n                data: t.strides\n            },\n            {\n                type: 6,\n                data: t.dilations\n            }\n        ];\n        Ke(t, V), V.push(...N(e1[0].dims, e1[1].dims));\n        let Q = [\n            \"rank\",\n            \"rank\"\n        ];\n        a && (V.push(...N(e1[2].dims)), Q.push(\"rank\")), V.push(...N(r));\n        let se = (Y)=>{\n            let ee = [\n                {\n                    name: \"dim_a_outer\",\n                    type: \"i32\"\n                },\n                {\n                    name: \"dim_b_outer\",\n                    type: \"i32\"\n                },\n                {\n                    name: \"dim_inner\",\n                    type: \"i32\"\n                },\n                {\n                    name: \"pad\",\n                    type: \"i32\",\n                    length: 2\n                },\n                {\n                    name: \"stride\",\n                    type: \"i32\",\n                    length: 2\n                },\n                {\n                    name: \"dilation\",\n                    type: \"i32\",\n                    length: 2\n                }\n            ];\n            je(t, ee);\n            let J = g ? 4 : 1, ne = _e(e1[0].dataType), be = \"\\n      fn setOutputAtIndex(flatIndex : i32, value : \".concat(g ? \"vec4<\".concat(ne, \">\") : ne, \") {\\n        result[flatIndex] = \").concat(g ? \"vec4<\".concat(ne, \">\") : ne, \"(value);\\n      }\\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : \").concat(g ? \"vec4<\".concat(ne, \">\") : ne, \") {\\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\\n        setOutputAtIndex(flatIndex \").concat(g ? \"/ 4\" : \"\", \", value);\\n      }\"), Oe = E(\"x\", e1[0].dataType, e1[0].dims.length, A === 3 ? 1 : A), $e = E(\"w\", e1[1].dataType, e1[1].dims.length, J), le = [\n                Oe,\n                $e\n            ], W = M(\"result\", e1[0].dataType, r.length, J);\n            if (a) {\n                let q = E(\"bias\", e1[2].dataType, e1[2].dims.length, J);\n                le.push(q), be += \"\\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> \".concat(g ? \"vec4<\".concat(ne, \">\") : ne, \" {\\n          return bias[coords.\").concat(p ? \"w\" : \"y\").concat(g ? \"/ 4\" : \"\", \"];\\n        }\");\n            }\n            return \"\\n        \".concat(Ru(\"uniforms.result_strides\"), \"\\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\\n        \").concat(Y.registerUniforms(ee).declareVariables(...le, W), \"\\n        \").concat(be, \"\\n        \").concat(df(p, R, G, K, a, t, j[0], j[1], j[2], ne), \"\\n        \").concat(g ? ho(S, v, ne, void 0, !p, D) : go(S, v, ne, void 0, !p, D, !1, void 0, d));\n        };\n        return {\n            name: \"Conv2DMatMul\",\n            shaderCache: {\n                hint: \"\".concat(t.cacheKey, \";\").concat(A, \";\").concat(g, \";\").concat(R, \";\").concat(G, \";\").concat(K, \";\").concat(k, \";\").concat(P, \";\").concat(D),\n                inputDependencies: Q\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: l ? l(r) : r,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: T[0],\n                        y: T[1],\n                        z: T[2]\n                    },\n                    programUniforms: V\n                }),\n            getShaderSource: se\n        };\n    };\n});\nvar lf, Lu, Jr, cf, Gu, pf, Hu, Fu, qu = U(()=>{\n    \"use strict\";\n    te();\n    et();\n    oe();\n    ae();\n    yt();\n    Yr();\n    lf = (e1)=>{\n        let t = 1;\n        for(let r = 0; r < e1.length; r++)t *= e1[r];\n        return t;\n    }, Lu = (e1)=>typeof e1 == \"number\" ? [\n            e1,\n            e1,\n            e1\n        ] : e1, Jr = (e1, t)=>t <= 1 ? e1 : e1 + (e1 - 1) * (t - 1), cf = function(e1, t, r) {\n        let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;\n        let o = Jr(t, n);\n        return Math.floor((e1[0] * (r - 1) - r + o) / 2);\n    }, Gu = (e1, t, r, n, o)=>{\n        o == null && (o = cf(e1, t[0], n[0]));\n        let i = [\n            0,\n            0,\n            0,\n            r\n        ];\n        for(let a = 0; a < 3; a++)e1[a] + 2 * o >= t[a] && (i[a] = Math.trunc((e1[a] - t[a] + 2 * o) / n[a] + 1));\n        return i;\n    }, pf = (e1, t, r, n, o, i, a, d, l, p)=>{\n        let m, u, h, _;\n        if (e1 === \"VALID\" && (e1 = 0), typeof e1 == \"number\") {\n            m = {\n                top: e1,\n                bottom: e1,\n                left: e1,\n                right: e1,\n                front: e1,\n                back: e1\n            };\n            let y = Gu([\n                t,\n                r,\n                n,\n                1\n            ], [\n                d,\n                l,\n                p\n            ], 1, [\n                o,\n                i,\n                a\n            ], e1);\n            u = y[0], h = y[1], _ = y[2];\n        } else if (Array.isArray(e1)) {\n            if (!e1.every((g, x, $)=>g === $[0])) throw Error(\"Unsupported padding parameter: \".concat(e1));\n            m = {\n                top: e1[0],\n                bottom: e1[1],\n                left: e1[2],\n                right: e1[3],\n                front: e1[4],\n                back: e1[5]\n            };\n            let y = Gu([\n                t,\n                r,\n                n,\n                1\n            ], [\n                d,\n                l,\n                p\n            ], 1, [\n                o,\n                i,\n                a\n            ], e1[0]);\n            u = y[0], h = y[1], _ = y[2];\n        } else if (e1 === \"SAME_UPPER\") {\n            u = Math.ceil(t / o), h = Math.ceil(r / i), _ = Math.ceil(n / a);\n            let y = (u - 1) * o + d - t, g = (h - 1) * i + l - r, x = (_ - 1) * a + p - n, $ = Math.floor(y / 2), v = y - $, S = Math.floor(g / 2), T = g - S, A = Math.floor(x / 2), k = x - A;\n            m = {\n                top: S,\n                bottom: T,\n                left: A,\n                right: k,\n                front: $,\n                back: v\n            };\n        } else throw Error(\"Unknown padding parameter: \".concat(e1));\n        return {\n            padInfo: m,\n            outDepth: u,\n            outHeight: h,\n            outWidth: _\n        };\n    }, Hu = function(e1, t, r, n, o) {\n        let i = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : !1, a = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : \"channelsLast\";\n        let d, l, p, m, u;\n        if (a === \"channelsLast\") [d, l, p, m, u] = e1;\n        else if (a === \"channelsFirst\") [d, u, l, p, m] = e1;\n        else throw new Error(\"Unknown dataFormat \".concat(a));\n        let [h, , _, y, g] = t, [x, $, v] = Lu(r), [S, T, A] = Lu(n), k = Jr(_, S), P = Jr(y, T), D = Jr(g, A), { padInfo: R, outDepth: G, outHeight: K, outWidth: j } = pf(o, l, p, m, x, $, v, k, P, D), V = i ? h * u : h, Q = [\n            0,\n            0,\n            0,\n            0,\n            0\n        ];\n        return a === \"channelsFirst\" ? Q = [\n            d,\n            V,\n            G,\n            K,\n            j\n        ] : a === \"channelsLast\" && (Q = [\n            d,\n            G,\n            K,\n            j,\n            V\n        ]), {\n            batchSize: d,\n            dataFormat: a,\n            inDepth: l,\n            inHeight: p,\n            inWidth: m,\n            inChannels: u,\n            outDepth: G,\n            outHeight: K,\n            outWidth: j,\n            outChannels: V,\n            padInfo: R,\n            strideDepth: x,\n            strideHeight: $,\n            strideWidth: v,\n            filterDepth: _,\n            filterHeight: y,\n            filterWidth: g,\n            effectiveFilterDepth: k,\n            effectiveFilterHeight: P,\n            effectiveFilterWidth: D,\n            dilationDepth: S,\n            dilationHeight: T,\n            dilationWidth: A,\n            inShape: e1,\n            outShape: Q,\n            filterShape: t\n        };\n    }, Fu = (e1, t, r, n, o, i)=>{\n        let a = i === \"channelsLast\", d = a ? e1[0].dims[3] : e1[0].dims[1], l = !1, p = [\n            64,\n            1,\n            1\n        ], m = {\n            x: r.map((v, S)=>S)\n        }, u = [\n            Math.ceil(lf(m.x.map((v)=>r[v])) / p[0]),\n            1,\n            1\n        ];\n        ue(\"verbose\", ()=>\"[conv3d_naive_webgpu] dispatch = \".concat(u));\n        let h = l ? a && d % 4 !== 0 ? 3 : 4 : 1, _ = C.size(r), y = [\n            {\n                type: 12,\n                data: _\n            },\n            {\n                type: 12,\n                data: n\n            },\n            {\n                type: 12,\n                data: o\n            },\n            {\n                type: 12,\n                data: t.strides\n            },\n            {\n                type: 12,\n                data: t.dilations\n            }\n        ];\n        Ke(t, y), y.push(...N(e1[0].dims, e1[1].dims));\n        let g = [\n            \"rank\",\n            \"rank\"\n        ], x = e1.length === 3;\n        x && (y.push(...N(e1[2].dims)), g.push(\"rank\")), y.push(...N(r));\n        let $ = (v)=>{\n            let S = [\n                {\n                    name: \"output_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"filter_dims\",\n                    type: \"u32\",\n                    length: n.length\n                },\n                {\n                    name: \"pads\",\n                    type: \"u32\",\n                    length: o.length\n                },\n                {\n                    name: \"strides\",\n                    type: \"u32\",\n                    length: t.strides.length\n                },\n                {\n                    name: \"dilations\",\n                    type: \"u32\",\n                    length: t.dilations.length\n                }\n            ];\n            je(t, S);\n            let T = l ? 4 : 1, A = _e(e1[0].dataType), k = E(\"x\", e1[0].dataType, e1[0].dims.length, h === 3 ? 1 : h), P = E(\"W\", e1[1].dataType, e1[1].dims.length, T), D = [\n                k,\n                P\n            ], R = M(\"result\", e1[0].dataType, r.length, T), G = \"\";\n            if (x) {\n                let V = E(\"bias\", e1[2].dataType, e1[2].dims.length, T);\n                D.push(V), G += \"\\n        fn getBiasByOutputCoords(coords : array<u32, 5>) -> \".concat(l ? \"vec4<\".concat(A, \">\") : A, \" {\\n          return bias[\").concat(a ? F(\"coords\", 4, 5) : F(\"coords\", 1, 5)).concat(l ? \"/ 4\" : \"\", \"];\\n        }\");\n            }\n            let K = Ae(h, A), j = qe(t, K, A);\n            return \"\\n            \".concat(G, \"\\n            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {\\n              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);\\n              return \").concat(k.getByIndices(\"aIndices\"), \";\\n            }\\n            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {\\n              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);\\n              return \").concat(P.getByIndices(\"aIndices\"), \";\\n            }\\n          \").concat(v.registerUniforms(S).declareVariables(...D, R), \"\\n          \").concat(v.mainStart(), \"\\n          \").concat(v.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\"), \"\\n              let coords = \").concat(R.offsetToIndices(\"global_idx\"), \";\\n              let batch = \").concat(F(\"coords\", 0, k.rank), \";\\n              let d2 = \").concat(a ? F(\"coords\", k.rank - 1, k.rank) : F(\"coords\", 1, k.rank), \";\\n              let xFRCCorner = vec3<u32>(\").concat(a ? F(\"coords\", 1, k.rank) : F(\"coords\", 2, k.rank), \",\\n              \").concat(a ? F(\"coords\", 2, k.rank) : F(\"coords\", 3, k.rank), \",\\n              \").concat(a ? F(\"coords\", 3, k.rank) : F(\"coords\", 4, k.rank), \") * uniforms.strides - uniforms.pads;\\n              let xFCorner = xFRCCorner.x;\\n              let xRCorner = xFRCCorner.y;\\n              let xCCorner = xFRCCorner.z;\\n              let xShapeY = \").concat(a ? F(\"uniforms.x_shape\", 1, k.rank) : F(\"uniforms.x_shape\", 2, k.rank), \";\\n              let xShapeZ = \").concat(a ? F(\"uniforms.x_shape\", 2, k.rank) : F(\"uniforms.x_shape\", 3, k.rank), \";\\n              let xShapeW = \").concat(a ? F(\"uniforms.x_shape\", 3, k.rank) : F(\"uniforms.x_shape\", 4, k.rank), \";\\n              let xShapeU = \").concat(a ? F(\"uniforms.x_shape\", 4, k.rank) : F(\"uniforms.x_shape\", 1, k.rank), \";\\n              let inputDepthNearestVec4 = (xShapeU / 4) * 4;\\n              let inputDepthVec4Remainder = xShapeU % 4;\\n\\n              var value = 0.0;\\n              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {\\n                let xF = xFCorner + wF * uniforms.dilations[0];\\n                if (xF < 0 || xF >= xShapeY) {\\n                  continue;\\n                }\\n\\n                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {\\n                  let xR = xRCorner + wR * uniforms.dilations[1];\\n                  if (xR < 0 || xR >= xShapeZ) {\\n                    continue;\\n                  }\\n\\n                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {\\n                    let xC = xCCorner + wC * uniforms.dilations[2];\\n                    if (xC < 0 || xC >= xShapeW) {\\n                      continue;\\n                    }\\n\\n                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {\\n                      \").concat(a ? \"let xValues = vec4<f32>(\\n                               getX(batch, xF, xR, xC, d1),\\n                               getX(batch, xF, xR, xC, d1 + 1),\\n                               getX(batch, xF, xR, xC, d1 + 2),\\n                               getX(batch, xF, xR, xC, d1 + 3));\\n                            \" : \"let xValues = vec4<f32>(\\n                               getX(batch, d1, xF, xR, xC),\\n                               getX(batch, d1 + 1, xF, xR, xC),\\n                               getX(batch, d1 + 2, xF, xR, xC),\\n                               getX(batch, d1 + 3, xF, xR, xC));\\n                            \", \"\\n                            let wValues = vec4<f32>(\\n                              getW(d2, d1, wF, wR, wC),\\n                              getW(d2, d1 + 1, wF, wR, wC),\\n                              getW(d2, d1 + 2, wF, wR, wC),\\n                              getW(d2, d1 + 3, wF, wR, wC));\\n                      value += dot(xValues, wValues);\\n                    }\\n                    if (inputDepthVec4Remainder == 1) {\\n                        \").concat(a ? \"value += getX(batch, xF, xR, xC, inputDepthNearestVec4)\\n                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);\" : \"value += getX(batch, inputDepthNearestVec4, xF, xR, xC)\\n                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);\", \"\\n                    } else if (inputDepthVec4Remainder == 2) {\\n                      \").concat(a ? \"let xValues = vec2<f32>(\\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4),\\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));\\n                      \" : \"let xValues = vec2<f32>(\\n                        getX(batch, inputDepthNearestVec4, xF, xR, xC),\\n                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));\\n                    \", \"\\n                    let wValues = vec2<f32>(\\n                      getW(d2, inputDepthNearestVec4, wF, wR, wC),\\n                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));\\n                      value += dot(xValues, wValues);\\n                    } else if (inputDepthVec4Remainder == 3) {\\n                      \").concat(a ? \"let xValues = vec3<f32>(\\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4),\\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),\\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));\\n                      \" : \"let xValues = vec3<f32>(\\n                        getX(batch, inputDepthNearestVec4, xF, xR, xC),\\n                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),\\n                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));\\n                    \", \"\\n                    let wValues = vec3<f32>(\\n                      getW(d2, inputDepthNearestVec4, wF, wR, wC),\\n                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),\\n                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));\\n                      value += dot(xValues, wValues);\\n                    }\\n                  }\\n                }\\n              }\\n              \").concat(x ? \"value = value + getBiasByOutputCoords(coords)\" : \"\", \";\\n              \").concat(j, \"\\n              result[global_idx] = f32(value);\\n          }\");\n        };\n        return {\n            name: \"Conv3DNaive\",\n            shaderCache: {\n                hint: \"\".concat(t.cacheKey, \";\").concat(a, \";\").concat(h, \";\").concat(x),\n                inputDependencies: g\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: r,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: u[0],\n                        y: u[1],\n                        z: u[2]\n                    },\n                    programUniforms: y\n                }),\n            getShaderSource: $\n        };\n    };\n});\nvar Ku, ju, Yu = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    ae();\n    yt();\n    Ku = (e1, t, r, n)=>{\n        let o = e1.length > 2, i = o ? \"value += b[output_channel];\" : \"\", a = e1[0].dims, d = e1[1].dims, l = t.format === \"NHWC\", p = l ? r[3] : r[1], m = p / t.group, u = l && m >= 4 ? me(p) : 1, h = C.size(r) / u, _ = [\n            {\n                type: 12,\n                data: h\n            },\n            {\n                type: 12,\n                data: t.dilations\n            },\n            {\n                type: 12,\n                data: [\n                    t.strides[0],\n                    t.strides[1]\n                ]\n            },\n            {\n                type: 12,\n                data: [\n                    t.pads[0],\n                    t.pads[1]\n                ]\n            },\n            {\n                type: 12,\n                data: m\n            }\n        ];\n        Ke(t, _), _.push(...N(a, [\n            d[0],\n            d[1],\n            d[2],\n            d[3] / u\n        ]));\n        let y = o ? [\n            \"rank\",\n            \"rank\",\n            \"rank\"\n        ] : [\n            \"rank\",\n            \"rank\"\n        ];\n        _.push(...N([\n            r[0],\n            r[1],\n            r[2],\n            r[3] / u\n        ]));\n        let g = (x)=>{\n            let $ = M(\"output\", e1[0].dataType, r.length, u), v = _e($.type.tensor), S = qe(t, $.type.value, v), T = E(\"x\", e1[0].dataType, a.length), A = E(\"w\", e1[1].dataType, d.length, u), k = [\n                T,\n                A\n            ];\n            o && k.push(E(\"b\", e1[2].dataType, e1[2].dims, u));\n            let P = [\n                {\n                    name: \"output_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"dilations\",\n                    type: \"u32\",\n                    length: t.dilations.length\n                },\n                {\n                    name: \"strides\",\n                    type: \"u32\",\n                    length: 2\n                },\n                {\n                    name: \"pads\",\n                    type: \"u32\",\n                    length: 2\n                },\n                {\n                    name: \"output_channels_per_group\",\n                    type: \"u32\"\n                }\n            ];\n            je(t, P);\n            let D = l ? \"\\n      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[0]; wHeight++) {\\n        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];\\n\\n        if (xHeight < 0u || xHeight >= uniforms.x_shape[1]) {\\n          continue;\\n        }\\n\\n        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[1]; wWidth++) {\\n          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];\\n          if (xWidth < 0u || xWidth >= uniforms.x_shape[2]) {\\n            continue;\\n          }\\n\\n          for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[2]; wInChannel++) {\\n            let input_channel = in_channel_offset + wInChannel;\\n            let xVal = \".concat(T.get(\"batch\", \"xHeight\", \"xWidth\", \"input_channel\"), \";\\n            let wVal = \").concat(A.get(\"wHeight\", \"wWidth\", \"wInChannel\", \"output_channel\"), \";\\n            value += xVal * wVal;\\n          }\\n        }\\n      }\\n      \") : \"\\n      for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {\\n        let input_channel = in_channel_offset + wInChannel;\\n        for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {\\n          let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];\\n\\n          if (xHeight < 0u || xHeight >= uniforms.x_shape[2]) {\\n            continue;\\n          }\\n\\n          for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {\\n            let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];\\n            if (xWidth < 0u || xWidth >= uniforms.x_shape[3]) {\\n              continue;\\n            }\\n\\n            let xVal = \".concat(T.get(\"batch\", \"input_channel\", \"xHeight\", \"xWidth\"), \";\\n            let wVal = \").concat(A.get(\"output_channel\", \"wInChannel\", \"wHeight\", \"wWidth\"), \";\\n            value += xVal * wVal;\\n          }\\n        }\\n      }\\n      \");\n            return \"\\n  \".concat(x.registerUniforms(P).declareVariables(...k, $), \"\\n\\n  \").concat(x.mainStart(), \"\\n    \").concat(x.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\"), \"\\n\\n    let outputIndices = \").concat($.offsetToIndices(\"global_idx\"), \";\\n    let batch: u32 = outputIndices[0];\\n    let output_channel: u32 = outputIndices[\").concat(l ? 3 : 1, \"];\\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[\").concat(l ? 1 : 2, \"], outputIndices[\").concat(l ? 2 : 3, \"]) * uniforms.strides - uniforms.pads;\\n    let group_id: u32 = output_channel * \").concat(u, \" / uniforms.output_channels_per_group;\\n    var in_channel_offset = group_id * uniforms.w_shape[\").concat(l ? 2 : 1, \"];\\n\\n    var value: \").concat($.type.value, \" = \").concat($.type.value, \"(0);\\n    \").concat(D, \"\\n    \").concat(i, \"\\n    \").concat(S, \"\\n    \").concat($.setByOffset(\"global_idx\", \"value\"), \"\\n  }\");\n        };\n        return {\n            name: \"GroupedConv\",\n            shaderCache: {\n                hint: \"\".concat(t.cacheKey, \"_\").concat(u),\n                inputDependencies: y\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: n ? n(r) : r,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(h / 64)\n                    },\n                    programUniforms: _\n                }),\n            getShaderSource: g\n        };\n    }, ju = (e1, t, r, n)=>{\n        let o = e1.length > 2, i = me(r[3]), a = me(r[2]), d = C.size(r) / i / a, l = [\n            e1[0].dims[0],\n            e1[0].dims[1],\n            e1[0].dims[2],\n            e1[0].dims[3] / i\n        ], p = [\n            e1[1].dims[0],\n            e1[1].dims[1],\n            e1[1].dims[2],\n            e1[1].dims[3] / i\n        ], m = [\n            r[0],\n            r[1],\n            r[2],\n            r[3] / i\n        ], u = [\n            {\n                type: 12,\n                data: d\n            },\n            {\n                type: 6,\n                data: [\n                    t.strides[0],\n                    t.strides[1]\n                ]\n            },\n            {\n                type: 6,\n                data: [\n                    t.pads[0],\n                    t.pads[1]\n                ]\n            }\n        ];\n        Ke(t, u), u.push(...N(l, p, m));\n        let h = (a - 1) * t.strides[1] + p[1], _ = (y)=>{\n            let g = M(\"output\", e1[0].dataType, m.length, i), x = _e(g.type.tensor), $ = qe(t, g.type.value, x), v = E(\"x\", e1[0].dataType, l.length, i), S = E(\"w\", e1[1].dataType, p.length, i), T = [\n                v,\n                S\n            ];\n            o && T.push(E(\"b\", e1[2].dataType, e1[2].dims, i));\n            let A = o ? \"value += b[output_channel];\" : \"\", k = [\n                {\n                    name: \"output_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"strides\",\n                    type: \"i32\",\n                    length: 2\n                },\n                {\n                    name: \"pads\",\n                    type: \"i32\",\n                    length: 2\n                }\n            ];\n            return je(t, k), \"\\n  \".concat(y.registerUniforms(k).declareVariables(...T, g), \"\\n  \").concat(y.mainStart(), \"\\n    \").concat(y.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\"), \"\\n    let width0 = uniforms.output_shape[3];\\n    let output_channel = global_idx % width0;\\n    var index1 = global_idx / width0;\\n    let width1 = uniforms.output_shape[2] / \").concat(a, \"u;\\n    let col = (index1 % width1) * \").concat(a, \"u;\\n    index1 = index1 / width1;\\n    let row = index1 % uniforms.output_shape[1];\\n    let batch = index1 / uniforms.output_shape[1];\\n\\n    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;\\n\\n    var x_vals: array<\").concat(v.type.value, \", \").concat(h, \">;\\n    var values: array<\").concat(g.type.value, \", \").concat(a, \">;\\n    let input_channel = output_channel;\\n    // Use constant instead of uniform can give better performance for w's height/width.\\n    for (var w_height: u32 = 0u; w_height < \").concat(p[0], \"; w_height++) {\\n      let x_height = x_corner.x + i32(w_height);\\n      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {\\n        for (var i = 0; i < \").concat(h, \"; i++) {\\n          let x_width = x_corner.y + i;\\n          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {\\n            x_vals[i] = \").concat(v.get(\"batch\", \"u32(x_height)\", \"u32(x_width)\", \"input_channel\"), \";\\n          } else {\\n            x_vals[i] = \").concat(v.type.value, \"(0);\\n          }\\n        }\\n        for (var w_width: u32 = 0u; w_width < \").concat(p[1], \"; w_width++) {\\n          let w_val = \").concat(S.get(\"w_height\", \"w_width\", \"0\", \"output_channel\"), \";\\n          for (var i = 0u; i < \").concat(a, \"u; i++) {\\n            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);\\n          }\\n        }\\n      }\\n    }\\n\\n    for (var i = 0u; i < \").concat(a, \"u; i++) {\\n      var value = values[i];\\n      \").concat(A, \"\\n      \").concat($, \"\\n      \").concat(g.set(\"batch\", \"row\", \"col + i\", \"output_channel\", \"value\"), \";\\n    }\\n  }\");\n        };\n        return {\n            name: \"GroupedConv-Vectorize\",\n            shaderCache: {\n                hint: \"\".concat(t.cacheKey, \";\").concat(i, \";\").concat(a, \";\").concat(h, \";\").concat(p[0], \";\").concat(p[1]),\n                inputDependencies: o ? [\n                    \"rank\",\n                    \"rank\",\n                    \"type\"\n                ] : [\n                    \"rank\",\n                    \"rank\"\n                ]\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: n ? n(r) : r,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(d / 64)\n                    },\n                    programUniforms: u\n                }),\n            getShaderSource: _\n        };\n    };\n});\nvar mf, bo, ff, yo, _o, Zu, hf, gf, wo, Qu = U(()=>{\n    \"use strict\";\n    oe();\n    Wu();\n    qu();\n    Xr();\n    Yu();\n    yt();\n    Qr();\n    dt();\n    mf = (e1, t, r, n, o, i)=>{\n        let a = e1[0], d = e1.slice(i ? 1 : 2, i ? 3 : 4), l = d.length, p = t[0], u = t.slice(2).map((y, g)=>y + (y - 1) * (r[g] - 1)), _ = d.map((y, g)=>y + n[g] + n[g + l]).map((y, g)=>Math.floor((y - u[g] + o[g]) / o[g]));\n        return _.splice(0, 0, a), _.splice(i ? 3 : 1, 0, p), _;\n    }, bo = [\n        2,\n        3,\n        1,\n        0\n    ], ff = (e1, t)=>{\n        if (!e1 || e1.length !== 2 && e1.length !== 3) throw new Error(\"Conv requires 2 or 3 inputs\");\n        if (e1[0].dims.length > 5) throw new Error(\"greater than 5D is not supported\");\n        if (e1[0].dims.length !== e1[1].dims.length) throw new Error(\"filter does not have same dimension as input\");\n        let r = e1[0].dims[t.format === \"NHWC\" ? e1[0].dims.length - 1 : 1], n = e1[1].dims[1] * t.group;\n        if (r !== n) throw new Error(\"FILTER_IN_CHANNEL should be equal to DATA_CHANNEL\");\n        if (e1.length === 3 && (e1[2].dims.length !== 1 || e1[1].dims[0] !== e1[2].dims[0])) throw new Error(\"invalid bias\");\n        let o = e1[0].dims.length - 2;\n        if (t.dilations.length !== o) throw new Error(\"dilations should be \".concat(o, \"D\"));\n        if (t.strides.length !== o) throw new Error(\"strides should be \".concat(o, \"D\"));\n        if (t.pads.length !== o * 2) throw new Error(\"pads should be \".concat(o * 2, \"D\"));\n        if (t.kernelShape.length !== 0 && t.kernelShape.length !== e1[1].dims.length - 2) throw new Error(\"invalid kernel shape\");\n    }, yo = (e1, t)=>{\n        let r = e1.kernelShape.slice();\n        r.length < t[1].dims.length - 2 && r.push(...Array(t[1].dims.length - 2 - r.length).fill(0));\n        for(let i = 2; i < t[1].dims.length; ++i)r[i - 2] === 0 && (r[i - 2] = t[1].dims[i]);\n        let n = e1.pads.slice();\n        At.adjustPadsBasedOnAutoPad(t[0].dims, e1.strides, e1.dilations, r, n, e1.format === \"NHWC\", e1.autoPad);\n        let o = Object.assign({}, e1);\n        return Object.assign(o, {\n            kernelShape: r,\n            pads: n\n        }), o;\n    }, _o = (e1)=>{\n        let t = jr(e1), r = e1.format, n = [\n            \"NOTSET\",\n            \"VALID\",\n            \"SAME_UPPER\",\n            \"SAME_LOWER\"\n        ][e1.auto_pad], o = e1.dilations, i = e1.group, a = e1.kernel_shape, d = e1.pads, l = e1.strides, p = e1.w_is_const();\n        return {\n            autoPad: n,\n            format: r,\n            dilations: o,\n            group: i,\n            kernelShape: a,\n            pads: d,\n            strides: l,\n            wIsConst: p,\n            ...t,\n            cacheKey: \"\".concat(e1.format, \";\").concat(t.activation, \";\")\n        };\n    }, Zu = (e1, t, r, n)=>{\n        let o = r.format === \"NHWC\", i = mf(t[0].dims, t[1].dims, r.dilations, r.pads, r.strides, o);\n        if (r.group !== 1) {\n            let k = [\n                t[0]\n            ];\n            if (o) {\n                var _e_kernelCustomData_wT;\n                let D = (_e_kernelCustomData_wT = e1.kernelCustomData.wT) !== null && _e_kernelCustomData_wT !== void 0 ? _e_kernelCustomData_wT : e1.compute(Pe(t[1], bo), {\n                    inputs: [\n                        1\n                    ],\n                    outputs: [\n                        r.wIsConst ? -2 : -1\n                    ]\n                })[0];\n                r.wIsConst && !e1.kernelCustomData.wT && (e1.kernelCustomData.wT = D), k.push(D);\n            } else k.push(t[1]);\n            t.length === 3 && k.push(t[2]), !e1.adapterInfo.isArchitecture(\"ampere\") && o && t[1].dims[0] === r.group && t[1].dims[1] === 1 && r.dilations[0] === 1 && r.dilations[1] === 1 ? e1.compute(ju(k, r, i, n), {\n                inputs: k\n            }) : e1.compute(Ku(k, r, i, n), {\n                inputs: k\n            });\n            return;\n        }\n        let a = t.length === 3, d = t[0].dims[o ? 1 : 2], l = t[0].dims[o ? 2 : 3], p = t[0].dims[o ? 3 : 1], m = t[1].dims[2], u = t[1].dims[3], h = i[o ? 1 : 2], _ = i[o ? 2 : 3], y = i[o ? 3 : 1], g = o && m === d && u === l && r.pads[0] === 0 && r.pads[1] === 0;\n        if (g || m === 1 && u === 1 && r.dilations[0] === 1 && r.dilations[1] === 1 && r.strides[0] === 1 && r.strides[1] === 1 && r.pads[0] === 0 && r.pads[1] === 0) {\n            let k = i[0], P, D, R, G = [];\n            if (o) {\n                var _e_kernelCustomData_wT1;\n                let V = (_e_kernelCustomData_wT1 = e1.kernelCustomData.wT) !== null && _e_kernelCustomData_wT1 !== void 0 ? _e_kernelCustomData_wT1 : e1.compute(Pe(t[1], bo), {\n                    inputs: [\n                        1\n                    ],\n                    outputs: [\n                        r.wIsConst ? -2 : -1\n                    ]\n                })[0];\n                if (r.wIsConst && !e1.kernelCustomData.wT && (e1.kernelCustomData.wT = V), g) {\n                    let Q = d * l * p;\n                    P = t[0].reshape([\n                        1,\n                        k,\n                        Q\n                    ]), D = V.reshape([\n                        1,\n                        Q,\n                        y\n                    ]), R = [\n                        1,\n                        k,\n                        y\n                    ];\n                } else P = t[0].reshape([\n                    k,\n                    d * l,\n                    p\n                ]), D = V.reshape([\n                    1,\n                    p,\n                    y\n                ]), R = [\n                    k,\n                    h * _,\n                    y\n                ];\n                G.push(P), G.push(D);\n            } else P = t[0].reshape([\n                k,\n                p,\n                d * l\n            ]), D = t[1].reshape([\n                1,\n                y,\n                p\n            ]), R = [\n                k,\n                y,\n                h * _\n            ], G.push(D), G.push(P);\n            a && G.push(t[2]);\n            let K = R[2], j = G[0].dims[G[0].dims.length - 1];\n            K < 8 && j < 8 ? e1.compute(Zr(G, r, i, R, o, n), {\n                inputs: G\n            }) : e1.compute(er(G, r, i, R, o, n), {\n                inputs: G\n            });\n            return;\n        }\n        var _e_kernelCustomData_wT2;\n        let x = !0, $ = (_e_kernelCustomData_wT2 = e1.kernelCustomData.wT) !== null && _e_kernelCustomData_wT2 !== void 0 ? _e_kernelCustomData_wT2 : e1.compute(Pe(t[1], bo), {\n            inputs: [\n                1\n            ],\n            outputs: [\n                r.wIsConst ? -2 : -1\n            ]\n        })[0];\n        r.wIsConst && !e1.kernelCustomData.wT && (e1.kernelCustomData.wT = $);\n        let v = [\n            t[0],\n            $\n        ];\n        a && v.push(t[2]);\n        let S = o ? h * _ : y, T = o ? y : h * _, A = m * u * p;\n        e1.compute(Vu(v, r, i, S, T, A, a, x, n), {\n            inputs: v\n        });\n    }, hf = (e1, t)=>{\n        let r = t.format === \"NHWC\", n = [\n            e1.inputs[0].reshape(r ? [\n                e1.inputs[0].dims[0],\n                1,\n                e1.inputs[0].dims[1],\n                e1.inputs[0].dims[2]\n            ] : [\n                e1.inputs[0].dims[0],\n                e1.inputs[0].dims[1],\n                1,\n                e1.inputs[0].dims[2]\n            ]),\n            e1.inputs[1].reshape([\n                e1.inputs[1].dims[0],\n                e1.inputs[1].dims[1],\n                1,\n                e1.inputs[1].dims[2]\n            ])\n        ];\n        e1.inputs.length === 3 && n.push(e1.inputs[2]);\n        let o = [\n            0,\n            t.pads[0],\n            0,\n            t.pads[1]\n        ], i = [\n            1\n        ].concat(t.strides), a = [\n            1\n        ].concat(t.dilations), d = [\n            1\n        ].concat(t.kernelShape), l = yo({\n            ...t,\n            pads: o,\n            strides: i,\n            dilations: a,\n            kernelShape: d\n        }, n);\n        Zu(e1, n, l, (p)=>r ? [\n                p[0],\n                p[2],\n                p[3]\n            ] : [\n                p[0],\n                p[1],\n                p[3]\n            ]);\n    }, gf = (e1, t, r)=>{\n        let n = r.format === \"NHWC\" ? \"channelsLast\" : \"channelsFirst\", o = yo(r, t), i = r.autoPad === \"NOTSET\" ? r.pads : r.autoPad, a = Hu(t[0].dims, t[1].dims, r.strides, r.dilations, i, !1, n);\n        e1.compute(Fu(t, o, a.outShape, [\n            a.filterDepth,\n            a.filterHeight,\n            a.filterWidth\n        ], [\n            a.padInfo.front,\n            a.padInfo.top,\n            a.padInfo.left\n        ], n));\n    }, wo = (e1, t)=>{\n        if (ff(e1.inputs, t), e1.inputs[0].dims.length === 3) hf(e1, t);\n        else if (e1.inputs[0].dims.length === 5) gf(e1, e1.inputs, t);\n        else {\n            let r = yo(t, e1.inputs);\n            Zu(e1, e1.inputs, r);\n        }\n    };\n});\nvar Xu, Ju = U(()=>{\n    \"use strict\";\n    te();\n    et();\n    oe();\n    ae();\n    Xu = (e1, t, r)=>{\n        let n = e1.length > 2, o = t.outputShape, i = t.format === \"NHWC\", a = t.group, d = e1[1].dims, l = d[2] / a, p = d[3], m = i ? me(l) : 1, u = i ? me(p) : 1, h = i ? p === 1 ? m : u : 1, _ = C.size(o) / u, y = [\n            Math.ceil(_ / 64),\n            1,\n            1\n        ];\n        ue(\"verbose\", ()=>\"[conv2d_backprop_webgpu] dispatch = \".concat(y));\n        let g = [\n            \"rank\",\n            \"rank\"\n        ], x = [\n            t.strides[0],\n            t.strides[1]\n        ], $ = [\n            t.kernelShape[i ? 1 : 2],\n            t.kernelShape[i ? 2 : 3]\n        ], v = [\n            t.dilations[0],\n            t.dilations[1]\n        ], S = [\n            $[0] + (t.dilations[0] <= 1 ? 0 : (t.kernelShape[i ? 1 : 2] - 1) * (t.dilations[0] - 1)),\n            $[1] + (t.dilations[1] <= 1 ? 0 : (t.kernelShape[i ? 2 : 3] - 1) * (t.dilations[1] - 1))\n        ], T = [\n            S[0] - 1 - Math.floor((t.pads[0] + t.pads[2]) / 2),\n            S[1] - 1 - Math.floor((t.pads[1] + t.pads[3]) / 2)\n        ], A = [\n            {\n                type: 12,\n                data: _\n            },\n            {\n                type: 12,\n                data: x\n            },\n            {\n                type: 12,\n                data: $\n            },\n            {\n                type: 12,\n                data: v\n            },\n            {\n                type: 12,\n                data: S\n            },\n            {\n                type: 6,\n                data: T\n            },\n            {\n                type: 12,\n                data: l\n            },\n            {\n                type: 12,\n                data: p\n            },\n            ...N(e1[0].dims, e1[1].dims)\n        ];\n        n && (A.push(...N(e1[2].dims)), g.push(\"rank\")), A.push(...N(o));\n        let k = (P)=>{\n            let D = [\n                {\n                    name: \"output_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"strides\",\n                    type: \"u32\",\n                    length: x.length\n                },\n                {\n                    name: \"filter_dims\",\n                    type: \"u32\",\n                    length: $.length\n                },\n                {\n                    name: \"dilations\",\n                    type: \"u32\",\n                    length: $.length\n                },\n                {\n                    name: \"effective_filter_dims\",\n                    type: \"u32\",\n                    length: S.length\n                },\n                {\n                    name: \"pads\",\n                    type: \"i32\",\n                    length: T.length\n                },\n                {\n                    name: \"input_channels_per_group\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"output_channels_per_group\",\n                    type: \"u32\"\n                }\n            ], R = _e(e1[0].dataType), G = i ? 1 : 2, K = i ? 2 : 3, j = i ? 3 : 1, V = E(\"W\", e1[1].dataType, e1[1].dims.length, h), Q = E(\"Dy\", e1[0].dataType, e1[0].dims.length, m), se = [\n                Q,\n                V\n            ];\n            n && se.push(E(\"bias\", e1[2].dataType, [\n                o[j]\n            ].length, u));\n            let Y = M(\"result\", e1[0].dataType, o.length, u), ee = ()=>{\n                let ne = \"\";\n                if (m === 1) ne += \"\\n        let w_offset = \".concat(V.indicesToOffset(\"\".concat(V.type.indices, \"(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)\")), \";\\n        let wValue = \").concat(V.getByOffset(\"w_offset / \".concat(h)), \";\\n        dotProd = dotProd + xValue * wValue;\");\n                else if (p === 1) ne += \"\\n          let wValue = \".concat(V.getByOffset(\"\".concat(V.indicesToOffset(\"\".concat(V.type.indices, \"(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)\")), \" / \").concat(h)), \";\\n          dotProd = dotProd + dot(xValue, wValue);\");\n                else for(let be = 0; be < m; be++)ne += \"\\n            let wValue\".concat(be, \" = \").concat(V.getByOffset(\"\".concat(V.indicesToOffset(\"\".concat(V.type.indices, \"(u32(wRPerm), u32(wCPerm), inputChannel + \").concat(be, \", wOutChannel)\")), \" / \").concat(h)), \";\\n            dotProd = dotProd + xValue[\").concat(be, \"] * wValue\").concat(be, \";\");\n                return ne;\n            }, J = \"\\n            let outputIndices = \".concat(Y.offsetToIndices(\"global_idx * \".concat(u)), \";\\n            let batch = \").concat(Y.indicesGet(\"outputIndices\", 0), \";\\n            let d1 = \").concat(Y.indicesGet(\"outputIndices\", j), \";\\n            let r = \").concat(Y.indicesGet(\"outputIndices\", G), \";\\n            let c = \").concat(Y.indicesGet(\"outputIndices\", K), \";\\n            let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;\\n            let dyRCorner = dyCorner.x;\\n            let dyCCorner = dyCorner.y;\\n            let groupId = d1 / uniforms.output_channels_per_group;\\n            let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;\\n            // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\\n            // ? = to be determined. : = across all values in that axis.\\n            var dotProd = \").concat(Y.type.value, \"(0.0);\\n            for (var wR: u32 = 0; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {\\n              if (wR % uniforms.dilations.x != 0) {\\n                continue;\\n              }\\n              let dyR = (\").concat(R, \"(dyRCorner) + \").concat(R, \"(wR)) / \").concat(R, \"(uniforms.strides[0]);\\n              let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;\\n              if (dyR < 0.0 || dyR >= \").concat(R, \"(uniforms.Dy_shape[\").concat(G, \"]) || fract(dyR) > 0.0 ||\\n                  wRPerm < 0) {\\n                continue;\\n              }\\n              wR = wR + uniforms.strides[0] - 1;\\n              let idyR: u32 = u32(dyR);\\n\\n              for (var wC: u32 = 0; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {\\n                if (wC % uniforms.dilations.y != 0) {\\n                  continue;\\n                }\\n                let dyC = (\").concat(R, \"(dyCCorner) + \").concat(R, \"(wC)) / \").concat(R, \"(uniforms.strides.y);\\n                let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;\\n                if (dyC < 0.0 || dyC >= \").concat(R, \"(uniforms.Dy_shape[\").concat(K, \"]) ||\\n                    fract(dyC) > 0.0 || wCPerm < 0) {\\n                  continue;\\n                }\\n                wC = wC + uniforms.strides.y - 1;\\n                let idyC: u32 = u32(dyC);\\n                var inputChannel = groupId * uniforms.input_channels_per_group;\\n                for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group; d2 = d2 + \").concat(m, \") {\\n                  let xValue = \").concat(i ? Q.getByOffset(\"\".concat(Q.indicesToOffset(\"\".concat(Q.type.indices, \"(batch, idyR, idyC, inputChannel)\")), \" / \").concat(m)) : Q.get(\"batch\", \"inputChannel\", \"idyR\", \"idyC\"), \";\\n                  \").concat(ee(), \"\\n                  inputChannel = inputChannel + \").concat(m, \";\\n                }\\n              }\\n            }\\n            let value = dotProd\").concat(n ? \" + bias[d1 / \".concat(u, \"]\") : \"\", \";\\n            \").concat(Y.setByOffset(\"global_idx\", \"value\"), \";\\n          \");\n            return \"\\n    \".concat(P.registerUniforms(D).declareVariables(...se, Y), \"\\n      \").concat(P.mainStart(), \"\\n      \").concat(P.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\"), \";\\n    \").concat(J, \"}\");\n        };\n        return {\n            name: \"ConvTranspose2D\",\n            shaderCache: {\n                hint: \"\".concat(t.cacheKey, \";\").concat(m).concat(h).concat(u).concat(p === 1),\n                inputDependencies: g\n            },\n            getRunData: ()=>({\n                    dispatchGroup: {\n                        x: y[0],\n                        y: y[1],\n                        z: y[2]\n                    },\n                    outputs: [\n                        {\n                            dims: r ? r(o) : o,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    programUniforms: A\n                }),\n            getShaderSource: k\n        };\n    };\n});\nvar bf, yf, _f, ed, td, wf, rd, vf, nd, od = U(()=>{\n    \"use strict\";\n    Ju();\n    yt();\n    dt();\n    bf = (e1, t, r, n, o, i)=>(e1 - 1) * t + r + (n - 1) * o + 1 - i, yf = (e1, t, r, n, o)=>{\n        let i = Math.floor(e1 / 2);\n        t === \"SAME_UPPER\" ? (r[n] = i, r[o] = e1 - i) : t === \"SAME_LOWER\" && (r[n] = e1 - i, r[o] = i);\n    }, _f = (e1, t, r, n, o, i, a, d, l, p)=>{\n        let m = e1.length - 2, u = p.length === 0;\n        l.length < m && l.push(...Array(m - l.length).fill(0));\n        let h = e1[0], _ = t[d ? 3 : 1] * o;\n        for(let y = 0, g = e1.length - m - (d ? 1 : 0); y < m; ++y, ++g){\n            let x = e1[g], $ = u ? x * a[y] : p[y], v = bf(x, a[y], i[y], t[g], r[y], $);\n            yf(v, n, i, y, y + m), u && p.push(a[y] * (x - 1) + l[y] + (t[g] - 1) * r[y] + 1 - i[y] - i[y + m]);\n        }\n        p.splice(0, 0, h), p.splice(d ? 3 : 1, 0, _);\n    }, ed = (e1, t)=>{\n        let r = e1.kernelShape.slice();\n        if (e1.kernelShape.length === 0 || e1.kernelShape.reduce((u, h)=>u * h, 1) === 0) {\n            r.length = 0;\n            for(let u = 2; u < t[1].dims.length; ++u)r.push(t[1].dims[u]);\n        }\n        let n = e1.format === \"NHWC\";\n        r.splice(0, 0, t[1].dims[0]), r.splice(n ? 3 : 1, 0, t[1].dims[1]);\n        let o = e1.pads.slice(), i = e1.outputShape.slice(), a = e1.outputPadding.slice(), d = t[0].dims, l = e1.dilations.slice();\n        if (l.reduce((u, h)=>u + h, 0) === 0) {\n            let u = t[0].dims.length - 2;\n            l = new Array(u).fill(1);\n        }\n        let p = e1.strides.slice();\n        if (p.reduce((u, h)=>u + h, 0) === 0) {\n            let u = t[0].dims.length - 2;\n            p = new Array(u).fill(1);\n        }\n        _f(d, r, l, e1.autoPad, e1.group, o, p, n, a, i);\n        let m = Object.assign({}, e1);\n        return Object.assign(m, {\n            kernelShape: r,\n            pads: o,\n            outputPadding: a,\n            outputShape: i,\n            dilations: l,\n            strides: p\n        }), m;\n    }, td = (e1)=>{\n        let t = jr(e1), r = e1.format, n = [\n            \"NOTSET\",\n            \"VALID\",\n            \"SAME_UPPER\",\n            \"SAME_LOWER\"\n        ][typeof e1.autoPad > \"u\" ? 0 : e1.autoPad], o = e1.dilations, i = e1.group, a = e1.kernelShape, d = e1.pads, l = e1.strides, p = e1.wIsConst(), m = e1.outputPadding, u = e1.outputShape;\n        return {\n            autoPad: n,\n            format: r,\n            dilations: o,\n            group: i,\n            kernelShape: a,\n            outputPadding: m,\n            outputShape: u,\n            pads: d,\n            strides: l,\n            wIsConst: p,\n            ...t,\n            cacheKey: \"\".concat(e1.format, \";\").concat(t.activation, \";\")\n        };\n    }, wf = (e1, t)=>{\n        if (!e1 || e1.length !== 2 && e1.length !== 3) throw new Error(\"Conv requires 2 or 3 inputs\");\n        if (e1[0].dims.length !== 4 && e1[0].dims.length !== 3) throw new Error(\"currently only support 2-dimensional conv\");\n        if (e1[0].dims.length !== e1[1].dims.length) throw new Error(\"filter does not have same dimension as input\");\n        let r = e1[0].dims[t.format === \"NHWC\" ? e1[0].dims.length - 1 : 1], n = e1[1].dims[0];\n        if (r !== n) throw new Error(\"FILTER_IN_CHANNEL should be equal to DATA_CHANNEL\");\n        let o = e1[1].dims[1] * t.group;\n        if (e1.length === 3 && (e1[2].dims.length !== 1 || e1[2].dims[0] !== o)) throw new Error(\"invalid bias\");\n        let i = e1[0].dims.length - 2;\n        if (t.dilations.reduce((m, u)=>m + u, 0) > 0 && t.dilations.length !== i) throw new Error(\"dilations should be \".concat(i, \"D\"));\n        if (t.strides.reduce((m, u)=>m + u, 0) > 0 && t.strides.length !== i) throw new Error(\"strides should be \".concat(i, \"D\"));\n        if (t.pads.reduce((m, u)=>m + u, 0) > 0 && t.pads.length !== i * 2) throw new Error(\"pads should be \".concat(i * 2, \"D\"));\n        if (t.outputPadding.length !== i && t.outputPadding.length !== 0) throw new Error(\"output_padding should be \".concat(i, \"D\"));\n        if (t.kernelShape.reduce((m, u)=>m + u, 0) > 0 && t.kernelShape.length !== 0 && t.kernelShape.length !== e1[1].dims.length - 2) throw new Error(\"invalid kernel shape\");\n        if (t.outputShape.length !== 0 && t.outputShape.length !== e1[0].dims.length - 2) throw new Error(\"invalid output shape\");\n    }, rd = (e1, t, r, n)=>{\n        var _e_kernelCustomData_wT;\n        let o = (_e_kernelCustomData_wT = e1.kernelCustomData.wT) !== null && _e_kernelCustomData_wT !== void 0 ? _e_kernelCustomData_wT : e1.compute(Pe(t[1], [\n            2,\n            3,\n            0,\n            1\n        ]), {\n            inputs: [\n                1\n            ],\n            outputs: [\n                r.wIsConst ? -2 : -1\n            ]\n        })[0];\n        r.wIsConst && !e1.kernelCustomData.wT && (e1.kernelCustomData.wT = o);\n        let i = [\n            t[0],\n            o\n        ];\n        t.length === 3 && i.push(t[2]), e1.compute(Xu(i, r, n), {\n            inputs: i\n        });\n    }, vf = (e1, t)=>{\n        let r = t.format === \"NHWC\", n = [\n            e1.inputs[0].reshape(r ? [\n                e1.inputs[0].dims[0],\n                1,\n                e1.inputs[0].dims[1],\n                e1.inputs[0].dims[2]\n            ] : [\n                e1.inputs[0].dims[0],\n                e1.inputs[0].dims[1],\n                1,\n                e1.inputs[0].dims[2]\n            ]),\n            e1.inputs[1].reshape([\n                e1.inputs[1].dims[0],\n                e1.inputs[1].dims[1],\n                1,\n                e1.inputs[1].dims[2]\n            ])\n        ];\n        e1.inputs.length === 3 && n.push(e1.inputs[2]);\n        let o = t.kernelShape;\n        (o.length === 0 || o[0] === 0) && (o = [\n            e1.inputs[1].dims[2]\n        ]);\n        let i = t.dilations;\n        (i.length === 0 || i[0] === 0) && (i = [\n            1\n        ]);\n        let a = t.strides;\n        (a.length === 0 || a[0] === 0) && (a = [\n            1\n        ]);\n        let d = t.pads;\n        d.length === 0 && (d = [\n            0,\n            0\n        ]), d = [\n            0,\n            d[0],\n            0,\n            d[1]\n        ], a = [\n            1\n        ].concat(a), i = [\n            1\n        ].concat(i), o = [\n            1\n        ].concat(o);\n        let l = ed({\n            ...t,\n            pads: d,\n            strides: a,\n            dilations: i,\n            kernelShape: o\n        }, n);\n        rd(e1, n, l, (p)=>r ? [\n                p[0],\n                p[2],\n                p[3]\n            ] : [\n                p[0],\n                p[1],\n                p[3]\n            ]);\n    }, nd = (e1, t)=>{\n        if (wf(e1.inputs, t), e1.inputs[0].dims.length === 3) vf(e1, t);\n        else {\n            let r = ed(t, e1.inputs);\n            rd(e1, e1.inputs, r);\n        }\n    };\n});\nvar $f, id, ad, sd = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    $f = (e1, t, r, n)=>{\n        let o = C.size(t), i = t.length, a = E(\"input\", e1, i), d = M(\"output\", e1, i), l = r.dataType === 6 ? r.getInt32Array()[0] : Number(r.getBigInt64Array()[0]), p = C.normalizeAxis(l, i), m = (u)=>{\n            let h = \" i32(\".concat(a.indicesGet(\"inputIndices\", \"uniforms.axis\"), \") \"), _ = F(\"uniforms.input_shape\", \"uniforms.axis\", i), y = n.reverse ? h + (n.exclusive ? \" + 1\" : \"\") : \"0\", g = n.reverse ? _ : h + (n.exclusive ? \"\" : \" + 1\");\n            return \"\\n                \".concat(u.registerUniform(\"outputSize\", \"u32\").registerUniform(\"axis\", \"u32\").declareVariables(a, d), \"\\n                \").concat(u.mainStart(), \"\\n                  \").concat(u.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\"), \"\\n                  var inputIndices = \").concat(d.offsetToIndices(\"global_idx\"), \";\\n                  var sum = \").concat(d.type.value, \"(0);\\n                  let first : i32 = \").concat(y, \";\\n                  let last : i32 = \").concat(g, \";\\n                  for (var i : i32 = first; i < last; i++) {\\n                    \").concat(a.indicesSet(\"inputIndices\", \"uniforms.axis\", \"u32(i)\"), \";\\n                    sum = sum + \").concat(a.getByIndices(\"inputIndices\"), \";\\n                  }\\n                  \").concat(d.setByOffset(\"global_idx\", \"sum\"), \";\\n                }\");\n        };\n        return {\n            name: \"CumSum\",\n            shaderCache: {\n                hint: n.cacheKey,\n                inputDependencies: [\n                    \"rank\"\n                ]\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: t,\n                            dataType: e1\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(o / 64)\n                    },\n                    programUniforms: [\n                        {\n                            type: 12,\n                            data: o\n                        },\n                        {\n                            type: 12,\n                            data: p\n                        },\n                        ...N(t, t)\n                    ]\n                }),\n            getShaderSource: m\n        };\n    }, id = (e1, t)=>{\n        let r = e1.inputs[0].dims, n = e1.inputs[0].dataType, o = e1.inputs[1];\n        e1.compute($f(n, r, o, t), {\n            inputs: [\n                0\n            ]\n        });\n    }, ad = (e1)=>{\n        let t = e1.exclusive === 1, r = e1.reverse === 1;\n        return re({\n            exclusive: t,\n            reverse: r\n        });\n    };\n});\nvar xf, Sf, Tf, ud, dd, ld = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    xf = (e1)=>{\n        if (!e1 || e1.length !== 1) throw new Error(\"DepthToSpace requires 1 input.\");\n        if (e1[0].dims.length !== 4) throw new Error(\"DepthToSpace requires 4D input.\");\n    }, Sf = (e1, t, r, n)=>{\n        let o = [];\n        o.push(\"fn perm(i: \".concat(n.type.indices, \") -> \").concat(r.type.indices, \" {\\n    var a: \").concat(r.type.indices, \";\"));\n        for(let i = 0; i < t; ++i)o.push(r.indicesSet(\"a\", e1[i], \"i[\".concat(i, \"]\")));\n        return o.push(\"return a;}\"), o.join(\"\\n\");\n    }, Tf = (e1, t)=>{\n        let r, n, o, i, a, d, l = t.format === \"NHWC\", p = t.blocksize, m = t.mode === \"DCR\";\n        l ? ([r, n, o, i] = e1.dims, a = m ? [\n            r,\n            n,\n            o,\n            p,\n            p,\n            i / p ** 2\n        ] : [\n            r,\n            n,\n            o,\n            i / p ** 2,\n            p,\n            p\n        ], d = m ? [\n            0,\n            1,\n            3,\n            2,\n            4,\n            5\n        ] : [\n            0,\n            1,\n            4,\n            2,\n            5,\n            3\n        ]) : ([r, n, o, i] = [\n            e1.dims[0],\n            e1.dims[2],\n            e1.dims[3],\n            e1.dims[1]\n        ], a = m ? [\n            r,\n            p,\n            p,\n            i / p ** 2,\n            n,\n            o\n        ] : [\n            r,\n            i / p ** 2,\n            p,\n            p,\n            n,\n            o\n        ], d = m ? [\n            0,\n            3,\n            4,\n            1,\n            5,\n            2\n        ] : [\n            0,\n            1,\n            4,\n            2,\n            5,\n            3\n        ]);\n        let u = e1.reshape(a), h = u.dims.length, _ = e1.dataType, y = E(\"a\", _, h), g = M(\"output\", _, h), x = ($)=>\"\\n  \".concat($.registerUniform(\"output_size\", \"u32\").declareVariables(y, g), \"\\n\\n  \").concat(Sf(d, h, y, g), \"\\n\\n  \").concat($.mainStart(), \"\\n    \").concat($.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\"), \"\\n\\n    let indices = \").concat(g.offsetToIndices(\"global_idx\"), \";\\n    let aIndices = perm(indices);\\n\\n    \").concat(g.setByOffset(\"global_idx\", y.getByIndices(\"aIndices\")), \"\\n  }\");\n        return {\n            name: \"DepthToSpace\",\n            shaderCache: {\n                hint: \"\".concat(e1.dims, \";\").concat(t.blocksize, \";\").concat(t.mode),\n                inputDependencies: [\n                    \"rank\"\n                ]\n            },\n            getRunData: ($)=>{\n                let v = l ? [\n                    r,\n                    n * p,\n                    o * p,\n                    i / p ** 2\n                ] : [\n                    r,\n                    i / p ** 2,\n                    n * p,\n                    o * p\n                ], S = C.size(v), T = u.dims, A = C.sortBasedOnPerm(T, d);\n                return {\n                    outputs: [\n                        {\n                            dims: v,\n                            dataType: $[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(S / 64)\n                    },\n                    programUniforms: [\n                        {\n                            type: 12,\n                            data: S\n                        },\n                        ...N(T, A)\n                    ]\n                };\n            },\n            getShaderSource: x\n        };\n    }, ud = (e1, t)=>{\n        xf(e1.inputs), e1.compute(Tf(e1.inputs[0], t));\n    }, dd = (e1)=>re({\n            blocksize: e1.blocksize,\n            mode: e1.mode,\n            format: e1.format\n        });\n});\nvar vo, en, cd, If, Cf, $o, xo, pd, Af, md, fd, hd = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    vo = \"[a-zA-Z]|\\\\.\\\\.\\\\.\", en = \"(\" + vo + \")+\", cd = \"^\" + en + \"$\", If = \"(\" + en + \",)*\" + en, Cf = \"^\" + If + \"$\", $o = class {\n        addSymbol(t, r) {\n            let n = this.symbolToIndices.get(t);\n            n === void 0 ? n = [\n                r\n            ] : n.push(r), this.symbolToIndices.set(t, n);\n        }\n        constructor(t = -1){\n            this.symbolToIndices = new Map, this.inputIndex = t;\n        }\n    }, xo = class {\n        addSymbol(t, r, n) {\n            let o = this.symbolToInfo.get(t);\n            if (o !== void 0) {\n                if (o.dimValue !== r && o.count !== 1) throw new Error(\"Dimension mismatch\");\n                o.count++, o.inputIndices.push(n);\n            } else o = {\n                count: 1,\n                dimValue: r,\n                inputIndices: [\n                    n\n                ]\n            };\n            this.symbolToInfo.set(t, o);\n        }\n        processTerm(t, r, n) {\n            let o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : -1;\n            let i = n.length, a = !1, d = [], l = 0;\n            if (!t.match(RegExp(cd)) && !r && t !== \"\") throw new Error(\"Invalid LHS term\");\n            let p = t.match(RegExp(vo, \"g\")), m = new $o(o);\n            return p === null || p === void 0 ? void 0 : p.forEach((u, h)=>{\n                if (u === \"...\") {\n                    if (a) throw new Error(\"Only one ellipsis is allowed per input term\");\n                    a = !0;\n                    let _ = i - p.length + 1;\n                    if (_ < 0) throw new Error(\"Ellipsis out of bounds\");\n                    if (d = n.slice(l, l + _), this.hasEllipsis) {\n                        if (this.ellipsisDims.length !== d.length || this.ellipsisDims.toString() !== d.toString()) throw new Error(\"Ellipsis dimensions mismatch\");\n                    } else if (r) this.hasEllipsis = !0, this.ellipsisDims = d;\n                    else throw new Error(\"Ellipsis must be specified in the LHS\");\n                    for(let y = 0; y < d.length; y++){\n                        let g = String.fromCharCode(\"0\".charCodeAt(0) + y);\n                        m.addSymbol(g, h + y), this.addSymbol(g, n[l++], o);\n                    }\n                } else m.addSymbol(u, h + (this.hasEllipsis ? this.ellipsisDims.length - 1 : 0)), this.addSymbol(u, n[l++], o);\n            }), m;\n        }\n        constructor(t, r){\n            var _o_match;\n            this.equation = r;\n            this.hasEllipsis = !1, this.symbolToInfo = new Map, this.lhs = new Array, this.outputDims = [];\n            let [n, o] = r.includes(\"->\") ? r.split(\"->\", 2) : [\n                r,\n                \"\"\n            ];\n            if (!n.match(RegExp(Cf))) throw new Error(\"Invalid LHS term\");\n            if (n.split(\",\").forEach((d, l)=>{\n                let p = t[l].dims.slice();\n                if (!d.match(RegExp(cd))) throw new Error(\"Invalid LHS term\");\n                let m = this.processTerm(d, !0, p, l);\n                this.lhs.push(m);\n            }), o === \"\") o += [\n                ...this.symbolToInfo.entries()\n            ].filter((param)=>{\n                let [d, l] = param;\n                return l.count === 1 || d === \"...\";\n            }).map((param)=>{\n                let [d] = param;\n                return d;\n            }).join(\"\");\n            else if (!o.match(RegExp(en))) throw new Error(\"Invalid RHS\");\n            (_o_match = o.match(RegExp(vo, \"g\"))) === null || _o_match === void 0 ? void 0 : _o_match.forEach((d)=>{\n                if (d === \"...\") this.outputDims = this.outputDims.concat(this.ellipsisDims);\n                else {\n                    let l = this.symbolToInfo.get(d);\n                    if (l === void 0) throw new Error(\"Invalid RHS symbol\");\n                    this.outputDims.push(l.dimValue);\n                }\n            }), this.rhs = this.processTerm(o, !1, this.outputDims);\n        }\n    }, pd = (e1)=>e1 + \"_max\", Af = (e1, t, r, n)=>{\n        let i = e1.map((m)=>m.length).map((m, u)=>E(\"input\".concat(u), t, m)), a = C.size(n), d = M(\"output\", t, n.length), l = [\n            ...r.symbolToInfo.keys()\n        ].filter((m)=>!r.rhs.symbolToIndices.has(m)), p = (m)=>{\n            let u = [], h = \"var prod = 1.0;\", _ = \"var sum = 0.0;\", y = \"sum += prod;\", g = [], x = [], $ = [], v = [], S = r.symbolToInfo.size === r.rhs.symbolToIndices.size;\n            r.symbolToInfo.forEach((A, k)=>{\n                if (r.rhs.symbolToIndices.has(k)) {\n                    var _r_rhs_symbolToIndices_get;\n                    let P = (_r_rhs_symbolToIndices_get = r.rhs.symbolToIndices.get(k)) === null || _r_rhs_symbolToIndices_get === void 0 ? void 0 : _r_rhs_symbolToIndices_get[0];\n                    P !== void 0 && r.lhs.forEach((D, R)=>{\n                        if (A.inputIndices.includes(R)) {\n                            let G = D.symbolToIndices.get(k);\n                            if (G === void 0) throw new Error(\"Invalid symbol error\");\n                            G.forEach((K)=>{\n                                u.push(\"\".concat(i[R].indicesSet(\"input\".concat(R, \"Indices\"), K, d.indicesGet(\"outputIndices\", P))));\n                            });\n                        }\n                    });\n                } else r.lhs.forEach((P, D)=>{\n                    if (A.inputIndices.includes(D)) {\n                        let R = P.symbolToIndices.get(k);\n                        if (R === void 0) throw new Error(\"Invalid symbol error\");\n                        R.forEach((G)=>{\n                            g.push(\"\".concat(i[D].indicesSet(\"input\".concat(D, \"Indices\"), G, \"\".concat(k))));\n                        }), v.push(\"prod *= \".concat(i[D].getByIndices(\"input\".concat(D, \"Indices\")), \";\"));\n                    }\n                }), x.push(\"for(var \".concat(k, \": u32 = 0; \").concat(k, \" < uniforms.\").concat(pd(k), \"; \").concat(k, \"++) {\")), $.push(\"}\");\n            });\n            let T = S ? [\n                ...u,\n                \"let sum = \".concat(i.map((A, k)=>A.getByIndices(\"input\".concat(k, \"Indices\"))).join(\" * \"), \";\")\n            ] : [\n                ...u,\n                _,\n                ...x,\n                ...g,\n                h,\n                ...v,\n                y,\n                ...$\n            ];\n            return \"\\n            \".concat(m.registerUniforms(l.map((A)=>({\n                    name: \"\".concat(pd(A)),\n                    type: \"u32\"\n                }))).registerUniform(\"outputSize\", \"u32\").declareVariables(...i, d), \"\\n\\n            \").concat(m.mainStart(), \"\\n            \").concat(m.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\"), \"\\n            var outputIndices = \").concat(d.offsetToIndices(\"global_idx\"), \";\\n            \").concat(i.map((A, k)=>\"var input\".concat(k, \"Indices: \").concat(i[k].type.indices, \";\")).join(\"\\n\"), \"\\n            \").concat(T.join(\"\\n\"), \";\\n            \").concat(d.setByOffset(\"global_idx\", \"sum\"), \";\\n          }\");\n        };\n        return {\n            name: \"Einsum\",\n            shaderCache: {\n                hint: r.equation,\n                inputDependencies: e1.map(()=>\"rank\")\n            },\n            getRunData: ()=>{\n                let m = l.filter((h)=>r.symbolToInfo.has(h)).map((h)=>{\n                    var _r_symbolToInfo_get;\n                    return {\n                        type: 12,\n                        data: ((_r_symbolToInfo_get = r.symbolToInfo.get(h)) === null || _r_symbolToInfo_get === void 0 ? void 0 : _r_symbolToInfo_get.dimValue) || 0\n                    };\n                });\n                m.push({\n                    type: 12,\n                    data: a\n                });\n                let u = e1.map((h, _)=>[\n                        ...N(h)\n                    ]).reduce((h, _)=>h.concat(_), m);\n                return u.push(...N(n)), {\n                    outputs: [\n                        {\n                            dims: n,\n                            dataType: t\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(a / 64)\n                    },\n                    programUniforms: u\n                };\n            },\n            getShaderSource: p\n        };\n    }, md = (e1, t)=>{\n        let r = new xo(e1.inputs, t.equation), n = r.outputDims, o = e1.inputs.map((i, a)=>i.dims);\n        e1.compute(Af(o, e1.inputs[0].dataType, r, n));\n    }, fd = (e1)=>{\n        let t = e1.equation.replace(/\\s+/g, \"\");\n        return re({\n            equation: t\n        });\n    };\n});\nvar kf, gd, Ef, Pf, bd, yd = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    ae();\n    kf = (e1)=>{\n        if (!e1 || e1.length !== 2) throw new Error(\"Expand requires 2 input.\");\n        let t = e1[0].dims, r = Array.from(e1[1].getBigInt64Array(), Number), n = r.length < t.length ? 0 : r.length - t.length, o = t.length < r.length ? 0 : t.length - r.length;\n        for(; n < r.length && o < t.length; ++n, ++o)if (r[n] !== t[o] && r[n] !== 1 && t[o] !== 1) throw new Error(\"Expand requires shape to be broadcastable to input\");\n    }, gd = (e1, t)=>{\n        let r = e1.length - t.length, n = [];\n        for(let o = 0; o < r; ++o)n.push(e1[o]);\n        for(let o = 0; o < t.length; ++o)n.push(t[o] === 1 ? e1[o + r] : t[o]);\n        return n;\n    }, Ef = (e1, t)=>e1.length > t.length ? gd(e1, t) : gd(t, e1), Pf = (e1)=>{\n        let t = e1[0].dims, r = Array.from(e1[1].getBigInt64Array(), Number), n = Ef(t, r), o = e1[0].dataType, i = o === 9 || C.size(t) === 1, a = o === 9 || t.length > 0 && t[t.length - 1] % 4 === 0 ? 4 : 1, d = i || n.length > 0 && n[n.length - 1] % 4 === 0 ? 4 : 1, l = Math.ceil(C.size(n) / d), p = (u)=>{\n            let h = E(\"input\", o, t.length, a), _ = M(\"output\", o, n.length, d), y;\n            if (o === 9) {\n                let g = function(x, $) {\n                    let v = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"\";\n                    return \"\\n          let outputIndices\".concat($, \" = \").concat(_.offsetToIndices(\"outputOffset + \".concat($, \"u\")), \";\\n          let offset\").concat($, \" = \").concat(h.broadcastedIndicesToOffset(\"outputIndices\".concat($), _), \";\\n          let index\").concat($, \" = offset\").concat($, \" / 4u;\\n          let component\").concat($, \" = offset\").concat($, \" % 4u;\\n          \").concat(x, \"[\").concat($, \"] = \").concat(v, \"(\").concat(h.getByOffset(\"index\".concat($)), \"[component\").concat($, \"]);\\n        \");\n                };\n                y = \"\\n        let outputOffset = global_idx * \".concat(d, \";\\n        var data = vec4<u32>(0);\\n        \").concat(g(\"data\", 0, \"u32\"), \"\\n        \").concat(g(\"data\", 1, \"u32\"), \"\\n        \").concat(g(\"data\", 2, \"u32\"), \"\\n        \").concat(g(\"data\", 3, \"u32\"), \"\\n        \").concat(_.setByOffset(\"global_idx\", \"data\"), \"\\n      }\");\n            } else y = \"\\n        let outputIndices = \".concat(_.offsetToIndices(\"global_idx * \".concat(d)), \";\\n        let inputOffset = \").concat(h.broadcastedIndicesToOffset(\"outputIndices\", _), \";\\n        let data = \").concat(_.type.value, \"(\").concat(h.getByOffset(\"inputOffset / \".concat(a)), \");\\n        \").concat(_.setByOffset(\"global_idx\", \"data\"), \"\\n      }\");\n            return \"\\n    \".concat(u.registerUniform(\"vec_size\", \"u32\").declareVariables(h, _), \"\\n    \").concat(u.mainStart(), \"\\n    \").concat(u.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.vec_size\"), \"\\n    \").concat(y);\n        }, m = [\n            {\n                type: 12,\n                data: l\n            },\n            ...N(t, n)\n        ];\n        return {\n            name: \"Expand\",\n            shaderCache: {\n                hint: \"\".concat(n.length, \";\").concat(a).concat(d),\n                inputDependencies: [\n                    \"rank\"\n                ]\n            },\n            getShaderSource: p,\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: n,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(l / 64)\n                    },\n                    programUniforms: m\n                })\n        };\n    }, bd = (e1)=>{\n        kf(e1.inputs), e1.compute(Pf(e1.inputs), {\n            inputs: [\n                0\n            ]\n        });\n    };\n});\nvar zf, _d, wd = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    ae();\n    Kr();\n    zf = (e1)=>{\n        let t = e1[0].dataType, r = C.size(e1[0].dims), n = C.size(e1[1].dims), o = n % 4 === 0, i = (a)=>{\n            let d = E(\"x\", t, [\n                1\n            ], 4), l = E(\"bias\", t, [\n                1\n            ], 4), p = M(\"y\", t, [\n                1\n            ], 4), m = [\n                {\n                    name: \"output_vec_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"bias_size\",\n                    type: \"u32\"\n                }\n            ], u = (_)=>\"\\n      let bias\".concat(_, \"_offset: u32 = (global_idx * 4 + \").concat(_, \") % uniforms.bias_size;\\n      let bias\").concat(_, \" = \").concat(l.getByOffset(\"bias\".concat(_, \"_offset / 4\")), \"[bias\").concat(_, \"_offset % 4];\"), h = o ? \"\\n      let bias = \".concat(l.getByOffset(\"global_idx % (uniforms.bias_size / 4)\"), \";\") : \"\".concat(u(0)).concat(u(1)).concat(u(2)).concat(u(3), \"\\n      let bias = \").concat(d.type.value, \"(bias0, bias1, bias2, bias3);\");\n            return \"\".concat(a.registerUniforms(m).declareVariables(d, l, p), \"\\n\\n    \").concat(mo(Ee(t)), \"\\n\\n    \").concat(a.mainStart(kt), \"\\n      \").concat(a.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_vec_size\"), \"\\n\\n      let x = \").concat(d.getByOffset(\"global_idx\"), \";\\n      \").concat(h, \"\\n      let x_in = x + bias;\\n      \").concat(p.setByOffset(\"global_idx\", fo(\"x_in\")), \"\\n    }\");\n        };\n        return {\n            name: \"FastGeluWithBias\",\n            shaderCache: {\n                hint: \"\".concat(o),\n                inputDependencies: [\n                    \"type\",\n                    \"type\"\n                ]\n            },\n            getShaderSource: i,\n            getRunData: (a)=>({\n                    outputs: [\n                        {\n                            dims: a[0].dims,\n                            dataType: a[0].dataType\n                        }\n                    ],\n                    programUniforms: [\n                        {\n                            type: 12,\n                            data: Math.ceil(r / 4)\n                        },\n                        {\n                            type: 12,\n                            data: n\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(r / kt / 4)\n                    }\n                })\n        };\n    }, _d = (e1)=>{\n        e1.inputs.length < 2 || C.size(e1.inputs[1].dims) === 0 ? hu(e1) : e1.compute(zf(e1.inputs));\n    };\n});\nvar Of, Df, vd, $d, xd = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    Of = (e1)=>{\n        if (!e1 || e1.length !== 2) throw new Error(\"Gather requires 2 inputs.\");\n    }, Df = (e1, t)=>{\n        let r = e1[0].dims, n = e1[1].dims, o = r.length, i = C.normalizeAxis(t.axis, o), a = r.slice(0);\n        a.splice(i, 1, ...n);\n        let d = r[i], l = e1[0].dataType === 9 ? 4 : 1, p = Math.ceil(C.size(a) / l), m = [\n            {\n                type: 12,\n                data: p\n            },\n            {\n                type: 6,\n                data: d\n            },\n            {\n                type: 12,\n                data: i\n            },\n            ...N(e1[0].dims, e1[1].dims, a)\n        ], u = (h)=>{\n            let _ = E(\"data\", e1[0].dataType, e1[0].dims.length, l), y = E(\"inputIndices\", e1[1].dataType, e1[1].dims.length), g = M(\"output\", e1[0].dataType, a.length, l), x = (v)=>{\n                let S = n.length, T = \"var indicesIndices\".concat(v, \"  = \").concat(y.type.indices, \"(0);\");\n                for(let A = 0; A < S; A++)T += \"\".concat(S > 1 ? \"indicesIndices\".concat(v, \"[\").concat(A, \"]\") : \"indicesIndices\".concat(v), \" = \").concat(a.length > 1 ? \"outputIndices\".concat(v, \"[uniforms.axis + \").concat(A, \"]\") : \"outputIndices\".concat(v), \";\");\n                T += \"\\n          var idx\".concat(v, \" = \").concat(y.getByIndices(\"indicesIndices\".concat(v)), \";\\n          if (idx\").concat(v, \" < 0) {\\n            idx\").concat(v, \" = idx\").concat(v, \" + uniforms.axisDimLimit;\\n          }\\n          var dataIndices\").concat(v, \" : \").concat(_.type.indices, \";\\n        \");\n                for(let A = 0, k = 0; A < o; A++)A === i ? (T += \"\".concat(o > 1 ? \"dataIndices\".concat(v, \"[\").concat(A, \"]\") : \"dataIndices\".concat(v), \" = u32(idx\").concat(v, \");\"), k += S) : (T += \"\".concat(o > 1 ? \"dataIndices\".concat(v, \"[\").concat(A, \"]\") : \"dataIndices\".concat(v), \" = \").concat(a.length > 1 ? \"outputIndices\".concat(v, \"[\").concat(k, \"]\") : \"outputIndices\".concat(v), \";\"), k++);\n                return T;\n            }, $;\n            if (e1[0].dataType === 9) {\n                let v = function(S, T) {\n                    let A = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"\";\n                    return \"\\n          let outputIndices\".concat(T, \" = \").concat(g.offsetToIndices(\"outputOffset + \".concat(T, \"u\")), \";\\n          \").concat(x(T), \";\\n          let offset\").concat(T, \" = \").concat(_.indicesToOffset(\"dataIndices\".concat(T)), \";\\n          let index\").concat(T, \" = offset\").concat(T, \" / 4u;\\n          let component\").concat(T, \" = offset\").concat(T, \" % 4u;\\n          \").concat(S, \"[\").concat(T, \"] = \").concat(A, \"(\").concat(_.getByOffset(\"index\".concat(T)), \"[component\").concat(T, \"]);\\n        \");\n                };\n                $ = \"\\n        let outputOffset = global_idx * \".concat(l, \";\\n        var value = vec4<u32>(0);\\n        \").concat(v(\"value\", 0, \"u32\"), \"\\n        \").concat(v(\"value\", 1, \"u32\"), \"\\n        \").concat(v(\"value\", 2, \"u32\"), \"\\n        \").concat(v(\"value\", 3, \"u32\"), \"\\n        \").concat(g.setByOffset(\"global_idx\", \"value\"), \"\\n      \");\n            } else $ = \"\\n      let outputIndices = \".concat(g.offsetToIndices(\"global_idx\"), \";\\n      \").concat(x(\"\"), \";\\n      let value = \").concat(_.getByIndices(\"dataIndices\"), \";\\n      \").concat(g.setByOffset(\"global_idx\", \"value\"), \";\\n      \");\n            return \"\\n      \".concat(h.registerUniform(\"outputSize\", \"u32\").registerUniform(\"axisDimLimit\", \"i32\").registerUniform(\"axis\", \"u32\").declareVariables(_, y, g), \"\\n      \").concat(h.mainStart(), \"\\n        \").concat(h.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\"), \"\\n        \").concat($, \"\\n      }\");\n        };\n        return {\n            name: \"Gather\",\n            shaderCache: {\n                hint: t.cacheKey,\n                inputDependencies: [\n                    \"rank\",\n                    \"rank\"\n                ]\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: a,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(p / 64)\n                    },\n                    programUniforms: m\n                }),\n            getShaderSource: u\n        };\n    }, vd = (e1)=>re({\n            axis: e1.axis\n        }), $d = (e1, t)=>{\n        let r = e1.inputs;\n        Of(r), e1.compute(Df(e1.inputs, t));\n    };\n});\nvar Bf, Sd, Td, Id = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    ae();\n    Bf = (e1, t, r, n, o, i, a, d, l)=>{\n        let p = [\n            {\n                type: 12,\n                data: i\n            },\n            {\n                type: 12,\n                data: n\n            },\n            {\n                type: 12,\n                data: o\n            },\n            {\n                type: 12,\n                data: r\n            },\n            {\n                type: 12,\n                data: a\n            },\n            {\n                type: 12,\n                data: d\n            },\n            {\n                type: 12,\n                data: l\n            }\n        ], m = [\n            i\n        ];\n        p.push(...N(t.dims, m));\n        let u = (h)=>{\n            let _ = E(\"indices_data\", t.dataType, t.dims.length), y = M(\"input_slice_offsets_data\", 12, 1, 1), g = [\n                _,\n                y\n            ], x = [\n                {\n                    name: \"output_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"batch_dims\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"input_dims\",\n                    type: \"u32\",\n                    length: o.length\n                },\n                {\n                    name: \"sizes_from_slice_dims_data\",\n                    type: \"u32\",\n                    length: r.length\n                },\n                {\n                    name: \"num_slices_per_batch\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"input_batch_stride\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"num_slice_dims\",\n                    type: \"u32\"\n                }\n            ];\n            return \"\\n  \".concat(h.registerUniforms(x).declareVariables(...g), \"\\n  \").concat(h.mainStart(), \"\\n    \").concat(h.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\"), \"\\n    let batch_idx = global_idx / uniforms.num_slices_per_batch;\\n    let base_offset = batch_idx * uniforms.input_batch_stride;\\n\\n    let slice_indices_base_offset = global_idx * uniforms.num_slice_dims;\\n    var relative_slice_offset = 0;\\n    for (var dim_idx = 0u; dim_idx < uniforms.num_slice_dims; dim_idx ++) {\\n      var index = i32(indices_data[dim_idx + slice_indices_base_offset].x);\\n      let input_dim_idx = uniforms.batch_dims + dim_idx;\\n      if (index < 0) {\\n        \").concat(o.length === 1 ? \"index += i32(uniforms.input_dims);\" : \"index += i32(uniforms.input_dims[input_dim_idx]);\", \"\\n      }\\n      \").concat(r.length === 1 ? \"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data);\" : \"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data[dim_idx]);\", \"\\n    }\\n\\n    input_slice_offsets_data[global_idx] =  base_offset + u32(relative_slice_offset);\\n  }\");\n        };\n        return e1.compute({\n            name: \"computeSliceOffsets\",\n            shaderCache: {\n                hint: \"\".concat(o.length, \"_\").concat(r.length),\n                inputDependencies: [\n                    \"rank\"\n                ]\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: m,\n                            dataType: e1.inputs[1].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(i / 64)\n                    },\n                    programUniforms: p\n                }),\n            getShaderSource: u\n        }, {\n            inputs: [\n                t\n            ],\n            outputs: [\n                -1\n            ]\n        })[0];\n    }, Sd = (e1, t)=>{\n        let r = e1.inputs, n = r[0].dims, o = r[0].dataType, i = r[1].dims, a = i[i.length - 1], d = C.sizeToDimension(i, i.length - 1), l = C.sizeFromDimension(n, t.batchDims + a), p = C.sizeToDimension(n, t.batchDims), m = C.sizeFromDimension(n, t.batchDims), u = d / p, h = new Array(a), _ = l;\n        for(let T = 0; T < a; ++T)h[a - 1 - T] = _, _ *= n[t.batchDims + a - 1 - T];\n        let y = Bf(e1, r[1], h, t.batchDims, n, d, u, m, a), g = t.batchDims + a;\n        if (g > n.length) throw new Error(\"last dimension of indices must not be larger than rank of input tensor\");\n        let x = i.slice(0, -1).concat(n.slice(g)), $ = C.size(x), v = [\n            {\n                type: 12,\n                data: $\n            },\n            {\n                type: 12,\n                data: l\n            },\n            ...N(r[0].dims, y.dims, x)\n        ], S = (T)=>{\n            let A = E(\"data\", r[0].dataType, r[0].dims.length), k = E(\"slice_offsets\", 12, y.dims.length), P = M(\"output\", r[0].dataType, x.length);\n            return \"\\n          \".concat(T.registerUniform(\"output_size\", \"u32\").registerUniform(\"slice_size\", \"u32\").declareVariables(A, k, P), \"\\n            \").concat(T.mainStart(), \"\\n            \").concat(T.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\"), \"\\n          let slice_offset = slice_offsets[global_idx / uniforms.slice_size];\\n          output[global_idx] = data[u32(slice_offset) + global_idx % uniforms.slice_size];\\n        }\");\n        };\n        e1.compute({\n            name: \"GatherND\",\n            shaderCache: {\n                hint: t.cacheKey,\n                inputDependencies: [\n                    \"rank\",\n                    \"rank\"\n                ]\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: x,\n                            dataType: o\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil($ / 64)\n                    },\n                    programUniforms: v\n                }),\n            getShaderSource: S\n        }, {\n            inputs: [\n                r[0],\n                y\n            ]\n        });\n    }, Td = (e1)=>({\n            batchDims: e1.batch_dims,\n            cacheKey: \"\"\n        });\n});\nvar Mf, Rf, Cd, Ad, kd = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    Mf = (e1, t)=>{\n        if (e1.length < 3 || e1.length > 4) throw new Error(\"GatherBlockQuantized requires 3 or 4 inputs.\");\n        let r = C.normalizeAxis(t.quantizeAxis, e1[0].dims.length), n = t.blockSize, o = e1[0], i = e1[2], a = e1.length === 4 ? e1[3] : void 0;\n        if (i.dims.length !== o.dims.length || !o.dims.map((d, l)=>l === r ? Math.ceil(d / n) === i.dims[l] : d === i.dims[l]).reduce((d, l)=>d && l, !0)) throw new Error(\"Scales must have the same rank as the input tensor and the dims should match except on gatherAxis.\");\n        if (a) {\n            if (a.dataType !== o.dataType) throw new Error(\"Zero point must have the same data type as the input tensor.\");\n            if (a.dims.length !== i.dims.length || !a.dims.map((d, l)=>d === i.dims[l]).reduce((d, l)=>d && l, !0)) throw new Error(\"Zero point must have the same rank as the input tensor and the dims should match except on quantizeAxis.\");\n        }\n    }, Rf = (e1, t)=>{\n        let r = e1[0].dims, n = e1[1].dims, o = r.length, i = C.normalizeAxis(t.gatherAxis, o), a = C.normalizeAxis(t.quantizeAxis, o), d = r.slice(0);\n        d.splice(i, 1, ...n);\n        let l = C.size(d), p = e1[2].dataType, u = e1[0].dataType === 22, h = [\n            {\n                type: 12,\n                data: l\n            },\n            {\n                type: 12,\n                data: a\n            },\n            {\n                type: 12,\n                data: i\n            },\n            {\n                type: 12,\n                data: t.blockSize\n            },\n            ...N(...e1.map((y, g)=>y.dims), d)\n        ], _ = (y)=>{\n            let g = E(\"data\", e1[0].dataType, e1[0].dims.length), x = E(\"inputIndices\", e1[1].dataType, e1[1].dims.length), $ = E(\"scales\", e1[2].dataType, e1[2].dims.length), v = e1.length > 3 ? E(\"zeroPoint\", e1[3].dataType, e1[3].dims.length) : void 0, S = M(\"output\", p, d.length), T = [\n                g,\n                x,\n                $\n            ];\n            v && T.push(v);\n            let A = [\n                {\n                    name: \"output_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"quantize_axis\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"gather_axis\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"block_size\",\n                    type: \"u32\"\n                }\n            ];\n            return \"\\n        \".concat(y.registerUniforms(A).declareVariables(...T, S), \"\\n        \").concat(y.mainStart(), \"\\n        let output_indices = \").concat(S.offsetToIndices(\"global_idx\"), \";\\n        var indices_indices = \").concat(x.type.indices, \"(0);\\n        \").concat((()=>n.length > 1 ? \"\\n          for (var i: u32 = 0; i < \".concat(n.length, \"; i++) {\\n            let index = \").concat(S.indicesGet(\"output_indices\", \"uniforms.gather_axis + i\"), \";\\n            \").concat(x.indicesSet(\"indices_indices\", \"i\", \"index\"), \";\\n          }\") : \"indices_indices = \".concat(S.indicesGet(\"output_indices\", \"uniforms.gather_axis\"), \";\"))(), \";\\n        var data_indices = \").concat(g.type.indices, \"(0);\\n        for (var i: u32 = 0; i < uniforms.gather_axis; i++) {\\n          let index = \").concat(S.indicesGet(\"output_indices\", \"i\"), \";\\n          \").concat(g.indicesSet(\"data_indices\", \"i\", \"index\"), \";\\n        }\\n        var index_from_indices = \").concat(x.getByIndices(\"indices_indices\"), \";\\n        if (index_from_indices < 0) {\\n          index_from_indices += \").concat(r[i], \";\\n        }\\n        \").concat(g.indicesSet(\"data_indices\", \"uniforms.gather_axis\", \"u32(index_from_indices)\"), \";\\n        for (var i = uniforms.gather_axis + 1; i < \").concat(d.length, \"; i++) {\\n          let index = \").concat(S.indicesGet(\"output_indices\", \"i + \".concat(n.length, \" - 1\")), \";\\n          \").concat(g.indicesSet(\"data_indices\", \"i\", \"index\"), \";\\n        }\\n        let data_offset = \").concat(g.indicesToOffset(\"data_indices\"), \";\\n        let data_index = data_offset % 8;\\n        // Convert 4-bit packed data to 8-bit packed data.\\n        let packed_4bit_quantized_data = \").concat(g.getByOffset(\"data_offset / 8\"), \";\\n        let packed_8bit_quantized_data = (packed_4bit_quantized_data >> (4 * (data_index % 2))) & 0x0f0f0f0f;\\n        let quantized_data_vec = \").concat(u ? \"unpack4xI8\" : \"unpack4xU8\", \"(u32(packed_8bit_quantized_data));\\n        let quantized_data = quantized_data_vec[data_index / 2];\\n        var scale_indices = data_indices;\\n        let quantize_axis_index = \").concat($.indicesGet(\"data_indices\", \"uniforms.quantize_axis\"), \" / uniforms.block_size;\\n        \").concat($.indicesSet(\"scale_indices\", \"uniforms.quantize_axis\", \"quantize_axis_index\"), \";\\n        var scale = \").concat($.getByIndices(\"scale_indices\"), \";\\n        \").concat((()=>v ? \"\\n              let zero_point_indices = scale_indices;\\n              let zero_point_offset = \".concat(v.indicesToOffset(\"zero_point_indices\"), \";\\n              let zero_point_index = zero_point_offset % 8;\\n              let packed_4bit_zero_points = \").concat(v.getByOffset(\"zero_point_offset / 8\"), \";\\n              let packed_8bit_zero_points = (packed_4bit_zero_points >> (4 * (zero_point_index % 2))) & 0x0f0f0f0f;\\n              let zero_point_vec = \").concat(u ? \"unpack4xI8\" : \"unpack4xU8\", \"(u32(packed_8bit_zero_points));\\n              let zero_point = zero_point_vec[zero_point_index / 2];\") : \"var zero_point = 0\")(), \";\\n        let dequantized_data = \").concat(Ee(p), \"(quantized_data - zero_point) * scale;\\n        \").concat(S.setByOffset(\"global_idx\", \"dequantized_data\"), \";\\n    }\");\n        };\n        return {\n            name: \"GatherBlockQuantized\",\n            shaderCache: {\n                hint: \"\".concat(t.cacheKey, \";\").concat(e1.filter((y, g)=>g !== 1).map((y)=>y.dims.join(\"_\")).join(\";\")),\n                inputDependencies: Array.from({\n                    length: e1.length\n                }, (y, g)=>\"rank\")\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: d,\n                            dataType: p\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(l / 64)\n                    },\n                    programUniforms: h\n                }),\n            getShaderSource: _\n        };\n    }, Cd = (e1, t)=>{\n        let r = e1.inputs;\n        Mf(r, t), e1.compute(Rf(e1.inputs, t));\n    }, Ad = (e1)=>re({\n            blockSize: e1.blockSize,\n            gatherAxis: e1.gatherAxis,\n            quantizeAxis: e1.quantizeAxis\n        });\n});\nvar Uf, Nf, Ed, Pd, zd = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    Uf = (e1)=>{\n        if (!e1 || e1.length !== 2) throw new Error(\"GatherElements requires 2 inputs.\");\n        if (e1[0].dims.length < 1) throw new Error(\"GatherElements requires that the data input be rank >= 1.\");\n        if (e1[0].dims.length !== e1[1].dims.length) throw new Error(\"GatherElements requires that the data input and\\n                     indices input tensors be of same rank.\");\n    }, Nf = (e1, t)=>{\n        let r = e1[0].dims, n = e1[0].dataType, o = r.length, i = e1[1].dims, a = e1[1].dataType, d = C.normalizeAxis(t.axis, o), l = r[d], p = i.slice(0), m = C.size(p), u = E(\"input\", n, o), h = E(\"indicesInput\", a, i.length), _ = M(\"output\", n, p.length), y = [\n            {\n                type: 12,\n                data: m\n            },\n            {\n                type: 6,\n                data: l\n            },\n            {\n                type: 12,\n                data: d\n            }\n        ];\n        return y.push(...N(r, i, p)), {\n            name: \"GatherElements\",\n            shaderCache: {\n                inputDependencies: [\n                    \"rank\",\n                    \"rank\"\n                ]\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: p,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(m / 64)\n                    },\n                    programUniforms: y\n                }),\n            getShaderSource: ($)=>\"\\n      \".concat($.registerUniform(\"outputSize\", \"u32\").registerUniform(\"axisDimLimit\", \"i32\").registerUniform(\"axis\", \"u32\").declareVariables(u, h, _), \"\\n      \").concat($.mainStart(), \"\\n      \").concat($.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\"), \"\\n\\n      let outputIndices = \").concat(_.offsetToIndices(\"global_idx\"), \";\\n\\n      var idx = \").concat(h.getByOffset(\"global_idx\"), \";\\n      if (idx < 0) {\\n        idx = idx + uniforms.axisDimLimit;\\n      }\\n      var inputIndices = \").concat(u.type.indices, \"(outputIndices);\\n      \").concat(u.indicesSet(\"inputIndices\", \"uniforms.axis\", \"u32(idx)\"), \";\\n      let value = \").concat(u.getByIndices(\"inputIndices\"), \";\\n\\n      \").concat(_.setByOffset(\"global_idx\", \"value\"), \";\\n  }\")\n        };\n    }, Ed = (e1)=>re({\n            axis: e1.axis\n        }), Pd = (e1, t)=>{\n        let r = e1.inputs;\n        Uf(r), e1.compute(Nf(e1.inputs, t));\n    };\n});\nvar Vf, Wf, Od, Dd, Bd = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    ae();\n    Vf = (e1)=>{\n        if (!e1) throw new Error(\"Input is missing\");\n        if (e1.length < 2 || e1.length > 3) throw new Error(\"Invaid input number.\");\n        if (e1.length === 3 && e1[2].dims.length > 2) throw new Error(\"Invalid input shape of C\");\n        if (e1[0].dataType !== e1[1].dataType || e1.length === 3 && e1[0].dataType !== e1[2].dataType) throw new Error(\"Input types are mismatched\");\n    }, Wf = (e1, t)=>{\n        let r = e1[0].dims.slice(), n = e1[1].dims.slice(), [o, i, a] = Vr.getShapeOfGemmResult(r, t.transA, n, t.transB, e1.length === 3 ? e1[2].dims : void 0), d = [\n            o,\n            i\n        ];\n        if (!d) throw new Error(\"Can't use gemm on the given tensors\");\n        let l = 16, p = Math.ceil(i / l), m = Math.ceil(o / l), u = !0, h = C.size(d), _ = [\n            {\n                type: 12,\n                data: u ? p : h\n            },\n            {\n                type: 12,\n                data: o\n            },\n            {\n                type: 12,\n                data: i\n            },\n            {\n                type: 12,\n                data: a\n            },\n            {\n                type: 1,\n                data: t.alpha\n            },\n            {\n                type: 1,\n                data: t.beta\n            }\n        ], y = [\n            \"type\",\n            \"type\"\n        ];\n        e1.length === 3 && (_.push(...N(e1[2].dims)), y.push(\"rank\")), _.push(...N(d));\n        let g = ($)=>{\n            let v = \"\";\n            t.transA && t.transB ? v = \"value += a[k * uniforms.M + m] * b[n * uniforms.K + k];\" : t.transA && !t.transB ? v = \"value += a[k * uniforms.M + m] * b[k * uniforms.N + n];\" : !t.transA && t.transB ? v = \"value += a[m * uniforms.K + k] * b[n * uniforms.K + k];\" : !t.transA && !t.transB && (v = \"value += a[m * uniforms.K + k] * b[k * uniforms.N + n];\");\n            let S = t.alpha === 1 ? \"\" : \"value *= uniforms.alpha;\", T = E(\"a\", e1[0].dataType, e1[0].dims), A = E(\"b\", e1[1].dataType, e1[1].dims), k = T.type.value, P = null, D = [\n                T,\n                A\n            ];\n            e1.length === 3 && (P = E(\"c\", e1[2].dataType, e1[2].dims.length), D.push(P));\n            let R = M(\"output\", e1[0].dataType, d.length);\n            D.push(R);\n            let G = [\n                {\n                    name: \"output_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"M\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"N\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"K\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"alpha\",\n                    type: \"f32\"\n                },\n                {\n                    name: \"beta\",\n                    type: \"f32\"\n                }\n            ];\n            return \"\\n  \".concat($.registerUniforms(G).declareVariables(...D), \"\\n\\n  \").concat($.mainStart(), \"\\n    \").concat($.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\"), \"\\n\\n    let m = global_idx / uniforms.N;\\n    let n = global_idx % uniforms.N;\\n\\n    var value = \").concat(k, \"(0);\\n    for (var k: u32 = 0u; k < uniforms.K; k++) {\\n      \").concat(v, \"\\n    }\\n\\n    \").concat(S, \"\\n    \").concat((()=>P != null ? \"let cOffset = \".concat(P.broadcastedIndicesToOffset(\"vec2(m, n)\", R), \"; value += \").concat(k, \"(uniforms.beta) * \").concat(P.getByOffset(\"cOffset\"), \";\") : \"\")(), \"\\n    output[global_idx] = value;\\n  }\");\n        }, x = ($)=>{\n            let v = E(\"a\", e1[0].dataType, e1[0].dims), S = E(\"b\", e1[1].dataType, e1[1].dims), T = null, A = [\n                v,\n                S\n            ];\n            e1.length === 3 && (T = E(\"c\", e1[2].dataType, e1[2].dims.length), A.push(T));\n            let k = M(\"output\", e1[0].dataType, d.length);\n            A.push(k);\n            let P = [\n                {\n                    name: \"num_tile_n\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"M\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"N\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"K\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"alpha\",\n                    type: \"f32\"\n                },\n                {\n                    name: \"beta\",\n                    type: \"f32\"\n                }\n            ], D = \"\", R = \"\";\n            t.transA && t.transB ? (R = \"\\n      var col = tile_row_start + local_id.x;\\n      var row = k_start + local_id.y;\\n      if (col < uniforms.M && row < uniforms.K) {\\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];\\n      } else {\\n        tile_a[local_id.y][local_id.x] = \".concat(v.type.value, \"(0);\\n      }\\n\\n      col = k_start + local_id.x;\\n      row = tile_col_start + local_id.y;\\n      if (col < uniforms.K && row < uniforms.N) {\\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];\\n      } else {\\n        tile_b[local_id.y][local_id.x] = \").concat(S.type.value, \"(0);\\n      }\\n      \"), D = \"value += tile_a[k][local_id.y] * tile_b[local_id.x][k];\") : t.transA && !t.transB ? (R = \"\\n      var col = tile_row_start + local_id.x;\\n      var row = k_start + local_id.y;\\n      if (col < uniforms.M && row < uniforms.K) {\\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];\\n      } else {\\n        tile_a[local_id.y][local_id.x] = \".concat(v.type.value, \"(0);\\n      }\\n\\n      col = tile_col_start + local_id.x;\\n      row = k_start + local_id.y;\\n      if (col < uniforms.N && row < uniforms.K) {\\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];\\n      } else {\\n        tile_b[local_id.y][local_id.x] = \").concat(S.type.value, \"(0);\\n      }\\n      \"), D = \"value += tile_a[k][local_id.y] * tile_b[k][local_id.x];\") : !t.transA && t.transB ? (R = \"\\n      var col = k_start + local_id.x;\\n      var row = tile_row_start + local_id.y;\\n      if (col < uniforms.K && row < uniforms.M) {\\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];\\n      } else {\\n        tile_a[local_id.y][local_id.x] = \".concat(v.type.value, \"(0);\\n      }\\n\\n      col = k_start + local_id.x;\\n      row = tile_col_start + local_id.y;\\n      if (col < uniforms.K && row < uniforms.N) {\\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];\\n      } else {\\n        tile_b[local_id.y][local_id.x] = \").concat(S.type.value, \"(0);\\n      }\\n      \"), D = \"value += tile_a[local_id.y][k] * tile_b[local_id.x][k];\") : !t.transA && !t.transB && (R = \"\\n      var col = k_start + local_id.x;\\n      var row = tile_row_start + local_id.y;\\n      if (col < uniforms.K && row < uniforms.M) {\\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];\\n      } else {\\n        tile_a[local_id.y][local_id.x] = \".concat(v.type.value, \"(0);\\n      }\\n\\n      col = tile_col_start + local_id.x;\\n      row = k_start + local_id.y;\\n      if (col < uniforms.N && row < uniforms.K) {\\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];\\n      } else {\\n        tile_b[local_id.y][local_id.x] = \").concat(S.type.value, \"(0);\\n      }\\n      \"), D = \"value += tile_a[local_id.y][k] * tile_b[k][local_id.x];\");\n            let G = t.alpha === 1 ? \"\" : \"value *= uniforms.alpha;\";\n            return \"\\n  \".concat($.registerUniforms(P).declareVariables(...A), \"\\n  var<workgroup> tile_a: array<array<\").concat(v.type.storage, \", \").concat(l, \">, \").concat(l, \">;\\n  var<workgroup> tile_b: array<array<\").concat(S.type.storage, \", \").concat(l, \">, \").concat(l, \">;\\n  \").concat($.mainStart([\n                l,\n                l,\n                1\n            ]), \"\\n    let tile_col_start = (workgroup_index % uniforms.num_tile_n) * \").concat(l, \";\\n    let tile_row_start = (workgroup_index / uniforms.num_tile_n) * \").concat(l, \";\\n    let num_tiles = (uniforms.K - 1) / \").concat(l, \" + 1;\\n    var k_start = 0u;\\n    var value = \").concat(k.type.value, \"(0);\\n    for (var t: u32 = 0u; t < num_tiles; t++) {\\n      \").concat(R, \"\\n      k_start = k_start + \").concat(l, \";\\n      workgroupBarrier();\\n\\n      for (var k: u32 = 0u; k < \").concat(l, \"; k++) {\\n        \").concat(D, \"\\n      }\\n      workgroupBarrier();\\n    }\\n\\n    \").concat(G, \"\\n    let m = tile_row_start + local_id.y;\\n    let n = tile_col_start + local_id.x;\\n    \").concat((()=>T != null ? \"let cOffset = \".concat(T.broadcastedIndicesToOffset(\"vec2(m, n)\", k), \"; value += \").concat(k.type.value, \"(uniforms.beta) * \").concat(T.getByOffset(\"cOffset\"), \";\") : \"\")(), \"\\n    if (m < uniforms.M && n < uniforms.N) {\\n      output[m * uniforms.N + n] = value;\\n    }\\n  }\");\n        };\n        return u ? {\n            name: \"GemmShared\",\n            shaderCache: {\n                hint: \"\".concat(t.cacheKey),\n                inputDependencies: y\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: d,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: p * m\n                    },\n                    programUniforms: _\n                }),\n            getShaderSource: x\n        } : {\n            name: \"Gemm\",\n            shaderCache: {\n                hint: \"\".concat(t.cacheKey),\n                inputDependencies: y\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: d,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(h / 64)\n                    },\n                    programUniforms: _\n                }),\n            getShaderSource: g\n        };\n    }, Od = (e1)=>{\n        let t = e1.transA, r = e1.transB, n = e1.alpha, o = e1.beta;\n        return {\n            transA: t,\n            transB: r,\n            alpha: n,\n            beta: o,\n            cacheKey: \"\".concat(e1.transA, \";\").concat(e1.transB, \";\").concat(e1.alpha === 1)\n        };\n    }, Dd = (e1, t)=>{\n        Vf(e1.inputs), e1.compute(Wf(e1.inputs, t));\n    };\n});\nvar lt, _t, Ut, Nt, Lf, Gf, Hf, Ff, qf, Kf, jf, Yf, Md, Rd, Ud = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    [lt, _t, Ut, Nt] = [\n        0,\n        1,\n        2,\n        3\n    ], Lf = (e1)=>{\n        if (e1[0].dims.length !== 4) throw new Error(\"only 4-D tensor is supported.\");\n        if (e1[0].dims.length !== e1[1].dims.length) throw new Error(\"input dimensions must be equal to grid dimensions\");\n        if (e1[0].dims.length - 2 !== e1[1].dims[e1[1].dims.length - 1]) throw new Error(\"last dimension of grid must be equal to \".concat(e1[0].dims.length - 2));\n        if (e1[0].dims[0] !== e1[1].dims[0]) throw new Error(\"grid batch size must match input batch size\");\n    }, Gf = \"\\n  fn gs_get_cubic_coeffs(x: f32) -> vec4<f32> {\\n    let cubic_alpha = -0.75f;\\n    let x_abs = abs(x);\\n    var coeffs: vec4<f32>;\\n    coeffs[0] = (((cubic_alpha * (x_abs + 1) - 5 * cubic_alpha) * (x_abs + 1) + 8 * cubic_alpha) * (x_abs + 1) - 4 * cubic_alpha);\\n    coeffs[1] = (((cubic_alpha + 2) * x_abs - (cubic_alpha + 3)) * x_abs * x_abs + 1);\\n    coeffs[2] = (((cubic_alpha + 2) * (1 - x_abs) - (cubic_alpha + 3)) * (1 - x_abs) * (1 - x_abs) + 1);\\n    coeffs[3] = (((cubic_alpha * (2 - x_abs) - 5 * cubic_alpha) * (2 - x_abs) + 8 * cubic_alpha) * (2 - x_abs) - 4 * cubic_alpha);\\n    return coeffs;\\n  }\\n\", Hf = (e1)=>\"\\n  fn gs_bicubic_interpolate(p: mat4x4<\".concat(e1, \">, x: f32, y: f32) -> \").concat(e1, \" {\\n    var v: vec4<f32>;\\n    var coeffs = gs_get_cubic_coeffs(x);\\n    for (var i = 0; i < 4; i++) {\\n      v[i] = coeffs[0] * p[i][0] + coeffs[1] * p[i][1] + coeffs[2] * p[i][2] + coeffs[3] * p[i][3];\\n    }\\n    coeffs = gs_get_cubic_coeffs(y);\\n    let pixel = \").concat(e1, \"(coeffs[0] * v[0] + coeffs[1] * v[1] + coeffs[2] * v[2] + coeffs[3] * v[3]);\\n    return pixel;\\n  }\\n\"), Ff = (e1)=>\"\\n  fn gs_denormalize(n: f32, length: i32) -> f32 {\\n    \".concat(e1.alignCorners === 0 ? \"\\n    // alignCorners: false => [-1, 1] to [-0.5, length - 0.5]\\n    return ((n + 1.0) * f32(length) - 1.0) / 2.0;\\n    \" : \"\\n    // alignCorners: true => [-1, 1] to [0, length - 1]\\n    return (n + 1.0) / 2.0 * (f32(length - 1));\\n    \", \"\\n  }\\n\"), qf = (e1)=>\"\\n  \".concat(e1.paddingMode === \"reflection\" ? \"\\n      fn gs_reflect(x: i32, x_min: f32, x_max: f32) -> u32 {\\n        var dx = 0.0;\\n        var fx = f32(x);\\n        let range = x_max - x_min;\\n        if (fx < x_min) {\\n          dx = x_min - fx;\\n          let n = u32(dx / range);\\n          let r = dx - f32(n) * range;\\n          if (n % 2 == 0) {\\n            fx = x_min + r;\\n          } else {\\n            fx = x_max - r;\\n          }\\n        } else if (fx > x_max) {\\n          dx = fx - x_max;\\n          let n = u32(dx / range);\\n          let r = dx - f32(n) * range;\\n          if (n % 2 == 0) {\\n            fx = x_max - r;\\n          } else {\\n            fx = x_min + r;\\n          }\\n        }\\n        return u32(fx);\\n      }\" : \"\", \"\\n\"), Kf = (e1, t, r)=>\"\\n  fn pixel_at_grid(r: i32, c: i32, H: i32, W: i32, batch: u32, channel: u32, border: vec4<f32>) -> \".concat(t, \" {\\n     var pixel = \").concat(t, \"(0);\\n     var indices = vec4<u32>(0);\\n     indices[\").concat(lt, \"] = batch;\\n     indices[\").concat(_t, \"] = channel;\") + (()=>{\n            switch(r.paddingMode){\n                case \"zeros\":\n                    return \"\\n          if (r >= 0 && r < H && c >=0 && c < W) {\\n            indices[\".concat(Ut, \"] = u32(r);\\n            indices[\").concat(Nt, \"] = u32(c);\\n          }\\n        \");\n                case \"border\":\n                    return \"\\n          indices[\".concat(Ut, \"] = u32(clamp(r, 0, H - 1));\\n          indices[\").concat(Nt, \"] = u32(clamp(c, 0, W - 1));\\n        \");\n                case \"reflection\":\n                    return \"\\n          indices[\".concat(Ut, \"] = gs_reflect(r, border[1], border[3]);\\n          indices[\").concat(Nt, \"] = gs_reflect(c, border[0], border[2]);\\n        \");\n                default:\n                    throw new Error(\"padding mode \".concat(r.paddingMode, \" is not supported\"));\n            }\n        })() + \"\\n    return \".concat(e1.getByIndices(\"indices\"), \";\\n  }\\n\"), jf = (e1, t, r)=>(()=>{\n            switch(r.mode){\n                case \"nearest\":\n                    return \"\\n          let result = pixel_at_grid(i32(round(y)), i32(round(x)), H_in, W_in, indices[\".concat(lt, \"], indices[\").concat(_t, \"], border);\\n        \");\n                case \"bilinear\":\n                    return \"\\n          let x1 = i32(floor(x));\\n          let y1 = i32(floor(y));\\n          let x2 = x1 + 1;\\n          let y2 = y1 + 1;\\n\\n          let p11 = pixel_at_grid(y1, x1, H_in, W_in, indices[\".concat(lt, \"], indices[\").concat(_t, \"], border);\\n          let p12 = pixel_at_grid(y1, x2, H_in, W_in, indices[\").concat(lt, \"], indices[\").concat(_t, \"], border);\\n          let p21 = pixel_at_grid(y2, x1, H_in, W_in, indices[\").concat(lt, \"], indices[\").concat(_t, \"], border);\\n          let p22 = pixel_at_grid(y2, x2, H_in, W_in, indices[\").concat(lt, \"], indices[\").concat(_t, \"], border);\\n\\n          let dx2 = \").concat(t, \"(f32(x2) - x);\\n          let dx1 = \").concat(t, \"(x - f32(x1));\\n          let dy2 = \").concat(t, \"(f32(y2) - y);\\n          let dy1 = \").concat(t, \"(y - f32(y1));\\n          let result = dy2 * (dx2 * p11 + dx1 * p12) + dy1 * (dx2 * p21 + dx1 * p22);\\n        \");\n                case \"bicubic\":\n                    return \"\\n          let x0 = i32(floor(x)) - 1;\\n          let y0 = i32(floor(y)) - 1;\\n          var p: mat4x4<\".concat(t, \">;\\n          for (var h = 0; h < 4; h++) {\\n            for (var w = 0; w < 4; w++) {\\n              p[h][w] = pixel_at_grid(h + y0, w + x0, H_in, W_in, indices[\").concat(lt, \"], indices[\").concat(_t, \"], border);\\n            }\\n          }\\n\\n          let dx = x - f32(x0 + 1);\\n          let dy = y - f32(y0 + 1);\\n          let result = gs_bicubic_interpolate(p, dx, dy);\\n        \");\n                default:\n                    throw new Error(\"mode \".concat(r.mode, \" is not supported\"));\n            }\n        })() + \"\".concat(e1.setByOffset(\"global_idx\", \"result\")), Yf = (e1, t)=>{\n        let r = E(\"x\", e1[0].dataType, e1[0].dims.length), n = [\n            e1[1].dims[0],\n            e1[1].dims[1],\n            e1[1].dims[2]\n        ], o = E(\"grid\", e1[1].dataType, n.length, 2), i = [\n            e1[0].dims[0],\n            e1[0].dims[1],\n            e1[1].dims[1],\n            e1[1].dims[2]\n        ];\n        t.format === \"NHWC\" && (i = [\n            e1[0].dims[0],\n            e1[1].dims[1],\n            e1[1].dims[2],\n            e1[0].dims[3]\n        ], [lt, _t, Ut, Nt] = [\n            0,\n            3,\n            1,\n            2\n        ]);\n        let a = M(\"output\", e1[0].dataType, i.length), d = r.type.value, l = C.size(i), p = [\n            {\n                type: 12,\n                data: l\n            },\n            ...N(e1[0].dims, n, i)\n        ], m = (u)=>\"\\n  \".concat(u.registerUniform(\"output_size\", \"u32\").declareVariables(r, o, a), \"\\n  \").concat(Gf, \"\\n  \").concat(Hf(d), \"\\n  \").concat(Ff(t), \"\\n  \").concat(qf(t), \"\\n  \").concat(Kf(r, d, t), \"\\n\\n  \").concat(u.mainStart(), \"\\n    \").concat(u.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\"), \"\\n      let H_in = i32(uniforms.x_shape[\").concat(Ut, \"]);\\n      let W_in = i32(uniforms.x_shape[\").concat(Nt, \"]);\\n\\n      \").concat(t.alignCorners === 0 ? \"\\n      let x_min = -0.5;\\n      let x_max = f32(W_in) - 0.5;\\n      let y_min = -0.5;\\n      let y_max = f32(H_in) - 0.5;\\n      \" : \"\\n      let x_min = 0.0;\\n      let x_max = f32(W_in) - 1.0;\\n      let y_min = 0.0;\\n      let y_max = f32(H_in) - 1.0;\\n      \", \";\\n      let border = vec4<f32>(x_min, y_min, x_max, y_max);\\n\\n      let indices = \").concat(a.offsetToIndices(\"global_idx\"), \";\\n      var grid_indices = vec3<u32>(indices[\").concat(lt, \"], indices[\").concat(Ut, \"], indices[\").concat(Nt, \"]);\\n      let nxy = \").concat(o.getByIndices(\"grid_indices\"), \";\\n      var x = gs_denormalize(f32(nxy[0]), W_in);\\n      var y = gs_denormalize(f32(nxy[1]), H_in);\\n\\n      \").concat(jf(a, d, t), \"\\n  }\");\n        return {\n            name: \"GridSample\",\n            shaderCache: {\n                hint: \"\".concat(t.cacheKey),\n                inputDependencies: [\n                    \"type\",\n                    \"type\"\n                ]\n            },\n            getRunData: (u)=>{\n                let h = C.size(i);\n                return {\n                    outputs: [\n                        {\n                            dims: i,\n                            dataType: u[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(h / 64)\n                    },\n                    programUniforms: p\n                };\n            },\n            getShaderSource: m\n        };\n    }, Md = (e1, t)=>{\n        Lf(e1.inputs), e1.compute(Yf(e1.inputs, t));\n    }, Rd = (e1)=>re({\n            alignCorners: e1.align_corners,\n            mode: e1.mode,\n            paddingMode: e1.padding_mode,\n            format: e1.format\n        });\n});\nvar Be, Xf, Vd, Nd, Jf, tr, Wd, So = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    Nr();\n    Fr();\n    ae();\n    dt();\n    Be = (e1, t)=>e1.length > t && e1[t].dims.length > 0 ? e1[t] : void 0, Xf = (e1, t)=>{\n        let r = e1[0], n = Be(e1, 1), o = Be(e1, 2), i = Be(e1, 3), a = Be(e1, 4), d = Be(e1, 5), l = Be(e1, 6), p = Be(e1, 7);\n        if (r.dims.length !== 3 && r.dims.length !== 5) throw new Error(\"Input query is expected to have 3 or 5 dimensions\");\n        let m = r.dims[0], u = r.dims[1], h = r.dims.length === 3 ? r.dims[2] : t.numHeads * r.dims[4], _ = u, y = 0, g = 0, x = Math.floor(h / t.numHeads);\n        if (l && p && C.size(l.dims) && C.size(p.dims)) {\n            if (l.dims.length !== 4) throw new Error('Input \"past_key\" is expected to have 4 dimensions');\n            if (l.dims[0] !== m || l.dims[1] !== t.numHeads || l.dims[3] !== x) throw new Error('Input \"past_key\" shape (batch_size, num_heads, past_sequence_length, head_size)');\n            if (p.dims[0] !== m || p.dims[1] !== t.numHeads || p.dims[3] !== x) throw new Error('Input \"past_value\" shape (batch_size, num_heads, past_sequence_length, head_size)');\n            if (l.dims[2] !== p.dims[2]) throw new Error('Input \"past_key\" and \"past_value\" shall have same dim 2 (past_sequence_length)');\n            if (p.dims.length !== 4) throw new Error('Input \"past_value\" is expected to have 4 dimensions');\n            y = l.dims[2], g = l.dims[2];\n        } else if (l && C.size(l.dims) || p && C.size(p.dims)) throw new Error('Input \"past_key\" and \"past_value\" shall be both present or both absent');\n        let $;\n        if (n && C.size(n.dims) > 0) {\n            if (r.dims.length !== 3) throw new Error('Input \"query\" is expected to have 3 dimensions when key is given');\n            if (n.dims.length < 3 || n.dims.length > 5) throw new Error('Input \"key\" is expected to have 3, 4, or 5 dimensions');\n            if (r.dims[0] !== n.dims[0]) throw new Error('Input \"query\" and \"key\" shall have same dim 0 (batch size)');\n            if (n.dims.length === 3) {\n                if (n.dims[2] !== r.dims[2]) throw new Error('Input \"query\" and \"key\" shall have same dim 2 (hidden_size)');\n                $ = 2, _ = n.dims[1];\n            } else if (n.dims.length === 5) {\n                if (n.dims[2] !== t.numHeads || n.dims[3] !== 2 || n.dims[4] !== x) throw new Error('Expect \"key\" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');\n                if (o) throw new Error('Expect \"value\" be none when \"key\" has packed kv format.');\n                $ = 5, _ = n.dims[1];\n            } else {\n                if (n.dims[1] !== t.numHeads || n.dims[3] !== x) throw new Error('Expect \"key\" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');\n                $ = 0, _ = n.dims[2];\n            }\n        } else {\n            if (r.dims.length !== 5) throw new Error('Input \"query\" is expected to have 5 dimensions when key is empty');\n            if (r.dims[2] !== t.numHeads || r.dims[3] !== 3) throw new Error('Expect \"query\" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');\n            $ = 3;\n        }\n        if (i && C.size(i.dims) > 0) {\n            if (i.dims.length !== 1) throw new Error('Input \"bias\" is expected to have 1 dimension');\n            if (n && n.dims.length === 5 && n.dims[3] === 2) throw new Error(\"bias is not allowed for packed kv.\");\n        }\n        let v = y + _, S = 0;\n        if (a && C.size(a.dims) > 0) {\n            S = 8;\n            let P = a.dims;\n            throw P.length === 1 ? P[0] === m ? S = 1 : P[0] === 3 * m + 2 && (S = 3) : P.length === 2 && P[0] === m && P[1] === v && (S = 5), S === 8 ? new Error('Input \"key_padding_mask\" shape shall be (batch_size) or (batch_size, total_sequence_length)') : new Error(\"Mask not supported\");\n        }\n        let T = !1, A = h;\n        if (o && C.size(o.dims) > 0) {\n            if (o.dims.length !== 3 && o.dims.length !== 4) throw new Error('Input \"value\" is expected to have 3 or 4 dimensions');\n            if (r.dims[0] !== o.dims[0]) throw new Error('Input \"query\" and \"value\" shall have same dim 0 (batch_size)');\n            if (o.dims.length === 3) {\n                if (_ !== o.dims[1]) throw new Error('Input \"key\" and \"value\" shall have the same dim 1 (kv_sequence_length)');\n                A = o.dims[2];\n            } else {\n                if (_ !== o.dims[2]) throw new Error('Input \"key\" and \"value\" shall have the same dim 2 (kv_sequence_length)');\n                A = o.dims[1] * o.dims[3], T = !0;\n            }\n        }\n        let k = !1;\n        if (a && C.size(a.dims) > 0) throw new Error(\"Key padding mask is not supported\");\n        if (d && C.size(d.dims) > 0) {\n            if (d.dims.length !== 4) throw new Error('Input \"attention_bias\" is expected to have 4 dimensions');\n            if (d.dims[0] !== m || d.dims[1] !== t.numHeads || d.dims[2] !== u || d.dims[3] !== v) throw new Error('Expect \"attention_bias\" shape (batch_size, num_heads, sequence_length, total_sequence_length)');\n        }\n        return {\n            batchSize: m,\n            sequenceLength: u,\n            pastSequenceLength: y,\n            kvSequenceLength: _,\n            totalSequenceLength: v,\n            maxSequenceLength: g,\n            inputHiddenSize: 0,\n            hiddenSize: h,\n            vHiddenSize: A,\n            headSize: x,\n            vHeadSize: Math.floor(A / t.numHeads),\n            numHeads: t.numHeads,\n            isUnidirectional: !1,\n            pastPresentShareBuffer: !1,\n            maskFilterValue: t.maskFilterValue,\n            maskType: S,\n            scale: t.scale,\n            broadcastResPosBias: k,\n            passPastInKv: T,\n            qkvFormat: $\n        };\n    }, Vd = (e1)=>re({\n            ...e1\n        }), Nd = re({\n        perm: [\n            0,\n            2,\n            1,\n            3\n        ]\n    }), Jf = (e1, t, r, n, o, i, a)=>{\n        let d = [\n            n,\n            o,\n            i\n        ], l = C.size(d), p = [\n            {\n                type: 12,\n                data: l\n            },\n            {\n                type: 12,\n                data: a\n            },\n            {\n                type: 12,\n                data: i\n            }\n        ], m = (u)=>{\n            let h = M(\"qkv_with_bias\", t.dataType, d), _ = E(\"qkv\", t.dataType, d), y = E(\"bias\", r.dataType, d), g = [\n                {\n                    name: \"output_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"bias_offset\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"hidden_size\",\n                    type: \"u32\"\n                }\n            ];\n            return \"\\n  \".concat(u.registerUniforms(g).declareVariables(_, y, h), \"\\n  \").concat(u.mainStart(), \"\\n    \").concat(u.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\"), \"\\n    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;\\n\\n    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];\\n  }\");\n        };\n        return e1.compute({\n            name: \"MultiHeadAttentionAddBias\",\n            shaderCache: {\n                inputDependencies: [\n                    \"type\",\n                    \"type\"\n                ]\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: d,\n                            dataType: t.dataType,\n                            gpuDataType: 0\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(l / 64)\n                    },\n                    programUniforms: p\n                }),\n            getShaderSource: m\n        }, {\n            inputs: [\n                t,\n                r\n            ],\n            outputs: [\n                -1\n            ]\n        })[0];\n    }, tr = (e1, t, r, n, o, i, a, d)=>{\n        let l = i;\n        if (a && C.size(a.dims) > 0) {\n            if (n === 1) throw new Error(\"AddBiasReshape is not implemented. Please export your model with packed QKV or KV\");\n            return l = Jf(e1, i, a, t, n, r * o, d), l = l.reshape([\n                t,\n                n,\n                r,\n                o\n            ]), r === 1 || n === 1 ? l : e1.compute(Pe(l, Nd.perm), {\n                inputs: [\n                    l\n                ],\n                outputs: [\n                    -1\n                ]\n            })[0];\n        } else return i.dims.length === 3 && (l = i.reshape([\n            t,\n            n,\n            r,\n            o\n        ])), r === 1 || n === 1 ? l : e1.compute(Pe(l, Nd.perm), {\n            inputs: [\n                l\n            ],\n            outputs: [\n                -1\n            ]\n        })[0];\n    }, Wd = (e1, t)=>{\n        let r = Xf(e1.inputs, t), n = e1.inputs[0], o = Be(e1.inputs, 1), i = Be(e1.inputs, 2), a = Be(e1.inputs, 3), d = Be(e1.inputs, 4), l = Be(e1.inputs, 5), p = Be(e1.inputs, 6), m = Be(e1.inputs, 7);\n        if (n.dims.length === 5) throw new Error(\"Packed QKV is not implemented\");\n        if ((o === null || o === void 0 ? void 0 : o.dims.length) === 5) throw new Error(\"Packed KV is not implemented\");\n        let u = o && i && o.dims.length === 4 && i.dims.length === 4, h = tr(e1, r.batchSize, r.numHeads, r.sequenceLength, r.headSize, n, a, 0);\n        if (u) return Rt(e1, h, o, i, d, void 0, p, m, l, r);\n        if (!o || !i) throw new Error(\"key and value must be provided\");\n        let _ = tr(e1, r.batchSize, r.numHeads, r.kvSequenceLength, r.headSize, o, a, r.hiddenSize), y = tr(e1, r.batchSize, r.numHeads, r.kvSequenceLength, r.vHeadSize, i, a, 2 * r.hiddenSize);\n        Rt(e1, h, _, y, d, void 0, p, m, l, r);\n    };\n});\nvar eh, th, rh, nh, To, Ld, Gd, Io = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    eh = (e1)=>{\n        if (!e1 || e1.length < 1) throw new Error(\"too few inputs\");\n    }, th = (e1, t)=>{\n        let r = [], n = t.numOutputs;\n        return e1[1].dims[0] > 0 && (e1[1].getBigInt64Array().forEach((o)=>r.push(Number(o))), n = r.length), re({\n            numOutputs: n,\n            axis: t.axis,\n            splitSizes: r\n        });\n    }, rh = (e1)=>\"\\nfn calculateOutputIndex(index: u32) -> u32 {\\n    for (var i: u32 = 0u; i < \".concat(e1, \"u; i += 1u ) {\\n    if (index < \").concat(F(\"uniforms.size_in_split_axis\", \"i\", e1), \") {\\n        return i;\\n    }\\n    }\\n    return \").concat(e1, \"u;\\n}\"), nh = (e1)=>{\n        let t = e1.length, r = [];\n        for(let n = 0; n < t; ++n){\n            let o = e1[n].setByIndices(\"indices\", \"input[global_idx]\");\n            t === 1 ? r.push(o) : n === 0 ? r.push(\"if (output_number == \".concat(n, \"u) { \").concat(o, \" }\")) : n === t - 1 ? r.push(\"else { \".concat(o, \" }\")) : r.push(\"else if (output_number == \".concat(n, \") { \").concat(o, \" }\"));\n        }\n        return \"\\n      fn writeBufferData(output_number: u32, indices: \".concat(e1[0].type.indices, \", global_idx: u32) {\\n        \").concat(r.join(\"\\n\"), \"\\n      }\");\n    }, To = (e1, t)=>{\n        let r = e1[0].dims, n = C.size(r), o = e1[0].dataType, i = C.normalizeAxis(t.axis, r.length), a = new Array(t.numOutputs), d = E(\"input\", o, r.length), l = new Array(t.numOutputs), p = [], m = [], u = 0, h = [\n            {\n                type: 12,\n                data: n\n            }\n        ];\n        for(let y = 0; y < t.numOutputs; y++){\n            u += t.splitSizes[y], l[y] = u;\n            let g = r.slice();\n            g[i] = t.splitSizes[y], m.push(g), a[y] = M(\"output\".concat(y), o, g.length), p.push({\n                dims: m[y],\n                dataType: e1[0].dataType\n            });\n        }\n        h.push({\n            type: 12,\n            data: l\n        }, ...N(r, ...m));\n        let _ = (y)=>\"\\n  \".concat(y.registerUniform(\"input_size\", \"u32\").registerUniform(\"size_in_split_axis\", \"u32\", l.length).declareVariables(d, ...a), \"\\n  \").concat(rh(l.length), \"\\n  \").concat(nh(a), \"\\n\\n  \").concat(y.mainStart(), \"\\n    \").concat(y.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.input_size\"), \"\\n\\n    var indices = \").concat(d.offsetToIndices(\"global_idx\"), \";\\n    var index = \").concat(d.indicesGet(\"indices\", i), \";\\n    let output_number = calculateOutputIndex(index);\\n    if (output_number != 0) {\\n      index -= \").concat(F(\"uniforms.size_in_split_axis\", \"output_number - 1u\", l.length), \";\\n      \").concat(d.indicesSet(\"indices\", i, \"index\"), \";\\n    }\\n    writeBufferData(output_number, indices, global_idx);\\n  }\");\n        return {\n            name: \"Split\",\n            shaderCache: {\n                hint: t.cacheKey,\n                inputDependencies: [\n                    \"rank\"\n                ]\n            },\n            getShaderSource: _,\n            getRunData: ()=>({\n                    outputs: p,\n                    dispatchGroup: {\n                        x: Math.ceil(n / 64)\n                    },\n                    programUniforms: h\n                })\n        };\n    }, Ld = (e1, t)=>{\n        eh(e1.inputs);\n        let r = e1.inputs.length === 1 ? t : th(e1.inputs, t);\n        e1.compute(To(e1.inputs, r), {\n            inputs: [\n                0\n            ]\n        });\n    }, Gd = (e1)=>{\n        let t = e1.axis, r = e1.splitSizes, n = e1.numOutputs < 0 ? r.length : e1.numOutputs;\n        if (n !== r.length) throw new Error(\"numOutputs and splitSizes lengh must be equal\");\n        return re({\n            axis: t,\n            numOutputs: n,\n            splitSizes: r\n        });\n    };\n});\nvar oh, ih, Hd, Fd, qd = U(()=>{\n    \"use strict\";\n    Se();\n    Fr();\n    So();\n    Io();\n    dt();\n    oh = (e1, t)=>{\n        if (t.doRotary) throw new Error(\"GroupQuerryAttention do_rotary attribute is not supported\");\n        if (t.doRotary && e1.length <= 7) throw new Error(\"cos_cache and sin_cache inputs are required if do_rotary is specified\");\n        let r = e1[0], n = e1[1], o = e1[2], i = e1[3], a = e1[4];\n        if (t.localWindowSize !== -1) throw new Error(\"Local attention is not supported\");\n        if (t.softcap !== 0) throw new Error(\"Softcap is not supported\");\n        if (t.rotaryInterleaved !== 0) throw new Error(\"Rotary interleaved is not supported\");\n        if (t.smoothSoftmax) throw new Error(\"Smooth softmax is not supported\");\n        if (r.dims.length !== 3 && r.dims.length !== 5) throw new Error(\"Input query is expected to have 3 or 5 dimensions\");\n        let d = !1, l = r.dims[0], p = r.dims[1], m = r.dims.length === 3 ? d ? r.dims[2] / 3 : r.dims[2] : t.numHeads * r.dims[4], u = p, h = 0, _ = !n || n.dims.length === 0, y = Math.floor(_ ? m / (t.numHeads + 2 * t.kvNumHeads) : m / t.numHeads);\n        _ && (m = y * t.numHeads);\n        let g = i && i.dims.length !== 0, x = a && a.dims.length !== 0;\n        if (g && i.dims.length === 4 && i.dims[0] === l && i.dims[1] !== t.kvNumHeads && i.dims[2] === t.kvNumHeads && i.dims[3] === y) throw new Error(\"BSNH pastKey/pastValue is not supported\");\n        if (g && x) {\n            if (i.dims.length !== 4) throw new Error('Input \"past_key\" is expected to have 4 dimensions');\n            if (a.dims.length !== 4) throw new Error('Input \"past_value\" is expected to have 4 dimensions');\n            h = i.dims[2];\n        } else if (g || x) throw new Error('Input \"past_key\" and \"past_value\" shall be both present or both absent');\n        let v = 1;\n        if (n && n.dims.length > 0) {\n            if (r.dims.length !== 3) throw new Error('Input \"query\" is expected to have 3 dimensions when key is given');\n            if (n.dims.length < 3 || n.dims.length > 5) throw new Error('Input \"key\" is expected to have 3, 4, or 5 dimensions');\n            if (r.dims[0] !== n.dims[0]) throw new Error('Input \"query\" and \"key\" shall have same dim 0 (batch size)');\n            if (n.dims.length === 3) {\n                if (r.dims[2] % n.dims[2] !== 0) throw new Error('Dimension 2 of \"query\" should be a multiple of \"key\"');\n                u = n.dims[1];\n            } else if (n.dims.length === 5) {\n                if (n.dims[2] !== t.numHeads || n.dims[3] !== 2 || n.dims[4] !== y) throw new Error('Expect \"key\" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');\n                if (o) throw new Error('Expect \"value\" be none when \"key\" has packed kv format.');\n                u = n.dims[1];\n            } else {\n                if (n.dims[1] !== t.numHeads || n.dims[3] !== y) throw new Error('Expect \"key\" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');\n                u = n.dims[2];\n            }\n        } else {\n            if (r.dims.length !== 3 && r.dims.length !== 5) throw new Error('Input \"query\" is expected to have 3 or 5 dimensions when key is empty');\n            if (r.dims.length === 5 && (r.dims[2] !== t.numHeads || r.dims[3] !== 3)) throw new Error('Expect \"query\" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');\n            v = 3;\n        }\n        let S = 0, T = !1, A = t.kvNumHeads ? y * t.kvNumHeads : m;\n        if (o && o.dims.length > 0) {\n            if (o.dims.length !== 3 && o.dims.length !== 4) throw new Error('Input \"value\" is expected to have 3 or 4 dimensions');\n            if (r.dims[0] !== o.dims[0]) throw new Error('Input \"query\" and \"value\" shall have same dim 0 (batch_size)');\n            if (o.dims.length === 3) {\n                if (u !== o.dims[1]) throw new Error('Input \"key\" and \"value\" shall have the same dim 1 (kv_sequence_length)');\n                A = o.dims[2];\n            } else {\n                if (u !== o.dims[2]) throw new Error('Input \"past_key\" and \"past_value\" shall have the same dim 2 (kv_sequence_length)');\n                A = o.dims[1] * o.dims[3], T = !0;\n            }\n        }\n        let k = e1.length > 4 ? e1[5] : void 0;\n        if (k && k.dims.length !== 1 && k.dims[0] !== l) throw new Error('Input \"seqlens\" is expected to have 1 dimension and the same dim 0 as batch_size');\n        let P = -1, D = -1, R = !1;\n        return {\n            batchSize: l,\n            sequenceLength: p,\n            pastSequenceLength: h,\n            kvSequenceLength: u,\n            totalSequenceLength: P,\n            maxSequenceLength: D,\n            inputHiddenSize: 0,\n            hiddenSize: m,\n            vHiddenSize: A,\n            headSize: y,\n            vHeadSize: Math.floor(A / t.kvNumHeads),\n            numHeads: t.numHeads,\n            kvNumHeads: t.kvNumHeads,\n            nReps: t.numHeads / t.kvNumHeads,\n            pastPresentShareBuffer: !1,\n            maskType: S,\n            scale: t.scale,\n            broadcastResPosBias: R,\n            passPastInKv: T,\n            qkvFormat: v\n        };\n    }, ih = re({\n        perm: [\n            0,\n            2,\n            1,\n            3\n        ]\n    }), Hd = (e1, t, r)=>{\n        let n = t, o = r.kvNumHeads;\n        return t.dims.length === 3 && r.kvSequenceLength !== 0 && (n = t.reshape([\n            r.batchSize,\n            r.kvSequenceLength,\n            o,\n            r.headSize\n        ]), n = e1.compute(Pe(n, ih.perm), {\n            inputs: [\n                n\n            ],\n            outputs: [\n                -1\n            ]\n        })[0]), n;\n    }, Fd = (e1, t)=>{\n        var _e_inputs_;\n        let r = oh(e1.inputs, t);\n        if (e1.inputs[0].dims.length === 5) throw new Error(\"Packed QKV is not implemented\");\n        if (((_e_inputs_ = e1.inputs[1]) === null || _e_inputs_ === void 0 ? void 0 : _e_inputs_.dims.length) === 5) throw new Error(\"Packed KV is not implemented\");\n        let n = e1.inputs[0], o = e1.inputs[1] && e1.inputs[1].dims.length > 0 ? e1.inputs[1] : void 0, i = e1.inputs[2] && e1.inputs[2].dims.length > 0 ? e1.inputs[2] : void 0, a = e1.inputs[3] && e1.inputs[3].dims.length !== 0 ? e1.inputs[3] : void 0, d = e1.inputs[4] && e1.inputs[4].dims.length !== 0 ? e1.inputs[4] : void 0, l = e1.inputs.length > 4 ? e1.inputs[5] : void 0, p = e1.inputs.length > 5 ? e1.inputs[6] : void 0, m = r.kvNumHeads ? r.kvNumHeads : r.numHeads, u = re({\n            axis: 2,\n            numOutputs: 3,\n            splitSizes: [\n                r.numHeads * r.headSize,\n                m * r.headSize,\n                m * r.headSize\n            ]\n        }), [h, _, y] = !o && !i ? e1.compute(To([\n            n\n        ], u), {\n            inputs: [\n                n\n            ],\n            outputs: [\n                -1,\n                -1,\n                -1\n            ]\n        }) : [\n            n,\n            o,\n            i\n        ], g = tr(e1, r.batchSize, r.numHeads, r.sequenceLength, r.headSize, h, void 0, 0);\n        Rt(e1, g, Hd(e1, _, r), Hd(e1, y, r), void 0, void 0, a, d, void 0, r, l, p);\n    };\n});\nvar Kd, ah, sh, jd, Yd = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    dt();\n    ae();\n    Kd = (e1, t, r, n, o, i, a, d)=>{\n        let l = me(i), p = l === 1 ? \"f32\" : \"vec\".concat(l, \"f\"), m = l === 1 ? \"vec2f\" : \"mat2x\".concat(l, \"f\"), u = o * a, h = 64;\n        u === 1 && (h = 256);\n        let _ = [\n            o,\n            a,\n            i / l\n        ], y = [\n            o,\n            a,\n            2\n        ], g = [\n            \"rank\",\n            \"type\",\n            \"type\"\n        ], x = [];\n        x.push(...N(_, y));\n        let $ = (v)=>{\n            let S = E(\"x\", t.dataType, 3, l), T = E(\"scale\", r.dataType, r.dims), A = E(\"bias\", n.dataType, n.dims), k = M(\"output\", 1, 3, 2), P = [\n                S,\n                T,\n                A,\n                k\n            ];\n            return \"\\n  var<workgroup> workgroup_shared : array<\".concat(m, \", \").concat(h, \">;\\n  const workgroup_size = \").concat(h, \"u;\\n  \").concat(v.declareVariables(...P), \"\\n  \").concat(v.mainStart(h), \"\\n    let batch = workgroup_index / uniforms.x_shape[1];\\n    let channel = workgroup_index % uniforms.x_shape[1];\\n    let hight = uniforms.x_shape[2];\\n    // initialize workgroup memory\\n    var sum = \").concat(p, \"(0);\\n    var squared_sum = \").concat(p, \"(0);\\n    for (var h = local_idx; h < hight; h += workgroup_size) {\\n      let value = \").concat(p, \"(\").concat(S.get(\"batch\", \"channel\", \"h\"), \");\\n      sum += value;\\n      squared_sum += value * value;\\n    }\\n    workgroup_shared[local_idx] = \").concat(m, \"(sum, squared_sum);\\n    workgroupBarrier();\\n\\n    for (var currSize = workgroup_size >> 1;  currSize > 0; currSize = currSize >> 1) {\\n      if (local_idx < currSize) {\\n        workgroup_shared[local_idx] = workgroup_shared[local_idx] + workgroup_shared[local_idx + currSize];\\n      }\\n      workgroupBarrier();\\n    }\\n    if (local_idx == 0) {\\n      let sum_final = \").concat(Fe(\"workgroup_shared[0][0]\", l), \" / f32(hight * \").concat(l, \");\\n      let squared_sum_final = \").concat(Fe(\"workgroup_shared[0][1]\", l), \" / f32(hight * \").concat(l, \");\\n\\n      let inv_std_dev = inverseSqrt(squared_sum_final - sum_final * sum_final + f32(\").concat(d, \"));\\n      let channel_scale = inv_std_dev * f32(scale[channel]);\\n      let channel_shift = f32(bias[channel]) - sum_final * channel_scale;\\n      output[workgroup_index] = vec2f(channel_scale, channel_shift);\\n    }\\n  }\");\n        };\n        return e1.compute({\n            name: \"InstanceNormComputeChannelScaleShift\",\n            shaderCache: {\n                hint: \"\".concat(l, \";\").concat(d, \";\").concat(h),\n                inputDependencies: g\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: y,\n                            dataType: 1\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: u\n                    },\n                    programUniforms: x\n                }),\n            getShaderSource: $\n        }, {\n            inputs: [\n                t,\n                r,\n                n\n            ],\n            outputs: [\n                -1\n            ]\n        })[0];\n    }, ah = (e1, t, r)=>{\n        let n = t[0].dims, o = n, i = 2, a = n[0], d = n[1], l = C.sizeFromDimension(n, i), p = me(l), m = C.size(o) / p, u = Kd(e1, t[0], t[1], t[2], a, l, d, r.epsilon), h = [\n            a,\n            d,\n            l / p\n        ], _ = [\n            a,\n            d\n        ], y = [\n            \"type\",\n            \"none\"\n        ], g = (x)=>{\n            let $ = E(\"x\", t[0].dataType, h.length, p), v = E(\"scale_shift\", 1, _.length, 2), S = M(\"output\", t[0].dataType, h.length, p), T = [\n                $,\n                v,\n                S\n            ];\n            return \"\\n  \".concat(x.registerUniform(\"output_size\", \"u32\").declareVariables(...T), \"\\n  \").concat(x.mainStart(), \"\\n  \").concat(x.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\"), \"\\n      let outputIndices = \").concat(S.offsetToIndices(\"global_idx\"), \";\\n      let batch = outputIndices[0];\\n      let channel = outputIndices[1];\\n      let scale_shift = \").concat(v.getByIndices(\"vec2<u32>(batch, channel)\"), \";\\n      let value = \").concat($.getByOffset(\"global_idx\"), \" * \").concat(S.type.value, \"(scale_shift.x) + \").concat(S.type.value, \"(scale_shift.y);\\n      \").concat(S.setByOffset(\"global_idx\", \"value\"), \";\\n  }\");\n        };\n        e1.compute({\n            name: \"InstanceNormalization\",\n            shaderCache: {\n                hint: \"\".concat(p),\n                inputDependencies: y\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: o,\n                            dataType: t[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(m / 64)\n                    },\n                    programUniforms: [\n                        {\n                            type: 12,\n                            data: m\n                        },\n                        ...N(h, _, h)\n                    ]\n                }),\n            getShaderSource: g\n        }, {\n            inputs: [\n                t[0],\n                u\n            ]\n        });\n    }, sh = (e1, t, r)=>{\n        let n = t[0].dims, o = n, i = n[0], a = n[n.length - 1], d = C.sizeFromDimension(n, 1) / a, l = me(a), p = C.size(o) / l, m = [\n            {\n                type: 12,\n                data: d\n            },\n            {\n                type: 12,\n                data: Math.floor(a / l)\n            }\n        ], u = [\n            \"type\",\n            \"type\"\n        ], h = !1, _ = [\n            0,\n            n.length - 1\n        ];\n        for(let $ = 0; $ < n.length - 2; $++)h = h || n[$ + 1] !== 1, _.push($ + 1);\n        h = h && n[n.length - 1] !== 1;\n        let y = h ? e1.compute(Pe(e1.inputs[0], _), {\n            inputs: [\n                e1.inputs[0]\n            ],\n            outputs: [\n                -1\n            ]\n        })[0] : e1.inputs[0].reshape(Array.from({\n            length: n.length\n        }, ($, v)=>n[_[v]])), g = Kd(e1, y, t[1], t[2], i, d, a, r.epsilon), x = ($)=>{\n            let v = _e(t[0].dataType), S = l === 1 ? \"vec2f\" : \"mat\".concat(l, \"x2f\"), T = (P)=>{\n                let D = P === 0 ? \"x\" : \"y\", R = l === 1 ? \"f32\" : \"vec\".concat(l, \"f\");\n                switch(l){\n                    case 1:\n                        return \"\".concat(v, \"(\").concat(R, \"(scale.\").concat(D, \"))\");\n                    case 2:\n                        return \"vec2<\".concat(v, \">(\").concat(R, \"(scale[0].\").concat(D, \", scale[1].\").concat(D, \"))\");\n                    case 4:\n                        return \"vec4<\".concat(v, \">(\").concat(R, \"(scale[0].\").concat(D, \", scale[1].\").concat(D, \", scale[2].\").concat(D, \", scale[3].\").concat(D, \"))\");\n                    default:\n                        throw new Error(\"Not supported compoents \".concat(l));\n                }\n            }, A = E(\"input\", t[0].dataType, t[0].dims, l), k = M(\"output\", t[0].dataType, o, l);\n            return \"\\n  @group(0) @binding(0) var<storage, read> input : array<\".concat(A.type.storage, \">;\\n  @group(0) @binding(1) var<storage, read> scale_input : array<\").concat(S, \">;\\n  @group(0) @binding(2) var<storage, read_write> output : array<\").concat(k.type.storage, \">;\\n  struct Uniforms {H: u32, C : u32};\\n  @group(0) @binding(3) var<uniform> uniforms: Uniforms;\\n\\n  \").concat($.mainStart(), \"\\n    let current_image_number = global_idx / (uniforms.C * uniforms.H);\\n    let current_channel_number = global_idx % uniforms.C;\\n\\n    let scale_offset = current_image_number * uniforms.C + current_channel_number;\\n    let scale = scale_input[scale_offset];\\n    output[global_idx] = fma(input[global_idx], \").concat(T(0), \", \").concat(T(1), \");\\n  }\");\n        };\n        e1.compute({\n            name: \"InstanceNormalizationNHWC\",\n            shaderCache: {\n                hint: \"\".concat(l),\n                inputDependencies: u\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: o,\n                            dataType: t[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(p / 64)\n                    },\n                    programUniforms: m\n                }),\n            getShaderSource: x\n        }, {\n            inputs: [\n                t[0],\n                g\n            ]\n        });\n    }, jd = (e1, t)=>{\n        t.format === \"NHWC\" ? sh(e1, e1.inputs, t) : ah(e1, e1.inputs, t);\n    };\n});\nvar uh, dh, Zd, Qd = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    ae();\n    uh = (e1)=>{\n        if (!e1 || e1.length < 2) throw new Error(\"layerNorm requires at least 2 inputs.\");\n    }, dh = (e1, t, r)=>{\n        let n = t.simplified, o = e1[0].dims, i = e1[1], a = !n && e1[2], d = o, l = C.normalizeAxis(t.axis, o.length), p = C.sizeToDimension(o, l), m = C.sizeFromDimension(o, l), u = C.size(i.dims), h = a ? C.size(a.dims) : 0;\n        if (u !== m || a && h !== m) throw new Error(\"Size of X.shape()[axis:] == \".concat(m, \".\\n       Size of scale and bias (if provided) must match this.\\n       Got scale size of \").concat(u, \" and bias size of \").concat(h));\n        let _ = [];\n        for(let A = 0; A < o.length; ++A)A < l ? _.push(o[A]) : _.push(1);\n        let y = me(m), g = [\n            \"type\",\n            \"type\"\n        ], x = [\n            {\n                type: 12,\n                data: p\n            },\n            {\n                type: 1,\n                data: m\n            },\n            {\n                type: 12,\n                data: Math.floor(m / y)\n            },\n            {\n                type: 1,\n                data: t.epsilon\n            }\n        ];\n        a && g.push(\"type\");\n        let $ = r > 1, v = r > 2, S = (A)=>{\n            let k = _e(e1[0].dataType), P = [\n                E(\"x\", e1[0].dataType, e1[0].dims, y),\n                E(\"scale\", i.dataType, i.dims, y)\n            ];\n            a && P.push(E(\"bias\", a.dataType, a.dims, y)), P.push(M(\"output\", e1[0].dataType, d, y)), $ && P.push(M(\"mean_data_output\", 1, _)), v && P.push(M(\"inv_std_output\", 1, _));\n            let D = [\n                {\n                    name: \"norm_count\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"norm_size\",\n                    type: \"f32\"\n                },\n                {\n                    name: \"norm_size_vectorized\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"epsilon\",\n                    type: \"f32\"\n                }\n            ];\n            return \"\\n  \".concat(A.registerUniforms(D).declareVariables(...P), \"\\n  \").concat(A.mainStart(), \"\\n    \").concat(A.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.norm_count\"), \"\\n    let offset = global_idx * uniforms.norm_size_vectorized;\\n    var mean_vector = \").concat(uo(\"f32\", y), \";\\n    var mean_square_vector = \").concat(uo(\"f32\", y), \";\\n\\n    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {\\n      let value = \").concat(Et(k, y, \"x[h + offset]\"), \";\\n      mean_vector += value;\\n      mean_square_vector += value * value;\\n    }\\n    let mean = \").concat(Fe(\"mean_vector\", y), \" / uniforms.norm_size;\\n    let inv_std_dev = inverseSqrt(\").concat(Fe(\"mean_square_vector\", y), \" / uniforms.norm_size \").concat(n ? \"\" : \"- mean * mean\", \" + uniforms.epsilon);\\n\\n    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {\\n      let f32input = \").concat(Et(k, y, \"x[j + offset]\"), \";\\n      let f32scale = \").concat(Et(k, y, \"scale[j]\"), \";\\n      output[j + offset] = \").concat(P[0].type.value, \"((f32input \").concat(n ? \"\" : \"- mean\", \") * inv_std_dev * f32scale\\n        \").concat(a ? \"+ \".concat(Et(k, y, \"bias[j]\")) : \"\", \"\\n      );\\n    }\\n\\n    \").concat($ ? \"mean_data_output[global_idx] = mean\" : \"\", \";\\n    \").concat(v ? \"inv_std_output[global_idx] = inv_std_dev\" : \"\", \";\\n  }\");\n        }, T = [\n            {\n                dims: d,\n                dataType: e1[0].dataType\n            }\n        ];\n        return $ && T.push({\n            dims: _,\n            dataType: 1\n        }), v && T.push({\n            dims: _,\n            dataType: 1\n        }), {\n            name: \"LayerNormalization\",\n            shaderCache: {\n                hint: \"\".concat(y, \";\").concat(r, \";\").concat(n),\n                inputDependencies: g\n            },\n            getRunData: ()=>({\n                    outputs: T,\n                    dispatchGroup: {\n                        x: Math.ceil(p / 64)\n                    },\n                    programUniforms: x\n                }),\n            getShaderSource: S\n        };\n    }, Zd = (e1, t)=>{\n        uh(e1.inputs), e1.compute(dh(e1.inputs, t, e1.outputCount));\n    };\n});\nvar lh, Xd, Jd = U(()=>{\n    \"use strict\";\n    oe();\n    Qr();\n    Xr();\n    lh = (e1)=>{\n        if (!e1 || e1.length !== 2) throw new Error(\"MatMul requires 2 inputs.\");\n        if (e1[0].dims[e1[0].dims.length - 1] !== e1[1].dims[e1[1].dims.length - 2]) throw new Error(\"shared dimension does not match.\");\n    }, Xd = (e1)=>{\n        lh(e1.inputs);\n        let t = tt.calcShape(e1.inputs[0].dims, e1.inputs[1].dims, !0);\n        if (!t) throw new Error(\"Can't use matmul on the given tensors\");\n        let r = t[t.length - 1], n = e1.inputs[0].dims[e1.inputs[0].dims.length - 1];\n        if (r < 8 && n < 8) e1.compute(Zr(e1.inputs, {\n            activation: \"\"\n        }, t));\n        else {\n            let o = t[t.length - 2], i = C.size(e1.inputs[0].dims.slice(0, -2)), a = C.size(e1.inputs[1].dims.slice(0, -2));\n            if (i !== 1 && o === 1 && a === 1) {\n                let d = e1.inputs[0].reshape([\n                    1,\n                    i,\n                    n\n                ]), l = e1.inputs[1].reshape([\n                    1,\n                    n,\n                    r\n                ]), p = [\n                    1,\n                    i,\n                    r\n                ], m = [\n                    d,\n                    l\n                ];\n                e1.compute(er(m, {\n                    activation: \"\"\n                }, t, p), {\n                    inputs: m\n                });\n            } else e1.compute(er(e1.inputs, {\n                activation: \"\"\n            }, t));\n        }\n    };\n});\nvar ch, ph, mh, el, tl, rl = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    ch = (e1, t)=>{\n        if (e1.length < 3 || e1.length > 4) throw new Error(\"MatMulNBits requires 3 or 4 inputs\");\n        let r = e1[0], n = r.dims.length;\n        if (r.dims[n - 1] !== t.k) throw new Error(\"The last dim of input shape does not match the k value\");\n        let o = Math.floor((t.k + t.blockSize - 1) / t.blockSize), i = t.blockSize / 8 * t.bits, a = e1[1];\n        if (!C.areEqual(a.dims, [\n            t.n,\n            o,\n            i\n        ])) throw new Error(\"The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize\");\n        let l = e1[2].dims;\n        if (C.size(l) !== t.n * o) throw new Error(\"scales input size error.\");\n        if (e1.length === 4) {\n            let m = e1[3].dims, u = t.bits > 4 ? t.n * o : t.n * Math.floor((o + 1) / 2);\n            if (C.size(m) !== u) throw new Error(\"zeroPoints input size error.\");\n        }\n    }, ph = (e1, t)=>{\n        let r = e1[0].dims, n = r.length, o = r[n - 2], i = t.k, a = t.n, d = r.slice(0, n - 2), l = C.size(d), m = e1[1].dims[2] / 4, u = e1[0].dataType, h = me(t.k), _ = me(m), y = me(a), g = d.concat([\n            o,\n            a\n        ]), x = o > 1 && a / y % 2 === 0 ? 2 : 1, $ = C.size(g) / y / x, v = 64, S = [], T = [\n            l,\n            o,\n            i / h\n        ], A = C.convertShape(e1[1].dims).slice();\n        A.splice(-1, 1, m / _), S.push(...N(T)), S.push(...N(A)), S.push(...N(e1[2].dims)), e1.length === 4 && S.push(...N(C.convertShape(e1[3].dims)));\n        let k = [\n            l,\n            o,\n            a / y\n        ];\n        S.push(...N(k));\n        let P = (D)=>{\n            let R = T.length, G = E(\"a\", e1[0].dataType, R, h), K = E(\"b\", 12, A.length, _), j = E(\"scales\", e1[2].dataType, e1[2].dims.length), V = [\n                G,\n                K,\n                j\n            ], Q = e1.length === 4 ? E(\"zero_points\", 12, e1[3].dims.length) : void 0;\n            Q && V.push(Q);\n            let se = k.length, Y = M(\"output\", e1[0].dataType, se, y), ee = _e(e1[0].dataType), J = (()=>{\n                switch(h){\n                    case 1:\n                        return \"array<\".concat(ee, \", 8>\");\n                    case 2:\n                        return \"mat4x2<\".concat(ee, \">\");\n                    case 4:\n                        return \"mat2x4<\".concat(ee, \">\");\n                    default:\n                        throw new Error(\"\".concat(h, \"-component is not supported.\"));\n                }\n            })(), ne = ()=>{\n                let $e = \"\\n          // reuse a data\\n            var input_offset = \".concat(G.indicesToOffset(\"\".concat(G.type.indices, \"(batch, row, word_offset)\")), \";\\n            var a_data: \").concat(J, \";\\n            for (var j: u32 = 0; j < \").concat(8 / h, \"; j++) {\\n              a_data[j] = \").concat(G.getByOffset(\"input_offset\"), \";\\n              input_offset++;\\n            }\\n          \");\n                for(let le = 0; le < y * x; le++)$e += \"\\n            b_value = \".concat(_ === 1 ? \"b\".concat(le, \"_data\") : \"b\".concat(le, \"_data[i]\"), \";\\n            b_value_lower = unpack4xU8(b_value & b_mask);\\n            b_value_upper = unpack4xU8((b_value >> 4) & b_mask);\\n            b_quantized_values = \").concat(J, \"(\").concat(Array.from({\n                    length: 4\n                }, (W, q)=>\"\".concat(ee, \"(b_value_lower[\").concat(q, \"]), \").concat(ee, \"(b_value_upper[\").concat(q, \"])\")).join(\", \"), \");\\n            b_dequantized_values = \").concat((()=>h === 1 ? \"\".concat(J, \"(\").concat(Array.from({\n                        length: 8\n                    }, (W, q)=>\"(b_quantized_values[\".concat(q, \"] - \").concat(Q ? \"zero_point\".concat(le) : \"zero_point\", \") * scale\").concat(le)).join(\", \"), \");\") : \"(b_quantized_values - \".concat(J, \"(\").concat(Array(8).fill(\"\".concat(Q ? \"zero_point\".concat(le) : \"zero_point\")).join(\",\"), \")) * scale\").concat(le, \";\"))(), \";\\n            workgroup_shared[local_id.x * \").concat(x, \" + \").concat(Math.floor(le / y), \"]\").concat(y > 1 ? \"[\".concat(le % y, \"]\") : \"\", \" += \").concat(Array.from({\n                    length: 8 / h\n                }, (W, q)=>\"\".concat(h === 1 ? \"a_data[\".concat(q, \"] * b_dequantized_values[\").concat(q, \"]\") : \"dot(a_data[\".concat(q, \"], b_dequantized_values[\").concat(q, \"])\"))).join(\" + \"), \";\\n          \");\n                return $e;\n            }, be = ()=>{\n                let $e = \"\\n            var col_index = col * \".concat(y, \";\\n            \").concat(Q ? \"\\n            let zero_point_bytes_per_col = (nBlocksPerCol + 1) / 2;\\n            var zero_point_byte_count: u32;\\n            var zero_point_word_index: u32;\\n            var zero_point_byte_offset: u32;\\n            let zero_point_nibble_offset: u32 = block & 0x1u;\\n            var zero_point_bits_offset: u32;\\n            var zero_point_word: u32;\" : \"\\n            // The default zero point is 8 for unsigned 4-bit quantization.\\n            let zero_point = \".concat(ee, \"(8);\"), \"\\n            \");\n                for(let le = 0; le < y * x; le++)$e += \"\\n            let scale\".concat(le, \" = \").concat(j.getByOffset(\"col_index * nBlocksPerCol + block\"), \";\\n            \").concat(Q ? \"\\n            zero_point_byte_count = col_index * zero_point_bytes_per_col + (block >> 0x1u);\\n            zero_point_word_index = zero_point_byte_count >> 0x2u;\\n            zero_point_byte_offset = zero_point_byte_count & 0x3u;\\n            zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);\\n            zero_point_word = \".concat(Q.getByOffset(\"zero_point_word_index\"), \" >> zero_point_bits_offset;\\n            let zero_point\").concat(le, \" = \").concat(ee, \"((zero_point_word) & 0xFu);\") : \"\", \"\\n            col_index += 1;\");\n                return $e;\n            }, Oe = ()=>{\n                let $e = \"col_index = col * \".concat(y, \";\");\n                for(let le = 0; le < y * x; le++)$e += \"\\n            let b\".concat(le, \"_data = \").concat(K.getByIndices(\"\".concat(K.type.indices, \"(col_index, block, word)\")), \";\\n            col_index += 1;\");\n                return $e += \"\\n            var b_value: u32;\\n            let b_mask: u32 = 0x0F0F0F0Fu;\\n            var b_value_lower: vec4<u32>;\\n            var b_value_upper: vec4<u32>;\\n            var b_quantized_values: \".concat(J, \";\\n            var b_dequantized_values: \").concat(J, \";\"), $e;\n            };\n            return \"\\n        var<workgroup> workgroup_shared: array<\".concat(Y.type.value, \", \").concat(x * v, \">;\\n        \").concat(D.declareVariables(...V, Y), \"\\n        \").concat(D.mainStart([\n                v,\n                1,\n                1\n            ]), \"\\n          let output_indices = \").concat(Y.offsetToIndices(\"(global_idx / \".concat(v, \") * \").concat(x)), \";\\n          let col = output_indices[2];\\n          let row = output_indices[1];\\n          let batch = output_indices[0];\\n          let nBlocksPerCol = uniforms.b_shape[1];\\n\\n          for (var block = local_id.x; block < nBlocksPerCol; block += \").concat(v, \") {\\n            //process one block\\n            var word_offset: u32 = block * \").concat(t.blockSize / h, \";\\n            \").concat(be(), \"\\n            for (var word: u32 = 0; word < \").concat(m, \"; word += \").concat(_, \") {\\n              \").concat(Oe(), \"\\n              for (var i: u32 = 0; i < \").concat(_, \"; i++) {\\n                \").concat(ne(), \"\\n                word_offset += \").concat(8 / h, \";\\n              }\\n            }\\n          }\\n          workgroupBarrier();\\n\\n          if (local_id.x < \").concat(x, \") {\\n            var output_value: \").concat(Y.type.value, \" = \").concat(Y.type.value, \"(0);\\n            var workgroup_shared_offset: u32 = local_id.x;\\n            for (var b: u32 = 0u; b < \").concat(v, \"u; b++) {\\n              output_value += workgroup_shared[workgroup_shared_offset];\\n              workgroup_shared_offset += \").concat(x, \";\\n            }\\n            \").concat(Y.setByIndices(\"\".concat(Y.type.indices, \"(batch, row, col + local_id.x)\"), \"output_value\"), \";\\n          }\\n        }\");\n        };\n        return {\n            name: \"MatMulNBits\",\n            shaderCache: {\n                hint: \"\".concat(t.blockSize, \";\").concat(t.bits, \";\").concat(h, \";\").concat(_, \";\").concat(y, \";\").concat(x, \";\").concat(v),\n                inputDependencies: Array(e1.length).fill(\"rank\")\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: g,\n                            dataType: u\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: $\n                    },\n                    programUniforms: S\n                }),\n            getShaderSource: P\n        };\n    }, mh = (e1, t)=>{\n        let r = e1[0].dims, n = r.length, o = r[n - 2], i = t.k, a = t.n, d = r.slice(0, n - 2), l = C.size(d), m = e1[1].dims[2] / 4, u = e1[0].dataType, h = me(t.k), _ = me(m), y = d.concat([\n            o,\n            a\n        ]), g = 128, x = a % 8 === 0 ? 8 : a % 4 === 0 ? 4 : 1, $ = g / x, v = $ * _ * 8, S = v / h, T = v / t.blockSize, A = C.size(y) / x, k = [], P = [\n            l,\n            o,\n            i / h\n        ], D = C.convertShape(e1[1].dims).slice();\n        D.splice(-1, 1, m / _), k.push(...N(P)), k.push(...N(D)), k.push(...N(e1[2].dims)), e1.length === 4 && k.push(...N(C.convertShape(e1[3].dims)));\n        let R = [\n            l,\n            o,\n            a\n        ];\n        k.push(...N(R));\n        let G = (K)=>{\n            let j = P.length, V = E(\"a\", e1[0].dataType, j, h), Q = E(\"b\", 12, D.length, _), se = E(\"scales\", e1[2].dataType, e1[2].dims.length), Y = [\n                V,\n                Q,\n                se\n            ], ee = e1.length === 4 ? E(\"zero_points\", 12, e1[3].dims.length) : void 0;\n            ee && Y.push(ee);\n            let J = R.length, ne = M(\"output\", e1[0].dataType, J), be = _e(e1[0].dataType), Oe = ()=>{\n                switch(h){\n                    case 1:\n                        return \"\\n          let a_data0 = vec4<\".concat(be, \">(sub_a[word_offset], sub_a[word_offset + 1], sub_a[word_offset + 2], sub_a[word_offset + 3]);\\n          let a_data1 = vec4<\").concat(be, \">(sub_a[word_offset + 4], sub_a[word_offset + 5], sub_a[word_offset + 6], sub_a[word_offset + 7]);\");\n                    case 2:\n                        return \"\\n          let a_data0 = vec4<\".concat(be, \">(sub_a[word_offset], sub_a[word_offset + 1]);\\n          let a_data1 = vec4<\").concat(be, \">(sub_a[word_offset + 2], sub_a[word_offset + 3]);\");\n                    case 4:\n                        return \"\\n          let a_data0 = sub_a[word_offset];\\n          let a_data1 = sub_a[word_offset + 1];\";\n                    default:\n                        throw new Error(\"\".concat(h, \"-component is not supported.\"));\n                }\n            };\n            return \"\\n        var<workgroup> sub_a: array<\".concat(V.type.value, \", \").concat(S, \">;\\n        var<workgroup> inter_results: array<array<\").concat(ne.type.value, \", \").concat($, \">, \").concat(x, \">;\\n        \").concat(K.declareVariables(...Y, ne), \"\\n        \").concat(K.mainStart([\n                $,\n                x,\n                1\n            ]), \"\\n          let output_indices = \").concat(ne.offsetToIndices(\"workgroup_index * \".concat(x)), \";\\n          let col = output_indices[2];\\n          let row = output_indices[1];\\n          let batch = output_indices[0];\\n          let n_blocks_per_col = uniforms.b_shape[1];\\n          let num_tiles =  (n_blocks_per_col - 1) / \").concat(T, \" + 1;\\n\\n          // Loop over shared dimension.\\n          for (var tile: u32 = 0; tile < num_tiles; tile += 1) {\\n            let a_col_start = tile * \").concat(S, \";\\n            // load one tile A data into shared memory.\\n            for (var a_offset = local_idx; a_offset < \").concat(S, \"; a_offset += \").concat(g, \")\\n            {\\n              let a_col = a_col_start + a_offset;\\n              if (a_col < uniforms.a_shape[2])\\n              {\\n                sub_a[a_offset] = \").concat(V.getByIndices(\"\".concat(V.type.indices, \"(batch, row, a_col)\")), \";\\n              } else {\\n                sub_a[a_offset] = \").concat(V.type.value, \"(0);\\n              }\\n            }\\n            workgroupBarrier();\\n\\n            // each thread process one block\\n            let b_row = col + local_id.y;\\n            let block = tile * \").concat(T, \" + local_id.x;\\n            \").concat(ee ? \"\\n            let zero_point_bytes_per_col = (n_blocks_per_col + 1) / 2;\\n            let zero_point_byte_count = b_row * zero_point_bytes_per_col + (block >> 0x1u);\\n            let zero_point_word_index = zero_point_byte_count >> 0x2u;\\n            let zero_point_byte_offset = zero_point_byte_count & 0x3u;\\n            let zero_point_nibble_offset: u32 = block & 0x1u;\\n            let zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);\\n            let zero_point_word = \".concat(ee.getByOffset(\"zero_point_word_index\"), \" >> zero_point_bits_offset;\\n            let zero_point = \").concat(be, \"((zero_point_word) & 0xFu);\") : \"\\n            // The default zero point is 8 for unsigned 4-bit quantization.\\n            let zero_point = \".concat(be, \"(8);\"), \"\\n            let scale = \").concat(se.getByOffset(\"b_row * n_blocks_per_col + block\"), \";\\n            let b_data = \").concat(Q.getByIndices(\"\".concat(Q.type.indices, \"(b_row, block, 0)\")), \";\\n            var word_offset = local_id.x * \").concat(t.blockSize / h, \";\\n            for (var i: u32 = 0; i < \").concat(_, \"; i++) {\\n              \").concat(Oe(), \"\\n              let b_value = \").concat(_ === 1 ? \"b_data\" : \"b_data[i]\", \";\\n              let b_value_lower = unpack4xU8(b_value & 0x0F0F0F0Fu);\\n              let b_value_upper = unpack4xU8((b_value >> 4) & 0x0F0F0F0Fu);\\n              let b_quantized_values = mat2x4<\").concat(be, \">(\").concat(Array.from({\n                length: 4\n            }, ($e, le)=>\"\".concat(be, \"(b_value_lower[\").concat(le, \"]), \").concat(be, \"(b_value_upper[\").concat(le, \"])\")).join(\", \"), \");\\n              let b_dequantized_values = (b_quantized_values - mat2x4<\").concat(be, \">(\").concat(Array(8).fill(\"zero_point\").join(\",\"), \")) * scale;\\n              inter_results[local_id.y][local_id.x] += \").concat(Array.from({\n                length: 2\n            }, ($e, le)=>\"\".concat(\"dot(a_data\".concat(le, \", b_dequantized_values[\").concat(le, \"])\"))).join(\" + \"), \";\\n              word_offset += \").concat(8 / h, \";\\n            }\\n            workgroupBarrier();\\n          }\\n\\n          if (local_idx < \").concat(x, \") {\\n            var output_value: \").concat(ne.type.value, \" = \").concat(ne.type.value, \"(0);\\n            for (var b = 0u; b < \").concat($, \"; b++) {\\n              output_value += inter_results[local_idx][b];\\n            }\\n            if (col + local_idx < uniforms.output_shape[2])\\n            {\\n              \").concat(ne.setByIndices(\"\".concat(ne.type.indices, \"(batch, row, col + local_idx)\"), \"output_value\"), \"\\n            }\\n          }\\n        }\");\n        };\n        return {\n            name: \"BlockwiseMatMulNBits32\",\n            shaderCache: {\n                hint: \"\".concat(t.blockSize, \";\").concat(h, \";\").concat(_, \";\").concat($, \";\").concat(x),\n                inputDependencies: Array(e1.length).fill(\"rank\")\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: y,\n                            dataType: u\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: A\n                    },\n                    programUniforms: k\n                }),\n            getShaderSource: G\n        };\n    }, el = (e1, t)=>{\n        ch(e1.inputs, t), t.blockSize === 32 && e1.adapterInfo.isVendor(\"intel\") && e1.adapterInfo.isArchitecture(\"gen-12lp\") ? e1.compute(mh(e1.inputs, t)) : e1.compute(ph(e1.inputs, t));\n    }, tl = (e1)=>re(e1);\n});\nvar fh, hh, gh, bh, yh, _h, wh, vh, nl, ol = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    ae();\n    fh = (e1)=>{\n        if (!e1 || e1.length < 1) throw new Error(\"Too few inputs\");\n        if (e1[0].dataType !== 1 && e1[0].dataType !== 10) throw new Error(\"Input type must be float or float16.\");\n        if (e1.length >= 2) {\n            let t = e1[0].dims.length * 2 === e1[1].dims[0];\n            if (e1.length === 4 && (t = e1[3].dims[0] * 2 === e1[1].dims[0]), !t) throw new Error(\"The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].\");\n        }\n    }, hh = (e1, t, r)=>{\n        let n = \"\";\n        for(let o = t - 1; o >= 0; --o)n += \"\\n            k = i32(\".concat(e1.indicesGet(\"indices\", o), \") - \").concat(F(\"uniforms.pads\", o, r), \";\\n            if (k < 0) {\\n              break;\\n            }\\n            if (k >= i32(\").concat(F(\"uniforms.x_shape\", o, t), \")) {\\n              break;\\n            }\\n            offset += k * i32(\").concat(F(\"uniforms.x_strides\", o, t), \");\\n        \");\n        return \"\\n          value = \".concat(e1.type.value, \"(uniforms.constant_value);\\n          for (var i = 0; i < 1; i++) {\\n            var offset = 0;\\n            var k = 0;\\n            \").concat(n, \"\\n            value = x[offset];\\n          }\\n      \");\n    }, gh = (e1, t, r)=>{\n        let n = \"\";\n        for(let o = t - 1; o >= 0; --o)n += \"\\n                k = i32(\".concat(e1.indicesGet(\"indices\", o), \") - \").concat(F(\"uniforms.pads\", o, r), \";\\n                if (k < 0) {\\n                  k = -k;\\n                }\\n                {\\n                  let _2n_1 = 2 * (i32(\").concat(F(\"uniforms.x_shape\", o, t), \") - 1);\\n                  k = k % _2n_1;\\n                  if(k >= i32(\").concat(F(\"uniforms.x_shape\", o, t), \")) {\\n                    k = _2n_1 - k;\\n                  }\\n                }\\n                offset += k * i32(\").concat(F(\"uniforms.x_strides\", o, t), \");\\n            \");\n        return \"\\n              var offset = 0;\\n              var k = 0;\\n              \".concat(n, \"\\n              value = x[offset];\\n          \");\n    }, bh = (e1, t, r)=>{\n        let n = \"\";\n        for(let o = t - 1; o >= 0; --o)n += \"\\n                k = i32(\".concat(e1.indicesGet(\"indices\", o), \") - \").concat(F(\"uniforms.pads\", o, r), \";\\n                if (k < 0) {\\n                  k = 0;\\n                }\\n                if (k >= i32(\").concat(F(\"uniforms.x_shape\", o, t), \")) {\\n                  k = i32(\").concat(F(\"uniforms.x_shape\", o, t), \") - 1;\\n                }\\n                offset += k * i32(\").concat(F(\"uniforms.x_strides\", o, t), \");\\n            \");\n        return \"\\n              var offset = 0;\\n              var k = 0;\\n              \".concat(n, \"\\n              value = x[offset];\\n          \");\n    }, yh = (e1, t, r)=>{\n        let n = \"\";\n        for(let o = t - 1; o >= 0; --o)n += \"\\n                k = i32(\".concat(e1.indicesGet(\"indices\", o), \") - \").concat(F(\"uniforms.pads\", o, r), \";\\n                if (k < 0)  {\\n                  k += i32(\").concat(F(\"uniforms.x_shape\", o, t), \"]);\\n                }\\n                if (k >= i32(\").concat(F(\"uniforms.x_shape\", o, t), \")) {\\n                  k -= i32(\").concat(F(\"uniforms.x_shape\", o, t), \");\\n                }\\n                offset += k * i32(\").concat(F(\"uniforms.x_strides\", o, t), \");\\n            \");\n        return \"\\n              var offset = 0;\\n              var k = 0;\\n              \".concat(n, \"\\n              value = x[offset];\\n          \");\n    }, _h = (e1, t, r)=>{\n        switch(r.mode){\n            case 0:\n                return hh(e1, t, r.pads.length);\n            case 1:\n                return gh(e1, t, r.pads.length);\n            case 2:\n                return bh(e1, t, r.pads.length);\n            case 3:\n                return yh(e1, t, r.pads.length);\n            default:\n                throw new Error(\"Invalid mode\");\n        }\n    }, wh = (e1, t)=>{\n        let r = C.padShape(e1[0].dims.slice(), t.pads), n = e1[0].dims, o = C.size(r), i = [\n            {\n                type: 12,\n                data: o\n            },\n            {\n                type: 6,\n                data: t.pads\n            }\n        ], a = e1.length >= 3 && e1[2].data;\n        t.mode === 0 && i.push({\n            type: a ? e1[2].dataType : 1,\n            data: t.value\n        }), i.push(...N(e1[0].dims, r));\n        let d = [\n            \"rank\"\n        ], l = (p)=>{\n            let m = M(\"output\", e1[0].dataType, r.length), u = E(\"x\", e1[0].dataType, n.length), h = u.type.value, _ = _h(m, n.length, t), y = [\n                {\n                    name: \"output_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"pads\",\n                    type: \"i32\",\n                    length: t.pads.length\n                }\n            ];\n            return t.mode === 0 && y.push({\n                name: \"constant_value\",\n                type: a ? h : \"f32\"\n            }), \"\\n            \".concat(p.registerUniforms(y).declareVariables(u, m), \"\\n            \").concat(p.mainStart(), \"\\n            \").concat(p.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\"), \"\\n\\n            let indices = \").concat(m.offsetToIndices(\"global_idx\"), \";\\n\\n            var value = \").concat(h, \"(0);\\n            \").concat(_, \"\\n            output[global_idx] = value;\\n        }\");\n        };\n        return {\n            name: \"Pad\",\n            shaderCache: {\n                hint: \"\".concat(t.mode).concat(a),\n                inputDependencies: d\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: r,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(C.size(r) / 64)\n                    },\n                    programUniforms: i\n                }),\n            getShaderSource: l\n        };\n    }, vh = (e1, t)=>{\n        if (e1.length > 1) {\n            let r = e1[1].getBigInt64Array(), n = e1.length >= 3 && e1[2].data ? e1[2].dataType === 10 ? e1[2].getUint16Array()[0] : e1[2].getFloat32Array()[0] : 0, o = e1[0].dims.length, i = new Int32Array(2 * o).fill(0);\n            if (e1.length >= 4) {\n                let d = e1[3].getBigInt64Array();\n                for(let l = 0; l < d.length; l++)i[Number(d[l])] = Number(r[l]), i[Number(d[l]) + o] = Number(r[l + d.length]);\n            } else r.forEach((d, l)=>i[Number(l)] = Number(d));\n            let a = [];\n            return i.forEach((d)=>a.push(d)), {\n                mode: t.mode,\n                value: n,\n                pads: a\n            };\n        } else return t;\n    }, nl = (e1, t)=>{\n        fh(e1.inputs);\n        let r = vh(e1.inputs, t);\n        e1.compute(wh(e1.inputs, r), {\n            inputs: [\n                0\n            ]\n        });\n    };\n});\nvar tn, il, al, sl, ul, $h, xh, dl, ll, cl, pl, ml, fl, hl, gl, bl, yl, _l, wl, vl = U(()=>{\n    \"use strict\";\n    We();\n    te();\n    oe();\n    ae();\n    tn = (e1)=>{\n        if (ve.webgpu.validateInputContent && (!e1 || e1.length !== 1)) throw new Error(\"Pool ops requires 1 input.\");\n    }, il = (e1, t, r)=>{\n        let n = t.format === \"NHWC\", o = e1.dims.slice();\n        n && o.splice(1, 0, o.pop());\n        let i = Object.hasOwnProperty.call(t, \"dilations\"), a = t.kernelShape.slice(), d = t.strides.slice(), l = i ? t.dilations.slice() : [], p = t.pads.slice();\n        At.adjustPoolAttributes(r, o, a, d, l, p);\n        let m = At.computePoolOutputShape(r, o, d, l, a, p, t.autoPad), u = Object.assign({}, t);\n        i ? Object.assign(u, {\n            kernelShape: a,\n            strides: d,\n            pads: p,\n            dilations: l,\n            cacheKey: t.cacheKey\n        }) : Object.assign(u, {\n            kernelShape: a,\n            strides: d,\n            pads: p,\n            cacheKey: t.cacheKey\n        });\n        let h = m.slice();\n        return h.push(h.splice(1, 1)[0]), [\n            u,\n            n ? h : m\n        ];\n    }, al = (e1, t)=>{\n        let r = t.format === \"NHWC\", n = C.size(e1), o = C.size(t.kernelShape), i = [\n            {\n                type: 12,\n                data: n\n            },\n            {\n                type: 12,\n                data: o\n            }\n        ], a = [\n            {\n                name: \"outputSize\",\n                type: \"u32\"\n            },\n            {\n                name: \"kernelSize\",\n                type: \"u32\"\n            }\n        ];\n        if (t.kernelShape.length <= 2) {\n            let d = t.kernelShape[t.kernelShape.length - 1], l = t.strides[t.strides.length - 1], p = t.pads[t.pads.length / 2 - 1], m = t.pads[t.pads.length - 1], u = !!(p + m);\n            i.push({\n                type: 12,\n                data: d\n            }, {\n                type: 12,\n                data: l\n            }, {\n                type: 12,\n                data: p\n            }, {\n                type: 12,\n                data: m\n            }), a.push({\n                name: \"kw\",\n                type: \"u32\"\n            }, {\n                name: \"sw\",\n                type: \"u32\"\n            }, {\n                name: \"pwStart\",\n                type: \"u32\"\n            }, {\n                name: \"pwEnd\",\n                type: \"u32\"\n            });\n            let h = !1;\n            if (t.kernelShape.length === 2) {\n                let _ = t.kernelShape[t.kernelShape.length - 2], y = t.strides[t.strides.length - 2], g = t.pads[t.pads.length / 2 - 2], x = t.pads[t.pads.length - 2];\n                h = !!(g + x), i.push({\n                    type: 12,\n                    data: _\n                }, {\n                    type: 12,\n                    data: y\n                }, {\n                    type: 12,\n                    data: g\n                }, {\n                    type: 12,\n                    data: x\n                }), a.push({\n                    name: \"kh\",\n                    type: \"u32\"\n                }, {\n                    name: \"sh\",\n                    type: \"u32\"\n                }, {\n                    name: \"phStart\",\n                    type: \"u32\"\n                }, {\n                    name: \"phEnd\",\n                    type: \"u32\"\n                });\n            }\n            return [\n                i,\n                a,\n                !0,\n                u,\n                h\n            ];\n        } else {\n            if (r) throw new Error(\"Pooling with kernelShape.length > 2 is not supported for NHWC format.\");\n            let d = C.computeStrides(t.kernelShape);\n            i.push({\n                type: 12,\n                data: d\n            }, {\n                type: 12,\n                data: t.pads\n            }, {\n                type: 12,\n                data: t.strides\n            }), a.push({\n                name: \"kernelStrides\",\n                type: \"u32\",\n                length: d.length\n            }, {\n                name: \"pads\",\n                type: \"u32\",\n                length: t.pads.length\n            }, {\n                name: \"strides\",\n                type: \"u32\",\n                length: t.strides.length\n            });\n            let l = t.pads.reduce((p, m)=>p + m);\n            return [\n                i,\n                a,\n                !!l,\n                !1,\n                !1\n            ];\n        }\n    }, sl = (e1, t, r, n, o, i, a, d, l, p, m, u)=>{\n        let h = o.format === \"NHWC\", _ = t.type.value, y = M(\"output\", t.type.tensor, n);\n        if (o.kernelShape.length <= 2) {\n            let g = \"\", x = \"\", $ = \"\", v = r - (h ? 2 : 1);\n            if (m ? g = \"\\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\\n                  xIndices[\".concat(v, \"] = indices[\").concat(v, \"] * uniforms.sw - uniforms.pwStart + i;\\n                  if (xIndices[\").concat(v, \"] < 0 || xIndices[\").concat(v, \"]\\n                      >= uniforms.x_shape[\").concat(v, \"]) {\\n                    pad++;\\n                    continue;\\n                  }\\n                  let x_val = x[\").concat(t.indicesToOffset(\"xIndices\"), \"];\\n                  \").concat(i, \"\\n                }\") : g = \"\\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\\n                  xIndices[\".concat(v, \"] = indices[\").concat(v, \"] * uniforms.sw - uniforms.pwStart + i;\\n                  let x_val = x[\").concat(t.indicesToOffset(\"xIndices\"), \"];\\n                  \").concat(i, \"\\n                }\"), o.kernelShape.length === 2) {\n                let T = r - (h ? 3 : 2);\n                u ? x = \"\\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\\n                  xIndices[\".concat(T, \"] = indices[\").concat(T, \"] * uniforms.sh - uniforms.phStart + j;\\n                  if (xIndices[\").concat(T, \"] < 0 || xIndices[\").concat(T, \"] >= uniforms.x_shape[\").concat(T, \"]) {\\n                    pad += i32(uniforms.kw);\\n                    continue;\\n                  }\\n              \") : x = \"\\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\\n                  xIndices[\".concat(T, \"] = indices[\").concat(T, \"] * uniforms.sh - uniforms.phStart + j;\\n                \"), $ = \"\\n              }\\n            \";\n            }\n            return \"\\n            \".concat(e1.registerUniforms(l).declareVariables(t, y), \"\\n\\n            \").concat(e1.mainStart(), \"\\n              \").concat(e1.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\"), \"\\n\\n              let indices = \").concat(y.offsetToIndices(\"global_idx\"), \";\\n              var xIndices = \").concat(y.offsetToIndices(\"global_idx\"), \";\\n\\n              var value = \").concat(_, \"(\").concat(d, \");\\n              var pad = 0;\\n              \").concat(x, \"\\n              \").concat(g, \"\\n              \").concat($, \"\\n              \").concat(a, \"\\n\\n              output[global_idx] = value;\\n            }\");\n        } else {\n            if (h) throw new Error(\"Pooling with kernelShape.length > 2 is not supported for NHWC format.\");\n            let g = o.kernelShape.length, x = o.pads.length, $ = \"\";\n            return p ? $ = \"\\n                if (xIndices[j] >= uniforms.x_shape[j]) {\\n                  pad++;\\n                  isPad = true;\\n                  break;\\n                }\\n              }\\n              if (!isPad) {\\n                let x_val = x[\".concat(t.indicesToOffset(\"xIndices\"), \"];\\n                \").concat(i, \"\\n              }\") : $ = \"\\n              }\\n              let x_val = x[\".concat(t.indicesToOffset(\"xIndices\"), \"];\\n              \").concat(i, \"\\n            \"), \"\\n            \".concat(e1.registerUniforms(l).declareVariables(t, y), \"\\n\\n            \").concat(e1.mainStart(), \"\\n              \").concat(e1.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\"), \"\\n              let indices = \").concat(y.offsetToIndices(\"global_idx\"), \";\\n              var xIndices = \").concat(y.offsetToIndices(\"global_idx\"), \";\\n\\n              var offsets: array<u32, \").concat(g, \">;\\n\\n              var value = \").concat(_, \"(\").concat(d, \");\\n              var pad = 0;\\n              var isPad = false;\\n\\n              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {\\n                var offset = i;\\n                for (var j = 0u; j < \").concat(g - 1, \"u; j++) {\\n                  offsets[j] = offset / \").concat(F(\"uniforms.kernelStrides\", \"j\", g), \";\\n                  offset -= offsets[j] * \").concat(F(\"uniforms.kernelStrides\", \"j\", g), \";\\n                }\\n                offsets[\").concat(g - 1, \"] = offset;\\n\\n                isPad = false;\\n                for (var j = \").concat(r - g, \"u; j < \").concat(r, \"u; j++) {\\n                  xIndices[j] = indices[j] * \").concat(F(\"uniforms.strides\", \"j - \".concat(r - g, \"u\"), g), \"\\n                    + offsets[j - \").concat(r - g, \"u] - \").concat(F(\"uniforms.pads\", \"j - 2u\", x), \";\\n                  \").concat($, \"\\n              }\\n              \").concat(a, \"\\n\\n              output[global_idx] = value;\\n            }\");\n        }\n    }, ul = (e1)=>\"\".concat(e1.format, \";\").concat(e1.ceilMode, \";\").concat(e1.autoPad, \";\").concat(e1.kernelShape.length), $h = (e1)=>\"\".concat(ul(e1), \";\").concat(e1.countIncludePad), xh = (e1)=>\"\".concat(ul(e1), \";\").concat(e1.storageOrder, \";\").concat(e1.dilations), dl = (e1)=>({\n            format: e1.format,\n            autoPad: [\n                \"NOTSET\",\n                \"VALID\",\n                \"SAME_UPPER\",\n                \"SAME_LOWER\"\n            ][e1.auto_pad],\n            ceilMode: e1.ceil_mode,\n            kernelShape: e1.kernel_shape,\n            strides: e1.strides,\n            pads: e1.pads\n        }), ll = (e1, t, r, n)=>{\n        let [o, i] = il(t, n, r), a = E(\"x\", t.dataType, t.dims.length), d = a.type.value, l = \"value += x_val;\", p = \"\";\n        o.countIncludePad ? p += \"value /= \".concat(d, \"(uniforms.kernelSize);\") : p += \"value /= \".concat(d, \"(i32(uniforms.kernelSize) - pad);\");\n        let [m, u, h, _, y] = al(i, o);\n        m.push(...N(t.dims, i));\n        let g = [\n            \"rank\"\n        ];\n        return {\n            name: e1,\n            shaderCache: {\n                hint: \"\".concat(n.cacheKey, \";\").concat(h, \";\").concat(_, \";\").concat(y),\n                inputDependencies: g\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: i,\n                            dataType: t.dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(C.size(i) / 64)\n                    },\n                    programUniforms: m\n                }),\n            getShaderSource: (x)=>sl(x, a, t.dims.length, i.length, o, l, p, 0, u, h, _, y)\n        };\n    }, cl = (e1)=>{\n        let t = e1.count_include_pad !== 0, r = dl(e1);\n        if (r.ceilMode !== 0) throw new Error(\"using ceil() in shape computation is not yet supported for AveragePool\");\n        let n = {\n            countIncludePad: t,\n            ...r,\n            cacheKey: \"\"\n        };\n        return {\n            ...n,\n            cacheKey: $h(n)\n        };\n    }, pl = (e1, t)=>{\n        tn(e1.inputs), e1.compute(ll(\"AveragePool\", e1.inputs[0], !1, t));\n    }, ml = {\n        autoPad: \"\",\n        ceilMode: 0,\n        countIncludePad: !1,\n        kernelShape: [],\n        strides: [],\n        pads: [],\n        storageOrder: 0,\n        dilations: []\n    }, fl = (e1)=>{\n        let t = e1.format;\n        return {\n            format: t,\n            ...ml,\n            cacheKey: t\n        };\n    }, hl = (e1, t)=>{\n        tn(e1.inputs), e1.compute(ll(\"GlobalAveragePool\", e1.inputs[0], !0, t));\n    }, gl = (e1, t, r, n)=>{\n        let [o, i] = il(t, n, r), a = \"\\n      value = max(x_val, value);\\n    \", d = \"\", l = E(\"x\", t.dataType, t.dims.length), p = [\n            \"rank\"\n        ], [m, u, h, _, y] = al(i, o);\n        return m.push(...N(t.dims, i)), {\n            name: e1,\n            shaderCache: {\n                hint: \"\".concat(n.cacheKey, \";\").concat(h, \";\").concat(_, \";\").concat(y),\n                inputDependencies: p\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: i,\n                            dataType: t.dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(C.size(i) / 64)\n                    },\n                    programUniforms: m\n                }),\n            getShaderSource: (g)=>sl(g, l, t.dims.length, i.length, o, a, d, t.dataType === 10 ? -65504 : -1e5, u, h, _, y)\n        };\n    }, bl = (e1, t)=>{\n        tn(e1.inputs), e1.compute(gl(\"MaxPool\", e1.inputs[0], !1, t));\n    }, yl = (e1)=>{\n        let t = e1.storage_order, r = e1.dilations, n = dl(e1);\n        if (t !== 0) throw new Error(\"column major storage order is not yet supported for MaxPool\");\n        if (n.ceilMode !== 0) throw new Error(\"using ceil() in shape computation is not yet supported for MaxPool\");\n        let o = {\n            storageOrder: t,\n            dilations: r,\n            ...n,\n            cacheKey: \"\"\n        };\n        return {\n            ...o,\n            cacheKey: xh(o)\n        };\n    }, _l = (e1)=>{\n        let t = e1.format;\n        return {\n            format: t,\n            ...ml,\n            cacheKey: t\n        };\n    }, wl = (e1, t)=>{\n        tn(e1.inputs), e1.compute(gl(\"GlobalMaxPool\", e1.inputs[0], !0, t));\n    };\n});\nvar Th, Ih, $l, xl, Sl = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    Th = (e1, t)=>{\n        if (e1.length < 2 || e1.length > 3) throw new Error(\"DequantizeLinear requires 2 or 3 inputs.\");\n        if (e1.length === 3 && e1[1].dims === e1[2].dims) throw new Error(\"x-scale and x-zero-point must have the same shape.\");\n        if (e1.length === 3 && e1[0].dataType !== e1[2].dataType) throw new Error(\"x and x-zero-point must have the same data type.\");\n        if (e1[0].dataType === 6 && e1.length > 2) throw new Error(\"In the case of dequantizing int32 there is no zero point.\");\n        if (e1[1].dims.length !== 0 && e1[1].dims.length !== 1 && e1[1].dims.length !== e1[0].dims.length) throw new Error(\"scale input must be a scalar, a 1D tensor, or have the same rank as the input tensor.\");\n        if (e1.length > 2) {\n            if (e1[0].dataType !== e1[2].dataType) throw new Error(\"x and x-zero-point must have the same data type.\");\n            if (e1[1].dims.length !== e1[2].dims.length) throw new Error(\"scale and zero-point inputs must have the same rank.\");\n            if (!e1[1].dims.map((r, n)=>r === e1[2].dims[n]).reduce((r, n)=>r && n, !0)) throw new Error(\"scale and zero-point inputs must have the same shape.\");\n        }\n        if (t.blockSize > 0) {\n            if (e1[1].dims.length === 0 || e1[1].dims.length === 1 && e1[1].dims[0] === 1) throw new Error(\"blockSize must be set only for block quantization.\");\n            if (!e1[1].dims.map((o, i)=>i === t.axis || o === e1[0].dims[i]).reduce((o, i)=>o && i, !0)) throw new Error(\"For block qunatization, scale input shape to match the input shape except for the axis\");\n            if (e1[1].dims.length !== e1[0].dims.length) throw new Error(\"For block qunatization the scale input rank must be the same as the x rank.\");\n            let r = e1[0].dims[t.axis], n = e1[1].dims[t.axis];\n            if (t.blockSize < Math.ceil(r / n) || t.blockSize > Math.ceil(r / (n - 1) - 1)) throw new Error(\"blockSize must be with in the range [ceil(dI / Si), ceil(dI / (Si - 1) - 1)].\");\n        }\n    }, Ih = (e1, t)=>{\n        let r = C.normalizeAxis(t.axis, e1[0].dims.length), n = e1[0].dataType, o = n === 3, i = e1[0].dims, a = e1[1].dataType, d = C.size(i), l = n === 3 || n === 2, p = l ? [\n            Math.ceil(C.size(e1[0].dims) / 4)\n        ] : e1[0].dims, m = e1[1].dims, u = e1.length > 2 ? e1[2] : void 0, h = u ? l ? [\n            Math.ceil(C.size(u.dims) / 4)\n        ] : u.dims : void 0, _ = m.length === 0 || m.length === 1 && m[0] === 1, y = _ === !1 && m.length === 1, g = me(d), x = _ && (!l || g === 4), $ = x ? g : 1, v = x && !l ? g : 1, S = E(\"input\", l ? 12 : n, p.length, v), T = E(\"scale\", a, m.length), A = u ? E(\"zero_point\", l ? 12 : n, h.length) : void 0, k = M(\"output\", a, i.length, $), P = [\n            S,\n            T\n        ];\n        A && P.push(A);\n        let D = [\n            p,\n            m\n        ];\n        u && D.push(h);\n        let R = [\n            {\n                type: 12,\n                data: d / $\n            },\n            {\n                type: 12,\n                data: r\n            },\n            {\n                type: 12,\n                data: t.blockSize\n            },\n            ...N(...D, i)\n        ], G = (K)=>{\n            let j = [\n                {\n                    name: \"output_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"axis\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"block_size\",\n                    type: \"u32\"\n                }\n            ];\n            return \"\\n      \".concat(K.registerUniforms(j).declareVariables(...P, k), \"\\n      \").concat(K.mainStart(), \"\\n          \").concat(K.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\"), \"\\n          let output_indices = \").concat(k.offsetToIndices(\"global_idx\"), \";\\n\\n          // Set input x\\n          \").concat((()=>l ? \"\\n            let input = \".concat(S.getByOffset(\"global_idx / 4\"), \";\\n            let x_vec = \").concat(o ? \"unpack4xI8(input)\" : \"unpack4xU8(input)\", \";\\n            let x_value = \").concat($ === 1 ? \"x_vec[global_idx % 4]\" : \"x_vec\", \";\") : \"let x_value = \".concat(S.getByOffset(\"global_idx\"), \";\"))(), \";\\n\\n          // Set scale input\\n          \").concat((()=>_ ? \"let scale_value= \".concat(T.getByOffset(\"0\")) : y ? \"\\n            let scale_index = \".concat(k.indicesGet(\"output_indices\", \"uniforms.axis\"), \";\\n            let scale_value= \").concat(T.getByOffset(\"scale_index\"), \";\") : \"\\n            var scale_indices: \".concat(T.type.indices, \" = output_indices;\\n            let index = \").concat(T.indicesGet(\"scale_indices\", \"uniforms.axis\"), \" / uniforms.block_size;\\n            \").concat(T.indicesSet(\"scale_indices\", \"uniforms.axis\", \"index\"), \";\\n            let scale_value= \").concat(T.getByIndices(\"scale_indices\"), \";\"))(), \";\\n\\n          // Set zero-point input\\n          \").concat((()=>A ? _ ? l ? \"\\n                let zero_point_input = \".concat(A.getByOffset(\"0\"), \";\\n                let zero_point_vec =  \").concat(o ? \"unpack4xI8(zero_point_input)\" : \"unpack4xU8(zero_point_input)\", \";\\n                let zero_point_value= zero_point_vec[0]\") : \"let zero_point_value = \".concat(A.getByOffset(\"0\")) : y ? l ? \"\\n                let zero_point_index = \".concat(k.indicesGet(\"output_indices\", \"uniforms.axis\"), \";\\n                let zero_point_input = \").concat(A.getByOffset(\"zero_point_index / 4\"), \";\\n                let zero_point_vec =  \").concat(o ? \"unpack4xI8(zero_point_input)\" : \"unpack4xU8(zero_point_input)\", \";\\n                let zero_point_value = zero_point_vec[zero_point_index % 4]\") : \"\\n                let zero_point_index = \".concat(k.indicesGet(\"output_indices\", \"uniforms.axis\"), \";\\n                let zero_point_value = \").concat(A.getByOffset(\"zero_point_index\"), \";\") : l ? \"\\n                let zero_point_offset = \".concat(T.indicesToOffset(\"scale_indices\"), \";\\n                let zero_point_input = \").concat(A.getByOffset(\"zero_point_offset / 4\"), \";\\n                let zero_point_vec = \").concat(o ? \"unpack4xI8(zero_point_input)\" : \"unpack4xU8(zero_point_input)\", \";\\n                let zero_point_value = zero_point_vec[zero_point_offset % 4];\") : \"let zero_point_value = \".concat(A.getByIndices(\"scale_indices\"), \";\") : \"let zero_point_value = \".concat(l ? o ? \"i32\" : \"u32\" : S.type.value, \"(0);\"))(), \";\\n      // Compute and write output\\n      \").concat(k.setByOffset(\"global_idx\", \"\".concat(k.type.value, \"(x_value - zero_point_value) * scale_value\")), \";\\n      }\");\n        };\n        return {\n            name: \"DequantizeLinear\",\n            shaderCache: {\n                hint: t.cacheKey,\n                inputDependencies: A ? [\n                    \"rank\",\n                    \"rank\",\n                    \"rank\"\n                ] : [\n                    \"rank\",\n                    \"rank\"\n                ]\n            },\n            getShaderSource: G,\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: i,\n                            dataType: a\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(d / $ / 64),\n                        y: 1,\n                        z: 1\n                    },\n                    programUniforms: R\n                })\n        };\n    }, $l = (e1, t)=>{\n        Th(e1.inputs, t), e1.compute(Ih(e1.inputs, t));\n    }, xl = (e1)=>re({\n            axis: e1.axis,\n            blockSize: e1.blockSize\n        });\n});\nvar Ch, Ah, Tl, Il = U(()=>{\n    \"use strict\";\n    We();\n    te();\n    ae();\n    Ch = (e1, t, r)=>{\n        let n = e1 === t, o = e1 < t && r < 0, i = e1 > t && r > 0;\n        if (n || o || i) throw new Error(\"Range these inputs' contents are invalid.\");\n    }, Ah = (e1, t, r, n)=>{\n        let o = Math.abs(Math.ceil((t - e1) / r)), i = [\n            o\n        ], a = o, d = [\n            {\n                type: 12,\n                data: a\n            },\n            {\n                type: n,\n                data: e1\n            },\n            {\n                type: n,\n                data: r\n            },\n            ...N(i)\n        ], l = (p)=>{\n            let m = M(\"output\", n, i.length), u = m.type.value, h = [\n                {\n                    name: \"outputSize\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"start\",\n                    type: u\n                },\n                {\n                    name: \"delta\",\n                    type: u\n                }\n            ];\n            return \"\\n        \".concat(p.registerUniforms(h).declareVariables(m), \"\\n        \").concat(p.mainStart(), \"\\n        \").concat(p.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\"), \"\\n        output[global_idx] = uniforms.start + \").concat(u, \"(global_idx) * uniforms.delta;\\n      }\");\n        };\n        return {\n            name: \"Range\",\n            shaderCache: {\n                hint: \"\".concat(n)\n            },\n            getShaderSource: l,\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: i,\n                            dataType: n\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(a / 64)\n                    },\n                    programUniforms: d\n                })\n        };\n    }, Tl = (e1)=>{\n        let t = 0, r = 0, n = 0;\n        e1.inputs[0].dataType === 6 ? (t = e1.inputs[0].getInt32Array()[0], r = e1.inputs[1].getInt32Array()[0], n = e1.inputs[2].getInt32Array()[0]) : e1.inputs[0].dataType === 1 && (t = e1.inputs[0].getFloat32Array()[0], r = e1.inputs[1].getFloat32Array()[0], n = e1.inputs[2].getFloat32Array()[0]), ve.webgpu.validateInputContent && Ch(t, r, n), e1.compute(Ah(t, r, n, e1.inputs[0].dataType), {\n            inputs: []\n        });\n    };\n});\nvar kh, Eh, Cl, Al, kl = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    kh = (e1, t, r, n)=>{\n        if (e1 !== \"none\" && n !== \"i32\" && n !== \"u32\" && n !== \"f32\") throw new Error(\"Input \".concat(n, \" is not supported with reduction \").concat(e1, \".\"));\n        let o = \"{\\n                var oldValue = 0;\\n                loop {\\n                  let newValueF32 =\", i = \";\\n                  let newValue = bitcast<i32>(newValueF32);\\n                  let res = atomicCompareExchangeWeak(&\".concat(t, \", oldValue, newValue);\\n                  if res.exchanged {\\n                    break;\\n                  }\\n                  oldValue = res.old_value;\\n                }\\n              }\");\n        switch(e1){\n            case \"none\":\n                return \"\".concat(t, \"=\").concat(r, \";\");\n            case \"add\":\n                return n === \"i32\" || n === \"u32\" ? \"atomicAdd(&\".concat(t, \", bitcast<\").concat(n, \">(\").concat(r, \"));\") : \"\\n              \".concat(o, \"bitcast<\").concat(n, \">(oldValue) + (\").concat(r, \")\").concat(i);\n            case \"max\":\n                return n === \"i32\" || n === \"u32\" ? \"atomicMax(&\".concat(t, \", bitcast<\").concat(n, \">(\").concat(r, \"));\") : \"\\n                \".concat(o, \"max(bitcast<f32>(oldValue), (\").concat(r, \"))\").concat(i);\n            case \"min\":\n                return n === \"i32\" || n === \"u32\" ? \"atomicMin(&\".concat(t, \", bitcast<\").concat(n, \">(\").concat(r, \"));\") : \"\".concat(o, \"min(bitcast<\").concat(n, \">(oldValue), (\").concat(r, \"))\").concat(i);\n            case \"mul\":\n                return \"\".concat(o, \"(bitcast<\").concat(n, \">(oldValue) * (\").concat(r, \"))\").concat(i);\n            default:\n                throw new Error(\"Reduction \".concat(e1, \" is not supported.\"));\n        }\n    }, Eh = (e1, t)=>{\n        let r = e1[0].dims, n = e1[1].dims, o = r, i = 1, a = Math.ceil(C.size(n) / i), d = n[n.length - 1], l = C.sizeFromDimension(r, d), p = [\n            {\n                type: 12,\n                data: a\n            },\n            {\n                type: 12,\n                data: d\n            },\n            {\n                type: 12,\n                data: l\n            },\n            ...N(e1[1].dims, e1[2].dims, o)\n        ], m = (u)=>{\n            let h = E(\"indices\", e1[1].dataType, e1[1].dims.length), _ = E(\"updates\", e1[2].dataType, e1[2].dims.length, i), y = t.reduction !== \"none\" && t.reduction !== \"\" ? rs(\"output\", e1[0].dataType, o.length) : M(\"output\", e1[0].dataType, o.length, i);\n            return \"\\n      \".concat(u.registerUniform(\"output_size\", \"u32\").registerUniform(\"last_index_dimension\", \"u32\").registerUniform(\"num_updates_elements\", \"u32\").declareVariables(h, _, y), \"\\n      \").concat(u.mainStart(), \"\\n        \").concat(u.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\"), \"\\n  var data_offset = 0u;\\n  let indices_start = uniforms.last_index_dimension * global_idx;\\n  let indices_end = indices_start + uniforms.last_index_dimension;\\n  for (var i = indices_start; i < indices_end; i++) {\\n    var index = i32(indices[i].x);\\n    \").concat(e1[0].dims.length === 1 ? \"\\n    let element_count_dim = uniforms.output_strides;\\n    let dim_value = uniforms.output_shape;\" : \"\\n    let element_count_dim = uniforms.output_strides[i - indices_start];\\n    let dim_value = uniforms.output_shape[i - indices_start + uniforms.last_index_dimension];\", \"\\n    if (index >= 0) {\\n      if (index >= i32(dim_value)) {\\n        index = i32(dim_value - 1);\\n      }\\n    } else {\\n      if (index < -i32(dim_value)) {\\n        index = 0;\\n      } else {\\n        index += i32(dim_value);\\n      }\\n    }\\n    data_offset += u32((u32(index) * element_count_dim));\\n  }\\n\\n  for (var i = 0u; i < uniforms.num_updates_elements; i++) {\\n    let value = updates[uniforms.num_updates_elements * global_idx + i];\\n    \").concat(kh(t.reduction, \"output[data_offset + i]\", \"value\", y.type.value), \"\\n  }\\n\\n      }\");\n        };\n        return {\n            name: \"ScatterND\",\n            shaderCache: {\n                hint: \"\".concat(t.cacheKey, \"_\").concat(t.reduction),\n                inputDependencies: [\n                    \"rank\",\n                    \"rank\"\n                ]\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: o,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(a / 64)\n                    },\n                    programUniforms: p\n                }),\n            getShaderSource: m\n        };\n    }, Cl = (e1)=>re({\n            reduction: e1.reduction\n        }), Al = (e1, t)=>{\n        e1.compute(Eh(e1.inputs, t), {\n            inputs: [\n                e1.inputs[1],\n                e1.inputs[2]\n            ],\n            outputs: []\n        });\n    };\n});\nvar Ph, zh, Oh, Dh, Bh, Mh, Rh, Uh, Nh, Vh, Wh, El, Lh, Gh, Hh, Fh, qh, Pl, zl, Ol = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    Ph = (e1, t)=>{\n        if (e1.every((r)=>r > 0 || (()=>{\n                throw new Error(\"Resize requires scales input values to be positive\");\n            })), e1.length > 0) {\n            if (t.mode === \"linear\") {\n                if (!(e1.length === 2 || e1.length === 3 || e1.length === 4 && e1[0] === 1 && e1[1] === 1 || e1.length === 4 && e1[0] === 1 && e1[3] === 1 || e1.length === 5 && e1[0] === 1 && e1[1] === 1)) throw new Error(\"For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and\\n            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1\");\n            } else if (t.mode === \"cubic\" && !(e1.length === 2 || e1.length === 4 && e1[0] === 1 && e1[1] === 1 || e1.length === 4 && e1[0] === 1 && e1[3] === 1)) throw new Error(\"Resize requires scales input size to be 2 or 4 for cubic mode\");\n        }\n    }, zh = (e1, t, r)=>{\n        t.every((o)=>o >= 0 && o < r || (()=>{\n                throw new Error(\"Resize requires axes input values to be positive and less than rank\");\n            }));\n        let n = new Array(r).fill(1);\n        return t.forEach((o, i)=>n[o] = e1[i]), n;\n    }, Oh = (e1, t, r, n, o, i)=>{\n        let [a, d, l] = r > 10 ? [\n            1,\n            2,\n            3\n        ] : [\n            -1,\n            e1.length > 1 ? 1 : -1,\n            -1\n        ], p = e1[0].dims.length;\n        if (a > 0 && e1.length > a && e1[a].dims.length > 0) e1[a].getFloat32Array().forEach((m)=>i.push(m));\n        else if (t.coordinateTransformMode === \"tf_crop_and_resize\") throw new Error(\"Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize\");\n        if (d > 0 && e1.length > d && e1[d].dims.length === 1 && e1[d].dims[0] > 0) {\n            if (e1[d].getFloat32Array().forEach((m)=>n.push(m)), n.length !== 0 && n.length !== p && r >= 18 && n.length !== t.axes.length) throw new Error(\"Resize requires scales input size to be same as input rank or axes size for opset 18 and up\");\n            Ph(n, t), t.axes.length > 0 && zh(n, t.axes, p).forEach((m, u)=>n[u] = m);\n        }\n        if (l > 0 && e1.length > l && e1[l].dims.length === 1 && e1[l].dims[0] > 0 && (e1[l].getBigInt64Array().forEach((m)=>o.push(Number(m))), o.length !== 0 && o.length !== p && r >= 18 && o.length !== t.axes.length)) throw new Error(\"Resize requires sizes input size to be same as input rank or axes size for opset 18 and up\");\n        if (t.axes.length > 0) {\n            if (n.length !== 0 && n.length !== t.axes.length) throw new Error('Resize requires \"scales\" input size to be of axes rank when axes attributes is specified');\n            if (o.length !== 0 && o.length !== t.axes.length) throw new Error('Resize requires \"sizes\" input size to be of rank axes rank when axes attributes is specified');\n        }\n        if (typeof n < \"u\" && typeof o < \"u\" && n.length > 0 && o.length > p) throw new Error(\"Resize requires only of scales or sizes to be specified\");\n    }, Dh = (e1, t)=>\"fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,\\n     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> \".concat(t, \" { \") + (()=>{\n            switch(e1){\n                case \"asymmetric\":\n                    return \"return \".concat(t, \"(xResized) / \").concat(t, \"(xScale);\");\n                case \"pytorch_half_pixel\":\n                    return \"if (lengthResized > 1) {\\n                    return (\".concat(t, \"(xResized) + 0.5) / \").concat(t, \"(xScale) - 0.5;\\n                  } else {\\n                    return 0.0;\\n                  }\");\n                case \"tf_half_pixel_for_nn\":\n                    return \"return (\".concat(t, \"(xResized) + 0.5) / \").concat(t, \"(xScale);\");\n                case \"align_corners\":\n                    return \"if (lengthResized == 1) {\\n                    return 0.0;\\n                  } else {\\n                    // The whole part and the fractional part are calculated separately due to inaccuracy of floating\\n                    // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an\\n                    // offset-by-one error later in floor().\\n                    let whole = \".concat(t, \"(xResized * (lengthOriginal - 1) / (lengthResized - 1));\\n                    let fract =\\n                        \").concat(t, \"(xResized * (lengthOriginal - 1) % (lengthResized - 1)) / \").concat(t, \"(lengthResized - 1);\\n                    return whole + fract;\\n                  }\");\n                case \"tf_crop_and_resize\":\n                    return \"if (lengthResized > 1) {\\n                    return \".concat(t, \"(roiStart) * \").concat(t, \"(lengthOriginal - 1) +\\n                        (\").concat(t, \"(xResized) * \").concat(t, \"(roiEnd - roiStart) * \").concat(t, \"(lengthOriginal - 1)) /\\n                        \").concat(t, \"(lengthResized - 1);\\n                  } else {\\n                    return 0.5 * \").concat(t, \"(roiStart + roiEnd) * \").concat(t, \"(lengthOriginal - 1);\\n                  }\");\n                case \"half_pixel_symmetric\":\n                    return \"const outputWidth = \".concat(t, \"xScale * \").concat(t, \"(lengthResized);\\n                  const adjustment = \").concat(t, \"(lengthResized) / outputWidth;\\n                  const center = \").concat(t, \"(lengthOriginal) / 2;\\n                  const offset = center * (1 - adjustment);\\n                  return offset + ((\").concat(t, \"(xResized) + 0.5) / \").concat(t, \"(xScale)) - 0.5;\");\n                case \"half_pixel\":\n                    return \"return ((\".concat(t, \"(xResized) + 0.5) / \").concat(t, \"(xScale)) - 0.5;\");\n                default:\n                    throw new Error(\"Coordinate transform mode \".concat(e1, \" is not supported\"));\n            }\n        })() + \"}\", Bh = (e1, t, r)=>\"fn getNearestPixelFromOriginal(xOriginal: \".concat(r, \", isDownSample: bool) -> \").concat(r, \" {\") + (()=>{\n            switch(e1){\n                case \"round_prefer_ceil\":\n                    return \"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }\";\n                case \"floor\":\n                    return \"return floor(xOriginal);\";\n                case \"ceil\":\n                    return \"return ceil(xOriginal);\";\n                case \"round_prefer_floor\":\n                    return \"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }\";\n                case \"simple\":\n                default:\n                    if (t < 11) return \"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }\";\n                    throw new Error(\"Nearest mode \".concat(e1, \" is not supported\"));\n            }\n        })() + \"}\", Mh = (e1, t, r)=>{\n        let n = new Array(r).fill(0).concat(new Array(r).fill(1)), o = e1.length === 0 ? n : e1.slice();\n        return t.length > 0 ? (t.forEach((i, a)=>{\n            n[i] = o[a], n[a + r] = o[t.length + a];\n        }), n) : o;\n    }, Rh = (e1, t, r, n)=>{\n        let o = [];\n        if (r.length > 0) if (n.length > 0) {\n            if (e1.forEach((i)=>o.push(i)), Math.max(...n) > e1.length) throw new Error(\"axes is out of bound\");\n            n.forEach((i, a)=>o[i] = r[a]);\n        } else r.forEach((i)=>o.push(i));\n        else {\n            if (t.length === 0) throw new Error(\"Resize requires either scales or sizes.\");\n            o = e1.map((i, a)=>Math.round(i * t[a]));\n        }\n        return o;\n    }, Uh = (e1, t, r)=>{\n        let n = (()=>{\n            switch(r.keepAspectRatioPolicy){\n                case \"not_larger\":\n                    return r.axes.length > 0 ? Math.min(...r.axes.map((i)=>t[i]), Number.MAX_VALUE) : Math.min(...t, Number.MAX_VALUE);\n                case \"not_smaller\":\n                    return r.axes.length > 0 ? Math.max(...r.axes.map((i)=>t[i]), Number.MIN_VALUE) : Math.max(...t, Number.MIN_VALUE);\n                default:\n                    throw new Error(\"Keep aspect ratio policy \".concat(r.keepAspectRatioPolicy, \" is not supported\"));\n            }\n        })();\n        t.fill(1, 0, t.length);\n        let o = e1.slice();\n        return r.axes.length > 0 ? (r.axes.forEach((i)=>t[i] = n), r.axes.forEach((i)=>o[i] = Math.round(e1[i] * t[i]))) : (t.fill(n, 0, t.length), o.forEach((i, a)=>o[a] = Math.round(i * t[a]))), o;\n    }, Nh = (e1, t, r, n, o)=>\"\\n    fn calculateOriginalIndicesFromOutputIndices(output_indices: \".concat(e1.type.indices, \") -> array<\").concat(e1.type.value, \", \").concat(r.length, \"> {\\n      var original_indices: array<\").concat(e1.type.value, \", \").concat(r.length, \">;\\n      for (var i:u32 = 0; i < \").concat(r.length, \"; i++) {\\n        var output_index = \").concat(e1.indicesGet(\"output_indices\", \"i\"), \";\\n        var scale = \").concat(F(\"uniforms.scales\", \"i\", n), \";\\n        var roi_low = \").concat(F(\"uniforms.roi\", \"i\", o), \";\\n        var roi_hi = \").concat(F(\"uniforms.roi\", \"i + \".concat(t.length), o), \";\\n        if (scale == 1.0) {\\n          original_indices[i] = \").concat(e1.type.value, \"(output_index);\\n        } else {\\n          var input_shape_i = \").concat(F(\"uniforms.input_shape\", \"i\", t.length), \";\\n          var output_shape_i = \").concat(F(\"uniforms.output_shape\", \"i\", r.length), \";\\n          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\\n                                                                           input_shape_i, roi_low, roi_hi);\\n        }\\n      }\\n      return original_indices;\\n    }\"), Vh = (e1, t, r, n, o, i, a)=>\"\\n    fn calculateInputIndicesFromOutputIndices(output_indices: \".concat(t.type.indices, \") -> \").concat(e1.type.indices, \" {\\n      var input_indices: \").concat(e1.type.indices, \";\\n      for (var i:u32 = 0; i < \").concat(n.length, \"; i++) {\\n        var output_index = \").concat(t.indicesGet(\"output_indices\", \"i\"), \";\\n        var input_index: u32;\\n        var scale = \").concat(F(\"uniforms.scales\", \"i\", o), \";\\n        if (scale == 1.0) {\\n          input_index = output_index;\\n        } else {\\n          var roi_low = \").concat(F(\"uniforms.roi\", \"i\", i), \";\\n          var roi_hi = \").concat(F(\"uniforms.roi\", \"i + \".concat(r.length), i), \";\\n          var input_shape_i = \").concat(F(\"uniforms.input_shape\", \"i\", r.length), \";\\n          var output_shape_i = \").concat(F(\"uniforms.output_shape\", \"i\", n.length), \";\\n          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\\n                                                                        input_shape_i, roi_low, roi_hi);\\n          if (!\").concat(a, \" || (original_idx >= 0 && original_idx < \").concat(t.type.value, \"(input_shape_i))) {\\n            if (original_idx < 0) {\\n              input_index = 0;\\n            } else if (original_idx > \").concat(t.type.value, \"(input_shape_i - 1)) {\\n              input_index = input_shape_i - 1;\\n            } else {\\n              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));\\n            }\\n          } else {\\n            input_index = u32(original_idx);\\n          }\\n        }\\n        \").concat(e1.indicesSet(\"input_indices\", \"i\", \" input_index\"), \"\\n      }\\n      return input_indices;\\n    }\"), Wh = (e1, t)=>\"\\n    fn checkInputIndices(input_indices: \".concat(e1.type.indices, \") -> bool {\\n      for (var i:u32 = 0; i < \").concat(t.length, \"; i++) {\\n        var input_index = \").concat(e1.indicesGet(\"input_indices\", \"i\"), \";\\n        if (input_index < 0 || input_index >= \").concat(F(\"uniforms.input_shape\", \"i\", t.length), \") {\\n          return false;\\n        }\\n      }\\n      return true;\\n    }\"), El = (e1, t, r, n)=>e1.rank > n ? \"\\n    \".concat(e1.indicesSet(\"input_indices\", t, \"channel\"), \";\\n    \").concat(e1.indicesSet(\"input_indices\", r, \"batch\"), \";\\n\") : \"\", Lh = (e1, t, r, n, o)=>{\n        let [a, d, l, p] = r.length === 2 ? [\n            -1,\n            0,\n            1,\n            -1\n        ] : [\n            0,\n            2,\n            3,\n            1\n        ], m = e1.type.value;\n        return \"\\n    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> \".concat(m, \" {\\n      var input_indices: \").concat(e1.type.indices, \";\\n      \").concat(e1.indicesSet(\"input_indices\", d, \"max(0, min(row, \".concat(r[d], \" - 1))\")), \";\\n      \").concat(e1.indicesSet(\"input_indices\", l, \"max(0, min(col, \".concat(r[l], \" - 1))\")), \";\\n      \").concat(El(e1, p, a, 2), \"\\n      return \").concat(e1.getByIndices(\"input_indices\"), \";\\n    }\\n\\n    fn bilinearInterpolation(output_indices: \").concat(t.type.indices, \") -> \").concat(m, \" {\\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\\n      var row:\").concat(m, \" = originalIndices[\").concat(d, \"];\\n      var col:\").concat(m, \" = originalIndices[\").concat(l, \"];\\n      \").concat(n ? \"if (row < 0 || row > (\".concat(r[d], \" - 1) || col < 0 || col > (\").concat(r[l], \" - 1)) {\\n        return \").concat(o, \";\\n      }\") : \"\", \";\\n      row = max(0, min(row, \").concat(r[d], \" - 1));\\n      col = max(0, min(col, \").concat(r[l], \" - 1));\\n      var row1: u32 = u32(row);\\n      var col1: u32 = u32(col);\\n      var row2: u32 = u32(row + 1);\\n      var col2: u32 = u32(col + 1);\\n      var channel: u32 = \").concat(r.length > 2 ? \"u32(originalIndices[\".concat(p, \"])\") : \"0\", \";\\n      var batch: u32 =  \").concat(r.length > 2 ? \"u32(originalIndices[\".concat(a, \"])\") : \"0\", \";\\n      var x11: \").concat(m, \" = getInputValue(batch, channel, row1, col1);\\n      var x12: \").concat(m, \" = getInputValue(batch, channel, row1, col2);\\n      var x21: \").concat(m, \" = getInputValue(batch, channel, row2, col1);\\n      var x22: \").concat(m, \" = getInputValue(batch, channel, row2, col2);\\n      var dx1: \").concat(m, \" = abs(row - \").concat(m, \"(row1));\\n      var dx2: \").concat(m, \" = abs(\").concat(m, \"(row2) - row);\\n      var dy1: \").concat(m, \" = abs(col - \").concat(m, \"(col1));\\n      var dy2: \").concat(m, \" = abs(\").concat(m, \"(col2) - col);\\n      if (row1 == row2) {\\n        dx1 = 0.5;\\n        dx2 = 0.5;\\n      }\\n      if (col1 == col2) {\\n        dy1 = 0.5;\\n        dy2 = 0.5;\\n      }\\n      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);\\n    }\");\n    }, Gh = (e1, t, r, n, o, i, a, d, l, p)=>{\n        let m = r.length === 2, u = !0, [h, _] = m ? [\n            0,\n            1\n        ] : u ? [\n            2,\n            3\n        ] : [\n            1,\n            2\n        ], y = e1.type.value, g = (x)=>{\n            let $ = x === h ? \"row\" : \"col\";\n            return \"\\n      fn \".concat($, \"CubicInterpolation(input_indices: \").concat(e1.type.indices, \", output_indices: \").concat(t.type.indices, \") -> \").concat(y, \" {\\n        var output_index = \").concat(t.indicesGet(\"output_indices\", x), \";\\n        var originalIdx: \").concat(y, \" = getOriginalCoordinateFromResizedCoordinate(output_index, \").concat(o[x], \",\\n        \").concat(n[x], \", \").concat(r[x], \", \").concat(i[x], \", \").concat(i[x], \" + \").concat(r.length, \");\\n        var fractOriginalIdx: \").concat(y, \" = originalIdx - floor(originalIdx);\\n        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);\\n\\n        if (\").concat(d, \" && (originalIdx < 0 || originalIdx > (\").concat(r[x], \" - 1))) {\\n          return \").concat(l, \";\\n        }\\n        var data: array<\").concat(y, \", 4> = array<\").concat(y, \", 4>(0.0, 0.0, 0.0, 0.0);\\n        for (var i: i32 = -1; i < 3; i++) {\\n          var \").concat($, \": \").concat(y, \" = originalIdx + \").concat(y, \"(i);\\n          if (\").concat($, \" < 0 || \").concat($, \" >= \").concat(r[x], \") {\\n            \").concat((()=>p ? \"coefs[i + 1] = 0.0;\\n                        continue;\" : d ? \"return \".concat(l, \";\") : \"\".concat($, \" = max(0, min(\").concat($, \", \").concat(r[x], \" - 1));\"))(), \";\\n          }\\n        var input_indices_copy: \").concat(e1.type.indices, \" = input_indices;\\n          \").concat(e1.indicesSet(\"input_indices_copy\", x, \"u32(\".concat($, \")\")), \";\\n          data[i + 1] = \").concat(x === h ? e1.getByIndices(\"input_indices_copy\") : \"rowCubicInterpolation(input_indices_copy, output_indices)\", \";\\n        }\\n        return cubicInterpolation1D(data, coefs);\\n      }\");\n        };\n        return \"\\n    \".concat(g(h), \";\\n    \").concat(g(_), \";\\n  fn getCubicInterpolationCoefs(s: \").concat(y, \") -> array<\").concat(y, \", 4> {\\n    var absS = abs(s);\\n    var coeffs: array<\").concat(y, \", 4> = array<\").concat(y, \", 4>(0.0, 0.0, 0.0, 0.0);\\n    var oneMinusAbsS: \").concat(y, \" = 1.0 - absS;\\n    var twoMinusAbsS: \").concat(y, \" = 2.0 - absS;\\n    var onePlusAbsS: \").concat(y, \" = 1.0 + absS;\\n    coeffs[0] = ((\").concat(a, \" * onePlusAbsS - 5 * \").concat(a, \") * onePlusAbsS + 8 * \").concat(a, \") * onePlusAbsS - 4 * \").concat(a, \";\\n    coeffs[1] = ((\").concat(a, \" + 2) * absS - (\").concat(a, \" + 3)) * absS * absS + 1;\\n    coeffs[2] = ((\").concat(a, \" + 2) * oneMinusAbsS - (\").concat(a, \" + 3)) * oneMinusAbsS * oneMinusAbsS + 1;\\n    coeffs[3] = ((\").concat(a, \" * twoMinusAbsS - 5 * \").concat(a, \") * twoMinusAbsS + 8 * \").concat(a, \") * twoMinusAbsS - 4 * \").concat(a, \";\\n    return coeffs;\\n  }\\n\\n  fn cubicInterpolation1D(x: array<\").concat(y, \", 4>, coefs: array<\").concat(y, \", 4>) -> \").concat(y, \" {\\n    var coefsSum: \").concat(y, \" = coefs[0] + coefs[1] + coefs[2] + coefs[3];\\n    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;\\n  }\\n\\n  fn bicubicInterpolation(output_indices: \").concat(t.type.indices, \") -> \").concat(y, \" {\\n    var input_indices: \").concat(e1.type.indices, \" = output_indices;\\n    return colCubicInterpolation(input_indices, output_indices);\\n  }\\n    \");\n    }, Hh = (e1, t, r, n, o)=>{\n        let [a, d, l, p, m] = r.length === 3 ? [\n            -1,\n            0,\n            1,\n            2,\n            -1\n        ] : [\n            0,\n            2,\n            3,\n            4,\n            1\n        ], u = e1.type.value;\n        return \"\\n    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> \".concat(u, \" {\\n      var input_indices: \").concat(e1.type.indices, \";\\n      \").concat(e1.indicesSet(\"input_indices\", d, \"max(0, min(depth, \".concat(r[d], \" - 1))\")), \";\\n      \").concat(e1.indicesSet(\"input_indices\", l, \"max(0, min(height, \".concat(r[l], \" - 1))\")), \";\\n      \").concat(e1.indicesSet(\"input_indices\", p, \"max(0, min(width, \".concat(r[p], \" - 1))\")), \";\\n      \").concat(El(e1, m, a, 3), \"\\n      return \").concat(e1.getByIndices(\"input_indices\"), \";\\n    }\\n\\n    fn trilinearInterpolation(output_indices: \").concat(t.type.indices, \") -> \").concat(u, \" {\\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\\n      var depth:\").concat(u, \" = originalIndices[\").concat(d, \"];\\n      var height:\").concat(u, \" = originalIndices[\").concat(l, \"];\\n      var width:\").concat(u, \" = originalIndices[\").concat(p, \"];\\n      \").concat(n ? \"if (depth < 0 || depth > (\".concat(r[d], \" - 1) || height < 0 || height > (\").concat(r[l], \" - 1) || width < 0 || (width > \").concat(r[p], \" - 1)) {\\n      return \").concat(o, \";\\n        }\") : \"\", \";\\n\\n    depth = max(0, min(depth, \").concat(r[d], \" - 1));\\n      height = max(0, min(height, \").concat(r[l], \" - 1));\\n      width = max(0, min(width, \").concat(r[p], \" - 1));\\n      var depth1: u32 = u32(depth);\\n      var height1: u32 = u32(height);\\n      var width1: u32 = u32(width);\\n      var depth2: u32 = u32(depth + 1);\\n      var height2: u32 = u32(height + 1);\\n      var width2: u32 = u32(width + 1);\\n      var channel: u32 = \").concat(r.length > 3 ? \"u32(originalIndices[\".concat(m, \"])\") : \"0\", \";\\n      var batch: u32 =  \").concat(r.length > 3 ? \"u32(originalIndices[\".concat(a, \"])\") : \"0\", \";\\n\\n      var x111: \").concat(u, \" = getInputValue(batch, channel, depth1, height1, width1);\\n      var x112: \").concat(u, \" = getInputValue(batch, channel, depth1, height1, width2);\\n      var x121: \").concat(u, \" = getInputValue(batch, channel, depth1, height2, width1);\\n      var x122: \").concat(u, \" = getInputValue(batch, channel, depth1, height2, width2);\\n      var x211: \").concat(u, \" = getInputValue(batch, channel, depth2, height1, width1);\\n      var x212: \").concat(u, \" = getInputValue(batch, channel, depth2, height1, width2);\\n      var x221: \").concat(u, \" = getInputValue(batch, channel, depth2, height2, width1);\\n      var x222: \").concat(u, \" = getInputValue(batch, channel, depth2, height2, width2);\\n      var dx1: \").concat(u, \" = abs(depth - \").concat(u, \"(depth1));\\n      var dx2: \").concat(u, \" = abs(\").concat(u, \"(depth2) - depth);\\n      var dy1: \").concat(u, \" = abs(height - \").concat(u, \"(height1));\\n      var dy2: \").concat(u, \" = abs(\").concat(u, \"(height2) - height);\\n      var dz1: \").concat(u, \" = abs(width - \").concat(u, \"(width1));\\n      var dz2: \").concat(u, \" = abs(\").concat(u, \"(width2) - width);\\n      if (depth1 == depth2) {\\n        dx1 = 0.5;\\n        dx2 = 0.5;\\n      }\\n      if (height1 == height2) {\\n        dy1 = 0.5;\\n        dy2 = 0.5;\\n      }\\n      if (width1 == width2) {\\n        dz1 = 0.5;\\n        dz2 = 0.5;\\n      }\\n      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +\\n              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);\\n    }\");\n    }, Fh = (e1, t, r, n, o, i)=>{\n        let a = e1.dims, d = Mh(i, t.axes, a.length), l = Rh(a, n, o, t.axes), p = n.slice();\n        n.length === 0 && (p = a.map((v, S)=>v === 0 ? 1 : l[S] / v), t.keepAspectRatioPolicy !== \"stretch\" && (l = Uh(a, p, t)));\n        let m = M(\"output\", e1.dataType, l.length), u = E(\"input\", e1.dataType, a.length), h = C.size(l), _ = a.length === l.length && a.every((v, S)=>v === l[S]), y = t.coordinateTransformMode === \"tf_crop_and_resize\", g = t.extrapolationValue, x = u.type.value, $ = (v)=>\"\\n      \".concat(_ ? \"\" : \"\\n      \".concat(Dh(t.coordinateTransformMode, x), \";\\n      \").concat((()=>{\n                switch(t.mode){\n                    case \"nearest\":\n                        return \"\\n              \".concat(Wh(u, a), \";\\n              \").concat(Bh(t.nearestMode, r, x), \";\\n              \").concat(Vh(u, m, a, l, p.length, d.length, y), \";\\n              \");\n                    case \"linear\":\n                        return \"\\n              \".concat(Nh(m, a, l, p.length, d.length), \";\\n              \").concat((()=>{\n                            if (a.length === 2 || a.length === 4) return \"\".concat(Lh(u, m, a, y, g));\n                            if (a.length === 3 || a.length === 5) return \"\".concat(Hh(u, m, a, y, g));\n                            throw Error(\"Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.\");\n                        })(), \";\\n            \");\n                    case \"cubic\":\n                        return \"\\n            \".concat((()=>{\n                            if (a.length === 2 || a.length === 4) return \"\".concat(Gh(u, m, a, l, p, d, t.cubicCoeffA, y, t.extrapolationValue, t.excludeOutside));\n                            throw Error(\"Cubic mode only supports input dims 2 and 4 are supported in linear mode.\");\n                        })(), \";\\n            \");\n                    default:\n                        throw Error(\"Invalid resize mode\");\n                }\n            })(), \";\\n      \"), \"\\n      \").concat(v.registerUniform(\"output_size\", \"u32\").registerUniform(\"scales\", \"f32\", p.length).registerUniform(\"roi\", \"f32\", d.length).declareVariables(u, m), \"\\n      \").concat(v.mainStart(), \"\\n        \").concat(v.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\"), \"\\n        \").concat(_ ? \"output[global_idx] = input[global_idx];\" : \"\\n        let output_indices = \".concat(m.offsetToIndices(\"global_idx\"), \";\\n        var input_indices: \").concat(u.type.indices, \";\\n        \").concat((()=>{\n                switch(t.mode){\n                    case \"nearest\":\n                        return \"input_indices = calculateInputIndicesFromOutputIndices(output_indices);\\n                if (checkInputIndices(input_indices)) {\\n                  output[global_idx] = \".concat(u.getByIndices(\"input_indices\"), \";\\n                } else {\\n                  output[global_idx] = \").concat(t.extrapolationValue, \";\\n                }\");\n                    case \"linear\":\n                        return \"output[global_idx] = \".concat(a.length === 2 || a.length === 4 ? \"bilinearInterpolation\" : \"trilinearInterpolation\", \"(output_indices);\");\n                    case \"cubic\":\n                        return \"output[global_idx] = bicubicInterpolation(output_indices);\";\n                    default:\n                        throw Error(\"Unsupported resize mode: \".concat(t.mode));\n                }\n            })(), \";\\n\"), \"\\n      }\");\n        return {\n            name: \"Resize\",\n            shaderCache: {\n                hint: \"\".concat(t.cacheKey, \"|\").concat(r, \"|\").concat(p.length > 0 ? p : \"\", \"|\").concat(o.length > 0 ? o : \"\", \"|\").concat(d.length > 0 ? d : \"\", \"|\").concat(_, \"|\").concat(a),\n                inputDependencies: [\n                    \"rank\"\n                ]\n            },\n            getShaderSource: $,\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: l,\n                            dataType: e1.dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(h / 64)\n                    },\n                    programUniforms: [\n                        {\n                            type: 12,\n                            data: h\n                        },\n                        {\n                            type: 1,\n                            data: p\n                        },\n                        {\n                            type: 1,\n                            data: d\n                        },\n                        ...N(a, l)\n                    ]\n                })\n        };\n    }, qh = (e1)=>{\n        let t = e1.customDataBuffer;\n        return new Uint32Array(t, t.byteOffset, 1)[0];\n    }, Pl = (e1, t)=>{\n        let r = [], n = [], o = [], i = qh(e1);\n        if (t.antialias !== 0) throw Error(\"Only default value (0) for Antialias attribute is supported\");\n        Oh(e1.inputs, t, i, r, n, o), e1.compute(Fh(e1.inputs[0], t, i, r, n, o), {\n            inputs: [\n                0\n            ]\n        });\n    }, zl = (e1)=>{\n        let t = e1.antialias, r = e1.axes, n = e1.coordinateTransformMode, o = e1.cubicCoeffA, i = e1.excludeOutside !== 0, a = e1.extrapolationValue, d = e1.keepAspectRatioPolicy, l = e1.mode, p = e1.nearestMode === \"\" ? \"simple\" : e1.nearestMode;\n        return re({\n            antialias: t,\n            axes: r,\n            coordinateTransformMode: n,\n            cubicCoeffA: o,\n            excludeOutside: i,\n            extrapolationValue: a,\n            keepAspectRatioPolicy: d,\n            mode: l,\n            nearestMode: p\n        });\n    };\n});\nvar Kh, jh, Dl, Bl = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    Kh = (e1, t)=>{\n        let [r, n, o, i] = e1, { numHeads: a, rotaryEmbeddingDim: d } = t;\n        if (r.dims.length !== 3 && r.dims.length !== 4) throw new Error(\"Input 'x' is expected to have 3 or 4 dimensions, got \".concat(r.dims.length));\n        if (!C.areEqual(n.dims, []) && !C.areEqual(n.dims, [\n            1\n        ]) && n.dims.length !== 2) throw new Error(\"Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got \".concat(n.dims.length));\n        if (o.dims.length !== 2) throw new Error(\"Input 'cos_cache' is expected to have 2 dimensions, got \".concat(o.dims.length));\n        if (i.dims.length !== 2) throw new Error(\"Input 'sin_cache' is expected to have 2 dimensions, got \".concat(i.dims.length));\n        if (!C.areEqual(o.dims, i.dims)) throw new Error(\"Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape\");\n        if (d > 0 && a === 0) throw new Error(\"num_heads must be provided if rotary_embedding_dim is specified\");\n        let l = r.dims[0], p = r.dims[r.dims.length - 2], m = o.dims[0], u = C.sizeFromDimension(r.dims, 1) / p, h = d === 0 ? o.dims[1] * 2 : u / a;\n        if (d > h) throw new Error(\"rotary_embedding_dim must be less than or equal to head_size\");\n        if (n.dims.length === 2) {\n            if (l !== n.dims[0]) throw new Error(\"Input 'position_ids' dimension 0 should be of size batch_size, got \".concat(n.dims[0]));\n            if (p !== n.dims[1]) throw new Error(\"Input 'position_ids' dimension 1 should be of size sequence_length, got \".concat(n.dims[1]));\n        }\n        if (h / 2 !== o.dims[1] && d / 2 !== o.dims[1]) throw new Error(\"Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got \".concat(o.dims[1]));\n        if (p > m) throw new Error(\"Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported\");\n    }, jh = (e1, t)=>{\n        let { interleaved: r, numHeads: n, rotaryEmbeddingDim: o, scale: i } = t, a = e1[0].dims[0], d = C.sizeFromDimension(e1[0].dims, 1), l = e1[0].dims[e1[0].dims.length - 2], p = d / l, m = e1[2].dims[1], u = o === 0 ? m * 2 : p / n, h = new Array(a, l, p / u, u - m), _ = C.computeStrides(h), y = [\n            {\n                type: 1,\n                data: i\n            },\n            {\n                type: 12,\n                data: h\n            },\n            {\n                type: 12,\n                data: _\n            },\n            ...e1[0].dims.length === 3 ? new Array({\n                type: 12,\n                data: [\n                    d,\n                    p,\n                    u,\n                    1\n                ]\n            }) : [],\n            ...e1[0].dims.length === 4 ? new Array({\n                type: 12,\n                data: [\n                    d,\n                    u,\n                    l * u,\n                    1\n                ]\n            }) : [],\n            ...N(e1[0].dims, e1[1].dims, e1[2].dims, e1[3].dims, e1[0].dims)\n        ], g = (x)=>{\n            let $ = E(\"input\", e1[0].dataType, e1[0].dims.length), v = E(\"position_ids\", e1[1].dataType, e1[1].dims.length), S = E(\"cos_cache\", e1[2].dataType, e1[2].dims.length), T = E(\"sin_cache\", e1[3].dataType, e1[3].dims.length), A = M(\"output\", e1[0].dataType, e1[0].dims.length);\n            return x.registerUniforms([\n                {\n                    name: \"scale\",\n                    type: \"f32\"\n                },\n                {\n                    name: \"global_shape\",\n                    type: \"u32\",\n                    length: h.length\n                },\n                {\n                    name: \"global_strides\",\n                    type: \"u32\",\n                    length: _.length\n                },\n                {\n                    name: \"input_output_strides\",\n                    type: \"u32\",\n                    length: _.length\n                }\n            ]), \"\\n        \".concat(x.declareVariables($, v, S, T, A), \"\\n\\n        \").concat(x.mainStart(kt), \"\\n          let half_rotary_emb_dim = uniforms.\").concat(S.name, \"_shape[1];\\n          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;\\n          let size = uniforms.global_shape[0] * uniforms.global_strides[0];\\n          \").concat(x.guardAgainstOutOfBoundsWorkgroupSizes(\"size\"), \"\\n\\n          if (bsnh[3] < half_rotary_emb_dim) {\\n            let position_ids_idx =\\n                \").concat(v.broadcastedIndicesToOffset(\"bsnh.xy\", M(\"\", v.type.tensor, 2)), \";\\n            let position_id =\\n                u32(\").concat(v.getByOffset(\"position_ids_idx\"), \") + select(0, bsnh[1], position_ids_idx == 0);\\n            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], \").concat(r, \");\\n            let j = i + select(half_rotary_emb_dim, 1, \").concat(r, \");\\n            let re = \").concat($.getByOffset(\"i\"), \" * \").concat(S.get(\"position_id\", \"bsnh[3]\"), \" -\\n                \").concat($.getByOffset(\"j\"), \" * \").concat(T.get(\"position_id\", \"bsnh[3]\"), \";\\n            \").concat(A.setByOffset(\"i\", \"re\"), \"\\n            let im = \").concat($.getByOffset(\"i\"), \" * \").concat(T.get(\"position_id\", \"bsnh[3]\"), \" +\\n                \").concat($.getByOffset(\"j\"), \" * \").concat(S.get(\"position_id\", \"bsnh[3]\"), \";\\n            \").concat(A.setByOffset(\"j\", \"im\"), \"\\n          } else {\\n            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;\\n            \").concat(A.setByOffset(\"k\", $.getByOffset(\"k\")), \"\\n          }\\n        }\");\n        };\n        return {\n            name: \"RotaryEmbedding\",\n            shaderCache: {\n                hint: re({\n                    interleaved: r\n                }).cacheKey,\n                inputDependencies: [\n                    \"rank\",\n                    \"rank\",\n                    \"rank\",\n                    \"rank\"\n                ]\n            },\n            getShaderSource: g,\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: e1[0].dims,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(C.size(h) / kt)\n                    },\n                    programUniforms: y\n                })\n        };\n    }, Dl = (e1, t)=>{\n        Kh(e1.inputs, t), e1.compute(jh(e1.inputs, t));\n    };\n});\nvar Yh, Zh, Ml, Rl = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    ae();\n    Yh = (e1)=>{\n        if (!e1 || e1.length < 3) throw new Error(\"layerNorm requires at least 3 inputs.\");\n        let t = e1[0], r = e1[1], n = e1[2];\n        if (t.dataType !== r.dataType || t.dataType !== n.dataType) throw new Error(\"All inputs must have the same data type\");\n        if (t.dims.length !== 3 && t.dims.length !== 2) throw new Error(\"Input must be 2D or 3D\");\n        if (r.dims.length !== 3 && r.dims.length !== 2) throw new Error(\"Skip must be 2D or 3D\");\n        let o = t.dims[t.dims.length - 1], i = t.dims[t.dims.length - 2];\n        if (r.dims[r.dims.length - 1] !== o) throw new Error(\"Skip must have the same hidden size as input\");\n        if (r.dims[r.dims.length - 2] !== i) throw new Error(\"Skip must have the same sequence length as input\");\n        if (n.dims.length !== 1) throw new Error(\"Gamma must be 1D\");\n        if (n.dims[n.dims.length - 1] !== o) throw new Error(\"Gamma must have the same hidden size as input\");\n        if (e1.length > 3) {\n            let a = e1[3];\n            if (a.dims.length !== 1) throw new Error(\"Beta must be 1D\");\n            if (a.dims[a.dims.length - 1] !== o) throw new Error(\"Beta must have the same hidden size as input\");\n        }\n        if (e1.length > 4) {\n            let a = e1[4];\n            if (a.dims.length !== 1) throw new Error(\"Bias must be 1D\");\n            if (a.dims[a.dims.length - 1] !== o) throw new Error(\"Bias must have the same hidden size as input\");\n        }\n    }, Zh = (e1, t, r, n)=>{\n        let o = t.simplified, i = e1[0].dims, a = C.size(i), d = i, l = a, p = i.slice(-1)[0], m = n ? i.slice(0, -1).concat(1) : [], u = !o && e1.length > 3, h = e1.length > 4, _ = n && r > 1, y = n && r > 2, g = r > 3, x = 64, $ = me(p), v = [\n            {\n                type: 12,\n                data: l\n            },\n            {\n                type: 12,\n                data: $\n            },\n            {\n                type: 12,\n                data: p\n            },\n            {\n                type: 1,\n                data: t.epsilon\n            }\n        ], S = (A)=>{\n            let k = [\n                {\n                    name: \"output_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"components\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"hidden_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"epsilon\",\n                    type: \"f32\"\n                }\n            ], P = [\n                E(\"x\", e1[0].dataType, e1[0].dims, $),\n                E(\"skip\", e1[1].dataType, e1[1].dims, $),\n                E(\"gamma\", e1[2].dataType, e1[2].dims, $)\n            ];\n            u && P.push(E(\"beta\", e1[3].dataType, e1[3].dims, $)), h && P.push(E(\"bias\", e1[4].dataType, e1[4].dims, $)), P.push(M(\"output\", e1[0].dataType, d, $)), _ && P.push(M(\"mean_output\", 1, m)), y && P.push(M(\"inv_std_output\", 1, m)), g && P.push(M(\"input_skip_bias_sum\", e1[0].dataType, d, $));\n            let D = _e(e1[0].dataType), R = _e(1, $);\n            return \"\\n\\n      \".concat(A.registerUniforms(k).declareVariables(...P), \"\\n      var<workgroup> sum_shared : array<\").concat(R, \", \").concat(x, \">;\\n      var<workgroup> sum_squared_shared : array<\").concat(R, \", \").concat(x, \">;\\n\\n      \").concat(A.mainStart([\n                x,\n                1,\n                1\n            ]), \"\\n        let ix = local_id.x;\\n        let iy = global_id.x / \").concat(x, \";\\n\\n        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;\\n        var stride = hidden_size_vectorized / \").concat(x, \";\\n        let offset = ix * stride + iy * hidden_size_vectorized;\\n        let offset1d = stride * ix;\\n        if (ix == \").concat(x - 1, \") {\\n          stride = hidden_size_vectorized - stride * ix;\\n        }\\n        for (var i: u32 = 0; i < stride; i++) {\\n          let skip_value = skip[offset + i];\\n          let bias_value = \").concat(h ? \"bias[offset1d + i]\" : D + \"(0.0)\", \";\\n          let input_value = x[offset + i];\\n          let value = input_value + skip_value + bias_value;\\n          \").concat(g ? \"input_skip_bias_sum[offset + i] = value;\" : \"\", \"\\n          output[offset + i] = value;\\n          let f32_value = \").concat(Et(D, $, \"value\"), \";\\n          sum_shared[ix] += f32_value;\\n          sum_squared_shared[ix] += f32_value * f32_value;\\n        }\\n        workgroupBarrier();\\n\\n        var reduce_size : u32 = \").concat(x, \";\\n        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {\\n          reduce_size = curr_size + (reduce_size & 1);\\n          if (ix < curr_size) {\\n            sum_shared[ix] += sum_shared[ix + reduce_size];\\n            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];\\n          }\\n          workgroupBarrier();\\n        }\\n\\n        let sum = sum_shared[0];\\n        let square_sum = sum_squared_shared[0];\\n        let mean = \").concat(Fe(\"sum\", $), \" / f32(uniforms.hidden_size);\\n        let inv_std_dev = inverseSqrt(\").concat(Fe(\"square_sum\", $), \" / f32(uniforms.hidden_size) \").concat(o ? \"\" : \"- mean * mean\", \" + uniforms.epsilon);\\n        \").concat(_ ? \"mean_output[global_idx] = mean;\" : \"\", \"\\n        \").concat(y ? \"inv_std_output[global_idx] = inv_std_dev;\" : \"\", \"\\n\\n        for (var i: u32 = 0; i < stride; i++) {\\n          output[offset + i] = (output[offset + i] \").concat(o ? \"\" : \"- \".concat(D, \"(mean)\"), \") *\\n            \").concat(D, \"(inv_std_dev) * gamma[offset1d + i]\\n            \").concat(u ? \"+ beta[offset1d + i]\" : \"\", \";\\n        }\\n      }\");\n        }, T = [\n            {\n                dims: d,\n                dataType: e1[0].dataType\n            }\n        ];\n        return r > 1 && T.push({\n            dims: m,\n            dataType: 1\n        }), r > 2 && T.push({\n            dims: m,\n            dataType: 1\n        }), r > 3 && T.push({\n            dims: i,\n            dataType: e1[0].dataType\n        }), {\n            name: \"SkipLayerNormalization\",\n            shaderCache: {\n                hint: \"\".concat($, \";\").concat(_, \";\").concat(y, \";\").concat(g),\n                inputDependencies: e1.map((A, k)=>\"type\")\n            },\n            getShaderSource: S,\n            getRunData: ()=>({\n                    outputs: T,\n                    dispatchGroup: {\n                        x: Math.ceil(l / p)\n                    },\n                    programUniforms: v\n                })\n        };\n    }, Ml = (e1, t)=>{\n        Yh(e1.inputs);\n        let n = [\n            0\n        ];\n        e1.outputCount > 1 && n.push(-3), e1.outputCount > 2 && n.push(-3), e1.outputCount > 3 && n.push(3), e1.compute(Zh(e1.inputs, t, e1.outputCount, !1), {\n            outputs: n\n        });\n    };\n});\nvar Qh, rn, Xh, Ul, Jh, eg, Nl, Vl, Wl = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    Qh = (e1, t)=>{\n        if (!e1 || e1.length < 1) throw new Error(\"too few inputs\");\n        if (t.axes.length !== 0) {\n            if (t.axes.length !== t.starts.length || t.axes.length !== t.ends.length) throw new Error(\"axes, starts and ends must have the same length\");\n        } else if (t.starts.length !== t.ends.length) throw new Error(\"starts and ends must have the same length\");\n        e1.slice(1).forEach((r, n)=>{\n            if (e1[n + 1].dataType !== 6 && e1[n + 1].dataType !== 7) throw new Error(\"Input \".concat(n, \" must be an array of int32 or int64\"));\n        });\n    }, rn = (e1, t)=>{\n        let r = [];\n        if (e1.length > t) if (e1[t].dataType === 7) e1[t].getBigInt64Array().forEach((n)=>r.push(Number(n)));\n        else if (e1[t].dataType === 6) e1[t].getInt32Array().forEach((n)=>r.push(Number(n)));\n        else throw new Error(\"Input \".concat(t, \" must be an array of int32 or int64\"));\n        return r;\n    }, Xh = (e1, t)=>{\n        if (e1.length > 1) {\n            let r = rn(e1, 1), n = rn(e1, 2), o = rn(e1, 3);\n            return o.length === 0 && (o = [\n                ...Array(e1[0].dims.length).keys()\n            ]), re({\n                starts: r,\n                ends: n,\n                axes: o\n            });\n        } else return t;\n    }, Ul = (e1, t, r, n, o)=>{\n        let i = e1;\n        return e1 < 0 && (i += r[n[t]]), o[t] < 0 ? Math.max(0, Math.min(i, r[n[t]] - 1)) : Math.max(0, Math.min(i, r[n[t]]));\n    }, Jh = (e1, t, r)=>\"fn calculateInputIndices(output_indices: \".concat(t.type.indices, \") -> \").concat(e1.type.indices, \" {\\n          var input_indices: \").concat(e1.type.indices, \";\\n          var carry = 0u;\\n          for (var i = \").concat(r.length, \"; i >= 0; i--) {\\n            let input_shape_i = \").concat(F(\"uniforms.input_shape\", \"i\", r.length), \";\\n            let steps_i = \").concat(F(\"uniforms.steps\", \"i\", r.length), \";\\n            let signs_i = \").concat(F(\"uniforms.signs\", \"i\", r.length), \";\\n            let starts_i = \").concat(F(\"uniforms.starts\", \"i\", r.length), \";\\n            var output_index = \").concat(t.indicesGet(\"output_indices\", \"i\"), \";\\n            var input_index = output_index * steps_i + starts_i + carry;\\n            carry = input_index / input_shape_i;\\n            input_index = input_index % input_shape_i;\\n            if (signs_i < 0) {\\n              input_index = input_shape_i - input_index - 1u + starts_i;\\n            }\\n            \").concat(e1.indicesSet(\"input_indices\", \"i\", \"input_index\"), \";\\n          }\\n          return input_indices;\\n      }\"), eg = (e1, t)=>{\n        let r = e1[0].dims, n = C.size(r), o = t.axes.length > 0 ? C.normalizeAxes(t.axes, r.length) : [\n            ...Array(r.length).keys()\n        ], i = rn(e1, 4);\n        i.forEach(($)=>$ !== 0 || (()=>{\n                throw new Error(\"step cannot be 0\");\n            })), i.length === 0 && (i = Array(o.length).fill(1));\n        let a = t.starts.map(($, v)=>Ul($, v, r, o, i)), d = t.ends.map(($, v)=>Ul($, v, r, o, i));\n        if (o.length !== a.length || o.length !== d.length) throw new Error(\"start, ends and axes should have the same number of elements\");\n        if (o.length !== r.length) for(let $ = 0; $ < r.length; ++$)o.includes($) || (a.splice($, 0, 0), d.splice($, 0, r[$]), i.splice($, 0, 1));\n        let l = i.map(($)=>Math.sign($));\n        i.forEach(($, v, S)=>{\n            if ($ < 0) {\n                let T = (d[v] - a[v]) / $, A = a[v], k = A + T * i[v];\n                a[v] = k, d[v] = A, S[v] = -$;\n            }\n        });\n        let p = r.slice(0);\n        o.forEach(($, v)=>{\n            p[$] = Math.ceil((d[$] - a[$]) / i[$]);\n        });\n        let m = {\n            dims: p,\n            dataType: e1[0].dataType\n        }, u = M(\"output\", e1[0].dataType, p.length), h = E(\"input\", e1[0].dataType, e1[0].dims.length), _ = C.size(p), y = [\n            {\n                name: \"outputSize\",\n                type: \"u32\"\n            },\n            {\n                name: \"starts\",\n                type: \"u32\",\n                length: a.length\n            },\n            {\n                name: \"signs\",\n                type: \"i32\",\n                length: l.length\n            },\n            {\n                name: \"steps\",\n                type: \"u32\",\n                length: i.length\n            }\n        ], g = [\n            {\n                type: 12,\n                data: _\n            },\n            {\n                type: 12,\n                data: a\n            },\n            {\n                type: 6,\n                data: l\n            },\n            {\n                type: 12,\n                data: i\n            },\n            ...N(e1[0].dims, p)\n        ], x = ($)=>\"\\n      \".concat($.registerUniforms(y).declareVariables(h, u), \"\\n        \").concat(Jh(h, u, r), \"\\n        \").concat($.mainStart(), \"\\n          \").concat($.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\"), \"\\n          let output_indices = \").concat(u.offsetToIndices(\"global_idx\"), \";\\n          let input_indices = calculateInputIndices(output_indices);\\n          \").concat(u.setByOffset(\"global_idx\", h.getByIndices(\"input_indices\")), \"\\n      }\");\n        return {\n            name: \"Slice\",\n            shaderCache: {\n                hint: \"\".concat(l.length, \"_\").concat(a.length, \"_\").concat(i.length),\n                inputDependencies: [\n                    \"rank\"\n                ]\n            },\n            getShaderSource: x,\n            getRunData: ()=>({\n                    outputs: [\n                        m\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(n / 64)\n                    },\n                    programUniforms: g\n                })\n        };\n    }, Nl = (e1, t)=>{\n        Qh(e1.inputs, t);\n        let r = Xh(e1.inputs, t);\n        e1.compute(eg(e1.inputs, r), {\n            inputs: [\n                0\n            ]\n        });\n    }, Vl = (e1)=>{\n        let t = e1.starts, r = e1.ends, n = e1.axes;\n        return re({\n            starts: t,\n            ends: r,\n            axes: n\n        });\n    };\n});\nvar tg, rg, Ll, Gl, Hl = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    dt();\n    ae();\n    tg = (e1)=>{\n        if (!e1 || e1.length !== 1) throw new Error(\"Softmax op requires 1 input.\");\n    }, rg = (e1, t)=>{\n        let r = e1.inputs[0], n = r.dims, o = C.size(n), i = n.length, a = C.normalizeAxis(t.axis, i), d = a < n.length - 1, l, p = [];\n        d ? (p = Array.from({\n            length: i\n        }, (P, D)=>D), p[a] = i - 1, p[i - 1] = a, l = e1.compute(Pe(r, p), {\n            inputs: [\n                r\n            ],\n            outputs: [\n                -1\n            ]\n        })[0]) : l = r;\n        let m = l.dims, u = m[i - 1], h = o / u, _ = me(u), y = u / _, g = 64;\n        h === 1 && (g = 256);\n        let x = (P, D)=>D === 4 ? \"max(max(\".concat(P, \".x, \").concat(P, \".y), max(\").concat(P, \".z, \").concat(P, \".w))\") : D === 2 ? \"max(\".concat(P, \".x, \").concat(P, \".y)\") : D === 3 ? \"max(max(\".concat(P, \".x, \").concat(P, \".y), \").concat(P, \".z)\") : P, $ = E(\"x\", l.dataType, l.dims, _), v = M(\"result\", l.dataType, l.dims, _), S = $.type.value, T = _e(l.dataType) === \"f32\" ? \"var threadMax = \".concat(S, \"(-3.402823e+38f);\") : \"var threadMax = \".concat(S, \"(-65504.0h);\"), A = (P)=>\"\\n      var<workgroup> rowMaxShared : \".concat(S, \";\\n      var<workgroup> rowSumShared : \").concat(S, \";\\n      var<workgroup> threadShared : array<\").concat(S, \", \").concat(g, \">;\\n\\n      fn getValue(row: i32, col: i32, row_stride: i32) -> \").concat(S, \" {\\n        let index = row * row_stride + col;\\n        return x[index];\\n      }\\n\\n      fn setValue(row: i32, col: i32, row_stride: i32, value: \").concat(S, \") {\\n        let index = row * row_stride + col;\\n        result[index] = value;\\n      }\\n      \").concat(P.registerUniform(\"packedCols\", \"i32\").declareVariables($, v), \"\\n      \").concat(P.mainStart(g), \"\\n        let gindex = i32(global_idx);\\n        let lindex = i32(local_idx);\\n        const wg = \").concat(g, \";\\n        let row = gindex / wg;\\n        let cols = uniforms.packedCols;\\n        let row_stride : i32 = uniforms.packedCols;\\n\\n        // find the rows max\\n        \").concat(T, \"\\n        for (var col = lindex; col < cols; col += wg) {\\n          let value = getValue(row, col, row_stride);\\n          threadMax = max(threadMax, value);\\n        }\\n        if (lindex < cols) {\\n          threadShared[lindex] = threadMax;\\n        }\\n        workgroupBarrier();\\n\\n        var reduceSize = min(cols, wg);\\n        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\\n          reduceSize = currSize + (reduceSize & 1);\\n          if (lindex < currSize) {\\n            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);\\n          }\\n          workgroupBarrier();\\n        }\\n        if (lindex == 0) {\\n          rowMaxShared = \").concat(S, \"(\").concat(x(\"threadShared[0]\", _), \");\\n        }\\n        workgroupBarrier();\\n\\n        // find the rows sum\\n        var threadSum = \").concat(S, \"(0.0);\\n        for (var col = lindex; col < cols; col += wg) {\\n          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);\\n          threadSum += subExp;\\n        }\\n        threadShared[lindex] = threadSum;\\n        workgroupBarrier();\\n\\n        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {\\n          if (lindex < currSize) {\\n            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];\\n          }\\n          workgroupBarrier();\\n        }\\n        if (lindex == 0) {\\n          rowSumShared = \").concat(S, \"(\").concat(Fe(\"threadShared[0]\", _), \");\\n        }\\n        workgroupBarrier();\\n\\n        // calculate final value for each element in the row\\n        for (var col = lindex; col < cols; col += wg) {\\n          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;\\n          setValue(row, col, row_stride, value);\\n        }\\n      }\"), k = e1.compute({\n            name: \"Softmax\",\n            shaderCache: {\n                hint: \"\".concat(_, \";\").concat(g),\n                inputDependencies: [\n                    \"type\"\n                ]\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: m,\n                            dataType: l.dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: h\n                    },\n                    programUniforms: [\n                        {\n                            type: 6,\n                            data: y\n                        }\n                    ]\n                }),\n            getShaderSource: A\n        }, {\n            inputs: [\n                l\n            ],\n            outputs: [\n                d ? -1 : 0\n            ]\n        })[0];\n        d && e1.compute(Pe(k, p), {\n            inputs: [\n                k\n            ]\n        });\n    }, Ll = (e1, t)=>{\n        tg(e1.inputs), rg(e1, t);\n    }, Gl = (e1)=>re({\n            axis: e1.axis\n        });\n});\nvar Fl, ng, og, ig, ql, Kl = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    ae();\n    Fl = (e1)=>Array.from(e1.getBigInt64Array(), Number), ng = (e1)=>{\n        if (!e1 || e1.length !== 2) throw new Error(\"Tile requires 2 inputs.\");\n        if (e1[0].dataType !== 1 && e1[0].dataType !== 10 && e1[0].dataType !== 6 && e1[0].dataType !== 12) throw new Error(\"Tile only support float, float16, int32, and uint32 data types\");\n        if (e1[1].dataType !== 7) throw new Error(\"Tile `repeats` input should be of int64 data type\");\n        if (e1[1].dims.length !== 1) throw new Error(\"Tile `repeats` input should be 1-D\");\n        if (Fl(e1[1]).length !== e1[0].dims.length) throw new Error(\"Tile `repeats` input should have same number of elements as rank of input data tensor\");\n    }, og = (e1, t)=>{\n        let r = [];\n        for(let n = 0; n < e1.length; ++n)r.push(e1[n] * t[n]);\n        return r;\n    }, ig = (e1, t)=>{\n        let r = e1[0].dims, n = t !== null && t !== void 0 ? t : Fl(e1[1]), o = og(r, n), i = C.size(o), a = e1[0].dataType, d = E(\"input\", a, r.length), l = M(\"output\", a, o.length), p = (m)=>\"\\n      const inputShape = \".concat(d.indices(...r), \";\\n      \").concat(m.registerUniform(\"output_size\", \"u32\").declareVariables(d, l), \"\\n      \").concat(m.mainStart(), \"\\n      \").concat(m.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\"), \"\\n      let output_indices = \").concat(l.offsetToIndices(\"global_idx\"), \";\\n      var input_indices: \").concat(d.type.indices, \";\\n      for (var i = 0; i < \").concat(r.length, \"; i++) {\\n        let input_dim_i = \").concat(d.indicesGet(\"uniforms.input_shape\", \"i\"), \";\\n        let input_dim_value = \").concat(l.indicesGet(\"output_indices\", \"i\"), \"  % input_dim_i;\\n\\n        \").concat(d.indicesSet(\"input_indices\", \"i\", \"input_dim_value\"), \"\\n      }\\n      \").concat(l.setByOffset(\"global_idx\", d.getByIndices(\"input_indices\")), \"\\n    }\");\n        return {\n            name: \"Tile\",\n            shaderCache: {\n                hint: \"\".concat(n),\n                inputDependencies: [\n                    \"rank\"\n                ]\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: o,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(i / 64)\n                    },\n                    programUniforms: [\n                        {\n                            type: 12,\n                            data: i\n                        },\n                        ...N(e1[0].dims, o)\n                    ]\n                }),\n            getShaderSource: p\n        };\n    }, ql = (e1)=>{\n        ng(e1.inputs), e1.compute(ig(e1.inputs), {\n            inputs: [\n                0\n            ]\n        });\n    };\n});\nvar ag, sg, jl, Yl = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    ae();\n    ag = (e1, t, r, n, o)=>{\n        let i = M(\"output_data\", o, r.length, 4), a = E(\"a_data\", t[1].dataType, t[1].dims.length, 4), d = E(\"b_data\", t[2].dataType, t[2].dims.length, 4), l = E(\"c_data\", t[0].dataType, t[0].dims.length, 4), p, m = (u, h, _)=>\"select(\".concat(h, \", \").concat(u, \", \").concat(_, \")\");\n        if (!n) p = i.setByOffset(\"global_idx\", m(a.getByOffset(\"global_idx\"), d.getByOffset(\"global_idx\"), l.getByOffset(\"global_idx\")));\n        else {\n            let u = function(h, _) {\n                let y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"\";\n                let g = \"a_data[index_a\".concat(_, \"][component_a\").concat(_, \"]\"), x = \"b_data[index_b\".concat(_, \"][component_b\").concat(_, \"]\"), $ = \"bool(c_data[index_c\".concat(_, \"] & (0xffu << (component_c\").concat(_, \" * 8)))\");\n                return \"\\n            let output_indices\".concat(_, \" = \").concat(i.offsetToIndices(\"global_idx * 4u + \".concat(_, \"u\")), \";\\n            let offset_a\").concat(_, \" = \").concat(a.broadcastedIndicesToOffset(\"output_indices\".concat(_), i), \";\\n            let offset_b\").concat(_, \" = \").concat(d.broadcastedIndicesToOffset(\"output_indices\".concat(_), i), \";\\n            let offset_c\").concat(_, \" = \").concat(l.broadcastedIndicesToOffset(\"output_indices\".concat(_), i), \";\\n            let index_a\").concat(_, \" = offset_a\").concat(_, \" / 4u;\\n            let index_b\").concat(_, \" = offset_b\").concat(_, \" / 4u;\\n            let index_c\").concat(_, \" = offset_c\").concat(_, \" / 4u;\\n            let component_a\").concat(_, \" = offset_a\").concat(_, \" % 4u;\\n            let component_b\").concat(_, \" = offset_b\").concat(_, \" % 4u;\\n            let component_c\").concat(_, \" = offset_c\").concat(_, \" % 4u;\\n            \").concat(h, \"[\").concat(_, \"] = \").concat(y, \"(\").concat(m(g, x, $), \");\\n          \");\n            };\n            o === 9 ? p = \"\\n            var data = vec4<u32>(0);\\n            \".concat(u(\"data\", 0, \"u32\"), \"\\n            \").concat(u(\"data\", 1, \"u32\"), \"\\n            \").concat(u(\"data\", 2, \"u32\"), \"\\n            \").concat(u(\"data\", 3, \"u32\"), \"\\n            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));\") : p = \"\\n            \".concat(u(\"output_data[global_idx]\", 0), \"\\n            \").concat(u(\"output_data[global_idx]\", 1), \"\\n            \").concat(u(\"output_data[global_idx]\", 2), \"\\n            \").concat(u(\"output_data[global_idx]\", 3), \"\\n          \");\n        }\n        return \"\\n        \".concat(e1.registerUniform(\"vec_size\", \"u32\").declareVariables(l, a, d, i), \"\\n        \").concat(e1.mainStart(), \"\\n        \").concat(e1.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.vec_size\"), \"\\n        \").concat(p, \"\\n      }\");\n    }, sg = (e1)=>{\n        let t = e1[1].dims, r = e1[2].dims, n = e1[0].dims, o = e1[1].dataType, i = !(C.areEqual(t, r) && C.areEqual(r, n)), a = t, d = C.size(t);\n        if (i) {\n            let p = tt.calcShape(tt.calcShape(t, r, !1), n, !1);\n            if (!p) throw new Error(\"Can't perform where op on the given tensors\");\n            a = p, d = C.size(a);\n        }\n        let l = Math.ceil(d / 4);\n        return {\n            name: \"Where\",\n            shaderCache: {\n                inputDependencies: [\n                    \"rank\",\n                    \"rank\",\n                    \"rank\"\n                ]\n            },\n            getShaderSource: (p)=>ag(p, e1, a, i, o),\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: a,\n                            dataType: o\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(d / 64 / 4)\n                    },\n                    programUniforms: [\n                        {\n                            type: 12,\n                            data: l\n                        },\n                        ...N(n, t, r, a)\n                    ]\n                })\n        };\n    }, jl = (e1)=>{\n        e1.compute(sg(e1.inputs));\n    };\n});\nvar Zl, Ql = U(()=>{\n    \"use strict\";\n    Ps();\n    Fr();\n    Ds();\n    Ms();\n    vu();\n    zu();\n    Bu();\n    Qu();\n    od();\n    sd();\n    ld();\n    hd();\n    yd();\n    wd();\n    xd();\n    Id();\n    kd();\n    zd();\n    Bd();\n    Ud();\n    qd();\n    Yd();\n    Qd();\n    Jd();\n    rl();\n    So();\n    ol();\n    vl();\n    Sl();\n    Il();\n    kl();\n    Gr();\n    Ol();\n    Bl();\n    Rl();\n    Wl();\n    Hl();\n    Io();\n    Kl();\n    dt();\n    Kr();\n    Yl();\n    Zl = new Map([\n        [\n            \"Abs\",\n            [\n                Rs\n            ]\n        ],\n        [\n            \"Acos\",\n            [\n                Us\n            ]\n        ],\n        [\n            \"Acosh\",\n            [\n                Ns\n            ]\n        ],\n        [\n            \"Add\",\n            [\n                $u\n            ]\n        ],\n        [\n            \"ArgMax\",\n            [\n                Es,\n                co\n            ]\n        ],\n        [\n            \"ArgMin\",\n            [\n                ks,\n                co\n            ]\n        ],\n        [\n            \"Asin\",\n            [\n                Vs\n            ]\n        ],\n        [\n            \"Asinh\",\n            [\n                Ws\n            ]\n        ],\n        [\n            \"Atan\",\n            [\n                Ls\n            ]\n        ],\n        [\n            \"Atanh\",\n            [\n                Gs\n            ]\n        ],\n        [\n            \"Attention\",\n            [\n                zs\n            ]\n        ],\n        [\n            \"AveragePool\",\n            [\n                pl,\n                cl\n            ]\n        ],\n        [\n            \"BatchNormalization\",\n            [\n                Os\n            ]\n        ],\n        [\n            \"BiasAdd\",\n            [\n                Bs\n            ]\n        ],\n        [\n            \"BiasSplitGelu\",\n            [\n                wu\n            ]\n        ],\n        [\n            \"Cast\",\n            [\n                Fs,\n                Hs\n            ]\n        ],\n        [\n            \"Ceil\",\n            [\n                Ks\n            ]\n        ],\n        [\n            \"Clip\",\n            [\n                qs\n            ]\n        ],\n        [\n            \"Concat\",\n            [\n                Ou,\n                Du\n            ]\n        ],\n        [\n            \"Conv\",\n            [\n                wo,\n                _o\n            ]\n        ],\n        [\n            \"ConvTranspose\",\n            [\n                nd,\n                td\n            ]\n        ],\n        [\n            \"Cos\",\n            [\n                js\n            ]\n        ],\n        [\n            \"Cosh\",\n            [\n                Ys\n            ]\n        ],\n        [\n            \"CumSum\",\n            [\n                id,\n                ad\n            ]\n        ],\n        [\n            \"DepthToSpace\",\n            [\n                ud,\n                dd\n            ]\n        ],\n        [\n            \"DequantizeLinear\",\n            [\n                $l,\n                xl\n            ]\n        ],\n        [\n            \"Div\",\n            [\n                xu\n            ]\n        ],\n        [\n            \"Einsum\",\n            [\n                md,\n                fd\n            ]\n        ],\n        [\n            \"Elu\",\n            [\n                Zs,\n                Xt\n            ]\n        ],\n        [\n            \"Equal\",\n            [\n                Su\n            ]\n        ],\n        [\n            \"Erf\",\n            [\n                Qs\n            ]\n        ],\n        [\n            \"Exp\",\n            [\n                Xs\n            ]\n        ],\n        [\n            \"Expand\",\n            [\n                bd\n            ]\n        ],\n        [\n            \"FastGelu\",\n            [\n                _d\n            ]\n        ],\n        [\n            \"Floor\",\n            [\n                Js\n            ]\n        ],\n        [\n            \"FusedConv\",\n            [\n                wo,\n                _o\n            ]\n        ],\n        [\n            \"Gather\",\n            [\n                $d,\n                vd\n            ]\n        ],\n        [\n            \"GatherElements\",\n            [\n                Pd,\n                Ed\n            ]\n        ],\n        [\n            \"GatherBlockQuantized\",\n            [\n                Cd,\n                Ad\n            ]\n        ],\n        [\n            \"GatherND\",\n            [\n                Sd,\n                Td\n            ]\n        ],\n        [\n            \"Gelu\",\n            [\n                eu\n            ]\n        ],\n        [\n            \"Gemm\",\n            [\n                Dd,\n                Od\n            ]\n        ],\n        [\n            \"GlobalAveragePool\",\n            [\n                hl,\n                fl\n            ]\n        ],\n        [\n            \"GlobalMaxPool\",\n            [\n                wl,\n                _l\n            ]\n        ],\n        [\n            \"Greater\",\n            [\n                Au\n            ]\n        ],\n        [\n            \"GreaterOrEqual\",\n            [\n                Eu\n            ]\n        ],\n        [\n            \"GridSample\",\n            [\n                Md,\n                Rd\n            ]\n        ],\n        [\n            \"GroupQueryAttention\",\n            [\n                Fd\n            ]\n        ],\n        [\n            \"HardSigmoid\",\n            [\n                uu,\n                su\n            ]\n        ],\n        [\n            \"InstanceNormalization\",\n            [\n                jd\n            ]\n        ],\n        [\n            \"LayerNormalization\",\n            [\n                Zd\n            ]\n        ],\n        [\n            \"LeakyRelu\",\n            [\n                tu,\n                Xt\n            ]\n        ],\n        [\n            \"Less\",\n            [\n                ku\n            ]\n        ],\n        [\n            \"LessOrEqual\",\n            [\n                Pu\n            ]\n        ],\n        [\n            \"Log\",\n            [\n                bu\n            ]\n        ],\n        [\n            \"MatMul\",\n            [\n                Xd\n            ]\n        ],\n        [\n            \"MatMulNBits\",\n            [\n                el,\n                tl\n            ]\n        ],\n        [\n            \"MaxPool\",\n            [\n                bl,\n                yl\n            ]\n        ],\n        [\n            \"Mul\",\n            [\n                Tu\n            ]\n        ],\n        [\n            \"MultiHeadAttention\",\n            [\n                Wd,\n                Vd\n            ]\n        ],\n        [\n            \"Neg\",\n            [\n                nu\n            ]\n        ],\n        [\n            \"Not\",\n            [\n                ru\n            ]\n        ],\n        [\n            \"Pad\",\n            [\n                nl\n            ]\n        ],\n        [\n            \"Pow\",\n            [\n                Iu\n            ]\n        ],\n        [\n            \"QuickGelu\",\n            [\n                yu,\n                Xt\n            ]\n        ],\n        [\n            \"Range\",\n            [\n                Tl\n            ]\n        ],\n        [\n            \"Reciprocal\",\n            [\n                ou\n            ]\n        ],\n        [\n            \"ReduceMin\",\n            [\n                xs\n            ]\n        ],\n        [\n            \"ReduceMean\",\n            [\n                ys\n            ]\n        ],\n        [\n            \"ReduceMax\",\n            [\n                $s\n            ]\n        ],\n        [\n            \"ReduceSum\",\n            [\n                Ts\n            ]\n        ],\n        [\n            \"ReduceProd\",\n            [\n                Ss\n            ]\n        ],\n        [\n            \"ReduceL1\",\n            [\n                _s\n            ]\n        ],\n        [\n            \"ReduceL2\",\n            [\n                ws\n            ]\n        ],\n        [\n            \"ReduceLogSum\",\n            [\n                Cs\n            ]\n        ],\n        [\n            \"ReduceLogSumExp\",\n            [\n                vs\n            ]\n        ],\n        [\n            \"ReduceSumSquare\",\n            [\n                Is\n            ]\n        ],\n        [\n            \"Relu\",\n            [\n                iu\n            ]\n        ],\n        [\n            \"Resize\",\n            [\n                Pl,\n                zl\n            ]\n        ],\n        [\n            \"RotaryEmbedding\",\n            [\n                Dl\n            ]\n        ],\n        [\n            \"ScatterND\",\n            [\n                Al,\n                Cl\n            ]\n        ],\n        [\n            \"Sigmoid\",\n            [\n                au\n            ]\n        ],\n        [\n            \"Sin\",\n            [\n                du\n            ]\n        ],\n        [\n            \"Sinh\",\n            [\n                lu\n            ]\n        ],\n        [\n            \"Slice\",\n            [\n                Nl,\n                Vl\n            ]\n        ],\n        [\n            \"SkipLayerNormalization\",\n            [\n                Ml\n            ]\n        ],\n        [\n            \"Split\",\n            [\n                Ld,\n                Gd\n            ]\n        ],\n        [\n            \"Sqrt\",\n            [\n                cu\n            ]\n        ],\n        [\n            \"Softmax\",\n            [\n                Ll,\n                Gl\n            ]\n        ],\n        [\n            \"Sub\",\n            [\n                Cu\n            ]\n        ],\n        [\n            \"Tan\",\n            [\n                pu\n            ]\n        ],\n        [\n            \"Tanh\",\n            [\n                fu\n            ]\n        ],\n        [\n            \"ThresholdedRelu\",\n            [\n                gu,\n                Xt\n            ]\n        ],\n        [\n            \"Tile\",\n            [\n                ql\n            ]\n        ],\n        [\n            \"Transpose\",\n            [\n                is,\n                as\n            ]\n        ],\n        [\n            \"Where\",\n            [\n                jl\n            ]\n        ]\n    ]);\n});\nvar nn, Xl = U(()=>{\n    \"use strict\";\n    We();\n    et();\n    ae();\n    nn = class {\n        getArtifact(t) {\n            return this.repo.get(t);\n        }\n        setArtifact(t, r) {\n            this.repo.set(t, r);\n        }\n        run(t, r, n, o, i) {\n            Ue(t.programInfo.name);\n            let a = this.backend.device, d = this.backend.getComputePassEncoder();\n            this.backend.writeTimestamp(this.backend.pendingDispatchNumber * 2);\n            let l = [];\n            for (let m of r)l.push({\n                binding: l.length,\n                resource: {\n                    buffer: m.buffer\n                }\n            });\n            for (let m of n)l.push({\n                binding: l.length,\n                resource: {\n                    buffer: m.buffer\n                }\n            });\n            i && l.push({\n                binding: l.length,\n                resource: i\n            });\n            let p = a.createBindGroup({\n                layout: t.computePipeline.getBindGroupLayout(0),\n                entries: l,\n                label: t.programInfo.name\n            });\n            if (this.backend.sessionStatus === \"capturing\") {\n                let m = {\n                    kernelId: this.backend.currentKernelId,\n                    computePipeline: t.computePipeline,\n                    bindGroup: p,\n                    dispatchGroup: o\n                };\n                this.backend.capturedCommandList.get(this.backend.currentSessionId).push(m);\n            }\n            d.setPipeline(t.computePipeline), d.setBindGroup(0, p), d.dispatchWorkgroups(...o), this.backend.writeTimestamp(this.backend.pendingDispatchNumber * 2 + 1), this.backend.pendingDispatchNumber++, (this.backend.pendingDispatchNumber >= this.backend.maxDispatchNumber || this.backend.queryType === \"at-passes\") && this.backend.endComputePass(), this.backend.pendingDispatchNumber >= this.backend.maxDispatchNumber && this.backend.flush(), De(t.programInfo.name);\n        }\n        dispose() {}\n        build(t, r) {\n            Ue(t.name);\n            let n = this.backend.device, o = [];\n            [\n                {\n                    feature: \"shader-f16\",\n                    extension: \"f16\"\n                },\n                {\n                    feature: \"subgroups\",\n                    extension: \"subgroups\"\n                },\n                {\n                    feature: \"subgroups-f16\",\n                    extension: \"subgroups_f16\"\n                }\n            ].forEach((u)=>{\n                n.features.has(u.feature) && o.push(\"enable \".concat(u.extension, \";\"));\n            });\n            let a = ns(r, this.backend.device.limits), d = t.getShaderSource(a), l = \"\".concat(o.join(\"\\n\"), \"\\n\").concat(a.additionalImplementations, \"\\n\").concat(d), p = n.createShaderModule({\n                code: l,\n                label: t.name\n            });\n            ue(\"verbose\", ()=>\"[WebGPU] \".concat(t.name, \" shader code: \").concat(l));\n            let m = n.createComputePipeline({\n                compute: {\n                    module: p,\n                    entryPoint: \"main\"\n                },\n                layout: \"auto\",\n                label: t.name\n            });\n            return De(t.name), {\n                programInfo: t,\n                computePipeline: m,\n                uniformVariablesInfo: a.variablesInfo\n            };\n        }\n        normalizeDispatchGroupSize(t) {\n            let r = typeof t == \"number\" ? t : t.x, n = typeof t == \"number\" ? 1 : t.y || 1, o = typeof t == \"number\" ? 1 : t.z || 1, i = this.backend.device.limits.maxComputeWorkgroupsPerDimension;\n            if (r <= i && n <= i && o <= i) return [\n                r,\n                n,\n                o\n            ];\n            let a = r * n * o, d = Math.ceil(Math.sqrt(a));\n            if (d > i) {\n                if (d = Math.ceil(Math.cbrt(a)), d > i) throw new Error(\"Total dispatch size exceeds WebGPU maximum.\");\n                return [\n                    d,\n                    d,\n                    d\n                ];\n            } else return [\n                d,\n                d,\n                1\n            ];\n        }\n        constructor(t){\n            this.backend = t;\n            this.repo = new Map, this.attributesBound = !1;\n        }\n    };\n});\nvar ug, dg, Co, Ao, on, Jl = U(()=>{\n    \"use strict\";\n    We();\n    te();\n    et();\n    Jn();\n    Ja();\n    Ql();\n    Xl();\n    ug = (e1, t)=>{\n        if (t.length !== e1.length) throw new Error(\"inputDependencies length \".concat(t.length, \" is not equal to inputTensors length \").concat(e1.length, \".\"));\n        let r = [];\n        for(let n = 0; n < e1.length; ++n){\n            let o = e1[n].dataType;\n            switch(t[n]){\n                case \"none\":\n                    {\n                        r.push(\"\");\n                        break;\n                    }\n                case \"type\":\n                    {\n                        r.push(\"\".concat(o));\n                        break;\n                    }\n                case \"rank\":\n                    {\n                        let i = e1[n].dims.length;\n                        r.push(\"\".concat(o, \";\").concat(i));\n                        break;\n                    }\n                case \"dims\":\n                    {\n                        let i = e1[n].dims.join(\",\");\n                        r.push(\"\".concat(o, \";\").concat(i));\n                        break;\n                    }\n                default:\n                    throw new Error(\"unsupported input dependency: \".concat(t[n]));\n            }\n        }\n        return r.join(\"|\");\n    }, dg = (e1, t, r)=>{\n        var _e_shaderCache, _e_shaderCache1;\n        let n = e1.name;\n        var _e_shaderCache_inputDependencies;\n        return ((_e_shaderCache = e1.shaderCache) === null || _e_shaderCache === void 0 ? void 0 : _e_shaderCache.hint) && (n += \"[\" + e1.shaderCache.hint + \"]\"), n += \":\" + r + \":\".concat(ug(t, (_e_shaderCache_inputDependencies = (_e_shaderCache1 = e1.shaderCache) === null || _e_shaderCache1 === void 0 ? void 0 : _e_shaderCache1.inputDependencies) !== null && _e_shaderCache_inputDependencies !== void 0 ? _e_shaderCache_inputDependencies : new Array(t.length).fill(\"dims\"))), n;\n    }, Co = class {\n        isArchitecture(t) {\n            return this.architecture === t;\n        }\n        isVendor(t) {\n            return this.vendor === t;\n        }\n        constructor(t){\n            t && (this.architecture = t.architecture, this.vendor = t.vendor);\n        }\n    }, Ao = class {\n        constructor(t){\n            this.subgroupsSupported = t.features.has(\"subgroups\"), this.subgroupsF16Supported = t.features.has(\"subgroups\");\n            let r = t.limits;\n            !this.subgroupsSupported || !r.minSubgroupSize || !r.maxSubgroupSize ? this.subgroupSizeRange = void 0 : this.subgroupSizeRange = [\n                r.minSubgroupSize,\n                r.maxSubgroupSize\n            ];\n        }\n    }, on = class {\n        get currentKernelCustomData() {\n            if (this.currentKernelId === null) throw new Error(\"currentKernelCustomData(): currentKernelId is null. (should not happen)\");\n            let t = this.kernelCustomData.get(this.currentKernelId);\n            return t || (t = {}, this.kernelCustomData.set(this.currentKernelId, t)), t;\n        }\n        async initialize(t, r) {\n            this.env = t;\n            let n = [], o = {\n                requiredLimits: {\n                    maxComputeWorkgroupStorageSize: r.limits.maxComputeWorkgroupStorageSize,\n                    maxComputeWorkgroupsPerDimension: r.limits.maxComputeWorkgroupsPerDimension,\n                    maxStorageBufferBindingSize: r.limits.maxStorageBufferBindingSize,\n                    maxBufferSize: r.limits.maxBufferSize,\n                    maxComputeInvocationsPerWorkgroup: r.limits.maxComputeInvocationsPerWorkgroup,\n                    maxComputeWorkgroupSizeX: r.limits.maxComputeWorkgroupSizeX,\n                    maxComputeWorkgroupSizeY: r.limits.maxComputeWorkgroupSizeY,\n                    maxComputeWorkgroupSizeZ: r.limits.maxComputeWorkgroupSizeZ\n                },\n                requiredFeatures: n\n            }, i = (a)=>r.features.has(a) && n.push(a) && !0;\n            i(\"chromium-experimental-timestamp-query-inside-passes\") || i(\"timestamp-query\"), i(\"shader-f16\"), i(\"subgroups\") && i(\"subgroups-f16\"), this.device = await r.requestDevice(o), this.deviceInfo = new Ao(this.device), this.adapterInfo = new Co(r.info || await r.requestAdapterInfo()), this.gpuDataManager = Xa(this), this.programManager = new nn(this), this.kernels = new Map, this.kernelPersistentData = new Map, this.kernelCustomData = new Map, Rr(t.logLevel, !!t.debug), this.device.onuncapturederror = (a)=>{\n                a.error instanceof GPUValidationError && console.error(\"An uncaught WebGPU validation error was raised: \".concat(a.error.message));\n            }, Object.defineProperty(this.env.webgpu, \"device\", {\n                value: this.device,\n                writable: !1,\n                enumerable: !0,\n                configurable: !1\n            }), Object.defineProperty(this.env.webgpu, \"adapter\", {\n                value: r,\n                writable: !1,\n                enumerable: !0,\n                configurable: !1\n            }), this.setQueryType();\n        }\n        dispose() {\n            typeof this.querySet < \"u\" && this.querySet.destroy(), this.gpuDataManager.dispose();\n        }\n        getCommandEncoder() {\n            return this.commandEncoder || (this.commandEncoder = this.device.createCommandEncoder()), this.commandEncoder;\n        }\n        getComputePassEncoder() {\n            if (!this.computePassEncoder) {\n                let t = this.getCommandEncoder(), r = {};\n                this.queryType === \"at-passes\" && (r.timestampWrites = {\n                    querySet: this.querySet,\n                    beginningOfPassWriteIndex: this.pendingDispatchNumber * 2,\n                    endOfPassWriteIndex: this.pendingDispatchNumber * 2 + 1\n                }), this.computePassEncoder = t.beginComputePass(r);\n            }\n            return this.computePassEncoder;\n        }\n        endComputePass() {\n            this.computePassEncoder && (this.computePassEncoder.end(), this.computePassEncoder = null);\n        }\n        flush() {\n            if (!this.commandEncoder) return;\n            Ue(), this.endComputePass();\n            let t;\n            this.queryType !== \"none\" && (this.commandEncoder.resolveQuerySet(this.querySet, 0, this.pendingDispatchNumber * 2, this.queryResolveBuffer, 0), t = this.device.createBuffer({\n                size: this.pendingDispatchNumber * 2 * 8,\n                usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST\n            }), this.pendingQueries.set(t, this.pendingKernels), this.pendingKernels = [], this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer, 0, t, 0, this.pendingDispatchNumber * 2 * 8)), this.device.queue.submit([\n                this.commandEncoder.finish()\n            ]), this.gpuDataManager.refreshPendingBuffers(), this.commandEncoder = null, this.pendingDispatchNumber = 0, this.queryType !== \"none\" && t.mapAsync(GPUMapMode.READ).then(()=>{\n                let r = new BigUint64Array(t.getMappedRange()), n = this.pendingQueries.get(t);\n                for(let o = 0; o < r.length / 2; o++){\n                    var _this_env_webgpu_profiling;\n                    let i = n[o], a = i.kernelId, d = this.kernels.get(a), l = d.kernelType, p = d.kernelName, m = i.programName, u = i.inputTensorViews, h = i.outputTensorViews, _ = r[o * 2], y = r[o * 2 + 1];\n                    typeof this.queryTimeBase > \"u\" && (this.queryTimeBase = _);\n                    let g = Number(_ - this.queryTimeBase), x = Number(y - this.queryTimeBase);\n                    if (!Number.isSafeInteger(g) || !Number.isSafeInteger(x)) throw new RangeError(\"incorrect timestamp range\");\n                    if ((_this_env_webgpu_profiling = this.env.webgpu.profiling) === null || _this_env_webgpu_profiling === void 0 ? void 0 : _this_env_webgpu_profiling.ondata) this.env.webgpu.profiling.ondata({\n                        version: 1,\n                        inputsMetadata: u.map(($)=>({\n                                dims: $.dims,\n                                dataType: bt($.dataType)\n                            })),\n                        outputsMetadata: h.map(($)=>({\n                                dims: $.dims,\n                                dataType: bt($.dataType)\n                            })),\n                        kernelId: a,\n                        kernelType: l,\n                        kernelName: p,\n                        programName: m,\n                        startTime: g,\n                        endTime: x\n                    });\n                    else {\n                        let $ = \"\";\n                        u.forEach((S, T)=>{\n                            $ += \"input[\".concat(T, \"]: [\").concat(S.dims, \"] | \").concat(bt(S.dataType), \", \");\n                        });\n                        let v = \"\";\n                        h.forEach((S, T)=>{\n                            v += \"output[\".concat(T, \"]: [\").concat(S.dims, \"] | \").concat(bt(S.dataType), \", \");\n                        }), console.log('[profiling] kernel \"'.concat(a, \"|\").concat(l, \"|\").concat(p, \"|\").concat(m, '\" ').concat($).concat(v, \"execution time: \").concat(x - g, \" ns\"));\n                    }\n                    wr(\"GPU\", \"\".concat(m, \"::\").concat(_, \"::\").concat(y));\n                }\n                t.unmap(), this.pendingQueries.delete(t);\n            }), De();\n        }\n        run(t, r, n, o, i, a) {\n            Ue(t.name);\n            let d = [];\n            for(let S = 0; S < r.length; ++S){\n                let T = r[S].data;\n                if (T === 0) continue;\n                let A = this.gpuDataManager.get(T);\n                if (!A) throw new Error(\"no GPU data for input: \".concat(T));\n                d.push(A);\n            }\n            let { outputs: l, dispatchGroup: p, programUniforms: m } = t.getRunData(r), u = n.length === 0 ? l.map((S, T)=>T) : n;\n            if (u.length !== l.length) throw new Error(\"Output size \".concat(u.length, \" must be equal to \").concat(l.length, \".\"));\n            let h = [], _ = [];\n            for(let S = 0; S < l.length; ++S){\n                if (!Number.isInteger(u[S]) || u[S] < -3 || u[S] >= a) throw new Error(\"Invalid output index: \".concat(u[S]));\n                if (u[S] === -3) continue;\n                let T = u[S] === -1, A = u[S] === -2, k = T || A ? i(l[S].dataType, l[S].dims) : o(u[S], l[S].dataType, l[S].dims);\n                if (h.push(k), k.data === 0) continue;\n                let P = this.gpuDataManager.get(k.data);\n                if (!P) throw new Error(\"no GPU data for output: \".concat(k.data));\n                if (T && this.temporaryData.push(P), A) {\n                    let D = this.kernelPersistentData.get(this.currentKernelId);\n                    D || (D = [], this.kernelPersistentData.set(this.currentKernelId, D)), D.push(P);\n                }\n                _.push(P);\n            }\n            if (d.length !== r.length || _.length !== h.length) {\n                if (_.length === 0) return De(t.name), h;\n                throw new Error(\"Program \".concat(t.name, \" has zero-sized tensor(s) in inputs or outputs. This is not supported now.\"));\n            }\n            let y;\n            if (m) {\n                let S = 0, T = [];\n                m.forEach((D)=>{\n                    let R = typeof D.data == \"number\" ? [\n                        D.data\n                    ] : D.data;\n                    if (R.length === 0) return;\n                    let G = D.type === 10 ? 2 : 4, K, j;\n                    D.type === 10 ? (j = R.length > 4 ? 16 : R.length > 2 ? 8 : R.length * G, K = R.length > 4 ? 16 : G * R.length) : (j = R.length <= 2 ? R.length * G : 16, K = 16), S = Math.ceil(S / j) * j, T.push(S);\n                    let V = D.type === 10 ? 8 : 4;\n                    S += R.length > 4 ? Math.ceil(R.length / V) * K : R.length * G;\n                });\n                let A = 16;\n                S = Math.ceil(S / A) * A;\n                let k = new ArrayBuffer(S);\n                m.forEach((D, R)=>{\n                    let G = T[R], K = typeof D.data == \"number\" ? [\n                        D.data\n                    ] : D.data;\n                    if (D.type === 6) new Int32Array(k, G, K.length).set(K);\n                    else if (D.type === 12) new Uint32Array(k, G, K.length).set(K);\n                    else if (D.type === 10) new Uint16Array(k, G, K.length).set(K);\n                    else if (D.type === 1) new Float32Array(k, G, K.length).set(K);\n                    else throw new Error(\"Unsupported uniform type: \".concat(bt(D.type)));\n                });\n                let P = this.gpuDataManager.create(S, GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM);\n                this.device.queue.writeBuffer(P.buffer, 0, k, 0, S), this.gpuDataManager.release(P.id), y = {\n                    offset: 0,\n                    size: S,\n                    buffer: P.buffer\n                };\n            }\n            let g = this.programManager.normalizeDispatchGroupSize(p), x = g[1] === 1 && g[2] === 1, $ = dg(t, r, x), v = this.programManager.getArtifact($);\n            if (v || (v = this.programManager.build(t, g), this.programManager.setArtifact($, v), ue(\"info\", ()=>\"[artifact] key: \".concat($, \", programName: \").concat(t.name))), m && v.uniformVariablesInfo) {\n                if (m.length !== v.uniformVariablesInfo.length) throw new Error(\"Uniform variables count mismatch: expect \".concat(v.uniformVariablesInfo.length, \", got \").concat(m.length, ' in program \"').concat(v.programInfo.name, '\".'));\n                for(let S = 0; S < m.length; S++){\n                    let T = m[S], A = T.type, k = typeof T.data == \"number\" ? 1 : T.data.length, [P, D] = v.uniformVariablesInfo[S];\n                    if (A !== P || k !== D) throw new Error(\"Uniform variable \".concat(S, \" mismatch: expect type \").concat(P, \" with size \").concat(D, \", got type \").concat(A, \" with size \").concat(k, ' in program \"').concat(v.programInfo.name, '\".'));\n                }\n            }\n            if (ue(\"info\", ()=>'[ProgramManager] run \"'.concat(t.name, '\" (key=').concat($, \") with \").concat(g[0], \"x\").concat(g[1], \"x\").concat(g[2])), this.queryType !== \"none\" || this.sessionStatus === \"capturing\") {\n                let S = {\n                    kernelId: this.currentKernelId,\n                    programName: v.programInfo.name,\n                    inputTensorViews: r,\n                    outputTensorViews: h\n                };\n                this.pendingKernels.push(S), this.sessionStatus === \"capturing\" && this.capturedPendingKernels.get(this.currentSessionId).push(S);\n            }\n            return this.programManager.run(v, d, _, g, y), De(t.name), h;\n        }\n        upload(t, r) {\n            this.gpuDataManager.upload(t, r);\n        }\n        memcpy(t, r) {\n            this.gpuDataManager.memcpy(t, r);\n        }\n        async download(t, r) {\n            await this.gpuDataManager.download(t, r);\n        }\n        alloc(t) {\n            return this.gpuDataManager.create(t).id;\n        }\n        free(t) {\n            return this.gpuDataManager.release(t);\n        }\n        createKernel(t, r, n, o) {\n            let i = Zl.get(t);\n            if (!i) throw new Error(\"kernel not implemented: \".concat(t));\n            let a = {\n                kernelType: t,\n                kernelName: o,\n                kernelEntry: i[0],\n                attributes: [\n                    i[1],\n                    n\n                ]\n            };\n            this.kernels.set(r, a);\n        }\n        releaseKernel(t) {\n            let r = this.kernelPersistentData.get(t);\n            if (r) {\n                for (let n of r)this.gpuDataManager.release(n.id);\n                this.kernelPersistentData.delete(t);\n            }\n            this.kernelCustomData.delete(t), this.kernels.delete(t);\n        }\n        computeKernel(t, r, n) {\n            let o = this.kernels.get(t);\n            if (!o) throw new Error(\"kernel not created: \".concat(t));\n            let i = o.kernelType, a = o.kernelName, d = o.kernelEntry, l = o.attributes;\n            if (this.currentKernelId !== null) throw new Error('kernel \"['.concat(i, \"] \").concat(a, '\" is not allowed to be called recursively'));\n            this.currentKernelId = t, l[0] && (l[1] = l[0](l[1]), l[0] = void 0), ue(\"info\", ()=>'[WebGPU] Start to run kernel \"['.concat(i, \"] \").concat(a, '\"...'));\n            let p = this.env.debug;\n            this.temporaryData = [];\n            try {\n                return p && this.device.pushErrorScope(\"validation\"), d(r, l[1]), 0;\n            } catch (m) {\n                return n.push(Promise.resolve('[WebGPU] Kernel \"['.concat(i, \"] \").concat(a, '\" failed. ').concat(m))), 1;\n            } finally{\n                p && n.push(this.device.popErrorScope().then((m)=>m ? 'GPU validation error for kernel \"['.concat(i, \"] \").concat(a, '\": ').concat(m.message) : null));\n                for (let m of this.temporaryData)this.gpuDataManager.release(m.id);\n                this.temporaryData = [], this.currentKernelId = null;\n            }\n        }\n        registerBuffer(t, r, n, o) {\n            let i = this.sessionExternalDataMapping.get(t);\n            i || (i = new Map, this.sessionExternalDataMapping.set(t, i));\n            let a = i.get(r), d = this.gpuDataManager.registerExternalBuffer(n, o, a);\n            return i.set(r, [\n                d,\n                n\n            ]), d;\n        }\n        unregisterBuffers(t) {\n            let r = this.sessionExternalDataMapping.get(t);\n            r && (r.forEach((n)=>this.gpuDataManager.unregisterExternalBuffer(n[0])), this.sessionExternalDataMapping.delete(t));\n        }\n        getBuffer(t) {\n            let r = this.gpuDataManager.get(t);\n            if (!r) throw new Error(\"no GPU data for buffer: \".concat(t));\n            return r.buffer;\n        }\n        createDownloader(t, r, n) {\n            return async ()=>{\n                let o = await no(this, t, r);\n                return Ur(o.buffer, n);\n            };\n        }\n        writeTimestamp(t) {\n            this.queryType === \"inside-passes\" && this.computePassEncoder.writeTimestamp(this.querySet, t);\n        }\n        setQueryType() {\n            var _this_env_webgpu_profiling;\n            this.queryType = \"none\", (((_this_env_webgpu_profiling = this.env.webgpu.profiling) === null || _this_env_webgpu_profiling === void 0 ? void 0 : _this_env_webgpu_profiling.mode) === \"default\" || (typeof this.env.trace > \"u\" ? this.env.wasm.trace : this.env.trace)) && (this.device.features.has(\"chromium-experimental-timestamp-query-inside-passes\") ? this.queryType = \"inside-passes\" : this.device.features.has(\"timestamp-query\") && (this.queryType = \"at-passes\"), this.queryType !== \"none\" && typeof this.querySet > \"u\" && (this.querySet = this.device.createQuerySet({\n                type: \"timestamp\",\n                count: this.maxDispatchNumber * 2\n            }), this.queryResolveBuffer = this.device.createBuffer({\n                size: this.maxDispatchNumber * 2 * 8,\n                usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.QUERY_RESOLVE\n            })));\n        }\n        captureBegin() {\n            ue(\"info\", \"captureBegin\"), this.capturedCommandList.get(this.currentSessionId) || this.capturedCommandList.set(this.currentSessionId, []), this.capturedPendingKernels.get(this.currentSessionId) || this.capturedPendingKernels.set(this.currentSessionId, []), this.flush(), this.sessionStatus = \"capturing\";\n        }\n        captureEnd() {\n            ue(\"info\", \"captureEnd\"), this.flush(), this.sessionStatus = \"default\";\n        }\n        replay() {\n            ue(\"info\", \"replay\"), this.sessionStatus = \"replaying\";\n            let t = this.capturedCommandList.get(this.currentSessionId), r = this.capturedPendingKernels.get(this.currentSessionId), n = t.length;\n            this.pendingKernels = [];\n            for(let o = 0; o < n; o++){\n                let i = this.getComputePassEncoder(), a = t[o];\n                this.writeTimestamp(this.pendingDispatchNumber * 2), i.setPipeline(a.computePipeline), i.setBindGroup(0, a.bindGroup), i.dispatchWorkgroups(...a.dispatchGroup), this.writeTimestamp(this.pendingDispatchNumber * 2 + 1), this.pendingDispatchNumber++, this.queryType !== \"none\" && this.pendingKernels.push(r[o]), (this.pendingDispatchNumber >= this.maxDispatchNumber || this.queryType === \"at-passes\") && this.endComputePass(), this.pendingDispatchNumber >= this.maxDispatchNumber && this.flush();\n            }\n            this.flush(), this.sessionStatus = \"default\";\n        }\n        onCreateSession() {\n            this.gpuDataManager.onCreateSession();\n        }\n        onReleaseSession(t) {\n            this.unregisterBuffers(t), this.capturedCommandList.has(t) && this.capturedCommandList.delete(t), this.capturedPendingKernels.has(t) && this.capturedPendingKernels.delete(t), this.gpuDataManager.onReleaseSession(t);\n        }\n        onRunStart(t) {\n            this.currentSessionId = t, this.setQueryType();\n        }\n        constructor(){\n            this.currentSessionId = null;\n            this.currentKernelId = null;\n            this.commandEncoder = null;\n            this.computePassEncoder = null;\n            this.maxDispatchNumber = 16;\n            this.pendingDispatchNumber = 0;\n            this.pendingKernels = [];\n            this.pendingQueries = new Map;\n            this.sessionStatus = \"default\";\n            this.capturedCommandList = new Map;\n            this.capturedPendingKernels = new Map;\n            this.sessionExternalDataMapping = new Map;\n        }\n    };\n});\nvar lg, ec, cg, tc, an, sn, ko, rc, nc = U(()=>{\n    \"use strict\";\n    et();\n    lg = 1, ec = ()=>lg++, cg = new Map([\n        [\n            \"float32\",\n            32\n        ],\n        [\n            \"float16\",\n            16\n        ],\n        [\n            \"int32\",\n            32\n        ],\n        [\n            \"uint32\",\n            32\n        ],\n        [\n            \"int64\",\n            64\n        ],\n        [\n            \"uint64\",\n            64\n        ],\n        [\n            \"int8\",\n            8\n        ],\n        [\n            \"uint8\",\n            8\n        ],\n        [\n            \"int4\",\n            4\n        ],\n        [\n            \"uint4\",\n            4\n        ]\n    ]), tc = (e1, t)=>{\n        let r = cg.get(e1);\n        if (!r) throw new Error(\"Unsupported data type.\");\n        return t.length > 0 ? Math.ceil(t.reduce((n, o)=>n * o) * r / 8) : 0;\n    }, an = class {\n        get tensor() {\n            return this.mlTensor;\n        }\n        get type() {\n            return this.dataType;\n        }\n        get shape() {\n            return this.tensorShape;\n        }\n        get byteLength() {\n            return tc(this.dataType, this.tensorShape);\n        }\n        destroy() {\n            ue(\"verbose\", ()=>\"[WebNN] TensorWrapper.destroy\"), this.mlTensor.destroy();\n        }\n        write(t) {\n            this.mlContext.writeTensor(this.mlTensor, t);\n        }\n        async read(t) {\n            return t ? this.mlContext.readTensor(this.mlTensor, t) : this.mlContext.readTensor(this.mlTensor);\n        }\n        canReuseTensor(t, r, n) {\n            return this.mlContext === t && this.dataType === r && this.tensorShape.length === n.length && this.tensorShape.every((o, i)=>o === n[i]);\n        }\n        constructor(t){\n            this.sessionId = t.sessionId, this.mlContext = t.context, this.mlTensor = t.tensor, this.dataType = t.dataType, this.tensorShape = t.shape;\n        }\n    }, sn = class {\n        get tensorWrapper() {\n            return this.wrapper;\n        }\n        releaseTensor() {\n            this.tensorWrapper && (this.tensorManager.releaseTensor(this.tensorWrapper), this.wrapper = void 0);\n        }\n        async ensureTensor(t, r, n, o) {\n            if (this.wrapper) {\n                if (this.wrapper.canReuseTensor(t, r, n)) return this.wrapper.tensor;\n                if (o) {\n                    if (this.wrapper.byteLength !== tc(r, n)) throw new Error(\"Unable to copy data to tensor with different size.\");\n                    this.activeUpload = new Uint8Array(await this.wrapper.read());\n                }\n                this.tensorManager.releaseTensor(this.wrapper);\n            }\n            let i = typeof MLTensorUsage > \"u\" ? void 0 : MLTensorUsage.READ | MLTensorUsage.WRITE;\n            return this.wrapper = await this.tensorManager.getCachedTensor(r, n, i, !0, !0), o && this.activeUpload && (this.wrapper.write(this.activeUpload), this.activeUpload = void 0), this.wrapper.tensor;\n        }\n        upload(t) {\n            if (this.wrapper) if (t.byteLength === this.wrapper.byteLength) {\n                this.wrapper.write(t);\n                return;\n            } else ue(\"verbose\", ()=>\"Data size does not match tensor size. Releasing tensor.\"), this.releaseTensor();\n            this.activeUpload ? this.activeUpload.set(t) : this.activeUpload = new Uint8Array(t);\n        }\n        async download(t) {\n            if (this.activeUpload) if (t) {\n                t instanceof ArrayBuffer ? new Uint8Array(t).set(this.activeUpload) : new Uint8Array(t.buffer, t.byteOffset, t.byteLength).set(this.activeUpload);\n                return;\n            } else return this.activeUpload.buffer;\n            if (!this.wrapper) throw new Error(\"Tensor has not been created.\");\n            return t ? this.wrapper.read(t) : this.wrapper.read();\n        }\n        constructor(t, r){\n            this.tensorManager = t;\n            this.wrapper = r;\n        }\n    }, ko = class {\n        reserveTensorId() {\n            let t = ec();\n            return this.tensorTrackersById.set(t, new sn(this)), t;\n        }\n        releaseTensorId(t) {\n            let r = this.tensorTrackersById.get(t);\n            r && (this.tensorTrackersById.delete(t), r.tensorWrapper && this.releaseTensor(r.tensorWrapper));\n        }\n        async ensureTensor(t, r, n, o) {\n            ue(\"verbose\", ()=>\"[WebNN] TensorManager.ensureTensor {tensorId: \".concat(t, \", dataType: \").concat(r, \", shape: \").concat(n, \", copyOld: \").concat(o, \"}\"));\n            let i = this.tensorTrackersById.get(t);\n            if (!i) throw new Error(\"Tensor not found.\");\n            return i.ensureTensor(this.backend.currentContext, r, n, o);\n        }\n        upload(t, r) {\n            let n = this.tensorTrackersById.get(t);\n            if (!n) throw new Error(\"Tensor not found.\");\n            n.upload(r);\n        }\n        async download(t, r) {\n            ue(\"verbose\", ()=>\"[WebNN] TensorManager.download {tensorId: \".concat(t, \", dstBuffer: \").concat(r === null || r === void 0 ? void 0 : r.byteLength, \"}\"));\n            let n = this.tensorTrackersById.get(t);\n            if (!n) throw new Error(\"Tensor not found.\");\n            return n.download(r);\n        }\n        releaseTensorsForSession(t) {\n            for (let r of this.freeTensors)r.sessionId === t && r.destroy();\n            this.freeTensors = this.freeTensors.filter((r)=>r.sessionId !== t);\n        }\n        registerTensor(t, r, n, o) {\n            let i = ec(), a = new an({\n                sessionId: this.backend.currentSessionId,\n                context: t,\n                tensor: r,\n                dataType: n,\n                shape: o\n            });\n            return this.tensorTrackersById.set(i, new sn(this, a)), this.externalTensors.add(a), i;\n        }\n        async getCachedTensor(t, r, n, o, i) {\n            let a = this.backend.currentSessionId, d = this.backend.currentContext;\n            for (let [p, m] of this.freeTensors.entries())if (m.canReuseTensor(d, t, r)) {\n                ue(\"verbose\", ()=>\"[WebNN] Reusing tensor {dataType: \".concat(t, \", shape: \").concat(r, \"}\"));\n                let u = this.freeTensors.splice(p, 1)[0];\n                return u.sessionId = a, u;\n            }\n            ue(\"verbose\", ()=>\"[WebNN] MLContext.createTensor {dataType: \".concat(t, \", shape: \").concat(r, \"}\"));\n            let l = await d.createTensor({\n                dataType: t,\n                shape: r,\n                dimensions: r,\n                usage: n,\n                writable: o,\n                readable: i\n            });\n            return new an({\n                sessionId: a,\n                context: d,\n                tensor: l,\n                dataType: t,\n                shape: r\n            });\n        }\n        releaseTensor(t) {\n            this.externalTensors.has(t) && this.externalTensors.delete(t), this.freeTensors.push(t);\n        }\n        constructor(t){\n            this.backend = t;\n            this.tensorTrackersById = new Map;\n            this.freeTensors = [];\n            this.externalTensors = new Set;\n        }\n    }, rc = function() {\n        for(var _len = arguments.length, e1 = new Array(_len), _key = 0; _key < _len; _key++){\n            e1[_key] = arguments[_key];\n        }\n        return new ko(...e1);\n    };\n});\nvar oc, pg, un, ic = U(()=>{\n    \"use strict\";\n    te();\n    gt();\n    Jn();\n    nc();\n    et();\n    oc = new Map([\n        [\n            1,\n            \"float32\"\n        ],\n        [\n            10,\n            \"float16\"\n        ],\n        [\n            6,\n            \"int32\"\n        ],\n        [\n            12,\n            \"uint32\"\n        ],\n        [\n            7,\n            \"int64\"\n        ],\n        [\n            13,\n            \"uint64\"\n        ],\n        [\n            22,\n            \"int4\"\n        ],\n        [\n            21,\n            \"uint4\"\n        ],\n        [\n            3,\n            \"int8\"\n        ],\n        [\n            2,\n            \"uint8\"\n        ],\n        [\n            9,\n            \"uint8\"\n        ]\n    ]), pg = (e1, t)=>{\n        if (e1 === t) return !0;\n        if (e1 === void 0 || t === void 0) return !1;\n        let r = Object.keys(e1).sort(), n = Object.keys(t).sort();\n        return r.length === n.length && r.every((o, i)=>o === n[i] && e1[o] === t[o]);\n    }, un = class {\n        get currentSessionId() {\n            if (this.activeSessionId === void 0) throw new Error(\"No active session\");\n            return this.activeSessionId;\n        }\n        onRunStart(t) {\n            this.activeSessionId = t;\n        }\n        async createMLContext(t) {\n            if (t instanceof GPUDevice) {\n                let n = this.mlContextCache.findIndex((o)=>o.gpuDevice === t);\n                if (n !== -1) return this.mlContextCache[n].mlContext;\n                {\n                    let o = await navigator.ml.createContext(t);\n                    return this.mlContextCache.push({\n                        gpuDevice: t,\n                        mlContext: o\n                    }), o;\n                }\n            } else if (t === void 0) {\n                let n = this.mlContextCache.findIndex((o)=>o.options === void 0 && o.gpuDevice === void 0);\n                if (n !== -1) return this.mlContextCache[n].mlContext;\n                {\n                    let o = await navigator.ml.createContext();\n                    return this.mlContextCache.push({\n                        mlContext: o\n                    }), o;\n                }\n            }\n            let r = this.mlContextCache.findIndex((n)=>pg(n.options, t));\n            if (r !== -1) return this.mlContextCache[r].mlContext;\n            {\n                let n = await navigator.ml.createContext(t);\n                return this.mlContextCache.push({\n                    options: t,\n                    mlContext: n\n                }), n;\n            }\n        }\n        get currentContext() {\n            let t = this.getMLContext(this.currentSessionId);\n            if (!t) throw new Error(\"No MLContext found for session \".concat(this.currentSessionId));\n            return t;\n        }\n        registerMLContext(t, r) {\n            this.mlContextBySessionId.set(t, r);\n            let n = this.sessionIdsByMLContext.get(r);\n            n || (n = new Set, this.sessionIdsByMLContext.set(r, n)), n.add(t);\n        }\n        onReleaseSession(t) {\n            let r = this.mlContextBySessionId.get(t);\n            if (!r) return;\n            this.tensorManager.releaseTensorsForSession(t), this.mlContextBySessionId.delete(t);\n            let n = this.sessionIdsByMLContext.get(r);\n            if (n.delete(t), n.size === 0) {\n                this.sessionIdsByMLContext.delete(r);\n                let o = this.mlContextCache.findIndex((i)=>i.mlContext === r);\n                o !== -1 && this.mlContextCache.splice(o, 1);\n            }\n        }\n        getMLContext(t) {\n            return this.mlContextBySessionId.get(t);\n        }\n        reserveTensorId() {\n            return this.tensorManager.reserveTensorId();\n        }\n        releaseTensorId(t) {\n            ue(\"verbose\", ()=>\"[WebNN] releaseTensorId {tensorId: \".concat(t, \"}\")), this.tensorManager.releaseTensorId(t);\n        }\n        async ensureTensor(t, r, n, o) {\n            let i = oc.get(r);\n            if (!i) throw new Error(\"Unsupported ONNX data type: \".concat(r));\n            return this.tensorManager.ensureTensor(t, i, n, o);\n        }\n        uploadTensor(t, r) {\n            if (!Ie().shouldTransferToMLTensor) throw new Error(\"Trying to upload to a MLTensor while shouldTransferToMLTensor is false\");\n            ue(\"verbose\", ()=>\"[WebNN] uploadTensor {tensorId: \".concat(t, \", data: \").concat(r.byteLength, \"}\")), this.tensorManager.upload(t, r);\n        }\n        async downloadTensor(t, r) {\n            return this.tensorManager.download(t, r);\n        }\n        createMLTensorDownloader(t, r) {\n            return async ()=>{\n                let n = await this.tensorManager.download(t);\n                return Ur(n, r);\n            };\n        }\n        registerMLTensor(t, r, n) {\n            let o = oc.get(r);\n            if (!o) throw new Error(\"Unsupported ONNX data type: \".concat(r));\n            let i = this.tensorManager.registerTensor(this.currentContext, t, o, n);\n            return ue(\"verbose\", ()=>\"[WebNN] registerMLTensor {tensor: \".concat(t, \", dataType: \").concat(o, \", dimensions: \").concat(n, \"} -> {tensorId: \").concat(i, \"}\")), i;\n        }\n        registerMLConstant(t, r, n, o, i, a) {\n            if (!a) throw new Error(\"External mounted files are not available.\");\n            let d = t;\n            t.startsWith(\"./\") && (d = t.substring(2));\n            let l = a.get(d);\n            if (!l) throw new Error(\"File with name \".concat(d, \" not found in preloaded files.\"));\n            if (r + n > l.byteLength) throw new Error(\"Out of bounds: data offset and length exceed the external file data size.\");\n            let p = l.slice(r, r + n).buffer, m;\n            switch(i.dataType){\n                case \"float32\":\n                    m = new Float32Array(p);\n                    break;\n                case \"float16\":\n                    m = new Uint16Array(p);\n                    break;\n                case \"int32\":\n                    m = new Int32Array(p);\n                    break;\n                case \"uint32\":\n                    m = new Uint32Array(p);\n                    break;\n                case \"int64\":\n                    m = new BigInt64Array(p);\n                    break;\n                case \"uint64\":\n                    m = new BigUint64Array(p);\n                    break;\n                case \"int8\":\n                    m = new Int8Array(p);\n                    break;\n                case \"int4\":\n                case \"uint4\":\n                case \"uint8\":\n                    m = new Uint8Array(p);\n                    break;\n                default:\n                    throw new Error(\"Unsupported data type: \".concat(i.dataType, \" in creating WebNN Constant from external data.\"));\n            }\n            return ue(\"verbose\", ()=>\"[WebNN] registerMLConstant {dataType: \".concat(i.dataType, \", shape: \").concat(i.shape, \"}}\")), o.constant(i, m);\n        }\n        flush() {}\n        constructor(t){\n            this.tensorManager = rc(this);\n            this.mlContextBySessionId = new Map;\n            this.sessionIdsByMLContext = new Map;\n            this.mlContextCache = [];\n            Rr(t.logLevel, !!t.debug);\n        }\n    };\n});\nvar ac = {};\nFt(ac, {\n    init: ()=>mg\n});\nvar rr, Eo, mg, sc = U(()=>{\n    \"use strict\";\n    te();\n    Jl();\n    et();\n    oe();\n    ic();\n    rr = class e1 {\n        getFloat32Array() {\n            if (this.dataType !== 1) throw new Error(\"Invalid data type\");\n            let t = C.size(this.dims);\n            return t === 0 ? new Float32Array : new Float32Array(this.module.HEAP8.buffer, this.data, t);\n        }\n        getBigInt64Array() {\n            if (this.dataType !== 7) throw new Error(\"Invalid data type\");\n            let t = C.size(this.dims);\n            return t === 0 ? new BigInt64Array : new BigInt64Array(this.module.HEAP8.buffer, this.data, t);\n        }\n        getInt32Array() {\n            if (this.dataType !== 6) throw new Error(\"Invalid data type\");\n            let t = C.size(this.dims);\n            return t === 0 ? new Int32Array : new Int32Array(this.module.HEAP8.buffer, this.data, t);\n        }\n        getUint16Array() {\n            if (this.dataType !== 10 && this.dataType !== 4) throw new Error(\"Invalid data type\");\n            let t = C.size(this.dims);\n            return t === 0 ? new Uint16Array : new Uint16Array(this.module.HEAP8.buffer, this.data, t);\n        }\n        reshape(t) {\n            if (C.size(t) !== C.size(this.dims)) throw new Error(\"Invalid new shape\");\n            return new e1(this.module, this.dataType, this.data, t);\n        }\n        constructor(t, r, n, o){\n            this.module = t;\n            this.dataType = r;\n            this.data = n;\n            this.dims = o;\n        }\n    }, Eo = class {\n        get kernelCustomData() {\n            return this.backend.currentKernelCustomData;\n        }\n        get customDataBuffer() {\n            return this.module.HEAPU8.subarray(this.customDataOffset, this.customDataOffset + this.customDataSize);\n        }\n        compute(t, r) {\n            var _r_inputs;\n            var _r_inputs_map, _r_outputs;\n            let n = (_r_inputs_map = r === null || r === void 0 ? void 0 : (_r_inputs = r.inputs) === null || _r_inputs === void 0 ? void 0 : _r_inputs.map((d)=>typeof d == \"number\" ? this.inputs[d] : d)) !== null && _r_inputs_map !== void 0 ? _r_inputs_map : this.inputs, o = (_r_outputs = r === null || r === void 0 ? void 0 : r.outputs) !== null && _r_outputs !== void 0 ? _r_outputs : [], i = (d, l, p)=>new rr(this.module, l, this.output(d, p), p), a = (d, l)=>{\n                let p = Ct(d, l);\n                if (!p) throw new Error(\"Unsupported data type: \".concat(d));\n                let m = p > 0 ? this.backend.gpuDataManager.create(p).id : 0;\n                return new rr(this.module, d, m, l);\n            };\n            return this.backend.run(t, n, o, i, a, this.outputCount);\n        }\n        output(t, r) {\n            let n = this.module.stackSave();\n            try {\n                let o = this.module.PTR_SIZE, i = o === 4 ? \"i32\" : \"i64\", a = this.module.stackAlloc((1 + r.length) * o);\n                this.module.setValue(a, r.length, i);\n                for(let d = 0; d < r.length; d++)this.module.setValue(a + o * (d + 1), r[d], i);\n                return this.module._JsepOutput(this.opKernelContext, t, a);\n            } catch (o) {\n                throw new Error(\"Failed to generate kernel's output[\".concat(t, \"] with dims [\").concat(r, \"]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: \").concat(o));\n            } finally{\n                this.module.stackRestore(n);\n            }\n        }\n        constructor(t, r, n){\n            this.module = t;\n            this.backend = r;\n            this.customDataOffset = 0;\n            this.customDataSize = 0;\n            this.adapterInfo = r.adapterInfo, this.deviceInfo = r.deviceInfo;\n            let o = t.PTR_SIZE, i = n / t.PTR_SIZE, a = o === 4 ? \"i32\" : \"i64\";\n            this.opKernelContext = Number(t.getValue(o * i++, a));\n            let d = Number(t.getValue(o * i++, a));\n            this.outputCount = Number(t.getValue(o * i++, a)), this.customDataOffset = Number(t.getValue(o * i++, \"*\")), this.customDataSize = Number(t.getValue(o * i++, a));\n            let l = [];\n            for(let p = 0; p < d; p++){\n                let m = Number(t.getValue(o * i++, a)), u = Number(t.getValue(o * i++, \"*\")), h = Number(t.getValue(o * i++, a)), _ = [];\n                for(let y = 0; y < h; y++)_.push(Number(t.getValue(o * i++, a)));\n                l.push(new rr(t, m, u, _));\n            }\n            this.inputs = l;\n        }\n    }, mg = async (e1, t, r, n)=>{\n        let o = t.jsepInit;\n        if (!o) throw new Error(\"Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.\");\n        if (e1 === \"webgpu\") {\n            let i = new on;\n            await i.initialize(r, n), o(\"webgpu\", [\n                i,\n                (a)=>i.alloc(Number(a)),\n                (a)=>i.free(a),\n                function(a, d, l) {\n                    let p = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;\n                    if (p) ue(\"verbose\", ()=>\"[WebGPU] jsepCopyGpuToGpu: src=\".concat(Number(a), \", dst=\").concat(Number(d), \", size=\").concat(Number(l))), i.memcpy(Number(a), Number(d));\n                    else {\n                        ue(\"verbose\", ()=>\"[WebGPU] jsepCopyCpuToGpu: dataOffset=\".concat(Number(a), \", gpuDataId=\").concat(Number(d), \", size=\").concat(Number(l)));\n                        let m = t.HEAPU8.subarray(Number(a >>> 0), Number(a >>> 0) + Number(l));\n                        i.upload(Number(d), m);\n                    }\n                },\n                async (a, d, l)=>{\n                    ue(\"verbose\", ()=>\"[WebGPU] jsepCopyGpuToCpu: gpuDataId=\".concat(a, \", dataOffset=\").concat(d, \", size=\").concat(l)), await i.download(Number(a), ()=>t.HEAPU8.subarray(Number(d) >>> 0, Number(d + l) >>> 0));\n                },\n                (a, d, l)=>i.createKernel(a, Number(d), l, t.UTF8ToString(t._JsepGetNodeName(Number(d)))),\n                (a)=>i.releaseKernel(a),\n                (a, d, l, p)=>{\n                    ue(\"verbose\", ()=>\"[WebGPU] jsepRun: sessionHandle=\".concat(l, \", kernel=\").concat(a, \", contextDataOffset=\").concat(d));\n                    let m = new Eo(t, i, Number(d));\n                    return i.computeKernel(Number(a), m, p);\n                },\n                ()=>i.captureBegin(),\n                ()=>i.captureEnd(),\n                ()=>i.replay()\n            ]);\n        } else {\n            let i = new un(r);\n            o(\"webnn\", [\n                i,\n                ()=>i.reserveTensorId(),\n                (a)=>i.releaseTensorId(a),\n                async (a, d, l, p)=>i.ensureTensor(a, d, l, p),\n                (a, d)=>{\n                    i.uploadTensor(a, d);\n                },\n                async (a, d)=>i.downloadTensor(a, d)\n            ]);\n        }\n    };\n});\nvar fg, Tr, Ir, Pt, hg, Kt, Cr, Ar, uc, kr, Er, Pr, qn = U(()=>{\n    \"use strict\";\n    Ha();\n    qa();\n    te();\n    gt();\n    Or();\n    Xn();\n    fg = (e1, t)=>{\n        Ie()._OrtInit(e1, t) !== 0 && pe(\"Can't initialize onnxruntime.\");\n    }, Tr = async (e1)=>{\n        fg(e1.wasm.numThreads, Zt(e1.logLevel));\n    }, Ir = async (e1, t)=>{\n        {\n            let r = (sc(), br(ac)).init;\n            if (t === \"webgpu\") {\n                if (typeof navigator > \"u\" || !navigator.gpu) throw new Error(\"WebGPU is not supported in current environment\");\n                let n = e1.webgpu.adapter;\n                if (n) {\n                    if (typeof n.limits != \"object\" || typeof n.features != \"object\" || typeof n.requestDevice != \"function\") throw new Error(\"Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.\");\n                } else {\n                    let o = e1.webgpu.powerPreference;\n                    if (o !== void 0 && o !== \"low-power\" && o !== \"high-performance\") throw new Error('Invalid powerPreference setting: \"'.concat(o, '\"'));\n                    let i = e1.webgpu.forceFallbackAdapter;\n                    if (i !== void 0 && typeof i != \"boolean\") throw new Error('Invalid forceFallbackAdapter setting: \"'.concat(i, '\"'));\n                    if (n = await navigator.gpu.requestAdapter({\n                        powerPreference: o,\n                        forceFallbackAdapter: i\n                    }), !n) throw new Error('Failed to get GPU adapter. You may need to enable flag \"--enable-unsafe-webgpu\" if you are using Chrome.');\n                }\n                await r(\"webgpu\", Ie(), e1, n);\n            }\n            if (t === \"webnn\") {\n                if (typeof navigator > \"u\" || !navigator.ml) throw new Error(\"WebNN is not supported in current environment\");\n                await r(\"webnn\", Ie(), e1);\n            }\n        }\n    }, Pt = new Map, hg = (e1)=>{\n        let t = Ie(), r = t.stackSave();\n        try {\n            let n = t.PTR_SIZE, o = t.stackAlloc(2 * n);\n            t._OrtGetInputOutputCount(e1, o, o + n) !== 0 && pe(\"Can't get session input/output count.\");\n            let a = n === 4 ? \"i32\" : \"i64\";\n            return [\n                Number(t.getValue(o, a)),\n                Number(t.getValue(o + n, a))\n            ];\n        } finally{\n            t.stackRestore(r);\n        }\n    }, Kt = (e1)=>{\n        let t = Ie(), r = t._malloc(e1.byteLength);\n        if (r === 0) throw new Error(\"Can't create a session. failed to allocate a buffer of size \".concat(e1.byteLength, \".\"));\n        return t.HEAPU8.set(e1, r), [\n            r,\n            e1.byteLength\n        ];\n    }, Cr = async (e1, t)=>{\n        let r, n, o = Ie();\n        Array.isArray(e1) ? [r, n] = e1 : e1.buffer === o.HEAPU8.buffer ? [r, n] = [\n            e1.byteOffset,\n            e1.byteLength\n        ] : [r, n] = Kt(e1);\n        let i = 0, a = 0, d = 0, l = [], p = [], m = [];\n        try {\n            var _o_jsepOnCreateSession;\n            if ([a, l] = Fa(t), (t === null || t === void 0 ? void 0 : t.externalData) && o.mountExternalData) {\n                let v = [];\n                for (let S of t.externalData){\n                    let T = typeof S == \"string\" ? S : S.path;\n                    v.push(Qt(typeof S == \"string\" ? S : S.data).then((A)=>{\n                        o.mountExternalData(T, A);\n                    }));\n                }\n                await Promise.all(v);\n            }\n            var _t_executionProviders;\n            for (let v of (_t_executionProviders = t === null || t === void 0 ? void 0 : t.executionProviders) !== null && _t_executionProviders !== void 0 ? _t_executionProviders : [])if ((typeof v == \"string\" ? v : v.name) === \"webnn\") {\n                if (o.shouldTransferToMLTensor = !1, typeof v != \"string\") {\n                    let T = v, A = T === null || T === void 0 ? void 0 : T.context, k = T === null || T === void 0 ? void 0 : T.gpuDevice, P = T === null || T === void 0 ? void 0 : T.deviceType, D = T === null || T === void 0 ? void 0 : T.powerPreference;\n                    A ? o.currentContext = A : k ? o.currentContext = await o.jsepCreateMLContext(k) : o.currentContext = await o.jsepCreateMLContext({\n                        deviceType: P,\n                        powerPreference: D\n                    });\n                } else o.currentContext = await o.jsepCreateMLContext();\n                break;\n            }\n            i = await o._OrtCreateSession(r, n, a), i === 0 && pe(\"Can't create a session.\"), (_o_jsepOnCreateSession = o.jsepOnCreateSession) === null || _o_jsepOnCreateSession === void 0 ? void 0 : _o_jsepOnCreateSession.call(o), o.currentContext && (o.jsepRegisterMLContext(i, o.currentContext), o.currentContext = void 0, o.shouldTransferToMLTensor = !0);\n            let [u, h] = hg(i), _ = !!(t === null || t === void 0 ? void 0 : t.enableGraphCapture), y = [], g = [], x = [];\n            for(let v = 0; v < u; v++){\n                let S = o._OrtGetInputName(i, v);\n                S === 0 && pe(\"Can't get an input name.\"), p.push(S), y.push(o.UTF8ToString(S));\n            }\n            for(let v = 0; v < h; v++){\n                let S = o._OrtGetOutputName(i, v);\n                S === 0 && pe(\"Can't get an output name.\"), m.push(S);\n                let T = o.UTF8ToString(S);\n                g.push(T);\n                {\n                    var _t_preferredOutputLocation;\n                    if (_ && (t === null || t === void 0 ? void 0 : t.preferredOutputLocation) === void 0) {\n                        x.push(\"gpu-buffer\");\n                        continue;\n                    }\n                    var _t_preferredOutputLocation_T;\n                    let A = typeof (t === null || t === void 0 ? void 0 : t.preferredOutputLocation) == \"string\" ? t.preferredOutputLocation : (_t_preferredOutputLocation_T = t === null || t === void 0 ? void 0 : (_t_preferredOutputLocation = t.preferredOutputLocation) === null || _t_preferredOutputLocation === void 0 ? void 0 : _t_preferredOutputLocation[T]) !== null && _t_preferredOutputLocation_T !== void 0 ? _t_preferredOutputLocation_T : \"cpu\";\n                    if (A !== \"cpu\" && A !== \"cpu-pinned\" && A !== \"gpu-buffer\" && A !== \"ml-tensor\") throw new Error(\"Not supported preferred output location: \".concat(A, \".\"));\n                    if (_ && A !== \"gpu-buffer\") throw new Error(\"Not supported preferred output location: \".concat(A, \". Only 'gpu-buffer' location is supported when enableGraphCapture is true.\"));\n                    x.push(A);\n                }\n            }\n            let $ = null;\n            return x.some((v)=>v === \"gpu-buffer\" || v === \"ml-tensor\") && (d = o._OrtCreateBinding(i), d === 0 && pe(\"Can't create IO binding.\"), $ = {\n                handle: d,\n                outputPreferredLocations: x,\n                outputPreferredLocationsEncoded: x.map((v)=>Qn(v))\n            }), Pt.set(i, [\n                i,\n                p,\n                m,\n                $,\n                _,\n                !1\n            ]), [\n                i,\n                y,\n                g\n            ];\n        } catch (u) {\n            throw p.forEach((h)=>o._OrtFree(h)), m.forEach((h)=>o._OrtFree(h)), d !== 0 && o._OrtReleaseBinding(d) !== 0 && pe(\"Can't release IO binding.\"), i !== 0 && o._OrtReleaseSession(i) !== 0 && pe(\"Can't release session.\"), u;\n        } finally{\n            var _o_unmountExternalData;\n            o._free(r), a !== 0 && o._OrtReleaseSessionOptions(a) !== 0 && pe(\"Can't release session options.\"), l.forEach((u)=>o._free(u)), (_o_unmountExternalData = o.unmountExternalData) === null || _o_unmountExternalData === void 0 ? void 0 : _o_unmountExternalData.call(o);\n        }\n    }, Ar = (e1)=>{\n        var _t_jsepOnReleaseSession;\n        let t = Ie(), r = Pt.get(e1);\n        if (!r) throw new Error(\"cannot release session. invalid session id: \".concat(e1));\n        let [n, o, i, a, d] = r;\n        a && (d && t._OrtClearBoundOutputs(a.handle) !== 0 && pe(\"Can't clear bound outputs.\"), t._OrtReleaseBinding(a.handle) !== 0 && pe(\"Can't release IO binding.\")), (_t_jsepOnReleaseSession = t.jsepOnReleaseSession) === null || _t_jsepOnReleaseSession === void 0 ? void 0 : _t_jsepOnReleaseSession.call(t, e1), o.forEach((l)=>t._OrtFree(l)), i.forEach((l)=>t._OrtFree(l)), t._OrtReleaseSession(n) !== 0 && pe(\"Can't release session.\"), Pt.delete(e1);\n    }, uc = function(e1, t, r, n, o) {\n        let i = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : !1;\n        if (!e1) {\n            t.push(0);\n            return;\n        }\n        let a = Ie(), d = a.PTR_SIZE, l = e1[0], p = e1[1], m = e1[3], u, h;\n        if (l === \"string\" && (m === \"gpu-buffer\" || m === \"ml-tensor\")) throw new Error(\"String tensor is not supported on GPU.\");\n        if (i && m !== \"gpu-buffer\") throw new Error(\"External buffer must be provided for input/output index \".concat(o, \" when enableGraphCapture is true.\"));\n        if (m === \"gpu-buffer\") {\n            let g = e1[2].gpuBuffer;\n            h = Ct(Yt(l), p);\n            let x = a.jsepRegisterBuffer;\n            if (!x) throw new Error('Tensor location \"gpu-buffer\" is not supported without using WebGPU.');\n            u = x(n, o, g, h);\n        } else if (m === \"ml-tensor\") {\n            let g = e1[2].mlTensor;\n            h = Ct(Yt(l), p);\n            let x = a.jsepRegisterMLTensor;\n            if (!x) throw new Error('Tensor location \"ml-tensor\" is not supported without using WebNN.');\n            u = x(g, Yt(l), p);\n        } else {\n            let g = e1[2];\n            if (Array.isArray(g)) {\n                h = d * g.length, u = a._malloc(h), r.push(u);\n                for(let x = 0; x < g.length; x++){\n                    if (typeof g[x] != \"string\") throw new TypeError(\"tensor data at index \".concat(x, \" is not a string\"));\n                    a.setValue(u + x * d, ke(g[x], r), \"*\");\n                }\n            } else h = g.byteLength, u = a._malloc(h), r.push(u), a.HEAPU8.set(new Uint8Array(g.buffer, g.byteOffset, h), u);\n        }\n        let _ = a.stackSave(), y = a.stackAlloc(4 * p.length);\n        try {\n            p.forEach((x, $)=>a.setValue(y + $ * d, x, d === 4 ? \"i32\" : \"i64\"));\n            let g = a._OrtCreateTensor(Yt(l), u, h, y, p.length, Qn(m));\n            g === 0 && pe(\"Can't create tensor for input/output. session=\".concat(n, \", index=\").concat(o, \".\")), t.push(g);\n        } finally{\n            a.stackRestore(_);\n        }\n    }, kr = async (e1, t, r, n, o, i)=>{\n        let a = Ie(), d = a.PTR_SIZE, l = Pt.get(e1);\n        if (!l) throw new Error(\"cannot run inference. invalid session id: \".concat(e1));\n        let p = l[0], m = l[1], u = l[2], h = l[3], _ = l[4], y = l[5], g = t.length, x = n.length, $ = 0, v = [], S = [], T = [], A = [], k = a.stackSave(), P = a.stackAlloc(g * d), D = a.stackAlloc(g * d), R = a.stackAlloc(x * d), G = a.stackAlloc(x * d);\n        try {\n            var _a_jsepOnRunStart;\n            (_a_jsepOnRunStart = a.jsepOnRunStart) === null || _a_jsepOnRunStart === void 0 ? void 0 : _a_jsepOnRunStart.call(a, p), [$, v] = Ga(i);\n            for(let V = 0; V < g; V++)uc(r[V], S, A, e1, t[V], _);\n            for(let V = 0; V < x; V++)uc(o[V], T, A, e1, g + n[V], _);\n            for(let V = 0; V < g; V++)a.setValue(P + V * d, S[V], \"*\"), a.setValue(D + V * d, m[t[V]], \"*\");\n            for(let V = 0; V < x; V++)a.setValue(R + V * d, T[V], \"*\"), a.setValue(G + V * d, u[n[V]], \"*\");\n            if (h && !y) {\n                let { handle: V, outputPreferredLocations: Q, outputPreferredLocationsEncoded: se } = h;\n                if (m.length !== g) throw new Error(\"input count from feeds (\".concat(g, \") is expected to be always equal to model's input count (\").concat(m.length, \").\"));\n                for(let Y = 0; Y < g; Y++){\n                    let ee = t[Y];\n                    await a._OrtBindInput(V, m[ee], S[Y]) !== 0 && pe(\"Can't bind input[\".concat(Y, \"] for session=\").concat(e1, \".\"));\n                }\n                for(let Y = 0; Y < x; Y++){\n                    var _o_Y;\n                    let ee = n[Y];\n                    ((_o_Y = o[Y]) === null || _o_Y === void 0 ? void 0 : _o_Y[3]) ? a._OrtBindOutput(V, u[ee], T[Y], 0) !== 0 && pe(\"Can't bind pre-allocated output[\".concat(Y, \"] for session=\").concat(e1, \".\")) : a._OrtBindOutput(V, u[ee], 0, se[ee]) !== 0 && pe(\"Can't bind output[\".concat(Y, \"] to \").concat(Q[Y], \" for session=\").concat(e1, \".\"));\n                }\n                Pt.set(e1, [\n                    p,\n                    m,\n                    u,\n                    h,\n                    _,\n                    !0\n                ]);\n            }\n            let K;\n            h ? K = await a._OrtRunWithBinding(p, h.handle, x, R, $) : K = await a._OrtRun(p, D, P, g, G, x, R, $), K !== 0 && pe(\"failed to call OrtRun().\");\n            let j = [];\n            for(let V = 0; V < x; V++){\n                let Q = Number(a.getValue(R + V * d, \"*\"));\n                if (Q === T[V]) {\n                    j.push(o[V]);\n                    continue;\n                }\n                let se = a.stackSave(), Y = a.stackAlloc(4 * d), ee = !1, J, ne = 0;\n                try {\n                    a._OrtGetTensorData(Q, Y, Y + d, Y + 2 * d, Y + 3 * d) !== 0 && pe(\"Can't access output tensor data on index \".concat(V, \".\"));\n                    let Oe = d === 4 ? \"i32\" : \"i64\", $e = Number(a.getValue(Y, Oe));\n                    ne = a.getValue(Y + d, \"*\");\n                    let le = a.getValue(Y + d * 2, \"*\"), W = Number(a.getValue(Y + d * 3, Oe)), q = [];\n                    for(let we = 0; we < W; we++)q.push(Number(a.getValue(le + we * d, Oe)));\n                    a._OrtFree(le) !== 0 && pe(\"Can't free memory for tensor dims.\");\n                    let he = q.reduce((we, ye)=>we * ye, 1);\n                    J = bt($e);\n                    let Ge = h === null || h === void 0 ? void 0 : h.outputPreferredLocations[n[V]];\n                    if (J === \"string\") {\n                        if (Ge === \"gpu-buffer\" || Ge === \"ml-tensor\") throw new Error(\"String tensor is not supported on GPU.\");\n                        let we = [];\n                        for(let ye = 0; ye < he; ye++){\n                            let Ye = a.getValue(ne + ye * d, \"*\"), Lt = a.getValue(ne + (ye + 1) * d, \"*\"), fn = ye === he - 1 ? void 0 : Lt - Ye;\n                            we.push(a.UTF8ToString(Ye, fn));\n                        }\n                        j.push([\n                            J,\n                            q,\n                            we,\n                            \"cpu\"\n                        ]);\n                    } else if (Ge === \"gpu-buffer\" && he > 0) {\n                        let we = a.jsepGetBuffer;\n                        if (!we) throw new Error('preferredLocation \"gpu-buffer\" is not supported without using WebGPU.');\n                        let ye = we(ne), Ye = Ct($e, he);\n                        if (Ye === void 0 || !Br(J)) throw new Error(\"Unsupported data type: \".concat(J));\n                        ee = !0, j.push([\n                            J,\n                            q,\n                            {\n                                gpuBuffer: ye,\n                                download: a.jsepCreateDownloader(ye, Ye, J),\n                                dispose: ()=>{\n                                    a._OrtReleaseTensor(Q) !== 0 && pe(\"Can't release tensor.\");\n                                }\n                            },\n                            \"gpu-buffer\"\n                        ]);\n                    } else if (Ge === \"ml-tensor\" && he > 0) {\n                        let we = a.jsepEnsureTensor;\n                        if (!we) throw new Error('preferredLocation \"ml-tensor\" is not supported without using WebNN.');\n                        if (Ct($e, he) === void 0 || !Mr(J)) throw new Error(\"Unsupported data type: \".concat(J));\n                        let Ye = await we(ne, $e, q, !1);\n                        ee = !0, j.push([\n                            J,\n                            q,\n                            {\n                                mlTensor: Ye,\n                                download: a.jsepCreateMLTensorDownloader(ne, J),\n                                dispose: ()=>{\n                                    a.jsepReleaseTensorId(ne), a._OrtReleaseTensor(Q);\n                                }\n                            },\n                            \"ml-tensor\"\n                        ]);\n                    } else {\n                        let we = Dr(J), ye = new we(he);\n                        new Uint8Array(ye.buffer, ye.byteOffset, ye.byteLength).set(a.HEAPU8.subarray(ne, ne + ye.byteLength)), j.push([\n                            J,\n                            q,\n                            ye,\n                            \"cpu\"\n                        ]);\n                    }\n                } finally{\n                    a.stackRestore(se), J === \"string\" && ne && a._free(ne), ee || a._OrtReleaseTensor(Q);\n                }\n            }\n            return h && !_ && (a._OrtClearBoundOutputs(h.handle) !== 0 && pe(\"Can't clear bound outputs.\"), Pt.set(e1, [\n                p,\n                m,\n                u,\n                h,\n                _,\n                !1\n            ])), j;\n        } finally{\n            a.stackRestore(k), S.forEach((K)=>a._OrtReleaseTensor(K)), T.forEach((K)=>a._OrtReleaseTensor(K)), A.forEach((K)=>a._free(K)), $ !== 0 && a._OrtReleaseRunOptions($), v.forEach((K)=>a._free(K));\n        }\n    }, Er = (e1)=>{\n        let t = Ie(), r = Pt.get(e1);\n        if (!r) throw new Error(\"invalid session id\");\n        let n = r[0], o = t._OrtEndProfiling(n);\n        o === 0 && pe(\"Can't get an profile file name.\"), t._OrtFree(o);\n    }, Pr = (e1)=>{\n        let t = [];\n        for (let r of e1){\n            let n = r[2];\n            !Array.isArray(n) && \"buffer\" in n && t.push(n.buffer);\n        }\n        return t;\n    };\n});\nvar zt, Le, nr, ln, cn, dn, Po, zo, Vt, Wt, bg, dc, lc, cc, pc, mc, fc, hc, Oo = U(()=>{\n    \"use strict\";\n    We();\n    qn();\n    gt();\n    xr();\n    zt = ()=>!!ve.wasm.proxy && typeof document < \"u\", nr = !1, ln = !1, cn = !1, zo = new Map, Vt = (e1, t)=>{\n        let r = zo.get(e1);\n        r ? r.push(t) : zo.set(e1, [\n            t\n        ]);\n    }, Wt = ()=>{\n        if (nr || !ln || cn || !Le) throw new Error(\"worker not ready\");\n    }, bg = (e1)=>{\n        switch(e1.data.type){\n            case \"init-wasm\":\n                nr = !1, e1.data.err ? (cn = !0, Po[1](e1.data.err)) : (ln = !0, Po[0]()), dn && (URL.revokeObjectURL(dn), dn = void 0);\n                break;\n            case \"init-ep\":\n            case \"copy-from\":\n            case \"create\":\n            case \"release\":\n            case \"run\":\n            case \"end-profiling\":\n                {\n                    let t = zo.get(e1.data.type);\n                    e1.data.err ? t.shift()[1](e1.data.err) : t.shift()[0](e1.data.out);\n                    break;\n                }\n            default:\n        }\n    }, dc = async ()=>{\n        if (!ln) {\n            if (nr) throw new Error(\"multiple calls to 'initWasm()' detected.\");\n            if (cn) throw new Error(\"previous call to 'initWasm()' failed.\");\n            if (nr = !0, zt()) return new Promise((e1, t)=>{\n                Le === null || Le === void 0 ? void 0 : Le.terminate(), Va().then((param)=>{\n                    let [r, n] = param;\n                    try {\n                        var _url;\n                        Le = n, Le.onerror = (i)=>t(i), Le.onmessage = bg, Po = [\n                            e1,\n                            t\n                        ];\n                        let o = {\n                            type: \"init-wasm\",\n                            in: ve\n                        };\n                        !o.in.wasm.wasmPaths && (r || ((_url = \"file:///Users/amityadav/Desktop/Text-Behind%20Image/node_modules/onnxruntime-web/dist/ort.bundle.min.mjs\") === null || _url === void 0 ? void 0 : _url.startsWith(\"file:\"))) && (o.in.wasm.wasmPaths = {\n                            wasm: /* asset import */ new __webpack_require__.U(__webpack_require__(/*! ort-wasm-simd-threaded.jsep.wasm */ \"(app-pages-browser)/./node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm\")).href\n                        }), Le.postMessage(o), dn = r;\n                    } catch (o) {\n                        t(o);\n                    }\n                }, t);\n            });\n            try {\n                await Sr(ve.wasm), await Tr(ve), ln = !0;\n            } catch (e1) {\n                throw cn = !0, e1;\n            } finally{\n                nr = !1;\n            }\n        }\n    }, lc = async (e1)=>{\n        if (zt()) return Wt(), new Promise((t, r)=>{\n            Vt(\"init-ep\", [\n                t,\n                r\n            ]);\n            let n = {\n                type: \"init-ep\",\n                in: {\n                    epName: e1,\n                    env: ve\n                }\n            };\n            Le.postMessage(n);\n        });\n        await Ir(ve, e1);\n    }, cc = async (e1)=>zt() ? (Wt(), new Promise((t, r)=>{\n            Vt(\"copy-from\", [\n                t,\n                r\n            ]);\n            let n = {\n                type: \"copy-from\",\n                in: {\n                    buffer: e1\n                }\n            };\n            Le.postMessage(n, [\n                e1.buffer\n            ]);\n        })) : Kt(e1), pc = async (e1, t)=>{\n        if (zt()) {\n            if (t === null || t === void 0 ? void 0 : t.preferredOutputLocation) throw new Error('session option \"preferredOutputLocation\" is not supported for proxy.');\n            return Wt(), new Promise((r, n)=>{\n                Vt(\"create\", [\n                    r,\n                    n\n                ]);\n                let o = {\n                    type: \"create\",\n                    in: {\n                        model: e1,\n                        options: {\n                            ...t\n                        }\n                    }\n                }, i = [];\n                e1 instanceof Uint8Array && i.push(e1.buffer), Le.postMessage(o, i);\n            });\n        } else return Cr(e1, t);\n    }, mc = async (e1)=>{\n        if (zt()) return Wt(), new Promise((t, r)=>{\n            Vt(\"release\", [\n                t,\n                r\n            ]);\n            let n = {\n                type: \"release\",\n                in: e1\n            };\n            Le.postMessage(n);\n        });\n        Ar(e1);\n    }, fc = async (e1, t, r, n, o, i)=>{\n        if (zt()) {\n            if (r.some((a)=>a[3] !== \"cpu\")) throw new Error(\"input tensor on GPU is not supported for proxy.\");\n            if (o.some((a)=>a)) throw new Error(\"pre-allocated output tensor is not supported for proxy.\");\n            return Wt(), new Promise((a, d)=>{\n                Vt(\"run\", [\n                    a,\n                    d\n                ]);\n                let l = r, p = {\n                    type: \"run\",\n                    in: {\n                        sessionId: e1,\n                        inputIndices: t,\n                        inputs: l,\n                        outputIndices: n,\n                        options: i\n                    }\n                };\n                Le.postMessage(p, Pr(l));\n            });\n        } else return kr(e1, t, r, n, o, i);\n    }, hc = async (e1)=>{\n        if (zt()) return Wt(), new Promise((t, r)=>{\n            Vt(\"end-profiling\", [\n                t,\n                r\n            ]);\n            let n = {\n                type: \"end-profiling\",\n                in: e1\n            };\n            Le.postMessage(n);\n        });\n        Er(e1);\n    };\n});\nvar gc, yg, pn, bc = U(()=>{\n    \"use strict\";\n    We();\n    Oo();\n    te();\n    $r();\n    Xn();\n    gc = (e1, t)=>{\n        switch(e1.location){\n            case \"cpu\":\n                return [\n                    e1.type,\n                    e1.dims,\n                    e1.data,\n                    \"cpu\"\n                ];\n            case \"gpu-buffer\":\n                return [\n                    e1.type,\n                    e1.dims,\n                    {\n                        gpuBuffer: e1.gpuBuffer\n                    },\n                    \"gpu-buffer\"\n                ];\n            case \"ml-tensor\":\n                return [\n                    e1.type,\n                    e1.dims,\n                    {\n                        mlTensor: e1.mlTensor\n                    },\n                    \"ml-tensor\"\n                ];\n            default:\n                throw new Error(\"invalid data location: \".concat(e1.location, \" for \").concat(t()));\n        }\n    }, yg = (e1)=>{\n        switch(e1[3]){\n            case \"cpu\":\n                return new He(e1[0], e1[2], e1[1]);\n            case \"gpu-buffer\":\n                {\n                    let t = e1[0];\n                    if (!Br(t)) throw new Error(\"not supported data type: \".concat(t, \" for deserializing GPU tensor\"));\n                    let { gpuBuffer: r, download: n, dispose: o } = e1[2];\n                    return He.fromGpuBuffer(r, {\n                        dataType: t,\n                        dims: e1[1],\n                        download: n,\n                        dispose: o\n                    });\n                }\n            case \"ml-tensor\":\n                {\n                    let t = e1[0];\n                    if (!Mr(t)) throw new Error(\"not supported data type: \".concat(t, \" for deserializing MLTensor tensor\"));\n                    let { mlTensor: r, download: n, dispose: o } = e1[2];\n                    return He.fromMLTensor(r, {\n                        dataType: t,\n                        dims: e1[1],\n                        download: n,\n                        dispose: o\n                    });\n                }\n            default:\n                throw new Error(\"invalid data location: \".concat(e1[3]));\n        }\n    }, pn = class {\n        async fetchModelAndCopyToWasmMemory(t) {\n            return cc(await Qt(t));\n        }\n        async loadModel(t, r) {\n            Ue();\n            let n;\n            typeof t == \"string\" ?  false ? 0 : n = await this.fetchModelAndCopyToWasmMemory(t) : n = t, [this.sessionId, this.inputNames, this.outputNames] = await pc(n, r), De();\n        }\n        async dispose() {\n            return mc(this.sessionId);\n        }\n        async run(t, r, n) {\n            Ue();\n            let o = [], i = [];\n            Object.entries(t).forEach((h)=>{\n                let _ = h[0], y = h[1], g = this.inputNames.indexOf(_);\n                if (g === -1) throw new Error(\"invalid input '\".concat(_, \"'\"));\n                o.push(y), i.push(g);\n            });\n            let a = [], d = [];\n            Object.entries(r).forEach((h)=>{\n                let _ = h[0], y = h[1], g = this.outputNames.indexOf(_);\n                if (g === -1) throw new Error(\"invalid output '\".concat(_, \"'\"));\n                a.push(y), d.push(g);\n            });\n            let l = o.map((h, _)=>gc(h, ()=>'input \"'.concat(this.inputNames[i[_]], '\"'))), p = a.map((h, _)=>h ? gc(h, ()=>'output \"'.concat(this.outputNames[d[_]], '\"')) : null), m = await fc(this.sessionId, i, l, d, p, n), u = {};\n            var _a_h;\n            for(let h = 0; h < m.length; h++)u[this.outputNames[d[h]]] = (_a_h = a[h]) !== null && _a_h !== void 0 ? _a_h : yg(m[h]);\n            return De(), u;\n        }\n        startProfiling() {}\n        endProfiling() {\n            hc(this.sessionId);\n        }\n    };\n});\nvar _c = {};\nFt(_c, {\n    OnnxruntimeWebAssemblyBackend: ()=>mn,\n    initializeFlags: ()=>yc,\n    wasmBackend: ()=>_g\n});\nvar yc, mn, _g, wc = U(()=>{\n    \"use strict\";\n    We();\n    Oo();\n    bc();\n    yc = ()=>{\n        if ((typeof ve.wasm.initTimeout != \"number\" || ve.wasm.initTimeout < 0) && (ve.wasm.initTimeout = 0), ve.wasm.simd === !1 && console.warn('Deprecated property \"env.wasm.simd\" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'), typeof ve.wasm.proxy != \"boolean\" && (ve.wasm.proxy = !1), typeof ve.wasm.trace != \"boolean\" && (ve.wasm.trace = !1), typeof ve.wasm.numThreads != \"number\" || !Number.isInteger(ve.wasm.numThreads) || ve.wasm.numThreads <= 0) if (typeof self < \"u\" && !self.crossOriginIsolated) ve.wasm.numThreads = 1;\n        else {\n            let e1 = typeof navigator > \"u\" ? Nn(\"node:os\").cpus().length : navigator.hardwareConcurrency;\n            ve.wasm.numThreads = Math.min(4, Math.ceil((e1 || 1) / 2));\n        }\n    }, mn = class {\n        async init(t) {\n            yc(), await dc(), await lc(t);\n        }\n        async createInferenceSessionHandler(t, r) {\n            let n = new pn;\n            return await n.loadModel(t, r), Promise.resolve(n);\n        }\n    }, _g = new mn;\n});\nWe();\nWe();\nWe();\nvar Ca = \"1.21.0-dev.20250114-228dd16893\";\nvar $1 = Fn;\n{\n    let e1 = (wc(), br(_c)).wasmBackend;\n    St(\"webgpu\", e1, 5), St(\"webnn\", e1, 5), St(\"cpu\", e1, 10), St(\"wasm\", e1, 10);\n}Object.defineProperty(ve.versions, \"web\", {\n    value: Ca,\n    enumerable: !0\n});\n /**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */  /**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */  /**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */  //# sourceMappingURL=ort.bundle.min.mjs.map\nvar _c1, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9, _c10;\n$RefreshReg$(_c1, \"Sa$U\");\n$RefreshReg$(_c2, \"Sa\");\n$RefreshReg$(_c3, \"Ta$U\");\n$RefreshReg$(_c4, \"Ta\");\n$RefreshReg$(_c5, \"Ia$U\");\n$RefreshReg$(_c6, \"Ia\");\n$RefreshReg$(_c7, \"We$U\");\n$RefreshReg$(_c8, \"We\");\n$RefreshReg$(_c9, \"Nr$U\");\n$RefreshReg$(_c10, \"Nr\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS13ZWIvZGlzdC9vcnQuYnVuZGxlLm1pbi5tanM/M2Y0NyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBOzs7O0NBSUMsR0FDRCxJQUFJQSxLQUFHQyxPQUFPQyxjQUFjO0FBQUMsSUFBSUMsS0FBR0YsT0FBT0csd0JBQXdCO0FBQUMsSUFBSUMsS0FBR0osT0FBT0ssbUJBQW1CO0FBQUMsSUFBSUMsS0FBR04sT0FBT08sU0FBUyxDQUFDQyxjQUFjO0FBQUMsSUFBSUMsS0FBRyxDQUFDQyxDQUFBQSxLQUFHLE9BQU9DLFVBQVEsTUFBSUEsVUFBUSxPQUFPQyxRQUFNLE1BQUksSUFBSUEsTUFBTUYsSUFBRTtRQUFDRyxLQUFJLENBQUNDLEdBQUVDLElBQUksQ0FBQyxPQUFPSixVQUFRLE1BQUlBLFVBQVFHLENBQUFBLENBQUUsQ0FBQ0MsRUFBRTtJQUFBLEtBQUdMLEVBQUFBLEVBQUcsU0FBU0EsRUFBQztJQUFFLElBQUcsT0FBT0MsVUFBUSxLQUFJLE9BQU9BLFFBQVFLLEtBQUssQ0FBQyxJQUFJLEVBQUNDO0lBQVcsTUFBTUMsTUFBTSx5QkFBdUJSLEtBQUU7QUFBcUI7QUFBRyxJQUFJUyxJQUFFLENBQUNULElBQUVJLElBQUksSUFBS0osQ0FBQUEsTUFBSUksQ0FBQUEsSUFBRUosR0FBRUEsS0FBRSxFQUFDLEdBQUdJLENBQUFBO0FBQUcsSUFBSU0sS0FBRyxDQUFDVixJQUFFSTtJQUFLLElBQUksSUFBSUMsS0FBS0QsRUFBRWYsR0FBR1csSUFBRUssR0FBRTtRQUFDRixLQUFJQyxDQUFDLENBQUNDLEVBQUU7UUFBQ00sWUFBVyxDQUFDO0lBQUM7QUFBRSxHQUFFQyxLQUFHLENBQUNaLElBQUVJLEdBQUVDLEdBQUVRO0lBQUssSUFBR1QsS0FBRyxPQUFPQSxLQUFHLFlBQVUsT0FBT0EsS0FBRyxZQUFXLEtBQUksSUFBSVUsS0FBS3BCLEdBQUdVLEdBQUcsQ0FBQ1IsR0FBR21C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RXF6RCxTQUFTLENBQUM5ekQsR0FBRUMsSUFBR3NILFFBQVFtTCxPQUFPLENBQUNqUztRQUFFO0lBQUMsR0FBRTR6RCxLQUFHLElBQUlKO0FBQUU7QUFBR3ZtRDtBQUFLQTtBQUFLQTtBQUFLLElBQUlnbUIsS0FBRztBQUFpQyxJQUFJK2dDLEtBQUd2bkQ7QUFBRztJQUFDLElBQUl0TixLQUFFLENBQUMwMEQsTUFBSzF6RCxHQUFHbXpELEdBQUUsRUFBR0ssV0FBVztJQUFDcHpELEdBQUcsVUFBU3BCLElBQUUsSUFBR29CLEdBQUcsU0FBUXBCLElBQUUsSUFBR29CLEdBQUcsT0FBTXBCLElBQUUsS0FBSW9CLEdBQUcsUUFBT3BCLElBQUU7QUFBRyxDQUFDVixPQUFPQyxjQUFjLENBQUM4RSxHQUFHSCxRQUFRLEVBQUMsT0FBTTtJQUFDakQsT0FBTTZ5QjtJQUFHbnpCLFlBQVcsQ0FBQztBQUFDO0FBQXFKLENBQ3RnekM7Ozs7Ozs7Ozs7Ozs7OztDQWVDLElBQ0Q7Ozs7Ozs7Ozs7Ozs7OztDQWVDLElBQ0Q7Ozs7Ozs7Ozs7Ozs7OztDQWVDLElBQ0QsMkNBQTJDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS13ZWIvZGlzdC9vcnQuYnVuZGxlLm1pbi5tanM/Mjc1OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIE9OTlggUnVudGltZSBXZWIgdjEuMjEuMC1kZXYuMjAyNTAxMTQtMjI4ZGQxNjg5M1xuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbnZhciBVbj1PYmplY3QuZGVmaW5lUHJvcGVydHk7dmFyIFZwPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7dmFyIFdwPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO3ZhciBMcD1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O3ZhciBObj0oZT0+dHlwZW9mIHJlcXVpcmU8XCJ1XCI/cmVxdWlyZTp0eXBlb2YgUHJveHk8XCJ1XCI/bmV3IFByb3h5KGUse2dldDoodCxyKT0+KHR5cGVvZiByZXF1aXJlPFwidVwiP3JlcXVpcmU6dClbcl19KTplKShmdW5jdGlvbihlKXtpZih0eXBlb2YgcmVxdWlyZTxcInVcIilyZXR1cm4gcmVxdWlyZS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dGhyb3cgRXJyb3IoJ0R5bmFtaWMgcmVxdWlyZSBvZiBcIicrZSsnXCIgaXMgbm90IHN1cHBvcnRlZCcpfSk7dmFyIFU9KGUsdCk9PigpPT4oZSYmKHQ9ZShlPTApKSx0KTt2YXIgRnQ9KGUsdCk9Pntmb3IodmFyIHIgaW4gdClVbihlLHIse2dldDp0W3JdLGVudW1lcmFibGU6ITB9KX0sR3A9KGUsdCxyLG4pPT57aWYodCYmdHlwZW9mIHQ9PVwib2JqZWN0XCJ8fHR5cGVvZiB0PT1cImZ1bmN0aW9uXCIpZm9yKGxldCBvIG9mIFdwKHQpKSFMcC5jYWxsKGUsbykmJm8hPT1yJiZVbihlLG8se2dldDooKT0+dFtvXSxlbnVtZXJhYmxlOiEobj1WcCh0LG8pKXx8bi5lbnVtZXJhYmxlfSk7cmV0dXJuIGV9O3ZhciBicj1lPT5HcChVbih7fSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlKTt2YXIgeXIseHQsU3QsSHAsSmksVm49VSgoKT0+e1widXNlIHN0cmljdFwiO3lyPW5ldyBNYXAseHQ9W10sU3Q9KGUsdCxyKT0+e2lmKHQmJnR5cGVvZiB0LmluaXQ9PVwiZnVuY3Rpb25cIiYmdHlwZW9mIHQuY3JlYXRlSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXI9PVwiZnVuY3Rpb25cIil7bGV0IG49eXIuZ2V0KGUpO2lmKG49PT12b2lkIDApeXIuc2V0KGUse2JhY2tlbmQ6dCxwcmlvcml0eTpyfSk7ZWxzZXtpZihuLnByaW9yaXR5PnIpcmV0dXJuO2lmKG4ucHJpb3JpdHk9PT1yJiZuLmJhY2tlbmQhPT10KXRocm93IG5ldyBFcnJvcihgY2Fubm90IHJlZ2lzdGVyIGJhY2tlbmQgXCIke2V9XCIgdXNpbmcgcHJpb3JpdHkgJHtyfWApfWlmKHI+PTApe2xldCBvPXh0LmluZGV4T2YoZSk7byE9PS0xJiZ4dC5zcGxpY2UobywxKTtmb3IobGV0IGk9MDtpPHh0Lmxlbmd0aDtpKyspaWYoeXIuZ2V0KHh0W2ldKS5wcmlvcml0eTw9cil7eHQuc3BsaWNlKGksMCxlKTtyZXR1cm59eHQucHVzaChlKX1yZXR1cm59dGhyb3cgbmV3IFR5cGVFcnJvcihcIm5vdCBhIHZhbGlkIGJhY2tlbmRcIil9LEhwPWFzeW5jIGU9PntsZXQgdD15ci5nZXQoZSk7aWYoIXQpcmV0dXJuXCJiYWNrZW5kIG5vdCBmb3VuZC5cIjtpZih0LmluaXRpYWxpemVkKXJldHVybiB0LmJhY2tlbmQ7aWYodC5hYm9ydGVkKXJldHVybiB0LmVycm9yO3tsZXQgcj0hIXQuaW5pdFByb21pc2U7dHJ5e3JldHVybiByfHwodC5pbml0UHJvbWlzZT10LmJhY2tlbmQuaW5pdChlKSksYXdhaXQgdC5pbml0UHJvbWlzZSx0LmluaXRpYWxpemVkPSEwLHQuYmFja2VuZH1jYXRjaChuKXtyZXR1cm4gcnx8KHQuZXJyb3I9YCR7bn1gLHQuYWJvcnRlZD0hMCksdC5lcnJvcn1maW5hbGx5e2RlbGV0ZSB0LmluaXRQcm9taXNlfX19LEppPWFzeW5jIGU9PntsZXQgdD1lLmV4ZWN1dGlvblByb3ZpZGVyc3x8W10scj10Lm1hcChsPT50eXBlb2YgbD09XCJzdHJpbmdcIj9sOmwubmFtZSksbj1yLmxlbmd0aD09PTA/eHQ6cixvLGk9W10sYT1uZXcgU2V0O2ZvcihsZXQgbCBvZiBuKXtsZXQgcD1hd2FpdCBIcChsKTt0eXBlb2YgcD09XCJzdHJpbmdcIj9pLnB1c2goe25hbWU6bCxlcnI6cH0pOihvfHwobz1wKSxvPT09cCYmYS5hZGQobCkpfWlmKCFvKXRocm93IG5ldyBFcnJvcihgbm8gYXZhaWxhYmxlIGJhY2tlbmQgZm91bmQuIEVSUjogJHtpLm1hcChsPT5gWyR7bC5uYW1lfV0gJHtsLmVycn1gKS5qb2luKFwiLCBcIil9YCk7Zm9yKGxldHtuYW1lOmwsZXJyOnB9b2YgaSlyLmluY2x1ZGVzKGwpJiZjb25zb2xlLndhcm4oYHJlbW92aW5nIHJlcXVlc3RlZCBleGVjdXRpb24gcHJvdmlkZXIgXCIke2x9XCIgZnJvbSBzZXNzaW9uIG9wdGlvbnMgYmVjYXVzZSBpdCBpcyBub3QgYXZhaWxhYmxlOiAke3B9YCk7bGV0IGQ9dC5maWx0ZXIobD0+YS5oYXModHlwZW9mIGw9PVwic3RyaW5nXCI/bDpsLm5hbWUpKTtyZXR1cm5bbyxuZXcgUHJveHkoZSx7Z2V0OihsLHApPT5wPT09XCJleGVjdXRpb25Qcm92aWRlcnNcIj9kOlJlZmxlY3QuZ2V0KGwscCl9KV19fSk7dmFyIGVhPVUoKCk9PntcInVzZSBzdHJpY3RcIjtWbigpfSk7dmFyIHRhLHJhPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0YT1cIjEuMjEuMC1kZXYuMjAyNDEyMTItMWY4ODI4NGY5NlwifSk7dmFyIG5hLFJlLFduPVUoKCk9PntcInVzZSBzdHJpY3RcIjtyYSgpO25hPVwid2FybmluZ1wiLFJlPXt3YXNtOnt9LHdlYmdsOnt9LHdlYmdwdTp7fSx2ZXJzaW9uczp7Y29tbW9uOnRhfSxzZXQgbG9nTGV2ZWwoZSl7aWYoZSE9PXZvaWQgMCl7aWYodHlwZW9mIGUhPVwic3RyaW5nXCJ8fFtcInZlcmJvc2VcIixcImluZm9cIixcIndhcm5pbmdcIixcImVycm9yXCIsXCJmYXRhbFwiXS5pbmRleE9mKGUpPT09LTEpdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBsb2dnaW5nIGxldmVsOiAke2V9YCk7bmE9ZX19LGdldCBsb2dMZXZlbCgpe3JldHVybiBuYX19O09iamVjdC5kZWZpbmVQcm9wZXJ0eShSZSxcImxvZ0xldmVsXCIse2VudW1lcmFibGU6ITB9KX0pO3ZhciB2ZSxvYT1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7V24oKTt2ZT1SZX0pO3ZhciBpYSxhYSxzYT1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7aWE9KGUsdCk9PntsZXQgcj10eXBlb2YgZG9jdW1lbnQ8XCJ1XCI/ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTpuZXcgT2Zmc2NyZWVuQ2FudmFzKDEsMSk7ci53aWR0aD1lLmRpbXNbM10sci5oZWlnaHQ9ZS5kaW1zWzJdO2xldCBuPXIuZ2V0Q29udGV4dChcIjJkXCIpO2lmKG4hPW51bGwpe2xldCBvLGk7dD8udGVuc29yTGF5b3V0IT09dm9pZCAwJiZ0LnRlbnNvckxheW91dD09PVwiTkhXQ1wiPyhvPWUuZGltc1syXSxpPWUuZGltc1szXSk6KG89ZS5kaW1zWzNdLGk9ZS5kaW1zWzJdKTtsZXQgYT10Py5mb3JtYXQhPT12b2lkIDA/dC5mb3JtYXQ6XCJSR0JcIixkPXQ/Lm5vcm0sbCxwO2Q9PT12b2lkIDB8fGQubWVhbj09PXZvaWQgMD9sPVsyNTUsMjU1LDI1NSwyNTVdOnR5cGVvZiBkLm1lYW49PVwibnVtYmVyXCI/bD1bZC5tZWFuLGQubWVhbixkLm1lYW4sZC5tZWFuXToobD1bZC5tZWFuWzBdLGQubWVhblsxXSxkLm1lYW5bMl0sMF0sZC5tZWFuWzNdIT09dm9pZCAwJiYobFszXT1kLm1lYW5bM10pKSxkPT09dm9pZCAwfHxkLmJpYXM9PT12b2lkIDA/cD1bMCwwLDAsMF06dHlwZW9mIGQuYmlhcz09XCJudW1iZXJcIj9wPVtkLmJpYXMsZC5iaWFzLGQuYmlhcyxkLmJpYXNdOihwPVtkLmJpYXNbMF0sZC5iaWFzWzFdLGQuYmlhc1syXSwwXSxkLmJpYXNbM10hPT12b2lkIDAmJihwWzNdPWQuYmlhc1szXSkpO2xldCBtPWkqbyx1PTAsaD1tLF89bSoyLHk9LTE7YT09PVwiUkdCQVwiPyh1PTAsaD1tLF89bSoyLHk9bSozKTphPT09XCJSR0JcIj8odT0wLGg9bSxfPW0qMik6YT09PVwiUkJHXCImJih1PTAsXz1tLGg9bSoyKTtmb3IobGV0IGc9MDtnPGk7ZysrKWZvcihsZXQgeD0wO3g8bzt4Kyspe2xldCAkPShlLmRhdGFbdSsrXS1wWzBdKSpsWzBdLHY9KGUuZGF0YVtoKytdLXBbMV0pKmxbMV0sUz0oZS5kYXRhW18rK10tcFsyXSkqbFsyXSxUPXk9PT0tMT8yNTU6KGUuZGF0YVt5KytdLXBbM10pKmxbM107bi5maWxsU3R5bGU9XCJyZ2JhKFwiKyQrXCIsXCIrditcIixcIitTK1wiLFwiK1QrXCIpXCIsbi5maWxsUmVjdCh4LGcsMSwxKX1pZihcInRvRGF0YVVSTFwiaW4gcilyZXR1cm4gci50b0RhdGFVUkwoKTt0aHJvdyBuZXcgRXJyb3IoXCJ0b0RhdGFVUkwgaXMgbm90IHN1cHBvcnRlZFwiKX1lbHNlIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgYWNjZXNzIGltYWdlIGRhdGFcIil9LGFhPShlLHQpPT57bGV0IHI9dHlwZW9mIGRvY3VtZW50PFwidVwiP2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIikuZ2V0Q29udGV4dChcIjJkXCIpOm5ldyBPZmZzY3JlZW5DYW52YXMoMSwxKS5nZXRDb250ZXh0KFwiMmRcIiksbjtpZihyIT1udWxsKXtsZXQgbyxpLGE7dD8udGVuc29yTGF5b3V0IT09dm9pZCAwJiZ0LnRlbnNvckxheW91dD09PVwiTkhXQ1wiPyhvPWUuZGltc1syXSxpPWUuZGltc1sxXSxhPWUuZGltc1szXSk6KG89ZS5kaW1zWzNdLGk9ZS5kaW1zWzJdLGE9ZS5kaW1zWzFdKTtsZXQgZD10IT09dm9pZCAwJiZ0LmZvcm1hdCE9PXZvaWQgMD90LmZvcm1hdDpcIlJHQlwiLGw9dD8ubm9ybSxwLG07bD09PXZvaWQgMHx8bC5tZWFuPT09dm9pZCAwP3A9WzI1NSwyNTUsMjU1LDI1NV06dHlwZW9mIGwubWVhbj09XCJudW1iZXJcIj9wPVtsLm1lYW4sbC5tZWFuLGwubWVhbixsLm1lYW5dOihwPVtsLm1lYW5bMF0sbC5tZWFuWzFdLGwubWVhblsyXSwyNTVdLGwubWVhblszXSE9PXZvaWQgMCYmKHBbM109bC5tZWFuWzNdKSksbD09PXZvaWQgMHx8bC5iaWFzPT09dm9pZCAwP209WzAsMCwwLDBdOnR5cGVvZiBsLmJpYXM9PVwibnVtYmVyXCI/bT1bbC5iaWFzLGwuYmlhcyxsLmJpYXMsbC5iaWFzXToobT1bbC5iaWFzWzBdLGwuYmlhc1sxXSxsLmJpYXNbMl0sMF0sbC5iaWFzWzNdIT09dm9pZCAwJiYobVszXT1sLmJpYXNbM10pKTtsZXQgdT1pKm87aWYodCE9PXZvaWQgMCYmKHQuZm9ybWF0IT09dm9pZCAwJiZhPT09NCYmdC5mb3JtYXQhPT1cIlJHQkFcInx8YT09PTMmJnQuZm9ybWF0IT09XCJSR0JcIiYmdC5mb3JtYXQhPT1cIkJHUlwiKSl0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3IgZm9ybWF0IGRvZXNuJ3QgbWF0Y2ggaW5wdXQgdGVuc29yIGRpbXNcIik7bGV0IGg9NCxfPTAseT0xLGc9Mix4PTMsJD0wLHY9dSxTPXUqMixUPS0xO2Q9PT1cIlJHQkFcIj8oJD0wLHY9dSxTPXUqMixUPXUqMyk6ZD09PVwiUkdCXCI/KCQ9MCx2PXUsUz11KjIpOmQ9PT1cIlJCR1wiJiYoJD0wLFM9dSx2PXUqMiksbj1yLmNyZWF0ZUltYWdlRGF0YShvLGkpO2ZvcihsZXQgQT0wO0E8aSpvO18rPWgseSs9aCxnKz1oLHgrPWgsQSsrKW4uZGF0YVtfXT0oZS5kYXRhWyQrK10tbVswXSkqcFswXSxuLmRhdGFbeV09KGUuZGF0YVt2KytdLW1bMV0pKnBbMV0sbi5kYXRhW2ddPShlLmRhdGFbUysrXS1tWzJdKSpwWzJdLG4uZGF0YVt4XT1UPT09LTE/MjU1OihlLmRhdGFbVCsrXS1tWzNdKSpwWzNdfWVsc2UgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YVwiKTtyZXR1cm4gbn19KTt2YXIgTG4sdWEsZGEsbGEsY2EscGEsbWE9VSgoKT0+e1widXNlIHN0cmljdFwiO19yKCk7TG49KGUsdCk9PntpZihlPT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIkltYWdlIGJ1ZmZlciBtdXN0IGJlIGRlZmluZWRcIik7aWYodC5oZWlnaHQ9PT12b2lkIDB8fHQud2lkdGg9PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiSW1hZ2UgaGVpZ2h0IGFuZCB3aWR0aCBtdXN0IGJlIGRlZmluZWRcIik7aWYodC50ZW5zb3JMYXlvdXQ9PT1cIk5IV0NcIil0aHJvdyBuZXcgRXJyb3IoXCJOSFdDIFRlbnNvciBsYXlvdXQgaXMgbm90IHN1cHBvcnRlZCB5ZXRcIik7bGV0e2hlaWdodDpyLHdpZHRoOm59PXQsbz10Lm5vcm0/P3ttZWFuOjI1NSxiaWFzOjB9LGksYTt0eXBlb2Ygby5tZWFuPT1cIm51bWJlclwiP2k9W28ubWVhbixvLm1lYW4sby5tZWFuLG8ubWVhbl06aT1bby5tZWFuWzBdLG8ubWVhblsxXSxvLm1lYW5bMl0sby5tZWFuWzNdPz8yNTVdLHR5cGVvZiBvLmJpYXM9PVwibnVtYmVyXCI/YT1bby5iaWFzLG8uYmlhcyxvLmJpYXMsby5iaWFzXTphPVtvLmJpYXNbMF0sby5iaWFzWzFdLG8uYmlhc1syXSxvLmJpYXNbM10/PzBdO2xldCBkPXQuZm9ybWF0IT09dm9pZCAwP3QuZm9ybWF0OlwiUkdCQVwiLGw9dC50ZW5zb3JGb3JtYXQhPT12b2lkIDAmJnQudGVuc29yRm9ybWF0IT09dm9pZCAwP3QudGVuc29yRm9ybWF0OlwiUkdCXCIscD1yKm4sbT1sPT09XCJSR0JBXCI/bmV3IEZsb2F0MzJBcnJheShwKjQpOm5ldyBGbG9hdDMyQXJyYXkocCozKSx1PTQsaD0wLF89MSx5PTIsZz0zLHg9MCwkPXAsdj1wKjIsUz0tMTtkPT09XCJSR0JcIiYmKHU9MyxoPTAsXz0xLHk9MixnPS0xKSxsPT09XCJSR0JBXCI/Uz1wKjM6bD09PVwiUkJHXCI/KHg9MCx2PXAsJD1wKjIpOmw9PT1cIkJHUlwiJiYodj0wLCQ9cCx4PXAqMik7Zm9yKGxldCBBPTA7QTxwO0ErKyxoKz11LHkrPXUsXys9dSxnKz11KW1beCsrXT0oZVtoXSthWzBdKS9pWzBdLG1bJCsrXT0oZVtfXSthWzFdKS9pWzFdLG1bdisrXT0oZVt5XSthWzJdKS9pWzJdLFMhPT0tMSYmZyE9PS0xJiYobVtTKytdPShlW2ddK2FbM10pL2lbM10pO3JldHVybiBsPT09XCJSR0JBXCI/bmV3IHplKFwiZmxvYXQzMlwiLG0sWzEsNCxyLG5dKTpuZXcgemUoXCJmbG9hdDMyXCIsbSxbMSwzLHIsbl0pfSx1YT1hc3luYyhlLHQpPT57bGV0IHI9dHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQ8XCJ1XCImJmUgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50LG49dHlwZW9mIEltYWdlRGF0YTxcInVcIiYmZSBpbnN0YW5jZW9mIEltYWdlRGF0YSxvPXR5cGVvZiBJbWFnZUJpdG1hcDxcInVcIiYmZSBpbnN0YW5jZW9mIEltYWdlQml0bWFwLGk9dHlwZW9mIGU9PVwic3RyaW5nXCIsYSxkPXQ/P3t9LGw9KCk9PntpZih0eXBlb2YgZG9jdW1lbnQ8XCJ1XCIpcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7aWYodHlwZW9mIE9mZnNjcmVlbkNhbnZhczxcInVcIilyZXR1cm4gbmV3IE9mZnNjcmVlbkNhbnZhcygxLDEpO3Rocm93IG5ldyBFcnJvcihcIkNhbnZhcyBpcyBub3Qgc3VwcG9ydGVkXCIpfSxwPW09PnR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudDxcInVcIiYmbSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50fHxtIGluc3RhbmNlb2YgT2Zmc2NyZWVuQ2FudmFzP20uZ2V0Q29udGV4dChcIjJkXCIpOm51bGw7aWYocil7bGV0IG09bCgpO20ud2lkdGg9ZS53aWR0aCxtLmhlaWdodD1lLmhlaWdodDtsZXQgdT1wKG0pO2lmKHUhPW51bGwpe2xldCBoPWUuaGVpZ2h0LF89ZS53aWR0aDtpZih0IT09dm9pZCAwJiZ0LnJlc2l6ZWRIZWlnaHQhPT12b2lkIDAmJnQucmVzaXplZFdpZHRoIT09dm9pZCAwJiYoaD10LnJlc2l6ZWRIZWlnaHQsXz10LnJlc2l6ZWRXaWR0aCksdCE9PXZvaWQgMCl7aWYoZD10LHQudGVuc29yRm9ybWF0IT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIkltYWdlIGlucHV0IGNvbmZpZyBmb3JtYXQgbXVzdCBiZSBSR0JBIGZvciBIVE1MSW1hZ2VFbGVtZW50XCIpO2QudGVuc29yRm9ybWF0PVwiUkdCQVwiLGQuaGVpZ2h0PWgsZC53aWR0aD1ffWVsc2UgZC50ZW5zb3JGb3JtYXQ9XCJSR0JBXCIsZC5oZWlnaHQ9aCxkLndpZHRoPV87dS5kcmF3SW1hZ2UoZSwwLDApLGE9dS5nZXRJbWFnZURhdGEoMCwwLF8saCkuZGF0YX1lbHNlIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgYWNjZXNzIGltYWdlIGRhdGFcIil9ZWxzZSBpZihuKXtsZXQgbSx1O2lmKHQhPT12b2lkIDAmJnQucmVzaXplZFdpZHRoIT09dm9pZCAwJiZ0LnJlc2l6ZWRIZWlnaHQhPT12b2lkIDA/KG09dC5yZXNpemVkSGVpZ2h0LHU9dC5yZXNpemVkV2lkdGgpOihtPWUuaGVpZ2h0LHU9ZS53aWR0aCksdCE9PXZvaWQgMCYmKGQ9dCksZC5mb3JtYXQ9XCJSR0JBXCIsZC5oZWlnaHQ9bSxkLndpZHRoPXUsdCE9PXZvaWQgMCl7bGV0IGg9bCgpO2gud2lkdGg9dSxoLmhlaWdodD1tO2xldCBfPXAoaCk7aWYoXyE9bnVsbClfLnB1dEltYWdlRGF0YShlLDAsMCksYT1fLmdldEltYWdlRGF0YSgwLDAsdSxtKS5kYXRhO2Vsc2UgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YVwiKX1lbHNlIGE9ZS5kYXRhfWVsc2UgaWYobyl7aWYodD09PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgcHJvdmlkZSBpbWFnZSBjb25maWcgd2l0aCBmb3JtYXQgZm9yIEltYWdlYml0bWFwXCIpO2xldCBtPWwoKTttLndpZHRoPWUud2lkdGgsbS5oZWlnaHQ9ZS5oZWlnaHQ7bGV0IHU9cChtKTtpZih1IT1udWxsKXtsZXQgaD1lLmhlaWdodCxfPWUud2lkdGg7cmV0dXJuIHUuZHJhd0ltYWdlKGUsMCwwLF8saCksYT11LmdldEltYWdlRGF0YSgwLDAsXyxoKS5kYXRhLGQuaGVpZ2h0PWgsZC53aWR0aD1fLExuKGEsZCl9ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhXCIpfWVsc2V7aWYoaSlyZXR1cm4gbmV3IFByb21pc2UoKG0sdSk9PntsZXQgaD1sKCksXz1wKGgpO2lmKCFlfHwhXylyZXR1cm4gdSgpO2xldCB5PW5ldyBJbWFnZTt5LmNyb3NzT3JpZ2luPVwiQW5vbnltb3VzXCIseS5zcmM9ZSx5Lm9ubG9hZD0oKT0+e2gud2lkdGg9eS53aWR0aCxoLmhlaWdodD15LmhlaWdodCxfLmRyYXdJbWFnZSh5LDAsMCxoLndpZHRoLGguaGVpZ2h0KTtsZXQgZz1fLmdldEltYWdlRGF0YSgwLDAsaC53aWR0aCxoLmhlaWdodCk7ZC5oZWlnaHQ9aC5oZWlnaHQsZC53aWR0aD1oLndpZHRoLG0oTG4oZy5kYXRhLGQpKX19KTt0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBkYXRhIHByb3ZpZGVkIGlzIG5vdCBzdXBwb3J0ZWQgLSBhYm9ydGVkIHRlbnNvciBjcmVhdGlvblwiKX1pZihhIT09dm9pZCAwKXJldHVybiBMbihhLGQpO3Rocm93IG5ldyBFcnJvcihcIklucHV0IGRhdGEgcHJvdmlkZWQgaXMgbm90IHN1cHBvcnRlZCAtIGFib3J0ZWQgdGVuc29yIGNyZWF0aW9uXCIpfSxkYT0oZSx0KT0+e2xldHt3aWR0aDpyLGhlaWdodDpuLGRvd25sb2FkOm8sZGlzcG9zZTppfT10LGE9WzEsbixyLDRdO3JldHVybiBuZXcgemUoe2xvY2F0aW9uOlwidGV4dHVyZVwiLHR5cGU6XCJmbG9hdDMyXCIsdGV4dHVyZTplLGRpbXM6YSxkb3dubG9hZDpvLGRpc3Bvc2U6aX0pfSxsYT0oZSx0KT0+e2xldHtkYXRhVHlwZTpyLGRpbXM6bixkb3dubG9hZDpvLGRpc3Bvc2U6aX09dDtyZXR1cm4gbmV3IHplKHtsb2NhdGlvbjpcImdwdS1idWZmZXJcIix0eXBlOnI/P1wiZmxvYXQzMlwiLGdwdUJ1ZmZlcjplLGRpbXM6bixkb3dubG9hZDpvLGRpc3Bvc2U6aX0pfSxjYT0oZSx0KT0+e2xldHtkYXRhVHlwZTpyLGRpbXM6bixkb3dubG9hZDpvLGRpc3Bvc2U6aX09dDtyZXR1cm4gbmV3IHplKHtsb2NhdGlvbjpcIm1sLXRlbnNvclwiLHR5cGU6cj8/XCJmbG9hdDMyXCIsbWxUZW5zb3I6ZSxkaW1zOm4sZG93bmxvYWQ6byxkaXNwb3NlOml9KX0scGE9KGUsdCxyKT0+bmV3IHplKHtsb2NhdGlvbjpcImNwdS1waW5uZWRcIix0eXBlOmUsZGF0YTp0LGRpbXM6cj8/W3QubGVuZ3RoXX0pfSk7dmFyIFR0LHF0LGZhLGhhLGdhPVUoKCk9PntcInVzZSBzdHJpY3RcIjtUdD1uZXcgTWFwKFtbXCJmbG9hdDMyXCIsRmxvYXQzMkFycmF5XSxbXCJ1aW50OFwiLFVpbnQ4QXJyYXldLFtcImludDhcIixJbnQ4QXJyYXldLFtcInVpbnQxNlwiLFVpbnQxNkFycmF5XSxbXCJpbnQxNlwiLEludDE2QXJyYXldLFtcImludDMyXCIsSW50MzJBcnJheV0sW1wiYm9vbFwiLFVpbnQ4QXJyYXldLFtcImZsb2F0NjRcIixGbG9hdDY0QXJyYXldLFtcInVpbnQzMlwiLFVpbnQzMkFycmF5XSxbXCJpbnQ0XCIsVWludDhBcnJheV0sW1widWludDRcIixVaW50OEFycmF5XV0pLHF0PW5ldyBNYXAoW1tGbG9hdDMyQXJyYXksXCJmbG9hdDMyXCJdLFtVaW50OEFycmF5LFwidWludDhcIl0sW0ludDhBcnJheSxcImludDhcIl0sW1VpbnQxNkFycmF5LFwidWludDE2XCJdLFtJbnQxNkFycmF5LFwiaW50MTZcIl0sW0ludDMyQXJyYXksXCJpbnQzMlwiXSxbRmxvYXQ2NEFycmF5LFwiZmxvYXQ2NFwiXSxbVWludDMyQXJyYXksXCJ1aW50MzJcIl1dKSxmYT0hMSxoYT0oKT0+e2lmKCFmYSl7ZmE9ITA7bGV0IGU9dHlwZW9mIEJpZ0ludDY0QXJyYXk8XCJ1XCImJkJpZ0ludDY0QXJyYXkuZnJvbSx0PXR5cGVvZiBCaWdVaW50NjRBcnJheTxcInVcIiYmQmlnVWludDY0QXJyYXkuZnJvbSxyPXR5cGVvZiBGbG9hdDE2QXJyYXk8XCJ1XCImJkZsb2F0MTZBcnJheS5mcm9tO2UmJihUdC5zZXQoXCJpbnQ2NFwiLEJpZ0ludDY0QXJyYXkpLHF0LnNldChCaWdJbnQ2NEFycmF5LFwiaW50NjRcIikpLHQmJihUdC5zZXQoXCJ1aW50NjRcIixCaWdVaW50NjRBcnJheSkscXQuc2V0KEJpZ1VpbnQ2NEFycmF5LFwidWludDY0XCIpKSxyPyhUdC5zZXQoXCJmbG9hdDE2XCIsRmxvYXQxNkFycmF5KSxxdC5zZXQoRmxvYXQxNkFycmF5LFwiZmxvYXQxNlwiKSk6VHQuc2V0KFwiZmxvYXQxNlwiLFVpbnQxNkFycmF5KX19fSk7dmFyIGJhLHlhLF9hPVUoKCk9PntcInVzZSBzdHJpY3RcIjtfcigpO2JhPWU9PntsZXQgdD0xO2ZvcihsZXQgcj0wO3I8ZS5sZW5ndGg7cisrKXtsZXQgbj1lW3JdO2lmKHR5cGVvZiBuIT1cIm51bWJlclwifHwhTnVtYmVyLmlzU2FmZUludGVnZXIobikpdGhyb3cgbmV3IFR5cGVFcnJvcihgZGltc1ske3J9XSBtdXN0IGJlIGFuIGludGVnZXIsIGdvdDogJHtufWApO2lmKG48MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihgZGltc1ske3J9XSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIsIGdvdDogJHtufWApO3QqPW59cmV0dXJuIHR9LHlhPShlLHQpPT57c3dpdGNoKGUubG9jYXRpb24pe2Nhc2VcImNwdVwiOnJldHVybiBuZXcgemUoZS50eXBlLGUuZGF0YSx0KTtjYXNlXCJjcHUtcGlubmVkXCI6cmV0dXJuIG5ldyB6ZSh7bG9jYXRpb246XCJjcHUtcGlubmVkXCIsZGF0YTplLmRhdGEsdHlwZTplLnR5cGUsZGltczp0fSk7Y2FzZVwidGV4dHVyZVwiOnJldHVybiBuZXcgemUoe2xvY2F0aW9uOlwidGV4dHVyZVwiLHRleHR1cmU6ZS50ZXh0dXJlLHR5cGU6ZS50eXBlLGRpbXM6dH0pO2Nhc2VcImdwdS1idWZmZXJcIjpyZXR1cm4gbmV3IHplKHtsb2NhdGlvbjpcImdwdS1idWZmZXJcIixncHVCdWZmZXI6ZS5ncHVCdWZmZXIsdHlwZTplLnR5cGUsZGltczp0fSk7Y2FzZVwibWwtdGVuc29yXCI6cmV0dXJuIG5ldyB6ZSh7bG9jYXRpb246XCJtbC10ZW5zb3JcIixtbFRlbnNvcjplLm1sVGVuc29yLHR5cGU6ZS50eXBlLGRpbXM6dH0pO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB0ZW5zb3JSZXNoYXBlOiB0ZW5zb3IgbG9jYXRpb24gJHtlLmxvY2F0aW9ufSBpcyBub3Qgc3VwcG9ydGVkYCl9fX0pO3ZhciB6ZSxfcj1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7c2EoKTttYSgpO2dhKCk7X2EoKTt6ZT1jbGFzc3tjb25zdHJ1Y3Rvcih0LHIsbil7aGEoKTtsZXQgbyxpO2lmKHR5cGVvZiB0PT1cIm9iamVjdFwiJiZcImxvY2F0aW9uXCJpbiB0KXN3aXRjaCh0aGlzLmRhdGFMb2NhdGlvbj10LmxvY2F0aW9uLG89dC50eXBlLGk9dC5kaW1zLHQubG9jYXRpb24pe2Nhc2VcImNwdS1waW5uZWRcIjp7bGV0IGQ9VHQuZ2V0KG8pO2lmKCFkKXRocm93IG5ldyBUeXBlRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGUgXCIke299XCIgdG8gY3JlYXRlIHRlbnNvciBmcm9tIHBpbm5lZCBidWZmZXJgKTtpZighKHQuZGF0YSBpbnN0YW5jZW9mIGQpKXRocm93IG5ldyBUeXBlRXJyb3IoYGJ1ZmZlciBzaG91bGQgYmUgb2YgdHlwZSAke2QubmFtZX1gKTt0aGlzLmNwdURhdGE9dC5kYXRhO2JyZWFrfWNhc2VcInRleHR1cmVcIjp7aWYobyE9PVwiZmxvYXQzMlwiKXRocm93IG5ldyBUeXBlRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGUgXCIke299XCIgdG8gY3JlYXRlIHRlbnNvciBmcm9tIHRleHR1cmVgKTt0aGlzLmdwdVRleHR1cmVEYXRhPXQudGV4dHVyZSx0aGlzLmRvd25sb2FkZXI9dC5kb3dubG9hZCx0aGlzLmRpc3Bvc2VyPXQuZGlzcG9zZTticmVha31jYXNlXCJncHUtYnVmZmVyXCI6e2lmKG8hPT1cImZsb2F0MzJcIiYmbyE9PVwiZmxvYXQxNlwiJiZvIT09XCJpbnQzMlwiJiZvIT09XCJpbnQ2NFwiJiZvIT09XCJ1aW50MzJcIiYmbyE9PVwidWludDhcIiYmbyE9PVwiYm9vbFwiJiZvIT09XCJ1aW50NFwiJiZvIT09XCJpbnQ0XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZSBcIiR7b31cIiB0byBjcmVhdGUgdGVuc29yIGZyb20gZ3B1IGJ1ZmZlcmApO3RoaXMuZ3B1QnVmZmVyRGF0YT10LmdwdUJ1ZmZlcix0aGlzLmRvd25sb2FkZXI9dC5kb3dubG9hZCx0aGlzLmRpc3Bvc2VyPXQuZGlzcG9zZTticmVha31jYXNlXCJtbC10ZW5zb3JcIjp7aWYobyE9PVwiZmxvYXQzMlwiJiZvIT09XCJmbG9hdDE2XCImJm8hPT1cImludDMyXCImJm8hPT1cImludDY0XCImJm8hPT1cInVpbnQzMlwiJiZvIT09XCJ1aW50NjRcIiYmbyE9PVwiaW50OFwiJiZvIT09XCJ1aW50OFwiJiZvIT09XCJib29sXCImJm8hPT1cInVpbnQ0XCImJm8hPT1cImludDRcIil0aHJvdyBuZXcgVHlwZUVycm9yKGB1bnN1cHBvcnRlZCB0eXBlIFwiJHtvfVwiIHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbSBNTFRlbnNvcmApO3RoaXMubWxUZW5zb3JEYXRhPXQubWxUZW5zb3IsdGhpcy5kb3dubG9hZGVyPXQuZG93bmxvYWQsdGhpcy5kaXNwb3Nlcj10LmRpc3Bvc2U7YnJlYWt9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFRlbnNvciBjb25zdHJ1Y3RvcjogdW5zdXBwb3J0ZWQgbG9jYXRpb24gJyR7dGhpcy5kYXRhTG9jYXRpb259J2ApfWVsc2V7bGV0IGQsbDtpZih0eXBlb2YgdD09XCJzdHJpbmdcIilpZihvPXQsbD1uLHQ9PT1cInN0cmluZ1wiKXtpZighQXJyYXkuaXNBcnJheShyKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQSBzdHJpbmcgdGVuc29yJ3MgZGF0YSBtdXN0IGJlIGEgc3RyaW5nIGFycmF5LlwiKTtkPXJ9ZWxzZXtsZXQgcD1UdC5nZXQodCk7aWYocD09PXZvaWQgMCl0aHJvdyBuZXcgVHlwZUVycm9yKGBVbnN1cHBvcnRlZCB0ZW5zb3IgdHlwZTogJHt0fS5gKTtpZihBcnJheS5pc0FycmF5KHIpKXtpZih0PT09XCJmbG9hdDE2XCImJnA9PT1VaW50MTZBcnJheXx8dD09PVwidWludDRcInx8dD09PVwiaW50NFwiKXRocm93IG5ldyBUeXBlRXJyb3IoYENyZWF0aW5nIGEgJHt0fSB0ZW5zb3IgZnJvbSBudW1iZXIgYXJyYXkgaXMgbm90IHN1cHBvcnRlZC4gUGxlYXNlIHVzZSAke3AubmFtZX0gYXMgZGF0YS5gKTt0PT09XCJ1aW50NjRcInx8dD09PVwiaW50NjRcIj9kPXAuZnJvbShyLEJpZ0ludCk6ZD1wLmZyb20ocil9ZWxzZSBpZihyIGluc3RhbmNlb2YgcClkPXI7ZWxzZSBpZihyIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkpaWYodD09PVwidWludDhcIilkPVVpbnQ4QXJyYXkuZnJvbShyKTtlbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBIFVpbnQ4Q2xhbXBlZEFycmF5IHRlbnNvcidzIGRhdGEgbXVzdCBiZSB0eXBlIG9mIHVpbnQ4XCIpO2Vsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcihgQSAke299IHRlbnNvcidzIGRhdGEgbXVzdCBiZSB0eXBlIG9mICR7cH1gKX1lbHNlIGlmKGw9cixBcnJheS5pc0FycmF5KHQpKXtpZih0Lmxlbmd0aD09PTApdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRlbnNvciB0eXBlIGNhbm5vdCBiZSBpbmZlcnJlZCBmcm9tIGFuIGVtcHR5IGFycmF5LlwiKTtsZXQgcD10eXBlb2YgdFswXTtpZihwPT09XCJzdHJpbmdcIilvPVwic3RyaW5nXCIsZD10O2Vsc2UgaWYocD09PVwiYm9vbGVhblwiKW89XCJib29sXCIsZD1VaW50OEFycmF5LmZyb20odCk7ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIGVsZW1lbnQgdHlwZSBvZiBkYXRhIGFycmF5OiAke3B9LmApfWVsc2UgaWYodCBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KW89XCJ1aW50OFwiLGQ9VWludDhBcnJheS5mcm9tKHQpO2Vsc2V7bGV0IHA9cXQuZ2V0KHQuY29uc3RydWN0b3IpO2lmKHA9PT12b2lkIDApdGhyb3cgbmV3IFR5cGVFcnJvcihgVW5zdXBwb3J0ZWQgdHlwZSBmb3IgdGVuc29yIGRhdGE6ICR7dC5jb25zdHJ1Y3Rvcn0uYCk7bz1wLGQ9dH1pZihsPT09dm9pZCAwKWw9W2QubGVuZ3RoXTtlbHNlIGlmKCFBcnJheS5pc0FycmF5KGwpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJBIHRlbnNvcidzIGRpbXMgbXVzdCBiZSBhIG51bWJlciBhcnJheVwiKTtpPWwsdGhpcy5jcHVEYXRhPWQsdGhpcy5kYXRhTG9jYXRpb249XCJjcHVcIn1sZXQgYT1iYShpKTtpZih0aGlzLmNwdURhdGEmJmEhPT10aGlzLmNwdURhdGEubGVuZ3RoJiYhKChvPT09XCJ1aW50NFwifHxvPT09XCJpbnQ0XCIpJiZNYXRoLmNlaWwoYS8yKT09PXRoaXMuY3B1RGF0YS5sZW5ndGgpKXRocm93IG5ldyBFcnJvcihgVGVuc29yJ3Mgc2l6ZSgke2F9KSBkb2VzIG5vdCBtYXRjaCBkYXRhIGxlbmd0aCgke3RoaXMuY3B1RGF0YS5sZW5ndGh9KS5gKTt0aGlzLnR5cGU9byx0aGlzLmRpbXM9aSx0aGlzLnNpemU9YX1zdGF0aWMgYXN5bmMgZnJvbUltYWdlKHQscil7cmV0dXJuIHVhKHQscil9c3RhdGljIGZyb21UZXh0dXJlKHQscil7cmV0dXJuIGRhKHQscil9c3RhdGljIGZyb21HcHVCdWZmZXIodCxyKXtyZXR1cm4gbGEodCxyKX1zdGF0aWMgZnJvbU1MVGVuc29yKHQscil7cmV0dXJuIGNhKHQscil9c3RhdGljIGZyb21QaW5uZWRCdWZmZXIodCxyLG4pe3JldHVybiBwYSh0LHIsbil9dG9EYXRhVVJMKHQpe3JldHVybiBpYSh0aGlzLHQpfXRvSW1hZ2VEYXRhKHQpe3JldHVybiBhYSh0aGlzLHQpfWdldCBkYXRhKCl7aWYodGhpcy5lbnN1cmVWYWxpZCgpLCF0aGlzLmNwdURhdGEpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGRhdGEgaXMgbm90IG9uIENQVS4gVXNlIGBnZXREYXRhKClgIHRvIGRvd25sb2FkIEdQVSBkYXRhIHRvIENQVSwgb3IgdXNlIGB0ZXh0dXJlYCBvciBgZ3B1QnVmZmVyYCBwcm9wZXJ0eSB0byBhY2Nlc3MgdGhlIEdQVSBkYXRhIGRpcmVjdGx5LlwiKTtyZXR1cm4gdGhpcy5jcHVEYXRhfWdldCBsb2NhdGlvbigpe3JldHVybiB0aGlzLmRhdGFMb2NhdGlvbn1nZXQgdGV4dHVyZSgpe2lmKHRoaXMuZW5zdXJlVmFsaWQoKSwhdGhpcy5ncHVUZXh0dXJlRGF0YSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZGF0YSBpcyBub3Qgc3RvcmVkIGFzIGEgV2ViR0wgdGV4dHVyZS5cIik7cmV0dXJuIHRoaXMuZ3B1VGV4dHVyZURhdGF9Z2V0IGdwdUJ1ZmZlcigpe2lmKHRoaXMuZW5zdXJlVmFsaWQoKSwhdGhpcy5ncHVCdWZmZXJEYXRhKXRocm93IG5ldyBFcnJvcihcIlRoZSBkYXRhIGlzIG5vdCBzdG9yZWQgYXMgYSBXZWJHUFUgYnVmZmVyLlwiKTtyZXR1cm4gdGhpcy5ncHVCdWZmZXJEYXRhfWdldCBtbFRlbnNvcigpe2lmKHRoaXMuZW5zdXJlVmFsaWQoKSwhdGhpcy5tbFRlbnNvckRhdGEpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGRhdGEgaXMgbm90IHN0b3JlZCBhcyBhIFdlYk5OIE1MVGVuc29yLlwiKTtyZXR1cm4gdGhpcy5tbFRlbnNvckRhdGF9YXN5bmMgZ2V0RGF0YSh0KXtzd2l0Y2godGhpcy5lbnN1cmVWYWxpZCgpLHRoaXMuZGF0YUxvY2F0aW9uKXtjYXNlXCJjcHVcIjpjYXNlXCJjcHUtcGlubmVkXCI6cmV0dXJuIHRoaXMuZGF0YTtjYXNlXCJ0ZXh0dXJlXCI6Y2FzZVwiZ3B1LWJ1ZmZlclwiOmNhc2VcIm1sLXRlbnNvclwiOntpZighdGhpcy5kb3dubG9hZGVyKXRocm93IG5ldyBFcnJvcihcIlRoZSBjdXJyZW50IHRlbnNvciBpcyBub3QgY3JlYXRlZCB3aXRoIGEgc3BlY2lmaWVkIGRhdGEgZG93bmxvYWRlci5cIik7aWYodGhpcy5pc0Rvd25sb2FkaW5nKXRocm93IG5ldyBFcnJvcihcIlRoZSBjdXJyZW50IHRlbnNvciBpcyBiZWluZyBkb3dubG9hZGVkLlwiKTt0cnl7dGhpcy5pc0Rvd25sb2FkaW5nPSEwO2xldCByPWF3YWl0IHRoaXMuZG93bmxvYWRlcigpO3JldHVybiB0aGlzLmRvd25sb2FkZXI9dm9pZCAwLHRoaXMuZGF0YUxvY2F0aW9uPVwiY3B1XCIsdGhpcy5jcHVEYXRhPXIsdCYmdGhpcy5kaXNwb3NlciYmKHRoaXMuZGlzcG9zZXIoKSx0aGlzLmRpc3Bvc2VyPXZvaWQgMCkscn1maW5hbGx5e3RoaXMuaXNEb3dubG9hZGluZz0hMX19ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBnZXQgZGF0YSBmcm9tIGxvY2F0aW9uOiAke3RoaXMuZGF0YUxvY2F0aW9ufWApfX1kaXNwb3NlKCl7aWYodGhpcy5pc0Rvd25sb2FkaW5nKXRocm93IG5ldyBFcnJvcihcIlRoZSBjdXJyZW50IHRlbnNvciBpcyBiZWluZyBkb3dubG9hZGVkLlwiKTt0aGlzLmRpc3Bvc2VyJiYodGhpcy5kaXNwb3NlcigpLHRoaXMuZGlzcG9zZXI9dm9pZCAwKSx0aGlzLmNwdURhdGE9dm9pZCAwLHRoaXMuZ3B1VGV4dHVyZURhdGE9dm9pZCAwLHRoaXMuZ3B1QnVmZmVyRGF0YT12b2lkIDAsdGhpcy5tbFRlbnNvckRhdGE9dm9pZCAwLHRoaXMuZG93bmxvYWRlcj12b2lkIDAsdGhpcy5pc0Rvd25sb2FkaW5nPXZvaWQgMCx0aGlzLmRhdGFMb2NhdGlvbj1cIm5vbmVcIn1lbnN1cmVWYWxpZCgpe2lmKHRoaXMuZGF0YUxvY2F0aW9uPT09XCJub25lXCIpdGhyb3cgbmV3IEVycm9yKFwiVGhlIHRlbnNvciBpcyBkaXNwb3NlZC5cIil9cmVzaGFwZSh0KXtpZih0aGlzLmVuc3VyZVZhbGlkKCksdGhpcy5kb3dubG9hZGVyfHx0aGlzLmRpc3Bvc2VyKXRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXNoYXBlIGEgdGVuc29yIHRoYXQgb3ducyBHUFUgcmVzb3VyY2UuXCIpO3JldHVybiB5YSh0aGlzLHQpfX19KTt2YXIgSGUsR249VSgoKT0+e1widXNlIHN0cmljdFwiO19yKCk7SGU9emV9KTt2YXIgd3Isd2EsVWUsRGUsSG49VSgoKT0+e1widXNlIHN0cmljdFwiO1duKCk7d3I9KGUsdCk9PnsodHlwZW9mIFJlLnRyYWNlPlwidVwiPyFSZS53YXNtLnRyYWNlOiFSZS50cmFjZSl8fGNvbnNvbGUudGltZVN0YW1wKGAke2V9OjpPUlQ6OiR7dH1gKX0sd2E9KGUsdCk9PntsZXQgcj1uZXcgRXJyb3IoKS5zdGFjaz8uc3BsaXQoL1xcclxcbnxcXHJ8XFxuL2cpfHxbXSxuPSExO2ZvcihsZXQgbz0wO288ci5sZW5ndGg7bysrKXtpZihuJiYhcltvXS5pbmNsdWRlcyhcIlRSQUNFX0ZVTkNcIikpe2xldCBpPWBGVU5DXyR7ZX06OiR7cltvXS50cmltKCkuc3BsaXQoXCIgXCIpWzFdfWA7dCYmKGkrPWA6OiR7dH1gKSx3cihcIkNQVVwiLGkpO3JldHVybn1yW29dLmluY2x1ZGVzKFwiVFJBQ0VfRlVOQ1wiKSYmKG49ITApfX0sVWU9ZT0+eyh0eXBlb2YgUmUudHJhY2U+XCJ1XCI/IVJlLndhc20udHJhY2U6IVJlLnRyYWNlKXx8d2EoXCJCRUdJTlwiLGUpfSxEZT1lPT57KHR5cGVvZiBSZS50cmFjZT5cInVcIj8hUmUud2FzbS50cmFjZTohUmUudHJhY2UpfHx3YShcIkVORFwiLGUpfX0pO3ZhciB2cix2YT1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Vm4oKTtHbigpO0huKCk7dnI9Y2xhc3MgZXtjb25zdHJ1Y3Rvcih0KXt0aGlzLmhhbmRsZXI9dH1hc3luYyBydW4odCxyLG4pe1VlKCk7bGV0IG89e30saT17fTtpZih0eXBlb2YgdCE9XCJvYmplY3RcInx8dD09PW51bGx8fHQgaW5zdGFuY2VvZiBIZXx8QXJyYXkuaXNBcnJheSh0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2ZlZWRzJyBtdXN0IGJlIGFuIG9iamVjdCB0aGF0IHVzZSBpbnB1dCBuYW1lcyBhcyBrZXlzIGFuZCBPbm54VmFsdWUgYXMgY29ycmVzcG9uZGluZyB2YWx1ZXMuXCIpO2xldCBhPSEwO2lmKHR5cGVvZiByPT1cIm9iamVjdFwiKXtpZihyPT09bnVsbCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5leHBlY3RlZCBhcmd1bWVudFsxXTogY2Fubm90IGJlIG51bGwuXCIpO2lmKHIgaW5zdGFuY2VvZiBIZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2ZldGNoZXMnIGNhbm5vdCBiZSBhIFRlbnNvclwiKTtpZihBcnJheS5pc0FycmF5KHIpKXtpZihyLmxlbmd0aD09PTApdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZXRjaGVzJyBjYW5ub3QgYmUgYW4gZW1wdHkgYXJyYXkuXCIpO2E9ITE7Zm9yKGxldCBwIG9mIHIpe2lmKHR5cGVvZiBwIT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInZmV0Y2hlcycgbXVzdCBiZSBhIHN0cmluZyBhcnJheSBvciBhbiBvYmplY3QuXCIpO2lmKHRoaXMub3V0cHV0TmFtZXMuaW5kZXhPZihwKT09PS0xKXRocm93IG5ldyBSYW5nZUVycm9yKGAnZmV0Y2hlcycgY29udGFpbnMgaW52YWxpZCBvdXRwdXQgbmFtZTogJHtwfS5gKTtvW3BdPW51bGx9aWYodHlwZW9mIG49PVwib2JqZWN0XCImJm4hPT1udWxsKWk9bjtlbHNlIGlmKHR5cGVvZiBuPFwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpfWVsc2V7bGV0IHA9ITEsbT1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhyKTtmb3IobGV0IHUgb2YgdGhpcy5vdXRwdXROYW1lcylpZihtLmluZGV4T2YodSkhPT0tMSl7bGV0IGg9clt1XTsoaD09PW51bGx8fGggaW5zdGFuY2VvZiBIZSkmJihwPSEwLGE9ITEsb1t1XT1oKX1pZihwKXtpZih0eXBlb2Ygbj09XCJvYmplY3RcIiYmbiE9PW51bGwpaT1uO2Vsc2UgaWYodHlwZW9mIG48XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIil9ZWxzZSBpPXJ9fWVsc2UgaWYodHlwZW9mIHI8XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuZXhwZWN0ZWQgYXJndW1lbnRbMV06IG11c3QgYmUgJ2ZldGNoZXMnIG9yICdvcHRpb25zJy5cIik7Zm9yKGxldCBwIG9mIHRoaXMuaW5wdXROYW1lcylpZih0eXBlb2YgdFtwXT5cInVcIil0aHJvdyBuZXcgRXJyb3IoYGlucHV0ICcke3B9JyBpcyBtaXNzaW5nIGluICdmZWVkcycuYCk7aWYoYSlmb3IobGV0IHAgb2YgdGhpcy5vdXRwdXROYW1lcylvW3BdPW51bGw7bGV0IGQ9YXdhaXQgdGhpcy5oYW5kbGVyLnJ1bih0LG8saSksbD17fTtmb3IobGV0IHAgaW4gZClpZihPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChkLHApKXtsZXQgbT1kW3BdO20gaW5zdGFuY2VvZiBIZT9sW3BdPW06bFtwXT1uZXcgSGUobS50eXBlLG0uZGF0YSxtLmRpbXMpfXJldHVybiBEZSgpLGx9YXN5bmMgcmVsZWFzZSgpe3JldHVybiB0aGlzLmhhbmRsZXIuZGlzcG9zZSgpfXN0YXRpYyBhc3luYyBjcmVhdGUodCxyLG4sbyl7VWUoKTtsZXQgaSxhPXt9O2lmKHR5cGVvZiB0PT1cInN0cmluZ1wiKXtpZihpPXQsdHlwZW9mIHI9PVwib2JqZWN0XCImJnIhPT1udWxsKWE9cjtlbHNlIGlmKHR5cGVvZiByPFwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpfWVsc2UgaWYodCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpe2lmKGk9dCx0eXBlb2Ygcj09XCJvYmplY3RcIiYmciE9PW51bGwpYT1yO2Vsc2UgaWYodHlwZW9mIHI8XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIil9ZWxzZSBpZih0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXJ8fHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlcjxcInVcIiYmdCBpbnN0YW5jZW9mIFNoYXJlZEFycmF5QnVmZmVyKXtsZXQgbT10LHU9MCxoPXQuYnl0ZUxlbmd0aDtpZih0eXBlb2Ygcj09XCJvYmplY3RcIiYmciE9PW51bGwpYT1yO2Vsc2UgaWYodHlwZW9mIHI9PVwibnVtYmVyXCIpe2lmKHU9ciwhTnVtYmVyLmlzU2FmZUludGVnZXIodSkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCInYnl0ZU9mZnNldCcgbXVzdCBiZSBhbiBpbnRlZ2VyLlwiKTtpZih1PDB8fHU+PW0uYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJ2J5dGVPZmZzZXQnIGlzIG91dCBvZiByYW5nZSBbMCwgJHttLmJ5dGVMZW5ndGh9KS5gKTtpZihoPXQuYnl0ZUxlbmd0aC11LHR5cGVvZiBuPT1cIm51bWJlclwiKXtpZihoPW4sIU51bWJlci5pc1NhZmVJbnRlZ2VyKGgpKXRocm93IG5ldyBSYW5nZUVycm9yKFwiJ2J5dGVMZW5ndGgnIG11c3QgYmUgYW4gaW50ZWdlci5cIik7aWYoaDw9MHx8dStoPm0uYnl0ZUxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihgJ2J5dGVMZW5ndGgnIGlzIG91dCBvZiByYW5nZSAoMCwgJHttLmJ5dGVMZW5ndGgtdX1dLmApO2lmKHR5cGVvZiBvPT1cIm9iamVjdFwiJiZvIT09bnVsbClhPW87ZWxzZSBpZih0eXBlb2YgbzxcInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKX1lbHNlIGlmKHR5cGVvZiBuPFwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInYnl0ZUxlbmd0aCcgbXVzdCBiZSBhIG51bWJlci5cIil9ZWxzZSBpZih0eXBlb2YgcjxcInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKTtpPW5ldyBVaW50OEFycmF5KG0sdSxoKX1lbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmV4cGVjdGVkIGFyZ3VtZW50WzBdOiBtdXN0IGJlICdwYXRoJyBvciAnYnVmZmVyJy5cIik7bGV0W2QsbF09YXdhaXQgSmkoYSkscD1hd2FpdCBkLmNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKGksbCk7cmV0dXJuIERlKCksbmV3IGUocCl9c3RhcnRQcm9maWxpbmcoKXt0aGlzLmhhbmRsZXIuc3RhcnRQcm9maWxpbmcoKX1lbmRQcm9maWxpbmcoKXt0aGlzLmhhbmRsZXIuZW5kUHJvZmlsaW5nKCl9Z2V0IGlucHV0TmFtZXMoKXtyZXR1cm4gdGhpcy5oYW5kbGVyLmlucHV0TmFtZXN9Z2V0IG91dHB1dE5hbWVzKCl7cmV0dXJuIHRoaXMuaGFuZGxlci5vdXRwdXROYW1lc319fSk7dmFyIEZwLCRhPVUoKCk9PntcInVzZSBzdHJpY3RcIjt2YSgpO0ZwPXZyfSk7dmFyIHhhPVUoKCk9PntcInVzZSBzdHJpY3RcIn0pO3ZhciBTYT1VKCgpPT57XCJ1c2Ugc3RyaWN0XCJ9KTt2YXIgVGE9VSgoKT0+e1widXNlIHN0cmljdFwifSk7dmFyIElhPVUoKCk9PntcInVzZSBzdHJpY3RcIn0pO3ZhciBGbj17fTtGdChGbix7SW5mZXJlbmNlU2Vzc2lvbjooKT0+RnAsVFJBQ0U6KCk9PndyLFRSQUNFX0ZVTkNfQkVHSU46KCk9PlVlLFRSQUNFX0ZVTkNfRU5EOigpPT5EZSxUZW5zb3I6KCk9PkhlLGVudjooKT0+dmUscmVnaXN0ZXJCYWNrZW5kOigpPT5TdH0pO3ZhciBXZT1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7ZWEoKTtvYSgpOyRhKCk7R24oKTt4YSgpO1NhKCk7SG4oKTtUYSgpO0lhKCl9KTt2YXIgJHI9VSgoKT0+e1widXNlIHN0cmljdFwifSk7dmFyIEVhPXt9O0Z0KEVhLHtkZWZhdWx0OigpPT5xcH0pO3ZhciBBYSxrYSxxcCxQYT1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7cW4oKTtndCgpO3hyKCk7QWE9XCJvcnQtd2FzbS1wcm94eS13b3JrZXJcIixrYT1nbG9iYWxUaGlzLnNlbGY/Lm5hbWU9PT1BYTtrYSYmKHNlbGYub25tZXNzYWdlPWU9PntsZXR7dHlwZTp0LGluOnJ9PWUuZGF0YTt0cnl7c3dpdGNoKHQpe2Nhc2VcImluaXQtd2FzbVwiOlNyKHIud2FzbSkudGhlbigoKT0+e1RyKHIpLnRoZW4oKCk9Pntwb3N0TWVzc2FnZSh7dHlwZTp0fSl9LG49Pntwb3N0TWVzc2FnZSh7dHlwZTp0LGVycjpufSl9KX0sbj0+e3Bvc3RNZXNzYWdlKHt0eXBlOnQsZXJyOm59KX0pO2JyZWFrO2Nhc2VcImluaXQtZXBcIjp7bGV0e2VwTmFtZTpuLGVudjpvfT1yO0lyKG8sbikudGhlbigoKT0+e3Bvc3RNZXNzYWdlKHt0eXBlOnR9KX0saT0+e3Bvc3RNZXNzYWdlKHt0eXBlOnQsZXJyOml9KX0pO2JyZWFrfWNhc2VcImNvcHktZnJvbVwiOntsZXR7YnVmZmVyOm59PXIsbz1LdChuKTtwb3N0TWVzc2FnZSh7dHlwZTp0LG91dDpvfSk7YnJlYWt9Y2FzZVwiY3JlYXRlXCI6e2xldHttb2RlbDpuLG9wdGlvbnM6b309cjtDcihuLG8pLnRoZW4oaT0+e3Bvc3RNZXNzYWdlKHt0eXBlOnQsb3V0Oml9KX0saT0+e3Bvc3RNZXNzYWdlKHt0eXBlOnQsZXJyOml9KX0pO2JyZWFrfWNhc2VcInJlbGVhc2VcIjpBcihyKSxwb3N0TWVzc2FnZSh7dHlwZTp0fSk7YnJlYWs7Y2FzZVwicnVuXCI6e2xldHtzZXNzaW9uSWQ6bixpbnB1dEluZGljZXM6byxpbnB1dHM6aSxvdXRwdXRJbmRpY2VzOmEsb3B0aW9uczpkfT1yO2tyKG4sbyxpLGEsbmV3IEFycmF5KGEubGVuZ3RoKS5maWxsKG51bGwpLGQpLnRoZW4obD0+e2wuc29tZShwPT5wWzNdIT09XCJjcHVcIik/cG9zdE1lc3NhZ2Uoe3R5cGU6dCxlcnI6XCJQcm94eSBkb2VzIG5vdCBzdXBwb3J0IG5vbi1jcHUgdGVuc29yIGxvY2F0aW9uLlwifSk6cG9zdE1lc3NhZ2Uoe3R5cGU6dCxvdXQ6bH0sUHIoWy4uLmksLi4ubF0pKX0sbD0+e3Bvc3RNZXNzYWdlKHt0eXBlOnQsZXJyOmx9KX0pO2JyZWFrfWNhc2VcImVuZC1wcm9maWxpbmdcIjpFcihyKSxwb3N0TWVzc2FnZSh7dHlwZTp0fSk7YnJlYWs7ZGVmYXVsdDp9fWNhdGNoKG4pe3Bvc3RNZXNzYWdlKHt0eXBlOnQsZXJyOm59KX19KTtxcD1rYT9udWxsOmU9Pm5ldyBXb3JrZXIoZT8/TmUse3R5cGU6XCJtb2R1bGVcIixuYW1lOkFhfSl9KTt2YXIgT2E9e307RnQoT2Ese2RlZmF1bHQ6KCk9PktwfSk7dmFyIEtuLHphLEtwLERhPVUoKCk9PntcInVzZSBzdHJpY3RcIjt6YT0oS249aW1wb3J0Lm1ldGEudXJsLGFzeW5jIGZ1bmN0aW9uKGU9e30pe2Z1bmN0aW9uIHQoKXtyZXR1cm4gc2UuYnVmZmVyIT1KLmJ1ZmZlciYmeWUoKSxKfWZ1bmN0aW9uIHIoKXtyZXR1cm4gc2UuYnVmZmVyIT1KLmJ1ZmZlciYmeWUoKSxuZX1mdW5jdGlvbiBuKCl7cmV0dXJuIHNlLmJ1ZmZlciE9Si5idWZmZXImJnllKCksYmV9ZnVuY3Rpb24gbygpe3JldHVybiBzZS5idWZmZXIhPUouYnVmZmVyJiZ5ZSgpLE9lfWZ1bmN0aW9uIGkoKXtyZXR1cm4gc2UuYnVmZmVyIT1KLmJ1ZmZlciYmeWUoKSwkZX1mdW5jdGlvbiBhKCl7cmV0dXJuIHNlLmJ1ZmZlciE9Si5idWZmZXImJnllKCksbGV9ZnVuY3Rpb24gZCgpe3JldHVybiBzZS5idWZmZXIhPUouYnVmZmVyJiZ5ZSgpLFd9ZnVuY3Rpb24gbCgpe3JldHVybiBzZS5idWZmZXIhPUouYnVmZmVyJiZ5ZSgpLEdlfXZhciBwLG0sdT1PYmplY3QuYXNzaWduKHt9LGUpLGg9bmV3IFByb21pc2UoKHMsYyk9PntwPXMsbT1jfSksXz10eXBlb2Ygd2luZG93PT1cIm9iamVjdFwiLHk9dHlwZW9mIGltcG9ydFNjcmlwdHM9PVwiZnVuY3Rpb25cIixnPXkmJnNlbGYubmFtZT09XCJlbS1wdGhyZWFkXCI7dS5tb3VudEV4dGVybmFsRGF0YT0ocyxjKT0+e3Muc3RhcnRzV2l0aChcIi4vXCIpJiYocz1zLnN1YnN0cmluZygyKSksKHUuRmJ8fCh1LkZiPW5ldyBNYXApKS5zZXQocyxjKX0sdS51bm1vdW50RXh0ZXJuYWxEYXRhPSgpPT57ZGVsZXRlIHUuRmJ9O3ZhciB4PWdsb2JhbFRoaXMuU2hhcmVkQXJyYXlCdWZmZXI/P25ldyBXZWJBc3NlbWJseS5NZW1vcnkoe2luaXRpYWw6MCxtYXhpbXVtOjAsc2hhcmVkOiEwfSkuYnVmZmVyLmNvbnN0cnVjdG9yO2xldCAkPSgpPT57bGV0IHM9KGYsYix3KT0+KC4uLkkpPT57bGV0IE89WGUsQj1iPy4oKTtJPWYoLi4uSSk7bGV0IEw9Yj8uKCk7cmV0dXJuIEIhPT1MJiYoZj1MLHcoQiksYj13PW51bGwpLFhlIT1PP25ldyBQcm9taXNlKChILFgpPT57RW49e3Jlc29sdmU6SCxyZWplY3Q6WH19KTpJfSxjPWY9PmFzeW5jKC4uLmIpPT57dHJ5e2lmKHUuR2IpdGhyb3cgRXJyb3IoXCJTZXNzaW9uIGFscmVhZHkgc3RhcnRlZFwiKTtsZXQgdz11LkdiPXtoYzpiWzBdLGVycm9yczpbXX0sST1hd2FpdCBmKC4uLmIpO2lmKHUuR2IhPT13KXRocm93IEVycm9yKFwiU2Vzc2lvbiBtaXNtYXRjaFwiKTt1LkhiPy5mbHVzaCgpO2xldCBPPXcuZXJyb3JzO2lmKDA8Ty5sZW5ndGgpe2xldCBCPWF3YWl0IFByb21pc2UuYWxsKE8pO2lmKEI9Qi5maWx0ZXIoTD0+TCksMDxCLmxlbmd0aCl0aHJvdyBFcnJvcihCLmpvaW4oYFxuYCkpfXJldHVybiBJfWZpbmFsbHl7dS5HYj1udWxsfX07dS5fT3J0Q3JlYXRlU2Vzc2lvbj1zKHUuX09ydENyZWF0ZVNlc3Npb24sKCk9PnUuX09ydENyZWF0ZVNlc3Npb24sZj0+dS5fT3J0Q3JlYXRlU2Vzc2lvbj1mKSx1Ll9PcnRSdW49YyhzKHUuX09ydFJ1biwoKT0+dS5fT3J0UnVuLGY9PnUuX09ydFJ1bj1mKSksdS5fT3J0UnVuV2l0aEJpbmRpbmc9YyhzKHUuX09ydFJ1bldpdGhCaW5kaW5nLCgpPT51Ll9PcnRSdW5XaXRoQmluZGluZyxmPT51Ll9PcnRSdW5XaXRoQmluZGluZz1mKSksdS5fT3J0QmluZElucHV0PXModS5fT3J0QmluZElucHV0LCgpPT51Ll9PcnRCaW5kSW5wdXQsZj0+dS5fT3J0QmluZElucHV0PWYpLCQ9dm9pZCAwfTt1LmpzZXBJbml0PShzLGMpPT57aWYoJD8uKCkscz09PVwid2ViZ3B1XCIpe1t1LkhiLHUuVmIsdS5aYix1Lk9iLHUuWWIsdS5rYix1LiRiLHUuY2MsdS5XYix1LlhiLHUuYWNdPWM7bGV0IGY9dS5IYjt1LmpzZXBSZWdpc3RlckJ1ZmZlcj0oYix3LEksTyk9PmYucmVnaXN0ZXJCdWZmZXIoYix3LEksTyksdS5qc2VwR2V0QnVmZmVyPWI9PmYuZ2V0QnVmZmVyKGIpLHUuanNlcENyZWF0ZURvd25sb2FkZXI9KGIsdyxJKT0+Zi5jcmVhdGVEb3dubG9hZGVyKGIsdyxJKSx1LmpzZXBPbkNyZWF0ZVNlc3Npb249Yj0+e2Yub25DcmVhdGVTZXNzaW9uKGIpfSx1LmpzZXBPblJlbGVhc2VTZXNzaW9uPWI9PntmLm9uUmVsZWFzZVNlc3Npb24oYil9LHUuanNlcE9uUnVuU3RhcnQ9Yj0+Zi5vblJ1blN0YXJ0KGIpLHUuZGM9KGIsdyk9PntmLnVwbG9hZChiLHcpfX1lbHNlIGlmKHM9PT1cIndlYm5uXCIpe1t1LkhiLHUuYmMsdS5QYix1LmpzZXBFbnN1cmVUZW5zb3IsdS5lYyx1LmpzZXBEb3dubG9hZFRlbnNvcl09Yyx1LmpzZXBSZWxlYXNlVGVuc29ySWQ9dS5QYjtsZXQgZj11LkhiO3UuanNlcE9uUnVuU3RhcnQ9Yj0+Zi5vblJ1blN0YXJ0KGIpLHUuanNlcFJlZ2lzdGVyTUxDb250ZXh0PShiLHcpPT57Zi5yZWdpc3Rlck1MQ29udGV4dChiLHcpfSx1LmpzZXBPblJlbGVhc2VTZXNzaW9uPWI9PntmLm9uUmVsZWFzZVNlc3Npb24oYil9LHUuanNlcENyZWF0ZU1MVGVuc29yRG93bmxvYWRlcj0oYix3KT0+Zi5jcmVhdGVNTFRlbnNvckRvd25sb2FkZXIoYix3KSx1LmpzZXBSZWdpc3Rlck1MVGVuc29yPShiLHcsSSk9PmYucmVnaXN0ZXJNTFRlbnNvcihiLHcsSSksdS5qc2VwQ3JlYXRlTUxDb250ZXh0PWI9PmYuY3JlYXRlTUxDb250ZXh0KGIpLHUuanNlcFJlZ2lzdGVyTUxDb25zdGFudD0oYix3LEksTyxCKT0+Zi5yZWdpc3Rlck1MQ29uc3RhbnQoYix3LEksTyxCLHUuRmIpfX07dmFyIHYsUyxUPU9iamVjdC5hc3NpZ24oe30sdSksQT1cIi4vdGhpcy5wcm9ncmFtXCIsaz0ocyxjKT0+e3Rocm93IGN9LFA9XCJcIjsoX3x8eSkmJih5P1A9c2VsZi5sb2NhdGlvbi5ocmVmOnR5cGVvZiBkb2N1bWVudDxcInVcIiYmZG9jdW1lbnQuY3VycmVudFNjcmlwdCYmKFA9ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmMpLEtuJiYoUD1LbiksUD1QLnN0YXJ0c1dpdGgoXCJibG9iOlwiKT9cIlwiOlAuc3Vic3RyKDAsUC5yZXBsYWNlKC9bPyNdLiovLFwiXCIpLmxhc3RJbmRleE9mKFwiL1wiKSsxKSx5JiYoUz1zPT57dmFyIGM9bmV3IFhNTEh0dHBSZXF1ZXN0O3JldHVybiBjLm9wZW4oXCJHRVRcIixzLCExKSxjLnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCIsYy5zZW5kKG51bGwpLG5ldyBVaW50OEFycmF5KGMucmVzcG9uc2UpfSksdj0ocyxjLGYpPT57dmFyIGI9bmV3IFhNTEh0dHBSZXF1ZXN0O2Iub3BlbihcIkdFVFwiLHMsITApLGIucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIixiLm9ubG9hZD0oKT0+e2Iuc3RhdHVzPT0yMDB8fGIuc3RhdHVzPT0wJiZiLnJlc3BvbnNlP2MoYi5yZXNwb25zZSk6ZigpfSxiLm9uZXJyb3I9ZixiLnNlbmQobnVsbCl9KTt2YXIgRCxSPWNvbnNvbGUubG9nLmJpbmQoY29uc29sZSksRz1jb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSksSz1SLGo9RztpZihPYmplY3QuYXNzaWduKHUsVCksVD1udWxsLGcpe2xldCBzPWZ1bmN0aW9uKGMpe3RyeXt2YXIgZj1jLmRhdGEsYj1mLmNtZDtpZihiPT09XCJsb2FkXCIpe2xldCB3PVtdO3NlbGYub25tZXNzYWdlPUk9PncucHVzaChJKSxzZWxmLnN0YXJ0V29ya2VyPSgpPT57cG9zdE1lc3NhZ2Uoe2NtZDpcImxvYWRlZFwifSk7Zm9yKGxldCBJIG9mIHcpcyhJKTtzZWxmLm9ubWVzc2FnZT1zfTtmb3IobGV0IEkgb2YgZi5oYW5kbGVycyl1W0ldJiYhdVtJXS5wcm94eXx8KHVbSV09KC4uLk8pPT57cG9zdE1lc3NhZ2Uoe05iOlwiY2FsbEhhbmRsZXJcIixwYzpJLGFyZ3M6T30pfSxJPT1cInByaW50XCImJihLPXVbSV0pLEk9PVwicHJpbnRFcnJcIiYmKGo9dVtJXSkpO3NlPWYud2FzbU1lbW9yeSx5ZSgpLFYoZi53YXNtTW9kdWxlKX1lbHNlIGlmKGI9PT1cInJ1blwiKXtEbihmLnB0aHJlYWRfcHRyLDAsMCwxLDAsMCksQW4oZi5wdGhyZWFkX3B0cikseGMoKSxIbygpLFF8fChXaSgpLFE9ITApO3RyeXtTYyhmLnN0YXJ0X3JvdXRpbmUsZi5hcmcpfWNhdGNoKHcpe2lmKHchPVwidW53aW5kXCIpdGhyb3cgd319ZWxzZSBiPT09XCJjYW5jZWxcIj9NdCgpJiZocigtMSk6Zi50YXJnZXQhPT1cInNldGltbWVkaWF0ZVwiJiYoYj09PVwiY2hlY2tNYWlsYm94XCI/USYmaXIoKTpiJiYoaihgd29ya2VyOiByZWNlaXZlZCB1bmtub3duIGNvbW1hbmQgJHtifWApLGooZikpKX1jYXRjaCh3KXt0aHJvdyBMaSgpLHd9fTt2YXIgd2c9cyxWLFE9ITE7aj1mdW5jdGlvbiguLi5jKXtjPWMuam9pbihcIiBcIiksY29uc29sZS5lcnJvcihjKX0sc2VsZi5hbGVydD1mdW5jdGlvbiguLi5jKXtwb3N0TWVzc2FnZSh7TmI6XCJhbGVydFwiLHRleHQ6Yy5qb2luKFwiIFwiKSxyYzpNdCgpfSl9LHUuaW5zdGFudGlhdGVXYXNtPShjLGYpPT5uZXcgUHJvbWlzZShiPT57Vj13PT57dz1uZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UodyxObygpKSxmKHcpLGIoKX19KSxzZWxmLm9udW5oYW5kbGVkcmVqZWN0aW9uPWM9Pnt0aHJvdyBjLnJlYXNvbnx8Y30sc2VsZi5vbm1lc3NhZ2U9c311Lndhc21CaW5hcnkmJihEPXUud2FzbUJpbmFyeSk7dmFyIHNlLFksZWUsSixuZSxiZSxPZSwkZSxsZSxXLHEsaGUsR2Usd2U9ITE7ZnVuY3Rpb24geWUoKXt2YXIgcz1zZS5idWZmZXI7dS5IRUFQOD1KPW5ldyBJbnQ4QXJyYXkocyksdS5IRUFQMTY9YmU9bmV3IEludDE2QXJyYXkocyksdS5IRUFQVTg9bmU9bmV3IFVpbnQ4QXJyYXkocyksdS5IRUFQVTE2PU9lPW5ldyBVaW50MTZBcnJheShzKSx1LkhFQVAzMj0kZT1uZXcgSW50MzJBcnJheShzKSx1LkhFQVBVMzI9bGU9bmV3IFVpbnQzMkFycmF5KHMpLHUuSEVBUEYzMj1XPW5ldyBGbG9hdDMyQXJyYXkocyksdS5IRUFQRjY0PUdlPW5ldyBGbG9hdDY0QXJyYXkocyksdS5IRUFQNjQ9cT1uZXcgQmlnSW50NjRBcnJheShzKSx1LkhFQVBVNjQ9aGU9bmV3IEJpZ1VpbnQ2NEFycmF5KHMpfWlmKCFnKXtpZighKChzZT1uZXcgV2ViQXNzZW1ibHkuTWVtb3J5KHtpbml0aWFsOjI1NixtYXhpbXVtOjY1NTM2LHNoYXJlZDohMH0pKS5idWZmZXIgaW5zdGFuY2VvZiB4KSl0aHJvdyBqKFwicmVxdWVzdGVkIGEgc2hhcmVkIFdlYkFzc2VtYmx5Lk1lbW9yeSBidXQgdGhlIHJldHVybmVkIGJ1ZmZlciBpcyBub3QgYSBTaGFyZWRBcnJheUJ1ZmZlciwgaW5kaWNhdGluZyB0aGF0IHdoaWxlIHRoZSBicm93c2VyIGhhcyBTaGFyZWRBcnJheUJ1ZmZlciBpdCBkb2VzIG5vdCBoYXZlIFdlYkFzc2VtYmx5IHRocmVhZHMgc3VwcG9ydCAtIHlvdSBtYXkgbmVlZCB0byBzZXQgYSBmbGFnXCIpLEVycm9yKFwiYmFkIG1lbW9yeVwiKTt5ZSgpfXZhciBZZT1bXSxMdD1bXSxmbj1bXSxHdD0wLGhuPW51bGwsSHQ9bnVsbDtmdW5jdGlvbiBEbygpe2lmKC0tR3Q9PTAmJihobiE9PW51bGwmJihjbGVhckludGVydmFsKGhuKSxobj1udWxsKSxIdCkpe3ZhciBzPUh0O0h0PW51bGwscygpfX1mdW5jdGlvbiBjdChzKXt0aHJvdyBqKHM9XCJBYm9ydGVkKFwiK3MrXCIpXCIpLHdlPSEwLGVlPTEscz1uZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKHMrXCIuIEJ1aWxkIHdpdGggLXNBU1NFUlRJT05TIGZvciBtb3JlIGluZm8uXCIpLG0ocyksc312YXIgZ24sQm89cz0+cy5zdGFydHNXaXRoKFwiZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LFwiKSxNbz1zPT5zLnN0YXJ0c1dpdGgoXCJmaWxlOi8vXCIpO2Z1bmN0aW9uIFJvKHMpe2lmKHM9PWduJiZEKXJldHVybiBuZXcgVWludDhBcnJheShEKTtpZihTKXJldHVybiBTKHMpO3Rocm93XCJib3RoIGFzeW5jIGFuZCBzeW5jIGZldGNoaW5nIG9mIHRoZSB3YXNtIGZhaWxlZFwifWZ1bmN0aW9uIFVvKHMsYyxmKXtyZXR1cm4gZnVuY3Rpb24oYil7aWYoIUQmJihffHx5KSl7aWYodHlwZW9mIGZldGNoPT1cImZ1bmN0aW9uXCImJiFNbyhiKSlyZXR1cm4gZmV0Y2goYix7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkudGhlbih3PT57aWYoIXcub2spdGhyb3dgZmFpbGVkIHRvIGxvYWQgd2FzbSBiaW5hcnkgZmlsZSBhdCAnJHtifSdgO3JldHVybiB3LmFycmF5QnVmZmVyKCl9KS5jYXRjaCgoKT0+Um8oYikpO2lmKHYpcmV0dXJuIG5ldyBQcm9taXNlKCh3LEkpPT57dihiLE89PncobmV3IFVpbnQ4QXJyYXkoTykpLEkpfSl9cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9PlJvKGIpKX0ocykudGhlbihiPT5XZWJBc3NlbWJseS5pbnN0YW50aWF0ZShiLGMpKS50aGVuKGYsYj0+e2ooYGZhaWxlZCB0byBhc3luY2hyb25vdXNseSBwcmVwYXJlIHdhc206ICR7Yn1gKSxjdChiKX0pfWZ1bmN0aW9uIE5vKCl7cmV0dXJue2E6e086JGMsQWE6dmMsYjpJYyxhYTpqbyxCOlFvLHFhOlhvLFk6ZWksXzp0aSxyYTpyaSxvYTpuaSxoYTpvaSxuYTppaSxMOmFpLFo6c2ksVzp1aSxwYTpkaSxYOmxpLHZhOkNjLEY6a2MsUTpFYyxQOnpjLEU6RGMsdTpCYyxxOk1jLEc6UmMsQTpIYyxSOkZjLHVhOnFjLGthOktjLFU6amMsYmE6WWMsSDpaYyxqYTpBbix0YTpRYyx0OlhjLEJhOkpjLHg6cnAsbjpucCxsOmlwLGM6SW4sbzphcCxqOmRwLHc6bHAscDpjcCxmOnBwLHM6bXAsbTpmcCxlOmhwLGs6Z3AsaTpicCxoOnlwLGQ6X3AsZWE6d3AsZmE6dnAsZ2E6JHAsY2E6U2ksZGE6VGksVDp4cCxnOlNwLEQ6VHAsSTpJcCxNOkNwLHk6QXAsc2E6a3AsVjpFcCx2OkNpLHo6UHAsTjp6cCxTOk9wLHphOkRwLHlhOkJwLGxhOkVpLG1hOlBpLCQ6dm4sQzp6aSxLOk9pLGlhOkRpLEo6QmksYTpzZSx4YTp3bix3YTpVaSxyOlVwfX19dmFyIGJuPXs5MTM3MDA6KHMsYyxmLGIsdyk9PntpZih1PT09dm9pZCAwfHwhdS5GYilyZXR1cm4gMTtpZigocz1DZShOdW1iZXIocz4+PjApKSkuc3RhcnRzV2l0aChcIi4vXCIpJiYocz1zLnN1YnN0cmluZygyKSksIShzPXUuRmIuZ2V0KHMpKSlyZXR1cm4gMjtpZihjPU51bWJlcihjPj4+MCksZj1OdW1iZXIoZj4+PjApLGI9TnVtYmVyKGI+Pj4wKSxjK2Y+cy5ieXRlTGVuZ3RoKXJldHVybiAzO3RyeXtsZXQgST1zLnN1YmFycmF5KGMsYytmKTtzd2l0Y2godyl7Y2FzZSAwOnIoKS5zZXQoSSxiPj4+MCk7YnJlYWs7Y2FzZSAxOnUuZGMoYixJKTticmVhaztkZWZhdWx0OnJldHVybiA0fXJldHVybiAwfWNhdGNoe3JldHVybiA0fX0sOTE0NDE1OihzLGMsZik9Pnt1LmVjKHMscigpLnN1YmFycmF5KGM+Pj4wLGMrZj4+PjApKX0sOTE0NDc4OigpPT51LmJjKCksOTE0NTE5OnM9Pnt1LlBiKHMpfSw5MTQ1NTU6KCk9Pnt1LldiKCl9LDkxNDU4NjooKT0+e3UuWGIoKX0sOTE0NjE1OigpPT57dS5hYygpfSw5MTQ2NDA6cz0+dS5WYihzKSw5MTQ2NzM6cz0+dS5aYihzKSw5MTQ3MDU6KHMsYyxmKT0+e3UuT2IoTnVtYmVyKHMpLE51bWJlcihjKSxOdW1iZXIoZiksITApfSw5MTQ3Njg6KHMsYyxmKT0+e3UuT2IoTnVtYmVyKHMpLE51bWJlcihjKSxOdW1iZXIoZikpfSw5MTQ4MjU6KCk9PnR5cGVvZiB3YXNtT2Zmc2V0Q29udmVydGVyPFwidVwiLDkxNDg4MjpzPT57dS5rYihcIkFic1wiLHMsdm9pZCAwKX0sOTE0OTMzOnM9Pnt1LmtiKFwiTmVnXCIscyx2b2lkIDApfSw5MTQ5ODQ6cz0+e3Uua2IoXCJGbG9vclwiLHMsdm9pZCAwKX0sOTE1MDM3OnM9Pnt1LmtiKFwiQ2VpbFwiLHMsdm9pZCAwKX0sOTE1MDg5OnM9Pnt1LmtiKFwiUmVjaXByb2NhbFwiLHMsdm9pZCAwKX0sOTE1MTQ3OnM9Pnt1LmtiKFwiU3FydFwiLHMsdm9pZCAwKX0sOTE1MTk5OnM9Pnt1LmtiKFwiRXhwXCIscyx2b2lkIDApfSw5MTUyNTA6cz0+e3Uua2IoXCJFcmZcIixzLHZvaWQgMCl9LDkxNTMwMTpzPT57dS5rYihcIlNpZ21vaWRcIixzLHZvaWQgMCl9LDkxNTM1NjoocyxjLGYpPT57dS5rYihcIkhhcmRTaWdtb2lkXCIscyx7YWxwaGE6YyxiZXRhOmZ9KX0sOTE1NDM1OnM9Pnt1LmtiKFwiTG9nXCIscyx2b2lkIDApfSw5MTU0ODY6cz0+e3Uua2IoXCJTaW5cIixzLHZvaWQgMCl9LDkxNTUzNzpzPT57dS5rYihcIkNvc1wiLHMsdm9pZCAwKX0sOTE1NTg4OnM9Pnt1LmtiKFwiVGFuXCIscyx2b2lkIDApfSw5MTU2Mzk6cz0+e3Uua2IoXCJBc2luXCIscyx2b2lkIDApfSw5MTU2OTE6cz0+e3Uua2IoXCJBY29zXCIscyx2b2lkIDApfSw5MTU3NDM6cz0+e3Uua2IoXCJBdGFuXCIscyx2b2lkIDApfSw5MTU3OTU6cz0+e3Uua2IoXCJTaW5oXCIscyx2b2lkIDApfSw5MTU4NDc6cz0+e3Uua2IoXCJDb3NoXCIscyx2b2lkIDApfSw5MTU4OTk6cz0+e3Uua2IoXCJBc2luaFwiLHMsdm9pZCAwKX0sOTE1OTUyOnM9Pnt1LmtiKFwiQWNvc2hcIixzLHZvaWQgMCl9LDkxNjAwNTpzPT57dS5rYihcIkF0YW5oXCIscyx2b2lkIDApfSw5MTYwNTg6cz0+e3Uua2IoXCJUYW5oXCIscyx2b2lkIDApfSw5MTYxMTA6cz0+e3Uua2IoXCJOb3RcIixzLHZvaWQgMCl9LDkxNjE2MToocyxjLGYpPT57dS5rYihcIkNsaXBcIixzLHttaW46YyxtYXg6Zn0pfSw5MTYyMzA6cz0+e3Uua2IoXCJDbGlwXCIscyx2b2lkIDApfSw5MTYyODI6KHMsYyk9Pnt1LmtiKFwiRWx1XCIscyx7YWxwaGE6Y30pfSw5MTYzNDA6cz0+e3Uua2IoXCJHZWx1XCIscyx2b2lkIDApfSw5MTYzOTI6cz0+e3Uua2IoXCJSZWx1XCIscyx2b2lkIDApfSw5MTY0NDQ6KHMsYyk9Pnt1LmtiKFwiTGVha3lSZWx1XCIscyx7YWxwaGE6Y30pfSw5MTY1MDg6KHMsYyk9Pnt1LmtiKFwiVGhyZXNob2xkZWRSZWx1XCIscyx7YWxwaGE6Y30pfSw5MTY1Nzg6KHMsYyk9Pnt1LmtiKFwiQ2FzdFwiLHMse3RvOmN9KX0sOTE2NjM2OnM9Pnt1LmtiKFwiQWRkXCIscyx2b2lkIDApfSw5MTY2ODc6cz0+e3Uua2IoXCJTdWJcIixzLHZvaWQgMCl9LDkxNjczODpzPT57dS5rYihcIk11bFwiLHMsdm9pZCAwKX0sOTE2Nzg5OnM9Pnt1LmtiKFwiRGl2XCIscyx2b2lkIDApfSw5MTY4NDA6cz0+e3Uua2IoXCJQb3dcIixzLHZvaWQgMCl9LDkxNjg5MTpzPT57dS5rYihcIkVxdWFsXCIscyx2b2lkIDApfSw5MTY5NDQ6cz0+e3Uua2IoXCJHcmVhdGVyXCIscyx2b2lkIDApfSw5MTY5OTk6cz0+e3Uua2IoXCJHcmVhdGVyT3JFcXVhbFwiLHMsdm9pZCAwKX0sOTE3MDYxOnM9Pnt1LmtiKFwiTGVzc1wiLHMsdm9pZCAwKX0sOTE3MTEzOnM9Pnt1LmtiKFwiTGVzc09yRXF1YWxcIixzLHZvaWQgMCl9LDkxNzE3MjoocyxjLGYsYix3KT0+e3Uua2IoXCJSZWR1Y2VNZWFuXCIscyx7a2VlcERpbXM6ISFjLG5vb3BXaXRoRW1wdHlBeGVzOiEhZixheGVzOmI/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGIpPj4+MCxOdW1iZXIodyk+Pj4wKSk6W119KX0sOTE3MzQ3OihzLGMsZixiLHcpPT57dS5rYihcIlJlZHVjZU1heFwiLHMse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWYsYXhlczpiP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihiKT4+PjAsTnVtYmVyKHcpPj4+MCkpOltdfSl9LDkxNzUyMToocyxjLGYsYix3KT0+e3Uua2IoXCJSZWR1Y2VNaW5cIixzLHtrZWVwRGltczohIWMsbm9vcFdpdGhFbXB0eUF4ZXM6ISFmLGF4ZXM6Yj9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoYik+Pj4wLE51bWJlcih3KT4+PjApKTpbXX0pfSw5MTc2OTU6KHMsYyxmLGIsdyk9Pnt1LmtiKFwiUmVkdWNlUHJvZFwiLHMse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWYsYXhlczpiP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihiKT4+PjAsTnVtYmVyKHcpPj4+MCkpOltdfSl9LDkxNzg3MDoocyxjLGYsYix3KT0+e3Uua2IoXCJSZWR1Y2VTdW1cIixzLHtrZWVwRGltczohIWMsbm9vcFdpdGhFbXB0eUF4ZXM6ISFmLGF4ZXM6Yj9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoYik+Pj4wLE51bWJlcih3KT4+PjApKTpbXX0pfSw5MTgwNDQ6KHMsYyxmLGIsdyk9Pnt1LmtiKFwiUmVkdWNlTDFcIixzLHtrZWVwRGltczohIWMsbm9vcFdpdGhFbXB0eUF4ZXM6ISFmLGF4ZXM6Yj9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoYik+Pj4wLE51bWJlcih3KT4+PjApKTpbXX0pfSw5MTgyMTc6KHMsYyxmLGIsdyk9Pnt1LmtiKFwiUmVkdWNlTDJcIixzLHtrZWVwRGltczohIWMsbm9vcFdpdGhFbXB0eUF4ZXM6ISFmLGF4ZXM6Yj9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoYik+Pj4wLE51bWJlcih3KT4+PjApKTpbXX0pfSw5MTgzOTA6KHMsYyxmLGIsdyk9Pnt1LmtiKFwiUmVkdWNlTG9nU3VtXCIscyx7a2VlcERpbXM6ISFjLG5vb3BXaXRoRW1wdHlBeGVzOiEhZixheGVzOmI/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGIpPj4+MCxOdW1iZXIodyk+Pj4wKSk6W119KX0sOTE4NTY3OihzLGMsZixiLHcpPT57dS5rYihcIlJlZHVjZVN1bVNxdWFyZVwiLHMse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWYsYXhlczpiP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihiKT4+PjAsTnVtYmVyKHcpPj4+MCkpOltdfSl9LDkxODc0NzoocyxjLGYsYix3KT0+e3Uua2IoXCJSZWR1Y2VMb2dTdW1FeHBcIixzLHtrZWVwRGltczohIWMsbm9vcFdpdGhFbXB0eUF4ZXM6ISFmLGF4ZXM6Yj9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoYik+Pj4wLE51bWJlcih3KT4+PjApKTpbXX0pfSw5MTg5Mjc6cz0+e3Uua2IoXCJXaGVyZVwiLHMsdm9pZCAwKX0sOTE4OTgwOihzLGMsZik9Pnt1LmtiKFwiVHJhbnNwb3NlXCIscyx7cGVybTpjP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihjKT4+PjAsTnVtYmVyKGYpPj4+MCkpOltdfSl9LDkxOTEwNDoocyxjLGYsYik9Pnt1LmtiKFwiRGVwdGhUb1NwYWNlXCIscyx7YmxvY2tzaXplOmMsbW9kZTpDZShmKSxmb3JtYXQ6Yj9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5MTkyMzc6KHMsYyxmLGIpPT57dS5rYihcIkRlcHRoVG9TcGFjZVwiLHMse2Jsb2Nrc2l6ZTpjLG1vZGU6Q2UoZiksZm9ybWF0OmI/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTE5MzcwOihzLGMsZixiLHcsSSxPLEIsTCxILFgsY2UsZ2UseixkZSk9Pnt1LmtiKFwiQ29udlRyYW5zcG9zZVwiLHMse2Zvcm1hdDpMP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9QYWQ6YyxkaWxhdGlvbnM6W2ZdLGdyb3VwOmIsa2VybmVsU2hhcGU6W3ddLHBhZHM6W0ksT10sc3RyaWRlczpbQl0sd0lzQ29uc3Q6KCk9PiEhdCgpW0g+Pj4wXSxvdXRwdXRQYWRkaW5nOlg/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKFgpPj4+MCxOdW1iZXIoY2UpPj4+MCkpOltdLG91dHB1dFNoYXBlOmdlP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihnZSk+Pj4wLE51bWJlcih6KT4+PjApKTpbXSxhY3RpdmF0aW9uOkNlKGRlKX0pfSw5MTk4MDM6KHMsYyxmLGIsdyxJLE8sQixMLEgsWCxjZSxnZSx6KT0+e3Uua2IoXCJDb252VHJhbnNwb3NlXCIscyx7Zm9ybWF0OkI/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b1BhZDpjLGRpbGF0aW9uczpBcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoZik+Pj4wLDIrKE51bWJlcihmKT4+PjApPj4+MCkpLGdyb3VwOmIsa2VybmVsU2hhcGU6QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKHcpPj4+MCwyKyhOdW1iZXIodyk+Pj4wKT4+PjApKSxwYWRzOkFycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihJKT4+PjAsNCsoTnVtYmVyKEkpPj4+MCk+Pj4wKSksc3RyaWRlczpBcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoTyk+Pj4wLDIrKE51bWJlcihPKT4+PjApPj4+MCkpLHdJc0NvbnN0OigpPT4hIXQoKVtMPj4+MF0sb3V0cHV0UGFkZGluZzpIP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihIKT4+PjAsTnVtYmVyKFgpPj4+MCkpOltdLG91dHB1dFNoYXBlOmNlP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihjZSk+Pj4wLE51bWJlcihnZSk+Pj4wKSk6W10sYWN0aXZhdGlvbjpDZSh6KX0pfSw5MjA0NjQ6KHMsYyxmLGIsdyxJLE8sQixMLEgsWCxjZSxnZSx6LGRlKT0+e3Uua2IoXCJDb252VHJhbnNwb3NlXCIscyx7Zm9ybWF0Okw/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b1BhZDpjLGRpbGF0aW9uczpbZl0sZ3JvdXA6YixrZXJuZWxTaGFwZTpbd10scGFkczpbSSxPXSxzdHJpZGVzOltCXSx3SXNDb25zdDooKT0+ISF0KClbSD4+PjBdLG91dHB1dFBhZGRpbmc6WD9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoWCk+Pj4wLE51bWJlcihjZSk+Pj4wKSk6W10sb3V0cHV0U2hhcGU6Z2U/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGdlKT4+PjAsTnVtYmVyKHopPj4+MCkpOltdLGFjdGl2YXRpb246Q2UoZGUpfSl9LDkyMDg5NzoocyxjLGYsYix3LEksTyxCLEwsSCxYLGNlLGdlLHopPT57dS5rYihcIkNvbnZUcmFuc3Bvc2VcIixzLHtmb3JtYXQ6Qj9cIk5IV0NcIjpcIk5DSFdcIixhdXRvUGFkOmMsZGlsYXRpb25zOkFycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihmKT4+PjAsMisoTnVtYmVyKGYpPj4+MCk+Pj4wKSksZ3JvdXA6YixrZXJuZWxTaGFwZTpBcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIodyk+Pj4wLDIrKE51bWJlcih3KT4+PjApPj4+MCkpLHBhZHM6QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKEkpPj4+MCw0KyhOdW1iZXIoSSk+Pj4wKT4+PjApKSxzdHJpZGVzOkFycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihPKT4+PjAsMisoTnVtYmVyKE8pPj4+MCk+Pj4wKSksd0lzQ29uc3Q6KCk9PiEhdCgpW0w+Pj4wXSxvdXRwdXRQYWRkaW5nOkg/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKEgpPj4+MCxOdW1iZXIoWCk+Pj4wKSk6W10sb3V0cHV0U2hhcGU6Y2U/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGNlKT4+PjAsTnVtYmVyKGdlKT4+PjApKTpbXSxhY3RpdmF0aW9uOkNlKHopfSl9LDkyMTU1ODoocyxjKT0+e3Uua2IoXCJHbG9iYWxBdmVyYWdlUG9vbFwiLHMse2Zvcm1hdDpjP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkyMTY0OToocyxjLGYsYix3LEksTyxCLEwsSCxYLGNlLGdlLHopPT57dS5rYihcIkF2ZXJhZ2VQb29sXCIscyx7Zm9ybWF0Ono/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6YyxjZWlsX21vZGU6Zixjb3VudF9pbmNsdWRlX3BhZDpiLHN0b3JhZ2Vfb3JkZXI6dyxkaWxhdGlvbnM6ST9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoSSk+Pj4wLE51bWJlcihPKT4+PjApKTpbXSxrZXJuZWxfc2hhcGU6Qj9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoQik+Pj4wLE51bWJlcihMKT4+PjApKTpbXSxwYWRzOkg/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKEgpPj4+MCxOdW1iZXIoWCk+Pj4wKSk6W10sc3RyaWRlczpjZT9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoY2UpPj4+MCxOdW1iZXIoZ2UpPj4+MCkpOltdfSl9LDkyMjEyODoocyxjKT0+e3Uua2IoXCJHbG9iYWxBdmVyYWdlUG9vbFwiLHMse2Zvcm1hdDpjP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkyMjIxOToocyxjLGYsYix3LEksTyxCLEwsSCxYLGNlLGdlLHopPT57dS5rYihcIkF2ZXJhZ2VQb29sXCIscyx7Zm9ybWF0Ono/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6YyxjZWlsX21vZGU6Zixjb3VudF9pbmNsdWRlX3BhZDpiLHN0b3JhZ2Vfb3JkZXI6dyxkaWxhdGlvbnM6ST9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoSSk+Pj4wLE51bWJlcihPKT4+PjApKTpbXSxrZXJuZWxfc2hhcGU6Qj9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoQik+Pj4wLE51bWJlcihMKT4+PjApKTpbXSxwYWRzOkg/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKEgpPj4+MCxOdW1iZXIoWCk+Pj4wKSk6W10sc3RyaWRlczpjZT9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoY2UpPj4+MCxOdW1iZXIoZ2UpPj4+MCkpOltdfSl9LDkyMjY5ODoocyxjKT0+e3Uua2IoXCJHbG9iYWxNYXhQb29sXCIscyx7Zm9ybWF0OmM/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTIyNzg1OihzLGMsZixiLHcsSSxPLEIsTCxILFgsY2UsZ2Useik9Pnt1LmtiKFwiTWF4UG9vbFwiLHMse2Zvcm1hdDp6P1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOmMsY2VpbF9tb2RlOmYsY291bnRfaW5jbHVkZV9wYWQ6YixzdG9yYWdlX29yZGVyOncsZGlsYXRpb25zOkk/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKEkpPj4+MCxOdW1iZXIoTyk+Pj4wKSk6W10sa2VybmVsX3NoYXBlOkI/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKEIpPj4+MCxOdW1iZXIoTCk+Pj4wKSk6W10scGFkczpIP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihIKT4+PjAsTnVtYmVyKFgpPj4+MCkpOltdLHN0cmlkZXM6Y2U/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGNlKT4+PjAsTnVtYmVyKGdlKT4+PjApKTpbXX0pfSw5MjMyNjA6KHMsYyk9Pnt1LmtiKFwiR2xvYmFsTWF4UG9vbFwiLHMse2Zvcm1hdDpjP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkyMzM0NzoocyxjLGYsYix3LEksTyxCLEwsSCxYLGNlLGdlLHopPT57dS5rYihcIk1heFBvb2xcIixzLHtmb3JtYXQ6ej9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDpjLGNlaWxfbW9kZTpmLGNvdW50X2luY2x1ZGVfcGFkOmIsc3RvcmFnZV9vcmRlcjp3LGRpbGF0aW9uczpJP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihJKT4+PjAsTnVtYmVyKE8pPj4+MCkpOltdLGtlcm5lbF9zaGFwZTpCP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihCKT4+PjAsTnVtYmVyKEwpPj4+MCkpOltdLHBhZHM6SD9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoSCk+Pj4wLE51bWJlcihYKT4+PjApKTpbXSxzdHJpZGVzOmNlP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihjZSk+Pj4wLE51bWJlcihnZSk+Pj4wKSk6W119KX0sOTIzODIyOihzLGMsZixiLHcpPT57dS5rYihcIkdlbW1cIixzLHthbHBoYTpjLGJldGE6Zix0cmFuc0E6Yix0cmFuc0I6d30pfSw5MjM5MjY6cz0+e3Uua2IoXCJNYXRNdWxcIixzLHZvaWQgMCl9LDkyMzk4MDoocyxjLGYsYik9Pnt1LmtiKFwiQXJnTWF4XCIscyx7a2VlcERpbXM6ISFjLHNlbGVjdExhc3RJbmRleDohIWYsYXhpczpifSl9LDkyNDA4ODoocyxjLGYsYik9Pnt1LmtiKFwiQXJnTWluXCIscyx7a2VlcERpbXM6ISFjLHNlbGVjdExhc3RJbmRleDohIWYsYXhpczpifSl9LDkyNDE5NjoocyxjKT0+e3Uua2IoXCJTb2Z0bWF4XCIscyx7YXhpczpjfSl9LDkyNDI1OToocyxjKT0+e3Uua2IoXCJDb25jYXRcIixzLHtheGlzOmN9KX0sOTI0MzE5OihzLGMsZixiLHcpPT57dS5rYihcIlNwbGl0XCIscyx7YXhpczpjLG51bU91dHB1dHM6ZixzcGxpdFNpemVzOmI/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGIpPj4+MCxOdW1iZXIodyk+Pj4wKSk6W119KX0sOTI0NDc1OnM9Pnt1LmtiKFwiRXhwYW5kXCIscyx2b2lkIDApfSw5MjQ1Mjk6KHMsYyk9Pnt1LmtiKFwiR2F0aGVyXCIscyx7YXhpczpOdW1iZXIoYyl9KX0sOTI0NjAwOihzLGMpPT57dS5rYihcIkdhdGhlckVsZW1lbnRzXCIscyx7YXhpczpOdW1iZXIoYyl9KX0sOTI0Njc5OihzLGMpPT57dS5rYihcIkdhdGhlck5EXCIscyx7YmF0Y2hfZGltczpOdW1iZXIoYyl9KX0sOTI0NzU4OihzLGMsZixiLHcsSSxPLEIsTCxILFgpPT57dS5rYihcIlJlc2l6ZVwiLHMse2FudGlhbGlhczpjLGF4ZXM6Zj9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoZik+Pj4wLE51bWJlcihiKT4+PjApKTpbXSxjb29yZGluYXRlVHJhbnNmb3JtTW9kZTpDZSh3KSxjdWJpY0NvZWZmQTpJLGV4Y2x1ZGVPdXRzaWRlOk8sZXh0cmFwb2xhdGlvblZhbHVlOkIsa2VlcEFzcGVjdFJhdGlvUG9saWN5OkNlKEwpLG1vZGU6Q2UoSCksbmVhcmVzdE1vZGU6Q2UoWCl9KX0sOTI1MTIwOihzLGMsZixiLHcsSSxPKT0+e3Uua2IoXCJTbGljZVwiLHMse3N0YXJ0czpjP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihjKT4+PjAsTnVtYmVyKGYpPj4+MCkpOltdLGVuZHM6Yj9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoYik+Pj4wLE51bWJlcih3KT4+PjApKTpbXSxheGVzOkk/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKEkpPj4+MCxOdW1iZXIoTyk+Pj4wKSk6W119KX0sOTI1Mzg0OnM9Pnt1LmtiKFwiVGlsZVwiLHMsdm9pZCAwKX0sOTI1NDM2OihzLGMsZik9Pnt1LmtiKFwiSW5zdGFuY2VOb3JtYWxpemF0aW9uXCIscyx7ZXBzaWxvbjpjLGZvcm1hdDpmP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkyNTU1MDoocyxjLGYpPT57dS5rYihcIkluc3RhbmNlTm9ybWFsaXphdGlvblwiLHMse2Vwc2lsb246Yyxmb3JtYXQ6Zj9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5MjU2NjQ6cz0+e3Uua2IoXCJSYW5nZVwiLHMsdm9pZCAwKX0sOTI1NzE3OihzLGMpPT57dS5rYihcIkVpbnN1bVwiLHMse2VxdWF0aW9uOkNlKGMpfSl9LDkyNTc5ODoocyxjLGYsYix3KT0+e3Uua2IoXCJQYWRcIixzLHttb2RlOmMsdmFsdWU6ZixwYWRzOmI/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGIpPj4+MCxOdW1iZXIodyk+Pj4wKSk6W119KX0sOTI1OTQxOihzLGMsZixiLHcsSSk9Pnt1LmtiKFwiQmF0Y2hOb3JtYWxpemF0aW9uXCIscyx7ZXBzaWxvbjpjLG1vbWVudHVtOmYsc3BhdGlhbDohIXcsdHJhaW5pbmdNb2RlOiEhYixmb3JtYXQ6ST9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5MjYxMTA6KHMsYyxmLGIsdyxJKT0+e3Uua2IoXCJCYXRjaE5vcm1hbGl6YXRpb25cIixzLHtlcHNpbG9uOmMsbW9tZW50dW06ZixzcGF0aWFsOiEhdyx0cmFpbmluZ01vZGU6ISFiLGZvcm1hdDpJP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkyNjI3OToocyxjLGYpPT57dS5rYihcIkN1bVN1bVwiLHMse2V4Y2x1c2l2ZTpOdW1iZXIoYykscmV2ZXJzZTpOdW1iZXIoZil9KX0sOTI2Mzc2OihzLGMsZik9Pnt1LmtiKFwiRGVxdWFudGl6ZUxpbmVhclwiLHMse2F4aXM6YyxibG9ja1NpemU6Zn0pfSw5MjY0NjY6KHMsYyxmLGIsdyk9Pnt1LmtiKFwiR3JpZFNhbXBsZVwiLHMse2FsaWduX2Nvcm5lcnM6Yyxtb2RlOkNlKGYpLHBhZGRpbmdfbW9kZTpDZShiKSxmb3JtYXQ6dz9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5MjY2MzY6KHMsYyxmLGIsdyk9Pnt1LmtiKFwiR3JpZFNhbXBsZVwiLHMse2FsaWduX2Nvcm5lcnM6Yyxtb2RlOkNlKGYpLHBhZGRpbmdfbW9kZTpDZShiKSxmb3JtYXQ6dz9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5MjY4MDY6KHMsYyxmLGIsdyxJLE8sQixMKT0+e3Uua2IoXCJBdHRlbnRpb25cIixzLHtudW1IZWFkczpjLGlzVW5pZGlyZWN0aW9uYWw6ZixtYXNrRmlsdGVyVmFsdWU6YixzY2FsZTp3LGRvUm90YXJ5OkkscWt2SGlkZGVuU2l6ZXM6Tz9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoQik+Pj4wLE51bWJlcihCKStPPj4+MCkpOltdLHBhc3RQcmVzZW50U2hhcmVCdWZmZXI6ISFMfSl9LDkyNzA3ODpzPT57dS5rYihcIkJpYXNBZGRcIixzLHZvaWQgMCl9LDkyNzEzMzpzPT57dS5rYihcIkJpYXNTcGxpdEdlbHVcIixzLHZvaWQgMCl9LDkyNzE5NDpzPT57dS5rYihcIkZhc3RHZWx1XCIscyx2b2lkIDApfSw5MjcyNTA6KHMsYyxmLGIsdyxJLE8sQixMLEgsWCxjZSxnZSx6LGRlLFRlKT0+e3Uua2IoXCJDb252XCIscyx7Zm9ybWF0OmNlP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOmMsZGlsYXRpb25zOmY/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGYpPj4+MCxOdW1iZXIoYik+Pj4wKSk6W10sZ3JvdXA6dyxrZXJuZWxfc2hhcGU6ST9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoSSk+Pj4wLE51bWJlcihPKT4+PjApKTpbXSxwYWRzOkI/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKEIpPj4+MCxOdW1iZXIoTCk+Pj4wKSk6W10sc3RyaWRlczpIP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihIKT4+PjAsTnVtYmVyKFgpPj4+MCkpOltdLHdfaXNfY29uc3Q6KCk9PiEhdCgpW051bWJlcihnZSk+Pj4wXSxhY3RpdmF0aW9uOkNlKHopLGFjdGl2YXRpb25fcGFyYW1zOmRlP0FycmF5LmZyb20oZCgpLnN1YmFycmF5KE51bWJlcihkZSk+Pj4wLE51bWJlcihUZSk+Pj4wKSk6W119KX0sOTI3ODM0OnM9Pnt1LmtiKFwiR2VsdVwiLHMsdm9pZCAwKX0sOTI3ODg2OihzLGMsZixiLHcsSSxPLEIsTCk9Pnt1LmtiKFwiR3JvdXBRdWVyeUF0dGVudGlvblwiLHMse251bUhlYWRzOmMsa3ZOdW1IZWFkczpmLHNjYWxlOmIsc29mdGNhcDp3LGRvUm90YXJ5Okkscm90YXJ5SW50ZXJsZWF2ZWQ6TyxzbW9vdGhTb2Z0bWF4OkIsbG9jYWxXaW5kb3dTaXplOkx9KX0sOTI4MTAzOihzLGMsZixiKT0+e3Uua2IoXCJMYXllck5vcm1hbGl6YXRpb25cIixzLHtheGlzOmMsZXBzaWxvbjpmLHNpbXBsaWZpZWQ6ISFifSl9LDkyODIxNDoocyxjLGYsYik9Pnt1LmtiKFwiTGF5ZXJOb3JtYWxpemF0aW9uXCIscyx7YXhpczpjLGVwc2lsb246ZixzaW1wbGlmaWVkOiEhYn0pfSw5MjgzMjU6KHMsYyxmLGIsdyxJKT0+e3Uua2IoXCJNYXRNdWxOQml0c1wiLHMse2s6YyxuOmYsYWNjdXJhY3lMZXZlbDpiLGJpdHM6dyxibG9ja1NpemU6SX0pfSw5Mjg0NTI6KHMsYyxmLGIsdyxJKT0+e3Uua2IoXCJNdWx0aUhlYWRBdHRlbnRpb25cIixzLHtudW1IZWFkczpjLGlzVW5pZGlyZWN0aW9uYWw6ZixtYXNrRmlsdGVyVmFsdWU6YixzY2FsZTp3LGRvUm90YXJ5Okl9KX0sOTI4NjExOihzLGMpPT57dS5rYihcIlF1aWNrR2VsdVwiLHMse2FscGhhOmN9KX0sOTI4Njc1OihzLGMsZixiLHcpPT57dS5rYihcIlJvdGFyeUVtYmVkZGluZ1wiLHMse2ludGVybGVhdmVkOiEhYyxudW1IZWFkczpmLHJvdGFyeUVtYmVkZGluZ0RpbTpiLHNjYWxlOnd9KX0sOTI4ODE0OihzLGMsZik9Pnt1LmtiKFwiU2tpcExheWVyTm9ybWFsaXphdGlvblwiLHMse2Vwc2lsb246YyxzaW1wbGlmaWVkOiEhZn0pfSw5Mjg5MTY6KHMsYyxmKT0+e3Uua2IoXCJTa2lwTGF5ZXJOb3JtYWxpemF0aW9uXCIscyx7ZXBzaWxvbjpjLHNpbXBsaWZpZWQ6ISFmfSl9LDkyOTAxODoocyxjLGYsYik9Pnt1LmtiKFwiR2F0aGVyQmxvY2tRdWFudGl6ZWRcIixzLHtnYXRoZXJBeGlzOmMscXVhbnRpemVBeGlzOmYsYmxvY2tTaXplOmJ9KX0sOTI5MTM5OnM9Pnt1LiRiKHMpfSw5MjkxNzM6KHMsYyk9PnUuY2MoTnVtYmVyKHMpLE51bWJlcihjKSx1LkdiLmhjLHUuR2IuZXJyb3JzKX07ZnVuY3Rpb24gdmMocyxjLGYpe3JldHVybiBfaShhc3luYygpPT57YXdhaXQgdS5ZYihOdW1iZXIocyksTnVtYmVyKGMpLE51bWJlcihmKSl9KX1mdW5jdGlvbiAkYygpe3JldHVybiB0eXBlb2Ygd2FzbU9mZnNldENvbnZlcnRlcjxcInVcIn1mdW5jdGlvbiB5bihzKXt0aGlzLm5hbWU9XCJFeGl0U3RhdHVzXCIsdGhpcy5tZXNzYWdlPWBQcm9ncmFtIHRlcm1pbmF0ZWQgd2l0aCBleGl0KCR7c30pYCx0aGlzLnN0YXR1cz1zfXZhciBfbj1zPT57cy50ZXJtaW5hdGUoKSxzLm9ubWVzc2FnZT0oKT0+e319LFZvPXM9PntwdC5sZW5ndGg9PTAmJihxbygpLEZvKHB0WzBdKSk7dmFyIGM9cHQucG9wKCk7aWYoIWMpcmV0dXJuIDY7dnQucHVzaChjKSxaZVtzLkJiXT1jLGMuQmI9cy5CYjt2YXIgZj17Y21kOlwicnVuXCIsc3RhcnRfcm91dGluZTpzLmljLGFyZzpzLlJiLHB0aHJlYWRfcHRyOnMuQmJ9O3JldHVybiBjLnBvc3RNZXNzYWdlKGYscy5uYyksMH0sd3Q9MCx4ZT0ocyxjLC4uLmYpPT57Zm9yKHZhciBiPTIqZi5sZW5ndGgsdz1SbigpLEk9TW4oOCpiKSxPPUk+Pj4zLEI9MDtCPGYubGVuZ3RoO0IrKyl7dmFyIEw9ZltCXTt0eXBlb2YgTD09XCJiaWdpbnRcIj8ocVtPKzIqQl09MW4scVtPKzIqQisxXT1MKToocVtPKzIqQl09MG4sbCgpW08rMipCKzE+Pj4wXT1MKX1yZXR1cm4gcz1HaShzLDAsYixJLGMpLGdyKHcpLHN9O2Z1bmN0aW9uIHduKHMpe2lmKGcpcmV0dXJuIHhlKDAsMSxzKTtpZihlZT1zLCEoMDx3dCkpe2Zvcih2YXIgYyBvZiB2dClfbihjKTtmb3IoYyBvZiBwdClfbihjKTtwdD1bXSx2dD1bXSxaZT1bXSx3ZT0hMH1rKHMsbmV3IHluKHMpKX1mdW5jdGlvbiBXbyhzKXtpZihnKXJldHVybiB4ZSgxLDAscyk7dm4ocyl9dmFyIHZuPXM9PntpZihlZT1zLGcpdGhyb3cgV28ocyksXCJ1bndpbmRcIjt3bihzKX0scHQ9W10sdnQ9W10sTG89W10sWmU9e30sR289cz0+e3ZhciBjPXMuQmI7ZGVsZXRlIFplW2NdLHB0LnB1c2gocyksdnQuc3BsaWNlKHZ0LmluZGV4T2YocyksMSkscy5CYj0wLEJuKGMpfTtmdW5jdGlvbiBIbygpe0xvLmZvckVhY2gocz0+cygpKX12YXIgRm89cz0+bmV3IFByb21pc2UoYz0+e3Mub25tZXNzYWdlPXc9Pnt2YXIgST0odz13LmRhdGEpLmNtZDtpZih3LnRhcmdldFRocmVhZCYmdy50YXJnZXRUaHJlYWQhPU10KCkpe3ZhciBPPVplW3cudGFyZ2V0VGhyZWFkXTtPP08ucG9zdE1lc3NhZ2Uodyx3LnRyYW5zZmVyTGlzdCk6aihgSW50ZXJuYWwgZXJyb3IhIFdvcmtlciBzZW50IGEgbWVzc2FnZSBcIiR7SX1cIiB0byB0YXJnZXQgcHRocmVhZCAke3cudGFyZ2V0VGhyZWFkfSwgYnV0IHRoYXQgdGhyZWFkIG5vIGxvbmdlciBleGlzdHMhYCl9ZWxzZSBJPT09XCJjaGVja01haWxib3hcIj9pcigpOkk9PT1cInNwYXduVGhyZWFkXCI/Vm8odyk6ST09PVwiY2xlYW51cFRocmVhZFwiP0dvKFplW3cudGhyZWFkXSk6ST09PVwia2lsbFRocmVhZFwiPyh3PXcudGhyZWFkLEk9WmVbd10sZGVsZXRlIFplW3ddLF9uKEkpLEJuKHcpLHZ0LnNwbGljZSh2dC5pbmRleE9mKEkpLDEpLEkuQmI9MCk6ST09PVwiY2FuY2VsVGhyZWFkXCI/WmVbdy50aHJlYWRdLnBvc3RNZXNzYWdlKHtjbWQ6XCJjYW5jZWxcIn0pOkk9PT1cImxvYWRlZFwiPyhzLmxvYWRlZD0hMCxjKHMpKTpJPT09XCJhbGVydFwiP2FsZXJ0KGBUaHJlYWQgJHt3LnRocmVhZElkfTogJHt3LnRleHR9YCk6dy50YXJnZXQ9PT1cInNldGltbWVkaWF0ZVwiP3MucG9zdE1lc3NhZ2Uodyk6ST09PVwiY2FsbEhhbmRsZXJcIj91W3cuaGFuZGxlcl0oLi4udy5hcmdzKTpJJiZqKGB3b3JrZXIgc2VudCBhbiB1bmtub3duIGNvbW1hbmQgJHtJfWApfSxzLm9uZXJyb3I9dz0+e3Rocm93IGooYHdvcmtlciBzZW50IGFuIGVycm9yISAke3cuZmlsZW5hbWV9OiR7dy5saW5lbm99OiAke3cubWVzc2FnZX1gKSx3fTt2YXIgZixiPVtdO2ZvcihmIG9mW10pdS5oYXNPd25Qcm9wZXJ0eShmKSYmYi5wdXNoKGYpO3MucG9zdE1lc3NhZ2Uoe2NtZDpcImxvYWRcIixoYW5kbGVyczpiLHdhc21NZW1vcnk6c2Usd2FzbU1vZHVsZTpZfSl9KTtmdW5jdGlvbiBxbygpe3ZhciBzPW5ldyBXb3JrZXIoaW1wb3J0Lm1ldGEudXJsLnN0YXJ0c1dpdGgoXCJmaWxlOlwiKT9uZXcgVVJMKFwib3J0LmJ1bmRsZS5taW4ubWpzXCIsaW1wb3J0Lm1ldGEudXJsKTpuZXcgVVJMKGltcG9ydC5tZXRhLnVybCkse3R5cGU6XCJtb2R1bGVcIix3b3JrZXJEYXRhOlwiZW0tcHRocmVhZFwiLG5hbWU6XCJlbS1wdGhyZWFkXCJ9KTtwdC5wdXNoKHMpfXZhciBvcj1zPT57Zm9yKDswPHMubGVuZ3RoOylzLnNoaWZ0KCkodSl9LHhjPSgpPT57dmFyIHM9TXQoKSxjPWEoKVtzKzUyPj4+Mj4+PjBdO3M9YSgpW3MrNTY+Pj4yPj4+MF0sRmkoYyxjLXMpLGdyKGMpfSxTYz0ocyxjKT0+e3d0PTAscz1xaShzLGMpLDA8d3Q/ZWU9czpocihzKX07Y2xhc3MgVGN7Y29uc3RydWN0b3IoYyl7dGhpcy5LYj1jLTI0fX1mdW5jdGlvbiBJYyhzLGMsZil7dmFyIGI9bmV3IFRjKHM+Pj49MCk7dGhyb3cgYz4+Pj0wLGY+Pj49MCxhKClbYi5LYisxNj4+PjI+Pj4wXT0wLGEoKVtiLktiKzQ+Pj4yPj4+MF09YyxhKClbYi5LYis4Pj4+Mj4+PjBdPWYsc31mdW5jdGlvbiBLbyhzLGMsZixiKXtyZXR1cm4gZz94ZSgyLDEscyxjLGYsYik6am8ocyxjLGYsYil9ZnVuY3Rpb24gam8ocyxjLGYsYil7aWYocz4+Pj0wLGM+Pj49MCxmPj4+PTAsYj4+Pj0wLHg9PT12b2lkIDApcmV0dXJuIGooXCJDdXJyZW50IGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgU2hhcmVkQXJyYXlCdWZmZXIsIHB0aHJlYWRzIGFyZSBub3QgYXZhaWxhYmxlIVwiKSw2O3ZhciB3PVtdO3JldHVybiBnJiZ3Lmxlbmd0aD09PTA/S28ocyxjLGYsYik6KHM9e2ljOmYsQmI6cyxSYjpiLG5jOnd9LGc/KHMuTmI9XCJzcGF3blRocmVhZFwiLHBvc3RNZXNzYWdlKHMsdyksMCk6Vm8ocykpfXZhciBZbz10eXBlb2YgVGV4dERlY29kZXI8XCJ1XCI/bmV3IFRleHREZWNvZGVyKFwidXRmOFwiKTp2b2lkIDAsWm89KHMsYyxmKT0+e3ZhciBiPShjPj4+PTApK2Y7Zm9yKGY9YztzW2ZdJiYhKGY+PWIpOykrK2Y7aWYoMTY8Zi1jJiZzLmJ1ZmZlciYmWW8pcmV0dXJuIFlvLmRlY29kZShzLmJ1ZmZlciBpbnN0YW5jZW9mIHg/cy5zbGljZShjLGYpOnMuc3ViYXJyYXkoYyxmKSk7Zm9yKGI9XCJcIjtjPGY7KXt2YXIgdz1zW2MrK107aWYoMTI4Jncpe3ZhciBJPTYzJnNbYysrXTtpZigoMjI0JncpPT0xOTIpYis9U3RyaW5nLmZyb21DaGFyQ29kZSgoMzEmdyk8PDZ8SSk7ZWxzZXt2YXIgTz02MyZzW2MrK107NjU1MzY+KHc9KDI0MCZ3KT09MjI0PygxNSZ3KTw8MTJ8STw8NnxPOig3JncpPDwxOHxJPDwxMnxPPDw2fDYzJnNbYysrXSk/Yis9U3RyaW5nLmZyb21DaGFyQ29kZSh3KToody09NjU1MzYsYis9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5Nnx3Pj4xMCw1NjMyMHwxMDIzJncpKX19ZWxzZSBiKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHcpfXJldHVybiBifSxDZT0ocyxjKT0+KHM+Pj49MCk/Wm8ocigpLHMsYyk6XCJcIjtmdW5jdGlvbiBRbyhzLGMsZil7cmV0dXJuIGc/eGUoMywxLHMsYyxmKTowfWZ1bmN0aW9uIFhvKHMsYyl7aWYoZylyZXR1cm4geGUoNCwxLHMsYyl9dmFyICRuPXM9Pntmb3IodmFyIGM9MCxmPTA7ZjxzLmxlbmd0aDsrK2Ype3ZhciBiPXMuY2hhckNvZGVBdChmKTsxMjc+PWI/YysrOjIwNDc+PWI/Yys9Mjo1NTI5Njw9YiYmNTczNDM+PWI/KGMrPTQsKytmKTpjKz0zfXJldHVybiBjfSxKbz0ocyxjLGYsYik9PntpZighKDA8YikpcmV0dXJuIDA7dmFyIHc9Zj4+Pj0wO2I9ZitiLTE7Zm9yKHZhciBJPTA7STxzLmxlbmd0aDsrK0kpe3ZhciBPPXMuY2hhckNvZGVBdChJKTtpZig1NTI5Njw9TyYmNTczNDM+PU8mJihPPTY1NTM2KygoMTAyMyZPKTw8MTApfDEwMjMmcy5jaGFyQ29kZUF0KCsrSSkpLDEyNz49Tyl7aWYoZj49YilicmVhaztjW2YrKz4+PjBdPU99ZWxzZXtpZigyMDQ3Pj1PKXtpZihmKzE+PWIpYnJlYWs7Y1tmKys+Pj4wXT0xOTJ8Tz4+Nn1lbHNle2lmKDY1NTM1Pj1PKXtpZihmKzI+PWIpYnJlYWs7Y1tmKys+Pj4wXT0yMjR8Tz4+MTJ9ZWxzZXtpZihmKzM+PWIpYnJlYWs7Y1tmKys+Pj4wXT0yNDB8Tz4+MTgsY1tmKys+Pj4wXT0xMjh8Tz4+MTImNjN9Y1tmKys+Pj4wXT0xMjh8Tz4+NiY2M31jW2YrKz4+PjBdPTEyOHw2MyZPfX1yZXR1cm4gY1tmPj4+MF09MCxmLXd9LE90PShzLGMsZik9PkpvKHMscigpLGMsZik7ZnVuY3Rpb24gZWkocyxjKXtpZihnKXJldHVybiB4ZSg1LDEscyxjKX1mdW5jdGlvbiB0aShzLGMsZil7aWYoZylyZXR1cm4geGUoNiwxLHMsYyxmKX1mdW5jdGlvbiByaShzLGMsZil7cmV0dXJuIGc/eGUoNywxLHMsYyxmKTowfWZ1bmN0aW9uIG5pKHMsYyl7aWYoZylyZXR1cm4geGUoOCwxLHMsYyl9ZnVuY3Rpb24gb2kocyxjLGYpe2lmKGcpcmV0dXJuIHhlKDksMSxzLGMsZil9ZnVuY3Rpb24gaWkocyxjLGYsYil7aWYoZylyZXR1cm4geGUoMTAsMSxzLGMsZixiKX1mdW5jdGlvbiBhaShzLGMsZixiKXtpZihnKXJldHVybiB4ZSgxMSwxLHMsYyxmLGIpfWZ1bmN0aW9uIHNpKHMsYyxmLGIpe2lmKGcpcmV0dXJuIHhlKDEyLDEscyxjLGYsYil9ZnVuY3Rpb24gdWkocyl7aWYoZylyZXR1cm4geGUoMTMsMSxzKX1mdW5jdGlvbiBkaShzLGMpe2lmKGcpcmV0dXJuIHhlKDE0LDEscyxjKX1mdW5jdGlvbiBsaShzLGMsZil7aWYoZylyZXR1cm4geGUoMTUsMSxzLGMsZil9dmFyIGNpLG10LENjPSgpPT57Y3QoXCJcIil9LFFlPXM9Pntmb3IodmFyIGM9XCJcIjtyKClbcz4+PjBdOyljKz1jaVtyKClbcysrPj4+MF1dO3JldHVybiBjfSx4bj17fSxTbj17fSxBYz17fTtmdW5jdGlvbiBzdChzLGMsZj17fSl7aWYoIShcImFyZ1BhY2tBZHZhbmNlXCJpbiBjKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwicmVnaXN0ZXJUeXBlIHJlZ2lzdGVyZWRJbnN0YW5jZSByZXF1aXJlcyBhcmdQYWNrQWR2YW5jZVwiKTtyZXR1cm4gZnVuY3Rpb24oYix3LEk9e30pe3ZhciBPPXcubmFtZTtpZighYil0aHJvdyBuZXcgbXQoYHR5cGUgXCIke099XCIgbXVzdCBoYXZlIGEgcG9zaXRpdmUgaW50ZWdlciB0eXBlaWQgcG9pbnRlcmApO2lmKFNuLmhhc093blByb3BlcnR5KGIpKXtpZihJLlRiKXJldHVybjt0aHJvdyBuZXcgbXQoYENhbm5vdCByZWdpc3RlciB0eXBlICcke099JyB0d2ljZWApfVNuW2JdPXcsZGVsZXRlIEFjW2JdLHhuLmhhc093blByb3BlcnR5KGIpJiYodz14bltiXSxkZWxldGUgeG5bYl0sdy5mb3JFYWNoKEI9PkIoKSkpfShzLGMsZil9dmFyIHBpPShzLGMsZik9Pntzd2l0Y2goYyl7Y2FzZSAxOnJldHVybiBmP2I9PnQoKVtiPj4+MF06Yj0+cigpW2I+Pj4wXTtjYXNlIDI6cmV0dXJuIGY/Yj0+bigpW2I+Pj4xPj4+MF06Yj0+bygpW2I+Pj4xPj4+MF07Y2FzZSA0OnJldHVybiBmP2I9PmkoKVtiPj4+Mj4+PjBdOmI9PmEoKVtiPj4+Mj4+PjBdO2Nhc2UgODpyZXR1cm4gZj9iPT5xW2I+Pj4zXTpiPT5oZVtiPj4+M107ZGVmYXVsdDp0aHJvdyBuZXcgVHlwZUVycm9yKGBpbnZhbGlkIGludGVnZXIgd2lkdGggKCR7Y30pOiAke3N9YCl9fTtmdW5jdGlvbiBrYyhzLGMsZil7Zj4+Pj0wLHN0KHM+Pj49MCx7bmFtZTpjPVFlKGM+Pj4wKSxmcm9tV2lyZVR5cGU6Yj0+Yix0b1dpcmVUeXBlOmZ1bmN0aW9uKGIsdyl7aWYodHlwZW9mIHchPVwiYmlnaW50XCImJnR5cGVvZiB3IT1cIm51bWJlclwiKXRocm93IHc9dz09PW51bGw/XCJudWxsXCI6KGI9dHlwZW9mIHcpPT1cIm9iamVjdFwifHxiPT09XCJhcnJheVwifHxiPT09XCJmdW5jdGlvblwiP3cudG9TdHJpbmcoKTpcIlwiK3csbmV3IFR5cGVFcnJvcihgQ2Fubm90IGNvbnZlcnQgXCIke3d9XCIgdG8gJHt0aGlzLm5hbWV9YCk7cmV0dXJuIHR5cGVvZiB3PT1cIm51bWJlclwiJiYodz1CaWdJbnQodykpLHd9LGFyZ1BhY2tBZHZhbmNlOmZ0LHJlYWRWYWx1ZUZyb21Qb2ludGVyOnBpKGMsZixjLmluZGV4T2YoXCJ1XCIpPT0tMSksRWI6bnVsbH0pfXZhciBmdD04O2Z1bmN0aW9uIEVjKHMsYyxmLGIpe3N0KHM+Pj49MCx7bmFtZTpjPVFlKGM+Pj4wKSxmcm9tV2lyZVR5cGU6ZnVuY3Rpb24odyl7cmV0dXJuISF3fSx0b1dpcmVUeXBlOmZ1bmN0aW9uKHcsSSl7cmV0dXJuIEk/ZjpifSxhcmdQYWNrQWR2YW5jZTpmdCxyZWFkVmFsdWVGcm9tUG9pbnRlcjpmdW5jdGlvbih3KXtyZXR1cm4gdGhpcy5mcm9tV2lyZVR5cGUocigpW3c+Pj4wXSl9LEViOm51bGx9KX12YXIgVG49W10sdXQ9W107ZnVuY3Rpb24gSW4ocyl7OTwocz4+Pj0wKSYmLS11dFtzKzFdPT0wJiYodXRbc109dm9pZCAwLFRuLnB1c2gocykpfXZhciBNZT1zPT57aWYoIXMpdGhyb3cgbmV3IG10KFwiQ2Fubm90IHVzZSBkZWxldGVkIHZhbC4gaGFuZGxlID0gXCIrcyk7cmV0dXJuIHV0W3NdfSxWZT1zPT57c3dpdGNoKHMpe2Nhc2Ugdm9pZCAwOnJldHVybiAyO2Nhc2UgbnVsbDpyZXR1cm4gNDtjYXNlITA6cmV0dXJuIDY7Y2FzZSExOnJldHVybiA4O2RlZmF1bHQ6bGV0IGM9VG4ucG9wKCl8fHV0Lmxlbmd0aDtyZXR1cm4gdXRbY109cyx1dFtjKzFdPTEsY319O2Z1bmN0aW9uIENuKHMpe3JldHVybiB0aGlzLmZyb21XaXJlVHlwZShhKClbcz4+PjI+Pj4wXSl9dmFyIFBjPXtuYW1lOlwiZW1zY3JpcHRlbjo6dmFsXCIsZnJvbVdpcmVUeXBlOnM9Pnt2YXIgYz1NZShzKTtyZXR1cm4gSW4ocyksY30sdG9XaXJlVHlwZToocyxjKT0+VmUoYyksYXJnUGFja0FkdmFuY2U6ZnQscmVhZFZhbHVlRnJvbVBvaW50ZXI6Q24sRWI6bnVsbH07ZnVuY3Rpb24gemMocyl7cmV0dXJuIHN0KHM+Pj4wLFBjKX12YXIgT2M9KHMsYyk9Pntzd2l0Y2goYyl7Y2FzZSA0OnJldHVybiBmdW5jdGlvbihmKXtyZXR1cm4gdGhpcy5mcm9tV2lyZVR5cGUoZCgpW2Y+Pj4yPj4+MF0pfTtjYXNlIDg6cmV0dXJuIGZ1bmN0aW9uKGYpe3JldHVybiB0aGlzLmZyb21XaXJlVHlwZShsKClbZj4+PjM+Pj4wXSl9O2RlZmF1bHQ6dGhyb3cgbmV3IFR5cGVFcnJvcihgaW52YWxpZCBmbG9hdCB3aWR0aCAoJHtjfSk6ICR7c31gKX19O2Z1bmN0aW9uIERjKHMsYyxmKXtmPj4+PTAsc3Qocz4+Pj0wLHtuYW1lOmM9UWUoYz4+PjApLGZyb21XaXJlVHlwZTpiPT5iLHRvV2lyZVR5cGU6KGIsdyk9PncsYXJnUGFja0FkdmFuY2U6ZnQscmVhZFZhbHVlRnJvbVBvaW50ZXI6T2MoYyxmKSxFYjpudWxsfSl9ZnVuY3Rpb24gQmMocyxjLGYsYix3KXtpZihzPj4+PTAsZj4+Pj0wLGM9UWUoYz4+PjApLHc9PT0tMSYmKHc9NDI5NDk2NzI5NSksdz1CPT5CLGI9PT0wKXt2YXIgST0zMi04KmY7dz1CPT5CPDxJPj4+SX12YXIgTz1jLmluY2x1ZGVzKFwidW5zaWduZWRcIik/ZnVuY3Rpb24oQixMKXtyZXR1cm4gTD4+PjB9OmZ1bmN0aW9uKEIsTCl7cmV0dXJuIEx9O3N0KHMse25hbWU6Yyxmcm9tV2lyZVR5cGU6dyx0b1dpcmVUeXBlOk8sYXJnUGFja0FkdmFuY2U6ZnQscmVhZFZhbHVlRnJvbVBvaW50ZXI6cGkoYyxmLGIhPT0wKSxFYjpudWxsfSl9ZnVuY3Rpb24gTWMocyxjLGYpe2Z1bmN0aW9uIGIoSSl7dmFyIE89YSgpW0k+Pj4yPj4+MF07cmV0dXJuIEk9YSgpW0krND4+PjI+Pj4wXSxuZXcgdyh0KCkuYnVmZmVyLEksTyl9dmFyIHc9W0ludDhBcnJheSxVaW50OEFycmF5LEludDE2QXJyYXksVWludDE2QXJyYXksSW50MzJBcnJheSxVaW50MzJBcnJheSxGbG9hdDMyQXJyYXksRmxvYXQ2NEFycmF5LEJpZ0ludDY0QXJyYXksQmlnVWludDY0QXJyYXldW2NdO3N0KHM+Pj49MCx7bmFtZTpmPVFlKGY+Pj4wKSxmcm9tV2lyZVR5cGU6YixhcmdQYWNrQWR2YW5jZTpmdCxyZWFkVmFsdWVGcm9tUG9pbnRlcjpifSx7VGI6ITB9KX1mdW5jdGlvbiBSYyhzLGMpe3M+Pj49MDt2YXIgZj0oYz1RZShjPj4+MCkpPT09XCJzdGQ6OnN0cmluZ1wiO3N0KHMse25hbWU6Yyxmcm9tV2lyZVR5cGU6ZnVuY3Rpb24oYil7dmFyIHc9YSgpW2I+Pj4yPj4+MF0sST1iKzQ7aWYoZilmb3IodmFyIE89SSxCPTA7Qjw9dzsrK0Ipe3ZhciBMPUkrQjtpZihCPT13fHxyKClbTD4+PjBdPT0wKXtpZihPPUNlKE8sTC1PKSxIPT09dm9pZCAwKXZhciBIPU87ZWxzZSBIKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDApLEgrPU87Tz1MKzF9fWVsc2V7Zm9yKEg9QXJyYXkodyksQj0wO0I8dzsrK0IpSFtCXT1TdHJpbmcuZnJvbUNoYXJDb2RlKHIoKVtJK0I+Pj4wXSk7SD1ILmpvaW4oXCJcIil9cmV0dXJuIEplKGIpLEh9LHRvV2lyZVR5cGU6ZnVuY3Rpb24oYix3KXt3IGluc3RhbmNlb2YgQXJyYXlCdWZmZXImJih3PW5ldyBVaW50OEFycmF5KHcpKTt2YXIgST10eXBlb2Ygdz09XCJzdHJpbmdcIjtpZighKEl8fHcgaW5zdGFuY2VvZiBVaW50OEFycmF5fHx3IGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXl8fHcgaW5zdGFuY2VvZiBJbnQ4QXJyYXkpKXRocm93IG5ldyBtdChcIkNhbm5vdCBwYXNzIG5vbi1zdHJpbmcgdG8gc3RkOjpzdHJpbmdcIik7dmFyIE89ZiYmST8kbih3KTp3Lmxlbmd0aCxCPWZyKDQrTysxKSxMPUIrNDtpZihhKClbQj4+PjI+Pj4wXT1PLGYmJkkpT3QodyxMLE8rMSk7ZWxzZSBpZihJKWZvcihJPTA7STxPOysrSSl7dmFyIEg9dy5jaGFyQ29kZUF0KEkpO2lmKDI1NTxIKXRocm93IEplKEwpLG5ldyBtdChcIlN0cmluZyBoYXMgVVRGLTE2IGNvZGUgdW5pdHMgdGhhdCBkbyBub3QgZml0IGluIDggYml0c1wiKTtyKClbTCtJPj4+MF09SH1lbHNlIGZvcihJPTA7STxPOysrSSlyKClbTCtJPj4+MF09d1tJXTtyZXR1cm4gYiE9PW51bGwmJmIucHVzaChKZSxCKSxCfSxhcmdQYWNrQWR2YW5jZTpmdCxyZWFkVmFsdWVGcm9tUG9pbnRlcjpDbixFYihiKXtKZShiKX19KX12YXIgbWk9dHlwZW9mIFRleHREZWNvZGVyPFwidVwiP25ldyBUZXh0RGVjb2RlcihcInV0Zi0xNmxlXCIpOnZvaWQgMCxVYz0ocyxjKT0+e2Zvcih2YXIgZj1zPj4xLGI9ZitjLzI7IShmPj1iKSYmbygpW2Y+Pj4wXTspKytmO2lmKDMyPChmPDw9MSktcyYmbWkpcmV0dXJuIG1pLmRlY29kZShyKCkuc2xpY2UocyxmKSk7Zm9yKGY9XCJcIixiPTA7IShiPj1jLzIpOysrYil7dmFyIHc9bigpW3MrMipiPj4+MT4+PjBdO2lmKHc9PTApYnJlYWs7Zis9U3RyaW5nLmZyb21DaGFyQ29kZSh3KX1yZXR1cm4gZn0sTmM9KHMsYyxmKT0+e2lmKGY/Pz0yMTQ3NDgzNjQ3LDI+ZilyZXR1cm4gMDt2YXIgYj1jO2Y9KGYtPTIpPDIqcy5sZW5ndGg/Zi8yOnMubGVuZ3RoO2Zvcih2YXIgdz0wO3c8ZjsrK3cpe3ZhciBJPXMuY2hhckNvZGVBdCh3KTtuKClbYz4+PjE+Pj4wXT1JLGMrPTJ9cmV0dXJuIG4oKVtjPj4+MT4+PjBdPTAsYy1ifSxWYz1zPT4yKnMubGVuZ3RoLFdjPShzLGMpPT57Zm9yKHZhciBmPTAsYj1cIlwiOyEoZj49Yy80KTspe3ZhciB3PWkoKVtzKzQqZj4+PjI+Pj4wXTtpZih3PT0wKWJyZWFrOysrZiw2NTUzNjw9dz8ody09NjU1MzYsYis9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5Nnx3Pj4xMCw1NjMyMHwxMDIzJncpKTpiKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHcpfXJldHVybiBifSxMYz0ocyxjLGYpPT57aWYoYz4+Pj0wLGY/Pz0yMTQ3NDgzNjQ3LDQ+ZilyZXR1cm4gMDt2YXIgYj1jO2Y9YitmLTQ7Zm9yKHZhciB3PTA7dzxzLmxlbmd0aDsrK3cpe3ZhciBJPXMuY2hhckNvZGVBdCh3KTtpZig1NTI5Njw9SSYmNTczNDM+PUkmJihJPTY1NTM2KygoMTAyMyZJKTw8MTApfDEwMjMmcy5jaGFyQ29kZUF0KCsrdykpLGkoKVtjPj4+Mj4+PjBdPUksKGMrPTQpKzQ+ZilicmVha31yZXR1cm4gaSgpW2M+Pj4yPj4+MF09MCxjLWJ9LEdjPXM9Pntmb3IodmFyIGM9MCxmPTA7ZjxzLmxlbmd0aDsrK2Ype3ZhciBiPXMuY2hhckNvZGVBdChmKTs1NTI5Njw9YiYmNTczNDM+PWImJisrZixjKz00fXJldHVybiBjfTtmdW5jdGlvbiBIYyhzLGMsZil7aWYocz4+Pj0wLGM+Pj49MCxmPVFlKGY+Pj49MCksYz09PTIpdmFyIGI9VWMsdz1OYyxJPVZjLE89Qj0+bygpW0I+Pj4xPj4+MF07ZWxzZSBjPT09NCYmKGI9V2Msdz1MYyxJPUdjLE89Qj0+YSgpW0I+Pj4yPj4+MF0pO3N0KHMse25hbWU6Zixmcm9tV2lyZVR5cGU6Qj0+e2Zvcih2YXIgTCxIPWEoKVtCPj4+Mj4+PjBdLFg9Qis0LGNlPTA7Y2U8PUg7KytjZSl7dmFyIGdlPUIrNCtjZSpjO2NlIT1IJiZPKGdlKSE9MHx8KFg9YihYLGdlLVgpLEw9PT12b2lkIDA/TD1YOihMKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDApLEwrPVgpLFg9Z2UrYyl9cmV0dXJuIEplKEIpLEx9LHRvV2lyZVR5cGU6KEIsTCk9PntpZih0eXBlb2YgTCE9XCJzdHJpbmdcIil0aHJvdyBuZXcgbXQoYENhbm5vdCBwYXNzIG5vbi1zdHJpbmcgdG8gQysrIHN0cmluZyB0eXBlICR7Zn1gKTt2YXIgSD1JKEwpLFg9ZnIoNCtIK2MpO3JldHVybiBhKClbWD4+PjI+Pj4wXT1IL2MsdyhMLFgrNCxIK2MpLEIhPT1udWxsJiZCLnB1c2goSmUsWCksWH0sYXJnUGFja0FkdmFuY2U6ZnQscmVhZFZhbHVlRnJvbVBvaW50ZXI6Q24sRWIoQil7SmUoQil9fSl9ZnVuY3Rpb24gRmMocyxjKXtzdChzPj4+PTAse1ViOiEwLG5hbWU6Yz1RZShjPj4+MCksYXJnUGFja0FkdmFuY2U6MCxmcm9tV2lyZVR5cGU6KCk9Pnt9LHRvV2lyZVR5cGU6KCk9Pnt9fSl9dmFyIHFjPSgpPT4xO2Z1bmN0aW9uIEtjKHMpe0RuKHM+Pj4wLCF5LDEsIV8sMTMxMDcyLCExKSxIbygpfXZhciBmaT1zPT57aWYoIXdlKXRyeXtpZihzKCksISgwPHd0KSl0cnl7Zz9ocihlZSk6dm4oZWUpfWNhdGNoKGMpe2MgaW5zdGFuY2VvZiB5bnx8Yz09XCJ1bndpbmRcInx8aygxLGMpfX1jYXRjaChjKXtjIGluc3RhbmNlb2YgeW58fGM9PVwidW53aW5kXCJ8fGsoMSxjKX19O2Z1bmN0aW9uIEFuKHMpe3M+Pj49MCx0eXBlb2YgQXRvbWljcy5vYz09XCJmdW5jdGlvblwiJiYoQXRvbWljcy5vYyhpKCkscz4+PjIscykudmFsdWUudGhlbihpcikscys9MTI4LEF0b21pY3Muc3RvcmUoaSgpLHM+Pj4yLDEpKX12YXIgaXI9KCk9Pnt2YXIgcz1NdCgpO3MmJihBbihzKSxmaShIaSkpfTtmdW5jdGlvbiBqYyhzLGMpeyhzPj4+PTApPT1jPj4+MD9zZXRUaW1lb3V0KGlyKTpnP3Bvc3RNZXNzYWdlKHt0YXJnZXRUaHJlYWQ6cyxjbWQ6XCJjaGVja01haWxib3hcIn0pOihzPVplW3NdKSYmcy5wb3N0TWVzc2FnZSh7Y21kOlwiY2hlY2tNYWlsYm94XCJ9KX12YXIga249W107ZnVuY3Rpb24gWWMocyxjLGYsYix3KXtmb3IoYz4+Pj0wLGIvPTIsa24ubGVuZ3RoPWIsZj13Pj4+MD4+PjMsdz0wO3c8Yjt3Kyspa25bd109cVtmKzIqd10/cVtmKzIqdysxXTpsKClbZisyKncrMT4+PjBdO3JldHVybihjP2JuW2NdOk5wW3NdKSguLi5rbil9ZnVuY3Rpb24gWmMocyl7cz4+Pj0wLGc/cG9zdE1lc3NhZ2Uoe2NtZDpcImNsZWFudXBUaHJlYWRcIix0aHJlYWQ6c30pOkdvKFplW3NdKX1mdW5jdGlvbiBRYyhzKXt9dmFyIGFyPShzLGMpPT57dmFyIGY9U25bc107aWYoZj09PXZvaWQgMCl0aHJvdyBzPVZpKHMpLGY9UWUocyksSmUocyksbmV3IG10KGAke2N9IGhhcyB1bmtub3duIHR5cGUgJHtmfWApO3JldHVybiBmfSxoaT0ocyxjLGYpPT57dmFyIGI9W107cmV0dXJuIHM9cy50b1dpcmVUeXBlKGIsZiksYi5sZW5ndGgmJihhKClbYz4+PjI+Pj4wXT1WZShiKSksc307ZnVuY3Rpb24gWGMocyxjLGYpe3JldHVybiBjPj4+PTAsZj4+Pj0wLHM9TWUocz4+PjApLGM9YXIoYyxcImVtdmFsOjphc1wiKSxoaShjLGYscyl9ZnVuY3Rpb24gSmMocyxjKXtyZXR1cm4gYz4+Pj0wLHM9TWUocz4+PjApLChjPWFyKGMsXCJlbXZhbDo6YXNcIikpLnRvV2lyZVR5cGUobnVsbCxzKX12YXIgc3I9cz0+e3RyeXtzKCl9Y2F0Y2goYyl7Y3QoYyl9fSxodD0wLFhlPW51bGwsZ2k9MCx1cj1bXSxiaT17fSx5aT17fSxlcD0wLEVuPW51bGwsdHA9W107ZnVuY3Rpb24gX2kocyl7cmV0dXJuIGZ1bmN0aW9uKGMpe2lmKCF3ZSl7aWYoaHQ9PT0wKXt2YXIgZj0hMSxiPSExO2MoKHc9MCk9PntpZighd2UmJihnaT13LGY9ITAsYikpe2h0PTIsc3IoKCk9PllpKFhlKSksdHlwZW9mIEJyb3dzZXI8XCJ1XCImJkJyb3dzZXIuTGIuU2ImJkJyb3dzZXIuTGIucmVzdW1lKCksdz0hMTt0cnl7dmFyIEk9ZnVuY3Rpb24oKXt2YXIgTD1pKClbWGUrOD4+PjI+Pj4wXTtyZXR1cm4gTD1aW3lpW0xdXSwtLXd0LEwoKX0oKX1jYXRjaChMKXtJPUwsdz0hMH12YXIgTz0hMTtpZighWGUpe3ZhciBCPUVuO0ImJihFbj1udWxsLCh3P0IucmVqZWN0OkIucmVzb2x2ZSkoSSksTz0hMCl9aWYodyYmIU8pdGhyb3cgSX19KSxiPSEwLGZ8fChodD0xLFhlPWZ1bmN0aW9uKCl7dmFyIHc9ZnIoNjU1NDgpLEk9dysxMjthKClbdz4+PjI+Pj4wXT1JLGEoKVt3KzQ+Pj4yPj4+MF09SSs2NTUzNixJPXVyWzBdO3ZhciBPPWJpW0ldO3JldHVybiBPPT09dm9pZCAwJiYoTz1lcCsrLGJpW0ldPU8seWlbT109SSksST1PLGkoKVt3Kzg+Pj4yPj4+MF09SSx3fSgpLHR5cGVvZiBCcm93c2VyPFwidVwiJiZCcm93c2VyLkxiLlNiJiZCcm93c2VyLkxiLnBhdXNlKCksc3IoKCk9PktpKFhlKSkpfWVsc2UgaHQ9PT0yPyhodD0wLHNyKFppKSxKZShYZSksWGU9bnVsbCx0cC5mb3JFYWNoKGZpKSk6Y3QoYGludmFsaWQgc3RhdGU6ICR7aHR9YCk7cmV0dXJuIGdpfX0oYz0+e3MoKS50aGVuKGMpfSl9ZnVuY3Rpb24gcnAocyl7cmV0dXJuIHM+Pj49MCxfaSgoKT0+KHM9TWUocykpLnRoZW4oVmUpKX12YXIgZHI9W107ZnVuY3Rpb24gbnAocyxjLGYsYil7cmV0dXJuIGY+Pj49MCxiPj4+PTAsKHM9ZHJbcz4+PjBdKShudWxsLGM9TWUoYz4+PjApLGYsYil9dmFyIG9wPXt9LGxyPXM9Pnt2YXIgYz1vcFtzXTtyZXR1cm4gYz09PXZvaWQgMD9RZShzKTpjfTtmdW5jdGlvbiBpcChzLGMsZixiLHcpe3JldHVybiBmPj4+PTAsYj4+Pj0wLHc+Pj49MCwocz1kcltzPj4+MF0pKGM9TWUoYz4+PjApLGNbZj1scihmKV0sYix3KX12YXIgd2k9KCk9PnR5cGVvZiBnbG9iYWxUaGlzPT1cIm9iamVjdFwiP2dsb2JhbFRoaXM6RnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO2Z1bmN0aW9uIGFwKHMpe3JldHVybihzPj4+PTApPT0wP1ZlKHdpKCkpOihzPWxyKHMpLFZlKHdpKClbc10pKX12YXIgc3A9cz0+e3ZhciBjPWRyLmxlbmd0aDtyZXR1cm4gZHIucHVzaChzKSxjfSx1cD0ocyxjKT0+e2Zvcih2YXIgZj1BcnJheShzKSxiPTA7YjxzOysrYilmW2JdPWFyKGEoKVtjKzQqYj4+PjI+Pj4wXSxcInBhcmFtZXRlciBcIitiKTtyZXR1cm4gZn0sdmk9KHMsYyk9Pk9iamVjdC5kZWZpbmVQcm9wZXJ0eShjLFwibmFtZVwiLHt2YWx1ZTpzfSk7ZnVuY3Rpb24gZHAocyxjLGYpe3ZhciBiPShjPXVwKHMsYz4+PjApKS5zaGlmdCgpO3MtLTt2YXIgdz1gcmV0dXJuIGZ1bmN0aW9uIChvYmosIGZ1bmMsIGRlc3RydWN0b3JzUmVmLCBhcmdzKSB7XG5gLEk9MCxPPVtdO2Y9PT0wJiZPLnB1c2goXCJvYmpcIik7Zm9yKHZhciBCPVtcInJldFR5cGVcIl0sTD1bYl0sSD0wO0g8czsrK0gpTy5wdXNoKFwiYXJnXCIrSCksQi5wdXNoKFwiYXJnVHlwZVwiK0gpLEwucHVzaChjW0hdKSx3Kz1gICB2YXIgYXJnJHtIfSA9IGFyZ1R5cGUke0h9LnJlYWRWYWx1ZUZyb21Qb2ludGVyKGFyZ3Mke0k/XCIrXCIrSTpcIlwifSk7XG5gLEkrPWNbSF0uYXJnUGFja0FkdmFuY2U7cmV0dXJuIHcrPWAgIHZhciBydiA9ICR7Zj09PTE/XCJuZXcgZnVuY1wiOlwiZnVuYy5jYWxsXCJ9KCR7Ty5qb2luKFwiLCBcIil9KTtcbmAsYi5VYnx8KEIucHVzaChcImVtdmFsX3JldHVyblZhbHVlXCIpLEwucHVzaChoaSksdys9YCAgcmV0dXJuIGVtdmFsX3JldHVyblZhbHVlKHJldFR5cGUsIGRlc3RydWN0b3JzUmVmLCBydik7XG5gKSxCLnB1c2godytgfTtcbmApLHM9ZnVuY3Rpb24oWCl7dmFyIGNlPUZ1bmN0aW9uO2lmKCEoY2UgaW5zdGFuY2VvZiBGdW5jdGlvbikpdGhyb3cgbmV3IFR5cGVFcnJvcihgbmV3XyBjYWxsZWQgd2l0aCBjb25zdHJ1Y3RvciB0eXBlICR7dHlwZW9mIGNlfSB3aGljaCBpcyBub3QgYSBmdW5jdGlvbmApO3ZhciBnZT12aShjZS5uYW1lfHxcInVua25vd25GdW5jdGlvbk5hbWVcIixmdW5jdGlvbigpe30pO3JldHVybiBnZS5wcm90b3R5cGU9Y2UucHJvdG90eXBlLGdlPW5ldyBnZSwoWD1jZS5hcHBseShnZSxYKSlpbnN0YW5jZW9mIE9iamVjdD9YOmdlfShCKSguLi5MKSxmPWBtZXRob2RDYWxsZXI8KCR7Yy5tYXAoWD0+WC5uYW1lKS5qb2luKFwiLCBcIil9KSA9PiAke2IubmFtZX0+YCxzcCh2aShmLHMpKX1mdW5jdGlvbiBscChzKXtyZXR1cm4gcz1scihzPj4+MCksVmUodVtzXSl9ZnVuY3Rpb24gY3AocyxjKXtyZXR1cm4gYz4+Pj0wLHM9TWUocz4+PjApLGM9TWUoYyksVmUoc1tjXSl9ZnVuY3Rpb24gcHAocyl7OTwocz4+Pj0wKSYmKHV0W3MrMV0rPTEpfWZ1bmN0aW9uIG1wKCl7cmV0dXJuIFZlKFtdKX1mdW5jdGlvbiBmcChzKXtzPU1lKHM+Pj4wKTtmb3IodmFyIGM9QXJyYXkocy5sZW5ndGgpLGY9MDtmPHMubGVuZ3RoO2YrKyljW2ZdPXNbZl07cmV0dXJuIFZlKGMpfWZ1bmN0aW9uIGhwKHMpe3JldHVybiBWZShscihzPj4+MCkpfWZ1bmN0aW9uIGdwKCl7cmV0dXJuIFZlKHt9KX1mdW5jdGlvbiBicChzKXtmb3IodmFyIGM9TWUocz4+Pj0wKTtjLmxlbmd0aDspe3ZhciBmPWMucG9wKCk7Yy5wb3AoKShmKX1JbihzKX1mdW5jdGlvbiB5cChzLGMsZil7Yz4+Pj0wLGY+Pj49MCxzPU1lKHM+Pj4wKSxjPU1lKGMpLGY9TWUoZiksc1tjXT1mfWZ1bmN0aW9uIF9wKHMsYyl7cmV0dXJuIGM+Pj49MCxzPShzPWFyKHM+Pj4wLFwiX2VtdmFsX3Rha2VfdmFsdWVcIikpLnJlYWRWYWx1ZUZyb21Qb2ludGVyKGMpLFZlKHMpfWZ1bmN0aW9uIHdwKHMsYyl7cz0tOTAwNzE5OTI1NDc0MDk5Mj5zfHw5MDA3MTk5MjU0NzQwOTkyPHM/TmFOOk51bWJlcihzKSxjPj4+PTAscz1uZXcgRGF0ZSgxZTMqcyksaSgpW2M+Pj4yPj4+MF09cy5nZXRVVENTZWNvbmRzKCksaSgpW2MrND4+PjI+Pj4wXT1zLmdldFVUQ01pbnV0ZXMoKSxpKClbYys4Pj4+Mj4+PjBdPXMuZ2V0VVRDSG91cnMoKSxpKClbYysxMj4+PjI+Pj4wXT1zLmdldFVUQ0RhdGUoKSxpKClbYysxNj4+PjI+Pj4wXT1zLmdldFVUQ01vbnRoKCksaSgpW2MrMjA+Pj4yPj4+MF09cy5nZXRVVENGdWxsWWVhcigpLTE5MDAsaSgpW2MrMjQ+Pj4yPj4+MF09cy5nZXRVVENEYXkoKSxzPShzLmdldFRpbWUoKS1EYXRlLlVUQyhzLmdldFVUQ0Z1bGxZZWFyKCksMCwxLDAsMCwwLDApKS84NjRlNXwwLGkoKVtjKzI4Pj4+Mj4+PjBdPXN9dmFyIER0PXM9PnMlND09MCYmKHMlMTAwIT0wfHxzJTQwMD09MCksJGk9WzAsMzEsNjAsOTEsMTIxLDE1MiwxODIsMjEzLDI0NCwyNzQsMzA1LDMzNV0seGk9WzAsMzEsNTksOTAsMTIwLDE1MSwxODEsMjEyLDI0MywyNzMsMzA0LDMzNF07ZnVuY3Rpb24gdnAocyxjKXtzPS05MDA3MTk5MjU0NzQwOTkyPnN8fDkwMDcxOTkyNTQ3NDA5OTI8cz9OYU46TnVtYmVyKHMpLGM+Pj49MCxzPW5ldyBEYXRlKDFlMypzKSxpKClbYz4+PjI+Pj4wXT1zLmdldFNlY29uZHMoKSxpKClbYys0Pj4+Mj4+PjBdPXMuZ2V0TWludXRlcygpLGkoKVtjKzg+Pj4yPj4+MF09cy5nZXRIb3VycygpLGkoKVtjKzEyPj4+Mj4+PjBdPXMuZ2V0RGF0ZSgpLGkoKVtjKzE2Pj4+Mj4+PjBdPXMuZ2V0TW9udGgoKSxpKClbYysyMD4+PjI+Pj4wXT1zLmdldEZ1bGxZZWFyKCktMTkwMCxpKClbYysyND4+PjI+Pj4wXT1zLmdldERheSgpO3ZhciBmPShEdChzLmdldEZ1bGxZZWFyKCkpPyRpOnhpKVtzLmdldE1vbnRoKCldK3MuZ2V0RGF0ZSgpLTF8MDtpKClbYysyOD4+PjI+Pj4wXT1mLGkoKVtjKzM2Pj4+Mj4+PjBdPS02MCpzLmdldFRpbWV6b25lT2Zmc2V0KCksZj1uZXcgRGF0ZShzLmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciBiPW5ldyBEYXRlKHMuZ2V0RnVsbFllYXIoKSwwLDEpLmdldFRpbWV6b25lT2Zmc2V0KCk7cz0wfChmIT1iJiZzLmdldFRpbWV6b25lT2Zmc2V0KCk9PU1hdGgubWluKGIsZikpLGkoKVtjKzMyPj4+Mj4+PjBdPXN9ZnVuY3Rpb24gJHAocyl7cz4+Pj0wO3ZhciBjPW5ldyBEYXRlKGkoKVtzKzIwPj4+Mj4+PjBdKzE5MDAsaSgpW3MrMTY+Pj4yPj4+MF0saSgpW3MrMTI+Pj4yPj4+MF0saSgpW3MrOD4+PjI+Pj4wXSxpKClbcys0Pj4+Mj4+PjBdLGkoKVtzPj4+Mj4+PjBdLDApLGY9aSgpW3MrMzI+Pj4yPj4+MF0sYj1jLmdldFRpbWV6b25lT2Zmc2V0KCksdz1uZXcgRGF0ZShjLmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpLEk9bmV3IERhdGUoYy5nZXRGdWxsWWVhcigpLDAsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKSxPPU1hdGgubWluKEksdyk7cmV0dXJuIDA+Zj9pKClbcyszMj4+PjI+Pj4wXT0rKHchPUkmJk89PWIpOjA8ZiE9KE89PWIpJiYodz1NYXRoLm1heChJLHcpLGMuc2V0VGltZShjLmdldFRpbWUoKSs2ZTQqKCgwPGY/Tzp3KS1iKSkpLGkoKVtzKzI0Pj4+Mj4+PjBdPWMuZ2V0RGF5KCksZj0oRHQoYy5nZXRGdWxsWWVhcigpKT8kaTp4aSlbYy5nZXRNb250aCgpXStjLmdldERhdGUoKS0xfDAsaSgpW3MrMjg+Pj4yPj4+MF09ZixpKClbcz4+PjI+Pj4wXT1jLmdldFNlY29uZHMoKSxpKClbcys0Pj4+Mj4+PjBdPWMuZ2V0TWludXRlcygpLGkoKVtzKzg+Pj4yPj4+MF09Yy5nZXRIb3VycygpLGkoKVtzKzEyPj4+Mj4+PjBdPWMuZ2V0RGF0ZSgpLGkoKVtzKzE2Pj4+Mj4+PjBdPWMuZ2V0TW9udGgoKSxpKClbcysyMD4+PjI+Pj4wXT1jLmdldFllYXIoKSxzPWMuZ2V0VGltZSgpLEJpZ0ludChpc05hTihzKT8tMTpzLzFlMyl9ZnVuY3Rpb24gU2kocyxjLGYsYix3LEksTyl7cmV0dXJuIGc/eGUoMTYsMSxzLGMsZixiLHcsSSxPKTotNTJ9ZnVuY3Rpb24gVGkocyxjLGYsYix3LEkpe2lmKGcpcmV0dXJuIHhlKDE3LDEscyxjLGYsYix3LEkpfWZ1bmN0aW9uIHhwKHMsYyxmLGIpe3M+Pj49MCxjPj4+PTAsZj4+Pj0wLGI+Pj49MDt2YXIgdz1uZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCksST1uZXcgRGF0ZSh3LDAsMSksTz1uZXcgRGF0ZSh3LDYsMSk7dz1JLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIEI9Ty5nZXRUaW1lem9uZU9mZnNldCgpLEw9TWF0aC5tYXgodyxCKTthKClbcz4+PjI+Pj4wXT02MCpMLGkoKVtjPj4+Mj4+PjBdPSsodyE9QiksST0ocz1IPT5ILnRvTG9jYWxlVGltZVN0cmluZyh2b2lkIDAse2hvdXIxMjohMSx0aW1lWm9uZU5hbWU6XCJzaG9ydFwifSkuc3BsaXQoXCIgXCIpWzFdKShJKSxPPXMoTyksQjx3PyhPdChJLGYsMTcpLE90KE8sYiwxNykpOihPdChJLGIsMTcpLE90KE8sZiwxNykpfXZhciBQbj1bXSxJaT0ocyxjKT0+e1BuLmxlbmd0aD0wO2Zvcih2YXIgZjtmPXIoKVtzKys+Pj4wXTspe3ZhciBiPWYhPTEwNTtjKz0oYiY9ZiE9MTEyKSYmYyU4PzQ6MCxQbi5wdXNoKGY9PTExMj9hKClbYz4+PjI+Pj4wXTpmPT0xMDY/cVtjPj4+M106Zj09MTA1P2koKVtjPj4+Mj4+PjBdOmwoKVtjPj4+Mz4+PjBdKSxjKz1iPzg6NH1yZXR1cm4gUG59O2Z1bmN0aW9uIFNwKHMsYyxmKXtyZXR1cm4gcz4+Pj0wLGM9SWkoYz4+PjAsZj4+PjApLGJuW3NdKC4uLmMpfWZ1bmN0aW9uIFRwKHMsYyxmKXtyZXR1cm4gcz4+Pj0wLGM9SWkoYz4+PjAsZj4+PjApLGJuW3NdKC4uLmMpfXZhciBJcD0oKT0+e30sQ3A9KCk9PkRhdGUubm93KCk7ZnVuY3Rpb24gQXAocyxjKXtyZXR1cm4gaihDZShzPj4+MCxjPj4+MCkpfXZhciBDaSxrcD0oKT0+e3Rocm93IHd0Kz0xLFwidW53aW5kXCJ9O2Z1bmN0aW9uIEVwKCl7cmV0dXJuIDQyOTQ5MDE3NjB9Q2k9KCk9PnBlcmZvcm1hbmNlLnRpbWVPcmlnaW4rcGVyZm9ybWFuY2Uubm93KCk7dmFyIFBwPSgpPT5uYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeTtmdW5jdGlvbiB6cCgpe3JldHVybiBjdChcIkNhbm5vdCB1c2UgZW1zY3JpcHRlbl9wY19nZXRfZnVuY3Rpb24gd2l0aG91dCAtc1VTRV9PRkZTRVRfQ09OVkVSVEVSXCIpLDB9ZnVuY3Rpb24gT3Aocyl7cz4+Pj0wO3ZhciBjPXIoKS5sZW5ndGg7aWYoczw9Y3x8NDI5NDkwMTc2MDxzKXJldHVybiExO2Zvcih2YXIgZj0xOzQ+PWY7Zio9Mil7dmFyIGI9YyooMSsuMi9mKTtiPU1hdGgubWluKGIscysxMDA2NjMyOTYpO3ZhciB3PU1hdGg7Yj1NYXRoLm1heChzLGIpO2U6e3c9KHcubWluLmNhbGwodyw0Mjk0OTAxNzYwLGIrKDY1NTM2LWIlNjU1MzYpJTY1NTM2KS1zZS5idWZmZXIuYnl0ZUxlbmd0aCs2NTUzNSkvNjU1MzY7dHJ5e3NlLmdyb3codykseWUoKTt2YXIgST0xO2JyZWFrIGV9Y2F0Y2h7fUk9dm9pZCAwfWlmKEkpcmV0dXJuITB9cmV0dXJuITF9dmFyIGNyPSgpPT4oY3QoXCJDYW5ub3QgdXNlIGNvbnZlcnRGcmFtZVRvUEMgKG5lZWRlZCBieSBfX2J1aWx0aW5fcmV0dXJuX2FkZHJlc3MpIHdpdGhvdXQgLXNVU0VfT0ZGU0VUX0NPTlZFUlRFUlwiKSwwKSxCdD17fSxBaT1zPT57cy5mb3JFYWNoKGM9Pnt2YXIgZj1jcigpO2YmJihCdFtmXT1jKX0pfTtmdW5jdGlvbiBEcCgpe3ZhciBzPUVycm9yKCkuc3RhY2sudG9TdHJpbmcoKS5zcGxpdChgXG5gKTtyZXR1cm4gc1swXT09XCJFcnJvclwiJiZzLnNoaWZ0KCksQWkocyksQnQuUWI9Y3IoKSxCdC5mYz1zLEJ0LlFifWZ1bmN0aW9uIEJwKHMsYyxmKXtpZihzPj4+PTAsYz4+Pj0wLEJ0LlFiPT1zKXZhciBiPUJ0LmZjO2Vsc2UoYj1FcnJvcigpLnN0YWNrLnRvU3RyaW5nKCkuc3BsaXQoYFxuYCkpWzBdPT1cIkVycm9yXCImJmIuc2hpZnQoKSxBaShiKTtmb3IodmFyIHc9MztiW3ddJiZjcigpIT1zOykrK3c7Zm9yKHM9MDtzPGYmJmJbcyt3XTsrK3MpaSgpW2MrNCpzPj4+Mj4+PjBdPWNyKCk7cmV0dXJuIHN9dmFyIHpuLE9uPXt9LGtpPSgpPT57aWYoIXpuKXt2YXIgcyxjPXtVU0VSOlwid2ViX3VzZXJcIixMT0dOQU1FOlwid2ViX3VzZXJcIixQQVRIOlwiL1wiLFBXRDpcIi9cIixIT01FOlwiL2hvbWUvd2ViX3VzZXJcIixMQU5HOih0eXBlb2YgbmF2aWdhdG9yPT1cIm9iamVjdFwiJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdfHxcIkNcIikucmVwbGFjZShcIi1cIixcIl9cIikrXCIuVVRGLThcIixfOkF8fFwiLi90aGlzLnByb2dyYW1cIn07Zm9yKHMgaW4gT24pT25bc109PT12b2lkIDA/ZGVsZXRlIGNbc106Y1tzXT1PbltzXTt2YXIgZj1bXTtmb3IocyBpbiBjKWYucHVzaChgJHtzfT0ke2Nbc119YCk7em49Zn1yZXR1cm4gem59O2Z1bmN0aW9uIEVpKHMsYyl7aWYoZylyZXR1cm4geGUoMTgsMSxzLGMpO3M+Pj49MCxjPj4+PTA7dmFyIGY9MDtyZXR1cm4ga2koKS5mb3JFYWNoKChiLHcpPT57dmFyIEk9YytmO2Zvcih3PWEoKVtzKzQqdz4+PjI+Pj4wXT1JLEk9MDtJPGIubGVuZ3RoOysrSSl0KClbdysrPj4+MF09Yi5jaGFyQ29kZUF0KEkpO3QoKVt3Pj4+MF09MCxmKz1iLmxlbmd0aCsxfSksMH1mdW5jdGlvbiBQaShzLGMpe2lmKGcpcmV0dXJuIHhlKDE5LDEscyxjKTtzPj4+PTAsYz4+Pj0wO3ZhciBmPWtpKCk7YSgpW3M+Pj4yPj4+MF09Zi5sZW5ndGg7dmFyIGI9MDtyZXR1cm4gZi5mb3JFYWNoKHc9PmIrPXcubGVuZ3RoKzEpLGEoKVtjPj4+Mj4+PjBdPWIsMH1mdW5jdGlvbiB6aShzKXtyZXR1cm4gZz94ZSgyMCwxLHMpOjUyfWZ1bmN0aW9uIE9pKHMsYyxmLGIpe3JldHVybiBnP3hlKDIxLDEscyxjLGYsYik6NTJ9ZnVuY3Rpb24gRGkocyxjLGYsYil7cmV0dXJuIGc/eGUoMjIsMSxzLGMsZixiKTo3MH12YXIgTXA9W251bGwsW10sW11dO2Z1bmN0aW9uIEJpKHMsYyxmLGIpe2lmKGcpcmV0dXJuIHhlKDIzLDEscyxjLGYsYik7Yz4+Pj0wLGY+Pj49MCxiPj4+PTA7Zm9yKHZhciB3PTAsST0wO0k8ZjtJKyspe3ZhciBPPWEoKVtjPj4+Mj4+PjBdLEI9YSgpW2MrND4+PjI+Pj4wXTtjKz04O2Zvcih2YXIgTD0wO0w8QjtMKyspe3ZhciBIPXIoKVtPK0w+Pj4wXSxYPU1wW3NdO0g9PT0wfHxIPT09MTA/KChzPT09MT9LOmopKFpvKFgsMCkpLFgubGVuZ3RoPTApOlgucHVzaChIKX13Kz1CfXJldHVybiBhKClbYj4+PjI+Pj4wXT13LDB9dmFyIE1pPVszMSwyOSwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV0sUmk9WzMxLDI4LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXSxScD0ocyxjKT0+e3QoKS5zZXQocyxjPj4+MCl9O2Z1bmN0aW9uIFVpKHMsYyxmLGIpe2Z1bmN0aW9uIHcoeixkZSxUZSl7Zm9yKHo9dHlwZW9mIHo9PVwibnVtYmVyXCI/ei50b1N0cmluZygpOnp8fFwiXCI7ei5sZW5ndGg8ZGU7KXo9VGVbMF0rejtyZXR1cm4gen1mdW5jdGlvbiBJKHosZGUpe3JldHVybiB3KHosZGUsXCIwXCIpfWZ1bmN0aW9uIE8oeixkZSl7ZnVuY3Rpb24gVGUoWGkpe3JldHVybiAwPlhpPy0xOjA8WGk/MTowfXZhciAkdDtyZXR1cm4oJHQ9VGUoei5nZXRGdWxsWWVhcigpLWRlLmdldEZ1bGxZZWFyKCkpKT09PTAmJigkdD1UZSh6LmdldE1vbnRoKCktZGUuZ2V0TW9udGgoKSkpPT09MCYmKCR0PVRlKHouZ2V0RGF0ZSgpLWRlLmdldERhdGUoKSkpLCR0fWZ1bmN0aW9uIEIoeil7c3dpdGNoKHouZ2V0RGF5KCkpe2Nhc2UgMDpyZXR1cm4gbmV3IERhdGUoei5nZXRGdWxsWWVhcigpLTEsMTEsMjkpO2Nhc2UgMTpyZXR1cm4gejtjYXNlIDI6cmV0dXJuIG5ldyBEYXRlKHouZ2V0RnVsbFllYXIoKSwwLDMpO2Nhc2UgMzpyZXR1cm4gbmV3IERhdGUoei5nZXRGdWxsWWVhcigpLDAsMik7Y2FzZSA0OnJldHVybiBuZXcgRGF0ZSh6LmdldEZ1bGxZZWFyKCksMCwxKTtjYXNlIDU6cmV0dXJuIG5ldyBEYXRlKHouZ2V0RnVsbFllYXIoKS0xLDExLDMxKTtjYXNlIDY6cmV0dXJuIG5ldyBEYXRlKHouZ2V0RnVsbFllYXIoKS0xLDExLDMwKX19ZnVuY3Rpb24gTCh6KXt2YXIgZGU9ei5DYjtmb3Ioej1uZXcgRGF0ZShuZXcgRGF0ZSh6LkRiKzE5MDAsMCwxKS5nZXRUaW1lKCkpOzA8ZGU7KXt2YXIgVGU9ei5nZXRNb250aCgpLCR0PShEdCh6LmdldEZ1bGxZZWFyKCkpP01pOlJpKVtUZV07aWYoIShkZT4kdC16LmdldERhdGUoKSkpe3ouc2V0RGF0ZSh6LmdldERhdGUoKStkZSk7YnJlYWt9ZGUtPSR0LXouZ2V0RGF0ZSgpKzEsei5zZXREYXRlKDEpLDExPlRlP3ouc2V0TW9udGgoVGUrMSk6KHouc2V0TW9udGgoMCksei5zZXRGdWxsWWVhcih6LmdldEZ1bGxZZWFyKCkrMSkpfXJldHVybiBUZT1uZXcgRGF0ZSh6LmdldEZ1bGxZZWFyKCkrMSwwLDQpLGRlPUIobmV3IERhdGUoei5nZXRGdWxsWWVhcigpLDAsNCkpLFRlPUIoVGUpLDA+PU8oZGUseik/MD49TyhUZSx6KT96LmdldEZ1bGxZZWFyKCkrMTp6LmdldEZ1bGxZZWFyKCk6ei5nZXRGdWxsWWVhcigpLTF9cz4+Pj0wLGM+Pj49MCxmPj4+PTAsYj4+Pj0wO3ZhciBIPWEoKVtiKzQwPj4+Mj4+PjBdO2Zvcih2YXIgWCBpbiBiPXtsYzppKClbYj4+PjI+Pj4wXSxrYzppKClbYis0Pj4+Mj4+PjBdLEliOmkoKVtiKzg+Pj4yPj4+MF0sTWI6aSgpW2IrMTI+Pj4yPj4+MF0sSmI6aSgpW2IrMTY+Pj4yPj4+MF0sRGI6aSgpW2IrMjA+Pj4yPj4+MF0sdmI6aSgpW2IrMjQ+Pj4yPj4+MF0sQ2I6aSgpW2IrMjg+Pj4yPj4+MF0sc2M6aSgpW2IrMzI+Pj4yPj4+MF0samM6aSgpW2IrMzY+Pj4yPj4+MF0sbWM6SD9DZShIKTpcIlwifSxmPUNlKGYpLEg9e1wiJWNcIjpcIiVhICViICVkICVIOiVNOiVTICVZXCIsXCIlRFwiOlwiJW0vJWQvJXlcIixcIiVGXCI6XCIlWS0lbS0lZFwiLFwiJWhcIjpcIiViXCIsXCIlclwiOlwiJUk6JU06JVMgJXBcIixcIiVSXCI6XCIlSDolTVwiLFwiJVRcIjpcIiVIOiVNOiVTXCIsXCIleFwiOlwiJW0vJWQvJXlcIixcIiVYXCI6XCIlSDolTTolU1wiLFwiJUVjXCI6XCIlY1wiLFwiJUVDXCI6XCIlQ1wiLFwiJUV4XCI6XCIlbS8lZC8leVwiLFwiJUVYXCI6XCIlSDolTTolU1wiLFwiJUV5XCI6XCIleVwiLFwiJUVZXCI6XCIlWVwiLFwiJU9kXCI6XCIlZFwiLFwiJU9lXCI6XCIlZVwiLFwiJU9IXCI6XCIlSFwiLFwiJU9JXCI6XCIlSVwiLFwiJU9tXCI6XCIlbVwiLFwiJU9NXCI6XCIlTVwiLFwiJU9TXCI6XCIlU1wiLFwiJU91XCI6XCIldVwiLFwiJU9VXCI6XCIlVVwiLFwiJU9WXCI6XCIlVlwiLFwiJU93XCI6XCIld1wiLFwiJU9XXCI6XCIlV1wiLFwiJU95XCI6XCIleVwifSlmPWYucmVwbGFjZShuZXcgUmVnRXhwKFgsXCJnXCIpLEhbWF0pO3ZhciBjZT1cIlN1bmRheSBNb25kYXkgVHVlc2RheSBXZWRuZXNkYXkgVGh1cnNkYXkgRnJpZGF5IFNhdHVyZGF5XCIuc3BsaXQoXCIgXCIpLGdlPVwiSmFudWFyeSBGZWJydWFyeSBNYXJjaCBBcHJpbCBNYXkgSnVuZSBKdWx5IEF1Z3VzdCBTZXB0ZW1iZXIgT2N0b2JlciBOb3ZlbWJlciBEZWNlbWJlclwiLnNwbGl0KFwiIFwiKTtmb3IoWCBpbiBIPXtcIiVhXCI6ej0+Y2Vbei52Yl0uc3Vic3RyaW5nKDAsMyksXCIlQVwiOno9PmNlW3oudmJdLFwiJWJcIjp6PT5nZVt6LkpiXS5zdWJzdHJpbmcoMCwzKSxcIiVCXCI6ej0+Z2Vbei5KYl0sXCIlQ1wiOno9PkkoKHouRGIrMTkwMCkvMTAwfDAsMiksXCIlZFwiOno9Pkkoei5NYiwyKSxcIiVlXCI6ej0+dyh6Lk1iLDIsXCIgXCIpLFwiJWdcIjp6PT5MKHopLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpLFwiJUdcIjpMLFwiJUhcIjp6PT5JKHouSWIsMiksXCIlSVwiOno9Pigoej16LkliKT09MD96PTEyOjEyPHomJih6LT0xMiksSSh6LDIpKSxcIiVqXCI6ej0+e2Zvcih2YXIgZGU9MCxUZT0wO1RlPD16LkpiLTE7ZGUrPShEdCh6LkRiKzE5MDApP01pOlJpKVtUZSsrXSk7cmV0dXJuIEkoei5NYitkZSwzKX0sXCIlbVwiOno9Pkkoei5KYisxLDIpLFwiJU1cIjp6PT5JKHoua2MsMiksXCIlblwiOigpPT5gXG5gLFwiJXBcIjp6PT4wPD16LkliJiYxMj56LkliP1wiQU1cIjpcIlBNXCIsXCIlU1wiOno9Pkkoei5sYywyKSxcIiV0XCI6KCk9PlwiXHRcIixcIiV1XCI6ej0+ei52Ynx8NyxcIiVVXCI6ej0+SShNYXRoLmZsb29yKCh6LkNiKzctei52YikvNyksMiksXCIlVlwiOno9Pnt2YXIgZGU9TWF0aC5mbG9vcigoei5DYis3LSh6LnZiKzYpJTcpLzcpO2lmKDI+PSh6LnZiKzM3MS16LkNiLTIpJTcmJmRlKyssZGUpZGU9PTUzJiYoKFRlPSh6LnZiKzM3MS16LkNiKSU3KT09NHx8VGU9PTMmJkR0KHouRGIpfHwoZGU9MSkpO2Vsc2V7ZGU9NTI7dmFyIFRlPSh6LnZiKzctei5DYi0xKSU3OyhUZT09NHx8VGU9PTUmJkR0KHouRGIlNDAwLTEpKSYmZGUrK31yZXR1cm4gSShkZSwyKX0sXCIld1wiOno9PnoudmIsXCIlV1wiOno9PkkoTWF0aC5mbG9vcigoei5DYis3LSh6LnZiKzYpJTcpLzcpLDIpLFwiJXlcIjp6PT4oei5EYisxOTAwKS50b1N0cmluZygpLnN1YnN0cmluZygyKSxcIiVZXCI6ej0+ei5EYisxOTAwLFwiJXpcIjp6PT57dmFyIGRlPTA8PSh6PXouamMpO3JldHVybiB6PU1hdGguYWJzKHopLzYwLChkZT9cIitcIjpcIi1cIikrKFwiMDAwMFwiKyh6LzYwKjEwMCt6JTYwKSkuc2xpY2UoLTQpfSxcIiVaXCI6ej0+ei5tYyxcIiUlXCI6KCk9PlwiJVwifSxmPWYucmVwbGFjZSgvJSUvZyxcIlxcMFxcMFwiKSxIKWYuaW5jbHVkZXMoWCkmJihmPWYucmVwbGFjZShuZXcgUmVnRXhwKFgsXCJnXCIpLEhbWF0oYikpKTtyZXR1cm4gWD1mdW5jdGlvbih6KXt2YXIgZGU9QXJyYXkoJG4oeikrMSk7cmV0dXJuIEpvKHosZGUsMCxkZS5sZW5ndGgpLGRlfShmPWYucmVwbGFjZSgvXFwwXFwwL2csXCIlXCIpKSxYLmxlbmd0aD5jPzA6KFJwKFgscyksWC5sZW5ndGgtMSl9ZnVuY3Rpb24gVXAocyxjLGYsYil7cmV0dXJuIFVpKHM+Pj4wLGM+Pj4wLGY+Pj4wLGI+Pj4wKX1nfHxmdW5jdGlvbigpe2Zvcih2YXIgcz11Lm51bVRocmVhZHMtMTtzLS07KXFvKCk7WWUudW5zaGlmdCgoKT0+e0d0KyssZnVuY3Rpb24oYyl7Zz9jKCk6UHJvbWlzZS5hbGwocHQubWFwKEZvKSkudGhlbihjKX0oKCk9PkRvKCkpfSl9KCk7Zm9yKHZhciBOaT1BcnJheSgyNTYpLHByPTA7MjU2PnByOysrcHIpTmlbcHJdPVN0cmluZy5mcm9tQ2hhckNvZGUocHIpO2NpPU5pLG10PXUuQmluZGluZ0Vycm9yPWNsYXNzIGV4dGVuZHMgRXJyb3J7Y29uc3RydWN0b3Iocyl7c3VwZXIocyksdGhpcy5uYW1lPVwiQmluZGluZ0Vycm9yXCJ9fSx1LkludGVybmFsRXJyb3I9Y2xhc3MgZXh0ZW5kcyBFcnJvcntjb25zdHJ1Y3RvcihzKXtzdXBlcihzKSx0aGlzLm5hbWU9XCJJbnRlcm5hbEVycm9yXCJ9fSx1dC5wdXNoKDAsMSx2b2lkIDAsMSxudWxsLDEsITAsMSwhMSwxKSx1LmNvdW50X2VtdmFsX2hhbmRsZXM9KCk9PnV0Lmxlbmd0aC8yLTUtVG4ubGVuZ3RoO3ZhciBOcD1bd24sV28sS28sUW8sWG8sZWksdGkscmksbmksb2ksaWksYWksc2ksdWksZGksbGksU2ksVGksRWksUGksemksT2ksRGksQmldLFo9ZnVuY3Rpb24oKXtmdW5jdGlvbiBzKGYsYil7cmV0dXJuIFo9Zi5leHBvcnRzLFo9ZnVuY3Rpb24oKXt2YXIgdz1aLEk9e307Zm9yKGxldFtPLEJdb2YgT2JqZWN0LmVudHJpZXModykpSVtPXT10eXBlb2YgQj09XCJmdW5jdGlvblwiPyguLi5MKT0+e3VyLnB1c2goTyk7dHJ5e3JldHVybiBCKC4uLkwpfWZpbmFsbHl7d2V8fCh1ci5wb3AoKSxYZSYmaHQ9PT0xJiZ1ci5sZW5ndGg9PT0wJiYoaHQ9MCx3dCs9MSxzcihqaSksdHlwZW9mIEZpYmVyczxcInVcIiYmRmliZXJzLnRjKCkpKX19OkI7cmV0dXJuIEl9KCksWj1mdW5jdGlvbigpe3ZhciB3PVosST1CPT5MPT5CKEwpPj4+MCxPPUI9PigpPT5CKCk+Pj4wO3JldHVybih3PU9iamVjdC5hc3NpZ24oe30sdykpLkRhPUkody5EYSksdy5nYj1PKHcuZ2IpLHcuaWI9SSh3LmliKSx3LmVtc2NyaXB0ZW5fbWFpbl9ydW50aW1lX3RocmVhZF9pZD1PKHcuZW1zY3JpcHRlbl9tYWluX3J1bnRpbWVfdGhyZWFkX2lkKSx3LnRiPUkody50Yiksdy51Yj1PKHcudWIpLHd9KCksTG8ucHVzaChaLmpiKSxMdC51bnNoaWZ0KFouQ2EpLFk9YixEbygpLFp9dmFyIGM9Tm8oKTtpZihHdCsrLHUuaW5zdGFudGlhdGVXYXNtKXRyeXtyZXR1cm4gdS5pbnN0YW50aWF0ZVdhc20oYyxzKX1jYXRjaChmKXtqKGBNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiAke2Z9YCksbShmKX1yZXR1cm4gZ258fD11LmxvY2F0ZUZpbGU/Qm8oXCJvcnQtd2FzbS1zaW1kLXRocmVhZGVkLmpzZXAud2FzbVwiKT9cIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC53YXNtXCI6dS5sb2NhdGVGaWxlP3UubG9jYXRlRmlsZShcIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC53YXNtXCIsUCk6UCtcIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC53YXNtXCI6bmV3IFVSTChcIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC53YXNtXCIsaW1wb3J0Lm1ldGEudXJsKS5ocmVmLGZ1bmN0aW9uKGYsYil7dmFyIHc9Z247cmV0dXJuIER8fHR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyE9XCJmdW5jdGlvblwifHxCbyh3KXx8TW8odyl8fHR5cGVvZiBmZXRjaCE9XCJmdW5jdGlvblwiP1VvKHcsZixiKTpmZXRjaCh3LHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKEk9PldlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKEksZikudGhlbihiLGZ1bmN0aW9uKE8pe3JldHVybiBqKGB3YXNtIHN0cmVhbWluZyBjb21waWxlIGZhaWxlZDogJHtPfWApLGooXCJmYWxsaW5nIGJhY2sgdG8gQXJyYXlCdWZmZXIgaW5zdGFudGlhdGlvblwiKSxVbyh3LGYsYil9KSl9KGMsZnVuY3Rpb24oZil7cyhmLmluc3RhbmNlLGYubW9kdWxlKX0pLmNhdGNoKG0pLHt9fSgpLFZpPXM9PihWaT1aLkRhKShzKSxXaT0oKT0+KFdpPVouRWEpKCk7dS5fT3J0SW5pdD0ocyxjKT0+KHUuX09ydEluaXQ9Wi5GYSkocyxjKSx1Ll9PcnRHZXRMYXN0RXJyb3I9KHMsYyk9Pih1Ll9PcnRHZXRMYXN0RXJyb3I9Wi5HYSkocyxjKSx1Ll9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucz0ocyxjLGYsYix3LEksTyxCLEwsSCk9Pih1Ll9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucz1aLkhhKShzLGMsZixiLHcsSSxPLEIsTCxIKSx1Ll9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlcj0ocyxjKT0+KHUuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPVouSWEpKHMsYyksdS5fT3J0QWRkRnJlZURpbWVuc2lvbk92ZXJyaWRlPShzLGMsZik9Pih1Ll9PcnRBZGRGcmVlRGltZW5zaW9uT3ZlcnJpZGU9Wi5KYSkocyxjLGYpLHUuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT0ocyxjLGYpPT4odS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5PVouS2EpKHMsYyxmKSx1Ll9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnM9cz0+KHUuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucz1aLkxhKShzKSx1Ll9PcnRDcmVhdGVTZXNzaW9uPShzLGMsZik9Pih1Ll9PcnRDcmVhdGVTZXNzaW9uPVouTWEpKHMsYyxmKSx1Ll9PcnRSZWxlYXNlU2Vzc2lvbj1zPT4odS5fT3J0UmVsZWFzZVNlc3Npb249Wi5OYSkocyksdS5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudD0ocyxjLGYpPT4odS5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudD1aLk9hKShzLGMsZiksdS5fT3J0R2V0SW5wdXROYW1lPShzLGMpPT4odS5fT3J0R2V0SW5wdXROYW1lPVouUGEpKHMsYyksdS5fT3J0R2V0T3V0cHV0TmFtZT0ocyxjKT0+KHUuX09ydEdldE91dHB1dE5hbWU9Wi5RYSkocyxjKSx1Ll9PcnRGcmVlPXM9Pih1Ll9PcnRGcmVlPVouUmEpKHMpLHUuX09ydENyZWF0ZVRlbnNvcj0ocyxjLGYsYix3LEkpPT4odS5fT3J0Q3JlYXRlVGVuc29yPVouU2EpKHMsYyxmLGIsdyxJKSx1Ll9PcnRHZXRUZW5zb3JEYXRhPShzLGMsZixiLHcpPT4odS5fT3J0R2V0VGVuc29yRGF0YT1aLlRhKShzLGMsZixiLHcpLHUuX09ydFJlbGVhc2VUZW5zb3I9cz0+KHUuX09ydFJlbGVhc2VUZW5zb3I9Wi5VYSkocyksdS5fT3J0Q3JlYXRlUnVuT3B0aW9ucz0ocyxjLGYsYik9Pih1Ll9PcnRDcmVhdGVSdW5PcHRpb25zPVouVmEpKHMsYyxmLGIpLHUuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PShzLGMsZik9Pih1Ll9PcnRBZGRSdW5Db25maWdFbnRyeT1aLldhKShzLGMsZiksdS5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9cz0+KHUuX09ydFJlbGVhc2VSdW5PcHRpb25zPVouWGEpKHMpLHUuX09ydENyZWF0ZUJpbmRpbmc9cz0+KHUuX09ydENyZWF0ZUJpbmRpbmc9Wi5ZYSkocyksdS5fT3J0QmluZElucHV0PShzLGMsZik9Pih1Ll9PcnRCaW5kSW5wdXQ9Wi5aYSkocyxjLGYpLHUuX09ydEJpbmRPdXRwdXQ9KHMsYyxmLGIpPT4odS5fT3J0QmluZE91dHB1dD1aLl9hKShzLGMsZixiKSx1Ll9PcnRDbGVhckJvdW5kT3V0cHV0cz1zPT4odS5fT3J0Q2xlYXJCb3VuZE91dHB1dHM9Wi4kYSkocyksdS5fT3J0UmVsZWFzZUJpbmRpbmc9cz0+KHUuX09ydFJlbGVhc2VCaW5kaW5nPVouYWIpKHMpLHUuX09ydFJ1bldpdGhCaW5kaW5nPShzLGMsZixiLHcpPT4odS5fT3J0UnVuV2l0aEJpbmRpbmc9Wi5iYikocyxjLGYsYix3KSx1Ll9PcnRSdW49KHMsYyxmLGIsdyxJLE8sQik9Pih1Ll9PcnRSdW49Wi5jYikocyxjLGYsYix3LEksTyxCKSx1Ll9PcnRFbmRQcm9maWxpbmc9cz0+KHUuX09ydEVuZFByb2ZpbGluZz1aLmRiKShzKSx1Ll9Kc2VwT3V0cHV0PShzLGMsZik9Pih1Ll9Kc2VwT3V0cHV0PVouZWIpKHMsYyxmKSx1Ll9Kc2VwR2V0Tm9kZU5hbWU9cz0+KHUuX0pzZXBHZXROb2RlTmFtZT1aLmZiKShzKTt2YXIgbXIsTXQ9KCk9PihNdD1aLmdiKSgpLEplPXUuX2ZyZWU9cz0+KEplPXUuX2ZyZWU9Wi5oYikocyksZnI9dS5fbWFsbG9jPXM9Pihmcj11Ll9tYWxsb2M9Wi5pYikocyksRG49KHMsYyxmLGIsdyxJKT0+KERuPVoubGIpKHMsYyxmLGIsdyxJKSxMaT0oKT0+KExpPVoubWIpKCksR2k9KHMsYyxmLGIsdyk9PihHaT1aLm5iKShzLGMsZixiLHcpLEJuPXM9PihCbj1aLm9iKShzKSxocj1zPT4oaHI9Wi5wYikocyksSGk9KCk9PihIaT1aLnFiKSgpLEZpPShzLGMpPT4oRmk9Wi5yYikocyxjKSxncj1zPT4oZ3I9Wi5zYikocyksTW49cz0+KE1uPVoudGIpKHMpLFJuPSgpPT4oUm49Wi51YikoKSxxaT11LmR5bkNhbGxfaWk9KHMsYyk9PihxaT11LmR5bkNhbGxfaWk9Wi53YikocyxjKSxLaT1zPT4oS2k9Wi54Yikocyksamk9KCk9PihqaT1aLnliKSgpLFlpPXM9PihZaT1aLnpiKShzKSxaaT0oKT0+KFppPVouQWIpKCk7ZnVuY3Rpb24gUWkoKXswPEd0fHwoZz8ocCh1KSxnfHxvcihMdCksc3RhcnRXb3JrZXIodSkpOihvcihZZSksMDxHdHx8bXJ8fChtcj0hMCx1LmNhbGxlZFJ1bj0hMCx3ZXx8KGd8fG9yKEx0KSxwKHUpLGd8fG9yKGZuKSkpKSl9cmV0dXJuIHUuX19fc3RhcnRfZW1fanM9OTI5MzAxLHUuX19fc3RvcF9lbV9qcz05Mjk1NDcsdS5zdGFja1NhdmU9KCk9PlJuKCksdS5zdGFja1Jlc3RvcmU9cz0+Z3IocyksdS5zdGFja0FsbG9jPXM9Pk1uKHMpLHUuc2V0VmFsdWU9ZnVuY3Rpb24ocyxjLGY9XCJpOFwiKXtzd2l0Y2goZi5lbmRzV2l0aChcIipcIikmJihmPVwiKlwiKSxmKXtjYXNlXCJpMVwiOmNhc2VcImk4XCI6dCgpW3M+Pj4wXT1jO2JyZWFrO2Nhc2VcImkxNlwiOm4oKVtzPj4+MT4+PjBdPWM7YnJlYWs7Y2FzZVwiaTMyXCI6aSgpW3M+Pj4yPj4+MF09YzticmVhaztjYXNlXCJpNjRcIjpxW3M+Pj4zXT1CaWdJbnQoYyk7YnJlYWs7Y2FzZVwiZmxvYXRcIjpkKClbcz4+PjI+Pj4wXT1jO2JyZWFrO2Nhc2VcImRvdWJsZVwiOmwoKVtzPj4+Mz4+PjBdPWM7YnJlYWs7Y2FzZVwiKlwiOmEoKVtzPj4+Mj4+PjBdPWM7YnJlYWs7ZGVmYXVsdDpjdChgaW52YWxpZCB0eXBlIGZvciBzZXRWYWx1ZTogJHtmfWApfX0sdS5nZXRWYWx1ZT1mdW5jdGlvbihzLGM9XCJpOFwiKXtzd2l0Y2goYy5lbmRzV2l0aChcIipcIikmJihjPVwiKlwiKSxjKXtjYXNlXCJpMVwiOmNhc2VcImk4XCI6cmV0dXJuIHQoKVtzPj4+MF07Y2FzZVwiaTE2XCI6cmV0dXJuIG4oKVtzPj4+MT4+PjBdO2Nhc2VcImkzMlwiOnJldHVybiBpKClbcz4+PjI+Pj4wXTtjYXNlXCJpNjRcIjpyZXR1cm4gcVtzPj4+M107Y2FzZVwiZmxvYXRcIjpyZXR1cm4gZCgpW3M+Pj4yPj4+MF07Y2FzZVwiZG91YmxlXCI6cmV0dXJuIGwoKVtzPj4+Mz4+PjBdO2Nhc2VcIipcIjpyZXR1cm4gYSgpW3M+Pj4yPj4+MF07ZGVmYXVsdDpjdChgaW52YWxpZCB0eXBlIGZvciBnZXRWYWx1ZTogJHtjfWApfX0sdS5VVEY4VG9TdHJpbmc9Q2UsdS5zdHJpbmdUb1VURjg9T3QsdS5sZW5ndGhCeXRlc1VURjg9JG4sSHQ9ZnVuY3Rpb24gcygpe21yfHxRaSgpLG1yfHwoSHQ9cyl9LFFpKCksdS5QVFJfU0laRT00LGh9KSxLcD16YTtnbG9iYWxUaGlzLnNlbGY/Lm5hbWU9PT1cImVtLXB0aHJlYWRcIiYmemEoKX0pO3ZhciBSYSxqcCxOZSxVYSxqbixZcCxacCxOYSxRcCxCYSxWYSxNYSxXYSx4cj1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7JHIoKTtSYT0hMXx8dHlwZW9mIGxvY2F0aW9uPlwidVwiP3ZvaWQgMDpsb2NhdGlvbi5vcmlnaW4sanA9KCk9PntpZighITEpcmV0dXJuIGltcG9ydC5tZXRhLnVybD8uc3RhcnRzV2l0aChcImZpbGU6XCIpP25ldyBVUkwobmV3IFVSTChcIm9ydC5idW5kbGUubWluLm1qc1wiLGltcG9ydC5tZXRhLnVybCkuaHJlZixSYSkuaHJlZjppbXBvcnQubWV0YS51cmx9LE5lPWpwKCksVWE9KCk9PntpZihOZSYmIU5lLnN0YXJ0c1dpdGgoXCJibG9iOlwiKSlyZXR1cm4gTmUuc3Vic3RyaW5nKDAsTmUubGFzdEluZGV4T2YoXCIvXCIpKzEpfSxqbj0oZSx0KT0+e3RyeXtsZXQgcj10Pz9OZTtyZXR1cm4ocj9uZXcgVVJMKGUscik6bmV3IFVSTChlKSkub3JpZ2luPT09UmF9Y2F0Y2h7cmV0dXJuITF9fSxZcD0oZSx0KT0+e2xldCByPXQ/P05lO3RyeXtyZXR1cm4ocj9uZXcgVVJMKGUscik6bmV3IFVSTChlKSkuaHJlZn1jYXRjaHtyZXR1cm59fSxacD0oZSx0KT0+YCR7dD8/XCIuL1wifSR7ZX1gLE5hPWFzeW5jIGU9PntsZXQgcj1hd2FpdChhd2FpdCBmZXRjaChlLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KSkuYmxvYigpO3JldHVybiBVUkwuY3JlYXRlT2JqZWN0VVJMKHIpfSxRcD1hc3luYyBlPT4oYXdhaXQgaW1wb3J0KC8qd2VicGFja0lnbm9yZTp0cnVlKi9lKSkuZGVmYXVsdCxCYT0oUGEoKSxicihFYSkpLmRlZmF1bHQsVmE9YXN5bmMoKT0+e2lmKCFOZSl0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gbG9hZCBwcm94eSB3b3JrZXI6IGNhbm5vdCBkZXRlcm1pbmUgdGhlIHNjcmlwdCBzb3VyY2UgVVJMLlwiKTtpZihqbihOZSkpcmV0dXJuW3ZvaWQgMCxCYSgpXTtsZXQgZT1hd2FpdCBOYShOZSk7cmV0dXJuW2UsQmEoZSldfSxNYT0oRGEoKSxicihPYSkpLmRlZmF1bHQsV2E9YXN5bmMoZSx0LHIpPT57aWYoIWUmJiF0JiZNYSYmTmUmJmpuKE5lKSlyZXR1cm5bdm9pZCAwLE1hXTt7bGV0IG49XCJvcnQtd2FzbS1zaW1kLXRocmVhZGVkLmpzZXAubWpzXCIsbz1lPz9ZcChuLHQpLGk9ISExJiZyJiZvJiYham4obyx0KSxhPWk/YXdhaXQgTmEobyk6bz8/WnAobix0KTtyZXR1cm5baT9hOnZvaWQgMCxhd2FpdCBRcChhKV19fX0pO3ZhciBZbixabix6cixMYSxYcCxKcCxTcixJZSxndD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7eHIoKTtabj0hMSx6cj0hMSxMYT0hMSxYcD0oKT0+e2lmKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlcj5cInVcIilyZXR1cm4hMTt0cnl7cmV0dXJuIHR5cGVvZiBNZXNzYWdlQ2hhbm5lbDxcInVcIiYmbmV3IE1lc3NhZ2VDaGFubmVsKCkucG9ydDEucG9zdE1lc3NhZ2UobmV3IFNoYXJlZEFycmF5QnVmZmVyKDEpKSxXZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw0LDEsOTYsMCwwLDMsMiwxLDAsNSw0LDEsMywxLDEsMTAsMTEsMSw5LDAsNjUsMCwyNTQsMTYsMiwwLDI2LDExXSkpfWNhdGNoe3JldHVybiExfX0sSnA9KCk9Pnt0cnl7cmV0dXJuIFdlYkFzc2VtYmx5LnZhbGlkYXRlKG5ldyBVaW50OEFycmF5KFswLDk3LDExNSwxMDksMSwwLDAsMCwxLDQsMSw5NiwwLDAsMywyLDEsMCwxMCwzMCwxLDI4LDAsNjUsMCwyNTMsMTUsMjUzLDEyLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMjUzLDE4NiwxLDI2LDExXSkpfWNhdGNoe3JldHVybiExfX0sU3I9YXN5bmMgZT0+e2lmKFpuKXJldHVybiBQcm9taXNlLnJlc29sdmUoKTtpZih6cil0aHJvdyBuZXcgRXJyb3IoXCJtdWx0aXBsZSBjYWxscyB0byAnaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KCknIGRldGVjdGVkLlwiKTtpZihMYSl0aHJvdyBuZXcgRXJyb3IoXCJwcmV2aW91cyBjYWxsIHRvICdpbml0aWFsaXplV2ViQXNzZW1ibHkoKScgZmFpbGVkLlwiKTt6cj0hMDtsZXQgdD1lLmluaXRUaW1lb3V0LHI9ZS5udW1UaHJlYWRzO2lmKCFKcCgpKXRocm93IG5ldyBFcnJvcihcIldlYkFzc2VtYmx5IFNJTUQgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC5cIik7bGV0IG49WHAoKTtyPjEmJiFuJiYodHlwZW9mIHNlbGY8XCJ1XCImJiFzZWxmLmNyb3NzT3JpZ2luSXNvbGF0ZWQmJmNvbnNvbGUud2FybihcImVudi53YXNtLm51bVRocmVhZHMgaXMgc2V0IHRvIFwiK3IrXCIsIGJ1dCB0aGlzIHdpbGwgbm90IHdvcmsgdW5sZXNzIHlvdSBlbmFibGUgY3Jvc3NPcmlnaW5Jc29sYXRlZCBtb2RlLiBTZWUgaHR0cHM6Ly93ZWIuZGV2L2Nyb3NzLW9yaWdpbi1pc29sYXRpb24tZ3VpZGUvIGZvciBtb3JlIGluZm8uXCIpLGNvbnNvbGUud2FybihcIldlYkFzc2VtYmx5IG11bHRpLXRocmVhZGluZyBpcyBub3Qgc3VwcG9ydGVkIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50LiBGYWxsaW5nIGJhY2sgdG8gc2luZ2xlLXRocmVhZGluZy5cIiksZS5udW1UaHJlYWRzPXI9MSk7bGV0IG89ZS53YXNtUGF0aHMsaT10eXBlb2Ygbz09XCJzdHJpbmdcIj9vOnZvaWQgMCxhPW8/Lm1qcyxkPWE/LmhyZWY/P2EsbD1vPy53YXNtLHA9bD8uaHJlZj8/bCxtPWUud2FzbUJpbmFyeSxbdSxoXT1hd2FpdCBXYShkLGkscj4xKSxfPSExLHk9W107aWYodD4wJiZ5LnB1c2gobmV3IFByb21pc2UoZz0+e3NldFRpbWVvdXQoKCk9PntfPSEwLGcoKX0sdCl9KSkseS5wdXNoKG5ldyBQcm9taXNlKChnLHgpPT57bGV0ICQ9e251bVRocmVhZHM6cn07aWYobSkkLndhc21CaW5hcnk9bTtlbHNlIGlmKHB8fGkpJC5sb2NhdGVGaWxlPXY9PnA/P2krdjtlbHNlIGlmKGQmJmQuaW5kZXhPZihcImJsb2I6XCIpIT09MCkkLmxvY2F0ZUZpbGU9dj0+bmV3IFVSTCh2LGQpLmhyZWY7ZWxzZSBpZih1KXtsZXQgdj1VYSgpO3YmJigkLmxvY2F0ZUZpbGU9Uz0+ditTKX1oKCQpLnRoZW4odj0+e3pyPSExLFpuPSEwLFluPXYsZygpLHUmJlVSTC5yZXZva2VPYmplY3RVUkwodSl9LHY9Pnt6cj0hMSxMYT0hMCx4KHYpfSl9KSksYXdhaXQgUHJvbWlzZS5yYWNlKHkpLF8pdGhyb3cgbmV3IEVycm9yKGBXZWJBc3NlbWJseSBiYWNrZW5kIGluaXRpYWxpemluZyBmYWlsZWQgZHVlIHRvIHRpbWVvdXQ6ICR7dH1tc2ApfSxJZT0oKT0+e2lmKFpuJiZZbilyZXR1cm4gWW47dGhyb3cgbmV3IEVycm9yKFwiV2ViQXNzZW1ibHkgaXMgbm90IGluaXRpYWxpemVkIHlldC5cIil9fSk7dmFyIGtlLGp0LHBlLE9yPVUoKCk9PntcInVzZSBzdHJpY3RcIjtndCgpO2tlPShlLHQpPT57bGV0IHI9SWUoKSxuPXIubGVuZ3RoQnl0ZXNVVEY4KGUpKzEsbz1yLl9tYWxsb2Mobik7cmV0dXJuIHIuc3RyaW5nVG9VVEY4KGUsbyxuKSx0LnB1c2gobyksb30sanQ9KGUsdCxyLG4pPT57aWYodHlwZW9mIGU9PVwib2JqZWN0XCImJmUhPT1udWxsKXtpZihyLmhhcyhlKSl0aHJvdyBuZXcgRXJyb3IoXCJDaXJjdWxhciByZWZlcmVuY2UgaW4gb3B0aW9uc1wiKTtyLmFkZChlKX1PYmplY3QuZW50cmllcyhlKS5mb3JFYWNoKChbbyxpXSk9PntsZXQgYT10P3QrbzpvO2lmKHR5cGVvZiBpPT1cIm9iamVjdFwiKWp0KGksYStcIi5cIixyLG4pO2Vsc2UgaWYodHlwZW9mIGk9PVwic3RyaW5nXCJ8fHR5cGVvZiBpPT1cIm51bWJlclwiKW4oYSxpLnRvU3RyaW5nKCkpO2Vsc2UgaWYodHlwZW9mIGk9PVwiYm9vbGVhblwiKW4oYSxpP1wiMVwiOlwiMFwiKTtlbHNlIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgaGFuZGxlIGV4dHJhIGNvbmZpZyB0eXBlOiAke3R5cGVvZiBpfWApfSl9LHBlPWU9PntsZXQgdD1JZSgpLHI9dC5zdGFja1NhdmUoKTt0cnl7bGV0IG49dC5QVFJfU0laRSxvPXQuc3RhY2tBbGxvYygyKm4pO3QuX09ydEdldExhc3RFcnJvcihvLG8rbik7bGV0IGk9TnVtYmVyKHQuZ2V0VmFsdWUobyxuPT09ND9cImkzMlwiOlwiaTY0XCIpKSxhPXQuZ2V0VmFsdWUobytuLFwiKlwiKSxkPWE/dC5VVEY4VG9TdHJpbmcoYSk6XCJcIjt0aHJvdyBuZXcgRXJyb3IoYCR7ZX0gRVJST1JfQ09ERTogJHtpfSwgRVJST1JfTUVTU0FHRTogJHtkfWApfWZpbmFsbHl7dC5zdGFja1Jlc3RvcmUocil9fX0pO3ZhciBHYSxIYT1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Z3QoKTtPcigpO0dhPWU9PntsZXQgdD1JZSgpLHI9MCxuPVtdLG89ZXx8e307dHJ5e2lmKGU/LmxvZ1NldmVyaXR5TGV2ZWw9PT12b2lkIDApby5sb2dTZXZlcml0eUxldmVsPTI7ZWxzZSBpZih0eXBlb2YgZS5sb2dTZXZlcml0eUxldmVsIT1cIm51bWJlclwifHwhTnVtYmVyLmlzSW50ZWdlcihlLmxvZ1NldmVyaXR5TGV2ZWwpfHxlLmxvZ1NldmVyaXR5TGV2ZWw8MHx8ZS5sb2dTZXZlcml0eUxldmVsPjQpdGhyb3cgbmV3IEVycm9yKGBsb2cgc2VydmVyaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtlLmxvZ1NldmVyaXR5TGV2ZWx9YCk7aWYoZT8ubG9nVmVyYm9zaXR5TGV2ZWw9PT12b2lkIDApby5sb2dWZXJib3NpdHlMZXZlbD0wO2Vsc2UgaWYodHlwZW9mIGUubG9nVmVyYm9zaXR5TGV2ZWwhPVwibnVtYmVyXCJ8fCFOdW1iZXIuaXNJbnRlZ2VyKGUubG9nVmVyYm9zaXR5TGV2ZWwpKXRocm93IG5ldyBFcnJvcihgbG9nIHZlcmJvc2l0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7ZS5sb2dWZXJib3NpdHlMZXZlbH1gKTtlPy50ZXJtaW5hdGU9PT12b2lkIDAmJihvLnRlcm1pbmF0ZT0hMSk7bGV0IGk9MDtyZXR1cm4gZT8udGFnIT09dm9pZCAwJiYoaT1rZShlLnRhZyxuKSkscj10Ll9PcnRDcmVhdGVSdW5PcHRpb25zKG8ubG9nU2V2ZXJpdHlMZXZlbCxvLmxvZ1ZlcmJvc2l0eUxldmVsLCEhby50ZXJtaW5hdGUsaSkscj09PTAmJnBlKFwiQ2FuJ3QgY3JlYXRlIHJ1biBvcHRpb25zLlwiKSxlPy5leHRyYSE9PXZvaWQgMCYmanQoZS5leHRyYSxcIlwiLG5ldyBXZWFrU2V0LChhLGQpPT57bGV0IGw9a2UoYSxuKSxwPWtlKGQsbik7dC5fT3J0QWRkUnVuQ29uZmlnRW50cnkocixsLHApIT09MCYmcGUoYENhbid0IHNldCBhIHJ1biBjb25maWcgZW50cnk6ICR7YX0gLSAke2R9LmApfSksW3Isbl19Y2F0Y2goaSl7dGhyb3cgciE9PTAmJnQuX09ydFJlbGVhc2VSdW5PcHRpb25zKHIpLG4uZm9yRWFjaChhPT50Ll9mcmVlKGEpKSxpfX19KTt2YXIgZW0sdG0scm0sbm0sRmEscWE9VSgoKT0+e1widXNlIHN0cmljdFwiO2d0KCk7T3IoKTtlbT1lPT57c3dpdGNoKGUpe2Nhc2VcImRpc2FibGVkXCI6cmV0dXJuIDA7Y2FzZVwiYmFzaWNcIjpyZXR1cm4gMTtjYXNlXCJleHRlbmRlZFwiOnJldHVybiAyO2Nhc2VcImFsbFwiOnJldHVybiA5OTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZ3JhcGggb3B0aW1pemF0aW9uIGxldmVsOiAke2V9YCl9fSx0bT1lPT57c3dpdGNoKGUpe2Nhc2VcInNlcXVlbnRpYWxcIjpyZXR1cm4gMDtjYXNlXCJwYXJhbGxlbFwiOnJldHVybiAxO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBleGVjdXRpb24gbW9kZTogJHtlfWApfX0scm09ZT0+e2UuZXh0cmF8fChlLmV4dHJhPXt9KSxlLmV4dHJhLnNlc3Npb258fChlLmV4dHJhLnNlc3Npb249e30pO2xldCB0PWUuZXh0cmEuc2Vzc2lvbjt0LnVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHl8fCh0LnVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHk9XCIxXCIpLGUuZXhlY3V0aW9uUHJvdmlkZXJzJiZlLmV4ZWN1dGlvblByb3ZpZGVycy5zb21lKHI9Pih0eXBlb2Ygcj09XCJzdHJpbmdcIj9yOnIubmFtZSk9PT1cIndlYmdwdVwiKSYmKGUuZW5hYmxlTWVtUGF0dGVybj0hMSl9LG5tPShlLHQscik9Pntmb3IobGV0IG4gb2YgdCl7bGV0IG89dHlwZW9mIG49PVwic3RyaW5nXCI/bjpuLm5hbWU7c3dpdGNoKG8pe2Nhc2VcIndlYm5uXCI6aWYobz1cIldFQk5OXCIsdHlwZW9mIG4hPVwic3RyaW5nXCIpe2xldCBkPW4/LmRldmljZVR5cGU7aWYoZCl7bGV0IGw9a2UoXCJkZXZpY2VUeXBlXCIscikscD1rZShkLHIpO0llKCkuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeShlLGwscCkhPT0wJiZwZShgQ2FuJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6ICdkZXZpY2VUeXBlJyAtICR7ZH0uYCl9fWJyZWFrO2Nhc2VcIndlYmdwdVwiOmlmKG89XCJKU1wiLHR5cGVvZiBuIT1cInN0cmluZ1wiKXtsZXQgYT1uO2lmKGE/LnByZWZlcnJlZExheW91dCl7aWYoYS5wcmVmZXJyZWRMYXlvdXQhPT1cIk5DSFdcIiYmYS5wcmVmZXJyZWRMYXlvdXQhPT1cIk5IV0NcIil0aHJvdyBuZXcgRXJyb3IoYHByZWZlcnJlZExheW91dCBtdXN0IGJlIGVpdGhlciAnTkNIVycgb3IgJ05IV0MnOiAke2EucHJlZmVycmVkTGF5b3V0fWApO2xldCBkPWtlKFwicHJlZmVycmVkTGF5b3V0XCIsciksbD1rZShhLnByZWZlcnJlZExheW91dCxyKTtJZSgpLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkoZSxkLGwpIT09MCYmcGUoYENhbid0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAncHJlZmVycmVkTGF5b3V0JyAtICR7YS5wcmVmZXJyZWRMYXlvdXR9LmApfX1icmVhaztjYXNlXCJ3YXNtXCI6Y2FzZVwiY3B1XCI6Y29udGludWU7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgZXhlY3V0aW9uIHByb3ZpZGVyOiAke299YCl9bGV0IGk9a2UobyxyKTtJZSgpLl9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlcihlLGkpIT09MCYmcGUoYENhbid0IGFwcGVuZCBleGVjdXRpb24gcHJvdmlkZXI6ICR7b30uYCl9fSxGYT1lPT57bGV0IHQ9SWUoKSxyPTAsbj1bXSxvPWV8fHt9O3JtKG8pO3RyeXtsZXQgaT1lbShvLmdyYXBoT3B0aW1pemF0aW9uTGV2ZWw/P1wiYWxsXCIpLGE9dG0oby5leGVjdXRpb25Nb2RlPz9cInNlcXVlbnRpYWxcIiksZD10eXBlb2Ygby5sb2dJZD09XCJzdHJpbmdcIj9rZShvLmxvZ0lkLG4pOjAsbD1vLmxvZ1NldmVyaXR5TGV2ZWw/PzI7aWYoIU51bWJlci5pc0ludGVnZXIobCl8fGw8MHx8bD40KXRocm93IG5ldyBFcnJvcihgbG9nIHNlcnZlcml0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7bH1gKTtsZXQgcD1vLmxvZ1ZlcmJvc2l0eUxldmVsPz8wO2lmKCFOdW1iZXIuaXNJbnRlZ2VyKHApfHxwPDB8fHA+NCl0aHJvdyBuZXcgRXJyb3IoYGxvZyB2ZXJib3NpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke3B9YCk7bGV0IG09dHlwZW9mIG8ub3B0aW1pemVkTW9kZWxGaWxlUGF0aD09XCJzdHJpbmdcIj9rZShvLm9wdGltaXplZE1vZGVsRmlsZVBhdGgsbik6MDtpZihyPXQuX09ydENyZWF0ZVNlc3Npb25PcHRpb25zKGksISFvLmVuYWJsZUNwdU1lbUFyZW5hLCEhby5lbmFibGVNZW1QYXR0ZXJuLGEsISFvLmVuYWJsZVByb2ZpbGluZywwLGQsbCxwLG0pLHI9PT0wJiZwZShcIkNhbid0IGNyZWF0ZSBzZXNzaW9uIG9wdGlvbnMuXCIpLG8uZXhlY3V0aW9uUHJvdmlkZXJzJiZubShyLG8uZXhlY3V0aW9uUHJvdmlkZXJzLG4pLG8uZW5hYmxlR3JhcGhDYXB0dXJlIT09dm9pZCAwKXtpZih0eXBlb2Ygby5lbmFibGVHcmFwaENhcHR1cmUhPVwiYm9vbGVhblwiKXRocm93IG5ldyBFcnJvcihgZW5hYmxlR3JhcGhDYXB0dXJlIG11c3QgYmUgYSBib29sZWFuIHZhbHVlOiAke28uZW5hYmxlR3JhcGhDYXB0dXJlfWApO2xldCB1PWtlKFwiZW5hYmxlR3JhcGhDYXB0dXJlXCIsbiksaD1rZShvLmVuYWJsZUdyYXBoQ2FwdHVyZS50b1N0cmluZygpLG4pO3QuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeShyLHUsaCkhPT0wJiZwZShgQ2FuJ3Qgc2V0IGEgc2Vzc2lvbiBjb25maWcgZW50cnk6ICdlbmFibGVHcmFwaENhcHR1cmUnIC0gJHtvLmVuYWJsZUdyYXBoQ2FwdHVyZX0uYCl9aWYoby5mcmVlRGltZW5zaW9uT3ZlcnJpZGVzKWZvcihsZXRbdSxoXW9mIE9iamVjdC5lbnRyaWVzKG8uZnJlZURpbWVuc2lvbk92ZXJyaWRlcykpe2lmKHR5cGVvZiB1IT1cInN0cmluZ1wiKXRocm93IG5ldyBFcnJvcihgZnJlZSBkaW1lbnNpb24gb3ZlcnJpZGUgbmFtZSBtdXN0IGJlIGEgc3RyaW5nOiAke3V9YCk7aWYodHlwZW9mIGghPVwibnVtYmVyXCJ8fCFOdW1iZXIuaXNJbnRlZ2VyKGgpfHxoPDApdGhyb3cgbmV3IEVycm9yKGBmcmVlIGRpbWVuc2lvbiBvdmVycmlkZSB2YWx1ZSBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXI6ICR7aH1gKTtsZXQgXz1rZSh1LG4pO3QuX09ydEFkZEZyZWVEaW1lbnNpb25PdmVycmlkZShyLF8saCkhPT0wJiZwZShgQ2FuJ3Qgc2V0IGEgZnJlZSBkaW1lbnNpb24gb3ZlcnJpZGU6ICR7dX0gLSAke2h9LmApfXJldHVybiBvLmV4dHJhIT09dm9pZCAwJiZqdChvLmV4dHJhLFwiXCIsbmV3IFdlYWtTZXQsKHUsaCk9PntsZXQgXz1rZSh1LG4pLHk9a2UoaCxuKTt0Ll9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkocixfLHkpIT09MCYmcGUoYENhbid0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAke3V9IC0gJHtofS5gKX0pLFtyLG5dfWNhdGNoKGkpe3Rocm93IHIhPT0wJiZ0Ll9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnMocikhPT0wJiZwZShcIkNhbid0IHJlbGVhc2Ugc2Vzc2lvbiBvcHRpb25zLlwiKSxuLmZvckVhY2goYT0+dC5fZnJlZShhKSksaX19fSk7dmFyIFl0LGJ0LEN0LERyLFp0LEJyLE1yLFFuLHRlPVUoKCk9PntcInVzZSBzdHJpY3RcIjtZdD1lPT57c3dpdGNoKGUpe2Nhc2VcImludDhcIjpyZXR1cm4gMztjYXNlXCJ1aW50OFwiOnJldHVybiAyO2Nhc2VcImJvb2xcIjpyZXR1cm4gOTtjYXNlXCJpbnQxNlwiOnJldHVybiA1O2Nhc2VcInVpbnQxNlwiOnJldHVybiA0O2Nhc2VcImludDMyXCI6cmV0dXJuIDY7Y2FzZVwidWludDMyXCI6cmV0dXJuIDEyO2Nhc2VcImZsb2F0MTZcIjpyZXR1cm4gMTA7Y2FzZVwiZmxvYXQzMlwiOnJldHVybiAxO2Nhc2VcImZsb2F0NjRcIjpyZXR1cm4gMTE7Y2FzZVwic3RyaW5nXCI6cmV0dXJuIDg7Y2FzZVwiaW50NjRcIjpyZXR1cm4gNztjYXNlXCJ1aW50NjRcIjpyZXR1cm4gMTM7Y2FzZVwiaW50NFwiOnJldHVybiAyMjtjYXNlXCJ1aW50NFwiOnJldHVybiAyMTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2V9YCl9fSxidD1lPT57c3dpdGNoKGUpe2Nhc2UgMzpyZXR1cm5cImludDhcIjtjYXNlIDI6cmV0dXJuXCJ1aW50OFwiO2Nhc2UgOTpyZXR1cm5cImJvb2xcIjtjYXNlIDU6cmV0dXJuXCJpbnQxNlwiO2Nhc2UgNDpyZXR1cm5cInVpbnQxNlwiO2Nhc2UgNjpyZXR1cm5cImludDMyXCI7Y2FzZSAxMjpyZXR1cm5cInVpbnQzMlwiO2Nhc2UgMTA6cmV0dXJuXCJmbG9hdDE2XCI7Y2FzZSAxOnJldHVyblwiZmxvYXQzMlwiO2Nhc2UgMTE6cmV0dXJuXCJmbG9hdDY0XCI7Y2FzZSA4OnJldHVyblwic3RyaW5nXCI7Y2FzZSA3OnJldHVyblwiaW50NjRcIjtjYXNlIDEzOnJldHVyblwidWludDY0XCI7Y2FzZSAyMjpyZXR1cm5cImludDRcIjtjYXNlIDIxOnJldHVyblwidWludDRcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2V9YCl9fSxDdD0oZSx0KT0+e2xldCByPVstMSw0LDEsMSwyLDIsNCw4LC0xLDEsMiw4LDQsOCwtMSwtMSwtMSwtMSwtMSwtMSwtMSwuNSwuNV1bZV0sbj10eXBlb2YgdD09XCJudW1iZXJcIj90OnQucmVkdWNlKChvLGkpPT5vKmksMSk7cmV0dXJuIHI+MD9NYXRoLmNlaWwobipyKTp2b2lkIDB9LERyPWU9Pntzd2l0Y2goZSl7Y2FzZVwiZmxvYXQxNlwiOnJldHVybiB0eXBlb2YgRmxvYXQxNkFycmF5PFwidVwiJiZGbG9hdDE2QXJyYXkuZnJvbT9GbG9hdDE2QXJyYXk6VWludDE2QXJyYXk7Y2FzZVwiZmxvYXQzMlwiOnJldHVybiBGbG9hdDMyQXJyYXk7Y2FzZVwidWludDhcIjpyZXR1cm4gVWludDhBcnJheTtjYXNlXCJpbnQ4XCI6cmV0dXJuIEludDhBcnJheTtjYXNlXCJ1aW50MTZcIjpyZXR1cm4gVWludDE2QXJyYXk7Y2FzZVwiaW50MTZcIjpyZXR1cm4gSW50MTZBcnJheTtjYXNlXCJpbnQzMlwiOnJldHVybiBJbnQzMkFycmF5O2Nhc2VcImJvb2xcIjpyZXR1cm4gVWludDhBcnJheTtjYXNlXCJmbG9hdDY0XCI6cmV0dXJuIEZsb2F0NjRBcnJheTtjYXNlXCJ1aW50MzJcIjpyZXR1cm4gVWludDMyQXJyYXk7Y2FzZVwiaW50NjRcIjpyZXR1cm4gQmlnSW50NjRBcnJheTtjYXNlXCJ1aW50NjRcIjpyZXR1cm4gQmlnVWludDY0QXJyYXk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGU6ICR7ZX1gKX19LFp0PWU9Pntzd2l0Y2goZSl7Y2FzZVwidmVyYm9zZVwiOnJldHVybiAwO2Nhc2VcImluZm9cIjpyZXR1cm4gMTtjYXNlXCJ3YXJuaW5nXCI6cmV0dXJuIDI7Y2FzZVwiZXJyb3JcIjpyZXR1cm4gMztjYXNlXCJmYXRhbFwiOnJldHVybiA0O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBsb2dnaW5nIGxldmVsOiAke2V9YCl9fSxCcj1lPT5lPT09XCJmbG9hdDMyXCJ8fGU9PT1cImZsb2F0MTZcInx8ZT09PVwiaW50MzJcInx8ZT09PVwiaW50NjRcInx8ZT09PVwidWludDMyXCJ8fGU9PT1cInVpbnQ4XCJ8fGU9PT1cImJvb2xcInx8ZT09PVwidWludDRcInx8ZT09PVwiaW50NFwiLE1yPWU9PmU9PT1cImZsb2F0MzJcInx8ZT09PVwiZmxvYXQxNlwifHxlPT09XCJpbnQzMlwifHxlPT09XCJpbnQ2NFwifHxlPT09XCJ1aW50MzJcInx8ZT09PVwidWludDY0XCJ8fGU9PT1cImludDhcInx8ZT09PVwidWludDhcInx8ZT09PVwiYm9vbFwifHxlPT09XCJ1aW50NFwifHxlPT09XCJpbnQ0XCIsUW49ZT0+e3N3aXRjaChlKXtjYXNlXCJub25lXCI6cmV0dXJuIDA7Y2FzZVwiY3B1XCI6cmV0dXJuIDE7Y2FzZVwiY3B1LXBpbm5lZFwiOnJldHVybiAyO2Nhc2VcInRleHR1cmVcIjpyZXR1cm4gMztjYXNlXCJncHUtYnVmZmVyXCI6cmV0dXJuIDQ7Y2FzZVwibWwtdGVuc29yXCI6cmV0dXJuIDU7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgbG9jYXRpb246ICR7ZX1gKX19fSk7dmFyIFF0LFhuPVUoKCk9PntcInVzZSBzdHJpY3RcIjskcigpO1F0PWFzeW5jIGU9PntpZih0eXBlb2YgZT09XCJzdHJpbmdcIilpZighMSl0cnl7bGV0e3JlYWRGaWxlOnR9PU5uKFwibm9kZTpmcy9wcm9taXNlc1wiKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgdChlKSl9Y2F0Y2godCl7aWYodC5jb2RlPT09XCJFUlJfRlNfRklMRV9UT09fTEFSR0VcIil7bGV0e2NyZWF0ZVJlYWRTdHJlYW06cn09Tm4oXCJub2RlOmZzXCIpLG49cihlKSxvPVtdO2ZvciBhd2FpdChsZXQgaSBvZiBuKW8ucHVzaChpKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoQnVmZmVyLmNvbmNhdChvKSl9dGhyb3cgdH1lbHNle2xldCB0PWF3YWl0IGZldGNoKGUpO2lmKCF0Lm9rKXRocm93IG5ldyBFcnJvcihgZmFpbGVkIHRvIGxvYWQgZXh0ZXJuYWwgZGF0YSBmaWxlOiAke2V9YCk7bGV0IHI9dC5oZWFkZXJzLmdldChcIkNvbnRlbnQtTGVuZ3RoXCIpLG49cj9wYXJzZUludChyLDEwKTowO2lmKG48MTA3Mzc0MTgyNClyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgdC5hcnJheUJ1ZmZlcigpKTt7aWYoIXQuYm9keSl0aHJvdyBuZXcgRXJyb3IoYGZhaWxlZCB0byBsb2FkIGV4dGVybmFsIGRhdGEgZmlsZTogJHtlfSwgbm8gcmVzcG9uc2UgYm9keS5gKTtsZXQgbz10LmJvZHkuZ2V0UmVhZGVyKCksaTt0cnl7aT1uZXcgQXJyYXlCdWZmZXIobil9Y2F0Y2goZCl7aWYoZCBpbnN0YW5jZW9mIFJhbmdlRXJyb3Ipe2xldCBsPU1hdGguY2VpbChuLzY1NTM2KTtpPW5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe2luaXRpYWw6bCxtYXhpbXVtOmx9KS5idWZmZXJ9ZWxzZSB0aHJvdyBkfWxldCBhPTA7Zm9yKDs7KXtsZXR7ZG9uZTpkLHZhbHVlOmx9PWF3YWl0IG8ucmVhZCgpO2lmKGQpYnJlYWs7bGV0IHA9bC5ieXRlTGVuZ3RoO25ldyBVaW50OEFycmF5KGksYSxwKS5zZXQobCksYSs9cH1yZXR1cm4gbmV3IFVpbnQ4QXJyYXkoaSwwLG4pfX1lbHNlIHJldHVybiBlIGluc3RhbmNlb2YgQmxvYj9uZXcgVWludDhBcnJheShhd2FpdCBlLmFycmF5QnVmZmVyKCkpOmUgaW5zdGFuY2VvZiBVaW50OEFycmF5P2U6bmV3IFVpbnQ4QXJyYXkoZSl9fSk7dmFyIG9tLGltLEthLGphLFJyLGFtLHVlLGV0PVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29tPVtcIlZcIixcIklcIixcIldcIixcIkVcIixcIkZcIl0saW09KGUsdCk9Pntjb25zb2xlLmxvZyhgWyR7b21bZV19LCR7bmV3IERhdGUoKS50b0lTT1N0cmluZygpfV0ke3R9YCl9LFJyPShlLHQpPT57S2E9ZSxqYT10fSxhbT0oZSx0KT0+e2xldCByPVp0KGUpLG49WnQoS2EpO3I+PW4mJmltKHIsdHlwZW9mIHQ9PVwiZnVuY3Rpb25cIj90KCk6dCl9LHVlPSguLi5lKT0+e2phJiZhbSguLi5lKX19KTt2YXIgVXIsSm49VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7VXI9KGUsdCk9Pm5ldyhEcih0KSkoZSl9KTt2YXIgTnI9VSgoKT0+e1widXNlIHN0cmljdFwifSk7dmFyIFlhLGVvLHRvLHNtLHVtLFphLG5vLHJvLFhhLEphPVUoKCk9PntcInVzZSBzdHJpY3RcIjtldCgpO05yKCk7WWE9bmV3IE1hcChbWzY0LDI1MF0sWzEyOCwyMDBdLFsyNTYsMjAwXSxbNTEyLDIwMF0sWzIwNDgsMjMwXSxbNDA5NiwyMDBdLFs4MTkyLDUwXSxbMTYzODQsNTBdLFszMjc2OCw1MF0sWzY1NTM2LDUwXSxbMTMxMDcyLDUwXSxbMjYyMTQ0LDUwXSxbNTI0Mjg4LDUwXSxbMTA0ODU3Niw1MF0sWzIwOTcxNTIsMzBdLFs0MTk0MzA0LDIwXSxbODM4ODYwOCwxMF0sWzEyNTgyOTEyLDEwXSxbMTY3NzcyMTYsMTBdLFsyNjIxNDQwMCwxNV0sWzMzNTU0NDMyLDIyXSxbNDQyMzY4MDAsMl0sWzU4OTgyNDAwLDZdLFs2NzEwODg2NCw2XSxbMTM0MjE3NzI4LDZdLFsxNjc3NzIxNjAsNl1dKSxlbz1bXSx0bz1lPT5NYXRoLmNlaWwoTnVtYmVyKGUpLzE2KSoxNixzbT1lPT57Zm9yKGxldCB0PTA7dDxlby5sZW5ndGg7dCsrKXtsZXQgcj1lb1t0XTtpZihlPD1yKXJldHVybiByfXJldHVybiBNYXRoLmNlaWwoZS8xNikqMTZ9LHVtPTEsWmE9KCk9PnVtKyssbm89YXN5bmMoZSx0LHIsbik9PntsZXQgbz10byhyKSxpPWUuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7c2l6ZTpvLHVzYWdlOkdQVUJ1ZmZlclVzYWdlLkNPUFlfRFNUfEdQVUJ1ZmZlclVzYWdlLk1BUF9SRUFEfSk7dHJ5e2xldCBhPWUuZ2V0Q29tbWFuZEVuY29kZXIoKTtlLmVuZENvbXB1dGVQYXNzKCksYS5jb3B5QnVmZmVyVG9CdWZmZXIodCwwLGksMCxvKSxlLmZsdXNoKCksYXdhaXQgaS5tYXBBc3luYyhHUFVNYXBNb2RlLlJFQUQpO2xldCBkPWkuZ2V0TWFwcGVkUmFuZ2UoKTtpZihuKXtsZXQgbD1uKCk7cmV0dXJuIGwuc2V0KG5ldyBVaW50OEFycmF5KGQsMCxyKSksbH1lbHNlIHJldHVybiBuZXcgVWludDhBcnJheShkLnNsaWNlKDAscikpfWZpbmFsbHl7aS5kZXN0cm95KCl9fSxybz1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLmJhY2tlbmQ9dDt0aGlzLnN0b3JhZ2VDYWNoZT1uZXcgTWFwLHRoaXMuZnJlZUJ1ZmZlcnM9bmV3IE1hcCx0aGlzLmZyZWVVbmlmb3JtQnVmZmVycz1uZXcgTWFwLHRoaXMuYnVmZmVyc1BlbmRpbmc9W10sdGhpcy5jYXB0dXJlZFBlbmRpbmdCdWZmZXJzPW5ldyBNYXA7Zm9yKGxldFtyXW9mIFlhKWVvLnB1c2gociksdGhpcy5mcmVlQnVmZmVycy5zZXQocixbXSksdGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnMuc2V0KHIsW10pO3RoaXMuc2Vzc2lvbkNvdW50PTB9dXBsb2FkKHQscil7bGV0IG49ci5idWZmZXIsbz1yLmJ5dGVPZmZzZXQsaT1yLmJ5dGVMZW5ndGgsYT10byhpKSxkPXRoaXMuc3RvcmFnZUNhY2hlLmdldCh0KTtpZighZCl0aHJvdyBuZXcgRXJyb3IoXCJncHUgZGF0YSBmb3IgdXBsb2FkaW5nIGRvZXMgbm90IGV4aXN0XCIpO2lmKE51bWJlcihkLm9yaWdpbmFsU2l6ZSkhPT1pKXRocm93IG5ldyBFcnJvcihgaW5jb25zaXN0ZW50IGRhdGEgc2l6ZS4gZ3B1IGRhdGEgc2l6ZT0ke2Qub3JpZ2luYWxTaXplfSwgZGF0YSBzaXplPSR7aX1gKTtsZXQgbD10aGlzLmJhY2tlbmQuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7bWFwcGVkQXRDcmVhdGlvbjohMCxzaXplOmEsdXNhZ2U6R1BVQnVmZmVyVXNhZ2UuTUFQX1dSSVRFfEdQVUJ1ZmZlclVzYWdlLkNPUFlfU1JDfSkscD1sLmdldE1hcHBlZFJhbmdlKCk7bmV3IFVpbnQ4QXJyYXkocCkuc2V0KG5ldyBVaW50OEFycmF5KG4sbyxpKSksbC51bm1hcCgpO2xldCBtPXRoaXMuYmFja2VuZC5kZXZpY2UuY3JlYXRlQ29tbWFuZEVuY29kZXIoKTttLmNvcHlCdWZmZXJUb0J1ZmZlcihsLDAsZC5ncHVEYXRhLmJ1ZmZlciwwLGEpLHRoaXMuYmFja2VuZC5kZXZpY2UucXVldWUuc3VibWl0KFttLmZpbmlzaCgpXSksbC5kZXN0cm95KCksdWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci51cGxvYWQoaWQ9JHt0fSlgKX1tZW1jcHkodCxyKXtsZXQgbj10aGlzLnN0b3JhZ2VDYWNoZS5nZXQodCk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwic291cmNlIGdwdSBkYXRhIGZvciBtZW1jcHkgZG9lcyBub3QgZXhpc3RcIik7bGV0IG89dGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KHIpO2lmKCFvKXRocm93IG5ldyBFcnJvcihcImRlc3RpbmF0aW9uIGdwdSBkYXRhIGZvciBtZW1jcHkgZG9lcyBub3QgZXhpc3RcIik7aWYobi5vcmlnaW5hbFNpemUhPT1vLm9yaWdpbmFsU2l6ZSl0aHJvdyBuZXcgRXJyb3IoXCJpbmNvbnNpc3RlbnQgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBncHUgZGF0YSBzaXplXCIpO2xldCBpPXRvKG4ub3JpZ2luYWxTaXplKSxhPXRoaXMuYmFja2VuZC5nZXRDb21tYW5kRW5jb2RlcigpO3RoaXMuYmFja2VuZC5lbmRDb21wdXRlUGFzcygpLGEuY29weUJ1ZmZlclRvQnVmZmVyKG4uZ3B1RGF0YS5idWZmZXIsMCxvLmdwdURhdGEuYnVmZmVyLDAsaSl9cmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcih0LHIsbil7bGV0IG87aWYobil7aWYobz1uWzBdLHQ9PT1uWzFdKXJldHVybiB1ZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoc2l6ZT0ke3J9KSA9PiBpZD0ke299LCBidWZmZXIgaXMgdGhlIHNhbWUsIHNraXAuYCksbztpZih0aGlzLmJhY2tlbmQuY2FwdHVyZWRDb21tYW5kTGlzdC5oYXModGhpcy5iYWNrZW5kLmN1cnJlbnRTZXNzaW9uSWQpKXRocm93IG5ldyBFcnJvcihgUmVnaXN0ZXJpbmcgYSBkaWZmZXJlbnQgZXh0ZXJuYWwgYnVmZmVyIHVuZGVyIGdyYXBoIGNhcHR1cmUgbW9kZSBpcyBub3Qgc3VwcG9ydGVkIHlldC5cbiAgICAgICAgICAgICBQbGVhc2UgdXNlIHRoZSBwcmV2aW91cyBleHRlcm5hbCBidWZmZXIhYCl9ZWxzZSBvPVphKCk7cmV0dXJuIHRoaXMuc3RvcmFnZUNhY2hlLnNldChvLHtncHVEYXRhOntpZDpvLHR5cGU6MCxidWZmZXI6dH0sb3JpZ2luYWxTaXplOnJ9KSx1ZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoc2l6ZT0ke3J9KSA9PiBpZD0ke299LCByZWdpc3RlcmVkLmApLG99dW5yZWdpc3RlckV4dGVybmFsQnVmZmVyKHQpe3QhPT12b2lkIDAmJih0aGlzLnN0b3JhZ2VDYWNoZS5kZWxldGUodCksdWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci51bnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoKSA9PiBpZD0ke3R9YCkpfWNyZWF0ZSh0LHI9R1BVQnVmZmVyVXNhZ2UuU1RPUkFHRXxHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQ3xHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVCl7bGV0IG49c20odCksbyxpPShyJkdQVUJ1ZmZlclVzYWdlLlNUT1JBR0UpPT09R1BVQnVmZmVyVXNhZ2UuU1RPUkFHRSxhPShyJkdQVUJ1ZmZlclVzYWdlLlVOSUZPUk0pPT09R1BVQnVmZmVyVXNhZ2UuVU5JRk9STTtpZihpfHxhKXtsZXQgcD0oaT90aGlzLmZyZWVCdWZmZXJzOnRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzKS5nZXQobik7cD9wLmxlbmd0aD4wP289cC5wb3AoKTpvPXRoaXMuYmFja2VuZC5kZXZpY2UuY3JlYXRlQnVmZmVyKHtzaXplOm4sdXNhZ2U6cn0pOm89dGhpcy5iYWNrZW5kLmRldmljZS5jcmVhdGVCdWZmZXIoe3NpemU6bix1c2FnZTpyfSl9ZWxzZSBvPXRoaXMuYmFja2VuZC5kZXZpY2UuY3JlYXRlQnVmZmVyKHtzaXplOm4sdXNhZ2U6cn0pO2xldCBkPXtpZDpaYSgpLHR5cGU6MCxidWZmZXI6b307cmV0dXJuIHRoaXMuc3RvcmFnZUNhY2hlLnNldChkLmlkLHtncHVEYXRhOmQsb3JpZ2luYWxTaXplOk51bWJlcih0KX0pLHVlKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIuY3JlYXRlKHNpemU9JHt0fSkgPT4gaWQ9JHtkLmlkfWApLGR9Z2V0KHQpe3JldHVybiB0aGlzLnN0b3JhZ2VDYWNoZS5nZXQodCk/LmdwdURhdGF9cmVsZWFzZSh0KXtsZXQgcj10eXBlb2YgdD09XCJiaWdpbnRcIj9OdW1iZXIodCk6dCxuPXRoaXMuc3RvcmFnZUNhY2hlLmdldChyKTtpZighbil7aWYodGhpcy5zdG9yYWdlQ2FjaGUuc2l6ZT09PTApcmV0dXJuIDA7dGhyb3cgbmV3IEVycm9yKFwicmVsZWFzaW5nIGRhdGEgZG9lcyBub3QgZXhpc3RcIil9cmV0dXJuIHVlKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIucmVsZWFzZShpZD0ke3J9KSwgZ3B1RGF0YUlkPSR7bi5ncHVEYXRhLmlkfWApLHRoaXMuc3RvcmFnZUNhY2hlLmRlbGV0ZShyKSx0aGlzLmJ1ZmZlcnNQZW5kaW5nLnB1c2gobi5ncHVEYXRhLmJ1ZmZlciksbi5vcmlnaW5hbFNpemV9YXN5bmMgZG93bmxvYWQodCxyKXtsZXQgbj10aGlzLnN0b3JhZ2VDYWNoZS5nZXQoTnVtYmVyKHQpKTtpZighbil0aHJvdyBuZXcgRXJyb3IoXCJkYXRhIGRvZXMgbm90IGV4aXN0XCIpO2F3YWl0IG5vKHRoaXMuYmFja2VuZCxuLmdwdURhdGEuYnVmZmVyLG4ub3JpZ2luYWxTaXplLHIpfXJlZnJlc2hQZW5kaW5nQnVmZmVycygpe2lmKHRoaXMuYnVmZmVyc1BlbmRpbmcubGVuZ3RoIT09MClpZih0aGlzLmJhY2tlbmQuc2Vzc2lvblN0YXR1cz09PVwiZGVmYXVsdFwiKXtmb3IobGV0IHQgb2YgdGhpcy5idWZmZXJzUGVuZGluZyl7bGV0IHI9WWEuZ2V0KHQuc2l6ZSk7aWYoKHQudXNhZ2UmR1BVQnVmZmVyVXNhZ2UuU1RPUkFHRSk9PT1HUFVCdWZmZXJVc2FnZS5TVE9SQUdFKXtsZXQgbj10aGlzLmZyZWVCdWZmZXJzLmdldCh0LnNpemUpfHxbXTtyPT09dm9pZCAwfHxuLmxlbmd0aD49cj90LmRlc3Ryb3koKTpuLnB1c2godCl9ZWxzZSBpZigodC51c2FnZSZHUFVCdWZmZXJVc2FnZS5VTklGT1JNKT09PUdQVUJ1ZmZlclVzYWdlLlVOSUZPUk0pe2xldCBuPXRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzLmdldCh0LnNpemUpfHxbXTtyPT09dm9pZCAwfHxuLmxlbmd0aD49cj90LmRlc3Ryb3koKTpuLnB1c2godCl9ZWxzZSB0LmRlc3Ryb3koKX10aGlzLmJ1ZmZlcnNQZW5kaW5nPVtdfWVsc2V7bGV0IHQ9dGhpcy5jYXB0dXJlZFBlbmRpbmdCdWZmZXJzLmdldCh0aGlzLmJhY2tlbmQuY3VycmVudFNlc3Npb25JZCk7dHx8KHQ9W10sdGhpcy5jYXB0dXJlZFBlbmRpbmdCdWZmZXJzLnNldCh0aGlzLmJhY2tlbmQuY3VycmVudFNlc3Npb25JZCx0KSk7Zm9yKGxldCByIG9mIHRoaXMuYnVmZmVyc1BlbmRpbmcpdC5wdXNoKHIpO3RoaXMuYnVmZmVyc1BlbmRpbmc9W119fWRpc3Bvc2UoKXt0aGlzLmZyZWVCdWZmZXJzLmZvckVhY2godD0+e3QuZm9yRWFjaChyPT57ci5kZXN0cm95KCl9KX0pLHRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzLmZvckVhY2godD0+e3QuZm9yRWFjaChyPT57ci5kZXN0cm95KCl9KX0pLHRoaXMuc3RvcmFnZUNhY2hlLmZvckVhY2godD0+e3QuZ3B1RGF0YS5idWZmZXIuZGVzdHJveSgpfSksdGhpcy5jYXB0dXJlZFBlbmRpbmdCdWZmZXJzLmZvckVhY2godD0+e3QuZm9yRWFjaChyPT57ci5kZXN0cm95KCl9KX0pLHRoaXMuc3RvcmFnZUNhY2hlPW5ldyBNYXAsdGhpcy5mcmVlQnVmZmVycz1uZXcgTWFwLHRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzPW5ldyBNYXAsdGhpcy5jYXB0dXJlZFBlbmRpbmdCdWZmZXJzPW5ldyBNYXB9b25DcmVhdGVTZXNzaW9uKCl7dGhpcy5zZXNzaW9uQ291bnQrPTF9b25SZWxlYXNlU2Vzc2lvbih0KXtsZXQgcj10aGlzLmNhcHR1cmVkUGVuZGluZ0J1ZmZlcnMuZ2V0KHQpO3ImJihyLmZvckVhY2gobj0+e24uZGVzdHJveSgpfSksdGhpcy5jYXB0dXJlZFBlbmRpbmdCdWZmZXJzLmRlbGV0ZSh0KSksdGhpcy5zZXNzaW9uQ291bnQtPTEsdGhpcy5zZXNzaW9uQ291bnQ9PT0wJiYodWUoXCJ3YXJuaW5nXCIsKCk9PlwiW1dlYkdQVV0gQ2xlYXJpbmcgd2ViZ3B1IGJ1ZmZlciBjYWNoZVwiKSx0aGlzLnN0b3JhZ2VDYWNoZS5mb3JFYWNoKG49PntuLmdwdURhdGEuYnVmZmVyLmRlc3Ryb3koKX0pLHRoaXMuc3RvcmFnZUNhY2hlPW5ldyBNYXApfX0sWGE9KC4uLmUpPT5uZXcgcm8oLi4uZSl9KTt2YXIgb28scmUsU2U9VSgoKT0+e1widXNlIHN0cmljdFwiO29vPWNsYXNze2NvbnN0cnVjdG9yKHQpe09iamVjdC5hc3NpZ24odGhpcyx0KX1nZXQgY2FjaGVLZXkoKXtyZXR1cm4gdGhpcy5rZXl8fCh0aGlzLmtleT1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKS5zb3J0KCkubWFwKHQ9PmAke3RoaXNbdF19YCkuam9pbihcIjtcIikpLHRoaXMua2V5fX0scmU9ZT0+bmV3IG9vKGUpfSk7dmFyIGlvLHR0LEMsQXQsVnIsZXMsdHMsb2U9VSgoKT0+e1widXNlIHN0cmljdFwiO2lvPWNsYXNze3N0YXRpYyBjYWxjTWF0TXVsU2hhcGUodCxyKXtyZXR1cm4gdFsxXSE9PXJbMF0/dm9pZCAwOlt0WzBdLHJbMV1dfX0sdHQ9Y2xhc3N7c3RhdGljIGNhbGNTaGFwZSh0LHIsbj0hMSl7bGV0IG89dC5sZW5ndGgsaT1yLmxlbmd0aDtpZihvPT09MClyZXR1cm4gcjtpZihpPT09MClyZXR1cm4gdDtsZXQgYT1NYXRoLm1heCh0Lmxlbmd0aCxyLmxlbmd0aCksZD1uZXcgQXJyYXkoYSk7aWYobil7aWYobzwyfHxpPDIpcmV0dXJuO2xldCBsPWlvLmNhbGNNYXRNdWxTaGFwZShbdFtvLTJdLHRbby0xXV0sW3JbaS0yXSxyW2ktMV1dKTtpZihsPT09dm9pZCAwKXJldHVybjtbZFthLTJdLGRbYS0xXV09bH1mb3IobGV0IGw9bj8zOjE7bDw9YTtsKyspe2xldCBwPW8tbDwwPzE6dFtvLWxdLG09aS1sPDA/MTpyW2ktbF07aWYocCE9PW0mJnA+MSYmbT4xKXJldHVybjtsZXQgdT1NYXRoLm1heChwLG0pO2lmKHAmJm0pZFthLWxdPU1hdGgubWF4KHAsbSk7ZWxzZXtpZih1PjEpcmV0dXJuO2RbYS1sXT0wfX1yZXR1cm4gZH1zdGF0aWMgaXNWYWxpZEJyb2FkY2FzdCh0LHIpe2xldCBuPXQubGVuZ3RoLG89ci5sZW5ndGg7aWYobj5vKXJldHVybiExO2ZvcihsZXQgaT0xO2k8PW47aSsrKWlmKHRbbi1pXSE9PTEmJnRbbi1pXSE9PXJbby1pXSlyZXR1cm4hMTtyZXR1cm4hMH19LEM9Y2xhc3MgZXtzdGF0aWMgc2l6ZSh0KXtyZXR1cm4gZS5nZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKHQsMCx0Lmxlbmd0aCl9c3RhdGljIGNvbnZlcnRTaGFwZSh0LHI9NCl7bGV0IG49dC5sZW5ndGg7aWYobj09PTApcmV0dXJuW107bGV0IG89bmV3IEFycmF5KG4pLGk9bi0xO2Zvcig7aT49MDspe2lmKHRbaV0lcj09PTApe29baV09dFtpXS9yO2JyZWFrfWlmKHIldFtpXSE9PTApdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGNvbnZlcnQgc2hhcGVcIik7b1tpXT0xLHIvPXRbaV0saS0tfWZvcihpLS07aT49MDtpLS0pb1tpXT10W2ldO3JldHVybiBvfXN0YXRpYyBzaXplRnJvbURpbWVuc2lvbih0LHIpe2lmKHI8MHx8cj50Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGltZW5zaW9uIG9mICR7cn0gZm9yIHNpemVGcm9tRGltZW5zaW9uIGFzIFRlbnNvciBoYXMgJHt0Lmxlbmd0aH0gZGltZW5zaW9ucy5gKTtyZXR1cm4gZS5nZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKHQscix0Lmxlbmd0aCl9c3RhdGljIHNpemVUb0RpbWVuc2lvbih0LHIpe2lmKHI8MHx8cj50Lmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGltZW5zaW9uIG9mICR7cn0gZm9yIHNpemVUb0RpbWVuc2lvbiBhcyBUZW5zb3IgaGFzICR7dC5sZW5ndGh9IGRpbWVuc2lvbnMuYCk7cmV0dXJuIGUuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZSh0LDAscil9c3RhdGljIGdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UodCxyLG4pe2xldCBvPTE7Zm9yKGxldCBpPXI7aTxuO2krKyl7aWYodFtpXTwwKXRocm93IG5ldyBFcnJvcihcImNhbm5vdCBnZXQgdmFsaWQgc2l6ZSBmcm9tIHNwZWNpZmllZCBkaW1lbnNpb24gcmFuZ2UuIE1vc3QgbGlrZWx5IHRoZSByYW5nZSBjb250YWlucyBuZWdhdGl2ZSB2YWx1ZXMgaW4gdGhlbS5cIik7byo9TnVtYmVyKHRbaV0pfXJldHVybiBvfXN0YXRpYyBjb21wdXRlU3RyaWRlcyh0KXtsZXQgcj10Lmxlbmd0aDtpZihyPT09MClyZXR1cm5bXTtpZihyPT09MSlyZXR1cm5bMV07bGV0IG49bmV3IEFycmF5KHIpO25bci0xXT0xLG5bci0yXT10W3ItMV07Zm9yKGxldCBvPXItMztvPj0wOy0tbyluW29dPW5bbysxXSp0W28rMV07cmV0dXJuIG59c3RhdGljIG5vcm1hbGl6ZUF4aXModCxyKXtpZih0PC1yJiZ0Pj1yKXRocm93IG5ldyBFcnJvcihcInVuc3VwcG9ydGVkIGF4aXMgZm9yIHRoaXMgb3BlcmF0aW9uLlwiKTtyZXR1cm4gdDwwP3Qrcjp0fXN0YXRpYyBub3JtYWxpemVBeGVzKHQscil7cmV0dXJuIHQubWFwKG49PnRoaXMubm9ybWFsaXplQXhpcyhuLHI/P3QubGVuZ3RoKSl9c3RhdGljIHNvcnRCYXNlZE9uUGVybSh0LHIpe3JldHVybiByP3IubWFwKG49PnRbbl0pOnQuc2xpY2UoKS5yZXZlcnNlKCl9c3RhdGljIHBhZFNoYXBlKHQscil7bGV0IG49dC5sZW5ndGg7cmV0dXJuIHQubWFwKChvLGkpPT5vK3JbaV0rcltpK25dKX1zdGF0aWMgYXJlRXF1YWwodCxyKXtyZXR1cm4gdC5sZW5ndGghPT1yLmxlbmd0aD8hMTp0LmV2ZXJ5KChuLG8pPT5uPT09cltvXSl9fSxBdD1jbGFzcyBle3N0YXRpYyBhZGp1c3RQb29sQXR0cmlidXRlcyh0LHIsbixvLGksYSl7aWYoIXQmJm4ubGVuZ3RoIT09ci5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggb2Ygc3BlY2lmaWVkIGtlcm5lbCBzaGFwZXMgc2hvdWxkIGJlIDIgbGVzcyB0aGFuIGxlbmd0aCBvZiBpbnB1dCBkaW1lbnNpb25zXCIpO2lmKHQpZm9yKGxldCBkPTA7ZDxyLmxlbmd0aC0yO2QrKylkPj1uLmxlbmd0aD9uLnB1c2gocltkKzJdKTpuW2RdPXJbZCsyXTtmb3IobGV0IGQ9MDtkPG4ubGVuZ3RoO2QrKylpZihkPG8ubGVuZ3RoKXtpZihvW2RdPDApdGhyb3cgbmV3IEVycm9yKFwic3RyaWRlcyBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDFcIil9ZWxzZSBvLnB1c2goMSk7Zm9yKGxldCBkPTA7ZDxuLmxlbmd0aDtkKyspaWYoZDxpLmxlbmd0aCl7aWYoaVtkXTwwKXRocm93IG5ldyBFcnJvcihcImRpbGF0aW9ucyBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDFcIil9ZWxzZSBpLnB1c2goMSk7Zm9yKGxldCBkPTA7ZDxuLmxlbmd0aCoyO2QrKylpZihkPGEubGVuZ3RoKXtpZihhW2RdPDApdGhyb3cgbmV3IEVycm9yKFwicGFkIHNob3VsZCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMVwiKX1lbHNlIGEucHVzaCgwKTtmb3IobGV0IGQ9MDtkPG4ubGVuZ3RoO2QrKyl7aWYobltkXTw9MCl0aHJvdyBuZXcgRXJyb3IoXCJrZXJuZWwgc2hhcGVzIG5lZWQgdG8gYmUgZ3JlYXRlciB0aGFuIDBcIik7aWYoYVtkXT49bltkXXx8YVtkK24ubGVuZ3RoXT49bltkXSl0aHJvdyBuZXcgRXJyb3IoXCJwYWRzIHNob3VsZCBiZSBzbWFsbGVyIHRoYW4ga2VybmVsXCIpfX1zdGF0aWMgYWRqdXN0UGFkc0Jhc2VkT25BdXRvUGFkKHQscixuLG8saSxhLGQpe2lmKGQpe2lmKGkubGVuZ3RoIT09MioodC5sZW5ndGgtMikpdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG9mIHBhZHMgc2hvdWxkIGJlIHR3aWNlIHRoZSBsZW5ndGggb2YgZGF0YSBkaW1lbnNpb25zXCIpO2lmKHIubGVuZ3RoIT09dC5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggb2Ygc3RyaWRlcyBzaG91bGQgYmUgdGhlIGxlbmd0aCBvZiBkYXRhIGRpbWVuc2lvbnNcIik7aWYoby5sZW5ndGghPT10Lmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImxlbmd0aCBvZiBrZXJuZWwgc2hhcGVzIHNob3VsZCBiZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9uc1wiKTtmb3IobGV0IGw9MDtsPHQubGVuZ3RoLTI7bCsrKWUuYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUodFtsKyhhPzE6MildLHJbbF0sbltsXSxvW2xdLGksbCxsK3QubGVuZ3RoLTIsZCl9fXN0YXRpYyBjb21wdXRlUG9vbE91dHB1dFNoYXBlKHQscixuLG8saSxhLGQpe2lmKHIubGVuZ3RoPD0wKXRocm93IG5ldyBFcnJvcihcImlucHV0IHNoYXBlIG11c3QgYmUgb2Ygc2l6ZSBncmVhdGVyIHRoYW4gMFwiKTtsZXQgbD1bclswXSxyWzFdXTtyZXR1cm4gZS5jb21wdXRlU2hhcGVIZWxwZXIodCxyLGwsbixvLGksYSxkKSxsfXN0YXRpYyBjb21wdXRlQ29udk91dHB1dFNoYXBlKHQscixuLG8saSxhLGQpe2lmKHQubGVuZ3RoPD0wfHxyLmxlbmd0aDw9MCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGlucHV0IHRlbnNvciBkaW1zIG9yIGludmFsaWQgZmlsdGVyIHRlbnNvciBkaW1zXCIpO2xldCBsPVt0WzBdLHJbMF1dO3JldHVybiBlLmNvbXB1dGVTaGFwZUhlbHBlcighMSx0LGwsbixvLGksYSxkKSxsfXN0YXRpYyBjb21wdXRlU2hhcGVIZWxwZXIodCxyLG4sbyxpLGEsZCxsKXtpZih0KWZvcihsZXQgcD0wO3A8ci5sZW5ndGgtMjtwKyspbi5wdXNoKDEpO2Vsc2UgZm9yKGxldCBwPTA7cDxyLmxlbmd0aC0yO3ArKyluLnB1c2goZS5hZGp1c3RQYWRBbmRSZXR1cm5TaGFwZShyW3ArMl0sb1twXSxpW3BdLGFbcF0sZCxwLHArci5sZW5ndGgtMixsKSl9c3RhdGljIGFkanVzdFBhZEFuZFJldHVyblNoYXBlKHQscixuLG8saSxhLGQsbCl7bGV0IHA9biooby0xKSsxO2lmKGwmJmwhPT1cIk5PVFNFVFwiKXN3aXRjaChsKXtjYXNlXCJWQUxJRFwiOnJldHVybiBpW2FdPTAsaVtkXT0wLE1hdGguZmxvb3IoKHQtcCkvcisxKTtjYXNlXCJTQU1FX0xPV0VSXCI6Y2FzZVwiU0FNRV9VUFBFUlwiOmlmKG4hPT0xKXRocm93IG5ldyBFcnJvcihcIkRpbGF0aW9uIG5vdCBzdXBwb3J0ZWQgZm9yIFNBTUVfVVBQRVIgb3IgU0FNRV9MT1dFUlwiKTt7bGV0IHU9KCh0K3ItMSkvci0xKSpyK28tdDtyZXR1cm4gaVthXT1NYXRoLmZsb29yKGw9PT1cIlNBTUVfTE9XRVJcIj8odSsxKS8yOnUvMiksaVtkXT11LWlbYV0sTWF0aC5mbG9vcigodCt1LW8pL3IrMSl9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBBdXRvUGFkIHR5cGVcIil9ZWxzZSByZXR1cm4gTWF0aC5mbG9vcigodCtpW2FdK2lbZF0tcCkvcisxKX19LFZyPWNsYXNze3N0YXRpYyBnZXRTaGFwZU9mR2VtbVJlc3VsdCh0LHIsbixvLGkpe2lmKHQubGVuZ3RoIT09Mnx8bi5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcInNoYXBlIG5lZWQgdG8gYmUgb2Ygc2l6ZSAyXCIpO2xldCBhLGQsbDtyPyhhPXRbMV0sZD10WzBdKTooYT10WzBdLGQ9dFsxXSk7bGV0IHA9LTE7aWYobz8obD1uWzBdLHA9MSk6KGw9blsxXSxwPTApLG5bcF0hPT1kKXRocm93IG5ldyBFcnJvcihcImRpbWVuc2lvbiBtaXNtYXRjaFwiKTtpZihhPD0wfHxsPD0wfHxkPD0wKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgc2hhcGUgc3BlY2lmaWVkXCIpO2lmKGkmJiF0dC5pc1ZhbGlkQnJvYWRjYXN0KGksW2EsbF0pKXRocm93IG5ldyBFcnJvcihcImdlbW06IGludmFsaWQgYmlhcyBzaGFwZSBmb3IgYnJvYWRjYXN0XCIpO3JldHVyblthLGwsZF19fSxlcz0tMzQwMjgyMzQ2NjM4NTI4ODZlMjIsdHM9MzQwMjgyMzQ2NjM4NTI4ODZlMjJ9KTt2YXIga3Qsc28sX2UsRWUsTixtZSx1byxFdCxGZSxGLFdyLEUsTSxycyxMcixhbyxucyxhZT1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtvZSgpO2t0PTY0LHNvPShlLHQpPT57aWYodD09PTMpdGhyb3cgbmV3IEVycm9yKFwidmVjMyBoYXMgc2FtZSBhbGlnbm1lbnQgYXMgdmVjNCwgdXNlIHZlYzQgaW5zdGVhZFwiKTtzd2l0Y2goTnVtYmVyKGUpKXtjYXNlIDEwOnJldHVybiB0PjE/YHZlYyR7dH08ZjE2PmA6XCJmMTZcIjtjYXNlIDE6cmV0dXJuIHQ+MT9gdmVjJHt0fTxmMzI+YDpcImYzMlwiO2Nhc2UgNjpyZXR1cm4gdD4xP2B2ZWMke3R9PGkzMj5gOlwiaTMyXCI7Y2FzZSAxMjpyZXR1cm4gdD4xP2B2ZWMke3R9PHUzMj5gOlwidTMyXCI7Y2FzZSA3OmlmKHQ+MSl0aHJvdyBuZXcgRXJyb3IoXCJjdXJyZW50bHkgbm90IHN1cHBvcnRlZCB2ZWNYIG9mIHVpbnQ2NCB5ZXRcIik7cmV0dXJuW1widmVjMjx1MzI+XCIsXCJpMzJcIl07Y2FzZSAxMzppZih0PjEpdGhyb3cgbmV3IEVycm9yKFwiY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQgdmVjWCBvZiB1aW50NjQgeWV0XCIpO3JldHVybltcInZlYzI8dTMyPlwiLFwidTMyXCJdO2Nhc2UgOTppZih0IT09NCl0aHJvdyBuZXcgRXJyb3IoXCJib29sIG11c3QgYmUgdmVjNFwiKTtyZXR1cm5bXCJ1MzJcIixcInZlYzQ8Ym9vbD5cIl07Y2FzZSAyMjpyZXR1cm5cImkzMlwiO2Nhc2UgMjE6cmV0dXJuXCJ1MzJcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVW5rbm93biBkYXRhIHR5cGU6ICR7ZX1gKX19LF9lPShlLHQ9MSk9PntsZXQgcj1zbyhlLHQpO3JldHVybiB0eXBlb2Ygcj09XCJzdHJpbmdcIj9yOnJbMF19LEVlPShlLHQ9MSk9PntsZXQgcj1zbyhlLHQpO3JldHVybiB0eXBlb2Ygcj09XCJzdHJpbmdcIj9yOnJbMV19LE49KC4uLmUpPT57bGV0IHQ9W107cmV0dXJuIGUuZm9yRWFjaChyPT57ci5sZW5ndGghPT0wJiZ0LnB1c2goe3R5cGU6MTIsZGF0YTpyfSx7dHlwZToxMixkYXRhOkMuY29tcHV0ZVN0cmlkZXMocil9KX0pLHR9LG1lPWU9PmUlND09PTA/NDplJTI9PT0wPzI6MSx1bz0oZT1cImYzMlwiLHQscj1cIjBcIik9PiF0fHx0PT09MT9gJHtlfSgke3J9KWA6YHZlYyR7dH08JHtlfT4oJHtyfSlgLEV0PShlLHQscik9PmU9PT1cImYzMlwiP3I6dD09PTE/YGYzMigke3J9KWA6YHZlYyR7dH08ZjMyPigke3J9KWAsRmU9KGUsdCk9PnQ9PT00P2AoJHtlfS54ICsgJHtlfS55ICsgJHtlfS56ICsgJHtlfS53KWA6dD09PTI/YCgke2V9LnggKyAke2V9LnkpYDp0PT09Mz9gKCR7ZX0ueCArICR7ZX0ueSArICR7ZX0ueilgOmUsRj0oZSx0LHIsbik9PmUuc3RhcnRzV2l0aChcInVuaWZvcm1zLlwiKSYmcj40P3R5cGVvZiB0PT1cInN0cmluZ1wiP249PT1cImYxNlwiP2Ake2V9Wygke3R9KSAvIDhdWygke3R9KSAlIDggLyA0XVsoJHt0fSkgJSA4ICUgNF1gOmAke2V9Wygke3R9KSAvIDRdWygke3R9KSAlIDRdYDpuPT09XCJmMTZcIj9gJHtlfVske01hdGguZmxvb3IodC84KX1dWyR7TWF0aC5mbG9vcih0JTgvNCl9XVske3QlOCU0fV1gOmAke2V9WyR7TWF0aC5mbG9vcih0LzQpfV1bJHt0JTR9XWA6cj4xP2Ake2V9WyR7dH1dYDplLFdyPShlLHQscixuLG8pPT57bGV0IGk9dHlwZW9mIHI9PVwibnVtYmVyXCIsYT1pP3I6ci5sZW5ndGgsZD1bLi4ubmV3IEFycmF5KGEpLmtleXMoKV0sbD1hPDI/XCJ1MzJcIjphPD00P2B2ZWMke2F9PHUzMj5gOmBhcnJheTx1MzIsICR7YX0+YCxwPXNvKHQsbyksbT10eXBlb2YgcD09XCJzdHJpbmdcIj9wOnBbMV0sdT10eXBlb2YgcD09XCJzdHJpbmdcIj9wOnBbMF0saD17aW5kaWNlczpsLHZhbHVlOm0sc3RvcmFnZTp1LHRlbnNvcjp0fSxfPVc9PnR5cGVvZiBXPT1cInN0cmluZ1wiP1c6YCR7V311YCx5PXtvZmZzZXRUb0luZGljZXM6ITEsaW5kaWNlc1RvT2Zmc2V0OiExLGJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0OiExLHNldDohMSxzZXRCeUluZGljZXM6ITEsZ2V0OiExLGdldEJ5SW5kaWNlczohMX0sZz1pP1widW5pZm9ybXMuXCI6XCJcIix4PWAke2d9JHtlfV9zaGFwZWAsJD1gJHtnfSR7ZX1fc3RyaWRlc2Asdj1cIlwiO2ZvcihsZXQgVz0wO1c8YS0xO1crKyl2Kz1gXG4gICAgbGV0IGRpbSR7V30gPSBjdXJyZW50IC8gJHtGKCQsVyxhKX07XG4gICAgbGV0IHJlc3Qke1d9ID0gY3VycmVudCAlICR7RigkLFcsYSl9O1xuICAgIGluZGljZXNbJHtXfV0gPSBkaW0ke1d9O1xuICAgIGN1cnJlbnQgPSByZXN0JHtXfTtcbiAgICBgO3YrPWBpbmRpY2VzWyR7YS0xfV0gPSBjdXJyZW50O2A7bGV0IFM9YTwyP1wiXCI6YFxuICBmbiBvMmlfJHtlfShvZmZzZXQ6IHUzMikgLT4gJHtoLmluZGljZXN9IHtcbiAgICB2YXIgaW5kaWNlczogJHtoLmluZGljZXN9O1xuICAgIHZhciBjdXJyZW50ID0gb2Zmc2V0O1xuICAgICR7dn1cbiAgICByZXR1cm4gaW5kaWNlcztcbiAgfWAsVD1XPT4oeS5vZmZzZXRUb0luZGljZXM9ITAsYTwyP1c6YG8yaV8ke2V9KCR7V30pYCksQT1bXTtpZihhPj0yKWZvcihsZXQgVz1hLTE7Vz49MDtXLS0pQS5wdXNoKGAke0YoJCxXLGEpfSAqIChpbmRpY2VzWyR7V31dKWApO2xldCBrPWE8Mj9cIlwiOmBcbiAgZm4gaTJvXyR7ZX0oaW5kaWNlczogJHtoLmluZGljZXN9KSAtPiB1MzIge1xuICAgIHJldHVybiAke0Euam9pbihcIitcIil9O1xuICB9YCxQPVc9Pih5LmluZGljZXNUb09mZnNldD0hMCxhPDI/VzpgaTJvXyR7ZX0oJHtXfSlgKSxEPSguLi5XKT0+YT09PTA/XCIwdVwiOmAke2guaW5kaWNlc30oJHtXLm1hcChfKS5qb2luKFwiLFwiKX0pYCxSPShXLHEpPT5hPDI/YCR7V31gOmAke0YoVyxxLGEpfWAsRz0oVyxxLGhlKT0+YTwyP2Ake1d9PSR7aGV9O2A6YCR7RihXLHEsYSl9PSR7aGV9O2AsSz17fSxqPShXLHEpPT57eS5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldD0hMDtsZXQgaGU9YCR7cS5uYW1lfWJyb2FkY2FzdGVkSW5kaWNlc1RvJHtlfU9mZnNldGA7aWYoaGUgaW4gSylyZXR1cm5gJHtoZX0oJHtXfSlgO2xldCBHZT1bXTtmb3IobGV0IHdlPWEtMTt3ZT49MDt3ZS0tKXtsZXQgeWU9cS5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLHdlK3EucmFuay1hKTtHZS5wdXNoKGAke1IoJCx3ZSl9ICogKCR7eWV9ICUgJHtSKHgsd2UpfSlgKX1yZXR1cm4gS1toZV09YGZuICR7aGV9KG91dHB1dEluZGljZXM6ICR7cS50eXBlLmluZGljZXN9KSAtPiB1MzIge1xuICAgICAgICAgICAgIHJldHVybiAke0dlLmxlbmd0aD4wP0dlLmpvaW4oXCIrXCIpOlwiMHVcIn07XG4gICAgICAgICAgIH1gLGAke2hlfSgke1d9KWB9LFY9KFcscSk9PigoKT0+e2lmKGguc3RvcmFnZT09PWgudmFsdWUpcmV0dXJuYCR7ZX1bJHtXfV09JHtxfTtgO2lmKGguc3RvcmFnZT09PVwidmVjMjx1MzI+XCImJmgudmFsdWU9PT1cImkzMlwiKXJldHVybmAke2V9WyR7V31dPXZlYzI8dTMyPih1MzIoJHtxfSksIHNlbGVjdCgwdSwgMHhGRkZGRkZGRnUsICR7cX0gPCAwKSk7YDtpZihoLnN0b3JhZ2U9PT1cInZlYzI8dTMyPlwiJiZoLnZhbHVlPT09XCJ1MzJcIilyZXR1cm5gJHtlfVske1d9XT12ZWMyPHUzMj4odTMyKCR7cX0pLCAwdSk7YDtpZihoLnN0b3JhZ2U9PT1cInUzMlwiJiZoLnZhbHVlPT09XCJ2ZWM0PGJvb2w+XCIpcmV0dXJuYCR7ZX1bJHtXfV09ZG90KHZlYzQ8dTMyPigweDEsIDB4MTAwLCAweDEwMDAwLCAweDEwMDAwMDApLCB2ZWM0PHUzMj4oJHtxfSkpO2A7dGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIGNvbWJpbmF0aW9uIG9mIHN0b3JhZ2UgdHlwZSAke2guc3RvcmFnZX0gYW5kIHZhbHVlIHR5cGUgJHtoLnZhbHVlfSB5ZXRgKX0pKCksUT1XPT4oKCk9PntpZihoLnN0b3JhZ2U9PT1oLnZhbHVlKXJldHVybmAke2V9WyR7V31dYDtpZihoLnN0b3JhZ2U9PT1cInZlYzI8dTMyPlwiJiZoLnZhbHVlPT09XCJpMzJcIilyZXR1cm5gaTMyKCR7ZX1bJHtXfV0ueClgO2lmKGguc3RvcmFnZT09PVwidmVjMjx1MzI+XCImJmgudmFsdWU9PT1cInUzMlwiKXJldHVybmB1MzIoJHtlfVske1d9XS54KWA7aWYoaC5zdG9yYWdlPT09XCJ1MzJcIiYmaC52YWx1ZT09PVwidmVjNDxib29sPlwiKXJldHVybmB2ZWM0PGJvb2w+KGJvb2woJHtlfVske1d9XSAmIDB4RkZ1KSwgYm9vbCgke2V9WyR7V31dICYgMHhGRjAwdSksIGJvb2woJHtlfVske1d9XSAmIDB4RkYwMDAwdSksIGJvb2woJHtlfVske1d9XSAmIDB4RkYwMDAwMDB1KSlgO3Rocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBjb21iaW5hdGlvbiBvZiBzdG9yYWdlIHR5cGUgJHtoLnN0b3JhZ2V9IGFuZCB2YWx1ZSB0eXBlICR7aC52YWx1ZX0geWV0YCl9KSgpLHNlPWE8Mj9cIlwiOmBcbiAgZm4gZ2V0XyR7ZX1CeUluZGljZXMoaW5kaWNlczogJHtoLmluZGljZXN9KSAtPiAke219IHtcbiAgICByZXR1cm4gJHtRKGBpMm9fJHtlfShpbmRpY2VzKWApfTtcbiAgfWAsWT1hPDI/XCJcIjooKCk9PntsZXQgVz1kLm1hcChoZT0+YGQke2hlfTogdTMyYCkuam9pbihcIiwgXCIpLHE9ZC5tYXAoaGU9PmBkJHtoZX1gKS5qb2luKFwiLCBcIik7cmV0dXJuYFxuICBmbiBnZXRfJHtlfSgke1d9KSAtPiAke219IHtcbiAgICByZXR1cm4gZ2V0XyR7ZX1CeUluZGljZXMoJHtEKHEpfSk7XG4gIH1gfSkoKSxlZT0oLi4uVyk9PntpZihXLmxlbmd0aCE9PWEpdGhyb3cgbmV3IEVycm9yKGBpbmRpY2VzIGxlbmd0aCBtdXN0IGJlICR7YX1gKTtsZXQgcT1XLm1hcChfKS5qb2luKFwiLFwiKTtyZXR1cm4gYT09PTA/UShcIjB1XCIpOmE9PT0xP1EocVswXSk6KHkuZ2V0PSEwLHkuZ2V0QnlJbmRpY2VzPSEwLHkuaW5kaWNlc1RvT2Zmc2V0PSEwLGBnZXRfJHtlfSgke3F9KWApfSxKPVc9PmE8Mj9RKFcpOih5LmdldEJ5SW5kaWNlcz0hMCx5LmluZGljZXNUb09mZnNldD0hMCxgZ2V0XyR7ZX1CeUluZGljZXMoJHtXfSlgKSxuZT1hPDI/XCJcIjpgXG4gIGZuIHNldF8ke2V9QnlJbmRpY2VzKGluZGljZXM6ICR7aC5pbmRpY2VzfSwgdmFsdWU6ICR7bX0pIHtcbiAgICAke1YoYGkyb18ke2V9KGluZGljZXMpYCxcInZhbHVlXCIpfVxuICB9YCxiZT1hPDI/XCJcIjooKCk9PntsZXQgVz1kLm1hcChoZT0+YGQke2hlfTogdTMyYCkuam9pbihcIiwgXCIpLHE9ZC5tYXAoaGU9PmBkJHtoZX1gKS5qb2luKFwiLCBcIik7cmV0dXJuYFxuICBmbiBzZXRfJHtlfSgke1d9LCB2YWx1ZTogJHttfSkge1xuICAgIHNldF8ke2V9QnlJbmRpY2VzKCR7RChxKX0sIHZhbHVlKTtcbiAgfWB9KSgpO3JldHVybntpbXBsOigpPT57bGV0IFc9W10scT0hMTtyZXR1cm4geS5vZmZzZXRUb0luZGljZXMmJihXLnB1c2goUykscT0hMCkseS5pbmRpY2VzVG9PZmZzZXQmJihXLnB1c2goaykscT0hMCkseS5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldCYmKE9iamVjdC52YWx1ZXMoSykuZm9yRWFjaChoZT0+Vy5wdXNoKGhlKSkscT0hMCkseS5zZXQmJihXLnB1c2goYmUpLHE9ITApLHkuc2V0QnlJbmRpY2VzJiYoVy5wdXNoKG5lKSxxPSEwKSx5LmdldCYmKFcucHVzaChZKSxxPSEwKSx5LmdldEJ5SW5kaWNlcyYmKFcucHVzaChzZSkscT0hMCksIWkmJnEmJlcudW5zaGlmdChgY29uc3QgJHt4fSA9ICR7aC5pbmRpY2VzfSgke3Iuam9pbihcIixcIil9KTtgLGBjb25zdCAkeyR9ID0gJHtoLmluZGljZXN9KCR7Qy5jb21wdXRlU3RyaWRlcyhyKS5qb2luKFwiLFwiKX0pO2ApLFcuam9pbihgXG5gKX0sdHlwZTpoLG9mZnNldFRvSW5kaWNlczpULGluZGljZXNUb09mZnNldDpQLGJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0OmosaW5kaWNlczpELGluZGljZXNHZXQ6UixpbmRpY2VzU2V0Okcsc2V0OiguLi5XKT0+e2lmKFcubGVuZ3RoIT09YSsxKXRocm93IG5ldyBFcnJvcihgaW5kaWNlcyBsZW5ndGggbXVzdCBiZSAke2F9YCk7bGV0IHE9V1thXTtpZih0eXBlb2YgcSE9XCJzdHJpbmdcIil0aHJvdyBuZXcgRXJyb3IoXCJ2YWx1ZSBtdXN0IGJlIHN0cmluZ1wiKTtsZXQgaGU9Vy5zbGljZSgwLGEpLm1hcChfKS5qb2luKFwiLFwiKTtyZXR1cm4gYT09PTA/VihcIjB1XCIscSk6YT09PTE/VihoZVswXSxxKTooeS5zZXQ9ITAseS5zZXRCeUluZGljZXM9ITAseS5pbmRpY2VzVG9PZmZzZXQ9ITAsYHNldF8ke2V9KCR7aGV9LCAke3F9KWApfSxzZXRCeU9mZnNldDpWLHNldEJ5SW5kaWNlczooVyxxKT0+YTwyP1YoVyxxKTooeS5zZXRCeUluZGljZXM9ITAseS5pbmRpY2VzVG9PZmZzZXQ9ITAsYHNldF8ke2V9QnlJbmRpY2VzKCR7V30sICR7cX0pO2ApLGdldDplZSxnZXRCeU9mZnNldDpRLGdldEJ5SW5kaWNlczpKLHVzYWdlOm4sbmFtZTplLHN0cmlkZXM6JCxzaGFwZTp4LHJhbms6YX19LEU9KGUsdCxyLG49MSk9PldyKGUsdCxyLFwiaW5wdXRcIixuKSxNPShlLHQscixuPTEpPT5XcihlLHQscixcIm91dHB1dFwiLG4pLHJzPShlLHQscik9PldyKGUsdCxyLFwiYXRvbWljT3V0cHV0XCIsMSksTHI9KGUsdCxyLG49MSk9PldyKGUsdCxyLFwiaW50ZXJuYWxcIixuKSxhbz1jbGFzc3tjb25zdHJ1Y3Rvcih0LHIpe3RoaXMubm9ybWFsaXplZERpc3BhdGNoR3JvdXA9dDt0aGlzLmxpbWl0cz1yO3RoaXMuaW50ZXJuYWxWYXJpYWJsZXM9W107dGhpcy52YXJpYWJsZXM9W107dGhpcy51bmlmb3Jtcz1bXTt0aGlzLnZhcmlhYmxlSW5kZXg9MH1ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKHQpe3JldHVybmBpZiAoZ2xvYmFsX2lkeCA+PSAke3R5cGVvZiB0PT1cIm51bWJlclwiP2Ake3R9dWA6dH0pIHsgcmV0dXJuOyB9YH1tYWluU3RhcnQodD1rdCl7bGV0IHI9dHlwZW9mIHQ9PVwibnVtYmVyXCI/dDp0WzBdLG49dHlwZW9mIHQ9PVwibnVtYmVyXCI/MTp0WzFdLG89dHlwZW9mIHQ9PVwibnVtYmVyXCI/MTp0WzJdO2lmKHI+dGhpcy5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVYfHxuPnRoaXMubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWXx8bz50aGlzLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVopdGhyb3cgbmV3IEVycm9yKGB3b3JrZ3JvdXAgc2l6ZSBbJHtyfSwgJHtufSwgJHtvfV0gZXhjZWVkcyB0aGUgbWF4aW11bSB3b3JrZ3JvdXAgc2l6ZSBbJHt0aGlzLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVh9LCAke3RoaXMubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWX0sICR7dGhpcy5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVafV0uYCk7aWYocipuKm8+dGhpcy5saW1pdHMubWF4Q29tcHV0ZUludm9jYXRpb25zUGVyV29ya2dyb3VwKXRocm93IG5ldyBFcnJvcihgd29ya2dyb3VwIHNpemUgWyR7cn0sICR7bn0sICR7b31dIGV4Y2VlZHMgdGhlIG1heGltdW0gd29ya2dyb3VwIGludm9jYXRpb25zICR7dGhpcy5saW1pdHMubWF4Q29tcHV0ZUludm9jYXRpb25zUGVyV29ya2dyb3VwfS5gKTtsZXQgaT10aGlzLm5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwWzFdPT09MSYmdGhpcy5ub3JtYWxpemVkRGlzcGF0Y2hHcm91cFsyXT09PTEsYT1pP2BAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsX2lkIDogdmVjMzx1MzI+LFxuICAgIEBidWlsdGluKHdvcmtncm91cF9pZCkgd29ya2dyb3VwX2lkIDogdmVjMzx1MzI+LFxuICAgIEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faW5kZXgpIGxvY2FsX2lkeCA6IHUzMixcbiAgICBAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBsb2NhbF9pZCA6IHZlYzM8dTMyPmA6YEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnbG9iYWxfaWQgOiB2ZWMzPHUzMj4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBsb2NhbF9pZCA6IHZlYzM8dTMyPixcbiAgICBAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2luZGV4KSBsb2NhbF9pZHggOiB1MzIsXG4gICAgQGJ1aWx0aW4od29ya2dyb3VwX2lkKSB3b3JrZ3JvdXBfaWQgOiB2ZWMzPHUzMj4sXG4gICAgQGJ1aWx0aW4obnVtX3dvcmtncm91cHMpIG51bV93b3JrZ3JvdXBzIDogdmVjMzx1MzI+YCxkPWk/YGxldCBnbG9iYWxfaWR4ID0gZ2xvYmFsX2lkLng7XG4gICAgICAgICBsZXQgd29ya2dyb3VwX2luZGV4ID0gd29ya2dyb3VwX2lkLng7YDpgbGV0IHdvcmtncm91cF9pbmRleCA9IHdvcmtncm91cF9pZC56ICogbnVtX3dvcmtncm91cHNbMF0gKiBudW1fd29ya2dyb3Vwc1sxXSArXG4gICAgICAgICAgICAgd29ya2dyb3VwX2lkLnkgKiBudW1fd29ya2dyb3Vwc1swXSArIHdvcmtncm91cF9pZC54O1xuICAgICAgICAgbGV0IGdsb2JhbF9pZHggPSB3b3JrZ3JvdXBfaW5kZXggKiAke3IqbipvfXUgKyBsb2NhbF9pZHg7YDtyZXR1cm5gQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKCR7cn0sICR7bn0sICR7b30pXG4gIGZuIG1haW4oJHthfSkge1xuICAgICR7ZH1cbiAgYH1hcHBlbmRWYXJpYWJsZVVuaWZvcm1zKHQpe3QucmFuayE9PTAmJih0LnNoYXBlLnN0YXJ0c1dpdGgoXCJ1bmlmb3Jtcy5cIikmJnRoaXMudW5pZm9ybXMucHVzaCh7bmFtZTp0LnNoYXBlLnJlcGxhY2UoXCJ1bmlmb3Jtcy5cIixcIlwiKSx0eXBlOlwidTMyXCIsbGVuZ3RoOnQucmFua30pLHQuc3RyaWRlcy5zdGFydHNXaXRoKFwidW5pZm9ybXMuXCIpJiZ0aGlzLnVuaWZvcm1zLnB1c2goe25hbWU6dC5zdHJpZGVzLnJlcGxhY2UoXCJ1bmlmb3Jtcy5cIixcIlwiKSx0eXBlOlwidTMyXCIsbGVuZ3RoOnQucmFua30pKX1kZWNsYXJlVmFyaWFibGUodCxyKXtpZih0LnVzYWdlPT09XCJpbnRlcm5hbFwiKXRocm93IG5ldyBFcnJvcihcImNhbm5vdCB1c2UgaW50ZXJuYWwgdmFyaWFibGUgd2l0aCBkZWNsYXJlVmFyaWFibGUoKS4gdXNlIHJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZXMoKSBpbnN0ZWFkLlwiKTt0aGlzLnZhcmlhYmxlcy5wdXNoKHQpLHRoaXMuYXBwZW5kVmFyaWFibGVVbmlmb3Jtcyh0KTtsZXQgbj10LnVzYWdlPT09XCJpbnB1dFwiP1wicmVhZFwiOlwicmVhZF93cml0ZVwiLG89dC51c2FnZT09PVwiYXRvbWljT3V0cHV0XCI/XCJhdG9taWM8aTMyPlwiOnQudHlwZS5zdG9yYWdlO3JldHVybmBAZ3JvdXAoMCkgQGJpbmRpbmcoJHtyfSkgdmFyPHN0b3JhZ2UsICR7bn0+ICR7dC5uYW1lfTogYXJyYXk8JHtvfT47YH1kZWNsYXJlVmFyaWFibGVzKC4uLnQpe3JldHVybiB0Lm1hcChyPT50aGlzLmRlY2xhcmVWYXJpYWJsZShyLHRoaXMudmFyaWFibGVJbmRleCsrKSkuam9pbihgXG5gKX1yZWdpc3RlckludGVybmFsVmFyaWFibGUodCl7aWYodC51c2FnZSE9PVwiaW50ZXJuYWxcIil0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgdXNlIGlucHV0IG9yIG91dHB1dCB2YXJpYWJsZSB3aXRoIHJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZSgpLiB1c2UgZGVjbGFyZVZhcmlhYmxlcygpIGluc3RlYWQuXCIpO3RoaXMuaW50ZXJuYWxWYXJpYWJsZXMucHVzaCh0KSx0aGlzLmFwcGVuZFZhcmlhYmxlVW5pZm9ybXModCl9cmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlcyguLi50KXtyZXR1cm4gdC5mb3JFYWNoKHI9PnRoaXMucmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlKHIpKSx0aGlzfXJlZ2lzdGVyVW5pZm9ybSh0LHIsbj0xKXtyZXR1cm4gdGhpcy51bmlmb3Jtcy5wdXNoKHtuYW1lOnQsdHlwZTpyLGxlbmd0aDpufSksdGhpc31yZWdpc3RlclVuaWZvcm1zKHQpe3JldHVybiB0aGlzLnVuaWZvcm1zPXRoaXMudW5pZm9ybXMuY29uY2F0KHQpLHRoaXN9dW5pZm9ybURlY2xhcmF0aW9uKCl7aWYodGhpcy51bmlmb3Jtcy5sZW5ndGg9PT0wKXJldHVyblwiXCI7bGV0IHQ9W107Zm9yKGxldHtuYW1lOnIsdHlwZTpuLGxlbmd0aDpvfW9mIHRoaXMudW5pZm9ybXMpaWYobyYmbz40KW49PT1cImYxNlwiP3QucHVzaChgQGFsaWduKDE2KSAke3J9OmFycmF5PG1hdDJ4NDwke259PiwgJHtNYXRoLmNlaWwoby84KX0+YCk6dC5wdXNoKGAke3J9OmFycmF5PHZlYzQ8JHtufT4sICR7TWF0aC5jZWlsKG8vNCl9PmApO2Vsc2V7bGV0IGk9bz09bnVsbHx8bz09PTE/bjpgdmVjJHtvfTwke259PmA7dC5wdXNoKGAke3J9OiR7aX1gKX1yZXR1cm5gXG4gICAgICBzdHJ1Y3QgVW5pZm9ybXMgeyAke3Quam9pbihcIiwgXCIpfSB9O1xuICAgICAgQGdyb3VwKDApIEBiaW5kaW5nKCR7dGhpcy52YXJpYWJsZUluZGV4fSkgdmFyPHVuaWZvcm0+IHVuaWZvcm1zOiBVbmlmb3JtcztgfWdldCBhZGRpdGlvbmFsSW1wbGVtZW50YXRpb25zKCl7cmV0dXJuIHRoaXMudW5pZm9ybURlY2xhcmF0aW9uKCkrdGhpcy52YXJpYWJsZXMubWFwKHQ9PnQuaW1wbCgpKS5qb2luKGBcbmApK3RoaXMuaW50ZXJuYWxWYXJpYWJsZXMubWFwKHQ9PnQuaW1wbCgpKS5qb2luKGBcbmApfWdldCB2YXJpYWJsZXNJbmZvKCl7aWYodGhpcy51bmlmb3Jtcy5sZW5ndGg9PT0wKXJldHVybjtsZXQgdD1yPT5bMTIsMTAsMSw2XVtbXCJ1MzJcIixcImYxNlwiLFwiZjMyXCIsXCJpMzJcIl0uaW5kZXhPZihyKV07cmV0dXJuIHRoaXMudW5pZm9ybXMubWFwKHI9Plt0KHIudHlwZSksci5sZW5ndGg/PzFdKX19LG5zPShlLHQpPT5uZXcgYW8oZSx0KX0pO3ZhciBkbSxvcyxsbSxjbSxwbSxtbSxQZSxpcyxhcyxkdD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtvZSgpO1NlKCk7YWUoKTtkbT0oZSx0KT0+e2lmKCFlfHxlLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNwb3NlIHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKHQubGVuZ3RoIT09MCYmdC5sZW5ndGghPT1lWzBdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgcGVybSBzaXplICR7dC5sZW5ndGh9IGRvZXMgbm90IG1hdGNoIGlucHV0IHJhbmsgJHtlWzBdLmRpbXMubGVuZ3RofWApfSxvcz0oZSx0KT0+dC5sZW5ndGghPT0wP3Q6Wy4uLm5ldyBBcnJheShlKS5rZXlzKCldLnJldmVyc2UoKSxsbT0oZSx0KT0+Qy5zb3J0QmFzZWRPblBlcm0oZSxvcyhlLmxlbmd0aCx0KSksY209KGUsdCxyLG4pPT57bGV0IG89YGZuIHBlcm0oaTogJHtuLnR5cGUuaW5kaWNlc30pIC0+ICR7ci50eXBlLmluZGljZXN9IHtcbiAgICB2YXIgYTogJHtyLnR5cGUuaW5kaWNlc307YDtmb3IobGV0IGk9MDtpPHQ7KytpKW8rPWBhWyR7ZVtpXX1dPWlbJHtpfV07YDtyZXR1cm4gbys9XCJyZXR1cm4gYTt9XCJ9LHBtPShlLHQpPT57bGV0IHI9W10sbj1bXTtmb3IobGV0IG89MDtvPGUubGVuZ3RoOysrbyllW29dIT09MSYmci5wdXNoKGVbb10pLGVbdFtvXV0hPT0xJiZuLnB1c2godFtvXSk7cmV0dXJue25ld1NoYXBlOnIsbmV3UGVybTpufX0sbW09KGUsdCk9PntsZXQgcj0wO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7KytuKWlmKHRbZVtuXV0hPT0xKXtpZihlW25dPHIpcmV0dXJuITE7cj1lW25dfXJldHVybiEwfSxQZT0oZSx0KT0+e2xldCByPWUuZGF0YVR5cGUsbj1lLmRpbXMubGVuZ3RoLG89b3Mobix0KSxpPWxtKGUuZGltcyxvKSxhPWUuZGltcyxkPWksbD1uPDJ8fG1tKG8sZS5kaW1zKSxwO2lmKGwpcmV0dXJuIHA9Zz0+e2xldCB4PUUoXCJpbnB1dFwiLHIsYSw0KSwkPU0oXCJvdXRwdXRcIixyLGQsNCk7cmV0dXJuYFxuICAke2cucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0X3NpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKHgsJCl9XG4gICR7Zy5tYWluU3RhcnQoKX1cbiAgICAke2cuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IGlucHV0W2dsb2JhbF9pZHhdO1xuICB9YH0se25hbWU6XCJUcmFuc3Bvc2VDb3B5XCIsc2hhZGVyQ2FjaGU6e2lucHV0RGVwZW5kZW5jaWVzOltcInR5cGVcIl19LGdldFJ1bkRhdGE6KCk9PntsZXQgZz1DLnNpemUoaSk7cmV0dXJue291dHB1dHM6W3tkaW1zOmksZGF0YVR5cGU6ZS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGcvNjQvNCl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTpNYXRoLmNlaWwoZy80KX1dfX0sZ2V0U2hhZGVyU291cmNlOnB9O2xldHtuZXdTaGFwZTptLG5ld1Blcm06dX09cG0oZS5kaW1zLG8pLGg9Qy5hcmVFcXVhbCh1LFsyLDMsMV0pLF89Qy5hcmVFcXVhbCh1LFszLDEsMl0pO2lmKG0ubGVuZ3RoPT09Mnx8aHx8Xyl7YT1oP1ttWzBdLG1bMV0qbVsyXV06Xz9bbVswXSptWzFdLG1bMl1dOm0sZD1bYVsxXSxhWzBdXTtsZXQgZz0xNjtyZXR1cm4gcD14PT57bGV0ICQ9RShcImFcIixyLGEubGVuZ3RoKSx2PU0oXCJvdXRwdXRcIixyLGQubGVuZ3RoKTtyZXR1cm5gXG4gICR7eC5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoJCx2KX1cbiAgdmFyPHdvcmtncm91cD4gdGlsZSA6IGFycmF5PGFycmF5PCR7di50eXBlLnZhbHVlfSwgJHtnKzF9PiwgJHtnfT47XG4gICR7eC5tYWluU3RhcnQoW2csZywxXSl9XG4gICAgbGV0IHN0cmlkZSA9ICh1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMV0gLSAxKSAvICR7Z30gKyAxO1xuICAgIGxldCB3b3JrZ3JvdXBfaWRfeCA9IHdvcmtncm91cF9pbmRleCAlIHN0cmlkZTtcbiAgICBsZXQgd29ya2dyb3VwX2lkX3kgPSB3b3JrZ3JvdXBfaW5kZXggLyBzdHJpZGU7XG4gICAgbGV0IGlucHV0X2NvbCA9IHdvcmtncm91cF9pZF95ICogJHtnfXUgKyBsb2NhbF9pZC54O1xuICAgIGxldCBpbnB1dF9yb3cgPSB3b3JrZ3JvdXBfaWRfeCAqICR7Z311ICsgbG9jYWxfaWQueTtcbiAgICBpZiAoaW5wdXRfcm93IDwgdW5pZm9ybXMuYV9zaGFwZVswXSAmJiBpbnB1dF9jb2wgPCB1bmlmb3Jtcy5hX3NoYXBlWzFdKSB7XG4gICAgICB0aWxlW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gJHskLmdldEJ5SW5kaWNlcyhgJHskLnR5cGUuaW5kaWNlc30oaW5wdXRfcm93LCBpbnB1dF9jb2wpYCl9O1xuICAgIH1cbiAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICBsZXQgb3V0cHV0X2NvbCA9IHdvcmtncm91cF9pZF94ICogJHtnfXUgKyBsb2NhbF9pZC54O1xuICAgIGxldCBvdXRwdXRfcm93ID0gd29ya2dyb3VwX2lkX3kgKiAke2d9dSArIGxvY2FsX2lkLnk7XG4gICAgaWYgKG91dHB1dF9yb3cgPCB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMF0gJiYgb3V0cHV0X2NvbCA8IHVuaWZvcm1zLm91dHB1dF9zaGFwZVsxXSkge1xuICAgICAgJHt2LnNldEJ5SW5kaWNlcyhgJHt2LnR5cGUuaW5kaWNlc30ob3V0cHV0X3Jvdywgb3V0cHV0X2NvbClgLFwidGlsZVtsb2NhbF9pZC54XVtsb2NhbF9pZC55XVwiKX1cbiAgICB9XG4gIH1gfSx7bmFtZTpcIlRyYW5zcG9zZVNoYXJlZFwiLHNoYWRlckNhY2hlOntpbnB1dERlcGVuZGVuY2llczpbXCJ0eXBlXCJdfSxnZXRSdW5EYXRhOigpPT57bGV0IHg9Qy5zaXplKGkpO3JldHVybntvdXRwdXRzOlt7ZGltczppLGRhdGFUeXBlOmUuZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChkWzFdL2cpLHk6TWF0aC5jZWlsKGRbMF0vZyl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTp4fSwuLi5OKGEsZCldfX0sZ2V0U2hhZGVyU291cmNlOnB9fXJldHVybiBwPWc9PntsZXQgeD1FKFwiYVwiLHIsYS5sZW5ndGgpLCQ9TShcIm91dHB1dFwiLHIsZC5sZW5ndGgpO3JldHVybmBcbiAgJHtnLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dF9zaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyh4LCQpfVxuXG4gICR7Y20obyxuLHgsJCl9XG5cbiAgJHtnLm1haW5TdGFydCgpfVxuICAgICR7Zy5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG5cbiAgICBsZXQgaW5kaWNlcyA9ICR7JC5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICBsZXQgYUluZGljZXMgPSBwZXJtKGluZGljZXMpO1xuXG4gICAgJHskLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLHguZ2V0QnlJbmRpY2VzKFwiYUluZGljZXNcIikpfVxuICB9YH0se25hbWU6XCJUcmFuc3Bvc2VcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0fWAsaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiXX0sZ2V0UnVuRGF0YTooKT0+e2xldCBnPUMuc2l6ZShpKTtyZXR1cm57b3V0cHV0czpbe2RpbXM6aSxkYXRhVHlwZTplLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoZy82NCl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTpnfSwuLi5OKGEsZCldfX0sZ2V0U2hhZGVyU291cmNlOnB9fSxpcz0oZSx0KT0+e2RtKGUuaW5wdXRzLHQucGVybSksZS5jb21wdXRlKFBlKGUuaW5wdXRzWzBdLHQucGVybSkpfSxhcz1lPT5yZSh7cGVybTplLnBlcm19KX0pO3ZhciBmbSxobSxnbSxibSx5bSxfbSx3bSx2bSwkbSx4bSxydCxzcyx1cyxkcyxscyxjcyxwcyxtcyxmcyxocyxncyxicz1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtvZSgpO2FlKCk7R3IoKTtkdCgpO2ZtPXttYXg6XCJzZWxlY3QoYmVzdFZhbHVlLCBjYW5kaWRhdGUsIGNhbmRpZGF0ZSA+IGJlc3RWYWx1ZSlcIixtaW46XCJzZWxlY3QoYmVzdFZhbHVlLCBjYW5kaWRhdGUsIGNhbmRpZGF0ZSA8IGJlc3RWYWx1ZSlcIixtZWFuOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCIsc3VtOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCIscHJvZDpcImJlc3RWYWx1ZSAqIGNhbmRpZGF0ZVwiLHN1bVNxdWFyZTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZSAqIGNhbmRpZGF0ZVwiLGxvZ1N1bUV4cDpcImJlc3RWYWx1ZSArIGV4cChjYW5kaWRhdGUpXCIsbDE6XCJiZXN0VmFsdWUgKyBhYnMoY2FuZGlkYXRlKVwiLGwyOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlICogY2FuZGlkYXRlXCIsbG9nU3VtOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCJ9LGhtPXttYXg6XCJzZWxlY3QoYmVzdFZhbHVlLCBjYW5kaWRhdGUsIGNhbmRpZGF0ZSA+IGJlc3RWYWx1ZSlcIixtaW46XCJzZWxlY3QoYmVzdFZhbHVlLCBjYW5kaWRhdGUsIGNhbmRpZGF0ZSA8IGJlc3RWYWx1ZSlcIixtZWFuOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCIsc3VtOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCIscHJvZDpcImJlc3RWYWx1ZSAqIGNhbmRpZGF0ZVwiLHN1bVNxdWFyZTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLGxvZ1N1bUV4cDpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLGwxOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCIsbDI6XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixsb2dTdW06XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIn0sZ209e21heDpcIl9BW29mZnNldF1cIixtaW46XCJfQVtvZmZzZXRdXCIsbWVhbjpcIjBcIixzdW06XCIwXCIscHJvZDpcIjFcIixzdW1TcXVhcmU6XCIwXCIsbG9nU3VtRXhwOlwiMFwiLGwxOlwiMFwiLGwyOlwiMFwiLGxvZ1N1bTpcIjBcIn0sYm09e21heDpcImJlc3RWYWx1ZVwiLG1pbjpcImJlc3RWYWx1ZVwiLHN1bTpcImJlc3RWYWx1ZVwiLHByb2Q6XCJiZXN0VmFsdWVcIixzdW1TcXVhcmU6XCJiZXN0VmFsdWVcIixsb2dTdW1FeHA6XCJsb2coYmVzdFZhbHVlKVwiLGwxOlwiYmVzdFZhbHVlXCIsbDI6XCJzcXJ0KGJlc3RWYWx1ZSlcIixsb2dTdW06XCJsb2coYmVzdFZhbHVlKVwifSx5bT0oZSx0KT0+e2xldCByPVtdO2ZvcihsZXQgbj10LWU7bjx0OysrbilyLnB1c2gobik7cmV0dXJuIHJ9LF9tPShlLHQpPT57bGV0IHI9W10sbj1lLmxlbmd0aDtmb3IobGV0IGk9MDtpPG47aSsrKXQuaW5kZXhPZihpKT09PS0xJiZyLnB1c2goZVtpXSk7bGV0IG89dC5tYXAoaT0+ZVtpXSk7cmV0dXJuW3Isb119LHdtPShlLHQpPT57bGV0IHI9ZS5sZW5ndGgrdC5sZW5ndGgsbj1bXSxvPTA7Zm9yKGxldCBpPTA7aTxyO2krKyl0LmluZGV4T2YoaSk9PT0tMT9uLnB1c2goZVtvKytdKTpuLnB1c2goMSk7cmV0dXJuIG59LHZtPShlLHQpPT57Zm9yKGxldCByPTA7cjxlLmxlbmd0aDsrK3IpaWYoZVtlLmxlbmd0aC1yLTFdIT09dC0xLXIpcmV0dXJuITE7cmV0dXJuITB9LCRtPShlLHQpPT57bGV0IHI9W107aWYoIXZtKGUsdCkpe2ZvcihsZXQgbj0wO248dDsrK24pZS5pbmRleE9mKG4pPT09LTEmJnIucHVzaChuKTtlLmZvckVhY2gobj0+ci5wdXNoKG4pKX1yZXR1cm4gcn0seG09KGUsdCxyLG4sbyxpLGEpPT57bGV0IGQ9clswXS5kaW1zLGw9Qy5zaXplKGkpLHA9Qy5zaXplKGEpLG09RShcIl9BXCIsclswXS5kYXRhVHlwZSxkKSx1PU0oXCJvdXRwdXRcIixvLGkpLGg9NjQ7bD09PTEmJihoPTI1Nik7bGV0IF89YFxuICAgICAgICAgIHZhcjx3b3JrZ3JvdXA+IGFCZXN0VmFsdWVzIDogYXJyYXk8ZjMyLCAke2h9PjtcbiAgICAgICBgLHk9Zz0+YFxuICAgICAgICAke2cucmVnaXN0ZXJVbmlmb3JtKFwicmVkdWNlU2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMobSx1KX1cbiAgICAgICAgJHtffVxuICAgICAgICBmbiBESVZfQ0VJTChhIDogdTMyLCBiIDogdTMyKSAtPiB1MzIge1xuICAgICAgICAgIHJldHVybiAoKGEgLSAxdSkgLyBiICsgMXUpO1xuICAgICAgICAgfVxuICAgICAgICAgJHtnLm1haW5TdGFydChoKX1cblxuICAgICAgICAgIGxldCBvdXRwdXRJbmRleCA9IGdsb2JhbF9pZHggLyAke2h9O1xuICAgICAgICAgIGxldCBvZmZzZXQgPSBvdXRwdXRJbmRleCAqIHVuaWZvcm1zLnJlZHVjZVNpemU7XG5cbiAgICAgICAgICB2YXIgYmVzdFZhbHVlID0gZjMyKCR7Z21bbl19KTtcbiAgICAgICAgICBsZXQgTGVuZ3RoID0gdW5pZm9ybXMucmVkdWNlU2l6ZTtcbiAgICAgICAgICBmb3IgKHZhciBrID0gbG9jYWxfaWR4OyBrIDwgTGVuZ3RoOyBrID0gayArICR7aH0pIHtcbiAgICAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IGYzMigke20uZ2V0QnlPZmZzZXQoXCJvZmZzZXQgKyBrXCIpfSk7XG4gICAgICAgICAgIGJlc3RWYWx1ZSA9ICR7Zm1bbl19O1xuICAgICAgICAgIH1cbiAgICAgICAgICBhQmVzdFZhbHVlc1tsb2NhbF9pZHhdID0gYmVzdFZhbHVlO1xuICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICAgdmFyIHJlZHVjZVNpemUgPSBtaW4oTGVuZ3RoLCAke2h9dSk7XG4gICAgICAgICBmb3IgKHZhciBjdXJyZW50U2l6ZSA9IHJlZHVjZVNpemUgLyAydTsgcmVkdWNlU2l6ZSA+IDF1O1xuICAgICAgICAgICAgIGN1cnJlbnRTaXplID0gcmVkdWNlU2l6ZSAvIDJ1KSB7XG4gICAgICAgICAgIGxldCBpbnRlcnZhbCA9IERJVl9DRUlMKHJlZHVjZVNpemUsIDJ1KTtcbiAgICAgICAgICAgaWYgKGxvY2FsX2lkeCA8IGN1cnJlbnRTaXplKSB7XG4gICAgICAgICAgICBsZXQgY2FuZGlkYXRlID0gYUJlc3RWYWx1ZXNbbG9jYWxfaWR4ICsgaW50ZXJ2YWxdO1xuICAgICAgICAgICAgYmVzdFZhbHVlID0gJHtobVtuXX07XG4gICAgICAgICAgICBhQmVzdFZhbHVlc1tsb2NhbF9pZHhdID0gYmVzdFZhbHVlO1xuICAgICAgICAgICB9XG4gICAgICAgICAgIHJlZHVjZVNpemUgPSBpbnRlcnZhbDtcbiAgICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgICAgICAgfVxuXG4gICAgICAgICBpZiAobG9jYWxfaWR4ID09IDB1KSB7XG4gICAgICAgICAgJHt1LnNldEJ5T2Zmc2V0KFwib3V0cHV0SW5kZXhcIixgJHtuPT09XCJtZWFuXCI/YCR7dS50eXBlLnN0b3JhZ2V9KGJlc3RWYWx1ZSAvIGYzMih1bmlmb3Jtcy5yZWR1Y2VTaXplKSlgOmAke3UudHlwZS5zdG9yYWdlfSgke2JtW25dfSlgfWApfTtcbiAgICAgICAgIH1cbiAgICAgICAgfWA7cmV0dXJue25hbWU6ZSxzaGFkZXJDYWNoZTp7aGludDpgJHt0fTske2h9YCxpbnB1dERlcGVuZGVuY2llczpbXCJ0eXBlXCJdfSxnZXRTaGFkZXJTb3VyY2U6eSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmksZGF0YVR5cGU6b31dLGRpc3BhdGNoR3JvdXA6e3g6bH0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZToxMixkYXRhOnB9XX0pfX0scnQ9KGUsdCxyLG4pPT57bGV0IG89ZS5pbnB1dHMubGVuZ3RoPT09MT9yOmxvKGUuaW5wdXRzLHIpLGk9by5heGVzO2kubGVuZ3RoPT09MCYmIW8ubm9vcFdpdGhFbXB0eUF4ZXMmJihpPWUuaW5wdXRzWzBdLmRpbXMubWFwKChfLHkpPT55KSk7bGV0IGE9Qy5ub3JtYWxpemVBeGVzKGksZS5pbnB1dHNbMF0uZGltcy5sZW5ndGgpLGQ9YSxsPWUuaW5wdXRzWzBdLHA9JG0oZCxlLmlucHV0c1swXS5kaW1zLmxlbmd0aCk7cC5sZW5ndGg+MCYmKGw9ZS5jb21wdXRlKFBlKGUuaW5wdXRzWzBdLHApLHtpbnB1dHM6WzBdLG91dHB1dHM6Wy0xXX0pWzBdLGQ9eW0oZC5sZW5ndGgsbC5kaW1zLmxlbmd0aCkpO2xldFttLHVdPV9tKGwuZGltcyxkKSxoPW07by5rZWVwRGltcyYmKGg9d20obSxhKSksZS5jb21wdXRlKHhtKHQsby5jYWNoZUtleSxbbF0sbixlLmlucHV0c1swXS5kYXRhVHlwZSxoLHUpLHtpbnB1dHM6W2xdfSl9LHNzPShlLHQpPT57cnQoZSxcIlJlZHVjZU1lYW5TaGFyZWRcIix0LFwibWVhblwiKX0sdXM9KGUsdCk9PntydChlLFwiUmVkdWNlTDFTaGFyZWRcIix0LFwibDFcIil9LGRzPShlLHQpPT57cnQoZSxcIlJlZHVjZUwyU2hhcmVkXCIsdCxcImwyXCIpfSxscz0oZSx0KT0+e3J0KGUsXCJSZWR1Y2VMb2dTdW1FeHBTaGFyZWRcIix0LFwibG9nU3VtRXhwXCIpfSxjcz0oZSx0KT0+e3J0KGUsXCJSZWR1Y2VNYXhTaGFyZWRcIix0LFwibWF4XCIpfSxwcz0oZSx0KT0+e3J0KGUsXCJSZWR1Y2VNaW5TaGFyZWRcIix0LFwibWluXCIpfSxtcz0oZSx0KT0+e3J0KGUsXCJSZWR1Y2VQcm9kU2hhcmVkXCIsdCxcInByb2RcIil9LGZzPShlLHQpPT57cnQoZSxcIlJlZHVjZVN1bVNoYXJlZFwiLHQsXCJzdW1cIil9LGhzPShlLHQpPT57cnQoZSxcIlJlZHVjZVN1bVNxdWFyZVNoYXJlZFwiLHQsXCJzdW1TcXVhcmVcIil9LGdzPShlLHQpPT57cnQoZSxcIlJlZHVjZUxvZ1N1bVNoYXJlZFwiLHQsXCJsb2dTdW1cIil9fSk7dmFyIG50LFNtLEhyLGxvLG90LFRtLEltLENtLEFtLGttLEVtLFBtLHptLE9tLERtLGl0LHlzLF9zLHdzLHZzLCRzLHhzLFNzLFRzLElzLENzLEdyPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7U2UoKTthZSgpO2JzKCk7bnQ9ZT0+e2lmKCFlfHxlLmxlbmd0aD09PTB8fGUubGVuZ3RoPjIpdGhyb3cgbmV3IEVycm9yKFwiUmVkdWNlIG9wIHJlcXVpcmVzIDEgb3IgMiBpbnB1dHMuXCIpO2lmKGUubGVuZ3RoPT09MiYmZVsxXS5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBheGVzIGlucHV0IGRpbXMuXCIpfSxTbT1lPT5bXCJcIixcIlwiLGB2YXIgdmFsdWUgPSAke2UuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07YCxcIlwiXSxIcj0oZSx0LHIsbixvLGksYT0hMSxkPSExKT0+e2xldCBsPVtdLHA9clswXS5kaW1zLG09cC5sZW5ndGgsdT1DLm5vcm1hbGl6ZUF4ZXMobyxtKSxoPSFkJiZ1Lmxlbmd0aD09PTA7cC5mb3JFYWNoKCh4LCQpPT57aHx8dS5pbmRleE9mKCQpPj0wP2EmJmwucHVzaCgxKTpsLnB1c2goeCl9KTtsZXQgXz1sLmxlbmd0aCx5PUMuc2l6ZShsKTtyZXR1cm57bmFtZTplLHNoYWRlckNhY2hlOnQsZ2V0U2hhZGVyU291cmNlOng9PntsZXQgJD1bXSx2PUUoXCJfQVwiLHJbMF0uZGF0YVR5cGUsbSksUz1NKFwib3V0cHV0XCIsaSxfKSxUPW4odixTLHUpLEE9VFsyXTtmb3IobGV0IGs9MCxQPTA7azxtO2srKylofHx1LmluZGV4T2Yoayk+PTA/KGEmJlArKyxBPWBmb3IodmFyIGoke2t9OiB1MzIgPSAwOyBqJHtrfSA8ICR7cFtrXX07IGoke2t9KyspIHtcbiAgICAgICAgICAgICAgICAgICR7VFsyXS5pbmNsdWRlcyhcImxhc3RfaW5kZXhcIik/YGxldCBsYXN0X2luZGV4ID0gaiR7a307YDpcIlwifVxuICAgICAgICAgICAgICAgICAgJHt2LmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsayxgaiR7a31gKX1cbiAgICAgICAgICAgICAgICAgICR7QX1cbiAgICAgICAgICAgICAgICB9YCk6KCQucHVzaChgJHt2LmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsayxTLmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLFApKX07YCksUCsrKTtyZXR1cm5gXG5cbiAgICAgICAgJHt4LnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dF9zaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyh2LFMpfVxuXG4gICAgICAgICR7eC5tYWluU3RhcnQoKX1cbiAgICAgICAgICAke3guZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgICAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke3YudHlwZS5pbmRpY2VzfTtcbiAgICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke1Mub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG5cbiAgICAgICAgICAkeyQuam9pbihgXG5gKX1cbiAgICAgICAgICAke1RbMF19ICAgICAgIC8vIGluaXQgb3BzIGZvciByZWR1Y2UgbWF4L21pblxuICAgICAgICAgICR7VFsxXX1cbiAgICAgICAgICAke0F9XG4gICAgICAgICAgJHtUWzNdfVxuICAgICAgICAgICR7VC5sZW5ndGg9PT00P1Muc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKTpULnNsaWNlKDQpLmpvaW4oYFxuYCl9XG4gICAgICAgIH1gfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmwsZGF0YVR5cGU6aX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHkvNjQpfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjEyLGRhdGE6eX0sLi4uTihwLGwpXX0pfX0sbG89KGUsdCk9PntsZXQgcj1bXTtyZXR1cm4gZVsxXS5kaW1zWzBdPjAmJmVbMV0uZ2V0QmlnSW50NjRBcnJheSgpLmZvckVhY2gobj0+ci5wdXNoKE51bWJlcihuKSkpLHJlKHtheGVzOnIsa2VlcERpbXM6dC5rZWVwRGltcyxub29wV2l0aEVtcHR5QXhlczp0Lm5vb3BXaXRoRW1wdHlBeGVzfSl9LG90PShlLHQscixuKT0+e2xldCBvPWUuaW5wdXRzLGk9by5sZW5ndGg9PT0xP3I6bG8obyxyKTtlLmNvbXB1dGUoSHIodCx7aGludDppLmNhY2hlS2V5LGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LFtvWzBdXSxpLm5vb3BXaXRoRW1wdHlBeGVzJiZpLmF4ZXMubGVuZ3RoPT09MD9TbTpuLGkuYXhlcyxvWzBdLmRhdGFUeXBlLGkua2VlcERpbXMsaS5ub29wV2l0aEVtcHR5QXhlcykse2lucHV0czpbMF19KX0sVG09KGUsdCk9PntudChlLmlucHV0cyksb3QoZSxcIlJlZHVjZUxvZ1N1bVwiLHQsKG4sbyk9PltgdmFyIHZhbHVlID0gJHtvLnR5cGUuc3RvcmFnZX0oMCk7YCxcIlwiLGB2YWx1ZSArPSAke24uZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07YCxcInZhbHVlID0gbG9nKHZhbHVlKTtcIl0pfSxJbT0oZSx0KT0+e250KGUuaW5wdXRzKSxvdChlLFwiUmVkdWNlTDFcIix0LChuLG8pPT5bYHZhciB2YWx1ZSA9ICR7by50eXBlLnN0b3JhZ2V9KDApO2AsXCJcIixgdmFsdWUgKz0gYWJzKCR7bi5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfSk7YCxcIlwiXSl9LENtPShlLHQpPT57bnQoZS5pbnB1dHMpLG90KGUsXCJSZWR1Y2VMMlwiLHQsKG4sbyk9PltgdmFyIHQgPSAke28udHlwZS52YWx1ZX0oMCk7IHZhciB2YWx1ZSA9ICR7by50eXBlLnZhbHVlfSgwKTtgLFwiXCIsYHQgPSAke24uZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07IHZhbHVlICs9ICh0ICogdCk7YCxcInZhbHVlID0gc3FydCh2YWx1ZSk7XCJdKX0sQW09KGUsdCk9PntudChlLmlucHV0cyksb3QoZSxcIlJlZHVjZUxvZ1N1bUV4cFwiLHQsKG4sbyk9PltgdmFyIHZhbHVlID0gJHtvLnR5cGUuc3RvcmFnZX0oMCk7YCxcIlwiLGB2YWx1ZSArPSBleHAoJHtuLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9KTtgLFwidmFsdWUgPSBsb2codmFsdWUpO1wiXSl9LGttPShlLHQpPT57bnQoZS5pbnB1dHMpLG90KGUsXCJSZWR1Y2VNYXhcIix0LChuLG8saSk9PntsZXQgYT1bXTtmb3IobGV0IGQ9MDtkPG4ucmFuaztkKyspKGkuaW5kZXhPZihkKT49MHx8aS5sZW5ndGg9PT0wKSYmYS5wdXNoKG4uaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixkLDApKTtyZXR1cm5bYCR7YS5qb2luKGBcbmApfWAsYHZhciB2YWx1ZSA9ICR7bi5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtgLGB2YWx1ZSA9IG1heCh2YWx1ZSwgJHtuLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9KTtgLFwiXCJdfSl9LEVtPShlLHQpPT57bnQoZS5pbnB1dHMpLG90KGUsXCJSZWR1Y2VNZWFuXCIsdCwobixvLGkpPT57bGV0IGE9MTtmb3IobGV0IGQ9MDtkPG4ucmFuaztkKyspKGkuaW5kZXhPZihkKT49MHx8aS5sZW5ndGg9PT0wKSYmKGEqPWUuaW5wdXRzWzBdLmRpbXNbZF0pO3JldHVybltcInZhciBzdW0gPSBmMzIoMCk7XCIsXCJcIixgc3VtICs9IGYzMigke24uZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX0pO2AsYGxldCB2YWx1ZSA9ICR7by50eXBlLnZhbHVlfShzdW0gLyAke2F9KTtgXX0pfSxQbT0oZSx0KT0+e250KGUuaW5wdXRzKSxvdChlLFwiUmVkdWNlTWluXCIsdCwobixvLGkpPT57bGV0IGE9W107Zm9yKGxldCBkPTA7ZDxuLnJhbms7ZCsrKShpLmluZGV4T2YoZCk+PTB8fGkubGVuZ3RoPT09MCkmJmEucHVzaChgaW5wdXRfaW5kaWNlc1ske2R9XSA9IDA7YCk7cmV0dXJuW2Ake2Euam9pbihgXG5gKX1gLGB2YXIgdmFsdWUgPSAke24uZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07YCxgdmFsdWUgPSBtaW4odmFsdWUsICR7bi5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfSk7YCxcIlwiXX0pfSx6bT0oZSx0KT0+e250KGUuaW5wdXRzKSxvdChlLFwiUmVkdWNlUHJvZFwiLHQsKG4sbyk9PltgdmFyIHZhbHVlID0gJHtvLnR5cGUuc3RvcmFnZX0oMSk7YCxcIlwiLGB2YWx1ZSAqPSAke24uZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07YCxcIlwiXSl9LE9tPShlLHQpPT57bnQoZS5pbnB1dHMpLG90KGUsXCJSZWR1Y2VTdW1cIix0LChuLG8pPT5bYHZhciB2YWx1ZSA9ICR7by50eXBlLnN0b3JhZ2V9KDApO2AsXCJcIixgdmFsdWUgKz0gJHtuLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O2AsXCJcIl0pfSxEbT0oZSx0KT0+e250KGUuaW5wdXRzKSxvdChlLFwiUmVkdWNlU3VtU3F1YXJlXCIsdCwobixvKT0+W2B2YXIgdCA9ICR7by50eXBlLnZhbHVlfSgwKTsgdmFyIHZhbHVlID0gJHtvLnR5cGUudmFsdWV9KDApO2AsXCJcIixgdCA9ICR7bi5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTsgdmFsdWUgKz0gdCAqIHQ7YCxcIlwiXSl9LGl0PShlLHQscik9PntpZih0Lmxlbmd0aD09PTApcmV0dXJuIHI7bGV0IG49MSxvPTE7Zm9yKGxldCBpPTA7aTx0Lmxlbmd0aDtpKyspdC5pbmRleE9mKGkpPT09LTE/bio9ZVtpXTpvKj1lW2ldO3JldHVybiBvPDMyJiZuPjEwMjR9LHlzPShlLHQpPT57aXQoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/RW0oZSx0KTpzcyhlLHQpfSxfcz0oZSx0KT0+e2l0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP0ltKGUsdCk6dXMoZSx0KX0sd3M9KGUsdCk9PntpdChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT9DbShlLHQpOmRzKGUsdCl9LHZzPShlLHQpPT57aXQoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/QW0oZSx0KTpscyhlLHQpfSwkcz0oZSx0KT0+e2l0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP2ttKGUsdCk6Y3MoZSx0KX0seHM9KGUsdCk9PntpdChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT9QbShlLHQpOnBzKGUsdCl9LFNzPShlLHQpPT57aXQoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/em0oZSx0KTptcyhlLHQpfSxUcz0oZSx0KT0+e2l0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP09tKGUsdCk6ZnMoZSx0KX0sSXM9KGUsdCk9PntpdChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT9EbShlLHQpOmhzKGUsdCl9LENzPShlLHQpPT57aXQoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/VG0oZSx0KTpncyhlLHQpfX0pO3ZhciBBcyxrcyxFcyxjbyxQcz1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtTZSgpO0dyKCk7QXM9ZT0+e2lmKCFlfHxlLmxlbmd0aD09PTB8fGUubGVuZ3RoPjIpdGhyb3cgbmV3IEVycm9yKFwiQXJnTWluTWF4T3Agb3AgcmVxdWlyZXMgMSBvciAyIGlucHV0cy5cIik7aWYoZVswXS5kYXRhVHlwZSE9PTEpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0eXBlLlwiKX0sa3M9KGUsdCk9PntBcyhlLmlucHV0cyk7bGV0IHI9KG4sbyxpKT0+e2xldCBhPVtdO2ZvcihsZXQgZD0wO2Q8bi5yYW5rO2QrKykoaS5pbmRleE9mKGQpPj0wfHxpLmxlbmd0aD09PTApJiZhLnB1c2goYGlucHV0X2luZGljZXNbJHtkfV0gPSAwO2ApO3JldHVybltgJHthLmpvaW4oYFxuYCl9YCxgdmFyIHZhbHVlID0gJHtuLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O1xudmFyIGJlc3RfaW5kZXggOiBpMzIgPSAwO2AsYGlmICgke24uZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX0gJHt0LnNlbGVjdExhc3RJbmRleD4wP1wiPD1cIjpcIjxcIn0gdmFsdWUpIHtcbiAgICAgICAgIHZhbHVlID0gJHtuLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O1xuICAgICAgICAgYmVzdF9pbmRleCA9IGkzMihsYXN0X2luZGV4KTtcbiAgICAgICB9YCxcIlwiLG8uc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJiZXN0X2luZGV4XCIpXX07ZS5jb21wdXRlKEhyKFwiQXJnTWluXCIse2hpbnQ6dC5jYWNoZUtleSxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxbZS5pbnB1dHNbMF1dLHIsW3QuYXhpc10sNyx0LmtlZXBEaW1zKSx7aW5wdXRzOlswXX0pfSxFcz0oZSx0KT0+e0FzKGUuaW5wdXRzKTtsZXQgcj0obixvLGkpPT57bGV0IGE9W107Zm9yKGxldCBkPTA7ZDxuLnJhbms7ZCsrKShpLmluZGV4T2YoZCk+PTB8fGkubGVuZ3RoPT09MCkmJmEucHVzaChgaW5wdXRfaW5kaWNlc1ske2R9XSA9IDA7YCk7cmV0dXJuW2Ake2Euam9pbihgXG5gKX1gLGB2YXIgdmFsdWUgPSAke24uZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07XG52YXIgYmVzdF9pbmRleCA6IGkzMiA9IDA7YCxgaWYgKCR7bi5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfSAke3Quc2VsZWN0TGFzdEluZGV4PjA/XCI+PVwiOlwiPlwifSB2YWx1ZSkge1xuICAgICAgICAgdmFsdWUgPSAke24uZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07XG4gICAgICAgICBiZXN0X2luZGV4ID0gaTMyKGxhc3RfaW5kZXgpO1xuICAgICAgIH1gLFwiXCIsby5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcImJlc3RfaW5kZXhcIildfTtlLmNvbXB1dGUoSHIoXCJhcmdNYXhcIix7aGludDp0LmNhY2hlS2V5LGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LFtlLmlucHV0c1swXV0scixbdC5heGlzXSw3LHQua2VlcERpbXMpLHtpbnB1dHM6WzBdfSl9LGNvPWU9PnJlKGUpfSk7dmFyIEJtLHBvLE1tLFJtLFVtLFJ0LE5tLHpzLEZyPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7TnIoKTthZSgpO0JtPShlLHQpPT57bGV0IHI9ZVswXSxuPWVbMV0sbz1lWzJdLGk9ZVszXSxhPWVbNF0sZD1lWzVdO2lmKGEmJmQpdGhyb3cgbmV3IEVycm9yKFwiQXR0ZW50aW9uIGNhbm5vdCBoYXZlIGJvdGggcGFzdCBhbmQgYXR0ZW50aW9uX2JpYXNcIik7aWYoci5kaW1zLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImlucHV0XCIgbXVzdCBoYXZlIDMgZGltZW5zaW9ucycpO2xldCBsPXIuZGltc1swXSxwPXIuZGltc1sxXSxtPXIuZGltc1syXTtpZihvLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwiYmlhc1wiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMSBkaW1lbnNpb25zJyk7aWYobi5kaW1zLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcIndlaWdodHNcIiBpcyBleHBlY3RlZCB0byBoYXZlIDIgZGltZW5zaW9ucycpO2lmKG4uZGltc1swXSE9PW0pdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgMSBkaW1lbnNpb24gMCBzaG91bGQgaGF2ZSBzYW1lIGxlbmd0aCBhcyBkaW1lbnNpb24gMiBvZiBpbnB1dCAwXCIpO2lmKG8uZGltc1swXSE9PW4uZGltc1sxXSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwiYmlhc1wiIGRpbWVuc2lvbiAwIHNob3VsZCBoYXZlIHNhbWUgbGVuZ3RoIGFzIGRpbWVuc2lvbiAxIG9mIGlucHV0IFwid2VpZ2h0c1wiJyk7bGV0IHU9by5kaW1zWzBdLzMsaD11LF89aDtpZih0LnFrdkhpZGRlblNpemVzLmxlbmd0aD4wKXtpZih0LnFrdkhpZGRlblNpemVzLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwicWt2X2hpZGRlbl9zaXplcyBhdHRyaWJ1dGUgc2hvdWxkIGhhdmUgMyBlbGVtZW50c1wiKTtmb3IobGV0IFMgb2YgdC5xa3ZIaWRkZW5TaXplcylpZihTJXQubnVtSGVhZHMhPT0wKXRocm93IG5ldyBFcnJvcihcInFrdl9oaWRkZW5fc2l6ZXMgc2hvdWxkIGJlIGRpdmlzaWJsZSBieSBudW1faGVhZHNcIik7dT10LnFrdkhpZGRlblNpemVzWzBdLGg9dC5xa3ZIaWRkZW5TaXplc1sxXSxfPXQucWt2SGlkZGVuU2l6ZXNbMl19bGV0IHk9cDtpZih1IT09aCl0aHJvdyBuZXcgRXJyb3IoXCJxa3ZfaGlkZGVuX3NpemVzIGZpcnN0IGVsZW1lbnQgc2hvdWxkIGJlIHNhbWUgYXMgdGhlIHNlY29uZFwiKTtpZihvLmRpbXNbMF0hPT11K2grXyl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwiYmlhc1wiIGRpbWVuc2lvbiAwIHNob3VsZCBoYXZlIHNhbWUgbGVuZ3RoIGFzIHN1bSBvZiBRL0svViBoaWRkZW4gc2l6ZXMnKTtsZXQgZz0wO2lmKGEpe2lmKGghPT1fKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0XCIgZXhwZWN0IGtfaGlkZGVuX3NpemUgPT0gdl9oaWRkZW5fc2l6ZScpO2lmKGEuZGltcy5sZW5ndGghPT01KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0XCIgbXVzdCBoYXZlIDUgZGltZW5zaW9ucycpO2lmKGEuZGltc1swXSE9PTIpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RcIiBmaXJzdCBkaW1lbnNpb24gbXVzdCBiZSAyJyk7aWYoYS5kaW1zWzFdIT09bCl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdFwiIHNlY29uZCBkaW1lbnNpb24gbXVzdCBiZSBiYXRjaF9zaXplJyk7aWYoYS5kaW1zWzJdIT09dC5udW1IZWFkcyl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdFwiIHRoaXJkIGRpbWVuc2lvbiBtdXN0IGJlIG51bV9oZWFkcycpO2lmKGEuZGltc1s0XSE9PWgvdC5udW1IZWFkcyl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdFwiIGZpZnRoIGRpbWVuc2lvbiBtdXN0IGJlIGtfaGlkZGVuX3NpemUgLyBudW1faGVhZHMnKTt0LnBhc3RQcmVzZW50U2hhcmVCdWZmZXJ8fChnPWEuZGltc1szXSl9bGV0IHg9eStnLCQ9LTEsdj0wO2lmKGkpdGhyb3cgbmV3IEVycm9yKFwiTWFzayBub3Qgc3VwcG9ydGVkXCIpO2lmKGEpdGhyb3cgbmV3IEVycm9yKFwicGFzdCBpcyBub3Qgc3VwcG9ydGVkXCIpO2lmKGQpe2lmKGQuZGltcy5sZW5ndGghPT00KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJhdHRlbnRpb25fYmlhc1wiIG11c3QgaGF2ZSA0IGRpbWVuc2lvbnMnKTtpZihkLmRpbXNbMF0hPT1sfHxkLmRpbXNbMV0hPT10Lm51bUhlYWRzfHxkLmRpbXNbMl0hPT1wfHxkLmRpbXNbM10hPT14KXRocm93IG5ldyBFcnJvcignRXhwZWN0IFwiYXR0ZW50aW9uX2JpYXNcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwgbnVtX2hlYWRzLCBzZXF1ZW5jZV9sZW5ndGgsIHRvdGFsX3NlcXVlbmNlX2xlbmd0aCknKX1yZXR1cm57YmF0Y2hTaXplOmwsc2VxdWVuY2VMZW5ndGg6cCxwYXN0U2VxdWVuY2VMZW5ndGg6ZyxrdlNlcXVlbmNlTGVuZ3RoOnksdG90YWxTZXF1ZW5jZUxlbmd0aDp4LG1heFNlcXVlbmNlTGVuZ3RoOiQsaW5wdXRIaWRkZW5TaXplOm0saGlkZGVuU2l6ZTp1LHZIaWRkZW5TaXplOl8saGVhZFNpemU6TWF0aC5mbG9vcih1L3QubnVtSGVhZHMpLHZIZWFkU2l6ZTpNYXRoLmZsb29yKF8vdC5udW1IZWFkcyksbnVtSGVhZHM6dC5udW1IZWFkcyxpc1VuaWRpcmVjdGlvbmFsOiExLHBhc3RQcmVzZW50U2hhcmVCdWZmZXI6ITEsbWFza0ZpbHRlclZhbHVlOnQubWFza0ZpbHRlclZhbHVlLG1hc2tUeXBlOnYsc2NhbGU6dC5zY2FsZSxicm9hZGNhc3RSZXNQb3NCaWFzOiExLHBhc3NQYXN0SW5LdjohMSxxa3ZGb3JtYXQ6MX19LHBvPShlLHQscik9PnQmJmU/YFxuICAgICAgbGV0IHRvdGFsX3NlcXVlbmNlX2xlbmd0aF9pbnB1dCA9IHUzMigke3QuZ2V0QnlPZmZzZXQoXCIwXCIpfSk7XG4gICAgICBsZXQgcHJlc2VudF9zZXF1ZW5jZV9sZW5ndGggPSBtYXgodG90YWxfc2VxdWVuY2VfbGVuZ3RoX2lucHV0LCB1bmlmb3Jtcy5wYXN0X3NlcXVlbmNlX2xlbmd0aCk7XG4gICAgICBsZXQgaXNfc3Vic2VxdWVudF9wcm9tcHQ6IGJvb2wgPSBzZXF1ZW5jZV9sZW5ndGggPiAxICYmIHNlcXVlbmNlX2xlbmd0aCAhPSB0b3RhbF9zZXF1ZW5jZV9sZW5ndGhfaW5wdXQ7XG4gICAgICBsZXQgaXNfZmlyc3RfcHJvbXB0OiBib29sID0gaXNfc3Vic2VxdWVudF9wcm9tcHQgPT0gZmFsc2UgJiYgc2VxdWVuY2VfbGVuZ3RoID09IHRvdGFsX3NlcXVlbmNlX2xlbmd0aF9pbnB1dDtcbiAgICAgIHRvdGFsX3NlcXVlbmNlX2xlbmd0aCA9IHUzMigke2U/LmdldEJ5T2Zmc2V0KFwiYmF0Y2hJZHhcIil9KSArIDE7XG4gICAgICB2YXIgcGFzdF9zZXF1ZW5jZV9sZW5ndGg6IHUzMiA9IDA7XG4gICAgICBpZiAoaXNfZmlyc3RfcHJvbXB0ID09IGZhbHNlKSB7XG4gICAgICAgIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoID0gdG90YWxfc2VxdWVuY2VfbGVuZ3RoIC0gc2VxdWVuY2VfbGVuZ3RoO1xuICAgICAgfVxuICAgICAgIGA6YFxuICAgICR7cj9cImxldCBwYXN0X3NlcXVlbmNlX2xlbmd0aCA9IHVuaWZvcm1zLnBhc3Rfc2VxdWVuY2VfbGVuZ3RoXCI6XCJcIn07XG4gICAgbGV0IHByZXNlbnRfc2VxdWVuY2VfbGVuZ3RoID0gdG90YWxfc2VxdWVuY2VfbGVuZ3RoO1xuICAgIGAsTW09KGUsdCxyLG4sbyxpLGEsZCk9PntsZXQgbD1tZShhPzE6aSkscD02NCxtPWkvbDttPHAmJihwPTMyKTtsZXQgdT1NYXRoLmNlaWwoaS9sL3ApLGg9W3t0eXBlOjEyLGRhdGE6dH0se3R5cGU6MTIsZGF0YTpyfSx7dHlwZToxMixkYXRhOm59LHt0eXBlOjEyLGRhdGE6b30se3R5cGU6MTIsZGF0YTptfSx7dHlwZToxMixkYXRhOnV9XSxfPV9lKGUuZGF0YVR5cGUsbCkseT1FZSgxLGwpLGc9W1widHlwZVwiXTthJiZnLnB1c2goXCJ0eXBlXCIpLGQmJmcucHVzaChcInR5cGVcIik7bGV0IHg9JD0+e2xldCB2PU0oXCJ4XCIsZS5kYXRhVHlwZSxlLmRpbXMsbCksUz1bdl0sVD1hP0UoXCJzZXFfbGVuc1wiLGEuZGF0YVR5cGUsYS5kaW1zKTp2b2lkIDA7VCYmUy5wdXNoKFQpO2xldCBBPWQ/RShcInRvdGFsX3NlcXVlbmNlX2xlbmd0aF9pbnB1dFwiLGQuZGF0YVR5cGUsZC5kaW1zKTp2b2lkIDA7QSYmUy5wdXNoKEEpO2xldCBrPUVlKGUuZGF0YVR5cGUpLFA9W3tuYW1lOlwiYmF0Y2hfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJudW1faGVhZHNcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwicGFzdF9zZXF1ZW5jZV9sZW5ndGhcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwic2VxdWVuY2VfbGVuZ3RoXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInRvdGFsX3NlcXVlbmNlX2xlbmd0aFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJlbGVtZW50c19wZXJfdGhyZWFkXCIsdHlwZTpcInUzMlwifV07cmV0dXJuYFxuICB2YXI8d29ya2dyb3VwPiB0aHJlYWRfbWF4OiBhcnJheTxmMzIsICR7cH0+O1xuICB2YXI8d29ya2dyb3VwPiB0aHJlYWRfc3VtOiBhcnJheTxmMzIsICR7cH0+O1xuICAkeyQucmVnaXN0ZXJVbmlmb3JtcyhQKS5kZWNsYXJlVmFyaWFibGVzKC4uLlMpfVxuICAkeyQubWFpblN0YXJ0KFtwLDEsMV0pfVxuICAgIGxldCBiYXRjaElkeCA9IHdvcmtncm91cF9pZC56IC8gdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgIGxldCBoZWFkSWR4ID0gd29ya2dyb3VwX2lkLnogJSB1bmlmb3Jtcy5udW1faGVhZHM7XG4gICAgbGV0IHNlcXVlbmNlX2xlbmd0aCA9IHVuaWZvcm1zLnNlcXVlbmNlX2xlbmd0aDtcbiAgICB2YXIgdG90YWxfc2VxdWVuY2VfbGVuZ3RoID0gdW5pZm9ybXMudG90YWxfc2VxdWVuY2VfbGVuZ3RoO1xuICAgICR7cG8oVCxBLCExKX1cbiAgICBsZXQgbG9jYWxfb2Zmc2V0ID0gbG9jYWxfaWR4ICogdW5pZm9ybXMuZWxlbWVudHNfcGVyX3RocmVhZDtcbiAgICBsZXQgb2Zmc2V0ID0gKGdsb2JhbF9pZHggLyAke3B9KSAqIHVuaWZvcm1zLnRvdGFsX3NlcXVlbmNlX2xlbmd0aCArIGxvY2FsX29mZnNldDtcbiAgICBsZXQgc2VxX2NhdXNhbF9sZW5ndGggPSAke2E/XCJ1MzIocGFzdF9zZXF1ZW5jZV9sZW5ndGggKyB3b3JrZ3JvdXBfaWQueSArIDEpXCI6XCJ0b3RhbF9zZXF1ZW5jZV9sZW5ndGhcIn07XG4gICAgdmFyIHRocmVhZF9tYXhfdmVjdG9yID0gJHt5fSgtMy40MDI4MjNlKzM4Zik7XG4gICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHVuaWZvcm1zLmVsZW1lbnRzX3Blcl90aHJlYWQgJiYgaSArIGxvY2FsX29mZnNldCA8IHNlcV9jYXVzYWxfbGVuZ3RoOyBpKyspIHtcbiAgICAgIHRocmVhZF9tYXhfdmVjdG9yID0gbWF4KCR7eX0oeFtvZmZzZXQgKyBpXSksIHRocmVhZF9tYXhfdmVjdG9yKTtcbiAgICB9XG4gICAgdGhyZWFkX21heFtsb2NhbF9pZHhdID0gJHsoKCk9Pntzd2l0Y2gobCl7Y2FzZSAxOnJldHVyblwidGhyZWFkX21heF92ZWN0b3JcIjtjYXNlIDI6cmV0dXJuXCJtYXgodGhyZWFkX21heF92ZWN0b3IueCwgdGhyZWFkX21heF92ZWN0b3IueSlcIjtjYXNlIDQ6cmV0dXJuXCJtYXgobWF4KHRocmVhZF9tYXhfdmVjdG9yLngsIHRocmVhZF9tYXhfdmVjdG9yLnkpLCBtYXgodGhyZWFkX21heF92ZWN0b3IueiwgdGhyZWFkX21heF92ZWN0b3IudykpXCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNvbXBvbmVudHM6ICR7bH1gKX19KSgpfTtcbiAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICB2YXIgbWF4X3ZhbHVlID0gIGYzMigtMy40MDI4MjNlKzM4Zik7XG4gICAgZm9yICh2YXIgaSA9IDB1OyBpIDwgJHtwfTsgaSsrKSB7XG4gICAgICBtYXhfdmFsdWUgPSBtYXgodGhyZWFkX21heFtpXSwgbWF4X3ZhbHVlKTtcbiAgICB9XG5cbiAgICB2YXIgc3VtX3ZlY3RvciA9ICR7eX0oMCk7XG4gICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHVuaWZvcm1zLmVsZW1lbnRzX3Blcl90aHJlYWQgJiYgaSArIGxvY2FsX29mZnNldCA8IHNlcV9jYXVzYWxfbGVuZ3RoOyBpKyspIHtcbiAgICAgIHN1bV92ZWN0b3IgKz0gZXhwKCR7eX0oeFtvZmZzZXQgKyBpXSkgLSBtYXhfdmFsdWUpO1xuICAgIH1cbiAgICB0aHJlYWRfc3VtW2xvY2FsX2lkeF0gPSAkeygoKT0+e3N3aXRjaChsKXtjYXNlIDE6cmV0dXJuXCJzdW1fdmVjdG9yXCI7Y2FzZSAyOnJldHVyblwic3VtX3ZlY3Rvci54ICsgc3VtX3ZlY3Rvci55XCI7Y2FzZSA0OnJldHVyblwic3VtX3ZlY3Rvci54ICsgc3VtX3ZlY3Rvci55ICsgc3VtX3ZlY3Rvci56ICsgc3VtX3ZlY3Rvci53XCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNvbXBvbmVudHM6ICR7bH1gKX19KSgpfTtcbiAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICB2YXIgc3VtOiBmMzIgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwdTsgaSA8ICR7cH07IGkrKykge1xuICAgICAgc3VtICs9IHRocmVhZF9zdW1baV07XG4gICAgfVxuXG4gICAgaWYgKHN1bSA9PSAwKSB7XG4gICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgdW5pZm9ybXMuZWxlbWVudHNfcGVyX3RocmVhZCAmJiBpICsgbG9jYWxfb2Zmc2V0IDwgc2VxX2NhdXNhbF9sZW5ndGg7IGkrKykge1xuICAgICAgICB4W29mZnNldCArIGldID0gJHt2LnR5cGUudmFsdWV9KCR7a30oMS4wKSAvICR7a30oc2VxX2NhdXNhbF9sZW5ndGgpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHVuaWZvcm1zLmVsZW1lbnRzX3Blcl90aHJlYWQgJiYgaSArIGxvY2FsX29mZnNldCA8IHNlcV9jYXVzYWxfbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGYzMmlucHV0ID0gJHt5fSh4W29mZnNldCArIGldKTtcbiAgICAgICAgeFtvZmZzZXQgKyBpXSA9ICR7di50eXBlLnZhbHVlfShleHAoZjMyaW5wdXQgLSBtYXhfdmFsdWUpIC8gc3VtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgICAke2E/YFxuICAgICAgICBmb3IgKHZhciB0b3RhbF9zZXFfaWQ6IHUzMiA9IHNlcV9jYXVzYWxfbGVuZ3RoOyB0b3RhbF9zZXFfaWQgKyBsb2NhbF9vZmZzZXQgPCB1bmlmb3Jtcy50b3RhbF9zZXF1ZW5jZV9sZW5ndGg7IHRvdGFsX3NlcV9pZCsrKSB7XG4gICAgICAgICAgeFtvZmZzZXQgKyB0b3RhbF9zZXFfaWRdID0gJHt2LnR5cGUudmFsdWV9KCR7a30oMCkpO1xuICAgICAgICB9YDpcIlwifTtcbiAgfWB9O3JldHVybntuYW1lOlwiQXR0ZW50aW9uUHJvYnNTb2Z0bWF4XCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7cH07JHtffTske2x9YCxpbnB1dERlcGVuZGVuY2llczpnfSxnZXRTaGFkZXJTb3VyY2U6eCxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W10sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoaS9wKSx5Om8sejp0KnJ9LHByb2dyYW1Vbmlmb3JtczpofSl9fSxSbT0oZSx0LHIsbixvLGksYSxkLGwpPT57bGV0IHA9YStpLmt2U2VxdWVuY2VMZW5ndGgsbT1baS5iYXRjaFNpemUsaS5udW1IZWFkcyxpLnNlcXVlbmNlTGVuZ3RoLHBdLHU9ZT4xJiZuLGg9aS5rdk51bUhlYWRzP2kua3ZOdW1IZWFkczppLm51bUhlYWRzLF89dT9baS5iYXRjaFNpemUsaCxwLGkuaGVhZFNpemVdOnZvaWQgMCx5PWkublJlcHM/aS5uUmVwczoxLGc9aS5zY2FsZT09PTA/MS9NYXRoLnNxcnQoaS5oZWFkU2l6ZSk6aS5zY2FsZSx4PW1lKGkuaGVhZFNpemUpLCQ9aS5oZWFkU2l6ZS94LHY9MTIsUz17eDpNYXRoLmNlaWwocC92KSx5Ok1hdGguY2VpbChpLnNlcXVlbmNlTGVuZ3RoL3YpLHo6aS5iYXRjaFNpemUqaS5udW1IZWFkc30sVD1be3R5cGU6MTIsZGF0YTppLnNlcXVlbmNlTGVuZ3RofSx7dHlwZToxMixkYXRhOiR9LHt0eXBlOjEyLGRhdGE6cH0se3R5cGU6MTIsZGF0YTppLm51bUhlYWRzfSx7dHlwZToxMixkYXRhOmkuaGVhZFNpemV9LHt0eXBlOjEsZGF0YTpnfSx7dHlwZToxMixkYXRhOmF9LHt0eXBlOjEyLGRhdGE6aS5rdlNlcXVlbmNlTGVuZ3RofSx7dHlwZToxMixkYXRhOnl9XSxBPXUmJm4mJkMuc2l6ZShuLmRpbXMpPjAsaz1bXCJ0eXBlXCIsXCJ0eXBlXCJdO0EmJmsucHVzaChcInR5cGVcIiksbyYmay5wdXNoKFwidHlwZVwiKSxkJiZrLnB1c2goXCJ0eXBlXCIpLGwmJmsucHVzaChcInR5cGVcIik7bGV0IFA9W3tkaW1zOm0sZGF0YVR5cGU6dC5kYXRhVHlwZSxncHVEYXRhVHlwZTowfV07dSYmUC5wdXNoKHtkaW1zOl8sZGF0YVR5cGU6dC5kYXRhVHlwZSxncHVEYXRhVHlwZTowfSk7bGV0IEQ9Uj0+e2xldCBHPUUoXCJxXCIsdC5kYXRhVHlwZSx0LmRpbXMseCksSz1FKFwia2V5XCIsci5kYXRhVHlwZSxyLmRpbXMseCksaj1bRyxLXTtpZihBKXtsZXQgbmU9RShcInBhc3Rfa2V5XCIsbi5kYXRhVHlwZSxuLmRpbXMseCk7ai5wdXNoKG5lKX1vJiZqLnB1c2goRShcImF0dGVudGlvbl9iaWFzXCIsby5kYXRhVHlwZSxvLmRpbXMpKTtsZXQgVj1kP0UoXCJzZXFfbGVuc1wiLGQuZGF0YVR5cGUsZC5kaW1zKTp2b2lkIDA7ViYmai5wdXNoKFYpO2xldCBRPWw/RShcInRvdGFsX3NlcXVlbmNlX2xlbmd0aF9pbnB1dFwiLGwuZGF0YVR5cGUsbC5kaW1zKTp2b2lkIDA7USYmai5wdXNoKFEpO2xldCBzZT1NKFwib3V0cHV0XCIsdC5kYXRhVHlwZSxtKSxZPVtzZV07dSYmWS5wdXNoKE0oXCJwcmVzZW50X2tleVwiLHQuZGF0YVR5cGUsXyx4KSk7bGV0IGVlPUVlKDEseCksSj1be25hbWU6XCJNXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIktcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiTlwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJudW1faGVhZHNcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiaGVhZF9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImFscGhhXCIsdHlwZTpcImYzMlwifSx7bmFtZTpcInBhc3Rfc2VxdWVuY2VfbGVuZ3RoXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImt2X3NlcXVlbmNlX2xlbmd0aFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJuX3JlcHNcIix0eXBlOlwidTMyXCJ9XTtyZXR1cm5gXG4gIGNvbnN0IFRJTEVfU0laRSA9ICR7dn11O1xuXG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVROiBhcnJheTwke0cudHlwZS5zdG9yYWdlfSwgJHt2KnZ9PjtcbiAgdmFyPHdvcmtncm91cD4gdGlsZUs6IGFycmF5PCR7Ry50eXBlLnN0b3JhZ2V9LCAke3Yqdn0+O1xuICAke1IucmVnaXN0ZXJVbmlmb3JtcyhKKS5kZWNsYXJlVmFyaWFibGVzKC4uLmosLi4uWSl9XG4gICR7Ui5tYWluU3RhcnQoW3YsdiwxXSl9XG4gICAgLy8geCBob2xkcyB0aGUgTiBhbmQgeSBob2xkcyB0aGUgTVxuICAgIGxldCBoZWFkSWR4ID0gd29ya2dyb3VwX2lkLnogJSB1bmlmb3Jtcy5udW1faGVhZHM7XG4gICAgbGV0IGt2SGVhZElkeCA9ICR7eT09PTE/XCJoZWFkSWR4XCI6XCJoZWFkSWR4IC8gdW5pZm9ybXMubl9yZXBzXCJ9O1xuICAgIGxldCBrdl9udW1faGVhZHMgPSAke3k9PT0xP1widW5pZm9ybXMubnVtX2hlYWRzXCI6XCJ1bmlmb3Jtcy5udW1faGVhZHMgLyB1bmlmb3Jtcy5uX3JlcHNcIn07XG4gICAgbGV0IGJhdGNoSWR4ID0gd29ya2dyb3VwX2lkLnogLyB1bmlmb3Jtcy5udW1faGVhZHM7XG4gICAgbGV0IG0gPSB3b3JrZ3JvdXBfaWQueSAqIFRJTEVfU0laRTtcbiAgICBsZXQgbiA9IHdvcmtncm91cF9pZC54ICogVElMRV9TSVpFO1xuICAgIGxldCBzZXF1ZW5jZV9sZW5ndGggPSB1bmlmb3Jtcy5NO1xuICAgIHZhciB0b3RhbF9zZXF1ZW5jZV9sZW5ndGggPSB1bmlmb3Jtcy5OO1xuICAgICR7cG8oVixRLCEwKX1cbiAgICBsZXQgYWJzS3ZIZWFkSWR4ID0gYmF0Y2hJZHggKiBrdl9udW1faGVhZHMgKyBrdkhlYWRJZHg7XG4gICAgbGV0IHFPZmZzZXQgPSB3b3JrZ3JvdXBfaWQueiAqIHVuaWZvcm1zLk0gKiB1bmlmb3Jtcy5LICsgbSAqIHVuaWZvcm1zLks7XG4gICAgJHtBJiZ1P1wibGV0IHBhc3RLZXlPZmZzZXQgPSBhYnNLdkhlYWRJZHggKiB1bmlmb3Jtcy5wYXN0X3NlcXVlbmNlX2xlbmd0aCAqIHVuaWZvcm1zLks7XCI6XCJcIn07XG4gICAgbGV0IGtPZmZzZXQgPSBhYnNLdkhlYWRJZHggKiB1bmlmb3Jtcy5rdl9zZXF1ZW5jZV9sZW5ndGggKiB1bmlmb3Jtcy5LO1xuICAgICR7dT9cImxldCBwcmVzZW50S2V5T2Zmc2V0ID0gYWJzS3ZIZWFkSWR4ICogdW5pZm9ybXMuTiAqIHVuaWZvcm1zLks7XCI6XCJcIn1cbiAgICB2YXIgdmFsdWUgPSAke2VlfSgwKTtcbiAgICBmb3IgKHZhciB3OiB1MzIgPSAwdTsgdyA8IHVuaWZvcm1zLks7IHcgKz0gVElMRV9TSVpFKSB7XG4gICAgICBpZiAoZ2xvYmFsX2lkLnkgPCB1bmlmb3Jtcy5NICYmIHcgKyBsb2NhbF9pZC54IDwgdW5pZm9ybXMuSykge1xuICAgICAgICB0aWxlUVtUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueF0gPSBxW3FPZmZzZXQgKyBsb2NhbF9pZC55ICogdW5pZm9ybXMuSyArIHcgKyBsb2NhbF9pZC54XTtcbiAgICAgIH1cbiAgICAgIGlmIChuICsgbG9jYWxfaWQueSA8IHVuaWZvcm1zLk4gJiYgdyArIGxvY2FsX2lkLnggPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIHZhciBpZHggPSBUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueDtcbiAgICAgICR7KCgpPT5BJiZ1P2BcbiAgICAgICAgICAgICAgaWYgKG4gKyBsb2NhbF9pZC55IDwgcGFzdF9zZXF1ZW5jZV9sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aWxlS1tpZHhdID0gcGFzdF9rZXlbcGFzdEtleU9mZnNldCArIChuICsgbG9jYWxfaWQueSkgKiB1bmlmb3Jtcy5LICsgdyArIGxvY2FsX2lkLnhdO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG4gKyBsb2NhbF9pZC55IC0gcGFzdF9zZXF1ZW5jZV9sZW5ndGggPCB1bmlmb3Jtcy5rdl9zZXF1ZW5jZV9sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aWxlS1tpZHhdID0ga2V5W2tPZmZzZXQgKyAobiArIGxvY2FsX2lkLnkgLSBwYXN0X3NlcXVlbmNlX2xlbmd0aCkgKiB1bmlmb3Jtcy5LICsgdyArIGxvY2FsX2lkLnhdO1xuICAgICAgICAgICAgICB9YDpgXG4gICAgICAgICAgaWYgKG4gKyBsb2NhbF9pZC55IDwgdW5pZm9ybXMua3Zfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgICAgICB0aWxlS1tpZHhdID0ga2V5W2tPZmZzZXQgKyAobiArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMuSyArIHcgKyBsb2NhbF9pZC54XTtcbiAgICAgICAgICB9YCkoKX1cbiAgICAgICR7dT9gaWYgKG4gKyBsb2NhbF9pZC55IDwgcHJlc2VudF9zZXF1ZW5jZV9sZW5ndGgpIHtcbiAgICAgICAgcHJlc2VudF9rZXlbcHJlc2VudEtleU9mZnNldCArIChuICsgbG9jYWxfaWQueSkgKiB1bmlmb3Jtcy5LICsgdyArIGxvY2FsX2lkLnhdID0gdGlsZUtbaWR4XTtcbiAgICAgIH1gOlwiXCJ9XG4gICAgICB9XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgIGZvciAodmFyIGs6IHUzMiA9IDB1OyBrIDwgVElMRV9TSVpFICYmIHcrayA8IHVuaWZvcm1zLks7IGsrKykge1xuICAgICAgICAgIHZhbHVlICs9ICR7ZWV9KHRpbGVRW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBrXSAqIHRpbGVLW1RJTEVfU0laRSAqIGxvY2FsX2lkLnggKyBrXSk7XG4gICAgICB9XG5cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICB9XG5cbiAgICBpZiAoZ2xvYmFsX2lkLnkgPCB1bmlmb3Jtcy5NICYmIGdsb2JhbF9pZC54IDwgdG90YWxfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICBsZXQgaGVhZE9mZnNldCA9IHdvcmtncm91cF9pZC56ICogdW5pZm9ybXMuTSAqIHVuaWZvcm1zLk47XG4gICAgICBsZXQgb3V0cHV0SWR4ID0gaGVhZE9mZnNldCArIGdsb2JhbF9pZC55ICogdW5pZm9ybXMuTiArIGdsb2JhbF9pZC54O1xuICAgICAgdmFyIHN1bTogZjMyID0gJHsoKCk9Pntzd2l0Y2goeCl7Y2FzZSAxOnJldHVyblwidmFsdWVcIjtjYXNlIDI6cmV0dXJuXCJ2YWx1ZS54ICsgdmFsdWUueVwiO2Nhc2UgNDpyZXR1cm5cInZhbHVlLnggKyB2YWx1ZS55ICsgdmFsdWUueiArIHZhbHVlLndcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgY29tcG9uZW50czogJHt4fWApfX0pKCl9O1xuICAgICAgICBvdXRwdXRbb3V0cHV0SWR4XSA9ICR7c2UudHlwZS52YWx1ZX0gKHN1bSAqIHVuaWZvcm1zLmFscGhhKSArICR7bz9cImF0dGVudGlvbl9iaWFzW291dHB1dElkeF1cIjpcIjAuMFwifTtcbiAgICB9XG4gIH1gfTtyZXR1cm57bmFtZTpcIkF0dGVudGlvblByb2JzXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7eH07JHtvIT09dm9pZCAwfTske24hPT12b2lkIDB9OyR7ZX1gLGlucHV0RGVwZW5kZW5jaWVzOmt9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpQLGRpc3BhdGNoR3JvdXA6Uyxwcm9ncmFtVW5pZm9ybXM6VH0pLGdldFNoYWRlclNvdXJjZTpEfX0sVW09KGUsdCxyLG4sbyxpLGE9dm9pZCAwLGQ9dm9pZCAwKT0+e2xldCBsPWkrby5rdlNlcXVlbmNlTGVuZ3RoLHA9by5uUmVwcz9vLm5SZXBzOjEsbT1vLnZIaWRkZW5TaXplKnAsdT1lPjEmJm4saD1vLmt2TnVtSGVhZHM/by5rdk51bUhlYWRzOm8ubnVtSGVhZHMsXz11P1tvLmJhdGNoU2l6ZSxoLGwsby5oZWFkU2l6ZV06dm9pZCAwLHk9W28uYmF0Y2hTaXplLG8uc2VxdWVuY2VMZW5ndGgsbV0sZz0xMix4PXt4Ok1hdGguY2VpbChvLnZIZWFkU2l6ZS9nKSx5Ok1hdGguY2VpbChvLnNlcXVlbmNlTGVuZ3RoL2cpLHo6by5iYXRjaFNpemUqby5udW1IZWFkc30sJD1be3R5cGU6MTIsZGF0YTpvLnNlcXVlbmNlTGVuZ3RofSx7dHlwZToxMixkYXRhOmx9LHt0eXBlOjEyLGRhdGE6by52SGVhZFNpemV9LHt0eXBlOjEyLGRhdGE6by5udW1IZWFkc30se3R5cGU6MTIsZGF0YTpvLmhlYWRTaXplfSx7dHlwZToxMixkYXRhOm19LHt0eXBlOjEyLGRhdGE6aX0se3R5cGU6MTIsZGF0YTpvLmt2U2VxdWVuY2VMZW5ndGh9LHt0eXBlOjEyLGRhdGE6cH1dLHY9dSYmbiYmQy5zaXplKG4uZGltcyk+MCxTPVtcInR5cGVcIixcInR5cGVcIl07diYmUy5wdXNoKFwidHlwZVwiKSxhJiZTLnB1c2goXCJ0eXBlXCIpLGQmJlMucHVzaChcInR5cGVcIik7bGV0IFQ9W3tkaW1zOnksZGF0YVR5cGU6dC5kYXRhVHlwZSxncHVEYXRhVHlwZTowfV07dSYmVC5wdXNoKHtkaW1zOl8sZGF0YVR5cGU6dC5kYXRhVHlwZSxncHVEYXRhVHlwZTowfSk7bGV0IEE9az0+e2xldCBQPUUoXCJwcm9ic1wiLHQuZGF0YVR5cGUsdC5kaW1zKSxEPUUoXCJ2XCIsci5kYXRhVHlwZSxyLmRpbXMpLFI9W1AsRF07diYmUi5wdXNoKEUoXCJwYXN0X3ZhbHVlXCIsbi5kYXRhVHlwZSxuLmRpbXMpKTtsZXQgRz1hP0UoXCJzZXFfbGVuc1wiLGEuZGF0YVR5cGUsYS5kaW1zKTp2b2lkIDA7YSYmUi5wdXNoKEcpO2xldCBLPWQ/RShcInRvdGFsX3NlcXVlbmNlX2xlbmd0aF9pbnB1dFwiLGQuZGF0YVR5cGUsZC5kaW1zKTp2b2lkIDA7ZCYmUi5wdXNoKEspO2xldCBWPVtNKFwib3V0cHV0XCIsdC5kYXRhVHlwZSx5KV07dSYmVi5wdXNoKE0oXCJwcmVzZW50X3ZhbHVlXCIsdC5kYXRhVHlwZSxfKSk7bGV0IFE9W3tuYW1lOlwiTVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJLXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIk5cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibnVtX2hlYWRzXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImhlYWRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJ2X2hpZGRlbl9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInBhc3Rfc2VxdWVuY2VfbGVuZ3RoXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImt2X3NlcXVlbmNlX2xlbmd0aFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJuX3JlcHNcIix0eXBlOlwidTMyXCJ9XTtyZXR1cm5gXG4gIGNvbnN0IFRJTEVfU0laRSA9ICR7Z311O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlUTogYXJyYXk8JHtQLnR5cGUudmFsdWV9LCAke2cqZ30+O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlVjogYXJyYXk8JHtQLnR5cGUudmFsdWV9LCAke2cqZ30+O1xuICAke2sucmVnaXN0ZXJVbmlmb3JtcyhRKS5kZWNsYXJlVmFyaWFibGVzKC4uLlIsLi4uVil9XG4gICR7ay5tYWluU3RhcnQoW2csZywxXSl9XG4gICBsZXQgaGVhZElkeCA9IHdvcmtncm91cF9pZC56ICUgdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgbGV0IGJhdGNoSWR4ID0gd29ya2dyb3VwX2lkLnogLyB1bmlmb3Jtcy5udW1faGVhZHM7XG4gICBsZXQga3ZIZWFkSWR4ID0gJHtwPT09MT9cImhlYWRJZHhcIjpcImhlYWRJZHggLyB1bmlmb3Jtcy5uX3JlcHNcIn07XG4gICBsZXQga3ZfbnVtX2hlYWRzID0gJHtwPT09MT9cInVuaWZvcm1zLm51bV9oZWFkc1wiOlwidW5pZm9ybXMubnVtX2hlYWRzIC8gdW5pZm9ybXMubl9yZXBzXCJ9O1xuICAgbGV0IG0gPSBnbG9iYWxfaWQueTtcbiAgIGxldCBuID0gZ2xvYmFsX2lkLng7XG4gICBsZXQgc2VxdWVuY2VfbGVuZ3RoID0gdW5pZm9ybXMuTTtcbiAgIHZhciB0b3RhbF9zZXF1ZW5jZV9sZW5ndGggPSB1bmlmb3Jtcy5LO1xuICAgJHtwbyhHLEssITApfVxuICAgbGV0IG9mZnNldEEgPSB3b3JrZ3JvdXBfaWQueiAqIHVuaWZvcm1zLk0gKiB1bmlmb3Jtcy5LICsgbSAqIHVuaWZvcm1zLks7XG4gICBsZXQgYWJzS3ZIZWFkSWR4ID0gYmF0Y2hJZHggKiBrdl9udW1faGVhZHMgKyBrdkhlYWRJZHg7IC8vIGt2SGVhZElkeCBpcyByZWxhdGl2ZSB0byB0aGUgYmF0Y2hcbiAgICR7diYmdT9cImxldCBwYXN0VmFsdWVPZmZzZXQgPSBhYnNLdkhlYWRJZHggKiB1bmlmb3Jtcy5OICogdW5pZm9ybXMucGFzdF9zZXF1ZW5jZV9sZW5ndGggKyBuO1wiOlwiXCJ9O1xuICAgbGV0IHZPZmZzZXQgPSBhYnNLdkhlYWRJZHggKiB1bmlmb3Jtcy5OICogdW5pZm9ybXMua3Zfc2VxdWVuY2VfbGVuZ3RoICsgbjtcbiAgICR7dT9cImxldCBwcmVzZW50VmFsdWVPZmZzZXQgPSBhYnNLdkhlYWRJZHggKiB1bmlmb3Jtcy5OICogdW5pZm9ybXMuSyArIG47XCI6XCJcIn1cbiAgIHZhciB2YWx1ZSA9ICR7UC50eXBlLnN0b3JhZ2V9KDApO1xuICAgZm9yICh2YXIgdzogdTMyID0gMHU7IHcgPCB1bmlmb3Jtcy5LOyB3ICs9IFRJTEVfU0laRSkge1xuICAgICAgaWYgKG0gPCB1bmlmb3Jtcy5NICYmIHcgKyBsb2NhbF9pZC54IDwgdW5pZm9ybXMuSykge1xuICAgICAgICB0aWxlUVtUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgbG9jYWxfaWQueF0gPSBwcm9ic1tvZmZzZXRBICsgdyArIGxvY2FsX2lkLnhdO1xuICAgICAgfVxuICAgICAgaWYgKG4gPCB1bmlmb3Jtcy5OICYmIHcgKyBsb2NhbF9pZC55IDwgdW5pZm9ybXMuSykge1xuICAgICAgICB2YXIgaWR4ID0gVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLng7XG4gICAgICAgICR7KCgpPT52JiZ1P2BcbiAgICAgICAgaWYgKHcgKyBsb2NhbF9pZC55IDwgcGFzdF9zZXF1ZW5jZV9sZW5ndGgpIHtcbiAgICAgICAgICB0aWxlVltpZHhdID0gcGFzdF92YWx1ZVtwYXN0VmFsdWVPZmZzZXQgKyAodyArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMuTl07XG4gICAgICAgIH0gZWxzZSBpZiAodyArIGxvY2FsX2lkLnkgLSBwYXN0X3NlcXVlbmNlX2xlbmd0aCA8IHVuaWZvcm1zLmt2X3NlcXVlbmNlX2xlbmd0aCkge1xuICAgICAgICAgIHRpbGVWW2lkeF0gPSB2W3ZPZmZzZXQgKyAodyArIGxvY2FsX2lkLnkgLSBwYXN0X3NlcXVlbmNlX2xlbmd0aCkgKiB1bmlmb3Jtcy5OXTtcbiAgICAgICAgfVxuICAgICAgYDpgXG4gICAgICAgICAgICBpZiAodyArIGxvY2FsX2lkLnkgPCB1bmlmb3Jtcy5rdl9zZXF1ZW5jZV9sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdGlsZVZbaWR4XSA9IHZbdk9mZnNldCArICh3ICsgbG9jYWxfaWQueSkgKiB1bmlmb3Jtcy5OXTtcbiAgICAgICAgICAgIH1gKSgpfVxuICAgICAgICAke3U/YFxuICAgICAgICAgICAgaWYgKHcgKyBsb2NhbF9pZC55IDwgcHJlc2VudF9zZXF1ZW5jZV9sZW5ndGgpIHtcbiAgICAgICAgICBwcmVzZW50X3ZhbHVlW3ByZXNlbnRWYWx1ZU9mZnNldCArICh3ICsgbG9jYWxfaWQueSkgKiB1bmlmb3Jtcy5OXSA9IHRpbGVWW2lkeF07XG4gICAgICAgIH1gOlwiXCJ9XG4gICAgICB9XG4gICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICAgZm9yICh2YXIgazogdTMyID0gMHU7IGsgPCBUSUxFX1NJWkUgJiYgdytrIDwgdG90YWxfc2VxdWVuY2VfbGVuZ3RoOyBrKyspIHtcbiAgICAgICB2YWx1ZSArPSB0aWxlUVtUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsga10gKiB0aWxlVltUSUxFX1NJWkUgKiBrICsgbG9jYWxfaWQueF07XG4gICAgIH1cbiAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgfVxuXG4gICAvLyB3ZSBuZWVkIHRvIHRyYW5zcG9zZSBvdXRwdXQgZnJvbSBCTlNIX3YgdG8gQlNORF92XG4gICBpZiAobSA8IHVuaWZvcm1zLk0gJiYgbiA8IHVuaWZvcm1zLk4pIHtcbiAgICAgbGV0IG91dHB1dElkeCA9IGJhdGNoSWR4ICogdW5pZm9ybXMuTSAqIHVuaWZvcm1zLnZfaGlkZGVuX3NpemUgKyBtICogdW5pZm9ybXMudl9oaWRkZW5fc2l6ZVxuICAgICAgICsgaGVhZElkeCAqIHVuaWZvcm1zLk4gKyBuO1xuICAgICBvdXRwdXRbb3V0cHV0SWR4XSA9IHZhbHVlO1xuICAgfVxuICB9YH07cmV0dXJue25hbWU6XCJBdHRlbnRpb25TY29yZVwiLHNoYWRlckNhY2hlOntoaW50OmAke24hPT12b2lkIDB9OyR7ZX1gLGlucHV0RGVwZW5kZW5jaWVzOlN9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpULGRpc3BhdGNoR3JvdXA6eCxwcm9ncmFtVW5pZm9ybXM6JH0pLGdldFNoYWRlclNvdXJjZTpBfX0sUnQ9KGUsdCxyLG4sbyxpLGEsZCxsLHAsbT12b2lkIDAsdT12b2lkIDApPT57bGV0IGg9TWF0aC5taW4oZS5vdXRwdXRDb3VudCwxKyhhPzE6MCkrKGQ/MTowKSksXz1oPjE/cC5wYXN0U2VxdWVuY2VMZW5ndGg6MCx5PV8rcC5rdlNlcXVlbmNlTGVuZ3RoLGc9bCYmQy5zaXplKGwuZGltcyk+MD9sOnZvaWQgMCx4PVt0LHJdO2g+MSYmYSYmQy5zaXplKGEuZGltcyk+MCYmeC5wdXNoKGEpLGcmJngucHVzaChnKSxtJiZ4LnB1c2gobSksdSYmeC5wdXNoKHUpO2xldCAkPWUuY29tcHV0ZShSbShoLHQscixhLGcscCxfLG0sdSkse2lucHV0czp4LG91dHB1dHM6aD4xP1stMSwxXTpbLTFdfSlbMF07ZS5jb21wdXRlKE1tKCQscC5iYXRjaFNpemUscC5udW1IZWFkcyxfLHAuc2VxdWVuY2VMZW5ndGgseSxtLHUpLHtpbnB1dHM6bSYmdT9bJCxtLHVdOlskXSxvdXRwdXRzOltdfSk7bGV0IHY9WyQsbl07aD4xJiZkJiZDLnNpemUoZC5kaW1zKT4wJiZ2LnB1c2goZCksbSYmdi5wdXNoKG0pLHUmJnYucHVzaCh1KSxlLmNvbXB1dGUoVW0oaCwkLG4sZCxwLF8sbSx1KSx7aW5wdXRzOnYsb3V0cHV0czpoPjE/WzAsMl06WzBdfSl9LE5tPShlLHQpPT57bGV0IHI9W3QuYmF0Y2hTaXplLHQubnVtSGVhZHMsdC5zZXF1ZW5jZUxlbmd0aCx0LmhlYWRTaXplXSxuPXQuc2VxdWVuY2VMZW5ndGgsbz10LmlucHV0SGlkZGVuU2l6ZSxpPXQuaGVhZFNpemUsYT0xMixkPXt4Ok1hdGguY2VpbCh0LmhlYWRTaXplL2EpLHk6TWF0aC5jZWlsKHQuc2VxdWVuY2VMZW5ndGgvYSksejp0LmJhdGNoU2l6ZSp0Lm51bUhlYWRzfSxsPVtlLmlucHV0c1swXSxlLmlucHV0c1sxXSxlLmlucHV0c1syXV0scD1be3R5cGU6MTIsZGF0YTpufSx7dHlwZToxMixkYXRhOm99LHt0eXBlOjEyLGRhdGE6aX0se3R5cGU6MTIsZGF0YTp0Lm51bUhlYWRzfSx7dHlwZToxMixkYXRhOnQuaGVhZFNpemV9LHt0eXBlOjEyLGRhdGE6dC5oaWRkZW5TaXplfSx7dHlwZToxMixkYXRhOnQuaGlkZGVuU2l6ZSt0LmhpZGRlblNpemUrdC52SGlkZGVuU2l6ZX1dLG09dT0+e2xldCBoPU0oXCJvdXRwdXRfcVwiLGxbMF0uZGF0YVR5cGUsciksXz1NKFwib3V0cHV0X2tcIixsWzBdLmRhdGFUeXBlLHIpLHk9TShcIm91dHB1dF92XCIsbFswXS5kYXRhVHlwZSxyKSxnPUUoXCJpbnB1dFwiLGxbMF0uZGF0YVR5cGUsbFswXS5kaW1zKSx4PUUoXCJ3ZWlnaHRcIixsWzFdLmRhdGFUeXBlLGxbMV0uZGltcyksJD1FKFwiYmlhc1wiLGxbMl0uZGF0YVR5cGUsbFsyXS5kaW1zKSx2PWcudHlwZS5zdG9yYWdlLFM9W3tuYW1lOlwiTVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJLXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIk5cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibnVtX2hlYWRzXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImhlYWRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJoaWRkZW5fc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJsZGJcIix0eXBlOlwidTMyXCJ9XTtyZXR1cm5gXG4gIGNvbnN0IFRJTEVfU0laRSA9ICR7YX11O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlSW5wdXQ6IGFycmF5PCR7dn0sICR7YSphfT47XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVXZWlnaHRROiBhcnJheTwke3Z9LCAke2EqYX0+O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlV2VpZ2h0SzogYXJyYXk8JHt2fSwgJHthKmF9PjtcbiAgdmFyPHdvcmtncm91cD4gdGlsZVdlaWdodFY6IGFycmF5PCR7dn0sICR7YSphfT47XG4gICR7dS5yZWdpc3RlclVuaWZvcm1zKFMpLmRlY2xhcmVWYXJpYWJsZXMoZyx4LCQsaCxfLHkpfVxuICAke3UubWFpblN0YXJ0KFthLGEsMV0pfVxuICAgIGxldCBiYXRjaEluZGV4ID0gd29ya2dyb3VwX2lkLnogLyB1bmlmb3Jtcy5udW1faGVhZHM7XG4gICAgbGV0IGhlYWROdW1iZXIgPSB3b3JrZ3JvdXBfaWQueiAlIHVuaWZvcm1zLm51bV9oZWFkcztcbiAgICBsZXQgbSA9IGdsb2JhbF9pZC55O1xuICAgIGxldCBuID0gZ2xvYmFsX2lkLng7XG5cbiAgICBsZXQgaW5wdXRPZmZzZXQgPSBiYXRjaEluZGV4ICogKHVuaWZvcm1zLk0gKiB1bmlmb3Jtcy5LKSArIG0gKiB1bmlmb3Jtcy5LO1xuICAgIGxldCBiaWFzT2Zmc2V0USA9IGhlYWROdW1iZXIgKiB1bmlmb3Jtcy5oZWFkX3NpemU7XG4gICAgbGV0IGJpYXNPZmZzZXRLID0gdW5pZm9ybXMuaGlkZGVuX3NpemUgKyBiaWFzT2Zmc2V0UTtcbiAgICBsZXQgYmlhc09mZnNldFYgPSB1bmlmb3Jtcy5oaWRkZW5fc2l6ZSArIGJpYXNPZmZzZXRLO1xuXG4gICAgdmFyIHZhbHVlUSA9ICR7dn0oMCk7XG4gICAgdmFyIHZhbHVlSyA9ICR7dn0oMCk7XG4gICAgdmFyIHZhbHVlViA9ICR7dn0oMCk7XG4gICAgZm9yICh2YXIgdzogdTMyID0gMHU7IHcgPCB1bmlmb3Jtcy5LOyB3ICs9IFRJTEVfU0laRSkge1xuICAgICAgaWYgKG0gPCB1bmlmb3Jtcy5NICYmIHcgKyBsb2NhbF9pZC54IDwgdW5pZm9ybXMuSykge1xuICAgICAgICB0aWxlSW5wdXRbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLnhdID0gaW5wdXRbaW5wdXRPZmZzZXQgKyB3ICsgbG9jYWxfaWQueF07XG4gICAgICB9XG4gICAgICBpZiAobiA8IHVuaWZvcm1zLk4gJiYgdyArIGxvY2FsX2lkLnkgPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIGxldCBvZmZzZXQgPSBuICsgKHcgKyBsb2NhbF9pZC55KSAqIHVuaWZvcm1zLmxkYjtcbiAgICAgICAgdGlsZVdlaWdodFFbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLnhdID0gd2VpZ2h0W2JpYXNPZmZzZXRRICsgb2Zmc2V0XTtcbiAgICAgICAgdGlsZVdlaWdodEtbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLnhdID0gd2VpZ2h0W2JpYXNPZmZzZXRLICsgb2Zmc2V0XTtcbiAgICAgICAgdGlsZVdlaWdodFZbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLnhdID0gd2VpZ2h0W2JpYXNPZmZzZXRWICsgb2Zmc2V0XTtcbiAgICAgIH1cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICAgIGZvciAodmFyIGs6IHUzMiA9IDB1OyBrPFRJTEVfU0laRSAmJiB3K2sgPCB1bmlmb3Jtcy5LOyBrKyspIHtcbiAgICAgICAgbGV0IGlucHV0VGlsZU9mZnNldCA9IFRJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBrO1xuICAgICAgICBsZXQgd2VpZ2h0VGlsZU9mZnNldCA9IFRJTEVfU0laRSAqIGsgKyBsb2NhbF9pZC54O1xuICAgICAgICB2YWx1ZVEgKz0gdGlsZUlucHV0W2lucHV0VGlsZU9mZnNldF0gKiB0aWxlV2VpZ2h0UVt3ZWlnaHRUaWxlT2Zmc2V0XTtcbiAgICAgICAgdmFsdWVLICs9IHRpbGVJbnB1dFtpbnB1dFRpbGVPZmZzZXRdICogdGlsZVdlaWdodEtbd2VpZ2h0VGlsZU9mZnNldF07XG4gICAgICAgIHZhbHVlViArPSB0aWxlSW5wdXRbaW5wdXRUaWxlT2Zmc2V0XSAqIHRpbGVXZWlnaHRWW3dlaWdodFRpbGVPZmZzZXRdO1xuICAgICAgfVxuXG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgfVxuXG4gICAgbGV0IGhlYWRPZmZzZXQgPSAobSAqIHVuaWZvcm1zLk4gKyBuKSAlIHVuaWZvcm1zLmhlYWRfc2l6ZTtcbiAgICB2YWx1ZVEgKz0gYmlhc1toZWFkT2Zmc2V0ICsgYmlhc09mZnNldFFdO1xuICAgIHZhbHVlSyArPSBiaWFzW2hlYWRPZmZzZXQgKyBiaWFzT2Zmc2V0S107XG4gICAgdmFsdWVWICs9IGJpYXNbaGVhZE9mZnNldCArIGJpYXNPZmZzZXRWXTtcblxuICAgIGxldCBvZmZzZXQgPSB3b3JrZ3JvdXBfaWQueiAqIHVuaWZvcm1zLk0gKiB1bmlmb3Jtcy5OO1xuICAgIGlmIChtIDwgdW5pZm9ybXMuTSAmJiBuIDwgdW5pZm9ybXMuTikge1xuICAgICAgbGV0IG91dHB1dElkeCA9IG9mZnNldCArIG0gKiB1bmlmb3Jtcy5OICsgbjtcbiAgICAgIG91dHB1dF9xW291dHB1dElkeF0gPSB2YWx1ZVE7XG4gICAgICBvdXRwdXRfa1tvdXRwdXRJZHhdID0gdmFsdWVLO1xuICAgICAgb3V0cHV0X3Zbb3V0cHV0SWR4XSA9IHZhbHVlVjtcbiAgICB9XG4gIH1gfTtyZXR1cm4gZS5jb21wdXRlKHtuYW1lOlwiQXR0ZW50aW9uUHJlcGFyZVwiLHNoYWRlckNhY2hlOntpbnB1dERlcGVuZGVuY2llczpbXCJ0eXBlXCIsXCJ0eXBlXCIsXCJ0eXBlXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnIsZGF0YVR5cGU6ZS5pbnB1dHNbMF0uZGF0YVR5cGUsZ3B1RGF0YVR5cGU6MH0se2RpbXM6cixkYXRhVHlwZTplLmlucHV0c1swXS5kYXRhVHlwZSxncHVEYXRhVHlwZTowfSx7ZGltczpyLGRhdGFUeXBlOmUuaW5wdXRzWzBdLmRhdGFUeXBlLGdwdURhdGFUeXBlOjB9XSxkaXNwYXRjaEdyb3VwOmQscHJvZ3JhbVVuaWZvcm1zOnB9KSxnZXRTaGFkZXJTb3VyY2U6bX0se2lucHV0czpsLG91dHB1dHM6Wy0xLC0xLC0xXX0pfSx6cz0oZSx0KT0+e2xldCByPUJtKGUuaW5wdXRzLHQpLFtuLG8saV09Tm0oZSxyKTtyZXR1cm4gUnQoZSxuLG8saSxlLmlucHV0c1s0XSx2b2lkIDAsdm9pZCAwLHZvaWQgMCxlLmlucHV0c1s1XSxyKX19KTt2YXIgVm0sV20sTG0sT3MsRHM9VSgoKT0+e1widXNlIHN0cmljdFwiO1dlKCk7dGUoKTtvZSgpO1NlKCk7YWUoKTtWbT0oZSx0KT0+e2lmKCFlfHxlLmxlbmd0aCE9PTUpdGhyb3cgbmV3IEVycm9yKFwiQmF0Y2hOb3JtYWxpemF0aW9uIHJlcXVpcmVzIDUgaW5wdXRzXCIpO2xldCByPShuLG8saSk9PntsZXQgYT1vLmxlbmd0aDtpZihhIT09bi5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGAke2l9OiBudW0gZGltZW5zaW9ucyAhPSAke2F9YCk7by5mb3JFYWNoKChkLGwpPT57aWYoZCE9PW5bbF0pdGhyb3cgbmV3IEVycm9yKGAke2l9OiBkaW1bJHtsfV0gZG8gbm90IG1hdGNoYCl9KX07aWYoZVswXS5kaW1zLmxlbmd0aD4xKXtsZXQgbj10LmZvcm1hdD09PVwiTkhXQ1wiP3Quc3BhdGlhbD9lWzBdLmRpbXMuc2xpY2UoLTEpOmVbMF0uZGltcy5zbGljZSgtMSkuY29uY2F0KGVbMF0uZGltcy5zbGljZSgxLGVbMF0uZGltcy5sZW5ndGgtMSkpOmVbMF0uZGltcy5zbGljZSgxLHQuc3BhdGlhbD8yOnZvaWQgMCk7cihlWzFdLmRpbXMsbixcIkludmFsaWQgaW5wdXQgc2NhbGVcIikscihlWzJdLmRpbXMsbixcIkludmFsaWQgaW5wdXQgQlwiKSxyKGVbM10uZGltcyxuLFwiSW52YWxpZCBpbnB1dCBtZWFuXCIpLHIoZVs0XS5kaW1zLG4sXCJJbnZhbGlkIGlucHV0IHZhclwiKX1lbHNlIHIoZVsxXS5kaW1zLFsxXSxcIkludmFsaWQgaW5wdXQgc2NhbGVcIikscihlWzJdLmRpbXMsWzFdLFwiSW52YWxpZCBpbnB1dCBCXCIpLHIoZVszXS5kaW1zLFsxXSxcIkludmFsaWQgaW5wdXQgbWVhblwiKSxyKGVbNF0uZGltcyxbMV0sXCJJbnZhbGlkIGlucHV0IHZhclwiKX0sV209KGUsdCk9PntsZXR7ZXBzaWxvbjpyLHNwYXRpYWw6bixmb3JtYXQ6b309dCxpPWVbMF0uZGltcyxhPW4/bWUoaVtpLmxlbmd0aC0xXSk6MSxkPW89PT1cIk5IV0NcIiYmaS5sZW5ndGg+MT9hOjEsbD1DLnNpemUoaSkvYSxwPW4sbT1wP2kubGVuZ3RoOmksdT1FKFwieFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLGEpLGg9RShcInNjYWxlXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMsZCksXz1FKFwiYmlhc1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLGQpLHk9RShcImlucHV0TWVhblwiLGVbM10uZGF0YVR5cGUsZVszXS5kaW1zLGQpLGc9RShcImlucHV0VmFyXCIsZVs0XS5kYXRhVHlwZSxlWzRdLmRpbXMsZCkseD1NKFwieVwiLGVbMF0uZGF0YVR5cGUsbSxhKSwkPSgpPT57bGV0IFM9XCJcIjtpZihuKVM9YGxldCBjT2Zmc2V0ID0gJHtpLmxlbmd0aD09PTE/XCIwdVwiOm89PT1cIk5IV0NcIj9gb3V0cHV0SW5kaWNlc1ske2kubGVuZ3RoLTF9XSAvICR7YX1gOlwib3V0cHV0SW5kaWNlc1sxXVwifTtgO2Vsc2UgaWYobz09PVwiTkNIV1wiKVM9YFxuICAgICAgICAgICAgJHt4LmluZGljZXNTZXQoXCJvdXRwdXRJbmRpY2VzXCIsXCIwXCIsXCIwXCIpfVxuICAgICAgICAgICAgbGV0IGNPZmZzZXQgPSAke3guaW5kaWNlc1RvT2Zmc2V0KFwib3V0cHV0SW5kaWNlc1wiKX07YDtlbHNle1M9YHZhciBjSW5kaWNlcyA9ICR7aC50eXBlLmluZGljZXN9KDApO1xuICAgICAgICAgICAgICAgICAgICAgICBjSW5kaWNlc1swXSA9IG91dHB1dEluZGljZXNbJHtpLmxlbmd0aC0xfV07YDtmb3IobGV0IFQ9MTtUPGgucmFuaztUKyspUys9YGNJbmRpY2VzWyR7VH1dID0gb3V0cHV0SW5kaWNlc1ske1R9XTtgO1MrPWBsZXQgY09mZnNldCA9ICR7aC5pbmRpY2VzVG9PZmZzZXQoXCJjSW5kaWNlc1wiKX07YH1yZXR1cm4gU30sdj1TPT5gXG4gIGNvbnN0IGVwc2lsb24gPSAke3J9O1xuICAke1MucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0U2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXModSxoLF8seSxnLHgpfVxuICAke1MubWFpblN0YXJ0KCl9XG4gICR7Uy5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0U2l6ZVwiKX1cbiAgICB2YXIgb3V0cHV0SW5kaWNlcyA9ICR7eC5vZmZzZXRUb0luZGljZXMoYGdsb2JhbF9pZHggKiAke2F9YCl9O1xuICAgICR7JCgpfVxuICAgIGxldCBzY2FsZSA9ICR7aC5nZXRCeU9mZnNldChcImNPZmZzZXRcIil9O1xuICAgIGxldCBiaWFzID0gJHtfLmdldEJ5T2Zmc2V0KFwiY09mZnNldFwiKX07XG4gICAgbGV0IGlucHV0TWVhbiA9ICR7eS5nZXRCeU9mZnNldChcImNPZmZzZXRcIil9O1xuICAgIGxldCBpbnB1dFZhciA9ICR7Zy5nZXRCeU9mZnNldChcImNPZmZzZXRcIil9O1xuICAgIGxldCB4ID0gJHt1LmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgbGV0IHZhbHVlID0gKHggLSBpbnB1dE1lYW4pICogaW52ZXJzZVNxcnQoaW5wdXRWYXIgKyBlcHNpbG9uKSAqIHNjYWxlICsgYmlhcztcbiAgICAke3guc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKX1cbiAgfWA7cmV0dXJue25hbWU6XCJCYXRjaE5vcm1hbGl6YXRpb25cIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmVwc2lsb259XyR7dC5mb3JtYXR9XyR7bn1fJHthfWAsaW5wdXREZXBlbmRlbmNpZXM6cD9bXCJyYW5rXCIsXCJ0eXBlXCIsXCJ0eXBlXCIsXCJ0eXBlXCIsXCJ0eXBlXCJdOnZvaWQgMH0sZ2V0U2hhZGVyU291cmNlOnYsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczplWzBdLmRpbXMsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGwvNjQpfSxwcm9ncmFtVW5pZm9ybXM6cD9be3R5cGU6MTIsZGF0YTpsfSwuLi5OKGkpXTpbe3R5cGU6MTIsZGF0YTpsfV19KX19LExtPWU9PnJlKGUpLE9zPShlLHQpPT57bGV0e2lucHV0czpyLG91dHB1dENvdW50Om59PWUsbz1MbSh7Li4udCxvdXRwdXRDb3VudDpufSk7aWYodmUud2ViZ3B1LnZhbGlkYXRlSW5wdXRDb250ZW50JiZWbShyLG8pLHQudHJhaW5pbmdNb2RlKXRocm93IG5ldyBFcnJvcihcIkJhdGNoTm9ybWFsaXphdGlvbiB0cmFpbmluZ01vZGUgaXMgbm90IHN1cHBvcnRlZCB5ZXQuXCIpO2UuY29tcHV0ZShXbShyLG8pKX19KTt2YXIgR20sSG0sQnMsTXM9VSgoKT0+e1widXNlIHN0cmljdFwiO29lKCk7YWUoKTtHbT1lPT57aWYoZVswXS5kaW1zLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgc2hvdWxkIGhhdmUgMyBkaW1lbnNpb25zXCIpO2lmKCFbMzIwLDY0MCwxMjgwXS5pbmNsdWRlcyhlWzBdLmRpbXNbMl0pKXRocm93IG5ldyBFcnJvcihcIm51bWJlciBvZiBjaGFubmVscyBzaG91bGQgYmUgMzIwLCA2NDAgb3IgMTI4MFwiKTtpZihlWzFdLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJiaWFzIGlzIGV4cGVjdGVkIHRvIGhhdmUgMSBkaW1lbnNpb25zXCIpO2lmKGVbMF0uZGltc1syXSE9PWVbMV0uZGltc1swXSl0aHJvdyBuZXcgRXJyb3IoXCJsYXN0IGRpbWVuc2lvbiBvZiBpbnB1dCBhbmQgYmlhcyBhcmUgbm90IHRoZSBzYW1lXCIpfSxIbT1lPT57bGV0IHQ9ZVswXS5kaW1zLHI9ZVswXS5kaW1zWzJdLG49Qy5zaXplKHQpLzQsbz1lWzBdLmRhdGFUeXBlLGk9RShcImlucHV0XCIsbyx0LDQpLGE9RShcImJpYXNcIixvLFtyXSw0KSxkPUUoXCJyZXNpZHVhbFwiLG8sdCw0KSxsPU0oXCJvdXRwdXRcIixvLHQsNCk7cmV0dXJue25hbWU6XCJCaWFzQWRkXCIsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczp0LGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChuLzY0KX19KSxnZXRTaGFkZXJTb3VyY2U6bT0+YFxuICBjb25zdCBjaGFubmVscyA9ICR7cn11IC8gNDtcbiAgJHttLmRlY2xhcmVWYXJpYWJsZXMoaSxhLGQsbCl9XG5cbiAgJHttLm1haW5TdGFydCgpfVxuICAgICR7bS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKG4pfVxuICAgIGxldCB2YWx1ZSA9ICR7aS5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIil9XG4gICAgICArICR7YS5nZXRCeU9mZnNldChcImdsb2JhbF9pZHggJSBjaGFubmVsc1wiKX0gKyAke2QuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAke2wuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKX1cbiAgfWB9fSxCcz1lPT57R20oZS5pbnB1dHMpLGUuY29tcHV0ZShIbShlLmlucHV0cykpfX0pO3ZhciBGbSxmZSxScyxVcyxOcyxWcyxXcyxMcyxHcyxIcyxGcyxxbSxxcyxLcyxqcyxZcyxYdCxacyxxcixRcyxYcyxKcyxldSx0dSxydSxudSxvdSxpdSxhdSxzdSx1dSxkdSxsdSxjdSxwdSxtdSxmdSxtbyxmbyxodSxndSxidSxLbSxqbSx5dSxLcj1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtvZSgpO1NlKCk7YWUoKTtGbT0oZSx0LHIsbixvLGksYSk9PntsZXQgZD1NYXRoLmNlaWwodC80KSxsPVwiXCI7dHlwZW9mIG89PVwic3RyaW5nXCI/bD1gJHtvfShhKWA6bD1vKFwiYVwiKTtsZXQgcD1FKFwiaW5wdXREYXRhXCIscixbZF0sNCksbT1NKFwib3V0cHV0RGF0YVwiLG4sW2RdLDQpLHU9W3tuYW1lOlwidmVjX3NpemVcIix0eXBlOlwidTMyXCJ9XTtyZXR1cm4gYSYmdS5wdXNoKC4uLmEpLGBcbiAgICAgICR7ZS5yZWdpc3RlclVuaWZvcm1zKHUpLmRlY2xhcmVWYXJpYWJsZXMocCxtKX1cblxuICAke2k/P1wiXCJ9XG5cbiAgJHtlLm1haW5TdGFydCgpfVxuICAgICR7ZS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMudmVjX3NpemVcIil9XG5cbiAgICBsZXQgYSA9ICR7cC5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIil9O1xuICAgICR7bS5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixsKX1cbiAgfWB9LGZlPShlLHQscixuLG8saT1lLmRhdGFUeXBlLGEsZCk9PntsZXQgbD1be3R5cGU6MTIsZGF0YTpNYXRoLmNlaWwoQy5zaXplKGUuZGltcykvNCl9XTtyZXR1cm4gYSYmbC5wdXNoKC4uLmEpLHtuYW1lOnQsc2hhZGVyQ2FjaGU6e2hpbnQ6byxpbnB1dERlcGVuZGVuY2llczpbXCJ0eXBlXCJdfSxnZXRTaGFkZXJTb3VyY2U6cD0+Rm0ocCxDLnNpemUoZS5kaW1zKSxlLmRhdGFUeXBlLGkscixuLGQpLGdldFJ1bkRhdGE6cD0+KHtvdXRwdXRzOlt7ZGltczplLmRpbXMsZGF0YVR5cGU6aX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKEMuc2l6ZShwWzBdLmRpbXMpLzY0LzQpfSxwcm9ncmFtVW5pZm9ybXM6bH0pfX0sUnM9ZT0+e2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIkFic1wiLFwiYWJzXCIpKX0sVXM9ZT0+e2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIkFjb3NcIixcImFjb3NcIikpfSxOcz1lPT57ZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiQWNvc2hcIixcImFjb3NoXCIpKX0sVnM9ZT0+e2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIkFzaW5cIixcImFzaW5cIikpfSxXcz1lPT57ZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiQXNpbmhcIixcImFzaW5oXCIpKX0sTHM9ZT0+e2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIkF0YW5cIixcImF0YW5cIikpfSxHcz1lPT57ZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiQXRhbmhcIixcImF0YW5oXCIpKX0sSHM9ZT0+cmUoZSksRnM9KGUsdCk9PntsZXQgcjtzd2l0Y2godC50byl7Y2FzZSAxMDpyPVwidmVjNDxmMTY+XCI7YnJlYWs7Y2FzZSAxOnI9XCJ2ZWM0PGYzMj5cIjticmVhaztjYXNlIDEyOnI9XCJ2ZWM0PHUzMj5cIjticmVhaztjYXNlIDY6cj1cInZlYzQ8aTMyPlwiO2JyZWFrO2Nhc2UgOTpyPVwidmVjNDxib29sPlwiO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IFJhbmdlRXJyb3IoYG5vdCBzdXBwb3J0ZWQgdHlwZSAoc3BlY2lmaWVkIGluIGF0dHJpYnV0ZSAndG8nIGZyb20gJ0Nhc3QnIG9wZXJhdG9yKTogJHt0LnRvfWApfWUuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIkNhc3RcIixyLHZvaWQgMCx0LmNhY2hlS2V5LHQudG8pKX0scW09ZT0+e2xldCB0LHIsbj1lLmxlbmd0aD49MiYmZVsxXS5kYXRhIT09MCxvPWUubGVuZ3RoPj0zJiZlWzJdLmRhdGEhPT0wO3N3aXRjaChlWzBdLmRhdGFUeXBlKXtjYXNlIDE6dD1uP2VbMV0uZ2V0RmxvYXQzMkFycmF5KClbMF06LTM0MDI4MjM0NjYzODUyODg2ZTIyLHI9bz9lWzJdLmdldEZsb2F0MzJBcnJheSgpWzBdOjM0MDI4MjM0NjYzODUyODg2ZTIyO2JyZWFrO2Nhc2UgMTA6dD1uP2VbMV0uZ2V0VWludDE2QXJyYXkoKVswXTo2NDUxMSxyPW8/ZVsyXS5nZXRVaW50MTZBcnJheSgpWzBdOjMxNzQzO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0IGRhdGEgdHlwZVwiKX1yZXR1cm4gcmUoe21pbjp0LG1heDpyfSl9LHFzPShlLHQpPT57bGV0IHI9dHx8cW0oZS5pbnB1dHMpLG49RWUoZS5pbnB1dHNbMF0uZGF0YVR5cGUpO2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIkNsaXBcIixvPT5gY2xhbXAoJHtvfSwgdmVjNDwke259Pih1bmlmb3Jtcy5taW4pLCB2ZWM0PCR7bn0+KHVuaWZvcm1zLm1heCkpYCx2b2lkIDAsci5jYWNoZUtleSx2b2lkIDAsW3t0eXBlOmUuaW5wdXRzWzBdLmRhdGFUeXBlLGRhdGE6ci5taW59LHt0eXBlOmUuaW5wdXRzWzBdLmRhdGFUeXBlLGRhdGE6ci5tYXh9XSxbe25hbWU6XCJtaW5cIix0eXBlOm59LHtuYW1lOlwibWF4XCIsdHlwZTpufV0pLHtpbnB1dHM6WzBdfSl9LEtzPWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJDZWlsXCIsXCJjZWlsXCIpKX0sanM9ZT0+e2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIkNvc1wiLFwiY29zXCIpKX0sWXM9ZT0+e2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIkNvc2hcIixcImNvc2hcIikpfSxYdD1lPT5yZShlKSxacz0oZSx0KT0+e2xldCByPUVlKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJFbHVcIixuPT5gZWx1X3ZmMzIoJHtufSlgLGBcbiAgY29uc3QgZWx1X2FscGhhXyA9ICR7cn0oJHt0LmFscGhhfSk7XG5cbiAgZm4gZWx1X2YzMihhOiAke3J9KSAtPiAke3J9IHtcbiAgcmV0dXJuIHNlbGVjdCgoZXhwKGEpIC0gMS4wKSAqIGVsdV9hbHBoYV8sIGEsIGEgPj0gMC4wKTtcbiAgfVxuXG4gIGZuIGVsdV92ZjMyKHY6IHZlYzQ8JHtyfT4pIC0+IHZlYzQ8JHtyfT4ge1xuICByZXR1cm4gdmVjNChlbHVfZjMyKHYueCksIGVsdV9mMzIodi55KSwgZWx1X2YzMih2LnopLCBlbHVfZjMyKHYudykpO1xuICB9YCx0LmNhY2hlS2V5KSl9LHFyPShlPVwiZjMyXCIpPT5gXG5jb25zdCByMDogJHtlfSA9IDAuMzI3NTkxMTtcbmNvbnN0IHIxOiAke2V9ID0gMC4yNTQ4Mjk1OTI7XG5jb25zdCByMjogJHtlfSA9IC0wLjI4NDQ5NjczNjtcbmNvbnN0IHIzOiAke2V9ID0gMS40MjE0MTM3NDE7XG5jb25zdCByNDogJHtlfSA9IC0xLjQ1MzE1MjAyNztcbmNvbnN0IHI1OiAke2V9ID0gMS4wNjE0MDU0Mjk7XG5cbmZuIGVyZl92ZjMyKHY6IHZlYzQ8JHtlfT4pIC0+IHZlYzQ8JHtlfT4ge1xuICBsZXQgYWJzdiA9IGFicyh2KTtcbiAgbGV0IHggPSAxLjAgLyAoMS4wICsgcjAgKiBhYnN2KTtcbiAgcmV0dXJuIHNpZ24odikgKiAoMS4wIC0gKCgoKHI1ICogeCArIHI0KSAqIHggKyByMykgKiB4ICsgcjIpICogeCArIHIxKSAqIHggKiBleHAoLWFic3YgKiBhYnN2KSk7XG59YCxRcz1lPT57bGV0IHQ9RWUoZS5pbnB1dHNbMF0uZGF0YVR5cGUpO2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIkVyZlwiLHI9PmBlcmZfdmYzMigke3J9KWAscXIodCkpKX0sWHM9ZT0+e2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIkV4cFwiLFwiZXhwXCIpKX0sSnM9ZT0+e2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIkZsb29yXCIsXCJmbG9vclwiKSl9LGV1PWU9PntsZXQgdD1FZShlLmlucHV0c1swXS5kYXRhVHlwZSk7ZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiR2VsdVwiLHI9PmAwLjUgKiAke3J9ICogKDEuMCArIGVyZl92ZjMyKCR7cn0gKiAwLjcwNzEwNjc4MTE4NjU0NzUpKWAscXIodCkpKX0sdHU9KGUsdCk9PntsZXQgcj1FZShlLmlucHV0c1swXS5kYXRhVHlwZSk7ZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiTGVha3lSZWx1XCIsbj0+YHNlbGVjdChsZWFreV9yZWx1X2FscGhhXyAqICR7bn0sICR7bn0sICR7bn0gPj0gdmVjNDwke3J9PigwLjApKWAsYGNvbnN0IGxlYWt5X3JlbHVfYWxwaGFfID0gJHtyfSgke3QuYWxwaGF9KTtgLHQuY2FjaGVLZXkpKX0scnU9ZT0+e2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIk5vdFwiLHQ9PmAhJHt0fWApKX0sbnU9ZT0+e2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIk5lZ1wiLHQ9PmAtJHt0fWApKX0sb3U9ZT0+e2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIlJlY2lwcm9jYWxcIix0PT5gMS4wLyR7dH1gKSl9LGl1PWU9PntsZXQgdD1FZShlLmlucHV0c1swXS5kYXRhVHlwZSk7ZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiUmVsdVwiLHI9PmBzZWxlY3QodmVjNDwke3R9PigwLjApLCAke3J9LCAke3J9ID4gdmVjNDwke3R9PigwLjApKWApKX0sYXU9ZT0+e2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIlNpZ21vaWRcIix0PT5gKDEuMCAvICgxLjAgKyBleHAoLSR7dH0pKSlgKSl9LHN1PWU9PnJlKGUpLHV1PShlLHQpPT57bGV0IHI9RWUoZS5pbnB1dHNbMF0uZGF0YVR5cGUpO2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIkhhcmRTaWdtb2lkXCIsbj0+YG1heCh2ZWM0PCR7cn0+KDAuMCksIG1pbih2ZWM0PCR7cn0+KDEuMCksICR7dC5hbHBoYX0gKiAke259ICsgdmVjNDwke3J9Pigke3QuYmV0YX0pKSlgLHZvaWQgMCx0LmNhY2hlS2V5KSl9LGR1PWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJTaW5cIixcInNpblwiKSl9LGx1PWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJTaW5oXCIsXCJzaW5oXCIpKX0sY3U9ZT0+e2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIlNxcnRcIixcInNxcnRcIikpfSxwdT1lPT57ZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiVGFuXCIsXCJ0YW5cIikpfSxtdT1lPT5gc2lnbigke2V9KSAqICgxIC0gZXhwKC0yICogYWJzKCR7ZX0pKSkgLyAoMSArIGV4cCgtMiAqIGFicygke2V9KSkpYCxmdT1lPT57ZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiVGFuaFwiLG11KSl9LG1vPShlPVwiZjMyXCIpPT5gXG5jb25zdCBmYXN0X2dlbHVfYTogJHtlfSA9IDAuNTtcbmNvbnN0IGZhc3RfZ2VsdV9iOiAke2V9ID0gMC43OTc4ODQ1NjA4MDI4NjU0O1xuY29uc3QgZmFzdF9nZWx1X2M6ICR7ZX0gPSAwLjAzNTY3NzQwODEzNjMwMDEyNTtcblxuZm4gdGFuaF92KHY6IHZlYzQ8JHtlfT4pIC0+IHZlYzQ8JHtlfT4ge1xuICByZXR1cm4gJHttdShcInZcIil9O1xufVxuYCxmbz1lPT5gKGZhc3RfZ2VsdV9hICsgZmFzdF9nZWx1X2EgKiB0YW5oX3YoJHtlfSAqIChmYXN0X2dlbHVfYyAqICR7ZX0gKiAke2V9ICsgZmFzdF9nZWx1X2IpKSkgKiAke2V9YCxodT1lPT57bGV0IHQ9RWUoZS5pbnB1dHNbMF0uZGF0YVR5cGUpO2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIkZhc3RHZWx1XCIsZm8sbW8odCksdm9pZCAwLGUuaW5wdXRzWzBdLmRhdGFUeXBlKSl9LGd1PShlLHQpPT57bGV0IHI9RWUoZS5pbnB1dHNbMF0uZGF0YVR5cGUpO3JldHVybiBlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJUaHJlc2hvbGRlZFJlbHVcIixuPT5gc2VsZWN0KHZlYzQ8JHtyfT4oMC4wKSwgJHtufSwgJHtufSA+IHRocmVzaG9sZGVkX3JlbHVfYWxwaGFfKWAsYGNvbnN0IHRocmVzaG9sZGVkX3JlbHVfYWxwaGFfID0gdmVjNDwke3J9Pigke3QuYWxwaGF9KTtgLHQuY2FjaGVLZXkpKSwwfSxidT1lPT57ZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiTG9nXCIsXCJsb2dcIikpfSxLbT0oZSx0KT0+YFxuY29uc3QgYWxwaGEgPSB2ZWM0PCR7ZX0+KCR7dH0pO1xuY29uc3Qgb25lID0gJHtlfSgxLjApO1xuY29uc3QgemVybyA9ICR7ZX0oMC4wKTtcblxuZm4gcXVpY2tfZ2VsdV9pbXBsKHg6IHZlYzQ8JHtlfT4pIC0+IHZlYzQ8JHtlfT4ge1xuICBsZXQgdiA9IHggKmFscGhhO1xuICB2YXIgeDEgOiB2ZWM0PCR7ZX0+O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkgPSBpICsgMSkge1xuICAgIGlmICh2W2ldID49IHplcm8pIHtcbiAgICAgIHgxW2ldID0gb25lIC8gKG9uZSArIGV4cCgtdltpXSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB4MVtpXSA9IG9uZSAtIG9uZSAvIChvbmUgKyBleHAodltpXSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4geCAqIHgxO1xufVxuYCxqbT1lPT5gcXVpY2tfZ2VsdV9pbXBsKCR7ZX0pYCx5dT0oZSx0KT0+e2xldCByPUVlKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJRdWlja0dlbHVcIixqbSxLbShyLHQuYWxwaGEpLHQuY2FjaGVLZXksZS5pbnB1dHNbMF0uZGF0YVR5cGUpKX19KTt2YXIgWW0sWm0sd3UsdnU9VSgoKT0+e1widXNlIHN0cmljdFwiO29lKCk7YWUoKTtLcigpO1ltPWU9PntpZihlWzBdLmRpbXMubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCBzaG91bGQgaGF2ZSAzIGRpbWVuc2lvbnNcIik7aWYoIVsyNTYwLDUxMjAsMTAyNDBdLmluY2x1ZGVzKGVbMF0uZGltc1syXSkpdGhyb3cgbmV3IEVycm9yKFwiaGlkZGVuIHN0YXRlIHNob3VsZCBiZSAyNTYwLCA1MTIwIG9yIDEwMjQwXCIpO2lmKGVbMV0uZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcImJpYXMgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAxIGRpbWVuc2lvbnNcIik7aWYoZVswXS5kaW1zWzJdIT09ZVsxXS5kaW1zWzBdKXRocm93IG5ldyBFcnJvcihcImxhc3QgZGltZW5zaW9uIG9mIGlucHV0IGFuZCBiaWFzIGFyZSBub3QgdGhlIHNhbWVcIil9LFptPWU9PntsZXQgdD1lWzBdLmRpbXMuc2xpY2UoKTt0WzJdPXRbMl0vMjtsZXQgcj1FKFwiaW5wdXRcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcyw0KSxuPUUoXCJiaWFzXCIsZVswXS5kYXRhVHlwZSxbZVswXS5kaW1zWzJdXSw0KSxvPU0oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLHQsNCksaT1DLnNpemUodCkvNCxhPV9lKGVbMF0uZGF0YVR5cGUpO3JldHVybntuYW1lOlwiQmlhc1NwbGl0R2VsdVwiLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6dCxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoaS82NCl9fSksZ2V0U2hhZGVyU291cmNlOmw9PmBcbiAgY29uc3QgTV9TUVJUMiA9IHNxcnQoMi4wKTtcbiAgY29uc3QgaGFsZkNoYW5uZWxzID0gJHtlWzBdLmRpbXNbMl0vNC8yfXU7XG5cbiAgJHtsLmRlY2xhcmVWYXJpYWJsZXMocixuLG8pfVxuXG4gICR7cXIoYSl9XG5cbiAgJHtsLm1haW5TdGFydCgpfVxuICAgICR7bC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKGkpfVxuICAgIGxldCBiaWFzSWR4ID0gZ2xvYmFsX2lkeCAlIGhhbGZDaGFubmVscztcbiAgICBsZXQgYmF0Y2hJbmRleCA9IGdsb2JhbF9pZHggLyBoYWxmQ2hhbm5lbHM7XG4gICAgbGV0IGlucHV0T2Zmc2V0ID0gYmlhc0lkeCArIGJhdGNoSW5kZXggKiBoYWxmQ2hhbm5lbHMgKiAyO1xuICAgIGxldCB2YWx1ZUxlZnQgPSBpbnB1dFtpbnB1dE9mZnNldF0gKyBiaWFzW2JpYXNJZHhdO1xuICAgIGxldCB2YWx1ZVJpZ2h0ID0gaW5wdXRbaW5wdXRPZmZzZXQgKyBoYWxmQ2hhbm5lbHNdICsgYmlhc1tiaWFzSWR4ICsgaGFsZkNoYW5uZWxzXTtcbiAgICBsZXQgZ2VsdVJpZ2h0ID0gdmFsdWVSaWdodCAqIDAuNSAqIChlcmZfdmYzMih2YWx1ZVJpZ2h0IC8gTV9TUVJUMikgKyAxKTtcblxuICAgICR7by5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlTGVmdCAqIGdlbHVSaWdodFwiKX1cbiAgfWB9fSx3dT1lPT57WW0oZS5pbnB1dHMpLGUuY29tcHV0ZShabShlLmlucHV0cykpfX0pO3ZhciBRbSxYbSxhdCwkdSx4dSxTdSxUdSxJdSxDdSxBdSxrdSxFdSxQdSx6dT1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtvZSgpO2FlKCk7UW09KGUsdCxyLG4sbyxpLGEsZCxsLHAsbSx1KT0+e2xldCBoLF87dHlwZW9mIGQ9PVwic3RyaW5nXCI/aD1fPSh2LFMpPT5gJHtkfSgoJHt2fSksKCR7U30pKWA6dHlwZW9mIGQ9PVwiZnVuY3Rpb25cIj9oPV89ZDooaD1kLnNjYWxhcixfPWQudmVjdG9yKTtsZXQgeT1NKFwib3V0cHV0RGF0YVwiLG0sbi5sZW5ndGgsNCksZz1FKFwiYURhdGFcIixsLHQubGVuZ3RoLDQpLHg9RShcImJEYXRhXCIscCxyLmxlbmd0aCw0KSwkO2lmKG8paWYoaSl7bGV0IHY9Qy5zaXplKHQpPT09MSxTPUMuc2l6ZShyKT09PTEsVD10Lmxlbmd0aD4wJiZ0W3QubGVuZ3RoLTFdJTQ9PT0wLEE9ci5sZW5ndGg+MCYmcltyLmxlbmd0aC0xXSU0PT09MDt2fHxTPyQ9eS5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixfKHY/YCR7Zy50eXBlLnZhbHVlfSgke2cuZ2V0QnlPZmZzZXQoXCIwXCIpfS54KWA6Zy5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIiksUz9gJHt4LnR5cGUudmFsdWV9KCR7eC5nZXRCeU9mZnNldChcIjBcIil9LngpYDp4LmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSkpOiQ9YFxuICAgICAgICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke3kub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeCAqIDR1XCIpfTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRBID0gJHtnLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KFwib3V0cHV0SW5kaWNlc1wiLHkpfTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRCID0gJHt4LmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KFwib3V0cHV0SW5kaWNlc1wiLHkpfTtcbiAgICAgICAgICAgICR7eS5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixfKGF8fFQ/Zy5nZXRCeU9mZnNldChcIm9mZnNldEEgLyA0dVwiKTpgJHtnLnR5cGUudmFsdWV9KCR7Zy5nZXRCeU9mZnNldChcIm9mZnNldEEgLyA0dVwiKX1bb2Zmc2V0QSAlIDR1XSlgLGF8fEE/eC5nZXRCeU9mZnNldChcIm9mZnNldEIgLyA0dVwiKTpgJHt4LnR5cGUudmFsdWV9KCR7eC5nZXRCeU9mZnNldChcIm9mZnNldEIgLyA0dVwiKX1bb2Zmc2V0QiAlIDR1XSlgKSl9XG4gICAgICAgICAgYH1lbHNlICQ9eS5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixfKGcuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpLHguZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpKSk7ZWxzZXtpZighaSl0aHJvdyBuZXcgRXJyb3IoXCJubyBuZWNlc3NhcnkgdG8gdXNlIHNjYWxhciBpbXBsZW1lbnRhdGlvbiBmb3IgZWxlbWVudC13aXNlIGJpbmFyeSBvcCBpbXBsZW1lbnRhdGlvbi5cIik7bGV0IHY9KFMsVCxBPVwiXCIpPT57bGV0IGs9YGFEYXRhW2luZGV4QSR7VH1dW2NvbXBvbmVudEEke1R9XWAsUD1gYkRhdGFbaW5kZXhCJHtUfV1bY29tcG9uZW50QiR7VH1dYDtyZXR1cm5gXG4gICAgICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyR7VH0gPSAke3kub2Zmc2V0VG9JbmRpY2VzKGBnbG9iYWxfaWR4ICogNHUgKyAke1R9dWApfTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRBJHtUfSA9ICR7Zy5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0SW5kaWNlcyR7VH1gLHkpfTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRCJHtUfSA9ICR7eC5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0SW5kaWNlcyR7VH1gLHkpfTtcbiAgICAgICAgICAgIGxldCBpbmRleEEke1R9ID0gb2Zmc2V0QSR7VH0gLyA0dTtcbiAgICAgICAgICAgIGxldCBpbmRleEIke1R9ID0gb2Zmc2V0QiR7VH0gLyA0dTtcbiAgICAgICAgICAgIGxldCBjb21wb25lbnRBJHtUfSA9IG9mZnNldEEke1R9ICUgNHU7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50QiR7VH0gPSBvZmZzZXRCJHtUfSAlIDR1O1xuICAgICAgICAgICAgJHtTfVske1R9XSA9ICR7QX0oJHtoKGssUCl9KTtcbiAgICAgICAgICBgfTttPT09OT8kPWBcbiAgICAgICAgICAgIHZhciBkYXRhID0gdmVjNDx1MzI+KDApO1xuICAgICAgICAgICAgJHt2KFwiZGF0YVwiLDAsXCJ1MzJcIil9XG4gICAgICAgICAgICAke3YoXCJkYXRhXCIsMSxcInUzMlwiKX1cbiAgICAgICAgICAgICR7dihcImRhdGFcIiwyLFwidTMyXCIpfVxuICAgICAgICAgICAgJHt2KFwiZGF0YVwiLDMsXCJ1MzJcIil9XG4gICAgICAgICAgICBvdXRwdXREYXRhW2dsb2JhbF9pZHhdID0gZG90KHZlYzQ8dTMyPigweDEsIDB4MTAwLCAweDEwMDAwLCAweDEwMDAwMDApLCB2ZWM0PHUzMj4oZGF0YSkpO2A6JD1gXG4gICAgICAgICAgICAke3YoXCJvdXRwdXREYXRhW2dsb2JhbF9pZHhdXCIsMCl9XG4gICAgICAgICAgICAke3YoXCJvdXRwdXREYXRhW2dsb2JhbF9pZHhdXCIsMSl9XG4gICAgICAgICAgICAke3YoXCJvdXRwdXREYXRhW2dsb2JhbF9pZHhdXCIsMil9XG4gICAgICAgICAgICAke3YoXCJvdXRwdXREYXRhW2dsb2JhbF9pZHhdXCIsMyl9XG4gICAgICAgICAgYH1yZXR1cm5gXG4gICAgICAgICR7ZS5yZWdpc3RlclVuaWZvcm0oXCJ2ZWNfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoZyx4LHkpfVxuXG4gICAgICAgICR7dT8/XCJcIn1cblxuICAgICAgICAke2UubWFpblN0YXJ0KCl9XG4gICAgICAgICR7ZS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMudmVjX3NpemVcIil9XG4gICAgICAgICR7JH1cbiAgICAgIH1gfSxYbT0oZSx0LHIsbixvLGksYT1yLmRhdGFUeXBlKT0+e2xldCBkPXIuZGltcy5tYXAoZz0+TnVtYmVyKGcpPz8xKSxsPW4uZGltcy5tYXAoZz0+TnVtYmVyKGcpPz8xKSxwPSFDLmFyZUVxdWFsKGQsbCksbT1kLHU9Qy5zaXplKGQpLGg9ITEsXz0hMSx5PVtwXTtpZihwKXtsZXQgZz10dC5jYWxjU2hhcGUoZCxsLCExKTtpZighZyl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBwZXJmb3JtIGJpbmFyeSBvcCBvbiB0aGUgZ2l2ZW4gdGVuc29yc1wiKTttPWcuc2xpY2UoKSx1PUMuc2l6ZShtKTtsZXQgeD1DLnNpemUoZCk9PT0xLCQ9Qy5zaXplKGwpPT09MSx2PWQubGVuZ3RoPjAmJmRbZC5sZW5ndGgtMV0lND09PTAsUz1sLmxlbmd0aD4wJiZsW2wubGVuZ3RoLTFdJTQ9PT0wO3kucHVzaCh4KSx5LnB1c2goJCkseS5wdXNoKHYpLHkucHVzaChTKTtsZXQgVD0xO2ZvcihsZXQgQT0xO0E8bS5sZW5ndGg7QSsrKXtsZXQgaz1kW2QubGVuZ3RoLUFdLFA9bFtsLmxlbmd0aC1BXTtpZihrPT09UClUKj1rO2Vsc2UgYnJlYWt9VCU0PT09MD8oXz0hMCxoPSEwKTooeHx8JHx8dnx8UykmJihoPSEwKX1lbHNlIGg9ITA7cmV0dXJuIHkucHVzaChoKSx7bmFtZTplLHNoYWRlckNhY2hlOntoaW50OnQreS5tYXAoZz0+Zy50b1N0cmluZygpKS5qb2luKFwiX1wiKSxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCIsXCJyYW5rXCJdfSxnZXRTaGFkZXJTb3VyY2U6Zz0+UW0oZyxkLGwsbSxoLHAsXyxvLHIuZGF0YVR5cGUsbi5kYXRhVHlwZSxhLGkpLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6bSxkYXRhVHlwZTphfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwodS82NC80KX0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZToxMixkYXRhOk1hdGguY2VpbChDLnNpemUobSkvNCl9LC4uLk4oZCxsLG0pXX0pfX0sYXQ9KGUsdCxyLG4sbyxpKT0+e2UuY29tcHV0ZShYbSh0LG8/P1wiXCIsZS5pbnB1dHNbMF0sZS5pbnB1dHNbMV0scixuLGkpKX0sJHU9ZT0+e2F0KGUsXCJBZGRcIiwodCxyKT0+YCR7dH0rJHtyfWApfSx4dT1lPT57YXQoZSxcIkRpdlwiLCh0LHIpPT5gJHt0fS8ke3J9YCl9LFN1PWU9PnthdChlLFwiRXF1YWxcIix7c2NhbGFyOih0LHIpPT5gdTMyKCR7dH09PSR7cn0pYCx2ZWN0b3I6KHQscik9PmB2ZWM0PHUzMj4oJHt0fT09JHtyfSlgfSx2b2lkIDAsdm9pZCAwLDkpfSxUdT1lPT57YXQoZSxcIk11bFwiLCh0LHIpPT5gJHt0fSoke3J9YCl9LEl1PWU9PntsZXQgdD1FKFwiaW5wdXRcIixlLmlucHV0c1swXS5kYXRhVHlwZSxlLmlucHV0c1swXS5kaW1zKS50eXBlLnZhbHVlO2F0KGUsXCJQb3dcIix7c2NhbGFyOihuLG8pPT5gcG93X2N1c3RvbSgke259LCR7b30pYCx2ZWN0b3I6KG4sbyk9PmBwb3dfdmVjdG9yX2N1c3RvbSgke259LCR7b30pYH0sYFxuICAgIGZuIHBvd19jdXN0b20oYSA6ICR7dH0sIGIgOiAke3R9KSAtPiAke3R9IHtcbiAgICAgIGlmIChiID09ICR7dH0oMC4wKSkge1xuICAgICAgICByZXR1cm4gJHt0fSgxLjApO1xuICAgICAgfSBlbHNlIGlmIChhIDwgJHt0fSgwLjApICYmIGYzMihiKSAhPSBmbG9vcihmMzIoYikpKSB7XG4gICAgICAgIHJldHVybiAke3R9KHBvdyhmMzIoYSksIGYzMihiKSkpOyAvLyBOYU5cbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxlY3Qoc2lnbihhKSwgJHt0fSgxLjApLCByb3VuZChmMzIoYWJzKGIpICUgJHt0fSgyLjApKSkgIT0gMS4wKSAqICR7dH0oJHt0PT09XCJpMzJcIj9cInJvdW5kXCI6XCJcIn0ocG93KGYzMihhYnMoYSkpLCBmMzIoYikpKSk7XG4gICAgfVxuICAgIGZuIHBvd192ZWN0b3JfY3VzdG9tKGEgOiB2ZWM0PCR7dH0+LCBiIDogdmVjNDwke3R9PikgLT4gdmVjNDwke3R9PiB7XG4gICAgICAvLyBUT0RPOiBpbXBsZW1lbnQgdmVjdG9yaXplZCBwb3dcbiAgICAgIHJldHVybiB2ZWM0PCR7dH0+KHBvd19jdXN0b20oYS54LCBiLngpLCBwb3dfY3VzdG9tKGEueSwgYi55KSwgcG93X2N1c3RvbShhLnosIGIueiksIHBvd19jdXN0b20oYS53LCBiLncpKTtcbiAgICB9XG4gICAgICBgKX0sQ3U9ZT0+e2F0KGUsXCJTdWJcIiwodCxyKT0+YCR7dH0tJHtyfWApfSxBdT1lPT57YXQoZSxcIkdyZWF0ZXJcIix7c2NhbGFyOih0LHIpPT5gdTMyKCR7dH0+JHtyfSlgLHZlY3RvcjoodCxyKT0+YHZlYzQ8dTMyPigke3R9PiR7cn0pYH0sdm9pZCAwLHZvaWQgMCw5KX0sa3U9ZT0+e2F0KGUsXCJMZXNzXCIse3NjYWxhcjoodCxyKT0+YHUzMigke3R9PCR7cn0pYCx2ZWN0b3I6KHQscik9PmB2ZWM0PHUzMj4oJHt0fTwke3J9KWB9LHZvaWQgMCx2b2lkIDAsOSl9LEV1PWU9PnthdChlLFwiR3JlYXRlck9yRXF1YWxcIix7c2NhbGFyOih0LHIpPT5gdTMyKCR7dH0+PSR7cn0pYCx2ZWN0b3I6KHQscik9PmB2ZWM0PHUzMj4oJHt0fT49JHtyfSlgfSx2b2lkIDAsdm9pZCAwLDkpfSxQdT1lPT57YXQoZSxcIkxlc3NPckVxdWFsXCIse3NjYWxhcjoodCxyKT0+YHUzMigke3R9PD0ke3J9KWAsdmVjdG9yOih0LHIpPT5gdmVjNDx1MzI+KCR7dH08PSR7cn0pYH0sdm9pZCAwLHZvaWQgMCw5KX19KTt2YXIgZWYsdGYscmYsbmYsT3UsRHUsQnU9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTtTZSgpO2FlKCk7ZWY9KGUsdCk9PntpZighZXx8ZS5sZW5ndGg8MSl0aHJvdyBuZXcgRXJyb3IoXCJ0b28gZmV3IGlucHV0c1wiKTtsZXQgcj0wLG49ZVtyXSxvPW4uZGF0YVR5cGUsaT1uLmRpbXMubGVuZ3RoO2UuZm9yRWFjaCgoYSxkKT0+e2lmKGQhPT1yKXtpZihhLmRhdGFUeXBlIT09byl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCB0ZW5zb3JzIHNob3VsZCBiZSBvbmUgdHlwZVwiKTtpZihhLmRpbXMubGVuZ3RoIT09aSl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCB0ZW5zb3JzIHNob3VsZCBoYXZlIHRoZSBzYW1lIHNoYXBlXCIpO2EuZGltcy5mb3JFYWNoKChsLHApPT57aWYocCE9PXQmJmwhPT1uLmRpbXNbcF0pdGhyb3cgbmV3IEVycm9yKFwibm9uIGNvbmNhdCBkaW1lbnNpb25zIG11c3QgbWF0Y2hcIil9KX19KX0sdGY9KGUsdCk9PmBcbiAgZm4gY2FsY3VsYXRlSW5wdXRJbmRleChpbmRleDogdTMyKSAtPiB1MzIge1xuICAgIGxldCBzaXplSW5Db25jYXRBeGlzID0gYXJyYXk8dTMyLCAke2V9dT4oJHt0fSk7XG4gICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCAke2V9OyBpICs9IDF1ICkge1xuICAgICAgaWYgKGluZGV4IDwgc2l6ZUluQ29uY2F0QXhpc1tpXSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICR7ZX11O1xuICB9YCxyZj0oZSx0KT0+e2xldCByPWUubGVuZ3RoLG49W107Zm9yKGxldCBvPTA7bzxyOysrbyl7bGV0IGk9dC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixlW29dLmdldEJ5SW5kaWNlcyhcImluZGljZXNcIikpO3I9PT0xP24ucHVzaChpKTpvPT09MD9uLnB1c2goYGlmIChpbnB1dEluZGV4ID09ICR7b311KSB7ICR7aX0gfWApOm89PT1yLTE/bi5wdXNoKGBlbHNlIHsgJHtpfSB9YCk6bi5wdXNoKGBlbHNlIGlmIChpbnB1dEluZGV4ID09ICR7b30pIHsgJHtpfSB9YCl9cmV0dXJuIG4uam9pbihgXG5gKX0sbmY9KGUsdCxyLG4pPT57bGV0IG89Qy5zaXplKHIpLGk9bmV3IEFycmF5KGUubGVuZ3RoKSxhPW5ldyBBcnJheShlLmxlbmd0aCksZD0wLGw9W10scD1bXSxtPVt7dHlwZToxMixkYXRhOm99XTtmb3IobGV0IGc9MDtnPGUubGVuZ3RoOysrZylkKz1lW2ddLmRpbXNbdF0saVtnXT1kLHAucHVzaChlW2ddLmRpbXMubGVuZ3RoKSxhW2ddPUUoYGlucHV0JHtnfWAsbixwW2ddKSxsLnB1c2goXCJyYW5rXCIpLG0ucHVzaCh7dHlwZToxMixkYXRhOmlbZ119KTtmb3IobGV0IGc9MDtnPGUubGVuZ3RoOysrZyltLnB1c2goLi4uTihlW2ddLmRpbXMpKTttLnB1c2goLi4uTihyKSk7bGV0IHU9TShcIm91dHB1dFwiLG4sci5sZW5ndGgpLGg9dS5pbmRpY2VzR2V0KFwiaW5kaWNlc1wiLHQpLF89QXJyYXkuZnJvbShBcnJheShpLmxlbmd0aCkua2V5cygpKS5tYXAoZz0+YHVuaWZvcm1zLnNpemVJbkNvbmNhdEF4aXMke2d9YCkuam9pbihcIixcIikseT1nPT5gXG5cbiAgJHsoKCk9PntnLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dFNpemVcIixcInUzMlwiKTtmb3IobGV0IHg9MDt4PGUubGVuZ3RoO3grKylnLnJlZ2lzdGVyVW5pZm9ybShgc2l6ZUluQ29uY2F0QXhpcyR7eH1gLFwidTMyXCIpO3JldHVybiBnLmRlY2xhcmVWYXJpYWJsZXMoLi4uYSx1KX0pKCl9XG5cbiAgJHt0ZihpLmxlbmd0aCxfKX1cblxuICAke2cubWFpblN0YXJ0KCl9XG4gICAgJHtnLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRTaXplXCIpfVxuXG4gICAgdmFyIGluZGljZXMgPSAke3Uub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG5cbiAgICBsZXQgaW5wdXRJbmRleCA9IGNhbGN1bGF0ZUlucHV0SW5kZXgoJHtofSk7XG4gICAgaWYgKGlucHV0SW5kZXggIT0gMHUpIHtcbiAgICAgIGxldCBzaXplSW5Db25jYXRBeGlzID0gYXJyYXk8dTMyLCAke2kubGVuZ3RofXU+KCR7X30pO1xuICAgICAgJHtofSAtPSBzaXplSW5Db25jYXRBeGlzW2lucHV0SW5kZXggLSAxdV07XG4gICAgfVxuXG4gICAgJHtyZihhLHUpfVxuICB9YDtyZXR1cm57bmFtZTpcIkNvbmNhdFwiLHNoYWRlckNhY2hlOntoaW50OmAke3R9YCxpbnB1dERlcGVuZGVuY2llczpsfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnIsZGF0YVR5cGU6bn1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKG8vNjQpfSxwcm9ncmFtVW5pZm9ybXM6bX0pLGdldFNoYWRlclNvdXJjZTp5fX0sT3U9KGUsdCk9PntsZXQgcj1lLmlucHV0cyxuPXJbMF0uZGltcyxvPUMubm9ybWFsaXplQXhpcyh0LmF4aXMsbi5sZW5ndGgpO2VmKHIsbyk7bGV0IGk9bi5zbGljZSgpO2lbb109ci5yZWR1Y2UoKGQsbCk9PmQrKGwuZGltcy5sZW5ndGg+bz9sLmRpbXNbb106MCksMCk7bGV0IGE9ci5maWx0ZXIoZD0+Qy5zaXplKGQuZGltcyk+MCk7ZS5jb21wdXRlKG5mKGEsbyxpLHJbMF0uZGF0YVR5cGUpLHtpbnB1dHM6YX0pfSxEdT1lPT5yZSh7YXhpczplLmF4aXN9KX0pO3ZhciBxZSxLZSxqZSxqcix5dD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtvZSgpO3FlPShlLHQscj1cImYzMlwiKT0+e3N3aXRjaChlLmFjdGl2YXRpb24pe2Nhc2VcIlJlbHVcIjpyZXR1cm5gdmFsdWUgPSBtYXgodmFsdWUsICR7dH0oMC4wKSk7YDtjYXNlXCJTaWdtb2lkXCI6cmV0dXJuYHZhbHVlID0gKCR7dH0oMS4wKSAvICgke3R9KDEuMCkgKyBleHAoLXZhbHVlKSkpO2A7Y2FzZVwiQ2xpcFwiOnJldHVybmB2YWx1ZSA9IGNsYW1wKHZhbHVlLCAke3R9KCR7cn0odW5pZm9ybXMuY2xpcF9taW4pKSwgJHt0fSgke3J9KHVuaWZvcm1zLmNsaXBfbWF4KSkpO2A7Y2FzZVwiSGFyZFNpZ21vaWRcIjpyZXR1cm5gdmFsdWUgPSBtYXgoJHt0fSgwLjApLCBtaW4oJHt0fSgxLjApLCAke3J9KHVuaWZvcm1zLmFscGhhKSAqIHZhbHVlICsgJHtyfSh1bmlmb3Jtcy5iZXRhKSkpO2A7Y2FzZVwiTGVha3lSZWx1XCI6cmV0dXJuYHZhbHVlID0gc2VsZWN0KCR7cn0odW5pZm9ybXMuYWxwaGEpICogdmFsdWUsIHZhbHVlLCB2YWx1ZSA+PSAke3R9KDAuMCkpO2A7Y2FzZVwiVGFuaFwiOnJldHVybmBsZXQgZTJ4ID0gZXhwKC0yLjAgKiBhYnModmFsdWUpKTtcbiAgICAgICAgICAgICAgdmFsdWUgPSBzaWduKHZhbHVlKSAqICgxLjAgLSBlMngpIC8gKDEuMCArIGUyeCk7XG4gICAgICAgIGA7Y2FzZVwiXCI6cmV0dXJuXCJcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgYWN0aXZhdGlvbiAke2UuYWN0aXZhdGlvbn1gKX19LEtlPShlLHQpPT57ZS5hY3RpdmF0aW9uPT09XCJDbGlwXCI/dC5wdXNoKHt0eXBlOjEsZGF0YTplLmNsaXBNYXh9LHt0eXBlOjEsZGF0YTplLmNsaXBNaW59KTplLmFjdGl2YXRpb249PT1cIkhhcmRTaWdtb2lkXCI/dC5wdXNoKHt0eXBlOjEsZGF0YTplLmFscGhhfSx7dHlwZToxLGRhdGE6ZS5iZXRhfSk6ZS5hY3RpdmF0aW9uPT09XCJMZWFreVJlbHVcIiYmdC5wdXNoKHt0eXBlOjEsZGF0YTplLmFscGhhfSl9LGplPShlLHQpPT57ZS5hY3RpdmF0aW9uPT09XCJDbGlwXCI/dC5wdXNoKHtuYW1lOlwiY2xpcF9tYXhcIix0eXBlOlwiZjMyXCJ9LHtuYW1lOlwiY2xpcF9taW5cIix0eXBlOlwiZjMyXCJ9KTplLmFjdGl2YXRpb249PT1cIkhhcmRTaWdtb2lkXCI/dC5wdXNoKHtuYW1lOlwiYWxwaGFcIix0eXBlOlwiZjMyXCJ9LHtuYW1lOlwiYmV0YVwiLHR5cGU6XCJmMzJcIn0pOmUuYWN0aXZhdGlvbj09PVwiTGVha3lSZWx1XCImJnQucHVzaCh7bmFtZTpcImFscGhhXCIsdHlwZTpcImYzMlwifSl9LGpyPWU9PntsZXQgdD1lPy5hY3RpdmF0aW9ufHxcIlwiO2lmKHQ9PT1cIkhhcmRTaWdtb2lkXCIpe2xldFtyLG5dPWU/LmFjdGl2YXRpb25fcGFyYW1zfHxbLjIsLjVdO3JldHVybnthY3RpdmF0aW9uOnQsYWxwaGE6cixiZXRhOm59fWVsc2UgaWYodD09PVwiQ2xpcFwiKXtsZXRbcixuXT1lPy5hY3RpdmF0aW9uX3BhcmFtc3x8W2VzLHRzXTtyZXR1cm57YWN0aXZhdGlvbjp0LGNsaXBNYXg6bixjbGlwTWluOnJ9fWVsc2UgaWYodD09PVwiTGVha3lSZWx1XCIpe2xldFtyXT1lPy5hY3RpdmF0aW9uX3BhcmFtc3x8Wy4wMV07cmV0dXJue2FjdGl2YXRpb246dCxhbHBoYTpyfX1yZXR1cm57YWN0aXZhdGlvbjp0fX19KTt2YXIgQWUsTXUsWXI9VSgoKT0+e1widXNlIHN0cmljdFwiO0FlPShlLHQpPT57c3dpdGNoKGUpe2Nhc2UgMTpyZXR1cm4gdDtjYXNlIDI6cmV0dXJuYHZlYzI8JHt0fT5gO2Nhc2UgMzpyZXR1cm5gdmVjMzwke3R9PmA7Y2FzZSA0OnJldHVybmB2ZWM0PCR7dH0+YDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgJHtlfS1jb21wb25lbnQgaXMgbm90IHN1cHBvcnRlZC5gKX19LE11PWU9PmBcbiAgICAgICR7ZT9cInZhbHVlID0gdmFsdWUgKyBnZXRCaWFzQnlPdXRwdXRDb29yZHMoY29vcmRzKTtcIjpcIlwifVxuICAgICAgYH0pO3ZhciBSdSxVdT1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7UnU9ZT0+YFxuZm4gZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmRzIDogdmVjNDxpMzI+LCBzaGFwZSA6IHZlYzQ8aTMyPikgLT4gaTMyIHtcbiAgcmV0dXJuIGRvdChjb29yZHMsIHZlYzQ8aTMyPihcbiAgICAgIHNoYXBlLnkgKiBzaGFwZS56ICogc2hhcGUudywgc2hhcGUueiAqIHNoYXBlLncsIHNoYXBlLncsIDEpKTtcbn1cbmZuIGdldE91dHB1dEluZGV4RnJvbUNvb3Jkcyhjb29yZHMgOiB2ZWM0PGkzMj4pIC0+IGkzMiB7XG4gIHJldHVybiBkb3QoY29vcmRzLCB2ZWM0PGkzMj4oXG4gICAgaTMyKCR7ZX0ueCksIGkzMigke2V9LnkpLCBpMzIoJHtlfS56KSwgMSkpO1xufVxuYH0pO3ZhciBKdCxacixRcj1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtvZSgpO2FlKCk7eXQoKTtKdD0oZSx0LHIsbixvKT0+e2xldCBpPW4tcjtyZXR1cm5gXG4gICAgICAke0FycmF5LmZyb20oe2xlbmd0aDpyfSkubWFwKChhLGQpPT5gXG4gICAgICBpZiAoJHtGKHQuc2hhcGUsZCx0LnJhbmspfSAhPSAxKSB7XG4gICAgICAgICR7dC5pbmRpY2VzU2V0KGUsZCxGKG8sZCtpLG4pKX1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICR7dC5pbmRpY2VzU2V0KGUsZCwwKX1cbiAgICAgIH1gKS5qb2luKFwiXCIpfVxuYH0sWnI9KGUsdCxyLG4sbz0hMSxpKT0+e2xldCBhPWVbMF0uZGltcyxkPWVbMV0uZGltcyxsPWFbYS5sZW5ndGgtMl0scD1kW2QubGVuZ3RoLTFdLG09YVthLmxlbmd0aC0xXSx1PW1lKHApLGg9bWUobSksXz1tZShsKSx5PUMuc2l6ZShyKS91L18sZz1lLmxlbmd0aD4yLHg9bj9uLnNsaWNlKDAsLTIpOnIuc2xpY2UoMCwtMiksdj1bQy5zaXplKHgpLGwscF0sUz1be3R5cGU6MTIsZGF0YTp5fSx7dHlwZToxMixkYXRhOmx9LHt0eXBlOjEyLGRhdGE6cH0se3R5cGU6MTIsZGF0YTptfV07S2UodCxTKSxTLnB1c2goLi4uTih4LGEsZCkpLGcmJlMucHVzaCguLi5OKGVbMl0uZGltcykpLFMucHVzaCguLi5OKHYpKTtsZXQgVD1BPT57bGV0IGs9THIoXCJiYXRjaF9kaW1zXCIsZVswXS5kYXRhVHlwZSx4Lmxlbmd0aCksUD1FKFwiYVwiLGVbMF0uZGF0YVR5cGUsYS5sZW5ndGgsaCksRD1FKFwiYlwiLGVbMV0uZGF0YVR5cGUsZC5sZW5ndGgsdSksUj1NKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSx2Lmxlbmd0aCx1KSxHPV9lKFIudHlwZS50ZW5zb3IpLEs9cWUodCxSLnR5cGUudmFsdWUsRyksaj1bUCxEXSxWPVwiXCI7aWYoZyl7bGV0IFk9bz91OjE7ai5wdXNoKEUoXCJiaWFzXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMubGVuZ3RoLFkpKSxWPWAke28/YHZhbHVlICs9IGJpYXNbY29sIC8gJHtZfV07YDpgdmFsdWUgKz0gJHtSLnR5cGUudmFsdWV9KGJpYXNbcm93ICsgaV0pO2B9YH1sZXQgUT1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJNXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIk5cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiS1wiLHR5cGU6XCJ1MzJcIn1dO2plKHQsUSk7bGV0IHNlPSgpPT57bGV0IFk9YHZhciBhX2RhdGE6ICR7UC50eXBlLnZhbHVlfTtgO2ZvcihsZXQgZWU9MDtlZTxoO2VlKyspWSs9YFxuICAgICAgICAgICAgICBsZXQgYl9kYXRhJHtlZX0gPSBiWyhiX29mZnNldCArIChrICsgJHtlZX0pICogdW5pZm9ybXMuTiArIGNvbCkgLyAke3V9XTtgO2ZvcihsZXQgZWU9MDtlZTxfO2VlKyspe1krPWBhX2RhdGEgPSBhWyhhX29mZnNldCArIChyb3cgKyAke2VlfSkgKiB1bmlmb3Jtcy5LICsgaykgLyAke2h9XTtgO2ZvcihsZXQgSj0wO0o8aDtKKyspWSs9YFxuICAgICAgICAgICAgdmFsdWVzWyR7ZWV9XSA9IGZtYSgke0QudHlwZS52YWx1ZX0oYV9kYXRhJHtoPT09MT9cIlwiOmBbJHtKfV1gfSksIGJfZGF0YSR7Sn0sIHZhbHVlc1ske2VlfV0pO1xuYH1yZXR1cm4gWX07cmV0dXJuYFxuICAke0EucmVnaXN0ZXJVbmlmb3JtcyhRKS5yZWdpc3RlckludGVybmFsVmFyaWFibGVzKGspLmRlY2xhcmVWYXJpYWJsZXMoLi4uaixSKX1cbiAgJHtBLm1haW5TdGFydCgpfVxuICAgICR7QS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgbGV0IGNvbCA9IChnbG9iYWxfaWR4ICUgKHVuaWZvcm1zLk4gLyAke3V9KSkgKiAke3V9O1xuICAgIHZhciBpbmRleDEgPSBnbG9iYWxfaWR4IC8gKHVuaWZvcm1zLk4gLyAke3V9KTtcbiAgICBsZXQgc3RyaWRlMSA9IHVuaWZvcm1zLk0gLyAke199O1xuICAgIGxldCByb3cgPSAoaW5kZXgxICUgc3RyaWRlMSkgKiAke199O1xuICAgIGxldCBiYXRjaCA9IGluZGV4MSAvIHN0cmlkZTE7XG5cbiAgICAke3IubGVuZ3RoPT09Mj9cIlwiOmBsZXQgYmF0Y2hfaW5kaWNlcyA9ICR7ay5vZmZzZXRUb0luZGljZXMoXCJiYXRjaFwiKX07YH1cblxuICAgIHZhciBhX2luZGljZXM6ICR7UC50eXBlLmluZGljZXN9O1xuICAgICR7SnQoXCJhX2luZGljZXNcIixQLFAucmFuay0yLGsucmFuayxcImJhdGNoX2luZGljZXNcIil9XG4gICAgJHtQLmluZGljZXNTZXQoXCJhX2luZGljZXNcIixQLnJhbmstMiwwKX1cbiAgICAke1AuaW5kaWNlc1NldChcImFfaW5kaWNlc1wiLFAucmFuay0xLDApfVxuICAgIGxldCBhX29mZnNldCA9ICR7UC5pbmRpY2VzVG9PZmZzZXQoXCJhX2luZGljZXNcIil9O1xuXG4gICAgdmFyIGJfaW5kaWNlczogJHtELnR5cGUuaW5kaWNlc307XG4gICAgJHtKdChcImJfaW5kaWNlc1wiLEQsRC5yYW5rLTIsay5yYW5rLFwiYmF0Y2hfaW5kaWNlc1wiKX1cbiAgICAke0QuaW5kaWNlc1NldChcImJfaW5kaWNlc1wiLEQucmFuay0yLDApfVxuICAgICR7RC5pbmRpY2VzU2V0KFwiYl9pbmRpY2VzXCIsRC5yYW5rLTEsMCl9XG4gICAgbGV0IGJfb2Zmc2V0ID0gJHtELmluZGljZXNUb09mZnNldChcImJfaW5kaWNlc1wiKX07XG4gICAgdmFyIHZhbHVlczogYXJyYXk8JHtSLnR5cGUudmFsdWV9LCAke199PjtcbiAgICBmb3IgKHZhciBrOiB1MzIgPSAwdTsgayA8IHVuaWZvcm1zLks7IGsgPSBrICsgJHtofSkge1xuICAgICAgJHtzZSgpfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMHU7IGkgPCAke199dTsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAke1Z9XG4gICAgICAke0t9XG4gICAgICBsZXQgY3VyX2luZGljZXMgPSAke1IudHlwZS5pbmRpY2VzfShiYXRjaCwgcm93ICsgaSwgY29sKTtcbiAgICAgIGxldCBvZmZzZXQgPSAke1IuaW5kaWNlc1RvT2Zmc2V0KFwiY3VyX2luZGljZXNcIil9O1xuICAgICAgJHtSLnNldEJ5T2Zmc2V0KGBvZmZzZXQgLyAke3V9YCxcInZhbHVlXCIpfTtcbiAgICB9XG4gIH1cbiAgYH07cmV0dXJue25hbWU6XCJNYXRNdWxOYWl2ZVwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuYWN0aXZhdGlvbn07JHt1fTske2h9OyR7X307JHtvfWAsaW5wdXREZXBlbmRlbmNpZXM6Zz9bXCJyYW5rXCIsXCJyYW5rXCIsXCJyYW5rXCJdOltcInJhbmtcIixcInJhbmtcIl19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6aT9pKHIpOnIsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHkvNjQpfSxwcm9ncmFtVW5pZm9ybXM6U30pLGdldFNoYWRlclNvdXJjZTpUfX19KTt2YXIgb2YsYWYsaG8sTnUsc2YsZ28sdWYsZXIsWHI9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTthZSgpO3l0KCk7UXIoKTtZcigpO29mPShlLHQpPT5lP2BcbiAgICAgICAgbW1fQXN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEEoYmF0Y2gsXG4gICAgICAgICAga1N0YXJ0ICsgaW5wdXRSb3csXG4gICAgICAgICAgZ2xvYmFsUm93U3RhcnQgLyBpbm5lckVsZW1lbnRTaXplICsgaW5wdXRDb2wke3Q/XCIsIGJhdGNoSW5kaWNlc1wiOlwiXCJ9KTtcbiAgICAgICAgYDpgXG4gICAgICAgIG1tX0FzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRBKGJhdGNoLFxuICAgICAgICAgIGdsb2JhbFJvdyArIGlubmVyUm93LFxuICAgICAgICAgIGtTdGFydCAvIGlubmVyRWxlbWVudFNpemUgKyBpbnB1dENvbCR7dD9cIiwgYmF0Y2hJbmRpY2VzXCI6XCJcIn0pO1xuICAgICAgICBgLGFmPShlLHQpPT5lP2BcbiAgICAgICAgbGV0IEFDYWNoZWQwID0gbW1fQXN1YltrICogaW5uZXJFbGVtZW50U2l6ZV1bbG9jYWxSb3ddO1xuICAgICAgICBsZXQgQUNhY2hlZDEgPSBtbV9Bc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgMV1bbG9jYWxSb3ddO1xuICAgICAgICBsZXQgQUNhY2hlZDIgPSBtbV9Bc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgMl1bbG9jYWxSb3ddO1xuICAgICAgICAke3Q9PT0zP1wiXCI6XCJsZXQgQUNhY2hlZDMgPSBtbV9Bc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgM11bbG9jYWxSb3ddO1wifVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd1BlclRocmVhZDsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDAgKiBBQ2FjaGVkMFtpXSArIGFjY1tpXTtcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMSAqIEFDYWNoZWQxW2ldICsgYWNjW2ldO1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQyICogQUNhY2hlZDJbaV0gKyBhY2NbaV07XG4gICAgICAgICAgJHt0PT09Mz9cIlwiOlwiYWNjW2ldID0gQkNhY2hlZDMgKiBBQ2FjaGVkM1tpXSArIGFjY1tpXTtcIn1cbiAgICAgICAgfWA6YFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd1BlclRocmVhZDsgaSA9IGkgKyAxKSB7XG4gICAgICAgICAgbGV0IEFDYWNoZWQgPSBtbV9Bc3ViW3RpbGVSb3cgKyBpXVtrXTtcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMCAqIEFDYWNoZWQueCArIGFjY1tpXTtcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMSAqIEFDYWNoZWQueSArIGFjY1tpXTtcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMiAqIEFDYWNoZWQueiArIGFjY1tpXTtcbiAgICAgICAgICAke3Q9PT0zP1wiXCI6XCJhY2NbaV0gPSBCQ2FjaGVkMyAqIEFDYWNoZWQudyArIGFjY1tpXTtcIn1cbiAgICAgICAgfWAsaG89KGUsdCxyPVwiZjMyXCIsbixvPSExLGk9MzIsYT0hMSxkPTMyKT0+e2xldCBsPXRbMV0qZVsxXSxwPXRbMF0qZVswXSxtPW8/bDppLHU9bz9pOmwsaD1tL3RbMF0sXz1pL3RbMV07aWYoISgobyYmaD09PTQmJmVbMV09PT00fHwhbyYmKGg9PT0zfHxoPT09NCkpJiZtJXRbMF09PT0wJiZpJXRbMV09PT0wJiZlWzBdPT09NCkpdGhyb3cgbmV3IEVycm9yKGBJZiB0cmFuc3Bvc2VBICR7b30gaXMgdHJ1ZSwgaW5uZXJFbGVtZW50U2l6ZSAke2h9IGFuZCB3b3JrUGVyVGhyZWFkWzFdICR7ZVsxXX0gbXVzdCBiZSA0LlxuICAgICAgT3RoZXJ3aXNlLCBpbm5lckVsZW1lbnRTaXplICR7aH0gbXVzdCBiZSAzIG9yIDQuXG4gIHRpbGVBV2lkdGggJHttfSBtdXN0IGJlIGRpdmlzaWJsZSBieSB3b3JrZ3JvdXBTaXplWzBdJHt0WzBdfS4gdGlsZUlubmVyICR7aX0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVsxXSAke3RbMV19LiBjb2xQZXJUaHJlYWQgJHtlWzBdfSBtdXN0IGJlIDQuYCk7cmV0dXJuYFxudmFyPHdvcmtncm91cD4gbW1fQXN1YjogYXJyYXk8YXJyYXk8dmVjJHtofTwke3J9PiwgJHttL2h9PiwgJHt1fT47XG52YXI8d29ya2dyb3VwPiBtbV9Cc3ViOiBhcnJheTxhcnJheTx2ZWM0PCR7cn0+LCAke3AvZVswXX0+LCAke2l9PjtcblxuY29uc3Qgcm93UGVyVGhyZWFkID0gJHtlWzFdfTtcbmNvbnN0IGNvbFBlclRocmVhZCA9ICR7ZVswXX07XG5jb25zdCBpbm5lckVsZW1lbnRTaXplID0gJHtofTtcbmNvbnN0IHRpbGVJbm5lciA9ICR7aX07XG5cbkBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSgke3RbMF19LCAke3RbMV19LCAke3RbMl19KVxuZm4gbWFpbihAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBsb2NhbElkIDogdmVjMzx1MzI+LFxuICAgICAgICBAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsSWQgOiB2ZWMzPHUzMj4sXG4gICAgICAgIEBidWlsdGluKHdvcmtncm91cF9pZCkgd29ya2dyb3VwSWQgOiB2ZWMzPHUzMj4pIHtcbiAgbGV0IGxvY2FsUm93ID0gaTMyKGxvY2FsSWQueSk7XG4gIGxldCB0aWxlUm93ID0gbG9jYWxSb3cgKiByb3dQZXJUaHJlYWQ7XG4gIGxldCB0aWxlQ29sID0gaTMyKGxvY2FsSWQueCk7XG5cbiAgbGV0IGdsb2JhbFJvdyA9aTMyKGdsb2JhbElkLnkpICogcm93UGVyVGhyZWFkO1xuICBsZXQgZ2xvYmFsQ29sID0gaTMyKGdsb2JhbElkLngpO1xuICBsZXQgYmF0Y2ggPSAke2E/XCIwXCI6XCJpMzIoZ2xvYmFsSWQueilcIn07XG4gICR7bj9gbGV0IGJhdGNoSW5kaWNlcyA9ICR7bi5vZmZzZXRUb0luZGljZXMoXCJ1MzIoYmF0Y2gpXCIpfTtgOlwiXCJ9XG4gIGxldCBnbG9iYWxSb3dTdGFydCA9IGkzMih3b3JrZ3JvdXBJZC55KSAqICR7bH07XG5cbiAgbGV0IG51bV90aWxlcyA9ICR7YT9gJHtNYXRoLmNlaWwoZC9pKX1gOlwiKHVuaWZvcm1zLmRpbV9pbm5lciAtIDEpIC8gdGlsZUlubmVyICsgMVwifTtcbiAgdmFyIGtTdGFydCA9ICR7YT9gaTMyKGdsb2JhbElkLnopICogJHtkfWA6XCIwXCJ9O1xuXG4gIHZhciBhY2M6IGFycmF5PHZlYzQ8JHtyfT4sIHJvd1BlclRocmVhZD47XG5cbiAgLy8gTG9vcCBvdmVyIHNoYXJlZCBkaW1lbnNpb24uXG4gIGxldCB0aWxlUm93QiA9IGxvY2FsUm93ICogJHtffTtcbiAgZm9yICh2YXIgdCA9IDA7IHQgPCBudW1fdGlsZXM7IHQgPSB0ICsgMSkge1xuICAgICAgLy8gTG9hZCBvbmUgdGlsZSBvZiBBIGludG8gbG9jYWwgbWVtb3J5LlxuICAgICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgICAgICBsZXQgaW5wdXRSb3cgPSB0aWxlUm93ICsgaW5uZXJSb3c7XG4gICAgICAgICAgbGV0IGlucHV0Q29sID0gdGlsZUNvbDtcbiAgICAgICAgICAke29mKG8sbil9XG4gICAgICB9XG5cbiAgICAgIC8vIExvYWQgb25lIHRpbGUgb2YgQiBpbnRvIGxvY2FsIG1lbW9yeS5cbiAgICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCAke199OyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgICAgICAgIGxldCBpbnB1dFJvdyA9IHRpbGVSb3dCICsgaW5uZXJSb3c7XG4gICAgICAgICAgbGV0IGlucHV0Q29sID0gdGlsZUNvbDtcbiAgICAgICAgICBtbV9Cc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQihiYXRjaCwga1N0YXJ0ICsgaW5wdXRSb3csIGdsb2JhbENvbCR7bj9cIiwgYmF0Y2hJbmRpY2VzXCI6XCJcIn0pO1xuICAgICAgfVxuICAgICAga1N0YXJ0ID0ga1N0YXJ0ICsgdGlsZUlubmVyO1xuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAvLyBDb21wdXRlIGFjYyB2YWx1ZXMgZm9yIGEgc2luZ2xlIHRocmVhZC5cbiAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgdGlsZUlubmVyIC8gaW5uZXJFbGVtZW50U2l6ZTsgayA9IGsgKyAxKSB7XG4gICAgICAgICAgbGV0IEJDYWNoZWQwID0gbW1fQnN1YltrICogaW5uZXJFbGVtZW50U2l6ZV1bdGlsZUNvbF07XG4gICAgICAgICAgbGV0IEJDYWNoZWQxID0gbW1fQnN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDFdW3RpbGVDb2xdO1xuICAgICAgICAgIGxldCBCQ2FjaGVkMiA9IG1tX0JzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAyXVt0aWxlQ29sXTtcbiAgICAgICAgICAke2g9PT0zP1wiXCI6XCJsZXQgQkNhY2hlZDMgPSBtbV9Cc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgM11bdGlsZUNvbF07XCJ9XG5cbiAgICAgICAgICAke2FmKG8saCl9XG4gICAgICB9XG5cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgfVxuXG4gIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICBtbV93cml0ZShiYXRjaCwgZ2xvYmFsUm93ICsgaW5uZXJSb3csIGdsb2JhbENvbCwgYWNjW2lubmVyUm93XSk7XG4gIH1cbn1gfSxOdT0oZSx0KT0+ZT9gXG4gICAgICAgICAgICBtbV9Bc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQShiYXRjaCxcbiAgICAgICAgICAgICAga1N0YXJ0ICsgaW5wdXRSb3csXG4gICAgICAgICAgICAgIGdsb2JhbFJvd1N0YXJ0ICsgaW5wdXRDb2wke3Q/XCIsIGJhdGNoSW5kaWNlc1wiOlwiXCJ9KTtcbiAgICAgICAgICAgIGA6YFxuICAgICAgICAgICAgbW1fQXN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEEoYmF0Y2gsXG4gICAgICAgICAgICAgIGdsb2JhbFJvd1N0YXJ0ICsgaW5wdXRSb3csXG4gICAgICAgICAgICAgIGtTdGFydCArIGlucHV0Q29sJHt0P1wiLCBiYXRjaEluZGljZXNcIjpcIlwifSk7XG4gICAgICAgICAgICBgLHNmPWU9PmU/XCJsZXQgQUNhY2hlZCA9IG1tX0FzdWJba11bdGlsZVJvdyArIGlubmVyUm93XTtcIjpcImxldCBBQ2FjaGVkID0gbW1fQXN1Ylt0aWxlUm93ICsgaW5uZXJSb3ddW2tdO1wiLGdvPShlLHQscj1cImYzMlwiLG4sbz0hMSxpPTMyLGE9ITEsZD0zMixsPSExKT0+e2xldCBwPWVbMV0qdFsxXSxtPWVbMF0qdFswXSx1PW8/cDppLGg9bz9pOnA7aWYoIShoJXRbMV09PT0wJiZ1JXRbMF09PT0wJiZpJXRbMV09PT0wKSl0aHJvdyBuZXcgRXJyb3IoYHRpbGVBSGlnaHQgJHtofSBtdXN0IGJlIGRpdmlzaWJsZSBieSB3b3JrZ3JvdXBTaXplWzFdJHt0WzFdfSwgdGlsZUFXaWR0aCAke3V9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMF0ke3RbMF19LCB0aWxlSW5uZXIgJHtpfSBtdXN0IGJlIGRpdmlzaWJsZSBieSB3b3JrZ3JvdXBTaXplWzFdJHt0WzFdfWApO2xldCBfPWgvdFsxXSx5PXUvdFswXSxnPWkvdFsxXSx4PWw/YFxuICAgIGxldCBsb2NhbFJvdyA9IGkzMihsb2NhbElkLnkpO1xuICAgIGxldCBsb2NhbENvbCA9IGkzMihsb2NhbElkLngpO1xuICAgIGxldCBnbG9iYWxSb3dTdGFydCA9IGkzMih3b3JrZ3JvdXBJZC55KSAqICR7cH07XG4gICAgbGV0IGdsb2JhbENvbFN0YXJ0ID0gaTMyKHdvcmtncm91cElkLngpICogJHttfTtcblxuICAgIC8vIExvb3Agb3ZlciBzaGFyZWQgZGltZW5zaW9uLlxuICAgIGZvciAodmFyIHQgPSAwOyB0IDwgbnVtX3RpbGVzOyB0ID0gdCArIDEpIHtcbiAgICAgIC8vIExvYWQgb25lIHRpbGUgb2YgQSBpbnRvIGxvY2FsIG1lbW9yeS5cbiAgICAgIGZvciAodmFyIGlucHV0Um93ID0gbG9jYWxSb3c7IGlucHV0Um93IDwgJHtofTsgaW5wdXRSb3cgPSBpbnB1dFJvdyArICR7dFsxXX0pIHtcbiAgICAgICAgZm9yICh2YXIgaW5wdXRDb2wgPSBsb2NhbENvbDsgaW5wdXRDb2wgPCAke3V9OyBpbnB1dENvbCA9IGlucHV0Q29sICsgJHt0WzBdfSkge1xuICAgICAgICAgICR7TnUobyxuKX1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gTG9hZCBvbmUgdGlsZSBvZiBCIGludG8gbG9jYWwgbWVtb3J5LlxuICAgICAgZm9yICh2YXIgaW5wdXRSb3cgPSBsb2NhbFJvdzsgaW5wdXRSb3cgPCAke2l9OyBpbnB1dFJvdyA9IGlucHV0Um93ICsgJHt0WzFdfSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaW5wdXRDb2wgPSBsb2NhbENvbDsgaW5wdXRDb2wgPCAke219OyBpbnB1dENvbCA9IGlucHV0Q29sICsgJHt0WzBdfSkge1xuICAgICAgICAgIG1tX0JzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRCKGJhdGNoLFxuICAgICAgICAgICAga1N0YXJ0ICsgaW5wdXRSb3csXG4gICAgICAgICAgICBnbG9iYWxDb2xTdGFydCArIGlucHV0Q29sJHtuP1wiLCBiYXRjaEluZGljZXNcIjpcIlwifSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGtTdGFydCA9IGtTdGFydCArIHRpbGVJbm5lcjtcbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgLy8gQ29tcHV0ZSBhY2MgdmFsdWVzIGZvciBhIHNpbmdsZSB0aHJlYWQuXG4gICAgICB2YXIgQkNhY2hlZCA6IGFycmF5PCR7cn0sIGNvbFBlclRocmVhZD47XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRpbGVJbm5lcjsgayA9IGsgKyAxKSB7XG4gICAgICAgIGZvciAodmFyIGlubmVyID0gMDsgaW5uZXIgPCBjb2xQZXJUaHJlYWQ7IGlubmVyID0gaW5uZXIgKyAxKSB7XG4gICAgICAgICAgQkNhY2hlZFtpbm5lcl0gPSBtbV9Cc3ViW2tdW2xvY2FsQ29sICsgaW5uZXIgKiAke3RbMF19XTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgICAgICAgIGxldCBBQ2FjaGVkID0gJHtvP2BtbV9Bc3ViW2tdW2xvY2FsUm93ICsgaW5uZXJSb3cgKiAke3RbMV19XTtgOmBtbV9Bc3ViW2xvY2FsUm93ICsgaW5uZXJSb3cgKiAke3RbMV19XVtrXTtgfVxuICAgICAgICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XG4gICAgICAgICAgICBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSA9IGFjY1tpbm5lclJvd11baW5uZXJDb2xdICtcbiAgICAgICAgICAgICAgICBBQ2FjaGVkICogQkNhY2hlZFtpbm5lckNvbF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgfVxuICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICBsZXQgZ1JvdyA9IGdsb2JhbFJvd1N0YXJ0ICsgbG9jYWxSb3cgKyBpbm5lclJvdyAqICR7dFsxXX07XG4gICAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgICAgICBsZXQgZ0NvbCA9IGdsb2JhbENvbFN0YXJ0ICsgbG9jYWxDb2wgKyBpbm5lckNvbCAqICR7dFswXX07XG4gICAgICAgIG1tX3dyaXRlKGJhdGNoLCBnUm93LCBnQ29sLCBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGA6YFxubGV0IHRpbGVSb3cgPSBpMzIobG9jYWxJZC55KSAqIHJvd1BlclRocmVhZDtcbmxldCB0aWxlQ29sID0gaTMyKGxvY2FsSWQueCkgKiBjb2xQZXJUaHJlYWQ7XG5cbmxldCBnbG9iYWxSb3cgPSBpMzIoZ2xvYmFsSWQueSkgKiByb3dQZXJUaHJlYWQ7XG5sZXQgZ2xvYmFsQ29sID0gaTMyKGdsb2JhbElkLngpICogY29sUGVyVGhyZWFkO1xubGV0IGdsb2JhbFJvd1N0YXJ0ID0gaTMyKHdvcmtncm91cElkLnkpICogJHtwfTtcblxubGV0IHRpbGVSb3dBID0gaTMyKGxvY2FsSWQueSkgKiAke199O1xubGV0IHRpbGVDb2xBID0gaTMyKGxvY2FsSWQueCkgKiAke3l9O1xubGV0IHRpbGVSb3dCID0gaTMyKGxvY2FsSWQueSkgKiAke2d9O1xuLy8gTG9vcCBvdmVyIHNoYXJlZCBkaW1lbnNpb24uXG5mb3IgKHZhciB0ID0gMDsgdCA8IG51bV90aWxlczsgdCA9IHQgKyAxKSB7XG4gIC8vIExvYWQgb25lIHRpbGUgb2YgQSBpbnRvIGxvY2FsIG1lbW9yeS5cbiAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8ICR7X307IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8ICR7eX07IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XG4gICAgICBsZXQgaW5wdXRSb3cgPSB0aWxlUm93QSArIGlubmVyUm93O1xuICAgICAgbGV0IGlucHV0Q29sID0gdGlsZUNvbEEgKyBpbm5lckNvbDtcbiAgICAgICR7TnUobyxuKX1cbiAgICB9XG4gIH1cblxuICAvLyBMb2FkIG9uZSB0aWxlIG9mIEIgaW50byBsb2NhbCBtZW1vcnkuXG4gIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCAke2d9OyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XG4gICAgICBsZXQgaW5wdXRSb3cgPSB0aWxlUm93QiArIGlubmVyUm93O1xuICAgICAgbGV0IGlucHV0Q29sID0gdGlsZUNvbCArIGlubmVyQ29sO1xuICAgICAgbW1fQnN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEIoYmF0Y2gsXG4gICAgICAgIGtTdGFydCArIGlucHV0Um93LFxuICAgICAgICBnbG9iYWxDb2wgKyBpbm5lckNvbCR7bj9cIiwgYmF0Y2hJbmRpY2VzXCI6XCJcIn0pO1xuICAgIH1cbiAgfVxuICBrU3RhcnQgPSBrU3RhcnQgKyB0aWxlSW5uZXI7XG4gIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAvLyBDb21wdXRlIGFjYyB2YWx1ZXMgZm9yIGEgc2luZ2xlIHRocmVhZC5cbiAgdmFyIEJDYWNoZWQgOiBhcnJheTwke3J9LCBjb2xQZXJUaHJlYWQ+O1xuICBmb3IgKHZhciBrID0gMDsgayA8IHRpbGVJbm5lcjsgayA9IGsgKyAxKSB7XG4gICAgZm9yICh2YXIgaW5uZXIgPSAwOyBpbm5lciA8IGNvbFBlclRocmVhZDsgaW5uZXIgPSBpbm5lciArIDEpIHtcbiAgICAgIEJDYWNoZWRbaW5uZXJdID0gbW1fQnN1YltrXVt0aWxlQ29sICsgaW5uZXJdO1xuICAgIH1cblxuICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICAke3NmKG8pfVxuICAgICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICAgICAgYWNjW2lubmVyUm93XVtpbm5lckNvbF0gPSBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSArIEFDYWNoZWQgKiBCQ2FjaGVkW2lubmVyQ29sXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG59XG5cbmZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XG4gICAgbW1fd3JpdGUoYmF0Y2gsIGdsb2JhbFJvdyArIGlubmVyUm93LCBnbG9iYWxDb2wgKyBpbm5lckNvbCxcbiAgICAgICAgYWNjW2lubmVyUm93XVtpbm5lckNvbF0pO1xuICB9XG59XG5gO3JldHVybmBcbiAgdmFyPHdvcmtncm91cD4gbW1fQXN1YiA6IGFycmF5PGFycmF5PCR7cn0sICR7dX0+LCAke2h9PjtcbiAgdmFyPHdvcmtncm91cD4gbW1fQnN1YiA6IGFycmF5PGFycmF5PCR7cn0sICR7bX0+LCAke2l9PjtcbiAgY29uc3Qgcm93UGVyVGhyZWFkID0gJHtlWzFdfTtcbiAgY29uc3QgY29sUGVyVGhyZWFkID0gJHtlWzBdfTtcbiAgY29uc3QgdGlsZUlubmVyID0gJHtpfTtcblxuQGNvbXB1dGUgQHdvcmtncm91cF9zaXplKCR7dFswXX0sICR7dFsxXX0sICR7dFsyXX0pXG5mbiBtYWluKEBidWlsdGluKGxvY2FsX2ludm9jYXRpb25faWQpIGxvY2FsSWQgOiB2ZWMzPHUzMj4sXG4gICAgICAgIEBidWlsdGluKGdsb2JhbF9pbnZvY2F0aW9uX2lkKSBnbG9iYWxJZCA6IHZlYzM8dTMyPixcbiAgICAgICAgQGJ1aWx0aW4od29ya2dyb3VwX2lkKSB3b3JrZ3JvdXBJZCA6IHZlYzM8dTMyPikge1xuICAgIGxldCBiYXRjaCA9ICR7YT9cIjBcIjpcImkzMihnbG9iYWxJZC56KVwifTtcbiAgICAke24/YGxldCBiYXRjaEluZGljZXMgPSAke24ub2Zmc2V0VG9JbmRpY2VzKFwidTMyKGJhdGNoKVwiKX07YDpcIlwifVxuICAgIGxldCBudW1fdGlsZXMgPSAke2E/YCR7TWF0aC5jZWlsKGQvaSl9YDpcIih1bmlmb3Jtcy5kaW1faW5uZXIgLSAxKSAvIHRpbGVJbm5lciArIDFcIn07XG4gICAgdmFyIGtTdGFydCA9ICR7YT9gaTMyKGdsb2JhbElkLnopICogJHtkfWA6XCIwXCJ9O1xuXG4gICAgdmFyIGFjYyA6IGFycmF5PGFycmF5PCR7cn0sIGNvbFBlclRocmVhZD4sIHJvd1BlclRocmVhZD47XG4gICAgJHt4fVxuICB9XG5gfSx1Zj0oZSx0LHIsbixvPSExKT0+e2xldFtpLGEsZCxsXT1uLHA9X2UoblswXS50eXBlLnRlbnNvcik7cmV0dXJuYFxuICAgIGZuIG1tX3JlYWRBKGJhdGNoOiBpMzIsIHJvdzogaTMyLCBjb2xJbjogaTMyLCBiYXRjaEluZGljZXM6ICR7aS50eXBlLmluZGljZXN9KSAtPiAke0FlKGUscCl9IHtcbiAgICAgIHZhciB2YWx1ZSA9ICR7QWUoZSxwKX0oMC4wKTtcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7ZX07XG4gICAgICBpZihyb3cgPCB1bmlmb3Jtcy5kaW1fYV9vdXRlciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1faW5uZXIpXG4gICAgICB7XG4gICAgICAgIHZhciBhSW5kaWNlczogJHthLnR5cGUuaW5kaWNlc307XG4gICAgICAgICR7SnQoXCJhSW5kaWNlc1wiLGEsYS5yYW5rLTIsaS5yYW5rLFwiYmF0Y2hJbmRpY2VzXCIpfVxuICAgICAgICAke2EuaW5kaWNlc1NldChcImFJbmRpY2VzXCIsYS5yYW5rLTIsXCJ1MzIocm93KVwiKX1cbiAgICAgICAgJHthLmluZGljZXNTZXQoXCJhSW5kaWNlc1wiLGEucmFuay0xLFwidTMyKGNvbEluKVwiKX1cbiAgICAgICAgdmFsdWUgPSAke2EuZ2V0QnlJbmRpY2VzKFwiYUluZGljZXNcIil9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGZuIG1tX3JlYWRCKGJhdGNoOiBpMzIsIHJvdzogaTMyLCBjb2xJbjogaTMyLCBiYXRjaEluZGljZXM6ICR7aS50eXBlLmluZGljZXN9KSAtPiAke0FlKGUscCl9IHtcbiAgICAgIHZhciB2YWx1ZSA9ICR7QWUoZSxwKX0oMC4wKTtcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7ZX07XG4gICAgICBpZihyb3cgPCB1bmlmb3Jtcy5kaW1faW5uZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXIpXG4gICAgICB7XG4gICAgICAgIHZhciBiSW5kaWNlczogJHtkLnR5cGUuaW5kaWNlc307XG4gICAgICAgICR7SnQoXCJiSW5kaWNlc1wiLGQsZC5yYW5rLTIsaS5yYW5rLFwiYmF0Y2hJbmRpY2VzXCIpfVxuICAgICAgICAke2QuaW5kaWNlc1NldChcImJJbmRpY2VzXCIsZC5yYW5rLTIsXCJ1MzIocm93KVwiKX1cbiAgICAgICAgJHtkLmluZGljZXNTZXQoXCJiSW5kaWNlc1wiLGQucmFuay0xLFwidTMyKGNvbEluKVwiKX1cbiAgICAgICAgdmFsdWUgPSAke2QuZ2V0QnlJbmRpY2VzKFwiYkluZGljZXNcIil9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGZuIG1tX3dyaXRlKGJhdGNoOiBpMzIsIHJvdzogaTMyLCBjb2xJbjogaTMyLCB2YWx1ZUluOiAke0FlKGUscCl9KSB7XG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke2V9O1xuICAgICAgaWYgKHJvdyA8IHVuaWZvcm1zLmRpbV9hX291dGVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9iX291dGVyKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlSW47XG4gICAgICAgIGxldCBjb29yZHMgPSB2ZWMzPGkzMj4oYmF0Y2gsIHJvdywgY29sSW4pO1xuICAgICAgICAke3Q/YHZhbHVlID0gdmFsdWUgKyAke28/XCJiaWFzW2NvbEluXVwiOmAke0FlKGUscCl9KGJpYXNbcm93XSlgfTtgOlwiXCJ9XG4gICAgICAgICR7cn1cbiAgICAgICAgJHtsLnNldEJ5SW5kaWNlcyhcInZlYzM8dTMyPihjb29yZHMpXCIsXCJ2YWx1ZVwiKX1cbiAgICAgIH1cbiAgICB9XG4gICAgYH0sZXI9KGUsdCxyLG4sbz0hMSxpKT0+e2xldCBhPWVbMF0uZGltcyxkPWVbMV0uZGltcyxsPWEuc2xpY2UoMCwtMikscD1kLnNsaWNlKDAsLTIpLG09bj9uLnNsaWNlKDAsLTIpOnIuc2xpY2UoMCwtMiksdT1DLnNpemUobSksaD1hW2EubGVuZ3RoLTJdLF89YVthLmxlbmd0aC0xXSx5PWRbZC5sZW5ndGgtMV0sZz1fJTQ9PT0wJiZ5JTQ9PT0wLHg9aDw9OD9bNCwxLDFdOls0LDQsMV0sJD1bOCw4LDFdLHY9W01hdGguY2VpbCh5LyRbMF0veFswXSksTWF0aC5jZWlsKGgvJFsxXS94WzFdKSxNYXRoLmNlaWwodS8kWzJdL3hbMl0pXSxTPWc/NDoxLFQ9Wy4uLmwsaCxfL1NdLEE9VC5sZW5ndGgsaz1bLi4ucCxfLHkvU10sUD1rLmxlbmd0aCxEPVt1LGgseS9TXSxSPVt7dHlwZTo2LGRhdGE6aH0se3R5cGU6NixkYXRhOnl9LHt0eXBlOjYsZGF0YTpffV07S2UodCxSKSxSLnB1c2goLi4uTihtLFQsaykpO2xldCBHPVtcInJhbmtcIixcInJhbmtcIl0sSz1lLmxlbmd0aD4yO0smJihSLnB1c2goLi4uTihlWzJdLmRpbXMpKSxHLnB1c2goXCJyYW5rXCIpKSxSLnB1c2goLi4uTihEKSk7bGV0IGo9Vj0+e2xldCBRPW0ubGVuZ3RoLHNlPUxyKFwiYmF0Y2hEaW1zXCIsZVswXS5kYXRhVHlwZSxRLDEpLFk9X2UoZVswXS5kYXRhVHlwZSksZWU9RShcImFcIixlWzBdLmRhdGFUeXBlLEEsUyksSj1FKFwiYlwiLGVbMV0uZGF0YVR5cGUsUCxTKSxuZT1NKFwicmVzdWx0XCIsZVswXS5kYXRhVHlwZSxELmxlbmd0aCxTKSxiZT1bZWUsSl07aWYoSyl7bGV0IHE9bz9TOjE7YmUucHVzaChFKFwiYmlhc1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLmxlbmd0aCxxKSl9bGV0IE9lPVt7bmFtZTpcImRpbV9hX291dGVyXCIsdHlwZTpcImkzMlwifSx7bmFtZTpcImRpbV9iX291dGVyXCIsdHlwZTpcImkzMlwifSx7bmFtZTpcImRpbV9pbm5lclwiLHR5cGU6XCJpMzJcIn1dO2plKHQsT2UpO2xldCAkZT1fZShuZS50eXBlLnRlbnNvciksbGU9cWUodCxuZS50eXBlLnZhbHVlLCRlKSxXPXVmKFMsSyxsZSxbc2UsZWUsSixuZV0sbyk7cmV0dXJuYFxuICAke1YucmVnaXN0ZXJVbmlmb3JtcyhPZSkucmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlcyhzZSkuZGVjbGFyZVZhcmlhYmxlcyguLi5iZSxuZSl9XG4gICR7V31cbiAgJHtnP2hvKHgsJCxZLHNlKTpnbyh4LCQsWSxzZSl9XG4gICAgICAgICAgICAgICAgICAgYH07cmV0dXJue25hbWU6XCJNYXRNdWxcIixzaGFkZXJDYWNoZTp7aGludDpgJHt4fTske3QuYWN0aXZhdGlvbn07JHtnfTske299YCxpbnB1dERlcGVuZGVuY2llczpHfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmk/aShyKTpyLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4OnZbMF0seTp2WzFdLHo6dlsyXX0scHJvZ3JhbVVuaWZvcm1zOlJ9KSxnZXRTaGFkZXJTb3VyY2U6an19fSk7dmFyIGRmLFZ1LFd1PVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO2V0KCk7YWUoKTt5dCgpO1lyKCk7VXUoKTtYcigpO2RmPShlLHQscixuLG89ITEsaSxhPTQsZD00LGw9NCxwPVwiZjMyXCIpPT57bGV0IG09Rz0+e3N3aXRjaChHKXtjYXNlIDE6cmV0dXJuXCJyZXNEYXRhID0geFt4SW5kZXhdO1wiO2Nhc2UgMzpyZXR1cm5gcmVzRGF0YSA9IHZlYzM8JHtwfT4oeFt4SW5kZXhdLCB4W3hJbmRleCArIDFdLCB4W3hJbmRleCArIDJdKTtgO2Nhc2UgNDpyZXR1cm5cInJlc0RhdGEgPSB4W3hJbmRleCAvIDRdO1wiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBpbm5lckVsZW1lbnRTaXplICR7R30gaXMgbm90IHN1cHBvcnRlZC5gKX19LHU9Rz0+e3N3aXRjaChHKXtjYXNlIDE6cmV0dXJuXCJyZXR1cm4gd1tyb3cgKiBpMzIodW5pZm9ybXMud19zaGFwZVszXSkgKyBjb2xJbl07XCI7Y2FzZSA0OnJldHVyblwicmV0dXJuIHdbcm93ICogaTMyKHVuaWZvcm1zLndfc2hhcGVbM10pIC8gNCArIGNvbEluXTtcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW5uZXJFbGVtZW50U2l6ZSAke0d9IGlzIG5vdCBzdXBwb3J0ZWQuYCl9fSxoPWU/YFxuICAgIGxldCBjb29yZCA9IHZlYzQ8aTMyPihiYXRjaCwgeFJvdywgeENvbCwgeENoKTtcbiAgICBgOmBcbiAgICBsZXQgY29vcmQgPSB2ZWM0PGkzMj4oYmF0Y2gsIHhDaCwgeFJvdywgeENvbCk7XG4gICAgYCxfPWU/YFxuICAgIGxldCBjb29yZHMgPSB2ZWM0PGkzMj4oXG4gICAgICBiYXRjaCxcbiAgICAgIHJvdyAvIG91dFdpZHRoLFxuICAgICAgcm93ICUgb3V0V2lkdGgsXG4gICAgICBjb2wpO1xuICAgIGA6YFxuICAgIGxldCBjb29yZHMgPSB2ZWM0PGkzMj4oXG4gICAgICBiYXRjaCxcbiAgICAgIHJvdyxcbiAgICAgIGNvbCAvIG91dFdpZHRoLFxuICAgICAgY29sICUgb3V0V2lkdGgpO1xuICAgIGAseT1lP1wiaTMyKHVuaWZvcm1zLnhfc2hhcGVbMV0pXCI6XCJpMzIodW5pZm9ybXMueF9zaGFwZVsyXSlcIixnPWU/XCJpMzIodW5pZm9ybXMueF9zaGFwZVsyXSlcIjpcImkzMih1bmlmb3Jtcy54X3NoYXBlWzNdKVwiLHg9ZT9cInJvd1wiOlwiY29sXCIsJD1lP1wiY29sXCI6XCJyb3dcIix2PWBcbiAgICBsZXQgaW5DaGFubmVscyA9IGkzMih1bmlmb3Jtcy53X3NoYXBlWzJdKTtcbiAgICBsZXQgb3V0V2lkdGggPSAke2U/XCJpMzIodW5pZm9ybXMucmVzdWx0X3NoYXBlWzJdKVwiOlwiaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVszXSlcIn07XG4gICAgbGV0IG91dFJvdyA9ICR7eH0gLyBvdXRXaWR0aDtcbiAgICBsZXQgb3V0Q29sID0gJHt4fSAlIG91dFdpZHRoO1xuXG4gICAgbGV0IFdSb3cgPSAkeyR9IC8gKGkzMih1bmlmb3Jtcy53X3NoYXBlWzFdKSAqIGluQ2hhbm5lbHMpO1xuICAgIGxldCBXQ29sID0gJHskfSAvIGluQ2hhbm5lbHMgJSBpMzIodW5pZm9ybXMud19zaGFwZVsxXSk7XG4gICAgbGV0IHhSb3cgPSBvdXRSb3cgKiB1bmlmb3Jtcy5zdHJpZGVbMF0gKyB1bmlmb3Jtcy5kaWxhdGlvblswXSAqIFdSb3cgLSB1bmlmb3Jtcy5wYWRbMF07XG4gICAgbGV0IHhDb2wgPSBvdXRDb2wgKiB1bmlmb3Jtcy5zdHJpZGVbMV0gKyB1bmlmb3Jtcy5kaWxhdGlvblsxXSAqIFdDb2wgLSB1bmlmb3Jtcy5wYWRbMV07XG4gICAgbGV0IHhDaCA9ICR7JH0gJSBpbkNoYW5uZWxzO1xuICAgIHZhciByZXNEYXRhID0gJHtBZShhLHApfSgwLjApO1xuICAgIC8vIFRoZSBib3VuZHMgY2hlY2tpbmcgaXMgYWx3YXlzIG5lZWRlZCBzaW5jZSB3ZSB1c2UgaXQgdG8gcGFkIHplcm8gZm9yXG4gICAgLy8gdGhlICdzYW1lJyBwYWRkaW5nIHR5cGUuXG4gICAgaWYgKHhSb3cgPj0gMCAmJiB4Um93IDwgJHt5fSAmJiB4Q29sID49IDAgJiYgeENvbCA8ICR7Z30pIHtcbiAgICAgICR7aH1cbiAgICAgIGxldCB4SW5kZXggPSBnZXRJbmRleEZyb21Db29yZHM0RChjb29yZCwgdmVjNDxpMzI+KHVuaWZvcm1zLnhfc2hhcGUpKTtcbiAgICAgICR7bShhKX1cbiAgICB9XG4gICAgcmV0dXJuIHJlc0RhdGE7YCxTPWU/dCYmbj9gXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHthfTtcbiAgICAke3Z9YDpgXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHthfTtcbiAgICBpZiAocm93IDwgdW5pZm9ybXMuZGltX2Ffb3V0ZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2lubmVyKSB7XG4gICAgICAke3Z9XG4gICAgfVxuICAgIHJldHVybiAke0FlKGEscCl9KDAuMCk7YDpuJiZyP2BcbiAgICBsZXQgY29sID0gY29sSW4gKiAke2F9O1xuICAgICR7dn1gOmBcbiAgICBsZXQgY29sID0gY29sSW4gKiAke2F9O1xuICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1faW5uZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXIpIHtcbiAgICAgICR7dn1cbiAgICB9XG4gICAgcmV0dXJuICR7QWUoYSxwKX0oMC4wKTtgLFQ9ZT9uJiZyP3UoZCk6YFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7ZH07XG4gICAgaWYgKHJvdyA8IHVuaWZvcm1zLmRpbV9pbm5lciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1fYl9vdXRlcikge1xuICAgICAgJHt1KGQpfVxuICAgIH1cbiAgICByZXR1cm4gJHtBZShkLHApfSgwLjApO2A6YFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7ZH07XG4gICAgaWYgKHJvdyA8IHVuaWZvcm1zLmRpbV9pbm5lciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1fYV9vdXRlcikge1xuICAgICAgJHt1KGQpfVxuICAgIH1cbiAgICByZXR1cm4gJHtBZShkLHApfSgwLjApO2AsQT1BZShsLHApLGs9ZT9BZShhLHApOkFlKGQscCksUD1lP0FlKGQscCk6QWUoYSxwKSxEPXFlKGksQSxwKTtyZXR1cm5gXG4gICAgZm4gbW1fcmVhZEEoYmF0Y2g6IGkzMiwgcm93IDogaTMyLCBjb2xJbiA6IGkzMikgLT4gJHtrfSB7XG4gICAgICAke2U/UzpUfVxuICAgIH1cblxuICAgIGZuIG1tX3JlYWRCKGJhdGNoOiBpMzIsIHJvdyA6IGkzMiwgY29sSW4gOiBpMzIpIC0+ICR7UH0ge1xuICAgICAgJHtlP1Q6U31cbiAgICB9XG5cbiAgICBmbiBtbV93cml0ZShiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyLCB2YWx1ZUluIDogJHtBfSkge1xuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHtsfTtcbiAgICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1fYV9vdXRlciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1fYl9vdXRlcilcbiAgICAgIHtcbiAgICAgIHZhciB2YWx1ZSA9IHZhbHVlSW47XG4gICAgICBsZXQgb3V0V2lkdGggPSAke2U/XCJpMzIodW5pZm9ybXMucmVzdWx0X3NoYXBlWzJdKVwiOlwiaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVszXSlcIn07XG4gICAgICAke199XG4gICAgICAke011KG8pfVxuICAgICAgJHtEfVxuICAgICAgc2V0T3V0cHV0QXRDb29yZHMoY29vcmRzWzBdLCBjb29yZHNbMV0sIGNvb3Jkc1syXSwgY29vcmRzWzNdLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfWB9LFZ1PShlLHQscixuLG8saSxhLGQsbCk9PntsZXQgcD10LmZvcm1hdD09PVwiTkhXQ1wiLG09cD9lWzBdLmRpbXNbM106ZVswXS5kaW1zWzFdLHU9clswXSxoPXA/clsyXTpyWzNdLF89cD9yWzFdOnJbMl0seT1wP3JbM106clsxXSxnPXAmJihtJTQ9PT0wfHxtJTM9PT0wKSYmeSU0PT09MCx4PXA/eTpoKl8sJD1wP2gqXzp5LHY9WzgsOCwxXSxTPW48PTg/WzQsMSwxXTpbNCw0LDFdLFQ9W01hdGguY2VpbCh4L3ZbMF0vU1swXSksTWF0aC5jZWlsKCQvdlsxXS9TWzFdKSxNYXRoLmNlaWwodS92WzJdL1NbMl0pXTt1ZShcInZlcmJvc2VcIiwoKT0+YFtjb252MmRfbW1fd2ViZ3B1XSBkaXNwYXRjaCA9ICR7VH1gKTtsZXQgQT1nP3AmJm0lNCE9PTA/Mzo0OjEsaz12WzFdKlNbMV0sUD12WzBdKlNbMF0sRD1NYXRoLm1heCh2WzBdKkEsdlsxXSksUj1uJWs9PT0wLEc9byVQPT09MCxLPWklRD09PTAsaj1nP1tBLDQsNF06WzEsMSwxXSxWPVt7dHlwZTo2LGRhdGE6bn0se3R5cGU6NixkYXRhOm99LHt0eXBlOjYsZGF0YTppfSx7dHlwZTo2LGRhdGE6W3QucGFkc1swXSx0LnBhZHNbMV1dfSx7dHlwZTo2LGRhdGE6dC5zdHJpZGVzfSx7dHlwZTo2LGRhdGE6dC5kaWxhdGlvbnN9XTtLZSh0LFYpLFYucHVzaCguLi5OKGVbMF0uZGltcyxlWzFdLmRpbXMpKTtsZXQgUT1bXCJyYW5rXCIsXCJyYW5rXCJdO2EmJihWLnB1c2goLi4uTihlWzJdLmRpbXMpKSxRLnB1c2goXCJyYW5rXCIpKSxWLnB1c2goLi4uTihyKSk7bGV0IHNlPVk9PntsZXQgZWU9W3tuYW1lOlwiZGltX2Ffb3V0ZXJcIix0eXBlOlwiaTMyXCJ9LHtuYW1lOlwiZGltX2Jfb3V0ZXJcIix0eXBlOlwiaTMyXCJ9LHtuYW1lOlwiZGltX2lubmVyXCIsdHlwZTpcImkzMlwifSx7bmFtZTpcInBhZFwiLHR5cGU6XCJpMzJcIixsZW5ndGg6Mn0se25hbWU6XCJzdHJpZGVcIix0eXBlOlwiaTMyXCIsbGVuZ3RoOjJ9LHtuYW1lOlwiZGlsYXRpb25cIix0eXBlOlwiaTMyXCIsbGVuZ3RoOjJ9XTtqZSh0LGVlKTtsZXQgSj1nPzQ6MSxuZT1fZShlWzBdLmRhdGFUeXBlKSxiZT1gXG4gICAgICBmbiBzZXRPdXRwdXRBdEluZGV4KGZsYXRJbmRleCA6IGkzMiwgdmFsdWUgOiAke2c/YHZlYzQ8JHtuZX0+YDpuZX0pIHtcbiAgICAgICAgcmVzdWx0W2ZsYXRJbmRleF0gPSAke2c/YHZlYzQ8JHtuZX0+YDpuZX0odmFsdWUpO1xuICAgICAgfVxuICAgICAgZm4gc2V0T3V0cHV0QXRDb29yZHMoZDAgOiBpMzIsIGQxIDogaTMyLCBkMiA6IGkzMiwgZDMgOiBpMzIsIHZhbHVlIDogJHtnP2B2ZWM0PCR7bmV9PmA6bmV9KSB7XG4gICAgICAgIGxldCBmbGF0SW5kZXggPSBnZXRPdXRwdXRJbmRleEZyb21Db29yZHModmVjNDxpMzI+KGQwLCBkMSwgZDIsIGQzKSk7XG4gICAgICAgIHNldE91dHB1dEF0SW5kZXgoZmxhdEluZGV4ICR7Zz9cIi8gNFwiOlwiXCJ9LCB2YWx1ZSk7XG4gICAgICB9YCxPZT1FKFwieFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLmxlbmd0aCxBPT09Mz8xOkEpLCRlPUUoXCJ3XCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMubGVuZ3RoLEopLGxlPVtPZSwkZV0sVz1NKFwicmVzdWx0XCIsZVswXS5kYXRhVHlwZSxyLmxlbmd0aCxKKTtpZihhKXtsZXQgcT1FKFwiYmlhc1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLmxlbmd0aCxKKTtsZS5wdXNoKHEpLGJlKz1gXG4gICAgICAgIGZuIGdldEJpYXNCeU91dHB1dENvb3Jkcyhjb29yZHMgOiB2ZWM0PGkzMj4pIC0+ICR7Zz9gdmVjNDwke25lfT5gOm5lfSB7XG4gICAgICAgICAgcmV0dXJuIGJpYXNbY29vcmRzLiR7cD9cIndcIjpcInlcIn0ke2c/XCIvIDRcIjpcIlwifV07XG4gICAgICAgIH1gfXJldHVybmBcbiAgICAgICAgJHtSdShcInVuaWZvcm1zLnJlc3VsdF9zdHJpZGVzXCIpfVxuICAgICAgICAvL3N0cnVjdCBVbmlmb3JtcyB7IHhTaGFwZSA6IHZlYzQ8aTMyPiwgd1NoYXBlIDogdmVjNDxpMzI+LCBvdXRTaGFwZSA6IHZlYzQ8aTMyPixcbiAgICAgICAgLy8gIG91dFNoYXBlU3RyaWRlczogdmVjMzxpMzI+LCBmaWx0ZXJEaW1zIDogdmVjMjxpMzI+LCBwYWQgOiB2ZWMyPGkzMj4sIHN0cmlkZSA6IHZlYzI8aTMyPixcbiAgICAgICAgLy8gIGRpbGF0aW9uIDogdmVjMjxpMzI+LCBkaW1BT3V0ZXIgOiBpMzIsIGRpbUJPdXRlciA6IGkzMiwgZGltSW5uZXIgOiBpMzIgfTtcbiAgICAgICAgJHtZLnJlZ2lzdGVyVW5pZm9ybXMoZWUpLmRlY2xhcmVWYXJpYWJsZXMoLi4ubGUsVyl9XG4gICAgICAgICR7YmV9XG4gICAgICAgICR7ZGYocCxSLEcsSyxhLHQsalswXSxqWzFdLGpbMl0sbmUpfVxuICAgICAgICAke2c/aG8oUyx2LG5lLHZvaWQgMCwhcCxEKTpnbyhTLHYsbmUsdm9pZCAwLCFwLEQsITEsdm9pZCAwLGQpfWB9O3JldHVybntuYW1lOlwiQ29udjJETWF0TXVsXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5jYWNoZUtleX07JHtBfTske2d9OyR7Un07JHtHfTske0t9OyR7a307JHtQfTske0R9YCxpbnB1dERlcGVuZGVuY2llczpRfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmw/bChyKTpyLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4OlRbMF0seTpUWzFdLHo6VFsyXX0scHJvZ3JhbVVuaWZvcm1zOlZ9KSxnZXRTaGFkZXJTb3VyY2U6c2V9fX0pO3ZhciBsZixMdSxKcixjZixHdSxwZixIdSxGdSxxdT1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtldCgpO29lKCk7YWUoKTt5dCgpO1lyKCk7bGY9ZT0+e2xldCB0PTE7Zm9yKGxldCByPTA7cjxlLmxlbmd0aDtyKyspdCo9ZVtyXTtyZXR1cm4gdH0sTHU9ZT0+dHlwZW9mIGU9PVwibnVtYmVyXCI/W2UsZSxlXTplLEpyPShlLHQpPT50PD0xP2U6ZSsoZS0xKSoodC0xKSxjZj0oZSx0LHIsbj0xKT0+e2xldCBvPUpyKHQsbik7cmV0dXJuIE1hdGguZmxvb3IoKGVbMF0qKHItMSktcitvKS8yKX0sR3U9KGUsdCxyLG4sbyk9PntvPT1udWxsJiYobz1jZihlLHRbMF0sblswXSkpO2xldCBpPVswLDAsMCxyXTtmb3IobGV0IGE9MDthPDM7YSsrKWVbYV0rMipvPj10W2FdJiYoaVthXT1NYXRoLnRydW5jKChlW2FdLXRbYV0rMipvKS9uW2FdKzEpKTtyZXR1cm4gaX0scGY9KGUsdCxyLG4sbyxpLGEsZCxsLHApPT57bGV0IG0sdSxoLF87aWYoZT09PVwiVkFMSURcIiYmKGU9MCksdHlwZW9mIGU9PVwibnVtYmVyXCIpe209e3RvcDplLGJvdHRvbTplLGxlZnQ6ZSxyaWdodDplLGZyb250OmUsYmFjazplfTtsZXQgeT1HdShbdCxyLG4sMV0sW2QsbCxwXSwxLFtvLGksYV0sZSk7dT15WzBdLGg9eVsxXSxfPXlbMl19ZWxzZSBpZihBcnJheS5pc0FycmF5KGUpKXtpZighZS5ldmVyeSgoZyx4LCQpPT5nPT09JFswXSkpdGhyb3cgRXJyb3IoYFVuc3VwcG9ydGVkIHBhZGRpbmcgcGFyYW1ldGVyOiAke2V9YCk7bT17dG9wOmVbMF0sYm90dG9tOmVbMV0sbGVmdDplWzJdLHJpZ2h0OmVbM10sZnJvbnQ6ZVs0XSxiYWNrOmVbNV19O2xldCB5PUd1KFt0LHIsbiwxXSxbZCxsLHBdLDEsW28saSxhXSxlWzBdKTt1PXlbMF0saD15WzFdLF89eVsyXX1lbHNlIGlmKGU9PT1cIlNBTUVfVVBQRVJcIil7dT1NYXRoLmNlaWwodC9vKSxoPU1hdGguY2VpbChyL2kpLF89TWF0aC5jZWlsKG4vYSk7bGV0IHk9KHUtMSkqbytkLXQsZz0oaC0xKSppK2wtcix4PShfLTEpKmErcC1uLCQ9TWF0aC5mbG9vcih5LzIpLHY9eS0kLFM9TWF0aC5mbG9vcihnLzIpLFQ9Zy1TLEE9TWF0aC5mbG9vcih4LzIpLGs9eC1BO209e3RvcDpTLGJvdHRvbTpULGxlZnQ6QSxyaWdodDprLGZyb250OiQsYmFjazp2fX1lbHNlIHRocm93IEVycm9yKGBVbmtub3duIHBhZGRpbmcgcGFyYW1ldGVyOiAke2V9YCk7cmV0dXJue3BhZEluZm86bSxvdXREZXB0aDp1LG91dEhlaWdodDpoLG91dFdpZHRoOl99fSxIdT0oZSx0LHIsbixvLGk9ITEsYT1cImNoYW5uZWxzTGFzdFwiKT0+e2xldCBkLGwscCxtLHU7aWYoYT09PVwiY2hhbm5lbHNMYXN0XCIpW2QsbCxwLG0sdV09ZTtlbHNlIGlmKGE9PT1cImNoYW5uZWxzRmlyc3RcIilbZCx1LGwscCxtXT1lO2Vsc2UgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGRhdGFGb3JtYXQgJHthfWApO2xldFtoLCxfLHksZ109dCxbeCwkLHZdPUx1KHIpLFtTLFQsQV09THUobiksaz1KcihfLFMpLFA9SnIoeSxUKSxEPUpyKGcsQSkse3BhZEluZm86UixvdXREZXB0aDpHLG91dEhlaWdodDpLLG91dFdpZHRoOmp9PXBmKG8sbCxwLG0seCwkLHYsayxQLEQpLFY9aT9oKnU6aCxRPVswLDAsMCwwLDBdO3JldHVybiBhPT09XCJjaGFubmVsc0ZpcnN0XCI/UT1bZCxWLEcsSyxqXTphPT09XCJjaGFubmVsc0xhc3RcIiYmKFE9W2QsRyxLLGosVl0pLHtiYXRjaFNpemU6ZCxkYXRhRm9ybWF0OmEsaW5EZXB0aDpsLGluSGVpZ2h0OnAsaW5XaWR0aDptLGluQ2hhbm5lbHM6dSxvdXREZXB0aDpHLG91dEhlaWdodDpLLG91dFdpZHRoOmosb3V0Q2hhbm5lbHM6VixwYWRJbmZvOlIsc3RyaWRlRGVwdGg6eCxzdHJpZGVIZWlnaHQ6JCxzdHJpZGVXaWR0aDp2LGZpbHRlckRlcHRoOl8sZmlsdGVySGVpZ2h0OnksZmlsdGVyV2lkdGg6ZyxlZmZlY3RpdmVGaWx0ZXJEZXB0aDprLGVmZmVjdGl2ZUZpbHRlckhlaWdodDpQLGVmZmVjdGl2ZUZpbHRlcldpZHRoOkQsZGlsYXRpb25EZXB0aDpTLGRpbGF0aW9uSGVpZ2h0OlQsZGlsYXRpb25XaWR0aDpBLGluU2hhcGU6ZSxvdXRTaGFwZTpRLGZpbHRlclNoYXBlOnR9fSxGdT0oZSx0LHIsbixvLGkpPT57bGV0IGE9aT09PVwiY2hhbm5lbHNMYXN0XCIsZD1hP2VbMF0uZGltc1szXTplWzBdLmRpbXNbMV0sbD0hMSxwPVs2NCwxLDFdLG09e3g6ci5tYXAoKHYsUyk9PlMpfSx1PVtNYXRoLmNlaWwobGYobS54Lm1hcCh2PT5yW3ZdKSkvcFswXSksMSwxXTt1ZShcInZlcmJvc2VcIiwoKT0+YFtjb252M2RfbmFpdmVfd2ViZ3B1XSBkaXNwYXRjaCA9ICR7dX1gKTtsZXQgaD1sP2EmJmQlNCE9PTA/Mzo0OjEsXz1DLnNpemUocikseT1be3R5cGU6MTIsZGF0YTpffSx7dHlwZToxMixkYXRhOm59LHt0eXBlOjEyLGRhdGE6b30se3R5cGU6MTIsZGF0YTp0LnN0cmlkZXN9LHt0eXBlOjEyLGRhdGE6dC5kaWxhdGlvbnN9XTtLZSh0LHkpLHkucHVzaCguLi5OKGVbMF0uZGltcyxlWzFdLmRpbXMpKTtsZXQgZz1bXCJyYW5rXCIsXCJyYW5rXCJdLHg9ZS5sZW5ndGg9PT0zO3gmJih5LnB1c2goLi4uTihlWzJdLmRpbXMpKSxnLnB1c2goXCJyYW5rXCIpKSx5LnB1c2goLi4uTihyKSk7bGV0ICQ9dj0+e2xldCBTPVt7bmFtZTpcIm91dHB1dF9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImZpbHRlcl9kaW1zXCIsdHlwZTpcInUzMlwiLGxlbmd0aDpuLmxlbmd0aH0se25hbWU6XCJwYWRzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDpvLmxlbmd0aH0se25hbWU6XCJzdHJpZGVzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDp0LnN0cmlkZXMubGVuZ3RofSx7bmFtZTpcImRpbGF0aW9uc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6dC5kaWxhdGlvbnMubGVuZ3RofV07amUodCxTKTtsZXQgVD1sPzQ6MSxBPV9lKGVbMF0uZGF0YVR5cGUpLGs9RShcInhcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcy5sZW5ndGgsaD09PTM/MTpoKSxQPUUoXCJXXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMubGVuZ3RoLFQpLEQ9W2ssUF0sUj1NKFwicmVzdWx0XCIsZVswXS5kYXRhVHlwZSxyLmxlbmd0aCxUKSxHPVwiXCI7aWYoeCl7bGV0IFY9RShcImJpYXNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcy5sZW5ndGgsVCk7RC5wdXNoKFYpLEcrPWBcbiAgICAgICAgZm4gZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3JkcyA6IGFycmF5PHUzMiwgNT4pIC0+ICR7bD9gdmVjNDwke0F9PmA6QX0ge1xuICAgICAgICAgIHJldHVybiBiaWFzWyR7YT9GKFwiY29vcmRzXCIsNCw1KTpGKFwiY29vcmRzXCIsMSw1KX0ke2w/XCIvIDRcIjpcIlwifV07XG4gICAgICAgIH1gfWxldCBLPUFlKGgsQSksaj1xZSh0LEssQSk7cmV0dXJuYFxuICAgICAgICAgICAgJHtHfVxuICAgICAgICAgICAgZm4gZ2V0WChkMCA6IHUzMiwgZDEgOiB1MzIsIGQyIDogdTMyLCBkMyA6IHUzMiwgZDQgOiB1MzIpIC0+IGYzMiB7XG4gICAgICAgICAgICAgIGxldCBhSW5kaWNlcyA9IGFycmF5PHUzMiwgNT4oZDAsIGQxLCBkMiwgZDMsIGQ0KTtcbiAgICAgICAgICAgICAgcmV0dXJuICR7ay5nZXRCeUluZGljZXMoXCJhSW5kaWNlc1wiKX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbiBnZXRXKGQwIDogdTMyLCBkMSA6IHUzMiwgZDIgOiB1MzIsIGQzIDogdTMyLCBkNCA6IHUzMikgLT4gZjMyIHtcbiAgICAgICAgICAgICAgbGV0IGFJbmRpY2VzID0gYXJyYXk8dTMyLCA1PihkMCwgZDEsIGQyLCBkMywgZDQpO1xuICAgICAgICAgICAgICByZXR1cm4gJHtQLmdldEJ5SW5kaWNlcyhcImFJbmRpY2VzXCIpfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAke3YucmVnaXN0ZXJVbmlmb3JtcyhTKS5kZWNsYXJlVmFyaWFibGVzKC4uLkQsUil9XG4gICAgICAgICAgJHt2Lm1haW5TdGFydCgpfVxuICAgICAgICAgICR7di5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgICAgICAgICAgIGxldCBjb29yZHMgPSAke1Iub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAgICAgICAgIGxldCBiYXRjaCA9ICR7RihcImNvb3Jkc1wiLDAsay5yYW5rKX07XG4gICAgICAgICAgICAgIGxldCBkMiA9ICR7YT9GKFwiY29vcmRzXCIsay5yYW5rLTEsay5yYW5rKTpGKFwiY29vcmRzXCIsMSxrLnJhbmspfTtcbiAgICAgICAgICAgICAgbGV0IHhGUkNDb3JuZXIgPSB2ZWMzPHUzMj4oJHthP0YoXCJjb29yZHNcIiwxLGsucmFuayk6RihcImNvb3Jkc1wiLDIsay5yYW5rKX0sXG4gICAgICAgICAgICAgICR7YT9GKFwiY29vcmRzXCIsMixrLnJhbmspOkYoXCJjb29yZHNcIiwzLGsucmFuayl9LFxuICAgICAgICAgICAgICAke2E/RihcImNvb3Jkc1wiLDMsay5yYW5rKTpGKFwiY29vcmRzXCIsNCxrLnJhbmspfSkgKiB1bmlmb3Jtcy5zdHJpZGVzIC0gdW5pZm9ybXMucGFkcztcbiAgICAgICAgICAgICAgbGV0IHhGQ29ybmVyID0geEZSQ0Nvcm5lci54O1xuICAgICAgICAgICAgICBsZXQgeFJDb3JuZXIgPSB4RlJDQ29ybmVyLnk7XG4gICAgICAgICAgICAgIGxldCB4Q0Nvcm5lciA9IHhGUkNDb3JuZXIuejtcbiAgICAgICAgICAgICAgbGV0IHhTaGFwZVkgPSAke2E/RihcInVuaWZvcm1zLnhfc2hhcGVcIiwxLGsucmFuayk6RihcInVuaWZvcm1zLnhfc2hhcGVcIiwyLGsucmFuayl9O1xuICAgICAgICAgICAgICBsZXQgeFNoYXBlWiA9ICR7YT9GKFwidW5pZm9ybXMueF9zaGFwZVwiLDIsay5yYW5rKTpGKFwidW5pZm9ybXMueF9zaGFwZVwiLDMsay5yYW5rKX07XG4gICAgICAgICAgICAgIGxldCB4U2hhcGVXID0gJHthP0YoXCJ1bmlmb3Jtcy54X3NoYXBlXCIsMyxrLnJhbmspOkYoXCJ1bmlmb3Jtcy54X3NoYXBlXCIsNCxrLnJhbmspfTtcbiAgICAgICAgICAgICAgbGV0IHhTaGFwZVUgPSAke2E/RihcInVuaWZvcm1zLnhfc2hhcGVcIiw0LGsucmFuayk6RihcInVuaWZvcm1zLnhfc2hhcGVcIiwxLGsucmFuayl9O1xuICAgICAgICAgICAgICBsZXQgaW5wdXREZXB0aE5lYXJlc3RWZWM0ID0gKHhTaGFwZVUgLyA0KSAqIDQ7XG4gICAgICAgICAgICAgIGxldCBpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9IHhTaGFwZVUgJSA0O1xuXG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9IDAuMDtcbiAgICAgICAgICAgICAgZm9yICh2YXIgd0YgPSAwdTsgd0YgPCB1bmlmb3Jtcy5maWx0ZXJfZGltc1swXTsgd0YrKykge1xuICAgICAgICAgICAgICAgIGxldCB4RiA9IHhGQ29ybmVyICsgd0YgKiB1bmlmb3Jtcy5kaWxhdGlvbnNbMF07XG4gICAgICAgICAgICAgICAgaWYgKHhGIDwgMCB8fCB4RiA+PSB4U2hhcGVZKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciB3UiA9IDB1OyB3UiA8IHVuaWZvcm1zLmZpbHRlcl9kaW1zWzFdOyB3UisrKSB7XG4gICAgICAgICAgICAgICAgICBsZXQgeFIgPSB4UkNvcm5lciArIHdSICogdW5pZm9ybXMuZGlsYXRpb25zWzFdO1xuICAgICAgICAgICAgICAgICAgaWYgKHhSIDwgMCB8fCB4UiA+PSB4U2hhcGVaKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciB3QyA9IDB1OyB3QyA8IHVuaWZvcm1zLmZpbHRlcl9kaW1zWzJdOyB3QysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB4QyA9IHhDQ29ybmVyICsgd0MgKiB1bmlmb3Jtcy5kaWxhdGlvbnNbMl07XG4gICAgICAgICAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0geFNoYXBlVykge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZDEgPSAwdTsgZDEgPCBpbnB1dERlcHRoTmVhcmVzdFZlYzQ7IGQxICs9IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAke2E/YGxldCB4VmFsdWVzID0gdmVjNDxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGQxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBkMSArIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGQxICsgMiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgZDEgKyAzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYDpgbGV0IHhWYWx1ZXMgPSB2ZWM0PGYzMj4oXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgZDEsIHhGLCB4UiwgeEMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGQxICsgMSwgeEYsIHhSLCB4QyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgZDEgKyAyLCB4RiwgeFIsIHhDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBkMSArIDMsIHhGLCB4UiwgeEMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB3VmFsdWVzID0gdmVjNDxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgZDEsIHdGLCB3Uiwgd0MpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgZDEgKyAxLCB3Riwgd1IsIHdDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGQxICsgMiwgd0YsIHdSLCB3QyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBkMSArIDMsIHdGLCB3Uiwgd0MpKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0RGVwdGhWZWM0UmVtYWluZGVyID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICR7YT9gdmFsdWUgKz0gZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgaW5wdXREZXB0aE5lYXJlc3RWZWM0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAqIGdldFcoZDIsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCwgd0YsIHdSLCB3Qyk7YDpgdmFsdWUgKz0gZ2V0WChiYXRjaCwgaW5wdXREZXB0aE5lYXJlc3RWZWM0LCB4RiwgeFIsIHhDKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAqIGdldFcoZDIsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCwgd0YsIHdSLCB3Qyk7YH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgJHthP2BsZXQgeFZhbHVlcyA9IHZlYzI8ZjMyPihcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCksXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgYDpgbGV0IHhWYWx1ZXMgPSB2ZWMyPGYzMj4oXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQsIHhGLCB4UiwgeEMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMSwgeEYsIHhSLCB4QykpO1xuICAgICAgICAgICAgICAgICAgICBgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlcyA9IHZlYzI8ZjMyPihcbiAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQsIHdGLCB3Uiwgd0MpLFxuICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDEsIHdGLCB3Uiwgd0MpKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXREZXB0aFZlYzRSZW1haW5kZXIgPT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICR7YT9gbGV0IHhWYWx1ZXMgPSB2ZWMzPGYzMj4oXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAyKSk7XG4gICAgICAgICAgICAgICAgICAgICAgYDpgbGV0IHhWYWx1ZXMgPSB2ZWMzPGYzMj4oXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQsIHhGLCB4UiwgeEMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMSwgeEYsIHhSLCB4QyksXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAyLCB4RiwgeFIsIHhDKSk7XG4gICAgICAgICAgICAgICAgICAgIGB9XG4gICAgICAgICAgICAgICAgICAgIGxldCB3VmFsdWVzID0gdmVjMzxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCwgd0YsIHdSLCB3QyksXG4gICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMSwgd0YsIHdSLCB3QyksXG4gICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMiwgd0YsIHdSLCB3QykpO1xuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGRvdCh4VmFsdWVzLCB3VmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAke3g/XCJ2YWx1ZSA9IHZhbHVlICsgZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3JkcylcIjpcIlwifTtcbiAgICAgICAgICAgICAgJHtqfVxuICAgICAgICAgICAgICByZXN1bHRbZ2xvYmFsX2lkeF0gPSBmMzIodmFsdWUpO1xuICAgICAgICAgIH1gfTtyZXR1cm57bmFtZTpcIkNvbnYzRE5haXZlXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5jYWNoZUtleX07JHthfTske2h9OyR7eH1gLGlucHV0RGVwZW5kZW5jaWVzOmd9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6cixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDp1WzBdLHk6dVsxXSx6OnVbMl19LHByb2dyYW1Vbmlmb3Jtczp5fSksZ2V0U2hhZGVyU291cmNlOiR9fX0pO3ZhciBLdSxqdSxZdT1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtvZSgpO2FlKCk7eXQoKTtLdT0oZSx0LHIsbik9PntsZXQgbz1lLmxlbmd0aD4yLGk9bz9cInZhbHVlICs9IGJbb3V0cHV0X2NoYW5uZWxdO1wiOlwiXCIsYT1lWzBdLmRpbXMsZD1lWzFdLmRpbXMsbD10LmZvcm1hdD09PVwiTkhXQ1wiLHA9bD9yWzNdOnJbMV0sbT1wL3QuZ3JvdXAsdT1sJiZtPj00P21lKHApOjEsaD1DLnNpemUocikvdSxfPVt7dHlwZToxMixkYXRhOmh9LHt0eXBlOjEyLGRhdGE6dC5kaWxhdGlvbnN9LHt0eXBlOjEyLGRhdGE6W3Quc3RyaWRlc1swXSx0LnN0cmlkZXNbMV1dfSx7dHlwZToxMixkYXRhOlt0LnBhZHNbMF0sdC5wYWRzWzFdXX0se3R5cGU6MTIsZGF0YTptfV07S2UodCxfKSxfLnB1c2goLi4uTihhLFtkWzBdLGRbMV0sZFsyXSxkWzNdL3VdKSk7bGV0IHk9bz9bXCJyYW5rXCIsXCJyYW5rXCIsXCJyYW5rXCJdOltcInJhbmtcIixcInJhbmtcIl07Xy5wdXNoKC4uLk4oW3JbMF0sclsxXSxyWzJdLHJbM10vdV0pKTtsZXQgZz14PT57bGV0ICQ9TShcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsci5sZW5ndGgsdSksdj1fZSgkLnR5cGUudGVuc29yKSxTPXFlKHQsJC50eXBlLnZhbHVlLHYpLFQ9RShcInhcIixlWzBdLmRhdGFUeXBlLGEubGVuZ3RoKSxBPUUoXCJ3XCIsZVsxXS5kYXRhVHlwZSxkLmxlbmd0aCx1KSxrPVtULEFdO28mJmsucHVzaChFKFwiYlwiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLHUpKTtsZXQgUD1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJkaWxhdGlvbnNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOnQuZGlsYXRpb25zLmxlbmd0aH0se25hbWU6XCJzdHJpZGVzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDoyfSx7bmFtZTpcInBhZHNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOjJ9LHtuYW1lOlwib3V0cHV0X2NoYW5uZWxzX3Blcl9ncm91cFwiLHR5cGU6XCJ1MzJcIn1dO2plKHQsUCk7bGV0IEQ9bD9gXG4gICAgICBmb3IgKHZhciB3SGVpZ2h0OiB1MzIgPSAwdTsgd0hlaWdodCA8IHVuaWZvcm1zLndfc2hhcGVbMF07IHdIZWlnaHQrKykge1xuICAgICAgICBsZXQgeEhlaWdodCA9IHhSQ0Nvcm5lci54ICsgd0hlaWdodCAqIHVuaWZvcm1zLmRpbGF0aW9uc1swXTtcblxuICAgICAgICBpZiAoeEhlaWdodCA8IDB1IHx8IHhIZWlnaHQgPj0gdW5pZm9ybXMueF9zaGFwZVsxXSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgd1dpZHRoOiB1MzIgPSAwdTsgd1dpZHRoIDwgdW5pZm9ybXMud19zaGFwZVsxXTsgd1dpZHRoKyspIHtcbiAgICAgICAgICBsZXQgeFdpZHRoID0geFJDQ29ybmVyLnkgKyB3V2lkdGggKiB1bmlmb3Jtcy5kaWxhdGlvbnNbMV07XG4gICAgICAgICAgaWYgKHhXaWR0aCA8IDB1IHx8IHhXaWR0aCA+PSB1bmlmb3Jtcy54X3NoYXBlWzJdKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciB3SW5DaGFubmVsOiB1MzIgPSAwdTsgd0luQ2hhbm5lbCA8IHVuaWZvcm1zLndfc2hhcGVbMl07IHdJbkNoYW5uZWwrKykge1xuICAgICAgICAgICAgbGV0IGlucHV0X2NoYW5uZWwgPSBpbl9jaGFubmVsX29mZnNldCArIHdJbkNoYW5uZWw7XG4gICAgICAgICAgICBsZXQgeFZhbCA9ICR7VC5nZXQoXCJiYXRjaFwiLFwieEhlaWdodFwiLFwieFdpZHRoXCIsXCJpbnB1dF9jaGFubmVsXCIpfTtcbiAgICAgICAgICAgIGxldCB3VmFsID0gJHtBLmdldChcIndIZWlnaHRcIixcIndXaWR0aFwiLFwid0luQ2hhbm5lbFwiLFwib3V0cHV0X2NoYW5uZWxcIil9O1xuICAgICAgICAgICAgdmFsdWUgKz0geFZhbCAqIHdWYWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBgOmBcbiAgICAgIGZvciAodmFyIHdJbkNoYW5uZWw6IHUzMiA9IDB1OyB3SW5DaGFubmVsIDwgdW5pZm9ybXMud19zaGFwZVsxXTsgd0luQ2hhbm5lbCsrKSB7XG4gICAgICAgIGxldCBpbnB1dF9jaGFubmVsID0gaW5fY2hhbm5lbF9vZmZzZXQgKyB3SW5DaGFubmVsO1xuICAgICAgICBmb3IgKHZhciB3SGVpZ2h0OiB1MzIgPSAwdTsgd0hlaWdodCA8IHVuaWZvcm1zLndfc2hhcGVbMl07IHdIZWlnaHQrKykge1xuICAgICAgICAgIGxldCB4SGVpZ2h0ID0geFJDQ29ybmVyLnggKyB3SGVpZ2h0ICogdW5pZm9ybXMuZGlsYXRpb25zWzBdO1xuXG4gICAgICAgICAgaWYgKHhIZWlnaHQgPCAwdSB8fCB4SGVpZ2h0ID49IHVuaWZvcm1zLnhfc2hhcGVbMl0pIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodmFyIHdXaWR0aDogdTMyID0gMHU7IHdXaWR0aCA8IHVuaWZvcm1zLndfc2hhcGVbM107IHdXaWR0aCsrKSB7XG4gICAgICAgICAgICBsZXQgeFdpZHRoID0geFJDQ29ybmVyLnkgKyB3V2lkdGggKiB1bmlmb3Jtcy5kaWxhdGlvbnNbMV07XG4gICAgICAgICAgICBpZiAoeFdpZHRoIDwgMHUgfHwgeFdpZHRoID49IHVuaWZvcm1zLnhfc2hhcGVbM10pIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCB4VmFsID0gJHtULmdldChcImJhdGNoXCIsXCJpbnB1dF9jaGFubmVsXCIsXCJ4SGVpZ2h0XCIsXCJ4V2lkdGhcIil9O1xuICAgICAgICAgICAgbGV0IHdWYWwgPSAke0EuZ2V0KFwib3V0cHV0X2NoYW5uZWxcIixcIndJbkNoYW5uZWxcIixcIndIZWlnaHRcIixcIndXaWR0aFwiKX07XG4gICAgICAgICAgICB2YWx1ZSArPSB4VmFsICogd1ZhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGA7cmV0dXJuYFxuICAke3gucmVnaXN0ZXJVbmlmb3JtcyhQKS5kZWNsYXJlVmFyaWFibGVzKC4uLmssJCl9XG5cbiAgJHt4Lm1haW5TdGFydCgpfVxuICAgICR7eC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG5cbiAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7JC5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICBsZXQgYmF0Y2g6IHUzMiA9IG91dHB1dEluZGljZXNbMF07XG4gICAgbGV0IG91dHB1dF9jaGFubmVsOiB1MzIgPSBvdXRwdXRJbmRpY2VzWyR7bD8zOjF9XTtcbiAgICBsZXQgeFJDQ29ybmVyOiB2ZWMyPHUzMj4gPSB2ZWMyPHUzMj4ob3V0cHV0SW5kaWNlc1ske2w/MToyfV0sIG91dHB1dEluZGljZXNbJHtsPzI6M31dKSAqIHVuaWZvcm1zLnN0cmlkZXMgLSB1bmlmb3Jtcy5wYWRzO1xuICAgIGxldCBncm91cF9pZDogdTMyID0gb3V0cHV0X2NoYW5uZWwgKiAke3V9IC8gdW5pZm9ybXMub3V0cHV0X2NoYW5uZWxzX3Blcl9ncm91cDtcbiAgICB2YXIgaW5fY2hhbm5lbF9vZmZzZXQgPSBncm91cF9pZCAqIHVuaWZvcm1zLndfc2hhcGVbJHtsPzI6MX1dO1xuXG4gICAgdmFyIHZhbHVlOiAkeyQudHlwZS52YWx1ZX0gPSAkeyQudHlwZS52YWx1ZX0oMCk7XG4gICAgJHtEfVxuICAgICR7aX1cbiAgICAke1N9XG4gICAgJHskLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIil9XG4gIH1gfTtyZXR1cm57bmFtZTpcIkdyb3VwZWRDb252XCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5jYWNoZUtleX1fJHt1fWAsaW5wdXREZXBlbmRlbmNpZXM6eX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpuP24ocik6cixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoaC82NCl9LHByb2dyYW1Vbmlmb3JtczpffSksZ2V0U2hhZGVyU291cmNlOmd9fSxqdT0oZSx0LHIsbik9PntsZXQgbz1lLmxlbmd0aD4yLGk9bWUoclszXSksYT1tZShyWzJdKSxkPUMuc2l6ZShyKS9pL2EsbD1bZVswXS5kaW1zWzBdLGVbMF0uZGltc1sxXSxlWzBdLmRpbXNbMl0sZVswXS5kaW1zWzNdL2ldLHA9W2VbMV0uZGltc1swXSxlWzFdLmRpbXNbMV0sZVsxXS5kaW1zWzJdLGVbMV0uZGltc1szXS9pXSxtPVtyWzBdLHJbMV0sclsyXSxyWzNdL2ldLHU9W3t0eXBlOjEyLGRhdGE6ZH0se3R5cGU6NixkYXRhOlt0LnN0cmlkZXNbMF0sdC5zdHJpZGVzWzFdXX0se3R5cGU6NixkYXRhOlt0LnBhZHNbMF0sdC5wYWRzWzFdXX1dO0tlKHQsdSksdS5wdXNoKC4uLk4obCxwLG0pKTtsZXQgaD0oYS0xKSp0LnN0cmlkZXNbMV0rcFsxXSxfPXk9PntsZXQgZz1NKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxtLmxlbmd0aCxpKSx4PV9lKGcudHlwZS50ZW5zb3IpLCQ9cWUodCxnLnR5cGUudmFsdWUseCksdj1FKFwieFwiLGVbMF0uZGF0YVR5cGUsbC5sZW5ndGgsaSksUz1FKFwid1wiLGVbMV0uZGF0YVR5cGUscC5sZW5ndGgsaSksVD1bdixTXTtvJiZULnB1c2goRShcImJcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcyxpKSk7bGV0IEE9bz9cInZhbHVlICs9IGJbb3V0cHV0X2NoYW5uZWxdO1wiOlwiXCIsaz1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJzdHJpZGVzXCIsdHlwZTpcImkzMlwiLGxlbmd0aDoyfSx7bmFtZTpcInBhZHNcIix0eXBlOlwiaTMyXCIsbGVuZ3RoOjJ9XTtyZXR1cm4gamUodCxrKSxgXG4gICR7eS5yZWdpc3RlclVuaWZvcm1zKGspLmRlY2xhcmVWYXJpYWJsZXMoLi4uVCxnKX1cbiAgJHt5Lm1haW5TdGFydCgpfVxuICAgICR7eS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgbGV0IHdpZHRoMCA9IHVuaWZvcm1zLm91dHB1dF9zaGFwZVszXTtcbiAgICBsZXQgb3V0cHV0X2NoYW5uZWwgPSBnbG9iYWxfaWR4ICUgd2lkdGgwO1xuICAgIHZhciBpbmRleDEgPSBnbG9iYWxfaWR4IC8gd2lkdGgwO1xuICAgIGxldCB3aWR0aDEgPSB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMl0gLyAke2F9dTtcbiAgICBsZXQgY29sID0gKGluZGV4MSAlIHdpZHRoMSkgKiAke2F9dTtcbiAgICBpbmRleDEgPSBpbmRleDEgLyB3aWR0aDE7XG4gICAgbGV0IHJvdyA9IGluZGV4MSAlIHVuaWZvcm1zLm91dHB1dF9zaGFwZVsxXTtcbiAgICBsZXQgYmF0Y2ggPSBpbmRleDEgLyB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMV07XG5cbiAgICBsZXQgeF9jb3JuZXIgPSB2ZWMyPGkzMj4oaTMyKHJvdyksIGkzMihjb2wpKSAqIHVuaWZvcm1zLnN0cmlkZXMgLSB1bmlmb3Jtcy5wYWRzO1xuXG4gICAgdmFyIHhfdmFsczogYXJyYXk8JHt2LnR5cGUudmFsdWV9LCAke2h9PjtcbiAgICB2YXIgdmFsdWVzOiBhcnJheTwke2cudHlwZS52YWx1ZX0sICR7YX0+O1xuICAgIGxldCBpbnB1dF9jaGFubmVsID0gb3V0cHV0X2NoYW5uZWw7XG4gICAgLy8gVXNlIGNvbnN0YW50IGluc3RlYWQgb2YgdW5pZm9ybSBjYW4gZ2l2ZSBiZXR0ZXIgcGVyZm9ybWFuY2UgZm9yIHcncyBoZWlnaHQvd2lkdGguXG4gICAgZm9yICh2YXIgd19oZWlnaHQ6IHUzMiA9IDB1OyB3X2hlaWdodCA8ICR7cFswXX07IHdfaGVpZ2h0KyspIHtcbiAgICAgIGxldCB4X2hlaWdodCA9IHhfY29ybmVyLnggKyBpMzIod19oZWlnaHQpO1xuICAgICAgaWYgKHhfaGVpZ2h0ID49IDAgJiYgdTMyKHhfaGVpZ2h0KSA8IHVuaWZvcm1zLnhfc2hhcGVbMV0pIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAke2h9OyBpKyspIHtcbiAgICAgICAgICBsZXQgeF93aWR0aCA9IHhfY29ybmVyLnkgKyBpO1xuICAgICAgICAgIGlmICh4X3dpZHRoID49IDAgJiYgdTMyKHhfd2lkdGgpIDwgdW5pZm9ybXMueF9zaGFwZVsyXSkge1xuICAgICAgICAgICAgeF92YWxzW2ldID0gJHt2LmdldChcImJhdGNoXCIsXCJ1MzIoeF9oZWlnaHQpXCIsXCJ1MzIoeF93aWR0aClcIixcImlucHV0X2NoYW5uZWxcIil9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4X3ZhbHNbaV0gPSAke3YudHlwZS52YWx1ZX0oMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIHdfd2lkdGg6IHUzMiA9IDB1OyB3X3dpZHRoIDwgJHtwWzFdfTsgd193aWR0aCsrKSB7XG4gICAgICAgICAgbGV0IHdfdmFsID0gJHtTLmdldChcIndfaGVpZ2h0XCIsXCJ3X3dpZHRoXCIsXCIwXCIsXCJvdXRwdXRfY2hhbm5lbFwiKX07XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDB1OyBpIDwgJHthfXU7IGkrKykge1xuICAgICAgICAgICAgdmFsdWVzW2ldID0gZm1hKHhfdmFsc1tpICogdTMyKHVuaWZvcm1zLnN0cmlkZXNbMV0pICsgd193aWR0aF0sIHdfdmFsLCB2YWx1ZXNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwdTsgaSA8ICR7YX11OyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICR7QX1cbiAgICAgICR7JH1cbiAgICAgICR7Zy5zZXQoXCJiYXRjaFwiLFwicm93XCIsXCJjb2wgKyBpXCIsXCJvdXRwdXRfY2hhbm5lbFwiLFwidmFsdWVcIil9O1xuICAgIH1cbiAgfWB9O3JldHVybntuYW1lOlwiR3JvdXBlZENvbnYtVmVjdG9yaXplXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5jYWNoZUtleX07JHtpfTske2F9OyR7aH07JHtwWzBdfTske3BbMV19YCxpbnB1dERlcGVuZGVuY2llczpvP1tcInJhbmtcIixcInJhbmtcIixcInR5cGVcIl06W1wicmFua1wiLFwicmFua1wiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpuP24ocik6cixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoZC82NCl9LHByb2dyYW1Vbmlmb3Jtczp1fSksZ2V0U2hhZGVyU291cmNlOl99fX0pO3ZhciBtZixibyxmZix5byxfbyxadSxoZixnZix3byxRdT1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7b2UoKTtXdSgpO3F1KCk7WHIoKTtZdSgpO3l0KCk7UXIoKTtkdCgpO21mPShlLHQscixuLG8saSk9PntsZXQgYT1lWzBdLGQ9ZS5zbGljZShpPzE6MixpPzM6NCksbD1kLmxlbmd0aCxwPXRbMF0sdT10LnNsaWNlKDIpLm1hcCgoeSxnKT0+eSsoeS0xKSoocltnXS0xKSksXz1kLm1hcCgoeSxnKT0+eStuW2ddK25bZytsXSkubWFwKCh5LGcpPT5NYXRoLmZsb29yKCh5LXVbZ10rb1tnXSkvb1tnXSkpO3JldHVybiBfLnNwbGljZSgwLDAsYSksXy5zcGxpY2UoaT8zOjEsMCxwKSxffSxibz1bMiwzLDEsMF0sZmY9KGUsdCk9PntpZighZXx8ZS5sZW5ndGghPT0yJiZlLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwiQ29udiByZXF1aXJlcyAyIG9yIDMgaW5wdXRzXCIpO2lmKGVbMF0uZGltcy5sZW5ndGg+NSl0aHJvdyBuZXcgRXJyb3IoXCJncmVhdGVyIHRoYW4gNUQgaXMgbm90IHN1cHBvcnRlZFwiKTtpZihlWzBdLmRpbXMubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJmaWx0ZXIgZG9lcyBub3QgaGF2ZSBzYW1lIGRpbWVuc2lvbiBhcyBpbnB1dFwiKTtsZXQgcj1lWzBdLmRpbXNbdC5mb3JtYXQ9PT1cIk5IV0NcIj9lWzBdLmRpbXMubGVuZ3RoLTE6MV0sbj1lWzFdLmRpbXNbMV0qdC5ncm91cDtpZihyIT09bil0aHJvdyBuZXcgRXJyb3IoXCJGSUxURVJfSU5fQ0hBTk5FTCBzaG91bGQgYmUgZXF1YWwgdG8gREFUQV9DSEFOTkVMXCIpO2lmKGUubGVuZ3RoPT09MyYmKGVbMl0uZGltcy5sZW5ndGghPT0xfHxlWzFdLmRpbXNbMF0hPT1lWzJdLmRpbXNbMF0pKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgYmlhc1wiKTtsZXQgbz1lWzBdLmRpbXMubGVuZ3RoLTI7aWYodC5kaWxhdGlvbnMubGVuZ3RoIT09byl0aHJvdyBuZXcgRXJyb3IoYGRpbGF0aW9ucyBzaG91bGQgYmUgJHtvfURgKTtpZih0LnN0cmlkZXMubGVuZ3RoIT09byl0aHJvdyBuZXcgRXJyb3IoYHN0cmlkZXMgc2hvdWxkIGJlICR7b31EYCk7aWYodC5wYWRzLmxlbmd0aCE9PW8qMil0aHJvdyBuZXcgRXJyb3IoYHBhZHMgc2hvdWxkIGJlICR7byoyfURgKTtpZih0Lmtlcm5lbFNoYXBlLmxlbmd0aCE9PTAmJnQua2VybmVsU2hhcGUubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImludmFsaWQga2VybmVsIHNoYXBlXCIpfSx5bz0oZSx0KT0+e2xldCByPWUua2VybmVsU2hhcGUuc2xpY2UoKTtyLmxlbmd0aDx0WzFdLmRpbXMubGVuZ3RoLTImJnIucHVzaCguLi5BcnJheSh0WzFdLmRpbXMubGVuZ3RoLTItci5sZW5ndGgpLmZpbGwoMCkpO2ZvcihsZXQgaT0yO2k8dFsxXS5kaW1zLmxlbmd0aDsrK2kpcltpLTJdPT09MCYmKHJbaS0yXT10WzFdLmRpbXNbaV0pO2xldCBuPWUucGFkcy5zbGljZSgpO0F0LmFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZCh0WzBdLmRpbXMsZS5zdHJpZGVzLGUuZGlsYXRpb25zLHIsbixlLmZvcm1hdD09PVwiTkhXQ1wiLGUuYXV0b1BhZCk7bGV0IG89T2JqZWN0LmFzc2lnbih7fSxlKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihvLHtrZXJuZWxTaGFwZTpyLHBhZHM6bn0pLG99LF9vPWU9PntsZXQgdD1qcihlKSxyPWUuZm9ybWF0LG49W1wiTk9UU0VUXCIsXCJWQUxJRFwiLFwiU0FNRV9VUFBFUlwiLFwiU0FNRV9MT1dFUlwiXVtlLmF1dG9fcGFkXSxvPWUuZGlsYXRpb25zLGk9ZS5ncm91cCxhPWUua2VybmVsX3NoYXBlLGQ9ZS5wYWRzLGw9ZS5zdHJpZGVzLHA9ZS53X2lzX2NvbnN0KCk7cmV0dXJue2F1dG9QYWQ6bixmb3JtYXQ6cixkaWxhdGlvbnM6byxncm91cDppLGtlcm5lbFNoYXBlOmEscGFkczpkLHN0cmlkZXM6bCx3SXNDb25zdDpwLC4uLnQsY2FjaGVLZXk6YCR7ZS5mb3JtYXR9OyR7dC5hY3RpdmF0aW9ufTtgfX0sWnU9KGUsdCxyLG4pPT57bGV0IG89ci5mb3JtYXQ9PT1cIk5IV0NcIixpPW1mKHRbMF0uZGltcyx0WzFdLmRpbXMsci5kaWxhdGlvbnMsci5wYWRzLHIuc3RyaWRlcyxvKTtpZihyLmdyb3VwIT09MSl7bGV0IGs9W3RbMF1dO2lmKG8pe2xldCBEPWUua2VybmVsQ3VzdG9tRGF0YS53VD8/ZS5jb21wdXRlKFBlKHRbMV0sYm8pLHtpbnB1dHM6WzFdLG91dHB1dHM6W3Iud0lzQ29uc3Q/LTI6LTFdfSlbMF07ci53SXNDb25zdCYmIWUua2VybmVsQ3VzdG9tRGF0YS53VCYmKGUua2VybmVsQ3VzdG9tRGF0YS53VD1EKSxrLnB1c2goRCl9ZWxzZSBrLnB1c2godFsxXSk7dC5sZW5ndGg9PT0zJiZrLnB1c2godFsyXSksIWUuYWRhcHRlckluZm8uaXNBcmNoaXRlY3R1cmUoXCJhbXBlcmVcIikmJm8mJnRbMV0uZGltc1swXT09PXIuZ3JvdXAmJnRbMV0uZGltc1sxXT09PTEmJnIuZGlsYXRpb25zWzBdPT09MSYmci5kaWxhdGlvbnNbMV09PT0xP2UuY29tcHV0ZShqdShrLHIsaSxuKSx7aW5wdXRzOmt9KTplLmNvbXB1dGUoS3UoayxyLGksbikse2lucHV0czprfSk7cmV0dXJufWxldCBhPXQubGVuZ3RoPT09MyxkPXRbMF0uZGltc1tvPzE6Ml0sbD10WzBdLmRpbXNbbz8yOjNdLHA9dFswXS5kaW1zW28/MzoxXSxtPXRbMV0uZGltc1syXSx1PXRbMV0uZGltc1szXSxoPWlbbz8xOjJdLF89aVtvPzI6M10seT1pW28/MzoxXSxnPW8mJm09PT1kJiZ1PT09bCYmci5wYWRzWzBdPT09MCYmci5wYWRzWzFdPT09MDtpZihnfHxtPT09MSYmdT09PTEmJnIuZGlsYXRpb25zWzBdPT09MSYmci5kaWxhdGlvbnNbMV09PT0xJiZyLnN0cmlkZXNbMF09PT0xJiZyLnN0cmlkZXNbMV09PT0xJiZyLnBhZHNbMF09PT0wJiZyLnBhZHNbMV09PT0wKXtsZXQgaz1pWzBdLFAsRCxSLEc9W107aWYobyl7bGV0IFY9ZS5rZXJuZWxDdXN0b21EYXRhLndUPz9lLmNvbXB1dGUoUGUodFsxXSxibykse2lucHV0czpbMV0sb3V0cHV0czpbci53SXNDb25zdD8tMjotMV19KVswXTtpZihyLndJc0NvbnN0JiYhZS5rZXJuZWxDdXN0b21EYXRhLndUJiYoZS5rZXJuZWxDdXN0b21EYXRhLndUPVYpLGcpe2xldCBRPWQqbCpwO1A9dFswXS5yZXNoYXBlKFsxLGssUV0pLEQ9Vi5yZXNoYXBlKFsxLFEseV0pLFI9WzEsayx5XX1lbHNlIFA9dFswXS5yZXNoYXBlKFtrLGQqbCxwXSksRD1WLnJlc2hhcGUoWzEscCx5XSksUj1bayxoKl8seV07Ry5wdXNoKFApLEcucHVzaChEKX1lbHNlIFA9dFswXS5yZXNoYXBlKFtrLHAsZCpsXSksRD10WzFdLnJlc2hhcGUoWzEseSxwXSksUj1bayx5LGgqX10sRy5wdXNoKEQpLEcucHVzaChQKTthJiZHLnB1c2godFsyXSk7bGV0IEs9UlsyXSxqPUdbMF0uZGltc1tHWzBdLmRpbXMubGVuZ3RoLTFdO0s8OCYmajw4P2UuY29tcHV0ZShacihHLHIsaSxSLG8sbikse2lucHV0czpHfSk6ZS5jb21wdXRlKGVyKEcscixpLFIsbyxuKSx7aW5wdXRzOkd9KTtyZXR1cm59bGV0IHg9ITAsJD1lLmtlcm5lbEN1c3RvbURhdGEud1Q/P2UuY29tcHV0ZShQZSh0WzFdLGJvKSx7aW5wdXRzOlsxXSxvdXRwdXRzOltyLndJc0NvbnN0Py0yOi0xXX0pWzBdO3Iud0lzQ29uc3QmJiFlLmtlcm5lbEN1c3RvbURhdGEud1QmJihlLmtlcm5lbEN1c3RvbURhdGEud1Q9JCk7bGV0IHY9W3RbMF0sJF07YSYmdi5wdXNoKHRbMl0pO2xldCBTPW8/aCpfOnksVD1vP3k6aCpfLEE9bSp1KnA7ZS5jb21wdXRlKFZ1KHYscixpLFMsVCxBLGEseCxuKSx7aW5wdXRzOnZ9KX0saGY9KGUsdCk9PntsZXQgcj10LmZvcm1hdD09PVwiTkhXQ1wiLG49W2UuaW5wdXRzWzBdLnJlc2hhcGUocj9bZS5pbnB1dHNbMF0uZGltc1swXSwxLGUuaW5wdXRzWzBdLmRpbXNbMV0sZS5pbnB1dHNbMF0uZGltc1syXV06W2UuaW5wdXRzWzBdLmRpbXNbMF0sZS5pbnB1dHNbMF0uZGltc1sxXSwxLGUuaW5wdXRzWzBdLmRpbXNbMl1dKSxlLmlucHV0c1sxXS5yZXNoYXBlKFtlLmlucHV0c1sxXS5kaW1zWzBdLGUuaW5wdXRzWzFdLmRpbXNbMV0sMSxlLmlucHV0c1sxXS5kaW1zWzJdXSldO2UuaW5wdXRzLmxlbmd0aD09PTMmJm4ucHVzaChlLmlucHV0c1syXSk7bGV0IG89WzAsdC5wYWRzWzBdLDAsdC5wYWRzWzFdXSxpPVsxXS5jb25jYXQodC5zdHJpZGVzKSxhPVsxXS5jb25jYXQodC5kaWxhdGlvbnMpLGQ9WzFdLmNvbmNhdCh0Lmtlcm5lbFNoYXBlKSxsPXlvKHsuLi50LHBhZHM6byxzdHJpZGVzOmksZGlsYXRpb25zOmEsa2VybmVsU2hhcGU6ZH0sbik7WnUoZSxuLGwscD0+cj9bcFswXSxwWzJdLHBbM11dOltwWzBdLHBbMV0scFszXV0pfSxnZj0oZSx0LHIpPT57bGV0IG49ci5mb3JtYXQ9PT1cIk5IV0NcIj9cImNoYW5uZWxzTGFzdFwiOlwiY2hhbm5lbHNGaXJzdFwiLG89eW8ocix0KSxpPXIuYXV0b1BhZD09PVwiTk9UU0VUXCI/ci5wYWRzOnIuYXV0b1BhZCxhPUh1KHRbMF0uZGltcyx0WzFdLmRpbXMsci5zdHJpZGVzLHIuZGlsYXRpb25zLGksITEsbik7ZS5jb21wdXRlKEZ1KHQsbyxhLm91dFNoYXBlLFthLmZpbHRlckRlcHRoLGEuZmlsdGVySGVpZ2h0LGEuZmlsdGVyV2lkdGhdLFthLnBhZEluZm8uZnJvbnQsYS5wYWRJbmZvLnRvcCxhLnBhZEluZm8ubGVmdF0sbikpfSx3bz0oZSx0KT0+e2lmKGZmKGUuaW5wdXRzLHQpLGUuaW5wdXRzWzBdLmRpbXMubGVuZ3RoPT09MyloZihlLHQpO2Vsc2UgaWYoZS5pbnB1dHNbMF0uZGltcy5sZW5ndGg9PT01KWdmKGUsZS5pbnB1dHMsdCk7ZWxzZXtsZXQgcj15byh0LGUuaW5wdXRzKTtadShlLGUuaW5wdXRzLHIpfX19KTt2YXIgWHUsSnU9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7ZXQoKTtvZSgpO2FlKCk7WHU9KGUsdCxyKT0+e2xldCBuPWUubGVuZ3RoPjIsbz10Lm91dHB1dFNoYXBlLGk9dC5mb3JtYXQ9PT1cIk5IV0NcIixhPXQuZ3JvdXAsZD1lWzFdLmRpbXMsbD1kWzJdL2EscD1kWzNdLG09aT9tZShsKToxLHU9aT9tZShwKToxLGg9aT9wPT09MT9tOnU6MSxfPUMuc2l6ZShvKS91LHk9W01hdGguY2VpbChfLzY0KSwxLDFdO3VlKFwidmVyYm9zZVwiLCgpPT5gW2NvbnYyZF9iYWNrcHJvcF93ZWJncHVdIGRpc3BhdGNoID0gJHt5fWApO2xldCBnPVtcInJhbmtcIixcInJhbmtcIl0seD1bdC5zdHJpZGVzWzBdLHQuc3RyaWRlc1sxXV0sJD1bdC5rZXJuZWxTaGFwZVtpPzE6Ml0sdC5rZXJuZWxTaGFwZVtpPzI6M11dLHY9W3QuZGlsYXRpb25zWzBdLHQuZGlsYXRpb25zWzFdXSxTPVskWzBdKyh0LmRpbGF0aW9uc1swXTw9MT8wOih0Lmtlcm5lbFNoYXBlW2k/MToyXS0xKSoodC5kaWxhdGlvbnNbMF0tMSkpLCRbMV0rKHQuZGlsYXRpb25zWzFdPD0xPzA6KHQua2VybmVsU2hhcGVbaT8yOjNdLTEpKih0LmRpbGF0aW9uc1sxXS0xKSldLFQ9W1NbMF0tMS1NYXRoLmZsb29yKCh0LnBhZHNbMF0rdC5wYWRzWzJdKS8yKSxTWzFdLTEtTWF0aC5mbG9vcigodC5wYWRzWzFdK3QucGFkc1szXSkvMildLEE9W3t0eXBlOjEyLGRhdGE6X30se3R5cGU6MTIsZGF0YTp4fSx7dHlwZToxMixkYXRhOiR9LHt0eXBlOjEyLGRhdGE6dn0se3R5cGU6MTIsZGF0YTpTfSx7dHlwZTo2LGRhdGE6VH0se3R5cGU6MTIsZGF0YTpsfSx7dHlwZToxMixkYXRhOnB9LC4uLk4oZVswXS5kaW1zLGVbMV0uZGltcyldO24mJihBLnB1c2goLi4uTihlWzJdLmRpbXMpKSxnLnB1c2goXCJyYW5rXCIpKSxBLnB1c2goLi4uTihvKSk7bGV0IGs9UD0+e2xldCBEPVt7bmFtZTpcIm91dHB1dF9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInN0cmlkZXNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOngubGVuZ3RofSx7bmFtZTpcImZpbHRlcl9kaW1zXCIsdHlwZTpcInUzMlwiLGxlbmd0aDokLmxlbmd0aH0se25hbWU6XCJkaWxhdGlvbnNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOiQubGVuZ3RofSx7bmFtZTpcImVmZmVjdGl2ZV9maWx0ZXJfZGltc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6Uy5sZW5ndGh9LHtuYW1lOlwicGFkc1wiLHR5cGU6XCJpMzJcIixsZW5ndGg6VC5sZW5ndGh9LHtuYW1lOlwiaW5wdXRfY2hhbm5lbHNfcGVyX2dyb3VwXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIm91dHB1dF9jaGFubmVsc19wZXJfZ3JvdXBcIix0eXBlOlwidTMyXCJ9XSxSPV9lKGVbMF0uZGF0YVR5cGUpLEc9aT8xOjIsSz1pPzI6MyxqPWk/MzoxLFY9RShcIldcIixlWzFdLmRhdGFUeXBlLGVbMV0uZGltcy5sZW5ndGgsaCksUT1FKFwiRHlcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcy5sZW5ndGgsbSksc2U9W1EsVl07biYmc2UucHVzaChFKFwiYmlhc1wiLGVbMl0uZGF0YVR5cGUsW29bal1dLmxlbmd0aCx1KSk7bGV0IFk9TShcInJlc3VsdFwiLGVbMF0uZGF0YVR5cGUsby5sZW5ndGgsdSksZWU9KCk9PntsZXQgbmU9XCJcIjtpZihtPT09MSluZSs9YFxuICAgICAgICBsZXQgd19vZmZzZXQgPSAke1YuaW5kaWNlc1RvT2Zmc2V0KGAke1YudHlwZS5pbmRpY2VzfSh1MzIod1JQZXJtKSwgdTMyKHdDUGVybSksIGlucHV0Q2hhbm5lbCwgd091dENoYW5uZWwpYCl9O1xuICAgICAgICBsZXQgd1ZhbHVlID0gJHtWLmdldEJ5T2Zmc2V0KGB3X29mZnNldCAvICR7aH1gKX07XG4gICAgICAgIGRvdFByb2QgPSBkb3RQcm9kICsgeFZhbHVlICogd1ZhbHVlO2A7ZWxzZSBpZihwPT09MSluZSs9YFxuICAgICAgICAgIGxldCB3VmFsdWUgPSAke1YuZ2V0QnlPZmZzZXQoYCR7Vi5pbmRpY2VzVG9PZmZzZXQoYCR7Vi50eXBlLmluZGljZXN9KHUzMih3UlBlcm0pLCB1MzIod0NQZXJtKSwgaW5wdXRDaGFubmVsLCB3T3V0Q2hhbm5lbClgKX0gLyAke2h9YCl9O1xuICAgICAgICAgIGRvdFByb2QgPSBkb3RQcm9kICsgZG90KHhWYWx1ZSwgd1ZhbHVlKTtgO2Vsc2UgZm9yKGxldCBiZT0wO2JlPG07YmUrKyluZSs9YFxuICAgICAgICAgICAgbGV0IHdWYWx1ZSR7YmV9ID0gJHtWLmdldEJ5T2Zmc2V0KGAke1YuaW5kaWNlc1RvT2Zmc2V0KGAke1YudHlwZS5pbmRpY2VzfSh1MzIod1JQZXJtKSwgdTMyKHdDUGVybSksIGlucHV0Q2hhbm5lbCArICR7YmV9LCB3T3V0Q2hhbm5lbClgKX0gLyAke2h9YCl9O1xuICAgICAgICAgICAgZG90UHJvZCA9IGRvdFByb2QgKyB4VmFsdWVbJHtiZX1dICogd1ZhbHVlJHtiZX07YDtyZXR1cm4gbmV9LEo9YFxuICAgICAgICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke1kub2Zmc2V0VG9JbmRpY2VzKGBnbG9iYWxfaWR4ICogJHt1fWApfTtcbiAgICAgICAgICAgIGxldCBiYXRjaCA9ICR7WS5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLDApfTtcbiAgICAgICAgICAgIGxldCBkMSA9ICR7WS5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLGopfTtcbiAgICAgICAgICAgIGxldCByID0gJHtZLmluZGljZXNHZXQoXCJvdXRwdXRJbmRpY2VzXCIsRyl9O1xuICAgICAgICAgICAgbGV0IGMgPSAke1kuaW5kaWNlc0dldChcIm91dHB1dEluZGljZXNcIixLKX07XG4gICAgICAgICAgICBsZXQgZHlDb3JuZXIgPSB2ZWMyPGkzMj4oaTMyKHIpLCBpMzIoYykpIC0gdW5pZm9ybXMucGFkcztcbiAgICAgICAgICAgIGxldCBkeVJDb3JuZXIgPSBkeUNvcm5lci54O1xuICAgICAgICAgICAgbGV0IGR5Q0Nvcm5lciA9IGR5Q29ybmVyLnk7XG4gICAgICAgICAgICBsZXQgZ3JvdXBJZCA9IGQxIC8gdW5pZm9ybXMub3V0cHV0X2NoYW5uZWxzX3Blcl9ncm91cDtcbiAgICAgICAgICAgIGxldCB3T3V0Q2hhbm5lbCA9IGQxIC0gZ3JvdXBJZCAqIHVuaWZvcm1zLm91dHB1dF9jaGFubmVsc19wZXJfZ3JvdXA7XG4gICAgICAgICAgICAvLyBDb252b2x2ZSBkeSg/LCA/LCBkMikgd2l0aCB3KDosIDosIGQxLCBkMikgdG8gY29tcHV0ZSBkeCh4UiwgeEMsIGQxKS5cbiAgICAgICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxuICAgICAgICAgICAgdmFyIGRvdFByb2QgPSAke1kudHlwZS52YWx1ZX0oMC4wKTtcbiAgICAgICAgICAgIGZvciAodmFyIHdSOiB1MzIgPSAwOyB3UiA8IHVuaWZvcm1zLmVmZmVjdGl2ZV9maWx0ZXJfZGltcy54OyB3UiA9IHdSICsgMSkge1xuICAgICAgICAgICAgICBpZiAod1IgJSB1bmlmb3Jtcy5kaWxhdGlvbnMueCAhPSAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGV0IGR5UiA9ICgke1J9KGR5UkNvcm5lcikgKyAke1J9KHdSKSkgLyAke1J9KHVuaWZvcm1zLnN0cmlkZXNbMF0pO1xuICAgICAgICAgICAgICBsZXQgd1JQZXJtID0gdW5pZm9ybXMuZmlsdGVyX2RpbXMueCAtIDEgLSB3UiAvIHVuaWZvcm1zLmRpbGF0aW9ucy54O1xuICAgICAgICAgICAgICBpZiAoZHlSIDwgMC4wIHx8IGR5UiA+PSAke1J9KHVuaWZvcm1zLkR5X3NoYXBlWyR7R31dKSB8fCBmcmFjdChkeVIpID4gMC4wIHx8XG4gICAgICAgICAgICAgICAgICB3UlBlcm0gPCAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd1IgPSB3UiArIHVuaWZvcm1zLnN0cmlkZXNbMF0gLSAxO1xuICAgICAgICAgICAgICBsZXQgaWR5UjogdTMyID0gdTMyKGR5Uik7XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgd0M6IHUzMiA9IDA7IHdDIDwgdW5pZm9ybXMuZWZmZWN0aXZlX2ZpbHRlcl9kaW1zLnk7IHdDID0gd0MgKyAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdDICUgdW5pZm9ybXMuZGlsYXRpb25zLnkgIT0gMCkge1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBkeUMgPSAoJHtSfShkeUNDb3JuZXIpICsgJHtSfSh3QykpIC8gJHtSfSh1bmlmb3Jtcy5zdHJpZGVzLnkpO1xuICAgICAgICAgICAgICAgIGxldCB3Q1Blcm0gPSB1bmlmb3Jtcy5maWx0ZXJfZGltcy55IC0gMSAtIHdDIC8gdW5pZm9ybXMuZGlsYXRpb25zLnk7XG4gICAgICAgICAgICAgICAgaWYgKGR5QyA8IDAuMCB8fCBkeUMgPj0gJHtSfSh1bmlmb3Jtcy5EeV9zaGFwZVske0t9XSkgfHxcbiAgICAgICAgICAgICAgICAgICAgZnJhY3QoZHlDKSA+IDAuMCB8fCB3Q1Blcm0gPCAwKSB7XG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd0MgPSB3QyArIHVuaWZvcm1zLnN0cmlkZXMueSAtIDE7XG4gICAgICAgICAgICAgICAgbGV0IGlkeUM6IHUzMiA9IHUzMihkeUMpO1xuICAgICAgICAgICAgICAgIHZhciBpbnB1dENoYW5uZWwgPSBncm91cElkICogdW5pZm9ybXMuaW5wdXRfY2hhbm5lbHNfcGVyX2dyb3VwO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGQyOiB1MzIgPSAwOyBkMiA8IHVuaWZvcm1zLmlucHV0X2NoYW5uZWxzX3Blcl9ncm91cDsgZDIgPSBkMiArICR7bX0pIHtcbiAgICAgICAgICAgICAgICAgIGxldCB4VmFsdWUgPSAke2k/US5nZXRCeU9mZnNldChgJHtRLmluZGljZXNUb09mZnNldChgJHtRLnR5cGUuaW5kaWNlc30oYmF0Y2gsIGlkeVIsIGlkeUMsIGlucHV0Q2hhbm5lbClgKX0gLyAke219YCk6US5nZXQoXCJiYXRjaFwiLFwiaW5wdXRDaGFubmVsXCIsXCJpZHlSXCIsXCJpZHlDXCIpfTtcbiAgICAgICAgICAgICAgICAgICR7ZWUoKX1cbiAgICAgICAgICAgICAgICAgIGlucHV0Q2hhbm5lbCA9IGlucHV0Q2hhbm5lbCArICR7bX07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBkb3RQcm9kJHtuP2AgKyBiaWFzW2QxIC8gJHt1fV1gOlwiXCJ9O1xuICAgICAgICAgICAgJHtZLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIil9O1xuICAgICAgICAgIGA7cmV0dXJuYFxuICAgICR7UC5yZWdpc3RlclVuaWZvcm1zKEQpLmRlY2xhcmVWYXJpYWJsZXMoLi4uc2UsWSl9XG4gICAgICAke1AubWFpblN0YXJ0KCl9XG4gICAgICAke1AuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfTtcbiAgICAke0p9fWB9O3JldHVybntuYW1lOlwiQ29udlRyYW5zcG9zZTJEXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5jYWNoZUtleX07JHttfSR7aH0ke3V9JHtwPT09MX1gLGlucHV0RGVwZW5kZW5jaWVzOmd9LGdldFJ1bkRhdGE6KCk9Pih7ZGlzcGF0Y2hHcm91cDp7eDp5WzBdLHk6eVsxXSx6OnlbMl19LG91dHB1dHM6W3tkaW1zOnI/cihvKTpvLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxwcm9ncmFtVW5pZm9ybXM6QX0pLGdldFNoYWRlclNvdXJjZTprfX19KTt2YXIgYmYseWYsX2YsZWQsdGQsd2YscmQsdmYsbmQsb2Q9VSgoKT0+e1widXNlIHN0cmljdFwiO0p1KCk7eXQoKTtkdCgpO2JmPShlLHQscixuLG8saSk9PihlLTEpKnQrcisobi0xKSpvKzEtaSx5Zj0oZSx0LHIsbixvKT0+e2xldCBpPU1hdGguZmxvb3IoZS8yKTt0PT09XCJTQU1FX1VQUEVSXCI/KHJbbl09aSxyW29dPWUtaSk6dD09PVwiU0FNRV9MT1dFUlwiJiYocltuXT1lLWkscltvXT1pKX0sX2Y9KGUsdCxyLG4sbyxpLGEsZCxsLHApPT57bGV0IG09ZS5sZW5ndGgtMix1PXAubGVuZ3RoPT09MDtsLmxlbmd0aDxtJiZsLnB1c2goLi4uQXJyYXkobS1sLmxlbmd0aCkuZmlsbCgwKSk7bGV0IGg9ZVswXSxfPXRbZD8zOjFdKm87Zm9yKGxldCB5PTAsZz1lLmxlbmd0aC1tLShkPzE6MCk7eTxtOysreSwrK2cpe2xldCB4PWVbZ10sJD11P3gqYVt5XTpwW3ldLHY9YmYoeCxhW3ldLGlbeV0sdFtnXSxyW3ldLCQpO3lmKHYsbixpLHkseSttKSx1JiZwLnB1c2goYVt5XSooeC0xKStsW3ldKyh0W2ddLTEpKnJbeV0rMS1pW3ldLWlbeSttXSl9cC5zcGxpY2UoMCwwLGgpLHAuc3BsaWNlKGQ/MzoxLDAsXyl9LGVkPShlLHQpPT57bGV0IHI9ZS5rZXJuZWxTaGFwZS5zbGljZSgpO2lmKGUua2VybmVsU2hhcGUubGVuZ3RoPT09MHx8ZS5rZXJuZWxTaGFwZS5yZWR1Y2UoKHUsaCk9PnUqaCwxKT09PTApe3IubGVuZ3RoPTA7Zm9yKGxldCB1PTI7dTx0WzFdLmRpbXMubGVuZ3RoOysrdSlyLnB1c2godFsxXS5kaW1zW3VdKX1sZXQgbj1lLmZvcm1hdD09PVwiTkhXQ1wiO3Iuc3BsaWNlKDAsMCx0WzFdLmRpbXNbMF0pLHIuc3BsaWNlKG4/MzoxLDAsdFsxXS5kaW1zWzFdKTtsZXQgbz1lLnBhZHMuc2xpY2UoKSxpPWUub3V0cHV0U2hhcGUuc2xpY2UoKSxhPWUub3V0cHV0UGFkZGluZy5zbGljZSgpLGQ9dFswXS5kaW1zLGw9ZS5kaWxhdGlvbnMuc2xpY2UoKTtpZihsLnJlZHVjZSgodSxoKT0+dStoLDApPT09MCl7bGV0IHU9dFswXS5kaW1zLmxlbmd0aC0yO2w9bmV3IEFycmF5KHUpLmZpbGwoMSl9bGV0IHA9ZS5zdHJpZGVzLnNsaWNlKCk7aWYocC5yZWR1Y2UoKHUsaCk9PnUraCwwKT09PTApe2xldCB1PXRbMF0uZGltcy5sZW5ndGgtMjtwPW5ldyBBcnJheSh1KS5maWxsKDEpfV9mKGQscixsLGUuYXV0b1BhZCxlLmdyb3VwLG8scCxuLGEsaSk7bGV0IG09T2JqZWN0LmFzc2lnbih7fSxlKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihtLHtrZXJuZWxTaGFwZTpyLHBhZHM6byxvdXRwdXRQYWRkaW5nOmEsb3V0cHV0U2hhcGU6aSxkaWxhdGlvbnM6bCxzdHJpZGVzOnB9KSxtfSx0ZD1lPT57bGV0IHQ9anIoZSkscj1lLmZvcm1hdCxuPVtcIk5PVFNFVFwiLFwiVkFMSURcIixcIlNBTUVfVVBQRVJcIixcIlNBTUVfTE9XRVJcIl1bdHlwZW9mIGUuYXV0b1BhZD5cInVcIj8wOmUuYXV0b1BhZF0sbz1lLmRpbGF0aW9ucyxpPWUuZ3JvdXAsYT1lLmtlcm5lbFNoYXBlLGQ9ZS5wYWRzLGw9ZS5zdHJpZGVzLHA9ZS53SXNDb25zdCgpLG09ZS5vdXRwdXRQYWRkaW5nLHU9ZS5vdXRwdXRTaGFwZTtyZXR1cm57YXV0b1BhZDpuLGZvcm1hdDpyLGRpbGF0aW9uczpvLGdyb3VwOmksa2VybmVsU2hhcGU6YSxvdXRwdXRQYWRkaW5nOm0sb3V0cHV0U2hhcGU6dSxwYWRzOmQsc3RyaWRlczpsLHdJc0NvbnN0OnAsLi4udCxjYWNoZUtleTpgJHtlLmZvcm1hdH07JHt0LmFjdGl2YXRpb259O2B9fSx3Zj0oZSx0KT0+e2lmKCFlfHxlLmxlbmd0aCE9PTImJmUubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoXCJDb252IHJlcXVpcmVzIDIgb3IgMyBpbnB1dHNcIik7aWYoZVswXS5kaW1zLmxlbmd0aCE9PTQmJmVbMF0uZGltcy5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcihcImN1cnJlbnRseSBvbmx5IHN1cHBvcnQgMi1kaW1lbnNpb25hbCBjb252XCIpO2lmKGVbMF0uZGltcy5sZW5ndGghPT1lWzFdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImZpbHRlciBkb2VzIG5vdCBoYXZlIHNhbWUgZGltZW5zaW9uIGFzIGlucHV0XCIpO2xldCByPWVbMF0uZGltc1t0LmZvcm1hdD09PVwiTkhXQ1wiP2VbMF0uZGltcy5sZW5ndGgtMToxXSxuPWVbMV0uZGltc1swXTtpZihyIT09bil0aHJvdyBuZXcgRXJyb3IoXCJGSUxURVJfSU5fQ0hBTk5FTCBzaG91bGQgYmUgZXF1YWwgdG8gREFUQV9DSEFOTkVMXCIpO2xldCBvPWVbMV0uZGltc1sxXSp0Lmdyb3VwO2lmKGUubGVuZ3RoPT09MyYmKGVbMl0uZGltcy5sZW5ndGghPT0xfHxlWzJdLmRpbXNbMF0hPT1vKSl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJpYXNcIik7bGV0IGk9ZVswXS5kaW1zLmxlbmd0aC0yO2lmKHQuZGlsYXRpb25zLnJlZHVjZSgobSx1KT0+bSt1LDApPjAmJnQuZGlsYXRpb25zLmxlbmd0aCE9PWkpdGhyb3cgbmV3IEVycm9yKGBkaWxhdGlvbnMgc2hvdWxkIGJlICR7aX1EYCk7aWYodC5zdHJpZGVzLnJlZHVjZSgobSx1KT0+bSt1LDApPjAmJnQuc3RyaWRlcy5sZW5ndGghPT1pKXRocm93IG5ldyBFcnJvcihgc3RyaWRlcyBzaG91bGQgYmUgJHtpfURgKTtpZih0LnBhZHMucmVkdWNlKChtLHUpPT5tK3UsMCk+MCYmdC5wYWRzLmxlbmd0aCE9PWkqMil0aHJvdyBuZXcgRXJyb3IoYHBhZHMgc2hvdWxkIGJlICR7aSoyfURgKTtpZih0Lm91dHB1dFBhZGRpbmcubGVuZ3RoIT09aSYmdC5vdXRwdXRQYWRkaW5nLmxlbmd0aCE9PTApdGhyb3cgbmV3IEVycm9yKGBvdXRwdXRfcGFkZGluZyBzaG91bGQgYmUgJHtpfURgKTtpZih0Lmtlcm5lbFNoYXBlLnJlZHVjZSgobSx1KT0+bSt1LDApPjAmJnQua2VybmVsU2hhcGUubGVuZ3RoIT09MCYmdC5rZXJuZWxTaGFwZS5sZW5ndGghPT1lWzFdLmRpbXMubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBrZXJuZWwgc2hhcGVcIik7aWYodC5vdXRwdXRTaGFwZS5sZW5ndGghPT0wJiZ0Lm91dHB1dFNoYXBlLmxlbmd0aCE9PWVbMF0uZGltcy5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIG91dHB1dCBzaGFwZVwiKX0scmQ9KGUsdCxyLG4pPT57bGV0IG89ZS5rZXJuZWxDdXN0b21EYXRhLndUPz9lLmNvbXB1dGUoUGUodFsxXSxbMiwzLDAsMV0pLHtpbnB1dHM6WzFdLG91dHB1dHM6W3Iud0lzQ29uc3Q/LTI6LTFdfSlbMF07ci53SXNDb25zdCYmIWUua2VybmVsQ3VzdG9tRGF0YS53VCYmKGUua2VybmVsQ3VzdG9tRGF0YS53VD1vKTtsZXQgaT1bdFswXSxvXTt0Lmxlbmd0aD09PTMmJmkucHVzaCh0WzJdKSxlLmNvbXB1dGUoWHUoaSxyLG4pLHtpbnB1dHM6aX0pfSx2Zj0oZSx0KT0+e2xldCByPXQuZm9ybWF0PT09XCJOSFdDXCIsbj1bZS5pbnB1dHNbMF0ucmVzaGFwZShyP1tlLmlucHV0c1swXS5kaW1zWzBdLDEsZS5pbnB1dHNbMF0uZGltc1sxXSxlLmlucHV0c1swXS5kaW1zWzJdXTpbZS5pbnB1dHNbMF0uZGltc1swXSxlLmlucHV0c1swXS5kaW1zWzFdLDEsZS5pbnB1dHNbMF0uZGltc1syXV0pLGUuaW5wdXRzWzFdLnJlc2hhcGUoW2UuaW5wdXRzWzFdLmRpbXNbMF0sZS5pbnB1dHNbMV0uZGltc1sxXSwxLGUuaW5wdXRzWzFdLmRpbXNbMl1dKV07ZS5pbnB1dHMubGVuZ3RoPT09MyYmbi5wdXNoKGUuaW5wdXRzWzJdKTtsZXQgbz10Lmtlcm5lbFNoYXBlOyhvLmxlbmd0aD09PTB8fG9bMF09PT0wKSYmKG89W2UuaW5wdXRzWzFdLmRpbXNbMl1dKTtsZXQgaT10LmRpbGF0aW9uczsoaS5sZW5ndGg9PT0wfHxpWzBdPT09MCkmJihpPVsxXSk7bGV0IGE9dC5zdHJpZGVzOyhhLmxlbmd0aD09PTB8fGFbMF09PT0wKSYmKGE9WzFdKTtsZXQgZD10LnBhZHM7ZC5sZW5ndGg9PT0wJiYoZD1bMCwwXSksZD1bMCxkWzBdLDAsZFsxXV0sYT1bMV0uY29uY2F0KGEpLGk9WzFdLmNvbmNhdChpKSxvPVsxXS5jb25jYXQobyk7bGV0IGw9ZWQoey4uLnQscGFkczpkLHN0cmlkZXM6YSxkaWxhdGlvbnM6aSxrZXJuZWxTaGFwZTpvfSxuKTtyZChlLG4sbCxwPT5yP1twWzBdLHBbMl0scFszXV06W3BbMF0scFsxXSxwWzNdXSl9LG5kPShlLHQpPT57aWYod2YoZS5pbnB1dHMsdCksZS5pbnB1dHNbMF0uZGltcy5sZW5ndGg9PT0zKXZmKGUsdCk7ZWxzZXtsZXQgcj1lZCh0LGUuaW5wdXRzKTtyZChlLGUuaW5wdXRzLHIpfX19KTt2YXIgJGYsaWQsYWQsc2Q9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTtTZSgpO2FlKCk7JGY9KGUsdCxyLG4pPT57bGV0IG89Qy5zaXplKHQpLGk9dC5sZW5ndGgsYT1FKFwiaW5wdXRcIixlLGkpLGQ9TShcIm91dHB1dFwiLGUsaSksbD1yLmRhdGFUeXBlPT09Nj9yLmdldEludDMyQXJyYXkoKVswXTpOdW1iZXIoci5nZXRCaWdJbnQ2NEFycmF5KClbMF0pLHA9Qy5ub3JtYWxpemVBeGlzKGwsaSksbT11PT57bGV0IGg9YCBpMzIoJHthLmluZGljZXNHZXQoXCJpbnB1dEluZGljZXNcIixcInVuaWZvcm1zLmF4aXNcIil9KSBgLF89RihcInVuaWZvcm1zLmlucHV0X3NoYXBlXCIsXCJ1bmlmb3Jtcy5heGlzXCIsaSkseT1uLnJldmVyc2U/aCsobi5leGNsdXNpdmU/XCIgKyAxXCI6XCJcIik6XCIwXCIsZz1uLnJldmVyc2U/XzpoKyhuLmV4Y2x1c2l2ZT9cIlwiOlwiICsgMVwiKTtyZXR1cm5gXG4gICAgICAgICAgICAgICAgJHt1LnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dFNpemVcIixcInUzMlwiKS5yZWdpc3RlclVuaWZvcm0oXCJheGlzXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyhhLGQpfVxuICAgICAgICAgICAgICAgICR7dS5tYWluU3RhcnQoKX1cbiAgICAgICAgICAgICAgICAgICR7dS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0U2l6ZVwiKX1cbiAgICAgICAgICAgICAgICAgIHZhciBpbnB1dEluZGljZXMgPSAke2Qub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAgICAgICAgICAgICB2YXIgc3VtID0gJHtkLnR5cGUudmFsdWV9KDApO1xuICAgICAgICAgICAgICAgICAgbGV0IGZpcnN0IDogaTMyID0gJHt5fTtcbiAgICAgICAgICAgICAgICAgIGxldCBsYXN0IDogaTMyID0gJHtnfTtcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgOiBpMzIgPSBmaXJzdDsgaSA8IGxhc3Q7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAke2EuaW5kaWNlc1NldChcImlucHV0SW5kaWNlc1wiLFwidW5pZm9ybXMuYXhpc1wiLFwidTMyKGkpXCIpfTtcbiAgICAgICAgICAgICAgICAgICAgc3VtID0gc3VtICsgJHthLmdldEJ5SW5kaWNlcyhcImlucHV0SW5kaWNlc1wiKX07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAke2Quc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJzdW1cIil9O1xuICAgICAgICAgICAgICAgIH1gfTtyZXR1cm57bmFtZTpcIkN1bVN1bVwiLHNoYWRlckNhY2hlOntoaW50Om4uY2FjaGVLZXksaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczp0LGRhdGFUeXBlOmV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChvLzY0KX0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZToxMixkYXRhOm99LHt0eXBlOjEyLGRhdGE6cH0sLi4uTih0LHQpXX0pLGdldFNoYWRlclNvdXJjZTptfX0saWQ9KGUsdCk9PntsZXQgcj1lLmlucHV0c1swXS5kaW1zLG49ZS5pbnB1dHNbMF0uZGF0YVR5cGUsbz1lLmlucHV0c1sxXTtlLmNvbXB1dGUoJGYobixyLG8sdCkse2lucHV0czpbMF19KX0sYWQ9ZT0+e2xldCB0PWUuZXhjbHVzaXZlPT09MSxyPWUucmV2ZXJzZT09PTE7cmV0dXJuIHJlKHtleGNsdXNpdmU6dCxyZXZlcnNlOnJ9KX19KTt2YXIgeGYsU2YsVGYsdWQsZGQsbGQ9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTtTZSgpO2FlKCk7eGY9ZT0+e2lmKCFlfHxlLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiRGVwdGhUb1NwYWNlIHJlcXVpcmVzIDEgaW5wdXQuXCIpO2lmKGVbMF0uZGltcy5sZW5ndGghPT00KXRocm93IG5ldyBFcnJvcihcIkRlcHRoVG9TcGFjZSByZXF1aXJlcyA0RCBpbnB1dC5cIil9LFNmPShlLHQscixuKT0+e2xldCBvPVtdO28ucHVzaChgZm4gcGVybShpOiAke24udHlwZS5pbmRpY2VzfSkgLT4gJHtyLnR5cGUuaW5kaWNlc30ge1xuICAgIHZhciBhOiAke3IudHlwZS5pbmRpY2VzfTtgKTtmb3IobGV0IGk9MDtpPHQ7KytpKW8ucHVzaChyLmluZGljZXNTZXQoXCJhXCIsZVtpXSxgaVske2l9XWApKTtyZXR1cm4gby5wdXNoKFwicmV0dXJuIGE7fVwiKSxvLmpvaW4oYFxuYCl9LFRmPShlLHQpPT57bGV0IHIsbixvLGksYSxkLGw9dC5mb3JtYXQ9PT1cIk5IV0NcIixwPXQuYmxvY2tzaXplLG09dC5tb2RlPT09XCJEQ1JcIjtsPyhbcixuLG8saV09ZS5kaW1zLGE9bT9bcixuLG8scCxwLGkvcCoqMl06W3IsbixvLGkvcCoqMixwLHBdLGQ9bT9bMCwxLDMsMiw0LDVdOlswLDEsNCwyLDUsM10pOihbcixuLG8saV09W2UuZGltc1swXSxlLmRpbXNbMl0sZS5kaW1zWzNdLGUuZGltc1sxXV0sYT1tP1tyLHAscCxpL3AqKjIsbixvXTpbcixpL3AqKjIscCxwLG4sb10sZD1tP1swLDMsNCwxLDUsMl06WzAsMSw0LDIsNSwzXSk7bGV0IHU9ZS5yZXNoYXBlKGEpLGg9dS5kaW1zLmxlbmd0aCxfPWUuZGF0YVR5cGUseT1FKFwiYVwiLF8saCksZz1NKFwib3V0cHV0XCIsXyxoKSx4PSQ9PmBcbiAgJHskLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dF9zaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyh5LGcpfVxuXG4gICR7U2YoZCxoLHksZyl9XG5cbiAgJHskLm1haW5TdGFydCgpfVxuICAgICR7JC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG5cbiAgICBsZXQgaW5kaWNlcyA9ICR7Zy5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICBsZXQgYUluZGljZXMgPSBwZXJtKGluZGljZXMpO1xuXG4gICAgJHtnLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLHkuZ2V0QnlJbmRpY2VzKFwiYUluZGljZXNcIikpfVxuICB9YDtyZXR1cm57bmFtZTpcIkRlcHRoVG9TcGFjZVwiLHNoYWRlckNhY2hlOntoaW50OmAke2UuZGltc307JHt0LmJsb2Nrc2l6ZX07JHt0Lm1vZGV9YCxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxnZXRSdW5EYXRhOiQ9PntsZXQgdj1sP1tyLG4qcCxvKnAsaS9wKioyXTpbcixpL3AqKjIsbipwLG8qcF0sUz1DLnNpemUodiksVD11LmRpbXMsQT1DLnNvcnRCYXNlZE9uUGVybShULGQpO3JldHVybntvdXRwdXRzOlt7ZGltczp2LGRhdGFUeXBlOiRbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChTLzY0KX0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZToxMixkYXRhOlN9LC4uLk4oVCxBKV19fSxnZXRTaGFkZXJTb3VyY2U6eH19LHVkPShlLHQpPT57eGYoZS5pbnB1dHMpLGUuY29tcHV0ZShUZihlLmlucHV0c1swXSx0KSl9LGRkPWU9PnJlKHtibG9ja3NpemU6ZS5ibG9ja3NpemUsbW9kZTplLm1vZGUsZm9ybWF0OmUuZm9ybWF0fSl9KTt2YXIgdm8sZW4sY2QsSWYsQ2YsJG8seG8scGQsQWYsbWQsZmQsaGQ9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTtTZSgpO2FlKCk7dm89XCJbYS16QS1aXXxcXFxcLlxcXFwuXFxcXC5cIixlbj1cIihcIit2bytcIikrXCIsY2Q9XCJeXCIrZW4rXCIkXCIsSWY9XCIoXCIrZW4rXCIsKSpcIitlbixDZj1cIl5cIitJZitcIiRcIiwkbz1jbGFzc3tjb25zdHJ1Y3Rvcih0PS0xKXt0aGlzLnN5bWJvbFRvSW5kaWNlcz1uZXcgTWFwLHRoaXMuaW5wdXRJbmRleD10fWFkZFN5bWJvbCh0LHIpe2xldCBuPXRoaXMuc3ltYm9sVG9JbmRpY2VzLmdldCh0KTtuPT09dm9pZCAwP249W3JdOm4ucHVzaChyKSx0aGlzLnN5bWJvbFRvSW5kaWNlcy5zZXQodCxuKX19LHhvPWNsYXNze2NvbnN0cnVjdG9yKHQscil7dGhpcy5lcXVhdGlvbj1yO3RoaXMuaGFzRWxsaXBzaXM9ITEsdGhpcy5zeW1ib2xUb0luZm89bmV3IE1hcCx0aGlzLmxocz1uZXcgQXJyYXksdGhpcy5vdXRwdXREaW1zPVtdO2xldFtuLG9dPXIuaW5jbHVkZXMoXCItPlwiKT9yLnNwbGl0KFwiLT5cIiwyKTpbcixcIlwiXTtpZighbi5tYXRjaChSZWdFeHAoQ2YpKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIExIUyB0ZXJtXCIpO2lmKG4uc3BsaXQoXCIsXCIpLmZvckVhY2goKGQsbCk9PntsZXQgcD10W2xdLmRpbXMuc2xpY2UoKTtpZighZC5tYXRjaChSZWdFeHAoY2QpKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIExIUyB0ZXJtXCIpO2xldCBtPXRoaXMucHJvY2Vzc1Rlcm0oZCwhMCxwLGwpO3RoaXMubGhzLnB1c2gobSl9KSxvPT09XCJcIilvKz1bLi4udGhpcy5zeW1ib2xUb0luZm8uZW50cmllcygpXS5maWx0ZXIoKFtkLGxdKT0+bC5jb3VudD09PTF8fGQ9PT1cIi4uLlwiKS5tYXAoKFtkXSk9PmQpLmpvaW4oXCJcIik7ZWxzZSBpZighby5tYXRjaChSZWdFeHAoZW4pKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFJIU1wiKTtvLm1hdGNoKFJlZ0V4cCh2byxcImdcIikpPy5mb3JFYWNoKGQ9PntpZihkPT09XCIuLi5cIil0aGlzLm91dHB1dERpbXM9dGhpcy5vdXRwdXREaW1zLmNvbmNhdCh0aGlzLmVsbGlwc2lzRGltcyk7ZWxzZXtsZXQgbD10aGlzLnN5bWJvbFRvSW5mby5nZXQoZCk7aWYobD09PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFJIUyBzeW1ib2xcIik7dGhpcy5vdXRwdXREaW1zLnB1c2gobC5kaW1WYWx1ZSl9fSksdGhpcy5yaHM9dGhpcy5wcm9jZXNzVGVybShvLCExLHRoaXMub3V0cHV0RGltcyl9YWRkU3ltYm9sKHQscixuKXtsZXQgbz10aGlzLnN5bWJvbFRvSW5mby5nZXQodCk7aWYobyE9PXZvaWQgMCl7aWYoby5kaW1WYWx1ZSE9PXImJm8uY291bnQhPT0xKXRocm93IG5ldyBFcnJvcihcIkRpbWVuc2lvbiBtaXNtYXRjaFwiKTtvLmNvdW50Kyssby5pbnB1dEluZGljZXMucHVzaChuKX1lbHNlIG89e2NvdW50OjEsZGltVmFsdWU6cixpbnB1dEluZGljZXM6W25dfTt0aGlzLnN5bWJvbFRvSW5mby5zZXQodCxvKX1wcm9jZXNzVGVybSh0LHIsbixvPS0xKXtsZXQgaT1uLmxlbmd0aCxhPSExLGQ9W10sbD0wO2lmKCF0Lm1hdGNoKFJlZ0V4cChjZCkpJiYhciYmdCE9PVwiXCIpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBMSFMgdGVybVwiKTtsZXQgcD10Lm1hdGNoKFJlZ0V4cCh2byxcImdcIikpLG09bmV3ICRvKG8pO3JldHVybiBwPy5mb3JFYWNoKCh1LGgpPT57aWYodT09PVwiLi4uXCIpe2lmKGEpdGhyb3cgbmV3IEVycm9yKFwiT25seSBvbmUgZWxsaXBzaXMgaXMgYWxsb3dlZCBwZXIgaW5wdXQgdGVybVwiKTthPSEwO2xldCBfPWktcC5sZW5ndGgrMTtpZihfPDApdGhyb3cgbmV3IEVycm9yKFwiRWxsaXBzaXMgb3V0IG9mIGJvdW5kc1wiKTtpZihkPW4uc2xpY2UobCxsK18pLHRoaXMuaGFzRWxsaXBzaXMpe2lmKHRoaXMuZWxsaXBzaXNEaW1zLmxlbmd0aCE9PWQubGVuZ3RofHx0aGlzLmVsbGlwc2lzRGltcy50b1N0cmluZygpIT09ZC50b1N0cmluZygpKXRocm93IG5ldyBFcnJvcihcIkVsbGlwc2lzIGRpbWVuc2lvbnMgbWlzbWF0Y2hcIil9ZWxzZSBpZihyKXRoaXMuaGFzRWxsaXBzaXM9ITAsdGhpcy5lbGxpcHNpc0RpbXM9ZDtlbHNlIHRocm93IG5ldyBFcnJvcihcIkVsbGlwc2lzIG11c3QgYmUgc3BlY2lmaWVkIGluIHRoZSBMSFNcIik7Zm9yKGxldCB5PTA7eTxkLmxlbmd0aDt5Kyspe2xldCBnPVN0cmluZy5mcm9tQ2hhckNvZGUoXCIwXCIuY2hhckNvZGVBdCgwKSt5KTttLmFkZFN5bWJvbChnLGgreSksdGhpcy5hZGRTeW1ib2woZyxuW2wrK10sbyl9fWVsc2UgbS5hZGRTeW1ib2wodSxoKyh0aGlzLmhhc0VsbGlwc2lzP3RoaXMuZWxsaXBzaXNEaW1zLmxlbmd0aC0xOjApKSx0aGlzLmFkZFN5bWJvbCh1LG5bbCsrXSxvKX0pLG19fSxwZD1lPT5lK1wiX21heFwiLEFmPShlLHQscixuKT0+e2xldCBpPWUubWFwKG09Pm0ubGVuZ3RoKS5tYXAoKG0sdSk9PkUoYGlucHV0JHt1fWAsdCxtKSksYT1DLnNpemUobiksZD1NKFwib3V0cHV0XCIsdCxuLmxlbmd0aCksbD1bLi4uci5zeW1ib2xUb0luZm8ua2V5cygpXS5maWx0ZXIobT0+IXIucmhzLnN5bWJvbFRvSW5kaWNlcy5oYXMobSkpLHA9bT0+e2xldCB1PVtdLGg9XCJ2YXIgcHJvZCA9IDEuMDtcIixfPVwidmFyIHN1bSA9IDAuMDtcIix5PVwic3VtICs9IHByb2Q7XCIsZz1bXSx4PVtdLCQ9W10sdj1bXSxTPXIuc3ltYm9sVG9JbmZvLnNpemU9PT1yLnJocy5zeW1ib2xUb0luZGljZXMuc2l6ZTtyLnN5bWJvbFRvSW5mby5mb3JFYWNoKChBLGspPT57aWYoci5yaHMuc3ltYm9sVG9JbmRpY2VzLmhhcyhrKSl7bGV0IFA9ci5yaHMuc3ltYm9sVG9JbmRpY2VzLmdldChrKT8uWzBdO1AhPT12b2lkIDAmJnIubGhzLmZvckVhY2goKEQsUik9PntpZihBLmlucHV0SW5kaWNlcy5pbmNsdWRlcyhSKSl7bGV0IEc9RC5zeW1ib2xUb0luZGljZXMuZ2V0KGspO2lmKEc9PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzeW1ib2wgZXJyb3JcIik7Ry5mb3JFYWNoKEs9Pnt1LnB1c2goYCR7aVtSXS5pbmRpY2VzU2V0KGBpbnB1dCR7Un1JbmRpY2VzYCxLLGQuaW5kaWNlc0dldChcIm91dHB1dEluZGljZXNcIixQKSl9YCl9KX19KX1lbHNlIHIubGhzLmZvckVhY2goKFAsRCk9PntpZihBLmlucHV0SW5kaWNlcy5pbmNsdWRlcyhEKSl7bGV0IFI9UC5zeW1ib2xUb0luZGljZXMuZ2V0KGspO2lmKFI9PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzeW1ib2wgZXJyb3JcIik7Ui5mb3JFYWNoKEc9PntnLnB1c2goYCR7aVtEXS5pbmRpY2VzU2V0KGBpbnB1dCR7RH1JbmRpY2VzYCxHLGAke2t9YCl9YCl9KSx2LnB1c2goYHByb2QgKj0gJHtpW0RdLmdldEJ5SW5kaWNlcyhgaW5wdXQke0R9SW5kaWNlc2ApfTtgKX19KSx4LnB1c2goYGZvcih2YXIgJHtrfTogdTMyID0gMDsgJHtrfSA8IHVuaWZvcm1zLiR7cGQoayl9OyAke2t9KyspIHtgKSwkLnB1c2goXCJ9XCIpfSk7bGV0IFQ9Uz9bLi4udSxgbGV0IHN1bSA9ICR7aS5tYXAoKEEsayk9PkEuZ2V0QnlJbmRpY2VzKGBpbnB1dCR7a31JbmRpY2VzYCkpLmpvaW4oXCIgKiBcIil9O2BdOlsuLi51LF8sLi4ueCwuLi5nLGgsLi4udix5LC4uLiRdO3JldHVybmBcbiAgICAgICAgICAgICR7bS5yZWdpc3RlclVuaWZvcm1zKGwubWFwKEE9Pih7bmFtZTpgJHtwZChBKX1gLHR5cGU6XCJ1MzJcIn0pKSkucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0U2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoLi4uaSxkKX1cblxuICAgICAgICAgICAgJHttLm1haW5TdGFydCgpfVxuICAgICAgICAgICAgJHttLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRTaXplXCIpfVxuICAgICAgICAgICAgdmFyIG91dHB1dEluZGljZXMgPSAke2Qub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAgICAgICAke2kubWFwKChBLGspPT5gdmFyIGlucHV0JHtrfUluZGljZXM6ICR7aVtrXS50eXBlLmluZGljZXN9O2ApLmpvaW4oYFxuYCl9XG4gICAgICAgICAgICAke1Quam9pbihgXG5gKX07XG4gICAgICAgICAgICAke2Quc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJzdW1cIil9O1xuICAgICAgICAgIH1gfTtyZXR1cm57bmFtZTpcIkVpbnN1bVwiLHNoYWRlckNhY2hlOntoaW50OnIuZXF1YXRpb24saW5wdXREZXBlbmRlbmNpZXM6ZS5tYXAoKCk9PlwicmFua1wiKX0sZ2V0UnVuRGF0YTooKT0+e2xldCBtPWwuZmlsdGVyKGg9PnIuc3ltYm9sVG9JbmZvLmhhcyhoKSkubWFwKGg9Pih7dHlwZToxMixkYXRhOnIuc3ltYm9sVG9JbmZvLmdldChoKT8uZGltVmFsdWV8fDB9KSk7bS5wdXNoKHt0eXBlOjEyLGRhdGE6YX0pO2xldCB1PWUubWFwKChoLF8pPT5bLi4uTihoKV0pLnJlZHVjZSgoaCxfKT0+aC5jb25jYXQoXyksbSk7cmV0dXJuIHUucHVzaCguLi5OKG4pKSx7b3V0cHV0czpbe2RpbXM6bixkYXRhVHlwZTp0fV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoYS82NCl9LHByb2dyYW1Vbmlmb3Jtczp1fX0sZ2V0U2hhZGVyU291cmNlOnB9fSxtZD0oZSx0KT0+e2xldCByPW5ldyB4byhlLmlucHV0cyx0LmVxdWF0aW9uKSxuPXIub3V0cHV0RGltcyxvPWUuaW5wdXRzLm1hcCgoaSxhKT0+aS5kaW1zKTtlLmNvbXB1dGUoQWYobyxlLmlucHV0c1swXS5kYXRhVHlwZSxyLG4pKX0sZmQ9ZT0+e2xldCB0PWUuZXF1YXRpb24ucmVwbGFjZSgvXFxzKy9nLFwiXCIpO3JldHVybiByZSh7ZXF1YXRpb246dH0pfX0pO3ZhciBrZixnZCxFZixQZixiZCx5ZD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtvZSgpO2FlKCk7a2Y9ZT0+e2lmKCFlfHxlLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwiRXhwYW5kIHJlcXVpcmVzIDIgaW5wdXQuXCIpO2xldCB0PWVbMF0uZGltcyxyPUFycmF5LmZyb20oZVsxXS5nZXRCaWdJbnQ2NEFycmF5KCksTnVtYmVyKSxuPXIubGVuZ3RoPHQubGVuZ3RoPzA6ci5sZW5ndGgtdC5sZW5ndGgsbz10Lmxlbmd0aDxyLmxlbmd0aD8wOnQubGVuZ3RoLXIubGVuZ3RoO2Zvcig7bjxyLmxlbmd0aCYmbzx0Lmxlbmd0aDsrK24sKytvKWlmKHJbbl0hPT10W29dJiZyW25dIT09MSYmdFtvXSE9PTEpdGhyb3cgbmV3IEVycm9yKFwiRXhwYW5kIHJlcXVpcmVzIHNoYXBlIHRvIGJlIGJyb2FkY2FzdGFibGUgdG8gaW5wdXRcIil9LGdkPShlLHQpPT57bGV0IHI9ZS5sZW5ndGgtdC5sZW5ndGgsbj1bXTtmb3IobGV0IG89MDtvPHI7KytvKW4ucHVzaChlW29dKTtmb3IobGV0IG89MDtvPHQubGVuZ3RoOysrbyluLnB1c2godFtvXT09PTE/ZVtvK3JdOnRbb10pO3JldHVybiBufSxFZj0oZSx0KT0+ZS5sZW5ndGg+dC5sZW5ndGg/Z2QoZSx0KTpnZCh0LGUpLFBmPWU9PntsZXQgdD1lWzBdLmRpbXMscj1BcnJheS5mcm9tKGVbMV0uZ2V0QmlnSW50NjRBcnJheSgpLE51bWJlciksbj1FZih0LHIpLG89ZVswXS5kYXRhVHlwZSxpPW89PT05fHxDLnNpemUodCk9PT0xLGE9bz09PTl8fHQubGVuZ3RoPjAmJnRbdC5sZW5ndGgtMV0lND09PTA/NDoxLGQ9aXx8bi5sZW5ndGg+MCYmbltuLmxlbmd0aC0xXSU0PT09MD80OjEsbD1NYXRoLmNlaWwoQy5zaXplKG4pL2QpLHA9dT0+e2xldCBoPUUoXCJpbnB1dFwiLG8sdC5sZW5ndGgsYSksXz1NKFwib3V0cHV0XCIsbyxuLmxlbmd0aCxkKSx5O2lmKG89PT05KXtsZXQgZz0oeCwkLHY9XCJcIik9PmBcbiAgICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyR7JH0gPSAke18ub2Zmc2V0VG9JbmRpY2VzKGBvdXRwdXRPZmZzZXQgKyAkeyR9dWApfTtcbiAgICAgICAgICBsZXQgb2Zmc2V0JHskfSA9ICR7aC5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0SW5kaWNlcyR7JH1gLF8pfTtcbiAgICAgICAgICBsZXQgaW5kZXgkeyR9ID0gb2Zmc2V0JHskfSAvIDR1O1xuICAgICAgICAgIGxldCBjb21wb25lbnQkeyR9ID0gb2Zmc2V0JHskfSAlIDR1O1xuICAgICAgICAgICR7eH1bJHskfV0gPSAke3Z9KCR7aC5nZXRCeU9mZnNldChgaW5kZXgkeyR9YCl9W2NvbXBvbmVudCR7JH1dKTtcbiAgICAgICAgYDt5PWBcbiAgICAgICAgbGV0IG91dHB1dE9mZnNldCA9IGdsb2JhbF9pZHggKiAke2R9O1xuICAgICAgICB2YXIgZGF0YSA9IHZlYzQ8dTMyPigwKTtcbiAgICAgICAgJHtnKFwiZGF0YVwiLDAsXCJ1MzJcIil9XG4gICAgICAgICR7ZyhcImRhdGFcIiwxLFwidTMyXCIpfVxuICAgICAgICAke2coXCJkYXRhXCIsMixcInUzMlwiKX1cbiAgICAgICAgJHtnKFwiZGF0YVwiLDMsXCJ1MzJcIil9XG4gICAgICAgICR7Xy5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcImRhdGFcIil9XG4gICAgICB9YH1lbHNlIHk9YFxuICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7Xy5vZmZzZXRUb0luZGljZXMoYGdsb2JhbF9pZHggKiAke2R9YCl9O1xuICAgICAgICBsZXQgaW5wdXRPZmZzZXQgPSAke2guYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoXCJvdXRwdXRJbmRpY2VzXCIsXyl9O1xuICAgICAgICBsZXQgZGF0YSA9ICR7Xy50eXBlLnZhbHVlfSgke2guZ2V0QnlPZmZzZXQoYGlucHV0T2Zmc2V0IC8gJHthfWApfSk7XG4gICAgICAgICR7Xy5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcImRhdGFcIil9XG4gICAgICB9YDtyZXR1cm5gXG4gICAgJHt1LnJlZ2lzdGVyVW5pZm9ybShcInZlY19zaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyhoLF8pfVxuICAgICR7dS5tYWluU3RhcnQoKX1cbiAgICAke3UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLnZlY19zaXplXCIpfVxuICAgICR7eX1gfSxtPVt7dHlwZToxMixkYXRhOmx9LC4uLk4odCxuKV07cmV0dXJue25hbWU6XCJFeHBhbmRcIixzaGFkZXJDYWNoZTp7aGludDpgJHtuLmxlbmd0aH07JHthfSR7ZH1gLGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LGdldFNoYWRlclNvdXJjZTpwLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6bixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwobC82NCl9LHByb2dyYW1Vbmlmb3JtczptfSl9fSxiZD1lPT57a2YoZS5pbnB1dHMpLGUuY29tcHV0ZShQZihlLmlucHV0cykse2lucHV0czpbMF19KX19KTt2YXIgemYsX2Qsd2Q9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTthZSgpO0tyKCk7emY9ZT0+e2xldCB0PWVbMF0uZGF0YVR5cGUscj1DLnNpemUoZVswXS5kaW1zKSxuPUMuc2l6ZShlWzFdLmRpbXMpLG89biU0PT09MCxpPWE9PntsZXQgZD1FKFwieFwiLHQsWzFdLDQpLGw9RShcImJpYXNcIix0LFsxXSw0KSxwPU0oXCJ5XCIsdCxbMV0sNCksbT1be25hbWU6XCJvdXRwdXRfdmVjX3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiYmlhc19zaXplXCIsdHlwZTpcInUzMlwifV0sdT1fPT5gXG4gICAgICBsZXQgYmlhcyR7X31fb2Zmc2V0OiB1MzIgPSAoZ2xvYmFsX2lkeCAqIDQgKyAke199KSAlIHVuaWZvcm1zLmJpYXNfc2l6ZTtcbiAgICAgIGxldCBiaWFzJHtffSA9ICR7bC5nZXRCeU9mZnNldChgYmlhcyR7X31fb2Zmc2V0IC8gNGApfVtiaWFzJHtffV9vZmZzZXQgJSA0XTtgLGg9bz9gXG4gICAgICBsZXQgYmlhcyA9ICR7bC5nZXRCeU9mZnNldChcImdsb2JhbF9pZHggJSAodW5pZm9ybXMuYmlhc19zaXplIC8gNClcIil9O2A6YCR7dSgwKX0ke3UoMSl9JHt1KDIpfSR7dSgzKX1cbiAgICAgIGxldCBiaWFzID0gJHtkLnR5cGUudmFsdWV9KGJpYXMwLCBiaWFzMSwgYmlhczIsIGJpYXMzKTtgO3JldHVybmAke2EucmVnaXN0ZXJVbmlmb3JtcyhtKS5kZWNsYXJlVmFyaWFibGVzKGQsbCxwKX1cblxuICAgICR7bW8oRWUodCkpfVxuXG4gICAgJHthLm1haW5TdGFydChrdCl9XG4gICAgICAke2EuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF92ZWNfc2l6ZVwiKX1cblxuICAgICAgbGV0IHggPSAke2QuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgICR7aH1cbiAgICAgIGxldCB4X2luID0geCArIGJpYXM7XG4gICAgICAke3Auc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsZm8oXCJ4X2luXCIpKX1cbiAgICB9YH07cmV0dXJue25hbWU6XCJGYXN0R2VsdVdpdGhCaWFzXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7b31gLGlucHV0RGVwZW5kZW5jaWVzOltcInR5cGVcIixcInR5cGVcIl19LGdldFNoYWRlclNvdXJjZTppLGdldFJ1bkRhdGE6YT0+KHtvdXRwdXRzOlt7ZGltczphWzBdLmRpbXMsZGF0YVR5cGU6YVswXS5kYXRhVHlwZX1dLHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTpNYXRoLmNlaWwoci80KX0se3R5cGU6MTIsZGF0YTpufV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoci9rdC80KX19KX19LF9kPWU9PntlLmlucHV0cy5sZW5ndGg8Mnx8Qy5zaXplKGUuaW5wdXRzWzFdLmRpbXMpPT09MD9odShlKTplLmNvbXB1dGUoemYoZS5pbnB1dHMpKX19KTt2YXIgT2YsRGYsdmQsJGQseGQ9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTtTZSgpO2FlKCk7T2Y9ZT0+e2lmKCFlfHxlLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwiR2F0aGVyIHJlcXVpcmVzIDIgaW5wdXRzLlwiKX0sRGY9KGUsdCk9PntsZXQgcj1lWzBdLmRpbXMsbj1lWzFdLmRpbXMsbz1yLmxlbmd0aCxpPUMubm9ybWFsaXplQXhpcyh0LmF4aXMsbyksYT1yLnNsaWNlKDApO2Euc3BsaWNlKGksMSwuLi5uKTtsZXQgZD1yW2ldLGw9ZVswXS5kYXRhVHlwZT09PTk/NDoxLHA9TWF0aC5jZWlsKEMuc2l6ZShhKS9sKSxtPVt7dHlwZToxMixkYXRhOnB9LHt0eXBlOjYsZGF0YTpkfSx7dHlwZToxMixkYXRhOml9LC4uLk4oZVswXS5kaW1zLGVbMV0uZGltcyxhKV0sdT1oPT57bGV0IF89RShcImRhdGFcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcy5sZW5ndGgsbCkseT1FKFwiaW5wdXRJbmRpY2VzXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMubGVuZ3RoKSxnPU0oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLGEubGVuZ3RoLGwpLHg9dj0+e2xldCBTPW4ubGVuZ3RoLFQ9YHZhciBpbmRpY2VzSW5kaWNlcyR7dn0gID0gJHt5LnR5cGUuaW5kaWNlc30oMCk7YDtmb3IobGV0IEE9MDtBPFM7QSsrKVQrPWAke1M+MT9gaW5kaWNlc0luZGljZXMke3Z9WyR7QX1dYDpgaW5kaWNlc0luZGljZXMke3Z9YH0gPSAke2EubGVuZ3RoPjE/YG91dHB1dEluZGljZXMke3Z9W3VuaWZvcm1zLmF4aXMgKyAke0F9XWA6YG91dHB1dEluZGljZXMke3Z9YH07YDtUKz1gXG4gICAgICAgICAgdmFyIGlkeCR7dn0gPSAke3kuZ2V0QnlJbmRpY2VzKGBpbmRpY2VzSW5kaWNlcyR7dn1gKX07XG4gICAgICAgICAgaWYgKGlkeCR7dn0gPCAwKSB7XG4gICAgICAgICAgICBpZHgke3Z9ID0gaWR4JHt2fSArIHVuaWZvcm1zLmF4aXNEaW1MaW1pdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGRhdGFJbmRpY2VzJHt2fSA6ICR7Xy50eXBlLmluZGljZXN9O1xuICAgICAgICBgO2ZvcihsZXQgQT0wLGs9MDtBPG87QSsrKUE9PT1pPyhUKz1gJHtvPjE/YGRhdGFJbmRpY2VzJHt2fVske0F9XWA6YGRhdGFJbmRpY2VzJHt2fWB9ID0gdTMyKGlkeCR7dn0pO2Asays9Uyk6KFQrPWAke28+MT9gZGF0YUluZGljZXMke3Z9WyR7QX1dYDpgZGF0YUluZGljZXMke3Z9YH0gPSAke2EubGVuZ3RoPjE/YG91dHB1dEluZGljZXMke3Z9WyR7a31dYDpgb3V0cHV0SW5kaWNlcyR7dn1gfTtgLGsrKyk7cmV0dXJuIFR9LCQ7aWYoZVswXS5kYXRhVHlwZT09PTkpe2xldCB2PShTLFQsQT1cIlwiKT0+YFxuICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzJHtUfSA9ICR7Zy5vZmZzZXRUb0luZGljZXMoYG91dHB1dE9mZnNldCArICR7VH11YCl9O1xuICAgICAgICAgICR7eChUKX07XG4gICAgICAgICAgbGV0IG9mZnNldCR7VH0gPSAke18uaW5kaWNlc1RvT2Zmc2V0KGBkYXRhSW5kaWNlcyR7VH1gKX07XG4gICAgICAgICAgbGV0IGluZGV4JHtUfSA9IG9mZnNldCR7VH0gLyA0dTtcbiAgICAgICAgICBsZXQgY29tcG9uZW50JHtUfSA9IG9mZnNldCR7VH0gJSA0dTtcbiAgICAgICAgICAke1N9WyR7VH1dID0gJHtBfSgke18uZ2V0QnlPZmZzZXQoYGluZGV4JHtUfWApfVtjb21wb25lbnQke1R9XSk7XG4gICAgICAgIGA7JD1gXG4gICAgICAgIGxldCBvdXRwdXRPZmZzZXQgPSBnbG9iYWxfaWR4ICogJHtsfTtcbiAgICAgICAgdmFyIHZhbHVlID0gdmVjNDx1MzI+KDApO1xuICAgICAgICAke3YoXCJ2YWx1ZVwiLDAsXCJ1MzJcIil9XG4gICAgICAgICR7dihcInZhbHVlXCIsMSxcInUzMlwiKX1cbiAgICAgICAgJHt2KFwidmFsdWVcIiwyLFwidTMyXCIpfVxuICAgICAgICAke3YoXCJ2YWx1ZVwiLDMsXCJ1MzJcIil9XG4gICAgICAgICR7Zy5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlXCIpfVxuICAgICAgYH1lbHNlICQ9YFxuICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke2cub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAke3goXCJcIil9O1xuICAgICAgbGV0IHZhbHVlID0gJHtfLmdldEJ5SW5kaWNlcyhcImRhdGFJbmRpY2VzXCIpfTtcbiAgICAgICR7Zy5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlXCIpfTtcbiAgICAgIGA7cmV0dXJuYFxuICAgICAgJHtoLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dFNpemVcIixcInUzMlwiKS5yZWdpc3RlclVuaWZvcm0oXCJheGlzRGltTGltaXRcIixcImkzMlwiKS5yZWdpc3RlclVuaWZvcm0oXCJheGlzXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyhfLHksZyl9XG4gICAgICAke2gubWFpblN0YXJ0KCl9XG4gICAgICAgICR7aC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0U2l6ZVwiKX1cbiAgICAgICAgJHskfVxuICAgICAgfWB9O3JldHVybntuYW1lOlwiR2F0aGVyXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6dC5jYWNoZUtleSxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCIsXCJyYW5rXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmEsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHAvNjQpfSxwcm9ncmFtVW5pZm9ybXM6bX0pLGdldFNoYWRlclNvdXJjZTp1fX0sdmQ9ZT0+cmUoe2F4aXM6ZS5heGlzfSksJGQ9KGUsdCk9PntsZXQgcj1lLmlucHV0cztPZihyKSxlLmNvbXB1dGUoRGYoZS5pbnB1dHMsdCkpfX0pO3ZhciBCZixTZCxUZCxJZD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtvZSgpO2FlKCk7QmY9KGUsdCxyLG4sbyxpLGEsZCxsKT0+e2xldCBwPVt7dHlwZToxMixkYXRhOml9LHt0eXBlOjEyLGRhdGE6bn0se3R5cGU6MTIsZGF0YTpvfSx7dHlwZToxMixkYXRhOnJ9LHt0eXBlOjEyLGRhdGE6YX0se3R5cGU6MTIsZGF0YTpkfSx7dHlwZToxMixkYXRhOmx9XSxtPVtpXTtwLnB1c2goLi4uTih0LmRpbXMsbSkpO2xldCB1PWg9PntsZXQgXz1FKFwiaW5kaWNlc19kYXRhXCIsdC5kYXRhVHlwZSx0LmRpbXMubGVuZ3RoKSx5PU0oXCJpbnB1dF9zbGljZV9vZmZzZXRzX2RhdGFcIiwxMiwxLDEpLGc9W18seV0seD1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJiYXRjaF9kaW1zXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImlucHV0X2RpbXNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOm8ubGVuZ3RofSx7bmFtZTpcInNpemVzX2Zyb21fc2xpY2VfZGltc19kYXRhXCIsdHlwZTpcInUzMlwiLGxlbmd0aDpyLmxlbmd0aH0se25hbWU6XCJudW1fc2xpY2VzX3Blcl9iYXRjaFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJpbnB1dF9iYXRjaF9zdHJpZGVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibnVtX3NsaWNlX2RpbXNcIix0eXBlOlwidTMyXCJ9XTtyZXR1cm5gXG4gICR7aC5yZWdpc3RlclVuaWZvcm1zKHgpLmRlY2xhcmVWYXJpYWJsZXMoLi4uZyl9XG4gICR7aC5tYWluU3RhcnQoKX1cbiAgICAke2guZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgIGxldCBiYXRjaF9pZHggPSBnbG9iYWxfaWR4IC8gdW5pZm9ybXMubnVtX3NsaWNlc19wZXJfYmF0Y2g7XG4gICAgbGV0IGJhc2Vfb2Zmc2V0ID0gYmF0Y2hfaWR4ICogdW5pZm9ybXMuaW5wdXRfYmF0Y2hfc3RyaWRlO1xuXG4gICAgbGV0IHNsaWNlX2luZGljZXNfYmFzZV9vZmZzZXQgPSBnbG9iYWxfaWR4ICogdW5pZm9ybXMubnVtX3NsaWNlX2RpbXM7XG4gICAgdmFyIHJlbGF0aXZlX3NsaWNlX29mZnNldCA9IDA7XG4gICAgZm9yICh2YXIgZGltX2lkeCA9IDB1OyBkaW1faWR4IDwgdW5pZm9ybXMubnVtX3NsaWNlX2RpbXM7IGRpbV9pZHggKyspIHtcbiAgICAgIHZhciBpbmRleCA9IGkzMihpbmRpY2VzX2RhdGFbZGltX2lkeCArIHNsaWNlX2luZGljZXNfYmFzZV9vZmZzZXRdLngpO1xuICAgICAgbGV0IGlucHV0X2RpbV9pZHggPSB1bmlmb3Jtcy5iYXRjaF9kaW1zICsgZGltX2lkeDtcbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgJHtvLmxlbmd0aD09PTE/XCJpbmRleCArPSBpMzIodW5pZm9ybXMuaW5wdXRfZGltcyk7XCI6XCJpbmRleCArPSBpMzIodW5pZm9ybXMuaW5wdXRfZGltc1tpbnB1dF9kaW1faWR4XSk7XCJ9XG4gICAgICB9XG4gICAgICAke3IubGVuZ3RoPT09MT9cInJlbGF0aXZlX3NsaWNlX29mZnNldCArPSBpbmRleCAqIGkzMih1bmlmb3Jtcy5zaXplc19mcm9tX3NsaWNlX2RpbXNfZGF0YSk7XCI6XCJyZWxhdGl2ZV9zbGljZV9vZmZzZXQgKz0gaW5kZXggKiBpMzIodW5pZm9ybXMuc2l6ZXNfZnJvbV9zbGljZV9kaW1zX2RhdGFbZGltX2lkeF0pO1wifVxuICAgIH1cblxuICAgIGlucHV0X3NsaWNlX29mZnNldHNfZGF0YVtnbG9iYWxfaWR4XSA9ICBiYXNlX29mZnNldCArIHUzMihyZWxhdGl2ZV9zbGljZV9vZmZzZXQpO1xuICB9YH07cmV0dXJuIGUuY29tcHV0ZSh7bmFtZTpcImNvbXB1dGVTbGljZU9mZnNldHNcIixzaGFkZXJDYWNoZTp7aGludDpgJHtvLmxlbmd0aH1fJHtyLmxlbmd0aH1gLGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6bSxkYXRhVHlwZTplLmlucHV0c1sxXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGkvNjQpfSxwcm9ncmFtVW5pZm9ybXM6cH0pLGdldFNoYWRlclNvdXJjZTp1fSx7aW5wdXRzOlt0XSxvdXRwdXRzOlstMV19KVswXX0sU2Q9KGUsdCk9PntsZXQgcj1lLmlucHV0cyxuPXJbMF0uZGltcyxvPXJbMF0uZGF0YVR5cGUsaT1yWzFdLmRpbXMsYT1pW2kubGVuZ3RoLTFdLGQ9Qy5zaXplVG9EaW1lbnNpb24oaSxpLmxlbmd0aC0xKSxsPUMuc2l6ZUZyb21EaW1lbnNpb24obix0LmJhdGNoRGltcythKSxwPUMuc2l6ZVRvRGltZW5zaW9uKG4sdC5iYXRjaERpbXMpLG09Qy5zaXplRnJvbURpbWVuc2lvbihuLHQuYmF0Y2hEaW1zKSx1PWQvcCxoPW5ldyBBcnJheShhKSxfPWw7Zm9yKGxldCBUPTA7VDxhOysrVCloW2EtMS1UXT1fLF8qPW5bdC5iYXRjaERpbXMrYS0xLVRdO2xldCB5PUJmKGUsclsxXSxoLHQuYmF0Y2hEaW1zLG4sZCx1LG0sYSksZz10LmJhdGNoRGltcythO2lmKGc+bi5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwibGFzdCBkaW1lbnNpb24gb2YgaW5kaWNlcyBtdXN0IG5vdCBiZSBsYXJnZXIgdGhhbiByYW5rIG9mIGlucHV0IHRlbnNvclwiKTtsZXQgeD1pLnNsaWNlKDAsLTEpLmNvbmNhdChuLnNsaWNlKGcpKSwkPUMuc2l6ZSh4KSx2PVt7dHlwZToxMixkYXRhOiR9LHt0eXBlOjEyLGRhdGE6bH0sLi4uTihyWzBdLmRpbXMseS5kaW1zLHgpXSxTPVQ9PntsZXQgQT1FKFwiZGF0YVwiLHJbMF0uZGF0YVR5cGUsclswXS5kaW1zLmxlbmd0aCksaz1FKFwic2xpY2Vfb2Zmc2V0c1wiLDEyLHkuZGltcy5sZW5ndGgpLFA9TShcIm91dHB1dFwiLHJbMF0uZGF0YVR5cGUseC5sZW5ndGgpO3JldHVybmBcbiAgICAgICAgICAke1QucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0X3NpemVcIixcInUzMlwiKS5yZWdpc3RlclVuaWZvcm0oXCJzbGljZV9zaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyhBLGssUCl9XG4gICAgICAgICAgICAke1QubWFpblN0YXJ0KCl9XG4gICAgICAgICAgICAke1QuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgICAgICAgIGxldCBzbGljZV9vZmZzZXQgPSBzbGljZV9vZmZzZXRzW2dsb2JhbF9pZHggLyB1bmlmb3Jtcy5zbGljZV9zaXplXTtcbiAgICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSBkYXRhW3UzMihzbGljZV9vZmZzZXQpICsgZ2xvYmFsX2lkeCAlIHVuaWZvcm1zLnNsaWNlX3NpemVdO1xuICAgICAgICB9YH07ZS5jb21wdXRlKHtuYW1lOlwiR2F0aGVyTkRcIixzaGFkZXJDYWNoZTp7aGludDp0LmNhY2hlS2V5LGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIixcInJhbmtcIl19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6eCxkYXRhVHlwZTpvfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoJC82NCl9LHByb2dyYW1Vbmlmb3Jtczp2fSksZ2V0U2hhZGVyU291cmNlOlN9LHtpbnB1dHM6W3JbMF0seV19KX0sVGQ9ZT0+KHtiYXRjaERpbXM6ZS5iYXRjaF9kaW1zLGNhY2hlS2V5OlwiXCJ9KX0pO3ZhciBNZixSZixDZCxBZCxrZD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtvZSgpO1NlKCk7YWUoKTtNZj0oZSx0KT0+e2lmKGUubGVuZ3RoPDN8fGUubGVuZ3RoPjQpdGhyb3cgbmV3IEVycm9yKFwiR2F0aGVyQmxvY2tRdWFudGl6ZWQgcmVxdWlyZXMgMyBvciA0IGlucHV0cy5cIik7bGV0IHI9Qy5ub3JtYWxpemVBeGlzKHQucXVhbnRpemVBeGlzLGVbMF0uZGltcy5sZW5ndGgpLG49dC5ibG9ja1NpemUsbz1lWzBdLGk9ZVsyXSxhPWUubGVuZ3RoPT09ND9lWzNdOnZvaWQgMDtpZihpLmRpbXMubGVuZ3RoIT09by5kaW1zLmxlbmd0aHx8IW8uZGltcy5tYXAoKGQsbCk9Pmw9PT1yP01hdGguY2VpbChkL24pPT09aS5kaW1zW2xdOmQ9PT1pLmRpbXNbbF0pLnJlZHVjZSgoZCxsKT0+ZCYmbCwhMCkpdGhyb3cgbmV3IEVycm9yKFwiU2NhbGVzIG11c3QgaGF2ZSB0aGUgc2FtZSByYW5rIGFzIHRoZSBpbnB1dCB0ZW5zb3IgYW5kIHRoZSBkaW1zIHNob3VsZCBtYXRjaCBleGNlcHQgb24gZ2F0aGVyQXhpcy5cIik7aWYoYSl7aWYoYS5kYXRhVHlwZSE9PW8uZGF0YVR5cGUpdGhyb3cgbmV3IEVycm9yKFwiWmVybyBwb2ludCBtdXN0IGhhdmUgdGhlIHNhbWUgZGF0YSB0eXBlIGFzIHRoZSBpbnB1dCB0ZW5zb3IuXCIpO2lmKGEuZGltcy5sZW5ndGghPT1pLmRpbXMubGVuZ3RofHwhYS5kaW1zLm1hcCgoZCxsKT0+ZD09PWkuZGltc1tsXSkucmVkdWNlKChkLGwpPT5kJiZsLCEwKSl0aHJvdyBuZXcgRXJyb3IoXCJaZXJvIHBvaW50IG11c3QgaGF2ZSB0aGUgc2FtZSByYW5rIGFzIHRoZSBpbnB1dCB0ZW5zb3IgYW5kIHRoZSBkaW1zIHNob3VsZCBtYXRjaCBleGNlcHQgb24gcXVhbnRpemVBeGlzLlwiKX19LFJmPShlLHQpPT57bGV0IHI9ZVswXS5kaW1zLG49ZVsxXS5kaW1zLG89ci5sZW5ndGgsaT1DLm5vcm1hbGl6ZUF4aXModC5nYXRoZXJBeGlzLG8pLGE9Qy5ub3JtYWxpemVBeGlzKHQucXVhbnRpemVBeGlzLG8pLGQ9ci5zbGljZSgwKTtkLnNwbGljZShpLDEsLi4ubik7bGV0IGw9Qy5zaXplKGQpLHA9ZVsyXS5kYXRhVHlwZSx1PWVbMF0uZGF0YVR5cGU9PT0yMixoPVt7dHlwZToxMixkYXRhOmx9LHt0eXBlOjEyLGRhdGE6YX0se3R5cGU6MTIsZGF0YTppfSx7dHlwZToxMixkYXRhOnQuYmxvY2tTaXplfSwuLi5OKC4uLmUubWFwKCh5LGcpPT55LmRpbXMpLGQpXSxfPXk9PntsZXQgZz1FKFwiZGF0YVwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLmxlbmd0aCkseD1FKFwiaW5wdXRJbmRpY2VzXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMubGVuZ3RoKSwkPUUoXCJzY2FsZXNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcy5sZW5ndGgpLHY9ZS5sZW5ndGg+Mz9FKFwiemVyb1BvaW50XCIsZVszXS5kYXRhVHlwZSxlWzNdLmRpbXMubGVuZ3RoKTp2b2lkIDAsUz1NKFwib3V0cHV0XCIscCxkLmxlbmd0aCksVD1bZyx4LCRdO3YmJlQucHVzaCh2KTtsZXQgQT1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJxdWFudGl6ZV9heGlzXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImdhdGhlcl9heGlzXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImJsb2NrX3NpemVcIix0eXBlOlwidTMyXCJ9XTtyZXR1cm5gXG4gICAgICAgICR7eS5yZWdpc3RlclVuaWZvcm1zKEEpLmRlY2xhcmVWYXJpYWJsZXMoLi4uVCxTKX1cbiAgICAgICAgJHt5Lm1haW5TdGFydCgpfVxuICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke1Mub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAgIHZhciBpbmRpY2VzX2luZGljZXMgPSAke3gudHlwZS5pbmRpY2VzfSgwKTtcbiAgICAgICAgJHsoKCk9Pm4ubGVuZ3RoPjE/YFxuICAgICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCAke24ubGVuZ3RofTsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSAke1MuaW5kaWNlc0dldChcIm91dHB1dF9pbmRpY2VzXCIsXCJ1bmlmb3Jtcy5nYXRoZXJfYXhpcyArIGlcIil9O1xuICAgICAgICAgICAgJHt4LmluZGljZXNTZXQoXCJpbmRpY2VzX2luZGljZXNcIixcImlcIixcImluZGV4XCIpfTtcbiAgICAgICAgICB9YDpgaW5kaWNlc19pbmRpY2VzID0gJHtTLmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLFwidW5pZm9ybXMuZ2F0aGVyX2F4aXNcIil9O2ApKCl9O1xuICAgICAgICB2YXIgZGF0YV9pbmRpY2VzID0gJHtnLnR5cGUuaW5kaWNlc30oMCk7XG4gICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCB1bmlmb3Jtcy5nYXRoZXJfYXhpczsgaSsrKSB7XG4gICAgICAgICAgbGV0IGluZGV4ID0gJHtTLmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLFwiaVwiKX07XG4gICAgICAgICAgJHtnLmluZGljZXNTZXQoXCJkYXRhX2luZGljZXNcIixcImlcIixcImluZGV4XCIpfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZXhfZnJvbV9pbmRpY2VzID0gJHt4LmdldEJ5SW5kaWNlcyhcImluZGljZXNfaW5kaWNlc1wiKX07XG4gICAgICAgIGlmIChpbmRleF9mcm9tX2luZGljZXMgPCAwKSB7XG4gICAgICAgICAgaW5kZXhfZnJvbV9pbmRpY2VzICs9ICR7cltpXX07XG4gICAgICAgIH1cbiAgICAgICAgJHtnLmluZGljZXNTZXQoXCJkYXRhX2luZGljZXNcIixcInVuaWZvcm1zLmdhdGhlcl9heGlzXCIsXCJ1MzIoaW5kZXhfZnJvbV9pbmRpY2VzKVwiKX07XG4gICAgICAgIGZvciAodmFyIGkgPSB1bmlmb3Jtcy5nYXRoZXJfYXhpcyArIDE7IGkgPCAke2QubGVuZ3RofTsgaSsrKSB7XG4gICAgICAgICAgbGV0IGluZGV4ID0gJHtTLmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLGBpICsgJHtuLmxlbmd0aH0gLSAxYCl9O1xuICAgICAgICAgICR7Zy5pbmRpY2VzU2V0KFwiZGF0YV9pbmRpY2VzXCIsXCJpXCIsXCJpbmRleFwiKX07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRhdGFfb2Zmc2V0ID0gJHtnLmluZGljZXNUb09mZnNldChcImRhdGFfaW5kaWNlc1wiKX07XG4gICAgICAgIGxldCBkYXRhX2luZGV4ID0gZGF0YV9vZmZzZXQgJSA4O1xuICAgICAgICAvLyBDb252ZXJ0IDQtYml0IHBhY2tlZCBkYXRhIHRvIDgtYml0IHBhY2tlZCBkYXRhLlxuICAgICAgICBsZXQgcGFja2VkXzRiaXRfcXVhbnRpemVkX2RhdGEgPSAke2cuZ2V0QnlPZmZzZXQoXCJkYXRhX29mZnNldCAvIDhcIil9O1xuICAgICAgICBsZXQgcGFja2VkXzhiaXRfcXVhbnRpemVkX2RhdGEgPSAocGFja2VkXzRiaXRfcXVhbnRpemVkX2RhdGEgPj4gKDQgKiAoZGF0YV9pbmRleCAlIDIpKSkgJiAweDBmMGYwZjBmO1xuICAgICAgICBsZXQgcXVhbnRpemVkX2RhdGFfdmVjID0gJHt1P1widW5wYWNrNHhJOFwiOlwidW5wYWNrNHhVOFwifSh1MzIocGFja2VkXzhiaXRfcXVhbnRpemVkX2RhdGEpKTtcbiAgICAgICAgbGV0IHF1YW50aXplZF9kYXRhID0gcXVhbnRpemVkX2RhdGFfdmVjW2RhdGFfaW5kZXggLyAyXTtcbiAgICAgICAgdmFyIHNjYWxlX2luZGljZXMgPSBkYXRhX2luZGljZXM7XG4gICAgICAgIGxldCBxdWFudGl6ZV9heGlzX2luZGV4ID0gJHskLmluZGljZXNHZXQoXCJkYXRhX2luZGljZXNcIixcInVuaWZvcm1zLnF1YW50aXplX2F4aXNcIil9IC8gdW5pZm9ybXMuYmxvY2tfc2l6ZTtcbiAgICAgICAgJHskLmluZGljZXNTZXQoXCJzY2FsZV9pbmRpY2VzXCIsXCJ1bmlmb3Jtcy5xdWFudGl6ZV9heGlzXCIsXCJxdWFudGl6ZV9heGlzX2luZGV4XCIpfTtcbiAgICAgICAgdmFyIHNjYWxlID0gJHskLmdldEJ5SW5kaWNlcyhcInNjYWxlX2luZGljZXNcIil9O1xuICAgICAgICAkeygoKT0+dj9gXG4gICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2luZGljZXMgPSBzY2FsZV9pbmRpY2VzO1xuICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9vZmZzZXQgPSAke3YuaW5kaWNlc1RvT2Zmc2V0KFwiemVyb19wb2ludF9pbmRpY2VzXCIpfTtcbiAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfaW5kZXggPSB6ZXJvX3BvaW50X29mZnNldCAlIDg7XG4gICAgICAgICAgICAgIGxldCBwYWNrZWRfNGJpdF96ZXJvX3BvaW50cyA9ICR7di5nZXRCeU9mZnNldChcInplcm9fcG9pbnRfb2Zmc2V0IC8gOFwiKX07XG4gICAgICAgICAgICAgIGxldCBwYWNrZWRfOGJpdF96ZXJvX3BvaW50cyA9IChwYWNrZWRfNGJpdF96ZXJvX3BvaW50cyA+PiAoNCAqICh6ZXJvX3BvaW50X2luZGV4ICUgMikpKSAmIDB4MGYwZjBmMGY7XG4gICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3ZlYyA9ICR7dT9cInVucGFjazR4SThcIjpcInVucGFjazR4VThcIn0odTMyKHBhY2tlZF84Yml0X3plcm9fcG9pbnRzKSk7XG4gICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50ID0gemVyb19wb2ludF92ZWNbemVyb19wb2ludF9pbmRleCAvIDJdO2A6XCJ2YXIgemVyb19wb2ludCA9IDBcIikoKX07XG4gICAgICAgIGxldCBkZXF1YW50aXplZF9kYXRhID0gJHtFZShwKX0ocXVhbnRpemVkX2RhdGEgLSB6ZXJvX3BvaW50KSAqIHNjYWxlO1xuICAgICAgICAke1Muc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJkZXF1YW50aXplZF9kYXRhXCIpfTtcbiAgICB9YH07cmV0dXJue25hbWU6XCJHYXRoZXJCbG9ja1F1YW50aXplZFwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9OyR7ZS5maWx0ZXIoKHksZyk9PmchPT0xKS5tYXAoeT0+eS5kaW1zLmpvaW4oXCJfXCIpKS5qb2luKFwiO1wiKX1gLGlucHV0RGVwZW5kZW5jaWVzOkFycmF5LmZyb20oe2xlbmd0aDplLmxlbmd0aH0sKHksZyk9PlwicmFua1wiKX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpkLGRhdGFUeXBlOnB9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChsLzY0KX0scHJvZ3JhbVVuaWZvcm1zOmh9KSxnZXRTaGFkZXJTb3VyY2U6X319LENkPShlLHQpPT57bGV0IHI9ZS5pbnB1dHM7TWYocix0KSxlLmNvbXB1dGUoUmYoZS5pbnB1dHMsdCkpfSxBZD1lPT5yZSh7YmxvY2tTaXplOmUuYmxvY2tTaXplLGdhdGhlckF4aXM6ZS5nYXRoZXJBeGlzLHF1YW50aXplQXhpczplLnF1YW50aXplQXhpc30pfSk7dmFyIFVmLE5mLEVkLFBkLHpkPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7U2UoKTthZSgpO1VmPWU9PntpZighZXx8ZS5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIkdhdGhlckVsZW1lbnRzIHJlcXVpcmVzIDIgaW5wdXRzLlwiKTtpZihlWzBdLmRpbXMubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKFwiR2F0aGVyRWxlbWVudHMgcmVxdWlyZXMgdGhhdCB0aGUgZGF0YSBpbnB1dCBiZSByYW5rID49IDEuXCIpO2lmKGVbMF0uZGltcy5sZW5ndGghPT1lWzFdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgR2F0aGVyRWxlbWVudHMgcmVxdWlyZXMgdGhhdCB0aGUgZGF0YSBpbnB1dCBhbmRcbiAgICAgICAgICAgICAgICAgICAgIGluZGljZXMgaW5wdXQgdGVuc29ycyBiZSBvZiBzYW1lIHJhbmsuYCl9LE5mPShlLHQpPT57bGV0IHI9ZVswXS5kaW1zLG49ZVswXS5kYXRhVHlwZSxvPXIubGVuZ3RoLGk9ZVsxXS5kaW1zLGE9ZVsxXS5kYXRhVHlwZSxkPUMubm9ybWFsaXplQXhpcyh0LmF4aXMsbyksbD1yW2RdLHA9aS5zbGljZSgwKSxtPUMuc2l6ZShwKSx1PUUoXCJpbnB1dFwiLG4sbyksaD1FKFwiaW5kaWNlc0lucHV0XCIsYSxpLmxlbmd0aCksXz1NKFwib3V0cHV0XCIsbixwLmxlbmd0aCkseT1be3R5cGU6MTIsZGF0YTptfSx7dHlwZTo2LGRhdGE6bH0se3R5cGU6MTIsZGF0YTpkfV07cmV0dXJuIHkucHVzaCguLi5OKHIsaSxwKSkse25hbWU6XCJHYXRoZXJFbGVtZW50c1wiLHNoYWRlckNhY2hlOntpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCIsXCJyYW5rXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnAsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKG0vNjQpfSxwcm9ncmFtVW5pZm9ybXM6eX0pLGdldFNoYWRlclNvdXJjZTokPT5gXG4gICAgICAkeyQucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0U2l6ZVwiLFwidTMyXCIpLnJlZ2lzdGVyVW5pZm9ybShcImF4aXNEaW1MaW1pdFwiLFwiaTMyXCIpLnJlZ2lzdGVyVW5pZm9ybShcImF4aXNcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKHUsaCxfKX1cbiAgICAgICR7JC5tYWluU3RhcnQoKX1cbiAgICAgICR7JC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0U2l6ZVwiKX1cblxuICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke18ub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG5cbiAgICAgIHZhciBpZHggPSAke2guZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgIGlmIChpZHggPCAwKSB7XG4gICAgICAgIGlkeCA9IGlkeCArIHVuaWZvcm1zLmF4aXNEaW1MaW1pdDtcbiAgICAgIH1cbiAgICAgIHZhciBpbnB1dEluZGljZXMgPSAke3UudHlwZS5pbmRpY2VzfShvdXRwdXRJbmRpY2VzKTtcbiAgICAgICR7dS5pbmRpY2VzU2V0KFwiaW5wdXRJbmRpY2VzXCIsXCJ1bmlmb3Jtcy5heGlzXCIsXCJ1MzIoaWR4KVwiKX07XG4gICAgICBsZXQgdmFsdWUgPSAke3UuZ2V0QnlJbmRpY2VzKFwiaW5wdXRJbmRpY2VzXCIpfTtcblxuICAgICAgJHtfLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIil9O1xuICB9YH19LEVkPWU9PnJlKHtheGlzOmUuYXhpc30pLFBkPShlLHQpPT57bGV0IHI9ZS5pbnB1dHM7VWYociksZS5jb21wdXRlKE5mKGUuaW5wdXRzLHQpKX19KTt2YXIgVmYsV2YsT2QsRGQsQmQ9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTthZSgpO1ZmPWU9PntpZighZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBpcyBtaXNzaW5nXCIpO2lmKGUubGVuZ3RoPDJ8fGUubGVuZ3RoPjMpdGhyb3cgbmV3IEVycm9yKFwiSW52YWlkIGlucHV0IG51bWJlci5cIik7aWYoZS5sZW5ndGg9PT0zJiZlWzJdLmRpbXMubGVuZ3RoPjIpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCBzaGFwZSBvZiBDXCIpO2lmKGVbMF0uZGF0YVR5cGUhPT1lWzFdLmRhdGFUeXBlfHxlLmxlbmd0aD09PTMmJmVbMF0uZGF0YVR5cGUhPT1lWzJdLmRhdGFUeXBlKXRocm93IG5ldyBFcnJvcihcIklucHV0IHR5cGVzIGFyZSBtaXNtYXRjaGVkXCIpfSxXZj0oZSx0KT0+e2xldCByPWVbMF0uZGltcy5zbGljZSgpLG49ZVsxXS5kaW1zLnNsaWNlKCksW28saSxhXT1Wci5nZXRTaGFwZU9mR2VtbVJlc3VsdChyLHQudHJhbnNBLG4sdC50cmFuc0IsZS5sZW5ndGg9PT0zP2VbMl0uZGltczp2b2lkIDApLGQ9W28saV07aWYoIWQpdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgdXNlIGdlbW0gb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7bGV0IGw9MTYscD1NYXRoLmNlaWwoaS9sKSxtPU1hdGguY2VpbChvL2wpLHU9ITAsaD1DLnNpemUoZCksXz1be3R5cGU6MTIsZGF0YTp1P3A6aH0se3R5cGU6MTIsZGF0YTpvfSx7dHlwZToxMixkYXRhOml9LHt0eXBlOjEyLGRhdGE6YX0se3R5cGU6MSxkYXRhOnQuYWxwaGF9LHt0eXBlOjEsZGF0YTp0LmJldGF9XSx5PVtcInR5cGVcIixcInR5cGVcIl07ZS5sZW5ndGg9PT0zJiYoXy5wdXNoKC4uLk4oZVsyXS5kaW1zKSkseS5wdXNoKFwicmFua1wiKSksXy5wdXNoKC4uLk4oZCkpO2xldCBnPSQ9PntsZXQgdj1cIlwiO3QudHJhbnNBJiZ0LnRyYW5zQj92PVwidmFsdWUgKz0gYVtrICogdW5pZm9ybXMuTSArIG1dICogYltuICogdW5pZm9ybXMuSyArIGtdO1wiOnQudHJhbnNBJiYhdC50cmFuc0I/dj1cInZhbHVlICs9IGFbayAqIHVuaWZvcm1zLk0gKyBtXSAqIGJbayAqIHVuaWZvcm1zLk4gKyBuXTtcIjohdC50cmFuc0EmJnQudHJhbnNCP3Y9XCJ2YWx1ZSArPSBhW20gKiB1bmlmb3Jtcy5LICsga10gKiBiW24gKiB1bmlmb3Jtcy5LICsga107XCI6IXQudHJhbnNBJiYhdC50cmFuc0ImJih2PVwidmFsdWUgKz0gYVttICogdW5pZm9ybXMuSyArIGtdICogYltrICogdW5pZm9ybXMuTiArIG5dO1wiKTtsZXQgUz10LmFscGhhPT09MT9cIlwiOlwidmFsdWUgKj0gdW5pZm9ybXMuYWxwaGE7XCIsVD1FKFwiYVwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zKSxBPUUoXCJiXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMpLGs9VC50eXBlLnZhbHVlLFA9bnVsbCxEPVtULEFdO2UubGVuZ3RoPT09MyYmKFA9RShcImNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcy5sZW5ndGgpLEQucHVzaChQKSk7bGV0IFI9TShcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsZC5sZW5ndGgpO0QucHVzaChSKTtsZXQgRz1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJNXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIk5cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiS1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJhbHBoYVwiLHR5cGU6XCJmMzJcIn0se25hbWU6XCJiZXRhXCIsdHlwZTpcImYzMlwifV07cmV0dXJuYFxuICAkeyQucmVnaXN0ZXJVbmlmb3JtcyhHKS5kZWNsYXJlVmFyaWFibGVzKC4uLkQpfVxuXG4gICR7JC5tYWluU3RhcnQoKX1cbiAgICAkeyQuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuXG4gICAgbGV0IG0gPSBnbG9iYWxfaWR4IC8gdW5pZm9ybXMuTjtcbiAgICBsZXQgbiA9IGdsb2JhbF9pZHggJSB1bmlmb3Jtcy5OO1xuXG4gICAgdmFyIHZhbHVlID0gJHtrfSgwKTtcbiAgICBmb3IgKHZhciBrOiB1MzIgPSAwdTsgayA8IHVuaWZvcm1zLks7IGsrKykge1xuICAgICAgJHt2fVxuICAgIH1cblxuICAgICR7U31cbiAgICAkeygoKT0+UCE9bnVsbD9gbGV0IGNPZmZzZXQgPSAke1AuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoXCJ2ZWMyKG0sIG4pXCIsUil9OyB2YWx1ZSArPSAke2t9KHVuaWZvcm1zLmJldGEpICogJHtQLmdldEJ5T2Zmc2V0KFwiY09mZnNldFwiKX07YDpcIlwiKSgpfVxuICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHZhbHVlO1xuICB9YH0seD0kPT57bGV0IHY9RShcImFcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcyksUz1FKFwiYlwiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zKSxUPW51bGwsQT1bdixTXTtlLmxlbmd0aD09PTMmJihUPUUoXCJjXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMubGVuZ3RoKSxBLnB1c2goVCkpO2xldCBrPU0oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLGQubGVuZ3RoKTtBLnB1c2goayk7bGV0IFA9W3tuYW1lOlwibnVtX3RpbGVfblwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJNXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIk5cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiS1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJhbHBoYVwiLHR5cGU6XCJmMzJcIn0se25hbWU6XCJiZXRhXCIsdHlwZTpcImYzMlwifV0sRD1cIlwiLFI9XCJcIjt0LnRyYW5zQSYmdC50cmFuc0I/KFI9YFxuICAgICAgdmFyIGNvbCA9IHRpbGVfcm93X3N0YXJ0ICsgbG9jYWxfaWQueDtcbiAgICAgIHZhciByb3cgPSBrX3N0YXJ0ICsgbG9jYWxfaWQueTtcbiAgICAgIGlmIChjb2wgPCB1bmlmb3Jtcy5NICYmIHJvdyA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdGlsZV9hW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gYVtyb3cgKiB1bmlmb3Jtcy5NICsgY29sXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbGVfYVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9ICR7di50eXBlLnZhbHVlfSgwKTtcbiAgICAgIH1cblxuICAgICAgY29sID0ga19zdGFydCArIGxvY2FsX2lkLng7XG4gICAgICByb3cgPSB0aWxlX2NvbF9zdGFydCArIGxvY2FsX2lkLnk7XG4gICAgICBpZiAoY29sIDwgdW5pZm9ybXMuSyAmJiByb3cgPCB1bmlmb3Jtcy5OKSB7XG4gICAgICAgIHRpbGVfYltsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9IGJbcm93ICogdW5pZm9ybXMuSyArIGNvbF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWxlX2JbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke1MudHlwZS52YWx1ZX0oMCk7XG4gICAgICB9XG4gICAgICBgLEQ9XCJ2YWx1ZSArPSB0aWxlX2Fba11bbG9jYWxfaWQueV0gKiB0aWxlX2JbbG9jYWxfaWQueF1ba107XCIpOnQudHJhbnNBJiYhdC50cmFuc0I/KFI9YFxuICAgICAgdmFyIGNvbCA9IHRpbGVfcm93X3N0YXJ0ICsgbG9jYWxfaWQueDtcbiAgICAgIHZhciByb3cgPSBrX3N0YXJ0ICsgbG9jYWxfaWQueTtcbiAgICAgIGlmIChjb2wgPCB1bmlmb3Jtcy5NICYmIHJvdyA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdGlsZV9hW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gYVtyb3cgKiB1bmlmb3Jtcy5NICsgY29sXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbGVfYVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9ICR7di50eXBlLnZhbHVlfSgwKTtcbiAgICAgIH1cblxuICAgICAgY29sID0gdGlsZV9jb2xfc3RhcnQgKyBsb2NhbF9pZC54O1xuICAgICAgcm93ID0ga19zdGFydCArIGxvY2FsX2lkLnk7XG4gICAgICBpZiAoY29sIDwgdW5pZm9ybXMuTiAmJiByb3cgPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIHRpbGVfYltsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9IGJbcm93ICogdW5pZm9ybXMuTiArIGNvbF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWxlX2JbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke1MudHlwZS52YWx1ZX0oMCk7XG4gICAgICB9XG4gICAgICBgLEQ9XCJ2YWx1ZSArPSB0aWxlX2Fba11bbG9jYWxfaWQueV0gKiB0aWxlX2Jba11bbG9jYWxfaWQueF07XCIpOiF0LnRyYW5zQSYmdC50cmFuc0I/KFI9YFxuICAgICAgdmFyIGNvbCA9IGtfc3RhcnQgKyBsb2NhbF9pZC54O1xuICAgICAgdmFyIHJvdyA9IHRpbGVfcm93X3N0YXJ0ICsgbG9jYWxfaWQueTtcbiAgICAgIGlmIChjb2wgPCB1bmlmb3Jtcy5LICYmIHJvdyA8IHVuaWZvcm1zLk0pIHtcbiAgICAgICAgdGlsZV9hW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gYVtyb3cgKiB1bmlmb3Jtcy5LICsgY29sXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbGVfYVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9ICR7di50eXBlLnZhbHVlfSgwKTtcbiAgICAgIH1cblxuICAgICAgY29sID0ga19zdGFydCArIGxvY2FsX2lkLng7XG4gICAgICByb3cgPSB0aWxlX2NvbF9zdGFydCArIGxvY2FsX2lkLnk7XG4gICAgICBpZiAoY29sIDwgdW5pZm9ybXMuSyAmJiByb3cgPCB1bmlmb3Jtcy5OKSB7XG4gICAgICAgIHRpbGVfYltsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9IGJbcm93ICogdW5pZm9ybXMuSyArIGNvbF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWxlX2JbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke1MudHlwZS52YWx1ZX0oMCk7XG4gICAgICB9XG4gICAgICBgLEQ9XCJ2YWx1ZSArPSB0aWxlX2FbbG9jYWxfaWQueV1ba10gKiB0aWxlX2JbbG9jYWxfaWQueF1ba107XCIpOiF0LnRyYW5zQSYmIXQudHJhbnNCJiYoUj1gXG4gICAgICB2YXIgY29sID0ga19zdGFydCArIGxvY2FsX2lkLng7XG4gICAgICB2YXIgcm93ID0gdGlsZV9yb3dfc3RhcnQgKyBsb2NhbF9pZC55O1xuICAgICAgaWYgKGNvbCA8IHVuaWZvcm1zLksgJiYgcm93IDwgdW5pZm9ybXMuTSkge1xuICAgICAgICB0aWxlX2FbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSBhW3JvdyAqIHVuaWZvcm1zLksgKyBjb2xdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGlsZV9hW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gJHt2LnR5cGUudmFsdWV9KDApO1xuICAgICAgfVxuXG4gICAgICBjb2wgPSB0aWxlX2NvbF9zdGFydCArIGxvY2FsX2lkLng7XG4gICAgICByb3cgPSBrX3N0YXJ0ICsgbG9jYWxfaWQueTtcbiAgICAgIGlmIChjb2wgPCB1bmlmb3Jtcy5OICYmIHJvdyA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdGlsZV9iW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gYltyb3cgKiB1bmlmb3Jtcy5OICsgY29sXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbGVfYltsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9ICR7Uy50eXBlLnZhbHVlfSgwKTtcbiAgICAgIH1cbiAgICAgIGAsRD1cInZhbHVlICs9IHRpbGVfYVtsb2NhbF9pZC55XVtrXSAqIHRpbGVfYltrXVtsb2NhbF9pZC54XTtcIik7bGV0IEc9dC5hbHBoYT09PTE/XCJcIjpcInZhbHVlICo9IHVuaWZvcm1zLmFscGhhO1wiO3JldHVybmBcbiAgJHskLnJlZ2lzdGVyVW5pZm9ybXMoUCkuZGVjbGFyZVZhcmlhYmxlcyguLi5BKX1cbiAgdmFyPHdvcmtncm91cD4gdGlsZV9hOiBhcnJheTxhcnJheTwke3YudHlwZS5zdG9yYWdlfSwgJHtsfT4sICR7bH0+O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlX2I6IGFycmF5PGFycmF5PCR7Uy50eXBlLnN0b3JhZ2V9LCAke2x9PiwgJHtsfT47XG4gICR7JC5tYWluU3RhcnQoW2wsbCwxXSl9XG4gICAgbGV0IHRpbGVfY29sX3N0YXJ0ID0gKHdvcmtncm91cF9pbmRleCAlIHVuaWZvcm1zLm51bV90aWxlX24pICogJHtsfTtcbiAgICBsZXQgdGlsZV9yb3dfc3RhcnQgPSAod29ya2dyb3VwX2luZGV4IC8gdW5pZm9ybXMubnVtX3RpbGVfbikgKiAke2x9O1xuICAgIGxldCBudW1fdGlsZXMgPSAodW5pZm9ybXMuSyAtIDEpIC8gJHtsfSArIDE7XG4gICAgdmFyIGtfc3RhcnQgPSAwdTtcbiAgICB2YXIgdmFsdWUgPSAke2sudHlwZS52YWx1ZX0oMCk7XG4gICAgZm9yICh2YXIgdDogdTMyID0gMHU7IHQgPCBudW1fdGlsZXM7IHQrKykge1xuICAgICAgJHtSfVxuICAgICAga19zdGFydCA9IGtfc3RhcnQgKyAke2x9O1xuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICBmb3IgKHZhciBrOiB1MzIgPSAwdTsgayA8ICR7bH07IGsrKykge1xuICAgICAgICAke0R9XG4gICAgICB9XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgfVxuXG4gICAgJHtHfVxuICAgIGxldCBtID0gdGlsZV9yb3dfc3RhcnQgKyBsb2NhbF9pZC55O1xuICAgIGxldCBuID0gdGlsZV9jb2xfc3RhcnQgKyBsb2NhbF9pZC54O1xuICAgICR7KCgpPT5UIT1udWxsP2BsZXQgY09mZnNldCA9ICR7VC5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChcInZlYzIobSwgbilcIixrKX07IHZhbHVlICs9ICR7ay50eXBlLnZhbHVlfSh1bmlmb3Jtcy5iZXRhKSAqICR7VC5nZXRCeU9mZnNldChcImNPZmZzZXRcIil9O2A6XCJcIikoKX1cbiAgICBpZiAobSA8IHVuaWZvcm1zLk0gJiYgbiA8IHVuaWZvcm1zLk4pIHtcbiAgICAgIG91dHB1dFttICogdW5pZm9ybXMuTiArIG5dID0gdmFsdWU7XG4gICAgfVxuICB9YH07cmV0dXJuIHU/e25hbWU6XCJHZW1tU2hhcmVkXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5jYWNoZUtleX1gLGlucHV0RGVwZW5kZW5jaWVzOnl9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6ZCxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpwKm19LHByb2dyYW1Vbmlmb3JtczpffSksZ2V0U2hhZGVyU291cmNlOnh9OntuYW1lOlwiR2VtbVwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9YCxpbnB1dERlcGVuZGVuY2llczp5fSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmQsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGgvNjQpfSxwcm9ncmFtVW5pZm9ybXM6X30pLGdldFNoYWRlclNvdXJjZTpnfX0sT2Q9ZT0+e2xldCB0PWUudHJhbnNBLHI9ZS50cmFuc0Isbj1lLmFscGhhLG89ZS5iZXRhO3JldHVybnt0cmFuc0E6dCx0cmFuc0I6cixhbHBoYTpuLGJldGE6byxjYWNoZUtleTpgJHtlLnRyYW5zQX07JHtlLnRyYW5zQn07JHtlLmFscGhhPT09MX1gfX0sRGQ9KGUsdCk9PntWZihlLmlucHV0cyksZS5jb21wdXRlKFdmKGUuaW5wdXRzLHQpKX19KTt2YXIgbHQsX3QsVXQsTnQsTGYsR2YsSGYsRmYscWYsS2YsamYsWWYsTWQsUmQsVWQ9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTtTZSgpO2FlKCk7W2x0LF90LFV0LE50XT1bMCwxLDIsM10sTGY9ZT0+e2lmKGVbMF0uZGltcy5sZW5ndGghPT00KXRocm93IG5ldyBFcnJvcihcIm9ubHkgNC1EIHRlbnNvciBpcyBzdXBwb3J0ZWQuXCIpO2lmKGVbMF0uZGltcy5sZW5ndGghPT1lWzFdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImlucHV0IGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCB0byBncmlkIGRpbWVuc2lvbnNcIik7aWYoZVswXS5kaW1zLmxlbmd0aC0yIT09ZVsxXS5kaW1zW2VbMV0uZGltcy5sZW5ndGgtMV0pdGhyb3cgbmV3IEVycm9yKGBsYXN0IGRpbWVuc2lvbiBvZiBncmlkIG11c3QgYmUgZXF1YWwgdG8gJHtlWzBdLmRpbXMubGVuZ3RoLTJ9YCk7aWYoZVswXS5kaW1zWzBdIT09ZVsxXS5kaW1zWzBdKXRocm93IG5ldyBFcnJvcihcImdyaWQgYmF0Y2ggc2l6ZSBtdXN0IG1hdGNoIGlucHV0IGJhdGNoIHNpemVcIil9LEdmPWBcbiAgZm4gZ3NfZ2V0X2N1YmljX2NvZWZmcyh4OiBmMzIpIC0+IHZlYzQ8ZjMyPiB7XG4gICAgbGV0IGN1YmljX2FscGhhID0gLTAuNzVmO1xuICAgIGxldCB4X2FicyA9IGFicyh4KTtcbiAgICB2YXIgY29lZmZzOiB2ZWM0PGYzMj47XG4gICAgY29lZmZzWzBdID0gKCgoY3ViaWNfYWxwaGEgKiAoeF9hYnMgKyAxKSAtIDUgKiBjdWJpY19hbHBoYSkgKiAoeF9hYnMgKyAxKSArIDggKiBjdWJpY19hbHBoYSkgKiAoeF9hYnMgKyAxKSAtIDQgKiBjdWJpY19hbHBoYSk7XG4gICAgY29lZmZzWzFdID0gKCgoY3ViaWNfYWxwaGEgKyAyKSAqIHhfYWJzIC0gKGN1YmljX2FscGhhICsgMykpICogeF9hYnMgKiB4X2FicyArIDEpO1xuICAgIGNvZWZmc1syXSA9ICgoKGN1YmljX2FscGhhICsgMikgKiAoMSAtIHhfYWJzKSAtIChjdWJpY19hbHBoYSArIDMpKSAqICgxIC0geF9hYnMpICogKDEgLSB4X2FicykgKyAxKTtcbiAgICBjb2VmZnNbM10gPSAoKChjdWJpY19hbHBoYSAqICgyIC0geF9hYnMpIC0gNSAqIGN1YmljX2FscGhhKSAqICgyIC0geF9hYnMpICsgOCAqIGN1YmljX2FscGhhKSAqICgyIC0geF9hYnMpIC0gNCAqIGN1YmljX2FscGhhKTtcbiAgICByZXR1cm4gY29lZmZzO1xuICB9XG5gLEhmPWU9PmBcbiAgZm4gZ3NfYmljdWJpY19pbnRlcnBvbGF0ZShwOiBtYXQ0eDQ8JHtlfT4sIHg6IGYzMiwgeTogZjMyKSAtPiAke2V9IHtcbiAgICB2YXIgdjogdmVjNDxmMzI+O1xuICAgIHZhciBjb2VmZnMgPSBnc19nZXRfY3ViaWNfY29lZmZzKHgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICB2W2ldID0gY29lZmZzWzBdICogcFtpXVswXSArIGNvZWZmc1sxXSAqIHBbaV1bMV0gKyBjb2VmZnNbMl0gKiBwW2ldWzJdICsgY29lZmZzWzNdICogcFtpXVszXTtcbiAgICB9XG4gICAgY29lZmZzID0gZ3NfZ2V0X2N1YmljX2NvZWZmcyh5KTtcbiAgICBsZXQgcGl4ZWwgPSAke2V9KGNvZWZmc1swXSAqIHZbMF0gKyBjb2VmZnNbMV0gKiB2WzFdICsgY29lZmZzWzJdICogdlsyXSArIGNvZWZmc1szXSAqIHZbM10pO1xuICAgIHJldHVybiBwaXhlbDtcbiAgfVxuYCxGZj1lPT5gXG4gIGZuIGdzX2Rlbm9ybWFsaXplKG46IGYzMiwgbGVuZ3RoOiBpMzIpIC0+IGYzMiB7XG4gICAgJHtlLmFsaWduQ29ybmVycz09PTA/YFxuICAgIC8vIGFsaWduQ29ybmVyczogZmFsc2UgPT4gWy0xLCAxXSB0byBbLTAuNSwgbGVuZ3RoIC0gMC41XVxuICAgIHJldHVybiAoKG4gKyAxLjApICogZjMyKGxlbmd0aCkgLSAxLjApIC8gMi4wO1xuICAgIGA6YFxuICAgIC8vIGFsaWduQ29ybmVyczogdHJ1ZSA9PiBbLTEsIDFdIHRvIFswLCBsZW5ndGggLSAxXVxuICAgIHJldHVybiAobiArIDEuMCkgLyAyLjAgKiAoZjMyKGxlbmd0aCAtIDEpKTtcbiAgICBgfVxuICB9XG5gLHFmPWU9PmBcbiAgJHtlLnBhZGRpbmdNb2RlPT09XCJyZWZsZWN0aW9uXCI/YFxuICAgICAgZm4gZ3NfcmVmbGVjdCh4OiBpMzIsIHhfbWluOiBmMzIsIHhfbWF4OiBmMzIpIC0+IHUzMiB7XG4gICAgICAgIHZhciBkeCA9IDAuMDtcbiAgICAgICAgdmFyIGZ4ID0gZjMyKHgpO1xuICAgICAgICBsZXQgcmFuZ2UgPSB4X21heCAtIHhfbWluO1xuICAgICAgICBpZiAoZnggPCB4X21pbikge1xuICAgICAgICAgIGR4ID0geF9taW4gLSBmeDtcbiAgICAgICAgICBsZXQgbiA9IHUzMihkeCAvIHJhbmdlKTtcbiAgICAgICAgICBsZXQgciA9IGR4IC0gZjMyKG4pICogcmFuZ2U7XG4gICAgICAgICAgaWYgKG4gJSAyID09IDApIHtcbiAgICAgICAgICAgIGZ4ID0geF9taW4gKyByO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmeCA9IHhfbWF4IC0gcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZnggPiB4X21heCkge1xuICAgICAgICAgIGR4ID0gZnggLSB4X21heDtcbiAgICAgICAgICBsZXQgbiA9IHUzMihkeCAvIHJhbmdlKTtcbiAgICAgICAgICBsZXQgciA9IGR4IC0gZjMyKG4pICogcmFuZ2U7XG4gICAgICAgICAgaWYgKG4gJSAyID09IDApIHtcbiAgICAgICAgICAgIGZ4ID0geF9tYXggLSByO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmeCA9IHhfbWluICsgcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHUzMihmeCk7XG4gICAgICB9YDpcIlwifVxuYCxLZj0oZSx0LHIpPT5gXG4gIGZuIHBpeGVsX2F0X2dyaWQocjogaTMyLCBjOiBpMzIsIEg6IGkzMiwgVzogaTMyLCBiYXRjaDogdTMyLCBjaGFubmVsOiB1MzIsIGJvcmRlcjogdmVjNDxmMzI+KSAtPiAke3R9IHtcbiAgICAgdmFyIHBpeGVsID0gJHt0fSgwKTtcbiAgICAgdmFyIGluZGljZXMgPSB2ZWM0PHUzMj4oMCk7XG4gICAgIGluZGljZXNbJHtsdH1dID0gYmF0Y2g7XG4gICAgIGluZGljZXNbJHtfdH1dID0gY2hhbm5lbDtgKygoKT0+e3N3aXRjaChyLnBhZGRpbmdNb2RlKXtjYXNlXCJ6ZXJvc1wiOnJldHVybmBcbiAgICAgICAgICBpZiAociA+PSAwICYmIHIgPCBIICYmIGMgPj0wICYmIGMgPCBXKSB7XG4gICAgICAgICAgICBpbmRpY2VzWyR7VXR9XSA9IHUzMihyKTtcbiAgICAgICAgICAgIGluZGljZXNbJHtOdH1dID0gdTMyKGMpO1xuICAgICAgICAgIH1cbiAgICAgICAgYDtjYXNlXCJib3JkZXJcIjpyZXR1cm5gXG4gICAgICAgICAgaW5kaWNlc1ske1V0fV0gPSB1MzIoY2xhbXAociwgMCwgSCAtIDEpKTtcbiAgICAgICAgICBpbmRpY2VzWyR7TnR9XSA9IHUzMihjbGFtcChjLCAwLCBXIC0gMSkpO1xuICAgICAgICBgO2Nhc2VcInJlZmxlY3Rpb25cIjpyZXR1cm5gXG4gICAgICAgICAgaW5kaWNlc1ske1V0fV0gPSBnc19yZWZsZWN0KHIsIGJvcmRlclsxXSwgYm9yZGVyWzNdKTtcbiAgICAgICAgICBpbmRpY2VzWyR7TnR9XSA9IGdzX3JlZmxlY3QoYywgYm9yZGVyWzBdLCBib3JkZXJbMl0pO1xuICAgICAgICBgO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBwYWRkaW5nIG1vZGUgJHtyLnBhZGRpbmdNb2RlfSBpcyBub3Qgc3VwcG9ydGVkYCl9fSkoKStgXG4gICAgcmV0dXJuICR7ZS5nZXRCeUluZGljZXMoXCJpbmRpY2VzXCIpfTtcbiAgfVxuYCxqZj0oZSx0LHIpPT4oKCk9Pntzd2l0Y2goci5tb2RlKXtjYXNlXCJuZWFyZXN0XCI6cmV0dXJuYFxuICAgICAgICAgIGxldCByZXN1bHQgPSBwaXhlbF9hdF9ncmlkKGkzMihyb3VuZCh5KSksIGkzMihyb3VuZCh4KSksIEhfaW4sIFdfaW4sIGluZGljZXNbJHtsdH1dLCBpbmRpY2VzWyR7X3R9XSwgYm9yZGVyKTtcbiAgICAgICAgYDtjYXNlXCJiaWxpbmVhclwiOnJldHVybmBcbiAgICAgICAgICBsZXQgeDEgPSBpMzIoZmxvb3IoeCkpO1xuICAgICAgICAgIGxldCB5MSA9IGkzMihmbG9vcih5KSk7XG4gICAgICAgICAgbGV0IHgyID0geDEgKyAxO1xuICAgICAgICAgIGxldCB5MiA9IHkxICsgMTtcblxuICAgICAgICAgIGxldCBwMTEgPSBwaXhlbF9hdF9ncmlkKHkxLCB4MSwgSF9pbiwgV19pbiwgaW5kaWNlc1ske2x0fV0sIGluZGljZXNbJHtfdH1dLCBib3JkZXIpO1xuICAgICAgICAgIGxldCBwMTIgPSBwaXhlbF9hdF9ncmlkKHkxLCB4MiwgSF9pbiwgV19pbiwgaW5kaWNlc1ske2x0fV0sIGluZGljZXNbJHtfdH1dLCBib3JkZXIpO1xuICAgICAgICAgIGxldCBwMjEgPSBwaXhlbF9hdF9ncmlkKHkyLCB4MSwgSF9pbiwgV19pbiwgaW5kaWNlc1ske2x0fV0sIGluZGljZXNbJHtfdH1dLCBib3JkZXIpO1xuICAgICAgICAgIGxldCBwMjIgPSBwaXhlbF9hdF9ncmlkKHkyLCB4MiwgSF9pbiwgV19pbiwgaW5kaWNlc1ske2x0fV0sIGluZGljZXNbJHtfdH1dLCBib3JkZXIpO1xuXG4gICAgICAgICAgbGV0IGR4MiA9ICR7dH0oZjMyKHgyKSAtIHgpO1xuICAgICAgICAgIGxldCBkeDEgPSAke3R9KHggLSBmMzIoeDEpKTtcbiAgICAgICAgICBsZXQgZHkyID0gJHt0fShmMzIoeTIpIC0geSk7XG4gICAgICAgICAgbGV0IGR5MSA9ICR7dH0oeSAtIGYzMih5MSkpO1xuICAgICAgICAgIGxldCByZXN1bHQgPSBkeTIgKiAoZHgyICogcDExICsgZHgxICogcDEyKSArIGR5MSAqIChkeDIgKiBwMjEgKyBkeDEgKiBwMjIpO1xuICAgICAgICBgO2Nhc2VcImJpY3ViaWNcIjpyZXR1cm5gXG4gICAgICAgICAgbGV0IHgwID0gaTMyKGZsb29yKHgpKSAtIDE7XG4gICAgICAgICAgbGV0IHkwID0gaTMyKGZsb29yKHkpKSAtIDE7XG4gICAgICAgICAgdmFyIHA6IG1hdDR4NDwke3R9PjtcbiAgICAgICAgICBmb3IgKHZhciBoID0gMDsgaCA8IDQ7IGgrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgdyA9IDA7IHcgPCA0OyB3KyspIHtcbiAgICAgICAgICAgICAgcFtoXVt3XSA9IHBpeGVsX2F0X2dyaWQoaCArIHkwLCB3ICsgeDAsIEhfaW4sIFdfaW4sIGluZGljZXNbJHtsdH1dLCBpbmRpY2VzWyR7X3R9XSwgYm9yZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsZXQgZHggPSB4IC0gZjMyKHgwICsgMSk7XG4gICAgICAgICAgbGV0IGR5ID0geSAtIGYzMih5MCArIDEpO1xuICAgICAgICAgIGxldCByZXN1bHQgPSBnc19iaWN1YmljX2ludGVycG9sYXRlKHAsIGR4LCBkeSk7XG4gICAgICAgIGA7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYG1vZGUgJHtyLm1vZGV9IGlzIG5vdCBzdXBwb3J0ZWRgKX19KSgpK2Ake2Uuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJyZXN1bHRcIil9YCxZZj0oZSx0KT0+e2xldCByPUUoXCJ4XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMubGVuZ3RoKSxuPVtlWzFdLmRpbXNbMF0sZVsxXS5kaW1zWzFdLGVbMV0uZGltc1syXV0sbz1FKFwiZ3JpZFwiLGVbMV0uZGF0YVR5cGUsbi5sZW5ndGgsMiksaT1bZVswXS5kaW1zWzBdLGVbMF0uZGltc1sxXSxlWzFdLmRpbXNbMV0sZVsxXS5kaW1zWzJdXTt0LmZvcm1hdD09PVwiTkhXQ1wiJiYoaT1bZVswXS5kaW1zWzBdLGVbMV0uZGltc1sxXSxlWzFdLmRpbXNbMl0sZVswXS5kaW1zWzNdXSxbbHQsX3QsVXQsTnRdPVswLDMsMSwyXSk7bGV0IGE9TShcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsaS5sZW5ndGgpLGQ9ci50eXBlLnZhbHVlLGw9Qy5zaXplKGkpLHA9W3t0eXBlOjEyLGRhdGE6bH0sLi4uTihlWzBdLmRpbXMsbixpKV0sbT11PT5gXG4gICR7dS5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMocixvLGEpfVxuICAke0dmfVxuICAke0hmKGQpfVxuICAke0ZmKHQpfVxuICAke3FmKHQpfVxuICAke0tmKHIsZCx0KX1cblxuICAke3UubWFpblN0YXJ0KCl9XG4gICAgJHt1Lmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICAgIGxldCBIX2luID0gaTMyKHVuaWZvcm1zLnhfc2hhcGVbJHtVdH1dKTtcbiAgICAgIGxldCBXX2luID0gaTMyKHVuaWZvcm1zLnhfc2hhcGVbJHtOdH1dKTtcblxuICAgICAgJHt0LmFsaWduQ29ybmVycz09PTA/YFxuICAgICAgbGV0IHhfbWluID0gLTAuNTtcbiAgICAgIGxldCB4X21heCA9IGYzMihXX2luKSAtIDAuNTtcbiAgICAgIGxldCB5X21pbiA9IC0wLjU7XG4gICAgICBsZXQgeV9tYXggPSBmMzIoSF9pbikgLSAwLjU7XG4gICAgICBgOmBcbiAgICAgIGxldCB4X21pbiA9IDAuMDtcbiAgICAgIGxldCB4X21heCA9IGYzMihXX2luKSAtIDEuMDtcbiAgICAgIGxldCB5X21pbiA9IDAuMDtcbiAgICAgIGxldCB5X21heCA9IGYzMihIX2luKSAtIDEuMDtcbiAgICAgIGB9O1xuICAgICAgbGV0IGJvcmRlciA9IHZlYzQ8ZjMyPih4X21pbiwgeV9taW4sIHhfbWF4LCB5X21heCk7XG5cbiAgICAgIGxldCBpbmRpY2VzID0gJHthLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgdmFyIGdyaWRfaW5kaWNlcyA9IHZlYzM8dTMyPihpbmRpY2VzWyR7bHR9XSwgaW5kaWNlc1ske1V0fV0sIGluZGljZXNbJHtOdH1dKTtcbiAgICAgIGxldCBueHkgPSAke28uZ2V0QnlJbmRpY2VzKFwiZ3JpZF9pbmRpY2VzXCIpfTtcbiAgICAgIHZhciB4ID0gZ3NfZGVub3JtYWxpemUoZjMyKG54eVswXSksIFdfaW4pO1xuICAgICAgdmFyIHkgPSBnc19kZW5vcm1hbGl6ZShmMzIobnh5WzFdKSwgSF9pbik7XG5cbiAgICAgICR7amYoYSxkLHQpfVxuICB9YDtyZXR1cm57bmFtZTpcIkdyaWRTYW1wbGVcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmNhY2hlS2V5fWAsaW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiLFwidHlwZVwiXX0sZ2V0UnVuRGF0YTp1PT57bGV0IGg9Qy5zaXplKGkpO3JldHVybntvdXRwdXRzOlt7ZGltczppLGRhdGFUeXBlOnVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChoLzY0KX0scHJvZ3JhbVVuaWZvcm1zOnB9fSxnZXRTaGFkZXJTb3VyY2U6bX19LE1kPShlLHQpPT57TGYoZS5pbnB1dHMpLGUuY29tcHV0ZShZZihlLmlucHV0cyx0KSl9LFJkPWU9PnJlKHthbGlnbkNvcm5lcnM6ZS5hbGlnbl9jb3JuZXJzLG1vZGU6ZS5tb2RlLHBhZGRpbmdNb2RlOmUucGFkZGluZ19tb2RlLGZvcm1hdDplLmZvcm1hdH0pfSk7dmFyIEJlLFhmLFZkLE5kLEpmLHRyLFdkLFNvPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7U2UoKTtOcigpO0ZyKCk7YWUoKTtkdCgpO0JlPShlLHQpPT5lLmxlbmd0aD50JiZlW3RdLmRpbXMubGVuZ3RoPjA/ZVt0XTp2b2lkIDAsWGY9KGUsdCk9PntsZXQgcj1lWzBdLG49QmUoZSwxKSxvPUJlKGUsMiksaT1CZShlLDMpLGE9QmUoZSw0KSxkPUJlKGUsNSksbD1CZShlLDYpLHA9QmUoZSw3KTtpZihyLmRpbXMubGVuZ3RoIT09MyYmci5kaW1zLmxlbmd0aCE9PTUpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgcXVlcnkgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIG9yIDUgZGltZW5zaW9uc1wiKTtsZXQgbT1yLmRpbXNbMF0sdT1yLmRpbXNbMV0saD1yLmRpbXMubGVuZ3RoPT09Mz9yLmRpbXNbMl06dC5udW1IZWFkcypyLmRpbXNbNF0sXz11LHk9MCxnPTAseD1NYXRoLmZsb29yKGgvdC5udW1IZWFkcyk7aWYobCYmcCYmQy5zaXplKGwuZGltcykmJkMuc2l6ZShwLmRpbXMpKXtpZihsLmRpbXMubGVuZ3RoIT09NCl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBpcyBleHBlY3RlZCB0byBoYXZlIDQgZGltZW5zaW9ucycpO2lmKGwuZGltc1swXSE9PW18fGwuZGltc1sxXSE9PXQubnVtSGVhZHN8fGwuZGltc1szXSE9PXgpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3Rfa2V5XCIgc2hhcGUgKGJhdGNoX3NpemUsIG51bV9oZWFkcywgcGFzdF9zZXF1ZW5jZV9sZW5ndGgsIGhlYWRfc2l6ZSknKTtpZihwLmRpbXNbMF0hPT1tfHxwLmRpbXNbMV0hPT10Lm51bUhlYWRzfHxwLmRpbXNbM10hPT14KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X3ZhbHVlXCIgc2hhcGUgKGJhdGNoX3NpemUsIG51bV9oZWFkcywgcGFzdF9zZXF1ZW5jZV9sZW5ndGgsIGhlYWRfc2l6ZSknKTtpZihsLmRpbXNbMl0hPT1wLmRpbXNbMl0pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3Rfa2V5XCIgYW5kIFwicGFzdF92YWx1ZVwiIHNoYWxsIGhhdmUgc2FtZSBkaW0gMiAocGFzdF9zZXF1ZW5jZV9sZW5ndGgpJyk7aWYocC5kaW1zLmxlbmd0aCE9PTQpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RfdmFsdWVcIiBpcyBleHBlY3RlZCB0byBoYXZlIDQgZGltZW5zaW9ucycpO3k9bC5kaW1zWzJdLGc9bC5kaW1zWzJdfWVsc2UgaWYobCYmQy5zaXplKGwuZGltcyl8fHAmJkMuc2l6ZShwLmRpbXMpKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIGFuZCBcInBhc3RfdmFsdWVcIiBzaGFsbCBiZSBib3RoIHByZXNlbnQgb3IgYm90aCBhYnNlbnQnKTtsZXQgJDtpZihuJiZDLnNpemUobi5kaW1zKT4wKXtpZihyLmRpbXMubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBpcyBleHBlY3RlZCB0byBoYXZlIDMgZGltZW5zaW9ucyB3aGVuIGtleSBpcyBnaXZlbicpO2lmKG4uZGltcy5sZW5ndGg8M3x8bi5kaW1zLmxlbmd0aD41KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJrZXlcIiBpcyBleHBlY3RlZCB0byBoYXZlIDMsIDQsIG9yIDUgZGltZW5zaW9ucycpO2lmKHIuZGltc1swXSE9PW4uZGltc1swXSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBhbmQgXCJrZXlcIiBzaGFsbCBoYXZlIHNhbWUgZGltIDAgKGJhdGNoIHNpemUpJyk7aWYobi5kaW1zLmxlbmd0aD09PTMpe2lmKG4uZGltc1syXSE9PXIuZGltc1syXSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBhbmQgXCJrZXlcIiBzaGFsbCBoYXZlIHNhbWUgZGltIDIgKGhpZGRlbl9zaXplKScpOyQ9MixfPW4uZGltc1sxXX1lbHNlIGlmKG4uZGltcy5sZW5ndGg9PT01KXtpZihuLmRpbXNbMl0hPT10Lm51bUhlYWRzfHxuLmRpbXNbM10hPT0yfHxuLmRpbXNbNF0hPT14KXRocm93IG5ldyBFcnJvcignRXhwZWN0IFwia2V5XCIgc2hhcGUgKGJhdGNoX3NpemUsIGt2X3NlcXVlbmNlX2xlbmd0aCwgbnVtX2hlYWRzLCAyLCBoZWFkX3NpemUpIGZvciBwYWNrZWQga3YnKTtpZihvKXRocm93IG5ldyBFcnJvcignRXhwZWN0IFwidmFsdWVcIiBiZSBub25lIHdoZW4gXCJrZXlcIiBoYXMgcGFja2VkIGt2IGZvcm1hdC4nKTskPTUsXz1uLmRpbXNbMV19ZWxzZXtpZihuLmRpbXNbMV0hPT10Lm51bUhlYWRzfHxuLmRpbXNbM10hPT14KXRocm93IG5ldyBFcnJvcignRXhwZWN0IFwia2V5XCIgc2hhcGUgKGJhdGNoX3NpemUsIG51bV9oZWFkcywga3Zfc2VxdWVuY2VfbGVuZ3RoLCBoZWFkX3NpemUpIGZvciBwYXN0X2tleScpOyQ9MCxfPW4uZGltc1syXX19ZWxzZXtpZihyLmRpbXMubGVuZ3RoIT09NSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBpcyBleHBlY3RlZCB0byBoYXZlIDUgZGltZW5zaW9ucyB3aGVuIGtleSBpcyBlbXB0eScpO2lmKHIuZGltc1syXSE9PXQubnVtSGVhZHN8fHIuZGltc1szXSE9PTMpdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJxdWVyeVwiIHNoYXBlIChiYXRjaF9zaXplLCBrdl9zZXF1ZW5jZV9sZW5ndGgsIG51bV9oZWFkcywgMywgaGVhZF9zaXplKSBmb3IgcGFja2VkIGt2Jyk7JD0zfWlmKGkmJkMuc2l6ZShpLmRpbXMpPjApe2lmKGkuZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJiaWFzXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAxIGRpbWVuc2lvbicpO2lmKG4mJm4uZGltcy5sZW5ndGg9PT01JiZuLmRpbXNbM109PT0yKXRocm93IG5ldyBFcnJvcihcImJpYXMgaXMgbm90IGFsbG93ZWQgZm9yIHBhY2tlZCBrdi5cIil9bGV0IHY9eStfLFM9MDtpZihhJiZDLnNpemUoYS5kaW1zKT4wKXtTPTg7bGV0IFA9YS5kaW1zO3Rocm93IFAubGVuZ3RoPT09MT9QWzBdPT09bT9TPTE6UFswXT09PTMqbSsyJiYoUz0zKTpQLmxlbmd0aD09PTImJlBbMF09PT1tJiZQWzFdPT09diYmKFM9NSksUz09PTg/bmV3IEVycm9yKCdJbnB1dCBcImtleV9wYWRkaW5nX21hc2tcIiBzaGFwZSBzaGFsbCBiZSAoYmF0Y2hfc2l6ZSkgb3IgKGJhdGNoX3NpemUsIHRvdGFsX3NlcXVlbmNlX2xlbmd0aCknKTpuZXcgRXJyb3IoXCJNYXNrIG5vdCBzdXBwb3J0ZWRcIil9bGV0IFQ9ITEsQT1oO2lmKG8mJkMuc2l6ZShvLmRpbXMpPjApe2lmKG8uZGltcy5sZW5ndGghPT0zJiZvLmRpbXMubGVuZ3RoIT09NCl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwidmFsdWVcIiBpcyBleHBlY3RlZCB0byBoYXZlIDMgb3IgNCBkaW1lbnNpb25zJyk7aWYoci5kaW1zWzBdIT09by5kaW1zWzBdKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGFuZCBcInZhbHVlXCIgc2hhbGwgaGF2ZSBzYW1lIGRpbSAwIChiYXRjaF9zaXplKScpO2lmKG8uZGltcy5sZW5ndGg9PT0zKXtpZihfIT09by5kaW1zWzFdKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJrZXlcIiBhbmQgXCJ2YWx1ZVwiIHNoYWxsIGhhdmUgdGhlIHNhbWUgZGltIDEgKGt2X3NlcXVlbmNlX2xlbmd0aCknKTtBPW8uZGltc1syXX1lbHNle2lmKF8hPT1vLmRpbXNbMl0pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImtleVwiIGFuZCBcInZhbHVlXCIgc2hhbGwgaGF2ZSB0aGUgc2FtZSBkaW0gMiAoa3Zfc2VxdWVuY2VfbGVuZ3RoKScpO0E9by5kaW1zWzFdKm8uZGltc1szXSxUPSEwfX1sZXQgaz0hMTtpZihhJiZDLnNpemUoYS5kaW1zKT4wKXRocm93IG5ldyBFcnJvcihcIktleSBwYWRkaW5nIG1hc2sgaXMgbm90IHN1cHBvcnRlZFwiKTtpZihkJiZDLnNpemUoZC5kaW1zKT4wKXtpZihkLmRpbXMubGVuZ3RoIT09NCl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwiYXR0ZW50aW9uX2JpYXNcIiBpcyBleHBlY3RlZCB0byBoYXZlIDQgZGltZW5zaW9ucycpO2lmKGQuZGltc1swXSE9PW18fGQuZGltc1sxXSE9PXQubnVtSGVhZHN8fGQuZGltc1syXSE9PXV8fGQuZGltc1szXSE9PXYpdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJhdHRlbnRpb25fYmlhc1wiIHNoYXBlIChiYXRjaF9zaXplLCBudW1faGVhZHMsIHNlcXVlbmNlX2xlbmd0aCwgdG90YWxfc2VxdWVuY2VfbGVuZ3RoKScpfXJldHVybntiYXRjaFNpemU6bSxzZXF1ZW5jZUxlbmd0aDp1LHBhc3RTZXF1ZW5jZUxlbmd0aDp5LGt2U2VxdWVuY2VMZW5ndGg6Xyx0b3RhbFNlcXVlbmNlTGVuZ3RoOnYsbWF4U2VxdWVuY2VMZW5ndGg6ZyxpbnB1dEhpZGRlblNpemU6MCxoaWRkZW5TaXplOmgsdkhpZGRlblNpemU6QSxoZWFkU2l6ZTp4LHZIZWFkU2l6ZTpNYXRoLmZsb29yKEEvdC5udW1IZWFkcyksbnVtSGVhZHM6dC5udW1IZWFkcyxpc1VuaWRpcmVjdGlvbmFsOiExLHBhc3RQcmVzZW50U2hhcmVCdWZmZXI6ITEsbWFza0ZpbHRlclZhbHVlOnQubWFza0ZpbHRlclZhbHVlLG1hc2tUeXBlOlMsc2NhbGU6dC5zY2FsZSxicm9hZGNhc3RSZXNQb3NCaWFzOmsscGFzc1Bhc3RJbkt2OlQscWt2Rm9ybWF0OiR9fSxWZD1lPT5yZSh7Li4uZX0pLE5kPXJlKHtwZXJtOlswLDIsMSwzXX0pLEpmPShlLHQscixuLG8saSxhKT0+e2xldCBkPVtuLG8saV0sbD1DLnNpemUoZCkscD1be3R5cGU6MTIsZGF0YTpsfSx7dHlwZToxMixkYXRhOmF9LHt0eXBlOjEyLGRhdGE6aX1dLG09dT0+e2xldCBoPU0oXCJxa3Zfd2l0aF9iaWFzXCIsdC5kYXRhVHlwZSxkKSxfPUUoXCJxa3ZcIix0LmRhdGFUeXBlLGQpLHk9RShcImJpYXNcIixyLmRhdGFUeXBlLGQpLGc9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiYmlhc19vZmZzZXRcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiaGlkZGVuX3NpemVcIix0eXBlOlwidTMyXCJ9XTtyZXR1cm5gXG4gICR7dS5yZWdpc3RlclVuaWZvcm1zKGcpLmRlY2xhcmVWYXJpYWJsZXMoXyx5LGgpfVxuICAke3UubWFpblN0YXJ0KCl9XG4gICAgJHt1Lmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICBsZXQgYmlhc19vZmZzZXRfaWR4ID0gKGdsb2JhbF9pZHggJSB1bmlmb3Jtcy5oaWRkZW5fc2l6ZSkgKyB1bmlmb3Jtcy5iaWFzX29mZnNldDtcblxuICAgIHFrdl93aXRoX2JpYXNbZ2xvYmFsX2lkeF0gPSBxa3ZbZ2xvYmFsX2lkeF0gKyBiaWFzW2JpYXNfb2Zmc2V0X2lkeF07XG4gIH1gfTtyZXR1cm4gZS5jb21wdXRlKHtuYW1lOlwiTXVsdGlIZWFkQXR0ZW50aW9uQWRkQmlhc1wiLHNoYWRlckNhY2hlOntpbnB1dERlcGVuZGVuY2llczpbXCJ0eXBlXCIsXCJ0eXBlXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmQsZGF0YVR5cGU6dC5kYXRhVHlwZSxncHVEYXRhVHlwZTowfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwobC82NCl9LHByb2dyYW1Vbmlmb3JtczpwfSksZ2V0U2hhZGVyU291cmNlOm19LHtpbnB1dHM6W3Qscl0sb3V0cHV0czpbLTFdfSlbMF19LHRyPShlLHQscixuLG8saSxhLGQpPT57bGV0IGw9aTtpZihhJiZDLnNpemUoYS5kaW1zKT4wKXtpZihuPT09MSl0aHJvdyBuZXcgRXJyb3IoXCJBZGRCaWFzUmVzaGFwZSBpcyBub3QgaW1wbGVtZW50ZWQuIFBsZWFzZSBleHBvcnQgeW91ciBtb2RlbCB3aXRoIHBhY2tlZCBRS1Ygb3IgS1ZcIik7cmV0dXJuIGw9SmYoZSxpLGEsdCxuLHIqbyxkKSxsPWwucmVzaGFwZShbdCxuLHIsb10pLHI9PT0xfHxuPT09MT9sOmUuY29tcHV0ZShQZShsLE5kLnBlcm0pLHtpbnB1dHM6W2xdLG91dHB1dHM6Wy0xXX0pWzBdfWVsc2UgcmV0dXJuIGkuZGltcy5sZW5ndGg9PT0zJiYobD1pLnJlc2hhcGUoW3QsbixyLG9dKSkscj09PTF8fG49PT0xP2w6ZS5jb21wdXRlKFBlKGwsTmQucGVybSkse2lucHV0czpbbF0sb3V0cHV0czpbLTFdfSlbMF19LFdkPShlLHQpPT57bGV0IHI9WGYoZS5pbnB1dHMsdCksbj1lLmlucHV0c1swXSxvPUJlKGUuaW5wdXRzLDEpLGk9QmUoZS5pbnB1dHMsMiksYT1CZShlLmlucHV0cywzKSxkPUJlKGUuaW5wdXRzLDQpLGw9QmUoZS5pbnB1dHMsNSkscD1CZShlLmlucHV0cyw2KSxtPUJlKGUuaW5wdXRzLDcpO2lmKG4uZGltcy5sZW5ndGg9PT01KXRocm93IG5ldyBFcnJvcihcIlBhY2tlZCBRS1YgaXMgbm90IGltcGxlbWVudGVkXCIpO2lmKG8/LmRpbXMubGVuZ3RoPT09NSl0aHJvdyBuZXcgRXJyb3IoXCJQYWNrZWQgS1YgaXMgbm90IGltcGxlbWVudGVkXCIpO2xldCB1PW8mJmkmJm8uZGltcy5sZW5ndGg9PT00JiZpLmRpbXMubGVuZ3RoPT09NCxoPXRyKGUsci5iYXRjaFNpemUsci5udW1IZWFkcyxyLnNlcXVlbmNlTGVuZ3RoLHIuaGVhZFNpemUsbixhLDApO2lmKHUpcmV0dXJuIFJ0KGUsaCxvLGksZCx2b2lkIDAscCxtLGwscik7aWYoIW98fCFpKXRocm93IG5ldyBFcnJvcihcImtleSBhbmQgdmFsdWUgbXVzdCBiZSBwcm92aWRlZFwiKTtsZXQgXz10cihlLHIuYmF0Y2hTaXplLHIubnVtSGVhZHMsci5rdlNlcXVlbmNlTGVuZ3RoLHIuaGVhZFNpemUsbyxhLHIuaGlkZGVuU2l6ZSkseT10cihlLHIuYmF0Y2hTaXplLHIubnVtSGVhZHMsci5rdlNlcXVlbmNlTGVuZ3RoLHIudkhlYWRTaXplLGksYSwyKnIuaGlkZGVuU2l6ZSk7UnQoZSxoLF8seSxkLHZvaWQgMCxwLG0sbCxyKX19KTt2YXIgZWgsdGgscmgsbmgsVG8sTGQsR2QsSW89VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTtTZSgpO2FlKCk7ZWg9ZT0+e2lmKCFlfHxlLmxlbmd0aDwxKXRocm93IG5ldyBFcnJvcihcInRvbyBmZXcgaW5wdXRzXCIpfSx0aD0oZSx0KT0+e2xldCByPVtdLG49dC5udW1PdXRwdXRzO3JldHVybiBlWzFdLmRpbXNbMF0+MCYmKGVbMV0uZ2V0QmlnSW50NjRBcnJheSgpLmZvckVhY2gobz0+ci5wdXNoKE51bWJlcihvKSkpLG49ci5sZW5ndGgpLHJlKHtudW1PdXRwdXRzOm4sYXhpczp0LmF4aXMsc3BsaXRTaXplczpyfSl9LHJoPWU9PmBcbmZuIGNhbGN1bGF0ZU91dHB1dEluZGV4KGluZGV4OiB1MzIpIC0+IHUzMiB7XG4gICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCAke2V9dTsgaSArPSAxdSApIHtcbiAgICBpZiAoaW5kZXggPCAke0YoXCJ1bmlmb3Jtcy5zaXplX2luX3NwbGl0X2F4aXNcIixcImlcIixlKX0pIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICAgIH1cbiAgICByZXR1cm4gJHtlfXU7XG59YCxuaD1lPT57bGV0IHQ9ZS5sZW5ndGgscj1bXTtmb3IobGV0IG49MDtuPHQ7KytuKXtsZXQgbz1lW25dLnNldEJ5SW5kaWNlcyhcImluZGljZXNcIixcImlucHV0W2dsb2JhbF9pZHhdXCIpO3Q9PT0xP3IucHVzaChvKTpuPT09MD9yLnB1c2goYGlmIChvdXRwdXRfbnVtYmVyID09ICR7bn11KSB7ICR7b30gfWApOm49PT10LTE/ci5wdXNoKGBlbHNlIHsgJHtvfSB9YCk6ci5wdXNoKGBlbHNlIGlmIChvdXRwdXRfbnVtYmVyID09ICR7bn0pIHsgJHtvfSB9YCl9cmV0dXJuYFxuICAgICAgZm4gd3JpdGVCdWZmZXJEYXRhKG91dHB1dF9udW1iZXI6IHUzMiwgaW5kaWNlczogJHtlWzBdLnR5cGUuaW5kaWNlc30sIGdsb2JhbF9pZHg6IHUzMikge1xuICAgICAgICAke3Iuam9pbihgXG5gKX1cbiAgICAgIH1gfSxUbz0oZSx0KT0+e2xldCByPWVbMF0uZGltcyxuPUMuc2l6ZShyKSxvPWVbMF0uZGF0YVR5cGUsaT1DLm5vcm1hbGl6ZUF4aXModC5heGlzLHIubGVuZ3RoKSxhPW5ldyBBcnJheSh0Lm51bU91dHB1dHMpLGQ9RShcImlucHV0XCIsbyxyLmxlbmd0aCksbD1uZXcgQXJyYXkodC5udW1PdXRwdXRzKSxwPVtdLG09W10sdT0wLGg9W3t0eXBlOjEyLGRhdGE6bn1dO2ZvcihsZXQgeT0wO3k8dC5udW1PdXRwdXRzO3krKyl7dSs9dC5zcGxpdFNpemVzW3ldLGxbeV09dTtsZXQgZz1yLnNsaWNlKCk7Z1tpXT10LnNwbGl0U2l6ZXNbeV0sbS5wdXNoKGcpLGFbeV09TShgb3V0cHV0JHt5fWAsbyxnLmxlbmd0aCkscC5wdXNoKHtkaW1zOm1beV0sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX0pfWgucHVzaCh7dHlwZToxMixkYXRhOmx9LC4uLk4ociwuLi5tKSk7bGV0IF89eT0+YFxuICAke3kucmVnaXN0ZXJVbmlmb3JtKFwiaW5wdXRfc2l6ZVwiLFwidTMyXCIpLnJlZ2lzdGVyVW5pZm9ybShcInNpemVfaW5fc3BsaXRfYXhpc1wiLFwidTMyXCIsbC5sZW5ndGgpLmRlY2xhcmVWYXJpYWJsZXMoZCwuLi5hKX1cbiAgJHtyaChsLmxlbmd0aCl9XG4gICR7bmgoYSl9XG5cbiAgJHt5Lm1haW5TdGFydCgpfVxuICAgICR7eS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMuaW5wdXRfc2l6ZVwiKX1cblxuICAgIHZhciBpbmRpY2VzID0gJHtkLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgIHZhciBpbmRleCA9ICR7ZC5pbmRpY2VzR2V0KFwiaW5kaWNlc1wiLGkpfTtcbiAgICBsZXQgb3V0cHV0X251bWJlciA9IGNhbGN1bGF0ZU91dHB1dEluZGV4KGluZGV4KTtcbiAgICBpZiAob3V0cHV0X251bWJlciAhPSAwKSB7XG4gICAgICBpbmRleCAtPSAke0YoXCJ1bmlmb3Jtcy5zaXplX2luX3NwbGl0X2F4aXNcIixcIm91dHB1dF9udW1iZXIgLSAxdVwiLGwubGVuZ3RoKX07XG4gICAgICAke2QuaW5kaWNlc1NldChcImluZGljZXNcIixpLFwiaW5kZXhcIil9O1xuICAgIH1cbiAgICB3cml0ZUJ1ZmZlckRhdGEob3V0cHV0X251bWJlciwgaW5kaWNlcywgZ2xvYmFsX2lkeCk7XG4gIH1gO3JldHVybntuYW1lOlwiU3BsaXRcIixzaGFkZXJDYWNoZTp7aGludDp0LmNhY2hlS2V5LGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LGdldFNoYWRlclNvdXJjZTpfLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpwLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKG4vNjQpfSxwcm9ncmFtVW5pZm9ybXM6aH0pfX0sTGQ9KGUsdCk9PntlaChlLmlucHV0cyk7bGV0IHI9ZS5pbnB1dHMubGVuZ3RoPT09MT90OnRoKGUuaW5wdXRzLHQpO2UuY29tcHV0ZShUbyhlLmlucHV0cyxyKSx7aW5wdXRzOlswXX0pfSxHZD1lPT57bGV0IHQ9ZS5heGlzLHI9ZS5zcGxpdFNpemVzLG49ZS5udW1PdXRwdXRzPDA/ci5sZW5ndGg6ZS5udW1PdXRwdXRzO2lmKG4hPT1yLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJudW1PdXRwdXRzIGFuZCBzcGxpdFNpemVzIGxlbmdoIG11c3QgYmUgZXF1YWxcIik7cmV0dXJuIHJlKHtheGlzOnQsbnVtT3V0cHV0czpuLHNwbGl0U2l6ZXM6cn0pfX0pO3ZhciBvaCxpaCxIZCxGZCxxZD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7U2UoKTtGcigpO1NvKCk7SW8oKTtkdCgpO29oPShlLHQpPT57aWYodC5kb1JvdGFyeSl0aHJvdyBuZXcgRXJyb3IoXCJHcm91cFF1ZXJyeUF0dGVudGlvbiBkb19yb3RhcnkgYXR0cmlidXRlIGlzIG5vdCBzdXBwb3J0ZWRcIik7aWYodC5kb1JvdGFyeSYmZS5sZW5ndGg8PTcpdGhyb3cgbmV3IEVycm9yKFwiY29zX2NhY2hlIGFuZCBzaW5fY2FjaGUgaW5wdXRzIGFyZSByZXF1aXJlZCBpZiBkb19yb3RhcnkgaXMgc3BlY2lmaWVkXCIpO2xldCByPWVbMF0sbj1lWzFdLG89ZVsyXSxpPWVbM10sYT1lWzRdO2lmKHQubG9jYWxXaW5kb3dTaXplIT09LTEpdGhyb3cgbmV3IEVycm9yKFwiTG9jYWwgYXR0ZW50aW9uIGlzIG5vdCBzdXBwb3J0ZWRcIik7aWYodC5zb2Z0Y2FwIT09MCl0aHJvdyBuZXcgRXJyb3IoXCJTb2Z0Y2FwIGlzIG5vdCBzdXBwb3J0ZWRcIik7aWYodC5yb3RhcnlJbnRlcmxlYXZlZCE9PTApdGhyb3cgbmV3IEVycm9yKFwiUm90YXJ5IGludGVybGVhdmVkIGlzIG5vdCBzdXBwb3J0ZWRcIik7aWYodC5zbW9vdGhTb2Z0bWF4KXRocm93IG5ldyBFcnJvcihcIlNtb290aCBzb2Z0bWF4IGlzIG5vdCBzdXBwb3J0ZWRcIik7aWYoci5kaW1zLmxlbmd0aCE9PTMmJnIuZGltcy5sZW5ndGghPT01KXRocm93IG5ldyBFcnJvcihcIklucHV0IHF1ZXJ5IGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBvciA1IGRpbWVuc2lvbnNcIik7bGV0IGQ9ITEsbD1yLmRpbXNbMF0scD1yLmRpbXNbMV0sbT1yLmRpbXMubGVuZ3RoPT09Mz9kP3IuZGltc1syXS8zOnIuZGltc1syXTp0Lm51bUhlYWRzKnIuZGltc1s0XSx1PXAsaD0wLF89IW58fG4uZGltcy5sZW5ndGg9PT0wLHk9TWF0aC5mbG9vcihfP20vKHQubnVtSGVhZHMrMip0Lmt2TnVtSGVhZHMpOm0vdC5udW1IZWFkcyk7XyYmKG09eSp0Lm51bUhlYWRzKTtsZXQgZz1pJiZpLmRpbXMubGVuZ3RoIT09MCx4PWEmJmEuZGltcy5sZW5ndGghPT0wO2lmKGcmJmkuZGltcy5sZW5ndGg9PT00JiZpLmRpbXNbMF09PT1sJiZpLmRpbXNbMV0hPT10Lmt2TnVtSGVhZHMmJmkuZGltc1syXT09PXQua3ZOdW1IZWFkcyYmaS5kaW1zWzNdPT09eSl0aHJvdyBuZXcgRXJyb3IoXCJCU05IIHBhc3RLZXkvcGFzdFZhbHVlIGlzIG5vdCBzdXBwb3J0ZWRcIik7aWYoZyYmeCl7aWYoaS5kaW1zLmxlbmd0aCE9PTQpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3Rfa2V5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSA0IGRpbWVuc2lvbnMnKTtpZihhLmRpbXMubGVuZ3RoIT09NCl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF92YWx1ZVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgNCBkaW1lbnNpb25zJyk7aD1pLmRpbXNbMl19ZWxzZSBpZihnfHx4KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIGFuZCBcInBhc3RfdmFsdWVcIiBzaGFsbCBiZSBib3RoIHByZXNlbnQgb3IgYm90aCBhYnNlbnQnKTtsZXQgdj0xO2lmKG4mJm4uZGltcy5sZW5ndGg+MCl7aWYoci5kaW1zLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIGRpbWVuc2lvbnMgd2hlbiBrZXkgaXMgZ2l2ZW4nKTtpZihuLmRpbXMubGVuZ3RoPDN8fG4uZGltcy5sZW5ndGg+NSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwia2V5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzLCA0LCBvciA1IGRpbWVuc2lvbnMnKTtpZihyLmRpbXNbMF0hPT1uLmRpbXNbMF0pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgYW5kIFwia2V5XCIgc2hhbGwgaGF2ZSBzYW1lIGRpbSAwIChiYXRjaCBzaXplKScpO2lmKG4uZGltcy5sZW5ndGg9PT0zKXtpZihyLmRpbXNbMl0lbi5kaW1zWzJdIT09MCl0aHJvdyBuZXcgRXJyb3IoJ0RpbWVuc2lvbiAyIG9mIFwicXVlcnlcIiBzaG91bGQgYmUgYSBtdWx0aXBsZSBvZiBcImtleVwiJyk7dT1uLmRpbXNbMV19ZWxzZSBpZihuLmRpbXMubGVuZ3RoPT09NSl7aWYobi5kaW1zWzJdIT09dC5udW1IZWFkc3x8bi5kaW1zWzNdIT09Mnx8bi5kaW1zWzRdIT09eSl0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcImtleVwiIHNoYXBlIChiYXRjaF9zaXplLCBrdl9zZXF1ZW5jZV9sZW5ndGgsIG51bV9oZWFkcywgMiwgaGVhZF9zaXplKSBmb3IgcGFja2VkIGt2Jyk7aWYobyl0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcInZhbHVlXCIgYmUgbm9uZSB3aGVuIFwia2V5XCIgaGFzIHBhY2tlZCBrdiBmb3JtYXQuJyk7dT1uLmRpbXNbMV19ZWxzZXtpZihuLmRpbXNbMV0hPT10Lm51bUhlYWRzfHxuLmRpbXNbM10hPT15KXRocm93IG5ldyBFcnJvcignRXhwZWN0IFwia2V5XCIgc2hhcGUgKGJhdGNoX3NpemUsIG51bV9oZWFkcywga3Zfc2VxdWVuY2VfbGVuZ3RoLCBoZWFkX3NpemUpIGZvciBwYXN0X2tleScpO3U9bi5kaW1zWzJdfX1lbHNle2lmKHIuZGltcy5sZW5ndGghPT0zJiZyLmRpbXMubGVuZ3RoIT09NSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBpcyBleHBlY3RlZCB0byBoYXZlIDMgb3IgNSBkaW1lbnNpb25zIHdoZW4ga2V5IGlzIGVtcHR5Jyk7aWYoci5kaW1zLmxlbmd0aD09PTUmJihyLmRpbXNbMl0hPT10Lm51bUhlYWRzfHxyLmRpbXNbM10hPT0zKSl0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcInF1ZXJ5XCIgc2hhcGUgKGJhdGNoX3NpemUsIGt2X3NlcXVlbmNlX2xlbmd0aCwgbnVtX2hlYWRzLCAzLCBoZWFkX3NpemUpIGZvciBwYWNrZWQga3YnKTt2PTN9bGV0IFM9MCxUPSExLEE9dC5rdk51bUhlYWRzP3kqdC5rdk51bUhlYWRzOm07aWYobyYmby5kaW1zLmxlbmd0aD4wKXtpZihvLmRpbXMubGVuZ3RoIT09MyYmby5kaW1zLmxlbmd0aCE9PTQpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInZhbHVlXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIG9yIDQgZGltZW5zaW9ucycpO2lmKHIuZGltc1swXSE9PW8uZGltc1swXSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBhbmQgXCJ2YWx1ZVwiIHNoYWxsIGhhdmUgc2FtZSBkaW0gMCAoYmF0Y2hfc2l6ZSknKTtpZihvLmRpbXMubGVuZ3RoPT09Myl7aWYodSE9PW8uZGltc1sxXSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwia2V5XCIgYW5kIFwidmFsdWVcIiBzaGFsbCBoYXZlIHRoZSBzYW1lIGRpbSAxIChrdl9zZXF1ZW5jZV9sZW5ndGgpJyk7QT1vLmRpbXNbMl19ZWxzZXtpZih1IT09by5kaW1zWzJdKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIGFuZCBcInBhc3RfdmFsdWVcIiBzaGFsbCBoYXZlIHRoZSBzYW1lIGRpbSAyIChrdl9zZXF1ZW5jZV9sZW5ndGgpJyk7QT1vLmRpbXNbMV0qby5kaW1zWzNdLFQ9ITB9fWxldCBrPWUubGVuZ3RoPjQ/ZVs1XTp2b2lkIDA7aWYoayYmay5kaW1zLmxlbmd0aCE9PTEmJmsuZGltc1swXSE9PWwpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInNlcWxlbnNcIiBpcyBleHBlY3RlZCB0byBoYXZlIDEgZGltZW5zaW9uIGFuZCB0aGUgc2FtZSBkaW0gMCBhcyBiYXRjaF9zaXplJyk7bGV0IFA9LTEsRD0tMSxSPSExO3JldHVybntiYXRjaFNpemU6bCxzZXF1ZW5jZUxlbmd0aDpwLHBhc3RTZXF1ZW5jZUxlbmd0aDpoLGt2U2VxdWVuY2VMZW5ndGg6dSx0b3RhbFNlcXVlbmNlTGVuZ3RoOlAsbWF4U2VxdWVuY2VMZW5ndGg6RCxpbnB1dEhpZGRlblNpemU6MCxoaWRkZW5TaXplOm0sdkhpZGRlblNpemU6QSxoZWFkU2l6ZTp5LHZIZWFkU2l6ZTpNYXRoLmZsb29yKEEvdC5rdk51bUhlYWRzKSxudW1IZWFkczp0Lm51bUhlYWRzLGt2TnVtSGVhZHM6dC5rdk51bUhlYWRzLG5SZXBzOnQubnVtSGVhZHMvdC5rdk51bUhlYWRzLHBhc3RQcmVzZW50U2hhcmVCdWZmZXI6ITEsbWFza1R5cGU6UyxzY2FsZTp0LnNjYWxlLGJyb2FkY2FzdFJlc1Bvc0JpYXM6UixwYXNzUGFzdEluS3Y6VCxxa3ZGb3JtYXQ6dn19LGloPXJlKHtwZXJtOlswLDIsMSwzXX0pLEhkPShlLHQscik9PntsZXQgbj10LG89ci5rdk51bUhlYWRzO3JldHVybiB0LmRpbXMubGVuZ3RoPT09MyYmci5rdlNlcXVlbmNlTGVuZ3RoIT09MCYmKG49dC5yZXNoYXBlKFtyLmJhdGNoU2l6ZSxyLmt2U2VxdWVuY2VMZW5ndGgsbyxyLmhlYWRTaXplXSksbj1lLmNvbXB1dGUoUGUobixpaC5wZXJtKSx7aW5wdXRzOltuXSxvdXRwdXRzOlstMV19KVswXSksbn0sRmQ9KGUsdCk9PntsZXQgcj1vaChlLmlucHV0cyx0KTtpZihlLmlucHV0c1swXS5kaW1zLmxlbmd0aD09PTUpdGhyb3cgbmV3IEVycm9yKFwiUGFja2VkIFFLViBpcyBub3QgaW1wbGVtZW50ZWRcIik7aWYoZS5pbnB1dHNbMV0/LmRpbXMubGVuZ3RoPT09NSl0aHJvdyBuZXcgRXJyb3IoXCJQYWNrZWQgS1YgaXMgbm90IGltcGxlbWVudGVkXCIpO2xldCBuPWUuaW5wdXRzWzBdLG89ZS5pbnB1dHNbMV0mJmUuaW5wdXRzWzFdLmRpbXMubGVuZ3RoPjA/ZS5pbnB1dHNbMV06dm9pZCAwLGk9ZS5pbnB1dHNbMl0mJmUuaW5wdXRzWzJdLmRpbXMubGVuZ3RoPjA/ZS5pbnB1dHNbMl06dm9pZCAwLGE9ZS5pbnB1dHNbM10mJmUuaW5wdXRzWzNdLmRpbXMubGVuZ3RoIT09MD9lLmlucHV0c1szXTp2b2lkIDAsZD1lLmlucHV0c1s0XSYmZS5pbnB1dHNbNF0uZGltcy5sZW5ndGghPT0wP2UuaW5wdXRzWzRdOnZvaWQgMCxsPWUuaW5wdXRzLmxlbmd0aD40P2UuaW5wdXRzWzVdOnZvaWQgMCxwPWUuaW5wdXRzLmxlbmd0aD41P2UuaW5wdXRzWzZdOnZvaWQgMCxtPXIua3ZOdW1IZWFkcz9yLmt2TnVtSGVhZHM6ci5udW1IZWFkcyx1PXJlKHtheGlzOjIsbnVtT3V0cHV0czozLHNwbGl0U2l6ZXM6W3IubnVtSGVhZHMqci5oZWFkU2l6ZSxtKnIuaGVhZFNpemUsbSpyLmhlYWRTaXplXX0pLFtoLF8seV09IW8mJiFpP2UuY29tcHV0ZShUbyhbbl0sdSkse2lucHV0czpbbl0sb3V0cHV0czpbLTEsLTEsLTFdfSk6W24sbyxpXSxnPXRyKGUsci5iYXRjaFNpemUsci5udW1IZWFkcyxyLnNlcXVlbmNlTGVuZ3RoLHIuaGVhZFNpemUsaCx2b2lkIDAsMCk7UnQoZSxnLEhkKGUsXyxyKSxIZChlLHksciksdm9pZCAwLHZvaWQgMCxhLGQsdm9pZCAwLHIsbCxwKX19KTt2YXIgS2QsYWgsc2gsamQsWWQ9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTtkdCgpO2FlKCk7S2Q9KGUsdCxyLG4sbyxpLGEsZCk9PntsZXQgbD1tZShpKSxwPWw9PT0xP1wiZjMyXCI6YHZlYyR7bH1mYCxtPWw9PT0xP1widmVjMmZcIjpgbWF0Mngke2x9ZmAsdT1vKmEsaD02NDt1PT09MSYmKGg9MjU2KTtsZXQgXz1bbyxhLGkvbF0seT1bbyxhLDJdLGc9W1wicmFua1wiLFwidHlwZVwiLFwidHlwZVwiXSx4PVtdO3gucHVzaCguLi5OKF8seSkpO2xldCAkPXY9PntsZXQgUz1FKFwieFwiLHQuZGF0YVR5cGUsMyxsKSxUPUUoXCJzY2FsZVwiLHIuZGF0YVR5cGUsci5kaW1zKSxBPUUoXCJiaWFzXCIsbi5kYXRhVHlwZSxuLmRpbXMpLGs9TShcIm91dHB1dFwiLDEsMywyKSxQPVtTLFQsQSxrXTtyZXR1cm5gXG4gIHZhcjx3b3JrZ3JvdXA+IHdvcmtncm91cF9zaGFyZWQgOiBhcnJheTwke219LCAke2h9PjtcbiAgY29uc3Qgd29ya2dyb3VwX3NpemUgPSAke2h9dTtcbiAgJHt2LmRlY2xhcmVWYXJpYWJsZXMoLi4uUCl9XG4gICR7di5tYWluU3RhcnQoaCl9XG4gICAgbGV0IGJhdGNoID0gd29ya2dyb3VwX2luZGV4IC8gdW5pZm9ybXMueF9zaGFwZVsxXTtcbiAgICBsZXQgY2hhbm5lbCA9IHdvcmtncm91cF9pbmRleCAlIHVuaWZvcm1zLnhfc2hhcGVbMV07XG4gICAgbGV0IGhpZ2h0ID0gdW5pZm9ybXMueF9zaGFwZVsyXTtcbiAgICAvLyBpbml0aWFsaXplIHdvcmtncm91cCBtZW1vcnlcbiAgICB2YXIgc3VtID0gJHtwfSgwKTtcbiAgICB2YXIgc3F1YXJlZF9zdW0gPSAke3B9KDApO1xuICAgIGZvciAodmFyIGggPSBsb2NhbF9pZHg7IGggPCBoaWdodDsgaCArPSB3b3JrZ3JvdXBfc2l6ZSkge1xuICAgICAgbGV0IHZhbHVlID0gJHtwfSgke1MuZ2V0KFwiYmF0Y2hcIixcImNoYW5uZWxcIixcImhcIil9KTtcbiAgICAgIHN1bSArPSB2YWx1ZTtcbiAgICAgIHNxdWFyZWRfc3VtICs9IHZhbHVlICogdmFsdWU7XG4gICAgfVxuICAgIHdvcmtncm91cF9zaGFyZWRbbG9jYWxfaWR4XSA9ICR7bX0oc3VtLCBzcXVhcmVkX3N1bSk7XG4gICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgZm9yICh2YXIgY3VyclNpemUgPSB3b3JrZ3JvdXBfc2l6ZSA+PiAxOyAgY3VyclNpemUgPiAwOyBjdXJyU2l6ZSA9IGN1cnJTaXplID4+IDEpIHtcbiAgICAgIGlmIChsb2NhbF9pZHggPCBjdXJyU2l6ZSkge1xuICAgICAgICB3b3JrZ3JvdXBfc2hhcmVkW2xvY2FsX2lkeF0gPSB3b3JrZ3JvdXBfc2hhcmVkW2xvY2FsX2lkeF0gKyB3b3JrZ3JvdXBfc2hhcmVkW2xvY2FsX2lkeCArIGN1cnJTaXplXTtcbiAgICAgIH1cbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICB9XG4gICAgaWYgKGxvY2FsX2lkeCA9PSAwKSB7XG4gICAgICBsZXQgc3VtX2ZpbmFsID0gJHtGZShcIndvcmtncm91cF9zaGFyZWRbMF1bMF1cIixsKX0gLyBmMzIoaGlnaHQgKiAke2x9KTtcbiAgICAgIGxldCBzcXVhcmVkX3N1bV9maW5hbCA9ICR7RmUoXCJ3b3JrZ3JvdXBfc2hhcmVkWzBdWzFdXCIsbCl9IC8gZjMyKGhpZ2h0ICogJHtsfSk7XG5cbiAgICAgIGxldCBpbnZfc3RkX2RldiA9IGludmVyc2VTcXJ0KHNxdWFyZWRfc3VtX2ZpbmFsIC0gc3VtX2ZpbmFsICogc3VtX2ZpbmFsICsgZjMyKCR7ZH0pKTtcbiAgICAgIGxldCBjaGFubmVsX3NjYWxlID0gaW52X3N0ZF9kZXYgKiBmMzIoc2NhbGVbY2hhbm5lbF0pO1xuICAgICAgbGV0IGNoYW5uZWxfc2hpZnQgPSBmMzIoYmlhc1tjaGFubmVsXSkgLSBzdW1fZmluYWwgKiBjaGFubmVsX3NjYWxlO1xuICAgICAgb3V0cHV0W3dvcmtncm91cF9pbmRleF0gPSB2ZWMyZihjaGFubmVsX3NjYWxlLCBjaGFubmVsX3NoaWZ0KTtcbiAgICB9XG4gIH1gfTtyZXR1cm4gZS5jb21wdXRlKHtuYW1lOlwiSW5zdGFuY2VOb3JtQ29tcHV0ZUNoYW5uZWxTY2FsZVNoaWZ0XCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7bH07JHtkfTske2h9YCxpbnB1dERlcGVuZGVuY2llczpnfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnksZGF0YVR5cGU6MX1dLGRpc3BhdGNoR3JvdXA6e3g6dX0scHJvZ3JhbVVuaWZvcm1zOnh9KSxnZXRTaGFkZXJTb3VyY2U6JH0se2lucHV0czpbdCxyLG5dLG91dHB1dHM6Wy0xXX0pWzBdfSxhaD0oZSx0LHIpPT57bGV0IG49dFswXS5kaW1zLG89bixpPTIsYT1uWzBdLGQ9blsxXSxsPUMuc2l6ZUZyb21EaW1lbnNpb24obixpKSxwPW1lKGwpLG09Qy5zaXplKG8pL3AsdT1LZChlLHRbMF0sdFsxXSx0WzJdLGEsbCxkLHIuZXBzaWxvbiksaD1bYSxkLGwvcF0sXz1bYSxkXSx5PVtcInR5cGVcIixcIm5vbmVcIl0sZz14PT57bGV0ICQ9RShcInhcIix0WzBdLmRhdGFUeXBlLGgubGVuZ3RoLHApLHY9RShcInNjYWxlX3NoaWZ0XCIsMSxfLmxlbmd0aCwyKSxTPU0oXCJvdXRwdXRcIix0WzBdLmRhdGFUeXBlLGgubGVuZ3RoLHApLFQ9WyQsdixTXTtyZXR1cm5gXG4gICR7eC5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoLi4uVCl9XG4gICR7eC5tYWluU3RhcnQoKX1cbiAgJHt4Lmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtTLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgbGV0IGJhdGNoID0gb3V0cHV0SW5kaWNlc1swXTtcbiAgICAgIGxldCBjaGFubmVsID0gb3V0cHV0SW5kaWNlc1sxXTtcbiAgICAgIGxldCBzY2FsZV9zaGlmdCA9ICR7di5nZXRCeUluZGljZXMoXCJ2ZWMyPHUzMj4oYmF0Y2gsIGNoYW5uZWwpXCIpfTtcbiAgICAgIGxldCB2YWx1ZSA9ICR7JC5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIil9ICogJHtTLnR5cGUudmFsdWV9KHNjYWxlX3NoaWZ0LngpICsgJHtTLnR5cGUudmFsdWV9KHNjYWxlX3NoaWZ0LnkpO1xuICAgICAgJHtTLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIil9O1xuICB9YH07ZS5jb21wdXRlKHtuYW1lOlwiSW5zdGFuY2VOb3JtYWxpemF0aW9uXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7cH1gLGlucHV0RGVwZW5kZW5jaWVzOnl9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6byxkYXRhVHlwZTp0WzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwobS82NCl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTptfSwuLi5OKGgsXyxoKV19KSxnZXRTaGFkZXJTb3VyY2U6Z30se2lucHV0czpbdFswXSx1XX0pfSxzaD0oZSx0LHIpPT57bGV0IG49dFswXS5kaW1zLG89bixpPW5bMF0sYT1uW24ubGVuZ3RoLTFdLGQ9Qy5zaXplRnJvbURpbWVuc2lvbihuLDEpL2EsbD1tZShhKSxwPUMuc2l6ZShvKS9sLG09W3t0eXBlOjEyLGRhdGE6ZH0se3R5cGU6MTIsZGF0YTpNYXRoLmZsb29yKGEvbCl9XSx1PVtcInR5cGVcIixcInR5cGVcIl0saD0hMSxfPVswLG4ubGVuZ3RoLTFdO2ZvcihsZXQgJD0wOyQ8bi5sZW5ndGgtMjskKyspaD1ofHxuWyQrMV0hPT0xLF8ucHVzaCgkKzEpO2g9aCYmbltuLmxlbmd0aC0xXSE9PTE7bGV0IHk9aD9lLmNvbXB1dGUoUGUoZS5pbnB1dHNbMF0sXykse2lucHV0czpbZS5pbnB1dHNbMF1dLG91dHB1dHM6Wy0xXX0pWzBdOmUuaW5wdXRzWzBdLnJlc2hhcGUoQXJyYXkuZnJvbSh7bGVuZ3RoOm4ubGVuZ3RofSwoJCx2KT0+bltfW3ZdXSkpLGc9S2QoZSx5LHRbMV0sdFsyXSxpLGQsYSxyLmVwc2lsb24pLHg9JD0+e2xldCB2PV9lKHRbMF0uZGF0YVR5cGUpLFM9bD09PTE/XCJ2ZWMyZlwiOmBtYXQke2x9eDJmYCxUPVA9PntsZXQgRD1QPT09MD9cInhcIjpcInlcIixSPWw9PT0xP1wiZjMyXCI6YHZlYyR7bH1mYDtzd2l0Y2gobCl7Y2FzZSAxOnJldHVybmAke3Z9KCR7Un0oc2NhbGUuJHtEfSkpYDtjYXNlIDI6cmV0dXJuYHZlYzI8JHt2fT4oJHtSfShzY2FsZVswXS4ke0R9LCBzY2FsZVsxXS4ke0R9KSlgO2Nhc2UgNDpyZXR1cm5gdmVjNDwke3Z9Pigke1J9KHNjYWxlWzBdLiR7RH0sIHNjYWxlWzFdLiR7RH0sIHNjYWxlWzJdLiR7RH0sIHNjYWxlWzNdLiR7RH0pKWA7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYE5vdCBzdXBwb3J0ZWQgY29tcG9lbnRzICR7bH1gKX19LEE9RShcImlucHV0XCIsdFswXS5kYXRhVHlwZSx0WzBdLmRpbXMsbCksaz1NKFwib3V0cHV0XCIsdFswXS5kYXRhVHlwZSxvLGwpO3JldHVybmBcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDApIHZhcjxzdG9yYWdlLCByZWFkPiBpbnB1dCA6IGFycmF5PCR7QS50eXBlLnN0b3JhZ2V9PjtcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDEpIHZhcjxzdG9yYWdlLCByZWFkPiBzY2FsZV9pbnB1dCA6IGFycmF5PCR7U30+O1xuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMikgdmFyPHN0b3JhZ2UsIHJlYWRfd3JpdGU+IG91dHB1dCA6IGFycmF5PCR7ay50eXBlLnN0b3JhZ2V9PjtcbiAgc3RydWN0IFVuaWZvcm1zIHtIOiB1MzIsIEMgOiB1MzJ9O1xuICBAZ3JvdXAoMCkgQGJpbmRpbmcoMykgdmFyPHVuaWZvcm0+IHVuaWZvcm1zOiBVbmlmb3JtcztcblxuICAkeyQubWFpblN0YXJ0KCl9XG4gICAgbGV0IGN1cnJlbnRfaW1hZ2VfbnVtYmVyID0gZ2xvYmFsX2lkeCAvICh1bmlmb3Jtcy5DICogdW5pZm9ybXMuSCk7XG4gICAgbGV0IGN1cnJlbnRfY2hhbm5lbF9udW1iZXIgPSBnbG9iYWxfaWR4ICUgdW5pZm9ybXMuQztcblxuICAgIGxldCBzY2FsZV9vZmZzZXQgPSBjdXJyZW50X2ltYWdlX251bWJlciAqIHVuaWZvcm1zLkMgKyBjdXJyZW50X2NoYW5uZWxfbnVtYmVyO1xuICAgIGxldCBzY2FsZSA9IHNjYWxlX2lucHV0W3NjYWxlX29mZnNldF07XG4gICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gZm1hKGlucHV0W2dsb2JhbF9pZHhdLCAke1QoMCl9LCAke1QoMSl9KTtcbiAgfWB9O2UuY29tcHV0ZSh7bmFtZTpcIkluc3RhbmNlTm9ybWFsaXphdGlvbk5IV0NcIixzaGFkZXJDYWNoZTp7aGludDpgJHtsfWAsaW5wdXREZXBlbmRlbmNpZXM6dX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpvLGRhdGFUeXBlOnRbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChwLzY0KX0scHJvZ3JhbVVuaWZvcm1zOm19KSxnZXRTaGFkZXJTb3VyY2U6eH0se2lucHV0czpbdFswXSxnXX0pfSxqZD0oZSx0KT0+e3QuZm9ybWF0PT09XCJOSFdDXCI/c2goZSxlLmlucHV0cyx0KTphaChlLGUuaW5wdXRzLHQpfX0pO3ZhciB1aCxkaCxaZCxRZD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtvZSgpO2FlKCk7dWg9ZT0+e2lmKCFlfHxlLmxlbmd0aDwyKXRocm93IG5ldyBFcnJvcihcImxheWVyTm9ybSByZXF1aXJlcyBhdCBsZWFzdCAyIGlucHV0cy5cIil9LGRoPShlLHQscik9PntsZXQgbj10LnNpbXBsaWZpZWQsbz1lWzBdLmRpbXMsaT1lWzFdLGE9IW4mJmVbMl0sZD1vLGw9Qy5ub3JtYWxpemVBeGlzKHQuYXhpcyxvLmxlbmd0aCkscD1DLnNpemVUb0RpbWVuc2lvbihvLGwpLG09Qy5zaXplRnJvbURpbWVuc2lvbihvLGwpLHU9Qy5zaXplKGkuZGltcyksaD1hP0Muc2l6ZShhLmRpbXMpOjA7aWYodSE9PW18fGEmJmghPT1tKXRocm93IG5ldyBFcnJvcihgU2l6ZSBvZiBYLnNoYXBlKClbYXhpczpdID09ICR7bX0uXG4gICAgICAgU2l6ZSBvZiBzY2FsZSBhbmQgYmlhcyAoaWYgcHJvdmlkZWQpIG11c3QgbWF0Y2ggdGhpcy5cbiAgICAgICBHb3Qgc2NhbGUgc2l6ZSBvZiAke3V9IGFuZCBiaWFzIHNpemUgb2YgJHtofWApO2xldCBfPVtdO2ZvcihsZXQgQT0wO0E8by5sZW5ndGg7KytBKUE8bD9fLnB1c2gob1tBXSk6Xy5wdXNoKDEpO2xldCB5PW1lKG0pLGc9W1widHlwZVwiLFwidHlwZVwiXSx4PVt7dHlwZToxMixkYXRhOnB9LHt0eXBlOjEsZGF0YTptfSx7dHlwZToxMixkYXRhOk1hdGguZmxvb3IobS95KX0se3R5cGU6MSxkYXRhOnQuZXBzaWxvbn1dO2EmJmcucHVzaChcInR5cGVcIik7bGV0ICQ9cj4xLHY9cj4yLFM9QT0+e2xldCBrPV9lKGVbMF0uZGF0YVR5cGUpLFA9W0UoXCJ4XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMseSksRShcInNjYWxlXCIsaS5kYXRhVHlwZSxpLmRpbXMseSldO2EmJlAucHVzaChFKFwiYmlhc1wiLGEuZGF0YVR5cGUsYS5kaW1zLHkpKSxQLnB1c2goTShcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsZCx5KSksJCYmUC5wdXNoKE0oXCJtZWFuX2RhdGFfb3V0cHV0XCIsMSxfKSksdiYmUC5wdXNoKE0oXCJpbnZfc3RkX291dHB1dFwiLDEsXykpO2xldCBEPVt7bmFtZTpcIm5vcm1fY291bnRcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibm9ybV9zaXplXCIsdHlwZTpcImYzMlwifSx7bmFtZTpcIm5vcm1fc2l6ZV92ZWN0b3JpemVkXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImVwc2lsb25cIix0eXBlOlwiZjMyXCJ9XTtyZXR1cm5gXG4gICR7QS5yZWdpc3RlclVuaWZvcm1zKEQpLmRlY2xhcmVWYXJpYWJsZXMoLi4uUCl9XG4gICR7QS5tYWluU3RhcnQoKX1cbiAgICAke0EuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm5vcm1fY291bnRcIil9XG4gICAgbGV0IG9mZnNldCA9IGdsb2JhbF9pZHggKiB1bmlmb3Jtcy5ub3JtX3NpemVfdmVjdG9yaXplZDtcbiAgICB2YXIgbWVhbl92ZWN0b3IgPSAke3VvKFwiZjMyXCIseSl9O1xuICAgIHZhciBtZWFuX3NxdWFyZV92ZWN0b3IgPSAke3VvKFwiZjMyXCIseSl9O1xuXG4gICAgZm9yICh2YXIgaDogdTMyID0gMHU7IGggPCB1bmlmb3Jtcy5ub3JtX3NpemVfdmVjdG9yaXplZDsgaCsrKSB7XG4gICAgICBsZXQgdmFsdWUgPSAke0V0KGsseSxcInhbaCArIG9mZnNldF1cIil9O1xuICAgICAgbWVhbl92ZWN0b3IgKz0gdmFsdWU7XG4gICAgICBtZWFuX3NxdWFyZV92ZWN0b3IgKz0gdmFsdWUgKiB2YWx1ZTtcbiAgICB9XG4gICAgbGV0IG1lYW4gPSAke0ZlKFwibWVhbl92ZWN0b3JcIix5KX0gLyB1bmlmb3Jtcy5ub3JtX3NpemU7XG4gICAgbGV0IGludl9zdGRfZGV2ID0gaW52ZXJzZVNxcnQoJHtGZShcIm1lYW5fc3F1YXJlX3ZlY3RvclwiLHkpfSAvIHVuaWZvcm1zLm5vcm1fc2l6ZSAke24/XCJcIjpcIi0gbWVhbiAqIG1lYW5cIn0gKyB1bmlmb3Jtcy5lcHNpbG9uKTtcblxuICAgIGZvciAodmFyIGo6IHUzMiA9IDA7IGogPCB1bmlmb3Jtcy5ub3JtX3NpemVfdmVjdG9yaXplZDsgaisrKSB7XG4gICAgICBsZXQgZjMyaW5wdXQgPSAke0V0KGsseSxcInhbaiArIG9mZnNldF1cIil9O1xuICAgICAgbGV0IGYzMnNjYWxlID0gJHtFdChrLHksXCJzY2FsZVtqXVwiKX07XG4gICAgICBvdXRwdXRbaiArIG9mZnNldF0gPSAke1BbMF0udHlwZS52YWx1ZX0oKGYzMmlucHV0ICR7bj9cIlwiOlwiLSBtZWFuXCJ9KSAqIGludl9zdGRfZGV2ICogZjMyc2NhbGVcbiAgICAgICAgJHthP2ArICR7RXQoayx5LFwiYmlhc1tqXVwiKX1gOlwiXCJ9XG4gICAgICApO1xuICAgIH1cblxuICAgICR7JD9cIm1lYW5fZGF0YV9vdXRwdXRbZ2xvYmFsX2lkeF0gPSBtZWFuXCI6XCJcIn07XG4gICAgJHt2P1wiaW52X3N0ZF9vdXRwdXRbZ2xvYmFsX2lkeF0gPSBpbnZfc3RkX2RldlwiOlwiXCJ9O1xuICB9YH0sVD1be2RpbXM6ZCxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV07cmV0dXJuICQmJlQucHVzaCh7ZGltczpfLGRhdGFUeXBlOjF9KSx2JiZULnB1c2goe2RpbXM6XyxkYXRhVHlwZToxfSkse25hbWU6XCJMYXllck5vcm1hbGl6YXRpb25cIixzaGFkZXJDYWNoZTp7aGludDpgJHt5fTske3J9OyR7bn1gLGlucHV0RGVwZW5kZW5jaWVzOmd9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpULGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHAvNjQpfSxwcm9ncmFtVW5pZm9ybXM6eH0pLGdldFNoYWRlclNvdXJjZTpTfX0sWmQ9KGUsdCk9Pnt1aChlLmlucHV0cyksZS5jb21wdXRlKGRoKGUuaW5wdXRzLHQsZS5vdXRwdXRDb3VudCkpfX0pO3ZhciBsaCxYZCxKZD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7b2UoKTtRcigpO1hyKCk7bGg9ZT0+e2lmKCFlfHxlLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKFwiTWF0TXVsIHJlcXVpcmVzIDIgaW5wdXRzLlwiKTtpZihlWzBdLmRpbXNbZVswXS5kaW1zLmxlbmd0aC0xXSE9PWVbMV0uZGltc1tlWzFdLmRpbXMubGVuZ3RoLTJdKXRocm93IG5ldyBFcnJvcihcInNoYXJlZCBkaW1lbnNpb24gZG9lcyBub3QgbWF0Y2guXCIpfSxYZD1lPT57bGgoZS5pbnB1dHMpO2xldCB0PXR0LmNhbGNTaGFwZShlLmlucHV0c1swXS5kaW1zLGUuaW5wdXRzWzFdLmRpbXMsITApO2lmKCF0KXRocm93IG5ldyBFcnJvcihcIkNhbid0IHVzZSBtYXRtdWwgb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7bGV0IHI9dFt0Lmxlbmd0aC0xXSxuPWUuaW5wdXRzWzBdLmRpbXNbZS5pbnB1dHNbMF0uZGltcy5sZW5ndGgtMV07aWYocjw4JiZuPDgpZS5jb21wdXRlKFpyKGUuaW5wdXRzLHthY3RpdmF0aW9uOlwiXCJ9LHQpKTtlbHNle2xldCBvPXRbdC5sZW5ndGgtMl0saT1DLnNpemUoZS5pbnB1dHNbMF0uZGltcy5zbGljZSgwLC0yKSksYT1DLnNpemUoZS5pbnB1dHNbMV0uZGltcy5zbGljZSgwLC0yKSk7aWYoaSE9PTEmJm89PT0xJiZhPT09MSl7bGV0IGQ9ZS5pbnB1dHNbMF0ucmVzaGFwZShbMSxpLG5dKSxsPWUuaW5wdXRzWzFdLnJlc2hhcGUoWzEsbixyXSkscD1bMSxpLHJdLG09W2QsbF07ZS5jb21wdXRlKGVyKG0se2FjdGl2YXRpb246XCJcIn0sdCxwKSx7aW5wdXRzOm19KX1lbHNlIGUuY29tcHV0ZShlcihlLmlucHV0cyx7YWN0aXZhdGlvbjpcIlwifSx0KSl9fX0pO3ZhciBjaCxwaCxtaCxlbCx0bCxybD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtvZSgpO1NlKCk7YWUoKTtjaD0oZSx0KT0+e2lmKGUubGVuZ3RoPDN8fGUubGVuZ3RoPjQpdGhyb3cgbmV3IEVycm9yKFwiTWF0TXVsTkJpdHMgcmVxdWlyZXMgMyBvciA0IGlucHV0c1wiKTtsZXQgcj1lWzBdLG49ci5kaW1zLmxlbmd0aDtpZihyLmRpbXNbbi0xXSE9PXQuayl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgbGFzdCBkaW0gb2YgaW5wdXQgc2hhcGUgZG9lcyBub3QgbWF0Y2ggdGhlIGsgdmFsdWVcIik7bGV0IG89TWF0aC5mbG9vcigodC5rK3QuYmxvY2tTaXplLTEpL3QuYmxvY2tTaXplKSxpPXQuYmxvY2tTaXplLzgqdC5iaXRzLGE9ZVsxXTtpZighQy5hcmVFcXVhbChhLmRpbXMsW3QubixvLGldKSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc2Vjb25kIGlucHV0cyBtdXN0IGJlIDNEIHRlbnNvciB3aXRoIHNoYXBlIE4gWCBuQmxvY2tzUGVyQ29sIFggYmxvYlNpemVcIik7bGV0IGw9ZVsyXS5kaW1zO2lmKEMuc2l6ZShsKSE9PXQubipvKXRocm93IG5ldyBFcnJvcihcInNjYWxlcyBpbnB1dCBzaXplIGVycm9yLlwiKTtpZihlLmxlbmd0aD09PTQpe2xldCBtPWVbM10uZGltcyx1PXQuYml0cz40P3QubipvOnQubipNYXRoLmZsb29yKChvKzEpLzIpO2lmKEMuc2l6ZShtKSE9PXUpdGhyb3cgbmV3IEVycm9yKFwiemVyb1BvaW50cyBpbnB1dCBzaXplIGVycm9yLlwiKX19LHBoPShlLHQpPT57bGV0IHI9ZVswXS5kaW1zLG49ci5sZW5ndGgsbz1yW24tMl0saT10LmssYT10Lm4sZD1yLnNsaWNlKDAsbi0yKSxsPUMuc2l6ZShkKSxtPWVbMV0uZGltc1syXS80LHU9ZVswXS5kYXRhVHlwZSxoPW1lKHQuayksXz1tZShtKSx5PW1lKGEpLGc9ZC5jb25jYXQoW28sYV0pLHg9bz4xJiZhL3klMj09PTA/MjoxLCQ9Qy5zaXplKGcpL3kveCx2PTY0LFM9W10sVD1bbCxvLGkvaF0sQT1DLmNvbnZlcnRTaGFwZShlWzFdLmRpbXMpLnNsaWNlKCk7QS5zcGxpY2UoLTEsMSxtL18pLFMucHVzaCguLi5OKFQpKSxTLnB1c2goLi4uTihBKSksUy5wdXNoKC4uLk4oZVsyXS5kaW1zKSksZS5sZW5ndGg9PT00JiZTLnB1c2goLi4uTihDLmNvbnZlcnRTaGFwZShlWzNdLmRpbXMpKSk7bGV0IGs9W2wsbyxhL3ldO1MucHVzaCguLi5OKGspKTtsZXQgUD1EPT57bGV0IFI9VC5sZW5ndGgsRz1FKFwiYVwiLGVbMF0uZGF0YVR5cGUsUixoKSxLPUUoXCJiXCIsMTIsQS5sZW5ndGgsXyksaj1FKFwic2NhbGVzXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMubGVuZ3RoKSxWPVtHLEssal0sUT1lLmxlbmd0aD09PTQ/RShcInplcm9fcG9pbnRzXCIsMTIsZVszXS5kaW1zLmxlbmd0aCk6dm9pZCAwO1EmJlYucHVzaChRKTtsZXQgc2U9ay5sZW5ndGgsWT1NKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxzZSx5KSxlZT1fZShlWzBdLmRhdGFUeXBlKSxKPSgoKT0+e3N3aXRjaChoKXtjYXNlIDE6cmV0dXJuYGFycmF5PCR7ZWV9LCA4PmA7Y2FzZSAyOnJldHVybmBtYXQ0eDI8JHtlZX0+YDtjYXNlIDQ6cmV0dXJuYG1hdDJ4NDwke2VlfT5gO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGAke2h9LWNvbXBvbmVudCBpcyBub3Qgc3VwcG9ydGVkLmApfX0pKCksbmU9KCk9PntsZXQgJGU9YFxuICAgICAgICAgIC8vIHJldXNlIGEgZGF0YVxuICAgICAgICAgICAgdmFyIGlucHV0X29mZnNldCA9ICR7Ry5pbmRpY2VzVG9PZmZzZXQoYCR7Ry50eXBlLmluZGljZXN9KGJhdGNoLCByb3csIHdvcmRfb2Zmc2V0KWApfTtcbiAgICAgICAgICAgIHZhciBhX2RhdGE6ICR7Sn07XG4gICAgICAgICAgICBmb3IgKHZhciBqOiB1MzIgPSAwOyBqIDwgJHs4L2h9OyBqKyspIHtcbiAgICAgICAgICAgICAgYV9kYXRhW2pdID0gJHtHLmdldEJ5T2Zmc2V0KFwiaW5wdXRfb2Zmc2V0XCIpfTtcbiAgICAgICAgICAgICAgaW5wdXRfb2Zmc2V0Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgYDtmb3IobGV0IGxlPTA7bGU8eSp4O2xlKyspJGUrPWBcbiAgICAgICAgICAgIGJfdmFsdWUgPSAke189PT0xP2BiJHtsZX1fZGF0YWA6YGIke2xlfV9kYXRhW2ldYH07XG4gICAgICAgICAgICBiX3ZhbHVlX2xvd2VyID0gdW5wYWNrNHhVOChiX3ZhbHVlICYgYl9tYXNrKTtcbiAgICAgICAgICAgIGJfdmFsdWVfdXBwZXIgPSB1bnBhY2s0eFU4KChiX3ZhbHVlID4+IDQpICYgYl9tYXNrKTtcbiAgICAgICAgICAgIGJfcXVhbnRpemVkX3ZhbHVlcyA9ICR7Sn0oJHtBcnJheS5mcm9tKHtsZW5ndGg6NH0sKFcscSk9PmAke2VlfShiX3ZhbHVlX2xvd2VyWyR7cX1dKSwgJHtlZX0oYl92YWx1ZV91cHBlclske3F9XSlgKS5qb2luKFwiLCBcIil9KTtcbiAgICAgICAgICAgIGJfZGVxdWFudGl6ZWRfdmFsdWVzID0gJHsoKCk9Pmg9PT0xP2Ake0p9KCR7QXJyYXkuZnJvbSh7bGVuZ3RoOjh9LChXLHEpPT5gKGJfcXVhbnRpemVkX3ZhbHVlc1ske3F9XSAtICR7UT9gemVyb19wb2ludCR7bGV9YDpcInplcm9fcG9pbnRcIn0pICogc2NhbGUke2xlfWApLmpvaW4oXCIsIFwiKX0pO2A6YChiX3F1YW50aXplZF92YWx1ZXMgLSAke0p9KCR7QXJyYXkoOCkuZmlsbChgJHtRP2B6ZXJvX3BvaW50JHtsZX1gOlwiemVyb19wb2ludFwifWApLmpvaW4oXCIsXCIpfSkpICogc2NhbGUke2xlfTtgKSgpfTtcbiAgICAgICAgICAgIHdvcmtncm91cF9zaGFyZWRbbG9jYWxfaWQueCAqICR7eH0gKyAke01hdGguZmxvb3IobGUveSl9XSR7eT4xP2BbJHtsZSV5fV1gOlwiXCJ9ICs9ICR7QXJyYXkuZnJvbSh7bGVuZ3RoOjgvaH0sKFcscSk9PmAke2g9PT0xP2BhX2RhdGFbJHtxfV0gKiBiX2RlcXVhbnRpemVkX3ZhbHVlc1ske3F9XWA6YGRvdChhX2RhdGFbJHtxfV0sIGJfZGVxdWFudGl6ZWRfdmFsdWVzWyR7cX1dKWB9YCkuam9pbihcIiArIFwiKX07XG4gICAgICAgICAgYDtyZXR1cm4gJGV9LGJlPSgpPT57bGV0ICRlPWBcbiAgICAgICAgICAgIHZhciBjb2xfaW5kZXggPSBjb2wgKiAke3l9O1xuICAgICAgICAgICAgJHtRP2BcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2J5dGVzX3Blcl9jb2wgPSAobkJsb2Nrc1BlckNvbCArIDEpIC8gMjtcbiAgICAgICAgICAgIHZhciB6ZXJvX3BvaW50X2J5dGVfY291bnQ6IHUzMjtcbiAgICAgICAgICAgIHZhciB6ZXJvX3BvaW50X3dvcmRfaW5kZXg6IHUzMjtcbiAgICAgICAgICAgIHZhciB6ZXJvX3BvaW50X2J5dGVfb2Zmc2V0OiB1MzI7XG4gICAgICAgICAgICBsZXQgemVyb19wb2ludF9uaWJibGVfb2Zmc2V0OiB1MzIgPSBibG9jayAmIDB4MXU7XG4gICAgICAgICAgICB2YXIgemVyb19wb2ludF9iaXRzX29mZnNldDogdTMyO1xuICAgICAgICAgICAgdmFyIHplcm9fcG9pbnRfd29yZDogdTMyO2A6YFxuICAgICAgICAgICAgLy8gVGhlIGRlZmF1bHQgemVybyBwb2ludCBpcyA4IGZvciB1bnNpZ25lZCA0LWJpdCBxdWFudGl6YXRpb24uXG4gICAgICAgICAgICBsZXQgemVyb19wb2ludCA9ICR7ZWV9KDgpO2B9XG4gICAgICAgICAgICBgO2ZvcihsZXQgbGU9MDtsZTx5Kng7bGUrKykkZSs9YFxuICAgICAgICAgICAgbGV0IHNjYWxlJHtsZX0gPSAke2ouZ2V0QnlPZmZzZXQoXCJjb2xfaW5kZXggKiBuQmxvY2tzUGVyQ29sICsgYmxvY2tcIil9O1xuICAgICAgICAgICAgJHtRP2BcbiAgICAgICAgICAgIHplcm9fcG9pbnRfYnl0ZV9jb3VudCA9IGNvbF9pbmRleCAqIHplcm9fcG9pbnRfYnl0ZXNfcGVyX2NvbCArIChibG9jayA+PiAweDF1KTtcbiAgICAgICAgICAgIHplcm9fcG9pbnRfd29yZF9pbmRleCA9IHplcm9fcG9pbnRfYnl0ZV9jb3VudCA+PiAweDJ1O1xuICAgICAgICAgICAgemVyb19wb2ludF9ieXRlX29mZnNldCA9IHplcm9fcG9pbnRfYnl0ZV9jb3VudCAmIDB4M3U7XG4gICAgICAgICAgICB6ZXJvX3BvaW50X2JpdHNfb2Zmc2V0ID0gKHplcm9fcG9pbnRfYnl0ZV9vZmZzZXQgPDwgMykgKyAoemVyb19wb2ludF9uaWJibGVfb2Zmc2V0IDw8IDIpO1xuICAgICAgICAgICAgemVyb19wb2ludF93b3JkID0gJHtRLmdldEJ5T2Zmc2V0KFwiemVyb19wb2ludF93b3JkX2luZGV4XCIpfSA+PiB6ZXJvX3BvaW50X2JpdHNfb2Zmc2V0O1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnQke2xlfSA9ICR7ZWV9KCh6ZXJvX3BvaW50X3dvcmQpICYgMHhGdSk7YDpcIlwifVxuICAgICAgICAgICAgY29sX2luZGV4ICs9IDE7YDtyZXR1cm4gJGV9LE9lPSgpPT57bGV0ICRlPWBjb2xfaW5kZXggPSBjb2wgKiAke3l9O2A7Zm9yKGxldCBsZT0wO2xlPHkqeDtsZSsrKSRlKz1gXG4gICAgICAgICAgICBsZXQgYiR7bGV9X2RhdGEgPSAke0suZ2V0QnlJbmRpY2VzKGAke0sudHlwZS5pbmRpY2VzfShjb2xfaW5kZXgsIGJsb2NrLCB3b3JkKWApfTtcbiAgICAgICAgICAgIGNvbF9pbmRleCArPSAxO2A7cmV0dXJuICRlKz1gXG4gICAgICAgICAgICB2YXIgYl92YWx1ZTogdTMyO1xuICAgICAgICAgICAgbGV0IGJfbWFzazogdTMyID0gMHgwRjBGMEYwRnU7XG4gICAgICAgICAgICB2YXIgYl92YWx1ZV9sb3dlcjogdmVjNDx1MzI+O1xuICAgICAgICAgICAgdmFyIGJfdmFsdWVfdXBwZXI6IHZlYzQ8dTMyPjtcbiAgICAgICAgICAgIHZhciBiX3F1YW50aXplZF92YWx1ZXM6ICR7Sn07XG4gICAgICAgICAgICB2YXIgYl9kZXF1YW50aXplZF92YWx1ZXM6ICR7Sn07YCwkZX07cmV0dXJuYFxuICAgICAgICB2YXI8d29ya2dyb3VwPiB3b3JrZ3JvdXBfc2hhcmVkOiBhcnJheTwke1kudHlwZS52YWx1ZX0sICR7eCp2fT47XG4gICAgICAgICR7RC5kZWNsYXJlVmFyaWFibGVzKC4uLlYsWSl9XG4gICAgICAgICR7RC5tYWluU3RhcnQoW3YsMSwxXSl9XG4gICAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHtZLm9mZnNldFRvSW5kaWNlcyhgKGdsb2JhbF9pZHggLyAke3Z9KSAqICR7eH1gKX07XG4gICAgICAgICAgbGV0IGNvbCA9IG91dHB1dF9pbmRpY2VzWzJdO1xuICAgICAgICAgIGxldCByb3cgPSBvdXRwdXRfaW5kaWNlc1sxXTtcbiAgICAgICAgICBsZXQgYmF0Y2ggPSBvdXRwdXRfaW5kaWNlc1swXTtcbiAgICAgICAgICBsZXQgbkJsb2Nrc1BlckNvbCA9IHVuaWZvcm1zLmJfc2hhcGVbMV07XG5cbiAgICAgICAgICBmb3IgKHZhciBibG9jayA9IGxvY2FsX2lkLng7IGJsb2NrIDwgbkJsb2Nrc1BlckNvbDsgYmxvY2sgKz0gJHt2fSkge1xuICAgICAgICAgICAgLy9wcm9jZXNzIG9uZSBibG9ja1xuICAgICAgICAgICAgdmFyIHdvcmRfb2Zmc2V0OiB1MzIgPSBibG9jayAqICR7dC5ibG9ja1NpemUvaH07XG4gICAgICAgICAgICAke2JlKCl9XG4gICAgICAgICAgICBmb3IgKHZhciB3b3JkOiB1MzIgPSAwOyB3b3JkIDwgJHttfTsgd29yZCArPSAke199KSB7XG4gICAgICAgICAgICAgICR7T2UoKX1cbiAgICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8ICR7X307IGkrKykge1xuICAgICAgICAgICAgICAgICR7bmUoKX1cbiAgICAgICAgICAgICAgICB3b3JkX29mZnNldCArPSAkezgvaH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgICAgaWYgKGxvY2FsX2lkLnggPCAke3h9KSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0X3ZhbHVlOiAke1kudHlwZS52YWx1ZX0gPSAke1kudHlwZS52YWx1ZX0oMCk7XG4gICAgICAgICAgICB2YXIgd29ya2dyb3VwX3NoYXJlZF9vZmZzZXQ6IHUzMiA9IGxvY2FsX2lkLng7XG4gICAgICAgICAgICBmb3IgKHZhciBiOiB1MzIgPSAwdTsgYiA8ICR7dn11OyBiKyspIHtcbiAgICAgICAgICAgICAgb3V0cHV0X3ZhbHVlICs9IHdvcmtncm91cF9zaGFyZWRbd29ya2dyb3VwX3NoYXJlZF9vZmZzZXRdO1xuICAgICAgICAgICAgICB3b3JrZ3JvdXBfc2hhcmVkX29mZnNldCArPSAke3h9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHtZLnNldEJ5SW5kaWNlcyhgJHtZLnR5cGUuaW5kaWNlc30oYmF0Y2gsIHJvdywgY29sICsgbG9jYWxfaWQueClgLFwib3V0cHV0X3ZhbHVlXCIpfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1gfTtyZXR1cm57bmFtZTpcIk1hdE11bE5CaXRzXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5ibG9ja1NpemV9OyR7dC5iaXRzfTske2h9OyR7X307JHt5fTske3h9OyR7dn1gLGlucHV0RGVwZW5kZW5jaWVzOkFycmF5KGUubGVuZ3RoKS5maWxsKFwicmFua1wiKX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpnLGRhdGFUeXBlOnV9XSxkaXNwYXRjaEdyb3VwOnt4OiR9LHByb2dyYW1Vbmlmb3JtczpTfSksZ2V0U2hhZGVyU291cmNlOlB9fSxtaD0oZSx0KT0+e2xldCByPWVbMF0uZGltcyxuPXIubGVuZ3RoLG89cltuLTJdLGk9dC5rLGE9dC5uLGQ9ci5zbGljZSgwLG4tMiksbD1DLnNpemUoZCksbT1lWzFdLmRpbXNbMl0vNCx1PWVbMF0uZGF0YVR5cGUsaD1tZSh0LmspLF89bWUobSkseT1kLmNvbmNhdChbbyxhXSksZz0xMjgseD1hJTg9PT0wPzg6YSU0PT09MD80OjEsJD1nL3gsdj0kKl8qOCxTPXYvaCxUPXYvdC5ibG9ja1NpemUsQT1DLnNpemUoeSkveCxrPVtdLFA9W2wsbyxpL2hdLEQ9Qy5jb252ZXJ0U2hhcGUoZVsxXS5kaW1zKS5zbGljZSgpO0Quc3BsaWNlKC0xLDEsbS9fKSxrLnB1c2goLi4uTihQKSksay5wdXNoKC4uLk4oRCkpLGsucHVzaCguLi5OKGVbMl0uZGltcykpLGUubGVuZ3RoPT09NCYmay5wdXNoKC4uLk4oQy5jb252ZXJ0U2hhcGUoZVszXS5kaW1zKSkpO2xldCBSPVtsLG8sYV07ay5wdXNoKC4uLk4oUikpO2xldCBHPUs9PntsZXQgaj1QLmxlbmd0aCxWPUUoXCJhXCIsZVswXS5kYXRhVHlwZSxqLGgpLFE9RShcImJcIiwxMixELmxlbmd0aCxfKSxzZT1FKFwic2NhbGVzXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMubGVuZ3RoKSxZPVtWLFEsc2VdLGVlPWUubGVuZ3RoPT09ND9FKFwiemVyb19wb2ludHNcIiwxMixlWzNdLmRpbXMubGVuZ3RoKTp2b2lkIDA7ZWUmJlkucHVzaChlZSk7bGV0IEo9Ui5sZW5ndGgsbmU9TShcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsSiksYmU9X2UoZVswXS5kYXRhVHlwZSksT2U9KCk9Pntzd2l0Y2goaCl7Y2FzZSAxOnJldHVybmBcbiAgICAgICAgICBsZXQgYV9kYXRhMCA9IHZlYzQ8JHtiZX0+KHN1Yl9hW3dvcmRfb2Zmc2V0XSwgc3ViX2Fbd29yZF9vZmZzZXQgKyAxXSwgc3ViX2Fbd29yZF9vZmZzZXQgKyAyXSwgc3ViX2Fbd29yZF9vZmZzZXQgKyAzXSk7XG4gICAgICAgICAgbGV0IGFfZGF0YTEgPSB2ZWM0PCR7YmV9PihzdWJfYVt3b3JkX29mZnNldCArIDRdLCBzdWJfYVt3b3JkX29mZnNldCArIDVdLCBzdWJfYVt3b3JkX29mZnNldCArIDZdLCBzdWJfYVt3b3JkX29mZnNldCArIDddKTtgO2Nhc2UgMjpyZXR1cm5gXG4gICAgICAgICAgbGV0IGFfZGF0YTAgPSB2ZWM0PCR7YmV9PihzdWJfYVt3b3JkX29mZnNldF0sIHN1Yl9hW3dvcmRfb2Zmc2V0ICsgMV0pO1xuICAgICAgICAgIGxldCBhX2RhdGExID0gdmVjNDwke2JlfT4oc3ViX2Fbd29yZF9vZmZzZXQgKyAyXSwgc3ViX2Fbd29yZF9vZmZzZXQgKyAzXSk7YDtjYXNlIDQ6cmV0dXJuYFxuICAgICAgICAgIGxldCBhX2RhdGEwID0gc3ViX2Fbd29yZF9vZmZzZXRdO1xuICAgICAgICAgIGxldCBhX2RhdGExID0gc3ViX2Fbd29yZF9vZmZzZXQgKyAxXTtgO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGAke2h9LWNvbXBvbmVudCBpcyBub3Qgc3VwcG9ydGVkLmApfX07cmV0dXJuYFxuICAgICAgICB2YXI8d29ya2dyb3VwPiBzdWJfYTogYXJyYXk8JHtWLnR5cGUudmFsdWV9LCAke1N9PjtcbiAgICAgICAgdmFyPHdvcmtncm91cD4gaW50ZXJfcmVzdWx0czogYXJyYXk8YXJyYXk8JHtuZS50eXBlLnZhbHVlfSwgJHskfT4sICR7eH0+O1xuICAgICAgICAke0suZGVjbGFyZVZhcmlhYmxlcyguLi5ZLG5lKX1cbiAgICAgICAgJHtLLm1haW5TdGFydChbJCx4LDFdKX1cbiAgICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke25lLm9mZnNldFRvSW5kaWNlcyhgd29ya2dyb3VwX2luZGV4ICogJHt4fWApfTtcbiAgICAgICAgICBsZXQgY29sID0gb3V0cHV0X2luZGljZXNbMl07XG4gICAgICAgICAgbGV0IHJvdyA9IG91dHB1dF9pbmRpY2VzWzFdO1xuICAgICAgICAgIGxldCBiYXRjaCA9IG91dHB1dF9pbmRpY2VzWzBdO1xuICAgICAgICAgIGxldCBuX2Jsb2Nrc19wZXJfY29sID0gdW5pZm9ybXMuYl9zaGFwZVsxXTtcbiAgICAgICAgICBsZXQgbnVtX3RpbGVzID0gIChuX2Jsb2Nrc19wZXJfY29sIC0gMSkgLyAke1R9ICsgMTtcblxuICAgICAgICAgIC8vIExvb3Agb3ZlciBzaGFyZWQgZGltZW5zaW9uLlxuICAgICAgICAgIGZvciAodmFyIHRpbGU6IHUzMiA9IDA7IHRpbGUgPCBudW1fdGlsZXM7IHRpbGUgKz0gMSkge1xuICAgICAgICAgICAgbGV0IGFfY29sX3N0YXJ0ID0gdGlsZSAqICR7U307XG4gICAgICAgICAgICAvLyBsb2FkIG9uZSB0aWxlIEEgZGF0YSBpbnRvIHNoYXJlZCBtZW1vcnkuXG4gICAgICAgICAgICBmb3IgKHZhciBhX29mZnNldCA9IGxvY2FsX2lkeDsgYV9vZmZzZXQgPCAke1N9OyBhX29mZnNldCArPSAke2d9KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBsZXQgYV9jb2wgPSBhX2NvbF9zdGFydCArIGFfb2Zmc2V0O1xuICAgICAgICAgICAgICBpZiAoYV9jb2wgPCB1bmlmb3Jtcy5hX3NoYXBlWzJdKVxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3ViX2FbYV9vZmZzZXRdID0gJHtWLmdldEJ5SW5kaWNlcyhgJHtWLnR5cGUuaW5kaWNlc30oYmF0Y2gsIHJvdywgYV9jb2wpYCl9O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN1Yl9hW2Ffb2Zmc2V0XSA9ICR7Vi50eXBlLnZhbHVlfSgwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgICAgICAvLyBlYWNoIHRocmVhZCBwcm9jZXNzIG9uZSBibG9ja1xuICAgICAgICAgICAgbGV0IGJfcm93ID0gY29sICsgbG9jYWxfaWQueTtcbiAgICAgICAgICAgIGxldCBibG9jayA9IHRpbGUgKiAke1R9ICsgbG9jYWxfaWQueDtcbiAgICAgICAgICAgICR7ZWU/YFxuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfYnl0ZXNfcGVyX2NvbCA9IChuX2Jsb2Nrc19wZXJfY29sICsgMSkgLyAyO1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfYnl0ZV9jb3VudCA9IGJfcm93ICogemVyb19wb2ludF9ieXRlc19wZXJfY29sICsgKGJsb2NrID4+IDB4MXUpO1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfd29yZF9pbmRleCA9IHplcm9fcG9pbnRfYnl0ZV9jb3VudCA+PiAweDJ1O1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfYnl0ZV9vZmZzZXQgPSB6ZXJvX3BvaW50X2J5dGVfY291bnQgJiAweDN1O1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfbmliYmxlX29mZnNldDogdTMyID0gYmxvY2sgJiAweDF1O1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfYml0c19vZmZzZXQgPSAoemVyb19wb2ludF9ieXRlX29mZnNldCA8PCAzKSArICh6ZXJvX3BvaW50X25pYmJsZV9vZmZzZXQgPDwgMik7XG4gICAgICAgICAgICBsZXQgemVyb19wb2ludF93b3JkID0gJHtlZS5nZXRCeU9mZnNldChcInplcm9fcG9pbnRfd29yZF9pbmRleFwiKX0gPj4gemVyb19wb2ludF9iaXRzX29mZnNldDtcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50ID0gJHtiZX0oKHplcm9fcG9pbnRfd29yZCkgJiAweEZ1KTtgOmBcbiAgICAgICAgICAgIC8vIFRoZSBkZWZhdWx0IHplcm8gcG9pbnQgaXMgOCBmb3IgdW5zaWduZWQgNC1iaXQgcXVhbnRpemF0aW9uLlxuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnQgPSAke2JlfSg4KTtgfVxuICAgICAgICAgICAgbGV0IHNjYWxlID0gJHtzZS5nZXRCeU9mZnNldChcImJfcm93ICogbl9ibG9ja3NfcGVyX2NvbCArIGJsb2NrXCIpfTtcbiAgICAgICAgICAgIGxldCBiX2RhdGEgPSAke1EuZ2V0QnlJbmRpY2VzKGAke1EudHlwZS5pbmRpY2VzfShiX3JvdywgYmxvY2ssIDApYCl9O1xuICAgICAgICAgICAgdmFyIHdvcmRfb2Zmc2V0ID0gbG9jYWxfaWQueCAqICR7dC5ibG9ja1NpemUvaH07XG4gICAgICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgJHtffTsgaSsrKSB7XG4gICAgICAgICAgICAgICR7T2UoKX1cbiAgICAgICAgICAgICAgbGV0IGJfdmFsdWUgPSAke189PT0xP1wiYl9kYXRhXCI6XCJiX2RhdGFbaV1cIn07XG4gICAgICAgICAgICAgIGxldCBiX3ZhbHVlX2xvd2VyID0gdW5wYWNrNHhVOChiX3ZhbHVlICYgMHgwRjBGMEYwRnUpO1xuICAgICAgICAgICAgICBsZXQgYl92YWx1ZV91cHBlciA9IHVucGFjazR4VTgoKGJfdmFsdWUgPj4gNCkgJiAweDBGMEYwRjBGdSk7XG4gICAgICAgICAgICAgIGxldCBiX3F1YW50aXplZF92YWx1ZXMgPSBtYXQyeDQ8JHtiZX0+KCR7QXJyYXkuZnJvbSh7bGVuZ3RoOjR9LCgkZSxsZSk9PmAke2JlfShiX3ZhbHVlX2xvd2VyWyR7bGV9XSksICR7YmV9KGJfdmFsdWVfdXBwZXJbJHtsZX1dKWApLmpvaW4oXCIsIFwiKX0pO1xuICAgICAgICAgICAgICBsZXQgYl9kZXF1YW50aXplZF92YWx1ZXMgPSAoYl9xdWFudGl6ZWRfdmFsdWVzIC0gbWF0Mng0PCR7YmV9Pigke0FycmF5KDgpLmZpbGwoXCJ6ZXJvX3BvaW50XCIpLmpvaW4oXCIsXCIpfSkpICogc2NhbGU7XG4gICAgICAgICAgICAgIGludGVyX3Jlc3VsdHNbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gKz0gJHtBcnJheS5mcm9tKHtsZW5ndGg6Mn0sKCRlLGxlKT0+YCR7YGRvdChhX2RhdGEke2xlfSwgYl9kZXF1YW50aXplZF92YWx1ZXNbJHtsZX1dKWB9YCkuam9pbihcIiArIFwiKX07XG4gICAgICAgICAgICAgIHdvcmRfb2Zmc2V0ICs9ICR7OC9ofTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobG9jYWxfaWR4IDwgJHt4fSkge1xuICAgICAgICAgICAgdmFyIG91dHB1dF92YWx1ZTogJHtuZS50eXBlLnZhbHVlfSA9ICR7bmUudHlwZS52YWx1ZX0oMCk7XG4gICAgICAgICAgICBmb3IgKHZhciBiID0gMHU7IGIgPCAkeyR9OyBiKyspIHtcbiAgICAgICAgICAgICAgb3V0cHV0X3ZhbHVlICs9IGludGVyX3Jlc3VsdHNbbG9jYWxfaWR4XVtiXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb2wgKyBsb2NhbF9pZHggPCB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMl0pXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICR7bmUuc2V0QnlJbmRpY2VzKGAke25lLnR5cGUuaW5kaWNlc30oYmF0Y2gsIHJvdywgY29sICsgbG9jYWxfaWR4KWAsXCJvdXRwdXRfdmFsdWVcIil9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9YH07cmV0dXJue25hbWU6XCJCbG9ja3dpc2VNYXRNdWxOQml0czMyXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5ibG9ja1NpemV9OyR7aH07JHtffTskeyR9OyR7eH1gLGlucHV0RGVwZW5kZW5jaWVzOkFycmF5KGUubGVuZ3RoKS5maWxsKFwicmFua1wiKX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczp5LGRhdGFUeXBlOnV9XSxkaXNwYXRjaEdyb3VwOnt4OkF9LHByb2dyYW1Vbmlmb3JtczprfSksZ2V0U2hhZGVyU291cmNlOkd9fSxlbD0oZSx0KT0+e2NoKGUuaW5wdXRzLHQpLHQuYmxvY2tTaXplPT09MzImJmUuYWRhcHRlckluZm8uaXNWZW5kb3IoXCJpbnRlbFwiKSYmZS5hZGFwdGVySW5mby5pc0FyY2hpdGVjdHVyZShcImdlbi0xMmxwXCIpP2UuY29tcHV0ZShtaChlLmlucHV0cyx0KSk6ZS5jb21wdXRlKHBoKGUuaW5wdXRzLHQpKX0sdGw9ZT0+cmUoZSl9KTt2YXIgZmgsaGgsZ2gsYmgseWgsX2gsd2gsdmgsbmwsb2w9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTthZSgpO2ZoPWU9PntpZighZXx8ZS5sZW5ndGg8MSl0aHJvdyBuZXcgRXJyb3IoXCJUb28gZmV3IGlucHV0c1wiKTtpZihlWzBdLmRhdGFUeXBlIT09MSYmZVswXS5kYXRhVHlwZSE9PTEwKXRocm93IG5ldyBFcnJvcihcIklucHV0IHR5cGUgbXVzdCBiZSBmbG9hdCBvciBmbG9hdDE2LlwiKTtpZihlLmxlbmd0aD49Mil7bGV0IHQ9ZVswXS5kaW1zLmxlbmd0aCoyPT09ZVsxXS5kaW1zWzBdO2lmKGUubGVuZ3RoPT09NCYmKHQ9ZVszXS5kaW1zWzBdKjI9PT1lWzFdLmRpbXNbMF0pLCF0KXRocm93IG5ldyBFcnJvcihcIlRoZSBwYWRzIHNob3VsZCBiZSBhIDFEIHRlbnNvciBvZiBzaGFwZSBbMiAqIGlucHV0X3JhbmtdIG9yIFsyICogbnVtX2F4ZXNdLlwiKX19LGhoPShlLHQscik9PntsZXQgbj1cIlwiO2ZvcihsZXQgbz10LTE7bz49MDstLW8pbis9YFxuICAgICAgICAgICAgayA9IGkzMigke2UuaW5kaWNlc0dldChcImluZGljZXNcIixvKX0pIC0gJHtGKFwidW5pZm9ybXMucGFkc1wiLG8scil9O1xuICAgICAgICAgICAgaWYgKGsgPCAwKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGsgPj0gaTMyKCR7RihcInVuaWZvcm1zLnhfc2hhcGVcIixvLHQpfSkpIHtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgKz0gayAqIGkzMigke0YoXCJ1bmlmb3Jtcy54X3N0cmlkZXNcIixvLHQpfSk7XG4gICAgICAgIGA7cmV0dXJuYFxuICAgICAgICAgIHZhbHVlID0gJHtlLnR5cGUudmFsdWV9KHVuaWZvcm1zLmNvbnN0YW50X3ZhbHVlKTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE7IGkrKykge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgICAgICAke259XG4gICAgICAgICAgICB2YWx1ZSA9IHhbb2Zmc2V0XTtcbiAgICAgICAgICB9XG4gICAgICBgfSxnaD0oZSx0LHIpPT57bGV0IG49XCJcIjtmb3IobGV0IG89dC0xO28+PTA7LS1vKW4rPWBcbiAgICAgICAgICAgICAgICBrID0gaTMyKCR7ZS5pbmRpY2VzR2V0KFwiaW5kaWNlc1wiLG8pfSkgLSAke0YoXCJ1bmlmb3Jtcy5wYWRzXCIsbyxyKX07XG4gICAgICAgICAgICAgICAgaWYgKGsgPCAwKSB7XG4gICAgICAgICAgICAgICAgICBrID0gLWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGxldCBfMm5fMSA9IDIgKiAoaTMyKCR7RihcInVuaWZvcm1zLnhfc2hhcGVcIixvLHQpfSkgLSAxKTtcbiAgICAgICAgICAgICAgICAgIGsgPSBrICUgXzJuXzE7XG4gICAgICAgICAgICAgICAgICBpZihrID49IGkzMigke0YoXCJ1bmlmb3Jtcy54X3NoYXBlXCIsbyx0KX0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGsgPSBfMm5fMSAtIGs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBrICogaTMyKCR7RihcInVuaWZvcm1zLnhfc3RyaWRlc1wiLG8sdCl9KTtcbiAgICAgICAgICAgIGA7cmV0dXJuYFxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgICAke259XG4gICAgICAgICAgICAgIHZhbHVlID0geFtvZmZzZXRdO1xuICAgICAgICAgIGB9LGJoPShlLHQscik9PntsZXQgbj1cIlwiO2ZvcihsZXQgbz10LTE7bz49MDstLW8pbis9YFxuICAgICAgICAgICAgICAgIGsgPSBpMzIoJHtlLmluZGljZXNHZXQoXCJpbmRpY2VzXCIsbyl9KSAtICR7RihcInVuaWZvcm1zLnBhZHNcIixvLHIpfTtcbiAgICAgICAgICAgICAgICBpZiAoayA8IDApIHtcbiAgICAgICAgICAgICAgICAgIGsgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoayA+PSBpMzIoJHtGKFwidW5pZm9ybXMueF9zaGFwZVwiLG8sdCl9KSkge1xuICAgICAgICAgICAgICAgICAgayA9IGkzMigke0YoXCJ1bmlmb3Jtcy54X3NoYXBlXCIsbyx0KX0pIC0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGsgKiBpMzIoJHtGKFwidW5pZm9ybXMueF9zdHJpZGVzXCIsbyx0KX0pO1xuICAgICAgICAgICAgYDtyZXR1cm5gXG4gICAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgICAgICAgICR7bn1cbiAgICAgICAgICAgICAgdmFsdWUgPSB4W29mZnNldF07XG4gICAgICAgICAgYH0seWg9KGUsdCxyKT0+e2xldCBuPVwiXCI7Zm9yKGxldCBvPXQtMTtvPj0wOy0tbyluKz1gXG4gICAgICAgICAgICAgICAgayA9IGkzMigke2UuaW5kaWNlc0dldChcImluZGljZXNcIixvKX0pIC0gJHtGKFwidW5pZm9ybXMucGFkc1wiLG8scil9O1xuICAgICAgICAgICAgICAgIGlmIChrIDwgMCkgIHtcbiAgICAgICAgICAgICAgICAgIGsgKz0gaTMyKCR7RihcInVuaWZvcm1zLnhfc2hhcGVcIixvLHQpfV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoayA+PSBpMzIoJHtGKFwidW5pZm9ybXMueF9zaGFwZVwiLG8sdCl9KSkge1xuICAgICAgICAgICAgICAgICAgayAtPSBpMzIoJHtGKFwidW5pZm9ybXMueF9zaGFwZVwiLG8sdCl9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGsgKiBpMzIoJHtGKFwidW5pZm9ybXMueF9zdHJpZGVzXCIsbyx0KX0pO1xuICAgICAgICAgICAgYDtyZXR1cm5gXG4gICAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgICB2YXIgayA9IDA7XG4gICAgICAgICAgICAgICR7bn1cbiAgICAgICAgICAgICAgdmFsdWUgPSB4W29mZnNldF07XG4gICAgICAgICAgYH0sX2g9KGUsdCxyKT0+e3N3aXRjaChyLm1vZGUpe2Nhc2UgMDpyZXR1cm4gaGgoZSx0LHIucGFkcy5sZW5ndGgpO2Nhc2UgMTpyZXR1cm4gZ2goZSx0LHIucGFkcy5sZW5ndGgpO2Nhc2UgMjpyZXR1cm4gYmgoZSx0LHIucGFkcy5sZW5ndGgpO2Nhc2UgMzpyZXR1cm4geWgoZSx0LHIucGFkcy5sZW5ndGgpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBtb2RlXCIpfX0sd2g9KGUsdCk9PntsZXQgcj1DLnBhZFNoYXBlKGVbMF0uZGltcy5zbGljZSgpLHQucGFkcyksbj1lWzBdLmRpbXMsbz1DLnNpemUociksaT1be3R5cGU6MTIsZGF0YTpvfSx7dHlwZTo2LGRhdGE6dC5wYWRzfV0sYT1lLmxlbmd0aD49MyYmZVsyXS5kYXRhO3QubW9kZT09PTAmJmkucHVzaCh7dHlwZTphP2VbMl0uZGF0YVR5cGU6MSxkYXRhOnQudmFsdWV9KSxpLnB1c2goLi4uTihlWzBdLmRpbXMscikpO2xldCBkPVtcInJhbmtcIl0sbD1wPT57bGV0IG09TShcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsci5sZW5ndGgpLHU9RShcInhcIixlWzBdLmRhdGFUeXBlLG4ubGVuZ3RoKSxoPXUudHlwZS52YWx1ZSxfPV9oKG0sbi5sZW5ndGgsdCkseT1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJwYWRzXCIsdHlwZTpcImkzMlwiLGxlbmd0aDp0LnBhZHMubGVuZ3RofV07cmV0dXJuIHQubW9kZT09PTAmJnkucHVzaCh7bmFtZTpcImNvbnN0YW50X3ZhbHVlXCIsdHlwZTphP2g6XCJmMzJcIn0pLGBcbiAgICAgICAgICAgICR7cC5yZWdpc3RlclVuaWZvcm1zKHkpLmRlY2xhcmVWYXJpYWJsZXModSxtKX1cbiAgICAgICAgICAgICR7cC5tYWluU3RhcnQoKX1cbiAgICAgICAgICAgICR7cC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG5cbiAgICAgICAgICAgIGxldCBpbmRpY2VzID0gJHttLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSAke2h9KDApO1xuICAgICAgICAgICAgJHtffVxuICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gdmFsdWU7XG4gICAgICAgIH1gfTtyZXR1cm57bmFtZTpcIlBhZFwiLHNoYWRlckNhY2hlOntoaW50OmAke3QubW9kZX0ke2F9YCxpbnB1dERlcGVuZGVuY2llczpkfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnIsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKEMuc2l6ZShyKS82NCl9LHByb2dyYW1Vbmlmb3JtczppfSksZ2V0U2hhZGVyU291cmNlOmx9fSx2aD0oZSx0KT0+e2lmKGUubGVuZ3RoPjEpe2xldCByPWVbMV0uZ2V0QmlnSW50NjRBcnJheSgpLG49ZS5sZW5ndGg+PTMmJmVbMl0uZGF0YT9lWzJdLmRhdGFUeXBlPT09MTA/ZVsyXS5nZXRVaW50MTZBcnJheSgpWzBdOmVbMl0uZ2V0RmxvYXQzMkFycmF5KClbMF06MCxvPWVbMF0uZGltcy5sZW5ndGgsaT1uZXcgSW50MzJBcnJheSgyKm8pLmZpbGwoMCk7aWYoZS5sZW5ndGg+PTQpe2xldCBkPWVbM10uZ2V0QmlnSW50NjRBcnJheSgpO2ZvcihsZXQgbD0wO2w8ZC5sZW5ndGg7bCsrKWlbTnVtYmVyKGRbbF0pXT1OdW1iZXIocltsXSksaVtOdW1iZXIoZFtsXSkrb109TnVtYmVyKHJbbCtkLmxlbmd0aF0pfWVsc2Ugci5mb3JFYWNoKChkLGwpPT5pW051bWJlcihsKV09TnVtYmVyKGQpKTtsZXQgYT1bXTtyZXR1cm4gaS5mb3JFYWNoKGQ9PmEucHVzaChkKSkse21vZGU6dC5tb2RlLHZhbHVlOm4scGFkczphfX1lbHNlIHJldHVybiB0fSxubD0oZSx0KT0+e2ZoKGUuaW5wdXRzKTtsZXQgcj12aChlLmlucHV0cyx0KTtlLmNvbXB1dGUod2goZS5pbnB1dHMscikse2lucHV0czpbMF19KX19KTt2YXIgdG4saWwsYWwsc2wsdWwsJGgseGgsZGwsbGwsY2wscGwsbWwsZmwsaGwsZ2wsYmwseWwsX2wsd2wsdmw9VSgoKT0+e1widXNlIHN0cmljdFwiO1dlKCk7dGUoKTtvZSgpO2FlKCk7dG49ZT0+e2lmKHZlLndlYmdwdS52YWxpZGF0ZUlucHV0Q29udGVudCYmKCFlfHxlLmxlbmd0aCE9PTEpKXRocm93IG5ldyBFcnJvcihcIlBvb2wgb3BzIHJlcXVpcmVzIDEgaW5wdXQuXCIpfSxpbD0oZSx0LHIpPT57bGV0IG49dC5mb3JtYXQ9PT1cIk5IV0NcIixvPWUuZGltcy5zbGljZSgpO24mJm8uc3BsaWNlKDEsMCxvLnBvcCgpKTtsZXQgaT1PYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbCh0LFwiZGlsYXRpb25zXCIpLGE9dC5rZXJuZWxTaGFwZS5zbGljZSgpLGQ9dC5zdHJpZGVzLnNsaWNlKCksbD1pP3QuZGlsYXRpb25zLnNsaWNlKCk6W10scD10LnBhZHMuc2xpY2UoKTtBdC5hZGp1c3RQb29sQXR0cmlidXRlcyhyLG8sYSxkLGwscCk7bGV0IG09QXQuY29tcHV0ZVBvb2xPdXRwdXRTaGFwZShyLG8sZCxsLGEscCx0LmF1dG9QYWQpLHU9T2JqZWN0LmFzc2lnbih7fSx0KTtpP09iamVjdC5hc3NpZ24odSx7a2VybmVsU2hhcGU6YSxzdHJpZGVzOmQscGFkczpwLGRpbGF0aW9uczpsLGNhY2hlS2V5OnQuY2FjaGVLZXl9KTpPYmplY3QuYXNzaWduKHUse2tlcm5lbFNoYXBlOmEsc3RyaWRlczpkLHBhZHM6cCxjYWNoZUtleTp0LmNhY2hlS2V5fSk7bGV0IGg9bS5zbGljZSgpO3JldHVybiBoLnB1c2goaC5zcGxpY2UoMSwxKVswXSksW3Usbj9oOm1dfSxhbD0oZSx0KT0+e2xldCByPXQuZm9ybWF0PT09XCJOSFdDXCIsbj1DLnNpemUoZSksbz1DLnNpemUodC5rZXJuZWxTaGFwZSksaT1be3R5cGU6MTIsZGF0YTpufSx7dHlwZToxMixkYXRhOm99XSxhPVt7bmFtZTpcIm91dHB1dFNpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwia2VybmVsU2l6ZVwiLHR5cGU6XCJ1MzJcIn1dO2lmKHQua2VybmVsU2hhcGUubGVuZ3RoPD0yKXtsZXQgZD10Lmtlcm5lbFNoYXBlW3Qua2VybmVsU2hhcGUubGVuZ3RoLTFdLGw9dC5zdHJpZGVzW3Quc3RyaWRlcy5sZW5ndGgtMV0scD10LnBhZHNbdC5wYWRzLmxlbmd0aC8yLTFdLG09dC5wYWRzW3QucGFkcy5sZW5ndGgtMV0sdT0hIShwK20pO2kucHVzaCh7dHlwZToxMixkYXRhOmR9LHt0eXBlOjEyLGRhdGE6bH0se3R5cGU6MTIsZGF0YTpwfSx7dHlwZToxMixkYXRhOm19KSxhLnB1c2goe25hbWU6XCJrd1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJzd1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJwd1N0YXJ0XCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInB3RW5kXCIsdHlwZTpcInUzMlwifSk7bGV0IGg9ITE7aWYodC5rZXJuZWxTaGFwZS5sZW5ndGg9PT0yKXtsZXQgXz10Lmtlcm5lbFNoYXBlW3Qua2VybmVsU2hhcGUubGVuZ3RoLTJdLHk9dC5zdHJpZGVzW3Quc3RyaWRlcy5sZW5ndGgtMl0sZz10LnBhZHNbdC5wYWRzLmxlbmd0aC8yLTJdLHg9dC5wYWRzW3QucGFkcy5sZW5ndGgtMl07aD0hIShnK3gpLGkucHVzaCh7dHlwZToxMixkYXRhOl99LHt0eXBlOjEyLGRhdGE6eX0se3R5cGU6MTIsZGF0YTpnfSx7dHlwZToxMixkYXRhOnh9KSxhLnB1c2goe25hbWU6XCJraFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJzaFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJwaFN0YXJ0XCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInBoRW5kXCIsdHlwZTpcInUzMlwifSl9cmV0dXJuW2ksYSwhMCx1LGhdfWVsc2V7aWYocil0aHJvdyBuZXcgRXJyb3IoXCJQb29saW5nIHdpdGgga2VybmVsU2hhcGUubGVuZ3RoID4gMiBpcyBub3Qgc3VwcG9ydGVkIGZvciBOSFdDIGZvcm1hdC5cIik7bGV0IGQ9Qy5jb21wdXRlU3RyaWRlcyh0Lmtlcm5lbFNoYXBlKTtpLnB1c2goe3R5cGU6MTIsZGF0YTpkfSx7dHlwZToxMixkYXRhOnQucGFkc30se3R5cGU6MTIsZGF0YTp0LnN0cmlkZXN9KSxhLnB1c2goe25hbWU6XCJrZXJuZWxTdHJpZGVzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDpkLmxlbmd0aH0se25hbWU6XCJwYWRzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDp0LnBhZHMubGVuZ3RofSx7bmFtZTpcInN0cmlkZXNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOnQuc3RyaWRlcy5sZW5ndGh9KTtsZXQgbD10LnBhZHMucmVkdWNlKChwLG0pPT5wK20pO3JldHVybltpLGEsISFsLCExLCExXX19LHNsPShlLHQscixuLG8saSxhLGQsbCxwLG0sdSk9PntsZXQgaD1vLmZvcm1hdD09PVwiTkhXQ1wiLF89dC50eXBlLnZhbHVlLHk9TShcIm91dHB1dFwiLHQudHlwZS50ZW5zb3Isbik7aWYoby5rZXJuZWxTaGFwZS5sZW5ndGg8PTIpe2xldCBnPVwiXCIseD1cIlwiLCQ9XCJcIix2PXItKGg/MjoxKTtpZihtP2c9YFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgdW5pZm9ybXMua3c7IGkrKykge1xuICAgICAgICAgICAgICAgICAgeEluZGljZXNbJHt2fV0gPSBpbmRpY2VzWyR7dn1dICogdW5pZm9ybXMuc3cgLSB1bmlmb3Jtcy5wd1N0YXJ0ICsgaTtcbiAgICAgICAgICAgICAgICAgIGlmICh4SW5kaWNlc1ske3Z9XSA8IDAgfHwgeEluZGljZXNbJHt2fV1cbiAgICAgICAgICAgICAgICAgICAgICA+PSB1bmlmb3Jtcy54X3NoYXBlWyR7dn1dKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhZCsrO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGxldCB4X3ZhbCA9IHhbJHt0LmluZGljZXNUb09mZnNldChcInhJbmRpY2VzXCIpfV07XG4gICAgICAgICAgICAgICAgICAke2l9XG4gICAgICAgICAgICAgICAgfWA6Zz1gXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCB1bmlmb3Jtcy5rdzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICB4SW5kaWNlc1ske3Z9XSA9IGluZGljZXNbJHt2fV0gKiB1bmlmb3Jtcy5zdyAtIHVuaWZvcm1zLnB3U3RhcnQgKyBpO1xuICAgICAgICAgICAgICAgICAgbGV0IHhfdmFsID0geFske3QuaW5kaWNlc1RvT2Zmc2V0KFwieEluZGljZXNcIil9XTtcbiAgICAgICAgICAgICAgICAgICR7aX1cbiAgICAgICAgICAgICAgICB9YCxvLmtlcm5lbFNoYXBlLmxlbmd0aD09PTIpe2xldCBUPXItKGg/MzoyKTt1P3g9YFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGo6IHUzMiA9IDB1OyBqIDwgdW5pZm9ybXMua2g7IGorKykge1xuICAgICAgICAgICAgICAgICAgeEluZGljZXNbJHtUfV0gPSBpbmRpY2VzWyR7VH1dICogdW5pZm9ybXMuc2ggLSB1bmlmb3Jtcy5waFN0YXJ0ICsgajtcbiAgICAgICAgICAgICAgICAgIGlmICh4SW5kaWNlc1ske1R9XSA8IDAgfHwgeEluZGljZXNbJHtUfV0gPj0gdW5pZm9ybXMueF9zaGFwZVske1R9XSkge1xuICAgICAgICAgICAgICAgICAgICBwYWQgKz0gaTMyKHVuaWZvcm1zLmt3KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGA6eD1gXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgajogdTMyID0gMHU7IGogPCB1bmlmb3Jtcy5raDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICB4SW5kaWNlc1ske1R9XSA9IGluZGljZXNbJHtUfV0gKiB1bmlmb3Jtcy5zaCAtIHVuaWZvcm1zLnBoU3RhcnQgKyBqO1xuICAgICAgICAgICAgICAgIGAsJD1gXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGB9cmV0dXJuYFxuICAgICAgICAgICAgJHtlLnJlZ2lzdGVyVW5pZm9ybXMobCkuZGVjbGFyZVZhcmlhYmxlcyh0LHkpfVxuXG4gICAgICAgICAgICAke2UubWFpblN0YXJ0KCl9XG4gICAgICAgICAgICAgICR7ZS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0U2l6ZVwiKX1cblxuICAgICAgICAgICAgICBsZXQgaW5kaWNlcyA9ICR7eS5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgICAgICAgICAgdmFyIHhJbmRpY2VzID0gJHt5Lm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuXG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9ICR7X30oJHtkfSk7XG4gICAgICAgICAgICAgIHZhciBwYWQgPSAwO1xuICAgICAgICAgICAgICAke3h9XG4gICAgICAgICAgICAgICR7Z31cbiAgICAgICAgICAgICAgJHskfVxuICAgICAgICAgICAgICAke2F9XG5cbiAgICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gdmFsdWU7XG4gICAgICAgICAgICB9YH1lbHNle2lmKGgpdGhyb3cgbmV3IEVycm9yKFwiUG9vbGluZyB3aXRoIGtlcm5lbFNoYXBlLmxlbmd0aCA+IDIgaXMgbm90IHN1cHBvcnRlZCBmb3IgTkhXQyBmb3JtYXQuXCIpO2xldCBnPW8ua2VybmVsU2hhcGUubGVuZ3RoLHg9by5wYWRzLmxlbmd0aCwkPVwiXCI7cmV0dXJuIHA/JD1gXG4gICAgICAgICAgICAgICAgaWYgKHhJbmRpY2VzW2pdID49IHVuaWZvcm1zLnhfc2hhcGVbal0pIHtcbiAgICAgICAgICAgICAgICAgIHBhZCsrO1xuICAgICAgICAgICAgICAgICAgaXNQYWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghaXNQYWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgeF92YWwgPSB4WyR7dC5pbmRpY2VzVG9PZmZzZXQoXCJ4SW5kaWNlc1wiKX1dO1xuICAgICAgICAgICAgICAgICR7aX1cbiAgICAgICAgICAgICAgfWA6JD1gXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGV0IHhfdmFsID0geFske3QuaW5kaWNlc1RvT2Zmc2V0KFwieEluZGljZXNcIil9XTtcbiAgICAgICAgICAgICAgJHtpfVxuICAgICAgICAgICAgYCxgXG4gICAgICAgICAgICAke2UucmVnaXN0ZXJVbmlmb3JtcyhsKS5kZWNsYXJlVmFyaWFibGVzKHQseSl9XG5cbiAgICAgICAgICAgICR7ZS5tYWluU3RhcnQoKX1cbiAgICAgICAgICAgICAgJHtlLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRTaXplXCIpfVxuICAgICAgICAgICAgICBsZXQgaW5kaWNlcyA9ICR7eS5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgICAgICAgICAgdmFyIHhJbmRpY2VzID0gJHt5Lm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuXG4gICAgICAgICAgICAgIHZhciBvZmZzZXRzOiBhcnJheTx1MzIsICR7Z30+O1xuXG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9ICR7X30oJHtkfSk7XG4gICAgICAgICAgICAgIHZhciBwYWQgPSAwO1xuICAgICAgICAgICAgICB2YXIgaXNQYWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwdTsgaSA8IHVuaWZvcm1zLmtlcm5lbFNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSBpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwdTsgaiA8ICR7Zy0xfXU7IGorKykge1xuICAgICAgICAgICAgICAgICAgb2Zmc2V0c1tqXSA9IG9mZnNldCAvICR7RihcInVuaWZvcm1zLmtlcm5lbFN0cmlkZXNcIixcImpcIixnKX07XG4gICAgICAgICAgICAgICAgICBvZmZzZXQgLT0gb2Zmc2V0c1tqXSAqICR7RihcInVuaWZvcm1zLmtlcm5lbFN0cmlkZXNcIixcImpcIixnKX07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldHNbJHtnLTF9XSA9IG9mZnNldDtcblxuICAgICAgICAgICAgICAgIGlzUGFkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9ICR7ci1nfXU7IGogPCAke3J9dTsgaisrKSB7XG4gICAgICAgICAgICAgICAgICB4SW5kaWNlc1tqXSA9IGluZGljZXNbal0gKiAke0YoXCJ1bmlmb3Jtcy5zdHJpZGVzXCIsYGogLSAke3ItZ311YCxnKX1cbiAgICAgICAgICAgICAgICAgICAgKyBvZmZzZXRzW2ogLSAke3ItZ311XSAtICR7RihcInVuaWZvcm1zLnBhZHNcIixcImogLSAydVwiLHgpfTtcbiAgICAgICAgICAgICAgICAgICR7JH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAke2F9XG5cbiAgICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gdmFsdWU7XG4gICAgICAgICAgICB9YH19LHVsPWU9PmAke2UuZm9ybWF0fTske2UuY2VpbE1vZGV9OyR7ZS5hdXRvUGFkfTske2Uua2VybmVsU2hhcGUubGVuZ3RofWAsJGg9ZT0+YCR7dWwoZSl9OyR7ZS5jb3VudEluY2x1ZGVQYWR9YCx4aD1lPT5gJHt1bChlKX07JHtlLnN0b3JhZ2VPcmRlcn07JHtlLmRpbGF0aW9uc31gLGRsPWU9Pih7Zm9ybWF0OmUuZm9ybWF0LGF1dG9QYWQ6W1wiTk9UU0VUXCIsXCJWQUxJRFwiLFwiU0FNRV9VUFBFUlwiLFwiU0FNRV9MT1dFUlwiXVtlLmF1dG9fcGFkXSxjZWlsTW9kZTplLmNlaWxfbW9kZSxrZXJuZWxTaGFwZTplLmtlcm5lbF9zaGFwZSxzdHJpZGVzOmUuc3RyaWRlcyxwYWRzOmUucGFkc30pLGxsPShlLHQscixuKT0+e2xldFtvLGldPWlsKHQsbixyKSxhPUUoXCJ4XCIsdC5kYXRhVHlwZSx0LmRpbXMubGVuZ3RoKSxkPWEudHlwZS52YWx1ZSxsPVwidmFsdWUgKz0geF92YWw7XCIscD1cIlwiO28uY291bnRJbmNsdWRlUGFkP3ArPWB2YWx1ZSAvPSAke2R9KHVuaWZvcm1zLmtlcm5lbFNpemUpO2A6cCs9YHZhbHVlIC89ICR7ZH0oaTMyKHVuaWZvcm1zLmtlcm5lbFNpemUpIC0gcGFkKTtgO2xldFttLHUsaCxfLHldPWFsKGksbyk7bS5wdXNoKC4uLk4odC5kaW1zLGkpKTtsZXQgZz1bXCJyYW5rXCJdO3JldHVybntuYW1lOmUsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7bi5jYWNoZUtleX07JHtofTske199OyR7eX1gLGlucHV0RGVwZW5kZW5jaWVzOmd9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6aSxkYXRhVHlwZTp0LmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoQy5zaXplKGkpLzY0KX0scHJvZ3JhbVVuaWZvcm1zOm19KSxnZXRTaGFkZXJTb3VyY2U6eD0+c2woeCxhLHQuZGltcy5sZW5ndGgsaS5sZW5ndGgsbyxsLHAsMCx1LGgsXyx5KX19LGNsPWU9PntsZXQgdD1lLmNvdW50X2luY2x1ZGVfcGFkIT09MCxyPWRsKGUpO2lmKHIuY2VpbE1vZGUhPT0wKXRocm93IG5ldyBFcnJvcihcInVzaW5nIGNlaWwoKSBpbiBzaGFwZSBjb21wdXRhdGlvbiBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgQXZlcmFnZVBvb2xcIik7bGV0IG49e2NvdW50SW5jbHVkZVBhZDp0LC4uLnIsY2FjaGVLZXk6XCJcIn07cmV0dXJuey4uLm4sY2FjaGVLZXk6JGgobil9fSxwbD0oZSx0KT0+e3RuKGUuaW5wdXRzKSxlLmNvbXB1dGUobGwoXCJBdmVyYWdlUG9vbFwiLGUuaW5wdXRzWzBdLCExLHQpKX0sbWw9e2F1dG9QYWQ6XCJcIixjZWlsTW9kZTowLGNvdW50SW5jbHVkZVBhZDohMSxrZXJuZWxTaGFwZTpbXSxzdHJpZGVzOltdLHBhZHM6W10sc3RvcmFnZU9yZGVyOjAsZGlsYXRpb25zOltdfSxmbD1lPT57bGV0IHQ9ZS5mb3JtYXQ7cmV0dXJue2Zvcm1hdDp0LC4uLm1sLGNhY2hlS2V5OnR9fSxobD0oZSx0KT0+e3RuKGUuaW5wdXRzKSxlLmNvbXB1dGUobGwoXCJHbG9iYWxBdmVyYWdlUG9vbFwiLGUuaW5wdXRzWzBdLCEwLHQpKX0sZ2w9KGUsdCxyLG4pPT57bGV0W28saV09aWwodCxuLHIpLGE9YFxuICAgICAgdmFsdWUgPSBtYXgoeF92YWwsIHZhbHVlKTtcbiAgICBgLGQ9XCJcIixsPUUoXCJ4XCIsdC5kYXRhVHlwZSx0LmRpbXMubGVuZ3RoKSxwPVtcInJhbmtcIl0sW20sdSxoLF8seV09YWwoaSxvKTtyZXR1cm4gbS5wdXNoKC4uLk4odC5kaW1zLGkpKSx7bmFtZTplLHNoYWRlckNhY2hlOntoaW50OmAke24uY2FjaGVLZXl9OyR7aH07JHtffTske3l9YCxpbnB1dERlcGVuZGVuY2llczpwfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmksZGF0YVR5cGU6dC5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKEMuc2l6ZShpKS82NCl9LHByb2dyYW1Vbmlmb3JtczptfSksZ2V0U2hhZGVyU291cmNlOmc9PnNsKGcsbCx0LmRpbXMubGVuZ3RoLGkubGVuZ3RoLG8sYSxkLHQuZGF0YVR5cGU9PT0xMD8tNjU1MDQ6LTFlNSx1LGgsXyx5KX19LGJsPShlLHQpPT57dG4oZS5pbnB1dHMpLGUuY29tcHV0ZShnbChcIk1heFBvb2xcIixlLmlucHV0c1swXSwhMSx0KSl9LHlsPWU9PntsZXQgdD1lLnN0b3JhZ2Vfb3JkZXIscj1lLmRpbGF0aW9ucyxuPWRsKGUpO2lmKHQhPT0wKXRocm93IG5ldyBFcnJvcihcImNvbHVtbiBtYWpvciBzdG9yYWdlIG9yZGVyIGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGZvciBNYXhQb29sXCIpO2lmKG4uY2VpbE1vZGUhPT0wKXRocm93IG5ldyBFcnJvcihcInVzaW5nIGNlaWwoKSBpbiBzaGFwZSBjb21wdXRhdGlvbiBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgTWF4UG9vbFwiKTtsZXQgbz17c3RvcmFnZU9yZGVyOnQsZGlsYXRpb25zOnIsLi4ubixjYWNoZUtleTpcIlwifTtyZXR1cm57Li4ubyxjYWNoZUtleTp4aChvKX19LF9sPWU9PntsZXQgdD1lLmZvcm1hdDtyZXR1cm57Zm9ybWF0OnQsLi4ubWwsY2FjaGVLZXk6dH19LHdsPShlLHQpPT57dG4oZS5pbnB1dHMpLGUuY29tcHV0ZShnbChcIkdsb2JhbE1heFBvb2xcIixlLmlucHV0c1swXSwhMCx0KSl9fSk7dmFyIFRoLEloLCRsLHhsLFNsPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7U2UoKTthZSgpO1RoPShlLHQpPT57aWYoZS5sZW5ndGg8Mnx8ZS5sZW5ndGg+Myl0aHJvdyBuZXcgRXJyb3IoXCJEZXF1YW50aXplTGluZWFyIHJlcXVpcmVzIDIgb3IgMyBpbnB1dHMuXCIpO2lmKGUubGVuZ3RoPT09MyYmZVsxXS5kaW1zPT09ZVsyXS5kaW1zKXRocm93IG5ldyBFcnJvcihcIngtc2NhbGUgYW5kIHgtemVyby1wb2ludCBtdXN0IGhhdmUgdGhlIHNhbWUgc2hhcGUuXCIpO2lmKGUubGVuZ3RoPT09MyYmZVswXS5kYXRhVHlwZSE9PWVbMl0uZGF0YVR5cGUpdGhyb3cgbmV3IEVycm9yKFwieCBhbmQgeC16ZXJvLXBvaW50IG11c3QgaGF2ZSB0aGUgc2FtZSBkYXRhIHR5cGUuXCIpO2lmKGVbMF0uZGF0YVR5cGU9PT02JiZlLmxlbmd0aD4yKXRocm93IG5ldyBFcnJvcihcIkluIHRoZSBjYXNlIG9mIGRlcXVhbnRpemluZyBpbnQzMiB0aGVyZSBpcyBubyB6ZXJvIHBvaW50LlwiKTtpZihlWzFdLmRpbXMubGVuZ3RoIT09MCYmZVsxXS5kaW1zLmxlbmd0aCE9PTEmJmVbMV0uZGltcy5sZW5ndGghPT1lWzBdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInNjYWxlIGlucHV0IG11c3QgYmUgYSBzY2FsYXIsIGEgMUQgdGVuc29yLCBvciBoYXZlIHRoZSBzYW1lIHJhbmsgYXMgdGhlIGlucHV0IHRlbnNvci5cIik7aWYoZS5sZW5ndGg+Mil7aWYoZVswXS5kYXRhVHlwZSE9PWVbMl0uZGF0YVR5cGUpdGhyb3cgbmV3IEVycm9yKFwieCBhbmQgeC16ZXJvLXBvaW50IG11c3QgaGF2ZSB0aGUgc2FtZSBkYXRhIHR5cGUuXCIpO2lmKGVbMV0uZGltcy5sZW5ndGghPT1lWzJdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcInNjYWxlIGFuZCB6ZXJvLXBvaW50IGlucHV0cyBtdXN0IGhhdmUgdGhlIHNhbWUgcmFuay5cIik7aWYoIWVbMV0uZGltcy5tYXAoKHIsbik9PnI9PT1lWzJdLmRpbXNbbl0pLnJlZHVjZSgocixuKT0+ciYmbiwhMCkpdGhyb3cgbmV3IEVycm9yKFwic2NhbGUgYW5kIHplcm8tcG9pbnQgaW5wdXRzIG11c3QgaGF2ZSB0aGUgc2FtZSBzaGFwZS5cIil9aWYodC5ibG9ja1NpemU+MCl7aWYoZVsxXS5kaW1zLmxlbmd0aD09PTB8fGVbMV0uZGltcy5sZW5ndGg9PT0xJiZlWzFdLmRpbXNbMF09PT0xKXRocm93IG5ldyBFcnJvcihcImJsb2NrU2l6ZSBtdXN0IGJlIHNldCBvbmx5IGZvciBibG9jayBxdWFudGl6YXRpb24uXCIpO2lmKCFlWzFdLmRpbXMubWFwKChvLGkpPT5pPT09dC5heGlzfHxvPT09ZVswXS5kaW1zW2ldKS5yZWR1Y2UoKG8saSk9Pm8mJmksITApKXRocm93IG5ldyBFcnJvcihcIkZvciBibG9jayBxdW5hdGl6YXRpb24sIHNjYWxlIGlucHV0IHNoYXBlIHRvIG1hdGNoIHRoZSBpbnB1dCBzaGFwZSBleGNlcHQgZm9yIHRoZSBheGlzXCIpO2lmKGVbMV0uZGltcy5sZW5ndGghPT1lWzBdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIkZvciBibG9jayBxdW5hdGl6YXRpb24gdGhlIHNjYWxlIGlucHV0IHJhbmsgbXVzdCBiZSB0aGUgc2FtZSBhcyB0aGUgeCByYW5rLlwiKTtsZXQgcj1lWzBdLmRpbXNbdC5heGlzXSxuPWVbMV0uZGltc1t0LmF4aXNdO2lmKHQuYmxvY2tTaXplPE1hdGguY2VpbChyL24pfHx0LmJsb2NrU2l6ZT5NYXRoLmNlaWwoci8obi0xKS0xKSl0aHJvdyBuZXcgRXJyb3IoXCJibG9ja1NpemUgbXVzdCBiZSB3aXRoIGluIHRoZSByYW5nZSBbY2VpbChkSSAvIFNpKSwgY2VpbChkSSAvIChTaSAtIDEpIC0gMSldLlwiKX19LEloPShlLHQpPT57bGV0IHI9Qy5ub3JtYWxpemVBeGlzKHQuYXhpcyxlWzBdLmRpbXMubGVuZ3RoKSxuPWVbMF0uZGF0YVR5cGUsbz1uPT09MyxpPWVbMF0uZGltcyxhPWVbMV0uZGF0YVR5cGUsZD1DLnNpemUoaSksbD1uPT09M3x8bj09PTIscD1sP1tNYXRoLmNlaWwoQy5zaXplKGVbMF0uZGltcykvNCldOmVbMF0uZGltcyxtPWVbMV0uZGltcyx1PWUubGVuZ3RoPjI/ZVsyXTp2b2lkIDAsaD11P2w/W01hdGguY2VpbChDLnNpemUodS5kaW1zKS80KV06dS5kaW1zOnZvaWQgMCxfPW0ubGVuZ3RoPT09MHx8bS5sZW5ndGg9PT0xJiZtWzBdPT09MSx5PV89PT0hMSYmbS5sZW5ndGg9PT0xLGc9bWUoZCkseD1fJiYoIWx8fGc9PT00KSwkPXg/ZzoxLHY9eCYmIWw/ZzoxLFM9RShcImlucHV0XCIsbD8xMjpuLHAubGVuZ3RoLHYpLFQ9RShcInNjYWxlXCIsYSxtLmxlbmd0aCksQT11P0UoXCJ6ZXJvX3BvaW50XCIsbD8xMjpuLGgubGVuZ3RoKTp2b2lkIDAsaz1NKFwib3V0cHV0XCIsYSxpLmxlbmd0aCwkKSxQPVtTLFRdO0EmJlAucHVzaChBKTtsZXQgRD1bcCxtXTt1JiZELnB1c2goaCk7bGV0IFI9W3t0eXBlOjEyLGRhdGE6ZC8kfSx7dHlwZToxMixkYXRhOnJ9LHt0eXBlOjEyLGRhdGE6dC5ibG9ja1NpemV9LC4uLk4oLi4uRCxpKV0sRz1LPT57bGV0IGo9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiYXhpc1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJibG9ja19zaXplXCIsdHlwZTpcInUzMlwifV07cmV0dXJuYFxuICAgICAgJHtLLnJlZ2lzdGVyVW5pZm9ybXMoaikuZGVjbGFyZVZhcmlhYmxlcyguLi5QLGspfVxuICAgICAgJHtLLm1haW5TdGFydCgpfVxuICAgICAgICAgICR7Sy5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHtrLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuXG4gICAgICAgICAgLy8gU2V0IGlucHV0IHhcbiAgICAgICAgICAkeygoKT0+bD9gXG4gICAgICAgICAgICBsZXQgaW5wdXQgPSAke1MuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4IC8gNFwiKX07XG4gICAgICAgICAgICBsZXQgeF92ZWMgPSAke28/XCJ1bnBhY2s0eEk4KGlucHV0KVwiOlwidW5wYWNrNHhVOChpbnB1dClcIn07XG4gICAgICAgICAgICBsZXQgeF92YWx1ZSA9ICR7JD09PTE/XCJ4X3ZlY1tnbG9iYWxfaWR4ICUgNF1cIjpcInhfdmVjXCJ9O2A6YGxldCB4X3ZhbHVlID0gJHtTLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKX07YCkoKX07XG5cbiAgICAgICAgICAvLyBTZXQgc2NhbGUgaW5wdXRcbiAgICAgICAgICAkeygoKT0+Xz9gbGV0IHNjYWxlX3ZhbHVlPSAke1QuZ2V0QnlPZmZzZXQoXCIwXCIpfWA6eT9gXG4gICAgICAgICAgICBsZXQgc2NhbGVfaW5kZXggPSAke2suaW5kaWNlc0dldChcIm91dHB1dF9pbmRpY2VzXCIsXCJ1bmlmb3Jtcy5heGlzXCIpfTtcbiAgICAgICAgICAgIGxldCBzY2FsZV92YWx1ZT0gJHtULmdldEJ5T2Zmc2V0KFwic2NhbGVfaW5kZXhcIil9O2A6YFxuICAgICAgICAgICAgdmFyIHNjYWxlX2luZGljZXM6ICR7VC50eXBlLmluZGljZXN9ID0gb3V0cHV0X2luZGljZXM7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSAke1QuaW5kaWNlc0dldChcInNjYWxlX2luZGljZXNcIixcInVuaWZvcm1zLmF4aXNcIil9IC8gdW5pZm9ybXMuYmxvY2tfc2l6ZTtcbiAgICAgICAgICAgICR7VC5pbmRpY2VzU2V0KFwic2NhbGVfaW5kaWNlc1wiLFwidW5pZm9ybXMuYXhpc1wiLFwiaW5kZXhcIil9O1xuICAgICAgICAgICAgbGV0IHNjYWxlX3ZhbHVlPSAke1QuZ2V0QnlJbmRpY2VzKFwic2NhbGVfaW5kaWNlc1wiKX07YCkoKX07XG5cbiAgICAgICAgICAvLyBTZXQgemVyby1wb2ludCBpbnB1dFxuICAgICAgICAgICR7KCgpPT5BP18/bD9gXG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfaW5wdXQgPSAke0EuZ2V0QnlPZmZzZXQoXCIwXCIpfTtcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF92ZWMgPSAgJHtvP1widW5wYWNrNHhJOCh6ZXJvX3BvaW50X2lucHV0KVwiOlwidW5wYWNrNHhVOCh6ZXJvX3BvaW50X2lucHV0KVwifTtcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF92YWx1ZT0gemVyb19wb2ludF92ZWNbMF1gOmBsZXQgemVyb19wb2ludF92YWx1ZSA9ICR7QS5nZXRCeU9mZnNldChcIjBcIil9YDp5P2w/YFxuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2luZGV4ID0gJHtrLmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLFwidW5pZm9ybXMuYXhpc1wiKX07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfaW5wdXQgPSAke0EuZ2V0QnlPZmZzZXQoXCJ6ZXJvX3BvaW50X2luZGV4IC8gNFwiKX07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmVjID0gICR7bz9cInVucGFjazR4STgoemVyb19wb2ludF9pbnB1dClcIjpcInVucGFjazR4VTgoemVyb19wb2ludF9pbnB1dClcIn07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmFsdWUgPSB6ZXJvX3BvaW50X3ZlY1t6ZXJvX3BvaW50X2luZGV4ICUgNF1gOmBcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9pbmRleCA9ICR7ay5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixcInVuaWZvcm1zLmF4aXNcIil9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3ZhbHVlID0gJHtBLmdldEJ5T2Zmc2V0KFwiemVyb19wb2ludF9pbmRleFwiKX07YDpsP2BcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9vZmZzZXQgPSAke1QuaW5kaWNlc1RvT2Zmc2V0KFwic2NhbGVfaW5kaWNlc1wiKX07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfaW5wdXQgPSAke0EuZ2V0QnlPZmZzZXQoXCJ6ZXJvX3BvaW50X29mZnNldCAvIDRcIil9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3ZlYyA9ICR7bz9cInVucGFjazR4STgoemVyb19wb2ludF9pbnB1dClcIjpcInVucGFjazR4VTgoemVyb19wb2ludF9pbnB1dClcIn07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmFsdWUgPSB6ZXJvX3BvaW50X3ZlY1t6ZXJvX3BvaW50X29mZnNldCAlIDRdO2A6YGxldCB6ZXJvX3BvaW50X3ZhbHVlID0gJHtBLmdldEJ5SW5kaWNlcyhcInNjYWxlX2luZGljZXNcIil9O2A6YGxldCB6ZXJvX3BvaW50X3ZhbHVlID0gJHtsP28/XCJpMzJcIjpcInUzMlwiOlMudHlwZS52YWx1ZX0oMCk7YCkoKX07XG4gICAgICAvLyBDb21wdXRlIGFuZCB3cml0ZSBvdXRwdXRcbiAgICAgICR7ay5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixgJHtrLnR5cGUudmFsdWV9KHhfdmFsdWUgLSB6ZXJvX3BvaW50X3ZhbHVlKSAqIHNjYWxlX3ZhbHVlYCl9O1xuICAgICAgfWB9O3JldHVybntuYW1lOlwiRGVxdWFudGl6ZUxpbmVhclwiLHNoYWRlckNhY2hlOntoaW50OnQuY2FjaGVLZXksaW5wdXREZXBlbmRlbmNpZXM6QT9bXCJyYW5rXCIsXCJyYW5rXCIsXCJyYW5rXCJdOltcInJhbmtcIixcInJhbmtcIl19LGdldFNoYWRlclNvdXJjZTpHLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6aSxkYXRhVHlwZTphfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoZC8kLzY0KSx5OjEsejoxfSxwcm9ncmFtVW5pZm9ybXM6Un0pfX0sJGw9KGUsdCk9PntUaChlLmlucHV0cyx0KSxlLmNvbXB1dGUoSWgoZS5pbnB1dHMsdCkpfSx4bD1lPT5yZSh7YXhpczplLmF4aXMsYmxvY2tTaXplOmUuYmxvY2tTaXplfSl9KTt2YXIgQ2gsQWgsVGwsSWw9VSgoKT0+e1widXNlIHN0cmljdFwiO1dlKCk7dGUoKTthZSgpO0NoPShlLHQscik9PntsZXQgbj1lPT09dCxvPWU8dCYmcjwwLGk9ZT50JiZyPjA7aWYobnx8b3x8aSl0aHJvdyBuZXcgRXJyb3IoXCJSYW5nZSB0aGVzZSBpbnB1dHMnIGNvbnRlbnRzIGFyZSBpbnZhbGlkLlwiKX0sQWg9KGUsdCxyLG4pPT57bGV0IG89TWF0aC5hYnMoTWF0aC5jZWlsKCh0LWUpL3IpKSxpPVtvXSxhPW8sZD1be3R5cGU6MTIsZGF0YTphfSx7dHlwZTpuLGRhdGE6ZX0se3R5cGU6bixkYXRhOnJ9LC4uLk4oaSldLGw9cD0+e2xldCBtPU0oXCJvdXRwdXRcIixuLGkubGVuZ3RoKSx1PW0udHlwZS52YWx1ZSxoPVt7bmFtZTpcIm91dHB1dFNpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwic3RhcnRcIix0eXBlOnV9LHtuYW1lOlwiZGVsdGFcIix0eXBlOnV9XTtyZXR1cm5gXG4gICAgICAgICR7cC5yZWdpc3RlclVuaWZvcm1zKGgpLmRlY2xhcmVWYXJpYWJsZXMobSl9XG4gICAgICAgICR7cC5tYWluU3RhcnQoKX1cbiAgICAgICAgJHtwLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRTaXplXCIpfVxuICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSB1bmlmb3Jtcy5zdGFydCArICR7dX0oZ2xvYmFsX2lkeCkgKiB1bmlmb3Jtcy5kZWx0YTtcbiAgICAgIH1gfTtyZXR1cm57bmFtZTpcIlJhbmdlXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7bn1gfSxnZXRTaGFkZXJTb3VyY2U6bCxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmksZGF0YVR5cGU6bn1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGEvNjQpfSxwcm9ncmFtVW5pZm9ybXM6ZH0pfX0sVGw9ZT0+e2xldCB0PTAscj0wLG49MDtlLmlucHV0c1swXS5kYXRhVHlwZT09PTY/KHQ9ZS5pbnB1dHNbMF0uZ2V0SW50MzJBcnJheSgpWzBdLHI9ZS5pbnB1dHNbMV0uZ2V0SW50MzJBcnJheSgpWzBdLG49ZS5pbnB1dHNbMl0uZ2V0SW50MzJBcnJheSgpWzBdKTplLmlucHV0c1swXS5kYXRhVHlwZT09PTEmJih0PWUuaW5wdXRzWzBdLmdldEZsb2F0MzJBcnJheSgpWzBdLHI9ZS5pbnB1dHNbMV0uZ2V0RmxvYXQzMkFycmF5KClbMF0sbj1lLmlucHV0c1syXS5nZXRGbG9hdDMyQXJyYXkoKVswXSksdmUud2ViZ3B1LnZhbGlkYXRlSW5wdXRDb250ZW50JiZDaCh0LHIsbiksZS5jb21wdXRlKEFoKHQscixuLGUuaW5wdXRzWzBdLmRhdGFUeXBlKSx7aW5wdXRzOltdfSl9fSk7dmFyIGtoLEVoLENsLEFsLGtsPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7U2UoKTthZSgpO2toPShlLHQscixuKT0+e2lmKGUhPT1cIm5vbmVcIiYmbiE9PVwiaTMyXCImJm4hPT1cInUzMlwiJiZuIT09XCJmMzJcIil0aHJvdyBuZXcgRXJyb3IoYElucHV0ICR7bn0gaXMgbm90IHN1cHBvcnRlZCB3aXRoIHJlZHVjdGlvbiAke2V9LmApO2xldCBvPWB7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFZhbHVlID0gMDtcbiAgICAgICAgICAgICAgICBsb29wIHtcbiAgICAgICAgICAgICAgICAgIGxldCBuZXdWYWx1ZUYzMiA9YCxpPWA7XG4gICAgICAgICAgICAgICAgICBsZXQgbmV3VmFsdWUgPSBiaXRjYXN0PGkzMj4obmV3VmFsdWVGMzIpO1xuICAgICAgICAgICAgICAgICAgbGV0IHJlcyA9IGF0b21pY0NvbXBhcmVFeGNoYW5nZVdlYWsoJiR7dH0sIG9sZFZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICBpZiByZXMuZXhjaGFuZ2VkIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9IHJlcy5vbGRfdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9YDtzd2l0Y2goZSl7Y2FzZVwibm9uZVwiOnJldHVybmAke3R9PSR7cn07YDtjYXNlXCJhZGRcIjpyZXR1cm4gbj09PVwiaTMyXCJ8fG49PT1cInUzMlwiP2BhdG9taWNBZGQoJiR7dH0sIGJpdGNhc3Q8JHtufT4oJHtyfSkpO2A6YFxuICAgICAgICAgICAgICAke299Yml0Y2FzdDwke259PihvbGRWYWx1ZSkgKyAoJHtyfSkke2l9YDtjYXNlXCJtYXhcIjpyZXR1cm4gbj09PVwiaTMyXCJ8fG49PT1cInUzMlwiP2BhdG9taWNNYXgoJiR7dH0sIGJpdGNhc3Q8JHtufT4oJHtyfSkpO2A6YFxuICAgICAgICAgICAgICAgICR7b31tYXgoYml0Y2FzdDxmMzI+KG9sZFZhbHVlKSwgKCR7cn0pKSR7aX1gO2Nhc2VcIm1pblwiOnJldHVybiBuPT09XCJpMzJcInx8bj09PVwidTMyXCI/YGF0b21pY01pbigmJHt0fSwgYml0Y2FzdDwke259Pigke3J9KSk7YDpgJHtvfW1pbihiaXRjYXN0PCR7bn0+KG9sZFZhbHVlKSwgKCR7cn0pKSR7aX1gO2Nhc2VcIm11bFwiOnJldHVybmAke299KGJpdGNhc3Q8JHtufT4ob2xkVmFsdWUpICogKCR7cn0pKSR7aX1gO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBSZWR1Y3Rpb24gJHtlfSBpcyBub3Qgc3VwcG9ydGVkLmApfX0sRWg9KGUsdCk9PntsZXQgcj1lWzBdLmRpbXMsbj1lWzFdLmRpbXMsbz1yLGk9MSxhPU1hdGguY2VpbChDLnNpemUobikvaSksZD1uW24ubGVuZ3RoLTFdLGw9Qy5zaXplRnJvbURpbWVuc2lvbihyLGQpLHA9W3t0eXBlOjEyLGRhdGE6YX0se3R5cGU6MTIsZGF0YTpkfSx7dHlwZToxMixkYXRhOmx9LC4uLk4oZVsxXS5kaW1zLGVbMl0uZGltcyxvKV0sbT11PT57bGV0IGg9RShcImluZGljZXNcIixlWzFdLmRhdGFUeXBlLGVbMV0uZGltcy5sZW5ndGgpLF89RShcInVwZGF0ZXNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcy5sZW5ndGgsaSkseT10LnJlZHVjdGlvbiE9PVwibm9uZVwiJiZ0LnJlZHVjdGlvbiE9PVwiXCI/cnMoXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLG8ubGVuZ3RoKTpNKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxvLmxlbmd0aCxpKTtyZXR1cm5gXG4gICAgICAke3UucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0X3NpemVcIixcInUzMlwiKS5yZWdpc3RlclVuaWZvcm0oXCJsYXN0X2luZGV4X2RpbWVuc2lvblwiLFwidTMyXCIpLnJlZ2lzdGVyVW5pZm9ybShcIm51bV91cGRhdGVzX2VsZW1lbnRzXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyhoLF8seSl9XG4gICAgICAke3UubWFpblN0YXJ0KCl9XG4gICAgICAgICR7dS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gIHZhciBkYXRhX29mZnNldCA9IDB1O1xuICBsZXQgaW5kaWNlc19zdGFydCA9IHVuaWZvcm1zLmxhc3RfaW5kZXhfZGltZW5zaW9uICogZ2xvYmFsX2lkeDtcbiAgbGV0IGluZGljZXNfZW5kID0gaW5kaWNlc19zdGFydCArIHVuaWZvcm1zLmxhc3RfaW5kZXhfZGltZW5zaW9uO1xuICBmb3IgKHZhciBpID0gaW5kaWNlc19zdGFydDsgaSA8IGluZGljZXNfZW5kOyBpKyspIHtcbiAgICB2YXIgaW5kZXggPSBpMzIoaW5kaWNlc1tpXS54KTtcbiAgICAke2VbMF0uZGltcy5sZW5ndGg9PT0xP2BcbiAgICBsZXQgZWxlbWVudF9jb3VudF9kaW0gPSB1bmlmb3Jtcy5vdXRwdXRfc3RyaWRlcztcbiAgICBsZXQgZGltX3ZhbHVlID0gdW5pZm9ybXMub3V0cHV0X3NoYXBlO2A6YFxuICAgIGxldCBlbGVtZW50X2NvdW50X2RpbSA9IHVuaWZvcm1zLm91dHB1dF9zdHJpZGVzW2kgLSBpbmRpY2VzX3N0YXJ0XTtcbiAgICBsZXQgZGltX3ZhbHVlID0gdW5pZm9ybXMub3V0cHV0X3NoYXBlW2kgLSBpbmRpY2VzX3N0YXJ0ICsgdW5pZm9ybXMubGFzdF9pbmRleF9kaW1lbnNpb25dO2B9XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIGlmIChpbmRleCA+PSBpMzIoZGltX3ZhbHVlKSkge1xuICAgICAgICBpbmRleCA9IGkzMihkaW1fdmFsdWUgLSAxKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGluZGV4IDwgLWkzMihkaW1fdmFsdWUpKSB7XG4gICAgICAgIGluZGV4ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGV4ICs9IGkzMihkaW1fdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBkYXRhX29mZnNldCArPSB1MzIoKHUzMihpbmRleCkgKiBlbGVtZW50X2NvdW50X2RpbSkpO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDB1OyBpIDwgdW5pZm9ybXMubnVtX3VwZGF0ZXNfZWxlbWVudHM7IGkrKykge1xuICAgIGxldCB2YWx1ZSA9IHVwZGF0ZXNbdW5pZm9ybXMubnVtX3VwZGF0ZXNfZWxlbWVudHMgKiBnbG9iYWxfaWR4ICsgaV07XG4gICAgJHtraCh0LnJlZHVjdGlvbixcIm91dHB1dFtkYXRhX29mZnNldCArIGldXCIsXCJ2YWx1ZVwiLHkudHlwZS52YWx1ZSl9XG4gIH1cblxuICAgICAgfWB9O3JldHVybntuYW1lOlwiU2NhdHRlck5EXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5jYWNoZUtleX1fJHt0LnJlZHVjdGlvbn1gLGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIixcInJhbmtcIl19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6byxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoYS82NCl9LHByb2dyYW1Vbmlmb3JtczpwfSksZ2V0U2hhZGVyU291cmNlOm19fSxDbD1lPT5yZSh7cmVkdWN0aW9uOmUucmVkdWN0aW9ufSksQWw9KGUsdCk9PntlLmNvbXB1dGUoRWgoZS5pbnB1dHMsdCkse2lucHV0czpbZS5pbnB1dHNbMV0sZS5pbnB1dHNbMl1dLG91dHB1dHM6W119KX19KTt2YXIgUGgsemgsT2gsRGgsQmgsTWgsUmgsVWgsTmgsVmgsV2gsRWwsTGgsR2gsSGgsRmgscWgsUGwsemwsT2w9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTtTZSgpO2FlKCk7UGg9KGUsdCk9PntpZihlLmV2ZXJ5KHI9PnI+MHx8KCgpPT57dGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIHNjYWxlcyBpbnB1dCB2YWx1ZXMgdG8gYmUgcG9zaXRpdmVcIil9KSksZS5sZW5ndGg+MCl7aWYodC5tb2RlPT09XCJsaW5lYXJcIil7aWYoIShlLmxlbmd0aD09PTJ8fGUubGVuZ3RoPT09M3x8ZS5sZW5ndGg9PT00JiZlWzBdPT09MSYmZVsxXT09PTF8fGUubGVuZ3RoPT09NCYmZVswXT09PTEmJmVbM109PT0xfHxlLmxlbmd0aD09PTUmJmVbMF09PT0xJiZlWzFdPT09MSkpdGhyb3cgbmV3IEVycm9yKGBGb3IgbGluZWFyIG1vZGUsIFJlc2l6ZSByZXF1aXJlcyBzY2FsZXMgdG8gYmUgMkQsIDNELCA0RCB3aXRoIGVpdGhlciB0d28gb3V0ZXJtb3N0IG9yIG9uZSBpbm5lcm1vc3QgYW5kXG4gICAgICAgICAgICBvbmUgb3V0ZXJtb3N0IHNjYWxlIHZhbHVlcyBlcXVhbCB0byAxLCBvciA1RCB3aXRoIHR3byBvdXRlcm1vc3Qgc2NhbGUgdmFsdWVzIGVxdWFsIHRvIDFgKX1lbHNlIGlmKHQubW9kZT09PVwiY3ViaWNcIiYmIShlLmxlbmd0aD09PTJ8fGUubGVuZ3RoPT09NCYmZVswXT09PTEmJmVbMV09PT0xfHxlLmxlbmd0aD09PTQmJmVbMF09PT0xJiZlWzNdPT09MSkpdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIHNjYWxlcyBpbnB1dCBzaXplIHRvIGJlIDIgb3IgNCBmb3IgY3ViaWMgbW9kZVwiKX19LHpoPShlLHQscik9Pnt0LmV2ZXJ5KG89Pm8+PTAmJm88cnx8KCgpPT57dGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIGF4ZXMgaW5wdXQgdmFsdWVzIHRvIGJlIHBvc2l0aXZlIGFuZCBsZXNzIHRoYW4gcmFua1wiKX0pKTtsZXQgbj1uZXcgQXJyYXkocikuZmlsbCgxKTtyZXR1cm4gdC5mb3JFYWNoKChvLGkpPT5uW29dPWVbaV0pLG59LE9oPShlLHQscixuLG8saSk9PntsZXRbYSxkLGxdPXI+MTA/WzEsMiwzXTpbLTEsZS5sZW5ndGg+MT8xOi0xLC0xXSxwPWVbMF0uZGltcy5sZW5ndGg7aWYoYT4wJiZlLmxlbmd0aD5hJiZlW2FdLmRpbXMubGVuZ3RoPjApZVthXS5nZXRGbG9hdDMyQXJyYXkoKS5mb3JFYWNoKG09PmkucHVzaChtKSk7ZWxzZSBpZih0LmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlPT09XCJ0Zl9jcm9wX2FuZF9yZXNpemVcIil0aHJvdyBuZXcgRXJyb3IoXCJSZXNpemUgcmVxdWlyZXMgUm9JIGlucHV0IHRvIGJlIHNwZWNpZmllZCB3aGVuIGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlIGlzIHRmQ3JvcEFuZFJlc2l6ZVwiKTtpZihkPjAmJmUubGVuZ3RoPmQmJmVbZF0uZGltcy5sZW5ndGg9PT0xJiZlW2RdLmRpbXNbMF0+MCl7aWYoZVtkXS5nZXRGbG9hdDMyQXJyYXkoKS5mb3JFYWNoKG09Pm4ucHVzaChtKSksbi5sZW5ndGghPT0wJiZuLmxlbmd0aCE9PXAmJnI+PTE4JiZuLmxlbmd0aCE9PXQuYXhlcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIHNjYWxlcyBpbnB1dCBzaXplIHRvIGJlIHNhbWUgYXMgaW5wdXQgcmFuayBvciBheGVzIHNpemUgZm9yIG9wc2V0IDE4IGFuZCB1cFwiKTtQaChuLHQpLHQuYXhlcy5sZW5ndGg+MCYmemgobix0LmF4ZXMscCkuZm9yRWFjaCgobSx1KT0+blt1XT1tKX1pZihsPjAmJmUubGVuZ3RoPmwmJmVbbF0uZGltcy5sZW5ndGg9PT0xJiZlW2xdLmRpbXNbMF0+MCYmKGVbbF0uZ2V0QmlnSW50NjRBcnJheSgpLmZvckVhY2gobT0+by5wdXNoKE51bWJlcihtKSkpLG8ubGVuZ3RoIT09MCYmby5sZW5ndGghPT1wJiZyPj0xOCYmby5sZW5ndGghPT10LmF4ZXMubGVuZ3RoKSl0aHJvdyBuZXcgRXJyb3IoXCJSZXNpemUgcmVxdWlyZXMgc2l6ZXMgaW5wdXQgc2l6ZSB0byBiZSBzYW1lIGFzIGlucHV0IHJhbmsgb3IgYXhlcyBzaXplIGZvciBvcHNldCAxOCBhbmQgdXBcIik7aWYodC5heGVzLmxlbmd0aD4wKXtpZihuLmxlbmd0aCE9PTAmJm4ubGVuZ3RoIT09dC5heGVzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoJ1Jlc2l6ZSByZXF1aXJlcyBcInNjYWxlc1wiIGlucHV0IHNpemUgdG8gYmUgb2YgYXhlcyByYW5rIHdoZW4gYXhlcyBhdHRyaWJ1dGVzIGlzIHNwZWNpZmllZCcpO2lmKG8ubGVuZ3RoIT09MCYmby5sZW5ndGghPT10LmF4ZXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcignUmVzaXplIHJlcXVpcmVzIFwic2l6ZXNcIiBpbnB1dCBzaXplIHRvIGJlIG9mIHJhbmsgYXhlcyByYW5rIHdoZW4gYXhlcyBhdHRyaWJ1dGVzIGlzIHNwZWNpZmllZCcpfWlmKHR5cGVvZiBuPFwidVwiJiZ0eXBlb2YgbzxcInVcIiYmbi5sZW5ndGg+MCYmby5sZW5ndGg+cCl0aHJvdyBuZXcgRXJyb3IoXCJSZXNpemUgcmVxdWlyZXMgb25seSBvZiBzY2FsZXMgb3Igc2l6ZXMgdG8gYmUgc3BlY2lmaWVkXCIpfSxEaD0oZSx0KT0+YGZuIGdldE9yaWdpbmFsQ29vcmRpbmF0ZUZyb21SZXNpemVkQ29vcmRpbmF0ZSh4UmVzaXplZDogdTMyLCB4U2NhbGU6IGYzMiwgbGVuZ3RoUmVzaXplZDogdTMyLFxuICAgICBsZW5ndGhPcmlnaW5hbDogdTMyLCByb2lTdGFydDogZjMyLCByb2lFbmQ6IGYzMikgLT4gJHt0fSB7IGArKCgpPT57c3dpdGNoKGUpe2Nhc2VcImFzeW1tZXRyaWNcIjpyZXR1cm5gcmV0dXJuICR7dH0oeFJlc2l6ZWQpIC8gJHt0fSh4U2NhbGUpO2A7Y2FzZVwicHl0b3JjaF9oYWxmX3BpeGVsXCI6cmV0dXJuYGlmIChsZW5ndGhSZXNpemVkID4gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCR7dH0oeFJlc2l6ZWQpICsgMC41KSAvICR7dH0oeFNjYWxlKSAtIDAuNTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwLjA7XG4gICAgICAgICAgICAgICAgICB9YDtjYXNlXCJ0Zl9oYWxmX3BpeGVsX2Zvcl9ublwiOnJldHVybmByZXR1cm4gKCR7dH0oeFJlc2l6ZWQpICsgMC41KSAvICR7dH0oeFNjYWxlKTtgO2Nhc2VcImFsaWduX2Nvcm5lcnNcIjpyZXR1cm5gaWYgKGxlbmd0aFJlc2l6ZWQgPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMC4wO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHdob2xlIHBhcnQgYW5kIHRoZSBmcmFjdGlvbmFsIHBhcnQgYXJlIGNhbGN1bGF0ZWQgc2VwYXJhdGVseSBkdWUgdG8gaW5hY2N1cmFjeSBvZiBmbG9hdGluZ1xuICAgICAgICAgICAgICAgICAgICAvLyBwb2ludCBkaXZpc2lvbi4gQXMgYW4gZXhhbXBsZSwgZjMyKDIxKSAvIGYzMig3KSBtYXkgZXZhbHVhdGUgdG8gMi45OS4uLiBpbnN0ZWFkIG9mIDMsIGNhdXNpbmcgYW5cbiAgICAgICAgICAgICAgICAgICAgLy8gb2Zmc2V0LWJ5LW9uZSBlcnJvciBsYXRlciBpbiBmbG9vcigpLlxuICAgICAgICAgICAgICAgICAgICBsZXQgd2hvbGUgPSAke3R9KHhSZXNpemVkICogKGxlbmd0aE9yaWdpbmFsIC0gMSkgLyAobGVuZ3RoUmVzaXplZCAtIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZyYWN0ID1cbiAgICAgICAgICAgICAgICAgICAgICAgICR7dH0oeFJlc2l6ZWQgKiAobGVuZ3RoT3JpZ2luYWwgLSAxKSAlIChsZW5ndGhSZXNpemVkIC0gMSkpIC8gJHt0fShsZW5ndGhSZXNpemVkIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3aG9sZSArIGZyYWN0O1xuICAgICAgICAgICAgICAgICAgfWA7Y2FzZVwidGZfY3JvcF9hbmRfcmVzaXplXCI6cmV0dXJuYGlmIChsZW5ndGhSZXNpemVkID4gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHt0fShyb2lTdGFydCkgKiAke3R9KGxlbmd0aE9yaWdpbmFsIC0gMSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKCR7dH0oeFJlc2l6ZWQpICogJHt0fShyb2lFbmQgLSByb2lTdGFydCkgKiAke3R9KGxlbmd0aE9yaWdpbmFsIC0gMSkpIC9cbiAgICAgICAgICAgICAgICAgICAgICAgICR7dH0obGVuZ3RoUmVzaXplZCAtIDEpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuNSAqICR7dH0ocm9pU3RhcnQgKyByb2lFbmQpICogJHt0fShsZW5ndGhPcmlnaW5hbCAtIDEpO1xuICAgICAgICAgICAgICAgICAgfWA7Y2FzZVwiaGFsZl9waXhlbF9zeW1tZXRyaWNcIjpyZXR1cm5gY29uc3Qgb3V0cHV0V2lkdGggPSAke3R9eFNjYWxlICogJHt0fShsZW5ndGhSZXNpemVkKTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGFkanVzdG1lbnQgPSAke3R9KGxlbmd0aFJlc2l6ZWQpIC8gb3V0cHV0V2lkdGg7XG4gICAgICAgICAgICAgICAgICBjb25zdCBjZW50ZXIgPSAke3R9KGxlbmd0aE9yaWdpbmFsKSAvIDI7XG4gICAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBjZW50ZXIgKiAoMSAtIGFkanVzdG1lbnQpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG9mZnNldCArICgoJHt0fSh4UmVzaXplZCkgKyAwLjUpIC8gJHt0fSh4U2NhbGUpKSAtIDAuNTtgO2Nhc2VcImhhbGZfcGl4ZWxcIjpyZXR1cm5gcmV0dXJuICgoJHt0fSh4UmVzaXplZCkgKyAwLjUpIC8gJHt0fSh4U2NhbGUpKSAtIDAuNTtgO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBDb29yZGluYXRlIHRyYW5zZm9ybSBtb2RlICR7ZX0gaXMgbm90IHN1cHBvcnRlZGApfX0pKCkrXCJ9XCIsQmg9KGUsdCxyKT0+YGZuIGdldE5lYXJlc3RQaXhlbEZyb21PcmlnaW5hbCh4T3JpZ2luYWw6ICR7cn0sIGlzRG93blNhbXBsZTogYm9vbCkgLT4gJHtyfSB7YCsoKCk9Pntzd2l0Y2goZSl7Y2FzZVwicm91bmRfcHJlZmVyX2NlaWxcIjpyZXR1cm5cImlmIChmcmFjdCh4T3JpZ2luYWwpID09IDAuNSkgeyAgICAgICAgICAgICByZXR1cm4gY2VpbCh4T3JpZ2luYWwpOyAgICAgICAgICAgfSBlbHNlIHsgICAgICAgICAgICAgcmV0dXJuIHJvdW5kKHhPcmlnaW5hbCk7ICAgICAgICAgICB9XCI7Y2FzZVwiZmxvb3JcIjpyZXR1cm5cInJldHVybiBmbG9vcih4T3JpZ2luYWwpO1wiO2Nhc2VcImNlaWxcIjpyZXR1cm5cInJldHVybiBjZWlsKHhPcmlnaW5hbCk7XCI7Y2FzZVwicm91bmRfcHJlZmVyX2Zsb29yXCI6cmV0dXJuXCJpZiAoZnJhY3QoeE9yaWdpbmFsKSA9PSAwLjUpIHsgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmxvb3IoeE9yaWdpbmFsKTsgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcm91bmQoeE9yaWdpbmFsKTsgICAgICAgICAgICAgICAgICAgfVwiO2Nhc2VcInNpbXBsZVwiOmRlZmF1bHQ6aWYodDwxMSlyZXR1cm5cImlmIChpc0Rvd25TYW1wbGUpICAgICAgICAgICAgICAgICAgICAgeyAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNlaWwoeE9yaWdpbmFsKTsgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHhPcmlnaW5hbDsgICAgICAgICAgICAgICAgICAgICB9XCI7dGhyb3cgbmV3IEVycm9yKGBOZWFyZXN0IG1vZGUgJHtlfSBpcyBub3Qgc3VwcG9ydGVkYCl9fSkoKStcIn1cIixNaD0oZSx0LHIpPT57bGV0IG49bmV3IEFycmF5KHIpLmZpbGwoMCkuY29uY2F0KG5ldyBBcnJheShyKS5maWxsKDEpKSxvPWUubGVuZ3RoPT09MD9uOmUuc2xpY2UoKTtyZXR1cm4gdC5sZW5ndGg+MD8odC5mb3JFYWNoKChpLGEpPT57bltpXT1vW2FdLG5bYStyXT1vW3QubGVuZ3RoK2FdfSksbik6b30sUmg9KGUsdCxyLG4pPT57bGV0IG89W107aWYoci5sZW5ndGg+MClpZihuLmxlbmd0aD4wKXtpZihlLmZvckVhY2goaT0+by5wdXNoKGkpKSxNYXRoLm1heCguLi5uKT5lLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJheGVzIGlzIG91dCBvZiBib3VuZFwiKTtuLmZvckVhY2goKGksYSk9Pm9baV09clthXSl9ZWxzZSByLmZvckVhY2goaT0+by5wdXNoKGkpKTtlbHNle2lmKHQubGVuZ3RoPT09MCl0aHJvdyBuZXcgRXJyb3IoXCJSZXNpemUgcmVxdWlyZXMgZWl0aGVyIHNjYWxlcyBvciBzaXplcy5cIik7bz1lLm1hcCgoaSxhKT0+TWF0aC5yb3VuZChpKnRbYV0pKX1yZXR1cm4gb30sVWg9KGUsdCxyKT0+e2xldCBuPSgoKT0+e3N3aXRjaChyLmtlZXBBc3BlY3RSYXRpb1BvbGljeSl7Y2FzZVwibm90X2xhcmdlclwiOnJldHVybiByLmF4ZXMubGVuZ3RoPjA/TWF0aC5taW4oLi4uci5heGVzLm1hcChpPT50W2ldKSxOdW1iZXIuTUFYX1ZBTFVFKTpNYXRoLm1pbiguLi50LE51bWJlci5NQVhfVkFMVUUpO2Nhc2VcIm5vdF9zbWFsbGVyXCI6cmV0dXJuIHIuYXhlcy5sZW5ndGg+MD9NYXRoLm1heCguLi5yLmF4ZXMubWFwKGk9PnRbaV0pLE51bWJlci5NSU5fVkFMVUUpOk1hdGgubWF4KC4uLnQsTnVtYmVyLk1JTl9WQUxVRSk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYEtlZXAgYXNwZWN0IHJhdGlvIHBvbGljeSAke3Iua2VlcEFzcGVjdFJhdGlvUG9saWN5fSBpcyBub3Qgc3VwcG9ydGVkYCl9fSkoKTt0LmZpbGwoMSwwLHQubGVuZ3RoKTtsZXQgbz1lLnNsaWNlKCk7cmV0dXJuIHIuYXhlcy5sZW5ndGg+MD8oci5heGVzLmZvckVhY2goaT0+dFtpXT1uKSxyLmF4ZXMuZm9yRWFjaChpPT5vW2ldPU1hdGgucm91bmQoZVtpXSp0W2ldKSkpOih0LmZpbGwobiwwLHQubGVuZ3RoKSxvLmZvckVhY2goKGksYSk9Pm9bYV09TWF0aC5yb3VuZChpKnRbYV0pKSksb30sTmg9KGUsdCxyLG4sbyk9PmBcbiAgICBmbiBjYWxjdWxhdGVPcmlnaW5hbEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc30pIC0+IGFycmF5PCR7ZS50eXBlLnZhbHVlfSwgJHtyLmxlbmd0aH0+IHtcbiAgICAgIHZhciBvcmlnaW5hbF9pbmRpY2VzOiBhcnJheTwke2UudHlwZS52YWx1ZX0sICR7ci5sZW5ndGh9PjtcbiAgICAgIGZvciAodmFyIGk6dTMyID0gMDsgaSA8ICR7ci5sZW5ndGh9OyBpKyspIHtcbiAgICAgICAgdmFyIG91dHB1dF9pbmRleCA9ICR7ZS5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixcImlcIil9O1xuICAgICAgICB2YXIgc2NhbGUgPSAke0YoXCJ1bmlmb3Jtcy5zY2FsZXNcIixcImlcIixuKX07XG4gICAgICAgIHZhciByb2lfbG93ID0gJHtGKFwidW5pZm9ybXMucm9pXCIsXCJpXCIsbyl9O1xuICAgICAgICB2YXIgcm9pX2hpID0gJHtGKFwidW5pZm9ybXMucm9pXCIsYGkgKyAke3QubGVuZ3RofWAsbyl9O1xuICAgICAgICBpZiAoc2NhbGUgPT0gMS4wKSB7XG4gICAgICAgICAgb3JpZ2luYWxfaW5kaWNlc1tpXSA9ICR7ZS50eXBlLnZhbHVlfShvdXRwdXRfaW5kZXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBpbnB1dF9zaGFwZV9pID0gJHtGKFwidW5pZm9ybXMuaW5wdXRfc2hhcGVcIixcImlcIix0Lmxlbmd0aCl9O1xuICAgICAgICAgIHZhciBvdXRwdXRfc2hhcGVfaSA9ICR7RihcInVuaWZvcm1zLm91dHB1dF9zaGFwZVwiLFwiaVwiLHIubGVuZ3RoKX07XG4gICAgICAgICAgb3JpZ2luYWxfaW5kaWNlc1tpXSA9IGdldE9yaWdpbmFsQ29vcmRpbmF0ZUZyb21SZXNpemVkQ29vcmRpbmF0ZShvdXRwdXRfaW5kZXgsIHNjYWxlLCBvdXRwdXRfc2hhcGVfaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0X3NoYXBlX2ksIHJvaV9sb3csIHJvaV9oaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmlnaW5hbF9pbmRpY2VzO1xuICAgIH1gLFZoPShlLHQscixuLG8saSxhKT0+YFxuICAgIGZuIGNhbGN1bGF0ZUlucHV0SW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzOiAke3QudHlwZS5pbmRpY2VzfSkgLT4gJHtlLnR5cGUuaW5kaWNlc30ge1xuICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7ZS50eXBlLmluZGljZXN9O1xuICAgICAgZm9yICh2YXIgaTp1MzIgPSAwOyBpIDwgJHtuLmxlbmd0aH07IGkrKykge1xuICAgICAgICB2YXIgb3V0cHV0X2luZGV4ID0gJHt0LmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLFwiaVwiKX07XG4gICAgICAgIHZhciBpbnB1dF9pbmRleDogdTMyO1xuICAgICAgICB2YXIgc2NhbGUgPSAke0YoXCJ1bmlmb3Jtcy5zY2FsZXNcIixcImlcIixvKX07XG4gICAgICAgIGlmIChzY2FsZSA9PSAxLjApIHtcbiAgICAgICAgICBpbnB1dF9pbmRleCA9IG91dHB1dF9pbmRleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcm9pX2xvdyA9ICR7RihcInVuaWZvcm1zLnJvaVwiLFwiaVwiLGkpfTtcbiAgICAgICAgICB2YXIgcm9pX2hpID0gJHtGKFwidW5pZm9ybXMucm9pXCIsYGkgKyAke3IubGVuZ3RofWAsaSl9O1xuICAgICAgICAgIHZhciBpbnB1dF9zaGFwZV9pID0gJHtGKFwidW5pZm9ybXMuaW5wdXRfc2hhcGVcIixcImlcIixyLmxlbmd0aCl9O1xuICAgICAgICAgIHZhciBvdXRwdXRfc2hhcGVfaSA9ICR7RihcInVuaWZvcm1zLm91dHB1dF9zaGFwZVwiLFwiaVwiLG4ubGVuZ3RoKX07XG4gICAgICAgICAgdmFyIG9yaWdpbmFsX2lkeCA9IGdldE9yaWdpbmFsQ29vcmRpbmF0ZUZyb21SZXNpemVkQ29vcmRpbmF0ZShvdXRwdXRfaW5kZXgsIHNjYWxlLCBvdXRwdXRfc2hhcGVfaSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0X3NoYXBlX2ksIHJvaV9sb3csIHJvaV9oaSk7XG4gICAgICAgICAgaWYgKCEke2F9IHx8IChvcmlnaW5hbF9pZHggPj0gMCAmJiBvcmlnaW5hbF9pZHggPCAke3QudHlwZS52YWx1ZX0oaW5wdXRfc2hhcGVfaSkpKSB7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWxfaWR4IDwgMCkge1xuICAgICAgICAgICAgICBpbnB1dF9pbmRleCA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9yaWdpbmFsX2lkeCA+ICR7dC50eXBlLnZhbHVlfShpbnB1dF9zaGFwZV9pIC0gMSkpIHtcbiAgICAgICAgICAgICAgaW5wdXRfaW5kZXggPSBpbnB1dF9zaGFwZV9pIC0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlucHV0X2luZGV4ID0gdTMyKGdldE5lYXJlc3RQaXhlbEZyb21PcmlnaW5hbChvcmlnaW5hbF9pZHgsIHNjYWxlIDwgMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnB1dF9pbmRleCA9IHUzMihvcmlnaW5hbF9pZHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixcImlcIixcIiBpbnB1dF9pbmRleFwiKX1cbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnB1dF9pbmRpY2VzO1xuICAgIH1gLFdoPShlLHQpPT5gXG4gICAgZm4gY2hlY2tJbnB1dEluZGljZXMoaW5wdXRfaW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc30pIC0+IGJvb2wge1xuICAgICAgZm9yICh2YXIgaTp1MzIgPSAwOyBpIDwgJHt0Lmxlbmd0aH07IGkrKykge1xuICAgICAgICB2YXIgaW5wdXRfaW5kZXggPSAke2UuaW5kaWNlc0dldChcImlucHV0X2luZGljZXNcIixcImlcIil9O1xuICAgICAgICBpZiAoaW5wdXRfaW5kZXggPCAwIHx8IGlucHV0X2luZGV4ID49ICR7RihcInVuaWZvcm1zLmlucHV0X3NoYXBlXCIsXCJpXCIsdC5sZW5ndGgpfSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfWAsRWw9KGUsdCxyLG4pPT5lLnJhbms+bj9gXG4gICAgJHtlLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsdCxcImNoYW5uZWxcIil9O1xuICAgICR7ZS5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLHIsXCJiYXRjaFwiKX07XG5gOlwiXCIsTGg9KGUsdCxyLG4sbyk9PntsZXRbYSxkLGwscF09ci5sZW5ndGg9PT0yP1stMSwwLDEsLTFdOlswLDIsMywxXSxtPWUudHlwZS52YWx1ZTtyZXR1cm5gXG4gICAgZm4gZ2V0SW5wdXRWYWx1ZShiYXRjaDogdTMyLCBjaGFubmVsOiB1MzIsIHJvdzogdTMyLCBjb2w6IHUzMikgLT4gJHttfSB7XG4gICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc307XG4gICAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixkLGBtYXgoMCwgbWluKHJvdywgJHtyW2RdfSAtIDEpKWApfTtcbiAgICAgICR7ZS5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLGwsYG1heCgwLCBtaW4oY29sLCAke3JbbF19IC0gMSkpYCl9O1xuICAgICAgJHtFbChlLHAsYSwyKX1cbiAgICAgIHJldHVybiAke2UuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07XG4gICAgfVxuXG4gICAgZm4gYmlsaW5lYXJJbnRlcnBvbGF0aW9uKG91dHB1dF9pbmRpY2VzOiAke3QudHlwZS5pbmRpY2VzfSkgLT4gJHttfSB7XG4gICAgICB2YXIgb3JpZ2luYWxJbmRpY2VzID0gY2FsY3VsYXRlT3JpZ2luYWxJbmRpY2VzRnJvbU91dHB1dEluZGljZXMob3V0cHV0X2luZGljZXMpO1xuICAgICAgdmFyIHJvdzoke219ID0gb3JpZ2luYWxJbmRpY2VzWyR7ZH1dO1xuICAgICAgdmFyIGNvbDoke219ID0gb3JpZ2luYWxJbmRpY2VzWyR7bH1dO1xuICAgICAgJHtuP2BpZiAocm93IDwgMCB8fCByb3cgPiAoJHtyW2RdfSAtIDEpIHx8IGNvbCA8IDAgfHwgY29sID4gKCR7cltsXX0gLSAxKSkge1xuICAgICAgICByZXR1cm4gJHtvfTtcbiAgICAgIH1gOlwiXCJ9O1xuICAgICAgcm93ID0gbWF4KDAsIG1pbihyb3csICR7cltkXX0gLSAxKSk7XG4gICAgICBjb2wgPSBtYXgoMCwgbWluKGNvbCwgJHtyW2xdfSAtIDEpKTtcbiAgICAgIHZhciByb3cxOiB1MzIgPSB1MzIocm93KTtcbiAgICAgIHZhciBjb2wxOiB1MzIgPSB1MzIoY29sKTtcbiAgICAgIHZhciByb3cyOiB1MzIgPSB1MzIocm93ICsgMSk7XG4gICAgICB2YXIgY29sMjogdTMyID0gdTMyKGNvbCArIDEpO1xuICAgICAgdmFyIGNoYW5uZWw6IHUzMiA9ICR7ci5sZW5ndGg+Mj9gdTMyKG9yaWdpbmFsSW5kaWNlc1ske3B9XSlgOlwiMFwifTtcbiAgICAgIHZhciBiYXRjaDogdTMyID0gICR7ci5sZW5ndGg+Mj9gdTMyKG9yaWdpbmFsSW5kaWNlc1ske2F9XSlgOlwiMFwifTtcbiAgICAgIHZhciB4MTE6ICR7bX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCByb3cxLCBjb2wxKTtcbiAgICAgIHZhciB4MTI6ICR7bX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCByb3cxLCBjb2wyKTtcbiAgICAgIHZhciB4MjE6ICR7bX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCByb3cyLCBjb2wxKTtcbiAgICAgIHZhciB4MjI6ICR7bX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCByb3cyLCBjb2wyKTtcbiAgICAgIHZhciBkeDE6ICR7bX0gPSBhYnMocm93IC0gJHttfShyb3cxKSk7XG4gICAgICB2YXIgZHgyOiAke219ID0gYWJzKCR7bX0ocm93MikgLSByb3cpO1xuICAgICAgdmFyIGR5MTogJHttfSA9IGFicyhjb2wgLSAke219KGNvbDEpKTtcbiAgICAgIHZhciBkeTI6ICR7bX0gPSBhYnMoJHttfShjb2wyKSAtIGNvbCk7XG4gICAgICBpZiAocm93MSA9PSByb3cyKSB7XG4gICAgICAgIGR4MSA9IDAuNTtcbiAgICAgICAgZHgyID0gMC41O1xuICAgICAgfVxuICAgICAgaWYgKGNvbDEgPT0gY29sMikge1xuICAgICAgICBkeTEgPSAwLjU7XG4gICAgICAgIGR5MiA9IDAuNTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoeDExICogZHgyICogZHkyICsgeDEyICogZHgyICogZHkxICsgeDIxICogZHgxICogZHkyICsgeDIyICogZHgxICogZHkxKTtcbiAgICB9YH0sR2g9KGUsdCxyLG4sbyxpLGEsZCxsLHApPT57bGV0IG09ci5sZW5ndGg9PT0yLHU9ITAsW2gsX109bT9bMCwxXTp1P1syLDNdOlsxLDJdLHk9ZS50eXBlLnZhbHVlLGc9eD0+e2xldCAkPXg9PT1oP1wicm93XCI6XCJjb2xcIjtyZXR1cm5gXG4gICAgICBmbiAkeyR9Q3ViaWNJbnRlcnBvbGF0aW9uKGlucHV0X2luZGljZXM6ICR7ZS50eXBlLmluZGljZXN9LCBvdXRwdXRfaW5kaWNlczogJHt0LnR5cGUuaW5kaWNlc30pIC0+ICR7eX0ge1xuICAgICAgICB2YXIgb3V0cHV0X2luZGV4ID0gJHt0LmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLHgpfTtcbiAgICAgICAgdmFyIG9yaWdpbmFsSWR4OiAke3l9ID0gZ2V0T3JpZ2luYWxDb29yZGluYXRlRnJvbVJlc2l6ZWRDb29yZGluYXRlKG91dHB1dF9pbmRleCwgJHtvW3hdfSxcbiAgICAgICAgJHtuW3hdfSwgJHtyW3hdfSwgJHtpW3hdfSwgJHtpW3hdfSArICR7ci5sZW5ndGh9KTtcbiAgICAgICAgdmFyIGZyYWN0T3JpZ2luYWxJZHg6ICR7eX0gPSBvcmlnaW5hbElkeCAtIGZsb29yKG9yaWdpbmFsSWR4KTtcbiAgICAgICAgdmFyIGNvZWZzID0gZ2V0Q3ViaWNJbnRlcnBvbGF0aW9uQ29lZnMoZnJhY3RPcmlnaW5hbElkeCk7XG5cbiAgICAgICAgaWYgKCR7ZH0gJiYgKG9yaWdpbmFsSWR4IDwgMCB8fCBvcmlnaW5hbElkeCA+ICgke3JbeF19IC0gMSkpKSB7XG4gICAgICAgICAgcmV0dXJuICR7bH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRhdGE6IGFycmF5PCR7eX0sIDQ+ID0gYXJyYXk8JHt5fSwgND4oMC4wLCAwLjAsIDAuMCwgMC4wKTtcbiAgICAgICAgZm9yICh2YXIgaTogaTMyID0gLTE7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICB2YXIgJHskfTogJHt5fSA9IG9yaWdpbmFsSWR4ICsgJHt5fShpKTtcbiAgICAgICAgICBpZiAoJHskfSA8IDAgfHwgJHskfSA+PSAke3JbeF19KSB7XG4gICAgICAgICAgICAkeygoKT0+cD9gY29lZnNbaSArIDFdID0gMC4wO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7YDpkP2ByZXR1cm4gJHtsfTtgOmAkeyR9ID0gbWF4KDAsIG1pbigkeyR9LCAke3JbeF19IC0gMSkpO2ApKCl9O1xuICAgICAgICAgIH1cbiAgICAgICAgdmFyIGlucHV0X2luZGljZXNfY29weTogJHtlLnR5cGUuaW5kaWNlc30gPSBpbnB1dF9pbmRpY2VzO1xuICAgICAgICAgICR7ZS5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc19jb3B5XCIseCxgdTMyKCR7JH0pYCl9O1xuICAgICAgICAgIGRhdGFbaSArIDFdID0gJHt4PT09aD9lLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNfY29weVwiKTpcInJvd0N1YmljSW50ZXJwb2xhdGlvbihpbnB1dF9pbmRpY2VzX2NvcHksIG91dHB1dF9pbmRpY2VzKVwifTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3ViaWNJbnRlcnBvbGF0aW9uMUQoZGF0YSwgY29lZnMpO1xuICAgICAgfWB9O3JldHVybmBcbiAgICAke2coaCl9O1xuICAgICR7ZyhfKX07XG4gIGZuIGdldEN1YmljSW50ZXJwb2xhdGlvbkNvZWZzKHM6ICR7eX0pIC0+IGFycmF5PCR7eX0sIDQ+IHtcbiAgICB2YXIgYWJzUyA9IGFicyhzKTtcbiAgICB2YXIgY29lZmZzOiBhcnJheTwke3l9LCA0PiA9IGFycmF5PCR7eX0sIDQ+KDAuMCwgMC4wLCAwLjAsIDAuMCk7XG4gICAgdmFyIG9uZU1pbnVzQWJzUzogJHt5fSA9IDEuMCAtIGFic1M7XG4gICAgdmFyIHR3b01pbnVzQWJzUzogJHt5fSA9IDIuMCAtIGFic1M7XG4gICAgdmFyIG9uZVBsdXNBYnNTOiAke3l9ID0gMS4wICsgYWJzUztcbiAgICBjb2VmZnNbMF0gPSAoKCR7YX0gKiBvbmVQbHVzQWJzUyAtIDUgKiAke2F9KSAqIG9uZVBsdXNBYnNTICsgOCAqICR7YX0pICogb25lUGx1c0Fic1MgLSA0ICogJHthfTtcbiAgICBjb2VmZnNbMV0gPSAoKCR7YX0gKyAyKSAqIGFic1MgLSAoJHthfSArIDMpKSAqIGFic1MgKiBhYnNTICsgMTtcbiAgICBjb2VmZnNbMl0gPSAoKCR7YX0gKyAyKSAqIG9uZU1pbnVzQWJzUyAtICgke2F9ICsgMykpICogb25lTWludXNBYnNTICogb25lTWludXNBYnNTICsgMTtcbiAgICBjb2VmZnNbM10gPSAoKCR7YX0gKiB0d29NaW51c0Fic1MgLSA1ICogJHthfSkgKiB0d29NaW51c0Fic1MgKyA4ICogJHthfSkgKiB0d29NaW51c0Fic1MgLSA0ICogJHthfTtcbiAgICByZXR1cm4gY29lZmZzO1xuICB9XG5cbiAgZm4gY3ViaWNJbnRlcnBvbGF0aW9uMUQoeDogYXJyYXk8JHt5fSwgND4sIGNvZWZzOiBhcnJheTwke3l9LCA0PikgLT4gJHt5fSB7XG4gICAgdmFyIGNvZWZzU3VtOiAke3l9ID0gY29lZnNbMF0gKyBjb2Vmc1sxXSArIGNvZWZzWzJdICsgY29lZnNbM107XG4gICAgcmV0dXJuICh4WzBdICogY29lZnNbMF0gKyB4WzFdICogY29lZnNbMV0rIHhbMl0gKiBjb2Vmc1syXSsgeFszXSAqIGNvZWZzWzNdKSAvIGNvZWZzU3VtO1xuICB9XG5cbiAgZm4gYmljdWJpY0ludGVycG9sYXRpb24ob3V0cHV0X2luZGljZXM6ICR7dC50eXBlLmluZGljZXN9KSAtPiAke3l9IHtcbiAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc30gPSBvdXRwdXRfaW5kaWNlcztcbiAgICByZXR1cm4gY29sQ3ViaWNJbnRlcnBvbGF0aW9uKGlucHV0X2luZGljZXMsIG91dHB1dF9pbmRpY2VzKTtcbiAgfVxuICAgIGB9LEhoPShlLHQscixuLG8pPT57bGV0W2EsZCxsLHAsbV09ci5sZW5ndGg9PT0zP1stMSwwLDEsMiwtMV06WzAsMiwzLDQsMV0sdT1lLnR5cGUudmFsdWU7cmV0dXJuYFxuICAgIGZuIGdldElucHV0VmFsdWUoYmF0Y2g6IHUzMiwgY2hhbm5lbDogdTMyLCBkZXB0aDp1MzIsIGhlaWdodDogdTMyLCB3aWR0aDogdTMyKSAtPiAke3V9IHtcbiAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2UudHlwZS5pbmRpY2VzfTtcbiAgICAgICR7ZS5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLGQsYG1heCgwLCBtaW4oZGVwdGgsICR7cltkXX0gLSAxKSlgKX07XG4gICAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixsLGBtYXgoMCwgbWluKGhlaWdodCwgJHtyW2xdfSAtIDEpKWApfTtcbiAgICAgICR7ZS5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLHAsYG1heCgwLCBtaW4od2lkdGgsICR7cltwXX0gLSAxKSlgKX07XG4gICAgICAke0VsKGUsbSxhLDMpfVxuICAgICAgcmV0dXJuICR7ZS5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtcbiAgICB9XG5cbiAgICBmbiB0cmlsaW5lYXJJbnRlcnBvbGF0aW9uKG91dHB1dF9pbmRpY2VzOiAke3QudHlwZS5pbmRpY2VzfSkgLT4gJHt1fSB7XG4gICAgICB2YXIgb3JpZ2luYWxJbmRpY2VzID0gY2FsY3VsYXRlT3JpZ2luYWxJbmRpY2VzRnJvbU91dHB1dEluZGljZXMob3V0cHV0X2luZGljZXMpO1xuICAgICAgdmFyIGRlcHRoOiR7dX0gPSBvcmlnaW5hbEluZGljZXNbJHtkfV07XG4gICAgICB2YXIgaGVpZ2h0OiR7dX0gPSBvcmlnaW5hbEluZGljZXNbJHtsfV07XG4gICAgICB2YXIgd2lkdGg6JHt1fSA9IG9yaWdpbmFsSW5kaWNlc1ske3B9XTtcbiAgICAgICR7bj9gaWYgKGRlcHRoIDwgMCB8fCBkZXB0aCA+ICgke3JbZF19IC0gMSkgfHwgaGVpZ2h0IDwgMCB8fCBoZWlnaHQgPiAoJHtyW2xdfSAtIDEpIHx8IHdpZHRoIDwgMCB8fCAod2lkdGggPiAke3JbcF19IC0gMSkpIHtcbiAgICAgIHJldHVybiAke299O1xuICAgICAgICB9YDpcIlwifTtcblxuICAgIGRlcHRoID0gbWF4KDAsIG1pbihkZXB0aCwgJHtyW2RdfSAtIDEpKTtcbiAgICAgIGhlaWdodCA9IG1heCgwLCBtaW4oaGVpZ2h0LCAke3JbbF19IC0gMSkpO1xuICAgICAgd2lkdGggPSBtYXgoMCwgbWluKHdpZHRoLCAke3JbcF19IC0gMSkpO1xuICAgICAgdmFyIGRlcHRoMTogdTMyID0gdTMyKGRlcHRoKTtcbiAgICAgIHZhciBoZWlnaHQxOiB1MzIgPSB1MzIoaGVpZ2h0KTtcbiAgICAgIHZhciB3aWR0aDE6IHUzMiA9IHUzMih3aWR0aCk7XG4gICAgICB2YXIgZGVwdGgyOiB1MzIgPSB1MzIoZGVwdGggKyAxKTtcbiAgICAgIHZhciBoZWlnaHQyOiB1MzIgPSB1MzIoaGVpZ2h0ICsgMSk7XG4gICAgICB2YXIgd2lkdGgyOiB1MzIgPSB1MzIod2lkdGggKyAxKTtcbiAgICAgIHZhciBjaGFubmVsOiB1MzIgPSAke3IubGVuZ3RoPjM/YHUzMihvcmlnaW5hbEluZGljZXNbJHttfV0pYDpcIjBcIn07XG4gICAgICB2YXIgYmF0Y2g6IHUzMiA9ICAke3IubGVuZ3RoPjM/YHUzMihvcmlnaW5hbEluZGljZXNbJHthfV0pYDpcIjBcIn07XG5cbiAgICAgIHZhciB4MTExOiAke3V9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgxLCBoZWlnaHQxLCB3aWR0aDEpO1xuICAgICAgdmFyIHgxMTI6ICR7dX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDEsIGhlaWdodDEsIHdpZHRoMik7XG4gICAgICB2YXIgeDEyMTogJHt1fSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMSwgaGVpZ2h0Miwgd2lkdGgxKTtcbiAgICAgIHZhciB4MTIyOiAke3V9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgxLCBoZWlnaHQyLCB3aWR0aDIpO1xuICAgICAgdmFyIHgyMTE6ICR7dX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDIsIGhlaWdodDEsIHdpZHRoMSk7XG4gICAgICB2YXIgeDIxMjogJHt1fSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMiwgaGVpZ2h0MSwgd2lkdGgyKTtcbiAgICAgIHZhciB4MjIxOiAke3V9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgyLCBoZWlnaHQyLCB3aWR0aDEpO1xuICAgICAgdmFyIHgyMjI6ICR7dX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDIsIGhlaWdodDIsIHdpZHRoMik7XG4gICAgICB2YXIgZHgxOiAke3V9ID0gYWJzKGRlcHRoIC0gJHt1fShkZXB0aDEpKTtcbiAgICAgIHZhciBkeDI6ICR7dX0gPSBhYnMoJHt1fShkZXB0aDIpIC0gZGVwdGgpO1xuICAgICAgdmFyIGR5MTogJHt1fSA9IGFicyhoZWlnaHQgLSAke3V9KGhlaWdodDEpKTtcbiAgICAgIHZhciBkeTI6ICR7dX0gPSBhYnMoJHt1fShoZWlnaHQyKSAtIGhlaWdodCk7XG4gICAgICB2YXIgZHoxOiAke3V9ID0gYWJzKHdpZHRoIC0gJHt1fSh3aWR0aDEpKTtcbiAgICAgIHZhciBkejI6ICR7dX0gPSBhYnMoJHt1fSh3aWR0aDIpIC0gd2lkdGgpO1xuICAgICAgaWYgKGRlcHRoMSA9PSBkZXB0aDIpIHtcbiAgICAgICAgZHgxID0gMC41O1xuICAgICAgICBkeDIgPSAwLjU7XG4gICAgICB9XG4gICAgICBpZiAoaGVpZ2h0MSA9PSBoZWlnaHQyKSB7XG4gICAgICAgIGR5MSA9IDAuNTtcbiAgICAgICAgZHkyID0gMC41O1xuICAgICAgfVxuICAgICAgaWYgKHdpZHRoMSA9PSB3aWR0aDIpIHtcbiAgICAgICAgZHoxID0gMC41O1xuICAgICAgICBkejIgPSAwLjU7XG4gICAgICB9XG4gICAgICByZXR1cm4gKHgxMTEgKiBkeDIgKiBkeTIgKiBkejIgKyB4MTEyICogZHgyICogZHkyICogZHoxICsgeDEyMSAqIGR4MiAqIGR5MSAqZHoyICsgeDEyMiAqIGR4MiAqIGR5MSAqIGR6MSArXG4gICAgICAgICAgICAgIHgyMTEgKiBkeDEgKiBkeTIgKiBkejIgKyB4MjEyICogZHgxICogZHkyICogZHoxICsgeDIyMSAqIGR4MSAqIGR5MSAqZHoyICsgeDIyMiAqIGR4MSAqIGR5MSAqIGR6MSk7XG4gICAgfWB9LEZoPShlLHQscixuLG8saSk9PntsZXQgYT1lLmRpbXMsZD1NaChpLHQuYXhlcyxhLmxlbmd0aCksbD1SaChhLG4sbyx0LmF4ZXMpLHA9bi5zbGljZSgpO24ubGVuZ3RoPT09MCYmKHA9YS5tYXAoKHYsUyk9PnY9PT0wPzE6bFtTXS92KSx0LmtlZXBBc3BlY3RSYXRpb1BvbGljeSE9PVwic3RyZXRjaFwiJiYobD1VaChhLHAsdCkpKTtsZXQgbT1NKFwib3V0cHV0XCIsZS5kYXRhVHlwZSxsLmxlbmd0aCksdT1FKFwiaW5wdXRcIixlLmRhdGFUeXBlLGEubGVuZ3RoKSxoPUMuc2l6ZShsKSxfPWEubGVuZ3RoPT09bC5sZW5ndGgmJmEuZXZlcnkoKHYsUyk9PnY9PT1sW1NdKSx5PXQuY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGU9PT1cInRmX2Nyb3BfYW5kX3Jlc2l6ZVwiLGc9dC5leHRyYXBvbGF0aW9uVmFsdWUseD11LnR5cGUudmFsdWUsJD12PT5gXG4gICAgICAke18/XCJcIjpgXG4gICAgICAke0RoKHQuY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUseCl9O1xuICAgICAgJHsoKCk9Pntzd2l0Y2godC5tb2RlKXtjYXNlXCJuZWFyZXN0XCI6cmV0dXJuYFxuICAgICAgICAgICAgICAke1doKHUsYSl9O1xuICAgICAgICAgICAgICAke0JoKHQubmVhcmVzdE1vZGUscix4KX07XG4gICAgICAgICAgICAgICR7VmgodSxtLGEsbCxwLmxlbmd0aCxkLmxlbmd0aCx5KX07XG4gICAgICAgICAgICAgIGA7Y2FzZVwibGluZWFyXCI6cmV0dXJuYFxuICAgICAgICAgICAgICAke05oKG0sYSxsLHAubGVuZ3RoLGQubGVuZ3RoKX07XG4gICAgICAgICAgICAgICR7KCgpPT57aWYoYS5sZW5ndGg9PT0yfHxhLmxlbmd0aD09PTQpcmV0dXJuYCR7TGgodSxtLGEseSxnKX1gO2lmKGEubGVuZ3RoPT09M3x8YS5sZW5ndGg9PT01KXJldHVybmAke0hoKHUsbSxhLHksZyl9YDt0aHJvdyBFcnJvcihcIkxpbmVhciBtb2RlIG9ubHkgc3VwcG9ydHMgaW5wdXQgZGltcyAyLCAzLCA0IGFuZCA1IGFyZSBzdXBwb3J0ZWQgaW4gbGluZWFyIG1vZGUuXCIpfSkoKX07XG4gICAgICAgICAgICBgO2Nhc2VcImN1YmljXCI6cmV0dXJuYFxuICAgICAgICAgICAgJHsoKCk9PntpZihhLmxlbmd0aD09PTJ8fGEubGVuZ3RoPT09NClyZXR1cm5gJHtHaCh1LG0sYSxsLHAsZCx0LmN1YmljQ29lZmZBLHksdC5leHRyYXBvbGF0aW9uVmFsdWUsdC5leGNsdWRlT3V0c2lkZSl9YDt0aHJvdyBFcnJvcihcIkN1YmljIG1vZGUgb25seSBzdXBwb3J0cyBpbnB1dCBkaW1zIDIgYW5kIDQgYXJlIHN1cHBvcnRlZCBpbiBsaW5lYXIgbW9kZS5cIil9KSgpfTtcbiAgICAgICAgICAgIGA7ZGVmYXVsdDp0aHJvdyBFcnJvcihcIkludmFsaWQgcmVzaXplIG1vZGVcIil9fSkoKX07XG4gICAgICBgfVxuICAgICAgJHt2LnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dF9zaXplXCIsXCJ1MzJcIikucmVnaXN0ZXJVbmlmb3JtKFwic2NhbGVzXCIsXCJmMzJcIixwLmxlbmd0aCkucmVnaXN0ZXJVbmlmb3JtKFwicm9pXCIsXCJmMzJcIixkLmxlbmd0aCkuZGVjbGFyZVZhcmlhYmxlcyh1LG0pfVxuICAgICAgJHt2Lm1haW5TdGFydCgpfVxuICAgICAgICAke3YuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgICAgICAke18/XCJvdXRwdXRbZ2xvYmFsX2lkeF0gPSBpbnB1dFtnbG9iYWxfaWR4XTtcIjpgXG4gICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7bS5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7dS50eXBlLmluZGljZXN9O1xuICAgICAgICAkeygoKT0+e3N3aXRjaCh0Lm1vZGUpe2Nhc2VcIm5lYXJlc3RcIjpyZXR1cm5gaW5wdXRfaW5kaWNlcyA9IGNhbGN1bGF0ZUlucHV0SW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tJbnB1dEluZGljZXMoaW5wdXRfaW5kaWNlcykpIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9ICR7dS5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gJHt0LmV4dHJhcG9sYXRpb25WYWx1ZX07XG4gICAgICAgICAgICAgICAgfWA7Y2FzZVwibGluZWFyXCI6cmV0dXJuYG91dHB1dFtnbG9iYWxfaWR4XSA9ICR7YS5sZW5ndGg9PT0yfHxhLmxlbmd0aD09PTQ/XCJiaWxpbmVhckludGVycG9sYXRpb25cIjpcInRyaWxpbmVhckludGVycG9sYXRpb25cIn0ob3V0cHV0X2luZGljZXMpO2A7Y2FzZVwiY3ViaWNcIjpyZXR1cm5cIm91dHB1dFtnbG9iYWxfaWR4XSA9IGJpY3ViaWNJbnRlcnBvbGF0aW9uKG91dHB1dF9pbmRpY2VzKTtcIjtkZWZhdWx0OnRocm93IEVycm9yKGBVbnN1cHBvcnRlZCByZXNpemUgbW9kZTogJHt0Lm1vZGV9YCl9fSkoKX07XG5gfVxuICAgICAgfWA7cmV0dXJue25hbWU6XCJSZXNpemVcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmNhY2hlS2V5fXwke3J9fCR7cC5sZW5ndGg+MD9wOlwiXCJ9fCR7by5sZW5ndGg+MD9vOlwiXCJ9fCR7ZC5sZW5ndGg+MD9kOlwiXCJ9fCR7X318JHthfWAsaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiXX0sZ2V0U2hhZGVyU291cmNlOiQsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpsLGRhdGFUeXBlOmUuZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChoLzY0KX0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZToxMixkYXRhOmh9LHt0eXBlOjEsZGF0YTpwfSx7dHlwZToxLGRhdGE6ZH0sLi4uTihhLGwpXX0pfX0scWg9ZT0+e2xldCB0PWUuY3VzdG9tRGF0YUJ1ZmZlcjtyZXR1cm4gbmV3IFVpbnQzMkFycmF5KHQsdC5ieXRlT2Zmc2V0LDEpWzBdfSxQbD0oZSx0KT0+e2xldCByPVtdLG49W10sbz1bXSxpPXFoKGUpO2lmKHQuYW50aWFsaWFzIT09MCl0aHJvdyBFcnJvcihcIk9ubHkgZGVmYXVsdCB2YWx1ZSAoMCkgZm9yIEFudGlhbGlhcyBhdHRyaWJ1dGUgaXMgc3VwcG9ydGVkXCIpO09oKGUuaW5wdXRzLHQsaSxyLG4sbyksZS5jb21wdXRlKEZoKGUuaW5wdXRzWzBdLHQsaSxyLG4sbykse2lucHV0czpbMF19KX0semw9ZT0+e2xldCB0PWUuYW50aWFsaWFzLHI9ZS5heGVzLG49ZS5jb29yZGluYXRlVHJhbnNmb3JtTW9kZSxvPWUuY3ViaWNDb2VmZkEsaT1lLmV4Y2x1ZGVPdXRzaWRlIT09MCxhPWUuZXh0cmFwb2xhdGlvblZhbHVlLGQ9ZS5rZWVwQXNwZWN0UmF0aW9Qb2xpY3ksbD1lLm1vZGUscD1lLm5lYXJlc3RNb2RlPT09XCJcIj9cInNpbXBsZVwiOmUubmVhcmVzdE1vZGU7cmV0dXJuIHJlKHthbnRpYWxpYXM6dCxheGVzOnIsY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGU6bixjdWJpY0NvZWZmQTpvLGV4Y2x1ZGVPdXRzaWRlOmksZXh0cmFwb2xhdGlvblZhbHVlOmEsa2VlcEFzcGVjdFJhdGlvUG9saWN5OmQsbW9kZTpsLG5lYXJlc3RNb2RlOnB9KX19KTt2YXIgS2gsamgsRGwsQmw9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTtTZSgpO2FlKCk7S2g9KGUsdCk9PntsZXRbcixuLG8saV09ZSx7bnVtSGVhZHM6YSxyb3RhcnlFbWJlZGRpbmdEaW06ZH09dDtpZihyLmRpbXMubGVuZ3RoIT09MyYmci5kaW1zLmxlbmd0aCE9PTQpdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAneCcgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIG9yIDQgZGltZW5zaW9ucywgZ290ICR7ci5kaW1zLmxlbmd0aH1gKTtpZighQy5hcmVFcXVhbChuLmRpbXMsW10pJiYhQy5hcmVFcXVhbChuLmRpbXMsWzFdKSYmbi5kaW1zLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAncG9zaXRpb25faWRzJyBpcyBleHBlY3RlZCB0byBoYXZlIDAsIDEsIG9yIDIgZGltZW5zaW9ucywgZ290ICR7bi5kaW1zLmxlbmd0aH1gKTtpZihvLmRpbXMubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoYElucHV0ICdjb3NfY2FjaGUnIGlzIGV4cGVjdGVkIHRvIGhhdmUgMiBkaW1lbnNpb25zLCBnb3QgJHtvLmRpbXMubGVuZ3RofWApO2lmKGkuZGltcy5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihgSW5wdXQgJ3Npbl9jYWNoZScgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAyIGRpbWVuc2lvbnMsIGdvdCAke2kuZGltcy5sZW5ndGh9YCk7aWYoIUMuYXJlRXF1YWwoby5kaW1zLGkuZGltcykpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXRzICdjb3NfY2FjaGUnIGFuZCAnc2luX2NhY2hlJyBhcmUgZXhwZWN0ZWQgdG8gaGF2ZSB0aGUgc2FtZSBzaGFwZVwiKTtpZihkPjAmJmE9PT0wKXRocm93IG5ldyBFcnJvcihcIm51bV9oZWFkcyBtdXN0IGJlIHByb3ZpZGVkIGlmIHJvdGFyeV9lbWJlZGRpbmdfZGltIGlzIHNwZWNpZmllZFwiKTtsZXQgbD1yLmRpbXNbMF0scD1yLmRpbXNbci5kaW1zLmxlbmd0aC0yXSxtPW8uZGltc1swXSx1PUMuc2l6ZUZyb21EaW1lbnNpb24oci5kaW1zLDEpL3AsaD1kPT09MD9vLmRpbXNbMV0qMjp1L2E7aWYoZD5oKXRocm93IG5ldyBFcnJvcihcInJvdGFyeV9lbWJlZGRpbmdfZGltIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGhlYWRfc2l6ZVwiKTtpZihuLmRpbXMubGVuZ3RoPT09Mil7aWYobCE9PW4uZGltc1swXSl0aHJvdyBuZXcgRXJyb3IoYElucHV0ICdwb3NpdGlvbl9pZHMnIGRpbWVuc2lvbiAwIHNob3VsZCBiZSBvZiBzaXplIGJhdGNoX3NpemUsIGdvdCAke24uZGltc1swXX1gKTtpZihwIT09bi5kaW1zWzFdKXRocm93IG5ldyBFcnJvcihgSW5wdXQgJ3Bvc2l0aW9uX2lkcycgZGltZW5zaW9uIDEgc2hvdWxkIGJlIG9mIHNpemUgc2VxdWVuY2VfbGVuZ3RoLCBnb3QgJHtuLmRpbXNbMV19YCl9aWYoaC8yIT09by5kaW1zWzFdJiZkLzIhPT1vLmRpbXNbMV0pdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAnY29zX2NhY2hlJyBkaW1lbnNpb24gMSBzaG91bGQgYmUgc2FtZSBhcyBoZWFkX3NpemUgLyAyIG9yIHJvdGFyeV9lbWJlZGRpbmdfZGltIC8gMiwgZ290ICR7by5kaW1zWzFdfWApO2lmKHA+bSl0aHJvdyBuZXcgRXJyb3IoXCJVcGRhdGluZyBjb3NfY2FjaGUgYW5kIHNpbl9jYWNoZSBpbiBSb3RhcnlFbWJlZGRpbmcgaXMgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWRcIil9LGpoPShlLHQpPT57bGV0e2ludGVybGVhdmVkOnIsbnVtSGVhZHM6bixyb3RhcnlFbWJlZGRpbmdEaW06byxzY2FsZTppfT10LGE9ZVswXS5kaW1zWzBdLGQ9Qy5zaXplRnJvbURpbWVuc2lvbihlWzBdLmRpbXMsMSksbD1lWzBdLmRpbXNbZVswXS5kaW1zLmxlbmd0aC0yXSxwPWQvbCxtPWVbMl0uZGltc1sxXSx1PW89PT0wP20qMjpwL24saD1uZXcgQXJyYXkoYSxsLHAvdSx1LW0pLF89Qy5jb21wdXRlU3RyaWRlcyhoKSx5PVt7dHlwZToxLGRhdGE6aX0se3R5cGU6MTIsZGF0YTpofSx7dHlwZToxMixkYXRhOl99LC4uLmVbMF0uZGltcy5sZW5ndGg9PT0zP25ldyBBcnJheSh7dHlwZToxMixkYXRhOltkLHAsdSwxXX0pOltdLC4uLmVbMF0uZGltcy5sZW5ndGg9PT00P25ldyBBcnJheSh7dHlwZToxMixkYXRhOltkLHUsbCp1LDFdfSk6W10sLi4uTihlWzBdLmRpbXMsZVsxXS5kaW1zLGVbMl0uZGltcyxlWzNdLmRpbXMsZVswXS5kaW1zKV0sZz14PT57bGV0ICQ9RShcImlucHV0XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMubGVuZ3RoKSx2PUUoXCJwb3NpdGlvbl9pZHNcIixlWzFdLmRhdGFUeXBlLGVbMV0uZGltcy5sZW5ndGgpLFM9RShcImNvc19jYWNoZVwiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLmxlbmd0aCksVD1FKFwic2luX2NhY2hlXCIsZVszXS5kYXRhVHlwZSxlWzNdLmRpbXMubGVuZ3RoKSxBPU0oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcy5sZW5ndGgpO3JldHVybiB4LnJlZ2lzdGVyVW5pZm9ybXMoW3tuYW1lOlwic2NhbGVcIix0eXBlOlwiZjMyXCJ9LHtuYW1lOlwiZ2xvYmFsX3NoYXBlXCIsdHlwZTpcInUzMlwiLGxlbmd0aDpoLmxlbmd0aH0se25hbWU6XCJnbG9iYWxfc3RyaWRlc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6Xy5sZW5ndGh9LHtuYW1lOlwiaW5wdXRfb3V0cHV0X3N0cmlkZXNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOl8ubGVuZ3RofV0pLGBcbiAgICAgICAgJHt4LmRlY2xhcmVWYXJpYWJsZXMoJCx2LFMsVCxBKX1cblxuICAgICAgICAke3gubWFpblN0YXJ0KGt0KX1cbiAgICAgICAgICBsZXQgaGFsZl9yb3RhcnlfZW1iX2RpbSA9IHVuaWZvcm1zLiR7Uy5uYW1lfV9zaGFwZVsxXTtcbiAgICAgICAgICBsZXQgYnNuaCA9IGdsb2JhbF9pZHggLyB1bmlmb3Jtcy5nbG9iYWxfc3RyaWRlcyAlIHVuaWZvcm1zLmdsb2JhbF9zaGFwZTtcbiAgICAgICAgICBsZXQgc2l6ZSA9IHVuaWZvcm1zLmdsb2JhbF9zaGFwZVswXSAqIHVuaWZvcm1zLmdsb2JhbF9zdHJpZGVzWzBdO1xuICAgICAgICAgICR7eC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwic2l6ZVwiKX1cblxuICAgICAgICAgIGlmIChic25oWzNdIDwgaGFsZl9yb3RhcnlfZW1iX2RpbSkge1xuICAgICAgICAgICAgbGV0IHBvc2l0aW9uX2lkc19pZHggPVxuICAgICAgICAgICAgICAgICR7di5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChcImJzbmgueHlcIixNKFwiXCIsdi50eXBlLnRlbnNvciwyKSl9O1xuICAgICAgICAgICAgbGV0IHBvc2l0aW9uX2lkID1cbiAgICAgICAgICAgICAgICB1MzIoJHt2LmdldEJ5T2Zmc2V0KFwicG9zaXRpb25faWRzX2lkeFwiKX0pICsgc2VsZWN0KDAsIGJzbmhbMV0sIHBvc2l0aW9uX2lkc19pZHggPT0gMCk7XG4gICAgICAgICAgICBsZXQgaSA9IGRvdChic25oLCB1bmlmb3Jtcy5pbnB1dF9vdXRwdXRfc3RyaWRlcykgKyBzZWxlY3QoMCwgYnNuaFszXSwgJHtyfSk7XG4gICAgICAgICAgICBsZXQgaiA9IGkgKyBzZWxlY3QoaGFsZl9yb3RhcnlfZW1iX2RpbSwgMSwgJHtyfSk7XG4gICAgICAgICAgICBsZXQgcmUgPSAkeyQuZ2V0QnlPZmZzZXQoXCJpXCIpfSAqICR7Uy5nZXQoXCJwb3NpdGlvbl9pZFwiLFwiYnNuaFszXVwiKX0gLVxuICAgICAgICAgICAgICAgICR7JC5nZXRCeU9mZnNldChcImpcIil9ICogJHtULmdldChcInBvc2l0aW9uX2lkXCIsXCJic25oWzNdXCIpfTtcbiAgICAgICAgICAgICR7QS5zZXRCeU9mZnNldChcImlcIixcInJlXCIpfVxuICAgICAgICAgICAgbGV0IGltID0gJHskLmdldEJ5T2Zmc2V0KFwiaVwiKX0gKiAke1QuZ2V0KFwicG9zaXRpb25faWRcIixcImJzbmhbM11cIil9ICtcbiAgICAgICAgICAgICAgICAkeyQuZ2V0QnlPZmZzZXQoXCJqXCIpfSAqICR7Uy5nZXQoXCJwb3NpdGlvbl9pZFwiLFwiYnNuaFszXVwiKX07XG4gICAgICAgICAgICAke0Euc2V0QnlPZmZzZXQoXCJqXCIsXCJpbVwiKX1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGsgPSBkb3QoYnNuaCwgdW5pZm9ybXMuaW5wdXRfb3V0cHV0X3N0cmlkZXMpICsgaGFsZl9yb3RhcnlfZW1iX2RpbTtcbiAgICAgICAgICAgICR7QS5zZXRCeU9mZnNldChcImtcIiwkLmdldEJ5T2Zmc2V0KFwia1wiKSl9XG4gICAgICAgICAgfVxuICAgICAgICB9YH07cmV0dXJue25hbWU6XCJSb3RhcnlFbWJlZGRpbmdcIixzaGFkZXJDYWNoZTp7aGludDpyZSh7aW50ZXJsZWF2ZWQ6cn0pLmNhY2hlS2V5LGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIixcInJhbmtcIixcInJhbmtcIixcInJhbmtcIl19LGdldFNoYWRlclNvdXJjZTpnLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6ZVswXS5kaW1zLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChDLnNpemUoaCkva3QpfSxwcm9ncmFtVW5pZm9ybXM6eX0pfX0sRGw9KGUsdCk9PntLaChlLmlucHV0cyx0KSxlLmNvbXB1dGUoamgoZS5pbnB1dHMsdCkpfX0pO3ZhciBZaCxaaCxNbCxSbD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtvZSgpO2FlKCk7WWg9ZT0+e2lmKCFlfHxlLmxlbmd0aDwzKXRocm93IG5ldyBFcnJvcihcImxheWVyTm9ybSByZXF1aXJlcyBhdCBsZWFzdCAzIGlucHV0cy5cIik7bGV0IHQ9ZVswXSxyPWVbMV0sbj1lWzJdO2lmKHQuZGF0YVR5cGUhPT1yLmRhdGFUeXBlfHx0LmRhdGFUeXBlIT09bi5kYXRhVHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJBbGwgaW5wdXRzIG11c3QgaGF2ZSB0aGUgc2FtZSBkYXRhIHR5cGVcIik7aWYodC5kaW1zLmxlbmd0aCE9PTMmJnQuZGltcy5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIklucHV0IG11c3QgYmUgMkQgb3IgM0RcIik7aWYoci5kaW1zLmxlbmd0aCE9PTMmJnIuZGltcy5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIlNraXAgbXVzdCBiZSAyRCBvciAzRFwiKTtsZXQgbz10LmRpbXNbdC5kaW1zLmxlbmd0aC0xXSxpPXQuZGltc1t0LmRpbXMubGVuZ3RoLTJdO2lmKHIuZGltc1tyLmRpbXMubGVuZ3RoLTFdIT09byl0aHJvdyBuZXcgRXJyb3IoXCJTa2lwIG11c3QgaGF2ZSB0aGUgc2FtZSBoaWRkZW4gc2l6ZSBhcyBpbnB1dFwiKTtpZihyLmRpbXNbci5kaW1zLmxlbmd0aC0yXSE9PWkpdGhyb3cgbmV3IEVycm9yKFwiU2tpcCBtdXN0IGhhdmUgdGhlIHNhbWUgc2VxdWVuY2UgbGVuZ3RoIGFzIGlucHV0XCIpO2lmKG4uZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIkdhbW1hIG11c3QgYmUgMURcIik7aWYobi5kaW1zW24uZGltcy5sZW5ndGgtMV0hPT1vKXRocm93IG5ldyBFcnJvcihcIkdhbW1hIG11c3QgaGF2ZSB0aGUgc2FtZSBoaWRkZW4gc2l6ZSBhcyBpbnB1dFwiKTtpZihlLmxlbmd0aD4zKXtsZXQgYT1lWzNdO2lmKGEuZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIkJldGEgbXVzdCBiZSAxRFwiKTtpZihhLmRpbXNbYS5kaW1zLmxlbmd0aC0xXSE9PW8pdGhyb3cgbmV3IEVycm9yKFwiQmV0YSBtdXN0IGhhdmUgdGhlIHNhbWUgaGlkZGVuIHNpemUgYXMgaW5wdXRcIil9aWYoZS5sZW5ndGg+NCl7bGV0IGE9ZVs0XTtpZihhLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJCaWFzIG11c3QgYmUgMURcIik7aWYoYS5kaW1zW2EuZGltcy5sZW5ndGgtMV0hPT1vKXRocm93IG5ldyBFcnJvcihcIkJpYXMgbXVzdCBoYXZlIHRoZSBzYW1lIGhpZGRlbiBzaXplIGFzIGlucHV0XCIpfX0sWmg9KGUsdCxyLG4pPT57bGV0IG89dC5zaW1wbGlmaWVkLGk9ZVswXS5kaW1zLGE9Qy5zaXplKGkpLGQ9aSxsPWEscD1pLnNsaWNlKC0xKVswXSxtPW4/aS5zbGljZSgwLC0xKS5jb25jYXQoMSk6W10sdT0hbyYmZS5sZW5ndGg+MyxoPWUubGVuZ3RoPjQsXz1uJiZyPjEseT1uJiZyPjIsZz1yPjMseD02NCwkPW1lKHApLHY9W3t0eXBlOjEyLGRhdGE6bH0se3R5cGU6MTIsZGF0YTokfSx7dHlwZToxMixkYXRhOnB9LHt0eXBlOjEsZGF0YTp0LmVwc2lsb259XSxTPUE9PntsZXQgaz1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJjb21wb25lbnRzXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImhpZGRlbl9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImVwc2lsb25cIix0eXBlOlwiZjMyXCJ9XSxQPVtFKFwieFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLCQpLEUoXCJza2lwXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMsJCksRShcImdhbW1hXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMsJCldO3UmJlAucHVzaChFKFwiYmV0YVwiLGVbM10uZGF0YVR5cGUsZVszXS5kaW1zLCQpKSxoJiZQLnB1c2goRShcImJpYXNcIixlWzRdLmRhdGFUeXBlLGVbNF0uZGltcywkKSksUC5wdXNoKE0oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLGQsJCkpLF8mJlAucHVzaChNKFwibWVhbl9vdXRwdXRcIiwxLG0pKSx5JiZQLnB1c2goTShcImludl9zdGRfb3V0cHV0XCIsMSxtKSksZyYmUC5wdXNoKE0oXCJpbnB1dF9za2lwX2JpYXNfc3VtXCIsZVswXS5kYXRhVHlwZSxkLCQpKTtsZXQgRD1fZShlWzBdLmRhdGFUeXBlKSxSPV9lKDEsJCk7cmV0dXJuYFxuXG4gICAgICAke0EucmVnaXN0ZXJVbmlmb3JtcyhrKS5kZWNsYXJlVmFyaWFibGVzKC4uLlApfVxuICAgICAgdmFyPHdvcmtncm91cD4gc3VtX3NoYXJlZCA6IGFycmF5PCR7Un0sICR7eH0+O1xuICAgICAgdmFyPHdvcmtncm91cD4gc3VtX3NxdWFyZWRfc2hhcmVkIDogYXJyYXk8JHtSfSwgJHt4fT47XG5cbiAgICAgICR7QS5tYWluU3RhcnQoW3gsMSwxXSl9XG4gICAgICAgIGxldCBpeCA9IGxvY2FsX2lkLng7XG4gICAgICAgIGxldCBpeSA9IGdsb2JhbF9pZC54IC8gJHt4fTtcblxuICAgICAgICBsZXQgaGlkZGVuX3NpemVfdmVjdG9yaXplZDogdTMyID0gdW5pZm9ybXMuaGlkZGVuX3NpemUgLyB1bmlmb3Jtcy5jb21wb25lbnRzO1xuICAgICAgICB2YXIgc3RyaWRlID0gaGlkZGVuX3NpemVfdmVjdG9yaXplZCAvICR7eH07XG4gICAgICAgIGxldCBvZmZzZXQgPSBpeCAqIHN0cmlkZSArIGl5ICogaGlkZGVuX3NpemVfdmVjdG9yaXplZDtcbiAgICAgICAgbGV0IG9mZnNldDFkID0gc3RyaWRlICogaXg7XG4gICAgICAgIGlmIChpeCA9PSAke3gtMX0pIHtcbiAgICAgICAgICBzdHJpZGUgPSBoaWRkZW5fc2l6ZV92ZWN0b3JpemVkIC0gc3RyaWRlICogaXg7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHN0cmlkZTsgaSsrKSB7XG4gICAgICAgICAgbGV0IHNraXBfdmFsdWUgPSBza2lwW29mZnNldCArIGldO1xuICAgICAgICAgIGxldCBiaWFzX3ZhbHVlID0gJHtoP1wiYmlhc1tvZmZzZXQxZCArIGldXCI6RCtcIigwLjApXCJ9O1xuICAgICAgICAgIGxldCBpbnB1dF92YWx1ZSA9IHhbb2Zmc2V0ICsgaV07XG4gICAgICAgICAgbGV0IHZhbHVlID0gaW5wdXRfdmFsdWUgKyBza2lwX3ZhbHVlICsgYmlhc192YWx1ZTtcbiAgICAgICAgICAke2c/XCJpbnB1dF9za2lwX2JpYXNfc3VtW29mZnNldCArIGldID0gdmFsdWU7XCI6XCJcIn1cbiAgICAgICAgICBvdXRwdXRbb2Zmc2V0ICsgaV0gPSB2YWx1ZTtcbiAgICAgICAgICBsZXQgZjMyX3ZhbHVlID0gJHtFdChELCQsXCJ2YWx1ZVwiKX07XG4gICAgICAgICAgc3VtX3NoYXJlZFtpeF0gKz0gZjMyX3ZhbHVlO1xuICAgICAgICAgIHN1bV9zcXVhcmVkX3NoYXJlZFtpeF0gKz0gZjMyX3ZhbHVlICogZjMyX3ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICB2YXIgcmVkdWNlX3NpemUgOiB1MzIgPSAke3h9O1xuICAgICAgICBmb3IgKHZhciBjdXJyX3NpemUgPSByZWR1Y2Vfc2l6ZSA+PiAxOyAgY3Vycl9zaXplID4gMDsgY3Vycl9zaXplID0gcmVkdWNlX3NpemUgPj4gMSkge1xuICAgICAgICAgIHJlZHVjZV9zaXplID0gY3Vycl9zaXplICsgKHJlZHVjZV9zaXplICYgMSk7XG4gICAgICAgICAgaWYgKGl4IDwgY3Vycl9zaXplKSB7XG4gICAgICAgICAgICBzdW1fc2hhcmVkW2l4XSArPSBzdW1fc2hhcmVkW2l4ICsgcmVkdWNlX3NpemVdO1xuICAgICAgICAgICAgc3VtX3NxdWFyZWRfc2hhcmVkW2l4XSArPSBzdW1fc3F1YXJlZF9zaGFyZWRbaXggKyByZWR1Y2Vfc2l6ZV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzdW0gPSBzdW1fc2hhcmVkWzBdO1xuICAgICAgICBsZXQgc3F1YXJlX3N1bSA9IHN1bV9zcXVhcmVkX3NoYXJlZFswXTtcbiAgICAgICAgbGV0IG1lYW4gPSAke0ZlKFwic3VtXCIsJCl9IC8gZjMyKHVuaWZvcm1zLmhpZGRlbl9zaXplKTtcbiAgICAgICAgbGV0IGludl9zdGRfZGV2ID0gaW52ZXJzZVNxcnQoJHtGZShcInNxdWFyZV9zdW1cIiwkKX0gLyBmMzIodW5pZm9ybXMuaGlkZGVuX3NpemUpICR7bz9cIlwiOlwiLSBtZWFuICogbWVhblwifSArIHVuaWZvcm1zLmVwc2lsb24pO1xuICAgICAgICAke18/XCJtZWFuX291dHB1dFtnbG9iYWxfaWR4XSA9IG1lYW47XCI6XCJcIn1cbiAgICAgICAgJHt5P1wiaW52X3N0ZF9vdXRwdXRbZ2xvYmFsX2lkeF0gPSBpbnZfc3RkX2RldjtcIjpcIlwifVxuXG4gICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCBzdHJpZGU7IGkrKykge1xuICAgICAgICAgIG91dHB1dFtvZmZzZXQgKyBpXSA9IChvdXRwdXRbb2Zmc2V0ICsgaV0gJHtvP1wiXCI6YC0gJHtEfShtZWFuKWB9KSAqXG4gICAgICAgICAgICAke0R9KGludl9zdGRfZGV2KSAqIGdhbW1hW29mZnNldDFkICsgaV1cbiAgICAgICAgICAgICR7dT9cIisgYmV0YVtvZmZzZXQxZCArIGldXCI6XCJcIn07XG4gICAgICAgIH1cbiAgICAgIH1gfSxUPVt7ZGltczpkLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XTtyZXR1cm4gcj4xJiZULnB1c2goe2RpbXM6bSxkYXRhVHlwZToxfSkscj4yJiZULnB1c2goe2RpbXM6bSxkYXRhVHlwZToxfSkscj4zJiZULnB1c2goe2RpbXM6aSxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfSkse25hbWU6XCJTa2lwTGF5ZXJOb3JtYWxpemF0aW9uXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7JH07JHtffTske3l9OyR7Z31gLGlucHV0RGVwZW5kZW5jaWVzOmUubWFwKChBLGspPT5cInR5cGVcIil9LGdldFNoYWRlclNvdXJjZTpTLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpULGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGwvcCl9LHByb2dyYW1Vbmlmb3Jtczp2fSl9fSxNbD0oZSx0KT0+e1loKGUuaW5wdXRzKTtsZXQgbj1bMF07ZS5vdXRwdXRDb3VudD4xJiZuLnB1c2goLTMpLGUub3V0cHV0Q291bnQ+MiYmbi5wdXNoKC0zKSxlLm91dHB1dENvdW50PjMmJm4ucHVzaCgzKSxlLmNvbXB1dGUoWmgoZS5pbnB1dHMsdCxlLm91dHB1dENvdW50LCExKSx7b3V0cHV0czpufSl9fSk7dmFyIFFoLHJuLFhoLFVsLEpoLGVnLE5sLFZsLFdsPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7U2UoKTthZSgpO1FoPShlLHQpPT57aWYoIWV8fGUubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKFwidG9vIGZldyBpbnB1dHNcIik7aWYodC5heGVzLmxlbmd0aCE9PTApe2lmKHQuYXhlcy5sZW5ndGghPT10LnN0YXJ0cy5sZW5ndGh8fHQuYXhlcy5sZW5ndGghPT10LmVuZHMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImF4ZXMsIHN0YXJ0cyBhbmQgZW5kcyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoXCIpfWVsc2UgaWYodC5zdGFydHMubGVuZ3RoIT09dC5lbmRzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzdGFydHMgYW5kIGVuZHMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiKTtlLnNsaWNlKDEpLmZvckVhY2goKHIsbik9PntpZihlW24rMV0uZGF0YVR5cGUhPT02JiZlW24rMV0uZGF0YVR5cGUhPT03KXRocm93IG5ldyBFcnJvcihgSW5wdXQgJHtufSBtdXN0IGJlIGFuIGFycmF5IG9mIGludDMyIG9yIGludDY0YCl9KX0scm49KGUsdCk9PntsZXQgcj1bXTtpZihlLmxlbmd0aD50KWlmKGVbdF0uZGF0YVR5cGU9PT03KWVbdF0uZ2V0QmlnSW50NjRBcnJheSgpLmZvckVhY2gobj0+ci5wdXNoKE51bWJlcihuKSkpO2Vsc2UgaWYoZVt0XS5kYXRhVHlwZT09PTYpZVt0XS5nZXRJbnQzMkFycmF5KCkuZm9yRWFjaChuPT5yLnB1c2goTnVtYmVyKG4pKSk7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoYElucHV0ICR7dH0gbXVzdCBiZSBhbiBhcnJheSBvZiBpbnQzMiBvciBpbnQ2NGApO3JldHVybiByfSxYaD0oZSx0KT0+e2lmKGUubGVuZ3RoPjEpe2xldCByPXJuKGUsMSksbj1ybihlLDIpLG89cm4oZSwzKTtyZXR1cm4gby5sZW5ndGg9PT0wJiYobz1bLi4uQXJyYXkoZVswXS5kaW1zLmxlbmd0aCkua2V5cygpXSkscmUoe3N0YXJ0czpyLGVuZHM6bixheGVzOm99KX1lbHNlIHJldHVybiB0fSxVbD0oZSx0LHIsbixvKT0+e2xldCBpPWU7cmV0dXJuIGU8MCYmKGkrPXJbblt0XV0pLG9bdF08MD9NYXRoLm1heCgwLE1hdGgubWluKGkscltuW3RdXS0xKSk6TWF0aC5tYXgoMCxNYXRoLm1pbihpLHJbblt0XV0pKX0sSmg9KGUsdCxyKT0+YGZuIGNhbGN1bGF0ZUlucHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlczogJHt0LnR5cGUuaW5kaWNlc30pIC0+ICR7ZS50eXBlLmluZGljZXN9IHtcbiAgICAgICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc307XG4gICAgICAgICAgdmFyIGNhcnJ5ID0gMHU7XG4gICAgICAgICAgZm9yICh2YXIgaSA9ICR7ci5sZW5ndGh9OyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IGlucHV0X3NoYXBlX2kgPSAke0YoXCJ1bmlmb3Jtcy5pbnB1dF9zaGFwZVwiLFwiaVwiLHIubGVuZ3RoKX07XG4gICAgICAgICAgICBsZXQgc3RlcHNfaSA9ICR7RihcInVuaWZvcm1zLnN0ZXBzXCIsXCJpXCIsci5sZW5ndGgpfTtcbiAgICAgICAgICAgIGxldCBzaWduc19pID0gJHtGKFwidW5pZm9ybXMuc2lnbnNcIixcImlcIixyLmxlbmd0aCl9O1xuICAgICAgICAgICAgbGV0IHN0YXJ0c19pID0gJHtGKFwidW5pZm9ybXMuc3RhcnRzXCIsXCJpXCIsci5sZW5ndGgpfTtcbiAgICAgICAgICAgIHZhciBvdXRwdXRfaW5kZXggPSAke3QuaW5kaWNlc0dldChcIm91dHB1dF9pbmRpY2VzXCIsXCJpXCIpfTtcbiAgICAgICAgICAgIHZhciBpbnB1dF9pbmRleCA9IG91dHB1dF9pbmRleCAqIHN0ZXBzX2kgKyBzdGFydHNfaSArIGNhcnJ5O1xuICAgICAgICAgICAgY2FycnkgPSBpbnB1dF9pbmRleCAvIGlucHV0X3NoYXBlX2k7XG4gICAgICAgICAgICBpbnB1dF9pbmRleCA9IGlucHV0X2luZGV4ICUgaW5wdXRfc2hhcGVfaTtcbiAgICAgICAgICAgIGlmIChzaWduc19pIDwgMCkge1xuICAgICAgICAgICAgICBpbnB1dF9pbmRleCA9IGlucHV0X3NoYXBlX2kgLSBpbnB1dF9pbmRleCAtIDF1ICsgc3RhcnRzX2k7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixcImlcIixcImlucHV0X2luZGV4XCIpfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGlucHV0X2luZGljZXM7XG4gICAgICB9YCxlZz0oZSx0KT0+e2xldCByPWVbMF0uZGltcyxuPUMuc2l6ZShyKSxvPXQuYXhlcy5sZW5ndGg+MD9DLm5vcm1hbGl6ZUF4ZXModC5heGVzLHIubGVuZ3RoKTpbLi4uQXJyYXkoci5sZW5ndGgpLmtleXMoKV0saT1ybihlLDQpO2kuZm9yRWFjaCgkPT4kIT09MHx8KCgpPT57dGhyb3cgbmV3IEVycm9yKFwic3RlcCBjYW5ub3QgYmUgMFwiKX0pKSxpLmxlbmd0aD09PTAmJihpPUFycmF5KG8ubGVuZ3RoKS5maWxsKDEpKTtsZXQgYT10LnN0YXJ0cy5tYXAoKCQsdik9PlVsKCQsdixyLG8saSkpLGQ9dC5lbmRzLm1hcCgoJCx2KT0+VWwoJCx2LHIsbyxpKSk7aWYoby5sZW5ndGghPT1hLmxlbmd0aHx8by5sZW5ndGghPT1kLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzdGFydCwgZW5kcyBhbmQgYXhlcyBzaG91bGQgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHNcIik7aWYoby5sZW5ndGghPT1yLmxlbmd0aClmb3IobGV0ICQ9MDskPHIubGVuZ3RoOysrJClvLmluY2x1ZGVzKCQpfHwoYS5zcGxpY2UoJCwwLDApLGQuc3BsaWNlKCQsMCxyWyRdKSxpLnNwbGljZSgkLDAsMSkpO2xldCBsPWkubWFwKCQ9Pk1hdGguc2lnbigkKSk7aS5mb3JFYWNoKCgkLHYsUyk9PntpZigkPDApe2xldCBUPShkW3ZdLWFbdl0pLyQsQT1hW3ZdLGs9QStUKmlbdl07YVt2XT1rLGRbdl09QSxTW3ZdPS0kfX0pO2xldCBwPXIuc2xpY2UoMCk7by5mb3JFYWNoKCgkLHYpPT57cFskXT1NYXRoLmNlaWwoKGRbJF0tYVskXSkvaVskXSl9KTtsZXQgbT17ZGltczpwLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9LHU9TShcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUscC5sZW5ndGgpLGg9RShcImlucHV0XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMubGVuZ3RoKSxfPUMuc2l6ZShwKSx5PVt7bmFtZTpcIm91dHB1dFNpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwic3RhcnRzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDphLmxlbmd0aH0se25hbWU6XCJzaWduc1wiLHR5cGU6XCJpMzJcIixsZW5ndGg6bC5sZW5ndGh9LHtuYW1lOlwic3RlcHNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOmkubGVuZ3RofV0sZz1be3R5cGU6MTIsZGF0YTpffSx7dHlwZToxMixkYXRhOmF9LHt0eXBlOjYsZGF0YTpsfSx7dHlwZToxMixkYXRhOml9LC4uLk4oZVswXS5kaW1zLHApXSx4PSQ9PmBcbiAgICAgICR7JC5yZWdpc3RlclVuaWZvcm1zKHkpLmRlY2xhcmVWYXJpYWJsZXMoaCx1KX1cbiAgICAgICAgJHtKaChoLHUscil9XG4gICAgICAgICR7JC5tYWluU3RhcnQoKX1cbiAgICAgICAgICAkeyQuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG4gICAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHt1Lm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgICAgIGxldCBpbnB1dF9pbmRpY2VzID0gY2FsY3VsYXRlSW5wdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzKTtcbiAgICAgICAgICAke3Uuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsaC5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpKX1cbiAgICAgIH1gO3JldHVybntuYW1lOlwiU2xpY2VcIixzaGFkZXJDYWNoZTp7aGludDpgJHtsLmxlbmd0aH1fJHthLmxlbmd0aH1fJHtpLmxlbmd0aH1gLGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LGdldFNoYWRlclNvdXJjZTp4LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbbV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwobi82NCl9LHByb2dyYW1Vbmlmb3JtczpnfSl9fSxObD0oZSx0KT0+e1FoKGUuaW5wdXRzLHQpO2xldCByPVhoKGUuaW5wdXRzLHQpO2UuY29tcHV0ZShlZyhlLmlucHV0cyxyKSx7aW5wdXRzOlswXX0pfSxWbD1lPT57bGV0IHQ9ZS5zdGFydHMscj1lLmVuZHMsbj1lLmF4ZXM7cmV0dXJuIHJlKHtzdGFydHM6dCxlbmRzOnIsYXhlczpufSl9fSk7dmFyIHRnLHJnLExsLEdsLEhsPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7U2UoKTtkdCgpO2FlKCk7dGc9ZT0+e2lmKCFlfHxlLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiU29mdG1heCBvcCByZXF1aXJlcyAxIGlucHV0LlwiKX0scmc9KGUsdCk9PntsZXQgcj1lLmlucHV0c1swXSxuPXIuZGltcyxvPUMuc2l6ZShuKSxpPW4ubGVuZ3RoLGE9Qy5ub3JtYWxpemVBeGlzKHQuYXhpcyxpKSxkPWE8bi5sZW5ndGgtMSxsLHA9W107ZD8ocD1BcnJheS5mcm9tKHtsZW5ndGg6aX0sKFAsRCk9PkQpLHBbYV09aS0xLHBbaS0xXT1hLGw9ZS5jb21wdXRlKFBlKHIscCkse2lucHV0czpbcl0sb3V0cHV0czpbLTFdfSlbMF0pOmw9cjtsZXQgbT1sLmRpbXMsdT1tW2ktMV0saD1vL3UsXz1tZSh1KSx5PXUvXyxnPTY0O2g9PT0xJiYoZz0yNTYpO2xldCB4PShQLEQpPT5EPT09ND9gbWF4KG1heCgke1B9LngsICR7UH0ueSksIG1heCgke1B9LnosICR7UH0udykpYDpEPT09Mj9gbWF4KCR7UH0ueCwgJHtQfS55KWA6RD09PTM/YG1heChtYXgoJHtQfS54LCAke1B9LnkpLCAke1B9LnopYDpQLCQ9RShcInhcIixsLmRhdGFUeXBlLGwuZGltcyxfKSx2PU0oXCJyZXN1bHRcIixsLmRhdGFUeXBlLGwuZGltcyxfKSxTPSQudHlwZS52YWx1ZSxUPV9lKGwuZGF0YVR5cGUpPT09XCJmMzJcIj9gdmFyIHRocmVhZE1heCA9ICR7U30oLTMuNDAyODIzZSszOGYpO2A6YHZhciB0aHJlYWRNYXggPSAke1N9KC02NTUwNC4waCk7YCxBPVA9PmBcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHJvd01heFNoYXJlZCA6ICR7U307XG4gICAgICB2YXI8d29ya2dyb3VwPiByb3dTdW1TaGFyZWQgOiAke1N9O1xuICAgICAgdmFyPHdvcmtncm91cD4gdGhyZWFkU2hhcmVkIDogYXJyYXk8JHtTfSwgJHtnfT47XG5cbiAgICAgIGZuIGdldFZhbHVlKHJvdzogaTMyLCBjb2w6IGkzMiwgcm93X3N0cmlkZTogaTMyKSAtPiAke1N9IHtcbiAgICAgICAgbGV0IGluZGV4ID0gcm93ICogcm93X3N0cmlkZSArIGNvbDtcbiAgICAgICAgcmV0dXJuIHhbaW5kZXhdO1xuICAgICAgfVxuXG4gICAgICBmbiBzZXRWYWx1ZShyb3c6IGkzMiwgY29sOiBpMzIsIHJvd19zdHJpZGU6IGkzMiwgdmFsdWU6ICR7U30pIHtcbiAgICAgICAgbGV0IGluZGV4ID0gcm93ICogcm93X3N0cmlkZSArIGNvbDtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgJHtQLnJlZ2lzdGVyVW5pZm9ybShcInBhY2tlZENvbHNcIixcImkzMlwiKS5kZWNsYXJlVmFyaWFibGVzKCQsdil9XG4gICAgICAke1AubWFpblN0YXJ0KGcpfVxuICAgICAgICBsZXQgZ2luZGV4ID0gaTMyKGdsb2JhbF9pZHgpO1xuICAgICAgICBsZXQgbGluZGV4ID0gaTMyKGxvY2FsX2lkeCk7XG4gICAgICAgIGNvbnN0IHdnID0gJHtnfTtcbiAgICAgICAgbGV0IHJvdyA9IGdpbmRleCAvIHdnO1xuICAgICAgICBsZXQgY29scyA9IHVuaWZvcm1zLnBhY2tlZENvbHM7XG4gICAgICAgIGxldCByb3dfc3RyaWRlIDogaTMyID0gdW5pZm9ybXMucGFja2VkQ29scztcblxuICAgICAgICAvLyBmaW5kIHRoZSByb3dzIG1heFxuICAgICAgICAke1R9XG4gICAgICAgIGZvciAodmFyIGNvbCA9IGxpbmRleDsgY29sIDwgY29sczsgY29sICs9IHdnKSB7XG4gICAgICAgICAgbGV0IHZhbHVlID0gZ2V0VmFsdWUocm93LCBjb2wsIHJvd19zdHJpZGUpO1xuICAgICAgICAgIHRocmVhZE1heCA9IG1heCh0aHJlYWRNYXgsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZGV4IDwgY29scykge1xuICAgICAgICAgIHRocmVhZFNoYXJlZFtsaW5kZXhdID0gdGhyZWFkTWF4O1xuICAgICAgICB9XG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICB2YXIgcmVkdWNlU2l6ZSA9IG1pbihjb2xzLCB3Zyk7XG4gICAgICAgIGZvciAodmFyIGN1cnJTaXplID0gcmVkdWNlU2l6ZSA+PiAxOyAgY3VyclNpemUgPiAwOyBjdXJyU2l6ZSA9IHJlZHVjZVNpemUgPj4gMSkge1xuICAgICAgICAgIHJlZHVjZVNpemUgPSBjdXJyU2l6ZSArIChyZWR1Y2VTaXplICYgMSk7XG4gICAgICAgICAgaWYgKGxpbmRleCA8IGN1cnJTaXplKSB7XG4gICAgICAgICAgICB0aHJlYWRTaGFyZWRbbGluZGV4XSA9IG1heCh0aHJlYWRTaGFyZWRbbGluZGV4XSwgdGhyZWFkU2hhcmVkW2xpbmRleCArIHJlZHVjZVNpemVdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5kZXggPT0gMCkge1xuICAgICAgICAgIHJvd01heFNoYXJlZCA9ICR7U30oJHt4KFwidGhyZWFkU2hhcmVkWzBdXCIsXyl9KTtcbiAgICAgICAgfVxuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgLy8gZmluZCB0aGUgcm93cyBzdW1cbiAgICAgICAgdmFyIHRocmVhZFN1bSA9ICR7U30oMC4wKTtcbiAgICAgICAgZm9yICh2YXIgY29sID0gbGluZGV4OyBjb2wgPCBjb2xzOyBjb2wgKz0gd2cpIHtcbiAgICAgICAgICBsZXQgc3ViRXhwID0gZXhwKGdldFZhbHVlKHJvdywgY29sLCByb3dfc3RyaWRlKSAtIHJvd01heFNoYXJlZCk7XG4gICAgICAgICAgdGhyZWFkU3VtICs9IHN1YkV4cDtcbiAgICAgICAgfVxuICAgICAgICB0aHJlYWRTaGFyZWRbbGluZGV4XSA9IHRocmVhZFN1bTtcbiAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgIGZvciAodmFyIGN1cnJTaXplID0gd2cgPj4gMTsgIGN1cnJTaXplID4gMDsgY3VyclNpemUgPSBjdXJyU2l6ZSA+PiAxKSB7XG4gICAgICAgICAgaWYgKGxpbmRleCA8IGN1cnJTaXplKSB7XG4gICAgICAgICAgICB0aHJlYWRTaGFyZWRbbGluZGV4XSA9IHRocmVhZFNoYXJlZFtsaW5kZXhdICsgdGhyZWFkU2hhcmVkW2xpbmRleCArIGN1cnJTaXplXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaW5kZXggPT0gMCkge1xuICAgICAgICAgIHJvd1N1bVNoYXJlZCA9ICR7U30oJHtGZShcInRocmVhZFNoYXJlZFswXVwiLF8pfSk7XG4gICAgICAgIH1cbiAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBmaW5hbCB2YWx1ZSBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSByb3dcbiAgICAgICAgZm9yICh2YXIgY29sID0gbGluZGV4OyBjb2wgPCBjb2xzOyBjb2wgKz0gd2cpIHtcbiAgICAgICAgICBsZXQgdmFsdWUgPSBleHAoZ2V0VmFsdWUocm93LCBjb2wsIHJvd19zdHJpZGUpIC0gcm93TWF4U2hhcmVkKSAvIHJvd1N1bVNoYXJlZDtcbiAgICAgICAgICBzZXRWYWx1ZShyb3csIGNvbCwgcm93X3N0cmlkZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9YCxrPWUuY29tcHV0ZSh7bmFtZTpcIlNvZnRtYXhcIixzaGFkZXJDYWNoZTp7aGludDpgJHtffTske2d9YCxpbnB1dERlcGVuZGVuY2llczpbXCJ0eXBlXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm0sZGF0YVR5cGU6bC5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6aH0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZTo2LGRhdGE6eX1dfSksZ2V0U2hhZGVyU291cmNlOkF9LHtpbnB1dHM6W2xdLG91dHB1dHM6W2Q/LTE6MF19KVswXTtkJiZlLmNvbXB1dGUoUGUoayxwKSx7aW5wdXRzOltrXX0pfSxMbD0oZSx0KT0+e3RnKGUuaW5wdXRzKSxyZyhlLHQpfSxHbD1lPT5yZSh7YXhpczplLmF4aXN9KX0pO3ZhciBGbCxuZyxvZyxpZyxxbCxLbD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtvZSgpO2FlKCk7Rmw9ZT0+QXJyYXkuZnJvbShlLmdldEJpZ0ludDY0QXJyYXkoKSxOdW1iZXIpLG5nPWU9PntpZighZXx8ZS5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIlRpbGUgcmVxdWlyZXMgMiBpbnB1dHMuXCIpO2lmKGVbMF0uZGF0YVR5cGUhPT0xJiZlWzBdLmRhdGFUeXBlIT09MTAmJmVbMF0uZGF0YVR5cGUhPT02JiZlWzBdLmRhdGFUeXBlIT09MTIpdGhyb3cgbmV3IEVycm9yKFwiVGlsZSBvbmx5IHN1cHBvcnQgZmxvYXQsIGZsb2F0MTYsIGludDMyLCBhbmQgdWludDMyIGRhdGEgdHlwZXNcIik7aWYoZVsxXS5kYXRhVHlwZSE9PTcpdGhyb3cgbmV3IEVycm9yKFwiVGlsZSBgcmVwZWF0c2AgaW5wdXQgc2hvdWxkIGJlIG9mIGludDY0IGRhdGEgdHlwZVwiKTtpZihlWzFdLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJUaWxlIGByZXBlYXRzYCBpbnB1dCBzaG91bGQgYmUgMS1EXCIpO2lmKEZsKGVbMV0pLmxlbmd0aCE9PWVbMF0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiVGlsZSBgcmVwZWF0c2AgaW5wdXQgc2hvdWxkIGhhdmUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHMgYXMgcmFuayBvZiBpbnB1dCBkYXRhIHRlbnNvclwiKX0sb2c9KGUsdCk9PntsZXQgcj1bXTtmb3IobGV0IG49MDtuPGUubGVuZ3RoOysrbilyLnB1c2goZVtuXSp0W25dKTtyZXR1cm4gcn0saWc9KGUsdCk9PntsZXQgcj1lWzBdLmRpbXMsbj10Pz9GbChlWzFdKSxvPW9nKHIsbiksaT1DLnNpemUobyksYT1lWzBdLmRhdGFUeXBlLGQ9RShcImlucHV0XCIsYSxyLmxlbmd0aCksbD1NKFwib3V0cHV0XCIsYSxvLmxlbmd0aCkscD1tPT5gXG4gICAgICBjb25zdCBpbnB1dFNoYXBlID0gJHtkLmluZGljZXMoLi4ucil9O1xuICAgICAgJHttLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dF9zaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyhkLGwpfVxuICAgICAgJHttLm1haW5TdGFydCgpfVxuICAgICAgJHttLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7bC5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2QudHlwZS5pbmRpY2VzfTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgJHtyLmxlbmd0aH07IGkrKykge1xuICAgICAgICBsZXQgaW5wdXRfZGltX2kgPSAke2QuaW5kaWNlc0dldChcInVuaWZvcm1zLmlucHV0X3NoYXBlXCIsXCJpXCIpfTtcbiAgICAgICAgbGV0IGlucHV0X2RpbV92YWx1ZSA9ICR7bC5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixcImlcIil9ICAlIGlucHV0X2RpbV9pO1xuXG4gICAgICAgICR7ZC5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLFwiaVwiLFwiaW5wdXRfZGltX3ZhbHVlXCIpfVxuICAgICAgfVxuICAgICAgJHtsLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLGQuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKSl9XG4gICAgfWA7cmV0dXJue25hbWU6XCJUaWxlXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7bn1gLGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6byxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoaS82NCl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTppfSwuLi5OKGVbMF0uZGltcyxvKV19KSxnZXRTaGFkZXJTb3VyY2U6cH19LHFsPWU9PntuZyhlLmlucHV0cyksZS5jb21wdXRlKGlnKGUuaW5wdXRzKSx7aW5wdXRzOlswXX0pfX0pO3ZhciBhZyxzZyxqbCxZbD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtvZSgpO2FlKCk7YWc9KGUsdCxyLG4sbyk9PntsZXQgaT1NKFwib3V0cHV0X2RhdGFcIixvLHIubGVuZ3RoLDQpLGE9RShcImFfZGF0YVwiLHRbMV0uZGF0YVR5cGUsdFsxXS5kaW1zLmxlbmd0aCw0KSxkPUUoXCJiX2RhdGFcIix0WzJdLmRhdGFUeXBlLHRbMl0uZGltcy5sZW5ndGgsNCksbD1FKFwiY19kYXRhXCIsdFswXS5kYXRhVHlwZSx0WzBdLmRpbXMubGVuZ3RoLDQpLHAsbT0odSxoLF8pPT5gc2VsZWN0KCR7aH0sICR7dX0sICR7X30pYDtpZighbilwPWkuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsbShhLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSxkLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSxsLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSkpO2Vsc2V7bGV0IHU9KGgsXyx5PVwiXCIpPT57bGV0IGc9YGFfZGF0YVtpbmRleF9hJHtffV1bY29tcG9uZW50X2Eke199XWAseD1gYl9kYXRhW2luZGV4X2Ike199XVtjb21wb25lbnRfYiR7X31dYCwkPWBib29sKGNfZGF0YVtpbmRleF9jJHtffV0gJiAoMHhmZnUgPDwgKGNvbXBvbmVudF9jJHtffSAqIDgpKSlgO3JldHVybmBcbiAgICAgICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyR7X30gPSAke2kub2Zmc2V0VG9JbmRpY2VzKGBnbG9iYWxfaWR4ICogNHUgKyAke199dWApfTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRfYSR7X30gPSAke2EuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dF9pbmRpY2VzJHtffWAsaSl9O1xuICAgICAgICAgICAgbGV0IG9mZnNldF9iJHtffSA9ICR7ZC5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0X2luZGljZXMke199YCxpKX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0X2Mke199ID0gJHtsLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KGBvdXRwdXRfaW5kaWNlcyR7X31gLGkpfTtcbiAgICAgICAgICAgIGxldCBpbmRleF9hJHtffSA9IG9mZnNldF9hJHtffSAvIDR1O1xuICAgICAgICAgICAgbGV0IGluZGV4X2Ike199ID0gb2Zmc2V0X2Ike199IC8gNHU7XG4gICAgICAgICAgICBsZXQgaW5kZXhfYyR7X30gPSBvZmZzZXRfYyR7X30gLyA0dTtcbiAgICAgICAgICAgIGxldCBjb21wb25lbnRfYSR7X30gPSBvZmZzZXRfYSR7X30gJSA0dTtcbiAgICAgICAgICAgIGxldCBjb21wb25lbnRfYiR7X30gPSBvZmZzZXRfYiR7X30gJSA0dTtcbiAgICAgICAgICAgIGxldCBjb21wb25lbnRfYyR7X30gPSBvZmZzZXRfYyR7X30gJSA0dTtcbiAgICAgICAgICAgICR7aH1bJHtffV0gPSAke3l9KCR7bShnLHgsJCl9KTtcbiAgICAgICAgICBgfTtvPT09OT9wPWBcbiAgICAgICAgICAgIHZhciBkYXRhID0gdmVjNDx1MzI+KDApO1xuICAgICAgICAgICAgJHt1KFwiZGF0YVwiLDAsXCJ1MzJcIil9XG4gICAgICAgICAgICAke3UoXCJkYXRhXCIsMSxcInUzMlwiKX1cbiAgICAgICAgICAgICR7dShcImRhdGFcIiwyLFwidTMyXCIpfVxuICAgICAgICAgICAgJHt1KFwiZGF0YVwiLDMsXCJ1MzJcIil9XG4gICAgICAgICAgICBvdXRwdXRfZGF0YVtnbG9iYWxfaWR4XSA9IGRvdCh2ZWM0PHUzMj4oMHgxLCAweDEwMCwgMHgxMDAwMCwgMHgxMDAwMDAwKSwgdmVjNDx1MzI+KGRhdGEpKTtgOnA9YFxuICAgICAgICAgICAgJHt1KFwib3V0cHV0X2RhdGFbZ2xvYmFsX2lkeF1cIiwwKX1cbiAgICAgICAgICAgICR7dShcIm91dHB1dF9kYXRhW2dsb2JhbF9pZHhdXCIsMSl9XG4gICAgICAgICAgICAke3UoXCJvdXRwdXRfZGF0YVtnbG9iYWxfaWR4XVwiLDIpfVxuICAgICAgICAgICAgJHt1KFwib3V0cHV0X2RhdGFbZ2xvYmFsX2lkeF1cIiwzKX1cbiAgICAgICAgICBgfXJldHVybmBcbiAgICAgICAgJHtlLnJlZ2lzdGVyVW5pZm9ybShcInZlY19zaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyhsLGEsZCxpKX1cbiAgICAgICAgJHtlLm1haW5TdGFydCgpfVxuICAgICAgICAke2UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLnZlY19zaXplXCIpfVxuICAgICAgICAke3B9XG4gICAgICB9YH0sc2c9ZT0+e2xldCB0PWVbMV0uZGltcyxyPWVbMl0uZGltcyxuPWVbMF0uZGltcyxvPWVbMV0uZGF0YVR5cGUsaT0hKEMuYXJlRXF1YWwodCxyKSYmQy5hcmVFcXVhbChyLG4pKSxhPXQsZD1DLnNpemUodCk7aWYoaSl7bGV0IHA9dHQuY2FsY1NoYXBlKHR0LmNhbGNTaGFwZSh0LHIsITEpLG4sITEpO2lmKCFwKXRocm93IG5ldyBFcnJvcihcIkNhbid0IHBlcmZvcm0gd2hlcmUgb3Agb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7YT1wLGQ9Qy5zaXplKGEpfWxldCBsPU1hdGguY2VpbChkLzQpO3JldHVybntuYW1lOlwiV2hlcmVcIixzaGFkZXJDYWNoZTp7aW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiLFwicmFua1wiLFwicmFua1wiXX0sZ2V0U2hhZGVyU291cmNlOnA9PmFnKHAsZSxhLGksbyksZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczphLGRhdGFUeXBlOm99XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChkLzY0LzQpfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjEyLGRhdGE6bH0sLi4uTihuLHQscixhKV19KX19LGpsPWU9PntlLmNvbXB1dGUoc2coZS5pbnB1dHMpKX19KTt2YXIgWmwsUWw9VSgoKT0+e1widXNlIHN0cmljdFwiO1BzKCk7RnIoKTtEcygpO01zKCk7dnUoKTt6dSgpO0J1KCk7UXUoKTtvZCgpO3NkKCk7bGQoKTtoZCgpO3lkKCk7d2QoKTt4ZCgpO0lkKCk7a2QoKTt6ZCgpO0JkKCk7VWQoKTtxZCgpO1lkKCk7UWQoKTtKZCgpO3JsKCk7U28oKTtvbCgpO3ZsKCk7U2woKTtJbCgpO2tsKCk7R3IoKTtPbCgpO0JsKCk7UmwoKTtXbCgpO0hsKCk7SW8oKTtLbCgpO2R0KCk7S3IoKTtZbCgpO1psPW5ldyBNYXAoW1tcIkFic1wiLFtSc11dLFtcIkFjb3NcIixbVXNdXSxbXCJBY29zaFwiLFtOc11dLFtcIkFkZFwiLFskdV1dLFtcIkFyZ01heFwiLFtFcyxjb11dLFtcIkFyZ01pblwiLFtrcyxjb11dLFtcIkFzaW5cIixbVnNdXSxbXCJBc2luaFwiLFtXc11dLFtcIkF0YW5cIixbTHNdXSxbXCJBdGFuaFwiLFtHc11dLFtcIkF0dGVudGlvblwiLFt6c11dLFtcIkF2ZXJhZ2VQb29sXCIsW3BsLGNsXV0sW1wiQmF0Y2hOb3JtYWxpemF0aW9uXCIsW09zXV0sW1wiQmlhc0FkZFwiLFtCc11dLFtcIkJpYXNTcGxpdEdlbHVcIixbd3VdXSxbXCJDYXN0XCIsW0ZzLEhzXV0sW1wiQ2VpbFwiLFtLc11dLFtcIkNsaXBcIixbcXNdXSxbXCJDb25jYXRcIixbT3UsRHVdXSxbXCJDb252XCIsW3dvLF9vXV0sW1wiQ29udlRyYW5zcG9zZVwiLFtuZCx0ZF1dLFtcIkNvc1wiLFtqc11dLFtcIkNvc2hcIixbWXNdXSxbXCJDdW1TdW1cIixbaWQsYWRdXSxbXCJEZXB0aFRvU3BhY2VcIixbdWQsZGRdXSxbXCJEZXF1YW50aXplTGluZWFyXCIsWyRsLHhsXV0sW1wiRGl2XCIsW3h1XV0sW1wiRWluc3VtXCIsW21kLGZkXV0sW1wiRWx1XCIsW1pzLFh0XV0sW1wiRXF1YWxcIixbU3VdXSxbXCJFcmZcIixbUXNdXSxbXCJFeHBcIixbWHNdXSxbXCJFeHBhbmRcIixbYmRdXSxbXCJGYXN0R2VsdVwiLFtfZF1dLFtcIkZsb29yXCIsW0pzXV0sW1wiRnVzZWRDb252XCIsW3dvLF9vXV0sW1wiR2F0aGVyXCIsWyRkLHZkXV0sW1wiR2F0aGVyRWxlbWVudHNcIixbUGQsRWRdXSxbXCJHYXRoZXJCbG9ja1F1YW50aXplZFwiLFtDZCxBZF1dLFtcIkdhdGhlck5EXCIsW1NkLFRkXV0sW1wiR2VsdVwiLFtldV1dLFtcIkdlbW1cIixbRGQsT2RdXSxbXCJHbG9iYWxBdmVyYWdlUG9vbFwiLFtobCxmbF1dLFtcIkdsb2JhbE1heFBvb2xcIixbd2wsX2xdXSxbXCJHcmVhdGVyXCIsW0F1XV0sW1wiR3JlYXRlck9yRXF1YWxcIixbRXVdXSxbXCJHcmlkU2FtcGxlXCIsW01kLFJkXV0sW1wiR3JvdXBRdWVyeUF0dGVudGlvblwiLFtGZF1dLFtcIkhhcmRTaWdtb2lkXCIsW3V1LHN1XV0sW1wiSW5zdGFuY2VOb3JtYWxpemF0aW9uXCIsW2pkXV0sW1wiTGF5ZXJOb3JtYWxpemF0aW9uXCIsW1pkXV0sW1wiTGVha3lSZWx1XCIsW3R1LFh0XV0sW1wiTGVzc1wiLFtrdV1dLFtcIkxlc3NPckVxdWFsXCIsW1B1XV0sW1wiTG9nXCIsW2J1XV0sW1wiTWF0TXVsXCIsW1hkXV0sW1wiTWF0TXVsTkJpdHNcIixbZWwsdGxdXSxbXCJNYXhQb29sXCIsW2JsLHlsXV0sW1wiTXVsXCIsW1R1XV0sW1wiTXVsdGlIZWFkQXR0ZW50aW9uXCIsW1dkLFZkXV0sW1wiTmVnXCIsW251XV0sW1wiTm90XCIsW3J1XV0sW1wiUGFkXCIsW25sXV0sW1wiUG93XCIsW0l1XV0sW1wiUXVpY2tHZWx1XCIsW3l1LFh0XV0sW1wiUmFuZ2VcIixbVGxdXSxbXCJSZWNpcHJvY2FsXCIsW291XV0sW1wiUmVkdWNlTWluXCIsW3hzXV0sW1wiUmVkdWNlTWVhblwiLFt5c11dLFtcIlJlZHVjZU1heFwiLFskc11dLFtcIlJlZHVjZVN1bVwiLFtUc11dLFtcIlJlZHVjZVByb2RcIixbU3NdXSxbXCJSZWR1Y2VMMVwiLFtfc11dLFtcIlJlZHVjZUwyXCIsW3dzXV0sW1wiUmVkdWNlTG9nU3VtXCIsW0NzXV0sW1wiUmVkdWNlTG9nU3VtRXhwXCIsW3ZzXV0sW1wiUmVkdWNlU3VtU3F1YXJlXCIsW0lzXV0sW1wiUmVsdVwiLFtpdV1dLFtcIlJlc2l6ZVwiLFtQbCx6bF1dLFtcIlJvdGFyeUVtYmVkZGluZ1wiLFtEbF1dLFtcIlNjYXR0ZXJORFwiLFtBbCxDbF1dLFtcIlNpZ21vaWRcIixbYXVdXSxbXCJTaW5cIixbZHVdXSxbXCJTaW5oXCIsW2x1XV0sW1wiU2xpY2VcIixbTmwsVmxdXSxbXCJTa2lwTGF5ZXJOb3JtYWxpemF0aW9uXCIsW01sXV0sW1wiU3BsaXRcIixbTGQsR2RdXSxbXCJTcXJ0XCIsW2N1XV0sW1wiU29mdG1heFwiLFtMbCxHbF1dLFtcIlN1YlwiLFtDdV1dLFtcIlRhblwiLFtwdV1dLFtcIlRhbmhcIixbZnVdXSxbXCJUaHJlc2hvbGRlZFJlbHVcIixbZ3UsWHRdXSxbXCJUaWxlXCIsW3FsXV0sW1wiVHJhbnNwb3NlXCIsW2lzLGFzXV0sW1wiV2hlcmVcIixbamxdXV0pfSk7dmFyIG5uLFhsPVUoKCk9PntcInVzZSBzdHJpY3RcIjtXZSgpO2V0KCk7YWUoKTtubj1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLmJhY2tlbmQ9dDt0aGlzLnJlcG89bmV3IE1hcCx0aGlzLmF0dHJpYnV0ZXNCb3VuZD0hMX1nZXRBcnRpZmFjdCh0KXtyZXR1cm4gdGhpcy5yZXBvLmdldCh0KX1zZXRBcnRpZmFjdCh0LHIpe3RoaXMucmVwby5zZXQodCxyKX1ydW4odCxyLG4sbyxpKXtVZSh0LnByb2dyYW1JbmZvLm5hbWUpO2xldCBhPXRoaXMuYmFja2VuZC5kZXZpY2UsZD10aGlzLmJhY2tlbmQuZ2V0Q29tcHV0ZVBhc3NFbmNvZGVyKCk7dGhpcy5iYWNrZW5kLndyaXRlVGltZXN0YW1wKHRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIqMik7bGV0IGw9W107Zm9yKGxldCBtIG9mIHIpbC5wdXNoKHtiaW5kaW5nOmwubGVuZ3RoLHJlc291cmNlOntidWZmZXI6bS5idWZmZXJ9fSk7Zm9yKGxldCBtIG9mIG4pbC5wdXNoKHtiaW5kaW5nOmwubGVuZ3RoLHJlc291cmNlOntidWZmZXI6bS5idWZmZXJ9fSk7aSYmbC5wdXNoKHtiaW5kaW5nOmwubGVuZ3RoLHJlc291cmNlOml9KTtsZXQgcD1hLmNyZWF0ZUJpbmRHcm91cCh7bGF5b3V0OnQuY29tcHV0ZVBpcGVsaW5lLmdldEJpbmRHcm91cExheW91dCgwKSxlbnRyaWVzOmwsbGFiZWw6dC5wcm9ncmFtSW5mby5uYW1lfSk7aWYodGhpcy5iYWNrZW5kLnNlc3Npb25TdGF0dXM9PT1cImNhcHR1cmluZ1wiKXtsZXQgbT17a2VybmVsSWQ6dGhpcy5iYWNrZW5kLmN1cnJlbnRLZXJuZWxJZCxjb21wdXRlUGlwZWxpbmU6dC5jb21wdXRlUGlwZWxpbmUsYmluZEdyb3VwOnAsZGlzcGF0Y2hHcm91cDpvfTt0aGlzLmJhY2tlbmQuY2FwdHVyZWRDb21tYW5kTGlzdC5nZXQodGhpcy5iYWNrZW5kLmN1cnJlbnRTZXNzaW9uSWQpLnB1c2gobSl9ZC5zZXRQaXBlbGluZSh0LmNvbXB1dGVQaXBlbGluZSksZC5zZXRCaW5kR3JvdXAoMCxwKSxkLmRpc3BhdGNoV29ya2dyb3VwcyguLi5vKSx0aGlzLmJhY2tlbmQud3JpdGVUaW1lc3RhbXAodGhpcy5iYWNrZW5kLnBlbmRpbmdEaXNwYXRjaE51bWJlcioyKzEpLHRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIrKywodGhpcy5iYWNrZW5kLnBlbmRpbmdEaXNwYXRjaE51bWJlcj49dGhpcy5iYWNrZW5kLm1heERpc3BhdGNoTnVtYmVyfHx0aGlzLmJhY2tlbmQucXVlcnlUeXBlPT09XCJhdC1wYXNzZXNcIikmJnRoaXMuYmFja2VuZC5lbmRDb21wdXRlUGFzcygpLHRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXI+PXRoaXMuYmFja2VuZC5tYXhEaXNwYXRjaE51bWJlciYmdGhpcy5iYWNrZW5kLmZsdXNoKCksRGUodC5wcm9ncmFtSW5mby5uYW1lKX1kaXNwb3NlKCl7fWJ1aWxkKHQscil7VWUodC5uYW1lKTtsZXQgbj10aGlzLmJhY2tlbmQuZGV2aWNlLG89W107W3tmZWF0dXJlOlwic2hhZGVyLWYxNlwiLGV4dGVuc2lvbjpcImYxNlwifSx7ZmVhdHVyZTpcInN1Ymdyb3Vwc1wiLGV4dGVuc2lvbjpcInN1Ymdyb3Vwc1wifSx7ZmVhdHVyZTpcInN1Ymdyb3Vwcy1mMTZcIixleHRlbnNpb246XCJzdWJncm91cHNfZjE2XCJ9XS5mb3JFYWNoKHU9PntuLmZlYXR1cmVzLmhhcyh1LmZlYXR1cmUpJiZvLnB1c2goYGVuYWJsZSAke3UuZXh0ZW5zaW9ufTtgKX0pO2xldCBhPW5zKHIsdGhpcy5iYWNrZW5kLmRldmljZS5saW1pdHMpLGQ9dC5nZXRTaGFkZXJTb3VyY2UoYSksbD1gJHtvLmpvaW4oYFxuYCl9XG4ke2EuYWRkaXRpb25hbEltcGxlbWVudGF0aW9uc31cbiR7ZH1gLHA9bi5jcmVhdGVTaGFkZXJNb2R1bGUoe2NvZGU6bCxsYWJlbDp0Lm5hbWV9KTt1ZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdICR7dC5uYW1lfSBzaGFkZXIgY29kZTogJHtsfWApO2xldCBtPW4uY3JlYXRlQ29tcHV0ZVBpcGVsaW5lKHtjb21wdXRlOnttb2R1bGU6cCxlbnRyeVBvaW50OlwibWFpblwifSxsYXlvdXQ6XCJhdXRvXCIsbGFiZWw6dC5uYW1lfSk7cmV0dXJuIERlKHQubmFtZSkse3Byb2dyYW1JbmZvOnQsY29tcHV0ZVBpcGVsaW5lOm0sdW5pZm9ybVZhcmlhYmxlc0luZm86YS52YXJpYWJsZXNJbmZvfX1ub3JtYWxpemVEaXNwYXRjaEdyb3VwU2l6ZSh0KXtsZXQgcj10eXBlb2YgdD09XCJudW1iZXJcIj90OnQueCxuPXR5cGVvZiB0PT1cIm51bWJlclwiPzE6dC55fHwxLG89dHlwZW9mIHQ9PVwibnVtYmVyXCI/MTp0Lnp8fDEsaT10aGlzLmJhY2tlbmQuZGV2aWNlLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3Vwc1BlckRpbWVuc2lvbjtpZihyPD1pJiZuPD1pJiZvPD1pKXJldHVybltyLG4sb107bGV0IGE9cipuKm8sZD1NYXRoLmNlaWwoTWF0aC5zcXJ0KGEpKTtpZihkPmkpe2lmKGQ9TWF0aC5jZWlsKE1hdGguY2JydChhKSksZD5pKXRocm93IG5ldyBFcnJvcihcIlRvdGFsIGRpc3BhdGNoIHNpemUgZXhjZWVkcyBXZWJHUFUgbWF4aW11bS5cIik7cmV0dXJuW2QsZCxkXX1lbHNlIHJldHVybltkLGQsMV19fX0pO3ZhciB1ZyxkZyxDbyxBbyxvbixKbD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7V2UoKTt0ZSgpO2V0KCk7Sm4oKTtKYSgpO1FsKCk7WGwoKTt1Zz0oZSx0KT0+e2lmKHQubGVuZ3RoIT09ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBpbnB1dERlcGVuZGVuY2llcyBsZW5ndGggJHt0Lmxlbmd0aH0gaXMgbm90IGVxdWFsIHRvIGlucHV0VGVuc29ycyBsZW5ndGggJHtlLmxlbmd0aH0uYCk7bGV0IHI9W107Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDsrK24pe2xldCBvPWVbbl0uZGF0YVR5cGU7c3dpdGNoKHRbbl0pe2Nhc2VcIm5vbmVcIjp7ci5wdXNoKFwiXCIpO2JyZWFrfWNhc2VcInR5cGVcIjp7ci5wdXNoKGAke299YCk7YnJlYWt9Y2FzZVwicmFua1wiOntsZXQgaT1lW25dLmRpbXMubGVuZ3RoO3IucHVzaChgJHtvfTske2l9YCk7YnJlYWt9Y2FzZVwiZGltc1wiOntsZXQgaT1lW25dLmRpbXMuam9pbihcIixcIik7ci5wdXNoKGAke299OyR7aX1gKTticmVha31kZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgaW5wdXQgZGVwZW5kZW5jeTogJHt0W25dfWApfX1yZXR1cm4gci5qb2luKFwifFwiKX0sZGc9KGUsdCxyKT0+e2xldCBuPWUubmFtZTtyZXR1cm4gZS5zaGFkZXJDYWNoZT8uaGludCYmKG4rPVwiW1wiK2Uuc2hhZGVyQ2FjaGUuaGludCtcIl1cIiksbis9XCI6XCIrcitgOiR7dWcodCxlLnNoYWRlckNhY2hlPy5pbnB1dERlcGVuZGVuY2llcz8/bmV3IEFycmF5KHQubGVuZ3RoKS5maWxsKFwiZGltc1wiKSl9YCxufSxDbz1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0JiYodGhpcy5hcmNoaXRlY3R1cmU9dC5hcmNoaXRlY3R1cmUsdGhpcy52ZW5kb3I9dC52ZW5kb3IpfWlzQXJjaGl0ZWN0dXJlKHQpe3JldHVybiB0aGlzLmFyY2hpdGVjdHVyZT09PXR9aXNWZW5kb3IodCl7cmV0dXJuIHRoaXMudmVuZG9yPT09dH19LEFvPWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMuc3ViZ3JvdXBzU3VwcG9ydGVkPXQuZmVhdHVyZXMuaGFzKFwic3ViZ3JvdXBzXCIpLHRoaXMuc3ViZ3JvdXBzRjE2U3VwcG9ydGVkPXQuZmVhdHVyZXMuaGFzKFwic3ViZ3JvdXBzXCIpO2xldCByPXQubGltaXRzOyF0aGlzLnN1Ymdyb3Vwc1N1cHBvcnRlZHx8IXIubWluU3ViZ3JvdXBTaXplfHwhci5tYXhTdWJncm91cFNpemU/dGhpcy5zdWJncm91cFNpemVSYW5nZT12b2lkIDA6dGhpcy5zdWJncm91cFNpemVSYW5nZT1bci5taW5TdWJncm91cFNpemUsci5tYXhTdWJncm91cFNpemVdfX0sb249Y2xhc3N7Y29uc3RydWN0b3IoKXt0aGlzLmN1cnJlbnRTZXNzaW9uSWQ9bnVsbDt0aGlzLmN1cnJlbnRLZXJuZWxJZD1udWxsO3RoaXMuY29tbWFuZEVuY29kZXI9bnVsbDt0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlcj1udWxsO3RoaXMubWF4RGlzcGF0Y2hOdW1iZXI9MTY7dGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXI9MDt0aGlzLnBlbmRpbmdLZXJuZWxzPVtdO3RoaXMucGVuZGluZ1F1ZXJpZXM9bmV3IE1hcDt0aGlzLnNlc3Npb25TdGF0dXM9XCJkZWZhdWx0XCI7dGhpcy5jYXB0dXJlZENvbW1hbmRMaXN0PW5ldyBNYXA7dGhpcy5jYXB0dXJlZFBlbmRpbmdLZXJuZWxzPW5ldyBNYXA7dGhpcy5zZXNzaW9uRXh0ZXJuYWxEYXRhTWFwcGluZz1uZXcgTWFwfWdldCBjdXJyZW50S2VybmVsQ3VzdG9tRGF0YSgpe2lmKHRoaXMuY3VycmVudEtlcm5lbElkPT09bnVsbCl0aHJvdyBuZXcgRXJyb3IoXCJjdXJyZW50S2VybmVsQ3VzdG9tRGF0YSgpOiBjdXJyZW50S2VybmVsSWQgaXMgbnVsbC4gKHNob3VsZCBub3QgaGFwcGVuKVwiKTtsZXQgdD10aGlzLmtlcm5lbEN1c3RvbURhdGEuZ2V0KHRoaXMuY3VycmVudEtlcm5lbElkKTtyZXR1cm4gdHx8KHQ9e30sdGhpcy5rZXJuZWxDdXN0b21EYXRhLnNldCh0aGlzLmN1cnJlbnRLZXJuZWxJZCx0KSksdH1hc3luYyBpbml0aWFsaXplKHQscil7dGhpcy5lbnY9dDtsZXQgbj1bXSxvPXtyZXF1aXJlZExpbWl0czp7bWF4Q29tcHV0ZVdvcmtncm91cFN0b3JhZ2VTaXplOnIubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTdG9yYWdlU2l6ZSxtYXhDb21wdXRlV29ya2dyb3Vwc1BlckRpbWVuc2lvbjpyLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3Vwc1BlckRpbWVuc2lvbixtYXhTdG9yYWdlQnVmZmVyQmluZGluZ1NpemU6ci5saW1pdHMubWF4U3RvcmFnZUJ1ZmZlckJpbmRpbmdTaXplLG1heEJ1ZmZlclNpemU6ci5saW1pdHMubWF4QnVmZmVyU2l6ZSxtYXhDb21wdXRlSW52b2NhdGlvbnNQZXJXb3JrZ3JvdXA6ci5saW1pdHMubWF4Q29tcHV0ZUludm9jYXRpb25zUGVyV29ya2dyb3VwLG1heENvbXB1dGVXb3JrZ3JvdXBTaXplWDpyLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVgsbWF4Q29tcHV0ZVdvcmtncm91cFNpemVZOnIubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWSxtYXhDb21wdXRlV29ya2dyb3VwU2l6ZVo6ci5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVafSxyZXF1aXJlZEZlYXR1cmVzOm59LGk9YT0+ci5mZWF0dXJlcy5oYXMoYSkmJm4ucHVzaChhKSYmITA7aShcImNocm9taXVtLWV4cGVyaW1lbnRhbC10aW1lc3RhbXAtcXVlcnktaW5zaWRlLXBhc3Nlc1wiKXx8aShcInRpbWVzdGFtcC1xdWVyeVwiKSxpKFwic2hhZGVyLWYxNlwiKSxpKFwic3ViZ3JvdXBzXCIpJiZpKFwic3ViZ3JvdXBzLWYxNlwiKSx0aGlzLmRldmljZT1hd2FpdCByLnJlcXVlc3REZXZpY2UobyksdGhpcy5kZXZpY2VJbmZvPW5ldyBBbyh0aGlzLmRldmljZSksdGhpcy5hZGFwdGVySW5mbz1uZXcgQ28oci5pbmZvfHxhd2FpdCByLnJlcXVlc3RBZGFwdGVySW5mbygpKSx0aGlzLmdwdURhdGFNYW5hZ2VyPVhhKHRoaXMpLHRoaXMucHJvZ3JhbU1hbmFnZXI9bmV3IG5uKHRoaXMpLHRoaXMua2VybmVscz1uZXcgTWFwLHRoaXMua2VybmVsUGVyc2lzdGVudERhdGE9bmV3IE1hcCx0aGlzLmtlcm5lbEN1c3RvbURhdGE9bmV3IE1hcCxScih0LmxvZ0xldmVsLCEhdC5kZWJ1ZyksdGhpcy5kZXZpY2Uub251bmNhcHR1cmVkZXJyb3I9YT0+e2EuZXJyb3IgaW5zdGFuY2VvZiBHUFVWYWxpZGF0aW9uRXJyb3ImJmNvbnNvbGUuZXJyb3IoYEFuIHVuY2F1Z2h0IFdlYkdQVSB2YWxpZGF0aW9uIGVycm9yIHdhcyByYWlzZWQ6ICR7YS5lcnJvci5tZXNzYWdlfWApfSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcy5lbnYud2ViZ3B1LFwiZGV2aWNlXCIse3ZhbHVlOnRoaXMuZGV2aWNlLHdyaXRhYmxlOiExLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiExfSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuZW52LndlYmdwdSxcImFkYXB0ZXJcIix7dmFsdWU6cix3cml0YWJsZTohMSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMX0pLHRoaXMuc2V0UXVlcnlUeXBlKCl9ZGlzcG9zZSgpe3R5cGVvZiB0aGlzLnF1ZXJ5U2V0PFwidVwiJiZ0aGlzLnF1ZXJ5U2V0LmRlc3Ryb3koKSx0aGlzLmdwdURhdGFNYW5hZ2VyLmRpc3Bvc2UoKX1nZXRDb21tYW5kRW5jb2Rlcigpe3JldHVybiB0aGlzLmNvbW1hbmRFbmNvZGVyfHwodGhpcy5jb21tYW5kRW5jb2Rlcj10aGlzLmRldmljZS5jcmVhdGVDb21tYW5kRW5jb2RlcigpKSx0aGlzLmNvbW1hbmRFbmNvZGVyfWdldENvbXB1dGVQYXNzRW5jb2Rlcigpe2lmKCF0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlcil7bGV0IHQ9dGhpcy5nZXRDb21tYW5kRW5jb2RlcigpLHI9e307dGhpcy5xdWVyeVR5cGU9PT1cImF0LXBhc3Nlc1wiJiYoci50aW1lc3RhbXBXcml0ZXM9e3F1ZXJ5U2V0OnRoaXMucXVlcnlTZXQsYmVnaW5uaW5nT2ZQYXNzV3JpdGVJbmRleDp0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcioyLGVuZE9mUGFzc1dyaXRlSW5kZXg6dGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIqMisxfSksdGhpcy5jb21wdXRlUGFzc0VuY29kZXI9dC5iZWdpbkNvbXB1dGVQYXNzKHIpfXJldHVybiB0aGlzLmNvbXB1dGVQYXNzRW5jb2Rlcn1lbmRDb21wdXRlUGFzcygpe3RoaXMuY29tcHV0ZVBhc3NFbmNvZGVyJiYodGhpcy5jb21wdXRlUGFzc0VuY29kZXIuZW5kKCksdGhpcy5jb21wdXRlUGFzc0VuY29kZXI9bnVsbCl9Zmx1c2goKXtpZighdGhpcy5jb21tYW5kRW5jb2RlcilyZXR1cm47VWUoKSx0aGlzLmVuZENvbXB1dGVQYXNzKCk7bGV0IHQ7dGhpcy5xdWVyeVR5cGUhPT1cIm5vbmVcIiYmKHRoaXMuY29tbWFuZEVuY29kZXIucmVzb2x2ZVF1ZXJ5U2V0KHRoaXMucXVlcnlTZXQsMCx0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcioyLHRoaXMucXVlcnlSZXNvbHZlQnVmZmVyLDApLHQ9dGhpcy5kZXZpY2UuY3JlYXRlQnVmZmVyKHtzaXplOnRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKjIqOCx1c2FnZTpHUFVCdWZmZXJVc2FnZS5NQVBfUkVBRHxHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVH0pLHRoaXMucGVuZGluZ1F1ZXJpZXMuc2V0KHQsdGhpcy5wZW5kaW5nS2VybmVscyksdGhpcy5wZW5kaW5nS2VybmVscz1bXSx0aGlzLmNvbW1hbmRFbmNvZGVyLmNvcHlCdWZmZXJUb0J1ZmZlcih0aGlzLnF1ZXJ5UmVzb2x2ZUJ1ZmZlciwwLHQsMCx0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcioyKjgpKSx0aGlzLmRldmljZS5xdWV1ZS5zdWJtaXQoW3RoaXMuY29tbWFuZEVuY29kZXIuZmluaXNoKCldKSx0aGlzLmdwdURhdGFNYW5hZ2VyLnJlZnJlc2hQZW5kaW5nQnVmZmVycygpLHRoaXMuY29tbWFuZEVuY29kZXI9bnVsbCx0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcj0wLHRoaXMucXVlcnlUeXBlIT09XCJub25lXCImJnQubWFwQXN5bmMoR1BVTWFwTW9kZS5SRUFEKS50aGVuKCgpPT57bGV0IHI9bmV3IEJpZ1VpbnQ2NEFycmF5KHQuZ2V0TWFwcGVkUmFuZ2UoKSksbj10aGlzLnBlbmRpbmdRdWVyaWVzLmdldCh0KTtmb3IobGV0IG89MDtvPHIubGVuZ3RoLzI7bysrKXtsZXQgaT1uW29dLGE9aS5rZXJuZWxJZCxkPXRoaXMua2VybmVscy5nZXQoYSksbD1kLmtlcm5lbFR5cGUscD1kLmtlcm5lbE5hbWUsbT1pLnByb2dyYW1OYW1lLHU9aS5pbnB1dFRlbnNvclZpZXdzLGg9aS5vdXRwdXRUZW5zb3JWaWV3cyxfPXJbbyoyXSx5PXJbbyoyKzFdO3R5cGVvZiB0aGlzLnF1ZXJ5VGltZUJhc2U+XCJ1XCImJih0aGlzLnF1ZXJ5VGltZUJhc2U9Xyk7bGV0IGc9TnVtYmVyKF8tdGhpcy5xdWVyeVRpbWVCYXNlKSx4PU51bWJlcih5LXRoaXMucXVlcnlUaW1lQmFzZSk7aWYoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGcpfHwhTnVtYmVyLmlzU2FmZUludGVnZXIoeCkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJpbmNvcnJlY3QgdGltZXN0YW1wIHJhbmdlXCIpO2lmKHRoaXMuZW52LndlYmdwdS5wcm9maWxpbmc/Lm9uZGF0YSl0aGlzLmVudi53ZWJncHUucHJvZmlsaW5nLm9uZGF0YSh7dmVyc2lvbjoxLGlucHV0c01ldGFkYXRhOnUubWFwKCQ9Pih7ZGltczokLmRpbXMsZGF0YVR5cGU6YnQoJC5kYXRhVHlwZSl9KSksb3V0cHV0c01ldGFkYXRhOmgubWFwKCQ9Pih7ZGltczokLmRpbXMsZGF0YVR5cGU6YnQoJC5kYXRhVHlwZSl9KSksa2VybmVsSWQ6YSxrZXJuZWxUeXBlOmwsa2VybmVsTmFtZTpwLHByb2dyYW1OYW1lOm0sc3RhcnRUaW1lOmcsZW5kVGltZTp4fSk7ZWxzZXtsZXQgJD1cIlwiO3UuZm9yRWFjaCgoUyxUKT0+eyQrPWBpbnB1dFske1R9XTogWyR7Uy5kaW1zfV0gfCAke2J0KFMuZGF0YVR5cGUpfSwgYH0pO2xldCB2PVwiXCI7aC5mb3JFYWNoKChTLFQpPT57dis9YG91dHB1dFske1R9XTogWyR7Uy5kaW1zfV0gfCAke2J0KFMuZGF0YVR5cGUpfSwgYH0pLGNvbnNvbGUubG9nKGBbcHJvZmlsaW5nXSBrZXJuZWwgXCIke2F9fCR7bH18JHtwfXwke219XCIgJHskfSR7dn1leGVjdXRpb24gdGltZTogJHt4LWd9IG5zYCl9d3IoXCJHUFVcIixgJHttfTo6JHtffTo6JHt5fWApfXQudW5tYXAoKSx0aGlzLnBlbmRpbmdRdWVyaWVzLmRlbGV0ZSh0KX0pLERlKCl9cnVuKHQscixuLG8saSxhKXtVZSh0Lm5hbWUpO2xldCBkPVtdO2ZvcihsZXQgUz0wO1M8ci5sZW5ndGg7KytTKXtsZXQgVD1yW1NdLmRhdGE7aWYoVD09PTApY29udGludWU7bGV0IEE9dGhpcy5ncHVEYXRhTWFuYWdlci5nZXQoVCk7aWYoIUEpdGhyb3cgbmV3IEVycm9yKGBubyBHUFUgZGF0YSBmb3IgaW5wdXQ6ICR7VH1gKTtkLnB1c2goQSl9bGV0e291dHB1dHM6bCxkaXNwYXRjaEdyb3VwOnAscHJvZ3JhbVVuaWZvcm1zOm19PXQuZ2V0UnVuRGF0YShyKSx1PW4ubGVuZ3RoPT09MD9sLm1hcCgoUyxUKT0+VCk6bjtpZih1Lmxlbmd0aCE9PWwubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgT3V0cHV0IHNpemUgJHt1Lmxlbmd0aH0gbXVzdCBiZSBlcXVhbCB0byAke2wubGVuZ3RofS5gKTtsZXQgaD1bXSxfPVtdO2ZvcihsZXQgUz0wO1M8bC5sZW5ndGg7KytTKXtpZighTnVtYmVyLmlzSW50ZWdlcih1W1NdKXx8dVtTXTwtM3x8dVtTXT49YSl0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgb3V0cHV0IGluZGV4OiAke3VbU119YCk7aWYodVtTXT09PS0zKWNvbnRpbnVlO2xldCBUPXVbU109PT0tMSxBPXVbU109PT0tMixrPVR8fEE/aShsW1NdLmRhdGFUeXBlLGxbU10uZGltcyk6byh1W1NdLGxbU10uZGF0YVR5cGUsbFtTXS5kaW1zKTtpZihoLnB1c2goayksay5kYXRhPT09MCljb250aW51ZTtsZXQgUD10aGlzLmdwdURhdGFNYW5hZ2VyLmdldChrLmRhdGEpO2lmKCFQKXRocm93IG5ldyBFcnJvcihgbm8gR1BVIGRhdGEgZm9yIG91dHB1dDogJHtrLmRhdGF9YCk7aWYoVCYmdGhpcy50ZW1wb3JhcnlEYXRhLnB1c2goUCksQSl7bGV0IEQ9dGhpcy5rZXJuZWxQZXJzaXN0ZW50RGF0YS5nZXQodGhpcy5jdXJyZW50S2VybmVsSWQpO0R8fChEPVtdLHRoaXMua2VybmVsUGVyc2lzdGVudERhdGEuc2V0KHRoaXMuY3VycmVudEtlcm5lbElkLEQpKSxELnB1c2goUCl9Xy5wdXNoKFApfWlmKGQubGVuZ3RoIT09ci5sZW5ndGh8fF8ubGVuZ3RoIT09aC5sZW5ndGgpe2lmKF8ubGVuZ3RoPT09MClyZXR1cm4gRGUodC5uYW1lKSxoO3Rocm93IG5ldyBFcnJvcihgUHJvZ3JhbSAke3QubmFtZX0gaGFzIHplcm8tc2l6ZWQgdGVuc29yKHMpIGluIGlucHV0cyBvciBvdXRwdXRzLiBUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgbm93LmApfWxldCB5O2lmKG0pe2xldCBTPTAsVD1bXTttLmZvckVhY2goRD0+e2xldCBSPXR5cGVvZiBELmRhdGE9PVwibnVtYmVyXCI/W0QuZGF0YV06RC5kYXRhO2lmKFIubGVuZ3RoPT09MClyZXR1cm47bGV0IEc9RC50eXBlPT09MTA/Mjo0LEssajtELnR5cGU9PT0xMD8oaj1SLmxlbmd0aD40PzE2OlIubGVuZ3RoPjI/ODpSLmxlbmd0aCpHLEs9Ui5sZW5ndGg+ND8xNjpHKlIubGVuZ3RoKTooaj1SLmxlbmd0aDw9Mj9SLmxlbmd0aCpHOjE2LEs9MTYpLFM9TWF0aC5jZWlsKFMvaikqaixULnB1c2goUyk7bGV0IFY9RC50eXBlPT09MTA/ODo0O1MrPVIubGVuZ3RoPjQ/TWF0aC5jZWlsKFIubGVuZ3RoL1YpKks6Ui5sZW5ndGgqR30pO2xldCBBPTE2O1M9TWF0aC5jZWlsKFMvQSkqQTtsZXQgaz1uZXcgQXJyYXlCdWZmZXIoUyk7bS5mb3JFYWNoKChELFIpPT57bGV0IEc9VFtSXSxLPXR5cGVvZiBELmRhdGE9PVwibnVtYmVyXCI/W0QuZGF0YV06RC5kYXRhO2lmKEQudHlwZT09PTYpbmV3IEludDMyQXJyYXkoayxHLEsubGVuZ3RoKS5zZXQoSyk7ZWxzZSBpZihELnR5cGU9PT0xMiluZXcgVWludDMyQXJyYXkoayxHLEsubGVuZ3RoKS5zZXQoSyk7ZWxzZSBpZihELnR5cGU9PT0xMCluZXcgVWludDE2QXJyYXkoayxHLEsubGVuZ3RoKS5zZXQoSyk7ZWxzZSBpZihELnR5cGU9PT0xKW5ldyBGbG9hdDMyQXJyYXkoayxHLEsubGVuZ3RoKS5zZXQoSyk7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHVuaWZvcm0gdHlwZTogJHtidChELnR5cGUpfWApfSk7bGV0IFA9dGhpcy5ncHVEYXRhTWFuYWdlci5jcmVhdGUoUyxHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVHxHUFVCdWZmZXJVc2FnZS5VTklGT1JNKTt0aGlzLmRldmljZS5xdWV1ZS53cml0ZUJ1ZmZlcihQLmJ1ZmZlciwwLGssMCxTKSx0aGlzLmdwdURhdGFNYW5hZ2VyLnJlbGVhc2UoUC5pZCkseT17b2Zmc2V0OjAsc2l6ZTpTLGJ1ZmZlcjpQLmJ1ZmZlcn19bGV0IGc9dGhpcy5wcm9ncmFtTWFuYWdlci5ub3JtYWxpemVEaXNwYXRjaEdyb3VwU2l6ZShwKSx4PWdbMV09PT0xJiZnWzJdPT09MSwkPWRnKHQscix4KSx2PXRoaXMucHJvZ3JhbU1hbmFnZXIuZ2V0QXJ0aWZhY3QoJCk7aWYodnx8KHY9dGhpcy5wcm9ncmFtTWFuYWdlci5idWlsZCh0LGcpLHRoaXMucHJvZ3JhbU1hbmFnZXIuc2V0QXJ0aWZhY3QoJCx2KSx1ZShcImluZm9cIiwoKT0+YFthcnRpZmFjdF0ga2V5OiAkeyR9LCBwcm9ncmFtTmFtZTogJHt0Lm5hbWV9YCkpLG0mJnYudW5pZm9ybVZhcmlhYmxlc0luZm8pe2lmKG0ubGVuZ3RoIT09di51bmlmb3JtVmFyaWFibGVzSW5mby5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBVbmlmb3JtIHZhcmlhYmxlcyBjb3VudCBtaXNtYXRjaDogZXhwZWN0ICR7di51bmlmb3JtVmFyaWFibGVzSW5mby5sZW5ndGh9LCBnb3QgJHttLmxlbmd0aH0gaW4gcHJvZ3JhbSBcIiR7di5wcm9ncmFtSW5mby5uYW1lfVwiLmApO2ZvcihsZXQgUz0wO1M8bS5sZW5ndGg7UysrKXtsZXQgVD1tW1NdLEE9VC50eXBlLGs9dHlwZW9mIFQuZGF0YT09XCJudW1iZXJcIj8xOlQuZGF0YS5sZW5ndGgsW1AsRF09di51bmlmb3JtVmFyaWFibGVzSW5mb1tTXTtpZihBIT09UHx8ayE9PUQpdGhyb3cgbmV3IEVycm9yKGBVbmlmb3JtIHZhcmlhYmxlICR7U30gbWlzbWF0Y2g6IGV4cGVjdCB0eXBlICR7UH0gd2l0aCBzaXplICR7RH0sIGdvdCB0eXBlICR7QX0gd2l0aCBzaXplICR7a30gaW4gcHJvZ3JhbSBcIiR7di5wcm9ncmFtSW5mby5uYW1lfVwiLmApfX1pZih1ZShcImluZm9cIiwoKT0+YFtQcm9ncmFtTWFuYWdlcl0gcnVuIFwiJHt0Lm5hbWV9XCIgKGtleT0keyR9KSB3aXRoICR7Z1swXX14JHtnWzFdfXgke2dbMl19YCksdGhpcy5xdWVyeVR5cGUhPT1cIm5vbmVcInx8dGhpcy5zZXNzaW9uU3RhdHVzPT09XCJjYXB0dXJpbmdcIil7bGV0IFM9e2tlcm5lbElkOnRoaXMuY3VycmVudEtlcm5lbElkLHByb2dyYW1OYW1lOnYucHJvZ3JhbUluZm8ubmFtZSxpbnB1dFRlbnNvclZpZXdzOnIsb3V0cHV0VGVuc29yVmlld3M6aH07dGhpcy5wZW5kaW5nS2VybmVscy5wdXNoKFMpLHRoaXMuc2Vzc2lvblN0YXR1cz09PVwiY2FwdHVyaW5nXCImJnRoaXMuY2FwdHVyZWRQZW5kaW5nS2VybmVscy5nZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkKS5wdXNoKFMpfXJldHVybiB0aGlzLnByb2dyYW1NYW5hZ2VyLnJ1bih2LGQsXyxnLHkpLERlKHQubmFtZSksaH11cGxvYWQodCxyKXt0aGlzLmdwdURhdGFNYW5hZ2VyLnVwbG9hZCh0LHIpfW1lbWNweSh0LHIpe3RoaXMuZ3B1RGF0YU1hbmFnZXIubWVtY3B5KHQscil9YXN5bmMgZG93bmxvYWQodCxyKXthd2FpdCB0aGlzLmdwdURhdGFNYW5hZ2VyLmRvd25sb2FkKHQscil9YWxsb2ModCl7cmV0dXJuIHRoaXMuZ3B1RGF0YU1hbmFnZXIuY3JlYXRlKHQpLmlkfWZyZWUodCl7cmV0dXJuIHRoaXMuZ3B1RGF0YU1hbmFnZXIucmVsZWFzZSh0KX1jcmVhdGVLZXJuZWwodCxyLG4sbyl7bGV0IGk9WmwuZ2V0KHQpO2lmKCFpKXRocm93IG5ldyBFcnJvcihga2VybmVsIG5vdCBpbXBsZW1lbnRlZDogJHt0fWApO2xldCBhPXtrZXJuZWxUeXBlOnQsa2VybmVsTmFtZTpvLGtlcm5lbEVudHJ5OmlbMF0sYXR0cmlidXRlczpbaVsxXSxuXX07dGhpcy5rZXJuZWxzLnNldChyLGEpfXJlbGVhc2VLZXJuZWwodCl7bGV0IHI9dGhpcy5rZXJuZWxQZXJzaXN0ZW50RGF0YS5nZXQodCk7aWYocil7Zm9yKGxldCBuIG9mIHIpdGhpcy5ncHVEYXRhTWFuYWdlci5yZWxlYXNlKG4uaWQpO3RoaXMua2VybmVsUGVyc2lzdGVudERhdGEuZGVsZXRlKHQpfXRoaXMua2VybmVsQ3VzdG9tRGF0YS5kZWxldGUodCksdGhpcy5rZXJuZWxzLmRlbGV0ZSh0KX1jb21wdXRlS2VybmVsKHQscixuKXtsZXQgbz10aGlzLmtlcm5lbHMuZ2V0KHQpO2lmKCFvKXRocm93IG5ldyBFcnJvcihga2VybmVsIG5vdCBjcmVhdGVkOiAke3R9YCk7bGV0IGk9by5rZXJuZWxUeXBlLGE9by5rZXJuZWxOYW1lLGQ9by5rZXJuZWxFbnRyeSxsPW8uYXR0cmlidXRlcztpZih0aGlzLmN1cnJlbnRLZXJuZWxJZCE9PW51bGwpdGhyb3cgbmV3IEVycm9yKGBrZXJuZWwgXCJbJHtpfV0gJHthfVwiIGlzIG5vdCBhbGxvd2VkIHRvIGJlIGNhbGxlZCByZWN1cnNpdmVseWApO3RoaXMuY3VycmVudEtlcm5lbElkPXQsbFswXSYmKGxbMV09bFswXShsWzFdKSxsWzBdPXZvaWQgMCksdWUoXCJpbmZvXCIsKCk9PmBbV2ViR1BVXSBTdGFydCB0byBydW4ga2VybmVsIFwiWyR7aX1dICR7YX1cIi4uLmApO2xldCBwPXRoaXMuZW52LmRlYnVnO3RoaXMudGVtcG9yYXJ5RGF0YT1bXTt0cnl7cmV0dXJuIHAmJnRoaXMuZGV2aWNlLnB1c2hFcnJvclNjb3BlKFwidmFsaWRhdGlvblwiKSxkKHIsbFsxXSksMH1jYXRjaChtKXtyZXR1cm4gbi5wdXNoKFByb21pc2UucmVzb2x2ZShgW1dlYkdQVV0gS2VybmVsIFwiWyR7aX1dICR7YX1cIiBmYWlsZWQuICR7bX1gKSksMX1maW5hbGx5e3AmJm4ucHVzaCh0aGlzLmRldmljZS5wb3BFcnJvclNjb3BlKCkudGhlbihtPT5tP2BHUFUgdmFsaWRhdGlvbiBlcnJvciBmb3Iga2VybmVsIFwiWyR7aX1dICR7YX1cIjogJHttLm1lc3NhZ2V9YDpudWxsKSk7Zm9yKGxldCBtIG9mIHRoaXMudGVtcG9yYXJ5RGF0YSl0aGlzLmdwdURhdGFNYW5hZ2VyLnJlbGVhc2UobS5pZCk7dGhpcy50ZW1wb3JhcnlEYXRhPVtdLHRoaXMuY3VycmVudEtlcm5lbElkPW51bGx9fXJlZ2lzdGVyQnVmZmVyKHQscixuLG8pe2xldCBpPXRoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmcuZ2V0KHQpO2l8fChpPW5ldyBNYXAsdGhpcy5zZXNzaW9uRXh0ZXJuYWxEYXRhTWFwcGluZy5zZXQodCxpKSk7bGV0IGE9aS5nZXQociksZD10aGlzLmdwdURhdGFNYW5hZ2VyLnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIobixvLGEpO3JldHVybiBpLnNldChyLFtkLG5dKSxkfXVucmVnaXN0ZXJCdWZmZXJzKHQpe2xldCByPXRoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmcuZ2V0KHQpO3ImJihyLmZvckVhY2gobj0+dGhpcy5ncHVEYXRhTWFuYWdlci51bnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIoblswXSkpLHRoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmcuZGVsZXRlKHQpKX1nZXRCdWZmZXIodCl7bGV0IHI9dGhpcy5ncHVEYXRhTWFuYWdlci5nZXQodCk7aWYoIXIpdGhyb3cgbmV3IEVycm9yKGBubyBHUFUgZGF0YSBmb3IgYnVmZmVyOiAke3R9YCk7cmV0dXJuIHIuYnVmZmVyfWNyZWF0ZURvd25sb2FkZXIodCxyLG4pe3JldHVybiBhc3luYygpPT57bGV0IG89YXdhaXQgbm8odGhpcyx0LHIpO3JldHVybiBVcihvLmJ1ZmZlcixuKX19d3JpdGVUaW1lc3RhbXAodCl7dGhpcy5xdWVyeVR5cGU9PT1cImluc2lkZS1wYXNzZXNcIiYmdGhpcy5jb21wdXRlUGFzc0VuY29kZXIud3JpdGVUaW1lc3RhbXAodGhpcy5xdWVyeVNldCx0KX1zZXRRdWVyeVR5cGUoKXt0aGlzLnF1ZXJ5VHlwZT1cIm5vbmVcIiwodGhpcy5lbnYud2ViZ3B1LnByb2ZpbGluZz8ubW9kZT09PVwiZGVmYXVsdFwifHwodHlwZW9mIHRoaXMuZW52LnRyYWNlPlwidVwiP3RoaXMuZW52Lndhc20udHJhY2U6dGhpcy5lbnYudHJhY2UpKSYmKHRoaXMuZGV2aWNlLmZlYXR1cmVzLmhhcyhcImNocm9taXVtLWV4cGVyaW1lbnRhbC10aW1lc3RhbXAtcXVlcnktaW5zaWRlLXBhc3Nlc1wiKT90aGlzLnF1ZXJ5VHlwZT1cImluc2lkZS1wYXNzZXNcIjp0aGlzLmRldmljZS5mZWF0dXJlcy5oYXMoXCJ0aW1lc3RhbXAtcXVlcnlcIikmJih0aGlzLnF1ZXJ5VHlwZT1cImF0LXBhc3Nlc1wiKSx0aGlzLnF1ZXJ5VHlwZSE9PVwibm9uZVwiJiZ0eXBlb2YgdGhpcy5xdWVyeVNldD5cInVcIiYmKHRoaXMucXVlcnlTZXQ9dGhpcy5kZXZpY2UuY3JlYXRlUXVlcnlTZXQoe3R5cGU6XCJ0aW1lc3RhbXBcIixjb3VudDp0aGlzLm1heERpc3BhdGNoTnVtYmVyKjJ9KSx0aGlzLnF1ZXJ5UmVzb2x2ZUJ1ZmZlcj10aGlzLmRldmljZS5jcmVhdGVCdWZmZXIoe3NpemU6dGhpcy5tYXhEaXNwYXRjaE51bWJlcioyKjgsdXNhZ2U6R1BVQnVmZmVyVXNhZ2UuQ09QWV9TUkN8R1BVQnVmZmVyVXNhZ2UuUVVFUllfUkVTT0xWRX0pKSl9Y2FwdHVyZUJlZ2luKCl7dWUoXCJpbmZvXCIsXCJjYXB0dXJlQmVnaW5cIiksdGhpcy5jYXB0dXJlZENvbW1hbmRMaXN0LmdldCh0aGlzLmN1cnJlbnRTZXNzaW9uSWQpfHx0aGlzLmNhcHR1cmVkQ29tbWFuZExpc3Quc2V0KHRoaXMuY3VycmVudFNlc3Npb25JZCxbXSksdGhpcy5jYXB0dXJlZFBlbmRpbmdLZXJuZWxzLmdldCh0aGlzLmN1cnJlbnRTZXNzaW9uSWQpfHx0aGlzLmNhcHR1cmVkUGVuZGluZ0tlcm5lbHMuc2V0KHRoaXMuY3VycmVudFNlc3Npb25JZCxbXSksdGhpcy5mbHVzaCgpLHRoaXMuc2Vzc2lvblN0YXR1cz1cImNhcHR1cmluZ1wifWNhcHR1cmVFbmQoKXt1ZShcImluZm9cIixcImNhcHR1cmVFbmRcIiksdGhpcy5mbHVzaCgpLHRoaXMuc2Vzc2lvblN0YXR1cz1cImRlZmF1bHRcIn1yZXBsYXkoKXt1ZShcImluZm9cIixcInJlcGxheVwiKSx0aGlzLnNlc3Npb25TdGF0dXM9XCJyZXBsYXlpbmdcIjtsZXQgdD10aGlzLmNhcHR1cmVkQ29tbWFuZExpc3QuZ2V0KHRoaXMuY3VycmVudFNlc3Npb25JZCkscj10aGlzLmNhcHR1cmVkUGVuZGluZ0tlcm5lbHMuZ2V0KHRoaXMuY3VycmVudFNlc3Npb25JZCksbj10Lmxlbmd0aDt0aGlzLnBlbmRpbmdLZXJuZWxzPVtdO2ZvcihsZXQgbz0wO288bjtvKyspe2xldCBpPXRoaXMuZ2V0Q29tcHV0ZVBhc3NFbmNvZGVyKCksYT10W29dO3RoaXMud3JpdGVUaW1lc3RhbXAodGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIqMiksaS5zZXRQaXBlbGluZShhLmNvbXB1dGVQaXBlbGluZSksaS5zZXRCaW5kR3JvdXAoMCxhLmJpbmRHcm91cCksaS5kaXNwYXRjaFdvcmtncm91cHMoLi4uYS5kaXNwYXRjaEdyb3VwKSx0aGlzLndyaXRlVGltZXN0YW1wKHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKjIrMSksdGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIrKyx0aGlzLnF1ZXJ5VHlwZSE9PVwibm9uZVwiJiZ0aGlzLnBlbmRpbmdLZXJuZWxzLnB1c2gocltvXSksKHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyPj10aGlzLm1heERpc3BhdGNoTnVtYmVyfHx0aGlzLnF1ZXJ5VHlwZT09PVwiYXQtcGFzc2VzXCIpJiZ0aGlzLmVuZENvbXB1dGVQYXNzKCksdGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXI+PXRoaXMubWF4RGlzcGF0Y2hOdW1iZXImJnRoaXMuZmx1c2goKX10aGlzLmZsdXNoKCksdGhpcy5zZXNzaW9uU3RhdHVzPVwiZGVmYXVsdFwifW9uQ3JlYXRlU2Vzc2lvbigpe3RoaXMuZ3B1RGF0YU1hbmFnZXIub25DcmVhdGVTZXNzaW9uKCl9b25SZWxlYXNlU2Vzc2lvbih0KXt0aGlzLnVucmVnaXN0ZXJCdWZmZXJzKHQpLHRoaXMuY2FwdHVyZWRDb21tYW5kTGlzdC5oYXModCkmJnRoaXMuY2FwdHVyZWRDb21tYW5kTGlzdC5kZWxldGUodCksdGhpcy5jYXB0dXJlZFBlbmRpbmdLZXJuZWxzLmhhcyh0KSYmdGhpcy5jYXB0dXJlZFBlbmRpbmdLZXJuZWxzLmRlbGV0ZSh0KSx0aGlzLmdwdURhdGFNYW5hZ2VyLm9uUmVsZWFzZVNlc3Npb24odCl9b25SdW5TdGFydCh0KXt0aGlzLmN1cnJlbnRTZXNzaW9uSWQ9dCx0aGlzLnNldFF1ZXJ5VHlwZSgpfX19KTt2YXIgbGcsZWMsY2csdGMsYW4sc24sa28scmMsbmM9VSgoKT0+e1widXNlIHN0cmljdFwiO2V0KCk7bGc9MSxlYz0oKT0+bGcrKyxjZz1uZXcgTWFwKFtbXCJmbG9hdDMyXCIsMzJdLFtcImZsb2F0MTZcIiwxNl0sW1wiaW50MzJcIiwzMl0sW1widWludDMyXCIsMzJdLFtcImludDY0XCIsNjRdLFtcInVpbnQ2NFwiLDY0XSxbXCJpbnQ4XCIsOF0sW1widWludDhcIiw4XSxbXCJpbnQ0XCIsNF0sW1widWludDRcIiw0XV0pLHRjPShlLHQpPT57bGV0IHI9Y2cuZ2V0KGUpO2lmKCFyKXRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGRhdGEgdHlwZS5cIik7cmV0dXJuIHQubGVuZ3RoPjA/TWF0aC5jZWlsKHQucmVkdWNlKChuLG8pPT5uKm8pKnIvOCk6MH0sYW49Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5zZXNzaW9uSWQ9dC5zZXNzaW9uSWQsdGhpcy5tbENvbnRleHQ9dC5jb250ZXh0LHRoaXMubWxUZW5zb3I9dC50ZW5zb3IsdGhpcy5kYXRhVHlwZT10LmRhdGFUeXBlLHRoaXMudGVuc29yU2hhcGU9dC5zaGFwZX1nZXQgdGVuc29yKCl7cmV0dXJuIHRoaXMubWxUZW5zb3J9Z2V0IHR5cGUoKXtyZXR1cm4gdGhpcy5kYXRhVHlwZX1nZXQgc2hhcGUoKXtyZXR1cm4gdGhpcy50ZW5zb3JTaGFwZX1nZXQgYnl0ZUxlbmd0aCgpe3JldHVybiB0Yyh0aGlzLmRhdGFUeXBlLHRoaXMudGVuc29yU2hhcGUpfWRlc3Ryb3koKXt1ZShcInZlcmJvc2VcIiwoKT0+XCJbV2ViTk5dIFRlbnNvcldyYXBwZXIuZGVzdHJveVwiKSx0aGlzLm1sVGVuc29yLmRlc3Ryb3koKX13cml0ZSh0KXt0aGlzLm1sQ29udGV4dC53cml0ZVRlbnNvcih0aGlzLm1sVGVuc29yLHQpfWFzeW5jIHJlYWQodCl7cmV0dXJuIHQ/dGhpcy5tbENvbnRleHQucmVhZFRlbnNvcih0aGlzLm1sVGVuc29yLHQpOnRoaXMubWxDb250ZXh0LnJlYWRUZW5zb3IodGhpcy5tbFRlbnNvcil9Y2FuUmV1c2VUZW5zb3IodCxyLG4pe3JldHVybiB0aGlzLm1sQ29udGV4dD09PXQmJnRoaXMuZGF0YVR5cGU9PT1yJiZ0aGlzLnRlbnNvclNoYXBlLmxlbmd0aD09PW4ubGVuZ3RoJiZ0aGlzLnRlbnNvclNoYXBlLmV2ZXJ5KChvLGkpPT5vPT09bltpXSl9fSxzbj1jbGFzc3tjb25zdHJ1Y3Rvcih0LHIpe3RoaXMudGVuc29yTWFuYWdlcj10O3RoaXMud3JhcHBlcj1yfWdldCB0ZW5zb3JXcmFwcGVyKCl7cmV0dXJuIHRoaXMud3JhcHBlcn1yZWxlYXNlVGVuc29yKCl7dGhpcy50ZW5zb3JXcmFwcGVyJiYodGhpcy50ZW5zb3JNYW5hZ2VyLnJlbGVhc2VUZW5zb3IodGhpcy50ZW5zb3JXcmFwcGVyKSx0aGlzLndyYXBwZXI9dm9pZCAwKX1hc3luYyBlbnN1cmVUZW5zb3IodCxyLG4sbyl7aWYodGhpcy53cmFwcGVyKXtpZih0aGlzLndyYXBwZXIuY2FuUmV1c2VUZW5zb3IodCxyLG4pKXJldHVybiB0aGlzLndyYXBwZXIudGVuc29yO2lmKG8pe2lmKHRoaXMud3JhcHBlci5ieXRlTGVuZ3RoIT09dGMocixuKSl0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gY29weSBkYXRhIHRvIHRlbnNvciB3aXRoIGRpZmZlcmVudCBzaXplLlwiKTt0aGlzLmFjdGl2ZVVwbG9hZD1uZXcgVWludDhBcnJheShhd2FpdCB0aGlzLndyYXBwZXIucmVhZCgpKX10aGlzLnRlbnNvck1hbmFnZXIucmVsZWFzZVRlbnNvcih0aGlzLndyYXBwZXIpfWxldCBpPXR5cGVvZiBNTFRlbnNvclVzYWdlPlwidVwiP3ZvaWQgMDpNTFRlbnNvclVzYWdlLlJFQUR8TUxUZW5zb3JVc2FnZS5XUklURTtyZXR1cm4gdGhpcy53cmFwcGVyPWF3YWl0IHRoaXMudGVuc29yTWFuYWdlci5nZXRDYWNoZWRUZW5zb3IocixuLGksITAsITApLG8mJnRoaXMuYWN0aXZlVXBsb2FkJiYodGhpcy53cmFwcGVyLndyaXRlKHRoaXMuYWN0aXZlVXBsb2FkKSx0aGlzLmFjdGl2ZVVwbG9hZD12b2lkIDApLHRoaXMud3JhcHBlci50ZW5zb3J9dXBsb2FkKHQpe2lmKHRoaXMud3JhcHBlcilpZih0LmJ5dGVMZW5ndGg9PT10aGlzLndyYXBwZXIuYnl0ZUxlbmd0aCl7dGhpcy53cmFwcGVyLndyaXRlKHQpO3JldHVybn1lbHNlIHVlKFwidmVyYm9zZVwiLCgpPT5cIkRhdGEgc2l6ZSBkb2VzIG5vdCBtYXRjaCB0ZW5zb3Igc2l6ZS4gUmVsZWFzaW5nIHRlbnNvci5cIiksdGhpcy5yZWxlYXNlVGVuc29yKCk7dGhpcy5hY3RpdmVVcGxvYWQ/dGhpcy5hY3RpdmVVcGxvYWQuc2V0KHQpOnRoaXMuYWN0aXZlVXBsb2FkPW5ldyBVaW50OEFycmF5KHQpfWFzeW5jIGRvd25sb2FkKHQpe2lmKHRoaXMuYWN0aXZlVXBsb2FkKWlmKHQpe3QgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcj9uZXcgVWludDhBcnJheSh0KS5zZXQodGhpcy5hY3RpdmVVcGxvYWQpOm5ldyBVaW50OEFycmF5KHQuYnVmZmVyLHQuYnl0ZU9mZnNldCx0LmJ5dGVMZW5ndGgpLnNldCh0aGlzLmFjdGl2ZVVwbG9hZCk7cmV0dXJufWVsc2UgcmV0dXJuIHRoaXMuYWN0aXZlVXBsb2FkLmJ1ZmZlcjtpZighdGhpcy53cmFwcGVyKXRocm93IG5ldyBFcnJvcihcIlRlbnNvciBoYXMgbm90IGJlZW4gY3JlYXRlZC5cIik7cmV0dXJuIHQ/dGhpcy53cmFwcGVyLnJlYWQodCk6dGhpcy53cmFwcGVyLnJlYWQoKX19LGtvPWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMuYmFja2VuZD10O3RoaXMudGVuc29yVHJhY2tlcnNCeUlkPW5ldyBNYXA7dGhpcy5mcmVlVGVuc29ycz1bXTt0aGlzLmV4dGVybmFsVGVuc29ycz1uZXcgU2V0fXJlc2VydmVUZW5zb3JJZCgpe2xldCB0PWVjKCk7cmV0dXJuIHRoaXMudGVuc29yVHJhY2tlcnNCeUlkLnNldCh0LG5ldyBzbih0aGlzKSksdH1yZWxlYXNlVGVuc29ySWQodCl7bGV0IHI9dGhpcy50ZW5zb3JUcmFja2Vyc0J5SWQuZ2V0KHQpO3ImJih0aGlzLnRlbnNvclRyYWNrZXJzQnlJZC5kZWxldGUodCksci50ZW5zb3JXcmFwcGVyJiZ0aGlzLnJlbGVhc2VUZW5zb3Ioci50ZW5zb3JXcmFwcGVyKSl9YXN5bmMgZW5zdXJlVGVuc29yKHQscixuLG8pe3VlKFwidmVyYm9zZVwiLCgpPT5gW1dlYk5OXSBUZW5zb3JNYW5hZ2VyLmVuc3VyZVRlbnNvciB7dGVuc29ySWQ6ICR7dH0sIGRhdGFUeXBlOiAke3J9LCBzaGFwZTogJHtufSwgY29weU9sZDogJHtvfX1gKTtsZXQgaT10aGlzLnRlbnNvclRyYWNrZXJzQnlJZC5nZXQodCk7aWYoIWkpdGhyb3cgbmV3IEVycm9yKFwiVGVuc29yIG5vdCBmb3VuZC5cIik7cmV0dXJuIGkuZW5zdXJlVGVuc29yKHRoaXMuYmFja2VuZC5jdXJyZW50Q29udGV4dCxyLG4sbyl9dXBsb2FkKHQscil7bGV0IG49dGhpcy50ZW5zb3JUcmFja2Vyc0J5SWQuZ2V0KHQpO2lmKCFuKXRocm93IG5ldyBFcnJvcihcIlRlbnNvciBub3QgZm91bmQuXCIpO24udXBsb2FkKHIpfWFzeW5jIGRvd25sb2FkKHQscil7dWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViTk5dIFRlbnNvck1hbmFnZXIuZG93bmxvYWQge3RlbnNvcklkOiAke3R9LCBkc3RCdWZmZXI6ICR7cj8uYnl0ZUxlbmd0aH19YCk7bGV0IG49dGhpcy50ZW5zb3JUcmFja2Vyc0J5SWQuZ2V0KHQpO2lmKCFuKXRocm93IG5ldyBFcnJvcihcIlRlbnNvciBub3QgZm91bmQuXCIpO3JldHVybiBuLmRvd25sb2FkKHIpfXJlbGVhc2VUZW5zb3JzRm9yU2Vzc2lvbih0KXtmb3IobGV0IHIgb2YgdGhpcy5mcmVlVGVuc29ycylyLnNlc3Npb25JZD09PXQmJnIuZGVzdHJveSgpO3RoaXMuZnJlZVRlbnNvcnM9dGhpcy5mcmVlVGVuc29ycy5maWx0ZXIocj0+ci5zZXNzaW9uSWQhPT10KX1yZWdpc3RlclRlbnNvcih0LHIsbixvKXtsZXQgaT1lYygpLGE9bmV3IGFuKHtzZXNzaW9uSWQ6dGhpcy5iYWNrZW5kLmN1cnJlbnRTZXNzaW9uSWQsY29udGV4dDp0LHRlbnNvcjpyLGRhdGFUeXBlOm4sc2hhcGU6b30pO3JldHVybiB0aGlzLnRlbnNvclRyYWNrZXJzQnlJZC5zZXQoaSxuZXcgc24odGhpcyxhKSksdGhpcy5leHRlcm5hbFRlbnNvcnMuYWRkKGEpLGl9YXN5bmMgZ2V0Q2FjaGVkVGVuc29yKHQscixuLG8saSl7bGV0IGE9dGhpcy5iYWNrZW5kLmN1cnJlbnRTZXNzaW9uSWQsZD10aGlzLmJhY2tlbmQuY3VycmVudENvbnRleHQ7Zm9yKGxldFtwLG1db2YgdGhpcy5mcmVlVGVuc29ycy5lbnRyaWVzKCkpaWYobS5jYW5SZXVzZVRlbnNvcihkLHQscikpe3VlKFwidmVyYm9zZVwiLCgpPT5gW1dlYk5OXSBSZXVzaW5nIHRlbnNvciB7ZGF0YVR5cGU6ICR7dH0sIHNoYXBlOiAke3J9fWApO2xldCB1PXRoaXMuZnJlZVRlbnNvcnMuc3BsaWNlKHAsMSlbMF07cmV0dXJuIHUuc2Vzc2lvbklkPWEsdX11ZShcInZlcmJvc2VcIiwoKT0+YFtXZWJOTl0gTUxDb250ZXh0LmNyZWF0ZVRlbnNvciB7ZGF0YVR5cGU6ICR7dH0sIHNoYXBlOiAke3J9fWApO2xldCBsPWF3YWl0IGQuY3JlYXRlVGVuc29yKHtkYXRhVHlwZTp0LHNoYXBlOnIsZGltZW5zaW9uczpyLHVzYWdlOm4sd3JpdGFibGU6byxyZWFkYWJsZTppfSk7cmV0dXJuIG5ldyBhbih7c2Vzc2lvbklkOmEsY29udGV4dDpkLHRlbnNvcjpsLGRhdGFUeXBlOnQsc2hhcGU6cn0pfXJlbGVhc2VUZW5zb3IodCl7dGhpcy5leHRlcm5hbFRlbnNvcnMuaGFzKHQpJiZ0aGlzLmV4dGVybmFsVGVuc29ycy5kZWxldGUodCksdGhpcy5mcmVlVGVuc29ycy5wdXNoKHQpfX0scmM9KC4uLmUpPT5uZXcga28oLi4uZSl9KTt2YXIgb2MscGcsdW4saWM9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7Z3QoKTtKbigpO25jKCk7ZXQoKTtvYz1uZXcgTWFwKFtbMSxcImZsb2F0MzJcIl0sWzEwLFwiZmxvYXQxNlwiXSxbNixcImludDMyXCJdLFsxMixcInVpbnQzMlwiXSxbNyxcImludDY0XCJdLFsxMyxcInVpbnQ2NFwiXSxbMjIsXCJpbnQ0XCJdLFsyMSxcInVpbnQ0XCJdLFszLFwiaW50OFwiXSxbMixcInVpbnQ4XCJdLFs5LFwidWludDhcIl1dKSxwZz0oZSx0KT0+e2lmKGU9PT10KXJldHVybiEwO2lmKGU9PT12b2lkIDB8fHQ9PT12b2lkIDApcmV0dXJuITE7bGV0IHI9T2JqZWN0LmtleXMoZSkuc29ydCgpLG49T2JqZWN0LmtleXModCkuc29ydCgpO3JldHVybiByLmxlbmd0aD09PW4ubGVuZ3RoJiZyLmV2ZXJ5KChvLGkpPT5vPT09bltpXSYmZVtvXT09PXRbb10pfSx1bj1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLnRlbnNvck1hbmFnZXI9cmModGhpcyk7dGhpcy5tbENvbnRleHRCeVNlc3Npb25JZD1uZXcgTWFwO3RoaXMuc2Vzc2lvbklkc0J5TUxDb250ZXh0PW5ldyBNYXA7dGhpcy5tbENvbnRleHRDYWNoZT1bXTtScih0LmxvZ0xldmVsLCEhdC5kZWJ1Zyl9Z2V0IGN1cnJlbnRTZXNzaW9uSWQoKXtpZih0aGlzLmFjdGl2ZVNlc3Npb25JZD09PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJObyBhY3RpdmUgc2Vzc2lvblwiKTtyZXR1cm4gdGhpcy5hY3RpdmVTZXNzaW9uSWR9b25SdW5TdGFydCh0KXt0aGlzLmFjdGl2ZVNlc3Npb25JZD10fWFzeW5jIGNyZWF0ZU1MQ29udGV4dCh0KXtpZih0IGluc3RhbmNlb2YgR1BVRGV2aWNlKXtsZXQgbj10aGlzLm1sQ29udGV4dENhY2hlLmZpbmRJbmRleChvPT5vLmdwdURldmljZT09PXQpO2lmKG4hPT0tMSlyZXR1cm4gdGhpcy5tbENvbnRleHRDYWNoZVtuXS5tbENvbnRleHQ7e2xldCBvPWF3YWl0IG5hdmlnYXRvci5tbC5jcmVhdGVDb250ZXh0KHQpO3JldHVybiB0aGlzLm1sQ29udGV4dENhY2hlLnB1c2goe2dwdURldmljZTp0LG1sQ29udGV4dDpvfSksb319ZWxzZSBpZih0PT09dm9pZCAwKXtsZXQgbj10aGlzLm1sQ29udGV4dENhY2hlLmZpbmRJbmRleChvPT5vLm9wdGlvbnM9PT12b2lkIDAmJm8uZ3B1RGV2aWNlPT09dm9pZCAwKTtpZihuIT09LTEpcmV0dXJuIHRoaXMubWxDb250ZXh0Q2FjaGVbbl0ubWxDb250ZXh0O3tsZXQgbz1hd2FpdCBuYXZpZ2F0b3IubWwuY3JlYXRlQ29udGV4dCgpO3JldHVybiB0aGlzLm1sQ29udGV4dENhY2hlLnB1c2goe21sQ29udGV4dDpvfSksb319bGV0IHI9dGhpcy5tbENvbnRleHRDYWNoZS5maW5kSW5kZXgobj0+cGcobi5vcHRpb25zLHQpKTtpZihyIT09LTEpcmV0dXJuIHRoaXMubWxDb250ZXh0Q2FjaGVbcl0ubWxDb250ZXh0O3tsZXQgbj1hd2FpdCBuYXZpZ2F0b3IubWwuY3JlYXRlQ29udGV4dCh0KTtyZXR1cm4gdGhpcy5tbENvbnRleHRDYWNoZS5wdXNoKHtvcHRpb25zOnQsbWxDb250ZXh0Om59KSxufX1nZXQgY3VycmVudENvbnRleHQoKXtsZXQgdD10aGlzLmdldE1MQ29udGV4dCh0aGlzLmN1cnJlbnRTZXNzaW9uSWQpO2lmKCF0KXRocm93IG5ldyBFcnJvcihgTm8gTUxDb250ZXh0IGZvdW5kIGZvciBzZXNzaW9uICR7dGhpcy5jdXJyZW50U2Vzc2lvbklkfWApO3JldHVybiB0fXJlZ2lzdGVyTUxDb250ZXh0KHQscil7dGhpcy5tbENvbnRleHRCeVNlc3Npb25JZC5zZXQodCxyKTtsZXQgbj10aGlzLnNlc3Npb25JZHNCeU1MQ29udGV4dC5nZXQocik7bnx8KG49bmV3IFNldCx0aGlzLnNlc3Npb25JZHNCeU1MQ29udGV4dC5zZXQocixuKSksbi5hZGQodCl9b25SZWxlYXNlU2Vzc2lvbih0KXtsZXQgcj10aGlzLm1sQ29udGV4dEJ5U2Vzc2lvbklkLmdldCh0KTtpZighcilyZXR1cm47dGhpcy50ZW5zb3JNYW5hZ2VyLnJlbGVhc2VUZW5zb3JzRm9yU2Vzc2lvbih0KSx0aGlzLm1sQ29udGV4dEJ5U2Vzc2lvbklkLmRlbGV0ZSh0KTtsZXQgbj10aGlzLnNlc3Npb25JZHNCeU1MQ29udGV4dC5nZXQocik7aWYobi5kZWxldGUodCksbi5zaXplPT09MCl7dGhpcy5zZXNzaW9uSWRzQnlNTENvbnRleHQuZGVsZXRlKHIpO2xldCBvPXRoaXMubWxDb250ZXh0Q2FjaGUuZmluZEluZGV4KGk9PmkubWxDb250ZXh0PT09cik7byE9PS0xJiZ0aGlzLm1sQ29udGV4dENhY2hlLnNwbGljZShvLDEpfX1nZXRNTENvbnRleHQodCl7cmV0dXJuIHRoaXMubWxDb250ZXh0QnlTZXNzaW9uSWQuZ2V0KHQpfXJlc2VydmVUZW5zb3JJZCgpe3JldHVybiB0aGlzLnRlbnNvck1hbmFnZXIucmVzZXJ2ZVRlbnNvcklkKCl9cmVsZWFzZVRlbnNvcklkKHQpe3VlKFwidmVyYm9zZVwiLCgpPT5gW1dlYk5OXSByZWxlYXNlVGVuc29ySWQge3RlbnNvcklkOiAke3R9fWApLHRoaXMudGVuc29yTWFuYWdlci5yZWxlYXNlVGVuc29ySWQodCl9YXN5bmMgZW5zdXJlVGVuc29yKHQscixuLG8pe2xldCBpPW9jLmdldChyKTtpZighaSl0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIE9OTlggZGF0YSB0eXBlOiAke3J9YCk7cmV0dXJuIHRoaXMudGVuc29yTWFuYWdlci5lbnN1cmVUZW5zb3IodCxpLG4sbyl9dXBsb2FkVGVuc29yKHQscil7aWYoIUllKCkuc2hvdWxkVHJhbnNmZXJUb01MVGVuc29yKXRocm93IG5ldyBFcnJvcihcIlRyeWluZyB0byB1cGxvYWQgdG8gYSBNTFRlbnNvciB3aGlsZSBzaG91bGRUcmFuc2ZlclRvTUxUZW5zb3IgaXMgZmFsc2VcIik7dWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViTk5dIHVwbG9hZFRlbnNvciB7dGVuc29ySWQ6ICR7dH0sIGRhdGE6ICR7ci5ieXRlTGVuZ3RofX1gKSx0aGlzLnRlbnNvck1hbmFnZXIudXBsb2FkKHQscil9YXN5bmMgZG93bmxvYWRUZW5zb3IodCxyKXtyZXR1cm4gdGhpcy50ZW5zb3JNYW5hZ2VyLmRvd25sb2FkKHQscil9Y3JlYXRlTUxUZW5zb3JEb3dubG9hZGVyKHQscil7cmV0dXJuIGFzeW5jKCk9PntsZXQgbj1hd2FpdCB0aGlzLnRlbnNvck1hbmFnZXIuZG93bmxvYWQodCk7cmV0dXJuIFVyKG4scil9fXJlZ2lzdGVyTUxUZW5zb3IodCxyLG4pe2xldCBvPW9jLmdldChyKTtpZighbyl0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIE9OTlggZGF0YSB0eXBlOiAke3J9YCk7bGV0IGk9dGhpcy50ZW5zb3JNYW5hZ2VyLnJlZ2lzdGVyVGVuc29yKHRoaXMuY3VycmVudENvbnRleHQsdCxvLG4pO3JldHVybiB1ZShcInZlcmJvc2VcIiwoKT0+YFtXZWJOTl0gcmVnaXN0ZXJNTFRlbnNvciB7dGVuc29yOiAke3R9LCBkYXRhVHlwZTogJHtvfSwgZGltZW5zaW9uczogJHtufX0gLT4ge3RlbnNvcklkOiAke2l9fWApLGl9cmVnaXN0ZXJNTENvbnN0YW50KHQscixuLG8saSxhKXtpZighYSl0aHJvdyBuZXcgRXJyb3IoXCJFeHRlcm5hbCBtb3VudGVkIGZpbGVzIGFyZSBub3QgYXZhaWxhYmxlLlwiKTtsZXQgZD10O3Quc3RhcnRzV2l0aChcIi4vXCIpJiYoZD10LnN1YnN0cmluZygyKSk7bGV0IGw9YS5nZXQoZCk7aWYoIWwpdGhyb3cgbmV3IEVycm9yKGBGaWxlIHdpdGggbmFtZSAke2R9IG5vdCBmb3VuZCBpbiBwcmVsb2FkZWQgZmlsZXMuYCk7aWYocituPmwuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJPdXQgb2YgYm91bmRzOiBkYXRhIG9mZnNldCBhbmQgbGVuZ3RoIGV4Y2VlZCB0aGUgZXh0ZXJuYWwgZmlsZSBkYXRhIHNpemUuXCIpO2xldCBwPWwuc2xpY2UocixyK24pLmJ1ZmZlcixtO3N3aXRjaChpLmRhdGFUeXBlKXtjYXNlXCJmbG9hdDMyXCI6bT1uZXcgRmxvYXQzMkFycmF5KHApO2JyZWFrO2Nhc2VcImZsb2F0MTZcIjptPW5ldyBVaW50MTZBcnJheShwKTticmVhaztjYXNlXCJpbnQzMlwiOm09bmV3IEludDMyQXJyYXkocCk7YnJlYWs7Y2FzZVwidWludDMyXCI6bT1uZXcgVWludDMyQXJyYXkocCk7YnJlYWs7Y2FzZVwiaW50NjRcIjptPW5ldyBCaWdJbnQ2NEFycmF5KHApO2JyZWFrO2Nhc2VcInVpbnQ2NFwiOm09bmV3IEJpZ1VpbnQ2NEFycmF5KHApO2JyZWFrO2Nhc2VcImludDhcIjptPW5ldyBJbnQ4QXJyYXkocCk7YnJlYWs7Y2FzZVwiaW50NFwiOmNhc2VcInVpbnQ0XCI6Y2FzZVwidWludDhcIjptPW5ldyBVaW50OEFycmF5KHApO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7aS5kYXRhVHlwZX0gaW4gY3JlYXRpbmcgV2ViTk4gQ29uc3RhbnQgZnJvbSBleHRlcm5hbCBkYXRhLmApfXJldHVybiB1ZShcInZlcmJvc2VcIiwoKT0+YFtXZWJOTl0gcmVnaXN0ZXJNTENvbnN0YW50IHtkYXRhVHlwZTogJHtpLmRhdGFUeXBlfSwgc2hhcGU6ICR7aS5zaGFwZX19fWApLG8uY29uc3RhbnQoaSxtKX1mbHVzaCgpe319fSk7dmFyIGFjPXt9O0Z0KGFjLHtpbml0OigpPT5tZ30pO3ZhciBycixFbyxtZyxzYz1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtKbCgpO2V0KCk7b2UoKTtpYygpO3JyPWNsYXNzIGV7Y29uc3RydWN0b3IodCxyLG4sbyl7dGhpcy5tb2R1bGU9dDt0aGlzLmRhdGFUeXBlPXI7dGhpcy5kYXRhPW47dGhpcy5kaW1zPW99Z2V0RmxvYXQzMkFycmF5KCl7aWYodGhpcy5kYXRhVHlwZSE9PTEpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkYXRhIHR5cGVcIik7bGV0IHQ9Qy5zaXplKHRoaXMuZGltcyk7cmV0dXJuIHQ9PT0wP25ldyBGbG9hdDMyQXJyYXk6bmV3IEZsb2F0MzJBcnJheSh0aGlzLm1vZHVsZS5IRUFQOC5idWZmZXIsdGhpcy5kYXRhLHQpfWdldEJpZ0ludDY0QXJyYXkoKXtpZih0aGlzLmRhdGFUeXBlIT09Nyl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGEgdHlwZVwiKTtsZXQgdD1DLnNpemUodGhpcy5kaW1zKTtyZXR1cm4gdD09PTA/bmV3IEJpZ0ludDY0QXJyYXk6bmV3IEJpZ0ludDY0QXJyYXkodGhpcy5tb2R1bGUuSEVBUDguYnVmZmVyLHRoaXMuZGF0YSx0KX1nZXRJbnQzMkFycmF5KCl7aWYodGhpcy5kYXRhVHlwZSE9PTYpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkYXRhIHR5cGVcIik7bGV0IHQ9Qy5zaXplKHRoaXMuZGltcyk7cmV0dXJuIHQ9PT0wP25ldyBJbnQzMkFycmF5Om5ldyBJbnQzMkFycmF5KHRoaXMubW9kdWxlLkhFQVA4LmJ1ZmZlcix0aGlzLmRhdGEsdCl9Z2V0VWludDE2QXJyYXkoKXtpZih0aGlzLmRhdGFUeXBlIT09MTAmJnRoaXMuZGF0YVR5cGUhPT00KXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0YSB0eXBlXCIpO2xldCB0PUMuc2l6ZSh0aGlzLmRpbXMpO3JldHVybiB0PT09MD9uZXcgVWludDE2QXJyYXk6bmV3IFVpbnQxNkFycmF5KHRoaXMubW9kdWxlLkhFQVA4LmJ1ZmZlcix0aGlzLmRhdGEsdCl9cmVzaGFwZSh0KXtpZihDLnNpemUodCkhPT1DLnNpemUodGhpcy5kaW1zKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIG5ldyBzaGFwZVwiKTtyZXR1cm4gbmV3IGUodGhpcy5tb2R1bGUsdGhpcy5kYXRhVHlwZSx0aGlzLmRhdGEsdCl9fSxFbz1jbGFzc3tjb25zdHJ1Y3Rvcih0LHIsbil7dGhpcy5tb2R1bGU9dDt0aGlzLmJhY2tlbmQ9cjt0aGlzLmN1c3RvbURhdGFPZmZzZXQ9MDt0aGlzLmN1c3RvbURhdGFTaXplPTA7dGhpcy5hZGFwdGVySW5mbz1yLmFkYXB0ZXJJbmZvLHRoaXMuZGV2aWNlSW5mbz1yLmRldmljZUluZm87bGV0IG89dC5QVFJfU0laRSxpPW4vdC5QVFJfU0laRSxhPW89PT00P1wiaTMyXCI6XCJpNjRcIjt0aGlzLm9wS2VybmVsQ29udGV4dD1OdW1iZXIodC5nZXRWYWx1ZShvKmkrKyxhKSk7bGV0IGQ9TnVtYmVyKHQuZ2V0VmFsdWUobyppKyssYSkpO3RoaXMub3V0cHV0Q291bnQ9TnVtYmVyKHQuZ2V0VmFsdWUobyppKyssYSkpLHRoaXMuY3VzdG9tRGF0YU9mZnNldD1OdW1iZXIodC5nZXRWYWx1ZShvKmkrKyxcIipcIikpLHRoaXMuY3VzdG9tRGF0YVNpemU9TnVtYmVyKHQuZ2V0VmFsdWUobyppKyssYSkpO2xldCBsPVtdO2ZvcihsZXQgcD0wO3A8ZDtwKyspe2xldCBtPU51bWJlcih0LmdldFZhbHVlKG8qaSsrLGEpKSx1PU51bWJlcih0LmdldFZhbHVlKG8qaSsrLFwiKlwiKSksaD1OdW1iZXIodC5nZXRWYWx1ZShvKmkrKyxhKSksXz1bXTtmb3IobGV0IHk9MDt5PGg7eSsrKV8ucHVzaChOdW1iZXIodC5nZXRWYWx1ZShvKmkrKyxhKSkpO2wucHVzaChuZXcgcnIodCxtLHUsXykpfXRoaXMuaW5wdXRzPWx9Z2V0IGtlcm5lbEN1c3RvbURhdGEoKXtyZXR1cm4gdGhpcy5iYWNrZW5kLmN1cnJlbnRLZXJuZWxDdXN0b21EYXRhfWdldCBjdXN0b21EYXRhQnVmZmVyKCl7cmV0dXJuIHRoaXMubW9kdWxlLkhFQVBVOC5zdWJhcnJheSh0aGlzLmN1c3RvbURhdGFPZmZzZXQsdGhpcy5jdXN0b21EYXRhT2Zmc2V0K3RoaXMuY3VzdG9tRGF0YVNpemUpfWNvbXB1dGUodCxyKXtsZXQgbj1yPy5pbnB1dHM/Lm1hcChkPT50eXBlb2YgZD09XCJudW1iZXJcIj90aGlzLmlucHV0c1tkXTpkKT8/dGhpcy5pbnB1dHMsbz1yPy5vdXRwdXRzPz9bXSxpPShkLGwscCk9Pm5ldyBycih0aGlzLm1vZHVsZSxsLHRoaXMub3V0cHV0KGQscCkscCksYT0oZCxsKT0+e2xldCBwPUN0KGQsbCk7aWYoIXApdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7ZH1gKTtsZXQgbT1wPjA/dGhpcy5iYWNrZW5kLmdwdURhdGFNYW5hZ2VyLmNyZWF0ZShwKS5pZDowO3JldHVybiBuZXcgcnIodGhpcy5tb2R1bGUsZCxtLGwpfTtyZXR1cm4gdGhpcy5iYWNrZW5kLnJ1bih0LG4sbyxpLGEsdGhpcy5vdXRwdXRDb3VudCl9b3V0cHV0KHQscil7bGV0IG49dGhpcy5tb2R1bGUuc3RhY2tTYXZlKCk7dHJ5e2xldCBvPXRoaXMubW9kdWxlLlBUUl9TSVpFLGk9bz09PTQ/XCJpMzJcIjpcImk2NFwiLGE9dGhpcy5tb2R1bGUuc3RhY2tBbGxvYygoMStyLmxlbmd0aCkqbyk7dGhpcy5tb2R1bGUuc2V0VmFsdWUoYSxyLmxlbmd0aCxpKTtmb3IobGV0IGQ9MDtkPHIubGVuZ3RoO2QrKyl0aGlzLm1vZHVsZS5zZXRWYWx1ZShhK28qKGQrMSkscltkXSxpKTtyZXR1cm4gdGhpcy5tb2R1bGUuX0pzZXBPdXRwdXQodGhpcy5vcEtlcm5lbENvbnRleHQsdCxhKX1jYXRjaChvKXt0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBnZW5lcmF0ZSBrZXJuZWwncyBvdXRwdXRbJHt0fV0gd2l0aCBkaW1zIFske3J9XS4gSWYgeW91IGFyZSBydW5uaW5nIHdpdGggcHJlLWFsbG9jYXRlZCBvdXRwdXQsIHBsZWFzZSBtYWtlIHN1cmUgdGhlIG91dHB1dCB0eXBlL2RpbXMgYXJlIGNvcnJlY3QuIEVycm9yOiAke299YCl9ZmluYWxseXt0aGlzLm1vZHVsZS5zdGFja1Jlc3RvcmUobil9fX0sbWc9YXN5bmMoZSx0LHIsbik9PntsZXQgbz10LmpzZXBJbml0O2lmKCFvKXRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBpbml0aWFsaXplIEpTRVAuIFRoZSBXZWJBc3NlbWJseSBtb2R1bGUgaXMgbm90IGJ1aWx0IHdpdGggSlNFUCBzdXBwb3J0LlwiKTtpZihlPT09XCJ3ZWJncHVcIil7bGV0IGk9bmV3IG9uO2F3YWl0IGkuaW5pdGlhbGl6ZShyLG4pLG8oXCJ3ZWJncHVcIixbaSxhPT5pLmFsbG9jKE51bWJlcihhKSksYT0+aS5mcmVlKGEpLChhLGQsbCxwPSExKT0+e2lmKHApdWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBqc2VwQ29weUdwdVRvR3B1OiBzcmM9JHtOdW1iZXIoYSl9LCBkc3Q9JHtOdW1iZXIoZCl9LCBzaXplPSR7TnVtYmVyKGwpfWApLGkubWVtY3B5KE51bWJlcihhKSxOdW1iZXIoZCkpO2Vsc2V7dWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBqc2VwQ29weUNwdVRvR3B1OiBkYXRhT2Zmc2V0PSR7TnVtYmVyKGEpfSwgZ3B1RGF0YUlkPSR7TnVtYmVyKGQpfSwgc2l6ZT0ke051bWJlcihsKX1gKTtsZXQgbT10LkhFQVBVOC5zdWJhcnJheShOdW1iZXIoYT4+PjApLE51bWJlcihhPj4+MCkrTnVtYmVyKGwpKTtpLnVwbG9hZChOdW1iZXIoZCksbSl9fSxhc3luYyhhLGQsbCk9Pnt1ZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIGpzZXBDb3B5R3B1VG9DcHU6IGdwdURhdGFJZD0ke2F9LCBkYXRhT2Zmc2V0PSR7ZH0sIHNpemU9JHtsfWApLGF3YWl0IGkuZG93bmxvYWQoTnVtYmVyKGEpLCgpPT50LkhFQVBVOC5zdWJhcnJheShOdW1iZXIoZCk+Pj4wLE51bWJlcihkK2wpPj4+MCkpfSwoYSxkLGwpPT5pLmNyZWF0ZUtlcm5lbChhLE51bWJlcihkKSxsLHQuVVRGOFRvU3RyaW5nKHQuX0pzZXBHZXROb2RlTmFtZShOdW1iZXIoZCkpKSksYT0+aS5yZWxlYXNlS2VybmVsKGEpLChhLGQsbCxwKT0+e3VlKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0ganNlcFJ1bjogc2Vzc2lvbkhhbmRsZT0ke2x9LCBrZXJuZWw9JHthfSwgY29udGV4dERhdGFPZmZzZXQ9JHtkfWApO2xldCBtPW5ldyBFbyh0LGksTnVtYmVyKGQpKTtyZXR1cm4gaS5jb21wdXRlS2VybmVsKE51bWJlcihhKSxtLHApfSwoKT0+aS5jYXB0dXJlQmVnaW4oKSwoKT0+aS5jYXB0dXJlRW5kKCksKCk9PmkucmVwbGF5KCldKX1lbHNle2xldCBpPW5ldyB1bihyKTtvKFwid2Vibm5cIixbaSwoKT0+aS5yZXNlcnZlVGVuc29ySWQoKSxhPT5pLnJlbGVhc2VUZW5zb3JJZChhKSxhc3luYyhhLGQsbCxwKT0+aS5lbnN1cmVUZW5zb3IoYSxkLGwscCksKGEsZCk9PntpLnVwbG9hZFRlbnNvcihhLGQpfSxhc3luYyhhLGQpPT5pLmRvd25sb2FkVGVuc29yKGEsZCldKX19fSk7dmFyIGZnLFRyLElyLFB0LGhnLEt0LENyLEFyLHVjLGtyLEVyLFByLHFuPVUoKCk9PntcInVzZSBzdHJpY3RcIjtIYSgpO3FhKCk7dGUoKTtndCgpO09yKCk7WG4oKTtmZz0oZSx0KT0+e0llKCkuX09ydEluaXQoZSx0KSE9PTAmJnBlKFwiQ2FuJ3QgaW5pdGlhbGl6ZSBvbm54cnVudGltZS5cIil9LFRyPWFzeW5jIGU9PntmZyhlLndhc20ubnVtVGhyZWFkcyxadChlLmxvZ0xldmVsKSl9LElyPWFzeW5jKGUsdCk9Pnt7bGV0IHI9KHNjKCksYnIoYWMpKS5pbml0O2lmKHQ9PT1cIndlYmdwdVwiKXtpZih0eXBlb2YgbmF2aWdhdG9yPlwidVwifHwhbmF2aWdhdG9yLmdwdSl0aHJvdyBuZXcgRXJyb3IoXCJXZWJHUFUgaXMgbm90IHN1cHBvcnRlZCBpbiBjdXJyZW50IGVudmlyb25tZW50XCIpO2xldCBuPWUud2ViZ3B1LmFkYXB0ZXI7aWYobil7aWYodHlwZW9mIG4ubGltaXRzIT1cIm9iamVjdFwifHx0eXBlb2Ygbi5mZWF0dXJlcyE9XCJvYmplY3RcInx8dHlwZW9mIG4ucmVxdWVzdERldmljZSE9XCJmdW5jdGlvblwiKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgR1BVIGFkYXB0ZXIgc2V0IGluIGBlbnYud2ViZ3B1LmFkYXB0ZXJgLiBJdCBtdXN0IGJlIGEgR1BVQWRhcHRlciBvYmplY3QuXCIpfWVsc2V7bGV0IG89ZS53ZWJncHUucG93ZXJQcmVmZXJlbmNlO2lmKG8hPT12b2lkIDAmJm8hPT1cImxvdy1wb3dlclwiJiZvIT09XCJoaWdoLXBlcmZvcm1hbmNlXCIpdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBvd2VyUHJlZmVyZW5jZSBzZXR0aW5nOiBcIiR7b31cImApO2xldCBpPWUud2ViZ3B1LmZvcmNlRmFsbGJhY2tBZGFwdGVyO2lmKGkhPT12b2lkIDAmJnR5cGVvZiBpIT1cImJvb2xlYW5cIil0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZm9yY2VGYWxsYmFja0FkYXB0ZXIgc2V0dGluZzogXCIke2l9XCJgKTtpZihuPWF3YWl0IG5hdmlnYXRvci5ncHUucmVxdWVzdEFkYXB0ZXIoe3Bvd2VyUHJlZmVyZW5jZTpvLGZvcmNlRmFsbGJhY2tBZGFwdGVyOml9KSwhbil0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBnZXQgR1BVIGFkYXB0ZXIuIFlvdSBtYXkgbmVlZCB0byBlbmFibGUgZmxhZyBcIi0tZW5hYmxlLXVuc2FmZS13ZWJncHVcIiBpZiB5b3UgYXJlIHVzaW5nIENocm9tZS4nKX1hd2FpdCByKFwid2ViZ3B1XCIsSWUoKSxlLG4pfWlmKHQ9PT1cIndlYm5uXCIpe2lmKHR5cGVvZiBuYXZpZ2F0b3I+XCJ1XCJ8fCFuYXZpZ2F0b3IubWwpdGhyb3cgbmV3IEVycm9yKFwiV2ViTk4gaXMgbm90IHN1cHBvcnRlZCBpbiBjdXJyZW50IGVudmlyb25tZW50XCIpO2F3YWl0IHIoXCJ3ZWJublwiLEllKCksZSl9fX0sUHQ9bmV3IE1hcCxoZz1lPT57bGV0IHQ9SWUoKSxyPXQuc3RhY2tTYXZlKCk7dHJ5e2xldCBuPXQuUFRSX1NJWkUsbz10LnN0YWNrQWxsb2MoMipuKTt0Ll9PcnRHZXRJbnB1dE91dHB1dENvdW50KGUsbyxvK24pIT09MCYmcGUoXCJDYW4ndCBnZXQgc2Vzc2lvbiBpbnB1dC9vdXRwdXQgY291bnQuXCIpO2xldCBhPW49PT00P1wiaTMyXCI6XCJpNjRcIjtyZXR1cm5bTnVtYmVyKHQuZ2V0VmFsdWUobyxhKSksTnVtYmVyKHQuZ2V0VmFsdWUobytuLGEpKV19ZmluYWxseXt0LnN0YWNrUmVzdG9yZShyKX19LEt0PWU9PntsZXQgdD1JZSgpLHI9dC5fbWFsbG9jKGUuYnl0ZUxlbmd0aCk7aWYocj09PTApdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBjcmVhdGUgYSBzZXNzaW9uLiBmYWlsZWQgdG8gYWxsb2NhdGUgYSBidWZmZXIgb2Ygc2l6ZSAke2UuYnl0ZUxlbmd0aH0uYCk7cmV0dXJuIHQuSEVBUFU4LnNldChlLHIpLFtyLGUuYnl0ZUxlbmd0aF19LENyPWFzeW5jKGUsdCk9PntsZXQgcixuLG89SWUoKTtBcnJheS5pc0FycmF5KGUpP1tyLG5dPWU6ZS5idWZmZXI9PT1vLkhFQVBVOC5idWZmZXI/W3Isbl09W2UuYnl0ZU9mZnNldCxlLmJ5dGVMZW5ndGhdOltyLG5dPUt0KGUpO2xldCBpPTAsYT0wLGQ9MCxsPVtdLHA9W10sbT1bXTt0cnl7aWYoW2EsbF09RmEodCksdD8uZXh0ZXJuYWxEYXRhJiZvLm1vdW50RXh0ZXJuYWxEYXRhKXtsZXQgdj1bXTtmb3IobGV0IFMgb2YgdC5leHRlcm5hbERhdGEpe2xldCBUPXR5cGVvZiBTPT1cInN0cmluZ1wiP1M6Uy5wYXRoO3YucHVzaChRdCh0eXBlb2YgUz09XCJzdHJpbmdcIj9TOlMuZGF0YSkudGhlbihBPT57by5tb3VudEV4dGVybmFsRGF0YShULEEpfSkpfWF3YWl0IFByb21pc2UuYWxsKHYpfWZvcihsZXQgdiBvZiB0Py5leGVjdXRpb25Qcm92aWRlcnM/P1tdKWlmKCh0eXBlb2Ygdj09XCJzdHJpbmdcIj92OnYubmFtZSk9PT1cIndlYm5uXCIpe2lmKG8uc2hvdWxkVHJhbnNmZXJUb01MVGVuc29yPSExLHR5cGVvZiB2IT1cInN0cmluZ1wiKXtsZXQgVD12LEE9VD8uY29udGV4dCxrPVQ/LmdwdURldmljZSxQPVQ/LmRldmljZVR5cGUsRD1UPy5wb3dlclByZWZlcmVuY2U7QT9vLmN1cnJlbnRDb250ZXh0PUE6az9vLmN1cnJlbnRDb250ZXh0PWF3YWl0IG8uanNlcENyZWF0ZU1MQ29udGV4dChrKTpvLmN1cnJlbnRDb250ZXh0PWF3YWl0IG8uanNlcENyZWF0ZU1MQ29udGV4dCh7ZGV2aWNlVHlwZTpQLHBvd2VyUHJlZmVyZW5jZTpEfSl9ZWxzZSBvLmN1cnJlbnRDb250ZXh0PWF3YWl0IG8uanNlcENyZWF0ZU1MQ29udGV4dCgpO2JyZWFrfWk9YXdhaXQgby5fT3J0Q3JlYXRlU2Vzc2lvbihyLG4sYSksaT09PTAmJnBlKFwiQ2FuJ3QgY3JlYXRlIGEgc2Vzc2lvbi5cIiksby5qc2VwT25DcmVhdGVTZXNzaW9uPy4oKSxvLmN1cnJlbnRDb250ZXh0JiYoby5qc2VwUmVnaXN0ZXJNTENvbnRleHQoaSxvLmN1cnJlbnRDb250ZXh0KSxvLmN1cnJlbnRDb250ZXh0PXZvaWQgMCxvLnNob3VsZFRyYW5zZmVyVG9NTFRlbnNvcj0hMCk7bGV0W3UsaF09aGcoaSksXz0hIXQ/LmVuYWJsZUdyYXBoQ2FwdHVyZSx5PVtdLGc9W10seD1bXTtmb3IobGV0IHY9MDt2PHU7disrKXtsZXQgUz1vLl9PcnRHZXRJbnB1dE5hbWUoaSx2KTtTPT09MCYmcGUoXCJDYW4ndCBnZXQgYW4gaW5wdXQgbmFtZS5cIikscC5wdXNoKFMpLHkucHVzaChvLlVURjhUb1N0cmluZyhTKSl9Zm9yKGxldCB2PTA7djxoO3YrKyl7bGV0IFM9by5fT3J0R2V0T3V0cHV0TmFtZShpLHYpO1M9PT0wJiZwZShcIkNhbid0IGdldCBhbiBvdXRwdXQgbmFtZS5cIiksbS5wdXNoKFMpO2xldCBUPW8uVVRGOFRvU3RyaW5nKFMpO2cucHVzaChUKTt7aWYoXyYmdD8ucHJlZmVycmVkT3V0cHV0TG9jYXRpb249PT12b2lkIDApe3gucHVzaChcImdwdS1idWZmZXJcIik7Y29udGludWV9bGV0IEE9dHlwZW9mIHQ/LnByZWZlcnJlZE91dHB1dExvY2F0aW9uPT1cInN0cmluZ1wiP3QucHJlZmVycmVkT3V0cHV0TG9jYXRpb246dD8ucHJlZmVycmVkT3V0cHV0TG9jYXRpb24/LltUXT8/XCJjcHVcIjtpZihBIT09XCJjcHVcIiYmQSE9PVwiY3B1LXBpbm5lZFwiJiZBIT09XCJncHUtYnVmZmVyXCImJkEhPT1cIm1sLXRlbnNvclwiKXRocm93IG5ldyBFcnJvcihgTm90IHN1cHBvcnRlZCBwcmVmZXJyZWQgb3V0cHV0IGxvY2F0aW9uOiAke0F9LmApO2lmKF8mJkEhPT1cImdwdS1idWZmZXJcIil0aHJvdyBuZXcgRXJyb3IoYE5vdCBzdXBwb3J0ZWQgcHJlZmVycmVkIG91dHB1dCBsb2NhdGlvbjogJHtBfS4gT25seSAnZ3B1LWJ1ZmZlcicgbG9jYXRpb24gaXMgc3VwcG9ydGVkIHdoZW4gZW5hYmxlR3JhcGhDYXB0dXJlIGlzIHRydWUuYCk7eC5wdXNoKEEpfX1sZXQgJD1udWxsO3JldHVybiB4LnNvbWUodj0+dj09PVwiZ3B1LWJ1ZmZlclwifHx2PT09XCJtbC10ZW5zb3JcIikmJihkPW8uX09ydENyZWF0ZUJpbmRpbmcoaSksZD09PTAmJnBlKFwiQ2FuJ3QgY3JlYXRlIElPIGJpbmRpbmcuXCIpLCQ9e2hhbmRsZTpkLG91dHB1dFByZWZlcnJlZExvY2F0aW9uczp4LG91dHB1dFByZWZlcnJlZExvY2F0aW9uc0VuY29kZWQ6eC5tYXAodj0+UW4odikpfSksUHQuc2V0KGksW2kscCxtLCQsXywhMV0pLFtpLHksZ119Y2F0Y2godSl7dGhyb3cgcC5mb3JFYWNoKGg9Pm8uX09ydEZyZWUoaCkpLG0uZm9yRWFjaChoPT5vLl9PcnRGcmVlKGgpKSxkIT09MCYmby5fT3J0UmVsZWFzZUJpbmRpbmcoZCkhPT0wJiZwZShcIkNhbid0IHJlbGVhc2UgSU8gYmluZGluZy5cIiksaSE9PTAmJm8uX09ydFJlbGVhc2VTZXNzaW9uKGkpIT09MCYmcGUoXCJDYW4ndCByZWxlYXNlIHNlc3Npb24uXCIpLHV9ZmluYWxseXtvLl9mcmVlKHIpLGEhPT0wJiZvLl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnMoYSkhPT0wJiZwZShcIkNhbid0IHJlbGVhc2Ugc2Vzc2lvbiBvcHRpb25zLlwiKSxsLmZvckVhY2godT0+by5fZnJlZSh1KSksby51bm1vdW50RXh0ZXJuYWxEYXRhPy4oKX19LEFyPWU9PntsZXQgdD1JZSgpLHI9UHQuZ2V0KGUpO2lmKCFyKXRocm93IG5ldyBFcnJvcihgY2Fubm90IHJlbGVhc2Ugc2Vzc2lvbi4gaW52YWxpZCBzZXNzaW9uIGlkOiAke2V9YCk7bGV0W24sbyxpLGEsZF09cjthJiYoZCYmdC5fT3J0Q2xlYXJCb3VuZE91dHB1dHMoYS5oYW5kbGUpIT09MCYmcGUoXCJDYW4ndCBjbGVhciBib3VuZCBvdXRwdXRzLlwiKSx0Ll9PcnRSZWxlYXNlQmluZGluZyhhLmhhbmRsZSkhPT0wJiZwZShcIkNhbid0IHJlbGVhc2UgSU8gYmluZGluZy5cIikpLHQuanNlcE9uUmVsZWFzZVNlc3Npb24/LihlKSxvLmZvckVhY2gobD0+dC5fT3J0RnJlZShsKSksaS5mb3JFYWNoKGw9PnQuX09ydEZyZWUobCkpLHQuX09ydFJlbGVhc2VTZXNzaW9uKG4pIT09MCYmcGUoXCJDYW4ndCByZWxlYXNlIHNlc3Npb24uXCIpLFB0LmRlbGV0ZShlKX0sdWM9KGUsdCxyLG4sbyxpPSExKT0+e2lmKCFlKXt0LnB1c2goMCk7cmV0dXJufWxldCBhPUllKCksZD1hLlBUUl9TSVpFLGw9ZVswXSxwPWVbMV0sbT1lWzNdLHUsaDtpZihsPT09XCJzdHJpbmdcIiYmKG09PT1cImdwdS1idWZmZXJcInx8bT09PVwibWwtdGVuc29yXCIpKXRocm93IG5ldyBFcnJvcihcIlN0cmluZyB0ZW5zb3IgaXMgbm90IHN1cHBvcnRlZCBvbiBHUFUuXCIpO2lmKGkmJm0hPT1cImdwdS1idWZmZXJcIil0aHJvdyBuZXcgRXJyb3IoYEV4dGVybmFsIGJ1ZmZlciBtdXN0IGJlIHByb3ZpZGVkIGZvciBpbnB1dC9vdXRwdXQgaW5kZXggJHtvfSB3aGVuIGVuYWJsZUdyYXBoQ2FwdHVyZSBpcyB0cnVlLmApO2lmKG09PT1cImdwdS1idWZmZXJcIil7bGV0IGc9ZVsyXS5ncHVCdWZmZXI7aD1DdChZdChsKSxwKTtsZXQgeD1hLmpzZXBSZWdpc3RlckJ1ZmZlcjtpZigheCl0aHJvdyBuZXcgRXJyb3IoJ1RlbnNvciBsb2NhdGlvbiBcImdwdS1idWZmZXJcIiBpcyBub3Qgc3VwcG9ydGVkIHdpdGhvdXQgdXNpbmcgV2ViR1BVLicpO3U9eChuLG8sZyxoKX1lbHNlIGlmKG09PT1cIm1sLXRlbnNvclwiKXtsZXQgZz1lWzJdLm1sVGVuc29yO2g9Q3QoWXQobCkscCk7bGV0IHg9YS5qc2VwUmVnaXN0ZXJNTFRlbnNvcjtpZigheCl0aHJvdyBuZXcgRXJyb3IoJ1RlbnNvciBsb2NhdGlvbiBcIm1sLXRlbnNvclwiIGlzIG5vdCBzdXBwb3J0ZWQgd2l0aG91dCB1c2luZyBXZWJOTi4nKTt1PXgoZyxZdChsKSxwKX1lbHNle2xldCBnPWVbMl07aWYoQXJyYXkuaXNBcnJheShnKSl7aD1kKmcubGVuZ3RoLHU9YS5fbWFsbG9jKGgpLHIucHVzaCh1KTtmb3IobGV0IHg9MDt4PGcubGVuZ3RoO3grKyl7aWYodHlwZW9mIGdbeF0hPVwic3RyaW5nXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihgdGVuc29yIGRhdGEgYXQgaW5kZXggJHt4fSBpcyBub3QgYSBzdHJpbmdgKTthLnNldFZhbHVlKHUreCpkLGtlKGdbeF0sciksXCIqXCIpfX1lbHNlIGg9Zy5ieXRlTGVuZ3RoLHU9YS5fbWFsbG9jKGgpLHIucHVzaCh1KSxhLkhFQVBVOC5zZXQobmV3IFVpbnQ4QXJyYXkoZy5idWZmZXIsZy5ieXRlT2Zmc2V0LGgpLHUpfWxldCBfPWEuc3RhY2tTYXZlKCkseT1hLnN0YWNrQWxsb2MoNCpwLmxlbmd0aCk7dHJ5e3AuZm9yRWFjaCgoeCwkKT0+YS5zZXRWYWx1ZSh5KyQqZCx4LGQ9PT00P1wiaTMyXCI6XCJpNjRcIikpO2xldCBnPWEuX09ydENyZWF0ZVRlbnNvcihZdChsKSx1LGgseSxwLmxlbmd0aCxRbihtKSk7Zz09PTAmJnBlKGBDYW4ndCBjcmVhdGUgdGVuc29yIGZvciBpbnB1dC9vdXRwdXQuIHNlc3Npb249JHtufSwgaW5kZXg9JHtvfS5gKSx0LnB1c2goZyl9ZmluYWxseXthLnN0YWNrUmVzdG9yZShfKX19LGtyPWFzeW5jKGUsdCxyLG4sbyxpKT0+e2xldCBhPUllKCksZD1hLlBUUl9TSVpFLGw9UHQuZ2V0KGUpO2lmKCFsKXRocm93IG5ldyBFcnJvcihgY2Fubm90IHJ1biBpbmZlcmVuY2UuIGludmFsaWQgc2Vzc2lvbiBpZDogJHtlfWApO2xldCBwPWxbMF0sbT1sWzFdLHU9bFsyXSxoPWxbM10sXz1sWzRdLHk9bFs1XSxnPXQubGVuZ3RoLHg9bi5sZW5ndGgsJD0wLHY9W10sUz1bXSxUPVtdLEE9W10saz1hLnN0YWNrU2F2ZSgpLFA9YS5zdGFja0FsbG9jKGcqZCksRD1hLnN0YWNrQWxsb2MoZypkKSxSPWEuc3RhY2tBbGxvYyh4KmQpLEc9YS5zdGFja0FsbG9jKHgqZCk7dHJ5e2EuanNlcE9uUnVuU3RhcnQ/LihwKSxbJCx2XT1HYShpKTtmb3IobGV0IFY9MDtWPGc7VisrKXVjKHJbVl0sUyxBLGUsdFtWXSxfKTtmb3IobGV0IFY9MDtWPHg7VisrKXVjKG9bVl0sVCxBLGUsZytuW1ZdLF8pO2ZvcihsZXQgVj0wO1Y8ZztWKyspYS5zZXRWYWx1ZShQK1YqZCxTW1ZdLFwiKlwiKSxhLnNldFZhbHVlKEQrVipkLG1bdFtWXV0sXCIqXCIpO2ZvcihsZXQgVj0wO1Y8eDtWKyspYS5zZXRWYWx1ZShSK1YqZCxUW1ZdLFwiKlwiKSxhLnNldFZhbHVlKEcrVipkLHVbbltWXV0sXCIqXCIpO2lmKGgmJiF5KXtsZXR7aGFuZGxlOlYsb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zOlEsb3V0cHV0UHJlZmVycmVkTG9jYXRpb25zRW5jb2RlZDpzZX09aDtpZihtLmxlbmd0aCE9PWcpdGhyb3cgbmV3IEVycm9yKGBpbnB1dCBjb3VudCBmcm9tIGZlZWRzICgke2d9KSBpcyBleHBlY3RlZCB0byBiZSBhbHdheXMgZXF1YWwgdG8gbW9kZWwncyBpbnB1dCBjb3VudCAoJHttLmxlbmd0aH0pLmApO2ZvcihsZXQgWT0wO1k8ZztZKyspe2xldCBlZT10W1ldO2F3YWl0IGEuX09ydEJpbmRJbnB1dChWLG1bZWVdLFNbWV0pIT09MCYmcGUoYENhbid0IGJpbmQgaW5wdXRbJHtZfV0gZm9yIHNlc3Npb249JHtlfS5gKX1mb3IobGV0IFk9MDtZPHg7WSsrKXtsZXQgZWU9bltZXTtvW1ldPy5bM10/YS5fT3J0QmluZE91dHB1dChWLHVbZWVdLFRbWV0sMCkhPT0wJiZwZShgQ2FuJ3QgYmluZCBwcmUtYWxsb2NhdGVkIG91dHB1dFske1l9XSBmb3Igc2Vzc2lvbj0ke2V9LmApOmEuX09ydEJpbmRPdXRwdXQoVix1W2VlXSwwLHNlW2VlXSkhPT0wJiZwZShgQ2FuJ3QgYmluZCBvdXRwdXRbJHtZfV0gdG8gJHtRW1ldfSBmb3Igc2Vzc2lvbj0ke2V9LmApfVB0LnNldChlLFtwLG0sdSxoLF8sITBdKX1sZXQgSztoP0s9YXdhaXQgYS5fT3J0UnVuV2l0aEJpbmRpbmcocCxoLmhhbmRsZSx4LFIsJCk6Sz1hd2FpdCBhLl9PcnRSdW4ocCxELFAsZyxHLHgsUiwkKSxLIT09MCYmcGUoXCJmYWlsZWQgdG8gY2FsbCBPcnRSdW4oKS5cIik7bGV0IGo9W107Zm9yKGxldCBWPTA7Vjx4O1YrKyl7bGV0IFE9TnVtYmVyKGEuZ2V0VmFsdWUoUitWKmQsXCIqXCIpKTtpZihRPT09VFtWXSl7ai5wdXNoKG9bVl0pO2NvbnRpbnVlfWxldCBzZT1hLnN0YWNrU2F2ZSgpLFk9YS5zdGFja0FsbG9jKDQqZCksZWU9ITEsSixuZT0wO3RyeXthLl9PcnRHZXRUZW5zb3JEYXRhKFEsWSxZK2QsWSsyKmQsWSszKmQpIT09MCYmcGUoYENhbid0IGFjY2VzcyBvdXRwdXQgdGVuc29yIGRhdGEgb24gaW5kZXggJHtWfS5gKTtsZXQgT2U9ZD09PTQ/XCJpMzJcIjpcImk2NFwiLCRlPU51bWJlcihhLmdldFZhbHVlKFksT2UpKTtuZT1hLmdldFZhbHVlKFkrZCxcIipcIik7bGV0IGxlPWEuZ2V0VmFsdWUoWStkKjIsXCIqXCIpLFc9TnVtYmVyKGEuZ2V0VmFsdWUoWStkKjMsT2UpKSxxPVtdO2ZvcihsZXQgd2U9MDt3ZTxXO3dlKyspcS5wdXNoKE51bWJlcihhLmdldFZhbHVlKGxlK3dlKmQsT2UpKSk7YS5fT3J0RnJlZShsZSkhPT0wJiZwZShcIkNhbid0IGZyZWUgbWVtb3J5IGZvciB0ZW5zb3IgZGltcy5cIik7bGV0IGhlPXEucmVkdWNlKCh3ZSx5ZSk9PndlKnllLDEpO0o9YnQoJGUpO2xldCBHZT1oPy5vdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNbbltWXV07aWYoSj09PVwic3RyaW5nXCIpe2lmKEdlPT09XCJncHUtYnVmZmVyXCJ8fEdlPT09XCJtbC10ZW5zb3JcIil0aHJvdyBuZXcgRXJyb3IoXCJTdHJpbmcgdGVuc29yIGlzIG5vdCBzdXBwb3J0ZWQgb24gR1BVLlwiKTtsZXQgd2U9W107Zm9yKGxldCB5ZT0wO3llPGhlO3llKyspe2xldCBZZT1hLmdldFZhbHVlKG5lK3llKmQsXCIqXCIpLEx0PWEuZ2V0VmFsdWUobmUrKHllKzEpKmQsXCIqXCIpLGZuPXllPT09aGUtMT92b2lkIDA6THQtWWU7d2UucHVzaChhLlVURjhUb1N0cmluZyhZZSxmbikpfWoucHVzaChbSixxLHdlLFwiY3B1XCJdKX1lbHNlIGlmKEdlPT09XCJncHUtYnVmZmVyXCImJmhlPjApe2xldCB3ZT1hLmpzZXBHZXRCdWZmZXI7aWYoIXdlKXRocm93IG5ldyBFcnJvcigncHJlZmVycmVkTG9jYXRpb24gXCJncHUtYnVmZmVyXCIgaXMgbm90IHN1cHBvcnRlZCB3aXRob3V0IHVzaW5nIFdlYkdQVS4nKTtsZXQgeWU9d2UobmUpLFllPUN0KCRlLGhlKTtpZihZZT09PXZvaWQgMHx8IUJyKEopKXRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke0p9YCk7ZWU9ITAsai5wdXNoKFtKLHEse2dwdUJ1ZmZlcjp5ZSxkb3dubG9hZDphLmpzZXBDcmVhdGVEb3dubG9hZGVyKHllLFllLEopLGRpc3Bvc2U6KCk9PnthLl9PcnRSZWxlYXNlVGVuc29yKFEpIT09MCYmcGUoXCJDYW4ndCByZWxlYXNlIHRlbnNvci5cIil9fSxcImdwdS1idWZmZXJcIl0pfWVsc2UgaWYoR2U9PT1cIm1sLXRlbnNvclwiJiZoZT4wKXtsZXQgd2U9YS5qc2VwRW5zdXJlVGVuc29yO2lmKCF3ZSl0aHJvdyBuZXcgRXJyb3IoJ3ByZWZlcnJlZExvY2F0aW9uIFwibWwtdGVuc29yXCIgaXMgbm90IHN1cHBvcnRlZCB3aXRob3V0IHVzaW5nIFdlYk5OLicpO2lmKEN0KCRlLGhlKT09PXZvaWQgMHx8IU1yKEopKXRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke0p9YCk7bGV0IFllPWF3YWl0IHdlKG5lLCRlLHEsITEpO2VlPSEwLGoucHVzaChbSixxLHttbFRlbnNvcjpZZSxkb3dubG9hZDphLmpzZXBDcmVhdGVNTFRlbnNvckRvd25sb2FkZXIobmUsSiksZGlzcG9zZTooKT0+e2EuanNlcFJlbGVhc2VUZW5zb3JJZChuZSksYS5fT3J0UmVsZWFzZVRlbnNvcihRKX19LFwibWwtdGVuc29yXCJdKX1lbHNle2xldCB3ZT1EcihKKSx5ZT1uZXcgd2UoaGUpO25ldyBVaW50OEFycmF5KHllLmJ1ZmZlcix5ZS5ieXRlT2Zmc2V0LHllLmJ5dGVMZW5ndGgpLnNldChhLkhFQVBVOC5zdWJhcnJheShuZSxuZSt5ZS5ieXRlTGVuZ3RoKSksai5wdXNoKFtKLHEseWUsXCJjcHVcIl0pfX1maW5hbGx5e2Euc3RhY2tSZXN0b3JlKHNlKSxKPT09XCJzdHJpbmdcIiYmbmUmJmEuX2ZyZWUobmUpLGVlfHxhLl9PcnRSZWxlYXNlVGVuc29yKFEpfX1yZXR1cm4gaCYmIV8mJihhLl9PcnRDbGVhckJvdW5kT3V0cHV0cyhoLmhhbmRsZSkhPT0wJiZwZShcIkNhbid0IGNsZWFyIGJvdW5kIG91dHB1dHMuXCIpLFB0LnNldChlLFtwLG0sdSxoLF8sITFdKSksan1maW5hbGx5e2Euc3RhY2tSZXN0b3JlKGspLFMuZm9yRWFjaChLPT5hLl9PcnRSZWxlYXNlVGVuc29yKEspKSxULmZvckVhY2goSz0+YS5fT3J0UmVsZWFzZVRlbnNvcihLKSksQS5mb3JFYWNoKEs9PmEuX2ZyZWUoSykpLCQhPT0wJiZhLl9PcnRSZWxlYXNlUnVuT3B0aW9ucygkKSx2LmZvckVhY2goSz0+YS5fZnJlZShLKSl9fSxFcj1lPT57bGV0IHQ9SWUoKSxyPVB0LmdldChlKTtpZighcil0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNlc3Npb24gaWRcIik7bGV0IG49clswXSxvPXQuX09ydEVuZFByb2ZpbGluZyhuKTtvPT09MCYmcGUoXCJDYW4ndCBnZXQgYW4gcHJvZmlsZSBmaWxlIG5hbWUuXCIpLHQuX09ydEZyZWUobyl9LFByPWU9PntsZXQgdD1bXTtmb3IobGV0IHIgb2YgZSl7bGV0IG49clsyXTshQXJyYXkuaXNBcnJheShuKSYmXCJidWZmZXJcImluIG4mJnQucHVzaChuLmJ1ZmZlcil9cmV0dXJuIHR9fSk7dmFyIHp0LExlLG5yLGxuLGNuLGRuLFBvLHpvLFZ0LFd0LGJnLGRjLGxjLGNjLHBjLG1jLGZjLGhjLE9vPVUoKCk9PntcInVzZSBzdHJpY3RcIjtXZSgpO3FuKCk7Z3QoKTt4cigpO3p0PSgpPT4hIXZlLndhc20ucHJveHkmJnR5cGVvZiBkb2N1bWVudDxcInVcIixucj0hMSxsbj0hMSxjbj0hMSx6bz1uZXcgTWFwLFZ0PShlLHQpPT57bGV0IHI9em8uZ2V0KGUpO3I/ci5wdXNoKHQpOnpvLnNldChlLFt0XSl9LFd0PSgpPT57aWYobnJ8fCFsbnx8Y258fCFMZSl0aHJvdyBuZXcgRXJyb3IoXCJ3b3JrZXIgbm90IHJlYWR5XCIpfSxiZz1lPT57c3dpdGNoKGUuZGF0YS50eXBlKXtjYXNlXCJpbml0LXdhc21cIjpucj0hMSxlLmRhdGEuZXJyPyhjbj0hMCxQb1sxXShlLmRhdGEuZXJyKSk6KGxuPSEwLFBvWzBdKCkpLGRuJiYoVVJMLnJldm9rZU9iamVjdFVSTChkbiksZG49dm9pZCAwKTticmVhaztjYXNlXCJpbml0LWVwXCI6Y2FzZVwiY29weS1mcm9tXCI6Y2FzZVwiY3JlYXRlXCI6Y2FzZVwicmVsZWFzZVwiOmNhc2VcInJ1blwiOmNhc2VcImVuZC1wcm9maWxpbmdcIjp7bGV0IHQ9em8uZ2V0KGUuZGF0YS50eXBlKTtlLmRhdGEuZXJyP3Quc2hpZnQoKVsxXShlLmRhdGEuZXJyKTp0LnNoaWZ0KClbMF0oZS5kYXRhLm91dCk7YnJlYWt9ZGVmYXVsdDp9fSxkYz1hc3luYygpPT57aWYoIWxuKXtpZihucil0aHJvdyBuZXcgRXJyb3IoXCJtdWx0aXBsZSBjYWxscyB0byAnaW5pdFdhc20oKScgZGV0ZWN0ZWQuXCIpO2lmKGNuKXRocm93IG5ldyBFcnJvcihcInByZXZpb3VzIGNhbGwgdG8gJ2luaXRXYXNtKCknIGZhaWxlZC5cIik7aWYobnI9ITAsenQoKSlyZXR1cm4gbmV3IFByb21pc2UoKGUsdCk9PntMZT8udGVybWluYXRlKCksVmEoKS50aGVuKChbcixuXSk9Pnt0cnl7TGU9bixMZS5vbmVycm9yPWk9PnQoaSksTGUub25tZXNzYWdlPWJnLFBvPVtlLHRdO2xldCBvPXt0eXBlOlwiaW5pdC13YXNtXCIsaW46dmV9OyFvLmluLndhc20ud2FzbVBhdGhzJiYocnx8aW1wb3J0Lm1ldGEudXJsPy5zdGFydHNXaXRoKFwiZmlsZTpcIikpJiYoby5pbi53YXNtLndhc21QYXRocz17d2FzbTpuZXcgVVJMKFwib3J0LXdhc20tc2ltZC10aHJlYWRlZC5qc2VwLndhc21cIixpbXBvcnQubWV0YS51cmwpLmhyZWZ9KSxMZS5wb3N0TWVzc2FnZShvKSxkbj1yfWNhdGNoKG8pe3Qobyl9fSx0KX0pO3RyeXthd2FpdCBTcih2ZS53YXNtKSxhd2FpdCBUcih2ZSksbG49ITB9Y2F0Y2goZSl7dGhyb3cgY249ITAsZX1maW5hbGx5e25yPSExfX19LGxjPWFzeW5jIGU9PntpZih6dCgpKXJldHVybiBXdCgpLG5ldyBQcm9taXNlKCh0LHIpPT57VnQoXCJpbml0LWVwXCIsW3Qscl0pO2xldCBuPXt0eXBlOlwiaW5pdC1lcFwiLGluOntlcE5hbWU6ZSxlbnY6dmV9fTtMZS5wb3N0TWVzc2FnZShuKX0pO2F3YWl0IElyKHZlLGUpfSxjYz1hc3luYyBlPT56dCgpPyhXdCgpLG5ldyBQcm9taXNlKCh0LHIpPT57VnQoXCJjb3B5LWZyb21cIixbdCxyXSk7bGV0IG49e3R5cGU6XCJjb3B5LWZyb21cIixpbjp7YnVmZmVyOmV9fTtMZS5wb3N0TWVzc2FnZShuLFtlLmJ1ZmZlcl0pfSkpOkt0KGUpLHBjPWFzeW5jKGUsdCk9PntpZih6dCgpKXtpZih0Py5wcmVmZXJyZWRPdXRwdXRMb2NhdGlvbil0aHJvdyBuZXcgRXJyb3IoJ3Nlc3Npb24gb3B0aW9uIFwicHJlZmVycmVkT3V0cHV0TG9jYXRpb25cIiBpcyBub3Qgc3VwcG9ydGVkIGZvciBwcm94eS4nKTtyZXR1cm4gV3QoKSxuZXcgUHJvbWlzZSgocixuKT0+e1Z0KFwiY3JlYXRlXCIsW3Isbl0pO2xldCBvPXt0eXBlOlwiY3JlYXRlXCIsaW46e21vZGVsOmUsb3B0aW9uczp7Li4udH19fSxpPVtdO2UgaW5zdGFuY2VvZiBVaW50OEFycmF5JiZpLnB1c2goZS5idWZmZXIpLExlLnBvc3RNZXNzYWdlKG8saSl9KX1lbHNlIHJldHVybiBDcihlLHQpfSxtYz1hc3luYyBlPT57aWYoenQoKSlyZXR1cm4gV3QoKSxuZXcgUHJvbWlzZSgodCxyKT0+e1Z0KFwicmVsZWFzZVwiLFt0LHJdKTtsZXQgbj17dHlwZTpcInJlbGVhc2VcIixpbjplfTtMZS5wb3N0TWVzc2FnZShuKX0pO0FyKGUpfSxmYz1hc3luYyhlLHQscixuLG8saSk9PntpZih6dCgpKXtpZihyLnNvbWUoYT0+YVszXSE9PVwiY3B1XCIpKXRocm93IG5ldyBFcnJvcihcImlucHV0IHRlbnNvciBvbiBHUFUgaXMgbm90IHN1cHBvcnRlZCBmb3IgcHJveHkuXCIpO2lmKG8uc29tZShhPT5hKSl0aHJvdyBuZXcgRXJyb3IoXCJwcmUtYWxsb2NhdGVkIG91dHB1dCB0ZW5zb3IgaXMgbm90IHN1cHBvcnRlZCBmb3IgcHJveHkuXCIpO3JldHVybiBXdCgpLG5ldyBQcm9taXNlKChhLGQpPT57VnQoXCJydW5cIixbYSxkXSk7bGV0IGw9cixwPXt0eXBlOlwicnVuXCIsaW46e3Nlc3Npb25JZDplLGlucHV0SW5kaWNlczp0LGlucHV0czpsLG91dHB1dEluZGljZXM6bixvcHRpb25zOml9fTtMZS5wb3N0TWVzc2FnZShwLFByKGwpKX0pfWVsc2UgcmV0dXJuIGtyKGUsdCxyLG4sbyxpKX0saGM9YXN5bmMgZT0+e2lmKHp0KCkpcmV0dXJuIFd0KCksbmV3IFByb21pc2UoKHQscik9PntWdChcImVuZC1wcm9maWxpbmdcIixbdCxyXSk7bGV0IG49e3R5cGU6XCJlbmQtcHJvZmlsaW5nXCIsaW46ZX07TGUucG9zdE1lc3NhZ2Uobil9KTtFcihlKX19KTt2YXIgZ2MseWcscG4sYmM9VSgoKT0+e1widXNlIHN0cmljdFwiO1dlKCk7T28oKTt0ZSgpOyRyKCk7WG4oKTtnYz0oZSx0KT0+e3N3aXRjaChlLmxvY2F0aW9uKXtjYXNlXCJjcHVcIjpyZXR1cm5bZS50eXBlLGUuZGltcyxlLmRhdGEsXCJjcHVcIl07Y2FzZVwiZ3B1LWJ1ZmZlclwiOnJldHVybltlLnR5cGUsZS5kaW1zLHtncHVCdWZmZXI6ZS5ncHVCdWZmZXJ9LFwiZ3B1LWJ1ZmZlclwiXTtjYXNlXCJtbC10ZW5zb3JcIjpyZXR1cm5bZS50eXBlLGUuZGltcyx7bWxUZW5zb3I6ZS5tbFRlbnNvcn0sXCJtbC10ZW5zb3JcIl07ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZGF0YSBsb2NhdGlvbjogJHtlLmxvY2F0aW9ufSBmb3IgJHt0KCl9YCl9fSx5Zz1lPT57c3dpdGNoKGVbM10pe2Nhc2VcImNwdVwiOnJldHVybiBuZXcgSGUoZVswXSxlWzJdLGVbMV0pO2Nhc2VcImdwdS1idWZmZXJcIjp7bGV0IHQ9ZVswXTtpZighQnIodCkpdGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIGRhdGEgdHlwZTogJHt0fSBmb3IgZGVzZXJpYWxpemluZyBHUFUgdGVuc29yYCk7bGV0e2dwdUJ1ZmZlcjpyLGRvd25sb2FkOm4sZGlzcG9zZTpvfT1lWzJdO3JldHVybiBIZS5mcm9tR3B1QnVmZmVyKHIse2RhdGFUeXBlOnQsZGltczplWzFdLGRvd25sb2FkOm4sZGlzcG9zZTpvfSl9Y2FzZVwibWwtdGVuc29yXCI6e2xldCB0PWVbMF07aWYoIU1yKHQpKXRocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7dH0gZm9yIGRlc2VyaWFsaXppbmcgTUxUZW5zb3IgdGVuc29yYCk7bGV0e21sVGVuc29yOnIsZG93bmxvYWQ6bixkaXNwb3NlOm99PWVbMl07cmV0dXJuIEhlLmZyb21NTFRlbnNvcihyLHtkYXRhVHlwZTp0LGRpbXM6ZVsxXSxkb3dubG9hZDpuLGRpc3Bvc2U6b30pfWRlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRhdGEgbG9jYXRpb246ICR7ZVszXX1gKX19LHBuPWNsYXNze2FzeW5jIGZldGNoTW9kZWxBbmRDb3B5VG9XYXNtTWVtb3J5KHQpe3JldHVybiBjYyhhd2FpdCBRdCh0KSl9YXN5bmMgbG9hZE1vZGVsKHQscil7VWUoKTtsZXQgbjt0eXBlb2YgdD09XCJzdHJpbmdcIj8hMT9uPWF3YWl0IFF0KHQpOm49YXdhaXQgdGhpcy5mZXRjaE1vZGVsQW5kQ29weVRvV2FzbU1lbW9yeSh0KTpuPXQsW3RoaXMuc2Vzc2lvbklkLHRoaXMuaW5wdXROYW1lcyx0aGlzLm91dHB1dE5hbWVzXT1hd2FpdCBwYyhuLHIpLERlKCl9YXN5bmMgZGlzcG9zZSgpe3JldHVybiBtYyh0aGlzLnNlc3Npb25JZCl9YXN5bmMgcnVuKHQscixuKXtVZSgpO2xldCBvPVtdLGk9W107T2JqZWN0LmVudHJpZXModCkuZm9yRWFjaChoPT57bGV0IF89aFswXSx5PWhbMV0sZz10aGlzLmlucHV0TmFtZXMuaW5kZXhPZihfKTtpZihnPT09LTEpdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGlucHV0ICcke199J2ApO28ucHVzaCh5KSxpLnB1c2goZyl9KTtsZXQgYT1bXSxkPVtdO09iamVjdC5lbnRyaWVzKHIpLmZvckVhY2goaD0+e2xldCBfPWhbMF0seT1oWzFdLGc9dGhpcy5vdXRwdXROYW1lcy5pbmRleE9mKF8pO2lmKGc9PT0tMSl0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgb3V0cHV0ICcke199J2ApO2EucHVzaCh5KSxkLnB1c2goZyl9KTtsZXQgbD1vLm1hcCgoaCxfKT0+Z2MoaCwoKT0+YGlucHV0IFwiJHt0aGlzLmlucHV0TmFtZXNbaVtfXV19XCJgKSkscD1hLm1hcCgoaCxfKT0+aD9nYyhoLCgpPT5gb3V0cHV0IFwiJHt0aGlzLm91dHB1dE5hbWVzW2RbX11dfVwiYCk6bnVsbCksbT1hd2FpdCBmYyh0aGlzLnNlc3Npb25JZCxpLGwsZCxwLG4pLHU9e307Zm9yKGxldCBoPTA7aDxtLmxlbmd0aDtoKyspdVt0aGlzLm91dHB1dE5hbWVzW2RbaF1dXT1hW2hdPz95ZyhtW2hdKTtyZXR1cm4gRGUoKSx1fXN0YXJ0UHJvZmlsaW5nKCl7fWVuZFByb2ZpbGluZygpe2hjKHRoaXMuc2Vzc2lvbklkKX19fSk7dmFyIF9jPXt9O0Z0KF9jLHtPbm54cnVudGltZVdlYkFzc2VtYmx5QmFja2VuZDooKT0+bW4saW5pdGlhbGl6ZUZsYWdzOigpPT55Yyx3YXNtQmFja2VuZDooKT0+X2d9KTt2YXIgeWMsbW4sX2csd2M9VSgoKT0+e1widXNlIHN0cmljdFwiO1dlKCk7T28oKTtiYygpO3ljPSgpPT57aWYoKHR5cGVvZiB2ZS53YXNtLmluaXRUaW1lb3V0IT1cIm51bWJlclwifHx2ZS53YXNtLmluaXRUaW1lb3V0PDApJiYodmUud2FzbS5pbml0VGltZW91dD0wKSx2ZS53YXNtLnNpbWQ9PT0hMSYmY29uc29sZS53YXJuKCdEZXByZWNhdGVkIHByb3BlcnR5IFwiZW52Lndhc20uc2ltZFwiIGlzIHNldCB0byBmYWxzZS4gbm9uLVNJTUQgYnVpbGQgaXMgbm8gbG9uZ2VyIHByb3ZpZGVkLCBhbmQgdGhpcyBzZXR0aW5nIHdpbGwgYmUgaWdub3JlZC4nKSx0eXBlb2YgdmUud2FzbS5wcm94eSE9XCJib29sZWFuXCImJih2ZS53YXNtLnByb3h5PSExKSx0eXBlb2YgdmUud2FzbS50cmFjZSE9XCJib29sZWFuXCImJih2ZS53YXNtLnRyYWNlPSExKSx0eXBlb2YgdmUud2FzbS5udW1UaHJlYWRzIT1cIm51bWJlclwifHwhTnVtYmVyLmlzSW50ZWdlcih2ZS53YXNtLm51bVRocmVhZHMpfHx2ZS53YXNtLm51bVRocmVhZHM8PTApaWYodHlwZW9mIHNlbGY8XCJ1XCImJiFzZWxmLmNyb3NzT3JpZ2luSXNvbGF0ZWQpdmUud2FzbS5udW1UaHJlYWRzPTE7ZWxzZXtsZXQgZT10eXBlb2YgbmF2aWdhdG9yPlwidVwiP05uKFwibm9kZTpvc1wiKS5jcHVzKCkubGVuZ3RoOm5hdmlnYXRvci5oYXJkd2FyZUNvbmN1cnJlbmN5O3ZlLndhc20ubnVtVGhyZWFkcz1NYXRoLm1pbig0LE1hdGguY2VpbCgoZXx8MSkvMikpfX0sbW49Y2xhc3N7YXN5bmMgaW5pdCh0KXt5YygpLGF3YWl0IGRjKCksYXdhaXQgbGModCl9YXN5bmMgY3JlYXRlSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIodCxyKXtsZXQgbj1uZXcgcG47cmV0dXJuIGF3YWl0IG4ubG9hZE1vZGVsKHQsciksUHJvbWlzZS5yZXNvbHZlKG4pfX0sX2c9bmV3IG1ufSk7V2UoKTtXZSgpO1dlKCk7dmFyIENhPVwiMS4yMS4wLWRldi4yMDI1MDExNC0yMjhkZDE2ODkzXCI7dmFyICQxPUZuO3tsZXQgZT0od2MoKSxicihfYykpLndhc21CYWNrZW5kO1N0KFwid2ViZ3B1XCIsZSw1KSxTdChcIndlYm5uXCIsZSw1KSxTdChcImNwdVwiLGUsMTApLFN0KFwid2FzbVwiLGUsMTApfU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2ZS52ZXJzaW9ucyxcIndlYlwiLHt2YWx1ZTpDYSxlbnVtZXJhYmxlOiEwfSk7ZXhwb3J0e0ZwIGFzIEluZmVyZW5jZVNlc3Npb24sd3IgYXMgVFJBQ0UsVWUgYXMgVFJBQ0VfRlVOQ19CRUdJTixEZSBhcyBUUkFDRV9GVU5DX0VORCxIZSBhcyBUZW5zb3IsJDEgYXMgZGVmYXVsdCx2ZSBhcyBlbnYsU3QgYXMgcmVnaXN0ZXJCYWNrZW5kfTtcbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIxIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTEMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9ydC5idW5kbGUubWluLm1qcy5tYXBcbiJdLCJuYW1lcyI6WyJVbiIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiVnAiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJXcCIsImdldE93blByb3BlcnR5TmFtZXMiLCJMcCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiTm4iLCJlIiwicmVxdWlyZSIsIlByb3h5IiwiZ2V0IiwidCIsInIiLCJhcHBseSIsImFyZ3VtZW50cyIsIkVycm9yIiwiVSIsIkZ0IiwiZW51bWVyYWJsZSIsIkdwIiwibiIsIm8iLCJjYWxsIiwiYnIiLCJ2YWx1ZSIsInlyIiwieHQiLCJTdCIsIkhwIiwiSmkiLCJWbiIsIk1hcCIsImluaXQiLCJjcmVhdGVJbmZlcmVuY2VTZXNzaW9uSGFuZGxlciIsInNldCIsImJhY2tlbmQiLCJwcmlvcml0eSIsImluZGV4T2YiLCJzcGxpY2UiLCJpIiwibGVuZ3RoIiwicHVzaCIsIlR5cGVFcnJvciIsImluaXRpYWxpemVkIiwiYWJvcnRlZCIsImVycm9yIiwiaW5pdFByb21pc2UiLCJleGVjdXRpb25Qcm92aWRlcnMiLCJtYXAiLCJsIiwibmFtZSIsImEiLCJTZXQiLCJwIiwiZXJyIiwiYWRkIiwiam9pbiIsImluY2x1ZGVzIiwiY29uc29sZSIsIndhcm4iLCJkIiwiZmlsdGVyIiwiaGFzIiwiUmVmbGVjdCIsImVhIiwidGEiLCJyYSIsIm5hIiwiUmUiLCJXbiIsIndhc20iLCJ3ZWJnbCIsIndlYmdwdSIsInZlcnNpb25zIiwiY29tbW9uIiwibG9nTGV2ZWwiLCJ2ZSIsIm9hIiwiaWEiLCJhYSIsInNhIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiT2Zmc2NyZWVuQ2FudmFzIiwid2lkdGgiLCJkaW1zIiwiaGVpZ2h0IiwiZ2V0Q29udGV4dCIsInRlbnNvckxheW91dCIsImZvcm1hdCIsIm5vcm0iLCJtZWFuIiwiYmlhcyIsIm0iLCJ1IiwiaCIsIl8iLCJ5IiwiZyIsIngiLCIkIiwiZGF0YSIsInYiLCJTIiwiVCIsImZpbGxTdHlsZSIsImZpbGxSZWN0IiwidG9EYXRhVVJMIiwiY3JlYXRlSW1hZ2VEYXRhIiwiQSIsIkxuIiwidWEiLCJkYSIsImxhIiwiY2EiLCJwYSIsIm1hIiwiX3IiLCJ0ZW5zb3JGb3JtYXQiLCJGbG9hdDMyQXJyYXkiLCJ6ZSIsIkhUTUxJbWFnZUVsZW1lbnQiLCJJbWFnZURhdGEiLCJJbWFnZUJpdG1hcCIsIkhUTUxDYW52YXNFbGVtZW50IiwicmVzaXplZEhlaWdodCIsInJlc2l6ZWRXaWR0aCIsImRyYXdJbWFnZSIsImdldEltYWdlRGF0YSIsInB1dEltYWdlRGF0YSIsIlByb21pc2UiLCJJbWFnZSIsImNyb3NzT3JpZ2luIiwic3JjIiwib25sb2FkIiwiZG93bmxvYWQiLCJkaXNwb3NlIiwibG9jYXRpb24iLCJ0eXBlIiwidGV4dHVyZSIsImRhdGFUeXBlIiwiZ3B1QnVmZmVyIiwibWxUZW5zb3IiLCJUdCIsInF0IiwiZmEiLCJoYSIsImdhIiwiVWludDhBcnJheSIsIkludDhBcnJheSIsIlVpbnQxNkFycmF5IiwiSW50MTZBcnJheSIsIkludDMyQXJyYXkiLCJGbG9hdDY0QXJyYXkiLCJVaW50MzJBcnJheSIsIkJpZ0ludDY0QXJyYXkiLCJmcm9tIiwiQmlnVWludDY0QXJyYXkiLCJGbG9hdDE2QXJyYXkiLCJiYSIsInlhIiwiX2EiLCJOdW1iZXIiLCJpc1NhZmVJbnRlZ2VyIiwiUmFuZ2VFcnJvciIsImZyb21JbWFnZSIsImZyb21UZXh0dXJlIiwiZnJvbUdwdUJ1ZmZlciIsImZyb21NTFRlbnNvciIsImZyb21QaW5uZWRCdWZmZXIiLCJ0b0ltYWdlRGF0YSIsImVuc3VyZVZhbGlkIiwiY3B1RGF0YSIsImRhdGFMb2NhdGlvbiIsImdwdVRleHR1cmVEYXRhIiwiZ3B1QnVmZmVyRGF0YSIsIm1sVGVuc29yRGF0YSIsImdldERhdGEiLCJkb3dubG9hZGVyIiwiaXNEb3dubG9hZGluZyIsImRpc3Bvc2VyIiwicmVzaGFwZSIsImNvbnN0cnVjdG9yIiwiQXJyYXkiLCJpc0FycmF5IiwiQmlnSW50IiwiVWludDhDbGFtcGVkQXJyYXkiLCJNYXRoIiwiY2VpbCIsInNpemUiLCJIZSIsIkduIiwid3IiLCJ3YSIsIlVlIiwiRGUiLCJIbiIsInRyYWNlIiwidGltZVN0YW1wIiwic3RhY2siLCJzcGxpdCIsInRyaW0iLCJ2ciIsInZhIiwicnVuIiwib3V0cHV0TmFtZXMiLCJpbnB1dE5hbWVzIiwiaGFuZGxlciIsInJlbGVhc2UiLCJjcmVhdGUiLCJBcnJheUJ1ZmZlciIsIlNoYXJlZEFycmF5QnVmZmVyIiwiYnl0ZUxlbmd0aCIsInN0YXJ0UHJvZmlsaW5nIiwiZW5kUHJvZmlsaW5nIiwiRnAiLCIkYSIsInhhIiwiU2EiLCJUYSIsIklhIiwiRm4iLCJJbmZlcmVuY2VTZXNzaW9uIiwiVFJBQ0UiLCJUUkFDRV9GVU5DX0JFR0lOIiwiVFJBQ0VfRlVOQ19FTkQiLCJUZW5zb3IiLCJlbnYiLCJyZWdpc3RlckJhY2tlbmQiLCJXZSIsIiRyIiwiRWEiLCJkZWZhdWx0IiwicXAiLCJBYSIsImthIiwiUGEiLCJnbG9iYWxUaGlzIiwicW4iLCJndCIsInhyIiwic2VsZiIsIm9ubWVzc2FnZSIsImluIiwiU3IiLCJ0aGVuIiwiVHIiLCJwb3N0TWVzc2FnZSIsImVwTmFtZSIsIklyIiwiYnVmZmVyIiwiS3QiLCJvdXQiLCJtb2RlbCIsIm9wdGlvbnMiLCJDciIsIkFyIiwic2Vzc2lvbklkIiwiaW5wdXRJbmRpY2VzIiwiaW5wdXRzIiwib3V0cHV0SW5kaWNlcyIsImtyIiwiZmlsbCIsInNvbWUiLCJQciIsIkVyIiwiV29ya2VyIiwiTmUiLCJPYSIsIktwIiwiS24iLCJ6YSIsIkRhIiwidXJsIiwic2UiLCJKIiwieWUiLCJuZSIsImJlIiwiT2UiLCIkZSIsImxlIiwiVyIsIkdlIiwiYXNzaWduIiwicyIsImMiLCJpbXBvcnRTY3JpcHRzIiwibW91bnRFeHRlcm5hbERhdGEiLCJzdGFydHNXaXRoIiwic3Vic3RyaW5nIiwiRmIiLCJ1bm1vdW50RXh0ZXJuYWxEYXRhIiwiV2ViQXNzZW1ibHkiLCJNZW1vcnkiLCJpbml0aWFsIiwibWF4aW11bSIsInNoYXJlZCIsImYiLCJiIiwidyIsIkkiLCJPIiwiWGUiLCJCIiwiTCIsIkgiLCJYIiwiRW4iLCJyZXNvbHZlIiwicmVqZWN0IiwiR2IiLCJoYyIsImVycm9ycyIsIkhiIiwiZmx1c2giLCJhbGwiLCJfT3J0Q3JlYXRlU2Vzc2lvbiIsIl9PcnRSdW4iLCJfT3J0UnVuV2l0aEJpbmRpbmciLCJfT3J0QmluZElucHV0IiwianNlcEluaXQiLCJWYiIsIlpiIiwiT2IiLCJZYiIsImtiIiwiJGIiLCJjYyIsIldiIiwiWGIiLCJhYyIsImpzZXBSZWdpc3RlckJ1ZmZlciIsInJlZ2lzdGVyQnVmZmVyIiwianNlcEdldEJ1ZmZlciIsImdldEJ1ZmZlciIsImpzZXBDcmVhdGVEb3dubG9hZGVyIiwiY3JlYXRlRG93bmxvYWRlciIsImpzZXBPbkNyZWF0ZVNlc3Npb24iLCJvbkNyZWF0ZVNlc3Npb24iLCJqc2VwT25SZWxlYXNlU2Vzc2lvbiIsIm9uUmVsZWFzZVNlc3Npb24iLCJqc2VwT25SdW5TdGFydCIsIm9uUnVuU3RhcnQiLCJkYyIsInVwbG9hZCIsImJjIiwiUGIiLCJqc2VwRW5zdXJlVGVuc29yIiwiZWMiLCJqc2VwRG93bmxvYWRUZW5zb3IiLCJqc2VwUmVsZWFzZVRlbnNvcklkIiwianNlcFJlZ2lzdGVyTUxDb250ZXh0IiwicmVnaXN0ZXJNTENvbnRleHQiLCJqc2VwQ3JlYXRlTUxUZW5zb3JEb3dubG9hZGVyIiwiY3JlYXRlTUxUZW5zb3JEb3dubG9hZGVyIiwianNlcFJlZ2lzdGVyTUxUZW5zb3IiLCJyZWdpc3Rlck1MVGVuc29yIiwianNlcENyZWF0ZU1MQ29udGV4dCIsImNyZWF0ZU1MQ29udGV4dCIsImpzZXBSZWdpc3Rlck1MQ29uc3RhbnQiLCJyZWdpc3Rlck1MQ29uc3RhbnQiLCJrIiwiUCIsImhyZWYiLCJjdXJyZW50U2NyaXB0Iiwic3Vic3RyIiwicmVwbGFjZSIsImxhc3RJbmRleE9mIiwiWE1MSHR0cFJlcXVlc3QiLCJvcGVuIiwicmVzcG9uc2VUeXBlIiwic2VuZCIsInJlc3BvbnNlIiwic3RhdHVzIiwib25lcnJvciIsIkQiLCJSIiwibG9nIiwiYmluZCIsIkciLCJLIiwiaiIsImNtZCIsInN0YXJ0V29ya2VyIiwiaGFuZGxlcnMiLCJwcm94eSIsIk5iIiwicGMiLCJhcmdzIiwid2FzbU1lbW9yeSIsIlYiLCJ3YXNtTW9kdWxlIiwiRG4iLCJwdGhyZWFkX3B0ciIsIkFuIiwieGMiLCJIbyIsIlEiLCJXaSIsIlNjIiwic3RhcnRfcm91dGluZSIsImFyZyIsIk10IiwiaHIiLCJ0YXJnZXQiLCJpciIsIkxpIiwid2ciLCJhbGVydCIsInRleHQiLCJyYyIsImluc3RhbnRpYXRlV2FzbSIsIkluc3RhbmNlIiwiTm8iLCJvbnVuaGFuZGxlZHJlamVjdGlvbiIsInJlYXNvbiIsIndhc21CaW5hcnkiLCJZIiwiZWUiLCJxIiwiaGUiLCJ3ZSIsIkhFQVA4IiwiSEVBUDE2IiwiSEVBUFU4IiwiSEVBUFUxNiIsIkhFQVAzMiIsIkhFQVBVMzIiLCJIRUFQRjMyIiwiSEVBUEY2NCIsIkhFQVA2NCIsIkhFQVBVNjQiLCJZZSIsIkx0IiwiZm4iLCJHdCIsImhuIiwiSHQiLCJEbyIsImNsZWFySW50ZXJ2YWwiLCJjdCIsIlJ1bnRpbWVFcnJvciIsImduIiwiQm8iLCJNbyIsIlJvIiwiVW8iLCJmZXRjaCIsImNyZWRlbnRpYWxzIiwib2siLCJhcnJheUJ1ZmZlciIsImNhdGNoIiwiaW5zdGFudGlhdGUiLCIkYyIsInZjIiwiSWMiLCJqbyIsIlFvIiwicWEiLCJYbyIsImVpIiwidGkiLCJyaSIsIm5pIiwib2kiLCJpaSIsImFpIiwiWiIsInNpIiwidWkiLCJkaSIsImxpIiwiQ2MiLCJGIiwia2MiLCJFYyIsInpjIiwiRSIsIkRjIiwiQmMiLCJNYyIsIlJjIiwiSGMiLCJGYyIsInFjIiwiS2MiLCJqYyIsIlljIiwiWmMiLCJqYSIsIlFjIiwiWGMiLCJCYSIsIkpjIiwicnAiLCJucCIsImlwIiwiSW4iLCJhcCIsImRwIiwibHAiLCJjcCIsInBwIiwibXAiLCJmcCIsImhwIiwiZ3AiLCJicCIsInlwIiwiX3AiLCJ3cCIsInZwIiwiJHAiLCJTaSIsIlRpIiwieHAiLCJTcCIsIlRwIiwiSXAiLCJNIiwiQ3AiLCJBcCIsImtwIiwiRXAiLCJDaSIsInoiLCJQcCIsIk4iLCJ6cCIsIk9wIiwiRHAiLCJCcCIsIkVpIiwiUGkiLCJ2biIsIkMiLCJ6aSIsIk9pIiwiRGkiLCJCaSIsInduIiwiVWkiLCJVcCIsImJuIiwiQ2UiLCJzdWJhcnJheSIsIndhc21PZmZzZXRDb252ZXJ0ZXIiLCJhbHBoYSIsImJldGEiLCJtaW4iLCJtYXgiLCJ0byIsImtlZXBEaW1zIiwibm9vcFdpdGhFbXB0eUF4ZXMiLCJheGVzIiwicGVybSIsImJsb2Nrc2l6ZSIsIm1vZGUiLCJjZSIsImdlIiwiZGUiLCJhdXRvUGFkIiwiZGlsYXRpb25zIiwiZ3JvdXAiLCJrZXJuZWxTaGFwZSIsInBhZHMiLCJzdHJpZGVzIiwid0lzQ29uc3QiLCJvdXRwdXRQYWRkaW5nIiwib3V0cHV0U2hhcGUiLCJhY3RpdmF0aW9uIiwiYXV0b19wYWQiLCJjZWlsX21vZGUiLCJjb3VudF9pbmNsdWRlX3BhZCIsInN0b3JhZ2Vfb3JkZXIiLCJrZXJuZWxfc2hhcGUiLCJ0cmFuc0EiLCJ0cmFuc0IiLCJzZWxlY3RMYXN0SW5kZXgiLCJheGlzIiwibnVtT3V0cHV0cyIsInNwbGl0U2l6ZXMiLCJiYXRjaF9kaW1zIiwiYW50aWFsaWFzIiwiY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUiLCJjdWJpY0NvZWZmQSIsImV4Y2x1ZGVPdXRzaWRlIiwiZXh0cmFwb2xhdGlvblZhbHVlIiwia2VlcEFzcGVjdFJhdGlvUG9saWN5IiwibmVhcmVzdE1vZGUiLCJzdGFydHMiLCJlbmRzIiwiZXBzaWxvbiIsImVxdWF0aW9uIiwibW9tZW50dW0iLCJzcGF0aWFsIiwidHJhaW5pbmdNb2RlIiwiZXhjbHVzaXZlIiwicmV2ZXJzZSIsImJsb2NrU2l6ZSIsImFsaWduX2Nvcm5lcnMiLCJwYWRkaW5nX21vZGUiLCJudW1IZWFkcyIsImlzVW5pZGlyZWN0aW9uYWwiLCJtYXNrRmlsdGVyVmFsdWUiLCJzY2FsZSIsImRvUm90YXJ5IiwicWt2SGlkZGVuU2l6ZXMiLCJwYXN0UHJlc2VudFNoYXJlQnVmZmVyIiwiVGUiLCJ3X2lzX2NvbnN0IiwiYWN0aXZhdGlvbl9wYXJhbXMiLCJrdk51bUhlYWRzIiwic29mdGNhcCIsInJvdGFyeUludGVybGVhdmVkIiwic21vb3RoU29mdG1heCIsImxvY2FsV2luZG93U2l6ZSIsInNpbXBsaWZpZWQiLCJhY2N1cmFjeUxldmVsIiwiYml0cyIsImludGVybGVhdmVkIiwicm90YXJ5RW1iZWRkaW5nRGltIiwiZ2F0aGVyQXhpcyIsInF1YW50aXplQXhpcyIsIl9pIiwieW4iLCJtZXNzYWdlIiwiX24iLCJ0ZXJtaW5hdGUiLCJWbyIsInB0IiwicW8iLCJGbyIsInBvcCIsInZ0IiwiWmUiLCJCYiIsImljIiwiUmIiLCJuYyIsInd0IiwieGUiLCJSbiIsIk1uIiwiR2kiLCJnciIsIldvIiwiTG8iLCJHbyIsIkJuIiwiZm9yRWFjaCIsInRhcmdldFRocmVhZCIsInRyYW5zZmVyTGlzdCIsInRocmVhZCIsImxvYWRlZCIsInRocmVhZElkIiwiZmlsZW5hbWUiLCJsaW5lbm8iLCJVUkwiLCJ3b3JrZXJEYXRhIiwib3IiLCJzaGlmdCIsIkZpIiwicWkiLCJUYyIsIktiIiwiS28iLCJZbyIsIlRleHREZWNvZGVyIiwiWm8iLCJkZWNvZGUiLCJzbGljZSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIiRuIiwiY2hhckNvZGVBdCIsIkpvIiwiT3QiLCJjaSIsIm10IiwiUWUiLCJ4biIsIlNuIiwiQWMiLCJzdCIsIlRiIiwicGkiLCJmcm9tV2lyZVR5cGUiLCJ0b1dpcmVUeXBlIiwidG9TdHJpbmciLCJhcmdQYWNrQWR2YW5jZSIsImZ0IiwicmVhZFZhbHVlRnJvbVBvaW50ZXIiLCJFYiIsIlRuIiwidXQiLCJNZSIsIlZlIiwiQ24iLCJQYyIsIk9jIiwiSmUiLCJmciIsIm1pIiwiVWMiLCJOYyIsIlZjIiwiV2MiLCJMYyIsIkdjIiwiVWIiLCJmaSIsIkF0b21pY3MiLCJvYyIsInN0b3JlIiwiSGkiLCJzZXRUaW1lb3V0Iiwia24iLCJOcCIsImFyIiwiVmkiLCJoaSIsInNyIiwiaHQiLCJnaSIsInVyIiwiYmkiLCJ5aSIsImVwIiwidHAiLCJZaSIsIkJyb3dzZXIiLCJMYiIsIlNiIiwicmVzdW1lIiwicGF1c2UiLCJLaSIsIlppIiwiZHIiLCJvcCIsImxyIiwid2kiLCJGdW5jdGlvbiIsInNwIiwidXAiLCJ2aSIsIk5hTiIsIkRhdGUiLCJnZXRVVENTZWNvbmRzIiwiZ2V0VVRDTWludXRlcyIsImdldFVUQ0hvdXJzIiwiZ2V0VVRDRGF0ZSIsImdldFVUQ01vbnRoIiwiZ2V0VVRDRnVsbFllYXIiLCJnZXRVVENEYXkiLCJnZXRUaW1lIiwiVVRDIiwiRHQiLCIkaSIsInhpIiwiZ2V0U2Vjb25kcyIsImdldE1pbnV0ZXMiLCJnZXRIb3VycyIsImdldERhdGUiLCJnZXRNb250aCIsImdldEZ1bGxZZWFyIiwiZ2V0RGF5IiwiZ2V0VGltZXpvbmVPZmZzZXQiLCJzZXRUaW1lIiwiZ2V0WWVhciIsImlzTmFOIiwidG9Mb2NhbGVUaW1lU3RyaW5nIiwiaG91cjEyIiwidGltZVpvbmVOYW1lIiwiUG4iLCJJaSIsIm5vdyIsInBlcmZvcm1hbmNlIiwidGltZU9yaWdpbiIsIm5hdmlnYXRvciIsImhhcmR3YXJlQ29uY3VycmVuY3kiLCJncm93IiwiY3IiLCJCdCIsIkFpIiwiUWIiLCJmYyIsInpuIiwiT24iLCJraSIsIlVTRVIiLCJMT0dOQU1FIiwiUEFUSCIsIlBXRCIsIkhPTUUiLCJMQU5HIiwibGFuZ3VhZ2VzIiwiTXAiLCJNaSIsIlJpIiwiUnAiLCJYaSIsIiR0IiwiQ2IiLCJEYiIsInNldERhdGUiLCJzZXRNb250aCIsInNldEZ1bGxZZWFyIiwibGMiLCJJYiIsIk1iIiwiSmIiLCJ2YiIsInNjIiwibWMiLCJSZWdFeHAiLCJmbG9vciIsImFicyIsIm51bVRocmVhZHMiLCJ1bnNoaWZ0IiwiTmkiLCJwciIsIkJpbmRpbmdFcnJvciIsIkludGVybmFsRXJyb3IiLCJjb3VudF9lbXZhbF9oYW5kbGVzIiwiZXhwb3J0cyIsImVudHJpZXMiLCJqaSIsIkZpYmVycyIsInRjIiwiZ2IiLCJpYiIsImVtc2NyaXB0ZW5fbWFpbl9ydW50aW1lX3RocmVhZF9pZCIsInRiIiwidWIiLCJqYiIsIkNhIiwibG9jYXRlRmlsZSIsImluc3RhbnRpYXRlU3RyZWFtaW5nIiwiaW5zdGFuY2UiLCJtb2R1bGUiLCJfT3J0SW5pdCIsIkZhIiwiX09ydEdldExhc3RFcnJvciIsIkdhIiwiX09ydENyZWF0ZVNlc3Npb25PcHRpb25zIiwiSGEiLCJfT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXIiLCJfT3J0QWRkRnJlZURpbWVuc2lvbk92ZXJyaWRlIiwiSmEiLCJfT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5IiwiS2EiLCJfT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zIiwiTGEiLCJNYSIsIl9PcnRSZWxlYXNlU2Vzc2lvbiIsIk5hIiwiX09ydEdldElucHV0T3V0cHV0Q291bnQiLCJfT3J0R2V0SW5wdXROYW1lIiwiX09ydEdldE91dHB1dE5hbWUiLCJRYSIsIl9PcnRGcmVlIiwiUmEiLCJfT3J0Q3JlYXRlVGVuc29yIiwiX09ydEdldFRlbnNvckRhdGEiLCJfT3J0UmVsZWFzZVRlbnNvciIsIlVhIiwiX09ydENyZWF0ZVJ1bk9wdGlvbnMiLCJWYSIsIl9PcnRBZGRSdW5Db25maWdFbnRyeSIsIldhIiwiX09ydFJlbGVhc2VSdW5PcHRpb25zIiwiWGEiLCJfT3J0Q3JlYXRlQmluZGluZyIsIllhIiwiWmEiLCJfT3J0QmluZE91dHB1dCIsIl9PcnRDbGVhckJvdW5kT3V0cHV0cyIsIl9PcnRSZWxlYXNlQmluZGluZyIsImFiIiwiYmIiLCJjYiIsIl9PcnRFbmRQcm9maWxpbmciLCJkYiIsIl9Kc2VwT3V0cHV0IiwiZWIiLCJfSnNlcEdldE5vZGVOYW1lIiwiZmIiLCJtciIsIl9mcmVlIiwiaGIiLCJfbWFsbG9jIiwibGIiLCJtYiIsIm5iIiwib2IiLCJwYiIsInFiIiwicmIiLCJzYiIsImR5bkNhbGxfaWkiLCJ3YiIsInhiIiwieWIiLCJ6YiIsIkFiIiwiUWkiLCJjYWxsZWRSdW4iLCJfX19zdGFydF9lbV9qcyIsIl9fX3N0b3BfZW1fanMiLCJzdGFja1NhdmUiLCJzdGFja1Jlc3RvcmUiLCJzdGFja0FsbG9jIiwic2V0VmFsdWUiLCJlbmRzV2l0aCIsImdldFZhbHVlIiwiVVRGOFRvU3RyaW5nIiwic3RyaW5nVG9VVEY4IiwibGVuZ3RoQnl0ZXNVVEY4IiwiUFRSX1NJWkUiLCJqcCIsImpuIiwiWXAiLCJacCIsIlFwIiwib3JpZ2luIiwiYmxvYiIsImNyZWF0ZU9iamVjdFVSTCIsIlluIiwiWm4iLCJ6ciIsIlhwIiwiSnAiLCJJZSIsIk1lc3NhZ2VDaGFubmVsIiwicG9ydDEiLCJ2YWxpZGF0ZSIsImluaXRUaW1lb3V0IiwiY3Jvc3NPcmlnaW5Jc29sYXRlZCIsIndhc21QYXRocyIsIm1qcyIsInJldm9rZU9iamVjdFVSTCIsInJhY2UiLCJrZSIsImp0IiwicGUiLCJPciIsImxvZ1NldmVyaXR5TGV2ZWwiLCJpc0ludGVnZXIiLCJsb2dWZXJib3NpdHlMZXZlbCIsInRhZyIsImV4dHJhIiwiV2Vha1NldCIsImVtIiwidG0iLCJybSIsIm5tIiwic2Vzc2lvbiIsInVzZV9vcnRfbW9kZWxfYnl0ZXNfZGlyZWN0bHkiLCJlbmFibGVNZW1QYXR0ZXJuIiwiZGV2aWNlVHlwZSIsInByZWZlcnJlZExheW91dCIsImdyYXBoT3B0aW1pemF0aW9uTGV2ZWwiLCJleGVjdXRpb25Nb2RlIiwibG9nSWQiLCJvcHRpbWl6ZWRNb2RlbEZpbGVQYXRoIiwiZW5hYmxlQ3B1TWVtQXJlbmEiLCJlbmFibGVQcm9maWxpbmciLCJlbmFibGVHcmFwaENhcHR1cmUiLCJmcmVlRGltZW5zaW9uT3ZlcnJpZGVzIiwiWXQiLCJidCIsIkN0IiwiRHIiLCJadCIsIkJyIiwiTXIiLCJRbiIsInRlIiwicmVkdWNlIiwiUXQiLCJYbiIsInJlYWRGaWxlIiwiY29kZSIsImNyZWF0ZVJlYWRTdHJlYW0iLCJCdWZmZXIiLCJjb25jYXQiLCJoZWFkZXJzIiwicGFyc2VJbnQiLCJib2R5IiwiZ2V0UmVhZGVyIiwiZG9uZSIsInJlYWQiLCJCbG9iIiwib20iLCJpbSIsIlJyIiwiYW0iLCJ1ZSIsImV0IiwidG9JU09TdHJpbmciLCJVciIsIkpuIiwiTnIiLCJlbyIsInNtIiwidW0iLCJubyIsInJvIiwiZGV2aWNlIiwiY3JlYXRlQnVmZmVyIiwidXNhZ2UiLCJHUFVCdWZmZXJVc2FnZSIsIkNPUFlfRFNUIiwiTUFQX1JFQUQiLCJnZXRDb21tYW5kRW5jb2RlciIsImVuZENvbXB1dGVQYXNzIiwiY29weUJ1ZmZlclRvQnVmZmVyIiwibWFwQXN5bmMiLCJHUFVNYXBNb2RlIiwiUkVBRCIsImdldE1hcHBlZFJhbmdlIiwiZGVzdHJveSIsImJ5dGVPZmZzZXQiLCJzdG9yYWdlQ2FjaGUiLCJvcmlnaW5hbFNpemUiLCJtYXBwZWRBdENyZWF0aW9uIiwiTUFQX1dSSVRFIiwiQ09QWV9TUkMiLCJ1bm1hcCIsImNyZWF0ZUNvbW1hbmRFbmNvZGVyIiwiZ3B1RGF0YSIsInF1ZXVlIiwic3VibWl0IiwiZmluaXNoIiwibWVtY3B5IiwicmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlciIsImNhcHR1cmVkQ29tbWFuZExpc3QiLCJjdXJyZW50U2Vzc2lvbklkIiwiaWQiLCJ1bnJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIiLCJkZWxldGUiLCJTVE9SQUdFIiwiVU5JRk9STSIsImZyZWVCdWZmZXJzIiwiZnJlZVVuaWZvcm1CdWZmZXJzIiwiYnVmZmVyc1BlbmRpbmciLCJyZWZyZXNoUGVuZGluZ0J1ZmZlcnMiLCJzZXNzaW9uU3RhdHVzIiwiY2FwdHVyZWRQZW5kaW5nQnVmZmVycyIsInNlc3Npb25Db3VudCIsIm9vIiwicmUiLCJTZSIsImNhY2hlS2V5Iiwia2V5Iiwic29ydCIsImlvIiwidHQiLCJBdCIsIlZyIiwiZXMiLCJ0cyIsIm9lIiwiY2FsY01hdE11bFNoYXBlIiwiY2FsY1NoYXBlIiwiaXNWYWxpZEJyb2FkY2FzdCIsImdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UiLCJjb252ZXJ0U2hhcGUiLCJzaXplRnJvbURpbWVuc2lvbiIsInNpemVUb0RpbWVuc2lvbiIsImNvbXB1dGVTdHJpZGVzIiwibm9ybWFsaXplQXhpcyIsIm5vcm1hbGl6ZUF4ZXMiLCJzb3J0QmFzZWRPblBlcm0iLCJwYWRTaGFwZSIsImFyZUVxdWFsIiwiZXZlcnkiLCJhZGp1c3RQb29sQXR0cmlidXRlcyIsImFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZCIsImFkanVzdFBhZEFuZFJldHVyblNoYXBlIiwiY29tcHV0ZVBvb2xPdXRwdXRTaGFwZSIsImNvbXB1dGVTaGFwZUhlbHBlciIsImNvbXB1dGVDb252T3V0cHV0U2hhcGUiLCJnZXRTaGFwZU9mR2VtbVJlc3VsdCIsImt0Iiwic28iLCJfZSIsIkVlIiwibWUiLCJ1byIsIkV0IiwiRmUiLCJXciIsInJzIiwiTHIiLCJhbyIsIm5zIiwiYWUiLCJrZXlzIiwiaW5kaWNlcyIsInN0b3JhZ2UiLCJ0ZW5zb3IiLCJvZmZzZXRUb0luZGljZXMiLCJpbmRpY2VzVG9PZmZzZXQiLCJicm9hZGNhc3RlZEluZGljZXNUb09mZnNldCIsInNldEJ5SW5kaWNlcyIsImdldEJ5SW5kaWNlcyIsImluZGljZXNHZXQiLCJyYW5rIiwiaW1wbCIsInZhbHVlcyIsImluZGljZXNTZXQiLCJzZXRCeU9mZnNldCIsImdldEJ5T2Zmc2V0Iiwic2hhcGUiLCJndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzIiwibWFpblN0YXJ0IiwibGltaXRzIiwibWF4Q29tcHV0ZVdvcmtncm91cFNpemVYIiwibWF4Q29tcHV0ZVdvcmtncm91cFNpemVZIiwibWF4Q29tcHV0ZVdvcmtncm91cFNpemVaIiwibWF4Q29tcHV0ZUludm9jYXRpb25zUGVyV29ya2dyb3VwIiwibm9ybWFsaXplZERpc3BhdGNoR3JvdXAiLCJhcHBlbmRWYXJpYWJsZVVuaWZvcm1zIiwidW5pZm9ybXMiLCJkZWNsYXJlVmFyaWFibGUiLCJ2YXJpYWJsZXMiLCJkZWNsYXJlVmFyaWFibGVzIiwidmFyaWFibGVJbmRleCIsInJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZSIsImludGVybmFsVmFyaWFibGVzIiwicmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlcyIsInJlZ2lzdGVyVW5pZm9ybSIsInJlZ2lzdGVyVW5pZm9ybXMiLCJ1bmlmb3JtRGVjbGFyYXRpb24iLCJhZGRpdGlvbmFsSW1wbGVtZW50YXRpb25zIiwidmFyaWFibGVzSW5mbyIsImRtIiwib3MiLCJsbSIsImNtIiwicG0iLCJtbSIsIlBlIiwiaXMiLCJhcyIsImR0IiwibmV3U2hhcGUiLCJuZXdQZXJtIiwic2hhZGVyQ2FjaGUiLCJpbnB1dERlcGVuZGVuY2llcyIsImdldFJ1bkRhdGEiLCJvdXRwdXRzIiwiZGlzcGF0Y2hHcm91cCIsInByb2dyYW1Vbmlmb3JtcyIsImdldFNoYWRlclNvdXJjZSIsImhpbnQiLCJjb21wdXRlIiwiZm0iLCJobSIsImdtIiwiYm0iLCJ5bSIsIl9tIiwid20iLCJ2bSIsIiRtIiwieG0iLCJydCIsInNzIiwidXMiLCJkcyIsImxzIiwiY3MiLCJwcyIsIm1zIiwiZnMiLCJocyIsImdzIiwiYnMiLCJHciIsInN1bSIsInByb2QiLCJzdW1TcXVhcmUiLCJsb2dTdW1FeHAiLCJsMSIsImwyIiwibG9nU3VtIiwibG8iLCJudCIsIlNtIiwiSHIiLCJvdCIsIlRtIiwiSW0iLCJDbSIsIkFtIiwia20iLCJFbSIsIlBtIiwiem0iLCJPbSIsIkRtIiwiaXQiLCJ5cyIsIl9zIiwid3MiLCJ2cyIsIiRzIiwieHMiLCJTcyIsIlRzIiwiSXMiLCJDcyIsImdldEJpZ0ludDY0QXJyYXkiLCJBcyIsImtzIiwiRXMiLCJjbyIsIlBzIiwiQm0iLCJwbyIsIk1tIiwiUm0iLCJVbSIsIlJ0IiwiTm0iLCJ6cyIsIkZyIiwiYmF0Y2hTaXplIiwic2VxdWVuY2VMZW5ndGgiLCJwYXN0U2VxdWVuY2VMZW5ndGgiLCJrdlNlcXVlbmNlTGVuZ3RoIiwidG90YWxTZXF1ZW5jZUxlbmd0aCIsIm1heFNlcXVlbmNlTGVuZ3RoIiwiaW5wdXRIaWRkZW5TaXplIiwiaGlkZGVuU2l6ZSIsInZIaWRkZW5TaXplIiwiaGVhZFNpemUiLCJ2SGVhZFNpemUiLCJtYXNrVHlwZSIsImJyb2FkY2FzdFJlc1Bvc0JpYXMiLCJwYXNzUGFzdEluS3YiLCJxa3ZGb3JtYXQiLCJuUmVwcyIsInNxcnQiLCJncHVEYXRhVHlwZSIsIm91dHB1dENvdW50IiwiVm0iLCJXbSIsIkxtIiwiT3MiLCJEcyIsInZhbGlkYXRlSW5wdXRDb250ZW50IiwiR20iLCJIbSIsIkJzIiwiTXMiLCJGbSIsImZlIiwiUnMiLCJVcyIsIk5zIiwiVnMiLCJXcyIsIkxzIiwiR3MiLCJIcyIsIkZzIiwicW0iLCJxcyIsIktzIiwianMiLCJZcyIsIlh0IiwiWnMiLCJxciIsIlFzIiwiWHMiLCJKcyIsImV1IiwidHUiLCJydSIsIm51Iiwib3UiLCJpdSIsImF1Iiwic3UiLCJ1dSIsImR1IiwibHUiLCJjdSIsInB1IiwibXUiLCJmdSIsIm1vIiwiZm8iLCJodSIsImd1IiwiYnUiLCJLbSIsImptIiwieXUiLCJLciIsImdldEZsb2F0MzJBcnJheSIsImdldFVpbnQxNkFycmF5IiwiWW0iLCJabSIsInd1IiwidnUiLCJRbSIsIlhtIiwiYXQiLCIkdSIsInh1IiwiU3UiLCJUdSIsIkl1IiwiQ3UiLCJBdSIsImt1IiwiRXUiLCJQdSIsInp1Iiwic2NhbGFyIiwidmVjdG9yIiwiZWYiLCJ0ZiIsInJmIiwibmYiLCJPdSIsIkR1IiwiQnUiLCJxZSIsIktlIiwiamUiLCJqciIsInl0IiwiY2xpcE1heCIsImNsaXBNaW4iLCJBZSIsIk11IiwiWXIiLCJSdSIsIlV1IiwiSnQiLCJaciIsIlFyIiwib2YiLCJhZiIsImhvIiwiTnUiLCJzZiIsImdvIiwidWYiLCJlciIsIlhyIiwiZGYiLCJWdSIsIld1IiwibGYiLCJMdSIsIkpyIiwiY2YiLCJHdSIsInBmIiwiSHUiLCJGdSIsInF1IiwidHJ1bmMiLCJ0b3AiLCJib3R0b20iLCJsZWZ0IiwicmlnaHQiLCJmcm9udCIsImJhY2siLCJwYWRJbmZvIiwib3V0RGVwdGgiLCJvdXRIZWlnaHQiLCJvdXRXaWR0aCIsImRhdGFGb3JtYXQiLCJpbkRlcHRoIiwiaW5IZWlnaHQiLCJpbldpZHRoIiwiaW5DaGFubmVscyIsIm91dENoYW5uZWxzIiwic3RyaWRlRGVwdGgiLCJzdHJpZGVIZWlnaHQiLCJzdHJpZGVXaWR0aCIsImZpbHRlckRlcHRoIiwiZmlsdGVySGVpZ2h0IiwiZmlsdGVyV2lkdGgiLCJlZmZlY3RpdmVGaWx0ZXJEZXB0aCIsImVmZmVjdGl2ZUZpbHRlckhlaWdodCIsImVmZmVjdGl2ZUZpbHRlcldpZHRoIiwiZGlsYXRpb25EZXB0aCIsImRpbGF0aW9uSGVpZ2h0IiwiZGlsYXRpb25XaWR0aCIsImluU2hhcGUiLCJvdXRTaGFwZSIsImZpbHRlclNoYXBlIiwiS3UiLCJqdSIsIll1IiwibWYiLCJibyIsImZmIiwieW8iLCJfbyIsIlp1IiwiaGYiLCJnZiIsIndvIiwiUXUiLCJrZXJuZWxDdXN0b21EYXRhIiwid1QiLCJhZGFwdGVySW5mbyIsImlzQXJjaGl0ZWN0dXJlIiwiWHUiLCJKdSIsImJmIiwieWYiLCJfZiIsImVkIiwidGQiLCJ3ZiIsInJkIiwidmYiLCJuZCIsIm9kIiwiJGYiLCJhZCIsInNkIiwiZ2V0SW50MzJBcnJheSIsInhmIiwiU2YiLCJUZiIsInVkIiwiZGQiLCJsZCIsInZvIiwiZW4iLCJjZCIsIklmIiwiQ2YiLCIkbyIsInhvIiwicGQiLCJBZiIsIm1kIiwiZmQiLCJoZCIsImFkZFN5bWJvbCIsInN5bWJvbFRvSW5kaWNlcyIsImlucHV0SW5kZXgiLCJzeW1ib2xUb0luZm8iLCJkaW1WYWx1ZSIsImNvdW50IiwicHJvY2Vzc1Rlcm0iLCJtYXRjaCIsImhhc0VsbGlwc2lzIiwiZWxsaXBzaXNEaW1zIiwibGhzIiwib3V0cHV0RGltcyIsInJocyIsImtmIiwiZ2QiLCJFZiIsIlBmIiwiYmQiLCJ5ZCIsInpmIiwiX2QiLCJ3ZCIsIk9mIiwiRGYiLCJ2ZCIsIiRkIiwieGQiLCJCZiIsIlNkIiwiVGQiLCJJZCIsImJhdGNoRGltcyIsIk1mIiwiUmYiLCJDZCIsIkFkIiwia2QiLCJVZiIsIk5mIiwiRWQiLCJQZCIsInpkIiwiVmYiLCJXZiIsIk9kIiwiRGQiLCJCZCIsImx0IiwiX3QiLCJVdCIsIk50IiwiTGYiLCJHZiIsIkhmIiwiRmYiLCJxZiIsIktmIiwiamYiLCJZZiIsIk1kIiwiUmQiLCJVZCIsImFsaWduQ29ybmVycyIsInBhZGRpbmdNb2RlIiwiQmUiLCJYZiIsIlZkIiwiTmQiLCJKZiIsInRyIiwiV2QiLCJTbyIsImVoIiwidGgiLCJyaCIsIm5oIiwiVG8iLCJMZCIsIkdkIiwiSW8iLCJvaCIsImloIiwiSGQiLCJGZCIsInFkIiwiS2QiLCJhaCIsInNoIiwiamQiLCJZZCIsInVoIiwiZGgiLCJaZCIsIlFkIiwibGgiLCJYZCIsIkpkIiwiY2giLCJwaCIsIm1oIiwiZWwiLCJ0bCIsInJsIiwiaXNWZW5kb3IiLCJmaCIsImhoIiwiZ2giLCJiaCIsInloIiwiX2giLCJ3aCIsInZoIiwibmwiLCJvbCIsInRuIiwiaWwiLCJhbCIsInNsIiwidWwiLCIkaCIsInhoIiwiZGwiLCJsbCIsImNsIiwicGwiLCJtbCIsImZsIiwiaGwiLCJnbCIsImJsIiwieWwiLCJfbCIsIndsIiwidmwiLCJjZWlsTW9kZSIsImNvdW50SW5jbHVkZVBhZCIsInN0b3JhZ2VPcmRlciIsIlRoIiwiSWgiLCIkbCIsInhsIiwiU2wiLCJDaCIsIkFoIiwiVGwiLCJJbCIsImtoIiwiRWgiLCJDbCIsIkFsIiwia2wiLCJyZWR1Y3Rpb24iLCJQaCIsInpoIiwiT2giLCJEaCIsIkJoIiwiTWgiLCJSaCIsIlVoIiwiTmgiLCJWaCIsIldoIiwiRWwiLCJMaCIsIkdoIiwiSGgiLCJGaCIsInFoIiwiUGwiLCJ6bCIsIk9sIiwicm91bmQiLCJNQVhfVkFMVUUiLCJNSU5fVkFMVUUiLCJjdXN0b21EYXRhQnVmZmVyIiwiS2giLCJqaCIsIkRsIiwiQmwiLCJZaCIsIlpoIiwiTWwiLCJSbCIsIlFoIiwicm4iLCJYaCIsIlVsIiwiSmgiLCJlZyIsIk5sIiwiVmwiLCJXbCIsInNpZ24iLCJ0ZyIsInJnIiwiTGwiLCJHbCIsIkhsIiwiRmwiLCJuZyIsIm9nIiwiaWciLCJxbCIsIktsIiwiYWciLCJzZyIsImpsIiwiWWwiLCJabCIsIlFsIiwibm4iLCJYbCIsImdldEFydGlmYWN0IiwicmVwbyIsInNldEFydGlmYWN0IiwicHJvZ3JhbUluZm8iLCJnZXRDb21wdXRlUGFzc0VuY29kZXIiLCJ3cml0ZVRpbWVzdGFtcCIsInBlbmRpbmdEaXNwYXRjaE51bWJlciIsImJpbmRpbmciLCJyZXNvdXJjZSIsImNyZWF0ZUJpbmRHcm91cCIsImxheW91dCIsImNvbXB1dGVQaXBlbGluZSIsImdldEJpbmRHcm91cExheW91dCIsImxhYmVsIiwia2VybmVsSWQiLCJjdXJyZW50S2VybmVsSWQiLCJiaW5kR3JvdXAiLCJzZXRQaXBlbGluZSIsInNldEJpbmRHcm91cCIsImRpc3BhdGNoV29ya2dyb3VwcyIsIm1heERpc3BhdGNoTnVtYmVyIiwicXVlcnlUeXBlIiwiYnVpbGQiLCJmZWF0dXJlIiwiZXh0ZW5zaW9uIiwiZmVhdHVyZXMiLCJjcmVhdGVTaGFkZXJNb2R1bGUiLCJjcmVhdGVDb21wdXRlUGlwZWxpbmUiLCJlbnRyeVBvaW50IiwidW5pZm9ybVZhcmlhYmxlc0luZm8iLCJub3JtYWxpemVEaXNwYXRjaEdyb3VwU2l6ZSIsIm1heENvbXB1dGVXb3JrZ3JvdXBzUGVyRGltZW5zaW9uIiwiY2JydCIsImF0dHJpYnV0ZXNCb3VuZCIsInVnIiwiZGciLCJDbyIsIkFvIiwib24iLCJKbCIsImFyY2hpdGVjdHVyZSIsInZlbmRvciIsInN1Ymdyb3Vwc1N1cHBvcnRlZCIsInN1Ymdyb3Vwc0YxNlN1cHBvcnRlZCIsIm1pblN1Ymdyb3VwU2l6ZSIsIm1heFN1Ymdyb3VwU2l6ZSIsInN1Ymdyb3VwU2l6ZVJhbmdlIiwiY3VycmVudEtlcm5lbEN1c3RvbURhdGEiLCJpbml0aWFsaXplIiwicmVxdWlyZWRMaW1pdHMiLCJtYXhDb21wdXRlV29ya2dyb3VwU3RvcmFnZVNpemUiLCJtYXhTdG9yYWdlQnVmZmVyQmluZGluZ1NpemUiLCJtYXhCdWZmZXJTaXplIiwicmVxdWlyZWRGZWF0dXJlcyIsInJlcXVlc3REZXZpY2UiLCJkZXZpY2VJbmZvIiwiaW5mbyIsInJlcXVlc3RBZGFwdGVySW5mbyIsImdwdURhdGFNYW5hZ2VyIiwicHJvZ3JhbU1hbmFnZXIiLCJrZXJuZWxzIiwia2VybmVsUGVyc2lzdGVudERhdGEiLCJkZWJ1ZyIsIm9udW5jYXB0dXJlZGVycm9yIiwiR1BVVmFsaWRhdGlvbkVycm9yIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJzZXRRdWVyeVR5cGUiLCJxdWVyeVNldCIsImNvbW1hbmRFbmNvZGVyIiwiY29tcHV0ZVBhc3NFbmNvZGVyIiwidGltZXN0YW1wV3JpdGVzIiwiYmVnaW5uaW5nT2ZQYXNzV3JpdGVJbmRleCIsImVuZE9mUGFzc1dyaXRlSW5kZXgiLCJiZWdpbkNvbXB1dGVQYXNzIiwiZW5kIiwicmVzb2x2ZVF1ZXJ5U2V0IiwicXVlcnlSZXNvbHZlQnVmZmVyIiwicGVuZGluZ1F1ZXJpZXMiLCJwZW5kaW5nS2VybmVscyIsImtlcm5lbFR5cGUiLCJrZXJuZWxOYW1lIiwicHJvZ3JhbU5hbWUiLCJpbnB1dFRlbnNvclZpZXdzIiwib3V0cHV0VGVuc29yVmlld3MiLCJxdWVyeVRpbWVCYXNlIiwicHJvZmlsaW5nIiwib25kYXRhIiwidmVyc2lvbiIsImlucHV0c01ldGFkYXRhIiwib3V0cHV0c01ldGFkYXRhIiwic3RhcnRUaW1lIiwiZW5kVGltZSIsInRlbXBvcmFyeURhdGEiLCJ3cml0ZUJ1ZmZlciIsIm9mZnNldCIsImNhcHR1cmVkUGVuZGluZ0tlcm5lbHMiLCJhbGxvYyIsImZyZWUiLCJjcmVhdGVLZXJuZWwiLCJrZXJuZWxFbnRyeSIsImF0dHJpYnV0ZXMiLCJyZWxlYXNlS2VybmVsIiwiY29tcHV0ZUtlcm5lbCIsInB1c2hFcnJvclNjb3BlIiwicG9wRXJyb3JTY29wZSIsInNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nIiwidW5yZWdpc3RlckJ1ZmZlcnMiLCJjcmVhdGVRdWVyeVNldCIsIlFVRVJZX1JFU09MVkUiLCJjYXB0dXJlQmVnaW4iLCJjYXB0dXJlRW5kIiwicmVwbGF5IiwibGciLCJjZyIsImFuIiwic24iLCJrbyIsInRlbnNvclNoYXBlIiwid3JpdGUiLCJtbENvbnRleHQiLCJ3cml0ZVRlbnNvciIsInJlYWRUZW5zb3IiLCJjYW5SZXVzZVRlbnNvciIsImNvbnRleHQiLCJ0ZW5zb3JXcmFwcGVyIiwid3JhcHBlciIsInJlbGVhc2VUZW5zb3IiLCJ0ZW5zb3JNYW5hZ2VyIiwiZW5zdXJlVGVuc29yIiwiYWN0aXZlVXBsb2FkIiwiTUxUZW5zb3JVc2FnZSIsIldSSVRFIiwiZ2V0Q2FjaGVkVGVuc29yIiwicmVzZXJ2ZVRlbnNvcklkIiwidGVuc29yVHJhY2tlcnNCeUlkIiwicmVsZWFzZVRlbnNvcklkIiwiY3VycmVudENvbnRleHQiLCJyZWxlYXNlVGVuc29yc0ZvclNlc3Npb24iLCJmcmVlVGVuc29ycyIsInJlZ2lzdGVyVGVuc29yIiwiZXh0ZXJuYWxUZW5zb3JzIiwiY3JlYXRlVGVuc29yIiwiZGltZW5zaW9ucyIsInJlYWRhYmxlIiwicGciLCJ1biIsImFjdGl2ZVNlc3Npb25JZCIsIkdQVURldmljZSIsIm1sQ29udGV4dENhY2hlIiwiZmluZEluZGV4IiwiZ3B1RGV2aWNlIiwiY3JlYXRlQ29udGV4dCIsImdldE1MQ29udGV4dCIsIm1sQ29udGV4dEJ5U2Vzc2lvbklkIiwic2Vzc2lvbklkc0J5TUxDb250ZXh0IiwidXBsb2FkVGVuc29yIiwic2hvdWxkVHJhbnNmZXJUb01MVGVuc29yIiwiZG93bmxvYWRUZW5zb3IiLCJjb25zdGFudCIsIm1nIiwicnIiLCJFbyIsImN1c3RvbURhdGFPZmZzZXQiLCJjdXN0b21EYXRhU2l6ZSIsIm91dHB1dCIsIm9wS2VybmVsQ29udGV4dCIsImZnIiwiUHQiLCJoZyIsInVjIiwiZ3B1IiwiYWRhcHRlciIsInBvd2VyUHJlZmVyZW5jZSIsImZvcmNlRmFsbGJhY2tBZGFwdGVyIiwicmVxdWVzdEFkYXB0ZXIiLCJleHRlcm5hbERhdGEiLCJwYXRoIiwicHJlZmVycmVkT3V0cHV0TG9jYXRpb24iLCJoYW5kbGUiLCJvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnMiLCJvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNFbmNvZGVkIiwienQiLCJMZSIsIm5yIiwibG4iLCJjbiIsImRuIiwiUG8iLCJ6byIsIlZ0IiwiV3QiLCJiZyIsIk9vIiwiZ2MiLCJ5ZyIsInBuIiwiZmV0Y2hNb2RlbEFuZENvcHlUb1dhc21NZW1vcnkiLCJsb2FkTW9kZWwiLCJfYyIsIk9ubnhydW50aW1lV2ViQXNzZW1ibHlCYWNrZW5kIiwibW4iLCJpbml0aWFsaXplRmxhZ3MiLCJ5YyIsIndhc21CYWNrZW5kIiwiX2ciLCJ3YyIsInNpbWQiLCJjcHVzIiwiJDEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/onnxruntime-web/dist/ort.bundle.min.mjs?3f47\n"));

/***/ })

}]);