/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/page"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Famityadav%2FDesktop%2FText-Behind%20Image%2Fapp%2Fpage.tsx&server=false!":
/*!*************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Famityadav%2FDesktop%2FText-Behind%20Image%2Fapp%2Fpage.tsx&server=false! ***!
  \*************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/page.tsx */ \"(app-pages-browser)/./app/page.tsx\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lMkZVc2VycyUyRmFtaXR5YWRhdiUyRkRlc2t0b3AlMkZUZXh0LUJlaGluZCUyMEltYWdlJTJGYXBwJTJGcGFnZS50c3gmc2VydmVyPWZhbHNlISIsIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvPzBhZGIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvVXNlcnMvYW1pdHlhZGF2L0Rlc2t0b3AvVGV4dC1CZWhpbmQgSW1hZ2UvYXBwL3BhZ2UudHN4XCIpIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Famityadav%2FDesktop%2FText-Behind%20Image%2Fapp%2Fpage.tsx&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/api/image.js":
/*!*********************************************!*\
  !*** ./node_modules/next/dist/api/image.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* reexport default from dynamic */ _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0___default.a; }\n/* harmony export */ });\n/* harmony import */ var _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../shared/lib/image-external */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-external.js\");\n/* harmony import */ var _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _shared_lib_image_external__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n //# sourceMappingURL=image.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL2ltYWdlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUF1RDtBQUNWLENBRTdDLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2FwaS9pbWFnZS5qcz9kMTAxIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IGRlZmF1bHQgfSBmcm9tIFwiLi4vc2hhcmVkL2xpYi9pbWFnZS1leHRlcm5hbFwiO1xuZXhwb3J0ICogZnJvbSBcIi4uL3NoYXJlZC9saWIvaW1hZ2UtZXh0ZXJuYWxcIjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1hZ2UuanMubWFwIl0sIm5hbWVzIjpbImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/api/image.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/process.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _global_process, _global_process1;\nmodule.exports = ((_global_process = __webpack_require__.g.process) == null ? void 0 : _global_process.env) && typeof ((_global_process1 = __webpack_require__.g.process) == null ? void 0 : _global_process1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(/*! next/dist/compiled/process */ \"(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\"); //# sourceMappingURL=process.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxpQkFBaUJDO0FBQ3JCQyxPQUFPQyxPQUFPLEdBQUcsQ0FBQyxDQUFDSCxrQkFBa0JJLHFCQUFNQSxDQUFDQyxPQUFPLEtBQUssT0FBTyxLQUFLLElBQUlMLGdCQUFnQk0sR0FBRyxLQUFLLE9BQVEsRUFBQ0wsbUJBQW1CRyxxQkFBTUEsQ0FBQ0MsT0FBTyxLQUFLLE9BQU8sS0FBSyxJQUFJSixpQkFBaUJLLEdBQUcsTUFBTSxXQUFXRixxQkFBTUEsQ0FBQ0MsT0FBTyxHQUFHRSxtQkFBT0EsQ0FBQyw0R0FBNEIsR0FFelAsbUNBQW1DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL3Byb2Nlc3MuanM/Y2E2NSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfZ2xvYmFsX3Byb2Nlc3MsIF9nbG9iYWxfcHJvY2VzczE7XG5tb2R1bGUuZXhwb3J0cyA9ICgoX2dsb2JhbF9wcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MuZW52KSAmJiB0eXBlb2YgKChfZ2xvYmFsX3Byb2Nlc3MxID0gZ2xvYmFsLnByb2Nlc3MpID09IG51bGwgPyB2b2lkIDAgOiBfZ2xvYmFsX3Byb2Nlc3MxLmVudikgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwucHJvY2VzcyA6IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzc1wiKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvY2Vzcy5qcy5tYXAiXSwibmFtZXMiOlsiX2dsb2JhbF9wcm9jZXNzIiwiX2dsb2JhbF9wcm9jZXNzMSIsIm1vZHVsZSIsImV4cG9ydHMiLCJnbG9iYWwiLCJwcm9jZXNzIiwiZW52IiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/compiled/buffer/index.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("var __dirname = \"/\";\n\n(function() {\n    var e = {\n        675: function(e, r) {\n            \"use strict\";\n            r.byteLength = byteLength;\n            r.toByteArray = toByteArray;\n            r.fromByteArray = fromByteArray;\n            var t = [];\n            var f = [];\n            var n = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\n            var i = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n            for(var o = 0, u = i.length; o < u; ++o){\n                t[o] = i[o];\n                f[i.charCodeAt(o)] = o;\n            }\n            f[\"-\".charCodeAt(0)] = 62;\n            f[\"_\".charCodeAt(0)] = 63;\n            function getLens(e) {\n                var r = e.length;\n                if (r % 4 > 0) {\n                    throw new Error(\"Invalid string. Length must be a multiple of 4\");\n                }\n                var t = e.indexOf(\"=\");\n                if (t === -1) t = r;\n                var f = t === r ? 0 : 4 - t % 4;\n                return [\n                    t,\n                    f\n                ];\n            }\n            function byteLength(e) {\n                var r = getLens(e);\n                var t = r[0];\n                var f = r[1];\n                return (t + f) * 3 / 4 - f;\n            }\n            function _byteLength(e, r, t) {\n                return (r + t) * 3 / 4 - t;\n            }\n            function toByteArray(e) {\n                var r;\n                var t = getLens(e);\n                var i = t[0];\n                var o = t[1];\n                var u = new n(_byteLength(e, i, o));\n                var a = 0;\n                var s = o > 0 ? i - 4 : i;\n                var h;\n                for(h = 0; h < s; h += 4){\n                    r = f[e.charCodeAt(h)] << 18 | f[e.charCodeAt(h + 1)] << 12 | f[e.charCodeAt(h + 2)] << 6 | f[e.charCodeAt(h + 3)];\n                    u[a++] = r >> 16 & 255;\n                    u[a++] = r >> 8 & 255;\n                    u[a++] = r & 255;\n                }\n                if (o === 2) {\n                    r = f[e.charCodeAt(h)] << 2 | f[e.charCodeAt(h + 1)] >> 4;\n                    u[a++] = r & 255;\n                }\n                if (o === 1) {\n                    r = f[e.charCodeAt(h)] << 10 | f[e.charCodeAt(h + 1)] << 4 | f[e.charCodeAt(h + 2)] >> 2;\n                    u[a++] = r >> 8 & 255;\n                    u[a++] = r & 255;\n                }\n                return u;\n            }\n            function tripletToBase64(e) {\n                return t[e >> 18 & 63] + t[e >> 12 & 63] + t[e >> 6 & 63] + t[e & 63];\n            }\n            function encodeChunk(e, r, t) {\n                var f;\n                var n = [];\n                for(var i = r; i < t; i += 3){\n                    f = (e[i] << 16 & 16711680) + (e[i + 1] << 8 & 65280) + (e[i + 2] & 255);\n                    n.push(tripletToBase64(f));\n                }\n                return n.join(\"\");\n            }\n            function fromByteArray(e) {\n                var r;\n                var f = e.length;\n                var n = f % 3;\n                var i = [];\n                var o = 16383;\n                for(var u = 0, a = f - n; u < a; u += o){\n                    i.push(encodeChunk(e, u, u + o > a ? a : u + o));\n                }\n                if (n === 1) {\n                    r = e[f - 1];\n                    i.push(t[r >> 2] + t[r << 4 & 63] + \"==\");\n                } else if (n === 2) {\n                    r = (e[f - 2] << 8) + e[f - 1];\n                    i.push(t[r >> 10] + t[r >> 4 & 63] + t[r << 2 & 63] + \"=\");\n                }\n                return i.join(\"\");\n            }\n        },\n        72: function(e, r, t) {\n            \"use strict\";\n            /*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */ var f = t(675);\n            var n = t(783);\n            var i = typeof Symbol === \"function\" && typeof Symbol.for === \"function\" ? Symbol.for(\"nodejs.util.inspect.custom\") : null;\n            r.Buffer = Buffer;\n            r.SlowBuffer = SlowBuffer;\n            r.INSPECT_MAX_BYTES = 50;\n            var o = 2147483647;\n            r.kMaxLength = o;\n            Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();\n            if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== \"undefined\" && typeof console.error === \"function\") {\n                console.error(\"This browser lacks typed array (Uint8Array) support which is required by \" + \"`buffer` v5.x. Use `buffer` v4.x if you require old browser support.\");\n            }\n            function typedArraySupport() {\n                try {\n                    var e = new Uint8Array(1);\n                    var r = {\n                        foo: function() {\n                            return 42;\n                        }\n                    };\n                    Object.setPrototypeOf(r, Uint8Array.prototype);\n                    Object.setPrototypeOf(e, r);\n                    return e.foo() === 42;\n                } catch (e) {\n                    return false;\n                }\n            }\n            Object.defineProperty(Buffer.prototype, \"parent\", {\n                enumerable: true,\n                get: function() {\n                    if (!Buffer.isBuffer(this)) return undefined;\n                    return this.buffer;\n                }\n            });\n            Object.defineProperty(Buffer.prototype, \"offset\", {\n                enumerable: true,\n                get: function() {\n                    if (!Buffer.isBuffer(this)) return undefined;\n                    return this.byteOffset;\n                }\n            });\n            function createBuffer(e) {\n                if (e > o) {\n                    throw new RangeError('The value \"' + e + '\" is invalid for option \"size\"');\n                }\n                var r = new Uint8Array(e);\n                Object.setPrototypeOf(r, Buffer.prototype);\n                return r;\n            }\n            function Buffer(e, r, t) {\n                if (typeof e === \"number\") {\n                    if (typeof r === \"string\") {\n                        throw new TypeError('The \"string\" argument must be of type string. Received type number');\n                    }\n                    return allocUnsafe(e);\n                }\n                return from(e, r, t);\n            }\n            Buffer.poolSize = 8192;\n            function from(e, r, t) {\n                if (typeof e === \"string\") {\n                    return fromString(e, r);\n                }\n                if (ArrayBuffer.isView(e)) {\n                    return fromArrayLike(e);\n                }\n                if (e == null) {\n                    throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, \" + \"or Array-like Object. Received type \" + typeof e);\n                }\n                if (isInstance(e, ArrayBuffer) || e && isInstance(e.buffer, ArrayBuffer)) {\n                    return fromArrayBuffer(e, r, t);\n                }\n                if (typeof SharedArrayBuffer !== \"undefined\" && (isInstance(e, SharedArrayBuffer) || e && isInstance(e.buffer, SharedArrayBuffer))) {\n                    return fromArrayBuffer(e, r, t);\n                }\n                if (typeof e === \"number\") {\n                    throw new TypeError('The \"value\" argument must not be of type number. Received type number');\n                }\n                var f = e.valueOf && e.valueOf();\n                if (f != null && f !== e) {\n                    return Buffer.from(f, r, t);\n                }\n                var n = fromObject(e);\n                if (n) return n;\n                if (typeof Symbol !== \"undefined\" && Symbol.toPrimitive != null && typeof e[Symbol.toPrimitive] === \"function\") {\n                    return Buffer.from(e[Symbol.toPrimitive](\"string\"), r, t);\n                }\n                throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, \" + \"or Array-like Object. Received type \" + typeof e);\n            }\n            Buffer.from = function(e, r, t) {\n                return from(e, r, t);\n            };\n            Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);\n            Object.setPrototypeOf(Buffer, Uint8Array);\n            function assertSize(e) {\n                if (typeof e !== \"number\") {\n                    throw new TypeError('\"size\" argument must be of type number');\n                } else if (e < 0) {\n                    throw new RangeError('The value \"' + e + '\" is invalid for option \"size\"');\n                }\n            }\n            function alloc(e, r, t) {\n                assertSize(e);\n                if (e <= 0) {\n                    return createBuffer(e);\n                }\n                if (r !== undefined) {\n                    return typeof t === \"string\" ? createBuffer(e).fill(r, t) : createBuffer(e).fill(r);\n                }\n                return createBuffer(e);\n            }\n            Buffer.alloc = function(e, r, t) {\n                return alloc(e, r, t);\n            };\n            function allocUnsafe(e) {\n                assertSize(e);\n                return createBuffer(e < 0 ? 0 : checked(e) | 0);\n            }\n            Buffer.allocUnsafe = function(e) {\n                return allocUnsafe(e);\n            };\n            Buffer.allocUnsafeSlow = function(e) {\n                return allocUnsafe(e);\n            };\n            function fromString(e, r) {\n                if (typeof r !== \"string\" || r === \"\") {\n                    r = \"utf8\";\n                }\n                if (!Buffer.isEncoding(r)) {\n                    throw new TypeError(\"Unknown encoding: \" + r);\n                }\n                var t = byteLength(e, r) | 0;\n                var f = createBuffer(t);\n                var n = f.write(e, r);\n                if (n !== t) {\n                    f = f.slice(0, n);\n                }\n                return f;\n            }\n            function fromArrayLike(e) {\n                var r = e.length < 0 ? 0 : checked(e.length) | 0;\n                var t = createBuffer(r);\n                for(var f = 0; f < r; f += 1){\n                    t[f] = e[f] & 255;\n                }\n                return t;\n            }\n            function fromArrayBuffer(e, r, t) {\n                if (r < 0 || e.byteLength < r) {\n                    throw new RangeError('\"offset\" is outside of buffer bounds');\n                }\n                if (e.byteLength < r + (t || 0)) {\n                    throw new RangeError('\"length\" is outside of buffer bounds');\n                }\n                var f;\n                if (r === undefined && t === undefined) {\n                    f = new Uint8Array(e);\n                } else if (t === undefined) {\n                    f = new Uint8Array(e, r);\n                } else {\n                    f = new Uint8Array(e, r, t);\n                }\n                Object.setPrototypeOf(f, Buffer.prototype);\n                return f;\n            }\n            function fromObject(e) {\n                if (Buffer.isBuffer(e)) {\n                    var r = checked(e.length) | 0;\n                    var t = createBuffer(r);\n                    if (t.length === 0) {\n                        return t;\n                    }\n                    e.copy(t, 0, 0, r);\n                    return t;\n                }\n                if (e.length !== undefined) {\n                    if (typeof e.length !== \"number\" || numberIsNaN(e.length)) {\n                        return createBuffer(0);\n                    }\n                    return fromArrayLike(e);\n                }\n                if (e.type === \"Buffer\" && Array.isArray(e.data)) {\n                    return fromArrayLike(e.data);\n                }\n            }\n            function checked(e) {\n                if (e >= o) {\n                    throw new RangeError(\"Attempt to allocate Buffer larger than maximum \" + \"size: 0x\" + o.toString(16) + \" bytes\");\n                }\n                return e | 0;\n            }\n            function SlowBuffer(e) {\n                if (+e != e) {\n                    e = 0;\n                }\n                return Buffer.alloc(+e);\n            }\n            Buffer.isBuffer = function isBuffer(e) {\n                return e != null && e._isBuffer === true && e !== Buffer.prototype;\n            };\n            Buffer.compare = function compare(e, r) {\n                if (isInstance(e, Uint8Array)) e = Buffer.from(e, e.offset, e.byteLength);\n                if (isInstance(r, Uint8Array)) r = Buffer.from(r, r.offset, r.byteLength);\n                if (!Buffer.isBuffer(e) || !Buffer.isBuffer(r)) {\n                    throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array');\n                }\n                if (e === r) return 0;\n                var t = e.length;\n                var f = r.length;\n                for(var n = 0, i = Math.min(t, f); n < i; ++n){\n                    if (e[n] !== r[n]) {\n                        t = e[n];\n                        f = r[n];\n                        break;\n                    }\n                }\n                if (t < f) return -1;\n                if (f < t) return 1;\n                return 0;\n            };\n            Buffer.isEncoding = function isEncoding(e) {\n                switch(String(e).toLowerCase()){\n                    case \"hex\":\n                    case \"utf8\":\n                    case \"utf-8\":\n                    case \"ascii\":\n                    case \"latin1\":\n                    case \"binary\":\n                    case \"base64\":\n                    case \"ucs2\":\n                    case \"ucs-2\":\n                    case \"utf16le\":\n                    case \"utf-16le\":\n                        return true;\n                    default:\n                        return false;\n                }\n            };\n            Buffer.concat = function concat(e, r) {\n                if (!Array.isArray(e)) {\n                    throw new TypeError('\"list\" argument must be an Array of Buffers');\n                }\n                if (e.length === 0) {\n                    return Buffer.alloc(0);\n                }\n                var t;\n                if (r === undefined) {\n                    r = 0;\n                    for(t = 0; t < e.length; ++t){\n                        r += e[t].length;\n                    }\n                }\n                var f = Buffer.allocUnsafe(r);\n                var n = 0;\n                for(t = 0; t < e.length; ++t){\n                    var i = e[t];\n                    if (isInstance(i, Uint8Array)) {\n                        i = Buffer.from(i);\n                    }\n                    if (!Buffer.isBuffer(i)) {\n                        throw new TypeError('\"list\" argument must be an Array of Buffers');\n                    }\n                    i.copy(f, n);\n                    n += i.length;\n                }\n                return f;\n            };\n            function byteLength(e, r) {\n                if (Buffer.isBuffer(e)) {\n                    return e.length;\n                }\n                if (ArrayBuffer.isView(e) || isInstance(e, ArrayBuffer)) {\n                    return e.byteLength;\n                }\n                if (typeof e !== \"string\") {\n                    throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' + \"Received type \" + typeof e);\n                }\n                var t = e.length;\n                var f = arguments.length > 2 && arguments[2] === true;\n                if (!f && t === 0) return 0;\n                var n = false;\n                for(;;){\n                    switch(r){\n                        case \"ascii\":\n                        case \"latin1\":\n                        case \"binary\":\n                            return t;\n                        case \"utf8\":\n                        case \"utf-8\":\n                            return utf8ToBytes(e).length;\n                        case \"ucs2\":\n                        case \"ucs-2\":\n                        case \"utf16le\":\n                        case \"utf-16le\":\n                            return t * 2;\n                        case \"hex\":\n                            return t >>> 1;\n                        case \"base64\":\n                            return base64ToBytes(e).length;\n                        default:\n                            if (n) {\n                                return f ? -1 : utf8ToBytes(e).length;\n                            }\n                            r = (\"\" + r).toLowerCase();\n                            n = true;\n                    }\n                }\n            }\n            Buffer.byteLength = byteLength;\n            function slowToString(e, r, t) {\n                var f = false;\n                if (r === undefined || r < 0) {\n                    r = 0;\n                }\n                if (r > this.length) {\n                    return \"\";\n                }\n                if (t === undefined || t > this.length) {\n                    t = this.length;\n                }\n                if (t <= 0) {\n                    return \"\";\n                }\n                t >>>= 0;\n                r >>>= 0;\n                if (t <= r) {\n                    return \"\";\n                }\n                if (!e) e = \"utf8\";\n                while(true){\n                    switch(e){\n                        case \"hex\":\n                            return hexSlice(this, r, t);\n                        case \"utf8\":\n                        case \"utf-8\":\n                            return utf8Slice(this, r, t);\n                        case \"ascii\":\n                            return asciiSlice(this, r, t);\n                        case \"latin1\":\n                        case \"binary\":\n                            return latin1Slice(this, r, t);\n                        case \"base64\":\n                            return base64Slice(this, r, t);\n                        case \"ucs2\":\n                        case \"ucs-2\":\n                        case \"utf16le\":\n                        case \"utf-16le\":\n                            return utf16leSlice(this, r, t);\n                        default:\n                            if (f) throw new TypeError(\"Unknown encoding: \" + e);\n                            e = (e + \"\").toLowerCase();\n                            f = true;\n                    }\n                }\n            }\n            Buffer.prototype._isBuffer = true;\n            function swap(e, r, t) {\n                var f = e[r];\n                e[r] = e[t];\n                e[t] = f;\n            }\n            Buffer.prototype.swap16 = function swap16() {\n                var e = this.length;\n                if (e % 2 !== 0) {\n                    throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n                }\n                for(var r = 0; r < e; r += 2){\n                    swap(this, r, r + 1);\n                }\n                return this;\n            };\n            Buffer.prototype.swap32 = function swap32() {\n                var e = this.length;\n                if (e % 4 !== 0) {\n                    throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n                }\n                for(var r = 0; r < e; r += 4){\n                    swap(this, r, r + 3);\n                    swap(this, r + 1, r + 2);\n                }\n                return this;\n            };\n            Buffer.prototype.swap64 = function swap64() {\n                var e = this.length;\n                if (e % 8 !== 0) {\n                    throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n                }\n                for(var r = 0; r < e; r += 8){\n                    swap(this, r, r + 7);\n                    swap(this, r + 1, r + 6);\n                    swap(this, r + 2, r + 5);\n                    swap(this, r + 3, r + 4);\n                }\n                return this;\n            };\n            Buffer.prototype.toString = function toString() {\n                var e = this.length;\n                if (e === 0) return \"\";\n                if (arguments.length === 0) return utf8Slice(this, 0, e);\n                return slowToString.apply(this, arguments);\n            };\n            Buffer.prototype.toLocaleString = Buffer.prototype.toString;\n            Buffer.prototype.equals = function equals(e) {\n                if (!Buffer.isBuffer(e)) throw new TypeError(\"Argument must be a Buffer\");\n                if (this === e) return true;\n                return Buffer.compare(this, e) === 0;\n            };\n            Buffer.prototype.inspect = function inspect() {\n                var e = \"\";\n                var t = r.INSPECT_MAX_BYTES;\n                e = this.toString(\"hex\", 0, t).replace(/(.{2})/g, \"$1 \").trim();\n                if (this.length > t) e += \" ... \";\n                return \"<Buffer \" + e + \">\";\n            };\n            if (i) {\n                Buffer.prototype[i] = Buffer.prototype.inspect;\n            }\n            Buffer.prototype.compare = function compare(e, r, t, f, n) {\n                if (isInstance(e, Uint8Array)) {\n                    e = Buffer.from(e, e.offset, e.byteLength);\n                }\n                if (!Buffer.isBuffer(e)) {\n                    throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. ' + \"Received type \" + typeof e);\n                }\n                if (r === undefined) {\n                    r = 0;\n                }\n                if (t === undefined) {\n                    t = e ? e.length : 0;\n                }\n                if (f === undefined) {\n                    f = 0;\n                }\n                if (n === undefined) {\n                    n = this.length;\n                }\n                if (r < 0 || t > e.length || f < 0 || n > this.length) {\n                    throw new RangeError(\"out of range index\");\n                }\n                if (f >= n && r >= t) {\n                    return 0;\n                }\n                if (f >= n) {\n                    return -1;\n                }\n                if (r >= t) {\n                    return 1;\n                }\n                r >>>= 0;\n                t >>>= 0;\n                f >>>= 0;\n                n >>>= 0;\n                if (this === e) return 0;\n                var i = n - f;\n                var o = t - r;\n                var u = Math.min(i, o);\n                var a = this.slice(f, n);\n                var s = e.slice(r, t);\n                for(var h = 0; h < u; ++h){\n                    if (a[h] !== s[h]) {\n                        i = a[h];\n                        o = s[h];\n                        break;\n                    }\n                }\n                if (i < o) return -1;\n                if (o < i) return 1;\n                return 0;\n            };\n            function bidirectionalIndexOf(e, r, t, f, n) {\n                if (e.length === 0) return -1;\n                if (typeof t === \"string\") {\n                    f = t;\n                    t = 0;\n                } else if (t > 2147483647) {\n                    t = 2147483647;\n                } else if (t < -2147483648) {\n                    t = -2147483648;\n                }\n                t = +t;\n                if (numberIsNaN(t)) {\n                    t = n ? 0 : e.length - 1;\n                }\n                if (t < 0) t = e.length + t;\n                if (t >= e.length) {\n                    if (n) return -1;\n                    else t = e.length - 1;\n                } else if (t < 0) {\n                    if (n) t = 0;\n                    else return -1;\n                }\n                if (typeof r === \"string\") {\n                    r = Buffer.from(r, f);\n                }\n                if (Buffer.isBuffer(r)) {\n                    if (r.length === 0) {\n                        return -1;\n                    }\n                    return arrayIndexOf(e, r, t, f, n);\n                } else if (typeof r === \"number\") {\n                    r = r & 255;\n                    if (typeof Uint8Array.prototype.indexOf === \"function\") {\n                        if (n) {\n                            return Uint8Array.prototype.indexOf.call(e, r, t);\n                        } else {\n                            return Uint8Array.prototype.lastIndexOf.call(e, r, t);\n                        }\n                    }\n                    return arrayIndexOf(e, [\n                        r\n                    ], t, f, n);\n                }\n                throw new TypeError(\"val must be string, number or Buffer\");\n            }\n            function arrayIndexOf(e, r, t, f, n) {\n                var i = 1;\n                var o = e.length;\n                var u = r.length;\n                if (f !== undefined) {\n                    f = String(f).toLowerCase();\n                    if (f === \"ucs2\" || f === \"ucs-2\" || f === \"utf16le\" || f === \"utf-16le\") {\n                        if (e.length < 2 || r.length < 2) {\n                            return -1;\n                        }\n                        i = 2;\n                        o /= 2;\n                        u /= 2;\n                        t /= 2;\n                    }\n                }\n                function read(e, r) {\n                    if (i === 1) {\n                        return e[r];\n                    } else {\n                        return e.readUInt16BE(r * i);\n                    }\n                }\n                var a;\n                if (n) {\n                    var s = -1;\n                    for(a = t; a < o; a++){\n                        if (read(e, a) === read(r, s === -1 ? 0 : a - s)) {\n                            if (s === -1) s = a;\n                            if (a - s + 1 === u) return s * i;\n                        } else {\n                            if (s !== -1) a -= a - s;\n                            s = -1;\n                        }\n                    }\n                } else {\n                    if (t + u > o) t = o - u;\n                    for(a = t; a >= 0; a--){\n                        var h = true;\n                        for(var c = 0; c < u; c++){\n                            if (read(e, a + c) !== read(r, c)) {\n                                h = false;\n                                break;\n                            }\n                        }\n                        if (h) return a;\n                    }\n                }\n                return -1;\n            }\n            Buffer.prototype.includes = function includes(e, r, t) {\n                return this.indexOf(e, r, t) !== -1;\n            };\n            Buffer.prototype.indexOf = function indexOf(e, r, t) {\n                return bidirectionalIndexOf(this, e, r, t, true);\n            };\n            Buffer.prototype.lastIndexOf = function lastIndexOf(e, r, t) {\n                return bidirectionalIndexOf(this, e, r, t, false);\n            };\n            function hexWrite(e, r, t, f) {\n                t = Number(t) || 0;\n                var n = e.length - t;\n                if (!f) {\n                    f = n;\n                } else {\n                    f = Number(f);\n                    if (f > n) {\n                        f = n;\n                    }\n                }\n                var i = r.length;\n                if (f > i / 2) {\n                    f = i / 2;\n                }\n                for(var o = 0; o < f; ++o){\n                    var u = parseInt(r.substr(o * 2, 2), 16);\n                    if (numberIsNaN(u)) return o;\n                    e[t + o] = u;\n                }\n                return o;\n            }\n            function utf8Write(e, r, t, f) {\n                return blitBuffer(utf8ToBytes(r, e.length - t), e, t, f);\n            }\n            function asciiWrite(e, r, t, f) {\n                return blitBuffer(asciiToBytes(r), e, t, f);\n            }\n            function latin1Write(e, r, t, f) {\n                return asciiWrite(e, r, t, f);\n            }\n            function base64Write(e, r, t, f) {\n                return blitBuffer(base64ToBytes(r), e, t, f);\n            }\n            function ucs2Write(e, r, t, f) {\n                return blitBuffer(utf16leToBytes(r, e.length - t), e, t, f);\n            }\n            Buffer.prototype.write = function write(e, r, t, f) {\n                if (r === undefined) {\n                    f = \"utf8\";\n                    t = this.length;\n                    r = 0;\n                } else if (t === undefined && typeof r === \"string\") {\n                    f = r;\n                    t = this.length;\n                    r = 0;\n                } else if (isFinite(r)) {\n                    r = r >>> 0;\n                    if (isFinite(t)) {\n                        t = t >>> 0;\n                        if (f === undefined) f = \"utf8\";\n                    } else {\n                        f = t;\n                        t = undefined;\n                    }\n                } else {\n                    throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\");\n                }\n                var n = this.length - r;\n                if (t === undefined || t > n) t = n;\n                if (e.length > 0 && (t < 0 || r < 0) || r > this.length) {\n                    throw new RangeError(\"Attempt to write outside buffer bounds\");\n                }\n                if (!f) f = \"utf8\";\n                var i = false;\n                for(;;){\n                    switch(f){\n                        case \"hex\":\n                            return hexWrite(this, e, r, t);\n                        case \"utf8\":\n                        case \"utf-8\":\n                            return utf8Write(this, e, r, t);\n                        case \"ascii\":\n                            return asciiWrite(this, e, r, t);\n                        case \"latin1\":\n                        case \"binary\":\n                            return latin1Write(this, e, r, t);\n                        case \"base64\":\n                            return base64Write(this, e, r, t);\n                        case \"ucs2\":\n                        case \"ucs-2\":\n                        case \"utf16le\":\n                        case \"utf-16le\":\n                            return ucs2Write(this, e, r, t);\n                        default:\n                            if (i) throw new TypeError(\"Unknown encoding: \" + f);\n                            f = (\"\" + f).toLowerCase();\n                            i = true;\n                    }\n                }\n            };\n            Buffer.prototype.toJSON = function toJSON() {\n                return {\n                    type: \"Buffer\",\n                    data: Array.prototype.slice.call(this._arr || this, 0)\n                };\n            };\n            function base64Slice(e, r, t) {\n                if (r === 0 && t === e.length) {\n                    return f.fromByteArray(e);\n                } else {\n                    return f.fromByteArray(e.slice(r, t));\n                }\n            }\n            function utf8Slice(e, r, t) {\n                t = Math.min(e.length, t);\n                var f = [];\n                var n = r;\n                while(n < t){\n                    var i = e[n];\n                    var o = null;\n                    var u = i > 239 ? 4 : i > 223 ? 3 : i > 191 ? 2 : 1;\n                    if (n + u <= t) {\n                        var a, s, h, c;\n                        switch(u){\n                            case 1:\n                                if (i < 128) {\n                                    o = i;\n                                }\n                                break;\n                            case 2:\n                                a = e[n + 1];\n                                if ((a & 192) === 128) {\n                                    c = (i & 31) << 6 | a & 63;\n                                    if (c > 127) {\n                                        o = c;\n                                    }\n                                }\n                                break;\n                            case 3:\n                                a = e[n + 1];\n                                s = e[n + 2];\n                                if ((a & 192) === 128 && (s & 192) === 128) {\n                                    c = (i & 15) << 12 | (a & 63) << 6 | s & 63;\n                                    if (c > 2047 && (c < 55296 || c > 57343)) {\n                                        o = c;\n                                    }\n                                }\n                                break;\n                            case 4:\n                                a = e[n + 1];\n                                s = e[n + 2];\n                                h = e[n + 3];\n                                if ((a & 192) === 128 && (s & 192) === 128 && (h & 192) === 128) {\n                                    c = (i & 15) << 18 | (a & 63) << 12 | (s & 63) << 6 | h & 63;\n                                    if (c > 65535 && c < 1114112) {\n                                        o = c;\n                                    }\n                                }\n                        }\n                    }\n                    if (o === null) {\n                        o = 65533;\n                        u = 1;\n                    } else if (o > 65535) {\n                        o -= 65536;\n                        f.push(o >>> 10 & 1023 | 55296);\n                        o = 56320 | o & 1023;\n                    }\n                    f.push(o);\n                    n += u;\n                }\n                return decodeCodePointsArray(f);\n            }\n            var u = 4096;\n            function decodeCodePointsArray(e) {\n                var r = e.length;\n                if (r <= u) {\n                    return String.fromCharCode.apply(String, e);\n                }\n                var t = \"\";\n                var f = 0;\n                while(f < r){\n                    t += String.fromCharCode.apply(String, e.slice(f, f += u));\n                }\n                return t;\n            }\n            function asciiSlice(e, r, t) {\n                var f = \"\";\n                t = Math.min(e.length, t);\n                for(var n = r; n < t; ++n){\n                    f += String.fromCharCode(e[n] & 127);\n                }\n                return f;\n            }\n            function latin1Slice(e, r, t) {\n                var f = \"\";\n                t = Math.min(e.length, t);\n                for(var n = r; n < t; ++n){\n                    f += String.fromCharCode(e[n]);\n                }\n                return f;\n            }\n            function hexSlice(e, r, t) {\n                var f = e.length;\n                if (!r || r < 0) r = 0;\n                if (!t || t < 0 || t > f) t = f;\n                var n = \"\";\n                for(var i = r; i < t; ++i){\n                    n += s[e[i]];\n                }\n                return n;\n            }\n            function utf16leSlice(e, r, t) {\n                var f = e.slice(r, t);\n                var n = \"\";\n                for(var i = 0; i < f.length; i += 2){\n                    n += String.fromCharCode(f[i] + f[i + 1] * 256);\n                }\n                return n;\n            }\n            Buffer.prototype.slice = function slice(e, r) {\n                var t = this.length;\n                e = ~~e;\n                r = r === undefined ? t : ~~r;\n                if (e < 0) {\n                    e += t;\n                    if (e < 0) e = 0;\n                } else if (e > t) {\n                    e = t;\n                }\n                if (r < 0) {\n                    r += t;\n                    if (r < 0) r = 0;\n                } else if (r > t) {\n                    r = t;\n                }\n                if (r < e) r = e;\n                var f = this.subarray(e, r);\n                Object.setPrototypeOf(f, Buffer.prototype);\n                return f;\n            };\n            function checkOffset(e, r, t) {\n                if (e % 1 !== 0 || e < 0) throw new RangeError(\"offset is not uint\");\n                if (e + r > t) throw new RangeError(\"Trying to access beyond buffer length\");\n            }\n            Buffer.prototype.readUIntLE = function readUIntLE(e, r, t) {\n                e = e >>> 0;\n                r = r >>> 0;\n                if (!t) checkOffset(e, r, this.length);\n                var f = this[e];\n                var n = 1;\n                var i = 0;\n                while(++i < r && (n *= 256)){\n                    f += this[e + i] * n;\n                }\n                return f;\n            };\n            Buffer.prototype.readUIntBE = function readUIntBE(e, r, t) {\n                e = e >>> 0;\n                r = r >>> 0;\n                if (!t) {\n                    checkOffset(e, r, this.length);\n                }\n                var f = this[e + --r];\n                var n = 1;\n                while(r > 0 && (n *= 256)){\n                    f += this[e + --r] * n;\n                }\n                return f;\n            };\n            Buffer.prototype.readUInt8 = function readUInt8(e, r) {\n                e = e >>> 0;\n                if (!r) checkOffset(e, 1, this.length);\n                return this[e];\n            };\n            Buffer.prototype.readUInt16LE = function readUInt16LE(e, r) {\n                e = e >>> 0;\n                if (!r) checkOffset(e, 2, this.length);\n                return this[e] | this[e + 1] << 8;\n            };\n            Buffer.prototype.readUInt16BE = function readUInt16BE(e, r) {\n                e = e >>> 0;\n                if (!r) checkOffset(e, 2, this.length);\n                return this[e] << 8 | this[e + 1];\n            };\n            Buffer.prototype.readUInt32LE = function readUInt32LE(e, r) {\n                e = e >>> 0;\n                if (!r) checkOffset(e, 4, this.length);\n                return (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216;\n            };\n            Buffer.prototype.readUInt32BE = function readUInt32BE(e, r) {\n                e = e >>> 0;\n                if (!r) checkOffset(e, 4, this.length);\n                return this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);\n            };\n            Buffer.prototype.readIntLE = function readIntLE(e, r, t) {\n                e = e >>> 0;\n                r = r >>> 0;\n                if (!t) checkOffset(e, r, this.length);\n                var f = this[e];\n                var n = 1;\n                var i = 0;\n                while(++i < r && (n *= 256)){\n                    f += this[e + i] * n;\n                }\n                n *= 128;\n                if (f >= n) f -= Math.pow(2, 8 * r);\n                return f;\n            };\n            Buffer.prototype.readIntBE = function readIntBE(e, r, t) {\n                e = e >>> 0;\n                r = r >>> 0;\n                if (!t) checkOffset(e, r, this.length);\n                var f = r;\n                var n = 1;\n                var i = this[e + --f];\n                while(f > 0 && (n *= 256)){\n                    i += this[e + --f] * n;\n                }\n                n *= 128;\n                if (i >= n) i -= Math.pow(2, 8 * r);\n                return i;\n            };\n            Buffer.prototype.readInt8 = function readInt8(e, r) {\n                e = e >>> 0;\n                if (!r) checkOffset(e, 1, this.length);\n                if (!(this[e] & 128)) return this[e];\n                return (255 - this[e] + 1) * -1;\n            };\n            Buffer.prototype.readInt16LE = function readInt16LE(e, r) {\n                e = e >>> 0;\n                if (!r) checkOffset(e, 2, this.length);\n                var t = this[e] | this[e + 1] << 8;\n                return t & 32768 ? t | 4294901760 : t;\n            };\n            Buffer.prototype.readInt16BE = function readInt16BE(e, r) {\n                e = e >>> 0;\n                if (!r) checkOffset(e, 2, this.length);\n                var t = this[e + 1] | this[e] << 8;\n                return t & 32768 ? t | 4294901760 : t;\n            };\n            Buffer.prototype.readInt32LE = function readInt32LE(e, r) {\n                e = e >>> 0;\n                if (!r) checkOffset(e, 4, this.length);\n                return this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;\n            };\n            Buffer.prototype.readInt32BE = function readInt32BE(e, r) {\n                e = e >>> 0;\n                if (!r) checkOffset(e, 4, this.length);\n                return this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];\n            };\n            Buffer.prototype.readFloatLE = function readFloatLE(e, r) {\n                e = e >>> 0;\n                if (!r) checkOffset(e, 4, this.length);\n                return n.read(this, e, true, 23, 4);\n            };\n            Buffer.prototype.readFloatBE = function readFloatBE(e, r) {\n                e = e >>> 0;\n                if (!r) checkOffset(e, 4, this.length);\n                return n.read(this, e, false, 23, 4);\n            };\n            Buffer.prototype.readDoubleLE = function readDoubleLE(e, r) {\n                e = e >>> 0;\n                if (!r) checkOffset(e, 8, this.length);\n                return n.read(this, e, true, 52, 8);\n            };\n            Buffer.prototype.readDoubleBE = function readDoubleBE(e, r) {\n                e = e >>> 0;\n                if (!r) checkOffset(e, 8, this.length);\n                return n.read(this, e, false, 52, 8);\n            };\n            function checkInt(e, r, t, f, n, i) {\n                if (!Buffer.isBuffer(e)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n                if (r > n || r < i) throw new RangeError('\"value\" argument is out of bounds');\n                if (t + f > e.length) throw new RangeError(\"Index out of range\");\n            }\n            Buffer.prototype.writeUIntLE = function writeUIntLE(e, r, t, f) {\n                e = +e;\n                r = r >>> 0;\n                t = t >>> 0;\n                if (!f) {\n                    var n = Math.pow(2, 8 * t) - 1;\n                    checkInt(this, e, r, t, n, 0);\n                }\n                var i = 1;\n                var o = 0;\n                this[r] = e & 255;\n                while(++o < t && (i *= 256)){\n                    this[r + o] = e / i & 255;\n                }\n                return r + t;\n            };\n            Buffer.prototype.writeUIntBE = function writeUIntBE(e, r, t, f) {\n                e = +e;\n                r = r >>> 0;\n                t = t >>> 0;\n                if (!f) {\n                    var n = Math.pow(2, 8 * t) - 1;\n                    checkInt(this, e, r, t, n, 0);\n                }\n                var i = t - 1;\n                var o = 1;\n                this[r + i] = e & 255;\n                while(--i >= 0 && (o *= 256)){\n                    this[r + i] = e / o & 255;\n                }\n                return r + t;\n            };\n            Buffer.prototype.writeUInt8 = function writeUInt8(e, r, t) {\n                e = +e;\n                r = r >>> 0;\n                if (!t) checkInt(this, e, r, 1, 255, 0);\n                this[r] = e & 255;\n                return r + 1;\n            };\n            Buffer.prototype.writeUInt16LE = function writeUInt16LE(e, r, t) {\n                e = +e;\n                r = r >>> 0;\n                if (!t) checkInt(this, e, r, 2, 65535, 0);\n                this[r] = e & 255;\n                this[r + 1] = e >>> 8;\n                return r + 2;\n            };\n            Buffer.prototype.writeUInt16BE = function writeUInt16BE(e, r, t) {\n                e = +e;\n                r = r >>> 0;\n                if (!t) checkInt(this, e, r, 2, 65535, 0);\n                this[r] = e >>> 8;\n                this[r + 1] = e & 255;\n                return r + 2;\n            };\n            Buffer.prototype.writeUInt32LE = function writeUInt32LE(e, r, t) {\n                e = +e;\n                r = r >>> 0;\n                if (!t) checkInt(this, e, r, 4, 4294967295, 0);\n                this[r + 3] = e >>> 24;\n                this[r + 2] = e >>> 16;\n                this[r + 1] = e >>> 8;\n                this[r] = e & 255;\n                return r + 4;\n            };\n            Buffer.prototype.writeUInt32BE = function writeUInt32BE(e, r, t) {\n                e = +e;\n                r = r >>> 0;\n                if (!t) checkInt(this, e, r, 4, 4294967295, 0);\n                this[r] = e >>> 24;\n                this[r + 1] = e >>> 16;\n                this[r + 2] = e >>> 8;\n                this[r + 3] = e & 255;\n                return r + 4;\n            };\n            Buffer.prototype.writeIntLE = function writeIntLE(e, r, t, f) {\n                e = +e;\n                r = r >>> 0;\n                if (!f) {\n                    var n = Math.pow(2, 8 * t - 1);\n                    checkInt(this, e, r, t, n - 1, -n);\n                }\n                var i = 0;\n                var o = 1;\n                var u = 0;\n                this[r] = e & 255;\n                while(++i < t && (o *= 256)){\n                    if (e < 0 && u === 0 && this[r + i - 1] !== 0) {\n                        u = 1;\n                    }\n                    this[r + i] = (e / o >> 0) - u & 255;\n                }\n                return r + t;\n            };\n            Buffer.prototype.writeIntBE = function writeIntBE(e, r, t, f) {\n                e = +e;\n                r = r >>> 0;\n                if (!f) {\n                    var n = Math.pow(2, 8 * t - 1);\n                    checkInt(this, e, r, t, n - 1, -n);\n                }\n                var i = t - 1;\n                var o = 1;\n                var u = 0;\n                this[r + i] = e & 255;\n                while(--i >= 0 && (o *= 256)){\n                    if (e < 0 && u === 0 && this[r + i + 1] !== 0) {\n                        u = 1;\n                    }\n                    this[r + i] = (e / o >> 0) - u & 255;\n                }\n                return r + t;\n            };\n            Buffer.prototype.writeInt8 = function writeInt8(e, r, t) {\n                e = +e;\n                r = r >>> 0;\n                if (!t) checkInt(this, e, r, 1, 127, -128);\n                if (e < 0) e = 255 + e + 1;\n                this[r] = e & 255;\n                return r + 1;\n            };\n            Buffer.prototype.writeInt16LE = function writeInt16LE(e, r, t) {\n                e = +e;\n                r = r >>> 0;\n                if (!t) checkInt(this, e, r, 2, 32767, -32768);\n                this[r] = e & 255;\n                this[r + 1] = e >>> 8;\n                return r + 2;\n            };\n            Buffer.prototype.writeInt16BE = function writeInt16BE(e, r, t) {\n                e = +e;\n                r = r >>> 0;\n                if (!t) checkInt(this, e, r, 2, 32767, -32768);\n                this[r] = e >>> 8;\n                this[r + 1] = e & 255;\n                return r + 2;\n            };\n            Buffer.prototype.writeInt32LE = function writeInt32LE(e, r, t) {\n                e = +e;\n                r = r >>> 0;\n                if (!t) checkInt(this, e, r, 4, 2147483647, -2147483648);\n                this[r] = e & 255;\n                this[r + 1] = e >>> 8;\n                this[r + 2] = e >>> 16;\n                this[r + 3] = e >>> 24;\n                return r + 4;\n            };\n            Buffer.prototype.writeInt32BE = function writeInt32BE(e, r, t) {\n                e = +e;\n                r = r >>> 0;\n                if (!t) checkInt(this, e, r, 4, 2147483647, -2147483648);\n                if (e < 0) e = 4294967295 + e + 1;\n                this[r] = e >>> 24;\n                this[r + 1] = e >>> 16;\n                this[r + 2] = e >>> 8;\n                this[r + 3] = e & 255;\n                return r + 4;\n            };\n            function checkIEEE754(e, r, t, f, n, i) {\n                if (t + f > e.length) throw new RangeError(\"Index out of range\");\n                if (t < 0) throw new RangeError(\"Index out of range\");\n            }\n            function writeFloat(e, r, t, f, i) {\n                r = +r;\n                t = t >>> 0;\n                if (!i) {\n                    checkIEEE754(e, r, t, 4, 34028234663852886e22, -34028234663852886e22);\n                }\n                n.write(e, r, t, f, 23, 4);\n                return t + 4;\n            }\n            Buffer.prototype.writeFloatLE = function writeFloatLE(e, r, t) {\n                return writeFloat(this, e, r, true, t);\n            };\n            Buffer.prototype.writeFloatBE = function writeFloatBE(e, r, t) {\n                return writeFloat(this, e, r, false, t);\n            };\n            function writeDouble(e, r, t, f, i) {\n                r = +r;\n                t = t >>> 0;\n                if (!i) {\n                    checkIEEE754(e, r, t, 8, 17976931348623157e292, -17976931348623157e292);\n                }\n                n.write(e, r, t, f, 52, 8);\n                return t + 8;\n            }\n            Buffer.prototype.writeDoubleLE = function writeDoubleLE(e, r, t) {\n                return writeDouble(this, e, r, true, t);\n            };\n            Buffer.prototype.writeDoubleBE = function writeDoubleBE(e, r, t) {\n                return writeDouble(this, e, r, false, t);\n            };\n            Buffer.prototype.copy = function copy(e, r, t, f) {\n                if (!Buffer.isBuffer(e)) throw new TypeError(\"argument should be a Buffer\");\n                if (!t) t = 0;\n                if (!f && f !== 0) f = this.length;\n                if (r >= e.length) r = e.length;\n                if (!r) r = 0;\n                if (f > 0 && f < t) f = t;\n                if (f === t) return 0;\n                if (e.length === 0 || this.length === 0) return 0;\n                if (r < 0) {\n                    throw new RangeError(\"targetStart out of bounds\");\n                }\n                if (t < 0 || t >= this.length) throw new RangeError(\"Index out of range\");\n                if (f < 0) throw new RangeError(\"sourceEnd out of bounds\");\n                if (f > this.length) f = this.length;\n                if (e.length - r < f - t) {\n                    f = e.length - r + t;\n                }\n                var n = f - t;\n                if (this === e && typeof Uint8Array.prototype.copyWithin === \"function\") {\n                    this.copyWithin(r, t, f);\n                } else if (this === e && t < r && r < f) {\n                    for(var i = n - 1; i >= 0; --i){\n                        e[i + r] = this[i + t];\n                    }\n                } else {\n                    Uint8Array.prototype.set.call(e, this.subarray(t, f), r);\n                }\n                return n;\n            };\n            Buffer.prototype.fill = function fill(e, r, t, f) {\n                if (typeof e === \"string\") {\n                    if (typeof r === \"string\") {\n                        f = r;\n                        r = 0;\n                        t = this.length;\n                    } else if (typeof t === \"string\") {\n                        f = t;\n                        t = this.length;\n                    }\n                    if (f !== undefined && typeof f !== \"string\") {\n                        throw new TypeError(\"encoding must be a string\");\n                    }\n                    if (typeof f === \"string\" && !Buffer.isEncoding(f)) {\n                        throw new TypeError(\"Unknown encoding: \" + f);\n                    }\n                    if (e.length === 1) {\n                        var n = e.charCodeAt(0);\n                        if (f === \"utf8\" && n < 128 || f === \"latin1\") {\n                            e = n;\n                        }\n                    }\n                } else if (typeof e === \"number\") {\n                    e = e & 255;\n                } else if (typeof e === \"boolean\") {\n                    e = Number(e);\n                }\n                if (r < 0 || this.length < r || this.length < t) {\n                    throw new RangeError(\"Out of range index\");\n                }\n                if (t <= r) {\n                    return this;\n                }\n                r = r >>> 0;\n                t = t === undefined ? this.length : t >>> 0;\n                if (!e) e = 0;\n                var i;\n                if (typeof e === \"number\") {\n                    for(i = r; i < t; ++i){\n                        this[i] = e;\n                    }\n                } else {\n                    var o = Buffer.isBuffer(e) ? e : Buffer.from(e, f);\n                    var u = o.length;\n                    if (u === 0) {\n                        throw new TypeError('The value \"' + e + '\" is invalid for argument \"value\"');\n                    }\n                    for(i = 0; i < t - r; ++i){\n                        this[i + r] = o[i % u];\n                    }\n                }\n                return this;\n            };\n            var a = /[^+/0-9A-Za-z-_]/g;\n            function base64clean(e) {\n                e = e.split(\"=\")[0];\n                e = e.trim().replace(a, \"\");\n                if (e.length < 2) return \"\";\n                while(e.length % 4 !== 0){\n                    e = e + \"=\";\n                }\n                return e;\n            }\n            function utf8ToBytes(e, r) {\n                r = r || Infinity;\n                var t;\n                var f = e.length;\n                var n = null;\n                var i = [];\n                for(var o = 0; o < f; ++o){\n                    t = e.charCodeAt(o);\n                    if (t > 55295 && t < 57344) {\n                        if (!n) {\n                            if (t > 56319) {\n                                if ((r -= 3) > -1) i.push(239, 191, 189);\n                                continue;\n                            } else if (o + 1 === f) {\n                                if ((r -= 3) > -1) i.push(239, 191, 189);\n                                continue;\n                            }\n                            n = t;\n                            continue;\n                        }\n                        if (t < 56320) {\n                            if ((r -= 3) > -1) i.push(239, 191, 189);\n                            n = t;\n                            continue;\n                        }\n                        t = (n - 55296 << 10 | t - 56320) + 65536;\n                    } else if (n) {\n                        if ((r -= 3) > -1) i.push(239, 191, 189);\n                    }\n                    n = null;\n                    if (t < 128) {\n                        if ((r -= 1) < 0) break;\n                        i.push(t);\n                    } else if (t < 2048) {\n                        if ((r -= 2) < 0) break;\n                        i.push(t >> 6 | 192, t & 63 | 128);\n                    } else if (t < 65536) {\n                        if ((r -= 3) < 0) break;\n                        i.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128);\n                    } else if (t < 1114112) {\n                        if ((r -= 4) < 0) break;\n                        i.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128);\n                    } else {\n                        throw new Error(\"Invalid code point\");\n                    }\n                }\n                return i;\n            }\n            function asciiToBytes(e) {\n                var r = [];\n                for(var t = 0; t < e.length; ++t){\n                    r.push(e.charCodeAt(t) & 255);\n                }\n                return r;\n            }\n            function utf16leToBytes(e, r) {\n                var t, f, n;\n                var i = [];\n                for(var o = 0; o < e.length; ++o){\n                    if ((r -= 2) < 0) break;\n                    t = e.charCodeAt(o);\n                    f = t >> 8;\n                    n = t % 256;\n                    i.push(n);\n                    i.push(f);\n                }\n                return i;\n            }\n            function base64ToBytes(e) {\n                return f.toByteArray(base64clean(e));\n            }\n            function blitBuffer(e, r, t, f) {\n                for(var n = 0; n < f; ++n){\n                    if (n + t >= r.length || n >= e.length) break;\n                    r[n + t] = e[n];\n                }\n                return n;\n            }\n            function isInstance(e, r) {\n                return e instanceof r || e != null && e.constructor != null && e.constructor.name != null && e.constructor.name === r.name;\n            }\n            function numberIsNaN(e) {\n                return e !== e;\n            }\n            var s = function() {\n                var e = \"0123456789abcdef\";\n                var r = new Array(256);\n                for(var t = 0; t < 16; ++t){\n                    var f = t * 16;\n                    for(var n = 0; n < 16; ++n){\n                        r[f + n] = e[t] + e[n];\n                    }\n                }\n                return r;\n            }();\n        },\n        783: function(e, r) {\n            /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ r.read = function(e, r, t, f, n) {\n                var i, o;\n                var u = n * 8 - f - 1;\n                var a = (1 << u) - 1;\n                var s = a >> 1;\n                var h = -7;\n                var c = t ? n - 1 : 0;\n                var l = t ? -1 : 1;\n                var p = e[r + c];\n                c += l;\n                i = p & (1 << -h) - 1;\n                p >>= -h;\n                h += u;\n                for(; h > 0; i = i * 256 + e[r + c], c += l, h -= 8){}\n                o = i & (1 << -h) - 1;\n                i >>= -h;\n                h += f;\n                for(; h > 0; o = o * 256 + e[r + c], c += l, h -= 8){}\n                if (i === 0) {\n                    i = 1 - s;\n                } else if (i === a) {\n                    return o ? NaN : (p ? -1 : 1) * Infinity;\n                } else {\n                    o = o + Math.pow(2, f);\n                    i = i - s;\n                }\n                return (p ? -1 : 1) * o * Math.pow(2, i - f);\n            };\n            r.write = function(e, r, t, f, n, i) {\n                var o, u, a;\n                var s = i * 8 - n - 1;\n                var h = (1 << s) - 1;\n                var c = h >> 1;\n                var l = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n                var p = f ? 0 : i - 1;\n                var y = f ? 1 : -1;\n                var g = r < 0 || r === 0 && 1 / r < 0 ? 1 : 0;\n                r = Math.abs(r);\n                if (isNaN(r) || r === Infinity) {\n                    u = isNaN(r) ? 1 : 0;\n                    o = h;\n                } else {\n                    o = Math.floor(Math.log(r) / Math.LN2);\n                    if (r * (a = Math.pow(2, -o)) < 1) {\n                        o--;\n                        a *= 2;\n                    }\n                    if (o + c >= 1) {\n                        r += l / a;\n                    } else {\n                        r += l * Math.pow(2, 1 - c);\n                    }\n                    if (r * a >= 2) {\n                        o++;\n                        a /= 2;\n                    }\n                    if (o + c >= h) {\n                        u = 0;\n                        o = h;\n                    } else if (o + c >= 1) {\n                        u = (r * a - 1) * Math.pow(2, n);\n                        o = o + c;\n                    } else {\n                        u = r * Math.pow(2, c - 1) * Math.pow(2, n);\n                        o = 0;\n                    }\n                }\n                for(; n >= 8; e[t + p] = u & 255, p += y, u /= 256, n -= 8){}\n                o = o << n | u;\n                s += n;\n                for(; s > 0; e[t + p] = o & 255, p += y, o /= 256, s -= 8){}\n                e[t + p - y] |= g * 128;\n            };\n        }\n    };\n    var r = {};\n    function __nccwpck_require__(t) {\n        var f = r[t];\n        if (f !== undefined) {\n            return f.exports;\n        }\n        var n = r[t] = {\n            exports: {}\n        };\n        var i = true;\n        try {\n            e[t](n, n.exports, __nccwpck_require__);\n            i = false;\n        } finally{\n            if (i) delete r[t];\n        }\n        return n.exports;\n    }\n    if (typeof __nccwpck_require__ !== \"undefined\") __nccwpck_require__.ab = __dirname + \"/\";\n    var t = __nccwpck_require__(72);\n    module.exports = t;\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvYnVmZmVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7O0FBQUM7SUFBVyxJQUFJQSxJQUFFO1FBQUMsS0FBSSxTQUFTQSxDQUFDLEVBQUNDLENBQUM7WUFBRTtZQUFhQSxFQUFFQyxVQUFVLEdBQUNBO1lBQVdELEVBQUVFLFdBQVcsR0FBQ0E7WUFBWUYsRUFBRUcsYUFBYSxHQUFDQTtZQUFjLElBQUlDLElBQUUsRUFBRTtZQUFDLElBQUlDLElBQUUsRUFBRTtZQUFDLElBQUlDLElBQUUsT0FBT0MsZUFBYSxjQUFZQSxhQUFXQztZQUFNLElBQUlDLElBQUU7WUFBbUUsSUFBSSxJQUFJQyxJQUFFLEdBQUVDLElBQUVGLEVBQUVHLE1BQU0sRUFBQ0YsSUFBRUMsR0FBRSxFQUFFRCxFQUFFO2dCQUFDTixDQUFDLENBQUNNLEVBQUUsR0FBQ0QsQ0FBQyxDQUFDQyxFQUFFO2dCQUFDTCxDQUFDLENBQUNJLEVBQUVJLFVBQVUsQ0FBQ0gsR0FBRyxHQUFDQTtZQUFDO1lBQUNMLENBQUMsQ0FBQyxJQUFJUSxVQUFVLENBQUMsR0FBRyxHQUFDO1lBQUdSLENBQUMsQ0FBQyxJQUFJUSxVQUFVLENBQUMsR0FBRyxHQUFDO1lBQUcsU0FBU0MsUUFBUWYsQ0FBQztnQkFBRSxJQUFJQyxJQUFFRCxFQUFFYSxNQUFNO2dCQUFDLElBQUdaLElBQUUsSUFBRSxHQUFFO29CQUFDLE1BQU0sSUFBSWUsTUFBTTtnQkFBaUQ7Z0JBQUMsSUFBSVgsSUFBRUwsRUFBRWlCLE9BQU8sQ0FBQztnQkFBSyxJQUFHWixNQUFJLENBQUMsR0FBRUEsSUFBRUo7Z0JBQUUsSUFBSUssSUFBRUQsTUFBSUosSUFBRSxJQUFFLElBQUVJLElBQUU7Z0JBQUUsT0FBTTtvQkFBQ0E7b0JBQUVDO2lCQUFFO1lBQUE7WUFBQyxTQUFTSixXQUFXRixDQUFDO2dCQUFFLElBQUlDLElBQUVjLFFBQVFmO2dCQUFHLElBQUlLLElB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O0lBQUM7SUFBRSxJQUFJdEwsSUFBRSxDQUFDO0lBQUUsU0FBUzRMLG9CQUFvQnhMLENBQUM7UUFBRSxJQUFJQyxJQUFFTCxDQUFDLENBQUNJLEVBQUU7UUFBQyxJQUFHQyxNQUFJc0MsV0FBVTtZQUFDLE9BQU90QyxFQUFFd0wsT0FBTztRQUFBO1FBQUMsSUFBSXZMLElBQUVOLENBQUMsQ0FBQ0ksRUFBRSxHQUFDO1lBQUN5TCxTQUFRLENBQUM7UUFBQztRQUFFLElBQUlwTCxJQUFFO1FBQUssSUFBRztZQUFDVixDQUFDLENBQUNLLEVBQUUsQ0FBQ0UsR0FBRUEsRUFBRXVMLE9BQU8sRUFBQ0Q7WUFBcUJuTCxJQUFFO1FBQUssU0FBUTtZQUFDLElBQUdBLEdBQUUsT0FBT1QsQ0FBQyxDQUFDSSxFQUFFO1FBQUE7UUFBQyxPQUFPRSxFQUFFdUwsT0FBTztJQUFBO0lBQUMsSUFBRyxPQUFPRCx3QkFBc0IsYUFBWUEsb0JBQW9CRSxFQUFFLEdBQUNDLFNBQVNBLEdBQUM7SUFBSSxJQUFJM0wsSUFBRXdMLG9CQUFvQjtJQUFJSSxPQUFPSCxPQUFPLEdBQUN6TDtBQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvYnVmZmVyL2luZGV4LmpzPzM3NzYiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7dmFyIGU9ezY3NTpmdW5jdGlvbihlLHIpe1widXNlIHN0cmljdFwiO3IuYnl0ZUxlbmd0aD1ieXRlTGVuZ3RoO3IudG9CeXRlQXJyYXk9dG9CeXRlQXJyYXk7ci5mcm9tQnl0ZUFycmF5PWZyb21CeXRlQXJyYXk7dmFyIHQ9W107dmFyIGY9W107dmFyIG49dHlwZW9mIFVpbnQ4QXJyYXkhPT1cInVuZGVmaW5lZFwiP1VpbnQ4QXJyYXk6QXJyYXk7dmFyIGk9XCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7Zm9yKHZhciBvPTAsdT1pLmxlbmd0aDtvPHU7KytvKXt0W29dPWlbb107ZltpLmNoYXJDb2RlQXQobyldPW99ZltcIi1cIi5jaGFyQ29kZUF0KDApXT02MjtmW1wiX1wiLmNoYXJDb2RlQXQoMCldPTYzO2Z1bmN0aW9uIGdldExlbnMoZSl7dmFyIHI9ZS5sZW5ndGg7aWYociU0PjApe3Rocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDRcIil9dmFyIHQ9ZS5pbmRleE9mKFwiPVwiKTtpZih0PT09LTEpdD1yO3ZhciBmPXQ9PT1yPzA6NC10JTQ7cmV0dXJuW3QsZl19ZnVuY3Rpb24gYnl0ZUxlbmd0aChlKXt2YXIgcj1nZXRMZW5zKGUpO3ZhciB0PXJbMF07dmFyIGY9clsxXTtyZXR1cm4odCtmKSozLzQtZn1mdW5jdGlvbiBfYnl0ZUxlbmd0aChlLHIsdCl7cmV0dXJuKHIrdCkqMy80LXR9ZnVuY3Rpb24gdG9CeXRlQXJyYXkoZSl7dmFyIHI7dmFyIHQ9Z2V0TGVucyhlKTt2YXIgaT10WzBdO3ZhciBvPXRbMV07dmFyIHU9bmV3IG4oX2J5dGVMZW5ndGgoZSxpLG8pKTt2YXIgYT0wO3ZhciBzPW8+MD9pLTQ6aTt2YXIgaDtmb3IoaD0wO2g8cztoKz00KXtyPWZbZS5jaGFyQ29kZUF0KGgpXTw8MTh8ZltlLmNoYXJDb2RlQXQoaCsxKV08PDEyfGZbZS5jaGFyQ29kZUF0KGgrMildPDw2fGZbZS5jaGFyQ29kZUF0KGgrMyldO3VbYSsrXT1yPj4xNiYyNTU7dVthKytdPXI+PjgmMjU1O3VbYSsrXT1yJjI1NX1pZihvPT09Mil7cj1mW2UuY2hhckNvZGVBdChoKV08PDJ8ZltlLmNoYXJDb2RlQXQoaCsxKV0+PjQ7dVthKytdPXImMjU1fWlmKG89PT0xKXtyPWZbZS5jaGFyQ29kZUF0KGgpXTw8MTB8ZltlLmNoYXJDb2RlQXQoaCsxKV08PDR8ZltlLmNoYXJDb2RlQXQoaCsyKV0+PjI7dVthKytdPXI+PjgmMjU1O3VbYSsrXT1yJjI1NX1yZXR1cm4gdX1mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQoZSl7cmV0dXJuIHRbZT4+MTgmNjNdK3RbZT4+MTImNjNdK3RbZT4+NiY2M10rdFtlJjYzXX1mdW5jdGlvbiBlbmNvZGVDaHVuayhlLHIsdCl7dmFyIGY7dmFyIG49W107Zm9yKHZhciBpPXI7aTx0O2krPTMpe2Y9KGVbaV08PDE2JjE2NzExNjgwKSsoZVtpKzFdPDw4JjY1MjgwKSsoZVtpKzJdJjI1NSk7bi5wdXNoKHRyaXBsZXRUb0Jhc2U2NChmKSl9cmV0dXJuIG4uam9pbihcIlwiKX1mdW5jdGlvbiBmcm9tQnl0ZUFycmF5KGUpe3ZhciByO3ZhciBmPWUubGVuZ3RoO3ZhciBuPWYlMzt2YXIgaT1bXTt2YXIgbz0xNjM4Mztmb3IodmFyIHU9MCxhPWYtbjt1PGE7dSs9byl7aS5wdXNoKGVuY29kZUNodW5rKGUsdSx1K28+YT9hOnUrbykpfWlmKG49PT0xKXtyPWVbZi0xXTtpLnB1c2godFtyPj4yXSt0W3I8PDQmNjNdK1wiPT1cIil9ZWxzZSBpZihuPT09Mil7cj0oZVtmLTJdPDw4KStlW2YtMV07aS5wdXNoKHRbcj4+MTBdK3Rbcj4+NCY2M10rdFtyPDwyJjYzXStcIj1cIil9cmV0dXJuIGkuam9pbihcIlwiKX19LDcyOmZ1bmN0aW9uKGUscix0KXtcInVzZSBzdHJpY3RcIjtcbi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL3ZhciBmPXQoNjc1KTt2YXIgbj10KDc4Myk7dmFyIGk9dHlwZW9mIFN5bWJvbD09PVwiZnVuY3Rpb25cIiYmdHlwZW9mIFN5bWJvbC5mb3I9PT1cImZ1bmN0aW9uXCI/U3ltYm9sLmZvcihcIm5vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tXCIpOm51bGw7ci5CdWZmZXI9QnVmZmVyO3IuU2xvd0J1ZmZlcj1TbG93QnVmZmVyO3IuSU5TUEVDVF9NQVhfQllURVM9NTA7dmFyIG89MjE0NzQ4MzY0NztyLmtNYXhMZW5ndGg9bztCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVD10eXBlZEFycmF5U3VwcG9ydCgpO2lmKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCYmdHlwZW9mIGNvbnNvbGUhPT1cInVuZGVmaW5lZFwiJiZ0eXBlb2YgY29uc29sZS5lcnJvcj09PVwiZnVuY3Rpb25cIil7Y29uc29sZS5lcnJvcihcIlRoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSBcIitcImBidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuXCIpfWZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0KCl7dHJ5e3ZhciBlPW5ldyBVaW50OEFycmF5KDEpO3ZhciByPXtmb286ZnVuY3Rpb24oKXtyZXR1cm4gNDJ9fTtPYmplY3Quc2V0UHJvdG90eXBlT2YocixVaW50OEFycmF5LnByb3RvdHlwZSk7T2JqZWN0LnNldFByb3RvdHlwZU9mKGUscik7cmV0dXJuIGUuZm9vKCk9PT00Mn1jYXRjaChlKXtyZXR1cm4gZmFsc2V9fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLFwicGFyZW50XCIse2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtpZighQnVmZmVyLmlzQnVmZmVyKHRoaXMpKXJldHVybiB1bmRlZmluZWQ7cmV0dXJuIHRoaXMuYnVmZmVyfX0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLFwib2Zmc2V0XCIse2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtpZighQnVmZmVyLmlzQnVmZmVyKHRoaXMpKXJldHVybiB1bmRlZmluZWQ7cmV0dXJuIHRoaXMuYnl0ZU9mZnNldH19KTtmdW5jdGlvbiBjcmVhdGVCdWZmZXIoZSl7aWYoZT5vKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJytlKydcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKX12YXIgcj1uZXcgVWludDhBcnJheShlKTtPYmplY3Quc2V0UHJvdG90eXBlT2YocixCdWZmZXIucHJvdG90eXBlKTtyZXR1cm4gcn1mdW5jdGlvbiBCdWZmZXIoZSxyLHQpe2lmKHR5cGVvZiBlPT09XCJudW1iZXJcIil7aWYodHlwZW9mIHI9PT1cInN0cmluZ1wiKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nLiBSZWNlaXZlZCB0eXBlIG51bWJlcicpfXJldHVybiBhbGxvY1Vuc2FmZShlKX1yZXR1cm4gZnJvbShlLHIsdCl9QnVmZmVyLnBvb2xTaXplPTgxOTI7ZnVuY3Rpb24gZnJvbShlLHIsdCl7aWYodHlwZW9mIGU9PT1cInN0cmluZ1wiKXtyZXR1cm4gZnJvbVN0cmluZyhlLHIpfWlmKEFycmF5QnVmZmVyLmlzVmlldyhlKSl7cmV0dXJuIGZyb21BcnJheUxpa2UoZSl9aWYoZT09bnVsbCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIFwiK1wib3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgXCIrdHlwZW9mIGUpfWlmKGlzSW5zdGFuY2UoZSxBcnJheUJ1ZmZlcil8fGUmJmlzSW5zdGFuY2UoZS5idWZmZXIsQXJyYXlCdWZmZXIpKXtyZXR1cm4gZnJvbUFycmF5QnVmZmVyKGUscix0KX1pZih0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIhPT1cInVuZGVmaW5lZFwiJiYoaXNJbnN0YW5jZShlLFNoYXJlZEFycmF5QnVmZmVyKXx8ZSYmaXNJbnN0YW5jZShlLmJ1ZmZlcixTaGFyZWRBcnJheUJ1ZmZlcikpKXtyZXR1cm4gZnJvbUFycmF5QnVmZmVyKGUscix0KX1pZih0eXBlb2YgZT09PVwibnVtYmVyXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJyl9dmFyIGY9ZS52YWx1ZU9mJiZlLnZhbHVlT2YoKTtpZihmIT1udWxsJiZmIT09ZSl7cmV0dXJuIEJ1ZmZlci5mcm9tKGYscix0KX12YXIgbj1mcm9tT2JqZWN0KGUpO2lmKG4pcmV0dXJuIG47aWYodHlwZW9mIFN5bWJvbCE9PVwidW5kZWZpbmVkXCImJlN5bWJvbC50b1ByaW1pdGl2ZSE9bnVsbCYmdHlwZW9mIGVbU3ltYm9sLnRvUHJpbWl0aXZlXT09PVwiZnVuY3Rpb25cIil7cmV0dXJuIEJ1ZmZlci5mcm9tKGVbU3ltYm9sLnRvUHJpbWl0aXZlXShcInN0cmluZ1wiKSxyLHQpfXRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBcIitcIm9yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlIFwiK3R5cGVvZiBlKX1CdWZmZXIuZnJvbT1mdW5jdGlvbihlLHIsdCl7cmV0dXJuIGZyb20oZSxyLHQpfTtPYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLnByb3RvdHlwZSxVaW50OEFycmF5LnByb3RvdHlwZSk7T2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlcixVaW50OEFycmF5KTtmdW5jdGlvbiBhc3NlcnRTaXplKGUpe2lmKHR5cGVvZiBlIT09XCJudW1iZXJcIil7dGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpfWVsc2UgaWYoZTwwKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJytlKydcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKX19ZnVuY3Rpb24gYWxsb2MoZSxyLHQpe2Fzc2VydFNpemUoZSk7aWYoZTw9MCl7cmV0dXJuIGNyZWF0ZUJ1ZmZlcihlKX1pZihyIT09dW5kZWZpbmVkKXtyZXR1cm4gdHlwZW9mIHQ9PT1cInN0cmluZ1wiP2NyZWF0ZUJ1ZmZlcihlKS5maWxsKHIsdCk6Y3JlYXRlQnVmZmVyKGUpLmZpbGwocil9cmV0dXJuIGNyZWF0ZUJ1ZmZlcihlKX1CdWZmZXIuYWxsb2M9ZnVuY3Rpb24oZSxyLHQpe3JldHVybiBhbGxvYyhlLHIsdCl9O2Z1bmN0aW9uIGFsbG9jVW5zYWZlKGUpe2Fzc2VydFNpemUoZSk7cmV0dXJuIGNyZWF0ZUJ1ZmZlcihlPDA/MDpjaGVja2VkKGUpfDApfUJ1ZmZlci5hbGxvY1Vuc2FmZT1mdW5jdGlvbihlKXtyZXR1cm4gYWxsb2NVbnNhZmUoZSl9O0J1ZmZlci5hbGxvY1Vuc2FmZVNsb3c9ZnVuY3Rpb24oZSl7cmV0dXJuIGFsbG9jVW5zYWZlKGUpfTtmdW5jdGlvbiBmcm9tU3RyaW5nKGUscil7aWYodHlwZW9mIHIhPT1cInN0cmluZ1wifHxyPT09XCJcIil7cj1cInV0ZjhcIn1pZighQnVmZmVyLmlzRW5jb2Rpbmcocikpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIityKX12YXIgdD1ieXRlTGVuZ3RoKGUscil8MDt2YXIgZj1jcmVhdGVCdWZmZXIodCk7dmFyIG49Zi53cml0ZShlLHIpO2lmKG4hPT10KXtmPWYuc2xpY2UoMCxuKX1yZXR1cm4gZn1mdW5jdGlvbiBmcm9tQXJyYXlMaWtlKGUpe3ZhciByPWUubGVuZ3RoPDA/MDpjaGVja2VkKGUubGVuZ3RoKXwwO3ZhciB0PWNyZWF0ZUJ1ZmZlcihyKTtmb3IodmFyIGY9MDtmPHI7Zis9MSl7dFtmXT1lW2ZdJjI1NX1yZXR1cm4gdH1mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIoZSxyLHQpe2lmKHI8MHx8ZS5ieXRlTGVuZ3RoPHIpe3Rocm93IG5ldyBSYW5nZUVycm9yKCdcIm9mZnNldFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpfWlmKGUuYnl0ZUxlbmd0aDxyKyh0fHwwKSl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wibGVuZ3RoXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJyl9dmFyIGY7aWYocj09PXVuZGVmaW5lZCYmdD09PXVuZGVmaW5lZCl7Zj1uZXcgVWludDhBcnJheShlKX1lbHNlIGlmKHQ9PT11bmRlZmluZWQpe2Y9bmV3IFVpbnQ4QXJyYXkoZSxyKX1lbHNle2Y9bmV3IFVpbnQ4QXJyYXkoZSxyLHQpfU9iamVjdC5zZXRQcm90b3R5cGVPZihmLEJ1ZmZlci5wcm90b3R5cGUpO3JldHVybiBmfWZ1bmN0aW9uIGZyb21PYmplY3QoZSl7aWYoQnVmZmVyLmlzQnVmZmVyKGUpKXt2YXIgcj1jaGVja2VkKGUubGVuZ3RoKXwwO3ZhciB0PWNyZWF0ZUJ1ZmZlcihyKTtpZih0Lmxlbmd0aD09PTApe3JldHVybiB0fWUuY29weSh0LDAsMCxyKTtyZXR1cm4gdH1pZihlLmxlbmd0aCE9PXVuZGVmaW5lZCl7aWYodHlwZW9mIGUubGVuZ3RoIT09XCJudW1iZXJcInx8bnVtYmVySXNOYU4oZS5sZW5ndGgpKXtyZXR1cm4gY3JlYXRlQnVmZmVyKDApfXJldHVybiBmcm9tQXJyYXlMaWtlKGUpfWlmKGUudHlwZT09PVwiQnVmZmVyXCImJkFycmF5LmlzQXJyYXkoZS5kYXRhKSl7cmV0dXJuIGZyb21BcnJheUxpa2UoZS5kYXRhKX19ZnVuY3Rpb24gY2hlY2tlZChlKXtpZihlPj1vKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkF0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gXCIrXCJzaXplOiAweFwiK28udG9TdHJpbmcoMTYpK1wiIGJ5dGVzXCIpfXJldHVybiBlfDB9ZnVuY3Rpb24gU2xvd0J1ZmZlcihlKXtpZigrZSE9ZSl7ZT0wfXJldHVybiBCdWZmZXIuYWxsb2MoK2UpfUJ1ZmZlci5pc0J1ZmZlcj1mdW5jdGlvbiBpc0J1ZmZlcihlKXtyZXR1cm4gZSE9bnVsbCYmZS5faXNCdWZmZXI9PT10cnVlJiZlIT09QnVmZmVyLnByb3RvdHlwZX07QnVmZmVyLmNvbXBhcmU9ZnVuY3Rpb24gY29tcGFyZShlLHIpe2lmKGlzSW5zdGFuY2UoZSxVaW50OEFycmF5KSllPUJ1ZmZlci5mcm9tKGUsZS5vZmZzZXQsZS5ieXRlTGVuZ3RoKTtpZihpc0luc3RhbmNlKHIsVWludDhBcnJheSkpcj1CdWZmZXIuZnJvbShyLHIub2Zmc2V0LHIuYnl0ZUxlbmd0aCk7aWYoIUJ1ZmZlci5pc0J1ZmZlcihlKXx8IUJ1ZmZlci5pc0J1ZmZlcihyKSl7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheScpfWlmKGU9PT1yKXJldHVybiAwO3ZhciB0PWUubGVuZ3RoO3ZhciBmPXIubGVuZ3RoO2Zvcih2YXIgbj0wLGk9TWF0aC5taW4odCxmKTtuPGk7KytuKXtpZihlW25dIT09cltuXSl7dD1lW25dO2Y9cltuXTticmVha319aWYodDxmKXJldHVybi0xO2lmKGY8dClyZXR1cm4gMTtyZXR1cm4gMH07QnVmZmVyLmlzRW5jb2Rpbmc9ZnVuY3Rpb24gaXNFbmNvZGluZyhlKXtzd2l0Y2goU3RyaW5nKGUpLnRvTG93ZXJDYXNlKCkpe2Nhc2VcImhleFwiOmNhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOmNhc2VcImFzY2lpXCI6Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6Y2FzZVwiYmFzZTY0XCI6Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuIHRydWU7ZGVmYXVsdDpyZXR1cm4gZmFsc2V9fTtCdWZmZXIuY29uY2F0PWZ1bmN0aW9uIGNvbmNhdChlLHIpe2lmKCFBcnJheS5pc0FycmF5KGUpKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKX1pZihlLmxlbmd0aD09PTApe3JldHVybiBCdWZmZXIuYWxsb2MoMCl9dmFyIHQ7aWYocj09PXVuZGVmaW5lZCl7cj0wO2Zvcih0PTA7dDxlLmxlbmd0aDsrK3Qpe3IrPWVbdF0ubGVuZ3RofX12YXIgZj1CdWZmZXIuYWxsb2NVbnNhZmUocik7dmFyIG49MDtmb3IodD0wO3Q8ZS5sZW5ndGg7Kyt0KXt2YXIgaT1lW3RdO2lmKGlzSW5zdGFuY2UoaSxVaW50OEFycmF5KSl7aT1CdWZmZXIuZnJvbShpKX1pZighQnVmZmVyLmlzQnVmZmVyKGkpKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKX1pLmNvcHkoZixuKTtuKz1pLmxlbmd0aH1yZXR1cm4gZn07ZnVuY3Rpb24gYnl0ZUxlbmd0aChlLHIpe2lmKEJ1ZmZlci5pc0J1ZmZlcihlKSl7cmV0dXJuIGUubGVuZ3RofWlmKEFycmF5QnVmZmVyLmlzVmlldyhlKXx8aXNJbnN0YW5jZShlLEFycmF5QnVmZmVyKSl7cmV0dXJuIGUuYnl0ZUxlbmd0aH1pZih0eXBlb2YgZSE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiAnK1wiUmVjZWl2ZWQgdHlwZSBcIit0eXBlb2YgZSl9dmFyIHQ9ZS5sZW5ndGg7dmFyIGY9YXJndW1lbnRzLmxlbmd0aD4yJiZhcmd1bWVudHNbMl09PT10cnVlO2lmKCFmJiZ0PT09MClyZXR1cm4gMDt2YXIgbj1mYWxzZTtmb3IoOzspe3N3aXRjaChyKXtjYXNlXCJhc2NpaVwiOmNhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOnJldHVybiB0O2Nhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOnJldHVybiB1dGY4VG9CeXRlcyhlKS5sZW5ndGg7Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuIHQqMjtjYXNlXCJoZXhcIjpyZXR1cm4gdD4+PjE7Y2FzZVwiYmFzZTY0XCI6cmV0dXJuIGJhc2U2NFRvQnl0ZXMoZSkubGVuZ3RoO2RlZmF1bHQ6aWYobil7cmV0dXJuIGY/LTE6dXRmOFRvQnl0ZXMoZSkubGVuZ3RofXI9KFwiXCIrcikudG9Mb3dlckNhc2UoKTtuPXRydWV9fX1CdWZmZXIuYnl0ZUxlbmd0aD1ieXRlTGVuZ3RoO2Z1bmN0aW9uIHNsb3dUb1N0cmluZyhlLHIsdCl7dmFyIGY9ZmFsc2U7aWYocj09PXVuZGVmaW5lZHx8cjwwKXtyPTB9aWYocj50aGlzLmxlbmd0aCl7cmV0dXJuXCJcIn1pZih0PT09dW5kZWZpbmVkfHx0PnRoaXMubGVuZ3RoKXt0PXRoaXMubGVuZ3RofWlmKHQ8PTApe3JldHVyblwiXCJ9dD4+Pj0wO3I+Pj49MDtpZih0PD1yKXtyZXR1cm5cIlwifWlmKCFlKWU9XCJ1dGY4XCI7d2hpbGUodHJ1ZSl7c3dpdGNoKGUpe2Nhc2VcImhleFwiOnJldHVybiBoZXhTbGljZSh0aGlzLHIsdCk7Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6cmV0dXJuIHV0ZjhTbGljZSh0aGlzLHIsdCk7Y2FzZVwiYXNjaWlcIjpyZXR1cm4gYXNjaWlTbGljZSh0aGlzLHIsdCk7Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6cmV0dXJuIGxhdGluMVNsaWNlKHRoaXMscix0KTtjYXNlXCJiYXNlNjRcIjpyZXR1cm4gYmFzZTY0U2xpY2UodGhpcyxyLHQpO2Nhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiB1dGYxNmxlU2xpY2UodGhpcyxyLHQpO2RlZmF1bHQ6aWYoZil0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrZSk7ZT0oZStcIlwiKS50b0xvd2VyQ2FzZSgpO2Y9dHJ1ZX19fUJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyPXRydWU7ZnVuY3Rpb24gc3dhcChlLHIsdCl7dmFyIGY9ZVtyXTtlW3JdPWVbdF07ZVt0XT1mfUJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2PWZ1bmN0aW9uIHN3YXAxNigpe3ZhciBlPXRoaXMubGVuZ3RoO2lmKGUlMiE9PTApe3Rocm93IG5ldyBSYW5nZUVycm9yKFwiQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHNcIil9Zm9yKHZhciByPTA7cjxlO3IrPTIpe3N3YXAodGhpcyxyLHIrMSl9cmV0dXJuIHRoaXN9O0J1ZmZlci5wcm90b3R5cGUuc3dhcDMyPWZ1bmN0aW9uIHN3YXAzMigpe3ZhciBlPXRoaXMubGVuZ3RoO2lmKGUlNCE9PTApe3Rocm93IG5ldyBSYW5nZUVycm9yKFwiQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHNcIil9Zm9yKHZhciByPTA7cjxlO3IrPTQpe3N3YXAodGhpcyxyLHIrMyk7c3dhcCh0aGlzLHIrMSxyKzIpfXJldHVybiB0aGlzfTtCdWZmZXIucHJvdG90eXBlLnN3YXA2ND1mdW5jdGlvbiBzd2FwNjQoKXt2YXIgZT10aGlzLmxlbmd0aDtpZihlJTghPT0wKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzXCIpfWZvcih2YXIgcj0wO3I8ZTtyKz04KXtzd2FwKHRoaXMscixyKzcpO3N3YXAodGhpcyxyKzEscis2KTtzd2FwKHRoaXMscisyLHIrNSk7c3dhcCh0aGlzLHIrMyxyKzQpfXJldHVybiB0aGlzfTtCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uIHRvU3RyaW5nKCl7dmFyIGU9dGhpcy5sZW5ndGg7aWYoZT09PTApcmV0dXJuXCJcIjtpZihhcmd1bWVudHMubGVuZ3RoPT09MClyZXR1cm4gdXRmOFNsaWNlKHRoaXMsMCxlKTtyZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07QnVmZmVyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZz1CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nO0J1ZmZlci5wcm90b3R5cGUuZXF1YWxzPWZ1bmN0aW9uIGVxdWFscyhlKXtpZighQnVmZmVyLmlzQnVmZmVyKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyXCIpO2lmKHRoaXM9PT1lKXJldHVybiB0cnVlO3JldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLGUpPT09MH07QnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0PWZ1bmN0aW9uIGluc3BlY3QoKXt2YXIgZT1cIlwiO3ZhciB0PXIuSU5TUEVDVF9NQVhfQllURVM7ZT10aGlzLnRvU3RyaW5nKFwiaGV4XCIsMCx0KS5yZXBsYWNlKC8oLnsyfSkvZyxcIiQxIFwiKS50cmltKCk7aWYodGhpcy5sZW5ndGg+dCllKz1cIiAuLi4gXCI7cmV0dXJuXCI8QnVmZmVyIFwiK2UrXCI+XCJ9O2lmKGkpe0J1ZmZlci5wcm90b3R5cGVbaV09QnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0fUJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZT1mdW5jdGlvbiBjb21wYXJlKGUscix0LGYsbil7aWYoaXNJbnN0YW5jZShlLFVpbnQ4QXJyYXkpKXtlPUJ1ZmZlci5mcm9tKGUsZS5vZmZzZXQsZS5ieXRlTGVuZ3RoKX1pZighQnVmZmVyLmlzQnVmZmVyKGUpKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiAnK1wiUmVjZWl2ZWQgdHlwZSBcIit0eXBlb2YgZSl9aWYocj09PXVuZGVmaW5lZCl7cj0wfWlmKHQ9PT11bmRlZmluZWQpe3Q9ZT9lLmxlbmd0aDowfWlmKGY9PT11bmRlZmluZWQpe2Y9MH1pZihuPT09dW5kZWZpbmVkKXtuPXRoaXMubGVuZ3RofWlmKHI8MHx8dD5lLmxlbmd0aHx8ZjwwfHxuPnRoaXMubGVuZ3RoKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIm91dCBvZiByYW5nZSBpbmRleFwiKX1pZihmPj1uJiZyPj10KXtyZXR1cm4gMH1pZihmPj1uKXtyZXR1cm4tMX1pZihyPj10KXtyZXR1cm4gMX1yPj4+PTA7dD4+Pj0wO2Y+Pj49MDtuPj4+PTA7aWYodGhpcz09PWUpcmV0dXJuIDA7dmFyIGk9bi1mO3ZhciBvPXQtcjt2YXIgdT1NYXRoLm1pbihpLG8pO3ZhciBhPXRoaXMuc2xpY2UoZixuKTt2YXIgcz1lLnNsaWNlKHIsdCk7Zm9yKHZhciBoPTA7aDx1OysraCl7aWYoYVtoXSE9PXNbaF0pe2k9YVtoXTtvPXNbaF07YnJlYWt9fWlmKGk8bylyZXR1cm4tMTtpZihvPGkpcmV0dXJuIDE7cmV0dXJuIDB9O2Z1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mKGUscix0LGYsbil7aWYoZS5sZW5ndGg9PT0wKXJldHVybi0xO2lmKHR5cGVvZiB0PT09XCJzdHJpbmdcIil7Zj10O3Q9MH1lbHNlIGlmKHQ+MjE0NzQ4MzY0Nyl7dD0yMTQ3NDgzNjQ3fWVsc2UgaWYodDwtMjE0NzQ4MzY0OCl7dD0tMjE0NzQ4MzY0OH10PSt0O2lmKG51bWJlcklzTmFOKHQpKXt0PW4/MDplLmxlbmd0aC0xfWlmKHQ8MCl0PWUubGVuZ3RoK3Q7aWYodD49ZS5sZW5ndGgpe2lmKG4pcmV0dXJuLTE7ZWxzZSB0PWUubGVuZ3RoLTF9ZWxzZSBpZih0PDApe2lmKG4pdD0wO2Vsc2UgcmV0dXJuLTF9aWYodHlwZW9mIHI9PT1cInN0cmluZ1wiKXtyPUJ1ZmZlci5mcm9tKHIsZil9aWYoQnVmZmVyLmlzQnVmZmVyKHIpKXtpZihyLmxlbmd0aD09PTApe3JldHVybi0xfXJldHVybiBhcnJheUluZGV4T2YoZSxyLHQsZixuKX1lbHNlIGlmKHR5cGVvZiByPT09XCJudW1iZXJcIil7cj1yJjI1NTtpZih0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZj09PVwiZnVuY3Rpb25cIil7aWYobil7cmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChlLHIsdCl9ZWxzZXtyZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChlLHIsdCl9fXJldHVybiBhcnJheUluZGV4T2YoZSxbcl0sdCxmLG4pfXRocm93IG5ldyBUeXBlRXJyb3IoXCJ2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXJcIil9ZnVuY3Rpb24gYXJyYXlJbmRleE9mKGUscix0LGYsbil7dmFyIGk9MTt2YXIgbz1lLmxlbmd0aDt2YXIgdT1yLmxlbmd0aDtpZihmIT09dW5kZWZpbmVkKXtmPVN0cmluZyhmKS50b0xvd2VyQ2FzZSgpO2lmKGY9PT1cInVjczJcInx8Zj09PVwidWNzLTJcInx8Zj09PVwidXRmMTZsZVwifHxmPT09XCJ1dGYtMTZsZVwiKXtpZihlLmxlbmd0aDwyfHxyLmxlbmd0aDwyKXtyZXR1cm4tMX1pPTI7by89Mjt1Lz0yO3QvPTJ9fWZ1bmN0aW9uIHJlYWQoZSxyKXtpZihpPT09MSl7cmV0dXJuIGVbcl19ZWxzZXtyZXR1cm4gZS5yZWFkVUludDE2QkUocippKX19dmFyIGE7aWYobil7dmFyIHM9LTE7Zm9yKGE9dDthPG87YSsrKXtpZihyZWFkKGUsYSk9PT1yZWFkKHIscz09PS0xPzA6YS1zKSl7aWYocz09PS0xKXM9YTtpZihhLXMrMT09PXUpcmV0dXJuIHMqaX1lbHNle2lmKHMhPT0tMSlhLT1hLXM7cz0tMX19fWVsc2V7aWYodCt1Pm8pdD1vLXU7Zm9yKGE9dDthPj0wO2EtLSl7dmFyIGg9dHJ1ZTtmb3IodmFyIGM9MDtjPHU7YysrKXtpZihyZWFkKGUsYStjKSE9PXJlYWQocixjKSl7aD1mYWxzZTticmVha319aWYoaClyZXR1cm4gYX19cmV0dXJuLTF9QnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcz1mdW5jdGlvbiBpbmNsdWRlcyhlLHIsdCl7cmV0dXJuIHRoaXMuaW5kZXhPZihlLHIsdCkhPT0tMX07QnVmZmVyLnByb3RvdHlwZS5pbmRleE9mPWZ1bmN0aW9uIGluZGV4T2YoZSxyLHQpe3JldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLGUscix0LHRydWUpfTtCdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mPWZ1bmN0aW9uIGxhc3RJbmRleE9mKGUscix0KXtyZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcyxlLHIsdCxmYWxzZSl9O2Z1bmN0aW9uIGhleFdyaXRlKGUscix0LGYpe3Q9TnVtYmVyKHQpfHwwO3ZhciBuPWUubGVuZ3RoLXQ7aWYoIWYpe2Y9bn1lbHNle2Y9TnVtYmVyKGYpO2lmKGY+bil7Zj1ufX12YXIgaT1yLmxlbmd0aDtpZihmPmkvMil7Zj1pLzJ9Zm9yKHZhciBvPTA7bzxmOysrbyl7dmFyIHU9cGFyc2VJbnQoci5zdWJzdHIobyoyLDIpLDE2KTtpZihudW1iZXJJc05hTih1KSlyZXR1cm4gbztlW3Qrb109dX1yZXR1cm4gb31mdW5jdGlvbiB1dGY4V3JpdGUoZSxyLHQsZil7cmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMocixlLmxlbmd0aC10KSxlLHQsZil9ZnVuY3Rpb24gYXNjaWlXcml0ZShlLHIsdCxmKXtyZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMociksZSx0LGYpfWZ1bmN0aW9uIGxhdGluMVdyaXRlKGUscix0LGYpe3JldHVybiBhc2NpaVdyaXRlKGUscix0LGYpfWZ1bmN0aW9uIGJhc2U2NFdyaXRlKGUscix0LGYpe3JldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMociksZSx0LGYpfWZ1bmN0aW9uIHVjczJXcml0ZShlLHIsdCxmKXtyZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhyLGUubGVuZ3RoLXQpLGUsdCxmKX1CdWZmZXIucHJvdG90eXBlLndyaXRlPWZ1bmN0aW9uIHdyaXRlKGUscix0LGYpe2lmKHI9PT11bmRlZmluZWQpe2Y9XCJ1dGY4XCI7dD10aGlzLmxlbmd0aDtyPTB9ZWxzZSBpZih0PT09dW5kZWZpbmVkJiZ0eXBlb2Ygcj09PVwic3RyaW5nXCIpe2Y9cjt0PXRoaXMubGVuZ3RoO3I9MH1lbHNlIGlmKGlzRmluaXRlKHIpKXtyPXI+Pj4wO2lmKGlzRmluaXRlKHQpKXt0PXQ+Pj4wO2lmKGY9PT11bmRlZmluZWQpZj1cInV0ZjhcIn1lbHNle2Y9dDt0PXVuZGVmaW5lZH19ZWxzZXt0aHJvdyBuZXcgRXJyb3IoXCJCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZFwiKX12YXIgbj10aGlzLmxlbmd0aC1yO2lmKHQ9PT11bmRlZmluZWR8fHQ+bil0PW47aWYoZS5sZW5ndGg+MCYmKHQ8MHx8cjwwKXx8cj50aGlzLmxlbmd0aCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kc1wiKX1pZighZilmPVwidXRmOFwiO3ZhciBpPWZhbHNlO2Zvcig7Oyl7c3dpdGNoKGYpe2Nhc2VcImhleFwiOnJldHVybiBoZXhXcml0ZSh0aGlzLGUscix0KTtjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpyZXR1cm4gdXRmOFdyaXRlKHRoaXMsZSxyLHQpO2Nhc2VcImFzY2lpXCI6cmV0dXJuIGFzY2lpV3JpdGUodGhpcyxlLHIsdCk7Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6cmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsZSxyLHQpO2Nhc2VcImJhc2U2NFwiOnJldHVybiBiYXNlNjRXcml0ZSh0aGlzLGUscix0KTtjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm4gdWNzMldyaXRlKHRoaXMsZSxyLHQpO2RlZmF1bHQ6aWYoaSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrZik7Zj0oXCJcIitmKS50b0xvd2VyQ2FzZSgpO2k9dHJ1ZX19fTtCdWZmZXIucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbiB0b0pTT04oKXtyZXR1cm57dHlwZTpcIkJ1ZmZlclwiLGRhdGE6QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyfHx0aGlzLDApfX07ZnVuY3Rpb24gYmFzZTY0U2xpY2UoZSxyLHQpe2lmKHI9PT0wJiZ0PT09ZS5sZW5ndGgpe3JldHVybiBmLmZyb21CeXRlQXJyYXkoZSl9ZWxzZXtyZXR1cm4gZi5mcm9tQnl0ZUFycmF5KGUuc2xpY2Uocix0KSl9fWZ1bmN0aW9uIHV0ZjhTbGljZShlLHIsdCl7dD1NYXRoLm1pbihlLmxlbmd0aCx0KTt2YXIgZj1bXTt2YXIgbj1yO3doaWxlKG48dCl7dmFyIGk9ZVtuXTt2YXIgbz1udWxsO3ZhciB1PWk+MjM5PzQ6aT4yMjM/MzppPjE5MT8yOjE7aWYobit1PD10KXt2YXIgYSxzLGgsYztzd2l0Y2godSl7Y2FzZSAxOmlmKGk8MTI4KXtvPWl9YnJlYWs7Y2FzZSAyOmE9ZVtuKzFdO2lmKChhJjE5Mik9PT0xMjgpe2M9KGkmMzEpPDw2fGEmNjM7aWYoYz4xMjcpe289Y319YnJlYWs7Y2FzZSAzOmE9ZVtuKzFdO3M9ZVtuKzJdO2lmKChhJjE5Mik9PT0xMjgmJihzJjE5Mik9PT0xMjgpe2M9KGkmMTUpPDwxMnwoYSY2Myk8PDZ8cyY2MztpZihjPjIwNDcmJihjPDU1Mjk2fHxjPjU3MzQzKSl7bz1jfX1icmVhaztjYXNlIDQ6YT1lW24rMV07cz1lW24rMl07aD1lW24rM107aWYoKGEmMTkyKT09PTEyOCYmKHMmMTkyKT09PTEyOCYmKGgmMTkyKT09PTEyOCl7Yz0oaSYxNSk8PDE4fChhJjYzKTw8MTJ8KHMmNjMpPDw2fGgmNjM7aWYoYz42NTUzNSYmYzwxMTE0MTEyKXtvPWN9fX19aWYobz09PW51bGwpe289NjU1MzM7dT0xfWVsc2UgaWYobz42NTUzNSl7by09NjU1MzY7Zi5wdXNoKG8+Pj4xMCYxMDIzfDU1Mjk2KTtvPTU2MzIwfG8mMTAyM31mLnB1c2gobyk7bis9dX1yZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KGYpfXZhciB1PTQwOTY7ZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5KGUpe3ZhciByPWUubGVuZ3RoO2lmKHI8PXUpe3JldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyxlKX12YXIgdD1cIlwiO3ZhciBmPTA7d2hpbGUoZjxyKXt0Kz1TdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyxlLnNsaWNlKGYsZis9dSkpfXJldHVybiB0fWZ1bmN0aW9uIGFzY2lpU2xpY2UoZSxyLHQpe3ZhciBmPVwiXCI7dD1NYXRoLm1pbihlLmxlbmd0aCx0KTtmb3IodmFyIG49cjtuPHQ7KytuKXtmKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGVbbl0mMTI3KX1yZXR1cm4gZn1mdW5jdGlvbiBsYXRpbjFTbGljZShlLHIsdCl7dmFyIGY9XCJcIjt0PU1hdGgubWluKGUubGVuZ3RoLHQpO2Zvcih2YXIgbj1yO248dDsrK24pe2YrPVN0cmluZy5mcm9tQ2hhckNvZGUoZVtuXSl9cmV0dXJuIGZ9ZnVuY3Rpb24gaGV4U2xpY2UoZSxyLHQpe3ZhciBmPWUubGVuZ3RoO2lmKCFyfHxyPDApcj0wO2lmKCF0fHx0PDB8fHQ+Zil0PWY7dmFyIG49XCJcIjtmb3IodmFyIGk9cjtpPHQ7KytpKXtuKz1zW2VbaV1dfXJldHVybiBufWZ1bmN0aW9uIHV0ZjE2bGVTbGljZShlLHIsdCl7dmFyIGY9ZS5zbGljZShyLHQpO3ZhciBuPVwiXCI7Zm9yKHZhciBpPTA7aTxmLmxlbmd0aDtpKz0yKXtuKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGZbaV0rZltpKzFdKjI1Nil9cmV0dXJuIG59QnVmZmVyLnByb3RvdHlwZS5zbGljZT1mdW5jdGlvbiBzbGljZShlLHIpe3ZhciB0PXRoaXMubGVuZ3RoO2U9fn5lO3I9cj09PXVuZGVmaW5lZD90On5+cjtpZihlPDApe2UrPXQ7aWYoZTwwKWU9MH1lbHNlIGlmKGU+dCl7ZT10fWlmKHI8MCl7cis9dDtpZihyPDApcj0wfWVsc2UgaWYocj50KXtyPXR9aWYocjxlKXI9ZTt2YXIgZj10aGlzLnN1YmFycmF5KGUscik7T2JqZWN0LnNldFByb3RvdHlwZU9mKGYsQnVmZmVyLnByb3RvdHlwZSk7cmV0dXJuIGZ9O2Z1bmN0aW9uIGNoZWNrT2Zmc2V0KGUscix0KXtpZihlJTEhPT0wfHxlPDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJvZmZzZXQgaXMgbm90IHVpbnRcIik7aWYoZStyPnQpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoXCIpfUJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRT1mdW5jdGlvbiByZWFkVUludExFKGUscix0KXtlPWU+Pj4wO3I9cj4+PjA7aWYoIXQpY2hlY2tPZmZzZXQoZSxyLHRoaXMubGVuZ3RoKTt2YXIgZj10aGlzW2VdO3ZhciBuPTE7dmFyIGk9MDt3aGlsZSgrK2k8ciYmKG4qPTI1Nikpe2YrPXRoaXNbZStpXSpufXJldHVybiBmfTtCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkU9ZnVuY3Rpb24gcmVhZFVJbnRCRShlLHIsdCl7ZT1lPj4+MDtyPXI+Pj4wO2lmKCF0KXtjaGVja09mZnNldChlLHIsdGhpcy5sZW5ndGgpfXZhciBmPXRoaXNbZSstLXJdO3ZhciBuPTE7d2hpbGUocj4wJiYobio9MjU2KSl7Zis9dGhpc1tlKy0tcl0qbn1yZXR1cm4gZn07QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDg9ZnVuY3Rpb24gcmVhZFVJbnQ4KGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDEsdGhpcy5sZW5ndGgpO3JldHVybiB0aGlzW2VdfTtCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRT1mdW5jdGlvbiByZWFkVUludDE2TEUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsMix0aGlzLmxlbmd0aCk7cmV0dXJuIHRoaXNbZV18dGhpc1tlKzFdPDw4fTtCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRT1mdW5jdGlvbiByZWFkVUludDE2QkUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsMix0aGlzLmxlbmd0aCk7cmV0dXJuIHRoaXNbZV08PDh8dGhpc1tlKzFdfTtCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRT1mdW5jdGlvbiByZWFkVUludDMyTEUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsNCx0aGlzLmxlbmd0aCk7cmV0dXJuKHRoaXNbZV18dGhpc1tlKzFdPDw4fHRoaXNbZSsyXTw8MTYpK3RoaXNbZSszXSoxNjc3NzIxNn07QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkU9ZnVuY3Rpb24gcmVhZFVJbnQzMkJFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDQsdGhpcy5sZW5ndGgpO3JldHVybiB0aGlzW2VdKjE2Nzc3MjE2Kyh0aGlzW2UrMV08PDE2fHRoaXNbZSsyXTw8OHx0aGlzW2UrM10pfTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRT1mdW5jdGlvbiByZWFkSW50TEUoZSxyLHQpe2U9ZT4+PjA7cj1yPj4+MDtpZighdCljaGVja09mZnNldChlLHIsdGhpcy5sZW5ndGgpO3ZhciBmPXRoaXNbZV07dmFyIG49MTt2YXIgaT0wO3doaWxlKCsraTxyJiYobio9MjU2KSl7Zis9dGhpc1tlK2ldKm59bio9MTI4O2lmKGY+PW4pZi09TWF0aC5wb3coMiw4KnIpO3JldHVybiBmfTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRT1mdW5jdGlvbiByZWFkSW50QkUoZSxyLHQpe2U9ZT4+PjA7cj1yPj4+MDtpZighdCljaGVja09mZnNldChlLHIsdGhpcy5sZW5ndGgpO3ZhciBmPXI7dmFyIG49MTt2YXIgaT10aGlzW2UrLS1mXTt3aGlsZShmPjAmJihuKj0yNTYpKXtpKz10aGlzW2UrLS1mXSpufW4qPTEyODtpZihpPj1uKWktPU1hdGgucG93KDIsOCpyKTtyZXR1cm4gaX07QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OD1mdW5jdGlvbiByZWFkSW50OChlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSwxLHRoaXMubGVuZ3RoKTtpZighKHRoaXNbZV0mMTI4KSlyZXR1cm4gdGhpc1tlXTtyZXR1cm4oMjU1LXRoaXNbZV0rMSkqLTF9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEU9ZnVuY3Rpb24gcmVhZEludDE2TEUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsMix0aGlzLmxlbmd0aCk7dmFyIHQ9dGhpc1tlXXx0aGlzW2UrMV08PDg7cmV0dXJuIHQmMzI3Njg/dHw0Mjk0OTAxNzYwOnR9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkU9ZnVuY3Rpb24gcmVhZEludDE2QkUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsMix0aGlzLmxlbmd0aCk7dmFyIHQ9dGhpc1tlKzFdfHRoaXNbZV08PDg7cmV0dXJuIHQmMzI3Njg/dHw0Mjk0OTAxNzYwOnR9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEU9ZnVuY3Rpb24gcmVhZEludDMyTEUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsNCx0aGlzLmxlbmd0aCk7cmV0dXJuIHRoaXNbZV18dGhpc1tlKzFdPDw4fHRoaXNbZSsyXTw8MTZ8dGhpc1tlKzNdPDwyNH07QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRT1mdW5jdGlvbiByZWFkSW50MzJCRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw0LHRoaXMubGVuZ3RoKTtyZXR1cm4gdGhpc1tlXTw8MjR8dGhpc1tlKzFdPDwxNnx0aGlzW2UrMl08PDh8dGhpc1tlKzNdfTtCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFPWZ1bmN0aW9uIHJlYWRGbG9hdExFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDQsdGhpcy5sZW5ndGgpO3JldHVybiBuLnJlYWQodGhpcyxlLHRydWUsMjMsNCl9O0J1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkU9ZnVuY3Rpb24gcmVhZEZsb2F0QkUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsNCx0aGlzLmxlbmd0aCk7cmV0dXJuIG4ucmVhZCh0aGlzLGUsZmFsc2UsMjMsNCl9O0J1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFPWZ1bmN0aW9uIHJlYWREb3VibGVMRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw4LHRoaXMubGVuZ3RoKTtyZXR1cm4gbi5yZWFkKHRoaXMsZSx0cnVlLDUyLDgpfTtCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRT1mdW5jdGlvbiByZWFkRG91YmxlQkUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsOCx0aGlzLmxlbmd0aCk7cmV0dXJuIG4ucmVhZCh0aGlzLGUsZmFsc2UsNTIsOCl9O2Z1bmN0aW9uIGNoZWNrSW50KGUscix0LGYsbixpKXtpZighQnVmZmVyLmlzQnVmZmVyKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpO2lmKHI+bnx8cjxpKXRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpO2lmKHQrZj5lLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKX1CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFPWZ1bmN0aW9uIHdyaXRlVUludExFKGUscix0LGYpe2U9K2U7cj1yPj4+MDt0PXQ+Pj4wO2lmKCFmKXt2YXIgbj1NYXRoLnBvdygyLDgqdCktMTtjaGVja0ludCh0aGlzLGUscix0LG4sMCl9dmFyIGk9MTt2YXIgbz0wO3RoaXNbcl09ZSYyNTU7d2hpbGUoKytvPHQmJihpKj0yNTYpKXt0aGlzW3Irb109ZS9pJjI1NX1yZXR1cm4gcit0fTtCdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFPWZ1bmN0aW9uIHdyaXRlVUludEJFKGUscix0LGYpe2U9K2U7cj1yPj4+MDt0PXQ+Pj4wO2lmKCFmKXt2YXIgbj1NYXRoLnBvdygyLDgqdCktMTtjaGVja0ludCh0aGlzLGUscix0LG4sMCl9dmFyIGk9dC0xO3ZhciBvPTE7dGhpc1tyK2ldPWUmMjU1O3doaWxlKC0taT49MCYmKG8qPTI1Nikpe3RoaXNbcitpXT1lL28mMjU1fXJldHVybiByK3R9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OD1mdW5jdGlvbiB3cml0ZVVJbnQ4KGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsMSwyNTUsMCk7dGhpc1tyXT1lJjI1NTtyZXR1cm4gcisxfTtCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEU9ZnVuY3Rpb24gd3JpdGVVSW50MTZMRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDIsNjU1MzUsMCk7dGhpc1tyXT1lJjI1NTt0aGlzW3IrMV09ZT4+Pjg7cmV0dXJuIHIrMn07QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFPWZ1bmN0aW9uIHdyaXRlVUludDE2QkUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciwyLDY1NTM1LDApO3RoaXNbcl09ZT4+Pjg7dGhpc1tyKzFdPWUmMjU1O3JldHVybiByKzJ9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRT1mdW5jdGlvbiB3cml0ZVVJbnQzMkxFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsNCw0Mjk0OTY3Mjk1LDApO3RoaXNbciszXT1lPj4+MjQ7dGhpc1tyKzJdPWU+Pj4xNjt0aGlzW3IrMV09ZT4+Pjg7dGhpc1tyXT1lJjI1NTtyZXR1cm4gcis0fTtCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkU9ZnVuY3Rpb24gd3JpdGVVSW50MzJCRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDQsNDI5NDk2NzI5NSwwKTt0aGlzW3JdPWU+Pj4yNDt0aGlzW3IrMV09ZT4+PjE2O3RoaXNbcisyXT1lPj4+ODt0aGlzW3IrM109ZSYyNTU7cmV0dXJuIHIrNH07QnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFPWZ1bmN0aW9uIHdyaXRlSW50TEUoZSxyLHQsZil7ZT0rZTtyPXI+Pj4wO2lmKCFmKXt2YXIgbj1NYXRoLnBvdygyLDgqdC0xKTtjaGVja0ludCh0aGlzLGUscix0LG4tMSwtbil9dmFyIGk9MDt2YXIgbz0xO3ZhciB1PTA7dGhpc1tyXT1lJjI1NTt3aGlsZSgrK2k8dCYmKG8qPTI1Nikpe2lmKGU8MCYmdT09PTAmJnRoaXNbcitpLTFdIT09MCl7dT0xfXRoaXNbcitpXT0oZS9vPj4wKS11JjI1NX1yZXR1cm4gcit0fTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkU9ZnVuY3Rpb24gd3JpdGVJbnRCRShlLHIsdCxmKXtlPStlO3I9cj4+PjA7aWYoIWYpe3ZhciBuPU1hdGgucG93KDIsOCp0LTEpO2NoZWNrSW50KHRoaXMsZSxyLHQsbi0xLC1uKX12YXIgaT10LTE7dmFyIG89MTt2YXIgdT0wO3RoaXNbcitpXT1lJjI1NTt3aGlsZSgtLWk+PTAmJihvKj0yNTYpKXtpZihlPDAmJnU9PT0wJiZ0aGlzW3IraSsxXSE9PTApe3U9MX10aGlzW3IraV09KGUvbz4+MCktdSYyNTV9cmV0dXJuIHIrdH07QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDg9ZnVuY3Rpb24gd3JpdGVJbnQ4KGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsMSwxMjcsLTEyOCk7aWYoZTwwKWU9MjU1K2UrMTt0aGlzW3JdPWUmMjU1O3JldHVybiByKzF9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFPWZ1bmN0aW9uIHdyaXRlSW50MTZMRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDIsMzI3NjcsLTMyNzY4KTt0aGlzW3JdPWUmMjU1O3RoaXNbcisxXT1lPj4+ODtyZXR1cm4gcisyfTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRT1mdW5jdGlvbiB3cml0ZUludDE2QkUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciwyLDMyNzY3LC0zMjc2OCk7dGhpc1tyXT1lPj4+ODt0aGlzW3IrMV09ZSYyNTU7cmV0dXJuIHIrMn07QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEU9ZnVuY3Rpb24gd3JpdGVJbnQzMkxFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsNCwyMTQ3NDgzNjQ3LC0yMTQ3NDgzNjQ4KTt0aGlzW3JdPWUmMjU1O3RoaXNbcisxXT1lPj4+ODt0aGlzW3IrMl09ZT4+PjE2O3RoaXNbciszXT1lPj4+MjQ7cmV0dXJuIHIrNH07QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkU9ZnVuY3Rpb24gd3JpdGVJbnQzMkJFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsNCwyMTQ3NDgzNjQ3LC0yMTQ3NDgzNjQ4KTtpZihlPDApZT00Mjk0OTY3Mjk1K2UrMTt0aGlzW3JdPWU+Pj4yNDt0aGlzW3IrMV09ZT4+PjE2O3RoaXNbcisyXT1lPj4+ODt0aGlzW3IrM109ZSYyNTU7cmV0dXJuIHIrNH07ZnVuY3Rpb24gY2hlY2tJRUVFNzU0KGUscix0LGYsbixpKXtpZih0K2Y+ZS5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIik7aWYodDwwKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpfWZ1bmN0aW9uIHdyaXRlRmxvYXQoZSxyLHQsZixpKXtyPStyO3Q9dD4+PjA7aWYoIWkpe2NoZWNrSUVFRTc1NChlLHIsdCw0LDM0MDI4MjM0NjYzODUyODg2ZTIyLC0zNDAyODIzNDY2Mzg1Mjg4NmUyMil9bi53cml0ZShlLHIsdCxmLDIzLDQpO3JldHVybiB0KzR9QnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEU9ZnVuY3Rpb24gd3JpdGVGbG9hdExFKGUscix0KXtyZXR1cm4gd3JpdGVGbG9hdCh0aGlzLGUscix0cnVlLHQpfTtCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRT1mdW5jdGlvbiB3cml0ZUZsb2F0QkUoZSxyLHQpe3JldHVybiB3cml0ZUZsb2F0KHRoaXMsZSxyLGZhbHNlLHQpfTtmdW5jdGlvbiB3cml0ZURvdWJsZShlLHIsdCxmLGkpe3I9K3I7dD10Pj4+MDtpZighaSl7Y2hlY2tJRUVFNzU0KGUscix0LDgsMTc5NzY5MzEzNDg2MjMxNTdlMjkyLC0xNzk3NjkzMTM0ODYyMzE1N2UyOTIpfW4ud3JpdGUoZSxyLHQsZiw1Miw4KTtyZXR1cm4gdCs4fUJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRT1mdW5jdGlvbiB3cml0ZURvdWJsZUxFKGUscix0KXtyZXR1cm4gd3JpdGVEb3VibGUodGhpcyxlLHIsdHJ1ZSx0KX07QnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFPWZ1bmN0aW9uIHdyaXRlRG91YmxlQkUoZSxyLHQpe3JldHVybiB3cml0ZURvdWJsZSh0aGlzLGUscixmYWxzZSx0KX07QnVmZmVyLnByb3RvdHlwZS5jb3B5PWZ1bmN0aW9uIGNvcHkoZSxyLHQsZil7aWYoIUJ1ZmZlci5pc0J1ZmZlcihlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXJndW1lbnQgc2hvdWxkIGJlIGEgQnVmZmVyXCIpO2lmKCF0KXQ9MDtpZighZiYmZiE9PTApZj10aGlzLmxlbmd0aDtpZihyPj1lLmxlbmd0aClyPWUubGVuZ3RoO2lmKCFyKXI9MDtpZihmPjAmJmY8dClmPXQ7aWYoZj09PXQpcmV0dXJuIDA7aWYoZS5sZW5ndGg9PT0wfHx0aGlzLmxlbmd0aD09PTApcmV0dXJuIDA7aWYocjwwKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInRhcmdldFN0YXJ0IG91dCBvZiBib3VuZHNcIil9aWYodDwwfHx0Pj10aGlzLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKTtpZihmPDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJzb3VyY2VFbmQgb3V0IG9mIGJvdW5kc1wiKTtpZihmPnRoaXMubGVuZ3RoKWY9dGhpcy5sZW5ndGg7aWYoZS5sZW5ndGgtcjxmLXQpe2Y9ZS5sZW5ndGgtcit0fXZhciBuPWYtdDtpZih0aGlzPT09ZSYmdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW49PT1cImZ1bmN0aW9uXCIpe3RoaXMuY29weVdpdGhpbihyLHQsZil9ZWxzZSBpZih0aGlzPT09ZSYmdDxyJiZyPGYpe2Zvcih2YXIgaT1uLTE7aT49MDstLWkpe2VbaStyXT10aGlzW2krdF19fWVsc2V7VWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoZSx0aGlzLnN1YmFycmF5KHQsZikscil9cmV0dXJuIG59O0J1ZmZlci5wcm90b3R5cGUuZmlsbD1mdW5jdGlvbiBmaWxsKGUscix0LGYpe2lmKHR5cGVvZiBlPT09XCJzdHJpbmdcIil7aWYodHlwZW9mIHI9PT1cInN0cmluZ1wiKXtmPXI7cj0wO3Q9dGhpcy5sZW5ndGh9ZWxzZSBpZih0eXBlb2YgdD09PVwic3RyaW5nXCIpe2Y9dDt0PXRoaXMubGVuZ3RofWlmKGYhPT11bmRlZmluZWQmJnR5cGVvZiBmIT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcImVuY29kaW5nIG11c3QgYmUgYSBzdHJpbmdcIil9aWYodHlwZW9mIGY9PT1cInN0cmluZ1wiJiYhQnVmZmVyLmlzRW5jb2RpbmcoZikpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIitmKX1pZihlLmxlbmd0aD09PTEpe3ZhciBuPWUuY2hhckNvZGVBdCgwKTtpZihmPT09XCJ1dGY4XCImJm48MTI4fHxmPT09XCJsYXRpbjFcIil7ZT1ufX19ZWxzZSBpZih0eXBlb2YgZT09PVwibnVtYmVyXCIpe2U9ZSYyNTV9ZWxzZSBpZih0eXBlb2YgZT09PVwiYm9vbGVhblwiKXtlPU51bWJlcihlKX1pZihyPDB8fHRoaXMubGVuZ3RoPHJ8fHRoaXMubGVuZ3RoPHQpe3Rocm93IG5ldyBSYW5nZUVycm9yKFwiT3V0IG9mIHJhbmdlIGluZGV4XCIpfWlmKHQ8PXIpe3JldHVybiB0aGlzfXI9cj4+PjA7dD10PT09dW5kZWZpbmVkP3RoaXMubGVuZ3RoOnQ+Pj4wO2lmKCFlKWU9MDt2YXIgaTtpZih0eXBlb2YgZT09PVwibnVtYmVyXCIpe2ZvcihpPXI7aTx0OysraSl7dGhpc1tpXT1lfX1lbHNle3ZhciBvPUJ1ZmZlci5pc0J1ZmZlcihlKT9lOkJ1ZmZlci5mcm9tKGUsZik7dmFyIHU9by5sZW5ndGg7aWYodT09PTApe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSB2YWx1ZSBcIicrZSsnXCIgaXMgaW52YWxpZCBmb3IgYXJndW1lbnQgXCJ2YWx1ZVwiJyl9Zm9yKGk9MDtpPHQtcjsrK2kpe3RoaXNbaStyXT1vW2kldV19fXJldHVybiB0aGlzfTt2YXIgYT0vW14rLzAtOUEtWmEtei1fXS9nO2Z1bmN0aW9uIGJhc2U2NGNsZWFuKGUpe2U9ZS5zcGxpdChcIj1cIilbMF07ZT1lLnRyaW0oKS5yZXBsYWNlKGEsXCJcIik7aWYoZS5sZW5ndGg8MilyZXR1cm5cIlwiO3doaWxlKGUubGVuZ3RoJTQhPT0wKXtlPWUrXCI9XCJ9cmV0dXJuIGV9ZnVuY3Rpb24gdXRmOFRvQnl0ZXMoZSxyKXtyPXJ8fEluZmluaXR5O3ZhciB0O3ZhciBmPWUubGVuZ3RoO3ZhciBuPW51bGw7dmFyIGk9W107Zm9yKHZhciBvPTA7bzxmOysrbyl7dD1lLmNoYXJDb2RlQXQobyk7aWYodD41NTI5NSYmdDw1NzM0NCl7aWYoIW4pe2lmKHQ+NTYzMTkpe2lmKChyLT0zKT4tMSlpLnB1c2goMjM5LDE5MSwxODkpO2NvbnRpbnVlfWVsc2UgaWYobysxPT09Zil7aWYoKHItPTMpPi0xKWkucHVzaCgyMzksMTkxLDE4OSk7Y29udGludWV9bj10O2NvbnRpbnVlfWlmKHQ8NTYzMjApe2lmKChyLT0zKT4tMSlpLnB1c2goMjM5LDE5MSwxODkpO249dDtjb250aW51ZX10PShuLTU1Mjk2PDwxMHx0LTU2MzIwKSs2NTUzNn1lbHNlIGlmKG4pe2lmKChyLT0zKT4tMSlpLnB1c2goMjM5LDE5MSwxODkpfW49bnVsbDtpZih0PDEyOCl7aWYoKHItPTEpPDApYnJlYWs7aS5wdXNoKHQpfWVsc2UgaWYodDwyMDQ4KXtpZigoci09Mik8MClicmVhaztpLnB1c2godD4+NnwxOTIsdCY2M3wxMjgpfWVsc2UgaWYodDw2NTUzNil7aWYoKHItPTMpPDApYnJlYWs7aS5wdXNoKHQ+PjEyfDIyNCx0Pj42JjYzfDEyOCx0JjYzfDEyOCl9ZWxzZSBpZih0PDExMTQxMTIpe2lmKChyLT00KTwwKWJyZWFrO2kucHVzaCh0Pj4xOHwyNDAsdD4+MTImNjN8MTI4LHQ+PjYmNjN8MTI4LHQmNjN8MTI4KX1lbHNle3Rocm93IG5ldyBFcnJvcihcIkludmFsaWQgY29kZSBwb2ludFwiKX19cmV0dXJuIGl9ZnVuY3Rpb24gYXNjaWlUb0J5dGVzKGUpe3ZhciByPVtdO2Zvcih2YXIgdD0wO3Q8ZS5sZW5ndGg7Kyt0KXtyLnB1c2goZS5jaGFyQ29kZUF0KHQpJjI1NSl9cmV0dXJuIHJ9ZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMoZSxyKXt2YXIgdCxmLG47dmFyIGk9W107Zm9yKHZhciBvPTA7bzxlLmxlbmd0aDsrK28pe2lmKChyLT0yKTwwKWJyZWFrO3Q9ZS5jaGFyQ29kZUF0KG8pO2Y9dD4+ODtuPXQlMjU2O2kucHVzaChuKTtpLnB1c2goZil9cmV0dXJuIGl9ZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyhlKXtyZXR1cm4gZi50b0J5dGVBcnJheShiYXNlNjRjbGVhbihlKSl9ZnVuY3Rpb24gYmxpdEJ1ZmZlcihlLHIsdCxmKXtmb3IodmFyIG49MDtuPGY7KytuKXtpZihuK3Q+PXIubGVuZ3RofHxuPj1lLmxlbmd0aClicmVhaztyW24rdF09ZVtuXX1yZXR1cm4gbn1mdW5jdGlvbiBpc0luc3RhbmNlKGUscil7cmV0dXJuIGUgaW5zdGFuY2VvZiByfHxlIT1udWxsJiZlLmNvbnN0cnVjdG9yIT1udWxsJiZlLmNvbnN0cnVjdG9yLm5hbWUhPW51bGwmJmUuY29uc3RydWN0b3IubmFtZT09PXIubmFtZX1mdW5jdGlvbiBudW1iZXJJc05hTihlKXtyZXR1cm4gZSE9PWV9dmFyIHM9ZnVuY3Rpb24oKXt2YXIgZT1cIjAxMjM0NTY3ODlhYmNkZWZcIjt2YXIgcj1uZXcgQXJyYXkoMjU2KTtmb3IodmFyIHQ9MDt0PDE2OysrdCl7dmFyIGY9dCoxNjtmb3IodmFyIG49MDtuPDE2Oysrbil7cltmK25dPWVbdF0rZVtuXX19cmV0dXJuIHJ9KCl9LDc4MzpmdW5jdGlvbihlLHIpe1xuLyohIGllZWU3NTQuIEJTRC0zLUNsYXVzZSBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbnIucmVhZD1mdW5jdGlvbihlLHIsdCxmLG4pe3ZhciBpLG87dmFyIHU9bio4LWYtMTt2YXIgYT0oMTw8dSktMTt2YXIgcz1hPj4xO3ZhciBoPS03O3ZhciBjPXQ/bi0xOjA7dmFyIGw9dD8tMToxO3ZhciBwPWVbcitjXTtjKz1sO2k9cCYoMTw8LWgpLTE7cD4+PS1oO2grPXU7Zm9yKDtoPjA7aT1pKjI1NitlW3IrY10sYys9bCxoLT04KXt9bz1pJigxPDwtaCktMTtpPj49LWg7aCs9Zjtmb3IoO2g+MDtvPW8qMjU2K2VbcitjXSxjKz1sLGgtPTgpe31pZihpPT09MCl7aT0xLXN9ZWxzZSBpZihpPT09YSl7cmV0dXJuIG8/TmFOOihwPy0xOjEpKkluZmluaXR5fWVsc2V7bz1vK01hdGgucG93KDIsZik7aT1pLXN9cmV0dXJuKHA/LTE6MSkqbypNYXRoLnBvdygyLGktZil9O3Iud3JpdGU9ZnVuY3Rpb24oZSxyLHQsZixuLGkpe3ZhciBvLHUsYTt2YXIgcz1pKjgtbi0xO3ZhciBoPSgxPDxzKS0xO3ZhciBjPWg+PjE7dmFyIGw9bj09PTIzP01hdGgucG93KDIsLTI0KS1NYXRoLnBvdygyLC03Nyk6MDt2YXIgcD1mPzA6aS0xO3ZhciB5PWY/MTotMTt2YXIgZz1yPDB8fHI9PT0wJiYxL3I8MD8xOjA7cj1NYXRoLmFicyhyKTtpZihpc05hTihyKXx8cj09PUluZmluaXR5KXt1PWlzTmFOKHIpPzE6MDtvPWh9ZWxzZXtvPU1hdGguZmxvb3IoTWF0aC5sb2cocikvTWF0aC5MTjIpO2lmKHIqKGE9TWF0aC5wb3coMiwtbykpPDEpe28tLTthKj0yfWlmKG8rYz49MSl7cis9bC9hfWVsc2V7cis9bCpNYXRoLnBvdygyLDEtYyl9aWYociphPj0yKXtvKys7YS89Mn1pZihvK2M+PWgpe3U9MDtvPWh9ZWxzZSBpZihvK2M+PTEpe3U9KHIqYS0xKSpNYXRoLnBvdygyLG4pO289bytjfWVsc2V7dT1yKk1hdGgucG93KDIsYy0xKSpNYXRoLnBvdygyLG4pO289MH19Zm9yKDtuPj04O2VbdCtwXT11JjI1NSxwKz15LHUvPTI1NixuLT04KXt9bz1vPDxufHU7cys9bjtmb3IoO3M+MDtlW3QrcF09byYyNTUscCs9eSxvLz0yNTYscy09OCl7fWVbdCtwLXldfD1nKjEyOH19fTt2YXIgcj17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHQpe3ZhciBmPXJbdF07aWYoZiE9PXVuZGVmaW5lZCl7cmV0dXJuIGYuZXhwb3J0c312YXIgbj1yW3RdPXtleHBvcnRzOnt9fTt2YXIgaT10cnVlO3RyeXtlW3RdKG4sbi5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO2k9ZmFsc2V9ZmluYWxseXtpZihpKWRlbGV0ZSByW3RdfXJldHVybiBuLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciB0PV9fbmNjd3Bja19yZXF1aXJlX18oNzIpO21vZHVsZS5leHBvcnRzPXR9KSgpOyJdLCJuYW1lcyI6WyJlIiwiciIsImJ5dGVMZW5ndGgiLCJ0b0J5dGVBcnJheSIsImZyb21CeXRlQXJyYXkiLCJ0IiwiZiIsIm4iLCJVaW50OEFycmF5IiwiQXJyYXkiLCJpIiwibyIsInUiLCJsZW5ndGgiLCJjaGFyQ29kZUF0IiwiZ2V0TGVucyIsIkVycm9yIiwiaW5kZXhPZiIsIl9ieXRlTGVuZ3RoIiwiYSIsInMiLCJoIiwidHJpcGxldFRvQmFzZTY0IiwiZW5jb2RlQ2h1bmsiLCJwdXNoIiwiam9pbiIsIlN5bWJvbCIsImZvciIsIkJ1ZmZlciIsIlNsb3dCdWZmZXIiLCJJTlNQRUNUX01BWF9CWVRFUyIsImtNYXhMZW5ndGgiLCJUWVBFRF9BUlJBWV9TVVBQT1JUIiwidHlwZWRBcnJheVN1cHBvcnQiLCJjb25zb2xlIiwiZXJyb3IiLCJmb28iLCJPYmplY3QiLCJzZXRQcm90b3R5cGVPZiIsInByb3RvdHlwZSIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImdldCIsImlzQnVmZmVyIiwidW5kZWZpbmVkIiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsImNyZWF0ZUJ1ZmZlciIsIlJhbmdlRXJyb3IiLCJUeXBlRXJyb3IiLCJhbGxvY1Vuc2FmZSIsImZyb20iLCJwb29sU2l6ZSIsImZyb21TdHJpbmciLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsImZyb21BcnJheUxpa2UiLCJpc0luc3RhbmNlIiwiZnJvbUFycmF5QnVmZmVyIiwiU2hhcmVkQXJyYXlCdWZmZXIiLCJ2YWx1ZU9mIiwiZnJvbU9iamVjdCIsInRvUHJpbWl0aXZlIiwiYXNzZXJ0U2l6ZSIsImFsbG9jIiwiZmlsbCIsImNoZWNrZWQiLCJhbGxvY1Vuc2FmZVNsb3ciLCJpc0VuY29kaW5nIiwid3JpdGUiLCJzbGljZSIsImNvcHkiLCJudW1iZXJJc05hTiIsInR5cGUiLCJpc0FycmF5IiwiZGF0YSIsInRvU3RyaW5nIiwiX2lzQnVmZmVyIiwiY29tcGFyZSIsIm9mZnNldCIsIk1hdGgiLCJtaW4iLCJTdHJpbmciLCJ0b0xvd2VyQ2FzZSIsImNvbmNhdCIsImFyZ3VtZW50cyIsInV0ZjhUb0J5dGVzIiwiYmFzZTY0VG9CeXRlcyIsInNsb3dUb1N0cmluZyIsImhleFNsaWNlIiwidXRmOFNsaWNlIiwiYXNjaWlTbGljZSIsImxhdGluMVNsaWNlIiwiYmFzZTY0U2xpY2UiLCJ1dGYxNmxlU2xpY2UiLCJzd2FwIiwic3dhcDE2Iiwic3dhcDMyIiwic3dhcDY0IiwiYXBwbHkiLCJ0b0xvY2FsZVN0cmluZyIsImVxdWFscyIsImluc3BlY3QiLCJyZXBsYWNlIiwidHJpbSIsImJpZGlyZWN0aW9uYWxJbmRleE9mIiwiYXJyYXlJbmRleE9mIiwiY2FsbCIsImxhc3RJbmRleE9mIiwicmVhZCIsInJlYWRVSW50MTZCRSIsImMiLCJpbmNsdWRlcyIsImhleFdyaXRlIiwiTnVtYmVyIiwicGFyc2VJbnQiLCJzdWJzdHIiLCJ1dGY4V3JpdGUiLCJibGl0QnVmZmVyIiwiYXNjaWlXcml0ZSIsImFzY2lpVG9CeXRlcyIsImxhdGluMVdyaXRlIiwiYmFzZTY0V3JpdGUiLCJ1Y3MyV3JpdGUiLCJ1dGYxNmxlVG9CeXRlcyIsImlzRmluaXRlIiwidG9KU09OIiwiX2FyciIsImRlY29kZUNvZGVQb2ludHNBcnJheSIsImZyb21DaGFyQ29kZSIsInN1YmFycmF5IiwiY2hlY2tPZmZzZXQiLCJyZWFkVUludExFIiwicmVhZFVJbnRCRSIsInJlYWRVSW50OCIsInJlYWRVSW50MTZMRSIsInJlYWRVSW50MzJMRSIsInJlYWRVSW50MzJCRSIsInJlYWRJbnRMRSIsInBvdyIsInJlYWRJbnRCRSIsInJlYWRJbnQ4IiwicmVhZEludDE2TEUiLCJyZWFkSW50MTZCRSIsInJlYWRJbnQzMkxFIiwicmVhZEludDMyQkUiLCJyZWFkRmxvYXRMRSIsInJlYWRGbG9hdEJFIiwicmVhZERvdWJsZUxFIiwicmVhZERvdWJsZUJFIiwiY2hlY2tJbnQiLCJ3cml0ZVVJbnRMRSIsIndyaXRlVUludEJFIiwid3JpdGVVSW50OCIsIndyaXRlVUludDE2TEUiLCJ3cml0ZVVJbnQxNkJFIiwid3JpdGVVSW50MzJMRSIsIndyaXRlVUludDMyQkUiLCJ3cml0ZUludExFIiwid3JpdGVJbnRCRSIsIndyaXRlSW50OCIsIndyaXRlSW50MTZMRSIsIndyaXRlSW50MTZCRSIsIndyaXRlSW50MzJMRSIsIndyaXRlSW50MzJCRSIsImNoZWNrSUVFRTc1NCIsIndyaXRlRmxvYXQiLCJ3cml0ZUZsb2F0TEUiLCJ3cml0ZUZsb2F0QkUiLCJ3cml0ZURvdWJsZSIsIndyaXRlRG91YmxlTEUiLCJ3cml0ZURvdWJsZUJFIiwiY29weVdpdGhpbiIsInNldCIsImJhc2U2NGNsZWFuIiwic3BsaXQiLCJJbmZpbml0eSIsImNvbnN0cnVjdG9yIiwibmFtZSIsImwiLCJwIiwiTmFOIiwieSIsImciLCJhYnMiLCJpc05hTiIsImZsb29yIiwibG9nIiwiTE4yIiwiX19uY2N3cGNrX3JlcXVpcmVfXyIsImV4cG9ydHMiLCJhYiIsIl9fZGlybmFtZSIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/micromatch/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/compiled/micromatch/index.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("var __dirname = \"/\";\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\n(()=>{\n    \"use strict\";\n    var e = {\n        333: (e, t, r)=>{\n            const n = r(137);\n            const u = r(179);\n            const s = r(13);\n            const o = r(719);\n            const braces = function(e) {\n                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                let r = [];\n                if (Array.isArray(e)) {\n                    for (let n of e){\n                        let e = braces.create(n, t);\n                        if (Array.isArray(e)) {\n                            r.push(...e);\n                        } else {\n                            r.push(e);\n                        }\n                    }\n                } else {\n                    r = [].concat(braces.create(e, t));\n                }\n                if (t && t.expand === true && t.nodupes === true) {\n                    r = [\n                        ...new Set(r)\n                    ];\n                }\n                return r;\n            };\n            braces.parse = function(e) {\n                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                return o(e, t);\n            };\n            braces.stringify = function(e) {\n                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                if (typeof e === \"string\") {\n                    return n(braces.parse(e, t), t);\n                }\n                return n(e, t);\n            };\n            braces.compile = function(e) {\n                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                if (typeof e === \"string\") {\n                    e = braces.parse(e, t);\n                }\n                return u(e, t);\n            };\n            braces.expand = function(e) {\n                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                if (typeof e === \"string\") {\n                    e = braces.parse(e, t);\n                }\n                let r = s(e, t);\n                if (t.noempty === true) {\n                    r = r.filter(Boolean);\n                }\n                if (t.nodupes === true) {\n                    r = [\n                        ...new Set(r)\n                    ];\n                }\n                return r;\n            };\n            braces.create = function(e) {\n                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                if (e === \"\" || e.length < 3) {\n                    return [\n                        e\n                    ];\n                }\n                return t.expand !== true ? braces.compile(e, t) : braces.expand(e, t);\n            };\n            e.exports = braces;\n        },\n        179: (e, t, r)=>{\n            const n = r(783);\n            const u = r(617);\n            const compile = function(e) {\n                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                let walk = function(e) {\n                    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                    let s = u.isInvalidBrace(r);\n                    let o = e.invalid === true && t.escapeInvalid === true;\n                    let i = s === true || o === true;\n                    let a = t.escapeInvalid === true ? \"\\\\\" : \"\";\n                    let l = \"\";\n                    if (e.isOpen === true) {\n                        return a + e.value;\n                    }\n                    if (e.isClose === true) {\n                        return a + e.value;\n                    }\n                    if (e.type === \"open\") {\n                        return i ? a + e.value : \"(\";\n                    }\n                    if (e.type === \"close\") {\n                        return i ? a + e.value : \")\";\n                    }\n                    if (e.type === \"comma\") {\n                        return e.prev.type === \"comma\" ? \"\" : i ? e.value : \"|\";\n                    }\n                    if (e.value) {\n                        return e.value;\n                    }\n                    if (e.nodes && e.ranges > 0) {\n                        let r = u.reduce(e.nodes);\n                        let s = n(...r, {\n                            ...t,\n                            wrap: false,\n                            toRegex: true\n                        });\n                        if (s.length !== 0) {\n                            return r.length > 1 && s.length > 1 ? \"(\".concat(s, \")\") : s;\n                        }\n                    }\n                    if (e.nodes) {\n                        for (let t of e.nodes){\n                            l += walk(t, e);\n                        }\n                    }\n                    return l;\n                };\n                return walk(e);\n            };\n            e.exports = compile;\n        },\n        457: (e)=>{\n            e.exports = {\n                MAX_LENGTH: 1024 * 64,\n                CHAR_0: \"0\",\n                CHAR_9: \"9\",\n                CHAR_UPPERCASE_A: \"A\",\n                CHAR_LOWERCASE_A: \"a\",\n                CHAR_UPPERCASE_Z: \"Z\",\n                CHAR_LOWERCASE_Z: \"z\",\n                CHAR_LEFT_PARENTHESES: \"(\",\n                CHAR_RIGHT_PARENTHESES: \")\",\n                CHAR_ASTERISK: \"*\",\n                CHAR_AMPERSAND: \"&\",\n                CHAR_AT: \"@\",\n                CHAR_BACKSLASH: \"\\\\\",\n                CHAR_BACKTICK: \"`\",\n                CHAR_CARRIAGE_RETURN: \"\\r\",\n                CHAR_CIRCUMFLEX_ACCENT: \"^\",\n                CHAR_COLON: \":\",\n                CHAR_COMMA: \",\",\n                CHAR_DOLLAR: \"$\",\n                CHAR_DOT: \".\",\n                CHAR_DOUBLE_QUOTE: '\"',\n                CHAR_EQUAL: \"=\",\n                CHAR_EXCLAMATION_MARK: \"!\",\n                CHAR_FORM_FEED: \"\\f\",\n                CHAR_FORWARD_SLASH: \"/\",\n                CHAR_HASH: \"#\",\n                CHAR_HYPHEN_MINUS: \"-\",\n                CHAR_LEFT_ANGLE_BRACKET: \"<\",\n                CHAR_LEFT_CURLY_BRACE: \"{\",\n                CHAR_LEFT_SQUARE_BRACKET: \"[\",\n                CHAR_LINE_FEED: \"\\n\",\n                CHAR_NO_BREAK_SPACE: \"\\xa0\",\n                CHAR_PERCENT: \"%\",\n                CHAR_PLUS: \"+\",\n                CHAR_QUESTION_MARK: \"?\",\n                CHAR_RIGHT_ANGLE_BRACKET: \">\",\n                CHAR_RIGHT_CURLY_BRACE: \"}\",\n                CHAR_RIGHT_SQUARE_BRACKET: \"]\",\n                CHAR_SEMICOLON: \";\",\n                CHAR_SINGLE_QUOTE: \"'\",\n                CHAR_SPACE: \" \",\n                CHAR_TAB: \"\t\",\n                CHAR_UNDERSCORE: \"_\",\n                CHAR_VERTICAL_LINE: \"|\",\n                CHAR_ZERO_WIDTH_NOBREAK_SPACE: \"\\uFEFF\"\n            };\n        },\n        13: (e, t, r)=>{\n            const n = r(783);\n            const u = r(137);\n            const s = r(617);\n            const append = function() {\n                let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"\", t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"\", r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n                let n = [];\n                e = [].concat(e);\n                t = [].concat(t);\n                if (!t.length) return e;\n                if (!e.length) {\n                    return r ? s.flatten(t).map((e)=>\"{\".concat(e, \"}\")) : t;\n                }\n                for (let u of e){\n                    if (Array.isArray(u)) {\n                        for (let e of u){\n                            n.push(append(e, t, r));\n                        }\n                    } else {\n                        for (let e of t){\n                            if (r === true && typeof e === \"string\") e = \"{\".concat(e, \"}\");\n                            n.push(Array.isArray(e) ? append(u, e, r) : u + e);\n                        }\n                    }\n                }\n                return s.flatten(n);\n            };\n            const expand = function(e) {\n                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                let r = t.rangeLimit === void 0 ? 1e3 : t.rangeLimit;\n                let walk = function(e) {\n                    let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                    e.queue = [];\n                    let i = o;\n                    let a = o.queue;\n                    while(i.type !== \"brace\" && i.type !== \"root\" && i.parent){\n                        i = i.parent;\n                        a = i.queue;\n                    }\n                    if (e.invalid || e.dollar) {\n                        a.push(append(a.pop(), u(e, t)));\n                        return;\n                    }\n                    if (e.type === \"brace\" && e.invalid !== true && e.nodes.length === 2) {\n                        a.push(append(a.pop(), [\n                            \"{}\"\n                        ]));\n                        return;\n                    }\n                    if (e.nodes && e.ranges > 0) {\n                        let o = s.reduce(e.nodes);\n                        if (s.exceedsLimit(...o, t.step, r)) {\n                            throw new RangeError(\"expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.\");\n                        }\n                        let i = n(...o, t);\n                        if (i.length === 0) {\n                            i = u(e, t);\n                        }\n                        a.push(append(a.pop(), i));\n                        e.nodes = [];\n                        return;\n                    }\n                    let l = s.encloseBrace(e);\n                    let c = e.queue;\n                    let p = e;\n                    while(p.type !== \"brace\" && p.type !== \"root\" && p.parent){\n                        p = p.parent;\n                        c = p.queue;\n                    }\n                    for(let t = 0; t < e.nodes.length; t++){\n                        let r = e.nodes[t];\n                        if (r.type === \"comma\" && e.type === \"brace\") {\n                            if (t === 1) c.push(\"\");\n                            c.push(\"\");\n                            continue;\n                        }\n                        if (r.type === \"close\") {\n                            a.push(append(a.pop(), c, l));\n                            continue;\n                        }\n                        if (r.value && r.type !== \"open\") {\n                            c.push(append(c.pop(), r.value));\n                            continue;\n                        }\n                        if (r.nodes) {\n                            walk(r, e);\n                        }\n                    }\n                    return c;\n                };\n                return s.flatten(walk(e));\n            };\n            e.exports = expand;\n        },\n        719: (e, t, r)=>{\n            const n = r(137);\n            const { MAX_LENGTH: u, CHAR_BACKSLASH: s, CHAR_BACKTICK: o, CHAR_COMMA: i, CHAR_DOT: a, CHAR_LEFT_PARENTHESES: l, CHAR_RIGHT_PARENTHESES: c, CHAR_LEFT_CURLY_BRACE: p, CHAR_RIGHT_CURLY_BRACE: f, CHAR_LEFT_SQUARE_BRACKET: A, CHAR_RIGHT_SQUARE_BRACKET: R, CHAR_DOUBLE_QUOTE: _, CHAR_SINGLE_QUOTE: h, CHAR_NO_BREAK_SPACE: g, CHAR_ZERO_WIDTH_NOBREAK_SPACE: E } = r(457);\n            const parse = function(e) {\n                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                if (typeof e !== \"string\") {\n                    throw new TypeError(\"Expected a string\");\n                }\n                let r = t || {};\n                let C = typeof r.maxLength === \"number\" ? Math.min(u, r.maxLength) : u;\n                if (e.length > C) {\n                    throw new SyntaxError(\"Input length (\".concat(e.length, \"), exceeds max characters (\").concat(C, \")\"));\n                }\n                let y = {\n                    type: \"root\",\n                    input: e,\n                    nodes: []\n                };\n                let d = [\n                    y\n                ];\n                let x = y;\n                let b = y;\n                let S = 0;\n                let H = e.length;\n                let v = 0;\n                let $ = 0;\n                let m;\n                let T = {};\n                const advance = ()=>e[v++];\n                const push = (e)=>{\n                    if (e.type === \"text\" && b.type === \"dot\") {\n                        b.type = \"text\";\n                    }\n                    if (b && b.type === \"text\" && e.type === \"text\") {\n                        b.value += e.value;\n                        return;\n                    }\n                    x.nodes.push(e);\n                    e.parent = x;\n                    e.prev = b;\n                    b = e;\n                    return e;\n                };\n                push({\n                    type: \"bos\"\n                });\n                while(v < H){\n                    x = d[d.length - 1];\n                    m = advance();\n                    if (m === E || m === g) {\n                        continue;\n                    }\n                    if (m === s) {\n                        push({\n                            type: \"text\",\n                            value: (t.keepEscaping ? m : \"\") + advance()\n                        });\n                        continue;\n                    }\n                    if (m === R) {\n                        push({\n                            type: \"text\",\n                            value: \"\\\\\" + m\n                        });\n                        continue;\n                    }\n                    if (m === A) {\n                        S++;\n                        let e = true;\n                        let t;\n                        while(v < H && (t = advance())){\n                            m += t;\n                            if (t === A) {\n                                S++;\n                                continue;\n                            }\n                            if (t === s) {\n                                m += advance();\n                                continue;\n                            }\n                            if (t === R) {\n                                S--;\n                                if (S === 0) {\n                                    break;\n                                }\n                            }\n                        }\n                        push({\n                            type: \"text\",\n                            value: m\n                        });\n                        continue;\n                    }\n                    if (m === l) {\n                        x = push({\n                            type: \"paren\",\n                            nodes: []\n                        });\n                        d.push(x);\n                        push({\n                            type: \"text\",\n                            value: m\n                        });\n                        continue;\n                    }\n                    if (m === c) {\n                        if (x.type !== \"paren\") {\n                            push({\n                                type: \"text\",\n                                value: m\n                            });\n                            continue;\n                        }\n                        x = d.pop();\n                        push({\n                            type: \"text\",\n                            value: m\n                        });\n                        x = d[d.length - 1];\n                        continue;\n                    }\n                    if (m === _ || m === h || m === o) {\n                        let e = m;\n                        let r;\n                        if (t.keepQuotes !== true) {\n                            m = \"\";\n                        }\n                        while(v < H && (r = advance())){\n                            if (r === s) {\n                                m += r + advance();\n                                continue;\n                            }\n                            if (r === e) {\n                                if (t.keepQuotes === true) m += r;\n                                break;\n                            }\n                            m += r;\n                        }\n                        push({\n                            type: \"text\",\n                            value: m\n                        });\n                        continue;\n                    }\n                    if (m === p) {\n                        $++;\n                        let e = b.value && b.value.slice(-1) === \"$\" || x.dollar === true;\n                        let t = {\n                            type: \"brace\",\n                            open: true,\n                            close: false,\n                            dollar: e,\n                            depth: $,\n                            commas: 0,\n                            ranges: 0,\n                            nodes: []\n                        };\n                        x = push(t);\n                        d.push(x);\n                        push({\n                            type: \"open\",\n                            value: m\n                        });\n                        continue;\n                    }\n                    if (m === f) {\n                        if (x.type !== \"brace\") {\n                            push({\n                                type: \"text\",\n                                value: m\n                            });\n                            continue;\n                        }\n                        let e = \"close\";\n                        x = d.pop();\n                        x.close = true;\n                        push({\n                            type: e,\n                            value: m\n                        });\n                        $--;\n                        x = d[d.length - 1];\n                        continue;\n                    }\n                    if (m === i && $ > 0) {\n                        if (x.ranges > 0) {\n                            x.ranges = 0;\n                            let e = x.nodes.shift();\n                            x.nodes = [\n                                e,\n                                {\n                                    type: \"text\",\n                                    value: n(x)\n                                }\n                            ];\n                        }\n                        push({\n                            type: \"comma\",\n                            value: m\n                        });\n                        x.commas++;\n                        continue;\n                    }\n                    if (m === a && $ > 0 && x.commas === 0) {\n                        let e = x.nodes;\n                        if ($ === 0 || e.length === 0) {\n                            push({\n                                type: \"text\",\n                                value: m\n                            });\n                            continue;\n                        }\n                        if (b.type === \"dot\") {\n                            x.range = [];\n                            b.value += m;\n                            b.type = \"range\";\n                            if (x.nodes.length !== 3 && x.nodes.length !== 5) {\n                                x.invalid = true;\n                                x.ranges = 0;\n                                b.type = \"text\";\n                                continue;\n                            }\n                            x.ranges++;\n                            x.args = [];\n                            continue;\n                        }\n                        if (b.type === \"range\") {\n                            e.pop();\n                            let t = e[e.length - 1];\n                            t.value += b.value + m;\n                            b = t;\n                            x.ranges--;\n                            continue;\n                        }\n                        push({\n                            type: \"dot\",\n                            value: m\n                        });\n                        continue;\n                    }\n                    push({\n                        type: \"text\",\n                        value: m\n                    });\n                }\n                do {\n                    x = d.pop();\n                    if (x.type !== \"root\") {\n                        x.nodes.forEach((e)=>{\n                            if (!e.nodes) {\n                                if (e.type === \"open\") e.isOpen = true;\n                                if (e.type === \"close\") e.isClose = true;\n                                if (!e.nodes) e.type = \"text\";\n                                e.invalid = true;\n                            }\n                        });\n                        let e = d[d.length - 1];\n                        let t = e.nodes.indexOf(x);\n                        e.nodes.splice(t, 1, ...x.nodes);\n                    }\n                }while (d.length > 0);\n                push({\n                    type: \"eos\"\n                });\n                return y;\n            };\n            e.exports = parse;\n        },\n        137: (e, t, r)=>{\n            const n = r(617);\n            e.exports = function(e) {\n                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                let stringify = function(e) {\n                    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                    let u = t.escapeInvalid && n.isInvalidBrace(r);\n                    let s = e.invalid === true && t.escapeInvalid === true;\n                    let o = \"\";\n                    if (e.value) {\n                        if ((u || s) && n.isOpenOrClose(e)) {\n                            return \"\\\\\" + e.value;\n                        }\n                        return e.value;\n                    }\n                    if (e.value) {\n                        return e.value;\n                    }\n                    if (e.nodes) {\n                        for (let t of e.nodes){\n                            o += stringify(t);\n                        }\n                    }\n                    return o;\n                };\n                return stringify(e);\n            };\n        },\n        617: (e, t)=>{\n            t.isInteger = (e)=>{\n                if (typeof e === \"number\") {\n                    return Number.isInteger(e);\n                }\n                if (typeof e === \"string\" && e.trim() !== \"\") {\n                    return Number.isInteger(Number(e));\n                }\n                return false;\n            };\n            t.find = (e, t)=>e.nodes.find((e)=>e.type === t);\n            t.exceedsLimit = function(e, r) {\n                let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, u = arguments.length > 3 ? arguments[3] : void 0;\n                if (u === false) return false;\n                if (!t.isInteger(e) || !t.isInteger(r)) return false;\n                return (Number(r) - Number(e)) / Number(n) >= u;\n            };\n            t.escapeNode = function(e) {\n                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, r = arguments.length > 2 ? arguments[2] : void 0;\n                let n = e.nodes[t];\n                if (!n) return;\n                if (r && n.type === r || n.type === \"open\" || n.type === \"close\") {\n                    if (n.escaped !== true) {\n                        n.value = \"\\\\\" + n.value;\n                        n.escaped = true;\n                    }\n                }\n            };\n            t.encloseBrace = (e)=>{\n                if (e.type !== \"brace\") return false;\n                if (e.commas >> 0 + e.ranges >> 0 === 0) {\n                    e.invalid = true;\n                    return true;\n                }\n                return false;\n            };\n            t.isInvalidBrace = (e)=>{\n                if (e.type !== \"brace\") return false;\n                if (e.invalid === true || e.dollar) return true;\n                if (e.commas >> 0 + e.ranges >> 0 === 0) {\n                    e.invalid = true;\n                    return true;\n                }\n                if (e.open !== true || e.close !== true) {\n                    e.invalid = true;\n                    return true;\n                }\n                return false;\n            };\n            t.isOpenOrClose = (e)=>{\n                if (e.type === \"open\" || e.type === \"close\") {\n                    return true;\n                }\n                return e.open === true || e.close === true;\n            };\n            t.reduce = (e)=>e.reduce((e, t)=>{\n                    if (t.type === \"text\") e.push(t.value);\n                    if (t.type === \"range\") t.type = \"text\";\n                    return e;\n                }, []);\n            t.flatten = function() {\n                for(var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++){\n                    e[_key] = arguments[_key];\n                }\n                const t = [];\n                const flat = (e)=>{\n                    for(let r = 0; r < e.length; r++){\n                        let n = e[r];\n                        Array.isArray(n) ? flat(n, t) : n !== void 0 && t.push(n);\n                    }\n                    return t;\n                };\n                flat(e);\n                return t;\n            };\n        },\n        783: (e, t, r)=>{\n            /*!\n * fill-range <https://github.com/jonschlinkert/fill-range>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Licensed under the MIT License.\n */ const n = r(837);\n            const u = r(492);\n            const isObject = (e)=>e !== null && typeof e === \"object\" && !Array.isArray(e);\n            const transform = (e)=>(t)=>e === true ? Number(t) : String(t);\n            const isValidValue = (e)=>typeof e === \"number\" || typeof e === \"string\" && e !== \"\";\n            const isNumber = (e)=>Number.isInteger(+e);\n            const zeros = (e)=>{\n                let t = \"\".concat(e);\n                let r = -1;\n                if (t[0] === \"-\") t = t.slice(1);\n                if (t === \"0\") return false;\n                while(t[++r] === \"0\");\n                return r > 0;\n            };\n            const stringify = (e, t, r)=>{\n                if (typeof e === \"string\" || typeof t === \"string\") {\n                    return true;\n                }\n                return r.stringify === true;\n            };\n            const pad = (e, t, r)=>{\n                if (t > 0) {\n                    let r = e[0] === \"-\" ? \"-\" : \"\";\n                    if (r) e = e.slice(1);\n                    e = r + e.padStart(r ? t - 1 : t, \"0\");\n                }\n                if (r === false) {\n                    return String(e);\n                }\n                return e;\n            };\n            const toMaxLen = (e, t)=>{\n                let r = e[0] === \"-\" ? \"-\" : \"\";\n                if (r) {\n                    e = e.slice(1);\n                    t--;\n                }\n                while(e.length < t)e = \"0\" + e;\n                return r ? \"-\" + e : e;\n            };\n            const toSequence = (e, t)=>{\n                e.negatives.sort((e, t)=>e < t ? -1 : e > t ? 1 : 0);\n                e.positives.sort((e, t)=>e < t ? -1 : e > t ? 1 : 0);\n                let r = t.capture ? \"\" : \"?:\";\n                let n = \"\";\n                let u = \"\";\n                let s;\n                if (e.positives.length) {\n                    n = e.positives.join(\"|\");\n                }\n                if (e.negatives.length) {\n                    u = \"-(\".concat(r).concat(e.negatives.join(\"|\"), \")\");\n                }\n                if (n && u) {\n                    s = \"\".concat(n, \"|\").concat(u);\n                } else {\n                    s = n || u;\n                }\n                if (t.wrap) {\n                    return \"(\".concat(r).concat(s, \")\");\n                }\n                return s;\n            };\n            const toRange = (e, t, r, n)=>{\n                if (r) {\n                    return u(e, t, {\n                        wrap: false,\n                        ...n\n                    });\n                }\n                let s = String.fromCharCode(e);\n                if (e === t) return s;\n                let o = String.fromCharCode(t);\n                return \"[\".concat(s, \"-\").concat(o, \"]\");\n            };\n            const toRegex = (e, t, r)=>{\n                if (Array.isArray(e)) {\n                    let t = r.wrap === true;\n                    let n = r.capture ? \"\" : \"?:\";\n                    return t ? \"(\".concat(n).concat(e.join(\"|\"), \")\") : e.join(\"|\");\n                }\n                return u(e, t, r);\n            };\n            const rangeError = function() {\n                for(var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++){\n                    e[_key] = arguments[_key];\n                }\n                return new RangeError(\"Invalid range arguments: \" + n.inspect(...e));\n            };\n            const invalidRange = (e, t, r)=>{\n                if (r.strictRanges === true) throw rangeError([\n                    e,\n                    t\n                ]);\n                return [];\n            };\n            const invalidStep = (e, t)=>{\n                if (t.strictRanges === true) {\n                    throw new TypeError('Expected step \"'.concat(e, '\" to be a number'));\n                }\n                return [];\n            };\n            const fillNumbers = function(e, t) {\n                let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n                let u = Number(e);\n                let s = Number(t);\n                if (!Number.isInteger(u) || !Number.isInteger(s)) {\n                    if (n.strictRanges === true) throw rangeError([\n                        e,\n                        t\n                    ]);\n                    return [];\n                }\n                if (u === 0) u = 0;\n                if (s === 0) s = 0;\n                let o = u > s;\n                let i = String(e);\n                let a = String(t);\n                let l = String(r);\n                r = Math.max(Math.abs(r), 1);\n                let c = zeros(i) || zeros(a) || zeros(l);\n                let p = c ? Math.max(i.length, a.length, l.length) : 0;\n                let f = c === false && stringify(e, t, n) === false;\n                let A = n.transform || transform(f);\n                if (n.toRegex && r === 1) {\n                    return toRange(toMaxLen(e, p), toMaxLen(t, p), true, n);\n                }\n                let R = {\n                    negatives: [],\n                    positives: []\n                };\n                let push = (e)=>R[e < 0 ? \"negatives\" : \"positives\"].push(Math.abs(e));\n                let _ = [];\n                let h = 0;\n                while(o ? u >= s : u <= s){\n                    if (n.toRegex === true && r > 1) {\n                        push(u);\n                    } else {\n                        _.push(pad(A(u, h), p, f));\n                    }\n                    u = o ? u - r : u + r;\n                    h++;\n                }\n                if (n.toRegex === true) {\n                    return r > 1 ? toSequence(R, n) : toRegex(_, null, {\n                        wrap: false,\n                        ...n\n                    });\n                }\n                return _;\n            };\n            const fillLetters = function(e, t) {\n                let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n                if (!isNumber(e) && e.length > 1 || !isNumber(t) && t.length > 1) {\n                    return invalidRange(e, t, n);\n                }\n                let u = n.transform || ((e)=>String.fromCharCode(e));\n                let s = \"\".concat(e).charCodeAt(0);\n                let o = \"\".concat(t).charCodeAt(0);\n                let i = s > o;\n                let a = Math.min(s, o);\n                let l = Math.max(s, o);\n                if (n.toRegex && r === 1) {\n                    return toRange(a, l, false, n);\n                }\n                let c = [];\n                let p = 0;\n                while(i ? s >= o : s <= o){\n                    c.push(u(s, p));\n                    s = i ? s - r : s + r;\n                    p++;\n                }\n                if (n.toRegex === true) {\n                    return toRegex(c, null, {\n                        wrap: false,\n                        options: n\n                    });\n                }\n                return c;\n            };\n            const fill = function(e, t, r) {\n                let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n                if (t == null && isValidValue(e)) {\n                    return [\n                        e\n                    ];\n                }\n                if (!isValidValue(e) || !isValidValue(t)) {\n                    return invalidRange(e, t, n);\n                }\n                if (typeof r === \"function\") {\n                    return fill(e, t, 1, {\n                        transform: r\n                    });\n                }\n                if (isObject(r)) {\n                    return fill(e, t, 0, r);\n                }\n                let u = {\n                    ...n\n                };\n                if (u.capture === true) u.wrap = true;\n                r = r || u.step || 1;\n                if (!isNumber(r)) {\n                    if (r != null && !isObject(r)) return invalidStep(r, u);\n                    return fill(e, t, 1, r);\n                }\n                if (isNumber(e) && isNumber(t)) {\n                    return fillNumbers(e, t, r, u);\n                }\n                return fillLetters(e, t, Math.max(Math.abs(r), 1), u);\n            };\n            e.exports = fill;\n        },\n        357: (e)=>{\n            /*!\n * is-number <https://github.com/jonschlinkert/is-number>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Released under the MIT License.\n */ e.exports = function(e) {\n                if (typeof e === \"number\") {\n                    return e - e === 0;\n                }\n                if (typeof e === \"string\" && e.trim() !== \"\") {\n                    return Number.isFinite ? Number.isFinite(+e) : isFinite(+e);\n                }\n                return false;\n            };\n        },\n        971: (e, t, r)=>{\n            const n = r(837);\n            const u = r(333);\n            const s = r(251);\n            const o = r(513);\n            const isEmptyString = (e)=>e === \"\" || e === \"./\";\n            const micromatch = (e, t, r)=>{\n                t = [].concat(t);\n                e = [].concat(e);\n                let n = new Set;\n                let u = new Set;\n                let o = new Set;\n                let i = 0;\n                let onResult = (e)=>{\n                    o.add(e.output);\n                    if (r && r.onResult) {\n                        r.onResult(e);\n                    }\n                };\n                for(let o = 0; o < t.length; o++){\n                    let a = s(String(t[o]), {\n                        ...r,\n                        onResult: onResult\n                    }, true);\n                    let l = a.state.negated || a.state.negatedExtglob;\n                    if (l) i++;\n                    for (let t of e){\n                        let e = a(t, true);\n                        let r = l ? !e.isMatch : e.isMatch;\n                        if (!r) continue;\n                        if (l) {\n                            n.add(e.output);\n                        } else {\n                            n.delete(e.output);\n                            u.add(e.output);\n                        }\n                    }\n                }\n                let a = i === t.length ? [\n                    ...o\n                ] : [\n                    ...u\n                ];\n                let l = a.filter((e)=>!n.has(e));\n                if (r && l.length === 0) {\n                    if (r.failglob === true) {\n                        throw new Error('No matches found for \"'.concat(t.join(\", \"), '\"'));\n                    }\n                    if (r.nonull === true || r.nullglob === true) {\n                        return r.unescape ? t.map((e)=>e.replace(/\\\\/g, \"\")) : t;\n                    }\n                }\n                return l;\n            };\n            micromatch.match = micromatch;\n            micromatch.matcher = (e, t)=>s(e, t);\n            micromatch.isMatch = (e, t, r)=>s(t, r)(e);\n            micromatch.any = micromatch.isMatch;\n            micromatch.not = function(e, t) {\n                let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n                t = [].concat(t).map(String);\n                let n = new Set;\n                let u = [];\n                let onResult = (e)=>{\n                    if (r.onResult) r.onResult(e);\n                    u.push(e.output);\n                };\n                let s = micromatch(e, t, {\n                    ...r,\n                    onResult: onResult\n                });\n                for (let e of u){\n                    if (!s.includes(e)) {\n                        n.add(e);\n                    }\n                }\n                return [\n                    ...n\n                ];\n            };\n            micromatch.contains = (e, t, r)=>{\n                if (typeof e !== \"string\") {\n                    throw new TypeError('Expected a string: \"'.concat(n.inspect(e), '\"'));\n                }\n                if (Array.isArray(t)) {\n                    return t.some((t)=>micromatch.contains(e, t, r));\n                }\n                if (typeof t === \"string\") {\n                    if (isEmptyString(e) || isEmptyString(t)) {\n                        return false;\n                    }\n                    if (e.includes(t) || e.startsWith(\"./\") && e.slice(2).includes(t)) {\n                        return true;\n                    }\n                }\n                return micromatch.isMatch(e, t, {\n                    ...r,\n                    contains: true\n                });\n            };\n            micromatch.matchKeys = (e, t, r)=>{\n                if (!o.isObject(e)) {\n                    throw new TypeError(\"Expected the first argument to be an object\");\n                }\n                let n = micromatch(Object.keys(e), t, r);\n                let u = {};\n                for (let t of n)u[t] = e[t];\n                return u;\n            };\n            micromatch.some = (e, t, r)=>{\n                let n = [].concat(e);\n                for (let e of [].concat(t)){\n                    let t = s(String(e), r);\n                    if (n.some((e)=>t(e))) {\n                        return true;\n                    }\n                }\n                return false;\n            };\n            micromatch.every = (e, t, r)=>{\n                let n = [].concat(e);\n                for (let e of [].concat(t)){\n                    let t = s(String(e), r);\n                    if (!n.every((e)=>t(e))) {\n                        return false;\n                    }\n                }\n                return true;\n            };\n            micromatch.all = (e, t, r)=>{\n                if (typeof e !== \"string\") {\n                    throw new TypeError('Expected a string: \"'.concat(n.inspect(e), '\"'));\n                }\n                return [].concat(t).every((t)=>s(t, r)(e));\n            };\n            micromatch.capture = (e, t, r)=>{\n                let n = o.isWindows(r);\n                let u = s.makeRe(String(e), {\n                    ...r,\n                    capture: true\n                });\n                let i = u.exec(n ? o.toPosixSlashes(t) : t);\n                if (i) {\n                    return i.slice(1).map((e)=>e === void 0 ? \"\" : e);\n                }\n            };\n            micromatch.makeRe = function() {\n                for(var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++){\n                    e[_key] = arguments[_key];\n                }\n                return s.makeRe(...e);\n            };\n            micromatch.scan = function() {\n                for(var _len = arguments.length, e = new Array(_len), _key = 0; _key < _len; _key++){\n                    e[_key] = arguments[_key];\n                }\n                return s.scan(...e);\n            };\n            micromatch.parse = (e, t)=>{\n                let r = [];\n                for (let n of [].concat(e || [])){\n                    for (let e of u(String(n), t)){\n                        r.push(s.parse(e, t));\n                    }\n                }\n                return r;\n            };\n            micromatch.braces = (e, t)=>{\n                if (typeof e !== \"string\") throw new TypeError(\"Expected a string\");\n                if (t && t.nobrace === true || !/\\{.*\\}/.test(e)) {\n                    return [\n                        e\n                    ];\n                }\n                return u(e, t);\n            };\n            micromatch.braceExpand = (e, t)=>{\n                if (typeof e !== \"string\") throw new TypeError(\"Expected a string\");\n                return micromatch.braces(e, {\n                    ...t,\n                    expand: true\n                });\n            };\n            e.exports = micromatch;\n        },\n        251: (e, t, r)=>{\n            e.exports = r(683);\n        },\n        356: (e, t, r)=>{\n            const n = r(17);\n            const u = \"\\\\\\\\/\";\n            const s = \"[^\".concat(u, \"]\");\n            const o = \"\\\\.\";\n            const i = \"\\\\+\";\n            const a = \"\\\\?\";\n            const l = \"\\\\/\";\n            const c = \"(?=.)\";\n            const p = \"[^/]\";\n            const f = \"(?:\".concat(l, \"|$)\");\n            const A = \"(?:^|\".concat(l, \")\");\n            const R = \"\".concat(o, \"{1,2}\").concat(f);\n            const _ = \"(?!\".concat(o, \")\");\n            const h = \"(?!\".concat(A).concat(R, \")\");\n            const g = \"(?!\".concat(o, \"{0,1}\").concat(f, \")\");\n            const E = \"(?!\".concat(R, \")\");\n            const C = \"[^.\".concat(l, \"]\");\n            const y = \"\".concat(p, \"*?\");\n            const d = {\n                DOT_LITERAL: o,\n                PLUS_LITERAL: i,\n                QMARK_LITERAL: a,\n                SLASH_LITERAL: l,\n                ONE_CHAR: c,\n                QMARK: p,\n                END_ANCHOR: f,\n                DOTS_SLASH: R,\n                NO_DOT: _,\n                NO_DOTS: h,\n                NO_DOT_SLASH: g,\n                NO_DOTS_SLASH: E,\n                QMARK_NO_DOT: C,\n                STAR: y,\n                START_ANCHOR: A\n            };\n            const x = {\n                ...d,\n                SLASH_LITERAL: \"[\".concat(u, \"]\"),\n                QMARK: s,\n                STAR: \"\".concat(s, \"*?\"),\n                DOTS_SLASH: \"\".concat(o, \"{1,2}(?:[\").concat(u, \"]|$)\"),\n                NO_DOT: \"(?!\".concat(o, \")\"),\n                NO_DOTS: \"(?!(?:^|[\".concat(u, \"])\").concat(o, \"{1,2}(?:[\").concat(u, \"]|$))\"),\n                NO_DOT_SLASH: \"(?!\".concat(o, \"{0,1}(?:[\").concat(u, \"]|$))\"),\n                NO_DOTS_SLASH: \"(?!\".concat(o, \"{1,2}(?:[\").concat(u, \"]|$))\"),\n                QMARK_NO_DOT: \"[^.\".concat(u, \"]\"),\n                START_ANCHOR: \"(?:^|[\".concat(u, \"])\"),\n                END_ANCHOR: \"(?:[\".concat(u, \"]|$)\")\n            };\n            const b = {\n                alnum: \"a-zA-Z0-9\",\n                alpha: \"a-zA-Z\",\n                ascii: \"\\\\x00-\\\\x7F\",\n                blank: \" \\\\t\",\n                cntrl: \"\\\\x00-\\\\x1F\\\\x7F\",\n                digit: \"0-9\",\n                graph: \"\\\\x21-\\\\x7E\",\n                lower: \"a-z\",\n                print: \"\\\\x20-\\\\x7E \",\n                punct: \"\\\\-!\\\"#$%&'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~\",\n                space: \" \\\\t\\\\r\\\\n\\\\v\\\\f\",\n                upper: \"A-Z\",\n                word: \"A-Za-z0-9_\",\n                xdigit: \"A-Fa-f0-9\"\n            };\n            e.exports = {\n                MAX_LENGTH: 1024 * 64,\n                POSIX_REGEX_SOURCE: b,\n                REGEX_BACKSLASH: /\\\\(?![*+?^${}(|)[\\]])/g,\n                REGEX_NON_SPECIAL_CHARS: /^[^@![\\].,$*+?^{}()|\\\\/]+/,\n                REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\\]]/,\n                REGEX_SPECIAL_CHARS_BACKREF: /(\\\\?)((\\W)(\\3*))/g,\n                REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\\]])/g,\n                REGEX_REMOVE_BACKSLASH: /(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,\n                REPLACEMENTS: {\n                    \"***\": \"*\",\n                    \"**/**\": \"**\",\n                    \"**/**/**\": \"**\"\n                },\n                CHAR_0: 48,\n                CHAR_9: 57,\n                CHAR_UPPERCASE_A: 65,\n                CHAR_LOWERCASE_A: 97,\n                CHAR_UPPERCASE_Z: 90,\n                CHAR_LOWERCASE_Z: 122,\n                CHAR_LEFT_PARENTHESES: 40,\n                CHAR_RIGHT_PARENTHESES: 41,\n                CHAR_ASTERISK: 42,\n                CHAR_AMPERSAND: 38,\n                CHAR_AT: 64,\n                CHAR_BACKWARD_SLASH: 92,\n                CHAR_CARRIAGE_RETURN: 13,\n                CHAR_CIRCUMFLEX_ACCENT: 94,\n                CHAR_COLON: 58,\n                CHAR_COMMA: 44,\n                CHAR_DOT: 46,\n                CHAR_DOUBLE_QUOTE: 34,\n                CHAR_EQUAL: 61,\n                CHAR_EXCLAMATION_MARK: 33,\n                CHAR_FORM_FEED: 12,\n                CHAR_FORWARD_SLASH: 47,\n                CHAR_GRAVE_ACCENT: 96,\n                CHAR_HASH: 35,\n                CHAR_HYPHEN_MINUS: 45,\n                CHAR_LEFT_ANGLE_BRACKET: 60,\n                CHAR_LEFT_CURLY_BRACE: 123,\n                CHAR_LEFT_SQUARE_BRACKET: 91,\n                CHAR_LINE_FEED: 10,\n                CHAR_NO_BREAK_SPACE: 160,\n                CHAR_PERCENT: 37,\n                CHAR_PLUS: 43,\n                CHAR_QUESTION_MARK: 63,\n                CHAR_RIGHT_ANGLE_BRACKET: 62,\n                CHAR_RIGHT_CURLY_BRACE: 125,\n                CHAR_RIGHT_SQUARE_BRACKET: 93,\n                CHAR_SEMICOLON: 59,\n                CHAR_SINGLE_QUOTE: 39,\n                CHAR_SPACE: 32,\n                CHAR_TAB: 9,\n                CHAR_UNDERSCORE: 95,\n                CHAR_VERTICAL_LINE: 124,\n                CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,\n                SEP: n.sep,\n                extglobChars (e) {\n                    return {\n                        \"!\": {\n                            type: \"negate\",\n                            open: \"(?:(?!(?:\",\n                            close: \"))\".concat(e.STAR, \")\")\n                        },\n                        \"?\": {\n                            type: \"qmark\",\n                            open: \"(?:\",\n                            close: \")?\"\n                        },\n                        \"+\": {\n                            type: \"plus\",\n                            open: \"(?:\",\n                            close: \")+\"\n                        },\n                        \"*\": {\n                            type: \"star\",\n                            open: \"(?:\",\n                            close: \")*\"\n                        },\n                        \"@\": {\n                            type: \"at\",\n                            open: \"(?:\",\n                            close: \")\"\n                        }\n                    };\n                },\n                globChars (e) {\n                    return e === true ? x : d;\n                }\n            };\n        },\n        754: (e, t, r)=>{\n            const n = r(356);\n            const u = r(513);\n            const { MAX_LENGTH: s, POSIX_REGEX_SOURCE: o, REGEX_NON_SPECIAL_CHARS: i, REGEX_SPECIAL_CHARS_BACKREF: a, REPLACEMENTS: l } = n;\n            const expandRange = (e, t)=>{\n                if (typeof t.expandRange === \"function\") {\n                    return t.expandRange(...e, t);\n                }\n                e.sort();\n                const r = \"[\".concat(e.join(\"-\"), \"]\");\n                try {\n                    new RegExp(r);\n                } catch (t) {\n                    return e.map((e)=>u.escapeRegex(e)).join(\"..\");\n                }\n                return r;\n            };\n            const syntaxError = (e, t)=>\"Missing \".concat(e, ': \"').concat(t, '\" - use \"\\\\\\\\').concat(t, '\" to match literal characters');\n            const parse = (e, t)=>{\n                if (typeof e !== \"string\") {\n                    throw new TypeError(\"Expected a string\");\n                }\n                e = l[e] || e;\n                const r = {\n                    ...t\n                };\n                const c = typeof r.maxLength === \"number\" ? Math.min(s, r.maxLength) : s;\n                let p = e.length;\n                if (p > c) {\n                    throw new SyntaxError(\"Input length: \".concat(p, \", exceeds maximum allowed length: \").concat(c));\n                }\n                const f = {\n                    type: \"bos\",\n                    value: \"\",\n                    output: r.prepend || \"\"\n                };\n                const A = [\n                    f\n                ];\n                const R = r.capture ? \"\" : \"?:\";\n                const _ = u.isWindows(t);\n                const h = n.globChars(_);\n                const g = n.extglobChars(h);\n                const { DOT_LITERAL: E, PLUS_LITERAL: C, SLASH_LITERAL: y, ONE_CHAR: d, DOTS_SLASH: x, NO_DOT: b, NO_DOT_SLASH: S, NO_DOTS_SLASH: H, QMARK: v, QMARK_NO_DOT: $, STAR: m, START_ANCHOR: T } = h;\n                const globstar = (e)=>\"(\".concat(R, \"(?:(?!\").concat(T).concat(e.dot ? x : E, \").)*?)\");\n                const L = r.dot ? \"\" : b;\n                const O = r.dot ? v : $;\n                let w = r.bash === true ? globstar(r) : m;\n                if (r.capture) {\n                    w = \"(\".concat(w, \")\");\n                }\n                if (typeof r.noext === \"boolean\") {\n                    r.noextglob = r.noext;\n                }\n                const N = {\n                    input: e,\n                    index: -1,\n                    start: 0,\n                    dot: r.dot === true,\n                    consumed: \"\",\n                    output: \"\",\n                    prefix: \"\",\n                    backtrack: false,\n                    negated: false,\n                    brackets: 0,\n                    braces: 0,\n                    parens: 0,\n                    quotes: 0,\n                    globstar: false,\n                    tokens: A\n                };\n                e = u.removePrefix(e, N);\n                p = e.length;\n                const k = [];\n                const I = [];\n                const M = [];\n                let P = f;\n                let B;\n                const eos = ()=>N.index === p - 1;\n                const G = N.peek = function() {\n                    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;\n                    return e[N.index + t];\n                };\n                const D = N.advance = ()=>e[++N.index];\n                const remaining = ()=>e.slice(N.index + 1);\n                const consume = function() {\n                    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"\", t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n                    N.consumed += e;\n                    N.index += t;\n                };\n                const append = (e)=>{\n                    N.output += e.output != null ? e.output : e.value;\n                    consume(e.value);\n                };\n                const negate = ()=>{\n                    let e = 1;\n                    while(G() === \"!\" && (G(2) !== \"(\" || G(3) === \"?\")){\n                        D();\n                        N.start++;\n                        e++;\n                    }\n                    if (e % 2 === 0) {\n                        return false;\n                    }\n                    N.negated = true;\n                    N.start++;\n                    return true;\n                };\n                const increment = (e)=>{\n                    N[e]++;\n                    M.push(e);\n                };\n                const decrement = (e)=>{\n                    N[e]--;\n                    M.pop();\n                };\n                const push = (e)=>{\n                    if (P.type === \"globstar\") {\n                        const t = N.braces > 0 && (e.type === \"comma\" || e.type === \"brace\");\n                        const r = e.extglob === true || k.length && (e.type === \"pipe\" || e.type === \"paren\");\n                        if (e.type !== \"slash\" && e.type !== \"paren\" && !t && !r) {\n                            N.output = N.output.slice(0, -P.output.length);\n                            P.type = \"star\";\n                            P.value = \"*\";\n                            P.output = w;\n                            N.output += P.output;\n                        }\n                    }\n                    if (k.length && e.type !== \"paren\" && !g[e.value]) {\n                        k[k.length - 1].inner += e.value;\n                    }\n                    if (e.value || e.output) append(e);\n                    if (P && P.type === \"text\" && e.type === \"text\") {\n                        P.value += e.value;\n                        P.output = (P.output || \"\") + e.value;\n                        return;\n                    }\n                    e.prev = P;\n                    A.push(e);\n                    P = e;\n                };\n                const extglobOpen = (e, t)=>{\n                    const n = {\n                        ...g[t],\n                        conditions: 1,\n                        inner: \"\"\n                    };\n                    n.prev = P;\n                    n.parens = N.parens;\n                    n.output = N.output;\n                    const u = (r.capture ? \"(\" : \"\") + n.open;\n                    increment(\"parens\");\n                    push({\n                        type: e,\n                        value: t,\n                        output: N.output ? \"\" : d\n                    });\n                    push({\n                        type: \"paren\",\n                        extglob: true,\n                        value: D(),\n                        output: u\n                    });\n                    k.push(n);\n                };\n                const extglobClose = (e)=>{\n                    let t = e.close + (r.capture ? \")\" : \"\");\n                    if (e.type === \"negate\") {\n                        let n = w;\n                        if (e.inner && e.inner.length > 1 && e.inner.includes(\"/\")) {\n                            n = globstar(r);\n                        }\n                        if (n !== w || eos() || /^\\)+$/.test(remaining())) {\n                            t = e.close = \")$))\".concat(n);\n                        }\n                        if (e.prev.type === \"bos\") {\n                            N.negatedExtglob = true;\n                        }\n                    }\n                    push({\n                        type: \"paren\",\n                        extglob: true,\n                        value: B,\n                        output: t\n                    });\n                    decrement(\"parens\");\n                };\n                if (r.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(e)) {\n                    let n = false;\n                    let s = e.replace(a, (e, t, r, u, s, o)=>{\n                        if (u === \"\\\\\") {\n                            n = true;\n                            return e;\n                        }\n                        if (u === \"?\") {\n                            if (t) {\n                                return t + u + (s ? v.repeat(s.length) : \"\");\n                            }\n                            if (o === 0) {\n                                return O + (s ? v.repeat(s.length) : \"\");\n                            }\n                            return v.repeat(r.length);\n                        }\n                        if (u === \".\") {\n                            return E.repeat(r.length);\n                        }\n                        if (u === \"*\") {\n                            if (t) {\n                                return t + u + (s ? w : \"\");\n                            }\n                            return w;\n                        }\n                        return t ? e : \"\\\\\".concat(e);\n                    });\n                    if (n === true) {\n                        if (r.unescape === true) {\n                            s = s.replace(/\\\\/g, \"\");\n                        } else {\n                            s = s.replace(/\\\\+/g, (e)=>e.length % 2 === 0 ? \"\\\\\\\\\" : e ? \"\\\\\" : \"\");\n                        }\n                    }\n                    if (s === e && r.contains === true) {\n                        N.output = e;\n                        return N;\n                    }\n                    N.output = u.wrapOutput(s, N, t);\n                    return N;\n                }\n                while(!eos()){\n                    B = D();\n                    if (B === \"\\x00\") {\n                        continue;\n                    }\n                    if (B === \"\\\\\") {\n                        const e = G();\n                        if (e === \"/\" && r.bash !== true) {\n                            continue;\n                        }\n                        if (e === \".\" || e === \";\") {\n                            continue;\n                        }\n                        if (!e) {\n                            B += \"\\\\\";\n                            push({\n                                type: \"text\",\n                                value: B\n                            });\n                            continue;\n                        }\n                        const t = /^\\\\+/.exec(remaining());\n                        let n = 0;\n                        if (t && t[0].length > 2) {\n                            n = t[0].length;\n                            N.index += n;\n                            if (n % 2 !== 0) {\n                                B += \"\\\\\";\n                            }\n                        }\n                        if (r.unescape === true) {\n                            B = D() || \"\";\n                        } else {\n                            B += D() || \"\";\n                        }\n                        if (N.brackets === 0) {\n                            push({\n                                type: \"text\",\n                                value: B\n                            });\n                            continue;\n                        }\n                    }\n                    if (N.brackets > 0 && (B !== \"]\" || P.value === \"[\" || P.value === \"[^\")) {\n                        if (r.posix !== false && B === \":\") {\n                            const e = P.value.slice(1);\n                            if (e.includes(\"[\")) {\n                                P.posix = true;\n                                if (e.includes(\":\")) {\n                                    const e = P.value.lastIndexOf(\"[\");\n                                    const t = P.value.slice(0, e);\n                                    const r = P.value.slice(e + 2);\n                                    const n = o[r];\n                                    if (n) {\n                                        P.value = t + n;\n                                        N.backtrack = true;\n                                        D();\n                                        if (!f.output && A.indexOf(P) === 1) {\n                                            f.output = d;\n                                        }\n                                        continue;\n                                    }\n                                }\n                            }\n                        }\n                        if (B === \"[\" && G() !== \":\" || B === \"-\" && G() === \"]\") {\n                            B = \"\\\\\".concat(B);\n                        }\n                        if (B === \"]\" && (P.value === \"[\" || P.value === \"[^\")) {\n                            B = \"\\\\\".concat(B);\n                        }\n                        if (r.posix === true && B === \"!\" && P.value === \"[\") {\n                            B = \"^\";\n                        }\n                        P.value += B;\n                        append({\n                            value: B\n                        });\n                        continue;\n                    }\n                    if (N.quotes === 1 && B !== '\"') {\n                        B = u.escapeRegex(B);\n                        P.value += B;\n                        append({\n                            value: B\n                        });\n                        continue;\n                    }\n                    if (B === '\"') {\n                        N.quotes = N.quotes === 1 ? 0 : 1;\n                        if (r.keepQuotes === true) {\n                            push({\n                                type: \"text\",\n                                value: B\n                            });\n                        }\n                        continue;\n                    }\n                    if (B === \"(\") {\n                        increment(\"parens\");\n                        push({\n                            type: \"paren\",\n                            value: B\n                        });\n                        continue;\n                    }\n                    if (B === \")\") {\n                        if (N.parens === 0 && r.strictBrackets === true) {\n                            throw new SyntaxError(syntaxError(\"opening\", \"(\"));\n                        }\n                        const e = k[k.length - 1];\n                        if (e && N.parens === e.parens + 1) {\n                            extglobClose(k.pop());\n                            continue;\n                        }\n                        push({\n                            type: \"paren\",\n                            value: B,\n                            output: N.parens ? \")\" : \"\\\\)\"\n                        });\n                        decrement(\"parens\");\n                        continue;\n                    }\n                    if (B === \"[\") {\n                        if (r.nobracket === true || !remaining().includes(\"]\")) {\n                            if (r.nobracket !== true && r.strictBrackets === true) {\n                                throw new SyntaxError(syntaxError(\"closing\", \"]\"));\n                            }\n                            B = \"\\\\\".concat(B);\n                        } else {\n                            increment(\"brackets\");\n                        }\n                        push({\n                            type: \"bracket\",\n                            value: B\n                        });\n                        continue;\n                    }\n                    if (B === \"]\") {\n                        if (r.nobracket === true || P && P.type === \"bracket\" && P.value.length === 1) {\n                            push({\n                                type: \"text\",\n                                value: B,\n                                output: \"\\\\\".concat(B)\n                            });\n                            continue;\n                        }\n                        if (N.brackets === 0) {\n                            if (r.strictBrackets === true) {\n                                throw new SyntaxError(syntaxError(\"opening\", \"[\"));\n                            }\n                            push({\n                                type: \"text\",\n                                value: B,\n                                output: \"\\\\\".concat(B)\n                            });\n                            continue;\n                        }\n                        decrement(\"brackets\");\n                        const e = P.value.slice(1);\n                        if (P.posix !== true && e[0] === \"^\" && !e.includes(\"/\")) {\n                            B = \"/\".concat(B);\n                        }\n                        P.value += B;\n                        append({\n                            value: B\n                        });\n                        if (r.literalBrackets === false || u.hasRegexChars(e)) {\n                            continue;\n                        }\n                        const t = u.escapeRegex(P.value);\n                        N.output = N.output.slice(0, -P.value.length);\n                        if (r.literalBrackets === true) {\n                            N.output += t;\n                            P.value = t;\n                            continue;\n                        }\n                        P.value = \"(\".concat(R).concat(t, \"|\").concat(P.value, \")\");\n                        N.output += P.value;\n                        continue;\n                    }\n                    if (B === \"{\" && r.nobrace !== true) {\n                        increment(\"braces\");\n                        const e = {\n                            type: \"brace\",\n                            value: B,\n                            output: \"(\",\n                            outputIndex: N.output.length,\n                            tokensIndex: N.tokens.length\n                        };\n                        I.push(e);\n                        push(e);\n                        continue;\n                    }\n                    if (B === \"}\") {\n                        const e = I[I.length - 1];\n                        if (r.nobrace === true || !e) {\n                            push({\n                                type: \"text\",\n                                value: B,\n                                output: B\n                            });\n                            continue;\n                        }\n                        let t = \")\";\n                        if (e.dots === true) {\n                            const e = A.slice();\n                            const n = [];\n                            for(let t = e.length - 1; t >= 0; t--){\n                                A.pop();\n                                if (e[t].type === \"brace\") {\n                                    break;\n                                }\n                                if (e[t].type !== \"dots\") {\n                                    n.unshift(e[t].value);\n                                }\n                            }\n                            t = expandRange(n, r);\n                            N.backtrack = true;\n                        }\n                        if (e.comma !== true && e.dots !== true) {\n                            const r = N.output.slice(0, e.outputIndex);\n                            const n = N.tokens.slice(e.tokensIndex);\n                            e.value = e.output = \"\\\\{\";\n                            B = t = \"\\\\}\";\n                            N.output = r;\n                            for (const e of n){\n                                N.output += e.output || e.value;\n                            }\n                        }\n                        push({\n                            type: \"brace\",\n                            value: B,\n                            output: t\n                        });\n                        decrement(\"braces\");\n                        I.pop();\n                        continue;\n                    }\n                    if (B === \"|\") {\n                        if (k.length > 0) {\n                            k[k.length - 1].conditions++;\n                        }\n                        push({\n                            type: \"text\",\n                            value: B\n                        });\n                        continue;\n                    }\n                    if (B === \",\") {\n                        let e = B;\n                        const t = I[I.length - 1];\n                        if (t && M[M.length - 1] === \"braces\") {\n                            t.comma = true;\n                            e = \"|\";\n                        }\n                        push({\n                            type: \"comma\",\n                            value: B,\n                            output: e\n                        });\n                        continue;\n                    }\n                    if (B === \"/\") {\n                        if (P.type === \"dot\" && N.index === N.start + 1) {\n                            N.start = N.index + 1;\n                            N.consumed = \"\";\n                            N.output = \"\";\n                            A.pop();\n                            P = f;\n                            continue;\n                        }\n                        push({\n                            type: \"slash\",\n                            value: B,\n                            output: y\n                        });\n                        continue;\n                    }\n                    if (B === \".\") {\n                        if (N.braces > 0 && P.type === \"dot\") {\n                            if (P.value === \".\") P.output = E;\n                            const e = I[I.length - 1];\n                            P.type = \"dots\";\n                            P.output += B;\n                            P.value += B;\n                            e.dots = true;\n                            continue;\n                        }\n                        if (N.braces + N.parens === 0 && P.type !== \"bos\" && P.type !== \"slash\") {\n                            push({\n                                type: \"text\",\n                                value: B,\n                                output: E\n                            });\n                            continue;\n                        }\n                        push({\n                            type: \"dot\",\n                            value: B,\n                            output: E\n                        });\n                        continue;\n                    }\n                    if (B === \"?\") {\n                        const e = P && P.value === \"(\";\n                        if (!e && r.noextglob !== true && G() === \"(\" && G(2) !== \"?\") {\n                            extglobOpen(\"qmark\", B);\n                            continue;\n                        }\n                        if (P && P.type === \"paren\") {\n                            const e = G();\n                            let t = B;\n                            if (e === \"<\" && !u.supportsLookbehinds()) {\n                                throw new Error(\"Node.js v10 or higher is required for regex lookbehinds\");\n                            }\n                            if (P.value === \"(\" && !/[!=<:]/.test(e) || e === \"<\" && !/<([!=]|\\w+>)/.test(remaining())) {\n                                t = \"\\\\\".concat(B);\n                            }\n                            push({\n                                type: \"text\",\n                                value: B,\n                                output: t\n                            });\n                            continue;\n                        }\n                        if (r.dot !== true && (P.type === \"slash\" || P.type === \"bos\")) {\n                            push({\n                                type: \"qmark\",\n                                value: B,\n                                output: $\n                            });\n                            continue;\n                        }\n                        push({\n                            type: \"qmark\",\n                            value: B,\n                            output: v\n                        });\n                        continue;\n                    }\n                    if (B === \"!\") {\n                        if (r.noextglob !== true && G() === \"(\") {\n                            if (G(2) !== \"?\" || !/[!=<:]/.test(G(3))) {\n                                extglobOpen(\"negate\", B);\n                                continue;\n                            }\n                        }\n                        if (r.nonegate !== true && N.index === 0) {\n                            negate();\n                            continue;\n                        }\n                    }\n                    if (B === \"+\") {\n                        if (r.noextglob !== true && G() === \"(\" && G(2) !== \"?\") {\n                            extglobOpen(\"plus\", B);\n                            continue;\n                        }\n                        if (P && P.value === \"(\" || r.regex === false) {\n                            push({\n                                type: \"plus\",\n                                value: B,\n                                output: C\n                            });\n                            continue;\n                        }\n                        if (P && (P.type === \"bracket\" || P.type === \"paren\" || P.type === \"brace\") || N.parens > 0) {\n                            push({\n                                type: \"plus\",\n                                value: B\n                            });\n                            continue;\n                        }\n                        push({\n                            type: \"plus\",\n                            value: C\n                        });\n                        continue;\n                    }\n                    if (B === \"@\") {\n                        if (r.noextglob !== true && G() === \"(\" && G(2) !== \"?\") {\n                            push({\n                                type: \"at\",\n                                extglob: true,\n                                value: B,\n                                output: \"\"\n                            });\n                            continue;\n                        }\n                        push({\n                            type: \"text\",\n                            value: B\n                        });\n                        continue;\n                    }\n                    if (B !== \"*\") {\n                        if (B === \"$\" || B === \"^\") {\n                            B = \"\\\\\".concat(B);\n                        }\n                        const e = i.exec(remaining());\n                        if (e) {\n                            B += e[0];\n                            N.index += e[0].length;\n                        }\n                        push({\n                            type: \"text\",\n                            value: B\n                        });\n                        continue;\n                    }\n                    if (P && (P.type === \"globstar\" || P.star === true)) {\n                        P.type = \"star\";\n                        P.star = true;\n                        P.value += B;\n                        P.output = w;\n                        N.backtrack = true;\n                        N.globstar = true;\n                        consume(B);\n                        continue;\n                    }\n                    let t = remaining();\n                    if (r.noextglob !== true && /^\\([^?]/.test(t)) {\n                        extglobOpen(\"star\", B);\n                        continue;\n                    }\n                    if (P.type === \"star\") {\n                        if (r.noglobstar === true) {\n                            consume(B);\n                            continue;\n                        }\n                        const n = P.prev;\n                        const u = n.prev;\n                        const s = n.type === \"slash\" || n.type === \"bos\";\n                        const o = u && (u.type === \"star\" || u.type === \"globstar\");\n                        if (r.bash === true && (!s || t[0] && t[0] !== \"/\")) {\n                            push({\n                                type: \"star\",\n                                value: B,\n                                output: \"\"\n                            });\n                            continue;\n                        }\n                        const i = N.braces > 0 && (n.type === \"comma\" || n.type === \"brace\");\n                        const a = k.length && (n.type === \"pipe\" || n.type === \"paren\");\n                        if (!s && n.type !== \"paren\" && !i && !a) {\n                            push({\n                                type: \"star\",\n                                value: B,\n                                output: \"\"\n                            });\n                            continue;\n                        }\n                        while(t.slice(0, 3) === \"/**\"){\n                            const r = e[N.index + 4];\n                            if (r && r !== \"/\") {\n                                break;\n                            }\n                            t = t.slice(3);\n                            consume(\"/**\", 3);\n                        }\n                        if (n.type === \"bos\" && eos()) {\n                            P.type = \"globstar\";\n                            P.value += B;\n                            P.output = globstar(r);\n                            N.output = P.output;\n                            N.globstar = true;\n                            consume(B);\n                            continue;\n                        }\n                        if (n.type === \"slash\" && n.prev.type !== \"bos\" && !o && eos()) {\n                            N.output = N.output.slice(0, -(n.output + P.output).length);\n                            n.output = \"(?:\".concat(n.output);\n                            P.type = \"globstar\";\n                            P.output = globstar(r) + (r.strictSlashes ? \")\" : \"|$)\");\n                            P.value += B;\n                            N.globstar = true;\n                            N.output += n.output + P.output;\n                            consume(B);\n                            continue;\n                        }\n                        if (n.type === \"slash\" && n.prev.type !== \"bos\" && t[0] === \"/\") {\n                            const e = t[1] !== void 0 ? \"|$\" : \"\";\n                            N.output = N.output.slice(0, -(n.output + P.output).length);\n                            n.output = \"(?:\".concat(n.output);\n                            P.type = \"globstar\";\n                            P.output = \"\".concat(globstar(r)).concat(y, \"|\").concat(y).concat(e, \")\");\n                            P.value += B;\n                            N.output += n.output + P.output;\n                            N.globstar = true;\n                            consume(B + D());\n                            push({\n                                type: \"slash\",\n                                value: \"/\",\n                                output: \"\"\n                            });\n                            continue;\n                        }\n                        if (n.type === \"bos\" && t[0] === \"/\") {\n                            P.type = \"globstar\";\n                            P.value += B;\n                            P.output = \"(?:^|\".concat(y, \"|\").concat(globstar(r)).concat(y, \")\");\n                            N.output = P.output;\n                            N.globstar = true;\n                            consume(B + D());\n                            push({\n                                type: \"slash\",\n                                value: \"/\",\n                                output: \"\"\n                            });\n                            continue;\n                        }\n                        N.output = N.output.slice(0, -P.output.length);\n                        P.type = \"globstar\";\n                        P.output = globstar(r);\n                        P.value += B;\n                        N.output += P.output;\n                        N.globstar = true;\n                        consume(B);\n                        continue;\n                    }\n                    const n = {\n                        type: \"star\",\n                        value: B,\n                        output: w\n                    };\n                    if (r.bash === true) {\n                        n.output = \".*?\";\n                        if (P.type === \"bos\" || P.type === \"slash\") {\n                            n.output = L + n.output;\n                        }\n                        push(n);\n                        continue;\n                    }\n                    if (P && (P.type === \"bracket\" || P.type === \"paren\") && r.regex === true) {\n                        n.output = B;\n                        push(n);\n                        continue;\n                    }\n                    if (N.index === N.start || P.type === \"slash\" || P.type === \"dot\") {\n                        if (P.type === \"dot\") {\n                            N.output += S;\n                            P.output += S;\n                        } else if (r.dot === true) {\n                            N.output += H;\n                            P.output += H;\n                        } else {\n                            N.output += L;\n                            P.output += L;\n                        }\n                        if (G() !== \"*\") {\n                            N.output += d;\n                            P.output += d;\n                        }\n                    }\n                    push(n);\n                }\n                while(N.brackets > 0){\n                    if (r.strictBrackets === true) throw new SyntaxError(syntaxError(\"closing\", \"]\"));\n                    N.output = u.escapeLast(N.output, \"[\");\n                    decrement(\"brackets\");\n                }\n                while(N.parens > 0){\n                    if (r.strictBrackets === true) throw new SyntaxError(syntaxError(\"closing\", \")\"));\n                    N.output = u.escapeLast(N.output, \"(\");\n                    decrement(\"parens\");\n                }\n                while(N.braces > 0){\n                    if (r.strictBrackets === true) throw new SyntaxError(syntaxError(\"closing\", \"}\"));\n                    N.output = u.escapeLast(N.output, \"{\");\n                    decrement(\"braces\");\n                }\n                if (r.strictSlashes !== true && (P.type === \"star\" || P.type === \"bracket\")) {\n                    push({\n                        type: \"maybe_slash\",\n                        value: \"\",\n                        output: \"\".concat(y, \"?\")\n                    });\n                }\n                if (N.backtrack === true) {\n                    N.output = \"\";\n                    for (const e of N.tokens){\n                        N.output += e.output != null ? e.output : e.value;\n                        if (e.suffix) {\n                            N.output += e.suffix;\n                        }\n                    }\n                }\n                return N;\n            };\n            parse.fastpaths = (e, t)=>{\n                const r = {\n                    ...t\n                };\n                const o = typeof r.maxLength === \"number\" ? Math.min(s, r.maxLength) : s;\n                const i = e.length;\n                if (i > o) {\n                    throw new SyntaxError(\"Input length: \".concat(i, \", exceeds maximum allowed length: \").concat(o));\n                }\n                e = l[e] || e;\n                const a = u.isWindows(t);\n                const { DOT_LITERAL: c, SLASH_LITERAL: p, ONE_CHAR: f, DOTS_SLASH: A, NO_DOT: R, NO_DOTS: _, NO_DOTS_SLASH: h, STAR: g, START_ANCHOR: E } = n.globChars(a);\n                const C = r.dot ? _ : R;\n                const y = r.dot ? h : R;\n                const d = r.capture ? \"\" : \"?:\";\n                const x = {\n                    negated: false,\n                    prefix: \"\"\n                };\n                let b = r.bash === true ? \".*?\" : g;\n                if (r.capture) {\n                    b = \"(\".concat(b, \")\");\n                }\n                const globstar = (e)=>{\n                    if (e.noglobstar === true) return b;\n                    return \"(\".concat(d, \"(?:(?!\").concat(E).concat(e.dot ? A : c, \").)*?)\");\n                };\n                const create = (e)=>{\n                    switch(e){\n                        case \"*\":\n                            return \"\".concat(C).concat(f).concat(b);\n                        case \".*\":\n                            return \"\".concat(c).concat(f).concat(b);\n                        case \"*.*\":\n                            return \"\".concat(C).concat(b).concat(c).concat(f).concat(b);\n                        case \"*/*\":\n                            return \"\".concat(C).concat(b).concat(p).concat(f).concat(y).concat(b);\n                        case \"**\":\n                            return C + globstar(r);\n                        case \"**/*\":\n                            return \"(?:\".concat(C).concat(globstar(r)).concat(p, \")?\").concat(y).concat(f).concat(b);\n                        case \"**/*.*\":\n                            return \"(?:\".concat(C).concat(globstar(r)).concat(p, \")?\").concat(y).concat(b).concat(c).concat(f).concat(b);\n                        case \"**/.*\":\n                            return \"(?:\".concat(C).concat(globstar(r)).concat(p, \")?\").concat(c).concat(f).concat(b);\n                        default:\n                            {\n                                const t = /^(.*?)\\.(\\w+)$/.exec(e);\n                                if (!t) return;\n                                const r = create(t[1]);\n                                if (!r) return;\n                                return r + c + t[2];\n                            }\n                    }\n                };\n                const S = u.removePrefix(e, x);\n                let H = create(S);\n                if (H && r.strictSlashes !== true) {\n                    H += \"\".concat(p, \"?\");\n                }\n                return H;\n            };\n            e.exports = parse;\n        },\n        683: (e, t, r)=>{\n            const n = r(17);\n            const u = r(700);\n            const s = r(754);\n            const o = r(513);\n            const i = r(356);\n            const isObject = (e)=>e && typeof e === \"object\" && !Array.isArray(e);\n            const picomatch = function(e, t) {\n                let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;\n                if (Array.isArray(e)) {\n                    const n = e.map((e)=>picomatch(e, t, r));\n                    const arrayMatcher = (e)=>{\n                        for (const t of n){\n                            const r = t(e);\n                            if (r) return r;\n                        }\n                        return false;\n                    };\n                    return arrayMatcher;\n                }\n                const n = isObject(e) && e.tokens && e.input;\n                if (e === \"\" || typeof e !== \"string\" && !n) {\n                    throw new TypeError(\"Expected pattern to be a non-empty string\");\n                }\n                const u = t || {};\n                const s = o.isWindows(t);\n                const i = n ? picomatch.compileRe(e, t) : picomatch.makeRe(e, t, false, true);\n                const a = i.state;\n                delete i.state;\n                let isIgnored = ()=>false;\n                if (u.ignore) {\n                    const e = {\n                        ...t,\n                        ignore: null,\n                        onMatch: null,\n                        onResult: null\n                    };\n                    isIgnored = picomatch(u.ignore, e, r);\n                }\n                const matcher = function(r) {\n                    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n                    const { isMatch: o, match: l, output: c } = picomatch.test(r, i, t, {\n                        glob: e,\n                        posix: s\n                    });\n                    const p = {\n                        glob: e,\n                        state: a,\n                        regex: i,\n                        posix: s,\n                        input: r,\n                        output: c,\n                        match: l,\n                        isMatch: o\n                    };\n                    if (typeof u.onResult === \"function\") {\n                        u.onResult(p);\n                    }\n                    if (o === false) {\n                        p.isMatch = false;\n                        return n ? p : false;\n                    }\n                    if (isIgnored(r)) {\n                        if (typeof u.onIgnore === \"function\") {\n                            u.onIgnore(p);\n                        }\n                        p.isMatch = false;\n                        return n ? p : false;\n                    }\n                    if (typeof u.onMatch === \"function\") {\n                        u.onMatch(p);\n                    }\n                    return n ? p : true;\n                };\n                if (r) {\n                    matcher.state = a;\n                }\n                return matcher;\n            };\n            picomatch.test = function(e, t, r) {\n                let { glob: n, posix: u } = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n                if (typeof e !== \"string\") {\n                    throw new TypeError(\"Expected input to be a string\");\n                }\n                if (e === \"\") {\n                    return {\n                        isMatch: false,\n                        output: \"\"\n                    };\n                }\n                const s = r || {};\n                const i = s.format || (u ? o.toPosixSlashes : null);\n                let a = e === n;\n                let l = a && i ? i(e) : e;\n                if (a === false) {\n                    l = i ? i(e) : e;\n                    a = l === n;\n                }\n                if (a === false || s.capture === true) {\n                    if (s.matchBase === true || s.basename === true) {\n                        a = picomatch.matchBase(e, t, r, u);\n                    } else {\n                        a = t.exec(l);\n                    }\n                }\n                return {\n                    isMatch: Boolean(a),\n                    match: a,\n                    output: l\n                };\n            };\n            picomatch.matchBase = function(e, t, r) {\n                let u = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : o.isWindows(r);\n                const s = t instanceof RegExp ? t : picomatch.makeRe(t, r);\n                return s.test(n.basename(e));\n            };\n            picomatch.isMatch = (e, t, r)=>picomatch(t, r)(e);\n            picomatch.parse = (e, t)=>{\n                if (Array.isArray(e)) return e.map((e)=>picomatch.parse(e, t));\n                return s(e, {\n                    ...t,\n                    fastpaths: false\n                });\n            };\n            picomatch.scan = (e, t)=>u(e, t);\n            picomatch.compileRe = function(e, t) {\n                let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;\n                if (r === true) {\n                    return e.output;\n                }\n                const u = t || {};\n                const s = u.contains ? \"\" : \"^\";\n                const o = u.contains ? \"\" : \"$\";\n                let i = \"\".concat(s, \"(?:\").concat(e.output, \")\").concat(o);\n                if (e && e.negated === true) {\n                    i = \"^(?!\".concat(i, \").*$\");\n                }\n                const a = picomatch.toRegex(i, t);\n                if (n === true) {\n                    a.state = e;\n                }\n                return a;\n            };\n            picomatch.makeRe = function(e, t) {\n                let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;\n                if (!e || typeof e !== \"string\") {\n                    throw new TypeError(\"Expected a non-empty string\");\n                }\n                const u = t || {};\n                let o = {\n                    negated: false,\n                    fastpaths: true\n                };\n                let i = \"\";\n                let a;\n                if (e.startsWith(\"./\")) {\n                    e = e.slice(2);\n                    i = o.prefix = \"./\";\n                }\n                if (u.fastpaths !== false && (e[0] === \".\" || e[0] === \"*\")) {\n                    a = s.fastpaths(e, t);\n                }\n                if (a === undefined) {\n                    o = s(e, t);\n                    o.prefix = i + (o.prefix || \"\");\n                } else {\n                    o.output = a;\n                }\n                return picomatch.compileRe(o, t, r, n);\n            };\n            picomatch.toRegex = (e, t)=>{\n                try {\n                    const r = t || {};\n                    return new RegExp(e, r.flags || (r.nocase ? \"i\" : \"\"));\n                } catch (e) {\n                    if (t && t.debug === true) throw e;\n                    return /$^/;\n                }\n            };\n            picomatch.constants = i;\n            e.exports = picomatch;\n        },\n        700: (e, t, r)=>{\n            const n = r(513);\n            const { CHAR_ASTERISK: u, CHAR_AT: s, CHAR_BACKWARD_SLASH: o, CHAR_COMMA: i, CHAR_DOT: a, CHAR_EXCLAMATION_MARK: l, CHAR_FORWARD_SLASH: c, CHAR_LEFT_CURLY_BRACE: p, CHAR_LEFT_PARENTHESES: f, CHAR_LEFT_SQUARE_BRACKET: A, CHAR_PLUS: R, CHAR_QUESTION_MARK: _, CHAR_RIGHT_CURLY_BRACE: h, CHAR_RIGHT_PARENTHESES: g, CHAR_RIGHT_SQUARE_BRACKET: E } = r(356);\n            const isPathSeparator = (e)=>e === c || e === o;\n            const depth = (e)=>{\n                if (e.isPrefix !== true) {\n                    e.depth = e.isGlobstar ? Infinity : 1;\n                }\n            };\n            const scan = (e, t)=>{\n                const r = t || {};\n                const C = e.length - 1;\n                const y = r.parts === true || r.scanToEnd === true;\n                const d = [];\n                const x = [];\n                const b = [];\n                let S = e;\n                let H = -1;\n                let v = 0;\n                let $ = 0;\n                let m = false;\n                let T = false;\n                let L = false;\n                let O = false;\n                let w = false;\n                let N = false;\n                let k = false;\n                let I = false;\n                let M = false;\n                let P = 0;\n                let B;\n                let G;\n                let D = {\n                    value: \"\",\n                    depth: 0,\n                    isGlob: false\n                };\n                const eos = ()=>H >= C;\n                const peek = ()=>S.charCodeAt(H + 1);\n                const advance = ()=>{\n                    B = G;\n                    return S.charCodeAt(++H);\n                };\n                while(H < C){\n                    G = advance();\n                    let e;\n                    if (G === o) {\n                        k = D.backslashes = true;\n                        G = advance();\n                        if (G === p) {\n                            N = true;\n                        }\n                        continue;\n                    }\n                    if (N === true || G === p) {\n                        P++;\n                        while(eos() !== true && (G = advance())){\n                            if (G === o) {\n                                k = D.backslashes = true;\n                                advance();\n                                continue;\n                            }\n                            if (G === p) {\n                                P++;\n                                continue;\n                            }\n                            if (N !== true && G === a && (G = advance()) === a) {\n                                m = D.isBrace = true;\n                                L = D.isGlob = true;\n                                M = true;\n                                if (y === true) {\n                                    continue;\n                                }\n                                break;\n                            }\n                            if (N !== true && G === i) {\n                                m = D.isBrace = true;\n                                L = D.isGlob = true;\n                                M = true;\n                                if (y === true) {\n                                    continue;\n                                }\n                                break;\n                            }\n                            if (G === h) {\n                                P--;\n                                if (P === 0) {\n                                    N = false;\n                                    m = D.isBrace = true;\n                                    M = true;\n                                    break;\n                                }\n                            }\n                        }\n                        if (y === true) {\n                            continue;\n                        }\n                        break;\n                    }\n                    if (G === c) {\n                        d.push(H);\n                        x.push(D);\n                        D = {\n                            value: \"\",\n                            depth: 0,\n                            isGlob: false\n                        };\n                        if (M === true) continue;\n                        if (B === a && H === v + 1) {\n                            v += 2;\n                            continue;\n                        }\n                        $ = H + 1;\n                        continue;\n                    }\n                    if (r.noext !== true) {\n                        const e = G === R || G === s || G === u || G === _ || G === l;\n                        if (e === true && peek() === f) {\n                            L = D.isGlob = true;\n                            O = D.isExtglob = true;\n                            M = true;\n                            if (y === true) {\n                                while(eos() !== true && (G = advance())){\n                                    if (G === o) {\n                                        k = D.backslashes = true;\n                                        G = advance();\n                                        continue;\n                                    }\n                                    if (G === g) {\n                                        L = D.isGlob = true;\n                                        M = true;\n                                        break;\n                                    }\n                                }\n                                continue;\n                            }\n                            break;\n                        }\n                    }\n                    if (G === u) {\n                        if (B === u) w = D.isGlobstar = true;\n                        L = D.isGlob = true;\n                        M = true;\n                        if (y === true) {\n                            continue;\n                        }\n                        break;\n                    }\n                    if (G === _) {\n                        L = D.isGlob = true;\n                        M = true;\n                        if (y === true) {\n                            continue;\n                        }\n                        break;\n                    }\n                    if (G === A) {\n                        while(eos() !== true && (e = advance())){\n                            if (e === o) {\n                                k = D.backslashes = true;\n                                advance();\n                                continue;\n                            }\n                            if (e === E) {\n                                T = D.isBracket = true;\n                                L = D.isGlob = true;\n                                M = true;\n                                break;\n                            }\n                        }\n                        if (y === true) {\n                            continue;\n                        }\n                        break;\n                    }\n                    if (r.nonegate !== true && G === l && H === v) {\n                        I = D.negated = true;\n                        v++;\n                        continue;\n                    }\n                    if (r.noparen !== true && G === f) {\n                        L = D.isGlob = true;\n                        if (y === true) {\n                            while(eos() !== true && (G = advance())){\n                                if (G === f) {\n                                    k = D.backslashes = true;\n                                    G = advance();\n                                    continue;\n                                }\n                                if (G === g) {\n                                    M = true;\n                                    break;\n                                }\n                            }\n                            continue;\n                        }\n                        break;\n                    }\n                    if (L === true) {\n                        M = true;\n                        if (y === true) {\n                            continue;\n                        }\n                        break;\n                    }\n                }\n                if (r.noext === true) {\n                    O = false;\n                    L = false;\n                }\n                let U = S;\n                let K = \"\";\n                let F = \"\";\n                if (v > 0) {\n                    K = S.slice(0, v);\n                    S = S.slice(v);\n                    $ -= v;\n                }\n                if (U && L === true && $ > 0) {\n                    U = S.slice(0, $);\n                    F = S.slice($);\n                } else if (L === true) {\n                    U = \"\";\n                    F = S;\n                } else {\n                    U = S;\n                }\n                if (U && U !== \"\" && U !== \"/\" && U !== S) {\n                    if (isPathSeparator(U.charCodeAt(U.length - 1))) {\n                        U = U.slice(0, -1);\n                    }\n                }\n                if (r.unescape === true) {\n                    if (F) F = n.removeBackslashes(F);\n                    if (U && k === true) {\n                        U = n.removeBackslashes(U);\n                    }\n                }\n                const Q = {\n                    prefix: K,\n                    input: e,\n                    start: v,\n                    base: U,\n                    glob: F,\n                    isBrace: m,\n                    isBracket: T,\n                    isGlob: L,\n                    isExtglob: O,\n                    isGlobstar: w,\n                    negated: I\n                };\n                if (r.tokens === true) {\n                    Q.maxDepth = 0;\n                    if (!isPathSeparator(G)) {\n                        x.push(D);\n                    }\n                    Q.tokens = x;\n                }\n                if (r.parts === true || r.tokens === true) {\n                    let t;\n                    for(let n = 0; n < d.length; n++){\n                        const u = t ? t + 1 : v;\n                        const s = d[n];\n                        const o = e.slice(u, s);\n                        if (r.tokens) {\n                            if (n === 0 && v !== 0) {\n                                x[n].isPrefix = true;\n                                x[n].value = K;\n                            } else {\n                                x[n].value = o;\n                            }\n                            depth(x[n]);\n                            Q.maxDepth += x[n].depth;\n                        }\n                        if (n !== 0 || o !== \"\") {\n                            b.push(o);\n                        }\n                        t = s;\n                    }\n                    if (t && t + 1 < e.length) {\n                        const n = e.slice(t + 1);\n                        b.push(n);\n                        if (r.tokens) {\n                            x[x.length - 1].value = n;\n                            depth(x[x.length - 1]);\n                            Q.maxDepth += x[x.length - 1].depth;\n                        }\n                    }\n                    Q.slashes = d;\n                    Q.parts = b;\n                }\n                return Q;\n            };\n            e.exports = scan;\n        },\n        513: (e, t, r)=>{\n            const n = r(17);\n            const u = process.platform === \"win32\";\n            const { REGEX_BACKSLASH: s, REGEX_REMOVE_BACKSLASH: o, REGEX_SPECIAL_CHARS: i, REGEX_SPECIAL_CHARS_GLOBAL: a } = r(356);\n            t.isObject = (e)=>e !== null && typeof e === \"object\" && !Array.isArray(e);\n            t.hasRegexChars = (e)=>i.test(e);\n            t.isRegexChar = (e)=>e.length === 1 && t.hasRegexChars(e);\n            t.escapeRegex = (e)=>e.replace(a, \"\\\\$1\");\n            t.toPosixSlashes = (e)=>e.replace(s, \"/\");\n            t.removeBackslashes = (e)=>e.replace(o, (e)=>e === \"\\\\\" ? \"\" : e);\n            t.supportsLookbehinds = ()=>{\n                const e = process.version.slice(1).split(\".\").map(Number);\n                if (e.length === 3 && e[0] >= 9 || e[0] === 8 && e[1] >= 10) {\n                    return true;\n                }\n                return false;\n            };\n            t.isWindows = (e)=>{\n                if (e && typeof e.windows === \"boolean\") {\n                    return e.windows;\n                }\n                return u === true || n.sep === \"\\\\\";\n            };\n            t.escapeLast = (e, r, n)=>{\n                const u = e.lastIndexOf(r, n);\n                if (u === -1) return e;\n                if (e[u - 1] === \"\\\\\") return t.escapeLast(e, r, u - 1);\n                return \"\".concat(e.slice(0, u), \"\\\\\").concat(e.slice(u));\n            };\n            t.removePrefix = function(e) {\n                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                let r = e;\n                if (r.startsWith(\"./\")) {\n                    r = r.slice(2);\n                    t.prefix = \"./\";\n                }\n                return r;\n            };\n            t.wrapOutput = function(e) {\n                let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n                const n = r.contains ? \"\" : \"^\";\n                const u = r.contains ? \"\" : \"$\";\n                let s = \"\".concat(n, \"(?:\").concat(e, \")\").concat(u);\n                if (t.negated === true) {\n                    s = \"(?:^(?!\".concat(s, \").*$)\");\n                }\n                return s;\n            };\n        },\n        492: (e, t, r)=>{\n            /*!\n * to-regex-range <https://github.com/micromatch/to-regex-range>\n *\n * Copyright (c) 2015-present, Jon Schlinkert.\n * Released under the MIT License.\n */ const n = r(357);\n            const toRegexRange = (e, t, r)=>{\n                if (n(e) === false) {\n                    throw new TypeError(\"toRegexRange: expected the first argument to be a number\");\n                }\n                if (t === void 0 || e === t) {\n                    return String(e);\n                }\n                if (n(t) === false) {\n                    throw new TypeError(\"toRegexRange: expected the second argument to be a number.\");\n                }\n                let u = {\n                    relaxZeros: true,\n                    ...r\n                };\n                if (typeof u.strictZeros === \"boolean\") {\n                    u.relaxZeros = u.strictZeros === false;\n                }\n                let s = String(u.relaxZeros);\n                let o = String(u.shorthand);\n                let i = String(u.capture);\n                let a = String(u.wrap);\n                let l = e + \":\" + t + \"=\" + s + o + i + a;\n                if (toRegexRange.cache.hasOwnProperty(l)) {\n                    return toRegexRange.cache[l].result;\n                }\n                let c = Math.min(e, t);\n                let p = Math.max(e, t);\n                if (Math.abs(c - p) === 1) {\n                    let r = e + \"|\" + t;\n                    if (u.capture) {\n                        return \"(\".concat(r, \")\");\n                    }\n                    if (u.wrap === false) {\n                        return r;\n                    }\n                    return \"(?:\".concat(r, \")\");\n                }\n                let f = hasPadding(e) || hasPadding(t);\n                let A = {\n                    min: e,\n                    max: t,\n                    a: c,\n                    b: p\n                };\n                let R = [];\n                let _ = [];\n                if (f) {\n                    A.isPadded = f;\n                    A.maxLen = String(A.max).length;\n                }\n                if (c < 0) {\n                    let e = p < 0 ? Math.abs(p) : 1;\n                    _ = splitToPatterns(e, Math.abs(c), A, u);\n                    c = A.a = 0;\n                }\n                if (p >= 0) {\n                    R = splitToPatterns(c, p, A, u);\n                }\n                A.negatives = _;\n                A.positives = R;\n                A.result = collatePatterns(_, R, u);\n                if (u.capture === true) {\n                    A.result = \"(\".concat(A.result, \")\");\n                } else if (u.wrap !== false && R.length + _.length > 1) {\n                    A.result = \"(?:\".concat(A.result, \")\");\n                }\n                toRegexRange.cache[l] = A;\n                return A.result;\n            };\n            function collatePatterns(e, t, r) {\n                let n = filterPatterns(e, t, \"-\", false, r) || [];\n                let u = filterPatterns(t, e, \"\", false, r) || [];\n                let s = filterPatterns(e, t, \"-?\", true, r) || [];\n                let o = n.concat(s).concat(u);\n                return o.join(\"|\");\n            }\n            function splitToRanges(e, t) {\n                let r = 1;\n                let n = 1;\n                let u = countNines(e, r);\n                let s = new Set([\n                    t\n                ]);\n                while(e <= u && u <= t){\n                    s.add(u);\n                    r += 1;\n                    u = countNines(e, r);\n                }\n                u = countZeros(t + 1, n) - 1;\n                while(e < u && u <= t){\n                    s.add(u);\n                    n += 1;\n                    u = countZeros(t + 1, n) - 1;\n                }\n                s = [\n                    ...s\n                ];\n                s.sort(compare);\n                return s;\n            }\n            function rangeToPattern(e, t, r) {\n                if (e === t) {\n                    return {\n                        pattern: e,\n                        count: [],\n                        digits: 0\n                    };\n                }\n                let n = zip(e, t);\n                let u = n.length;\n                let s = \"\";\n                let o = 0;\n                for(let e = 0; e < u; e++){\n                    let [t, u] = n[e];\n                    if (t === u) {\n                        s += t;\n                    } else if (t !== \"0\" || u !== \"9\") {\n                        s += toCharacterClass(t, u, r);\n                    } else {\n                        o++;\n                    }\n                }\n                if (o) {\n                    s += r.shorthand === true ? \"\\\\d\" : \"[0-9]\";\n                }\n                return {\n                    pattern: s,\n                    count: [\n                        o\n                    ],\n                    digits: u\n                };\n            }\n            function splitToPatterns(e, t, r, n) {\n                let u = splitToRanges(e, t);\n                let s = [];\n                let o = e;\n                let i;\n                for(let e = 0; e < u.length; e++){\n                    let t = u[e];\n                    let a = rangeToPattern(String(o), String(t), n);\n                    let l = \"\";\n                    if (!r.isPadded && i && i.pattern === a.pattern) {\n                        if (i.count.length > 1) {\n                            i.count.pop();\n                        }\n                        i.count.push(a.count[0]);\n                        i.string = i.pattern + toQuantifier(i.count);\n                        o = t + 1;\n                        continue;\n                    }\n                    if (r.isPadded) {\n                        l = padZeros(t, r, n);\n                    }\n                    a.string = l + a.pattern + toQuantifier(a.count);\n                    s.push(a);\n                    o = t + 1;\n                    i = a;\n                }\n                return s;\n            }\n            function filterPatterns(e, t, r, n, u) {\n                let s = [];\n                for (let u of e){\n                    let { string: e } = u;\n                    if (!n && !contains(t, \"string\", e)) {\n                        s.push(r + e);\n                    }\n                    if (n && contains(t, \"string\", e)) {\n                        s.push(r + e);\n                    }\n                }\n                return s;\n            }\n            function zip(e, t) {\n                let r = [];\n                for(let n = 0; n < e.length; n++)r.push([\n                    e[n],\n                    t[n]\n                ]);\n                return r;\n            }\n            function compare(e, t) {\n                return e > t ? 1 : t > e ? -1 : 0;\n            }\n            function contains(e, t, r) {\n                return e.some((e)=>e[t] === r);\n            }\n            function countNines(e, t) {\n                return Number(String(e).slice(0, -t) + \"9\".repeat(t));\n            }\n            function countZeros(e, t) {\n                return e - e % Math.pow(10, t);\n            }\n            function toQuantifier(e) {\n                let [t = 0, r = \"\"] = e;\n                if (r || t > 1) {\n                    return \"{\".concat(t + (r ? \",\" + r : \"\"), \"}\");\n                }\n                return \"\";\n            }\n            function toCharacterClass(e, t, r) {\n                return \"[\".concat(e).concat(t - e === 1 ? \"\" : \"-\").concat(t, \"]\");\n            }\n            function hasPadding(e) {\n                return /^-?(0+)\\d/.test(e);\n            }\n            function padZeros(e, t, r) {\n                if (!t.isPadded) {\n                    return e;\n                }\n                let n = Math.abs(t.maxLen - String(e).length);\n                let u = r.relaxZeros !== false;\n                switch(n){\n                    case 0:\n                        return \"\";\n                    case 1:\n                        return u ? \"0?\" : \"0\";\n                    case 2:\n                        return u ? \"0{0,2}\" : \"00\";\n                    default:\n                        {\n                            return u ? \"0{0,\".concat(n, \"}\") : \"0{\".concat(n, \"}\");\n                        }\n                }\n            }\n            toRegexRange.cache = {};\n            toRegexRange.clearCache = ()=>toRegexRange.cache = {};\n            e.exports = toRegexRange;\n        },\n        17: (e)=>{\n            e.exports = __webpack_require__(/*! path */ \"(app-pages-browser)/./node_modules/next/dist/compiled/path-browserify/index.js\");\n        },\n        837: (e)=>{\n            e.exports = __webpack_require__(/*! util */ \"(app-pages-browser)/./node_modules/next/dist/compiled/util/util.js\");\n        }\n    };\n    var t = {};\n    function __nccwpck_require__(r) {\n        var n = t[r];\n        if (n !== undefined) {\n            return n.exports;\n        }\n        var u = t[r] = {\n            exports: {}\n        };\n        var s = true;\n        try {\n            e[r](u, u.exports, __nccwpck_require__);\n            s = false;\n        } finally{\n            if (s) delete t[r];\n        }\n        return u.exports;\n    }\n    if (typeof __nccwpck_require__ !== \"undefined\") __nccwpck_require__.ab = __dirname + \"/\";\n    var r = __nccwpck_require__(971);\n    module.exports = r;\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWljcm9tYXRjaC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBQztJQUFLO0lBQWEsSUFBSUEsSUFBRTtRQUFDLEtBQUksQ0FBQ0EsR0FBRUMsR0FBRUM7WUFBSyxNQUFNQyxJQUFFRCxFQUFFO1lBQUssTUFBTUUsSUFBRUYsRUFBRTtZQUFLLE1BQU1HLElBQUVILEVBQUU7WUFBSSxNQUFNSSxJQUFFSixFQUFFO1lBQUssTUFBTUssU0FBTyxTQUFDUDtvQkFBRUMscUVBQUUsQ0FBQztnQkFBSyxJQUFJQyxJQUFFLEVBQUU7Z0JBQUMsSUFBR00sTUFBTUMsT0FBTyxDQUFDVCxJQUFHO29CQUFDLEtBQUksSUFBSUcsS0FBS0gsRUFBRTt3QkFBQyxJQUFJQSxJQUFFTyxPQUFPRyxNQUFNLENBQUNQLEdBQUVGO3dCQUFHLElBQUdPLE1BQU1DLE9BQU8sQ0FBQ1QsSUFBRzs0QkFBQ0UsRUFBRVMsSUFBSSxJQUFJWDt3QkFBRSxPQUFLOzRCQUFDRSxFQUFFUyxJQUFJLENBQUNYO3dCQUFFO29CQUFDO2dCQUFDLE9BQUs7b0JBQUNFLElBQUUsRUFBRSxDQUFDVSxNQUFNLENBQUNMLE9BQU9HLE1BQU0sQ0FBQ1YsR0FBRUM7Z0JBQUc7Z0JBQUMsSUFBR0EsS0FBR0EsRUFBRVksTUFBTSxLQUFHLFFBQU1aLEVBQUVhLE9BQU8sS0FBRyxNQUFLO29CQUFDWixJQUFFOzJCQUFJLElBQUlhLElBQUliO3FCQUFHO2dCQUFBO2dCQUFDLE9BQU9BO1lBQUM7WUFBRUssT0FBT1MsS0FBSyxHQUFDLFNBQUNoQjtvQkFBRUMscUVBQUUsQ0FBQzt1QkFBSUssRUFBRU4sR0FBRUM7O1lBQUdNLE9BQU9VLFNBQVMsR0FBQyxTQUFDakI7b0JBQUVDLHFFQUFFLENBQUM7Z0JBQUssSUFBRyxPQUFPRCxNQUFJLFVBQVM7b0JBQUMsT0FBT0csRUFBRUksT0FBT1MsS0FBSyxDQUFDaEIsR0FBRUMs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QUFFO2dCQUFDO1lBQUM7WUFBQ3lXLGFBQWFJLEtBQUssR0FBQyxDQUFDO1lBQUVKLGFBQWEyQixVQUFVLEdBQUMsSUFBSTNCLGFBQWFJLEtBQUssR0FBQyxDQUFDO1lBQUVoWCxFQUFFdUIsT0FBTyxHQUFDcVY7UUFBWTtRQUFFLElBQUc1VyxDQUFBQTtZQUFJQSxFQUFFdUIsT0FBTyxHQUFDaVgsbUJBQU9BLENBQUMsNEZBQU07UUFBQztRQUFFLEtBQUl4WSxDQUFBQTtZQUFJQSxFQUFFdUIsT0FBTyxHQUFDaVgsbUJBQU9BLENBQUMsZ0ZBQU07UUFBQztJQUFDO0lBQUUsSUFBSXZZLElBQUUsQ0FBQztJQUFFLFNBQVN3WSxvQkFBb0J2WSxDQUFDO1FBQUUsSUFBSUMsSUFBRUYsQ0FBQyxDQUFDQyxFQUFFO1FBQUMsSUFBR0MsTUFBSTBVLFdBQVU7WUFBQyxPQUFPMVUsRUFBRW9CLE9BQU87UUFBQTtRQUFDLElBQUluQixJQUFFSCxDQUFDLENBQUNDLEVBQUUsR0FBQztZQUFDcUIsU0FBUSxDQUFDO1FBQUM7UUFBRSxJQUFJbEIsSUFBRTtRQUFLLElBQUc7WUFBQ0wsQ0FBQyxDQUFDRSxFQUFFLENBQUNFLEdBQUVBLEVBQUVtQixPQUFPLEVBQUNrWDtZQUFxQnBZLElBQUU7UUFBSyxTQUFRO1lBQUMsSUFBR0EsR0FBRSxPQUFPSixDQUFDLENBQUNDLEVBQUU7UUFBQTtRQUFDLE9BQU9FLEVBQUVtQixPQUFPO0lBQUE7SUFBQyxJQUFHLE9BQU9rWCx3QkFBc0IsYUFBWUEsb0JBQW9CQyxFQUFFLEdBQUNDLFNBQVNBLEdBQUM7SUFBSSxJQUFJelksSUFBRXVZLG9CQUFvQjtJQUFLRyxPQUFPclgsT0FBTyxHQUFDckI7QUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pY3JvbWF0Y2gvaW5kZXguanM/M2NlZCJdLCJzb3VyY2VzQ29udGVudCI6WyIoKCk9PntcInVzZSBzdHJpY3RcIjt2YXIgZT17MzMzOihlLHQscik9Pntjb25zdCBuPXIoMTM3KTtjb25zdCB1PXIoMTc5KTtjb25zdCBzPXIoMTMpO2NvbnN0IG89cig3MTkpO2NvbnN0IGJyYWNlcz0oZSx0PXt9KT0+e2xldCByPVtdO2lmKEFycmF5LmlzQXJyYXkoZSkpe2ZvcihsZXQgbiBvZiBlKXtsZXQgZT1icmFjZXMuY3JlYXRlKG4sdCk7aWYoQXJyYXkuaXNBcnJheShlKSl7ci5wdXNoKC4uLmUpfWVsc2V7ci5wdXNoKGUpfX19ZWxzZXtyPVtdLmNvbmNhdChicmFjZXMuY3JlYXRlKGUsdCkpfWlmKHQmJnQuZXhwYW5kPT09dHJ1ZSYmdC5ub2R1cGVzPT09dHJ1ZSl7cj1bLi4ubmV3IFNldChyKV19cmV0dXJuIHJ9O2JyYWNlcy5wYXJzZT0oZSx0PXt9KT0+byhlLHQpO2JyYWNlcy5zdHJpbmdpZnk9KGUsdD17fSk9PntpZih0eXBlb2YgZT09PVwic3RyaW5nXCIpe3JldHVybiBuKGJyYWNlcy5wYXJzZShlLHQpLHQpfXJldHVybiBuKGUsdCl9O2JyYWNlcy5jb21waWxlPShlLHQ9e30pPT57aWYodHlwZW9mIGU9PT1cInN0cmluZ1wiKXtlPWJyYWNlcy5wYXJzZShlLHQpfXJldHVybiB1KGUsdCl9O2JyYWNlcy5leHBhbmQ9KGUsdD17fSk9PntpZih0eXBlb2YgZT09PVwic3RyaW5nXCIpe2U9YnJhY2VzLnBhcnNlKGUsdCl9bGV0IHI9cyhlLHQpO2lmKHQubm9lbXB0eT09PXRydWUpe3I9ci5maWx0ZXIoQm9vbGVhbil9aWYodC5ub2R1cGVzPT09dHJ1ZSl7cj1bLi4ubmV3IFNldChyKV19cmV0dXJuIHJ9O2JyYWNlcy5jcmVhdGU9KGUsdD17fSk9PntpZihlPT09XCJcInx8ZS5sZW5ndGg8Myl7cmV0dXJuW2VdfXJldHVybiB0LmV4cGFuZCE9PXRydWU/YnJhY2VzLmNvbXBpbGUoZSx0KTpicmFjZXMuZXhwYW5kKGUsdCl9O2UuZXhwb3J0cz1icmFjZXN9LDE3OTooZSx0LHIpPT57Y29uc3Qgbj1yKDc4Myk7Y29uc3QgdT1yKDYxNyk7Y29uc3QgY29tcGlsZT0oZSx0PXt9KT0+e2xldCB3YWxrPShlLHI9e30pPT57bGV0IHM9dS5pc0ludmFsaWRCcmFjZShyKTtsZXQgbz1lLmludmFsaWQ9PT10cnVlJiZ0LmVzY2FwZUludmFsaWQ9PT10cnVlO2xldCBpPXM9PT10cnVlfHxvPT09dHJ1ZTtsZXQgYT10LmVzY2FwZUludmFsaWQ9PT10cnVlP1wiXFxcXFwiOlwiXCI7bGV0IGw9XCJcIjtpZihlLmlzT3Blbj09PXRydWUpe3JldHVybiBhK2UudmFsdWV9aWYoZS5pc0Nsb3NlPT09dHJ1ZSl7cmV0dXJuIGErZS52YWx1ZX1pZihlLnR5cGU9PT1cIm9wZW5cIil7cmV0dXJuIGk/YStlLnZhbHVlOlwiKFwifWlmKGUudHlwZT09PVwiY2xvc2VcIil7cmV0dXJuIGk/YStlLnZhbHVlOlwiKVwifWlmKGUudHlwZT09PVwiY29tbWFcIil7cmV0dXJuIGUucHJldi50eXBlPT09XCJjb21tYVwiP1wiXCI6aT9lLnZhbHVlOlwifFwifWlmKGUudmFsdWUpe3JldHVybiBlLnZhbHVlfWlmKGUubm9kZXMmJmUucmFuZ2VzPjApe2xldCByPXUucmVkdWNlKGUubm9kZXMpO2xldCBzPW4oLi4ucix7Li4udCx3cmFwOmZhbHNlLHRvUmVnZXg6dHJ1ZX0pO2lmKHMubGVuZ3RoIT09MCl7cmV0dXJuIHIubGVuZ3RoPjEmJnMubGVuZ3RoPjE/YCgke3N9KWA6c319aWYoZS5ub2Rlcyl7Zm9yKGxldCB0IG9mIGUubm9kZXMpe2wrPXdhbGsodCxlKX19cmV0dXJuIGx9O3JldHVybiB3YWxrKGUpfTtlLmV4cG9ydHM9Y29tcGlsZX0sNDU3OmU9PntlLmV4cG9ydHM9e01BWF9MRU5HVEg6MTAyNCo2NCxDSEFSXzA6XCIwXCIsQ0hBUl85OlwiOVwiLENIQVJfVVBQRVJDQVNFX0E6XCJBXCIsQ0hBUl9MT1dFUkNBU0VfQTpcImFcIixDSEFSX1VQUEVSQ0FTRV9aOlwiWlwiLENIQVJfTE9XRVJDQVNFX1o6XCJ6XCIsQ0hBUl9MRUZUX1BBUkVOVEhFU0VTOlwiKFwiLENIQVJfUklHSFRfUEFSRU5USEVTRVM6XCIpXCIsQ0hBUl9BU1RFUklTSzpcIipcIixDSEFSX0FNUEVSU0FORDpcIiZcIixDSEFSX0FUOlwiQFwiLENIQVJfQkFDS1NMQVNIOlwiXFxcXFwiLENIQVJfQkFDS1RJQ0s6XCJgXCIsQ0hBUl9DQVJSSUFHRV9SRVRVUk46XCJcXHJcIixDSEFSX0NJUkNVTUZMRVhfQUNDRU5UOlwiXlwiLENIQVJfQ09MT046XCI6XCIsQ0hBUl9DT01NQTpcIixcIixDSEFSX0RPTExBUjpcIiRcIixDSEFSX0RPVDpcIi5cIixDSEFSX0RPVUJMRV9RVU9URTonXCInLENIQVJfRVFVQUw6XCI9XCIsQ0hBUl9FWENMQU1BVElPTl9NQVJLOlwiIVwiLENIQVJfRk9STV9GRUVEOlwiXFxmXCIsQ0hBUl9GT1JXQVJEX1NMQVNIOlwiL1wiLENIQVJfSEFTSDpcIiNcIixDSEFSX0hZUEhFTl9NSU5VUzpcIi1cIixDSEFSX0xFRlRfQU5HTEVfQlJBQ0tFVDpcIjxcIixDSEFSX0xFRlRfQ1VSTFlfQlJBQ0U6XCJ7XCIsQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUOlwiW1wiLENIQVJfTElORV9GRUVEOlwiXFxuXCIsQ0hBUl9OT19CUkVBS19TUEFDRTpcIsKgXCIsQ0hBUl9QRVJDRU5UOlwiJVwiLENIQVJfUExVUzpcIitcIixDSEFSX1FVRVNUSU9OX01BUks6XCI/XCIsQ0hBUl9SSUdIVF9BTkdMRV9CUkFDS0VUOlwiPlwiLENIQVJfUklHSFRfQ1VSTFlfQlJBQ0U6XCJ9XCIsQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVDpcIl1cIixDSEFSX1NFTUlDT0xPTjpcIjtcIixDSEFSX1NJTkdMRV9RVU9URTpcIidcIixDSEFSX1NQQUNFOlwiIFwiLENIQVJfVEFCOlwiXFx0XCIsQ0hBUl9VTkRFUlNDT1JFOlwiX1wiLENIQVJfVkVSVElDQUxfTElORTpcInxcIixDSEFSX1pFUk9fV0lEVEhfTk9CUkVBS19TUEFDRTpcIlxcdWZlZmZcIn19LDEzOihlLHQscik9Pntjb25zdCBuPXIoNzgzKTtjb25zdCB1PXIoMTM3KTtjb25zdCBzPXIoNjE3KTtjb25zdCBhcHBlbmQ9KGU9XCJcIix0PVwiXCIscj1mYWxzZSk9PntsZXQgbj1bXTtlPVtdLmNvbmNhdChlKTt0PVtdLmNvbmNhdCh0KTtpZighdC5sZW5ndGgpcmV0dXJuIGU7aWYoIWUubGVuZ3RoKXtyZXR1cm4gcj9zLmZsYXR0ZW4odCkubWFwKChlPT5geyR7ZX19YCkpOnR9Zm9yKGxldCB1IG9mIGUpe2lmKEFycmF5LmlzQXJyYXkodSkpe2ZvcihsZXQgZSBvZiB1KXtuLnB1c2goYXBwZW5kKGUsdCxyKSl9fWVsc2V7Zm9yKGxldCBlIG9mIHQpe2lmKHI9PT10cnVlJiZ0eXBlb2YgZT09PVwic3RyaW5nXCIpZT1geyR7ZX19YDtuLnB1c2goQXJyYXkuaXNBcnJheShlKT9hcHBlbmQodSxlLHIpOnUrZSl9fX1yZXR1cm4gcy5mbGF0dGVuKG4pfTtjb25zdCBleHBhbmQ9KGUsdD17fSk9PntsZXQgcj10LnJhbmdlTGltaXQ9PT12b2lkIDA/MWUzOnQucmFuZ2VMaW1pdDtsZXQgd2Fsaz0oZSxvPXt9KT0+e2UucXVldWU9W107bGV0IGk9bztsZXQgYT1vLnF1ZXVlO3doaWxlKGkudHlwZSE9PVwiYnJhY2VcIiYmaS50eXBlIT09XCJyb290XCImJmkucGFyZW50KXtpPWkucGFyZW50O2E9aS5xdWV1ZX1pZihlLmludmFsaWR8fGUuZG9sbGFyKXthLnB1c2goYXBwZW5kKGEucG9wKCksdShlLHQpKSk7cmV0dXJufWlmKGUudHlwZT09PVwiYnJhY2VcIiYmZS5pbnZhbGlkIT09dHJ1ZSYmZS5ub2Rlcy5sZW5ndGg9PT0yKXthLnB1c2goYXBwZW5kKGEucG9wKCksW1wie31cIl0pKTtyZXR1cm59aWYoZS5ub2RlcyYmZS5yYW5nZXM+MCl7bGV0IG89cy5yZWR1Y2UoZS5ub2Rlcyk7aWYocy5leGNlZWRzTGltaXQoLi4ubyx0LnN0ZXAscikpe3Rocm93IG5ldyBSYW5nZUVycm9yKFwiZXhwYW5kZWQgYXJyYXkgbGVuZ3RoIGV4Y2VlZHMgcmFuZ2UgbGltaXQuIFVzZSBvcHRpb25zLnJhbmdlTGltaXQgdG8gaW5jcmVhc2Ugb3IgZGlzYWJsZSB0aGUgbGltaXQuXCIpfWxldCBpPW4oLi4ubyx0KTtpZihpLmxlbmd0aD09PTApe2k9dShlLHQpfWEucHVzaChhcHBlbmQoYS5wb3AoKSxpKSk7ZS5ub2Rlcz1bXTtyZXR1cm59bGV0IGw9cy5lbmNsb3NlQnJhY2UoZSk7bGV0IGM9ZS5xdWV1ZTtsZXQgcD1lO3doaWxlKHAudHlwZSE9PVwiYnJhY2VcIiYmcC50eXBlIT09XCJyb290XCImJnAucGFyZW50KXtwPXAucGFyZW50O2M9cC5xdWV1ZX1mb3IobGV0IHQ9MDt0PGUubm9kZXMubGVuZ3RoO3QrKyl7bGV0IHI9ZS5ub2Rlc1t0XTtpZihyLnR5cGU9PT1cImNvbW1hXCImJmUudHlwZT09PVwiYnJhY2VcIil7aWYodD09PTEpYy5wdXNoKFwiXCIpO2MucHVzaChcIlwiKTtjb250aW51ZX1pZihyLnR5cGU9PT1cImNsb3NlXCIpe2EucHVzaChhcHBlbmQoYS5wb3AoKSxjLGwpKTtjb250aW51ZX1pZihyLnZhbHVlJiZyLnR5cGUhPT1cIm9wZW5cIil7Yy5wdXNoKGFwcGVuZChjLnBvcCgpLHIudmFsdWUpKTtjb250aW51ZX1pZihyLm5vZGVzKXt3YWxrKHIsZSl9fXJldHVybiBjfTtyZXR1cm4gcy5mbGF0dGVuKHdhbGsoZSkpfTtlLmV4cG9ydHM9ZXhwYW5kfSw3MTk6KGUsdCxyKT0+e2NvbnN0IG49cigxMzcpO2NvbnN0e01BWF9MRU5HVEg6dSxDSEFSX0JBQ0tTTEFTSDpzLENIQVJfQkFDS1RJQ0s6byxDSEFSX0NPTU1BOmksQ0hBUl9ET1Q6YSxDSEFSX0xFRlRfUEFSRU5USEVTRVM6bCxDSEFSX1JJR0hUX1BBUkVOVEhFU0VTOmMsQ0hBUl9MRUZUX0NVUkxZX0JSQUNFOnAsQ0hBUl9SSUdIVF9DVVJMWV9CUkFDRTpmLENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVDpBLENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVQ6UixDSEFSX0RPVUJMRV9RVU9URTpfLENIQVJfU0lOR0xFX1FVT1RFOmgsQ0hBUl9OT19CUkVBS19TUEFDRTpnLENIQVJfWkVST19XSURUSF9OT0JSRUFLX1NQQUNFOkV9PXIoNDU3KTtjb25zdCBwYXJzZT0oZSx0PXt9KT0+e2lmKHR5cGVvZiBlIT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgc3RyaW5nXCIpfWxldCByPXR8fHt9O2xldCBDPXR5cGVvZiByLm1heExlbmd0aD09PVwibnVtYmVyXCI/TWF0aC5taW4odSxyLm1heExlbmd0aCk6dTtpZihlLmxlbmd0aD5DKXt0aHJvdyBuZXcgU3ludGF4RXJyb3IoYElucHV0IGxlbmd0aCAoJHtlLmxlbmd0aH0pLCBleGNlZWRzIG1heCBjaGFyYWN0ZXJzICgke0N9KWApfWxldCB5PXt0eXBlOlwicm9vdFwiLGlucHV0OmUsbm9kZXM6W119O2xldCBkPVt5XTtsZXQgeD15O2xldCBiPXk7bGV0IFM9MDtsZXQgSD1lLmxlbmd0aDtsZXQgdj0wO2xldCAkPTA7bGV0IG07bGV0IFQ9e307Y29uc3QgYWR2YW5jZT0oKT0+ZVt2KytdO2NvbnN0IHB1c2g9ZT0+e2lmKGUudHlwZT09PVwidGV4dFwiJiZiLnR5cGU9PT1cImRvdFwiKXtiLnR5cGU9XCJ0ZXh0XCJ9aWYoYiYmYi50eXBlPT09XCJ0ZXh0XCImJmUudHlwZT09PVwidGV4dFwiKXtiLnZhbHVlKz1lLnZhbHVlO3JldHVybn14Lm5vZGVzLnB1c2goZSk7ZS5wYXJlbnQ9eDtlLnByZXY9YjtiPWU7cmV0dXJuIGV9O3B1c2goe3R5cGU6XCJib3NcIn0pO3doaWxlKHY8SCl7eD1kW2QubGVuZ3RoLTFdO209YWR2YW5jZSgpO2lmKG09PT1FfHxtPT09Zyl7Y29udGludWV9aWYobT09PXMpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6KHQua2VlcEVzY2FwaW5nP206XCJcIikrYWR2YW5jZSgpfSk7Y29udGludWV9aWYobT09PVIpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6XCJcXFxcXCIrbX0pO2NvbnRpbnVlfWlmKG09PT1BKXtTKys7bGV0IGU9dHJ1ZTtsZXQgdDt3aGlsZSh2PEgmJih0PWFkdmFuY2UoKSkpe20rPXQ7aWYodD09PUEpe1MrKztjb250aW51ZX1pZih0PT09cyl7bSs9YWR2YW5jZSgpO2NvbnRpbnVlfWlmKHQ9PT1SKXtTLS07aWYoUz09PTApe2JyZWFrfX19cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSk7Y29udGludWV9aWYobT09PWwpe3g9cHVzaCh7dHlwZTpcInBhcmVuXCIsbm9kZXM6W119KTtkLnB1c2goeCk7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSk7Y29udGludWV9aWYobT09PWMpe2lmKHgudHlwZSE9PVwicGFyZW5cIil7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSk7Y29udGludWV9eD1kLnBvcCgpO3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6bX0pO3g9ZFtkLmxlbmd0aC0xXTtjb250aW51ZX1pZihtPT09X3x8bT09PWh8fG09PT1vKXtsZXQgZT1tO2xldCByO2lmKHQua2VlcFF1b3RlcyE9PXRydWUpe209XCJcIn13aGlsZSh2PEgmJihyPWFkdmFuY2UoKSkpe2lmKHI9PT1zKXttKz1yK2FkdmFuY2UoKTtjb250aW51ZX1pZihyPT09ZSl7aWYodC5rZWVwUXVvdGVzPT09dHJ1ZSltKz1yO2JyZWFrfW0rPXJ9cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSk7Y29udGludWV9aWYobT09PXApeyQrKztsZXQgZT1iLnZhbHVlJiZiLnZhbHVlLnNsaWNlKC0xKT09PVwiJFwifHx4LmRvbGxhcj09PXRydWU7bGV0IHQ9e3R5cGU6XCJicmFjZVwiLG9wZW46dHJ1ZSxjbG9zZTpmYWxzZSxkb2xsYXI6ZSxkZXB0aDokLGNvbW1hczowLHJhbmdlczowLG5vZGVzOltdfTt4PXB1c2godCk7ZC5wdXNoKHgpO3B1c2goe3R5cGU6XCJvcGVuXCIsdmFsdWU6bX0pO2NvbnRpbnVlfWlmKG09PT1mKXtpZih4LnR5cGUhPT1cImJyYWNlXCIpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6bX0pO2NvbnRpbnVlfWxldCBlPVwiY2xvc2VcIjt4PWQucG9wKCk7eC5jbG9zZT10cnVlO3B1c2goe3R5cGU6ZSx2YWx1ZTptfSk7JC0tO3g9ZFtkLmxlbmd0aC0xXTtjb250aW51ZX1pZihtPT09aSYmJD4wKXtpZih4LnJhbmdlcz4wKXt4LnJhbmdlcz0wO2xldCBlPXgubm9kZXMuc2hpZnQoKTt4Lm5vZGVzPVtlLHt0eXBlOlwidGV4dFwiLHZhbHVlOm4oeCl9XX1wdXNoKHt0eXBlOlwiY29tbWFcIix2YWx1ZTptfSk7eC5jb21tYXMrKztjb250aW51ZX1pZihtPT09YSYmJD4wJiZ4LmNvbW1hcz09PTApe2xldCBlPXgubm9kZXM7aWYoJD09PTB8fGUubGVuZ3RoPT09MCl7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTptfSk7Y29udGludWV9aWYoYi50eXBlPT09XCJkb3RcIil7eC5yYW5nZT1bXTtiLnZhbHVlKz1tO2IudHlwZT1cInJhbmdlXCI7aWYoeC5ub2Rlcy5sZW5ndGghPT0zJiZ4Lm5vZGVzLmxlbmd0aCE9PTUpe3guaW52YWxpZD10cnVlO3gucmFuZ2VzPTA7Yi50eXBlPVwidGV4dFwiO2NvbnRpbnVlfXgucmFuZ2VzKys7eC5hcmdzPVtdO2NvbnRpbnVlfWlmKGIudHlwZT09PVwicmFuZ2VcIil7ZS5wb3AoKTtsZXQgdD1lW2UubGVuZ3RoLTFdO3QudmFsdWUrPWIudmFsdWUrbTtiPXQ7eC5yYW5nZXMtLTtjb250aW51ZX1wdXNoKHt0eXBlOlwiZG90XCIsdmFsdWU6bX0pO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6bX0pfWRve3g9ZC5wb3AoKTtpZih4LnR5cGUhPT1cInJvb3RcIil7eC5ub2Rlcy5mb3JFYWNoKChlPT57aWYoIWUubm9kZXMpe2lmKGUudHlwZT09PVwib3BlblwiKWUuaXNPcGVuPXRydWU7aWYoZS50eXBlPT09XCJjbG9zZVwiKWUuaXNDbG9zZT10cnVlO2lmKCFlLm5vZGVzKWUudHlwZT1cInRleHRcIjtlLmludmFsaWQ9dHJ1ZX19KSk7bGV0IGU9ZFtkLmxlbmd0aC0xXTtsZXQgdD1lLm5vZGVzLmluZGV4T2YoeCk7ZS5ub2Rlcy5zcGxpY2UodCwxLC4uLngubm9kZXMpfX13aGlsZShkLmxlbmd0aD4wKTtwdXNoKHt0eXBlOlwiZW9zXCJ9KTtyZXR1cm4geX07ZS5leHBvcnRzPXBhcnNlfSwxMzc6KGUsdCxyKT0+e2NvbnN0IG49cig2MTcpO2UuZXhwb3J0cz0oZSx0PXt9KT0+e2xldCBzdHJpbmdpZnk9KGUscj17fSk9PntsZXQgdT10LmVzY2FwZUludmFsaWQmJm4uaXNJbnZhbGlkQnJhY2Uocik7bGV0IHM9ZS5pbnZhbGlkPT09dHJ1ZSYmdC5lc2NhcGVJbnZhbGlkPT09dHJ1ZTtsZXQgbz1cIlwiO2lmKGUudmFsdWUpe2lmKCh1fHxzKSYmbi5pc09wZW5PckNsb3NlKGUpKXtyZXR1cm5cIlxcXFxcIitlLnZhbHVlfXJldHVybiBlLnZhbHVlfWlmKGUudmFsdWUpe3JldHVybiBlLnZhbHVlfWlmKGUubm9kZXMpe2ZvcihsZXQgdCBvZiBlLm5vZGVzKXtvKz1zdHJpbmdpZnkodCl9fXJldHVybiBvfTtyZXR1cm4gc3RyaW5naWZ5KGUpfX0sNjE3OihlLHQpPT57dC5pc0ludGVnZXI9ZT0+e2lmKHR5cGVvZiBlPT09XCJudW1iZXJcIil7cmV0dXJuIE51bWJlci5pc0ludGVnZXIoZSl9aWYodHlwZW9mIGU9PT1cInN0cmluZ1wiJiZlLnRyaW0oKSE9PVwiXCIpe3JldHVybiBOdW1iZXIuaXNJbnRlZ2VyKE51bWJlcihlKSl9cmV0dXJuIGZhbHNlfTt0LmZpbmQ9KGUsdCk9PmUubm9kZXMuZmluZCgoZT0+ZS50eXBlPT09dCkpO3QuZXhjZWVkc0xpbWl0PShlLHIsbj0xLHUpPT57aWYodT09PWZhbHNlKXJldHVybiBmYWxzZTtpZighdC5pc0ludGVnZXIoZSl8fCF0LmlzSW50ZWdlcihyKSlyZXR1cm4gZmFsc2U7cmV0dXJuKE51bWJlcihyKS1OdW1iZXIoZSkpL051bWJlcihuKT49dX07dC5lc2NhcGVOb2RlPShlLHQ9MCxyKT0+e2xldCBuPWUubm9kZXNbdF07aWYoIW4pcmV0dXJuO2lmKHImJm4udHlwZT09PXJ8fG4udHlwZT09PVwib3BlblwifHxuLnR5cGU9PT1cImNsb3NlXCIpe2lmKG4uZXNjYXBlZCE9PXRydWUpe24udmFsdWU9XCJcXFxcXCIrbi52YWx1ZTtuLmVzY2FwZWQ9dHJ1ZX19fTt0LmVuY2xvc2VCcmFjZT1lPT57aWYoZS50eXBlIT09XCJicmFjZVwiKXJldHVybiBmYWxzZTtpZihlLmNvbW1hcz4+MCtlLnJhbmdlcz4+MD09PTApe2UuaW52YWxpZD10cnVlO3JldHVybiB0cnVlfXJldHVybiBmYWxzZX07dC5pc0ludmFsaWRCcmFjZT1lPT57aWYoZS50eXBlIT09XCJicmFjZVwiKXJldHVybiBmYWxzZTtpZihlLmludmFsaWQ9PT10cnVlfHxlLmRvbGxhcilyZXR1cm4gdHJ1ZTtpZihlLmNvbW1hcz4+MCtlLnJhbmdlcz4+MD09PTApe2UuaW52YWxpZD10cnVlO3JldHVybiB0cnVlfWlmKGUub3BlbiE9PXRydWV8fGUuY2xvc2UhPT10cnVlKXtlLmludmFsaWQ9dHJ1ZTtyZXR1cm4gdHJ1ZX1yZXR1cm4gZmFsc2V9O3QuaXNPcGVuT3JDbG9zZT1lPT57aWYoZS50eXBlPT09XCJvcGVuXCJ8fGUudHlwZT09PVwiY2xvc2VcIil7cmV0dXJuIHRydWV9cmV0dXJuIGUub3Blbj09PXRydWV8fGUuY2xvc2U9PT10cnVlfTt0LnJlZHVjZT1lPT5lLnJlZHVjZSgoKGUsdCk9PntpZih0LnR5cGU9PT1cInRleHRcIillLnB1c2godC52YWx1ZSk7aWYodC50eXBlPT09XCJyYW5nZVwiKXQudHlwZT1cInRleHRcIjtyZXR1cm4gZX0pLFtdKTt0LmZsYXR0ZW49KC4uLmUpPT57Y29uc3QgdD1bXTtjb25zdCBmbGF0PWU9Pntmb3IobGV0IHI9MDtyPGUubGVuZ3RoO3IrKyl7bGV0IG49ZVtyXTtBcnJheS5pc0FycmF5KG4pP2ZsYXQobix0KTpuIT09dm9pZCAwJiZ0LnB1c2gobil9cmV0dXJuIHR9O2ZsYXQoZSk7cmV0dXJuIHR9fSw3ODM6KGUsdCxyKT0+e1xuLyohXG4gKiBmaWxsLXJhbmdlIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9maWxsLXJhbmdlPlxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBKb24gU2NobGlua2VydC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuY29uc3Qgbj1yKDgzNyk7Y29uc3QgdT1yKDQ5Mik7Y29uc3QgaXNPYmplY3Q9ZT0+ZSE9PW51bGwmJnR5cGVvZiBlPT09XCJvYmplY3RcIiYmIUFycmF5LmlzQXJyYXkoZSk7Y29uc3QgdHJhbnNmb3JtPWU9PnQ9PmU9PT10cnVlP051bWJlcih0KTpTdHJpbmcodCk7Y29uc3QgaXNWYWxpZFZhbHVlPWU9PnR5cGVvZiBlPT09XCJudW1iZXJcInx8dHlwZW9mIGU9PT1cInN0cmluZ1wiJiZlIT09XCJcIjtjb25zdCBpc051bWJlcj1lPT5OdW1iZXIuaXNJbnRlZ2VyKCtlKTtjb25zdCB6ZXJvcz1lPT57bGV0IHQ9YCR7ZX1gO2xldCByPS0xO2lmKHRbMF09PT1cIi1cIil0PXQuc2xpY2UoMSk7aWYodD09PVwiMFwiKXJldHVybiBmYWxzZTt3aGlsZSh0Wysrcl09PT1cIjBcIik7cmV0dXJuIHI+MH07Y29uc3Qgc3RyaW5naWZ5PShlLHQscik9PntpZih0eXBlb2YgZT09PVwic3RyaW5nXCJ8fHR5cGVvZiB0PT09XCJzdHJpbmdcIil7cmV0dXJuIHRydWV9cmV0dXJuIHIuc3RyaW5naWZ5PT09dHJ1ZX07Y29uc3QgcGFkPShlLHQscik9PntpZih0PjApe2xldCByPWVbMF09PT1cIi1cIj9cIi1cIjpcIlwiO2lmKHIpZT1lLnNsaWNlKDEpO2U9citlLnBhZFN0YXJ0KHI/dC0xOnQsXCIwXCIpfWlmKHI9PT1mYWxzZSl7cmV0dXJuIFN0cmluZyhlKX1yZXR1cm4gZX07Y29uc3QgdG9NYXhMZW49KGUsdCk9PntsZXQgcj1lWzBdPT09XCItXCI/XCItXCI6XCJcIjtpZihyKXtlPWUuc2xpY2UoMSk7dC0tfXdoaWxlKGUubGVuZ3RoPHQpZT1cIjBcIitlO3JldHVybiByP1wiLVwiK2U6ZX07Y29uc3QgdG9TZXF1ZW5jZT0oZSx0KT0+e2UubmVnYXRpdmVzLnNvcnQoKChlLHQpPT5lPHQ/LTE6ZT50PzE6MCkpO2UucG9zaXRpdmVzLnNvcnQoKChlLHQpPT5lPHQ/LTE6ZT50PzE6MCkpO2xldCByPXQuY2FwdHVyZT9cIlwiOlwiPzpcIjtsZXQgbj1cIlwiO2xldCB1PVwiXCI7bGV0IHM7aWYoZS5wb3NpdGl2ZXMubGVuZ3RoKXtuPWUucG9zaXRpdmVzLmpvaW4oXCJ8XCIpfWlmKGUubmVnYXRpdmVzLmxlbmd0aCl7dT1gLSgke3J9JHtlLm5lZ2F0aXZlcy5qb2luKFwifFwiKX0pYH1pZihuJiZ1KXtzPWAke259fCR7dX1gfWVsc2V7cz1ufHx1fWlmKHQud3JhcCl7cmV0dXJuYCgke3J9JHtzfSlgfXJldHVybiBzfTtjb25zdCB0b1JhbmdlPShlLHQscixuKT0+e2lmKHIpe3JldHVybiB1KGUsdCx7d3JhcDpmYWxzZSwuLi5ufSl9bGV0IHM9U3RyaW5nLmZyb21DaGFyQ29kZShlKTtpZihlPT09dClyZXR1cm4gcztsZXQgbz1TdHJpbmcuZnJvbUNoYXJDb2RlKHQpO3JldHVybmBbJHtzfS0ke299XWB9O2NvbnN0IHRvUmVnZXg9KGUsdCxyKT0+e2lmKEFycmF5LmlzQXJyYXkoZSkpe2xldCB0PXIud3JhcD09PXRydWU7bGV0IG49ci5jYXB0dXJlP1wiXCI6XCI/OlwiO3JldHVybiB0P2AoJHtufSR7ZS5qb2luKFwifFwiKX0pYDplLmpvaW4oXCJ8XCIpfXJldHVybiB1KGUsdCxyKX07Y29uc3QgcmFuZ2VFcnJvcj0oLi4uZSk9Pm5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCByYW5nZSBhcmd1bWVudHM6IFwiK24uaW5zcGVjdCguLi5lKSk7Y29uc3QgaW52YWxpZFJhbmdlPShlLHQscik9PntpZihyLnN0cmljdFJhbmdlcz09PXRydWUpdGhyb3cgcmFuZ2VFcnJvcihbZSx0XSk7cmV0dXJuW119O2NvbnN0IGludmFsaWRTdGVwPShlLHQpPT57aWYodC5zdHJpY3RSYW5nZXM9PT10cnVlKXt0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBzdGVwIFwiJHtlfVwiIHRvIGJlIGEgbnVtYmVyYCl9cmV0dXJuW119O2NvbnN0IGZpbGxOdW1iZXJzPShlLHQscj0xLG49e30pPT57bGV0IHU9TnVtYmVyKGUpO2xldCBzPU51bWJlcih0KTtpZighTnVtYmVyLmlzSW50ZWdlcih1KXx8IU51bWJlci5pc0ludGVnZXIocykpe2lmKG4uc3RyaWN0UmFuZ2VzPT09dHJ1ZSl0aHJvdyByYW5nZUVycm9yKFtlLHRdKTtyZXR1cm5bXX1pZih1PT09MCl1PTA7aWYocz09PTApcz0wO2xldCBvPXU+cztsZXQgaT1TdHJpbmcoZSk7bGV0IGE9U3RyaW5nKHQpO2xldCBsPVN0cmluZyhyKTtyPU1hdGgubWF4KE1hdGguYWJzKHIpLDEpO2xldCBjPXplcm9zKGkpfHx6ZXJvcyhhKXx8emVyb3MobCk7bGV0IHA9Yz9NYXRoLm1heChpLmxlbmd0aCxhLmxlbmd0aCxsLmxlbmd0aCk6MDtsZXQgZj1jPT09ZmFsc2UmJnN0cmluZ2lmeShlLHQsbik9PT1mYWxzZTtsZXQgQT1uLnRyYW5zZm9ybXx8dHJhbnNmb3JtKGYpO2lmKG4udG9SZWdleCYmcj09PTEpe3JldHVybiB0b1JhbmdlKHRvTWF4TGVuKGUscCksdG9NYXhMZW4odCxwKSx0cnVlLG4pfWxldCBSPXtuZWdhdGl2ZXM6W10scG9zaXRpdmVzOltdfTtsZXQgcHVzaD1lPT5SW2U8MD9cIm5lZ2F0aXZlc1wiOlwicG9zaXRpdmVzXCJdLnB1c2goTWF0aC5hYnMoZSkpO2xldCBfPVtdO2xldCBoPTA7d2hpbGUobz91Pj1zOnU8PXMpe2lmKG4udG9SZWdleD09PXRydWUmJnI+MSl7cHVzaCh1KX1lbHNle18ucHVzaChwYWQoQSh1LGgpLHAsZikpfXU9bz91LXI6dStyO2grK31pZihuLnRvUmVnZXg9PT10cnVlKXtyZXR1cm4gcj4xP3RvU2VxdWVuY2UoUixuKTp0b1JlZ2V4KF8sbnVsbCx7d3JhcDpmYWxzZSwuLi5ufSl9cmV0dXJuIF99O2NvbnN0IGZpbGxMZXR0ZXJzPShlLHQscj0xLG49e30pPT57aWYoIWlzTnVtYmVyKGUpJiZlLmxlbmd0aD4xfHwhaXNOdW1iZXIodCkmJnQubGVuZ3RoPjEpe3JldHVybiBpbnZhbGlkUmFuZ2UoZSx0LG4pfWxldCB1PW4udHJhbnNmb3JtfHwoZT0+U3RyaW5nLmZyb21DaGFyQ29kZShlKSk7bGV0IHM9YCR7ZX1gLmNoYXJDb2RlQXQoMCk7bGV0IG89YCR7dH1gLmNoYXJDb2RlQXQoMCk7bGV0IGk9cz5vO2xldCBhPU1hdGgubWluKHMsbyk7bGV0IGw9TWF0aC5tYXgocyxvKTtpZihuLnRvUmVnZXgmJnI9PT0xKXtyZXR1cm4gdG9SYW5nZShhLGwsZmFsc2Usbil9bGV0IGM9W107bGV0IHA9MDt3aGlsZShpP3M+PW86czw9byl7Yy5wdXNoKHUocyxwKSk7cz1pP3MtcjpzK3I7cCsrfWlmKG4udG9SZWdleD09PXRydWUpe3JldHVybiB0b1JlZ2V4KGMsbnVsbCx7d3JhcDpmYWxzZSxvcHRpb25zOm59KX1yZXR1cm4gY307Y29uc3QgZmlsbD0oZSx0LHIsbj17fSk9PntpZih0PT1udWxsJiZpc1ZhbGlkVmFsdWUoZSkpe3JldHVybltlXX1pZighaXNWYWxpZFZhbHVlKGUpfHwhaXNWYWxpZFZhbHVlKHQpKXtyZXR1cm4gaW52YWxpZFJhbmdlKGUsdCxuKX1pZih0eXBlb2Ygcj09PVwiZnVuY3Rpb25cIil7cmV0dXJuIGZpbGwoZSx0LDEse3RyYW5zZm9ybTpyfSl9aWYoaXNPYmplY3Qocikpe3JldHVybiBmaWxsKGUsdCwwLHIpfWxldCB1PXsuLi5ufTtpZih1LmNhcHR1cmU9PT10cnVlKXUud3JhcD10cnVlO3I9cnx8dS5zdGVwfHwxO2lmKCFpc051bWJlcihyKSl7aWYociE9bnVsbCYmIWlzT2JqZWN0KHIpKXJldHVybiBpbnZhbGlkU3RlcChyLHUpO3JldHVybiBmaWxsKGUsdCwxLHIpfWlmKGlzTnVtYmVyKGUpJiZpc051bWJlcih0KSl7cmV0dXJuIGZpbGxOdW1iZXJzKGUsdCxyLHUpfXJldHVybiBmaWxsTGV0dGVycyhlLHQsTWF0aC5tYXgoTWF0aC5hYnMociksMSksdSl9O2UuZXhwb3J0cz1maWxsfSwzNTc6ZT0+e1xuLyohXG4gKiBpcy1udW1iZXIgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2lzLW51bWJlcj5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbmUuZXhwb3J0cz1mdW5jdGlvbihlKXtpZih0eXBlb2YgZT09PVwibnVtYmVyXCIpe3JldHVybiBlLWU9PT0wfWlmKHR5cGVvZiBlPT09XCJzdHJpbmdcIiYmZS50cmltKCkhPT1cIlwiKXtyZXR1cm4gTnVtYmVyLmlzRmluaXRlP051bWJlci5pc0Zpbml0ZSgrZSk6aXNGaW5pdGUoK2UpfXJldHVybiBmYWxzZX19LDk3MTooZSx0LHIpPT57Y29uc3Qgbj1yKDgzNyk7Y29uc3QgdT1yKDMzMyk7Y29uc3Qgcz1yKDI1MSk7Y29uc3Qgbz1yKDUxMyk7Y29uc3QgaXNFbXB0eVN0cmluZz1lPT5lPT09XCJcInx8ZT09PVwiLi9cIjtjb25zdCBtaWNyb21hdGNoPShlLHQscik9Pnt0PVtdLmNvbmNhdCh0KTtlPVtdLmNvbmNhdChlKTtsZXQgbj1uZXcgU2V0O2xldCB1PW5ldyBTZXQ7bGV0IG89bmV3IFNldDtsZXQgaT0wO2xldCBvblJlc3VsdD1lPT57by5hZGQoZS5vdXRwdXQpO2lmKHImJnIub25SZXN1bHQpe3Iub25SZXN1bHQoZSl9fTtmb3IobGV0IG89MDtvPHQubGVuZ3RoO28rKyl7bGV0IGE9cyhTdHJpbmcodFtvXSksey4uLnIsb25SZXN1bHQ6b25SZXN1bHR9LHRydWUpO2xldCBsPWEuc3RhdGUubmVnYXRlZHx8YS5zdGF0ZS5uZWdhdGVkRXh0Z2xvYjtpZihsKWkrKztmb3IobGV0IHQgb2YgZSl7bGV0IGU9YSh0LHRydWUpO2xldCByPWw/IWUuaXNNYXRjaDplLmlzTWF0Y2g7aWYoIXIpY29udGludWU7aWYobCl7bi5hZGQoZS5vdXRwdXQpfWVsc2V7bi5kZWxldGUoZS5vdXRwdXQpO3UuYWRkKGUub3V0cHV0KX19fWxldCBhPWk9PT10Lmxlbmd0aD9bLi4ub106Wy4uLnVdO2xldCBsPWEuZmlsdGVyKChlPT4hbi5oYXMoZSkpKTtpZihyJiZsLmxlbmd0aD09PTApe2lmKHIuZmFpbGdsb2I9PT10cnVlKXt0aHJvdyBuZXcgRXJyb3IoYE5vIG1hdGNoZXMgZm91bmQgZm9yIFwiJHt0LmpvaW4oXCIsIFwiKX1cImApfWlmKHIubm9udWxsPT09dHJ1ZXx8ci5udWxsZ2xvYj09PXRydWUpe3JldHVybiByLnVuZXNjYXBlP3QubWFwKChlPT5lLnJlcGxhY2UoL1xcXFwvZyxcIlwiKSkpOnR9fXJldHVybiBsfTttaWNyb21hdGNoLm1hdGNoPW1pY3JvbWF0Y2g7bWljcm9tYXRjaC5tYXRjaGVyPShlLHQpPT5zKGUsdCk7bWljcm9tYXRjaC5pc01hdGNoPShlLHQscik9PnModCxyKShlKTttaWNyb21hdGNoLmFueT1taWNyb21hdGNoLmlzTWF0Y2g7bWljcm9tYXRjaC5ub3Q9KGUsdCxyPXt9KT0+e3Q9W10uY29uY2F0KHQpLm1hcChTdHJpbmcpO2xldCBuPW5ldyBTZXQ7bGV0IHU9W107bGV0IG9uUmVzdWx0PWU9PntpZihyLm9uUmVzdWx0KXIub25SZXN1bHQoZSk7dS5wdXNoKGUub3V0cHV0KX07bGV0IHM9bWljcm9tYXRjaChlLHQsey4uLnIsb25SZXN1bHQ6b25SZXN1bHR9KTtmb3IobGV0IGUgb2YgdSl7aWYoIXMuaW5jbHVkZXMoZSkpe24uYWRkKGUpfX1yZXR1cm5bLi4ubl19O21pY3JvbWF0Y2guY29udGFpbnM9KGUsdCxyKT0+e2lmKHR5cGVvZiBlIT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgYSBzdHJpbmc6IFwiJHtuLmluc3BlY3QoZSl9XCJgKX1pZihBcnJheS5pc0FycmF5KHQpKXtyZXR1cm4gdC5zb21lKCh0PT5taWNyb21hdGNoLmNvbnRhaW5zKGUsdCxyKSkpfWlmKHR5cGVvZiB0PT09XCJzdHJpbmdcIil7aWYoaXNFbXB0eVN0cmluZyhlKXx8aXNFbXB0eVN0cmluZyh0KSl7cmV0dXJuIGZhbHNlfWlmKGUuaW5jbHVkZXModCl8fGUuc3RhcnRzV2l0aChcIi4vXCIpJiZlLnNsaWNlKDIpLmluY2x1ZGVzKHQpKXtyZXR1cm4gdHJ1ZX19cmV0dXJuIG1pY3JvbWF0Y2guaXNNYXRjaChlLHQsey4uLnIsY29udGFpbnM6dHJ1ZX0pfTttaWNyb21hdGNoLm1hdGNoS2V5cz0oZSx0LHIpPT57aWYoIW8uaXNPYmplY3QoZSkpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCB0aGUgZmlyc3QgYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0XCIpfWxldCBuPW1pY3JvbWF0Y2goT2JqZWN0LmtleXMoZSksdCxyKTtsZXQgdT17fTtmb3IobGV0IHQgb2Ygbil1W3RdPWVbdF07cmV0dXJuIHV9O21pY3JvbWF0Y2guc29tZT0oZSx0LHIpPT57bGV0IG49W10uY29uY2F0KGUpO2ZvcihsZXQgZSBvZltdLmNvbmNhdCh0KSl7bGV0IHQ9cyhTdHJpbmcoZSkscik7aWYobi5zb21lKChlPT50KGUpKSkpe3JldHVybiB0cnVlfX1yZXR1cm4gZmFsc2V9O21pY3JvbWF0Y2guZXZlcnk9KGUsdCxyKT0+e2xldCBuPVtdLmNvbmNhdChlKTtmb3IobGV0IGUgb2ZbXS5jb25jYXQodCkpe2xldCB0PXMoU3RyaW5nKGUpLHIpO2lmKCFuLmV2ZXJ5KChlPT50KGUpKSkpe3JldHVybiBmYWxzZX19cmV0dXJuIHRydWV9O21pY3JvbWF0Y2guYWxsPShlLHQscik9PntpZih0eXBlb2YgZSE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIGEgc3RyaW5nOiBcIiR7bi5pbnNwZWN0KGUpfVwiYCl9cmV0dXJuW10uY29uY2F0KHQpLmV2ZXJ5KCh0PT5zKHQscikoZSkpKX07bWljcm9tYXRjaC5jYXB0dXJlPShlLHQscik9PntsZXQgbj1vLmlzV2luZG93cyhyKTtsZXQgdT1zLm1ha2VSZShTdHJpbmcoZSksey4uLnIsY2FwdHVyZTp0cnVlfSk7bGV0IGk9dS5leGVjKG4/by50b1Bvc2l4U2xhc2hlcyh0KTp0KTtpZihpKXtyZXR1cm4gaS5zbGljZSgxKS5tYXAoKGU9PmU9PT12b2lkIDA/XCJcIjplKSl9fTttaWNyb21hdGNoLm1ha2VSZT0oLi4uZSk9PnMubWFrZVJlKC4uLmUpO21pY3JvbWF0Y2guc2Nhbj0oLi4uZSk9PnMuc2NhbiguLi5lKTttaWNyb21hdGNoLnBhcnNlPShlLHQpPT57bGV0IHI9W107Zm9yKGxldCBuIG9mW10uY29uY2F0KGV8fFtdKSl7Zm9yKGxldCBlIG9mIHUoU3RyaW5nKG4pLHQpKXtyLnB1c2gocy5wYXJzZShlLHQpKX19cmV0dXJuIHJ9O21pY3JvbWF0Y2guYnJhY2VzPShlLHQpPT57aWYodHlwZW9mIGUhPT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhIHN0cmluZ1wiKTtpZih0JiZ0Lm5vYnJhY2U9PT10cnVlfHwhL1xcey4qXFx9Ly50ZXN0KGUpKXtyZXR1cm5bZV19cmV0dXJuIHUoZSx0KX07bWljcm9tYXRjaC5icmFjZUV4cGFuZD0oZSx0KT0+e2lmKHR5cGVvZiBlIT09XCJzdHJpbmdcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgYSBzdHJpbmdcIik7cmV0dXJuIG1pY3JvbWF0Y2guYnJhY2VzKGUsey4uLnQsZXhwYW5kOnRydWV9KX07ZS5leHBvcnRzPW1pY3JvbWF0Y2h9LDI1MTooZSx0LHIpPT57ZS5leHBvcnRzPXIoNjgzKX0sMzU2OihlLHQscik9Pntjb25zdCBuPXIoMTcpO2NvbnN0IHU9XCJcXFxcXFxcXC9cIjtjb25zdCBzPWBbXiR7dX1dYDtjb25zdCBvPVwiXFxcXC5cIjtjb25zdCBpPVwiXFxcXCtcIjtjb25zdCBhPVwiXFxcXD9cIjtjb25zdCBsPVwiXFxcXC9cIjtjb25zdCBjPVwiKD89LilcIjtjb25zdCBwPVwiW14vXVwiO2NvbnN0IGY9YCg/OiR7bH18JClgO2NvbnN0IEE9YCg/Ol58JHtsfSlgO2NvbnN0IFI9YCR7b317MSwyfSR7Zn1gO2NvbnN0IF89YCg/ISR7b30pYDtjb25zdCBoPWAoPyEke0F9JHtSfSlgO2NvbnN0IGc9YCg/ISR7b317MCwxfSR7Zn0pYDtjb25zdCBFPWAoPyEke1J9KWA7Y29uc3QgQz1gW14uJHtsfV1gO2NvbnN0IHk9YCR7cH0qP2A7Y29uc3QgZD17RE9UX0xJVEVSQUw6byxQTFVTX0xJVEVSQUw6aSxRTUFSS19MSVRFUkFMOmEsU0xBU0hfTElURVJBTDpsLE9ORV9DSEFSOmMsUU1BUks6cCxFTkRfQU5DSE9SOmYsRE9UU19TTEFTSDpSLE5PX0RPVDpfLE5PX0RPVFM6aCxOT19ET1RfU0xBU0g6ZyxOT19ET1RTX1NMQVNIOkUsUU1BUktfTk9fRE9UOkMsU1RBUjp5LFNUQVJUX0FOQ0hPUjpBfTtjb25zdCB4PXsuLi5kLFNMQVNIX0xJVEVSQUw6YFske3V9XWAsUU1BUks6cyxTVEFSOmAke3N9Kj9gLERPVFNfU0xBU0g6YCR7b317MSwyfSg/Olske3V9XXwkKWAsTk9fRE9UOmAoPyEke299KWAsTk9fRE9UUzpgKD8hKD86XnxbJHt1fV0pJHtvfXsxLDJ9KD86WyR7dX1dfCQpKWAsTk9fRE9UX1NMQVNIOmAoPyEke299ezAsMX0oPzpbJHt1fV18JCkpYCxOT19ET1RTX1NMQVNIOmAoPyEke299ezEsMn0oPzpbJHt1fV18JCkpYCxRTUFSS19OT19ET1Q6YFteLiR7dX1dYCxTVEFSVF9BTkNIT1I6YCg/Ol58WyR7dX1dKWAsRU5EX0FOQ0hPUjpgKD86WyR7dX1dfCQpYH07Y29uc3QgYj17YWxudW06XCJhLXpBLVowLTlcIixhbHBoYTpcImEtekEtWlwiLGFzY2lpOlwiXFxcXHgwMC1cXFxceDdGXCIsYmxhbms6XCIgXFxcXHRcIixjbnRybDpcIlxcXFx4MDAtXFxcXHgxRlxcXFx4N0ZcIixkaWdpdDpcIjAtOVwiLGdyYXBoOlwiXFxcXHgyMS1cXFxceDdFXCIsbG93ZXI6XCJhLXpcIixwcmludDpcIlxcXFx4MjAtXFxcXHg3RSBcIixwdW5jdDpcIlxcXFwtIVxcXCIjJCUmJygpXFxcXCorLC4vOjs8PT4/QFtcXFxcXV5fYHt8fX5cIixzcGFjZTpcIiBcXFxcdFxcXFxyXFxcXG5cXFxcdlxcXFxmXCIsdXBwZXI6XCJBLVpcIix3b3JkOlwiQS1aYS16MC05X1wiLHhkaWdpdDpcIkEtRmEtZjAtOVwifTtlLmV4cG9ydHM9e01BWF9MRU5HVEg6MTAyNCo2NCxQT1NJWF9SRUdFWF9TT1VSQ0U6YixSRUdFWF9CQUNLU0xBU0g6L1xcXFwoPyFbKis/XiR7fSh8KVtcXF1dKS9nLFJFR0VYX05PTl9TUEVDSUFMX0NIQVJTOi9eW15AIVtcXF0uLCQqKz9ee30oKXxcXFxcL10rLyxSRUdFWF9TUEVDSUFMX0NIQVJTOi9bLSorPy5eJHt9KHwpW1xcXV0vLFJFR0VYX1NQRUNJQUxfQ0hBUlNfQkFDS1JFRjovKFxcXFw/KSgoXFxXKShcXDMqKSkvZyxSRUdFWF9TUEVDSUFMX0NIQVJTX0dMT0JBTDovKFstKis/Ll4ke30ofClbXFxdXSkvZyxSRUdFWF9SRU1PVkVfQkFDS1NMQVNIOi8oPzpcXFsuKj9bXlxcXFxdXFxdfFxcXFwoPz0uKSkvZyxSRVBMQUNFTUVOVFM6e1wiKioqXCI6XCIqXCIsXCIqKi8qKlwiOlwiKipcIixcIioqLyoqLyoqXCI6XCIqKlwifSxDSEFSXzA6NDgsQ0hBUl85OjU3LENIQVJfVVBQRVJDQVNFX0E6NjUsQ0hBUl9MT1dFUkNBU0VfQTo5NyxDSEFSX1VQUEVSQ0FTRV9aOjkwLENIQVJfTE9XRVJDQVNFX1o6MTIyLENIQVJfTEVGVF9QQVJFTlRIRVNFUzo0MCxDSEFSX1JJR0hUX1BBUkVOVEhFU0VTOjQxLENIQVJfQVNURVJJU0s6NDIsQ0hBUl9BTVBFUlNBTkQ6MzgsQ0hBUl9BVDo2NCxDSEFSX0JBQ0tXQVJEX1NMQVNIOjkyLENIQVJfQ0FSUklBR0VfUkVUVVJOOjEzLENIQVJfQ0lSQ1VNRkxFWF9BQ0NFTlQ6OTQsQ0hBUl9DT0xPTjo1OCxDSEFSX0NPTU1BOjQ0LENIQVJfRE9UOjQ2LENIQVJfRE9VQkxFX1FVT1RFOjM0LENIQVJfRVFVQUw6NjEsQ0hBUl9FWENMQU1BVElPTl9NQVJLOjMzLENIQVJfRk9STV9GRUVEOjEyLENIQVJfRk9SV0FSRF9TTEFTSDo0NyxDSEFSX0dSQVZFX0FDQ0VOVDo5NixDSEFSX0hBU0g6MzUsQ0hBUl9IWVBIRU5fTUlOVVM6NDUsQ0hBUl9MRUZUX0FOR0xFX0JSQUNLRVQ6NjAsQ0hBUl9MRUZUX0NVUkxZX0JSQUNFOjEyMyxDSEFSX0xFRlRfU1FVQVJFX0JSQUNLRVQ6OTEsQ0hBUl9MSU5FX0ZFRUQ6MTAsQ0hBUl9OT19CUkVBS19TUEFDRToxNjAsQ0hBUl9QRVJDRU5UOjM3LENIQVJfUExVUzo0MyxDSEFSX1FVRVNUSU9OX01BUks6NjMsQ0hBUl9SSUdIVF9BTkdMRV9CUkFDS0VUOjYyLENIQVJfUklHSFRfQ1VSTFlfQlJBQ0U6MTI1LENIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVQ6OTMsQ0hBUl9TRU1JQ09MT046NTksQ0hBUl9TSU5HTEVfUVVPVEU6MzksQ0hBUl9TUEFDRTozMixDSEFSX1RBQjo5LENIQVJfVU5ERVJTQ09SRTo5NSxDSEFSX1ZFUlRJQ0FMX0xJTkU6MTI0LENIQVJfWkVST19XSURUSF9OT0JSRUFLX1NQQUNFOjY1Mjc5LFNFUDpuLnNlcCxleHRnbG9iQ2hhcnMoZSl7cmV0dXJue1wiIVwiOnt0eXBlOlwibmVnYXRlXCIsb3BlbjpcIig/Oig/ISg/OlwiLGNsb3NlOmApKSR7ZS5TVEFSfSlgfSxcIj9cIjp7dHlwZTpcInFtYXJrXCIsb3BlbjpcIig/OlwiLGNsb3NlOlwiKT9cIn0sXCIrXCI6e3R5cGU6XCJwbHVzXCIsb3BlbjpcIig/OlwiLGNsb3NlOlwiKStcIn0sXCIqXCI6e3R5cGU6XCJzdGFyXCIsb3BlbjpcIig/OlwiLGNsb3NlOlwiKSpcIn0sXCJAXCI6e3R5cGU6XCJhdFwiLG9wZW46XCIoPzpcIixjbG9zZTpcIilcIn19fSxnbG9iQ2hhcnMoZSl7cmV0dXJuIGU9PT10cnVlP3g6ZH19fSw3NTQ6KGUsdCxyKT0+e2NvbnN0IG49cigzNTYpO2NvbnN0IHU9cig1MTMpO2NvbnN0e01BWF9MRU5HVEg6cyxQT1NJWF9SRUdFWF9TT1VSQ0U6byxSRUdFWF9OT05fU1BFQ0lBTF9DSEFSUzppLFJFR0VYX1NQRUNJQUxfQ0hBUlNfQkFDS1JFRjphLFJFUExBQ0VNRU5UUzpsfT1uO2NvbnN0IGV4cGFuZFJhbmdlPShlLHQpPT57aWYodHlwZW9mIHQuZXhwYW5kUmFuZ2U9PT1cImZ1bmN0aW9uXCIpe3JldHVybiB0LmV4cGFuZFJhbmdlKC4uLmUsdCl9ZS5zb3J0KCk7Y29uc3Qgcj1gWyR7ZS5qb2luKFwiLVwiKX1dYDt0cnl7bmV3IFJlZ0V4cChyKX1jYXRjaCh0KXtyZXR1cm4gZS5tYXAoKGU9PnUuZXNjYXBlUmVnZXgoZSkpKS5qb2luKFwiLi5cIil9cmV0dXJuIHJ9O2NvbnN0IHN5bnRheEVycm9yPShlLHQpPT5gTWlzc2luZyAke2V9OiBcIiR7dH1cIiAtIHVzZSBcIlxcXFxcXFxcJHt0fVwiIHRvIG1hdGNoIGxpdGVyYWwgY2hhcmFjdGVyc2A7Y29uc3QgcGFyc2U9KGUsdCk9PntpZih0eXBlb2YgZSE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhIHN0cmluZ1wiKX1lPWxbZV18fGU7Y29uc3Qgcj17Li4udH07Y29uc3QgYz10eXBlb2Ygci5tYXhMZW5ndGg9PT1cIm51bWJlclwiP01hdGgubWluKHMsci5tYXhMZW5ndGgpOnM7bGV0IHA9ZS5sZW5ndGg7aWYocD5jKXt0aHJvdyBuZXcgU3ludGF4RXJyb3IoYElucHV0IGxlbmd0aDogJHtwfSwgZXhjZWVkcyBtYXhpbXVtIGFsbG93ZWQgbGVuZ3RoOiAke2N9YCl9Y29uc3QgZj17dHlwZTpcImJvc1wiLHZhbHVlOlwiXCIsb3V0cHV0OnIucHJlcGVuZHx8XCJcIn07Y29uc3QgQT1bZl07Y29uc3QgUj1yLmNhcHR1cmU/XCJcIjpcIj86XCI7Y29uc3QgXz11LmlzV2luZG93cyh0KTtjb25zdCBoPW4uZ2xvYkNoYXJzKF8pO2NvbnN0IGc9bi5leHRnbG9iQ2hhcnMoaCk7Y29uc3R7RE9UX0xJVEVSQUw6RSxQTFVTX0xJVEVSQUw6QyxTTEFTSF9MSVRFUkFMOnksT05FX0NIQVI6ZCxET1RTX1NMQVNIOngsTk9fRE9UOmIsTk9fRE9UX1NMQVNIOlMsTk9fRE9UU19TTEFTSDpILFFNQVJLOnYsUU1BUktfTk9fRE9UOiQsU1RBUjptLFNUQVJUX0FOQ0hPUjpUfT1oO2NvbnN0IGdsb2JzdGFyPWU9PmAoJHtSfSg/Oig/ISR7VH0ke2UuZG90P3g6RX0pLikqPylgO2NvbnN0IEw9ci5kb3Q/XCJcIjpiO2NvbnN0IE89ci5kb3Q/djokO2xldCB3PXIuYmFzaD09PXRydWU/Z2xvYnN0YXIocik6bTtpZihyLmNhcHR1cmUpe3c9YCgke3d9KWB9aWYodHlwZW9mIHIubm9leHQ9PT1cImJvb2xlYW5cIil7ci5ub2V4dGdsb2I9ci5ub2V4dH1jb25zdCBOPXtpbnB1dDplLGluZGV4Oi0xLHN0YXJ0OjAsZG90OnIuZG90PT09dHJ1ZSxjb25zdW1lZDpcIlwiLG91dHB1dDpcIlwiLHByZWZpeDpcIlwiLGJhY2t0cmFjazpmYWxzZSxuZWdhdGVkOmZhbHNlLGJyYWNrZXRzOjAsYnJhY2VzOjAscGFyZW5zOjAscXVvdGVzOjAsZ2xvYnN0YXI6ZmFsc2UsdG9rZW5zOkF9O2U9dS5yZW1vdmVQcmVmaXgoZSxOKTtwPWUubGVuZ3RoO2NvbnN0IGs9W107Y29uc3QgST1bXTtjb25zdCBNPVtdO2xldCBQPWY7bGV0IEI7Y29uc3QgZW9zPSgpPT5OLmluZGV4PT09cC0xO2NvbnN0IEc9Ti5wZWVrPSh0PTEpPT5lW04uaW5kZXgrdF07Y29uc3QgRD1OLmFkdmFuY2U9KCk9PmVbKytOLmluZGV4XTtjb25zdCByZW1haW5pbmc9KCk9PmUuc2xpY2UoTi5pbmRleCsxKTtjb25zdCBjb25zdW1lPShlPVwiXCIsdD0wKT0+e04uY29uc3VtZWQrPWU7Ti5pbmRleCs9dH07Y29uc3QgYXBwZW5kPWU9PntOLm91dHB1dCs9ZS5vdXRwdXQhPW51bGw/ZS5vdXRwdXQ6ZS52YWx1ZTtjb25zdW1lKGUudmFsdWUpfTtjb25zdCBuZWdhdGU9KCk9PntsZXQgZT0xO3doaWxlKEcoKT09PVwiIVwiJiYoRygyKSE9PVwiKFwifHxHKDMpPT09XCI/XCIpKXtEKCk7Ti5zdGFydCsrO2UrK31pZihlJTI9PT0wKXtyZXR1cm4gZmFsc2V9Ti5uZWdhdGVkPXRydWU7Ti5zdGFydCsrO3JldHVybiB0cnVlfTtjb25zdCBpbmNyZW1lbnQ9ZT0+e05bZV0rKztNLnB1c2goZSl9O2NvbnN0IGRlY3JlbWVudD1lPT57TltlXS0tO00ucG9wKCl9O2NvbnN0IHB1c2g9ZT0+e2lmKFAudHlwZT09PVwiZ2xvYnN0YXJcIil7Y29uc3QgdD1OLmJyYWNlcz4wJiYoZS50eXBlPT09XCJjb21tYVwifHxlLnR5cGU9PT1cImJyYWNlXCIpO2NvbnN0IHI9ZS5leHRnbG9iPT09dHJ1ZXx8ay5sZW5ndGgmJihlLnR5cGU9PT1cInBpcGVcInx8ZS50eXBlPT09XCJwYXJlblwiKTtpZihlLnR5cGUhPT1cInNsYXNoXCImJmUudHlwZSE9PVwicGFyZW5cIiYmIXQmJiFyKXtOLm91dHB1dD1OLm91dHB1dC5zbGljZSgwLC1QLm91dHB1dC5sZW5ndGgpO1AudHlwZT1cInN0YXJcIjtQLnZhbHVlPVwiKlwiO1Aub3V0cHV0PXc7Ti5vdXRwdXQrPVAub3V0cHV0fX1pZihrLmxlbmd0aCYmZS50eXBlIT09XCJwYXJlblwiJiYhZ1tlLnZhbHVlXSl7a1trLmxlbmd0aC0xXS5pbm5lcis9ZS52YWx1ZX1pZihlLnZhbHVlfHxlLm91dHB1dClhcHBlbmQoZSk7aWYoUCYmUC50eXBlPT09XCJ0ZXh0XCImJmUudHlwZT09PVwidGV4dFwiKXtQLnZhbHVlKz1lLnZhbHVlO1Aub3V0cHV0PShQLm91dHB1dHx8XCJcIikrZS52YWx1ZTtyZXR1cm59ZS5wcmV2PVA7QS5wdXNoKGUpO1A9ZX07Y29uc3QgZXh0Z2xvYk9wZW49KGUsdCk9Pntjb25zdCBuPXsuLi5nW3RdLGNvbmRpdGlvbnM6MSxpbm5lcjpcIlwifTtuLnByZXY9UDtuLnBhcmVucz1OLnBhcmVucztuLm91dHB1dD1OLm91dHB1dDtjb25zdCB1PShyLmNhcHR1cmU/XCIoXCI6XCJcIikrbi5vcGVuO2luY3JlbWVudChcInBhcmVuc1wiKTtwdXNoKHt0eXBlOmUsdmFsdWU6dCxvdXRwdXQ6Ti5vdXRwdXQ/XCJcIjpkfSk7cHVzaCh7dHlwZTpcInBhcmVuXCIsZXh0Z2xvYjp0cnVlLHZhbHVlOkQoKSxvdXRwdXQ6dX0pO2sucHVzaChuKX07Y29uc3QgZXh0Z2xvYkNsb3NlPWU9PntsZXQgdD1lLmNsb3NlKyhyLmNhcHR1cmU/XCIpXCI6XCJcIik7aWYoZS50eXBlPT09XCJuZWdhdGVcIil7bGV0IG49dztpZihlLmlubmVyJiZlLmlubmVyLmxlbmd0aD4xJiZlLmlubmVyLmluY2x1ZGVzKFwiL1wiKSl7bj1nbG9ic3RhcihyKX1pZihuIT09d3x8ZW9zKCl8fC9eXFwpKyQvLnRlc3QocmVtYWluaW5nKCkpKXt0PWUuY2xvc2U9YCkkKSkke259YH1pZihlLnByZXYudHlwZT09PVwiYm9zXCIpe04ubmVnYXRlZEV4dGdsb2I9dHJ1ZX19cHVzaCh7dHlwZTpcInBhcmVuXCIsZXh0Z2xvYjp0cnVlLHZhbHVlOkIsb3V0cHV0OnR9KTtkZWNyZW1lbnQoXCJwYXJlbnNcIil9O2lmKHIuZmFzdHBhdGhzIT09ZmFsc2UmJiEvKF5bKiFdfFsvKClbXFxde31cIl0pLy50ZXN0KGUpKXtsZXQgbj1mYWxzZTtsZXQgcz1lLnJlcGxhY2UoYSwoKGUsdCxyLHUscyxvKT0+e2lmKHU9PT1cIlxcXFxcIil7bj10cnVlO3JldHVybiBlfWlmKHU9PT1cIj9cIil7aWYodCl7cmV0dXJuIHQrdSsocz92LnJlcGVhdChzLmxlbmd0aCk6XCJcIil9aWYobz09PTApe3JldHVybiBPKyhzP3YucmVwZWF0KHMubGVuZ3RoKTpcIlwiKX1yZXR1cm4gdi5yZXBlYXQoci5sZW5ndGgpfWlmKHU9PT1cIi5cIil7cmV0dXJuIEUucmVwZWF0KHIubGVuZ3RoKX1pZih1PT09XCIqXCIpe2lmKHQpe3JldHVybiB0K3UrKHM/dzpcIlwiKX1yZXR1cm4gd31yZXR1cm4gdD9lOmBcXFxcJHtlfWB9KSk7aWYobj09PXRydWUpe2lmKHIudW5lc2NhcGU9PT10cnVlKXtzPXMucmVwbGFjZSgvXFxcXC9nLFwiXCIpfWVsc2V7cz1zLnJlcGxhY2UoL1xcXFwrL2csKGU9PmUubGVuZ3RoJTI9PT0wP1wiXFxcXFxcXFxcIjplP1wiXFxcXFwiOlwiXCIpKX19aWYocz09PWUmJnIuY29udGFpbnM9PT10cnVlKXtOLm91dHB1dD1lO3JldHVybiBOfU4ub3V0cHV0PXUud3JhcE91dHB1dChzLE4sdCk7cmV0dXJuIE59d2hpbGUoIWVvcygpKXtCPUQoKTtpZihCPT09XCJcXDBcIil7Y29udGludWV9aWYoQj09PVwiXFxcXFwiKXtjb25zdCBlPUcoKTtpZihlPT09XCIvXCImJnIuYmFzaCE9PXRydWUpe2NvbnRpbnVlfWlmKGU9PT1cIi5cInx8ZT09PVwiO1wiKXtjb250aW51ZX1pZighZSl7Qis9XCJcXFxcXCI7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpCfSk7Y29udGludWV9Y29uc3QgdD0vXlxcXFwrLy5leGVjKHJlbWFpbmluZygpKTtsZXQgbj0wO2lmKHQmJnRbMF0ubGVuZ3RoPjIpe249dFswXS5sZW5ndGg7Ti5pbmRleCs9bjtpZihuJTIhPT0wKXtCKz1cIlxcXFxcIn19aWYoci51bmVzY2FwZT09PXRydWUpe0I9RCgpfHxcIlwifWVsc2V7Qis9RCgpfHxcIlwifWlmKE4uYnJhY2tldHM9PT0wKXtwdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkJ9KTtjb250aW51ZX19aWYoTi5icmFja2V0cz4wJiYoQiE9PVwiXVwifHxQLnZhbHVlPT09XCJbXCJ8fFAudmFsdWU9PT1cIlteXCIpKXtpZihyLnBvc2l4IT09ZmFsc2UmJkI9PT1cIjpcIil7Y29uc3QgZT1QLnZhbHVlLnNsaWNlKDEpO2lmKGUuaW5jbHVkZXMoXCJbXCIpKXtQLnBvc2l4PXRydWU7aWYoZS5pbmNsdWRlcyhcIjpcIikpe2NvbnN0IGU9UC52YWx1ZS5sYXN0SW5kZXhPZihcIltcIik7Y29uc3QgdD1QLnZhbHVlLnNsaWNlKDAsZSk7Y29uc3Qgcj1QLnZhbHVlLnNsaWNlKGUrMik7Y29uc3Qgbj1vW3JdO2lmKG4pe1AudmFsdWU9dCtuO04uYmFja3RyYWNrPXRydWU7RCgpO2lmKCFmLm91dHB1dCYmQS5pbmRleE9mKFApPT09MSl7Zi5vdXRwdXQ9ZH1jb250aW51ZX19fX1pZihCPT09XCJbXCImJkcoKSE9PVwiOlwifHxCPT09XCItXCImJkcoKT09PVwiXVwiKXtCPWBcXFxcJHtCfWB9aWYoQj09PVwiXVwiJiYoUC52YWx1ZT09PVwiW1wifHxQLnZhbHVlPT09XCJbXlwiKSl7Qj1gXFxcXCR7Qn1gfWlmKHIucG9zaXg9PT10cnVlJiZCPT09XCIhXCImJlAudmFsdWU9PT1cIltcIil7Qj1cIl5cIn1QLnZhbHVlKz1CO2FwcGVuZCh7dmFsdWU6Qn0pO2NvbnRpbnVlfWlmKE4ucXVvdGVzPT09MSYmQiE9PSdcIicpe0I9dS5lc2NhcGVSZWdleChCKTtQLnZhbHVlKz1CO2FwcGVuZCh7dmFsdWU6Qn0pO2NvbnRpbnVlfWlmKEI9PT0nXCInKXtOLnF1b3Rlcz1OLnF1b3Rlcz09PTE/MDoxO2lmKHIua2VlcFF1b3Rlcz09PXRydWUpe3B1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6Qn0pfWNvbnRpbnVlfWlmKEI9PT1cIihcIil7aW5jcmVtZW50KFwicGFyZW5zXCIpO3B1c2goe3R5cGU6XCJwYXJlblwiLHZhbHVlOkJ9KTtjb250aW51ZX1pZihCPT09XCIpXCIpe2lmKE4ucGFyZW5zPT09MCYmci5zdHJpY3RCcmFja2V0cz09PXRydWUpe3Rocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcihcIm9wZW5pbmdcIixcIihcIikpfWNvbnN0IGU9a1trLmxlbmd0aC0xXTtpZihlJiZOLnBhcmVucz09PWUucGFyZW5zKzEpe2V4dGdsb2JDbG9zZShrLnBvcCgpKTtjb250aW51ZX1wdXNoKHt0eXBlOlwicGFyZW5cIix2YWx1ZTpCLG91dHB1dDpOLnBhcmVucz9cIilcIjpcIlxcXFwpXCJ9KTtkZWNyZW1lbnQoXCJwYXJlbnNcIik7Y29udGludWV9aWYoQj09PVwiW1wiKXtpZihyLm5vYnJhY2tldD09PXRydWV8fCFyZW1haW5pbmcoKS5pbmNsdWRlcyhcIl1cIikpe2lmKHIubm9icmFja2V0IT09dHJ1ZSYmci5zdHJpY3RCcmFja2V0cz09PXRydWUpe3Rocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcihcImNsb3NpbmdcIixcIl1cIikpfUI9YFxcXFwke0J9YH1lbHNle2luY3JlbWVudChcImJyYWNrZXRzXCIpfXB1c2goe3R5cGU6XCJicmFja2V0XCIsdmFsdWU6Qn0pO2NvbnRpbnVlfWlmKEI9PT1cIl1cIil7aWYoci5ub2JyYWNrZXQ9PT10cnVlfHxQJiZQLnR5cGU9PT1cImJyYWNrZXRcIiYmUC52YWx1ZS5sZW5ndGg9PT0xKXtwdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkIsb3V0cHV0OmBcXFxcJHtCfWB9KTtjb250aW51ZX1pZihOLmJyYWNrZXRzPT09MCl7aWYoci5zdHJpY3RCcmFja2V0cz09PXRydWUpe3Rocm93IG5ldyBTeW50YXhFcnJvcihzeW50YXhFcnJvcihcIm9wZW5pbmdcIixcIltcIikpfXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6QixvdXRwdXQ6YFxcXFwke0J9YH0pO2NvbnRpbnVlfWRlY3JlbWVudChcImJyYWNrZXRzXCIpO2NvbnN0IGU9UC52YWx1ZS5zbGljZSgxKTtpZihQLnBvc2l4IT09dHJ1ZSYmZVswXT09PVwiXlwiJiYhZS5pbmNsdWRlcyhcIi9cIikpe0I9YC8ke0J9YH1QLnZhbHVlKz1CO2FwcGVuZCh7dmFsdWU6Qn0pO2lmKHIubGl0ZXJhbEJyYWNrZXRzPT09ZmFsc2V8fHUuaGFzUmVnZXhDaGFycyhlKSl7Y29udGludWV9Y29uc3QgdD11LmVzY2FwZVJlZ2V4KFAudmFsdWUpO04ub3V0cHV0PU4ub3V0cHV0LnNsaWNlKDAsLVAudmFsdWUubGVuZ3RoKTtpZihyLmxpdGVyYWxCcmFja2V0cz09PXRydWUpe04ub3V0cHV0Kz10O1AudmFsdWU9dDtjb250aW51ZX1QLnZhbHVlPWAoJHtSfSR7dH18JHtQLnZhbHVlfSlgO04ub3V0cHV0Kz1QLnZhbHVlO2NvbnRpbnVlfWlmKEI9PT1cIntcIiYmci5ub2JyYWNlIT09dHJ1ZSl7aW5jcmVtZW50KFwiYnJhY2VzXCIpO2NvbnN0IGU9e3R5cGU6XCJicmFjZVwiLHZhbHVlOkIsb3V0cHV0OlwiKFwiLG91dHB1dEluZGV4Ok4ub3V0cHV0Lmxlbmd0aCx0b2tlbnNJbmRleDpOLnRva2Vucy5sZW5ndGh9O0kucHVzaChlKTtwdXNoKGUpO2NvbnRpbnVlfWlmKEI9PT1cIn1cIil7Y29uc3QgZT1JW0kubGVuZ3RoLTFdO2lmKHIubm9icmFjZT09PXRydWV8fCFlKXtwdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkIsb3V0cHV0OkJ9KTtjb250aW51ZX1sZXQgdD1cIilcIjtpZihlLmRvdHM9PT10cnVlKXtjb25zdCBlPUEuc2xpY2UoKTtjb25zdCBuPVtdO2ZvcihsZXQgdD1lLmxlbmd0aC0xO3Q+PTA7dC0tKXtBLnBvcCgpO2lmKGVbdF0udHlwZT09PVwiYnJhY2VcIil7YnJlYWt9aWYoZVt0XS50eXBlIT09XCJkb3RzXCIpe24udW5zaGlmdChlW3RdLnZhbHVlKX19dD1leHBhbmRSYW5nZShuLHIpO04uYmFja3RyYWNrPXRydWV9aWYoZS5jb21tYSE9PXRydWUmJmUuZG90cyE9PXRydWUpe2NvbnN0IHI9Ti5vdXRwdXQuc2xpY2UoMCxlLm91dHB1dEluZGV4KTtjb25zdCBuPU4udG9rZW5zLnNsaWNlKGUudG9rZW5zSW5kZXgpO2UudmFsdWU9ZS5vdXRwdXQ9XCJcXFxce1wiO0I9dD1cIlxcXFx9XCI7Ti5vdXRwdXQ9cjtmb3IoY29uc3QgZSBvZiBuKXtOLm91dHB1dCs9ZS5vdXRwdXR8fGUudmFsdWV9fXB1c2goe3R5cGU6XCJicmFjZVwiLHZhbHVlOkIsb3V0cHV0OnR9KTtkZWNyZW1lbnQoXCJicmFjZXNcIik7SS5wb3AoKTtjb250aW51ZX1pZihCPT09XCJ8XCIpe2lmKGsubGVuZ3RoPjApe2tbay5sZW5ndGgtMV0uY29uZGl0aW9ucysrfXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6Qn0pO2NvbnRpbnVlfWlmKEI9PT1cIixcIil7bGV0IGU9Qjtjb25zdCB0PUlbSS5sZW5ndGgtMV07aWYodCYmTVtNLmxlbmd0aC0xXT09PVwiYnJhY2VzXCIpe3QuY29tbWE9dHJ1ZTtlPVwifFwifXB1c2goe3R5cGU6XCJjb21tYVwiLHZhbHVlOkIsb3V0cHV0OmV9KTtjb250aW51ZX1pZihCPT09XCIvXCIpe2lmKFAudHlwZT09PVwiZG90XCImJk4uaW5kZXg9PT1OLnN0YXJ0KzEpe04uc3RhcnQ9Ti5pbmRleCsxO04uY29uc3VtZWQ9XCJcIjtOLm91dHB1dD1cIlwiO0EucG9wKCk7UD1mO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJzbGFzaFwiLHZhbHVlOkIsb3V0cHV0Onl9KTtjb250aW51ZX1pZihCPT09XCIuXCIpe2lmKE4uYnJhY2VzPjAmJlAudHlwZT09PVwiZG90XCIpe2lmKFAudmFsdWU9PT1cIi5cIilQLm91dHB1dD1FO2NvbnN0IGU9SVtJLmxlbmd0aC0xXTtQLnR5cGU9XCJkb3RzXCI7UC5vdXRwdXQrPUI7UC52YWx1ZSs9QjtlLmRvdHM9dHJ1ZTtjb250aW51ZX1pZihOLmJyYWNlcytOLnBhcmVucz09PTAmJlAudHlwZSE9PVwiYm9zXCImJlAudHlwZSE9PVwic2xhc2hcIil7cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpCLG91dHB1dDpFfSk7Y29udGludWV9cHVzaCh7dHlwZTpcImRvdFwiLHZhbHVlOkIsb3V0cHV0OkV9KTtjb250aW51ZX1pZihCPT09XCI/XCIpe2NvbnN0IGU9UCYmUC52YWx1ZT09PVwiKFwiO2lmKCFlJiZyLm5vZXh0Z2xvYiE9PXRydWUmJkcoKT09PVwiKFwiJiZHKDIpIT09XCI/XCIpe2V4dGdsb2JPcGVuKFwicW1hcmtcIixCKTtjb250aW51ZX1pZihQJiZQLnR5cGU9PT1cInBhcmVuXCIpe2NvbnN0IGU9RygpO2xldCB0PUI7aWYoZT09PVwiPFwiJiYhdS5zdXBwb3J0c0xvb2tiZWhpbmRzKCkpe3Rocm93IG5ldyBFcnJvcihcIk5vZGUuanMgdjEwIG9yIGhpZ2hlciBpcyByZXF1aXJlZCBmb3IgcmVnZXggbG9va2JlaGluZHNcIil9aWYoUC52YWx1ZT09PVwiKFwiJiYhL1shPTw6XS8udGVzdChlKXx8ZT09PVwiPFwiJiYhLzwoWyE9XXxcXHcrPikvLnRlc3QocmVtYWluaW5nKCkpKXt0PWBcXFxcJHtCfWB9cHVzaCh7dHlwZTpcInRleHRcIix2YWx1ZTpCLG91dHB1dDp0fSk7Y29udGludWV9aWYoci5kb3QhPT10cnVlJiYoUC50eXBlPT09XCJzbGFzaFwifHxQLnR5cGU9PT1cImJvc1wiKSl7cHVzaCh7dHlwZTpcInFtYXJrXCIsdmFsdWU6QixvdXRwdXQ6JH0pO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJxbWFya1wiLHZhbHVlOkIsb3V0cHV0OnZ9KTtjb250aW51ZX1pZihCPT09XCIhXCIpe2lmKHIubm9leHRnbG9iIT09dHJ1ZSYmRygpPT09XCIoXCIpe2lmKEcoMikhPT1cIj9cInx8IS9bIT08Ol0vLnRlc3QoRygzKSkpe2V4dGdsb2JPcGVuKFwibmVnYXRlXCIsQik7Y29udGludWV9fWlmKHIubm9uZWdhdGUhPT10cnVlJiZOLmluZGV4PT09MCl7bmVnYXRlKCk7Y29udGludWV9fWlmKEI9PT1cIitcIil7aWYoci5ub2V4dGdsb2IhPT10cnVlJiZHKCk9PT1cIihcIiYmRygyKSE9PVwiP1wiKXtleHRnbG9iT3BlbihcInBsdXNcIixCKTtjb250aW51ZX1pZihQJiZQLnZhbHVlPT09XCIoXCJ8fHIucmVnZXg9PT1mYWxzZSl7cHVzaCh7dHlwZTpcInBsdXNcIix2YWx1ZTpCLG91dHB1dDpDfSk7Y29udGludWV9aWYoUCYmKFAudHlwZT09PVwiYnJhY2tldFwifHxQLnR5cGU9PT1cInBhcmVuXCJ8fFAudHlwZT09PVwiYnJhY2VcIil8fE4ucGFyZW5zPjApe3B1c2goe3R5cGU6XCJwbHVzXCIsdmFsdWU6Qn0pO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJwbHVzXCIsdmFsdWU6Q30pO2NvbnRpbnVlfWlmKEI9PT1cIkBcIil7aWYoci5ub2V4dGdsb2IhPT10cnVlJiZHKCk9PT1cIihcIiYmRygyKSE9PVwiP1wiKXtwdXNoKHt0eXBlOlwiYXRcIixleHRnbG9iOnRydWUsdmFsdWU6QixvdXRwdXQ6XCJcIn0pO2NvbnRpbnVlfXB1c2goe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6Qn0pO2NvbnRpbnVlfWlmKEIhPT1cIipcIil7aWYoQj09PVwiJFwifHxCPT09XCJeXCIpe0I9YFxcXFwke0J9YH1jb25zdCBlPWkuZXhlYyhyZW1haW5pbmcoKSk7aWYoZSl7Qis9ZVswXTtOLmluZGV4Kz1lWzBdLmxlbmd0aH1wdXNoKHt0eXBlOlwidGV4dFwiLHZhbHVlOkJ9KTtjb250aW51ZX1pZihQJiYoUC50eXBlPT09XCJnbG9ic3RhclwifHxQLnN0YXI9PT10cnVlKSl7UC50eXBlPVwic3RhclwiO1Auc3Rhcj10cnVlO1AudmFsdWUrPUI7UC5vdXRwdXQ9dztOLmJhY2t0cmFjaz10cnVlO04uZ2xvYnN0YXI9dHJ1ZTtjb25zdW1lKEIpO2NvbnRpbnVlfWxldCB0PXJlbWFpbmluZygpO2lmKHIubm9leHRnbG9iIT09dHJ1ZSYmL15cXChbXj9dLy50ZXN0KHQpKXtleHRnbG9iT3BlbihcInN0YXJcIixCKTtjb250aW51ZX1pZihQLnR5cGU9PT1cInN0YXJcIil7aWYoci5ub2dsb2JzdGFyPT09dHJ1ZSl7Y29uc3VtZShCKTtjb250aW51ZX1jb25zdCBuPVAucHJldjtjb25zdCB1PW4ucHJldjtjb25zdCBzPW4udHlwZT09PVwic2xhc2hcInx8bi50eXBlPT09XCJib3NcIjtjb25zdCBvPXUmJih1LnR5cGU9PT1cInN0YXJcInx8dS50eXBlPT09XCJnbG9ic3RhclwiKTtpZihyLmJhc2g9PT10cnVlJiYoIXN8fHRbMF0mJnRbMF0hPT1cIi9cIikpe3B1c2goe3R5cGU6XCJzdGFyXCIsdmFsdWU6QixvdXRwdXQ6XCJcIn0pO2NvbnRpbnVlfWNvbnN0IGk9Ti5icmFjZXM+MCYmKG4udHlwZT09PVwiY29tbWFcInx8bi50eXBlPT09XCJicmFjZVwiKTtjb25zdCBhPWsubGVuZ3RoJiYobi50eXBlPT09XCJwaXBlXCJ8fG4udHlwZT09PVwicGFyZW5cIik7aWYoIXMmJm4udHlwZSE9PVwicGFyZW5cIiYmIWkmJiFhKXtwdXNoKHt0eXBlOlwic3RhclwiLHZhbHVlOkIsb3V0cHV0OlwiXCJ9KTtjb250aW51ZX13aGlsZSh0LnNsaWNlKDAsMyk9PT1cIi8qKlwiKXtjb25zdCByPWVbTi5pbmRleCs0XTtpZihyJiZyIT09XCIvXCIpe2JyZWFrfXQ9dC5zbGljZSgzKTtjb25zdW1lKFwiLyoqXCIsMyl9aWYobi50eXBlPT09XCJib3NcIiYmZW9zKCkpe1AudHlwZT1cImdsb2JzdGFyXCI7UC52YWx1ZSs9QjtQLm91dHB1dD1nbG9ic3RhcihyKTtOLm91dHB1dD1QLm91dHB1dDtOLmdsb2JzdGFyPXRydWU7Y29uc3VtZShCKTtjb250aW51ZX1pZihuLnR5cGU9PT1cInNsYXNoXCImJm4ucHJldi50eXBlIT09XCJib3NcIiYmIW8mJmVvcygpKXtOLm91dHB1dD1OLm91dHB1dC5zbGljZSgwLC0obi5vdXRwdXQrUC5vdXRwdXQpLmxlbmd0aCk7bi5vdXRwdXQ9YCg/OiR7bi5vdXRwdXR9YDtQLnR5cGU9XCJnbG9ic3RhclwiO1Aub3V0cHV0PWdsb2JzdGFyKHIpKyhyLnN0cmljdFNsYXNoZXM/XCIpXCI6XCJ8JClcIik7UC52YWx1ZSs9QjtOLmdsb2JzdGFyPXRydWU7Ti5vdXRwdXQrPW4ub3V0cHV0K1Aub3V0cHV0O2NvbnN1bWUoQik7Y29udGludWV9aWYobi50eXBlPT09XCJzbGFzaFwiJiZuLnByZXYudHlwZSE9PVwiYm9zXCImJnRbMF09PT1cIi9cIil7Y29uc3QgZT10WzFdIT09dm9pZCAwP1wifCRcIjpcIlwiO04ub3V0cHV0PU4ub3V0cHV0LnNsaWNlKDAsLShuLm91dHB1dCtQLm91dHB1dCkubGVuZ3RoKTtuLm91dHB1dD1gKD86JHtuLm91dHB1dH1gO1AudHlwZT1cImdsb2JzdGFyXCI7UC5vdXRwdXQ9YCR7Z2xvYnN0YXIocil9JHt5fXwke3l9JHtlfSlgO1AudmFsdWUrPUI7Ti5vdXRwdXQrPW4ub3V0cHV0K1Aub3V0cHV0O04uZ2xvYnN0YXI9dHJ1ZTtjb25zdW1lKEIrRCgpKTtwdXNoKHt0eXBlOlwic2xhc2hcIix2YWx1ZTpcIi9cIixvdXRwdXQ6XCJcIn0pO2NvbnRpbnVlfWlmKG4udHlwZT09PVwiYm9zXCImJnRbMF09PT1cIi9cIil7UC50eXBlPVwiZ2xvYnN0YXJcIjtQLnZhbHVlKz1CO1Aub3V0cHV0PWAoPzpefCR7eX18JHtnbG9ic3RhcihyKX0ke3l9KWA7Ti5vdXRwdXQ9UC5vdXRwdXQ7Ti5nbG9ic3Rhcj10cnVlO2NvbnN1bWUoQitEKCkpO3B1c2goe3R5cGU6XCJzbGFzaFwiLHZhbHVlOlwiL1wiLG91dHB1dDpcIlwifSk7Y29udGludWV9Ti5vdXRwdXQ9Ti5vdXRwdXQuc2xpY2UoMCwtUC5vdXRwdXQubGVuZ3RoKTtQLnR5cGU9XCJnbG9ic3RhclwiO1Aub3V0cHV0PWdsb2JzdGFyKHIpO1AudmFsdWUrPUI7Ti5vdXRwdXQrPVAub3V0cHV0O04uZ2xvYnN0YXI9dHJ1ZTtjb25zdW1lKEIpO2NvbnRpbnVlfWNvbnN0IG49e3R5cGU6XCJzdGFyXCIsdmFsdWU6QixvdXRwdXQ6d307aWYoci5iYXNoPT09dHJ1ZSl7bi5vdXRwdXQ9XCIuKj9cIjtpZihQLnR5cGU9PT1cImJvc1wifHxQLnR5cGU9PT1cInNsYXNoXCIpe24ub3V0cHV0PUwrbi5vdXRwdXR9cHVzaChuKTtjb250aW51ZX1pZihQJiYoUC50eXBlPT09XCJicmFja2V0XCJ8fFAudHlwZT09PVwicGFyZW5cIikmJnIucmVnZXg9PT10cnVlKXtuLm91dHB1dD1CO3B1c2gobik7Y29udGludWV9aWYoTi5pbmRleD09PU4uc3RhcnR8fFAudHlwZT09PVwic2xhc2hcInx8UC50eXBlPT09XCJkb3RcIil7aWYoUC50eXBlPT09XCJkb3RcIil7Ti5vdXRwdXQrPVM7UC5vdXRwdXQrPVN9ZWxzZSBpZihyLmRvdD09PXRydWUpe04ub3V0cHV0Kz1IO1Aub3V0cHV0Kz1IfWVsc2V7Ti5vdXRwdXQrPUw7UC5vdXRwdXQrPUx9aWYoRygpIT09XCIqXCIpe04ub3V0cHV0Kz1kO1Aub3V0cHV0Kz1kfX1wdXNoKG4pfXdoaWxlKE4uYnJhY2tldHM+MCl7aWYoci5zdHJpY3RCcmFja2V0cz09PXRydWUpdGhyb3cgbmV3IFN5bnRheEVycm9yKHN5bnRheEVycm9yKFwiY2xvc2luZ1wiLFwiXVwiKSk7Ti5vdXRwdXQ9dS5lc2NhcGVMYXN0KE4ub3V0cHV0LFwiW1wiKTtkZWNyZW1lbnQoXCJicmFja2V0c1wiKX13aGlsZShOLnBhcmVucz4wKXtpZihyLnN0cmljdEJyYWNrZXRzPT09dHJ1ZSl0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJjbG9zaW5nXCIsXCIpXCIpKTtOLm91dHB1dD11LmVzY2FwZUxhc3QoTi5vdXRwdXQsXCIoXCIpO2RlY3JlbWVudChcInBhcmVuc1wiKX13aGlsZShOLmJyYWNlcz4wKXtpZihyLnN0cmljdEJyYWNrZXRzPT09dHJ1ZSl0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3ludGF4RXJyb3IoXCJjbG9zaW5nXCIsXCJ9XCIpKTtOLm91dHB1dD11LmVzY2FwZUxhc3QoTi5vdXRwdXQsXCJ7XCIpO2RlY3JlbWVudChcImJyYWNlc1wiKX1pZihyLnN0cmljdFNsYXNoZXMhPT10cnVlJiYoUC50eXBlPT09XCJzdGFyXCJ8fFAudHlwZT09PVwiYnJhY2tldFwiKSl7cHVzaCh7dHlwZTpcIm1heWJlX3NsYXNoXCIsdmFsdWU6XCJcIixvdXRwdXQ6YCR7eX0/YH0pfWlmKE4uYmFja3RyYWNrPT09dHJ1ZSl7Ti5vdXRwdXQ9XCJcIjtmb3IoY29uc3QgZSBvZiBOLnRva2Vucyl7Ti5vdXRwdXQrPWUub3V0cHV0IT1udWxsP2Uub3V0cHV0OmUudmFsdWU7aWYoZS5zdWZmaXgpe04ub3V0cHV0Kz1lLnN1ZmZpeH19fXJldHVybiBOfTtwYXJzZS5mYXN0cGF0aHM9KGUsdCk9Pntjb25zdCByPXsuLi50fTtjb25zdCBvPXR5cGVvZiByLm1heExlbmd0aD09PVwibnVtYmVyXCI/TWF0aC5taW4ocyxyLm1heExlbmd0aCk6cztjb25zdCBpPWUubGVuZ3RoO2lmKGk+byl7dGhyb3cgbmV3IFN5bnRheEVycm9yKGBJbnB1dCBsZW5ndGg6ICR7aX0sIGV4Y2VlZHMgbWF4aW11bSBhbGxvd2VkIGxlbmd0aDogJHtvfWApfWU9bFtlXXx8ZTtjb25zdCBhPXUuaXNXaW5kb3dzKHQpO2NvbnN0e0RPVF9MSVRFUkFMOmMsU0xBU0hfTElURVJBTDpwLE9ORV9DSEFSOmYsRE9UU19TTEFTSDpBLE5PX0RPVDpSLE5PX0RPVFM6XyxOT19ET1RTX1NMQVNIOmgsU1RBUjpnLFNUQVJUX0FOQ0hPUjpFfT1uLmdsb2JDaGFycyhhKTtjb25zdCBDPXIuZG90P186Ujtjb25zdCB5PXIuZG90P2g6Ujtjb25zdCBkPXIuY2FwdHVyZT9cIlwiOlwiPzpcIjtjb25zdCB4PXtuZWdhdGVkOmZhbHNlLHByZWZpeDpcIlwifTtsZXQgYj1yLmJhc2g9PT10cnVlP1wiLio/XCI6ZztpZihyLmNhcHR1cmUpe2I9YCgke2J9KWB9Y29uc3QgZ2xvYnN0YXI9ZT0+e2lmKGUubm9nbG9ic3Rhcj09PXRydWUpcmV0dXJuIGI7cmV0dXJuYCgke2R9KD86KD8hJHtFfSR7ZS5kb3Q/QTpjfSkuKSo/KWB9O2NvbnN0IGNyZWF0ZT1lPT57c3dpdGNoKGUpe2Nhc2VcIipcIjpyZXR1cm5gJHtDfSR7Zn0ke2J9YDtjYXNlXCIuKlwiOnJldHVybmAke2N9JHtmfSR7Yn1gO2Nhc2VcIiouKlwiOnJldHVybmAke0N9JHtifSR7Y30ke2Z9JHtifWA7Y2FzZVwiKi8qXCI6cmV0dXJuYCR7Q30ke2J9JHtwfSR7Zn0ke3l9JHtifWA7Y2FzZVwiKipcIjpyZXR1cm4gQytnbG9ic3RhcihyKTtjYXNlXCIqKi8qXCI6cmV0dXJuYCg/OiR7Q30ke2dsb2JzdGFyKHIpfSR7cH0pPyR7eX0ke2Z9JHtifWA7Y2FzZVwiKiovKi4qXCI6cmV0dXJuYCg/OiR7Q30ke2dsb2JzdGFyKHIpfSR7cH0pPyR7eX0ke2J9JHtjfSR7Zn0ke2J9YDtjYXNlXCIqKi8uKlwiOnJldHVybmAoPzoke0N9JHtnbG9ic3RhcihyKX0ke3B9KT8ke2N9JHtmfSR7Yn1gO2RlZmF1bHQ6e2NvbnN0IHQ9L14oLio/KVxcLihcXHcrKSQvLmV4ZWMoZSk7aWYoIXQpcmV0dXJuO2NvbnN0IHI9Y3JlYXRlKHRbMV0pO2lmKCFyKXJldHVybjtyZXR1cm4gcitjK3RbMl19fX07Y29uc3QgUz11LnJlbW92ZVByZWZpeChlLHgpO2xldCBIPWNyZWF0ZShTKTtpZihIJiZyLnN0cmljdFNsYXNoZXMhPT10cnVlKXtIKz1gJHtwfT9gfXJldHVybiBIfTtlLmV4cG9ydHM9cGFyc2V9LDY4MzooZSx0LHIpPT57Y29uc3Qgbj1yKDE3KTtjb25zdCB1PXIoNzAwKTtjb25zdCBzPXIoNzU0KTtjb25zdCBvPXIoNTEzKTtjb25zdCBpPXIoMzU2KTtjb25zdCBpc09iamVjdD1lPT5lJiZ0eXBlb2YgZT09PVwib2JqZWN0XCImJiFBcnJheS5pc0FycmF5KGUpO2NvbnN0IHBpY29tYXRjaD0oZSx0LHI9ZmFsc2UpPT57aWYoQXJyYXkuaXNBcnJheShlKSl7Y29uc3Qgbj1lLm1hcCgoZT0+cGljb21hdGNoKGUsdCxyKSkpO2NvbnN0IGFycmF5TWF0Y2hlcj1lPT57Zm9yKGNvbnN0IHQgb2Ygbil7Y29uc3Qgcj10KGUpO2lmKHIpcmV0dXJuIHJ9cmV0dXJuIGZhbHNlfTtyZXR1cm4gYXJyYXlNYXRjaGVyfWNvbnN0IG49aXNPYmplY3QoZSkmJmUudG9rZW5zJiZlLmlucHV0O2lmKGU9PT1cIlwifHx0eXBlb2YgZSE9PVwic3RyaW5nXCImJiFuKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgcGF0dGVybiB0byBiZSBhIG5vbi1lbXB0eSBzdHJpbmdcIil9Y29uc3QgdT10fHx7fTtjb25zdCBzPW8uaXNXaW5kb3dzKHQpO2NvbnN0IGk9bj9waWNvbWF0Y2guY29tcGlsZVJlKGUsdCk6cGljb21hdGNoLm1ha2VSZShlLHQsZmFsc2UsdHJ1ZSk7Y29uc3QgYT1pLnN0YXRlO2RlbGV0ZSBpLnN0YXRlO2xldCBpc0lnbm9yZWQ9KCk9PmZhbHNlO2lmKHUuaWdub3JlKXtjb25zdCBlPXsuLi50LGlnbm9yZTpudWxsLG9uTWF0Y2g6bnVsbCxvblJlc3VsdDpudWxsfTtpc0lnbm9yZWQ9cGljb21hdGNoKHUuaWdub3JlLGUscil9Y29uc3QgbWF0Y2hlcj0ocixuPWZhbHNlKT0+e2NvbnN0e2lzTWF0Y2g6byxtYXRjaDpsLG91dHB1dDpjfT1waWNvbWF0Y2gudGVzdChyLGksdCx7Z2xvYjplLHBvc2l4OnN9KTtjb25zdCBwPXtnbG9iOmUsc3RhdGU6YSxyZWdleDppLHBvc2l4OnMsaW5wdXQ6cixvdXRwdXQ6YyxtYXRjaDpsLGlzTWF0Y2g6b307aWYodHlwZW9mIHUub25SZXN1bHQ9PT1cImZ1bmN0aW9uXCIpe3Uub25SZXN1bHQocCl9aWYobz09PWZhbHNlKXtwLmlzTWF0Y2g9ZmFsc2U7cmV0dXJuIG4/cDpmYWxzZX1pZihpc0lnbm9yZWQocikpe2lmKHR5cGVvZiB1Lm9uSWdub3JlPT09XCJmdW5jdGlvblwiKXt1Lm9uSWdub3JlKHApfXAuaXNNYXRjaD1mYWxzZTtyZXR1cm4gbj9wOmZhbHNlfWlmKHR5cGVvZiB1Lm9uTWF0Y2g9PT1cImZ1bmN0aW9uXCIpe3Uub25NYXRjaChwKX1yZXR1cm4gbj9wOnRydWV9O2lmKHIpe21hdGNoZXIuc3RhdGU9YX1yZXR1cm4gbWF0Y2hlcn07cGljb21hdGNoLnRlc3Q9KGUsdCxyLHtnbG9iOm4scG9zaXg6dX09e30pPT57aWYodHlwZW9mIGUhPT1cInN0cmluZ1wiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgaW5wdXQgdG8gYmUgYSBzdHJpbmdcIil9aWYoZT09PVwiXCIpe3JldHVybntpc01hdGNoOmZhbHNlLG91dHB1dDpcIlwifX1jb25zdCBzPXJ8fHt9O2NvbnN0IGk9cy5mb3JtYXR8fCh1P28udG9Qb3NpeFNsYXNoZXM6bnVsbCk7bGV0IGE9ZT09PW47bGV0IGw9YSYmaT9pKGUpOmU7aWYoYT09PWZhbHNlKXtsPWk/aShlKTplO2E9bD09PW59aWYoYT09PWZhbHNlfHxzLmNhcHR1cmU9PT10cnVlKXtpZihzLm1hdGNoQmFzZT09PXRydWV8fHMuYmFzZW5hbWU9PT10cnVlKXthPXBpY29tYXRjaC5tYXRjaEJhc2UoZSx0LHIsdSl9ZWxzZXthPXQuZXhlYyhsKX19cmV0dXJue2lzTWF0Y2g6Qm9vbGVhbihhKSxtYXRjaDphLG91dHB1dDpsfX07cGljb21hdGNoLm1hdGNoQmFzZT0oZSx0LHIsdT1vLmlzV2luZG93cyhyKSk9Pntjb25zdCBzPXQgaW5zdGFuY2VvZiBSZWdFeHA/dDpwaWNvbWF0Y2gubWFrZVJlKHQscik7cmV0dXJuIHMudGVzdChuLmJhc2VuYW1lKGUpKX07cGljb21hdGNoLmlzTWF0Y2g9KGUsdCxyKT0+cGljb21hdGNoKHQscikoZSk7cGljb21hdGNoLnBhcnNlPShlLHQpPT57aWYoQXJyYXkuaXNBcnJheShlKSlyZXR1cm4gZS5tYXAoKGU9PnBpY29tYXRjaC5wYXJzZShlLHQpKSk7cmV0dXJuIHMoZSx7Li4udCxmYXN0cGF0aHM6ZmFsc2V9KX07cGljb21hdGNoLnNjYW49KGUsdCk9PnUoZSx0KTtwaWNvbWF0Y2guY29tcGlsZVJlPShlLHQscj1mYWxzZSxuPWZhbHNlKT0+e2lmKHI9PT10cnVlKXtyZXR1cm4gZS5vdXRwdXR9Y29uc3QgdT10fHx7fTtjb25zdCBzPXUuY29udGFpbnM/XCJcIjpcIl5cIjtjb25zdCBvPXUuY29udGFpbnM/XCJcIjpcIiRcIjtsZXQgaT1gJHtzfSg/OiR7ZS5vdXRwdXR9KSR7b31gO2lmKGUmJmUubmVnYXRlZD09PXRydWUpe2k9YF4oPyEke2l9KS4qJGB9Y29uc3QgYT1waWNvbWF0Y2gudG9SZWdleChpLHQpO2lmKG49PT10cnVlKXthLnN0YXRlPWV9cmV0dXJuIGF9O3BpY29tYXRjaC5tYWtlUmU9KGUsdCxyPWZhbHNlLG49ZmFsc2UpPT57aWYoIWV8fHR5cGVvZiBlIT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgbm9uLWVtcHR5IHN0cmluZ1wiKX1jb25zdCB1PXR8fHt9O2xldCBvPXtuZWdhdGVkOmZhbHNlLGZhc3RwYXRoczp0cnVlfTtsZXQgaT1cIlwiO2xldCBhO2lmKGUuc3RhcnRzV2l0aChcIi4vXCIpKXtlPWUuc2xpY2UoMik7aT1vLnByZWZpeD1cIi4vXCJ9aWYodS5mYXN0cGF0aHMhPT1mYWxzZSYmKGVbMF09PT1cIi5cInx8ZVswXT09PVwiKlwiKSl7YT1zLmZhc3RwYXRocyhlLHQpfWlmKGE9PT11bmRlZmluZWQpe289cyhlLHQpO28ucHJlZml4PWkrKG8ucHJlZml4fHxcIlwiKX1lbHNle28ub3V0cHV0PWF9cmV0dXJuIHBpY29tYXRjaC5jb21waWxlUmUobyx0LHIsbil9O3BpY29tYXRjaC50b1JlZ2V4PShlLHQpPT57dHJ5e2NvbnN0IHI9dHx8e307cmV0dXJuIG5ldyBSZWdFeHAoZSxyLmZsYWdzfHwoci5ub2Nhc2U/XCJpXCI6XCJcIikpfWNhdGNoKGUpe2lmKHQmJnQuZGVidWc9PT10cnVlKXRocm93IGU7cmV0dXJuLyReL319O3BpY29tYXRjaC5jb25zdGFudHM9aTtlLmV4cG9ydHM9cGljb21hdGNofSw3MDA6KGUsdCxyKT0+e2NvbnN0IG49cig1MTMpO2NvbnN0e0NIQVJfQVNURVJJU0s6dSxDSEFSX0FUOnMsQ0hBUl9CQUNLV0FSRF9TTEFTSDpvLENIQVJfQ09NTUE6aSxDSEFSX0RPVDphLENIQVJfRVhDTEFNQVRJT05fTUFSSzpsLENIQVJfRk9SV0FSRF9TTEFTSDpjLENIQVJfTEVGVF9DVVJMWV9CUkFDRTpwLENIQVJfTEVGVF9QQVJFTlRIRVNFUzpmLENIQVJfTEVGVF9TUVVBUkVfQlJBQ0tFVDpBLENIQVJfUExVUzpSLENIQVJfUVVFU1RJT05fTUFSSzpfLENIQVJfUklHSFRfQ1VSTFlfQlJBQ0U6aCxDSEFSX1JJR0hUX1BBUkVOVEhFU0VTOmcsQ0hBUl9SSUdIVF9TUVVBUkVfQlJBQ0tFVDpFfT1yKDM1Nik7Y29uc3QgaXNQYXRoU2VwYXJhdG9yPWU9PmU9PT1jfHxlPT09bztjb25zdCBkZXB0aD1lPT57aWYoZS5pc1ByZWZpeCE9PXRydWUpe2UuZGVwdGg9ZS5pc0dsb2JzdGFyP0luZmluaXR5OjF9fTtjb25zdCBzY2FuPShlLHQpPT57Y29uc3Qgcj10fHx7fTtjb25zdCBDPWUubGVuZ3RoLTE7Y29uc3QgeT1yLnBhcnRzPT09dHJ1ZXx8ci5zY2FuVG9FbmQ9PT10cnVlO2NvbnN0IGQ9W107Y29uc3QgeD1bXTtjb25zdCBiPVtdO2xldCBTPWU7bGV0IEg9LTE7bGV0IHY9MDtsZXQgJD0wO2xldCBtPWZhbHNlO2xldCBUPWZhbHNlO2xldCBMPWZhbHNlO2xldCBPPWZhbHNlO2xldCB3PWZhbHNlO2xldCBOPWZhbHNlO2xldCBrPWZhbHNlO2xldCBJPWZhbHNlO2xldCBNPWZhbHNlO2xldCBQPTA7bGV0IEI7bGV0IEc7bGV0IEQ9e3ZhbHVlOlwiXCIsZGVwdGg6MCxpc0dsb2I6ZmFsc2V9O2NvbnN0IGVvcz0oKT0+SD49Qztjb25zdCBwZWVrPSgpPT5TLmNoYXJDb2RlQXQoSCsxKTtjb25zdCBhZHZhbmNlPSgpPT57Qj1HO3JldHVybiBTLmNoYXJDb2RlQXQoKytIKX07d2hpbGUoSDxDKXtHPWFkdmFuY2UoKTtsZXQgZTtpZihHPT09byl7az1ELmJhY2tzbGFzaGVzPXRydWU7Rz1hZHZhbmNlKCk7aWYoRz09PXApe049dHJ1ZX1jb250aW51ZX1pZihOPT09dHJ1ZXx8Rz09PXApe1ArKzt3aGlsZShlb3MoKSE9PXRydWUmJihHPWFkdmFuY2UoKSkpe2lmKEc9PT1vKXtrPUQuYmFja3NsYXNoZXM9dHJ1ZTthZHZhbmNlKCk7Y29udGludWV9aWYoRz09PXApe1ArKztjb250aW51ZX1pZihOIT09dHJ1ZSYmRz09PWEmJihHPWFkdmFuY2UoKSk9PT1hKXttPUQuaXNCcmFjZT10cnVlO0w9RC5pc0dsb2I9dHJ1ZTtNPXRydWU7aWYoeT09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKE4hPT10cnVlJiZHPT09aSl7bT1ELmlzQnJhY2U9dHJ1ZTtMPUQuaXNHbG9iPXRydWU7TT10cnVlO2lmKHk9PT10cnVlKXtjb250aW51ZX1icmVha31pZihHPT09aCl7UC0tO2lmKFA9PT0wKXtOPWZhbHNlO209RC5pc0JyYWNlPXRydWU7TT10cnVlO2JyZWFrfX19aWYoeT09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKEc9PT1jKXtkLnB1c2goSCk7eC5wdXNoKEQpO0Q9e3ZhbHVlOlwiXCIsZGVwdGg6MCxpc0dsb2I6ZmFsc2V9O2lmKE09PT10cnVlKWNvbnRpbnVlO2lmKEI9PT1hJiZIPT09disxKXt2Kz0yO2NvbnRpbnVlfSQ9SCsxO2NvbnRpbnVlfWlmKHIubm9leHQhPT10cnVlKXtjb25zdCBlPUc9PT1SfHxHPT09c3x8Rz09PXV8fEc9PT1ffHxHPT09bDtpZihlPT09dHJ1ZSYmcGVlaygpPT09Zil7TD1ELmlzR2xvYj10cnVlO089RC5pc0V4dGdsb2I9dHJ1ZTtNPXRydWU7aWYoeT09PXRydWUpe3doaWxlKGVvcygpIT09dHJ1ZSYmKEc9YWR2YW5jZSgpKSl7aWYoRz09PW8pe2s9RC5iYWNrc2xhc2hlcz10cnVlO0c9YWR2YW5jZSgpO2NvbnRpbnVlfWlmKEc9PT1nKXtMPUQuaXNHbG9iPXRydWU7TT10cnVlO2JyZWFrfX1jb250aW51ZX1icmVha319aWYoRz09PXUpe2lmKEI9PT11KXc9RC5pc0dsb2JzdGFyPXRydWU7TD1ELmlzR2xvYj10cnVlO009dHJ1ZTtpZih5PT09dHJ1ZSl7Y29udGludWV9YnJlYWt9aWYoRz09PV8pe0w9RC5pc0dsb2I9dHJ1ZTtNPXRydWU7aWYoeT09PXRydWUpe2NvbnRpbnVlfWJyZWFrfWlmKEc9PT1BKXt3aGlsZShlb3MoKSE9PXRydWUmJihlPWFkdmFuY2UoKSkpe2lmKGU9PT1vKXtrPUQuYmFja3NsYXNoZXM9dHJ1ZTthZHZhbmNlKCk7Y29udGludWV9aWYoZT09PUUpe1Q9RC5pc0JyYWNrZXQ9dHJ1ZTtMPUQuaXNHbG9iPXRydWU7TT10cnVlO2JyZWFrfX1pZih5PT09dHJ1ZSl7Y29udGludWV9YnJlYWt9aWYoci5ub25lZ2F0ZSE9PXRydWUmJkc9PT1sJiZIPT09dil7ST1ELm5lZ2F0ZWQ9dHJ1ZTt2Kys7Y29udGludWV9aWYoci5ub3BhcmVuIT09dHJ1ZSYmRz09PWYpe0w9RC5pc0dsb2I9dHJ1ZTtpZih5PT09dHJ1ZSl7d2hpbGUoZW9zKCkhPT10cnVlJiYoRz1hZHZhbmNlKCkpKXtpZihHPT09Zil7az1ELmJhY2tzbGFzaGVzPXRydWU7Rz1hZHZhbmNlKCk7Y29udGludWV9aWYoRz09PWcpe009dHJ1ZTticmVha319Y29udGludWV9YnJlYWt9aWYoTD09PXRydWUpe009dHJ1ZTtpZih5PT09dHJ1ZSl7Y29udGludWV9YnJlYWt9fWlmKHIubm9leHQ9PT10cnVlKXtPPWZhbHNlO0w9ZmFsc2V9bGV0IFU9UztsZXQgSz1cIlwiO2xldCBGPVwiXCI7aWYodj4wKXtLPVMuc2xpY2UoMCx2KTtTPVMuc2xpY2Uodik7JC09dn1pZihVJiZMPT09dHJ1ZSYmJD4wKXtVPVMuc2xpY2UoMCwkKTtGPVMuc2xpY2UoJCl9ZWxzZSBpZihMPT09dHJ1ZSl7VT1cIlwiO0Y9U31lbHNle1U9U31pZihVJiZVIT09XCJcIiYmVSE9PVwiL1wiJiZVIT09Uyl7aWYoaXNQYXRoU2VwYXJhdG9yKFUuY2hhckNvZGVBdChVLmxlbmd0aC0xKSkpe1U9VS5zbGljZSgwLC0xKX19aWYoci51bmVzY2FwZT09PXRydWUpe2lmKEYpRj1uLnJlbW92ZUJhY2tzbGFzaGVzKEYpO2lmKFUmJms9PT10cnVlKXtVPW4ucmVtb3ZlQmFja3NsYXNoZXMoVSl9fWNvbnN0IFE9e3ByZWZpeDpLLGlucHV0OmUsc3RhcnQ6dixiYXNlOlUsZ2xvYjpGLGlzQnJhY2U6bSxpc0JyYWNrZXQ6VCxpc0dsb2I6TCxpc0V4dGdsb2I6Tyxpc0dsb2JzdGFyOncsbmVnYXRlZDpJfTtpZihyLnRva2Vucz09PXRydWUpe1EubWF4RGVwdGg9MDtpZighaXNQYXRoU2VwYXJhdG9yKEcpKXt4LnB1c2goRCl9US50b2tlbnM9eH1pZihyLnBhcnRzPT09dHJ1ZXx8ci50b2tlbnM9PT10cnVlKXtsZXQgdDtmb3IobGV0IG49MDtuPGQubGVuZ3RoO24rKyl7Y29uc3QgdT10P3QrMTp2O2NvbnN0IHM9ZFtuXTtjb25zdCBvPWUuc2xpY2UodSxzKTtpZihyLnRva2Vucyl7aWYobj09PTAmJnYhPT0wKXt4W25dLmlzUHJlZml4PXRydWU7eFtuXS52YWx1ZT1LfWVsc2V7eFtuXS52YWx1ZT1vfWRlcHRoKHhbbl0pO1EubWF4RGVwdGgrPXhbbl0uZGVwdGh9aWYobiE9PTB8fG8hPT1cIlwiKXtiLnB1c2gobyl9dD1zfWlmKHQmJnQrMTxlLmxlbmd0aCl7Y29uc3Qgbj1lLnNsaWNlKHQrMSk7Yi5wdXNoKG4pO2lmKHIudG9rZW5zKXt4W3gubGVuZ3RoLTFdLnZhbHVlPW47ZGVwdGgoeFt4Lmxlbmd0aC0xXSk7US5tYXhEZXB0aCs9eFt4Lmxlbmd0aC0xXS5kZXB0aH19US5zbGFzaGVzPWQ7US5wYXJ0cz1ifXJldHVybiBRfTtlLmV4cG9ydHM9c2Nhbn0sNTEzOihlLHQscik9Pntjb25zdCBuPXIoMTcpO2NvbnN0IHU9cHJvY2Vzcy5wbGF0Zm9ybT09PVwid2luMzJcIjtjb25zdHtSRUdFWF9CQUNLU0xBU0g6cyxSRUdFWF9SRU1PVkVfQkFDS1NMQVNIOm8sUkVHRVhfU1BFQ0lBTF9DSEFSUzppLFJFR0VYX1NQRUNJQUxfQ0hBUlNfR0xPQkFMOmF9PXIoMzU2KTt0LmlzT2JqZWN0PWU9PmUhPT1udWxsJiZ0eXBlb2YgZT09PVwib2JqZWN0XCImJiFBcnJheS5pc0FycmF5KGUpO3QuaGFzUmVnZXhDaGFycz1lPT5pLnRlc3QoZSk7dC5pc1JlZ2V4Q2hhcj1lPT5lLmxlbmd0aD09PTEmJnQuaGFzUmVnZXhDaGFycyhlKTt0LmVzY2FwZVJlZ2V4PWU9PmUucmVwbGFjZShhLFwiXFxcXCQxXCIpO3QudG9Qb3NpeFNsYXNoZXM9ZT0+ZS5yZXBsYWNlKHMsXCIvXCIpO3QucmVtb3ZlQmFja3NsYXNoZXM9ZT0+ZS5yZXBsYWNlKG8sKGU9PmU9PT1cIlxcXFxcIj9cIlwiOmUpKTt0LnN1cHBvcnRzTG9va2JlaGluZHM9KCk9Pntjb25zdCBlPXByb2Nlc3MudmVyc2lvbi5zbGljZSgxKS5zcGxpdChcIi5cIikubWFwKE51bWJlcik7aWYoZS5sZW5ndGg9PT0zJiZlWzBdPj05fHxlWzBdPT09OCYmZVsxXT49MTApe3JldHVybiB0cnVlfXJldHVybiBmYWxzZX07dC5pc1dpbmRvd3M9ZT0+e2lmKGUmJnR5cGVvZiBlLndpbmRvd3M9PT1cImJvb2xlYW5cIil7cmV0dXJuIGUud2luZG93c31yZXR1cm4gdT09PXRydWV8fG4uc2VwPT09XCJcXFxcXCJ9O3QuZXNjYXBlTGFzdD0oZSxyLG4pPT57Y29uc3QgdT1lLmxhc3RJbmRleE9mKHIsbik7aWYodT09PS0xKXJldHVybiBlO2lmKGVbdS0xXT09PVwiXFxcXFwiKXJldHVybiB0LmVzY2FwZUxhc3QoZSxyLHUtMSk7cmV0dXJuYCR7ZS5zbGljZSgwLHUpfVxcXFwke2Uuc2xpY2UodSl9YH07dC5yZW1vdmVQcmVmaXg9KGUsdD17fSk9PntsZXQgcj1lO2lmKHIuc3RhcnRzV2l0aChcIi4vXCIpKXtyPXIuc2xpY2UoMik7dC5wcmVmaXg9XCIuL1wifXJldHVybiByfTt0LndyYXBPdXRwdXQ9KGUsdD17fSxyPXt9KT0+e2NvbnN0IG49ci5jb250YWlucz9cIlwiOlwiXlwiO2NvbnN0IHU9ci5jb250YWlucz9cIlwiOlwiJFwiO2xldCBzPWAke259KD86JHtlfSkke3V9YDtpZih0Lm5lZ2F0ZWQ9PT10cnVlKXtzPWAoPzpeKD8hJHtzfSkuKiQpYH1yZXR1cm4gc319LDQ5MjooZSx0LHIpPT57XG4vKiFcbiAqIHRvLXJlZ2V4LXJhbmdlIDxodHRwczovL2dpdGh1Yi5jb20vbWljcm9tYXRjaC90by1yZWdleC1yYW5nZT5cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUtcHJlc2VudCwgSm9uIFNjaGxpbmtlcnQuXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKi9cbmNvbnN0IG49cigzNTcpO2NvbnN0IHRvUmVnZXhSYW5nZT0oZSx0LHIpPT57aWYobihlKT09PWZhbHNlKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwidG9SZWdleFJhbmdlOiBleHBlY3RlZCB0aGUgZmlyc3QgYXJndW1lbnQgdG8gYmUgYSBudW1iZXJcIil9aWYodD09PXZvaWQgMHx8ZT09PXQpe3JldHVybiBTdHJpbmcoZSl9aWYobih0KT09PWZhbHNlKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwidG9SZWdleFJhbmdlOiBleHBlY3RlZCB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIGEgbnVtYmVyLlwiKX1sZXQgdT17cmVsYXhaZXJvczp0cnVlLC4uLnJ9O2lmKHR5cGVvZiB1LnN0cmljdFplcm9zPT09XCJib29sZWFuXCIpe3UucmVsYXhaZXJvcz11LnN0cmljdFplcm9zPT09ZmFsc2V9bGV0IHM9U3RyaW5nKHUucmVsYXhaZXJvcyk7bGV0IG89U3RyaW5nKHUuc2hvcnRoYW5kKTtsZXQgaT1TdHJpbmcodS5jYXB0dXJlKTtsZXQgYT1TdHJpbmcodS53cmFwKTtsZXQgbD1lK1wiOlwiK3QrXCI9XCIrcytvK2krYTtpZih0b1JlZ2V4UmFuZ2UuY2FjaGUuaGFzT3duUHJvcGVydHkobCkpe3JldHVybiB0b1JlZ2V4UmFuZ2UuY2FjaGVbbF0ucmVzdWx0fWxldCBjPU1hdGgubWluKGUsdCk7bGV0IHA9TWF0aC5tYXgoZSx0KTtpZihNYXRoLmFicyhjLXApPT09MSl7bGV0IHI9ZStcInxcIit0O2lmKHUuY2FwdHVyZSl7cmV0dXJuYCgke3J9KWB9aWYodS53cmFwPT09ZmFsc2Upe3JldHVybiByfXJldHVybmAoPzoke3J9KWB9bGV0IGY9aGFzUGFkZGluZyhlKXx8aGFzUGFkZGluZyh0KTtsZXQgQT17bWluOmUsbWF4OnQsYTpjLGI6cH07bGV0IFI9W107bGV0IF89W107aWYoZil7QS5pc1BhZGRlZD1mO0EubWF4TGVuPVN0cmluZyhBLm1heCkubGVuZ3RofWlmKGM8MCl7bGV0IGU9cDwwP01hdGguYWJzKHApOjE7Xz1zcGxpdFRvUGF0dGVybnMoZSxNYXRoLmFicyhjKSxBLHUpO2M9QS5hPTB9aWYocD49MCl7Uj1zcGxpdFRvUGF0dGVybnMoYyxwLEEsdSl9QS5uZWdhdGl2ZXM9XztBLnBvc2l0aXZlcz1SO0EucmVzdWx0PWNvbGxhdGVQYXR0ZXJucyhfLFIsdSk7aWYodS5jYXB0dXJlPT09dHJ1ZSl7QS5yZXN1bHQ9YCgke0EucmVzdWx0fSlgfWVsc2UgaWYodS53cmFwIT09ZmFsc2UmJlIubGVuZ3RoK18ubGVuZ3RoPjEpe0EucmVzdWx0PWAoPzoke0EucmVzdWx0fSlgfXRvUmVnZXhSYW5nZS5jYWNoZVtsXT1BO3JldHVybiBBLnJlc3VsdH07ZnVuY3Rpb24gY29sbGF0ZVBhdHRlcm5zKGUsdCxyKXtsZXQgbj1maWx0ZXJQYXR0ZXJucyhlLHQsXCItXCIsZmFsc2Uscil8fFtdO2xldCB1PWZpbHRlclBhdHRlcm5zKHQsZSxcIlwiLGZhbHNlLHIpfHxbXTtsZXQgcz1maWx0ZXJQYXR0ZXJucyhlLHQsXCItP1wiLHRydWUscil8fFtdO2xldCBvPW4uY29uY2F0KHMpLmNvbmNhdCh1KTtyZXR1cm4gby5qb2luKFwifFwiKX1mdW5jdGlvbiBzcGxpdFRvUmFuZ2VzKGUsdCl7bGV0IHI9MTtsZXQgbj0xO2xldCB1PWNvdW50TmluZXMoZSxyKTtsZXQgcz1uZXcgU2V0KFt0XSk7d2hpbGUoZTw9dSYmdTw9dCl7cy5hZGQodSk7cis9MTt1PWNvdW50TmluZXMoZSxyKX11PWNvdW50WmVyb3ModCsxLG4pLTE7d2hpbGUoZTx1JiZ1PD10KXtzLmFkZCh1KTtuKz0xO3U9Y291bnRaZXJvcyh0KzEsbiktMX1zPVsuLi5zXTtzLnNvcnQoY29tcGFyZSk7cmV0dXJuIHN9ZnVuY3Rpb24gcmFuZ2VUb1BhdHRlcm4oZSx0LHIpe2lmKGU9PT10KXtyZXR1cm57cGF0dGVybjplLGNvdW50OltdLGRpZ2l0czowfX1sZXQgbj16aXAoZSx0KTtsZXQgdT1uLmxlbmd0aDtsZXQgcz1cIlwiO2xldCBvPTA7Zm9yKGxldCBlPTA7ZTx1O2UrKyl7bGV0W3QsdV09bltlXTtpZih0PT09dSl7cys9dH1lbHNlIGlmKHQhPT1cIjBcInx8dSE9PVwiOVwiKXtzKz10b0NoYXJhY3RlckNsYXNzKHQsdSxyKX1lbHNle28rK319aWYobyl7cys9ci5zaG9ydGhhbmQ9PT10cnVlP1wiXFxcXGRcIjpcIlswLTldXCJ9cmV0dXJue3BhdHRlcm46cyxjb3VudDpbb10sZGlnaXRzOnV9fWZ1bmN0aW9uIHNwbGl0VG9QYXR0ZXJucyhlLHQscixuKXtsZXQgdT1zcGxpdFRvUmFuZ2VzKGUsdCk7bGV0IHM9W107bGV0IG89ZTtsZXQgaTtmb3IobGV0IGU9MDtlPHUubGVuZ3RoO2UrKyl7bGV0IHQ9dVtlXTtsZXQgYT1yYW5nZVRvUGF0dGVybihTdHJpbmcobyksU3RyaW5nKHQpLG4pO2xldCBsPVwiXCI7aWYoIXIuaXNQYWRkZWQmJmkmJmkucGF0dGVybj09PWEucGF0dGVybil7aWYoaS5jb3VudC5sZW5ndGg+MSl7aS5jb3VudC5wb3AoKX1pLmNvdW50LnB1c2goYS5jb3VudFswXSk7aS5zdHJpbmc9aS5wYXR0ZXJuK3RvUXVhbnRpZmllcihpLmNvdW50KTtvPXQrMTtjb250aW51ZX1pZihyLmlzUGFkZGVkKXtsPXBhZFplcm9zKHQscixuKX1hLnN0cmluZz1sK2EucGF0dGVybit0b1F1YW50aWZpZXIoYS5jb3VudCk7cy5wdXNoKGEpO289dCsxO2k9YX1yZXR1cm4gc31mdW5jdGlvbiBmaWx0ZXJQYXR0ZXJucyhlLHQscixuLHUpe2xldCBzPVtdO2ZvcihsZXQgdSBvZiBlKXtsZXR7c3RyaW5nOmV9PXU7aWYoIW4mJiFjb250YWlucyh0LFwic3RyaW5nXCIsZSkpe3MucHVzaChyK2UpfWlmKG4mJmNvbnRhaW5zKHQsXCJzdHJpbmdcIixlKSl7cy5wdXNoKHIrZSl9fXJldHVybiBzfWZ1bmN0aW9uIHppcChlLHQpe2xldCByPVtdO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7bisrKXIucHVzaChbZVtuXSx0W25dXSk7cmV0dXJuIHJ9ZnVuY3Rpb24gY29tcGFyZShlLHQpe3JldHVybiBlPnQ/MTp0PmU/LTE6MH1mdW5jdGlvbiBjb250YWlucyhlLHQscil7cmV0dXJuIGUuc29tZSgoZT0+ZVt0XT09PXIpKX1mdW5jdGlvbiBjb3VudE5pbmVzKGUsdCl7cmV0dXJuIE51bWJlcihTdHJpbmcoZSkuc2xpY2UoMCwtdCkrXCI5XCIucmVwZWF0KHQpKX1mdW5jdGlvbiBjb3VudFplcm9zKGUsdCl7cmV0dXJuIGUtZSVNYXRoLnBvdygxMCx0KX1mdW5jdGlvbiB0b1F1YW50aWZpZXIoZSl7bGV0W3Q9MCxyPVwiXCJdPWU7aWYocnx8dD4xKXtyZXR1cm5geyR7dCsocj9cIixcIityOlwiXCIpfX1gfXJldHVyblwiXCJ9ZnVuY3Rpb24gdG9DaGFyYWN0ZXJDbGFzcyhlLHQscil7cmV0dXJuYFske2V9JHt0LWU9PT0xP1wiXCI6XCItXCJ9JHt0fV1gfWZ1bmN0aW9uIGhhc1BhZGRpbmcoZSl7cmV0dXJuL14tPygwKylcXGQvLnRlc3QoZSl9ZnVuY3Rpb24gcGFkWmVyb3MoZSx0LHIpe2lmKCF0LmlzUGFkZGVkKXtyZXR1cm4gZX1sZXQgbj1NYXRoLmFicyh0Lm1heExlbi1TdHJpbmcoZSkubGVuZ3RoKTtsZXQgdT1yLnJlbGF4WmVyb3MhPT1mYWxzZTtzd2l0Y2gobil7Y2FzZSAwOnJldHVyblwiXCI7Y2FzZSAxOnJldHVybiB1P1wiMD9cIjpcIjBcIjtjYXNlIDI6cmV0dXJuIHU/XCIwezAsMn1cIjpcIjAwXCI7ZGVmYXVsdDp7cmV0dXJuIHU/YDB7MCwke259fWA6YDB7JHtufX1gfX19dG9SZWdleFJhbmdlLmNhY2hlPXt9O3RvUmVnZXhSYW5nZS5jbGVhckNhY2hlPSgpPT50b1JlZ2V4UmFuZ2UuY2FjaGU9e307ZS5leHBvcnRzPXRvUmVnZXhSYW5nZX0sMTc6ZT0+e2UuZXhwb3J0cz1yZXF1aXJlKFwicGF0aFwiKX0sODM3OmU9PntlLmV4cG9ydHM9cmVxdWlyZShcInV0aWxcIil9fTt2YXIgdD17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHIpe3ZhciBuPXRbcl07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgdT10W3JdPXtleHBvcnRzOnt9fTt2YXIgcz10cnVlO3RyeXtlW3JdKHUsdS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO3M9ZmFsc2V9ZmluYWxseXtpZihzKWRlbGV0ZSB0W3JdfXJldHVybiB1LmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciByPV9fbmNjd3Bja19yZXF1aXJlX18oOTcxKTttb2R1bGUuZXhwb3J0cz1yfSkoKTsiXSwibmFtZXMiOlsiZSIsInQiLCJyIiwibiIsInUiLCJzIiwibyIsImJyYWNlcyIsIkFycmF5IiwiaXNBcnJheSIsImNyZWF0ZSIsInB1c2giLCJjb25jYXQiLCJleHBhbmQiLCJub2R1cGVzIiwiU2V0IiwicGFyc2UiLCJzdHJpbmdpZnkiLCJjb21waWxlIiwibm9lbXB0eSIsImZpbHRlciIsIkJvb2xlYW4iLCJsZW5ndGgiLCJleHBvcnRzIiwid2FsayIsImlzSW52YWxpZEJyYWNlIiwiaW52YWxpZCIsImVzY2FwZUludmFsaWQiLCJpIiwiYSIsImwiLCJpc09wZW4iLCJ2YWx1ZSIsImlzQ2xvc2UiLCJ0eXBlIiwicHJldiIsIm5vZGVzIiwicmFuZ2VzIiwicmVkdWNlIiwid3JhcCIsInRvUmVnZXgiLCJNQVhfTEVOR1RIIiwiQ0hBUl8wIiwiQ0hBUl85IiwiQ0hBUl9VUFBFUkNBU0VfQSIsIkNIQVJfTE9XRVJDQVNFX0EiLCJDSEFSX1VQUEVSQ0FTRV9aIiwiQ0hBUl9MT1dFUkNBU0VfWiIsIkNIQVJfTEVGVF9QQVJFTlRIRVNFUyIsIkNIQVJfUklHSFRfUEFSRU5USEVTRVMiLCJDSEFSX0FTVEVSSVNLIiwiQ0hBUl9BTVBFUlNBTkQiLCJDSEFSX0FUIiwiQ0hBUl9CQUNLU0xBU0giLCJDSEFSX0JBQ0tUSUNLIiwiQ0hBUl9DQVJSSUFHRV9SRVRVUk4iLCJDSEFSX0NJUkNVTUZMRVhfQUNDRU5UIiwiQ0hBUl9DT0xPTiIsIkNIQVJfQ09NTUEiLCJDSEFSX0RPTExBUiIsIkNIQVJfRE9UIiwiQ0hBUl9ET1VCTEVfUVVPVEUiLCJDSEFSX0VRVUFMIiwiQ0hBUl9FWENMQU1BVElPTl9NQVJLIiwiQ0hBUl9GT1JNX0ZFRUQiLCJDSEFSX0ZPUldBUkRfU0xBU0giLCJDSEFSX0hBU0giLCJDSEFSX0hZUEhFTl9NSU5VUyIsIkNIQVJfTEVGVF9BTkdMRV9CUkFDS0VUIiwiQ0hBUl9MRUZUX0NVUkxZX0JSQUNFIiwiQ0hBUl9MRUZUX1NRVUFSRV9CUkFDS0VUIiwiQ0hBUl9MSU5FX0ZFRUQiLCJDSEFSX05PX0JSRUFLX1NQQUNFIiwiQ0hBUl9QRVJDRU5UIiwiQ0hBUl9QTFVTIiwiQ0hBUl9RVUVTVElPTl9NQVJLIiwiQ0hBUl9SSUdIVF9BTkdMRV9CUkFDS0VUIiwiQ0hBUl9SSUdIVF9DVVJMWV9CUkFDRSIsIkNIQVJfUklHSFRfU1FVQVJFX0JSQUNLRVQiLCJDSEFSX1NFTUlDT0xPTiIsIkNIQVJfU0lOR0xFX1FVT1RFIiwiQ0hBUl9TUEFDRSIsIkNIQVJfVEFCIiwiQ0hBUl9VTkRFUlNDT1JFIiwiQ0hBUl9WRVJUSUNBTF9MSU5FIiwiQ0hBUl9aRVJPX1dJRFRIX05PQlJFQUtfU1BBQ0UiLCJhcHBlbmQiLCJmbGF0dGVuIiwibWFwIiwicmFuZ2VMaW1pdCIsInF1ZXVlIiwicGFyZW50IiwiZG9sbGFyIiwicG9wIiwiZXhjZWVkc0xpbWl0Iiwic3RlcCIsIlJhbmdlRXJyb3IiLCJlbmNsb3NlQnJhY2UiLCJjIiwicCIsImYiLCJBIiwiUiIsIl8iLCJoIiwiZyIsIkUiLCJUeXBlRXJyb3IiLCJDIiwibWF4TGVuZ3RoIiwiTWF0aCIsIm1pbiIsIlN5bnRheEVycm9yIiwieSIsImlucHV0IiwiZCIsIngiLCJiIiwiUyIsIkgiLCJ2IiwiJCIsIm0iLCJUIiwiYWR2YW5jZSIsImtlZXBFc2NhcGluZyIsImtlZXBRdW90ZXMiLCJzbGljZSIsIm9wZW4iLCJjbG9zZSIsImRlcHRoIiwiY29tbWFzIiwic2hpZnQiLCJyYW5nZSIsImFyZ3MiLCJmb3JFYWNoIiwiaW5kZXhPZiIsInNwbGljZSIsImlzT3Blbk9yQ2xvc2UiLCJpc0ludGVnZXIiLCJOdW1iZXIiLCJ0cmltIiwiZmluZCIsImVzY2FwZU5vZGUiLCJlc2NhcGVkIiwiZmxhdCIsImlzT2JqZWN0IiwidHJhbnNmb3JtIiwiU3RyaW5nIiwiaXNWYWxpZFZhbHVlIiwiaXNOdW1iZXIiLCJ6ZXJvcyIsInBhZCIsInBhZFN0YXJ0IiwidG9NYXhMZW4iLCJ0b1NlcXVlbmNlIiwibmVnYXRpdmVzIiwic29ydCIsInBvc2l0aXZlcyIsImNhcHR1cmUiLCJqb2luIiwidG9SYW5nZSIsImZyb21DaGFyQ29kZSIsInJhbmdlRXJyb3IiLCJpbnNwZWN0IiwiaW52YWxpZFJhbmdlIiwic3RyaWN0UmFuZ2VzIiwiaW52YWxpZFN0ZXAiLCJmaWxsTnVtYmVycyIsIm1heCIsImFicyIsImZpbGxMZXR0ZXJzIiwiY2hhckNvZGVBdCIsIm9wdGlvbnMiLCJmaWxsIiwiaXNGaW5pdGUiLCJpc0VtcHR5U3RyaW5nIiwibWljcm9tYXRjaCIsIm9uUmVzdWx0IiwiYWRkIiwib3V0cHV0Iiwic3RhdGUiLCJuZWdhdGVkIiwibmVnYXRlZEV4dGdsb2IiLCJpc01hdGNoIiwiZGVsZXRlIiwiaGFzIiwiZmFpbGdsb2IiLCJFcnJvciIsIm5vbnVsbCIsIm51bGxnbG9iIiwidW5lc2NhcGUiLCJyZXBsYWNlIiwibWF0Y2giLCJtYXRjaGVyIiwiYW55Iiwibm90IiwiaW5jbHVkZXMiLCJjb250YWlucyIsInNvbWUiLCJzdGFydHNXaXRoIiwibWF0Y2hLZXlzIiwiT2JqZWN0Iiwia2V5cyIsImV2ZXJ5IiwiYWxsIiwiaXNXaW5kb3dzIiwibWFrZVJlIiwiZXhlYyIsInRvUG9zaXhTbGFzaGVzIiwic2NhbiIsIm5vYnJhY2UiLCJ0ZXN0IiwiYnJhY2VFeHBhbmQiLCJET1RfTElURVJBTCIsIlBMVVNfTElURVJBTCIsIlFNQVJLX0xJVEVSQUwiLCJTTEFTSF9MSVRFUkFMIiwiT05FX0NIQVIiLCJRTUFSSyIsIkVORF9BTkNIT1IiLCJET1RTX1NMQVNIIiwiTk9fRE9UIiwiTk9fRE9UUyIsIk5PX0RPVF9TTEFTSCIsIk5PX0RPVFNfU0xBU0giLCJRTUFSS19OT19ET1QiLCJTVEFSIiwiU1RBUlRfQU5DSE9SIiwiYWxudW0iLCJhbHBoYSIsImFzY2lpIiwiYmxhbmsiLCJjbnRybCIsImRpZ2l0IiwiZ3JhcGgiLCJsb3dlciIsInByaW50IiwicHVuY3QiLCJzcGFjZSIsInVwcGVyIiwid29yZCIsInhkaWdpdCIsIlBPU0lYX1JFR0VYX1NPVVJDRSIsIlJFR0VYX0JBQ0tTTEFTSCIsIlJFR0VYX05PTl9TUEVDSUFMX0NIQVJTIiwiUkVHRVhfU1BFQ0lBTF9DSEFSUyIsIlJFR0VYX1NQRUNJQUxfQ0hBUlNfQkFDS1JFRiIsIlJFR0VYX1NQRUNJQUxfQ0hBUlNfR0xPQkFMIiwiUkVHRVhfUkVNT1ZFX0JBQ0tTTEFTSCIsIlJFUExBQ0VNRU5UUyIsIkNIQVJfQkFDS1dBUkRfU0xBU0giLCJDSEFSX0dSQVZFX0FDQ0VOVCIsIlNFUCIsInNlcCIsImV4dGdsb2JDaGFycyIsImdsb2JDaGFycyIsImV4cGFuZFJhbmdlIiwiUmVnRXhwIiwiZXNjYXBlUmVnZXgiLCJzeW50YXhFcnJvciIsInByZXBlbmQiLCJnbG9ic3RhciIsImRvdCIsIkwiLCJPIiwidyIsImJhc2giLCJub2V4dCIsIm5vZXh0Z2xvYiIsIk4iLCJpbmRleCIsInN0YXJ0IiwiY29uc3VtZWQiLCJwcmVmaXgiLCJiYWNrdHJhY2siLCJicmFja2V0cyIsInBhcmVucyIsInF1b3RlcyIsInRva2VucyIsInJlbW92ZVByZWZpeCIsImsiLCJJIiwiTSIsIlAiLCJCIiwiZW9zIiwiRyIsInBlZWsiLCJEIiwicmVtYWluaW5nIiwiY29uc3VtZSIsIm5lZ2F0ZSIsImluY3JlbWVudCIsImRlY3JlbWVudCIsImV4dGdsb2IiLCJpbm5lciIsImV4dGdsb2JPcGVuIiwiY29uZGl0aW9ucyIsImV4dGdsb2JDbG9zZSIsImZhc3RwYXRocyIsInJlcGVhdCIsIndyYXBPdXRwdXQiLCJwb3NpeCIsImxhc3RJbmRleE9mIiwic3RyaWN0QnJhY2tldHMiLCJub2JyYWNrZXQiLCJsaXRlcmFsQnJhY2tldHMiLCJoYXNSZWdleENoYXJzIiwib3V0cHV0SW5kZXgiLCJ0b2tlbnNJbmRleCIsImRvdHMiLCJ1bnNoaWZ0IiwiY29tbWEiLCJzdXBwb3J0c0xvb2tiZWhpbmRzIiwibm9uZWdhdGUiLCJyZWdleCIsInN0YXIiLCJub2dsb2JzdGFyIiwic3RyaWN0U2xhc2hlcyIsImVzY2FwZUxhc3QiLCJzdWZmaXgiLCJwaWNvbWF0Y2giLCJhcnJheU1hdGNoZXIiLCJjb21waWxlUmUiLCJpc0lnbm9yZWQiLCJpZ25vcmUiLCJvbk1hdGNoIiwiZ2xvYiIsIm9uSWdub3JlIiwiZm9ybWF0IiwibWF0Y2hCYXNlIiwiYmFzZW5hbWUiLCJ1bmRlZmluZWQiLCJmbGFncyIsIm5vY2FzZSIsImRlYnVnIiwiY29uc3RhbnRzIiwiaXNQYXRoU2VwYXJhdG9yIiwiaXNQcmVmaXgiLCJpc0dsb2JzdGFyIiwiSW5maW5pdHkiLCJwYXJ0cyIsInNjYW5Ub0VuZCIsImlzR2xvYiIsImJhY2tzbGFzaGVzIiwiaXNCcmFjZSIsImlzRXh0Z2xvYiIsImlzQnJhY2tldCIsIm5vcGFyZW4iLCJVIiwiSyIsIkYiLCJyZW1vdmVCYWNrc2xhc2hlcyIsIlEiLCJiYXNlIiwibWF4RGVwdGgiLCJzbGFzaGVzIiwicHJvY2VzcyIsInBsYXRmb3JtIiwiaXNSZWdleENoYXIiLCJ2ZXJzaW9uIiwic3BsaXQiLCJ3aW5kb3dzIiwidG9SZWdleFJhbmdlIiwicmVsYXhaZXJvcyIsInN0cmljdFplcm9zIiwic2hvcnRoYW5kIiwiY2FjaGUiLCJoYXNPd25Qcm9wZXJ0eSIsInJlc3VsdCIsImhhc1BhZGRpbmciLCJpc1BhZGRlZCIsIm1heExlbiIsInNwbGl0VG9QYXR0ZXJucyIsImNvbGxhdGVQYXR0ZXJucyIsImZpbHRlclBhdHRlcm5zIiwic3BsaXRUb1JhbmdlcyIsImNvdW50TmluZXMiLCJjb3VudFplcm9zIiwiY29tcGFyZSIsInJhbmdlVG9QYXR0ZXJuIiwicGF0dGVybiIsImNvdW50IiwiZGlnaXRzIiwiemlwIiwidG9DaGFyYWN0ZXJDbGFzcyIsInN0cmluZyIsInRvUXVhbnRpZmllciIsInBhZFplcm9zIiwicG93IiwiY2xlYXJDYWNoZSIsInJlcXVpcmUiLCJfX25jY3dwY2tfcmVxdWlyZV9fIiwiYWIiLCJfX2Rpcm5hbWUiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/micromatch/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/path-browserify/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/path-browserify/index.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("var __dirname = \"/\";\n\n(function() {\n    \"use strict\";\n    var e = {\n        114: function(e) {\n            function assertPath(e) {\n                if (typeof e !== \"string\") {\n                    throw new TypeError(\"Path must be a string. Received \" + JSON.stringify(e));\n                }\n            }\n            function normalizeStringPosix(e, r) {\n                var t = \"\";\n                var i = 0;\n                var n = -1;\n                var a = 0;\n                var f;\n                for(var l = 0; l <= e.length; ++l){\n                    if (l < e.length) f = e.charCodeAt(l);\n                    else if (f === 47) break;\n                    else f = 47;\n                    if (f === 47) {\n                        if (n === l - 1 || a === 1) {} else if (n !== l - 1 && a === 2) {\n                            if (t.length < 2 || i !== 2 || t.charCodeAt(t.length - 1) !== 46 || t.charCodeAt(t.length - 2) !== 46) {\n                                if (t.length > 2) {\n                                    var s = t.lastIndexOf(\"/\");\n                                    if (s !== t.length - 1) {\n                                        if (s === -1) {\n                                            t = \"\";\n                                            i = 0;\n                                        } else {\n                                            t = t.slice(0, s);\n                                            i = t.length - 1 - t.lastIndexOf(\"/\");\n                                        }\n                                        n = l;\n                                        a = 0;\n                                        continue;\n                                    }\n                                } else if (t.length === 2 || t.length === 1) {\n                                    t = \"\";\n                                    i = 0;\n                                    n = l;\n                                    a = 0;\n                                    continue;\n                                }\n                            }\n                            if (r) {\n                                if (t.length > 0) t += \"/..\";\n                                else t = \"..\";\n                                i = 2;\n                            }\n                        } else {\n                            if (t.length > 0) t += \"/\" + e.slice(n + 1, l);\n                            else t = e.slice(n + 1, l);\n                            i = l - n - 1;\n                        }\n                        n = l;\n                        a = 0;\n                    } else if (f === 46 && a !== -1) {\n                        ++a;\n                    } else {\n                        a = -1;\n                    }\n                }\n                return t;\n            }\n            function _format(e, r) {\n                var t = r.dir || r.root;\n                var i = r.base || (r.name || \"\") + (r.ext || \"\");\n                if (!t) {\n                    return i;\n                }\n                if (t === r.root) {\n                    return t + i;\n                }\n                return t + e + i;\n            }\n            var r = {\n                resolve: function resolve() {\n                    var e = \"\";\n                    var r = false;\n                    var t;\n                    for(var i = arguments.length - 1; i >= -1 && !r; i--){\n                        var n;\n                        if (i >= 0) n = arguments[i];\n                        else {\n                            if (t === undefined) t = \"\";\n                            n = t;\n                        }\n                        assertPath(n);\n                        if (n.length === 0) {\n                            continue;\n                        }\n                        e = n + \"/\" + e;\n                        r = n.charCodeAt(0) === 47;\n                    }\n                    e = normalizeStringPosix(e, !r);\n                    if (r) {\n                        if (e.length > 0) return \"/\" + e;\n                        else return \"/\";\n                    } else if (e.length > 0) {\n                        return e;\n                    } else {\n                        return \".\";\n                    }\n                },\n                normalize: function normalize(e) {\n                    assertPath(e);\n                    if (e.length === 0) return \".\";\n                    var r = e.charCodeAt(0) === 47;\n                    var t = e.charCodeAt(e.length - 1) === 47;\n                    e = normalizeStringPosix(e, !r);\n                    if (e.length === 0 && !r) e = \".\";\n                    if (e.length > 0 && t) e += \"/\";\n                    if (r) return \"/\" + e;\n                    return e;\n                },\n                isAbsolute: function isAbsolute(e) {\n                    assertPath(e);\n                    return e.length > 0 && e.charCodeAt(0) === 47;\n                },\n                join: function join() {\n                    if (arguments.length === 0) return \".\";\n                    var e;\n                    for(var t = 0; t < arguments.length; ++t){\n                        var i = arguments[t];\n                        assertPath(i);\n                        if (i.length > 0) {\n                            if (e === undefined) e = i;\n                            else e += \"/\" + i;\n                        }\n                    }\n                    if (e === undefined) return \".\";\n                    return r.normalize(e);\n                },\n                relative: function relative(e, t) {\n                    assertPath(e);\n                    assertPath(t);\n                    if (e === t) return \"\";\n                    e = r.resolve(e);\n                    t = r.resolve(t);\n                    if (e === t) return \"\";\n                    var i = 1;\n                    for(; i < e.length; ++i){\n                        if (e.charCodeAt(i) !== 47) break;\n                    }\n                    var n = e.length;\n                    var a = n - i;\n                    var f = 1;\n                    for(; f < t.length; ++f){\n                        if (t.charCodeAt(f) !== 47) break;\n                    }\n                    var l = t.length;\n                    var s = l - f;\n                    var o = a < s ? a : s;\n                    var u = -1;\n                    var h = 0;\n                    for(; h <= o; ++h){\n                        if (h === o) {\n                            if (s > o) {\n                                if (t.charCodeAt(f + h) === 47) {\n                                    return t.slice(f + h + 1);\n                                } else if (h === 0) {\n                                    return t.slice(f + h);\n                                }\n                            } else if (a > o) {\n                                if (e.charCodeAt(i + h) === 47) {\n                                    u = h;\n                                } else if (h === 0) {\n                                    u = 0;\n                                }\n                            }\n                            break;\n                        }\n                        var c = e.charCodeAt(i + h);\n                        var v = t.charCodeAt(f + h);\n                        if (c !== v) break;\n                        else if (c === 47) u = h;\n                    }\n                    var g = \"\";\n                    for(h = i + u + 1; h <= n; ++h){\n                        if (h === n || e.charCodeAt(h) === 47) {\n                            if (g.length === 0) g += \"..\";\n                            else g += \"/..\";\n                        }\n                    }\n                    if (g.length > 0) return g + t.slice(f + u);\n                    else {\n                        f += u;\n                        if (t.charCodeAt(f) === 47) ++f;\n                        return t.slice(f);\n                    }\n                },\n                _makeLong: function _makeLong(e) {\n                    return e;\n                },\n                dirname: function dirname(e) {\n                    assertPath(e);\n                    if (e.length === 0) return \".\";\n                    var r = e.charCodeAt(0);\n                    var t = r === 47;\n                    var i = -1;\n                    var n = true;\n                    for(var a = e.length - 1; a >= 1; --a){\n                        r = e.charCodeAt(a);\n                        if (r === 47) {\n                            if (!n) {\n                                i = a;\n                                break;\n                            }\n                        } else {\n                            n = false;\n                        }\n                    }\n                    if (i === -1) return t ? \"/\" : \".\";\n                    if (t && i === 1) return \"//\";\n                    return e.slice(0, i);\n                },\n                basename: function basename(e, r) {\n                    if (r !== undefined && typeof r !== \"string\") throw new TypeError('\"ext\" argument must be a string');\n                    assertPath(e);\n                    var t = 0;\n                    var i = -1;\n                    var n = true;\n                    var a;\n                    if (r !== undefined && r.length > 0 && r.length <= e.length) {\n                        if (r.length === e.length && r === e) return \"\";\n                        var f = r.length - 1;\n                        var l = -1;\n                        for(a = e.length - 1; a >= 0; --a){\n                            var s = e.charCodeAt(a);\n                            if (s === 47) {\n                                if (!n) {\n                                    t = a + 1;\n                                    break;\n                                }\n                            } else {\n                                if (l === -1) {\n                                    n = false;\n                                    l = a + 1;\n                                }\n                                if (f >= 0) {\n                                    if (s === r.charCodeAt(f)) {\n                                        if (--f === -1) {\n                                            i = a;\n                                        }\n                                    } else {\n                                        f = -1;\n                                        i = l;\n                                    }\n                                }\n                            }\n                        }\n                        if (t === i) i = l;\n                        else if (i === -1) i = e.length;\n                        return e.slice(t, i);\n                    } else {\n                        for(a = e.length - 1; a >= 0; --a){\n                            if (e.charCodeAt(a) === 47) {\n                                if (!n) {\n                                    t = a + 1;\n                                    break;\n                                }\n                            } else if (i === -1) {\n                                n = false;\n                                i = a + 1;\n                            }\n                        }\n                        if (i === -1) return \"\";\n                        return e.slice(t, i);\n                    }\n                },\n                extname: function extname(e) {\n                    assertPath(e);\n                    var r = -1;\n                    var t = 0;\n                    var i = -1;\n                    var n = true;\n                    var a = 0;\n                    for(var f = e.length - 1; f >= 0; --f){\n                        var l = e.charCodeAt(f);\n                        if (l === 47) {\n                            if (!n) {\n                                t = f + 1;\n                                break;\n                            }\n                            continue;\n                        }\n                        if (i === -1) {\n                            n = false;\n                            i = f + 1;\n                        }\n                        if (l === 46) {\n                            if (r === -1) r = f;\n                            else if (a !== 1) a = 1;\n                        } else if (r !== -1) {\n                            a = -1;\n                        }\n                    }\n                    if (r === -1 || i === -1 || a === 0 || a === 1 && r === i - 1 && r === t + 1) {\n                        return \"\";\n                    }\n                    return e.slice(r, i);\n                },\n                format: function format(e) {\n                    if (e === null || typeof e !== \"object\") {\n                        throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof e);\n                    }\n                    return _format(\"/\", e);\n                },\n                parse: function parse(e) {\n                    assertPath(e);\n                    var r = {\n                        root: \"\",\n                        dir: \"\",\n                        base: \"\",\n                        ext: \"\",\n                        name: \"\"\n                    };\n                    if (e.length === 0) return r;\n                    var t = e.charCodeAt(0);\n                    var i = t === 47;\n                    var n;\n                    if (i) {\n                        r.root = \"/\";\n                        n = 1;\n                    } else {\n                        n = 0;\n                    }\n                    var a = -1;\n                    var f = 0;\n                    var l = -1;\n                    var s = true;\n                    var o = e.length - 1;\n                    var u = 0;\n                    for(; o >= n; --o){\n                        t = e.charCodeAt(o);\n                        if (t === 47) {\n                            if (!s) {\n                                f = o + 1;\n                                break;\n                            }\n                            continue;\n                        }\n                        if (l === -1) {\n                            s = false;\n                            l = o + 1;\n                        }\n                        if (t === 46) {\n                            if (a === -1) a = o;\n                            else if (u !== 1) u = 1;\n                        } else if (a !== -1) {\n                            u = -1;\n                        }\n                    }\n                    if (a === -1 || l === -1 || u === 0 || u === 1 && a === l - 1 && a === f + 1) {\n                        if (l !== -1) {\n                            if (f === 0 && i) r.base = r.name = e.slice(1, l);\n                            else r.base = r.name = e.slice(f, l);\n                        }\n                    } else {\n                        if (f === 0 && i) {\n                            r.name = e.slice(1, a);\n                            r.base = e.slice(1, l);\n                        } else {\n                            r.name = e.slice(f, a);\n                            r.base = e.slice(f, l);\n                        }\n                        r.ext = e.slice(a, l);\n                    }\n                    if (f > 0) r.dir = e.slice(0, f - 1);\n                    else if (i) r.dir = \"/\";\n                    return r;\n                },\n                sep: \"/\",\n                delimiter: \":\",\n                win32: null,\n                posix: null\n            };\n            r.posix = r;\n            e.exports = r;\n        }\n    };\n    var r = {};\n    function __nccwpck_require__(t) {\n        var i = r[t];\n        if (i !== undefined) {\n            return i.exports;\n        }\n        var n = r[t] = {\n            exports: {}\n        };\n        var a = true;\n        try {\n            e[t](n, n.exports, __nccwpck_require__);\n            a = false;\n        } finally{\n            if (a) delete r[t];\n        }\n        return n.exports;\n    }\n    if (typeof __nccwpck_require__ !== \"undefined\") __nccwpck_require__.ab = __dirname + \"/\";\n    var t = __nccwpck_require__(114);\n    module.exports = t;\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7O0FBQUM7SUFBVztJQUFhLElBQUlBLElBQUU7UUFBQyxLQUFJLFNBQVNBLENBQUM7WUFBRSxTQUFTQyxXQUFXRCxDQUFDO2dCQUFFLElBQUcsT0FBT0EsTUFBSSxVQUFTO29CQUFDLE1BQU0sSUFBSUUsVUFBVSxxQ0FBbUNDLEtBQUtDLFNBQVMsQ0FBQ0o7Z0JBQUc7WUFBQztZQUFDLFNBQVNLLHFCQUFxQkwsQ0FBQyxFQUFDTSxDQUFDO2dCQUFFLElBQUlDLElBQUU7Z0JBQUcsSUFBSUMsSUFBRTtnQkFBRSxJQUFJQyxJQUFFLENBQUM7Z0JBQUUsSUFBSUMsSUFBRTtnQkFBRSxJQUFJQztnQkFBRSxJQUFJLElBQUlDLElBQUUsR0FBRUEsS0FBR1osRUFBRWEsTUFBTSxFQUFDLEVBQUVELEVBQUU7b0JBQUMsSUFBR0EsSUFBRVosRUFBRWEsTUFBTSxFQUFDRixJQUFFWCxFQUFFYyxVQUFVLENBQUNGO3lCQUFRLElBQUdELE1BQUksSUFBRzt5QkFBV0EsSUFBRTtvQkFBRyxJQUFHQSxNQUFJLElBQUc7d0JBQUMsSUFBR0YsTUFBSUcsSUFBRSxLQUFHRixNQUFJLEdBQUUsQ0FBQyxPQUFNLElBQUdELE1BQUlHLElBQUUsS0FBR0YsTUFBSSxHQUFFOzRCQUFDLElBQUdILEVBQUVNLE1BQU0sR0FBQyxLQUFHTCxNQUFJLEtBQUdELEVBQUVPLFVBQVUsQ0FBQ1AsRUFBRU0sTUFBTSxHQUFDLE9BQUssTUFBSU4sRUFBRU8sVUFBVSxDQUFDUCxFQUFFTSxNQUFNLEdBQUMsT0FBSyxJQUFHO2dDQUFDLElBQUdOLEVBQUVNLE1BQU0sR0FBQyxHQUFFO29DQUFDLElBQUlFLElBQUVSLEVBQUVTLFdBQVcsQ0FBQztvQ0FBSyxJQUFHRCxNQUFJUixFQUFFTSxNQUFNLEdBQUMsR0FBRTt3Q0FBQyxJQUFHRSxNQUFJLENBQUMsR0FBRTs0Q0FBQ1IsSUFBRTs0Q0FBR0MsSUFBRTt3Q0FBQyxPQUFLOzRDQUFDRCxJQUFFQSxFQUFFVSxLQUFLLENBQUMsR0FBRUY7NENBQUdQLElBQUVELEVBQUVNLE1BQU0sR0FBQyxJQUFFTixFQUFFUyxXQUFXLENBQUM7d0NBQUk7d0NBQUNQLElBQUVHO3dDQUFFRixJQUFFO3dDQUFFO29DQUFRO2dDQUFDLE9BQU0sSUFBR0gsRUFBRU0sTUFBTSxLQUFHLEtBQUdOLEVBQUVNLE1BQU0sS0FBRyxHQUFFO29DQUFDTixJQUFFO29DQUFHQyxJQUFFO29DQUFFQyxJQUFFRztvQ0FBRUYsSUFBRTtvQ0FBRTtnQ0FBUTs0QkFBQzs0QkFBQyxJQUFHSixHQUFFO2dDQUFDLElBQUdDLEVBQUVNLE1BQU0sR0FBQyxHQUFFTixLQUFHO3FDQUFXQSxJQUFFO2dDQUFLQyxJQUFFOzRCQUFDO3dCQUFDLE9BQUs7NEJBQUMsSUFBR0QsRUFBRU0sTUFBTSxHQUFDLEdBQUVOLEtBQUcsTUFBSVAsRUFBRWlCLEtBQUssQ0FBQ1IsSUFBRSxHQUFFRztpQ0FBUUwsSUFBRVAsRUFBRWlCLEtBQUssQ0FBQ1IsSUFBRSxHQUFFRzs0QkFBR0osSUFBRUksSUFBRUgsSUFBRTt3QkFBQzt3QkFBQ0EsSUFBRUc7d0JBQUVGLElBQUU7b0JBQUMsT0FBTSxJQUFHQyxNQUFJLE1BQUlELE1BQUksQ0FBQyxHQUFFO3dCQUFDLEVBQUVBO29CQUFDLE9BQUs7d0JBQUNBLElBQUUsQ0FBQztvQkFBQztnQkFBQztnQkFBQyxPQUFPSDtZQUFDO1lBQUMsU0FBU1csUUFBUWxCLENBQUMsRUFBQ00sQ0FBQztnQkFBRSxJQUFJQyxJQUFFRCxFQUFFYSxHQUFHLElBQUViLEVBQUVjLElBQUk7Z0JBQUMsSUFBSVosSUFBRUYsRUFBRWUsSUFBSSxJQUFFLENBQUNmLEVBQUVnQixJQUFJLElBQUUsRUFBQyxJQUFJaEIsQ0FBQUEsRUFBRWlCLEdBQUcsSUFBRSxFQUFDO2dCQUFHLElBQUcsQ0FBQ2hCLEdBQUU7b0JBQUMsT0FBT0M7Z0JBQUM7Z0JBQUMsSUFBR0QsTUFBSUQsRUFBRWMsSUFBSSxFQUFDO29CQUFDLE9BQU9iLElBQUVDO2dCQUFDO2dCQUFDLE9BQU9ELElBQUVQLElBQUVRO1lBQUM7WUFBQyxJQUFJRixJQUFFO2dCQUFDa0IsU0FBUSxTQUFTQTtvQkFBVSxJQUFJeEIsSUFBRTtvQkFBRyxJQUFJTSxJQUFFO29CQUFNLElBQUlDO29CQUFFLElBQUksSUFBSUMsSUFBRWlCLFVBQVVaLE1BQU0sR0FBQyxHQUFFTCxLQUFHLENBQUMsS0FBRyxDQUFDRixHQUFFRSxJQUFJO3dCQUFDLElBQUlDO3dCQUFFLElBQUdELEtBQUcsR0FBRUMsSUFBRWdCLFNBQVMsQ0FBQ2pCLEVBQUU7NkJBQUs7NEJBQUMsSUFBR0QsTUFBSW1CLFdBQVVuQixJQUFFOzRCQUFHRSxJQUFFRjt3QkFBQzt3QkFBQ04sV0FBV1E7d0JBQUcsSUFBR0EsRUFBRUksTUFBTSxLQUFHLEdBQUU7NEJBQUM7d0JBQVE7d0JBQUNiLElBQUVTLElBQUUsTUFBSVQ7d0JBQUVNLElBQUVHLEVBQUVLLFVBQVUsQ0FBQyxPQUFLO29CQUFFO29CQUFDZCxJQUFFSyxxQkFBcUJMLEdBQUUsQ0FBQ007b0JBQUcsSUFBR0EsR0FBRTt3QkFBQyxJQUFHTixFQUFFYSxNQUFNLEdBQUMsR0FBRSxPQUFNLE1BQUliOzZCQUFPLE9BQU07b0JBQUcsT0FBTSxJQUFHQSxFQUFFYSxNQUFNLEdBQUMsR0FBRTt3QkFBQyxPQUFPYjtvQkFBQyxPQUFLO3dCQUFDLE9BQU07b0JBQUc7Z0JBQUM7Z0JBQUUyQixXQUFVLFNBQVNBLFVBQVUzQixDQUFDO29CQUFFQyxXQUFXRDtvQkFBRyxJQUFHQSxFQUFFYSxNQUFNLEtBQUcsR0FBRSxPQUFNO29CQUFJLElBQUlQLElBQUVOLEVBQUVjLFVBQVUsQ0FBQyxPQUFLO29CQUFHLElBQUlQLElBQUVQLEVBQUVjLFVBQVUsQ0FBQ2QsRUFBRWEsTUFBTSxHQUFDLE9BQUs7b0JBQUdiLElBQUVLLHFCQUFxQkwsR0FBRSxDQUFDTTtvQkFBRyxJQUFHTixFQUFFYSxNQUFNLEtBQUcsS0FBRyxDQUFDUCxHQUFFTixJQUFFO29CQUFJLElBQUdBLEVBQUVhLE1BQU0sR0FBQyxLQUFHTixHQUFFUCxLQUFHO29CQUFJLElBQUdNLEdBQUUsT0FBTSxNQUFJTjtvQkFBRSxPQUFPQTtnQkFBQztnQkFBRTRCLFlBQVcsU0FBU0EsV0FBVzVCLENBQUM7b0JBQUVDLFdBQVdEO29CQUFHLE9BQU9BLEVBQUVhLE1BQU0sR0FBQyxLQUFHYixFQUFFYyxVQUFVLENBQUMsT0FBSztnQkFBRTtnQkFBRWUsTUFBSyxTQUFTQTtvQkFBTyxJQUFHSixVQUFVWixNQUFNLEtBQUcsR0FBRSxPQUFNO29CQUFJLElBQUliO29CQUFFLElBQUksSUFBSU8sSUFBRSxHQUFFQSxJQUFFa0IsVUFBVVosTUFBTSxFQUFDLEVBQUVOLEVBQUU7d0JBQUMsSUFBSUMsSUFBRWlCLFNBQVMsQ0FBQ2xCLEVBQUU7d0JBQUNOLFdBQVdPO3dCQUFHLElBQUdBLEVBQUVLLE1BQU0sR0FBQyxHQUFFOzRCQUFDLElBQUdiLE1BQUkwQixXQUFVMUIsSUFBRVE7aUNBQU9SLEtBQUcsTUFBSVE7d0JBQUM7b0JBQUM7b0JBQUMsSUFBR1IsTUFBSTBCLFdBQVUsT0FBTTtvQkFBSSxPQUFPcEIsRUFBRXFCLFNBQVMsQ0FBQzNCO2dCQUFFO2dCQUFFOEIsVUFBUyxTQUFTQSxTQUFTOUIsQ0FBQyxFQUFDTyxDQUFDO29CQUFFTixXQUFXRDtvQkFBR0MsV0FBV007b0JBQUcsSUFBR1AsTUFBSU8sR0FBRSxPQUFNO29CQUFHUCxJQUFFTSxFQUFFa0IsT0FBTyxDQUFDeEI7b0JBQUdPLElBQUVELEVBQUVrQixPQUFPLENBQUNqQjtvQkFBRyxJQUFHUCxNQUFJTyxHQUFFLE9BQU07b0JBQUcsSUFBSUMsSUFBRTtvQkFBRSxNQUFLQSxJQUFFUixFQUFFYSxNQUFNLEVBQUMsRUFBRUwsRUFBRTt3QkFBQyxJQUFHUixFQUFFYyxVQUFVLENBQUNOLE9BQUssSUFBRztvQkFBSztvQkFBQyxJQUFJQyxJQUFFVCxFQUFFYSxNQUFNO29CQUFDLElBQUlILElBQUVELElBQUVEO29CQUFFLElBQUlHLElBQUU7b0JBQUUsTUFBS0EsSUFBRUosRUFBRU0sTUFBTSxFQUFDLEVBQUVGLEVBQUU7d0JBQUMsSUFBR0osRUFBRU8sVUFBVSxDQUFDSCxPQUFLLElBQUc7b0JBQUs7b0JBQUMsSUFBSUMsSUFBRUwsRUFBRU0sTUFBTTtvQkFBQyxJQUFJRSxJQUFFSCxJQUFFRDtvQkFBRSxJQUFJb0IsSUFBRXJCLElBQUVLLElBQUVMLElBQUVLO29CQUFFLElBQUlpQixJQUFFLENBQUM7b0JBQUUsSUFBSUMsSUFBRTtvQkFBRSxNQUFLQSxLQUFHRixHQUFFLEVBQUVFLEVBQUU7d0JBQUMsSUFBR0EsTUFBSUYsR0FBRTs0QkFBQyxJQUFHaEIsSUFBRWdCLEdBQUU7Z0NBQUMsSUFBR3hCLEVBQUVPLFVBQVUsQ0FBQ0gsSUFBRXNCLE9BQUssSUFBRztvQ0FBQyxPQUFPMUIsRUFBRVUsS0FBSyxDQUFDTixJQUFFc0IsSUFBRTtnQ0FBRSxPQUFNLElBQUdBLE1BQUksR0FBRTtvQ0FBQyxPQUFPMUIsRUFBRVUsS0FBSyxDQUFDTixJQUFFc0I7Z0NBQUU7NEJBQUMsT0FBTSxJQUFHdkIsSUFBRXFCLEdBQUU7Z0NBQUMsSUFBRy9CLEVBQUVjLFVBQVUsQ0FBQ04sSUFBRXlCLE9BQUssSUFBRztvQ0FBQ0QsSUFBRUM7Z0NBQUMsT0FBTSxJQUFHQSxNQUFJLEdBQUU7b0NBQUNELElBQUU7Z0NBQUM7NEJBQUM7NEJBQUM7d0JBQUs7d0JBQUMsSUFBSUUsSUFBRWxDLEVBQUVjLFVBQVUsQ0FBQ04sSUFBRXlCO3dCQUFHLElBQUlFLElBQUU1QixFQUFFTyxVQUFVLENBQUNILElBQUVzQjt3QkFBRyxJQUFHQyxNQUFJQyxHQUFFOzZCQUFXLElBQUdELE1BQUksSUFBR0YsSUFBRUM7b0JBQUM7b0JBQUMsSUFBSUcsSUFBRTtvQkFBRyxJQUFJSCxJQUFFekIsSUFBRXdCLElBQUUsR0FBRUMsS0FBR3hCLEdBQUUsRUFBRXdCLEVBQUU7d0JBQUMsSUFBR0EsTUFBSXhCLEtBQUdULEVBQUVjLFVBQVUsQ0FBQ21CLE9BQUssSUFBRzs0QkFBQyxJQUFHRyxFQUFFdkIsTUFBTSxLQUFHLEdBQUV1QixLQUFHO2lDQUFVQSxLQUFHO3dCQUFLO29CQUFDO29CQUFDLElBQUdBLEVBQUV2QixNQUFNLEdBQUMsR0FBRSxPQUFPdUIsSUFBRTdCLEVBQUVVLEtBQUssQ0FBQ04sSUFBRXFCO3lCQUFPO3dCQUFDckIsS0FBR3FCO3dCQUFFLElBQUd6QixFQUFFTyxVQUFVLENBQUNILE9BQUssSUFBRyxFQUFFQTt3QkFBRSxPQUFPSixFQUFFVSxLQUFLLENBQUNOO29CQUFFO2dCQUFDO2dCQUFFMEIsV0FBVSxTQUFTQSxVQUFVckMsQ0FBQztvQkFBRSxPQUFPQTtnQkFBQztnQkFBRXNDLFNBQVEsU0FBU0EsUUFBUXRDLENBQUM7b0JBQUVDLFdBQVdEO29CQUFHLElBQUdBLEVBQUVhLE1BQU0sS0FBRyxHQUFFLE9BQU07b0JBQUksSUFBSVAsSUFBRU4sRUFBRWMsVUFBVSxDQUFDO29CQUFHLElBQUlQLElBQUVELE1BQUk7b0JBQUcsSUFBSUUsSUFBRSxDQUFDO29CQUFFLElBQUlDLElBQUU7b0JBQUssSUFBSSxJQUFJQyxJQUFFVixFQUFFYSxNQUFNLEdBQUMsR0FBRUgsS0FBRyxHQUFFLEVBQUVBLEVBQUU7d0JBQUNKLElBQUVOLEVBQUVjLFVBQVUsQ0FBQ0o7d0JBQUcsSUFBR0osTUFBSSxJQUFHOzRCQUFDLElBQUcsQ0FBQ0csR0FBRTtnQ0FBQ0QsSUFBRUU7Z0NBQUU7NEJBQUs7d0JBQUMsT0FBSzs0QkFBQ0QsSUFBRTt3QkFBSztvQkFBQztvQkFBQyxJQUFHRCxNQUFJLENBQUMsR0FBRSxPQUFPRCxJQUFFLE1BQUk7b0JBQUksSUFBR0EsS0FBR0MsTUFBSSxHQUFFLE9BQU07b0JBQUssT0FBT1IsRUFBRWlCLEtBQUssQ0FBQyxHQUFFVDtnQkFBRTtnQkFBRStCLFVBQVMsU0FBU0EsU0FBU3ZDLENBQUMsRUFBQ00sQ0FBQztvQkFBRSxJQUFHQSxNQUFJb0IsYUFBVyxPQUFPcEIsTUFBSSxVQUFTLE1BQU0sSUFBSUosVUFBVTtvQkFBbUNELFdBQVdEO29CQUFHLElBQUlPLElBQUU7b0JBQUUsSUFBSUMsSUFBRSxDQUFDO29CQUFFLElBQUlDLElBQUU7b0JBQUssSUFBSUM7b0JBQUUsSUFBR0osTUFBSW9CLGFBQVdwQixFQUFFTyxNQUFNLEdBQUMsS0FBR1AsRUFBRU8sTUFBTSxJQUFFYixFQUFFYSxNQUFNLEVBQUM7d0JBQUMsSUFBR1AsRUFBRU8sTUFBTSxLQUFHYixFQUFFYSxNQUFNLElBQUVQLE1BQUlOLEdBQUUsT0FBTTt3QkFBRyxJQUFJVyxJQUFFTCxFQUFFTyxNQUFNLEdBQUM7d0JBQUUsSUFBSUQsSUFBRSxDQUFDO3dCQUFFLElBQUlGLElBQUVWLEVBQUVhLE1BQU0sR0FBQyxHQUFFSCxLQUFHLEdBQUUsRUFBRUEsRUFBRTs0QkFBQyxJQUFJSyxJQUFFZixFQUFFYyxVQUFVLENBQUNKOzRCQUFHLElBQUdLLE1BQUksSUFBRztnQ0FBQyxJQUFHLENBQUNOLEdBQUU7b0NBQUNGLElBQUVHLElBQUU7b0NBQUU7Z0NBQUs7NEJBQUMsT0FBSztnQ0FBQyxJQUFHRSxNQUFJLENBQUMsR0FBRTtvQ0FBQ0gsSUFBRTtvQ0FBTUcsSUFBRUYsSUFBRTtnQ0FBQztnQ0FBQyxJQUFHQyxLQUFHLEdBQUU7b0NBQUMsSUFBR0ksTUFBSVQsRUFBRVEsVUFBVSxDQUFDSCxJQUFHO3dDQUFDLElBQUcsRUFBRUEsTUFBSSxDQUFDLEdBQUU7NENBQUNILElBQUVFO3dDQUFDO29DQUFDLE9BQUs7d0NBQUNDLElBQUUsQ0FBQzt3Q0FBRUgsSUFBRUk7b0NBQUM7Z0NBQUM7NEJBQUM7d0JBQUM7d0JBQUMsSUFBR0wsTUFBSUMsR0FBRUEsSUFBRUk7NkJBQU8sSUFBR0osTUFBSSxDQUFDLEdBQUVBLElBQUVSLEVBQUVhLE1BQU07d0JBQUMsT0FBT2IsRUFBRWlCLEtBQUssQ0FBQ1YsR0FBRUM7b0JBQUUsT0FBSzt3QkFBQyxJQUFJRSxJQUFFVixFQUFFYSxNQUFNLEdBQUMsR0FBRUgsS0FBRyxHQUFFLEVBQUVBLEVBQUU7NEJBQUMsSUFBR1YsRUFBRWMsVUFBVSxDQUFDSixPQUFLLElBQUc7Z0NBQUMsSUFBRyxDQUFDRCxHQUFFO29DQUFDRixJQUFFRyxJQUFFO29DQUFFO2dDQUFLOzRCQUFDLE9BQU0sSUFBR0YsTUFBSSxDQUFDLEdBQUU7Z0NBQUNDLElBQUU7Z0NBQU1ELElBQUVFLElBQUU7NEJBQUM7d0JBQUM7d0JBQUMsSUFBR0YsTUFBSSxDQUFDLEdBQUUsT0FBTTt3QkFBRyxPQUFPUixFQUFFaUIsS0FBSyxDQUFDVixHQUFFQztvQkFBRTtnQkFBQztnQkFBRWdDLFNBQVEsU0FBU0EsUUFBUXhDLENBQUM7b0JBQUVDLFdBQVdEO29CQUFHLElBQUlNLElBQUUsQ0FBQztvQkFBRSxJQUFJQyxJQUFFO29CQUFFLElBQUlDLElBQUUsQ0FBQztvQkFBRSxJQUFJQyxJQUFFO29CQUFLLElBQUlDLElBQUU7b0JBQUUsSUFBSSxJQUFJQyxJQUFFWCxFQUFFYSxNQUFNLEdBQUMsR0FBRUYsS0FBRyxHQUFFLEVBQUVBLEVBQUU7d0JBQUMsSUFBSUMsSUFBRVosRUFBRWMsVUFBVSxDQUFDSDt3QkFBRyxJQUFHQyxNQUFJLElBQUc7NEJBQUMsSUFBRyxDQUFDSCxHQUFFO2dDQUFDRixJQUFFSSxJQUFFO2dDQUFFOzRCQUFLOzRCQUFDO3dCQUFRO3dCQUFDLElBQUdILE1BQUksQ0FBQyxHQUFFOzRCQUFDQyxJQUFFOzRCQUFNRCxJQUFFRyxJQUFFO3dCQUFDO3dCQUFDLElBQUdDLE1BQUksSUFBRzs0QkFBQyxJQUFHTixNQUFJLENBQUMsR0FBRUEsSUFBRUs7aUNBQU8sSUFBR0QsTUFBSSxHQUFFQSxJQUFFO3dCQUFDLE9BQU0sSUFBR0osTUFBSSxDQUFDLEdBQUU7NEJBQUNJLElBQUUsQ0FBQzt3QkFBQztvQkFBQztvQkFBQyxJQUFHSixNQUFJLENBQUMsS0FBR0UsTUFBSSxDQUFDLEtBQUdFLE1BQUksS0FBR0EsTUFBSSxLQUFHSixNQUFJRSxJQUFFLEtBQUdGLE1BQUlDLElBQUUsR0FBRTt3QkFBQyxPQUFNO29CQUFFO29CQUFDLE9BQU9QLEVBQUVpQixLQUFLLENBQUNYLEdBQUVFO2dCQUFFO2dCQUFFaUMsUUFBTyxTQUFTQSxPQUFPekMsQ0FBQztvQkFBRSxJQUFHQSxNQUFJLFFBQU0sT0FBT0EsTUFBSSxVQUFTO3dCQUFDLE1BQU0sSUFBSUUsVUFBVSxxRUFBbUUsT0FBT0Y7b0JBQUU7b0JBQUMsT0FBT2tCLFFBQVEsS0FBSWxCO2dCQUFFO2dCQUFFMEMsT0FBTSxTQUFTQSxNQUFNMUMsQ0FBQztvQkFBRUMsV0FBV0Q7b0JBQUcsSUFBSU0sSUFBRTt3QkFBQ2MsTUFBSzt3QkFBR0QsS0FBSTt3QkFBR0UsTUFBSzt3QkFBR0UsS0FBSTt3QkFBR0QsTUFBSztvQkFBRTtvQkFBRSxJQUFHdEIsRUFBRWEsTUFBTSxLQUFHLEdBQUUsT0FBT1A7b0JBQUUsSUFBSUMsSUFBRVAsRUFBRWMsVUFBVSxDQUFDO29CQUFHLElBQUlOLElBQUVELE1BQUk7b0JBQUcsSUFBSUU7b0JBQUUsSUFBR0QsR0FBRTt3QkFBQ0YsRUFBRWMsSUFBSSxHQUFDO3dCQUFJWCxJQUFFO29CQUFDLE9BQUs7d0JBQUNBLElBQUU7b0JBQUM7b0JBQUMsSUFBSUMsSUFBRSxDQUFDO29CQUFFLElBQUlDLElBQUU7b0JBQUUsSUFBSUMsSUFBRSxDQUFDO29CQUFFLElBQUlHLElBQUU7b0JBQUssSUFBSWdCLElBQUUvQixFQUFFYSxNQUFNLEdBQUM7b0JBQUUsSUFBSW1CLElBQUU7b0JBQUUsTUFBS0QsS0FBR3RCLEdBQUUsRUFBRXNCLEVBQUU7d0JBQUN4QixJQUFFUCxFQUFFYyxVQUFVLENBQUNpQjt3QkFBRyxJQUFHeEIsTUFBSSxJQUFHOzRCQUFDLElBQUcsQ0FBQ1EsR0FBRTtnQ0FBQ0osSUFBRW9CLElBQUU7Z0NBQUU7NEJBQUs7NEJBQUM7d0JBQVE7d0JBQUMsSUFBR25CLE1BQUksQ0FBQyxHQUFFOzRCQUFDRyxJQUFFOzRCQUFNSCxJQUFFbUIsSUFBRTt3QkFBQzt3QkFBQyxJQUFHeEIsTUFBSSxJQUFHOzRCQUFDLElBQUdHLE1BQUksQ0FBQyxHQUFFQSxJQUFFcUI7aUNBQU8sSUFBR0MsTUFBSSxHQUFFQSxJQUFFO3dCQUFDLE9BQU0sSUFBR3RCLE1BQUksQ0FBQyxHQUFFOzRCQUFDc0IsSUFBRSxDQUFDO3dCQUFDO29CQUFDO29CQUFDLElBQUd0QixNQUFJLENBQUMsS0FBR0UsTUFBSSxDQUFDLEtBQUdvQixNQUFJLEtBQUdBLE1BQUksS0FBR3RCLE1BQUlFLElBQUUsS0FBR0YsTUFBSUMsSUFBRSxHQUFFO3dCQUFDLElBQUdDLE1BQUksQ0FBQyxHQUFFOzRCQUFDLElBQUdELE1BQUksS0FBR0gsR0FBRUYsRUFBRWUsSUFBSSxHQUFDZixFQUFFZ0IsSUFBSSxHQUFDdEIsRUFBRWlCLEtBQUssQ0FBQyxHQUFFTDtpQ0FBUU4sRUFBRWUsSUFBSSxHQUFDZixFQUFFZ0IsSUFBSSxHQUFDdEIsRUFBRWlCLEtBQUssQ0FBQ04sR0FBRUM7d0JBQUU7b0JBQUMsT0FBSzt3QkFBQyxJQUFHRCxNQUFJLEtBQUdILEdBQUU7NEJBQUNGLEVBQUVnQixJQUFJLEdBQUN0QixFQUFFaUIsS0FBSyxDQUFDLEdBQUVQOzRCQUFHSixFQUFFZSxJQUFJLEdBQUNyQixFQUFFaUIsS0FBSyxDQUFDLEdBQUVMO3dCQUFFLE9BQUs7NEJBQUNOLEVBQUVnQixJQUFJLEdBQUN0QixFQUFFaUIsS0FBSyxDQUFDTixHQUFFRDs0QkFBR0osRUFBRWUsSUFBSSxHQUFDckIsRUFBRWlCLEtBQUssQ0FBQ04sR0FBRUM7d0JBQUU7d0JBQUNOLEVBQUVpQixHQUFHLEdBQUN2QixFQUFFaUIsS0FBSyxDQUFDUCxHQUFFRTtvQkFBRTtvQkFBQyxJQUFHRCxJQUFFLEdBQUVMLEVBQUVhLEdBQUcsR0FBQ25CLEVBQUVpQixLQUFLLENBQUMsR0FBRU4sSUFBRTt5QkFBUSxJQUFHSCxHQUFFRixFQUFFYSxHQUFHLEdBQUM7b0JBQUksT0FBT2I7Z0JBQUM7Z0JBQUVxQyxLQUFJO2dCQUFJQyxXQUFVO2dCQUFJQyxPQUFNO2dCQUFLQyxPQUFNO1lBQUk7WUFBRXhDLEVBQUV3QyxLQUFLLEdBQUN4QztZQUFFTixFQUFFK0MsT0FBTyxHQUFDekM7UUFBQztJQUFDO0lBQUUsSUFBSUEsSUFBRSxDQUFDO0lBQUUsU0FBUzBDLG9CQUFvQnpDLENBQUM7UUFBRSxJQUFJQyxJQUFFRixDQUFDLENBQUNDLEVBQUU7UUFBQyxJQUFHQyxNQUFJa0IsV0FBVTtZQUFDLE9BQU9sQixFQUFFdUMsT0FBTztRQUFBO1FBQUMsSUFBSXRDLElBQUVILENBQUMsQ0FBQ0MsRUFBRSxHQUFDO1lBQUN3QyxTQUFRLENBQUM7UUFBQztRQUFFLElBQUlyQyxJQUFFO1FBQUssSUFBRztZQUFDVixDQUFDLENBQUNPLEVBQUUsQ0FBQ0UsR0FBRUEsRUFBRXNDLE9BQU8sRUFBQ0M7WUFBcUJ0QyxJQUFFO1FBQUssU0FBUTtZQUFDLElBQUdBLEdBQUUsT0FBT0osQ0FBQyxDQUFDQyxFQUFFO1FBQUE7UUFBQyxPQUFPRSxFQUFFc0MsT0FBTztJQUFBO0lBQUMsSUFBRyxPQUFPQyx3QkFBc0IsYUFBWUEsb0JBQW9CQyxFQUFFLEdBQUNDLFNBQVNBLEdBQUM7SUFBSSxJQUFJM0MsSUFBRXlDLG9CQUFvQjtJQUFLRyxPQUFPSixPQUFPLEdBQUN4QztBQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzPzNjZDEiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIGU9ezExNDpmdW5jdGlvbihlKXtmdW5jdGlvbiBhc3NlcnRQYXRoKGUpe2lmKHR5cGVvZiBlIT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhdGggbXVzdCBiZSBhIHN0cmluZy4gUmVjZWl2ZWQgXCIrSlNPTi5zdHJpbmdpZnkoZSkpfX1mdW5jdGlvbiBub3JtYWxpemVTdHJpbmdQb3NpeChlLHIpe3ZhciB0PVwiXCI7dmFyIGk9MDt2YXIgbj0tMTt2YXIgYT0wO3ZhciBmO2Zvcih2YXIgbD0wO2w8PWUubGVuZ3RoOysrbCl7aWYobDxlLmxlbmd0aClmPWUuY2hhckNvZGVBdChsKTtlbHNlIGlmKGY9PT00NylicmVhaztlbHNlIGY9NDc7aWYoZj09PTQ3KXtpZihuPT09bC0xfHxhPT09MSl7fWVsc2UgaWYobiE9PWwtMSYmYT09PTIpe2lmKHQubGVuZ3RoPDJ8fGkhPT0yfHx0LmNoYXJDb2RlQXQodC5sZW5ndGgtMSkhPT00Nnx8dC5jaGFyQ29kZUF0KHQubGVuZ3RoLTIpIT09NDYpe2lmKHQubGVuZ3RoPjIpe3ZhciBzPXQubGFzdEluZGV4T2YoXCIvXCIpO2lmKHMhPT10Lmxlbmd0aC0xKXtpZihzPT09LTEpe3Q9XCJcIjtpPTB9ZWxzZXt0PXQuc2xpY2UoMCxzKTtpPXQubGVuZ3RoLTEtdC5sYXN0SW5kZXhPZihcIi9cIil9bj1sO2E9MDtjb250aW51ZX19ZWxzZSBpZih0Lmxlbmd0aD09PTJ8fHQubGVuZ3RoPT09MSl7dD1cIlwiO2k9MDtuPWw7YT0wO2NvbnRpbnVlfX1pZihyKXtpZih0Lmxlbmd0aD4wKXQrPVwiLy4uXCI7ZWxzZSB0PVwiLi5cIjtpPTJ9fWVsc2V7aWYodC5sZW5ndGg+MCl0Kz1cIi9cIitlLnNsaWNlKG4rMSxsKTtlbHNlIHQ9ZS5zbGljZShuKzEsbCk7aT1sLW4tMX1uPWw7YT0wfWVsc2UgaWYoZj09PTQ2JiZhIT09LTEpeysrYX1lbHNle2E9LTF9fXJldHVybiB0fWZ1bmN0aW9uIF9mb3JtYXQoZSxyKXt2YXIgdD1yLmRpcnx8ci5yb290O3ZhciBpPXIuYmFzZXx8KHIubmFtZXx8XCJcIikrKHIuZXh0fHxcIlwiKTtpZighdCl7cmV0dXJuIGl9aWYodD09PXIucm9vdCl7cmV0dXJuIHQraX1yZXR1cm4gdCtlK2l9dmFyIHI9e3Jlc29sdmU6ZnVuY3Rpb24gcmVzb2x2ZSgpe3ZhciBlPVwiXCI7dmFyIHI9ZmFsc2U7dmFyIHQ7Zm9yKHZhciBpPWFyZ3VtZW50cy5sZW5ndGgtMTtpPj0tMSYmIXI7aS0tKXt2YXIgbjtpZihpPj0wKW49YXJndW1lbnRzW2ldO2Vsc2V7aWYodD09PXVuZGVmaW5lZCl0PVwiXCI7bj10fWFzc2VydFBhdGgobik7aWYobi5sZW5ndGg9PT0wKXtjb250aW51ZX1lPW4rXCIvXCIrZTtyPW4uY2hhckNvZGVBdCgwKT09PTQ3fWU9bm9ybWFsaXplU3RyaW5nUG9zaXgoZSwhcik7aWYocil7aWYoZS5sZW5ndGg+MClyZXR1cm5cIi9cIitlO2Vsc2UgcmV0dXJuXCIvXCJ9ZWxzZSBpZihlLmxlbmd0aD4wKXtyZXR1cm4gZX1lbHNle3JldHVyblwiLlwifX0sbm9ybWFsaXplOmZ1bmN0aW9uIG5vcm1hbGl6ZShlKXthc3NlcnRQYXRoKGUpO2lmKGUubGVuZ3RoPT09MClyZXR1cm5cIi5cIjt2YXIgcj1lLmNoYXJDb2RlQXQoMCk9PT00Nzt2YXIgdD1lLmNoYXJDb2RlQXQoZS5sZW5ndGgtMSk9PT00NztlPW5vcm1hbGl6ZVN0cmluZ1Bvc2l4KGUsIXIpO2lmKGUubGVuZ3RoPT09MCYmIXIpZT1cIi5cIjtpZihlLmxlbmd0aD4wJiZ0KWUrPVwiL1wiO2lmKHIpcmV0dXJuXCIvXCIrZTtyZXR1cm4gZX0saXNBYnNvbHV0ZTpmdW5jdGlvbiBpc0Fic29sdXRlKGUpe2Fzc2VydFBhdGgoZSk7cmV0dXJuIGUubGVuZ3RoPjAmJmUuY2hhckNvZGVBdCgwKT09PTQ3fSxqb2luOmZ1bmN0aW9uIGpvaW4oKXtpZihhcmd1bWVudHMubGVuZ3RoPT09MClyZXR1cm5cIi5cIjt2YXIgZTtmb3IodmFyIHQ9MDt0PGFyZ3VtZW50cy5sZW5ndGg7Kyt0KXt2YXIgaT1hcmd1bWVudHNbdF07YXNzZXJ0UGF0aChpKTtpZihpLmxlbmd0aD4wKXtpZihlPT09dW5kZWZpbmVkKWU9aTtlbHNlIGUrPVwiL1wiK2l9fWlmKGU9PT11bmRlZmluZWQpcmV0dXJuXCIuXCI7cmV0dXJuIHIubm9ybWFsaXplKGUpfSxyZWxhdGl2ZTpmdW5jdGlvbiByZWxhdGl2ZShlLHQpe2Fzc2VydFBhdGgoZSk7YXNzZXJ0UGF0aCh0KTtpZihlPT09dClyZXR1cm5cIlwiO2U9ci5yZXNvbHZlKGUpO3Q9ci5yZXNvbHZlKHQpO2lmKGU9PT10KXJldHVyblwiXCI7dmFyIGk9MTtmb3IoO2k8ZS5sZW5ndGg7KytpKXtpZihlLmNoYXJDb2RlQXQoaSkhPT00NylicmVha312YXIgbj1lLmxlbmd0aDt2YXIgYT1uLWk7dmFyIGY9MTtmb3IoO2Y8dC5sZW5ndGg7KytmKXtpZih0LmNoYXJDb2RlQXQoZikhPT00NylicmVha312YXIgbD10Lmxlbmd0aDt2YXIgcz1sLWY7dmFyIG89YTxzP2E6czt2YXIgdT0tMTt2YXIgaD0wO2Zvcig7aDw9bzsrK2gpe2lmKGg9PT1vKXtpZihzPm8pe2lmKHQuY2hhckNvZGVBdChmK2gpPT09NDcpe3JldHVybiB0LnNsaWNlKGYraCsxKX1lbHNlIGlmKGg9PT0wKXtyZXR1cm4gdC5zbGljZShmK2gpfX1lbHNlIGlmKGE+byl7aWYoZS5jaGFyQ29kZUF0KGkraCk9PT00Nyl7dT1ofWVsc2UgaWYoaD09PTApe3U9MH19YnJlYWt9dmFyIGM9ZS5jaGFyQ29kZUF0KGkraCk7dmFyIHY9dC5jaGFyQ29kZUF0KGYraCk7aWYoYyE9PXYpYnJlYWs7ZWxzZSBpZihjPT09NDcpdT1ofXZhciBnPVwiXCI7Zm9yKGg9aSt1KzE7aDw9bjsrK2gpe2lmKGg9PT1ufHxlLmNoYXJDb2RlQXQoaCk9PT00Nyl7aWYoZy5sZW5ndGg9PT0wKWcrPVwiLi5cIjtlbHNlIGcrPVwiLy4uXCJ9fWlmKGcubGVuZ3RoPjApcmV0dXJuIGcrdC5zbGljZShmK3UpO2Vsc2V7Zis9dTtpZih0LmNoYXJDb2RlQXQoZik9PT00NykrK2Y7cmV0dXJuIHQuc2xpY2UoZil9fSxfbWFrZUxvbmc6ZnVuY3Rpb24gX21ha2VMb25nKGUpe3JldHVybiBlfSxkaXJuYW1lOmZ1bmN0aW9uIGRpcm5hbWUoZSl7YXNzZXJ0UGF0aChlKTtpZihlLmxlbmd0aD09PTApcmV0dXJuXCIuXCI7dmFyIHI9ZS5jaGFyQ29kZUF0KDApO3ZhciB0PXI9PT00Nzt2YXIgaT0tMTt2YXIgbj10cnVlO2Zvcih2YXIgYT1lLmxlbmd0aC0xO2E+PTE7LS1hKXtyPWUuY2hhckNvZGVBdChhKTtpZihyPT09NDcpe2lmKCFuKXtpPWE7YnJlYWt9fWVsc2V7bj1mYWxzZX19aWYoaT09PS0xKXJldHVybiB0P1wiL1wiOlwiLlwiO2lmKHQmJmk9PT0xKXJldHVyblwiLy9cIjtyZXR1cm4gZS5zbGljZSgwLGkpfSxiYXNlbmFtZTpmdW5jdGlvbiBiYXNlbmFtZShlLHIpe2lmKHIhPT11bmRlZmluZWQmJnR5cGVvZiByIT09XCJzdHJpbmdcIil0aHJvdyBuZXcgVHlwZUVycm9yKCdcImV4dFwiIGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnKTthc3NlcnRQYXRoKGUpO3ZhciB0PTA7dmFyIGk9LTE7dmFyIG49dHJ1ZTt2YXIgYTtpZihyIT09dW5kZWZpbmVkJiZyLmxlbmd0aD4wJiZyLmxlbmd0aDw9ZS5sZW5ndGgpe2lmKHIubGVuZ3RoPT09ZS5sZW5ndGgmJnI9PT1lKXJldHVyblwiXCI7dmFyIGY9ci5sZW5ndGgtMTt2YXIgbD0tMTtmb3IoYT1lLmxlbmd0aC0xO2E+PTA7LS1hKXt2YXIgcz1lLmNoYXJDb2RlQXQoYSk7aWYocz09PTQ3KXtpZighbil7dD1hKzE7YnJlYWt9fWVsc2V7aWYobD09PS0xKXtuPWZhbHNlO2w9YSsxfWlmKGY+PTApe2lmKHM9PT1yLmNoYXJDb2RlQXQoZikpe2lmKC0tZj09PS0xKXtpPWF9fWVsc2V7Zj0tMTtpPWx9fX19aWYodD09PWkpaT1sO2Vsc2UgaWYoaT09PS0xKWk9ZS5sZW5ndGg7cmV0dXJuIGUuc2xpY2UodCxpKX1lbHNle2ZvcihhPWUubGVuZ3RoLTE7YT49MDstLWEpe2lmKGUuY2hhckNvZGVBdChhKT09PTQ3KXtpZighbil7dD1hKzE7YnJlYWt9fWVsc2UgaWYoaT09PS0xKXtuPWZhbHNlO2k9YSsxfX1pZihpPT09LTEpcmV0dXJuXCJcIjtyZXR1cm4gZS5zbGljZSh0LGkpfX0sZXh0bmFtZTpmdW5jdGlvbiBleHRuYW1lKGUpe2Fzc2VydFBhdGgoZSk7dmFyIHI9LTE7dmFyIHQ9MDt2YXIgaT0tMTt2YXIgbj10cnVlO3ZhciBhPTA7Zm9yKHZhciBmPWUubGVuZ3RoLTE7Zj49MDstLWYpe3ZhciBsPWUuY2hhckNvZGVBdChmKTtpZihsPT09NDcpe2lmKCFuKXt0PWYrMTticmVha31jb250aW51ZX1pZihpPT09LTEpe249ZmFsc2U7aT1mKzF9aWYobD09PTQ2KXtpZihyPT09LTEpcj1mO2Vsc2UgaWYoYSE9PTEpYT0xfWVsc2UgaWYociE9PS0xKXthPS0xfX1pZihyPT09LTF8fGk9PT0tMXx8YT09PTB8fGE9PT0xJiZyPT09aS0xJiZyPT09dCsxKXtyZXR1cm5cIlwifXJldHVybiBlLnNsaWNlKHIsaSl9LGZvcm1hdDpmdW5jdGlvbiBmb3JtYXQoZSl7aWYoZT09PW51bGx8fHR5cGVvZiBlIT09XCJvYmplY3RcIil7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwicGF0aE9iamVjdFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyt0eXBlb2YgZSl9cmV0dXJuIF9mb3JtYXQoXCIvXCIsZSl9LHBhcnNlOmZ1bmN0aW9uIHBhcnNlKGUpe2Fzc2VydFBhdGgoZSk7dmFyIHI9e3Jvb3Q6XCJcIixkaXI6XCJcIixiYXNlOlwiXCIsZXh0OlwiXCIsbmFtZTpcIlwifTtpZihlLmxlbmd0aD09PTApcmV0dXJuIHI7dmFyIHQ9ZS5jaGFyQ29kZUF0KDApO3ZhciBpPXQ9PT00Nzt2YXIgbjtpZihpKXtyLnJvb3Q9XCIvXCI7bj0xfWVsc2V7bj0wfXZhciBhPS0xO3ZhciBmPTA7dmFyIGw9LTE7dmFyIHM9dHJ1ZTt2YXIgbz1lLmxlbmd0aC0xO3ZhciB1PTA7Zm9yKDtvPj1uOy0tbyl7dD1lLmNoYXJDb2RlQXQobyk7aWYodD09PTQ3KXtpZighcyl7Zj1vKzE7YnJlYWt9Y29udGludWV9aWYobD09PS0xKXtzPWZhbHNlO2w9bysxfWlmKHQ9PT00Nil7aWYoYT09PS0xKWE9bztlbHNlIGlmKHUhPT0xKXU9MX1lbHNlIGlmKGEhPT0tMSl7dT0tMX19aWYoYT09PS0xfHxsPT09LTF8fHU9PT0wfHx1PT09MSYmYT09PWwtMSYmYT09PWYrMSl7aWYobCE9PS0xKXtpZihmPT09MCYmaSlyLmJhc2U9ci5uYW1lPWUuc2xpY2UoMSxsKTtlbHNlIHIuYmFzZT1yLm5hbWU9ZS5zbGljZShmLGwpfX1lbHNle2lmKGY9PT0wJiZpKXtyLm5hbWU9ZS5zbGljZSgxLGEpO3IuYmFzZT1lLnNsaWNlKDEsbCl9ZWxzZXtyLm5hbWU9ZS5zbGljZShmLGEpO3IuYmFzZT1lLnNsaWNlKGYsbCl9ci5leHQ9ZS5zbGljZShhLGwpfWlmKGY+MClyLmRpcj1lLnNsaWNlKDAsZi0xKTtlbHNlIGlmKGkpci5kaXI9XCIvXCI7cmV0dXJuIHJ9LHNlcDpcIi9cIixkZWxpbWl0ZXI6XCI6XCIsd2luMzI6bnVsbCxwb3NpeDpudWxsfTtyLnBvc2l4PXI7ZS5leHBvcnRzPXJ9fTt2YXIgcj17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHQpe3ZhciBpPXJbdF07aWYoaSE9PXVuZGVmaW5lZCl7cmV0dXJuIGkuZXhwb3J0c312YXIgbj1yW3RdPXtleHBvcnRzOnt9fTt2YXIgYT10cnVlO3RyeXtlW3RdKG4sbi5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO2E9ZmFsc2V9ZmluYWxseXtpZihhKWRlbGV0ZSByW3RdfXJldHVybiBuLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciB0PV9fbmNjd3Bja19yZXF1aXJlX18oMTE0KTttb2R1bGUuZXhwb3J0cz10fSkoKTsiXSwibmFtZXMiOlsiZSIsImFzc2VydFBhdGgiLCJUeXBlRXJyb3IiLCJKU09OIiwic3RyaW5naWZ5Iiwibm9ybWFsaXplU3RyaW5nUG9zaXgiLCJyIiwidCIsImkiLCJuIiwiYSIsImYiLCJsIiwibGVuZ3RoIiwiY2hhckNvZGVBdCIsInMiLCJsYXN0SW5kZXhPZiIsInNsaWNlIiwiX2Zvcm1hdCIsImRpciIsInJvb3QiLCJiYXNlIiwibmFtZSIsImV4dCIsInJlc29sdmUiLCJhcmd1bWVudHMiLCJ1bmRlZmluZWQiLCJub3JtYWxpemUiLCJpc0Fic29sdXRlIiwiam9pbiIsInJlbGF0aXZlIiwibyIsInUiLCJoIiwiYyIsInYiLCJnIiwiX21ha2VMb25nIiwiZGlybmFtZSIsImJhc2VuYW1lIiwiZXh0bmFtZSIsImZvcm1hdCIsInBhcnNlIiwic2VwIiwiZGVsaW1pdGVyIiwid2luMzIiLCJwb3NpeCIsImV4cG9ydHMiLCJfX25jY3dwY2tfcmVxdWlyZV9fIiwiYWIiLCJfX2Rpcm5hbWUiLCJtb2R1bGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/path-browserify/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/compiled/process/browser.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("var __dirname = \"/\";\n\n(function() {\n    var e = {\n        229: function(e) {\n            var t = e.exports = {};\n            var r;\n            var n;\n            function defaultSetTimout() {\n                throw new Error(\"setTimeout has not been defined\");\n            }\n            function defaultClearTimeout() {\n                throw new Error(\"clearTimeout has not been defined\");\n            }\n            (function() {\n                try {\n                    if (typeof setTimeout === \"function\") {\n                        r = setTimeout;\n                    } else {\n                        r = defaultSetTimout;\n                    }\n                } catch (e) {\n                    r = defaultSetTimout;\n                }\n                try {\n                    if (typeof clearTimeout === \"function\") {\n                        n = clearTimeout;\n                    } else {\n                        n = defaultClearTimeout;\n                    }\n                } catch (e) {\n                    n = defaultClearTimeout;\n                }\n            })();\n            function runTimeout(e) {\n                if (r === setTimeout) {\n                    return setTimeout(e, 0);\n                }\n                if ((r === defaultSetTimout || !r) && setTimeout) {\n                    r = setTimeout;\n                    return setTimeout(e, 0);\n                }\n                try {\n                    return r(e, 0);\n                } catch (t) {\n                    try {\n                        return r.call(null, e, 0);\n                    } catch (t) {\n                        return r.call(this, e, 0);\n                    }\n                }\n            }\n            function runClearTimeout(e) {\n                if (n === clearTimeout) {\n                    return clearTimeout(e);\n                }\n                if ((n === defaultClearTimeout || !n) && clearTimeout) {\n                    n = clearTimeout;\n                    return clearTimeout(e);\n                }\n                try {\n                    return n(e);\n                } catch (t) {\n                    try {\n                        return n.call(null, e);\n                    } catch (t) {\n                        return n.call(this, e);\n                    }\n                }\n            }\n            var i = [];\n            var o = false;\n            var u;\n            var a = -1;\n            function cleanUpNextTick() {\n                if (!o || !u) {\n                    return;\n                }\n                o = false;\n                if (u.length) {\n                    i = u.concat(i);\n                } else {\n                    a = -1;\n                }\n                if (i.length) {\n                    drainQueue();\n                }\n            }\n            function drainQueue() {\n                if (o) {\n                    return;\n                }\n                var e = runTimeout(cleanUpNextTick);\n                o = true;\n                var t = i.length;\n                while(t){\n                    u = i;\n                    i = [];\n                    while(++a < t){\n                        if (u) {\n                            u[a].run();\n                        }\n                    }\n                    a = -1;\n                    t = i.length;\n                }\n                u = null;\n                o = false;\n                runClearTimeout(e);\n            }\n            t.nextTick = function(e) {\n                var t = new Array(arguments.length - 1);\n                if (arguments.length > 1) {\n                    for(var r = 1; r < arguments.length; r++){\n                        t[r - 1] = arguments[r];\n                    }\n                }\n                i.push(new Item(e, t));\n                if (i.length === 1 && !o) {\n                    runTimeout(drainQueue);\n                }\n            };\n            function Item(e, t) {\n                this.fun = e;\n                this.array = t;\n            }\n            Item.prototype.run = function() {\n                this.fun.apply(null, this.array);\n            };\n            t.title = \"browser\";\n            t.browser = true;\n            t.env = {};\n            t.argv = [];\n            t.version = \"\";\n            t.versions = {};\n            function noop() {}\n            t.on = noop;\n            t.addListener = noop;\n            t.once = noop;\n            t.off = noop;\n            t.removeListener = noop;\n            t.removeAllListeners = noop;\n            t.emit = noop;\n            t.prependListener = noop;\n            t.prependOnceListener = noop;\n            t.listeners = function(e) {\n                return [];\n            };\n            t.binding = function(e) {\n                throw new Error(\"process.binding is not supported\");\n            };\n            t.cwd = function() {\n                return \"/\";\n            };\n            t.chdir = function(e) {\n                throw new Error(\"process.chdir is not supported\");\n            };\n            t.umask = function() {\n                return 0;\n            };\n        }\n    };\n    var t = {};\n    function __nccwpck_require__(r) {\n        var n = t[r];\n        if (n !== undefined) {\n            return n.exports;\n        }\n        var i = t[r] = {\n            exports: {}\n        };\n        var o = true;\n        try {\n            e[r](i, i.exports, __nccwpck_require__);\n            o = false;\n        } finally{\n            if (o) delete t[r];\n        }\n        return i.exports;\n    }\n    if (typeof __nccwpck_require__ !== \"undefined\") __nccwpck_require__.ab = __dirname + \"/\";\n    var r = __nccwpck_require__(229);\n    module.exports = r;\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcHJvY2Vzcy9icm93c2VyLmpzIiwibWFwcGluZ3MiOiI7O0FBQUM7SUFBVyxJQUFJQSxJQUFFO1FBQUMsS0FBSSxTQUFTQSxDQUFDO1lBQUUsSUFBSUMsSUFBRUQsRUFBRUUsT0FBTyxHQUFDLENBQUM7WUFBRSxJQUFJQztZQUFFLElBQUlDO1lBQUUsU0FBU0M7Z0JBQW1CLE1BQU0sSUFBSUMsTUFBTTtZQUFrQztZQUFDLFNBQVNDO2dCQUFzQixNQUFNLElBQUlELE1BQU07WUFBb0M7WUFBRTtnQkFBVyxJQUFHO29CQUFDLElBQUcsT0FBT0UsZUFBYSxZQUFXO3dCQUFDTCxJQUFFSztvQkFBVSxPQUFLO3dCQUFDTCxJQUFFRTtvQkFBZ0I7Z0JBQUMsRUFBQyxPQUFNTCxHQUFFO29CQUFDRyxJQUFFRTtnQkFBZ0I7Z0JBQUMsSUFBRztvQkFBQyxJQUFHLE9BQU9JLGlCQUFlLFlBQVc7d0JBQUNMLElBQUVLO29CQUFZLE9BQUs7d0JBQUNMLElBQUVHO29CQUFtQjtnQkFBQyxFQUFDLE9BQU1QLEdBQUU7b0JBQUNJLElBQUVHO2dCQUFtQjtZQUFDO1lBQUssU0FBU0csV0FBV1YsQ0FBQztnQkFBRSxJQUFHRyxNQUFJSyxZQUFXO29CQUFDLE9BQU9BLFdBQVdSLEdBQUU7Z0JBQUU7Z0JBQUMsSUFBRyxDQUFDRyxNQUFJRSxvQkFBa0IsQ0FBQ0YsQ0FBQUEsS0FBSUssWUFBVztvQkFBQ0wsSUFBRUs7b0JBQVcsT0FBT0EsV0FBV1IsR0FBRTtnQkFBRTtnQkFBQyxJQUFHO29CQUFDLE9BQU9HLEVBQUVILEdBQUU7Z0JBQUUsRUFBQyxPQUFNQyxHQUFFO29CQUFDLElBQUc7d0JBQUMsT0FBT0UsRUFBRVEsSUFBSSxDQUFDLE1BQUtYLEdBQUU7b0JBQUUsRUFBQyxPQUFNQyxHQUFFO3dCQUFDLE9BQU9FLEVBQUVRLElBQUksQ0FBQyxJQUFJLEVBQUNYLEdBQUU7b0JBQUU7Z0JB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c3QvY29tcGlsZWQvcHJvY2Vzcy9icm93c2VyLmpzPzFiMWQiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7dmFyIGU9ezIyOTpmdW5jdGlvbihlKXt2YXIgdD1lLmV4cG9ydHM9e307dmFyIHI7dmFyIG47ZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpe3Rocm93IG5ldyBFcnJvcihcInNldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9ZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCgpe3Rocm93IG5ldyBFcnJvcihcImNsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFwiKX0oZnVuY3Rpb24oKXt0cnl7aWYodHlwZW9mIHNldFRpbWVvdXQ9PT1cImZ1bmN0aW9uXCIpe3I9c2V0VGltZW91dH1lbHNle3I9ZGVmYXVsdFNldFRpbW91dH19Y2F0Y2goZSl7cj1kZWZhdWx0U2V0VGltb3V0fXRyeXtpZih0eXBlb2YgY2xlYXJUaW1lb3V0PT09XCJmdW5jdGlvblwiKXtuPWNsZWFyVGltZW91dH1lbHNle249ZGVmYXVsdENsZWFyVGltZW91dH19Y2F0Y2goZSl7bj1kZWZhdWx0Q2xlYXJUaW1lb3V0fX0pKCk7ZnVuY3Rpb24gcnVuVGltZW91dChlKXtpZihyPT09c2V0VGltZW91dCl7cmV0dXJuIHNldFRpbWVvdXQoZSwwKX1pZigocj09PWRlZmF1bHRTZXRUaW1vdXR8fCFyKSYmc2V0VGltZW91dCl7cj1zZXRUaW1lb3V0O3JldHVybiBzZXRUaW1lb3V0KGUsMCl9dHJ5e3JldHVybiByKGUsMCl9Y2F0Y2godCl7dHJ5e3JldHVybiByLmNhbGwobnVsbCxlLDApfWNhdGNoKHQpe3JldHVybiByLmNhbGwodGhpcyxlLDApfX19ZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KGUpe2lmKG49PT1jbGVhclRpbWVvdXQpe3JldHVybiBjbGVhclRpbWVvdXQoZSl9aWYoKG49PT1kZWZhdWx0Q2xlYXJUaW1lb3V0fHwhbikmJmNsZWFyVGltZW91dCl7bj1jbGVhclRpbWVvdXQ7cmV0dXJuIGNsZWFyVGltZW91dChlKX10cnl7cmV0dXJuIG4oZSl9Y2F0Y2godCl7dHJ5e3JldHVybiBuLmNhbGwobnVsbCxlKX1jYXRjaCh0KXtyZXR1cm4gbi5jYWxsKHRoaXMsZSl9fX12YXIgaT1bXTt2YXIgbz1mYWxzZTt2YXIgdTt2YXIgYT0tMTtmdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKXtpZighb3x8IXUpe3JldHVybn1vPWZhbHNlO2lmKHUubGVuZ3RoKXtpPXUuY29uY2F0KGkpfWVsc2V7YT0tMX1pZihpLmxlbmd0aCl7ZHJhaW5RdWV1ZSgpfX1mdW5jdGlvbiBkcmFpblF1ZXVlKCl7aWYobyl7cmV0dXJufXZhciBlPXJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtvPXRydWU7dmFyIHQ9aS5sZW5ndGg7d2hpbGUodCl7dT1pO2k9W107d2hpbGUoKythPHQpe2lmKHUpe3VbYV0ucnVuKCl9fWE9LTE7dD1pLmxlbmd0aH11PW51bGw7bz1mYWxzZTtydW5DbGVhclRpbWVvdXQoZSl9dC5uZXh0VGljaz1mdW5jdGlvbihlKXt2YXIgdD1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKTtpZihhcmd1bWVudHMubGVuZ3RoPjEpe2Zvcih2YXIgcj0xO3I8YXJndW1lbnRzLmxlbmd0aDtyKyspe3Rbci0xXT1hcmd1bWVudHNbcl19fWkucHVzaChuZXcgSXRlbShlLHQpKTtpZihpLmxlbmd0aD09PTEmJiFvKXtydW5UaW1lb3V0KGRyYWluUXVldWUpfX07ZnVuY3Rpb24gSXRlbShlLHQpe3RoaXMuZnVuPWU7dGhpcy5hcnJheT10fUl0ZW0ucHJvdG90eXBlLnJ1bj1mdW5jdGlvbigpe3RoaXMuZnVuLmFwcGx5KG51bGwsdGhpcy5hcnJheSl9O3QudGl0bGU9XCJicm93c2VyXCI7dC5icm93c2VyPXRydWU7dC5lbnY9e307dC5hcmd2PVtdO3QudmVyc2lvbj1cIlwiO3QudmVyc2lvbnM9e307ZnVuY3Rpb24gbm9vcCgpe310Lm9uPW5vb3A7dC5hZGRMaXN0ZW5lcj1ub29wO3Qub25jZT1ub29wO3Qub2ZmPW5vb3A7dC5yZW1vdmVMaXN0ZW5lcj1ub29wO3QucmVtb3ZlQWxsTGlzdGVuZXJzPW5vb3A7dC5lbWl0PW5vb3A7dC5wcmVwZW5kTGlzdGVuZXI9bm9vcDt0LnByZXBlbmRPbmNlTGlzdGVuZXI9bm9vcDt0Lmxpc3RlbmVycz1mdW5jdGlvbihlKXtyZXR1cm5bXX07dC5iaW5kaW5nPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcInByb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkXCIpfTt0LmN3ZD1mdW5jdGlvbigpe3JldHVyblwiL1wifTt0LmNoZGlyPWZ1bmN0aW9uKGUpe3Rocm93IG5ldyBFcnJvcihcInByb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZFwiKX07dC51bWFzaz1mdW5jdGlvbigpe3JldHVybiAwfX19O3ZhciB0PXt9O2Z1bmN0aW9uIF9fbmNjd3Bja19yZXF1aXJlX18ocil7dmFyIG49dFtyXTtpZihuIT09dW5kZWZpbmVkKXtyZXR1cm4gbi5leHBvcnRzfXZhciBpPXRbcl09e2V4cG9ydHM6e319O3ZhciBvPXRydWU7dHJ5e2Vbcl0oaSxpLmV4cG9ydHMsX19uY2N3cGNrX3JlcXVpcmVfXyk7bz1mYWxzZX1maW5hbGx5e2lmKG8pZGVsZXRlIHRbcl19cmV0dXJuIGkuZXhwb3J0c31pZih0eXBlb2YgX19uY2N3cGNrX3JlcXVpcmVfXyE9PVwidW5kZWZpbmVkXCIpX19uY2N3cGNrX3JlcXVpcmVfXy5hYj1fX2Rpcm5hbWUrXCIvXCI7dmFyIHI9X19uY2N3cGNrX3JlcXVpcmVfXygyMjkpO21vZHVsZS5leHBvcnRzPXJ9KSgpOyJdLCJuYW1lcyI6WyJlIiwidCIsImV4cG9ydHMiLCJyIiwibiIsImRlZmF1bHRTZXRUaW1vdXQiLCJFcnJvciIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwicnVuVGltZW91dCIsImNhbGwiLCJydW5DbGVhclRpbWVvdXQiLCJpIiwibyIsInUiLCJhIiwiY2xlYW5VcE5leHRUaWNrIiwibGVuZ3RoIiwiY29uY2F0IiwiZHJhaW5RdWV1ZSIsInJ1biIsIm5leHRUaWNrIiwiQXJyYXkiLCJhcmd1bWVudHMiLCJwdXNoIiwiSXRlbSIsImZ1biIsImFycmF5IiwicHJvdG90eXBlIiwiYXBwbHkiLCJ0aXRsZSIsImJyb3dzZXIiLCJlbnYiLCJhcmd2IiwidmVyc2lvbiIsInZlcnNpb25zIiwibm9vcCIsIm9uIiwiYWRkTGlzdGVuZXIiLCJvbmNlIiwib2ZmIiwicmVtb3ZlTGlzdGVuZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJlbWl0IiwicHJlcGVuZExpc3RlbmVyIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsImxpc3RlbmVycyIsImJpbmRpbmciLCJjd2QiLCJjaGRpciIsInVtYXNrIiwiX19uY2N3cGNrX3JlcXVpcmVfXyIsInVuZGVmaW5lZCIsImFiIiwiX19kaXJuYW1lIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/process/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n        // ATTENTION\n        // When adding new symbols to this file,\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n        // The Symbol used to tag the ReactElement-like types.\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n        var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n        var REACT_CACHE_TYPE = Symbol.for(\"react.cache\");\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n        function getIteratorFn(maybeIterable) {\n            if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n                return null;\n            }\n            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n            if (typeof maybeIterator === \"function\") {\n                return maybeIterator;\n            }\n            return null;\n        }\n        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        function error(format) {\n            {\n                {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    printWarning(\"error\", format, args);\n                }\n            }\n        }\n        function printWarning(level, format, args) {\n            // When changing this logic, you might want to also\n            // update consoleWithStackDev.www.js as well.\n            {\n                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n                var stack = ReactDebugCurrentFrame.getStackAddendum();\n                if (stack !== \"\") {\n                    format += \"%s\";\n                    args = args.concat([\n                        stack\n                    ]);\n                } // eslint-disable-next-line react-internal/safe-string-coercion\n                var argsWithFormat = args.map(function(item) {\n                    return String(item);\n                }); // Careful: RN currently depends on this prefix\n                argsWithFormat.unshift(\"Warning: \" + format); // We intentionally don't use spread (or .apply) directly because it\n                // breaks IE9: https://github.com/facebook/react/issues/13610\n                // eslint-disable-next-line react-internal/no-production-logging\n                Function.prototype.apply.call(console[level], console, argsWithFormat);\n            }\n        }\n        // -----------------------------------------------------------------------------\n        var enableScopeAPI = false; // Experimental Create Event Handle API.\n        var enableCacheElement = false;\n        var enableTransitionTracing = false; // No known bugs, but needs performance testing\n        var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n        // stuff. Intended to enable React core members to more easily debug scheduling\n        // issues in DEV builds.\n        var enableDebugTracing = false;\n        var REACT_CLIENT_REFERENCE$2 = Symbol.for(\"react.client.reference\");\n        function isValidElementType(type) {\n            if (typeof type === \"string\" || typeof type === \"function\") {\n                return true;\n            } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n                return true;\n            }\n            if (typeof type === \"object\" && type !== null) {\n                if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n                // types supported by any Flight configuration anywhere since\n                // we don't know which Flight build this will end up being used\n                // with.\n                type.$$typeof === REACT_CLIENT_REFERENCE$2 || type.getModuleId !== undefined) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n            var displayName = outerType.displayName;\n            if (displayName) {\n                return displayName;\n            }\n            var functionName = innerType.displayName || innerType.name || \"\";\n            return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        } // Keep in sync with react-reconciler/getComponentNameFromFiber\n        function getContextName(type) {\n            return type.displayName || \"Context\";\n        }\n        var REACT_CLIENT_REFERENCE$1 = Symbol.for(\"react.client.reference\"); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n        function getComponentNameFromType(type) {\n            if (type == null) {\n                // Host root, text node or just invalid type.\n                return null;\n            }\n            if (typeof type === \"function\") {\n                if (type.$$typeof === REACT_CLIENT_REFERENCE$1) {\n                    // TODO: Create a convention for naming client references with debug info.\n                    return null;\n                }\n                return type.displayName || type.name || null;\n            }\n            if (typeof type === \"string\") {\n                return type;\n            }\n            switch(type){\n                case REACT_FRAGMENT_TYPE:\n                    return \"Fragment\";\n                case REACT_PORTAL_TYPE:\n                    return \"Portal\";\n                case REACT_PROFILER_TYPE:\n                    return \"Profiler\";\n                case REACT_STRICT_MODE_TYPE:\n                    return \"StrictMode\";\n                case REACT_SUSPENSE_TYPE:\n                    return \"Suspense\";\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return \"SuspenseList\";\n                case REACT_CACHE_TYPE:\n                    {\n                        return \"Cache\";\n                    }\n            }\n            if (typeof type === \"object\") {\n                {\n                    if (typeof type.tag === \"number\") {\n                        error(\"Received an unexpected object in getComponentNameFromType(). \" + \"This is likely a bug in React. Please file an issue.\");\n                    }\n                }\n                switch(type.$$typeof){\n                    case REACT_CONTEXT_TYPE:\n                        var context = type;\n                        return getContextName(context) + \".Consumer\";\n                    case REACT_PROVIDER_TYPE:\n                        var provider = type;\n                        return getContextName(provider._context) + \".Provider\";\n                    case REACT_FORWARD_REF_TYPE:\n                        return getWrappedName(type, type.render, \"ForwardRef\");\n                    case REACT_MEMO_TYPE:\n                        var outerName = type.displayName || null;\n                        if (outerName !== null) {\n                            return outerName;\n                        }\n                        return getComponentNameFromType(type.type) || \"Memo\";\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                return getComponentNameFromType(init(payload));\n                            } catch (x) {\n                                return null;\n                            }\n                        }\n                }\n            }\n            return null;\n        }\n        var assign = Object.assign;\n        // Helpers to patch console.logs to avoid logging during side-effect free\n        // replaying on render function. This currently only patches the object\n        // lazily which won't cover if the log function was extracted eagerly.\n        // We could also eagerly patch the method.\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {}\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n            {\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;\n                    prevInfo = console.info;\n                    prevWarn = console.warn;\n                    prevError = console.error;\n                    prevGroup = console.group;\n                    prevGroupCollapsed = console.groupCollapsed;\n                    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n                    var props = {\n                        configurable: true,\n                        enumerable: true,\n                        value: disabledLog,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        info: props,\n                        log: props,\n                        warn: props,\n                        error: props,\n                        group: props,\n                        groupCollapsed: props,\n                        groupEnd: props\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                disabledDepth++;\n            }\n        }\n        function reenableLogs() {\n            {\n                disabledDepth--;\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ var props = {\n                        configurable: true,\n                        enumerable: true,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        log: assign({}, props, {\n                            value: prevLog\n                        }),\n                        info: assign({}, props, {\n                            value: prevInfo\n                        }),\n                        warn: assign({}, props, {\n                            value: prevWarn\n                        }),\n                        error: assign({}, props, {\n                            value: prevError\n                        }),\n                        group: assign({}, props, {\n                            value: prevGroup\n                        }),\n                        groupCollapsed: assign({}, props, {\n                            value: prevGroupCollapsed\n                        }),\n                        groupEnd: assign({}, props, {\n                            value: prevGroupEnd\n                        })\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                if (disabledDepth < 0) {\n                    error(\"disabledDepth fell below zero. \" + \"This is a bug in React. Please file an issue.\");\n                }\n            }\n        }\n        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n        var prefix;\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\n            {\n                if (prefix === undefined) {\n                    // Extract the VM specific prefix used by each line.\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        var match = x.stack.trim().match(/\\n( *(at )?)/);\n                        prefix = match && match[1] || \"\";\n                    }\n                } // We use the prefix to ensure our stacks line up with native stack frames.\n                return \"\\n\" + prefix + name;\n            }\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n            var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n            componentFrameCache = new PossiblyWeakMap();\n        }\n        /**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */ function describeNativeComponentFrame(fn, construct) {\n            // If something asked for a stack inside a fake render, it should get ignored.\n            if (!fn || reentry) {\n                return \"\";\n            }\n            {\n                var frame = componentFrameCache.get(fn);\n                if (frame !== undefined) {\n                    return frame;\n                }\n            }\n            reentry = true;\n            var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n            Error.prepareStackTrace = undefined;\n            var previousDispatcher;\n            {\n                previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n                // for warnings.\n                ReactCurrentDispatcher.current = null;\n                disableLogs();\n            }\n            /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */ var RunInRootFrame = {\n                DetermineComponentFrameRoot: function() {\n                    var control;\n                    try {\n                        // This should throw.\n                        if (construct) {\n                            // Something should be setting the props in the constructor.\n                            var Fake = function() {\n                                throw Error();\n                            }; // $FlowFixMe[prop-missing]\n                            Object.defineProperty(Fake.prototype, \"props\", {\n                                set: function() {\n                                    // We use a throwing setter instead of frozen or non-writable props\n                                    // because that won't throw in a non-strict mode function.\n                                    throw Error();\n                                }\n                            });\n                            if (typeof Reflect === \"object\" && Reflect.construct) {\n                                // We construct a different control for this case to include any extra\n                                // frames added by the construct call.\n                                try {\n                                    Reflect.construct(Fake, []);\n                                } catch (x) {\n                                    control = x;\n                                }\n                                Reflect.construct(fn, [], Fake);\n                            } else {\n                                try {\n                                    Fake.call();\n                                } catch (x) {\n                                    control = x;\n                                } // $FlowFixMe[prop-missing] found when upgrading Flow\n                                fn.call(Fake.prototype);\n                            }\n                        } else {\n                            try {\n                                throw Error();\n                            } catch (x) {\n                                control = x;\n                            } // TODO(luna): This will currently only throw if the function component\n                            // tries to access React/ReactDOM/props. We should probably make this throw\n                            // in simple components too\n                            var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n                            // component, which we don't yet support. Attach a noop catch handler to\n                            // silence the error.\n                            // TODO: Implement component stacks for async client components?\n                            if (maybePromise && typeof maybePromise.catch === \"function\") {\n                                maybePromise.catch(function() {});\n                            }\n                        }\n                    } catch (sample) {\n                        // This is inlined manually because closure doesn't do it for us.\n                        if (sample && control && typeof sample.stack === \"string\") {\n                            return [\n                                sample.stack,\n                                control.stack\n                            ];\n                        }\n                    }\n                    return [\n                        null,\n                        null\n                    ];\n                }\n            }; // $FlowFixMe[prop-missing]\n            RunInRootFrame.DetermineComponentFrameRoot.displayName = \"DetermineComponentFrameRoot\";\n            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, \"name\"); // Before ES6, the `name` property was not configurable.\n            if (namePropDescriptor && namePropDescriptor.configurable) {\n                // V8 utilizes a function's `name` property when generating a stack trace.\n                Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // is set to `false`.\n                // $FlowFixMe[cannot-write]\n                \"name\", {\n                    value: \"DetermineComponentFrameRoot\"\n                });\n            }\n            try {\n                var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];\n                if (sampleStack && controlStack) {\n                    // This extracts the first frame from the sample that isn't also in the control.\n                    // Skipping one frame that we assume is the frame that calls the two.\n                    var sampleLines = sampleStack.split(\"\\n\");\n                    var controlLines = controlStack.split(\"\\n\");\n                    var s = 0;\n                    var c = 0;\n                    while(s < sampleLines.length && !sampleLines[s].includes(\"DetermineComponentFrameRoot\")){\n                        s++;\n                    }\n                    while(c < controlLines.length && !controlLines[c].includes(\"DetermineComponentFrameRoot\")){\n                        c++;\n                    } // We couldn't find our intentionally injected common root frame, attempt\n                    // to find another common root frame by search from the bottom of the\n                    // control stack...\n                    if (s === sampleLines.length || c === controlLines.length) {\n                        s = sampleLines.length - 1;\n                        c = controlLines.length - 1;\n                        while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){\n                            // We expect at least one stack frame to be shared.\n                            // Typically this will be the root most one. However, stack frames may be\n                            // cut off due to maximum stack limits. In this case, one maybe cut off\n                            // earlier than the other. We assume that the sample is longer or the same\n                            // and there for cut off earlier. So we should find the root most frame in\n                            // the sample somewhere in the control.\n                            c--;\n                        }\n                    }\n                    for(; s >= 1 && c >= 0; s--, c--){\n                        // Next we find the first one that isn't the same which should be the\n                        // frame that called our sample function and the control.\n                        if (sampleLines[s] !== controlLines[c]) {\n                            // In V8, the first line is describing the message but other VMs don't.\n                            // If we're about to return the first line, and the control is also on the same\n                            // line, that's a pretty good indicator that our sample threw at same line as\n                            // the control. I.e. before we entered the sample frame. So we ignore this result.\n                            // This can happen if you passed a class to function component, or non-function.\n                            if (s !== 1 || c !== 1) {\n                                do {\n                                    s--;\n                                    c--; // We may still have similar intermediate frames from the construct call.\n                                    // The next one that isn't the same should be our match though.\n                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                                        // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                                        var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \"); // If our component frame is labeled \"<anonymous>\"\n                                        // but we have a user-provided \"displayName\"\n                                        // splice it in to make the stack more readable.\n                                        if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                                            _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                                        }\n                                        if (true) {\n                                            if (typeof fn === \"function\") {\n                                                componentFrameCache.set(fn, _frame);\n                                            }\n                                        } // Return the line we found.\n                                        return _frame;\n                                    }\n                                }while (s >= 1 && c >= 0);\n                            }\n                            break;\n                        }\n                    }\n                }\n            } finally{\n                reentry = false;\n                {\n                    ReactCurrentDispatcher.current = previousDispatcher;\n                    reenableLogs();\n                }\n                Error.prepareStackTrace = previousPrepareStackTrace;\n            } // Fallback to just using the name if we couldn't make it throw.\n            var name = fn ? fn.displayName || fn.name : \"\";\n            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n            {\n                if (typeof fn === \"function\") {\n                    componentFrameCache.set(fn, syntheticFrame);\n                }\n            }\n            return syntheticFrame;\n        }\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(fn, false);\n            }\n        }\n        function shouldConstruct(Component) {\n            var prototype = Component.prototype;\n            return !!(prototype && prototype.isReactComponent);\n        }\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n            if (type == null) {\n                return \"\";\n            }\n            if (typeof type === \"function\") {\n                {\n                    return describeNativeComponentFrame(type, shouldConstruct(type));\n                }\n            }\n            if (typeof type === \"string\") {\n                return describeBuiltInComponentFrame(type);\n            }\n            switch(type){\n                case REACT_SUSPENSE_TYPE:\n                    return describeBuiltInComponentFrame(\"Suspense\");\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return describeBuiltInComponentFrame(\"SuspenseList\");\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        return describeFunctionComponentFrame(type.render);\n                    case REACT_MEMO_TYPE:\n                        // Memo may contain any component type so we recursively resolve it.\n                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                // Lazy may contain any component type so we recursively resolve it.\n                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                            } catch (x) {}\n                        }\n                }\n            }\n            return \"\";\n        }\n        // $FlowFixMe[method-unbinding]\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        var loggedTypeFailures = {};\n        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement$1(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n                }\n            }\n        }\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\n            {\n                // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n                var has = Function.call.bind(hasOwnProperty);\n                for(var typeSpecName in typeSpecs){\n                    if (has(typeSpecs, typeSpecName)) {\n                        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n                        // fail the render phase where it didn't fail before. So we log it.\n                        // After these have been cleaned up, we'll let them throw.\n                        try {\n                            // This is intentionally an invariant that gets caught. It's the same\n                            // behavior as without this statement except with a better message.\n                            if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                                // eslint-disable-next-line react-internal/prod-error-codes\n                                var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                                err.name = \"Invariant Violation\";\n                                throw err;\n                            }\n                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                        } catch (ex) {\n                            error$1 = ex;\n                        }\n                        if (error$1 && !(error$1 instanceof Error)) {\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"%s: type specification of %s\" + \" `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                            // Only monitor this failure once because there tends to be a lot of the\n                            // same error.\n                            loggedTypeFailures[error$1.message] = true;\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"Failed %s type: %s\", location, error$1.message);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                    }\n                }\n            }\n        }\n        var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n        function isArray(a) {\n            return isArrayImpl(a);\n        }\n        /*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */ // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function typeName(value) {\n            {\n                // toStringTag is needed for namespaced types like Temporal.Instant\n                var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\"; // $FlowFixMe[incompatible-return]\n                return type;\n            }\n        } // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function willCoercionThrow(value) {\n            {\n                try {\n                    testStringCoercion(value);\n                    return false;\n                } catch (e) {\n                    return true;\n                }\n            }\n        }\n        function testStringCoercion(value) {\n            // If you ended up here by following an exception call stack, here's what's\n            // happened: you supplied an object or symbol value to React (as a prop, key,\n            // DOM attribute, CSS property, string ref, etc.) and when React tried to\n            // coerce it to a string using `'' + value`, an exception was thrown.\n            //\n            // The most common types that will cause this exception are `Symbol` instances\n            // and Temporal objects like `Temporal.Instant`. But any object that has a\n            // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n            // exception. (Library authors do this to prevent users from using built-in\n            // numeric operators like `+` or comparison operators like `>=` because custom\n            // methods are needed to perform accurate arithmetic or comparison.)\n            //\n            // To fix the problem, coerce this object or symbol value to a string before\n            // passing it to React. The most reliable way is usually `String(value)`.\n            //\n            // To find which value is throwing, check the browser or debugger console.\n            // Before this exception was thrown, there should be `console.error` output\n            // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n            // problem and how that type was used: key, atrribute, input value prop, etc.\n            // In most cases, this console output also shows the component and its\n            // ancestor components where the exception happened.\n            //\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            return \"\" + value;\n        }\n        function checkKeyStringCoercion(value) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided key is an unsupported type %s.\" + \" This value must be coerced to a string before using it here.\", typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n        var RESERVED_PROPS = {\n            key: true,\n            ref: true,\n            __self: true,\n            __source: true\n        };\n        var specialPropKeyWarningShown;\n        var specialPropRefWarningShown;\n        var didWarnAboutStringRefs;\n        {\n            didWarnAboutStringRefs = {};\n        }\n        function hasValidRef(config) {\n            {\n                if (hasOwnProperty.call(config, \"ref\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"ref\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.ref !== undefined;\n        }\n        function hasValidKey(config) {\n            {\n                if (hasOwnProperty.call(config, \"key\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.key !== undefined;\n        }\n        function warnIfStringRefCannotBeAutoConverted(config, self) {\n            {\n                if (typeof config.ref === \"string\" && ReactCurrentOwner$1.current && self && ReactCurrentOwner$1.current.stateNode !== self) {\n                    var componentName = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n                    if (!didWarnAboutStringRefs[componentName]) {\n                        error('Component \"%s\" contains the string ref \"%s\". ' + \"Support for string refs will be removed in a future major release. \" + \"This case cannot be automatically converted to an arrow function. \" + \"We ask you to manually fix this case by using useRef() or createRef() instead. \" + \"Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-string-ref\", getComponentNameFromType(ReactCurrentOwner$1.current.type), config.ref);\n                        didWarnAboutStringRefs[componentName] = true;\n                    }\n                }\n            }\n        }\n        function defineKeyPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingKey = function() {\n                    if (!specialPropKeyWarningShown) {\n                        specialPropKeyWarningShown = true;\n                        error(\"%s: `key` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingKey.isReactWarning = true;\n                Object.defineProperty(props, \"key\", {\n                    get: warnAboutAccessingKey,\n                    configurable: true\n                });\n            }\n        }\n        function defineRefPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingRef = function() {\n                    if (!specialPropRefWarningShown) {\n                        specialPropRefWarningShown = true;\n                        error(\"%s: `ref` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingRef.isReactWarning = true;\n                Object.defineProperty(props, \"ref\", {\n                    get: warnAboutAccessingRef,\n                    configurable: true\n                });\n            }\n        }\n        /**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */ function ReactElement(type, key, ref, self, source, owner, props) {\n            var element = {\n                // This tag allows us to uniquely identify this as a React Element\n                $$typeof: REACT_ELEMENT_TYPE,\n                // Built-in properties that belong on the element\n                type: type,\n                key: key,\n                ref: ref,\n                props: props,\n                // Record the component responsible for creating this element.\n                _owner: owner\n            };\n            {\n                // The validation flag is currently mutative. We put it on\n                // an external backing store so that we can freeze the whole object.\n                // This can be replaced with a WeakMap once they are implemented in\n                // commonly used development environments.\n                element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n                // the validation flag non-enumerable (where possible, which should\n                // include every environment we run tests in), so the test framework\n                // ignores it.\n                Object.defineProperty(element._store, \"validated\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: true,\n                    value: false\n                }); // self and source are DEV only properties.\n                Object.defineProperty(element, \"_self\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: self\n                }); // Two elements created in two different places should be considered\n                // equal for testing purposes and therefore we hide it from enumeration.\n                Object.defineProperty(element, \"_source\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: source\n                });\n                if (Object.freeze) {\n                    Object.freeze(element.props);\n                    Object.freeze(element);\n                }\n            }\n            return element;\n        }\n        /**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */ function jsxDEV$1(type, config, maybeKey, source, self) {\n            {\n                var propName; // Reserved names are extracted\n                var props = {};\n                var key = null;\n                var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n                // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n                // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n                // but as an intermediary step, we will use jsxDEV for everything except\n                // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n                // key is explicitly declared to be undefined or not.\n                if (maybeKey !== undefined) {\n                    {\n                        checkKeyStringCoercion(maybeKey);\n                    }\n                    key = \"\" + maybeKey;\n                }\n                if (hasValidKey(config)) {\n                    {\n                        checkKeyStringCoercion(config.key);\n                    }\n                    key = \"\" + config.key;\n                }\n                if (hasValidRef(config)) {\n                    ref = config.ref;\n                    warnIfStringRefCannotBeAutoConverted(config, self);\n                } // Remaining properties are added to a new props object\n                for(propName in config){\n                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n                        props[propName] = config[propName];\n                    }\n                } // Resolve default props\n                if (type && type.defaultProps) {\n                    var defaultProps = type.defaultProps;\n                    for(propName in defaultProps){\n                        if (props[propName] === undefined) {\n                            props[propName] = defaultProps[propName];\n                        }\n                    }\n                }\n                if (key || ref) {\n                    var displayName = typeof type === \"function\" ? type.displayName || type.name || \"Unknown\" : type;\n                    if (key) {\n                        defineKeyPropWarningGetter(props, displayName);\n                    }\n                    if (ref) {\n                        defineRefPropWarningGetter(props, displayName);\n                    }\n                }\n                return ReactElement(type, key, ref, self, source, ReactCurrentOwner$1.current, props);\n            }\n        }\n        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\n        function setCurrentlyValidatingElement(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame.setExtraStackFrame(null);\n                }\n            }\n        }\n        var propTypesMisspellWarningShown;\n        {\n            propTypesMisspellWarningShown = false;\n        }\n        /**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */ function isValidElement(object) {\n            {\n                return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n            }\n        }\n        function getDeclarationErrorAddendum() {\n            {\n                if (ReactCurrentOwner.current) {\n                    var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n                    if (name) {\n                        return \"\\n\\nCheck the render method of `\" + name + \"`.\";\n                    }\n                }\n                return \"\";\n            }\n        }\n        function getSourceInfoErrorAddendum(source) {\n            {\n                if (source !== undefined) {\n                    var fileName = source.fileName.replace(/^.*[\\\\\\/]/, \"\");\n                    var lineNumber = source.lineNumber;\n                    return \"\\n\\nCheck your code at \" + fileName + \":\" + lineNumber + \".\";\n                }\n                return \"\";\n            }\n        }\n        /**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */ var ownerHasKeyUseWarning = {};\n        function getCurrentComponentErrorInfo(parentType) {\n            {\n                var info = getDeclarationErrorAddendum();\n                if (!info) {\n                    var parentName = getComponentNameFromType(parentType);\n                    if (parentName) {\n                        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n                    }\n                }\n                return info;\n            }\n        }\n        /**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */ function validateExplicitKey(element, parentType) {\n            {\n                if (!element._store || element._store.validated || element.key != null) {\n                    return;\n                }\n                element._store.validated = true;\n                var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n                if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n                    return;\n                }\n                ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n                // property, it may be the creator of the child that's responsible for\n                // assigning it a key.\n                var childOwner = \"\";\n                if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n                    // Give the component that originally created this child.\n                    childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n                }\n                setCurrentlyValidatingElement(element);\n                error('Each child in a list should have a unique \"key\" prop.' + \"%s%s See https://reactjs.org/link/warning-keys for more information.\", currentComponentErrorInfo, childOwner);\n                setCurrentlyValidatingElement(null);\n            }\n        }\n        /**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */ function validateChildKeys(node, parentType) {\n            {\n                if (typeof node !== \"object\" || !node) {\n                    return;\n                }\n                if (node.$$typeof === REACT_CLIENT_REFERENCE) ;\n                else if (isArray(node)) {\n                    for(var i = 0; i < node.length; i++){\n                        var child = node[i];\n                        if (isValidElement(child)) {\n                            validateExplicitKey(child, parentType);\n                        }\n                    }\n                } else if (isValidElement(node)) {\n                    // This element was passed in a valid location.\n                    if (node._store) {\n                        node._store.validated = true;\n                    }\n                } else {\n                    var iteratorFn = getIteratorFn(node);\n                    if (typeof iteratorFn === \"function\") {\n                        // Entry iterators used to provide implicit keys,\n                        // but now we print a separate warning for them later.\n                        if (iteratorFn !== node.entries) {\n                            var iterator = iteratorFn.call(node);\n                            var step;\n                            while(!(step = iterator.next()).done){\n                                if (isValidElement(step.value)) {\n                                    validateExplicitKey(step.value, parentType);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        /**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */ function validatePropTypes(element) {\n            {\n                var type = element.type;\n                if (type === null || type === undefined || typeof type === \"string\") {\n                    return;\n                }\n                if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n                    return;\n                }\n                var propTypes;\n                if (typeof type === \"function\") {\n                    propTypes = type.propTypes;\n                } else if (typeof type === \"object\" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n                // Inner props are checked in the reconciler.\n                type.$$typeof === REACT_MEMO_TYPE)) {\n                    propTypes = type.propTypes;\n                } else {\n                    return;\n                }\n                if (propTypes) {\n                    // Intentionally inside to avoid triggering lazy initializers:\n                    var name = getComponentNameFromType(type);\n                    checkPropTypes(propTypes, element.props, \"prop\", name, element);\n                } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n                    propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n                    var _name = getComponentNameFromType(type);\n                    error(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", _name || \"Unknown\");\n                }\n                if (typeof type.getDefaultProps === \"function\" && !type.getDefaultProps.isReactClassApproved) {\n                    error(\"getDefaultProps is only used on classic React.createClass \" + \"definitions. Use a static property named `defaultProps` instead.\");\n                }\n            }\n        }\n        /**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */ function validateFragmentProps(fragment) {\n            {\n                var keys = Object.keys(fragment.props);\n                for(var i = 0; i < keys.length; i++){\n                    var key = keys[i];\n                    if (key !== \"children\" && key !== \"key\") {\n                        setCurrentlyValidatingElement(fragment);\n                        error(\"Invalid prop `%s` supplied to `React.Fragment`. \" + \"React.Fragment can only have `key` and `children` props.\", key);\n                        setCurrentlyValidatingElement(null);\n                        break;\n                    }\n                }\n                if (fragment.ref !== null) {\n                    setCurrentlyValidatingElement(fragment);\n                    error(\"Invalid attribute `ref` supplied to `React.Fragment`.\");\n                    setCurrentlyValidatingElement(null);\n                }\n            }\n        }\n        var didWarnAboutKeySpread = {};\n        function jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n            {\n                var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n                // succeed and there will likely be errors in render.\n                if (!validType) {\n                    var info = \"\";\n                    if (type === undefined || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                        info += \" You likely forgot to export your component from the file \" + \"it's defined in, or you might have mixed up default and named imports.\";\n                    }\n                    var sourceInfo = getSourceInfoErrorAddendum(source);\n                    if (sourceInfo) {\n                        info += sourceInfo;\n                    } else {\n                        info += getDeclarationErrorAddendum();\n                    }\n                    var typeString;\n                    if (type === null) {\n                        typeString = \"null\";\n                    } else if (isArray(type)) {\n                        typeString = \"array\";\n                    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n                        typeString = \"<\" + (getComponentNameFromType(type.type) || \"Unknown\") + \" />\";\n                        info = \" Did you accidentally export a JSX literal instead of a component?\";\n                    } else {\n                        typeString = typeof type;\n                    }\n                    error(\"React.jsx: type is invalid -- expected a string (for \" + \"built-in components) or a class/function (for composite \" + \"components) but got: %s.%s\", typeString, info);\n                }\n                var element = jsxDEV$1(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n                // TODO: Drop this when these are no longer allowed as the type argument.\n                if (element == null) {\n                    return element;\n                } // Skip key warning if the type isn't valid since our key validation logic\n                // doesn't expect a non-string/function type and can throw confusing errors.\n                // We don't want exception behavior to differ between dev and prod.\n                // (Rendering will throw with a helpful message and as soon as the type is\n                // fixed, the key warnings will appear.)\n                if (validType) {\n                    var children = props.children;\n                    if (children !== undefined) {\n                        if (isStaticChildren) {\n                            if (isArray(children)) {\n                                for(var i = 0; i < children.length; i++){\n                                    validateChildKeys(children[i], type);\n                                }\n                                if (Object.freeze) {\n                                    Object.freeze(children);\n                                }\n                            } else {\n                                error(\"React.jsx: Static children should always be an array. \" + \"You are likely explicitly calling React.jsxs or React.jsxDEV. \" + \"Use the Babel transform instead.\");\n                            }\n                        } else {\n                            validateChildKeys(children, type);\n                        }\n                    }\n                }\n                if (hasOwnProperty.call(props, \"key\")) {\n                    var componentName = getComponentNameFromType(type);\n                    var keys = Object.keys(props).filter(function(k) {\n                        return k !== \"key\";\n                    });\n                    var beforeExample = keys.length > 0 ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\" : \"{key: someKey}\";\n                    if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n                        var afterExample = keys.length > 0 ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\";\n                        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + \"  let props = %s;\\n\" + \"  <%s {...props} />\\n\" + \"React keys must be passed directly to JSX without using spread:\\n\" + \"  let props = %s;\\n\" + \"  <%s key={someKey} {...props} />\", beforeExample, componentName, afterExample, componentName);\n                        didWarnAboutKeySpread[componentName + beforeExample] = true;\n                    }\n                }\n                if (type === REACT_FRAGMENT_TYPE) {\n                    validateFragmentProps(element);\n                } else {\n                    validatePropTypes(element);\n                }\n                return element;\n            }\n        } // These two functions exist to still get child warnings in dev\n        var jsxDEV = jsxWithValidation;\n        exports.Fragment = REACT_FRAGMENT_TYPE;\n        exports.jsxDEV = jsxDEV;\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVEO0FBRUEsSUFBSUEsSUFBcUMsRUFBRTtJQUN4QztRQUNIO1FBRUEsSUFBSUMsUUFBUUMsbUJBQU9BLENBQUMsc0dBQTBCO1FBRTlDLFlBQVk7UUFDWix3Q0FBd0M7UUFDeEMsa0ZBQWtGO1FBQ2xGLHNEQUFzRDtRQUN0RCxJQUFJQyxxQkFBcUJDLE9BQU9DLEdBQUcsQ0FBQztRQUNwQyxJQUFJQyxvQkFBb0JGLE9BQU9DLEdBQUcsQ0FBQztRQUNuQyxJQUFJRSxzQkFBc0JILE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJRyx5QkFBeUJKLE9BQU9DLEdBQUcsQ0FBQztRQUN4QyxJQUFJSSxzQkFBc0JMLE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJSyxzQkFBc0JOLE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJTSxxQkFBcUJQLE9BQU9DLEdBQUcsQ0FBQztRQUNwQyxJQUFJTyx5QkFBeUJSLE9BQU9DLEdBQUcsQ0FBQztRQUN4QyxJQUFJUSxzQkFBc0JULE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJUywyQkFBMkJWLE9BQU9DLEdBQUcsQ0FBQztRQUMxQyxJQUFJVSxrQkFBa0JYLE9BQU9DLEdBQUcsQ0FBQztRQUNqQyxJQUFJVyxrQkFBa0JaLE9BQU9DLEdBQUcsQ0FBQztRQUNqQyxJQUFJWSx1QkFBdUJiLE9BQU9DLEdBQUcsQ0FBQztRQUN0QyxJQUFJYSxtQkFBbUJkLE9BQU9DLEdBQUcsQ0FBQztRQUNsQyxJQUFJYyx3QkFBd0JmLE9BQU9nQixRQUFRO1FBQzNDLElBQUlDLHVCQUF1QjtRQUMzQixTQUFTQyxjQUFjQyxhQUFhO1lBQ2xDLElBQUlBLGtCQUFrQixRQUFRLE9BQU9BLGtCQUFrQixVQUFVO2dCQUMv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LE9BQU8sUUFBUTtvQkFDckMsSUFBSXVFLGdCQUFnQnZHLHlCQUF5QmI7b0JBQzdDLElBQUlzTSxPQUFPM0ssT0FBTzJLLElBQUksQ0FBQ3pKLE9BQU9pSyxNQUFNLENBQUMsU0FBVUMsQ0FBQzt3QkFDOUMsT0FBT0EsTUFBTTtvQkFDZjtvQkFDQSxJQUFJQyxnQkFBZ0JWLEtBQUtqTyxNQUFNLEdBQUcsSUFBSSxvQkFBb0JpTyxLQUFLVyxJQUFJLENBQUMsYUFBYSxXQUFXO29CQUU1RixJQUFJLENBQUNWLHFCQUFxQixDQUFDbkYsZ0JBQWdCNEYsY0FBYyxFQUFFO3dCQUN6RCxJQUFJRSxlQUFlWixLQUFLak8sTUFBTSxHQUFHLElBQUksTUFBTWlPLEtBQUtXLElBQUksQ0FBQyxhQUFhLFdBQVc7d0JBRTdFaFAsTUFBTSx1RUFBdUUsd0JBQXdCLDBCQUEwQixzRUFBc0Usd0JBQXdCLHFDQUFxQytPLGVBQWU1RixlQUFlOEYsY0FBYzlGO3dCQUU5U21GLHFCQUFxQixDQUFDbkYsZ0JBQWdCNEYsY0FBYyxHQUFHO29CQUN6RDtnQkFDRjtnQkFFQSxJQUFJaE4sU0FBU25ELHFCQUFxQjtvQkFDaEN1UCxzQkFBc0J6RjtnQkFDeEIsT0FBTztvQkFDTG1GLGtCQUFrQm5GO2dCQUNwQjtnQkFFQSxPQUFPQTtZQUNUO1FBQ0YsRUFBRSwrREFBK0Q7UUFFakUsSUFBSXdHLFNBQVNYO1FBRWJZLGdCQUFnQixHQUFHdlE7UUFDbkJ1USxjQUFjLEdBQUdEO0lBQ2Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanM/ZmU2MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3RcIik7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpO1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJyk7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJyk7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubGF6eScpO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG52YXIgUkVBQ1RfQ0FDSEVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNhY2hlJyk7XG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG52YXIgZW5hYmxlQ2FjaGVFbGVtZW50ID0gZmFsc2U7XG52YXIgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTsgLy8gTm8ga25vd24gYnVncywgYnV0IG5lZWRzIHBlcmZvcm1hbmNlIHRlc3RpbmdcblxudmFyIGVuYWJsZUxlZ2FjeUhpZGRlbiA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRmliZXJcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7XG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgZW5hYmxlRGVidWdUcmFjaW5nICB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiAgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgIHx8IGVuYWJsZUNhY2hlRWxlbWVudCAgfHwgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG4gICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgLy8gd2l0aC5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgfHwgdHlwZS5nZXRNb2R1bGVJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSkge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHZhciBvdXRlck5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvdXRlck5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ01lbW8nO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG4vKipcbiAqIExldmVyYWdlcyBuYXRpdmUgYnJvd3Nlci9WTSBzdGFjayBmcmFtZXMgdG8gZ2V0IHByb3BlciBkZXRhaWxzIChlLmcuXG4gKiBmaWxlbmFtZSwgbGluZSArIGNvbCBudW1iZXIpIGZvciBhIHNpbmdsZSBjb21wb25lbnQgaW4gYSBjb21wb25lbnQgc3RhY2suIFdlXG4gKiBkbyB0aGlzIGJ5OlxuICogICAoMSkgdGhyb3dpbmcgYW5kIGNhdGNoaW5nIGFuIGVycm9yIGluIHRoZSBmdW5jdGlvbiAtIHRoaXMgd2lsbCBiZSBvdXJcbiAqICAgICAgIGNvbnRyb2wgZXJyb3IuXG4gKiAgICgyKSBjYWxsaW5nIHRoZSBjb21wb25lbnQgd2hpY2ggd2lsbCBldmVudHVhbGx5IHRocm93IGFuIGVycm9yIHRoYXQgd2UnbGxcbiAqICAgICAgIGNhdGNoIC0gdGhpcyB3aWxsIGJlIG91ciBzYW1wbGUgZXJyb3IuXG4gKiAgICgzKSBkaWZmaW5nIHRoZSBjb250cm9sIGFuZCBzYW1wbGUgZXJyb3Igc3RhY2tzIHRvIGZpbmQgdGhlIHN0YWNrIGZyYW1lXG4gKiAgICAgICB3aGljaCByZXByZXNlbnRzIG91ciBjb21wb25lbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kaW5nIGEgY29tbW9uIHN0YWNrIGZyYW1lIGJldHdlZW4gc2FtcGxlIGFuZCBjb250cm9sIGVycm9ycyBjYW4gYmVcbiAgICogdHJpY2t5IGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMgYW5kIGxldmVscyBvZiBzdGFjayB0cmFjZSB0cnVuY2F0aW9uIGZyb21cbiAgICogZGlmZmVyZW50IEpTIFZNcy4gU28gaW5zdGVhZCB3ZSdsbCBhdHRlbXB0IHRvIGNvbnRyb2wgd2hhdCB0aGF0IGNvbW1vblxuICAgKiBmcmFtZSBzaG91bGQgYmUgdGhyb3VnaCB0aGlzIG9iamVjdCBtZXRob2Q6XG4gICAqIEhhdmluZyBib3RoIHRoZSBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGJlIGluIHRoZSBmdW5jdGlvbiB1bmRlciB0aGVcbiAgICogYERlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWVSb290YCBwcm9wZXJ0eSwgKyBzZXR0aW5nIHRoZSBgbmFtZWAgYW5kXG4gICAqIGBkaXNwbGF5TmFtZWAgcHJvcGVydGllcyBvZiB0aGUgZnVuY3Rpb24gZW5zdXJlcyB0aGF0IGEgc3RhY2tcbiAgICogZnJhbWUgZXhpc3RzIHRoYXQgaGFzIHRoZSBtZXRob2QgbmFtZSBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIGluXG4gICAqIGl0IGZvciBib3RoIGNvbnRyb2wgYW5kIHNhbXBsZSBzdGFja3MuXG4gICAqL1xuXG5cbiAgdmFyIFJ1bkluUm9vdEZyYW1lID0ge1xuICAgIERldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbnRyb2w7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH07IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgIH0gLy8gVE9ETyhsdW5hKTogVGhpcyB3aWxsIGN1cnJlbnRseSBvbmx5IHRocm93IGlmIHRoZSBmdW5jdGlvbiBjb21wb25lbnRcbiAgICAgICAgICAvLyB0cmllcyB0byBhY2Nlc3MgUmVhY3QvUmVhY3RET00vcHJvcHMuIFdlIHNob3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgdGhyb3dcbiAgICAgICAgICAvLyBpbiBzaW1wbGUgY29tcG9uZW50cyB0b29cblxuXG4gICAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IGZuKCk7IC8vIElmIHRoZSBmdW5jdGlvbiBjb21wb25lbnQgcmV0dXJucyBhIHByb21pc2UsIGl0J3MgbGlrZWx5IGFuIGFzeW5jXG4gICAgICAgICAgLy8gY29tcG9uZW50LCB3aGljaCB3ZSBkb24ndCB5ZXQgc3VwcG9ydC4gQXR0YWNoIGEgbm9vcCBjYXRjaCBoYW5kbGVyIHRvXG4gICAgICAgICAgLy8gc2lsZW5jZSB0aGUgZXJyb3IuXG4gICAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IGNvbXBvbmVudCBzdGFja3MgZm9yIGFzeW5jIGNsaWVudCBjb21wb25lbnRzP1xuXG4gICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSAmJiB0eXBlb2YgbWF5YmVQcm9taXNlLmNhdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UuY2F0Y2goZnVuY3Rpb24gKCkge30pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiBbc2FtcGxlLnN0YWNrLCBjb250cm9sLnN0YWNrXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgIH1cbiAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cbiAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID0gJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCc7XG4gIHZhciBuYW1lUHJvcERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgJ25hbWUnKTsgLy8gQmVmb3JlIEVTNiwgdGhlIGBuYW1lYCBwcm9wZXJ0eSB3YXMgbm90IGNvbmZpZ3VyYWJsZS5cblxuICBpZiAobmFtZVByb3BEZXNjcmlwdG9yICYmIG5hbWVQcm9wRGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcbiAgICAvLyBWOCB1dGlsaXplcyBhIGZ1bmN0aW9uJ3MgYG5hbWVgIHByb3BlcnR5IHdoZW4gZ2VuZXJhdGluZyBhIHN0YWNrIHRyYWNlLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsIC8vIENvbmZpZ3VyYWJsZSBwcm9wZXJ0aWVzIGNhbiBiZSB1cGRhdGVkIGV2ZW4gaWYgaXRzIHdyaXRhYmxlIGRlc2NyaXB0b3JcbiAgICAvLyBpcyBzZXQgdG8gYGZhbHNlYC5cbiAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV1cbiAgICAnbmFtZScsIHtcbiAgICAgIHZhbHVlOiAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290J1xuICAgIH0pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIgX1J1bkluUm9vdEZyYW1lJERldGVyID0gUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290KCksXG4gICAgICAgIHNhbXBsZVN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzBdLFxuICAgICAgICBjb250cm9sU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMV07XG5cbiAgICBpZiAoc2FtcGxlU3RhY2sgJiYgY29udHJvbFN0YWNrKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGVTdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbFN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gMDtcbiAgICAgIHZhciBjID0gMDtcblxuICAgICAgd2hpbGUgKHMgPCBzYW1wbGVMaW5lcy5sZW5ndGggJiYgIXNhbXBsZUxpbmVzW3NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBzKys7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChjIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJiAhY29udHJvbExpbmVzW2NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBjKys7XG4gICAgICB9IC8vIFdlIGNvdWxkbid0IGZpbmQgb3VyIGludGVudGlvbmFsbHkgaW5qZWN0ZWQgY29tbW9uIHJvb3QgZnJhbWUsIGF0dGVtcHRcbiAgICAgIC8vIHRvIGZpbmQgYW5vdGhlciBjb21tb24gcm9vdCBmcmFtZSBieSBzZWFyY2ggZnJvbSB0aGUgYm90dG9tIG9mIHRoZVxuICAgICAgLy8gY29udHJvbCBzdGFjay4uLlxuXG5cbiAgICAgIGlmIChzID09PSBzYW1wbGVMaW5lcy5sZW5ndGggfHwgYyA9PT0gY29udHJvbExpbmVzLmxlbmd0aCkge1xuICAgICAgICBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgICAgYy0tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpOyAvLyBJZiBvdXIgY29tcG9uZW50IGZyYW1lIGlzIGxhYmVsZWQgXCI8YW5vbnltb3VzPlwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cbiAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG59XG5cbi8qXG4gKiBUaGUgYCcnICsgdmFsdWVgIHBhdHRlcm4gKHVzZWQgaW4gcGVyZi1zZW5zaXRpdmUgY29kZSkgdGhyb3dzIGZvciBTeW1ib2xcbiAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB3aWxsIHRocm93IGFuIGVhc2llci10by11bmRlcnN0YW5kLFxuICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxuICogcHJvYmxlbS4gKEluc3RlYWQgb2YgYSBjb25mdXNpbmcgZXhjZXB0aW9uIHRocm93biBpbnNpZGUgdGhlIGltcGxlbWVudGF0aW9uXG4gKiBvZiB0aGUgYHZhbHVlYCBvYmplY3QpLlxuICovXG4vLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAge1xuICAgIC8vIHRvU3RyaW5nVGFnIGlzIG5lZWRlZCBmb3IgbmFtZXNwYWNlZCB0eXBlcyBsaWtlIFRlbXBvcmFsLkluc3RhbnRcbiAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0JzsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbn0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cblxuXG5mdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xuICB7XG4gICAgdHJ5IHtcbiAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAvLyBJZiB5b3UgZW5kZWQgdXAgaGVyZSBieSBmb2xsb3dpbmcgYW4gZXhjZXB0aW9uIGNhbGwgc3RhY2ssIGhlcmUncyB3aGF0J3NcbiAgLy8gaGFwcGVuZWQ6IHlvdSBzdXBwbGllZCBhbiBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIFJlYWN0IChhcyBhIHByb3AsIGtleSxcbiAgLy8gRE9NIGF0dHJpYnV0ZSwgQ1NTIHByb3BlcnR5LCBzdHJpbmcgcmVmLCBldGMuKSBhbmQgd2hlbiBSZWFjdCB0cmllZCB0b1xuICAvLyBjb2VyY2UgaXQgdG8gYSBzdHJpbmcgdXNpbmcgYCcnICsgdmFsdWVgLCBhbiBleGNlcHRpb24gd2FzIHRocm93bi5cbiAgLy9cbiAgLy8gVGhlIG1vc3QgY29tbW9uIHR5cGVzIHRoYXQgd2lsbCBjYXVzZSB0aGlzIGV4Y2VwdGlvbiBhcmUgYFN5bWJvbGAgaW5zdGFuY2VzXG4gIC8vIGFuZCBUZW1wb3JhbCBvYmplY3RzIGxpa2UgYFRlbXBvcmFsLkluc3RhbnRgLiBCdXQgYW55IG9iamVjdCB0aGF0IGhhcyBhXG4gIC8vIGB2YWx1ZU9mYCBvciBgW1N5bWJvbC50b1ByaW1pdGl2ZV1gIG1ldGhvZCB0aGF0IHRocm93cyB3aWxsIGFsc28gY2F1c2UgdGhpc1xuICAvLyBleGNlcHRpb24uIChMaWJyYXJ5IGF1dGhvcnMgZG8gdGhpcyB0byBwcmV2ZW50IHVzZXJzIGZyb20gdXNpbmcgYnVpbHQtaW5cbiAgLy8gbnVtZXJpYyBvcGVyYXRvcnMgbGlrZSBgK2Agb3IgY29tcGFyaXNvbiBvcGVyYXRvcnMgbGlrZSBgPj1gIGJlY2F1c2UgY3VzdG9tXG4gIC8vIG1ldGhvZHMgYXJlIG5lZWRlZCB0byBwZXJmb3JtIGFjY3VyYXRlIGFyaXRobWV0aWMgb3IgY29tcGFyaXNvbi4pXG4gIC8vXG4gIC8vIFRvIGZpeCB0aGUgcHJvYmxlbSwgY29lcmNlIHRoaXMgb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZyBiZWZvcmVcbiAgLy8gcGFzc2luZyBpdCB0byBSZWFjdC4gVGhlIG1vc3QgcmVsaWFibGUgd2F5IGlzIHVzdWFsbHkgYFN0cmluZyh2YWx1ZSlgLlxuICAvL1xuICAvLyBUbyBmaW5kIHdoaWNoIHZhbHVlIGlzIHRocm93aW5nLCBjaGVjayB0aGUgYnJvd3NlciBvciBkZWJ1Z2dlciBjb25zb2xlLlxuICAvLyBCZWZvcmUgdGhpcyBleGNlcHRpb24gd2FzIHRocm93biwgdGhlcmUgc2hvdWxkIGJlIGBjb25zb2xlLmVycm9yYCBvdXRwdXRcbiAgLy8gdGhhdCBzaG93cyB0aGUgdHlwZSAoU3ltYm9sLCBUZW1wb3JhbC5QbGFpbkRhdGUsIGV0Yy4pIHRoYXQgY2F1c2VkIHRoZVxuICAvLyBwcm9ibGVtIGFuZCBob3cgdGhhdCB0eXBlIHdhcyB1c2VkOiBrZXksIGF0cnJpYnV0ZSwgaW5wdXQgdmFsdWUgcHJvcCwgZXRjLlxuICAvLyBJbiBtb3N0IGNhc2VzLCB0aGlzIGNvbnNvbGUgb3V0cHV0IGFsc28gc2hvd3MgdGhlIGNvbXBvbmVudCBhbmQgaXRzXG4gIC8vIGFuY2VzdG9yIGNvbXBvbmVudHMgd2hlcmUgdGhlIGV4Y2VwdGlvbiBoYXBwZW5lZC5cbiAgLy9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gIHJldHVybiAnJyArIHZhbHVlO1xufVxuZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LCBwcm9wcyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUocGFyZW50VHlwZSk7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JyB8fCAhbm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChub2RlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSA7IGVsc2UgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYkMSh0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBrICE9PSAna2V5JztcbiAgICAgIH0pO1xuICAgICAgdmFyIGJlZm9yZUV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAne2tleTogc29tZUtleSwgJyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne2tleTogc29tZUtleX0nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0pIHtcbiAgICAgICAgdmFyIGFmdGVyRXhhbXBsZSA9IGtleXMubGVuZ3RoID4gMCA/ICd7JyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne30nO1xuXG4gICAgICAgIGVycm9yKCdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyB7Li4ucHJvcHN9IC8+XFxuJyArICdSZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyBrZXk9e3NvbWVLZXl9IHsuLi5wcm9wc30gLz4nLCBiZWZvcmVFeGFtcGxlLCBjb21wb25lbnROYW1lLCBhZnRlckV4YW1wbGUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxuXG52YXIganN4REVWID0ganN4V2l0aFZhbGlkYXRpb24gO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJSZWFjdCIsInJlcXVpcmUiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJSRUFDVF9QT1JUQUxfVFlQRSIsIlJFQUNUX0ZSQUdNRU5UX1RZUEUiLCJSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIiwiUkVBQ1RfUFJPRklMRVJfVFlQRSIsIlJFQUNUX1BST1ZJREVSX1RZUEUiLCJSRUFDVF9DT05URVhUX1RZUEUiLCJSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSIsIlJFQUNUX01FTU9fVFlQRSIsIlJFQUNUX0xBWllfVFlQRSIsIlJFQUNUX09GRlNDUkVFTl9UWVBFIiwiUkVBQ1RfQ0FDSEVfVFlQRSIsIk1BWUJFX0lURVJBVE9SX1NZTUJPTCIsIml0ZXJhdG9yIiwiRkFVWF9JVEVSQVRPUl9TWU1CT0wiLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYWJsZSIsIm1heWJlSXRlcmF0b3IiLCJSZWFjdFNoYXJlZEludGVybmFscyIsIl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIiwiZXJyb3IiLCJmb3JtYXQiLCJfbGVuMiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkyIiwicHJpbnRXYXJuaW5nIiwibGV2ZWwiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lIiwic3RhY2siLCJnZXRTdGFja0FkZGVuZHVtIiwiY29uY2F0IiwiYXJnc1dpdGhGb3JtYXQiLCJtYXAiLCJpdGVtIiwiU3RyaW5nIiwidW5zaGlmdCIsIkZ1bmN0aW9uIiwicHJvdG90eXBlIiwiYXBwbHkiLCJjYWxsIiwiY29uc29sZSIsImVuYWJsZVNjb3BlQVBJIiwiZW5hYmxlQ2FjaGVFbGVtZW50IiwiZW5hYmxlVHJhbnNpdGlvblRyYWNpbmciLCJlbmFibGVMZWdhY3lIaWRkZW4iLCJlbmFibGVEZWJ1Z1RyYWNpbmciLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJ0eXBlIiwiJCR0eXBlb2YiLCJnZXRNb2R1bGVJZCIsInVuZGVmaW5lZCIsImdldFdyYXBwZWROYW1lIiwib3V0ZXJUeXBlIiwiaW5uZXJUeXBlIiwid3JhcHBlck5hbWUiLCJkaXNwbGF5TmFtZSIsImZ1bmN0aW9uTmFtZSIsIm5hbWUiLCJnZXRDb250ZXh0TmFtZSIsIlJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSIsImdldENvbXBvbmVudE5hbWVGcm9tVHlwZSIsInRhZyIsImNvbnRleHQiLCJwcm92aWRlciIsIl9jb250ZXh0IiwicmVuZGVyIiwib3V0ZXJOYW1lIiwibGF6eUNvbXBvbmVudCIsInBheWxvYWQiLCJfcGF5bG9hZCIsImluaXQiLCJfaW5pdCIsIngiLCJhc3NpZ24iLCJPYmplY3QiLCJkaXNhYmxlZERlcHRoIiwicHJldkxvZyIsInByZXZJbmZvIiwicHJldldhcm4iLCJwcmV2RXJyb3IiLCJwcmV2R3JvdXAiLCJwcmV2R3JvdXBDb2xsYXBzZWQiLCJwcmV2R3JvdXBFbmQiLCJkaXNhYmxlZExvZyIsIl9fcmVhY3REaXNhYmxlZExvZyIsImRpc2FibGVMb2dzIiwibG9nIiwiaW5mbyIsIndhcm4iLCJncm91cCIsImdyb3VwQ29sbGFwc2VkIiwiZ3JvdXBFbmQiLCJwcm9wcyIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ2YWx1ZSIsIndyaXRhYmxlIiwiZGVmaW5lUHJvcGVydGllcyIsInJlZW5hYmxlTG9ncyIsIlJlYWN0Q3VycmVudERpc3BhdGNoZXIiLCJwcmVmaXgiLCJkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSIsInNvdXJjZSIsIm93bmVyRm4iLCJFcnJvciIsIm1hdGNoIiwidHJpbSIsInJlZW50cnkiLCJjb21wb25lbnRGcmFtZUNhY2hlIiwiUG9zc2libHlXZWFrTWFwIiwiV2Vha01hcCIsIk1hcCIsImRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUiLCJmbiIsImNvbnN0cnVjdCIsImZyYW1lIiwiZ2V0IiwicHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSIsInByZXBhcmVTdGFja1RyYWNlIiwicHJldmlvdXNEaXNwYXRjaGVyIiwiY3VycmVudCIsIlJ1bkluUm9vdEZyYW1lIiwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290IiwiY29udHJvbCIsIkZha2UiLCJkZWZpbmVQcm9wZXJ0eSIsInNldCIsIlJlZmxlY3QiLCJtYXliZVByb21pc2UiLCJjYXRjaCIsInNhbXBsZSIsIm5hbWVQcm9wRGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9SdW5JblJvb3RGcmFtZSREZXRlciIsInNhbXBsZVN0YWNrIiwiY29udHJvbFN0YWNrIiwic2FtcGxlTGluZXMiLCJzcGxpdCIsImNvbnRyb2xMaW5lcyIsInMiLCJjIiwiaW5jbHVkZXMiLCJfZnJhbWUiLCJyZXBsYWNlIiwic3ludGhldGljRnJhbWUiLCJkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUiLCJzaG91bGRDb25zdHJ1Y3QiLCJDb21wb25lbnQiLCJpc1JlYWN0Q29tcG9uZW50IiwiZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWIiwiaGFzT3duUHJvcGVydHkiLCJsb2dnZWRUeXBlRmFpbHVyZXMiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEiLCJzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxIiwiZWxlbWVudCIsIm93bmVyIiwiX293bmVyIiwiX3NvdXJjZSIsInNldEV4dHJhU3RhY2tGcmFtZSIsImNoZWNrUHJvcFR5cGVzIiwidHlwZVNwZWNzIiwidmFsdWVzIiwibG9jYXRpb24iLCJjb21wb25lbnROYW1lIiwiaGFzIiwiYmluZCIsInR5cGVTcGVjTmFtZSIsImVycm9yJDEiLCJlcnIiLCJleCIsIm1lc3NhZ2UiLCJpc0FycmF5SW1wbCIsImlzQXJyYXkiLCJhIiwidHlwZU5hbWUiLCJoYXNUb1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwiY29uc3RydWN0b3IiLCJ3aWxsQ29lcmNpb25UaHJvdyIsInRlc3RTdHJpbmdDb2VyY2lvbiIsImUiLCJjaGVja0tleVN0cmluZ0NvZXJjaW9uIiwiUmVhY3RDdXJyZW50T3duZXIkMSIsIlJlYWN0Q3VycmVudE93bmVyIiwiUkVTRVJWRURfUFJPUFMiLCJrZXkiLCJyZWYiLCJfX3NlbGYiLCJfX3NvdXJjZSIsInNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duIiwic3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24iLCJkaWRXYXJuQWJvdXRTdHJpbmdSZWZzIiwiaGFzVmFsaWRSZWYiLCJjb25maWciLCJnZXR0ZXIiLCJpc1JlYWN0V2FybmluZyIsImhhc1ZhbGlkS2V5Iiwid2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkIiwic2VsZiIsInN0YXRlTm9kZSIsImRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nS2V5IiwiZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdSZWYiLCJSZWFjdEVsZW1lbnQiLCJfc3RvcmUiLCJmcmVlemUiLCJqc3hERVYkMSIsIm1heWJlS2V5IiwicHJvcE5hbWUiLCJkZWZhdWx0UHJvcHMiLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFIiwic2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQiLCJwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biIsImlzVmFsaWRFbGVtZW50Iiwib2JqZWN0IiwiZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtIiwiZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0iLCJmaWxlTmFtZSIsImxpbmVOdW1iZXIiLCJvd25lckhhc0tleVVzZVdhcm5pbmciLCJnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwicGFyZW50VHlwZSIsInBhcmVudE5hbWUiLCJ2YWxpZGF0ZUV4cGxpY2l0S2V5IiwidmFsaWRhdGVkIiwiY3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsImNoaWxkT3duZXIiLCJ2YWxpZGF0ZUNoaWxkS2V5cyIsIm5vZGUiLCJpIiwiY2hpbGQiLCJpdGVyYXRvckZuIiwiZW50cmllcyIsInN0ZXAiLCJuZXh0IiwiZG9uZSIsInZhbGlkYXRlUHJvcFR5cGVzIiwicHJvcFR5cGVzIiwiUHJvcFR5cGVzIiwiX25hbWUiLCJnZXREZWZhdWx0UHJvcHMiLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsInZhbGlkYXRlRnJhZ21lbnRQcm9wcyIsImZyYWdtZW50Iiwia2V5cyIsImRpZFdhcm5BYm91dEtleVNwcmVhZCIsImpzeFdpdGhWYWxpZGF0aW9uIiwiaXNTdGF0aWNDaGlsZHJlbiIsInZhbGlkVHlwZSIsInNvdXJjZUluZm8iLCJ0eXBlU3RyaW5nIiwiY2hpbGRyZW4iLCJmaWx0ZXIiLCJrIiwiYmVmb3JlRXhhbXBsZSIsImpvaW4iLCJhZnRlckV4YW1wbGUiLCJqc3hERVYiLCJleHBvcnRzIiwiRnJhZ21lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsS0FBeUIsRUFBYyxFQUUxQyxNQUFNO0lBQ0xDLDhMQUF5QjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcz9jYTIwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/util/util.js":
/*!******************************************************!*\
  !*** ./node_modules/next/dist/compiled/util/util.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("var __dirname = \"/\";\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\n(function() {\n    var r = {\n        992: function(r) {\n            r.exports = function(r, t, o) {\n                if (r.filter) return r.filter(t, o);\n                if (void 0 === r || null === r) throw new TypeError;\n                if (\"function\" != typeof t) throw new TypeError;\n                var n = [];\n                for(var i = 0; i < r.length; i++){\n                    if (!e.call(r, i)) continue;\n                    var a = r[i];\n                    if (t.call(o, a, i, r)) n.push(a);\n                }\n                return n;\n            };\n            var e = Object.prototype.hasOwnProperty;\n        },\n        256: function(r, e, t) {\n            \"use strict\";\n            var o = t(925);\n            var n = t(139);\n            var i = n(o(\"String.prototype.indexOf\"));\n            r.exports = function callBoundIntrinsic(r, e) {\n                var t = o(r, !!e);\n                if (typeof t === \"function\" && i(r, \".prototype.\") > -1) {\n                    return n(t);\n                }\n                return t;\n            };\n        },\n        139: function(r, e, t) {\n            \"use strict\";\n            var o = t(174);\n            var n = t(925);\n            var i = n(\"%Function.prototype.apply%\");\n            var a = n(\"%Function.prototype.call%\");\n            var y = n(\"%Reflect.apply%\", true) || o.call(a, i);\n            var f = n(\"%Object.getOwnPropertyDescriptor%\", true);\n            var p = n(\"%Object.defineProperty%\", true);\n            var u = n(\"%Math.max%\");\n            if (p) {\n                try {\n                    p({}, \"a\", {\n                        value: 1\n                    });\n                } catch (r) {\n                    p = null;\n                }\n            }\n            r.exports = function callBind(r) {\n                var e = y(o, a, arguments);\n                if (f && p) {\n                    var t = f(e, \"length\");\n                    if (t.configurable) {\n                        p(e, \"length\", {\n                            value: 1 + u(0, r.length - (arguments.length - 1))\n                        });\n                    }\n                }\n                return e;\n            };\n            var s = function applyBind() {\n                return y(o, i, arguments);\n            };\n            if (p) {\n                p(r.exports, \"apply\", {\n                    value: s\n                });\n            } else {\n                r.exports.apply = s;\n            }\n        },\n        144: function(r) {\n            var e = Object.prototype.hasOwnProperty;\n            var t = Object.prototype.toString;\n            r.exports = function forEach(r, o, n) {\n                if (t.call(o) !== \"[object Function]\") {\n                    throw new TypeError(\"iterator must be a function\");\n                }\n                var i = r.length;\n                if (i === +i) {\n                    for(var a = 0; a < i; a++){\n                        o.call(n, r[a], a, r);\n                    }\n                } else {\n                    for(var y in r){\n                        if (e.call(r, y)) {\n                            o.call(n, r[y], y, r);\n                        }\n                    }\n                }\n            };\n        },\n        426: function(r) {\n            \"use strict\";\n            var e = \"Function.prototype.bind called on incompatible \";\n            var t = Array.prototype.slice;\n            var o = Object.prototype.toString;\n            var n = \"[object Function]\";\n            r.exports = function bind(r) {\n                var i = this;\n                if (typeof i !== \"function\" || o.call(i) !== n) {\n                    throw new TypeError(e + i);\n                }\n                var a = t.call(arguments, 1);\n                var y;\n                var binder = function() {\n                    if (this instanceof y) {\n                        var e = i.apply(this, a.concat(t.call(arguments)));\n                        if (Object(e) === e) {\n                            return e;\n                        }\n                        return this;\n                    } else {\n                        return i.apply(r, a.concat(t.call(arguments)));\n                    }\n                };\n                var f = Math.max(0, i.length - a.length);\n                var p = [];\n                for(var u = 0; u < f; u++){\n                    p.push(\"$\" + u);\n                }\n                y = Function(\"binder\", \"return function (\" + p.join(\",\") + \"){ return binder.apply(this,arguments); }\")(binder);\n                if (i.prototype) {\n                    var s = function Empty() {};\n                    s.prototype = i.prototype;\n                    y.prototype = new s;\n                    s.prototype = null;\n                }\n                return y;\n            };\n        },\n        174: function(r, e, t) {\n            \"use strict\";\n            var o = t(426);\n            r.exports = Function.prototype.bind || o;\n        },\n        500: function(r, e, t) {\n            \"use strict\";\n            var o;\n            var n = SyntaxError;\n            var i = Function;\n            var a = TypeError;\n            var getEvalledConstructor = function(r) {\n                try {\n                    return i('\"use strict\"; return (' + r + \").constructor;\")();\n                } catch (r) {}\n            };\n            var y = Object.getOwnPropertyDescriptor;\n            if (y) {\n                try {\n                    y({}, \"\");\n                } catch (r) {\n                    y = null;\n                }\n            }\n            var throwTypeError = function() {\n                throw new a;\n            };\n            var f = y ? function() {\n                try {\n                    arguments.callee;\n                    return throwTypeError;\n                } catch (r) {\n                    try {\n                        return y(arguments, \"callee\").get;\n                    } catch (r) {\n                        return throwTypeError;\n                    }\n                }\n            }() : throwTypeError;\n            var p = t(115)();\n            var u = Object.getPrototypeOf || function(r) {\n                return r.__proto__;\n            };\n            var s = {};\n            var c = typeof Uint8Array === \"undefined\" ? o : u(Uint8Array);\n            var l = {\n                \"%AggregateError%\": typeof AggregateError === \"undefined\" ? o : AggregateError,\n                \"%Array%\": Array,\n                \"%ArrayBuffer%\": typeof ArrayBuffer === \"undefined\" ? o : ArrayBuffer,\n                \"%ArrayIteratorPrototype%\": p ? u([][Symbol.iterator]()) : o,\n                \"%AsyncFromSyncIteratorPrototype%\": o,\n                \"%AsyncFunction%\": s,\n                \"%AsyncGenerator%\": s,\n                \"%AsyncGeneratorFunction%\": s,\n                \"%AsyncIteratorPrototype%\": s,\n                \"%Atomics%\": typeof Atomics === \"undefined\" ? o : Atomics,\n                \"%BigInt%\": typeof BigInt === \"undefined\" ? o : BigInt,\n                \"%Boolean%\": Boolean,\n                \"%DataView%\": typeof DataView === \"undefined\" ? o : DataView,\n                \"%Date%\": Date,\n                \"%decodeURI%\": decodeURI,\n                \"%decodeURIComponent%\": decodeURIComponent,\n                \"%encodeURI%\": encodeURI,\n                \"%encodeURIComponent%\": encodeURIComponent,\n                \"%Error%\": Error,\n                \"%eval%\": eval,\n                \"%EvalError%\": EvalError,\n                \"%Float32Array%\": typeof Float32Array === \"undefined\" ? o : Float32Array,\n                \"%Float64Array%\": typeof Float64Array === \"undefined\" ? o : Float64Array,\n                \"%FinalizationRegistry%\": typeof FinalizationRegistry === \"undefined\" ? o : FinalizationRegistry,\n                \"%Function%\": i,\n                \"%GeneratorFunction%\": s,\n                \"%Int8Array%\": typeof Int8Array === \"undefined\" ? o : Int8Array,\n                \"%Int16Array%\": typeof Int16Array === \"undefined\" ? o : Int16Array,\n                \"%Int32Array%\": typeof Int32Array === \"undefined\" ? o : Int32Array,\n                \"%isFinite%\": isFinite,\n                \"%isNaN%\": isNaN,\n                \"%IteratorPrototype%\": p ? u(u([][Symbol.iterator]())) : o,\n                \"%JSON%\": typeof JSON === \"object\" ? JSON : o,\n                \"%Map%\": typeof Map === \"undefined\" ? o : Map,\n                \"%MapIteratorPrototype%\": typeof Map === \"undefined\" || !p ? o : u((new Map)[Symbol.iterator]()),\n                \"%Math%\": Math,\n                \"%Number%\": Number,\n                \"%Object%\": Object,\n                \"%parseFloat%\": parseFloat,\n                \"%parseInt%\": parseInt,\n                \"%Promise%\": typeof Promise === \"undefined\" ? o : Promise,\n                \"%Proxy%\": typeof Proxy === \"undefined\" ? o : Proxy,\n                \"%RangeError%\": RangeError,\n                \"%ReferenceError%\": ReferenceError,\n                \"%Reflect%\": typeof Reflect === \"undefined\" ? o : Reflect,\n                \"%RegExp%\": RegExp,\n                \"%Set%\": typeof Set === \"undefined\" ? o : Set,\n                \"%SetIteratorPrototype%\": typeof Set === \"undefined\" || !p ? o : u((new Set)[Symbol.iterator]()),\n                \"%SharedArrayBuffer%\": typeof SharedArrayBuffer === \"undefined\" ? o : SharedArrayBuffer,\n                \"%String%\": String,\n                \"%StringIteratorPrototype%\": p ? u(\"\"[Symbol.iterator]()) : o,\n                \"%Symbol%\": p ? Symbol : o,\n                \"%SyntaxError%\": n,\n                \"%ThrowTypeError%\": f,\n                \"%TypedArray%\": c,\n                \"%TypeError%\": a,\n                \"%Uint8Array%\": typeof Uint8Array === \"undefined\" ? o : Uint8Array,\n                \"%Uint8ClampedArray%\": typeof Uint8ClampedArray === \"undefined\" ? o : Uint8ClampedArray,\n                \"%Uint16Array%\": typeof Uint16Array === \"undefined\" ? o : Uint16Array,\n                \"%Uint32Array%\": typeof Uint32Array === \"undefined\" ? o : Uint32Array,\n                \"%URIError%\": URIError,\n                \"%WeakMap%\": typeof WeakMap === \"undefined\" ? o : WeakMap,\n                \"%WeakRef%\": typeof WeakRef === \"undefined\" ? o : WeakRef,\n                \"%WeakSet%\": typeof WeakSet === \"undefined\" ? o : WeakSet\n            };\n            var d = function doEval(r) {\n                var e;\n                if (r === \"%AsyncFunction%\") {\n                    e = getEvalledConstructor(\"async function () {}\");\n                } else if (r === \"%GeneratorFunction%\") {\n                    e = getEvalledConstructor(\"function* () {}\");\n                } else if (r === \"%AsyncGeneratorFunction%\") {\n                    e = getEvalledConstructor(\"async function* () {}\");\n                } else if (r === \"%AsyncGenerator%\") {\n                    var t = doEval(\"%AsyncGeneratorFunction%\");\n                    if (t) {\n                        e = t.prototype;\n                    }\n                } else if (r === \"%AsyncIteratorPrototype%\") {\n                    var o = doEval(\"%AsyncGenerator%\");\n                    if (o) {\n                        e = u(o.prototype);\n                    }\n                }\n                l[r] = e;\n                return e;\n            };\n            var g = {\n                \"%ArrayBufferPrototype%\": [\n                    \"ArrayBuffer\",\n                    \"prototype\"\n                ],\n                \"%ArrayPrototype%\": [\n                    \"Array\",\n                    \"prototype\"\n                ],\n                \"%ArrayProto_entries%\": [\n                    \"Array\",\n                    \"prototype\",\n                    \"entries\"\n                ],\n                \"%ArrayProto_forEach%\": [\n                    \"Array\",\n                    \"prototype\",\n                    \"forEach\"\n                ],\n                \"%ArrayProto_keys%\": [\n                    \"Array\",\n                    \"prototype\",\n                    \"keys\"\n                ],\n                \"%ArrayProto_values%\": [\n                    \"Array\",\n                    \"prototype\",\n                    \"values\"\n                ],\n                \"%AsyncFunctionPrototype%\": [\n                    \"AsyncFunction\",\n                    \"prototype\"\n                ],\n                \"%AsyncGenerator%\": [\n                    \"AsyncGeneratorFunction\",\n                    \"prototype\"\n                ],\n                \"%AsyncGeneratorPrototype%\": [\n                    \"AsyncGeneratorFunction\",\n                    \"prototype\",\n                    \"prototype\"\n                ],\n                \"%BooleanPrototype%\": [\n                    \"Boolean\",\n                    \"prototype\"\n                ],\n                \"%DataViewPrototype%\": [\n                    \"DataView\",\n                    \"prototype\"\n                ],\n                \"%DatePrototype%\": [\n                    \"Date\",\n                    \"prototype\"\n                ],\n                \"%ErrorPrototype%\": [\n                    \"Error\",\n                    \"prototype\"\n                ],\n                \"%EvalErrorPrototype%\": [\n                    \"EvalError\",\n                    \"prototype\"\n                ],\n                \"%Float32ArrayPrototype%\": [\n                    \"Float32Array\",\n                    \"prototype\"\n                ],\n                \"%Float64ArrayPrototype%\": [\n                    \"Float64Array\",\n                    \"prototype\"\n                ],\n                \"%FunctionPrototype%\": [\n                    \"Function\",\n                    \"prototype\"\n                ],\n                \"%Generator%\": [\n                    \"GeneratorFunction\",\n                    \"prototype\"\n                ],\n                \"%GeneratorPrototype%\": [\n                    \"GeneratorFunction\",\n                    \"prototype\",\n                    \"prototype\"\n                ],\n                \"%Int8ArrayPrototype%\": [\n                    \"Int8Array\",\n                    \"prototype\"\n                ],\n                \"%Int16ArrayPrototype%\": [\n                    \"Int16Array\",\n                    \"prototype\"\n                ],\n                \"%Int32ArrayPrototype%\": [\n                    \"Int32Array\",\n                    \"prototype\"\n                ],\n                \"%JSONParse%\": [\n                    \"JSON\",\n                    \"parse\"\n                ],\n                \"%JSONStringify%\": [\n                    \"JSON\",\n                    \"stringify\"\n                ],\n                \"%MapPrototype%\": [\n                    \"Map\",\n                    \"prototype\"\n                ],\n                \"%NumberPrototype%\": [\n                    \"Number\",\n                    \"prototype\"\n                ],\n                \"%ObjectPrototype%\": [\n                    \"Object\",\n                    \"prototype\"\n                ],\n                \"%ObjProto_toString%\": [\n                    \"Object\",\n                    \"prototype\",\n                    \"toString\"\n                ],\n                \"%ObjProto_valueOf%\": [\n                    \"Object\",\n                    \"prototype\",\n                    \"valueOf\"\n                ],\n                \"%PromisePrototype%\": [\n                    \"Promise\",\n                    \"prototype\"\n                ],\n                \"%PromiseProto_then%\": [\n                    \"Promise\",\n                    \"prototype\",\n                    \"then\"\n                ],\n                \"%Promise_all%\": [\n                    \"Promise\",\n                    \"all\"\n                ],\n                \"%Promise_reject%\": [\n                    \"Promise\",\n                    \"reject\"\n                ],\n                \"%Promise_resolve%\": [\n                    \"Promise\",\n                    \"resolve\"\n                ],\n                \"%RangeErrorPrototype%\": [\n                    \"RangeError\",\n                    \"prototype\"\n                ],\n                \"%ReferenceErrorPrototype%\": [\n                    \"ReferenceError\",\n                    \"prototype\"\n                ],\n                \"%RegExpPrototype%\": [\n                    \"RegExp\",\n                    \"prototype\"\n                ],\n                \"%SetPrototype%\": [\n                    \"Set\",\n                    \"prototype\"\n                ],\n                \"%SharedArrayBufferPrototype%\": [\n                    \"SharedArrayBuffer\",\n                    \"prototype\"\n                ],\n                \"%StringPrototype%\": [\n                    \"String\",\n                    \"prototype\"\n                ],\n                \"%SymbolPrototype%\": [\n                    \"Symbol\",\n                    \"prototype\"\n                ],\n                \"%SyntaxErrorPrototype%\": [\n                    \"SyntaxError\",\n                    \"prototype\"\n                ],\n                \"%TypedArrayPrototype%\": [\n                    \"TypedArray\",\n                    \"prototype\"\n                ],\n                \"%TypeErrorPrototype%\": [\n                    \"TypeError\",\n                    \"prototype\"\n                ],\n                \"%Uint8ArrayPrototype%\": [\n                    \"Uint8Array\",\n                    \"prototype\"\n                ],\n                \"%Uint8ClampedArrayPrototype%\": [\n                    \"Uint8ClampedArray\",\n                    \"prototype\"\n                ],\n                \"%Uint16ArrayPrototype%\": [\n                    \"Uint16Array\",\n                    \"prototype\"\n                ],\n                \"%Uint32ArrayPrototype%\": [\n                    \"Uint32Array\",\n                    \"prototype\"\n                ],\n                \"%URIErrorPrototype%\": [\n                    \"URIError\",\n                    \"prototype\"\n                ],\n                \"%WeakMapPrototype%\": [\n                    \"WeakMap\",\n                    \"prototype\"\n                ],\n                \"%WeakSetPrototype%\": [\n                    \"WeakSet\",\n                    \"prototype\"\n                ]\n            };\n            var v = t(174);\n            var b = t(101);\n            var A = v.call(Function.call, Array.prototype.concat);\n            var m = v.call(Function.apply, Array.prototype.splice);\n            var S = v.call(Function.call, String.prototype.replace);\n            var h = v.call(Function.call, String.prototype.slice);\n            var P = v.call(Function.call, RegExp.prototype.exec);\n            var O = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;\n            var w = /\\\\(\\\\)?/g;\n            var j = function stringToPath(r) {\n                var e = h(r, 0, 1);\n                var t = h(r, -1);\n                if (e === \"%\" && t !== \"%\") {\n                    throw new n(\"invalid intrinsic syntax, expected closing `%`\");\n                } else if (t === \"%\" && e !== \"%\") {\n                    throw new n(\"invalid intrinsic syntax, expected opening `%`\");\n                }\n                var o = [];\n                S(r, O, function(r, e, t, n) {\n                    o[o.length] = t ? S(n, w, \"$1\") : e || r;\n                });\n                return o;\n            };\n            var E = function getBaseIntrinsic(r, e) {\n                var t = r;\n                var o;\n                if (b(g, t)) {\n                    o = g[t];\n                    t = \"%\" + o[0] + \"%\";\n                }\n                if (b(l, t)) {\n                    var i = l[t];\n                    if (i === s) {\n                        i = d(t);\n                    }\n                    if (typeof i === \"undefined\" && !e) {\n                        throw new a(\"intrinsic \" + r + \" exists, but is not available. Please file an issue!\");\n                    }\n                    return {\n                        alias: o,\n                        name: t,\n                        value: i\n                    };\n                }\n                throw new n(\"intrinsic \" + r + \" does not exist!\");\n            };\n            r.exports = function GetIntrinsic(r, e) {\n                if (typeof r !== \"string\" || r.length === 0) {\n                    throw new a(\"intrinsic name must be a non-empty string\");\n                }\n                if (arguments.length > 1 && typeof e !== \"boolean\") {\n                    throw new a('\"allowMissing\" argument must be a boolean');\n                }\n                if (P(/^%?[^%]*%?$/g, r) === null) {\n                    throw new n(\"`%` may not be present anywhere but at the beginning and end of the intrinsic name\");\n                }\n                var t = j(r);\n                var i = t.length > 0 ? t[0] : \"\";\n                var f = E(\"%\" + i + \"%\", e);\n                var p = f.name;\n                var u = f.value;\n                var s = false;\n                var c = f.alias;\n                if (c) {\n                    i = c[0];\n                    m(t, A([\n                        0,\n                        1\n                    ], c));\n                }\n                for(var d = 1, g = true; d < t.length; d += 1){\n                    var v = t[d];\n                    var S = h(v, 0, 1);\n                    var O = h(v, -1);\n                    if ((S === '\"' || S === \"'\" || S === \"`\" || O === '\"' || O === \"'\" || O === \"`\") && S !== O) {\n                        throw new n(\"property names with quotes must have matching quotes\");\n                    }\n                    if (v === \"constructor\" || !g) {\n                        s = true;\n                    }\n                    i += \".\" + v;\n                    p = \"%\" + i + \"%\";\n                    if (b(l, p)) {\n                        u = l[p];\n                    } else if (u != null) {\n                        if (!(v in u)) {\n                            if (!e) {\n                                throw new a(\"base intrinsic for \" + r + \" exists, but the property is not available.\");\n                            }\n                            return void o;\n                        }\n                        if (y && d + 1 >= t.length) {\n                            var w = y(u, v);\n                            g = !!w;\n                            if (g && \"get\" in w && !(\"originalValue\" in w.get)) {\n                                u = w.get;\n                            } else {\n                                u = u[v];\n                            }\n                        } else {\n                            g = b(u, v);\n                            u = u[v];\n                        }\n                        if (g && !s) {\n                            l[p] = u;\n                        }\n                    }\n                }\n                return u;\n            };\n        },\n        925: function(r, e, t) {\n            \"use strict\";\n            var o;\n            var n = SyntaxError;\n            var i = Function;\n            var a = TypeError;\n            var getEvalledConstructor = function(r) {\n                try {\n                    return i('\"use strict\"; return (' + r + \").constructor;\")();\n                } catch (r) {}\n            };\n            var y = Object.getOwnPropertyDescriptor;\n            if (y) {\n                try {\n                    y({}, \"\");\n                } catch (r) {\n                    y = null;\n                }\n            }\n            var throwTypeError = function() {\n                throw new a;\n            };\n            var f = y ? function() {\n                try {\n                    arguments.callee;\n                    return throwTypeError;\n                } catch (r) {\n                    try {\n                        return y(arguments, \"callee\").get;\n                    } catch (r) {\n                        return throwTypeError;\n                    }\n                }\n            }() : throwTypeError;\n            var p = t(115)();\n            var u = t(504)();\n            var s = Object.getPrototypeOf || (u ? function(r) {\n                return r.__proto__;\n            } : null);\n            var c = {};\n            var l = typeof Uint8Array === \"undefined\" || !s ? o : s(Uint8Array);\n            var d = {\n                \"%AggregateError%\": typeof AggregateError === \"undefined\" ? o : AggregateError,\n                \"%Array%\": Array,\n                \"%ArrayBuffer%\": typeof ArrayBuffer === \"undefined\" ? o : ArrayBuffer,\n                \"%ArrayIteratorPrototype%\": p && s ? s([][Symbol.iterator]()) : o,\n                \"%AsyncFromSyncIteratorPrototype%\": o,\n                \"%AsyncFunction%\": c,\n                \"%AsyncGenerator%\": c,\n                \"%AsyncGeneratorFunction%\": c,\n                \"%AsyncIteratorPrototype%\": c,\n                \"%Atomics%\": typeof Atomics === \"undefined\" ? o : Atomics,\n                \"%BigInt%\": typeof BigInt === \"undefined\" ? o : BigInt,\n                \"%BigInt64Array%\": typeof BigInt64Array === \"undefined\" ? o : BigInt64Array,\n                \"%BigUint64Array%\": typeof BigUint64Array === \"undefined\" ? o : BigUint64Array,\n                \"%Boolean%\": Boolean,\n                \"%DataView%\": typeof DataView === \"undefined\" ? o : DataView,\n                \"%Date%\": Date,\n                \"%decodeURI%\": decodeURI,\n                \"%decodeURIComponent%\": decodeURIComponent,\n                \"%encodeURI%\": encodeURI,\n                \"%encodeURIComponent%\": encodeURIComponent,\n                \"%Error%\": Error,\n                \"%eval%\": eval,\n                \"%EvalError%\": EvalError,\n                \"%Float32Array%\": typeof Float32Array === \"undefined\" ? o : Float32Array,\n                \"%Float64Array%\": typeof Float64Array === \"undefined\" ? o : Float64Array,\n                \"%FinalizationRegistry%\": typeof FinalizationRegistry === \"undefined\" ? o : FinalizationRegistry,\n                \"%Function%\": i,\n                \"%GeneratorFunction%\": c,\n                \"%Int8Array%\": typeof Int8Array === \"undefined\" ? o : Int8Array,\n                \"%Int16Array%\": typeof Int16Array === \"undefined\" ? o : Int16Array,\n                \"%Int32Array%\": typeof Int32Array === \"undefined\" ? o : Int32Array,\n                \"%isFinite%\": isFinite,\n                \"%isNaN%\": isNaN,\n                \"%IteratorPrototype%\": p && s ? s(s([][Symbol.iterator]())) : o,\n                \"%JSON%\": typeof JSON === \"object\" ? JSON : o,\n                \"%Map%\": typeof Map === \"undefined\" ? o : Map,\n                \"%MapIteratorPrototype%\": typeof Map === \"undefined\" || !p || !s ? o : s((new Map)[Symbol.iterator]()),\n                \"%Math%\": Math,\n                \"%Number%\": Number,\n                \"%Object%\": Object,\n                \"%parseFloat%\": parseFloat,\n                \"%parseInt%\": parseInt,\n                \"%Promise%\": typeof Promise === \"undefined\" ? o : Promise,\n                \"%Proxy%\": typeof Proxy === \"undefined\" ? o : Proxy,\n                \"%RangeError%\": RangeError,\n                \"%ReferenceError%\": ReferenceError,\n                \"%Reflect%\": typeof Reflect === \"undefined\" ? o : Reflect,\n                \"%RegExp%\": RegExp,\n                \"%Set%\": typeof Set === \"undefined\" ? o : Set,\n                \"%SetIteratorPrototype%\": typeof Set === \"undefined\" || !p || !s ? o : s((new Set)[Symbol.iterator]()),\n                \"%SharedArrayBuffer%\": typeof SharedArrayBuffer === \"undefined\" ? o : SharedArrayBuffer,\n                \"%String%\": String,\n                \"%StringIteratorPrototype%\": p && s ? s(\"\"[Symbol.iterator]()) : o,\n                \"%Symbol%\": p ? Symbol : o,\n                \"%SyntaxError%\": n,\n                \"%ThrowTypeError%\": f,\n                \"%TypedArray%\": l,\n                \"%TypeError%\": a,\n                \"%Uint8Array%\": typeof Uint8Array === \"undefined\" ? o : Uint8Array,\n                \"%Uint8ClampedArray%\": typeof Uint8ClampedArray === \"undefined\" ? o : Uint8ClampedArray,\n                \"%Uint16Array%\": typeof Uint16Array === \"undefined\" ? o : Uint16Array,\n                \"%Uint32Array%\": typeof Uint32Array === \"undefined\" ? o : Uint32Array,\n                \"%URIError%\": URIError,\n                \"%WeakMap%\": typeof WeakMap === \"undefined\" ? o : WeakMap,\n                \"%WeakRef%\": typeof WeakRef === \"undefined\" ? o : WeakRef,\n                \"%WeakSet%\": typeof WeakSet === \"undefined\" ? o : WeakSet\n            };\n            if (s) {\n                try {\n                    null.error;\n                } catch (r) {\n                    var g = s(s(r));\n                    d[\"%Error.prototype%\"] = g;\n                }\n            }\n            var v = function doEval(r) {\n                var e;\n                if (r === \"%AsyncFunction%\") {\n                    e = getEvalledConstructor(\"async function () {}\");\n                } else if (r === \"%GeneratorFunction%\") {\n                    e = getEvalledConstructor(\"function* () {}\");\n                } else if (r === \"%AsyncGeneratorFunction%\") {\n                    e = getEvalledConstructor(\"async function* () {}\");\n                } else if (r === \"%AsyncGenerator%\") {\n                    var t = doEval(\"%AsyncGeneratorFunction%\");\n                    if (t) {\n                        e = t.prototype;\n                    }\n                } else if (r === \"%AsyncIteratorPrototype%\") {\n                    var o = doEval(\"%AsyncGenerator%\");\n                    if (o && s) {\n                        e = s(o.prototype);\n                    }\n                }\n                d[r] = e;\n                return e;\n            };\n            var b = {\n                \"%ArrayBufferPrototype%\": [\n                    \"ArrayBuffer\",\n                    \"prototype\"\n                ],\n                \"%ArrayPrototype%\": [\n                    \"Array\",\n                    \"prototype\"\n                ],\n                \"%ArrayProto_entries%\": [\n                    \"Array\",\n                    \"prototype\",\n                    \"entries\"\n                ],\n                \"%ArrayProto_forEach%\": [\n                    \"Array\",\n                    \"prototype\",\n                    \"forEach\"\n                ],\n                \"%ArrayProto_keys%\": [\n                    \"Array\",\n                    \"prototype\",\n                    \"keys\"\n                ],\n                \"%ArrayProto_values%\": [\n                    \"Array\",\n                    \"prototype\",\n                    \"values\"\n                ],\n                \"%AsyncFunctionPrototype%\": [\n                    \"AsyncFunction\",\n                    \"prototype\"\n                ],\n                \"%AsyncGenerator%\": [\n                    \"AsyncGeneratorFunction\",\n                    \"prototype\"\n                ],\n                \"%AsyncGeneratorPrototype%\": [\n                    \"AsyncGeneratorFunction\",\n                    \"prototype\",\n                    \"prototype\"\n                ],\n                \"%BooleanPrototype%\": [\n                    \"Boolean\",\n                    \"prototype\"\n                ],\n                \"%DataViewPrototype%\": [\n                    \"DataView\",\n                    \"prototype\"\n                ],\n                \"%DatePrototype%\": [\n                    \"Date\",\n                    \"prototype\"\n                ],\n                \"%ErrorPrototype%\": [\n                    \"Error\",\n                    \"prototype\"\n                ],\n                \"%EvalErrorPrototype%\": [\n                    \"EvalError\",\n                    \"prototype\"\n                ],\n                \"%Float32ArrayPrototype%\": [\n                    \"Float32Array\",\n                    \"prototype\"\n                ],\n                \"%Float64ArrayPrototype%\": [\n                    \"Float64Array\",\n                    \"prototype\"\n                ],\n                \"%FunctionPrototype%\": [\n                    \"Function\",\n                    \"prototype\"\n                ],\n                \"%Generator%\": [\n                    \"GeneratorFunction\",\n                    \"prototype\"\n                ],\n                \"%GeneratorPrototype%\": [\n                    \"GeneratorFunction\",\n                    \"prototype\",\n                    \"prototype\"\n                ],\n                \"%Int8ArrayPrototype%\": [\n                    \"Int8Array\",\n                    \"prototype\"\n                ],\n                \"%Int16ArrayPrototype%\": [\n                    \"Int16Array\",\n                    \"prototype\"\n                ],\n                \"%Int32ArrayPrototype%\": [\n                    \"Int32Array\",\n                    \"prototype\"\n                ],\n                \"%JSONParse%\": [\n                    \"JSON\",\n                    \"parse\"\n                ],\n                \"%JSONStringify%\": [\n                    \"JSON\",\n                    \"stringify\"\n                ],\n                \"%MapPrototype%\": [\n                    \"Map\",\n                    \"prototype\"\n                ],\n                \"%NumberPrototype%\": [\n                    \"Number\",\n                    \"prototype\"\n                ],\n                \"%ObjectPrototype%\": [\n                    \"Object\",\n                    \"prototype\"\n                ],\n                \"%ObjProto_toString%\": [\n                    \"Object\",\n                    \"prototype\",\n                    \"toString\"\n                ],\n                \"%ObjProto_valueOf%\": [\n                    \"Object\",\n                    \"prototype\",\n                    \"valueOf\"\n                ],\n                \"%PromisePrototype%\": [\n                    \"Promise\",\n                    \"prototype\"\n                ],\n                \"%PromiseProto_then%\": [\n                    \"Promise\",\n                    \"prototype\",\n                    \"then\"\n                ],\n                \"%Promise_all%\": [\n                    \"Promise\",\n                    \"all\"\n                ],\n                \"%Promise_reject%\": [\n                    \"Promise\",\n                    \"reject\"\n                ],\n                \"%Promise_resolve%\": [\n                    \"Promise\",\n                    \"resolve\"\n                ],\n                \"%RangeErrorPrototype%\": [\n                    \"RangeError\",\n                    \"prototype\"\n                ],\n                \"%ReferenceErrorPrototype%\": [\n                    \"ReferenceError\",\n                    \"prototype\"\n                ],\n                \"%RegExpPrototype%\": [\n                    \"RegExp\",\n                    \"prototype\"\n                ],\n                \"%SetPrototype%\": [\n                    \"Set\",\n                    \"prototype\"\n                ],\n                \"%SharedArrayBufferPrototype%\": [\n                    \"SharedArrayBuffer\",\n                    \"prototype\"\n                ],\n                \"%StringPrototype%\": [\n                    \"String\",\n                    \"prototype\"\n                ],\n                \"%SymbolPrototype%\": [\n                    \"Symbol\",\n                    \"prototype\"\n                ],\n                \"%SyntaxErrorPrototype%\": [\n                    \"SyntaxError\",\n                    \"prototype\"\n                ],\n                \"%TypedArrayPrototype%\": [\n                    \"TypedArray\",\n                    \"prototype\"\n                ],\n                \"%TypeErrorPrototype%\": [\n                    \"TypeError\",\n                    \"prototype\"\n                ],\n                \"%Uint8ArrayPrototype%\": [\n                    \"Uint8Array\",\n                    \"prototype\"\n                ],\n                \"%Uint8ClampedArrayPrototype%\": [\n                    \"Uint8ClampedArray\",\n                    \"prototype\"\n                ],\n                \"%Uint16ArrayPrototype%\": [\n                    \"Uint16Array\",\n                    \"prototype\"\n                ],\n                \"%Uint32ArrayPrototype%\": [\n                    \"Uint32Array\",\n                    \"prototype\"\n                ],\n                \"%URIErrorPrototype%\": [\n                    \"URIError\",\n                    \"prototype\"\n                ],\n                \"%WeakMapPrototype%\": [\n                    \"WeakMap\",\n                    \"prototype\"\n                ],\n                \"%WeakSetPrototype%\": [\n                    \"WeakSet\",\n                    \"prototype\"\n                ]\n            };\n            var A = t(174);\n            var m = t(101);\n            var S = A.call(Function.call, Array.prototype.concat);\n            var h = A.call(Function.apply, Array.prototype.splice);\n            var P = A.call(Function.call, String.prototype.replace);\n            var O = A.call(Function.call, String.prototype.slice);\n            var w = A.call(Function.call, RegExp.prototype.exec);\n            var j = /[^%.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|%$))/g;\n            var E = /\\\\(\\\\)?/g;\n            var I = function stringToPath(r) {\n                var e = O(r, 0, 1);\n                var t = O(r, -1);\n                if (e === \"%\" && t !== \"%\") {\n                    throw new n(\"invalid intrinsic syntax, expected closing `%`\");\n                } else if (t === \"%\" && e !== \"%\") {\n                    throw new n(\"invalid intrinsic syntax, expected opening `%`\");\n                }\n                var o = [];\n                P(r, j, function(r, e, t, n) {\n                    o[o.length] = t ? P(n, E, \"$1\") : e || r;\n                });\n                return o;\n            };\n            var B = function getBaseIntrinsic(r, e) {\n                var t = r;\n                var o;\n                if (m(b, t)) {\n                    o = b[t];\n                    t = \"%\" + o[0] + \"%\";\n                }\n                if (m(d, t)) {\n                    var i = d[t];\n                    if (i === c) {\n                        i = v(t);\n                    }\n                    if (typeof i === \"undefined\" && !e) {\n                        throw new a(\"intrinsic \" + r + \" exists, but is not available. Please file an issue!\");\n                    }\n                    return {\n                        alias: o,\n                        name: t,\n                        value: i\n                    };\n                }\n                throw new n(\"intrinsic \" + r + \" does not exist!\");\n            };\n            r.exports = function GetIntrinsic(r, e) {\n                if (typeof r !== \"string\" || r.length === 0) {\n                    throw new a(\"intrinsic name must be a non-empty string\");\n                }\n                if (arguments.length > 1 && typeof e !== \"boolean\") {\n                    throw new a('\"allowMissing\" argument must be a boolean');\n                }\n                if (w(/^%?[^%]*%?$/, r) === null) {\n                    throw new n(\"`%` may not be present anywhere but at the beginning and end of the intrinsic name\");\n                }\n                var t = I(r);\n                var i = t.length > 0 ? t[0] : \"\";\n                var f = B(\"%\" + i + \"%\", e);\n                var p = f.name;\n                var u = f.value;\n                var s = false;\n                var c = f.alias;\n                if (c) {\n                    i = c[0];\n                    h(t, S([\n                        0,\n                        1\n                    ], c));\n                }\n                for(var l = 1, g = true; l < t.length; l += 1){\n                    var v = t[l];\n                    var b = O(v, 0, 1);\n                    var A = O(v, -1);\n                    if ((b === '\"' || b === \"'\" || b === \"`\" || A === '\"' || A === \"'\" || A === \"`\") && b !== A) {\n                        throw new n(\"property names with quotes must have matching quotes\");\n                    }\n                    if (v === \"constructor\" || !g) {\n                        s = true;\n                    }\n                    i += \".\" + v;\n                    p = \"%\" + i + \"%\";\n                    if (m(d, p)) {\n                        u = d[p];\n                    } else if (u != null) {\n                        if (!(v in u)) {\n                            if (!e) {\n                                throw new a(\"base intrinsic for \" + r + \" exists, but the property is not available.\");\n                            }\n                            return void o;\n                        }\n                        if (y && l + 1 >= t.length) {\n                            var P = y(u, v);\n                            g = !!P;\n                            if (g && \"get\" in P && !(\"originalValue\" in P.get)) {\n                                u = P.get;\n                            } else {\n                                u = u[v];\n                            }\n                        } else {\n                            g = m(u, v);\n                            u = u[v];\n                        }\n                        if (g && !s) {\n                            d[p] = u;\n                        }\n                    }\n                }\n                return u;\n            };\n        },\n        504: function(r) {\n            \"use strict\";\n            var e = {\n                foo: {}\n            };\n            var t = Object;\n            r.exports = function hasProto() {\n                return ({\n                    __proto__: e\n                }).foo === e.foo && !(({\n                    __proto__: null\n                }) instanceof t);\n            };\n        },\n        942: function(r, e, t) {\n            \"use strict\";\n            var o = typeof Symbol !== \"undefined\" && Symbol;\n            var n = t(773);\n            r.exports = function hasNativeSymbols() {\n                if (typeof o !== \"function\") {\n                    return false;\n                }\n                if (typeof Symbol !== \"function\") {\n                    return false;\n                }\n                if (typeof o(\"foo\") !== \"symbol\") {\n                    return false;\n                }\n                if (typeof Symbol(\"bar\") !== \"symbol\") {\n                    return false;\n                }\n                return n();\n            };\n        },\n        773: function(r) {\n            \"use strict\";\n            r.exports = function hasSymbols() {\n                if (typeof Symbol !== \"function\" || typeof Object.getOwnPropertySymbols !== \"function\") {\n                    return false;\n                }\n                if (typeof Symbol.iterator === \"symbol\") {\n                    return true;\n                }\n                var r = {};\n                var e = Symbol(\"test\");\n                var t = Object(e);\n                if (typeof e === \"string\") {\n                    return false;\n                }\n                if (Object.prototype.toString.call(e) !== \"[object Symbol]\") {\n                    return false;\n                }\n                if (Object.prototype.toString.call(t) !== \"[object Symbol]\") {\n                    return false;\n                }\n                var o = 42;\n                r[e] = o;\n                for(e in r){\n                    return false;\n                }\n                if (typeof Object.keys === \"function\" && Object.keys(r).length !== 0) {\n                    return false;\n                }\n                if (typeof Object.getOwnPropertyNames === \"function\" && Object.getOwnPropertyNames(r).length !== 0) {\n                    return false;\n                }\n                var n = Object.getOwnPropertySymbols(r);\n                if (n.length !== 1 || n[0] !== e) {\n                    return false;\n                }\n                if (!Object.prototype.propertyIsEnumerable.call(r, e)) {\n                    return false;\n                }\n                if (typeof Object.getOwnPropertyDescriptor === \"function\") {\n                    var i = Object.getOwnPropertyDescriptor(r, e);\n                    if (i.value !== o || i.enumerable !== true) {\n                        return false;\n                    }\n                }\n                return true;\n            };\n        },\n        115: function(r, e, t) {\n            \"use strict\";\n            var o = typeof Symbol !== \"undefined\" && Symbol;\n            var n = t(832);\n            r.exports = function hasNativeSymbols() {\n                if (typeof o !== \"function\") {\n                    return false;\n                }\n                if (typeof Symbol !== \"function\") {\n                    return false;\n                }\n                if (typeof o(\"foo\") !== \"symbol\") {\n                    return false;\n                }\n                if (typeof Symbol(\"bar\") !== \"symbol\") {\n                    return false;\n                }\n                return n();\n            };\n        },\n        832: function(r) {\n            \"use strict\";\n            r.exports = function hasSymbols() {\n                if (typeof Symbol !== \"function\" || typeof Object.getOwnPropertySymbols !== \"function\") {\n                    return false;\n                }\n                if (typeof Symbol.iterator === \"symbol\") {\n                    return true;\n                }\n                var r = {};\n                var e = Symbol(\"test\");\n                var t = Object(e);\n                if (typeof e === \"string\") {\n                    return false;\n                }\n                if (Object.prototype.toString.call(e) !== \"[object Symbol]\") {\n                    return false;\n                }\n                if (Object.prototype.toString.call(t) !== \"[object Symbol]\") {\n                    return false;\n                }\n                var o = 42;\n                r[e] = o;\n                for(e in r){\n                    return false;\n                }\n                if (typeof Object.keys === \"function\" && Object.keys(r).length !== 0) {\n                    return false;\n                }\n                if (typeof Object.getOwnPropertyNames === \"function\" && Object.getOwnPropertyNames(r).length !== 0) {\n                    return false;\n                }\n                var n = Object.getOwnPropertySymbols(r);\n                if (n.length !== 1 || n[0] !== e) {\n                    return false;\n                }\n                if (!Object.prototype.propertyIsEnumerable.call(r, e)) {\n                    return false;\n                }\n                if (typeof Object.getOwnPropertyDescriptor === \"function\") {\n                    var i = Object.getOwnPropertyDescriptor(r, e);\n                    if (i.value !== o || i.enumerable !== true) {\n                        return false;\n                    }\n                }\n                return true;\n            };\n        },\n        101: function(r, e, t) {\n            \"use strict\";\n            var o = t(174);\n            r.exports = o.call(Function.call, Object.prototype.hasOwnProperty);\n        },\n        782: function(r) {\n            if (typeof Object.create === \"function\") {\n                r.exports = function inherits(r, e) {\n                    if (e) {\n                        r.super_ = e;\n                        r.prototype = Object.create(e.prototype, {\n                            constructor: {\n                                value: r,\n                                enumerable: false,\n                                writable: true,\n                                configurable: true\n                            }\n                        });\n                    }\n                };\n            } else {\n                r.exports = function inherits(r, e) {\n                    if (e) {\n                        r.super_ = e;\n                        var TempCtor = function() {};\n                        TempCtor.prototype = e.prototype;\n                        r.prototype = new TempCtor;\n                        r.prototype.constructor = r;\n                    }\n                };\n            }\n        },\n        157: function(r) {\n            \"use strict\";\n            var e = typeof Symbol === \"function\" && typeof Symbol.toStringTag === \"symbol\";\n            var t = Object.prototype.toString;\n            var o = function isArguments(r) {\n                if (e && r && typeof r === \"object\" && Symbol.toStringTag in r) {\n                    return false;\n                }\n                return t.call(r) === \"[object Arguments]\";\n            };\n            var n = function isArguments(r) {\n                if (o(r)) {\n                    return true;\n                }\n                return r !== null && typeof r === \"object\" && typeof r.length === \"number\" && r.length >= 0 && t.call(r) !== \"[object Array]\" && t.call(r.callee) === \"[object Function]\";\n            };\n            var i = function() {\n                return o(arguments);\n            }();\n            o.isLegacyArguments = n;\n            r.exports = i ? o : n;\n        },\n        391: function(r) {\n            \"use strict\";\n            var e = Object.prototype.toString;\n            var t = Function.prototype.toString;\n            var o = /^\\s*(?:function)?\\*/;\n            var n = typeof Symbol === \"function\" && typeof Symbol.toStringTag === \"symbol\";\n            var i = Object.getPrototypeOf;\n            var getGeneratorFunc = function() {\n                if (!n) {\n                    return false;\n                }\n                try {\n                    return Function(\"return function*() {}\")();\n                } catch (r) {}\n            };\n            var a = getGeneratorFunc();\n            var y = a ? i(a) : {};\n            r.exports = function isGeneratorFunction(r) {\n                if (typeof r !== \"function\") {\n                    return false;\n                }\n                if (o.test(t.call(r))) {\n                    return true;\n                }\n                if (!n) {\n                    var a = e.call(r);\n                    return a === \"[object GeneratorFunction]\";\n                }\n                return i(r) === y;\n            };\n        },\n        994: function(r, e, t) {\n            \"use strict\";\n            var o = t(144);\n            var n = t(349);\n            var i = t(256);\n            var a = i(\"Object.prototype.toString\");\n            var y = t(942)();\n            var f = y && typeof Symbol.toStringTag === \"symbol\";\n            var p = n();\n            var u = i(\"Array.prototype.indexOf\", true) || function indexOf(r, e) {\n                for(var t = 0; t < r.length; t += 1){\n                    if (r[t] === e) {\n                        return t;\n                    }\n                }\n                return -1;\n            };\n            var s = i(\"String.prototype.slice\");\n            var c = {};\n            var l = t(24);\n            var d = Object.getPrototypeOf;\n            if (f && l && d) {\n                o(p, function(r) {\n                    var e = new __webpack_require__.g[r];\n                    if (!(Symbol.toStringTag in e)) {\n                        throw new EvalError(\"this engine has support for Symbol.toStringTag, but \" + r + \" does not have the property! Please report this.\");\n                    }\n                    var t = d(e);\n                    var o = l(t, Symbol.toStringTag);\n                    if (!o) {\n                        var n = d(t);\n                        o = l(n, Symbol.toStringTag);\n                    }\n                    c[r] = o.get;\n                });\n            }\n            var g = function tryAllTypedArrays(r) {\n                var e = false;\n                o(c, function(t, o) {\n                    if (!e) {\n                        try {\n                            e = t.call(r) === o;\n                        } catch (r) {}\n                    }\n                });\n                return e;\n            };\n            r.exports = function isTypedArray(r) {\n                if (!r || typeof r !== \"object\") {\n                    return false;\n                }\n                if (!f) {\n                    var e = s(a(r), 8, -1);\n                    return u(p, e) > -1;\n                }\n                if (!l) {\n                    return false;\n                }\n                return g(r);\n            };\n        },\n        369: function(r) {\n            r.exports = function isBuffer(r) {\n                return r instanceof Buffer;\n            };\n        },\n        584: function(r, e, t) {\n            \"use strict\";\n            var o = t(157);\n            var n = t(391);\n            var i = t(490);\n            var a = t(994);\n            function uncurryThis(r) {\n                return r.call.bind(r);\n            }\n            var y = typeof BigInt !== \"undefined\";\n            var f = typeof Symbol !== \"undefined\";\n            var p = uncurryThis(Object.prototype.toString);\n            var u = uncurryThis(Number.prototype.valueOf);\n            var s = uncurryThis(String.prototype.valueOf);\n            var c = uncurryThis(Boolean.prototype.valueOf);\n            if (y) {\n                var l = uncurryThis(BigInt.prototype.valueOf);\n            }\n            if (f) {\n                var d = uncurryThis(Symbol.prototype.valueOf);\n            }\n            function checkBoxedPrimitive(r, e) {\n                if (typeof r !== \"object\") {\n                    return false;\n                }\n                try {\n                    e(r);\n                    return true;\n                } catch (r) {\n                    return false;\n                }\n            }\n            e.isArgumentsObject = o;\n            e.isGeneratorFunction = n;\n            e.isTypedArray = a;\n            function isPromise(r) {\n                return typeof Promise !== \"undefined\" && r instanceof Promise || r !== null && typeof r === \"object\" && typeof r.then === \"function\" && typeof r.catch === \"function\";\n            }\n            e.isPromise = isPromise;\n            function isArrayBufferView(r) {\n                if (typeof ArrayBuffer !== \"undefined\" && ArrayBuffer.isView) {\n                    return ArrayBuffer.isView(r);\n                }\n                return a(r) || isDataView(r);\n            }\n            e.isArrayBufferView = isArrayBufferView;\n            function isUint8Array(r) {\n                return i(r) === \"Uint8Array\";\n            }\n            e.isUint8Array = isUint8Array;\n            function isUint8ClampedArray(r) {\n                return i(r) === \"Uint8ClampedArray\";\n            }\n            e.isUint8ClampedArray = isUint8ClampedArray;\n            function isUint16Array(r) {\n                return i(r) === \"Uint16Array\";\n            }\n            e.isUint16Array = isUint16Array;\n            function isUint32Array(r) {\n                return i(r) === \"Uint32Array\";\n            }\n            e.isUint32Array = isUint32Array;\n            function isInt8Array(r) {\n                return i(r) === \"Int8Array\";\n            }\n            e.isInt8Array = isInt8Array;\n            function isInt16Array(r) {\n                return i(r) === \"Int16Array\";\n            }\n            e.isInt16Array = isInt16Array;\n            function isInt32Array(r) {\n                return i(r) === \"Int32Array\";\n            }\n            e.isInt32Array = isInt32Array;\n            function isFloat32Array(r) {\n                return i(r) === \"Float32Array\";\n            }\n            e.isFloat32Array = isFloat32Array;\n            function isFloat64Array(r) {\n                return i(r) === \"Float64Array\";\n            }\n            e.isFloat64Array = isFloat64Array;\n            function isBigInt64Array(r) {\n                return i(r) === \"BigInt64Array\";\n            }\n            e.isBigInt64Array = isBigInt64Array;\n            function isBigUint64Array(r) {\n                return i(r) === \"BigUint64Array\";\n            }\n            e.isBigUint64Array = isBigUint64Array;\n            function isMapToString(r) {\n                return p(r) === \"[object Map]\";\n            }\n            isMapToString.working = typeof Map !== \"undefined\" && isMapToString(new Map);\n            function isMap(r) {\n                if (typeof Map === \"undefined\") {\n                    return false;\n                }\n                return isMapToString.working ? isMapToString(r) : r instanceof Map;\n            }\n            e.isMap = isMap;\n            function isSetToString(r) {\n                return p(r) === \"[object Set]\";\n            }\n            isSetToString.working = typeof Set !== \"undefined\" && isSetToString(new Set);\n            function isSet(r) {\n                if (typeof Set === \"undefined\") {\n                    return false;\n                }\n                return isSetToString.working ? isSetToString(r) : r instanceof Set;\n            }\n            e.isSet = isSet;\n            function isWeakMapToString(r) {\n                return p(r) === \"[object WeakMap]\";\n            }\n            isWeakMapToString.working = typeof WeakMap !== \"undefined\" && isWeakMapToString(new WeakMap);\n            function isWeakMap(r) {\n                if (typeof WeakMap === \"undefined\") {\n                    return false;\n                }\n                return isWeakMapToString.working ? isWeakMapToString(r) : r instanceof WeakMap;\n            }\n            e.isWeakMap = isWeakMap;\n            function isWeakSetToString(r) {\n                return p(r) === \"[object WeakSet]\";\n            }\n            isWeakSetToString.working = typeof WeakSet !== \"undefined\" && isWeakSetToString(new WeakSet);\n            function isWeakSet(r) {\n                return isWeakSetToString(r);\n            }\n            e.isWeakSet = isWeakSet;\n            function isArrayBufferToString(r) {\n                return p(r) === \"[object ArrayBuffer]\";\n            }\n            isArrayBufferToString.working = typeof ArrayBuffer !== \"undefined\" && isArrayBufferToString(new ArrayBuffer);\n            function isArrayBuffer(r) {\n                if (typeof ArrayBuffer === \"undefined\") {\n                    return false;\n                }\n                return isArrayBufferToString.working ? isArrayBufferToString(r) : r instanceof ArrayBuffer;\n            }\n            e.isArrayBuffer = isArrayBuffer;\n            function isDataViewToString(r) {\n                return p(r) === \"[object DataView]\";\n            }\n            isDataViewToString.working = typeof ArrayBuffer !== \"undefined\" && typeof DataView !== \"undefined\" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));\n            function isDataView(r) {\n                if (typeof DataView === \"undefined\") {\n                    return false;\n                }\n                return isDataViewToString.working ? isDataViewToString(r) : r instanceof DataView;\n            }\n            e.isDataView = isDataView;\n            var g = typeof SharedArrayBuffer !== \"undefined\" ? SharedArrayBuffer : undefined;\n            function isSharedArrayBufferToString(r) {\n                return p(r) === \"[object SharedArrayBuffer]\";\n            }\n            function isSharedArrayBuffer(r) {\n                if (typeof g === \"undefined\") {\n                    return false;\n                }\n                if (typeof isSharedArrayBufferToString.working === \"undefined\") {\n                    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new g);\n                }\n                return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(r) : r instanceof g;\n            }\n            e.isSharedArrayBuffer = isSharedArrayBuffer;\n            function isAsyncFunction(r) {\n                return p(r) === \"[object AsyncFunction]\";\n            }\n            e.isAsyncFunction = isAsyncFunction;\n            function isMapIterator(r) {\n                return p(r) === \"[object Map Iterator]\";\n            }\n            e.isMapIterator = isMapIterator;\n            function isSetIterator(r) {\n                return p(r) === \"[object Set Iterator]\";\n            }\n            e.isSetIterator = isSetIterator;\n            function isGeneratorObject(r) {\n                return p(r) === \"[object Generator]\";\n            }\n            e.isGeneratorObject = isGeneratorObject;\n            function isWebAssemblyCompiledModule(r) {\n                return p(r) === \"[object WebAssembly.Module]\";\n            }\n            e.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;\n            function isNumberObject(r) {\n                return checkBoxedPrimitive(r, u);\n            }\n            e.isNumberObject = isNumberObject;\n            function isStringObject(r) {\n                return checkBoxedPrimitive(r, s);\n            }\n            e.isStringObject = isStringObject;\n            function isBooleanObject(r) {\n                return checkBoxedPrimitive(r, c);\n            }\n            e.isBooleanObject = isBooleanObject;\n            function isBigIntObject(r) {\n                return y && checkBoxedPrimitive(r, l);\n            }\n            e.isBigIntObject = isBigIntObject;\n            function isSymbolObject(r) {\n                return f && checkBoxedPrimitive(r, d);\n            }\n            e.isSymbolObject = isSymbolObject;\n            function isBoxedPrimitive(r) {\n                return isNumberObject(r) || isStringObject(r) || isBooleanObject(r) || isBigIntObject(r) || isSymbolObject(r);\n            }\n            e.isBoxedPrimitive = isBoxedPrimitive;\n            function isAnyArrayBuffer(r) {\n                return typeof Uint8Array !== \"undefined\" && (isArrayBuffer(r) || isSharedArrayBuffer(r));\n            }\n            e.isAnyArrayBuffer = isAnyArrayBuffer;\n            [\n                \"isProxy\",\n                \"isExternal\",\n                \"isModuleNamespaceObject\"\n            ].forEach(function(r) {\n                Object.defineProperty(e, r, {\n                    enumerable: false,\n                    value: function() {\n                        throw new Error(r + \" is not supported in userland\");\n                    }\n                });\n            });\n        },\n        177: function(r, e, t) {\n            var o = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(r) {\n                var e = Object.keys(r);\n                var t = {};\n                for(var o = 0; o < e.length; o++){\n                    t[e[o]] = Object.getOwnPropertyDescriptor(r, e[o]);\n                }\n                return t;\n            };\n            var n = /%[sdj%]/g;\n            e.format = function(r) {\n                if (!isString(r)) {\n                    var e = [];\n                    for(var t = 0; t < arguments.length; t++){\n                        e.push(inspect(arguments[t]));\n                    }\n                    return e.join(\" \");\n                }\n                var t = 1;\n                var o = arguments;\n                var i = o.length;\n                var a = String(r).replace(n, function(r) {\n                    if (r === \"%%\") return \"%\";\n                    if (t >= i) return r;\n                    switch(r){\n                        case \"%s\":\n                            return String(o[t++]);\n                        case \"%d\":\n                            return Number(o[t++]);\n                        case \"%j\":\n                            try {\n                                return JSON.stringify(o[t++]);\n                            } catch (r) {\n                                return \"[Circular]\";\n                            }\n                        default:\n                            return r;\n                    }\n                });\n                for(var y = o[t]; t < i; y = o[++t]){\n                    if (isNull(y) || !isObject(y)) {\n                        a += \" \" + y;\n                    } else {\n                        a += \" \" + inspect(y);\n                    }\n                }\n                return a;\n            };\n            e.deprecate = function(r, t) {\n                if (typeof process !== \"undefined\" && process.noDeprecation === true) {\n                    return r;\n                }\n                if (typeof process === \"undefined\") {\n                    return function() {\n                        return e.deprecate(r, t).apply(this, arguments);\n                    };\n                }\n                var o = false;\n                function deprecated() {\n                    if (!o) {\n                        if (process.throwDeprecation) {\n                            throw new Error(t);\n                        } else if (process.traceDeprecation) {\n                            console.trace(t);\n                        } else {\n                            console.error(t);\n                        }\n                        o = true;\n                    }\n                    return r.apply(this, arguments);\n                }\n                return deprecated;\n            };\n            var i = {};\n            var a = /^$/;\n            if (process.env.NODE_DEBUG) {\n                var y = process.env.NODE_DEBUG;\n                y = y.replace(/[|\\\\{}()[\\]^$+?.]/g, \"\\\\$&\").replace(/\\*/g, \".*\").replace(/,/g, \"$|^\").toUpperCase();\n                a = new RegExp(\"^\" + y + \"$\", \"i\");\n            }\n            e.debuglog = function(r) {\n                r = r.toUpperCase();\n                if (!i[r]) {\n                    if (a.test(r)) {\n                        var t = process.pid;\n                        i[r] = function() {\n                            var o = e.format.apply(e, arguments);\n                            console.error(\"%s %d: %s\", r, t, o);\n                        };\n                    } else {\n                        i[r] = function() {};\n                    }\n                }\n                return i[r];\n            };\n            function inspect(r, t) {\n                var o = {\n                    seen: [],\n                    stylize: stylizeNoColor\n                };\n                if (arguments.length >= 3) o.depth = arguments[2];\n                if (arguments.length >= 4) o.colors = arguments[3];\n                if (isBoolean(t)) {\n                    o.showHidden = t;\n                } else if (t) {\n                    e._extend(o, t);\n                }\n                if (isUndefined(o.showHidden)) o.showHidden = false;\n                if (isUndefined(o.depth)) o.depth = 2;\n                if (isUndefined(o.colors)) o.colors = false;\n                if (isUndefined(o.customInspect)) o.customInspect = true;\n                if (o.colors) o.stylize = stylizeWithColor;\n                return formatValue(o, r, o.depth);\n            }\n            e.inspect = inspect;\n            inspect.colors = {\n                bold: [\n                    1,\n                    22\n                ],\n                italic: [\n                    3,\n                    23\n                ],\n                underline: [\n                    4,\n                    24\n                ],\n                inverse: [\n                    7,\n                    27\n                ],\n                white: [\n                    37,\n                    39\n                ],\n                grey: [\n                    90,\n                    39\n                ],\n                black: [\n                    30,\n                    39\n                ],\n                blue: [\n                    34,\n                    39\n                ],\n                cyan: [\n                    36,\n                    39\n                ],\n                green: [\n                    32,\n                    39\n                ],\n                magenta: [\n                    35,\n                    39\n                ],\n                red: [\n                    31,\n                    39\n                ],\n                yellow: [\n                    33,\n                    39\n                ]\n            };\n            inspect.styles = {\n                special: \"cyan\",\n                number: \"yellow\",\n                boolean: \"yellow\",\n                undefined: \"grey\",\n                null: \"bold\",\n                string: \"green\",\n                date: \"magenta\",\n                regexp: \"red\"\n            };\n            function stylizeWithColor(r, e) {\n                var t = inspect.styles[e];\n                if (t) {\n                    return \"\\x1b[\" + inspect.colors[t][0] + \"m\" + r + \"\\x1b[\" + inspect.colors[t][1] + \"m\";\n                } else {\n                    return r;\n                }\n            }\n            function stylizeNoColor(r, e) {\n                return r;\n            }\n            function arrayToHash(r) {\n                var e = {};\n                r.forEach(function(r, t) {\n                    e[r] = true;\n                });\n                return e;\n            }\n            function formatValue(r, t, o) {\n                if (r.customInspect && t && isFunction(t.inspect) && t.inspect !== e.inspect && !(t.constructor && t.constructor.prototype === t)) {\n                    var n = t.inspect(o, r);\n                    if (!isString(n)) {\n                        n = formatValue(r, n, o);\n                    }\n                    return n;\n                }\n                var i = formatPrimitive(r, t);\n                if (i) {\n                    return i;\n                }\n                var a = Object.keys(t);\n                var y = arrayToHash(a);\n                if (r.showHidden) {\n                    a = Object.getOwnPropertyNames(t);\n                }\n                if (isError(t) && (a.indexOf(\"message\") >= 0 || a.indexOf(\"description\") >= 0)) {\n                    return formatError(t);\n                }\n                if (a.length === 0) {\n                    if (isFunction(t)) {\n                        var f = t.name ? \": \" + t.name : \"\";\n                        return r.stylize(\"[Function\" + f + \"]\", \"special\");\n                    }\n                    if (isRegExp(t)) {\n                        return r.stylize(RegExp.prototype.toString.call(t), \"regexp\");\n                    }\n                    if (isDate(t)) {\n                        return r.stylize(Date.prototype.toString.call(t), \"date\");\n                    }\n                    if (isError(t)) {\n                        return formatError(t);\n                    }\n                }\n                var p = \"\", u = false, s = [\n                    \"{\",\n                    \"}\"\n                ];\n                if (isArray(t)) {\n                    u = true;\n                    s = [\n                        \"[\",\n                        \"]\"\n                    ];\n                }\n                if (isFunction(t)) {\n                    var c = t.name ? \": \" + t.name : \"\";\n                    p = \" [Function\" + c + \"]\";\n                }\n                if (isRegExp(t)) {\n                    p = \" \" + RegExp.prototype.toString.call(t);\n                }\n                if (isDate(t)) {\n                    p = \" \" + Date.prototype.toUTCString.call(t);\n                }\n                if (isError(t)) {\n                    p = \" \" + formatError(t);\n                }\n                if (a.length === 0 && (!u || t.length == 0)) {\n                    return s[0] + p + s[1];\n                }\n                if (o < 0) {\n                    if (isRegExp(t)) {\n                        return r.stylize(RegExp.prototype.toString.call(t), \"regexp\");\n                    } else {\n                        return r.stylize(\"[Object]\", \"special\");\n                    }\n                }\n                r.seen.push(t);\n                var l;\n                if (u) {\n                    l = formatArray(r, t, o, y, a);\n                } else {\n                    l = a.map(function(e) {\n                        return formatProperty(r, t, o, y, e, u);\n                    });\n                }\n                r.seen.pop();\n                return reduceToSingleString(l, p, s);\n            }\n            function formatPrimitive(r, e) {\n                if (isUndefined(e)) return r.stylize(\"undefined\", \"undefined\");\n                if (isString(e)) {\n                    var t = \"'\" + JSON.stringify(e).replace(/^\"|\"$/g, \"\").replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"') + \"'\";\n                    return r.stylize(t, \"string\");\n                }\n                if (isNumber(e)) return r.stylize(\"\" + e, \"number\");\n                if (isBoolean(e)) return r.stylize(\"\" + e, \"boolean\");\n                if (isNull(e)) return r.stylize(\"null\", \"null\");\n            }\n            function formatError(r) {\n                return \"[\" + Error.prototype.toString.call(r) + \"]\";\n            }\n            function formatArray(r, e, t, o, n) {\n                var i = [];\n                for(var a = 0, y = e.length; a < y; ++a){\n                    if (hasOwnProperty(e, String(a))) {\n                        i.push(formatProperty(r, e, t, o, String(a), true));\n                    } else {\n                        i.push(\"\");\n                    }\n                }\n                n.forEach(function(n) {\n                    if (!n.match(/^\\d+$/)) {\n                        i.push(formatProperty(r, e, t, o, n, true));\n                    }\n                });\n                return i;\n            }\n            function formatProperty(r, e, t, o, n, i) {\n                var a, y, f;\n                f = Object.getOwnPropertyDescriptor(e, n) || {\n                    value: e[n]\n                };\n                if (f.get) {\n                    if (f.set) {\n                        y = r.stylize(\"[Getter/Setter]\", \"special\");\n                    } else {\n                        y = r.stylize(\"[Getter]\", \"special\");\n                    }\n                } else {\n                    if (f.set) {\n                        y = r.stylize(\"[Setter]\", \"special\");\n                    }\n                }\n                if (!hasOwnProperty(o, n)) {\n                    a = \"[\" + n + \"]\";\n                }\n                if (!y) {\n                    if (r.seen.indexOf(f.value) < 0) {\n                        if (isNull(t)) {\n                            y = formatValue(r, f.value, null);\n                        } else {\n                            y = formatValue(r, f.value, t - 1);\n                        }\n                        if (y.indexOf(\"\\n\") > -1) {\n                            if (i) {\n                                y = y.split(\"\\n\").map(function(r) {\n                                    return \"  \" + r;\n                                }).join(\"\\n\").substr(2);\n                            } else {\n                                y = \"\\n\" + y.split(\"\\n\").map(function(r) {\n                                    return \"   \" + r;\n                                }).join(\"\\n\");\n                            }\n                        }\n                    } else {\n                        y = r.stylize(\"[Circular]\", \"special\");\n                    }\n                }\n                if (isUndefined(a)) {\n                    if (i && n.match(/^\\d+$/)) {\n                        return y;\n                    }\n                    a = JSON.stringify(\"\" + n);\n                    if (a.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n                        a = a.substr(1, a.length - 2);\n                        a = r.stylize(a, \"name\");\n                    } else {\n                        a = a.replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"').replace(/(^\"|\"$)/g, \"'\");\n                        a = r.stylize(a, \"string\");\n                    }\n                }\n                return a + \": \" + y;\n            }\n            function reduceToSingleString(r, e, t) {\n                var o = 0;\n                var n = r.reduce(function(r, e) {\n                    o++;\n                    if (e.indexOf(\"\\n\") >= 0) o++;\n                    return r + e.replace(/\\u001b\\[\\d\\d?m/g, \"\").length + 1;\n                }, 0);\n                if (n > 60) {\n                    return t[0] + (e === \"\" ? \"\" : e + \"\\n \") + \" \" + r.join(\",\\n  \") + \" \" + t[1];\n                }\n                return t[0] + e + \" \" + r.join(\", \") + \" \" + t[1];\n            }\n            e.types = t(584);\n            function isArray(r) {\n                return Array.isArray(r);\n            }\n            e.isArray = isArray;\n            function isBoolean(r) {\n                return typeof r === \"boolean\";\n            }\n            e.isBoolean = isBoolean;\n            function isNull(r) {\n                return r === null;\n            }\n            e.isNull = isNull;\n            function isNullOrUndefined(r) {\n                return r == null;\n            }\n            e.isNullOrUndefined = isNullOrUndefined;\n            function isNumber(r) {\n                return typeof r === \"number\";\n            }\n            e.isNumber = isNumber;\n            function isString(r) {\n                return typeof r === \"string\";\n            }\n            e.isString = isString;\n            function isSymbol(r) {\n                return typeof r === \"symbol\";\n            }\n            e.isSymbol = isSymbol;\n            function isUndefined(r) {\n                return r === void 0;\n            }\n            e.isUndefined = isUndefined;\n            function isRegExp(r) {\n                return isObject(r) && objectToString(r) === \"[object RegExp]\";\n            }\n            e.isRegExp = isRegExp;\n            e.types.isRegExp = isRegExp;\n            function isObject(r) {\n                return typeof r === \"object\" && r !== null;\n            }\n            e.isObject = isObject;\n            function isDate(r) {\n                return isObject(r) && objectToString(r) === \"[object Date]\";\n            }\n            e.isDate = isDate;\n            e.types.isDate = isDate;\n            function isError(r) {\n                return isObject(r) && (objectToString(r) === \"[object Error]\" || r instanceof Error);\n            }\n            e.isError = isError;\n            e.types.isNativeError = isError;\n            function isFunction(r) {\n                return typeof r === \"function\";\n            }\n            e.isFunction = isFunction;\n            function isPrimitive(r) {\n                return r === null || typeof r === \"boolean\" || typeof r === \"number\" || typeof r === \"string\" || typeof r === \"symbol\" || typeof r === \"undefined\";\n            }\n            e.isPrimitive = isPrimitive;\n            e.isBuffer = t(369);\n            function objectToString(r) {\n                return Object.prototype.toString.call(r);\n            }\n            function pad(r) {\n                return r < 10 ? \"0\" + r.toString(10) : r.toString(10);\n            }\n            var f = [\n                \"Jan\",\n                \"Feb\",\n                \"Mar\",\n                \"Apr\",\n                \"May\",\n                \"Jun\",\n                \"Jul\",\n                \"Aug\",\n                \"Sep\",\n                \"Oct\",\n                \"Nov\",\n                \"Dec\"\n            ];\n            function timestamp() {\n                var r = new Date;\n                var e = [\n                    pad(r.getHours()),\n                    pad(r.getMinutes()),\n                    pad(r.getSeconds())\n                ].join(\":\");\n                return [\n                    r.getDate(),\n                    f[r.getMonth()],\n                    e\n                ].join(\" \");\n            }\n            e.log = function() {\n                console.log(\"%s - %s\", timestamp(), e.format.apply(e, arguments));\n            };\n            e.inherits = t(782);\n            e._extend = function(r, e) {\n                if (!e || !isObject(e)) return r;\n                var t = Object.keys(e);\n                var o = t.length;\n                while(o--){\n                    r[t[o]] = e[t[o]];\n                }\n                return r;\n            };\n            function hasOwnProperty(r, e) {\n                return Object.prototype.hasOwnProperty.call(r, e);\n            }\n            var p = typeof Symbol !== \"undefined\" ? Symbol(\"util.promisify.custom\") : undefined;\n            e.promisify = function promisify(r) {\n                if (typeof r !== \"function\") throw new TypeError('The \"original\" argument must be of type Function');\n                if (p && r[p]) {\n                    var e = r[p];\n                    if (typeof e !== \"function\") {\n                        throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n                    }\n                    Object.defineProperty(e, p, {\n                        value: e,\n                        enumerable: false,\n                        writable: false,\n                        configurable: true\n                    });\n                    return e;\n                }\n                function e() {\n                    var e, t;\n                    var o = new Promise(function(r, o) {\n                        e = r;\n                        t = o;\n                    });\n                    var n = [];\n                    for(var i = 0; i < arguments.length; i++){\n                        n.push(arguments[i]);\n                    }\n                    n.push(function(r, o) {\n                        if (r) {\n                            t(r);\n                        } else {\n                            e(o);\n                        }\n                    });\n                    try {\n                        r.apply(this, n);\n                    } catch (r) {\n                        t(r);\n                    }\n                    return o;\n                }\n                Object.setPrototypeOf(e, Object.getPrototypeOf(r));\n                if (p) Object.defineProperty(e, p, {\n                    value: e,\n                    enumerable: false,\n                    writable: false,\n                    configurable: true\n                });\n                return Object.defineProperties(e, o(r));\n            };\n            e.promisify.custom = p;\n            function callbackifyOnRejected(r, e) {\n                if (!r) {\n                    var t = new Error(\"Promise was rejected with a falsy value\");\n                    t.reason = r;\n                    r = t;\n                }\n                return e(r);\n            }\n            function callbackify(r) {\n                if (typeof r !== \"function\") {\n                    throw new TypeError('The \"original\" argument must be of type Function');\n                }\n                function callbackified() {\n                    var e = [];\n                    for(var t = 0; t < arguments.length; t++){\n                        e.push(arguments[t]);\n                    }\n                    var o = e.pop();\n                    if (typeof o !== \"function\") {\n                        throw new TypeError(\"The last argument must be of type Function\");\n                    }\n                    var n = this;\n                    var cb = function() {\n                        return o.apply(n, arguments);\n                    };\n                    r.apply(this, e).then(function(r) {\n                        process.nextTick(cb.bind(null, null, r));\n                    }, function(r) {\n                        process.nextTick(callbackifyOnRejected.bind(null, r, cb));\n                    });\n                }\n                Object.setPrototypeOf(callbackified, Object.getPrototypeOf(r));\n                Object.defineProperties(callbackified, o(r));\n                return callbackified;\n            }\n            e.callbackify = callbackify;\n        },\n        490: function(r, e, t) {\n            \"use strict\";\n            var o = t(144);\n            var n = t(349);\n            var i = t(256);\n            var a = i(\"Object.prototype.toString\");\n            var y = t(942)();\n            var f = y && typeof Symbol.toStringTag === \"symbol\";\n            var p = n();\n            var u = i(\"String.prototype.slice\");\n            var s = {};\n            var c = t(24);\n            var l = Object.getPrototypeOf;\n            if (f && c && l) {\n                o(p, function(r) {\n                    if (typeof __webpack_require__.g[r] === \"function\") {\n                        var e = new __webpack_require__.g[r];\n                        if (!(Symbol.toStringTag in e)) {\n                            throw new EvalError(\"this engine has support for Symbol.toStringTag, but \" + r + \" does not have the property! Please report this.\");\n                        }\n                        var t = l(e);\n                        var o = c(t, Symbol.toStringTag);\n                        if (!o) {\n                            var n = l(t);\n                            o = c(n, Symbol.toStringTag);\n                        }\n                        s[r] = o.get;\n                    }\n                });\n            }\n            var d = function tryAllTypedArrays(r) {\n                var e = false;\n                o(s, function(t, o) {\n                    if (!e) {\n                        try {\n                            var n = t.call(r);\n                            if (n === o) {\n                                e = n;\n                            }\n                        } catch (r) {}\n                    }\n                });\n                return e;\n            };\n            var g = t(994);\n            r.exports = function whichTypedArray(r) {\n                if (!g(r)) {\n                    return false;\n                }\n                if (!f) {\n                    return u(a(r), 8, -1);\n                }\n                return d(r);\n            };\n        },\n        349: function(r, e, t) {\n            \"use strict\";\n            var o = t(992);\n            r.exports = function availableTypedArrays() {\n                return o([\n                    \"BigInt64Array\",\n                    \"BigUint64Array\",\n                    \"Float32Array\",\n                    \"Float64Array\",\n                    \"Int16Array\",\n                    \"Int32Array\",\n                    \"Int8Array\",\n                    \"Uint16Array\",\n                    \"Uint32Array\",\n                    \"Uint8Array\",\n                    \"Uint8ClampedArray\"\n                ], function(r) {\n                    return typeof __webpack_require__.g[r] === \"function\";\n                });\n            };\n        },\n        24: function(r, e, t) {\n            \"use strict\";\n            var o = t(500);\n            var n = o(\"%Object.getOwnPropertyDescriptor%\", true);\n            if (n) {\n                try {\n                    n([], \"length\");\n                } catch (r) {\n                    n = null;\n                }\n            }\n            r.exports = n;\n        }\n    };\n    var e = {};\n    function __nccwpck_require__(t) {\n        var o = e[t];\n        if (o !== undefined) {\n            return o.exports;\n        }\n        var n = e[t] = {\n            exports: {}\n        };\n        var i = true;\n        try {\n            r[t](n, n.exports, __nccwpck_require__);\n            i = false;\n        } finally{\n            if (i) delete e[t];\n        }\n        return n.exports;\n    }\n    if (typeof __nccwpck_require__ !== \"undefined\") __nccwpck_require__.ab = __dirname + \"/\";\n    var t = __nccwpck_require__(177);\n    module.exports = t;\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvdXRpbC91dGlsLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQztJQUFXLElBQUlBLElBQUU7UUFBQyxLQUFJLFNBQVNBLENBQUM7WUFBRUEsRUFBRUMsT0FBTyxHQUFDLFNBQVNELENBQUMsRUFBQ0UsQ0FBQyxFQUFDQyxDQUFDO2dCQUFFLElBQUdILEVBQUVJLE1BQU0sRUFBQyxPQUFPSixFQUFFSSxNQUFNLENBQUNGLEdBQUVDO2dCQUFHLElBQUcsS0FBSyxNQUFJSCxLQUFHLFNBQU9BLEdBQUUsTUFBTSxJQUFJSztnQkFBVSxJQUFHLGNBQVksT0FBT0gsR0FBRSxNQUFNLElBQUlHO2dCQUFVLElBQUlDLElBQUUsRUFBRTtnQkFBQyxJQUFJLElBQUlDLElBQUUsR0FBRUEsSUFBRVAsRUFBRVEsTUFBTSxFQUFDRCxJQUFJO29CQUFDLElBQUcsQ0FBQ0UsRUFBRUMsSUFBSSxDQUFDVixHQUFFTyxJQUFHO29CQUFTLElBQUlJLElBQUVYLENBQUMsQ0FBQ08sRUFBRTtvQkFBQyxJQUFHTCxFQUFFUSxJQUFJLENBQUNQLEdBQUVRLEdBQUVKLEdBQUVQLElBQUdNLEVBQUVNLElBQUksQ0FBQ0Q7Z0JBQUU7Z0JBQUMsT0FBT0w7WUFBQztZQUFFLElBQUlHLElBQUVJLE9BQU9DLFNBQVMsQ0FBQ0MsY0FBYztRQUFBO1FBQUUsS0FBSSxTQUFTZixDQUFDLEVBQUNTLENBQUMsRUFBQ1AsQ0FBQztZQUFFO1lBQWEsSUFBSUMsSUFBRUQsRUFBRTtZQUFLLElBQUlJLElBQUVKLEVBQUU7WUFBSyxJQUFJSyxJQUFFRCxFQUFFSCxFQUFFO1lBQTZCSCxFQUFFQyxPQUFPLEdBQUMsU0FBU2UsbUJBQW1CaEIsQ0FBQyxFQUFDUyxDQUFDO2dCQUFFLElBQUlQLElBQUVDLEVBQUVILEdBQUUsQ0FBQyxDQUFDUztnQkFBRyxJQUFHLE9BQU9QLE1BQUksY0FBWUssRUFBRVAsR0FBRSxpQkFBZSxD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O1lBQUM7WUFBQ04sRUFBRUMsT0FBTyxHQUFDSztRQUFDO0lBQUM7SUFBRSxJQUFJRyxJQUFFLENBQUM7SUFBRSxTQUFTaVMsb0JBQW9CeFMsQ0FBQztRQUFFLElBQUlDLElBQUVNLENBQUMsQ0FBQ1AsRUFBRTtRQUFDLElBQUdDLE1BQUlvTCxXQUFVO1lBQUMsT0FBT3BMLEVBQUVGLE9BQU87UUFBQTtRQUFDLElBQUlLLElBQUVHLENBQUMsQ0FBQ1AsRUFBRSxHQUFDO1lBQUNELFNBQVEsQ0FBQztRQUFDO1FBQUUsSUFBSU0sSUFBRTtRQUFLLElBQUc7WUFBQ1AsQ0FBQyxDQUFDRSxFQUFFLENBQUNJLEdBQUVBLEVBQUVMLE9BQU8sRUFBQ3lTO1lBQXFCblMsSUFBRTtRQUFLLFNBQVE7WUFBQyxJQUFHQSxHQUFFLE9BQU9FLENBQUMsQ0FBQ1AsRUFBRTtRQUFBO1FBQUMsT0FBT0ksRUFBRUwsT0FBTztJQUFBO0lBQUMsSUFBRyxPQUFPeVMsd0JBQXNCLGFBQVlBLG9CQUFvQkMsRUFBRSxHQUFDQyxTQUFTQSxHQUFDO0lBQUksSUFBSTFTLElBQUV3UyxvQkFBb0I7SUFBS0csT0FBTzVTLE9BQU8sR0FBQ0M7QUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3V0aWwvdXRpbC5qcz9hYzE0Il0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe3ZhciByPXs5OTI6ZnVuY3Rpb24ocil7ci5leHBvcnRzPWZ1bmN0aW9uKHIsdCxvKXtpZihyLmZpbHRlcilyZXR1cm4gci5maWx0ZXIodCxvKTtpZih2b2lkIDA9PT1yfHxudWxsPT09cil0aHJvdyBuZXcgVHlwZUVycm9yO2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcjt2YXIgbj1bXTtmb3IodmFyIGk9MDtpPHIubGVuZ3RoO2krKyl7aWYoIWUuY2FsbChyLGkpKWNvbnRpbnVlO3ZhciBhPXJbaV07aWYodC5jYWxsKG8sYSxpLHIpKW4ucHVzaChhKX1yZXR1cm4gbn07dmFyIGU9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eX0sMjU2OmZ1bmN0aW9uKHIsZSx0KXtcInVzZSBzdHJpY3RcIjt2YXIgbz10KDkyNSk7dmFyIG49dCgxMzkpO3ZhciBpPW4obyhcIlN0cmluZy5wcm90b3R5cGUuaW5kZXhPZlwiKSk7ci5leHBvcnRzPWZ1bmN0aW9uIGNhbGxCb3VuZEludHJpbnNpYyhyLGUpe3ZhciB0PW8ociwhIWUpO2lmKHR5cGVvZiB0PT09XCJmdW5jdGlvblwiJiZpKHIsXCIucHJvdG90eXBlLlwiKT4tMSl7cmV0dXJuIG4odCl9cmV0dXJuIHR9fSwxMzk6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBvPXQoMTc0KTt2YXIgbj10KDkyNSk7dmFyIGk9bihcIiVGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHklXCIpO3ZhciBhPW4oXCIlRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwlXCIpO3ZhciB5PW4oXCIlUmVmbGVjdC5hcHBseSVcIix0cnVlKXx8by5jYWxsKGEsaSk7dmFyIGY9bihcIiVPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJVwiLHRydWUpO3ZhciBwPW4oXCIlT2JqZWN0LmRlZmluZVByb3BlcnR5JVwiLHRydWUpO3ZhciB1PW4oXCIlTWF0aC5tYXglXCIpO2lmKHApe3RyeXtwKHt9LFwiYVwiLHt2YWx1ZToxfSl9Y2F0Y2gocil7cD1udWxsfX1yLmV4cG9ydHM9ZnVuY3Rpb24gY2FsbEJpbmQocil7dmFyIGU9eShvLGEsYXJndW1lbnRzKTtpZihmJiZwKXt2YXIgdD1mKGUsXCJsZW5ndGhcIik7aWYodC5jb25maWd1cmFibGUpe3AoZSxcImxlbmd0aFwiLHt2YWx1ZToxK3UoMCxyLmxlbmd0aC0oYXJndW1lbnRzLmxlbmd0aC0xKSl9KX19cmV0dXJuIGV9O3ZhciBzPWZ1bmN0aW9uIGFwcGx5QmluZCgpe3JldHVybiB5KG8saSxhcmd1bWVudHMpfTtpZihwKXtwKHIuZXhwb3J0cyxcImFwcGx5XCIse3ZhbHVlOnN9KX1lbHNle3IuZXhwb3J0cy5hcHBseT1zfX0sMTQ0OmZ1bmN0aW9uKHIpe3ZhciBlPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7dmFyIHQ9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztyLmV4cG9ydHM9ZnVuY3Rpb24gZm9yRWFjaChyLG8sbil7aWYodC5jYWxsKG8pIT09XCJbb2JqZWN0IEZ1bmN0aW9uXVwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpfXZhciBpPXIubGVuZ3RoO2lmKGk9PT0raSl7Zm9yKHZhciBhPTA7YTxpO2ErKyl7by5jYWxsKG4sclthXSxhLHIpfX1lbHNle2Zvcih2YXIgeSBpbiByKXtpZihlLmNhbGwocix5KSl7by5jYWxsKG4sclt5XSx5LHIpfX19fX0sNDI2OmZ1bmN0aW9uKHIpe1widXNlIHN0cmljdFwiO3ZhciBlPVwiRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSBcIjt2YXIgdD1BcnJheS5wcm90b3R5cGUuc2xpY2U7dmFyIG89T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZzt2YXIgbj1cIltvYmplY3QgRnVuY3Rpb25dXCI7ci5leHBvcnRzPWZ1bmN0aW9uIGJpbmQocil7dmFyIGk9dGhpcztpZih0eXBlb2YgaSE9PVwiZnVuY3Rpb25cInx8by5jYWxsKGkpIT09bil7dGhyb3cgbmV3IFR5cGVFcnJvcihlK2kpfXZhciBhPXQuY2FsbChhcmd1bWVudHMsMSk7dmFyIHk7dmFyIGJpbmRlcj1mdW5jdGlvbigpe2lmKHRoaXMgaW5zdGFuY2VvZiB5KXt2YXIgZT1pLmFwcGx5KHRoaXMsYS5jb25jYXQodC5jYWxsKGFyZ3VtZW50cykpKTtpZihPYmplY3QoZSk9PT1lKXtyZXR1cm4gZX1yZXR1cm4gdGhpc31lbHNle3JldHVybiBpLmFwcGx5KHIsYS5jb25jYXQodC5jYWxsKGFyZ3VtZW50cykpKX19O3ZhciBmPU1hdGgubWF4KDAsaS5sZW5ndGgtYS5sZW5ndGgpO3ZhciBwPVtdO2Zvcih2YXIgdT0wO3U8Zjt1Kyspe3AucHVzaChcIiRcIit1KX15PUZ1bmN0aW9uKFwiYmluZGVyXCIsXCJyZXR1cm4gZnVuY3Rpb24gKFwiK3Auam9pbihcIixcIikrXCIpeyByZXR1cm4gYmluZGVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKTsgfVwiKShiaW5kZXIpO2lmKGkucHJvdG90eXBlKXt2YXIgcz1mdW5jdGlvbiBFbXB0eSgpe307cy5wcm90b3R5cGU9aS5wcm90b3R5cGU7eS5wcm90b3R5cGU9bmV3IHM7cy5wcm90b3R5cGU9bnVsbH1yZXR1cm4geX19LDE3NDpmdW5jdGlvbihyLGUsdCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG89dCg0MjYpO3IuZXhwb3J0cz1GdW5jdGlvbi5wcm90b3R5cGUuYmluZHx8b30sNTAwOmZ1bmN0aW9uKHIsZSx0KXtcInVzZSBzdHJpY3RcIjt2YXIgbzt2YXIgbj1TeW50YXhFcnJvcjt2YXIgaT1GdW5jdGlvbjt2YXIgYT1UeXBlRXJyb3I7dmFyIGdldEV2YWxsZWRDb25zdHJ1Y3Rvcj1mdW5jdGlvbihyKXt0cnl7cmV0dXJuIGkoJ1widXNlIHN0cmljdFwiOyByZXR1cm4gKCcrcitcIikuY29uc3RydWN0b3I7XCIpKCl9Y2F0Y2gocil7fX07dmFyIHk9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtpZih5KXt0cnl7eSh7fSxcIlwiKX1jYXRjaChyKXt5PW51bGx9fXZhciB0aHJvd1R5cGVFcnJvcj1mdW5jdGlvbigpe3Rocm93IG5ldyBhfTt2YXIgZj15P2Z1bmN0aW9uKCl7dHJ5e2FyZ3VtZW50cy5jYWxsZWU7cmV0dXJuIHRocm93VHlwZUVycm9yfWNhdGNoKHIpe3RyeXtyZXR1cm4geShhcmd1bWVudHMsXCJjYWxsZWVcIikuZ2V0fWNhdGNoKHIpe3JldHVybiB0aHJvd1R5cGVFcnJvcn19fSgpOnRocm93VHlwZUVycm9yO3ZhciBwPXQoMTE1KSgpO3ZhciB1PU9iamVjdC5nZXRQcm90b3R5cGVPZnx8ZnVuY3Rpb24ocil7cmV0dXJuIHIuX19wcm90b19ffTt2YXIgcz17fTt2YXIgYz10eXBlb2YgVWludDhBcnJheT09PVwidW5kZWZpbmVkXCI/bzp1KFVpbnQ4QXJyYXkpO3ZhciBsPXtcIiVBZ2dyZWdhdGVFcnJvciVcIjp0eXBlb2YgQWdncmVnYXRlRXJyb3I9PT1cInVuZGVmaW5lZFwiP286QWdncmVnYXRlRXJyb3IsXCIlQXJyYXklXCI6QXJyYXksXCIlQXJyYXlCdWZmZXIlXCI6dHlwZW9mIEFycmF5QnVmZmVyPT09XCJ1bmRlZmluZWRcIj9vOkFycmF5QnVmZmVyLFwiJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlXCI6cD91KFtdW1N5bWJvbC5pdGVyYXRvcl0oKSk6byxcIiVBc3luY0Zyb21TeW5jSXRlcmF0b3JQcm90b3R5cGUlXCI6byxcIiVBc3luY0Z1bmN0aW9uJVwiOnMsXCIlQXN5bmNHZW5lcmF0b3IlXCI6cyxcIiVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJVwiOnMsXCIlQXN5bmNJdGVyYXRvclByb3RvdHlwZSVcIjpzLFwiJUF0b21pY3MlXCI6dHlwZW9mIEF0b21pY3M9PT1cInVuZGVmaW5lZFwiP286QXRvbWljcyxcIiVCaWdJbnQlXCI6dHlwZW9mIEJpZ0ludD09PVwidW5kZWZpbmVkXCI/bzpCaWdJbnQsXCIlQm9vbGVhbiVcIjpCb29sZWFuLFwiJURhdGFWaWV3JVwiOnR5cGVvZiBEYXRhVmlldz09PVwidW5kZWZpbmVkXCI/bzpEYXRhVmlldyxcIiVEYXRlJVwiOkRhdGUsXCIlZGVjb2RlVVJJJVwiOmRlY29kZVVSSSxcIiVkZWNvZGVVUklDb21wb25lbnQlXCI6ZGVjb2RlVVJJQ29tcG9uZW50LFwiJWVuY29kZVVSSSVcIjplbmNvZGVVUkksXCIlZW5jb2RlVVJJQ29tcG9uZW50JVwiOmVuY29kZVVSSUNvbXBvbmVudCxcIiVFcnJvciVcIjpFcnJvcixcIiVldmFsJVwiOmV2YWwsXCIlRXZhbEVycm9yJVwiOkV2YWxFcnJvcixcIiVGbG9hdDMyQXJyYXklXCI6dHlwZW9mIEZsb2F0MzJBcnJheT09PVwidW5kZWZpbmVkXCI/bzpGbG9hdDMyQXJyYXksXCIlRmxvYXQ2NEFycmF5JVwiOnR5cGVvZiBGbG9hdDY0QXJyYXk9PT1cInVuZGVmaW5lZFwiP286RmxvYXQ2NEFycmF5LFwiJUZpbmFsaXphdGlvblJlZ2lzdHJ5JVwiOnR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeT09PVwidW5kZWZpbmVkXCI/bzpGaW5hbGl6YXRpb25SZWdpc3RyeSxcIiVGdW5jdGlvbiVcIjppLFwiJUdlbmVyYXRvckZ1bmN0aW9uJVwiOnMsXCIlSW50OEFycmF5JVwiOnR5cGVvZiBJbnQ4QXJyYXk9PT1cInVuZGVmaW5lZFwiP286SW50OEFycmF5LFwiJUludDE2QXJyYXklXCI6dHlwZW9mIEludDE2QXJyYXk9PT1cInVuZGVmaW5lZFwiP286SW50MTZBcnJheSxcIiVJbnQzMkFycmF5JVwiOnR5cGVvZiBJbnQzMkFycmF5PT09XCJ1bmRlZmluZWRcIj9vOkludDMyQXJyYXksXCIlaXNGaW5pdGUlXCI6aXNGaW5pdGUsXCIlaXNOYU4lXCI6aXNOYU4sXCIlSXRlcmF0b3JQcm90b3R5cGUlXCI6cD91KHUoW11bU3ltYm9sLml0ZXJhdG9yXSgpKSk6byxcIiVKU09OJVwiOnR5cGVvZiBKU09OPT09XCJvYmplY3RcIj9KU09OOm8sXCIlTWFwJVwiOnR5cGVvZiBNYXA9PT1cInVuZGVmaW5lZFwiP286TWFwLFwiJU1hcEl0ZXJhdG9yUHJvdG90eXBlJVwiOnR5cGVvZiBNYXA9PT1cInVuZGVmaW5lZFwifHwhcD9vOnUoKG5ldyBNYXApW1N5bWJvbC5pdGVyYXRvcl0oKSksXCIlTWF0aCVcIjpNYXRoLFwiJU51bWJlciVcIjpOdW1iZXIsXCIlT2JqZWN0JVwiOk9iamVjdCxcIiVwYXJzZUZsb2F0JVwiOnBhcnNlRmxvYXQsXCIlcGFyc2VJbnQlXCI6cGFyc2VJbnQsXCIlUHJvbWlzZSVcIjp0eXBlb2YgUHJvbWlzZT09PVwidW5kZWZpbmVkXCI/bzpQcm9taXNlLFwiJVByb3h5JVwiOnR5cGVvZiBQcm94eT09PVwidW5kZWZpbmVkXCI/bzpQcm94eSxcIiVSYW5nZUVycm9yJVwiOlJhbmdlRXJyb3IsXCIlUmVmZXJlbmNlRXJyb3IlXCI6UmVmZXJlbmNlRXJyb3IsXCIlUmVmbGVjdCVcIjp0eXBlb2YgUmVmbGVjdD09PVwidW5kZWZpbmVkXCI/bzpSZWZsZWN0LFwiJVJlZ0V4cCVcIjpSZWdFeHAsXCIlU2V0JVwiOnR5cGVvZiBTZXQ9PT1cInVuZGVmaW5lZFwiP286U2V0LFwiJVNldEl0ZXJhdG9yUHJvdG90eXBlJVwiOnR5cGVvZiBTZXQ9PT1cInVuZGVmaW5lZFwifHwhcD9vOnUoKG5ldyBTZXQpW1N5bWJvbC5pdGVyYXRvcl0oKSksXCIlU2hhcmVkQXJyYXlCdWZmZXIlXCI6dHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyPT09XCJ1bmRlZmluZWRcIj9vOlNoYXJlZEFycmF5QnVmZmVyLFwiJVN0cmluZyVcIjpTdHJpbmcsXCIlU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlXCI6cD91KFwiXCJbU3ltYm9sLml0ZXJhdG9yXSgpKTpvLFwiJVN5bWJvbCVcIjpwP1N5bWJvbDpvLFwiJVN5bnRheEVycm9yJVwiOm4sXCIlVGhyb3dUeXBlRXJyb3IlXCI6ZixcIiVUeXBlZEFycmF5JVwiOmMsXCIlVHlwZUVycm9yJVwiOmEsXCIlVWludDhBcnJheSVcIjp0eXBlb2YgVWludDhBcnJheT09PVwidW5kZWZpbmVkXCI/bzpVaW50OEFycmF5LFwiJVVpbnQ4Q2xhbXBlZEFycmF5JVwiOnR5cGVvZiBVaW50OENsYW1wZWRBcnJheT09PVwidW5kZWZpbmVkXCI/bzpVaW50OENsYW1wZWRBcnJheSxcIiVVaW50MTZBcnJheSVcIjp0eXBlb2YgVWludDE2QXJyYXk9PT1cInVuZGVmaW5lZFwiP286VWludDE2QXJyYXksXCIlVWludDMyQXJyYXklXCI6dHlwZW9mIFVpbnQzMkFycmF5PT09XCJ1bmRlZmluZWRcIj9vOlVpbnQzMkFycmF5LFwiJVVSSUVycm9yJVwiOlVSSUVycm9yLFwiJVdlYWtNYXAlXCI6dHlwZW9mIFdlYWtNYXA9PT1cInVuZGVmaW5lZFwiP286V2Vha01hcCxcIiVXZWFrUmVmJVwiOnR5cGVvZiBXZWFrUmVmPT09XCJ1bmRlZmluZWRcIj9vOldlYWtSZWYsXCIlV2Vha1NldCVcIjp0eXBlb2YgV2Vha1NldD09PVwidW5kZWZpbmVkXCI/bzpXZWFrU2V0fTt2YXIgZD1mdW5jdGlvbiBkb0V2YWwocil7dmFyIGU7aWYocj09PVwiJUFzeW5jRnVuY3Rpb24lXCIpe2U9Z2V0RXZhbGxlZENvbnN0cnVjdG9yKFwiYXN5bmMgZnVuY3Rpb24gKCkge31cIil9ZWxzZSBpZihyPT09XCIlR2VuZXJhdG9yRnVuY3Rpb24lXCIpe2U9Z2V0RXZhbGxlZENvbnN0cnVjdG9yKFwiZnVuY3Rpb24qICgpIHt9XCIpfWVsc2UgaWYocj09PVwiJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lXCIpe2U9Z2V0RXZhbGxlZENvbnN0cnVjdG9yKFwiYXN5bmMgZnVuY3Rpb24qICgpIHt9XCIpfWVsc2UgaWYocj09PVwiJUFzeW5jR2VuZXJhdG9yJVwiKXt2YXIgdD1kb0V2YWwoXCIlQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiVcIik7aWYodCl7ZT10LnByb3RvdHlwZX19ZWxzZSBpZihyPT09XCIlQXN5bmNJdGVyYXRvclByb3RvdHlwZSVcIil7dmFyIG89ZG9FdmFsKFwiJUFzeW5jR2VuZXJhdG9yJVwiKTtpZihvKXtlPXUoby5wcm90b3R5cGUpfX1sW3JdPWU7cmV0dXJuIGV9O3ZhciBnPXtcIiVBcnJheUJ1ZmZlclByb3RvdHlwZSVcIjpbXCJBcnJheUJ1ZmZlclwiLFwicHJvdG90eXBlXCJdLFwiJUFycmF5UHJvdG90eXBlJVwiOltcIkFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlQXJyYXlQcm90b19lbnRyaWVzJVwiOltcIkFycmF5XCIsXCJwcm90b3R5cGVcIixcImVudHJpZXNcIl0sXCIlQXJyYXlQcm90b19mb3JFYWNoJVwiOltcIkFycmF5XCIsXCJwcm90b3R5cGVcIixcImZvckVhY2hcIl0sXCIlQXJyYXlQcm90b19rZXlzJVwiOltcIkFycmF5XCIsXCJwcm90b3R5cGVcIixcImtleXNcIl0sXCIlQXJyYXlQcm90b192YWx1ZXMlXCI6W1wiQXJyYXlcIixcInByb3RvdHlwZVwiLFwidmFsdWVzXCJdLFwiJUFzeW5jRnVuY3Rpb25Qcm90b3R5cGUlXCI6W1wiQXN5bmNGdW5jdGlvblwiLFwicHJvdG90eXBlXCJdLFwiJUFzeW5jR2VuZXJhdG9yJVwiOltcIkFzeW5jR2VuZXJhdG9yRnVuY3Rpb25cIixcInByb3RvdHlwZVwiXSxcIiVBc3luY0dlbmVyYXRvclByb3RvdHlwZSVcIjpbXCJBc3luY0dlbmVyYXRvckZ1bmN0aW9uXCIsXCJwcm90b3R5cGVcIixcInByb3RvdHlwZVwiXSxcIiVCb29sZWFuUHJvdG90eXBlJVwiOltcIkJvb2xlYW5cIixcInByb3RvdHlwZVwiXSxcIiVEYXRhVmlld1Byb3RvdHlwZSVcIjpbXCJEYXRhVmlld1wiLFwicHJvdG90eXBlXCJdLFwiJURhdGVQcm90b3R5cGUlXCI6W1wiRGF0ZVwiLFwicHJvdG90eXBlXCJdLFwiJUVycm9yUHJvdG90eXBlJVwiOltcIkVycm9yXCIsXCJwcm90b3R5cGVcIl0sXCIlRXZhbEVycm9yUHJvdG90eXBlJVwiOltcIkV2YWxFcnJvclwiLFwicHJvdG90eXBlXCJdLFwiJUZsb2F0MzJBcnJheVByb3RvdHlwZSVcIjpbXCJGbG9hdDMyQXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVGbG9hdDY0QXJyYXlQcm90b3R5cGUlXCI6W1wiRmxvYXQ2NEFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlRnVuY3Rpb25Qcm90b3R5cGUlXCI6W1wiRnVuY3Rpb25cIixcInByb3RvdHlwZVwiXSxcIiVHZW5lcmF0b3IlXCI6W1wiR2VuZXJhdG9yRnVuY3Rpb25cIixcInByb3RvdHlwZVwiXSxcIiVHZW5lcmF0b3JQcm90b3R5cGUlXCI6W1wiR2VuZXJhdG9yRnVuY3Rpb25cIixcInByb3RvdHlwZVwiLFwicHJvdG90eXBlXCJdLFwiJUludDhBcnJheVByb3RvdHlwZSVcIjpbXCJJbnQ4QXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVJbnQxNkFycmF5UHJvdG90eXBlJVwiOltcIkludDE2QXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVJbnQzMkFycmF5UHJvdG90eXBlJVwiOltcIkludDMyQXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVKU09OUGFyc2UlXCI6W1wiSlNPTlwiLFwicGFyc2VcIl0sXCIlSlNPTlN0cmluZ2lmeSVcIjpbXCJKU09OXCIsXCJzdHJpbmdpZnlcIl0sXCIlTWFwUHJvdG90eXBlJVwiOltcIk1hcFwiLFwicHJvdG90eXBlXCJdLFwiJU51bWJlclByb3RvdHlwZSVcIjpbXCJOdW1iZXJcIixcInByb3RvdHlwZVwiXSxcIiVPYmplY3RQcm90b3R5cGUlXCI6W1wiT2JqZWN0XCIsXCJwcm90b3R5cGVcIl0sXCIlT2JqUHJvdG9fdG9TdHJpbmclXCI6W1wiT2JqZWN0XCIsXCJwcm90b3R5cGVcIixcInRvU3RyaW5nXCJdLFwiJU9ialByb3RvX3ZhbHVlT2YlXCI6W1wiT2JqZWN0XCIsXCJwcm90b3R5cGVcIixcInZhbHVlT2ZcIl0sXCIlUHJvbWlzZVByb3RvdHlwZSVcIjpbXCJQcm9taXNlXCIsXCJwcm90b3R5cGVcIl0sXCIlUHJvbWlzZVByb3RvX3RoZW4lXCI6W1wiUHJvbWlzZVwiLFwicHJvdG90eXBlXCIsXCJ0aGVuXCJdLFwiJVByb21pc2VfYWxsJVwiOltcIlByb21pc2VcIixcImFsbFwiXSxcIiVQcm9taXNlX3JlamVjdCVcIjpbXCJQcm9taXNlXCIsXCJyZWplY3RcIl0sXCIlUHJvbWlzZV9yZXNvbHZlJVwiOltcIlByb21pc2VcIixcInJlc29sdmVcIl0sXCIlUmFuZ2VFcnJvclByb3RvdHlwZSVcIjpbXCJSYW5nZUVycm9yXCIsXCJwcm90b3R5cGVcIl0sXCIlUmVmZXJlbmNlRXJyb3JQcm90b3R5cGUlXCI6W1wiUmVmZXJlbmNlRXJyb3JcIixcInByb3RvdHlwZVwiXSxcIiVSZWdFeHBQcm90b3R5cGUlXCI6W1wiUmVnRXhwXCIsXCJwcm90b3R5cGVcIl0sXCIlU2V0UHJvdG90eXBlJVwiOltcIlNldFwiLFwicHJvdG90eXBlXCJdLFwiJVNoYXJlZEFycmF5QnVmZmVyUHJvdG90eXBlJVwiOltcIlNoYXJlZEFycmF5QnVmZmVyXCIsXCJwcm90b3R5cGVcIl0sXCIlU3RyaW5nUHJvdG90eXBlJVwiOltcIlN0cmluZ1wiLFwicHJvdG90eXBlXCJdLFwiJVN5bWJvbFByb3RvdHlwZSVcIjpbXCJTeW1ib2xcIixcInByb3RvdHlwZVwiXSxcIiVTeW50YXhFcnJvclByb3RvdHlwZSVcIjpbXCJTeW50YXhFcnJvclwiLFwicHJvdG90eXBlXCJdLFwiJVR5cGVkQXJyYXlQcm90b3R5cGUlXCI6W1wiVHlwZWRBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJVR5cGVFcnJvclByb3RvdHlwZSVcIjpbXCJUeXBlRXJyb3JcIixcInByb3RvdHlwZVwiXSxcIiVVaW50OEFycmF5UHJvdG90eXBlJVwiOltcIlVpbnQ4QXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVVaW50OENsYW1wZWRBcnJheVByb3RvdHlwZSVcIjpbXCJVaW50OENsYW1wZWRBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJVVpbnQxNkFycmF5UHJvdG90eXBlJVwiOltcIlVpbnQxNkFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlVWludDMyQXJyYXlQcm90b3R5cGUlXCI6W1wiVWludDMyQXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVVUklFcnJvclByb3RvdHlwZSVcIjpbXCJVUklFcnJvclwiLFwicHJvdG90eXBlXCJdLFwiJVdlYWtNYXBQcm90b3R5cGUlXCI6W1wiV2Vha01hcFwiLFwicHJvdG90eXBlXCJdLFwiJVdlYWtTZXRQcm90b3R5cGUlXCI6W1wiV2Vha1NldFwiLFwicHJvdG90eXBlXCJdfTt2YXIgdj10KDE3NCk7dmFyIGI9dCgxMDEpO3ZhciBBPXYuY2FsbChGdW5jdGlvbi5jYWxsLEFycmF5LnByb3RvdHlwZS5jb25jYXQpO3ZhciBtPXYuY2FsbChGdW5jdGlvbi5hcHBseSxBcnJheS5wcm90b3R5cGUuc3BsaWNlKTt2YXIgUz12LmNhbGwoRnVuY3Rpb24uY2FsbCxTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UpO3ZhciBoPXYuY2FsbChGdW5jdGlvbi5jYWxsLFN0cmluZy5wcm90b3R5cGUuc2xpY2UpO3ZhciBQPXYuY2FsbChGdW5jdGlvbi5jYWxsLFJlZ0V4cC5wcm90b3R5cGUuZXhlYyk7dmFyIE89L1teJS5bXFxdXSt8XFxbKD86KC0/XFxkKyg/OlxcLlxcZCspPyl8KFtcIiddKSgoPzooPyFcXDIpW15cXFxcXXxcXFxcLikqPylcXDIpXFxdfCg/PSg/OlxcLnxcXFtcXF0pKD86XFwufFxcW1xcXXwlJCkpL2c7dmFyIHc9L1xcXFwoXFxcXCk/L2c7dmFyIGo9ZnVuY3Rpb24gc3RyaW5nVG9QYXRoKHIpe3ZhciBlPWgociwwLDEpO3ZhciB0PWgociwtMSk7aWYoZT09PVwiJVwiJiZ0IT09XCIlXCIpe3Rocm93IG5ldyBuKFwiaW52YWxpZCBpbnRyaW5zaWMgc3ludGF4LCBleHBlY3RlZCBjbG9zaW5nIGAlYFwiKX1lbHNlIGlmKHQ9PT1cIiVcIiYmZSE9PVwiJVwiKXt0aHJvdyBuZXcgbihcImludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgb3BlbmluZyBgJWBcIil9dmFyIG89W107UyhyLE8sKGZ1bmN0aW9uKHIsZSx0LG4pe29bby5sZW5ndGhdPXQ/UyhuLHcsXCIkMVwiKTplfHxyfSkpO3JldHVybiBvfTt2YXIgRT1mdW5jdGlvbiBnZXRCYXNlSW50cmluc2ljKHIsZSl7dmFyIHQ9cjt2YXIgbztpZihiKGcsdCkpe289Z1t0XTt0PVwiJVwiK29bMF0rXCIlXCJ9aWYoYihsLHQpKXt2YXIgaT1sW3RdO2lmKGk9PT1zKXtpPWQodCl9aWYodHlwZW9mIGk9PT1cInVuZGVmaW5lZFwiJiYhZSl7dGhyb3cgbmV3IGEoXCJpbnRyaW5zaWMgXCIrcitcIiBleGlzdHMsIGJ1dCBpcyBub3QgYXZhaWxhYmxlLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZSFcIil9cmV0dXJue2FsaWFzOm8sbmFtZTp0LHZhbHVlOml9fXRocm93IG5ldyBuKFwiaW50cmluc2ljIFwiK3IrXCIgZG9lcyBub3QgZXhpc3QhXCIpfTtyLmV4cG9ydHM9ZnVuY3Rpb24gR2V0SW50cmluc2ljKHIsZSl7aWYodHlwZW9mIHIhPT1cInN0cmluZ1wifHxyLmxlbmd0aD09PTApe3Rocm93IG5ldyBhKFwiaW50cmluc2ljIG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmdcIil9aWYoYXJndW1lbnRzLmxlbmd0aD4xJiZ0eXBlb2YgZSE9PVwiYm9vbGVhblwiKXt0aHJvdyBuZXcgYSgnXCJhbGxvd01pc3NpbmdcIiBhcmd1bWVudCBtdXN0IGJlIGEgYm9vbGVhbicpfWlmKFAoL14lP1teJV0qJT8kL2cscik9PT1udWxsKXt0aHJvdyBuZXcgbihcImAlYCBtYXkgbm90IGJlIHByZXNlbnQgYW55d2hlcmUgYnV0IGF0IHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiB0aGUgaW50cmluc2ljIG5hbWVcIil9dmFyIHQ9aihyKTt2YXIgaT10Lmxlbmd0aD4wP3RbMF06XCJcIjt2YXIgZj1FKFwiJVwiK2krXCIlXCIsZSk7dmFyIHA9Zi5uYW1lO3ZhciB1PWYudmFsdWU7dmFyIHM9ZmFsc2U7dmFyIGM9Zi5hbGlhcztpZihjKXtpPWNbMF07bSh0LEEoWzAsMV0sYykpfWZvcih2YXIgZD0xLGc9dHJ1ZTtkPHQubGVuZ3RoO2QrPTEpe3ZhciB2PXRbZF07dmFyIFM9aCh2LDAsMSk7dmFyIE89aCh2LC0xKTtpZigoUz09PSdcIid8fFM9PT1cIidcInx8Uz09PVwiYFwifHwoTz09PSdcIid8fE89PT1cIidcInx8Tz09PVwiYFwiKSkmJlMhPT1PKXt0aHJvdyBuZXcgbihcInByb3BlcnR5IG5hbWVzIHdpdGggcXVvdGVzIG11c3QgaGF2ZSBtYXRjaGluZyBxdW90ZXNcIil9aWYodj09PVwiY29uc3RydWN0b3JcInx8IWcpe3M9dHJ1ZX1pKz1cIi5cIit2O3A9XCIlXCIraStcIiVcIjtpZihiKGwscCkpe3U9bFtwXX1lbHNlIGlmKHUhPW51bGwpe2lmKCEodiBpbiB1KSl7aWYoIWUpe3Rocm93IG5ldyBhKFwiYmFzZSBpbnRyaW5zaWMgZm9yIFwiK3IrXCIgZXhpc3RzLCBidXQgdGhlIHByb3BlcnR5IGlzIG5vdCBhdmFpbGFibGUuXCIpfXJldHVybiB2b2lkIG99aWYoeSYmZCsxPj10Lmxlbmd0aCl7dmFyIHc9eSh1LHYpO2c9ISF3O2lmKGcmJlwiZ2V0XCJpbiB3JiYhKFwib3JpZ2luYWxWYWx1ZVwiaW4gdy5nZXQpKXt1PXcuZ2V0fWVsc2V7dT11W3ZdfX1lbHNle2c9Yih1LHYpO3U9dVt2XX1pZihnJiYhcyl7bFtwXT11fX19cmV0dXJuIHV9fSw5MjU6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBvO3ZhciBuPVN5bnRheEVycm9yO3ZhciBpPUZ1bmN0aW9uO3ZhciBhPVR5cGVFcnJvcjt2YXIgZ2V0RXZhbGxlZENvbnN0cnVjdG9yPWZ1bmN0aW9uKHIpe3RyeXtyZXR1cm4gaSgnXCJ1c2Ugc3RyaWN0XCI7IHJldHVybiAoJytyK1wiKS5jb25zdHJ1Y3RvcjtcIikoKX1jYXRjaChyKXt9fTt2YXIgeT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO2lmKHkpe3RyeXt5KHt9LFwiXCIpfWNhdGNoKHIpe3k9bnVsbH19dmFyIHRocm93VHlwZUVycm9yPWZ1bmN0aW9uKCl7dGhyb3cgbmV3IGF9O3ZhciBmPXk/ZnVuY3Rpb24oKXt0cnl7YXJndW1lbnRzLmNhbGxlZTtyZXR1cm4gdGhyb3dUeXBlRXJyb3J9Y2F0Y2gocil7dHJ5e3JldHVybiB5KGFyZ3VtZW50cyxcImNhbGxlZVwiKS5nZXR9Y2F0Y2gocil7cmV0dXJuIHRocm93VHlwZUVycm9yfX19KCk6dGhyb3dUeXBlRXJyb3I7dmFyIHA9dCgxMTUpKCk7dmFyIHU9dCg1MDQpKCk7dmFyIHM9T2JqZWN0LmdldFByb3RvdHlwZU9mfHwodT9mdW5jdGlvbihyKXtyZXR1cm4gci5fX3Byb3RvX199Om51bGwpO3ZhciBjPXt9O3ZhciBsPXR5cGVvZiBVaW50OEFycmF5PT09XCJ1bmRlZmluZWRcInx8IXM/bzpzKFVpbnQ4QXJyYXkpO3ZhciBkPXtcIiVBZ2dyZWdhdGVFcnJvciVcIjp0eXBlb2YgQWdncmVnYXRlRXJyb3I9PT1cInVuZGVmaW5lZFwiP286QWdncmVnYXRlRXJyb3IsXCIlQXJyYXklXCI6QXJyYXksXCIlQXJyYXlCdWZmZXIlXCI6dHlwZW9mIEFycmF5QnVmZmVyPT09XCJ1bmRlZmluZWRcIj9vOkFycmF5QnVmZmVyLFwiJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlXCI6cCYmcz9zKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSk6byxcIiVBc3luY0Zyb21TeW5jSXRlcmF0b3JQcm90b3R5cGUlXCI6byxcIiVBc3luY0Z1bmN0aW9uJVwiOmMsXCIlQXN5bmNHZW5lcmF0b3IlXCI6YyxcIiVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJVwiOmMsXCIlQXN5bmNJdGVyYXRvclByb3RvdHlwZSVcIjpjLFwiJUF0b21pY3MlXCI6dHlwZW9mIEF0b21pY3M9PT1cInVuZGVmaW5lZFwiP286QXRvbWljcyxcIiVCaWdJbnQlXCI6dHlwZW9mIEJpZ0ludD09PVwidW5kZWZpbmVkXCI/bzpCaWdJbnQsXCIlQmlnSW50NjRBcnJheSVcIjp0eXBlb2YgQmlnSW50NjRBcnJheT09PVwidW5kZWZpbmVkXCI/bzpCaWdJbnQ2NEFycmF5LFwiJUJpZ1VpbnQ2NEFycmF5JVwiOnR5cGVvZiBCaWdVaW50NjRBcnJheT09PVwidW5kZWZpbmVkXCI/bzpCaWdVaW50NjRBcnJheSxcIiVCb29sZWFuJVwiOkJvb2xlYW4sXCIlRGF0YVZpZXclXCI6dHlwZW9mIERhdGFWaWV3PT09XCJ1bmRlZmluZWRcIj9vOkRhdGFWaWV3LFwiJURhdGUlXCI6RGF0ZSxcIiVkZWNvZGVVUkklXCI6ZGVjb2RlVVJJLFwiJWRlY29kZVVSSUNvbXBvbmVudCVcIjpkZWNvZGVVUklDb21wb25lbnQsXCIlZW5jb2RlVVJJJVwiOmVuY29kZVVSSSxcIiVlbmNvZGVVUklDb21wb25lbnQlXCI6ZW5jb2RlVVJJQ29tcG9uZW50LFwiJUVycm9yJVwiOkVycm9yLFwiJWV2YWwlXCI6ZXZhbCxcIiVFdmFsRXJyb3IlXCI6RXZhbEVycm9yLFwiJUZsb2F0MzJBcnJheSVcIjp0eXBlb2YgRmxvYXQzMkFycmF5PT09XCJ1bmRlZmluZWRcIj9vOkZsb2F0MzJBcnJheSxcIiVGbG9hdDY0QXJyYXklXCI6dHlwZW9mIEZsb2F0NjRBcnJheT09PVwidW5kZWZpbmVkXCI/bzpGbG9hdDY0QXJyYXksXCIlRmluYWxpemF0aW9uUmVnaXN0cnklXCI6dHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5PT09XCJ1bmRlZmluZWRcIj9vOkZpbmFsaXphdGlvblJlZ2lzdHJ5LFwiJUZ1bmN0aW9uJVwiOmksXCIlR2VuZXJhdG9yRnVuY3Rpb24lXCI6YyxcIiVJbnQ4QXJyYXklXCI6dHlwZW9mIEludDhBcnJheT09PVwidW5kZWZpbmVkXCI/bzpJbnQ4QXJyYXksXCIlSW50MTZBcnJheSVcIjp0eXBlb2YgSW50MTZBcnJheT09PVwidW5kZWZpbmVkXCI/bzpJbnQxNkFycmF5LFwiJUludDMyQXJyYXklXCI6dHlwZW9mIEludDMyQXJyYXk9PT1cInVuZGVmaW5lZFwiP286SW50MzJBcnJheSxcIiVpc0Zpbml0ZSVcIjppc0Zpbml0ZSxcIiVpc05hTiVcIjppc05hTixcIiVJdGVyYXRvclByb3RvdHlwZSVcIjpwJiZzP3MocyhbXVtTeW1ib2wuaXRlcmF0b3JdKCkpKTpvLFwiJUpTT04lXCI6dHlwZW9mIEpTT049PT1cIm9iamVjdFwiP0pTT046byxcIiVNYXAlXCI6dHlwZW9mIE1hcD09PVwidW5kZWZpbmVkXCI/bzpNYXAsXCIlTWFwSXRlcmF0b3JQcm90b3R5cGUlXCI6dHlwZW9mIE1hcD09PVwidW5kZWZpbmVkXCJ8fCFwfHwhcz9vOnMoKG5ldyBNYXApW1N5bWJvbC5pdGVyYXRvcl0oKSksXCIlTWF0aCVcIjpNYXRoLFwiJU51bWJlciVcIjpOdW1iZXIsXCIlT2JqZWN0JVwiOk9iamVjdCxcIiVwYXJzZUZsb2F0JVwiOnBhcnNlRmxvYXQsXCIlcGFyc2VJbnQlXCI6cGFyc2VJbnQsXCIlUHJvbWlzZSVcIjp0eXBlb2YgUHJvbWlzZT09PVwidW5kZWZpbmVkXCI/bzpQcm9taXNlLFwiJVByb3h5JVwiOnR5cGVvZiBQcm94eT09PVwidW5kZWZpbmVkXCI/bzpQcm94eSxcIiVSYW5nZUVycm9yJVwiOlJhbmdlRXJyb3IsXCIlUmVmZXJlbmNlRXJyb3IlXCI6UmVmZXJlbmNlRXJyb3IsXCIlUmVmbGVjdCVcIjp0eXBlb2YgUmVmbGVjdD09PVwidW5kZWZpbmVkXCI/bzpSZWZsZWN0LFwiJVJlZ0V4cCVcIjpSZWdFeHAsXCIlU2V0JVwiOnR5cGVvZiBTZXQ9PT1cInVuZGVmaW5lZFwiP286U2V0LFwiJVNldEl0ZXJhdG9yUHJvdG90eXBlJVwiOnR5cGVvZiBTZXQ9PT1cInVuZGVmaW5lZFwifHwhcHx8IXM/bzpzKChuZXcgU2V0KVtTeW1ib2wuaXRlcmF0b3JdKCkpLFwiJVNoYXJlZEFycmF5QnVmZmVyJVwiOnR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlcj09PVwidW5kZWZpbmVkXCI/bzpTaGFyZWRBcnJheUJ1ZmZlcixcIiVTdHJpbmclXCI6U3RyaW5nLFwiJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJVwiOnAmJnM/cyhcIlwiW1N5bWJvbC5pdGVyYXRvcl0oKSk6byxcIiVTeW1ib2wlXCI6cD9TeW1ib2w6byxcIiVTeW50YXhFcnJvciVcIjpuLFwiJVRocm93VHlwZUVycm9yJVwiOmYsXCIlVHlwZWRBcnJheSVcIjpsLFwiJVR5cGVFcnJvciVcIjphLFwiJVVpbnQ4QXJyYXklXCI6dHlwZW9mIFVpbnQ4QXJyYXk9PT1cInVuZGVmaW5lZFwiP286VWludDhBcnJheSxcIiVVaW50OENsYW1wZWRBcnJheSVcIjp0eXBlb2YgVWludDhDbGFtcGVkQXJyYXk9PT1cInVuZGVmaW5lZFwiP286VWludDhDbGFtcGVkQXJyYXksXCIlVWludDE2QXJyYXklXCI6dHlwZW9mIFVpbnQxNkFycmF5PT09XCJ1bmRlZmluZWRcIj9vOlVpbnQxNkFycmF5LFwiJVVpbnQzMkFycmF5JVwiOnR5cGVvZiBVaW50MzJBcnJheT09PVwidW5kZWZpbmVkXCI/bzpVaW50MzJBcnJheSxcIiVVUklFcnJvciVcIjpVUklFcnJvcixcIiVXZWFrTWFwJVwiOnR5cGVvZiBXZWFrTWFwPT09XCJ1bmRlZmluZWRcIj9vOldlYWtNYXAsXCIlV2Vha1JlZiVcIjp0eXBlb2YgV2Vha1JlZj09PVwidW5kZWZpbmVkXCI/bzpXZWFrUmVmLFwiJVdlYWtTZXQlXCI6dHlwZW9mIFdlYWtTZXQ9PT1cInVuZGVmaW5lZFwiP286V2Vha1NldH07aWYocyl7dHJ5e251bGwuZXJyb3J9Y2F0Y2gocil7dmFyIGc9cyhzKHIpKTtkW1wiJUVycm9yLnByb3RvdHlwZSVcIl09Z319dmFyIHY9ZnVuY3Rpb24gZG9FdmFsKHIpe3ZhciBlO2lmKHI9PT1cIiVBc3luY0Z1bmN0aW9uJVwiKXtlPWdldEV2YWxsZWRDb25zdHJ1Y3RvcihcImFzeW5jIGZ1bmN0aW9uICgpIHt9XCIpfWVsc2UgaWYocj09PVwiJUdlbmVyYXRvckZ1bmN0aW9uJVwiKXtlPWdldEV2YWxsZWRDb25zdHJ1Y3RvcihcImZ1bmN0aW9uKiAoKSB7fVwiKX1lbHNlIGlmKHI9PT1cIiVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJVwiKXtlPWdldEV2YWxsZWRDb25zdHJ1Y3RvcihcImFzeW5jIGZ1bmN0aW9uKiAoKSB7fVwiKX1lbHNlIGlmKHI9PT1cIiVBc3luY0dlbmVyYXRvciVcIil7dmFyIHQ9ZG9FdmFsKFwiJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lXCIpO2lmKHQpe2U9dC5wcm90b3R5cGV9fWVsc2UgaWYocj09PVwiJUFzeW5jSXRlcmF0b3JQcm90b3R5cGUlXCIpe3ZhciBvPWRvRXZhbChcIiVBc3luY0dlbmVyYXRvciVcIik7aWYobyYmcyl7ZT1zKG8ucHJvdG90eXBlKX19ZFtyXT1lO3JldHVybiBlfTt2YXIgYj17XCIlQXJyYXlCdWZmZXJQcm90b3R5cGUlXCI6W1wiQXJyYXlCdWZmZXJcIixcInByb3RvdHlwZVwiXSxcIiVBcnJheVByb3RvdHlwZSVcIjpbXCJBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJUFycmF5UHJvdG9fZW50cmllcyVcIjpbXCJBcnJheVwiLFwicHJvdG90eXBlXCIsXCJlbnRyaWVzXCJdLFwiJUFycmF5UHJvdG9fZm9yRWFjaCVcIjpbXCJBcnJheVwiLFwicHJvdG90eXBlXCIsXCJmb3JFYWNoXCJdLFwiJUFycmF5UHJvdG9fa2V5cyVcIjpbXCJBcnJheVwiLFwicHJvdG90eXBlXCIsXCJrZXlzXCJdLFwiJUFycmF5UHJvdG9fdmFsdWVzJVwiOltcIkFycmF5XCIsXCJwcm90b3R5cGVcIixcInZhbHVlc1wiXSxcIiVBc3luY0Z1bmN0aW9uUHJvdG90eXBlJVwiOltcIkFzeW5jRnVuY3Rpb25cIixcInByb3RvdHlwZVwiXSxcIiVBc3luY0dlbmVyYXRvciVcIjpbXCJBc3luY0dlbmVyYXRvckZ1bmN0aW9uXCIsXCJwcm90b3R5cGVcIl0sXCIlQXN5bmNHZW5lcmF0b3JQcm90b3R5cGUlXCI6W1wiQXN5bmNHZW5lcmF0b3JGdW5jdGlvblwiLFwicHJvdG90eXBlXCIsXCJwcm90b3R5cGVcIl0sXCIlQm9vbGVhblByb3RvdHlwZSVcIjpbXCJCb29sZWFuXCIsXCJwcm90b3R5cGVcIl0sXCIlRGF0YVZpZXdQcm90b3R5cGUlXCI6W1wiRGF0YVZpZXdcIixcInByb3RvdHlwZVwiXSxcIiVEYXRlUHJvdG90eXBlJVwiOltcIkRhdGVcIixcInByb3RvdHlwZVwiXSxcIiVFcnJvclByb3RvdHlwZSVcIjpbXCJFcnJvclwiLFwicHJvdG90eXBlXCJdLFwiJUV2YWxFcnJvclByb3RvdHlwZSVcIjpbXCJFdmFsRXJyb3JcIixcInByb3RvdHlwZVwiXSxcIiVGbG9hdDMyQXJyYXlQcm90b3R5cGUlXCI6W1wiRmxvYXQzMkFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlRmxvYXQ2NEFycmF5UHJvdG90eXBlJVwiOltcIkZsb2F0NjRBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJUZ1bmN0aW9uUHJvdG90eXBlJVwiOltcIkZ1bmN0aW9uXCIsXCJwcm90b3R5cGVcIl0sXCIlR2VuZXJhdG9yJVwiOltcIkdlbmVyYXRvckZ1bmN0aW9uXCIsXCJwcm90b3R5cGVcIl0sXCIlR2VuZXJhdG9yUHJvdG90eXBlJVwiOltcIkdlbmVyYXRvckZ1bmN0aW9uXCIsXCJwcm90b3R5cGVcIixcInByb3RvdHlwZVwiXSxcIiVJbnQ4QXJyYXlQcm90b3R5cGUlXCI6W1wiSW50OEFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlSW50MTZBcnJheVByb3RvdHlwZSVcIjpbXCJJbnQxNkFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlSW50MzJBcnJheVByb3RvdHlwZSVcIjpbXCJJbnQzMkFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlSlNPTlBhcnNlJVwiOltcIkpTT05cIixcInBhcnNlXCJdLFwiJUpTT05TdHJpbmdpZnklXCI6W1wiSlNPTlwiLFwic3RyaW5naWZ5XCJdLFwiJU1hcFByb3RvdHlwZSVcIjpbXCJNYXBcIixcInByb3RvdHlwZVwiXSxcIiVOdW1iZXJQcm90b3R5cGUlXCI6W1wiTnVtYmVyXCIsXCJwcm90b3R5cGVcIl0sXCIlT2JqZWN0UHJvdG90eXBlJVwiOltcIk9iamVjdFwiLFwicHJvdG90eXBlXCJdLFwiJU9ialByb3RvX3RvU3RyaW5nJVwiOltcIk9iamVjdFwiLFwicHJvdG90eXBlXCIsXCJ0b1N0cmluZ1wiXSxcIiVPYmpQcm90b192YWx1ZU9mJVwiOltcIk9iamVjdFwiLFwicHJvdG90eXBlXCIsXCJ2YWx1ZU9mXCJdLFwiJVByb21pc2VQcm90b3R5cGUlXCI6W1wiUHJvbWlzZVwiLFwicHJvdG90eXBlXCJdLFwiJVByb21pc2VQcm90b190aGVuJVwiOltcIlByb21pc2VcIixcInByb3RvdHlwZVwiLFwidGhlblwiXSxcIiVQcm9taXNlX2FsbCVcIjpbXCJQcm9taXNlXCIsXCJhbGxcIl0sXCIlUHJvbWlzZV9yZWplY3QlXCI6W1wiUHJvbWlzZVwiLFwicmVqZWN0XCJdLFwiJVByb21pc2VfcmVzb2x2ZSVcIjpbXCJQcm9taXNlXCIsXCJyZXNvbHZlXCJdLFwiJVJhbmdlRXJyb3JQcm90b3R5cGUlXCI6W1wiUmFuZ2VFcnJvclwiLFwicHJvdG90eXBlXCJdLFwiJVJlZmVyZW5jZUVycm9yUHJvdG90eXBlJVwiOltcIlJlZmVyZW5jZUVycm9yXCIsXCJwcm90b3R5cGVcIl0sXCIlUmVnRXhwUHJvdG90eXBlJVwiOltcIlJlZ0V4cFwiLFwicHJvdG90eXBlXCJdLFwiJVNldFByb3RvdHlwZSVcIjpbXCJTZXRcIixcInByb3RvdHlwZVwiXSxcIiVTaGFyZWRBcnJheUJ1ZmZlclByb3RvdHlwZSVcIjpbXCJTaGFyZWRBcnJheUJ1ZmZlclwiLFwicHJvdG90eXBlXCJdLFwiJVN0cmluZ1Byb3RvdHlwZSVcIjpbXCJTdHJpbmdcIixcInByb3RvdHlwZVwiXSxcIiVTeW1ib2xQcm90b3R5cGUlXCI6W1wiU3ltYm9sXCIsXCJwcm90b3R5cGVcIl0sXCIlU3ludGF4RXJyb3JQcm90b3R5cGUlXCI6W1wiU3ludGF4RXJyb3JcIixcInByb3RvdHlwZVwiXSxcIiVUeXBlZEFycmF5UHJvdG90eXBlJVwiOltcIlR5cGVkQXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVUeXBlRXJyb3JQcm90b3R5cGUlXCI6W1wiVHlwZUVycm9yXCIsXCJwcm90b3R5cGVcIl0sXCIlVWludDhBcnJheVByb3RvdHlwZSVcIjpbXCJVaW50OEFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUlXCI6W1wiVWludDhDbGFtcGVkQXJyYXlcIixcInByb3RvdHlwZVwiXSxcIiVVaW50MTZBcnJheVByb3RvdHlwZSVcIjpbXCJVaW50MTZBcnJheVwiLFwicHJvdG90eXBlXCJdLFwiJVVpbnQzMkFycmF5UHJvdG90eXBlJVwiOltcIlVpbnQzMkFycmF5XCIsXCJwcm90b3R5cGVcIl0sXCIlVVJJRXJyb3JQcm90b3R5cGUlXCI6W1wiVVJJRXJyb3JcIixcInByb3RvdHlwZVwiXSxcIiVXZWFrTWFwUHJvdG90eXBlJVwiOltcIldlYWtNYXBcIixcInByb3RvdHlwZVwiXSxcIiVXZWFrU2V0UHJvdG90eXBlJVwiOltcIldlYWtTZXRcIixcInByb3RvdHlwZVwiXX07dmFyIEE9dCgxNzQpO3ZhciBtPXQoMTAxKTt2YXIgUz1BLmNhbGwoRnVuY3Rpb24uY2FsbCxBcnJheS5wcm90b3R5cGUuY29uY2F0KTt2YXIgaD1BLmNhbGwoRnVuY3Rpb24uYXBwbHksQXJyYXkucHJvdG90eXBlLnNwbGljZSk7dmFyIFA9QS5jYWxsKEZ1bmN0aW9uLmNhbGwsU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlKTt2YXIgTz1BLmNhbGwoRnVuY3Rpb24uY2FsbCxTdHJpbmcucHJvdG90eXBlLnNsaWNlKTt2YXIgdz1BLmNhbGwoRnVuY3Rpb24uY2FsbCxSZWdFeHAucHJvdG90eXBlLmV4ZWMpO3ZhciBqPS9bXiUuW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JSQpKS9nO3ZhciBFPS9cXFxcKFxcXFwpPy9nO3ZhciBJPWZ1bmN0aW9uIHN0cmluZ1RvUGF0aChyKXt2YXIgZT1PKHIsMCwxKTt2YXIgdD1PKHIsLTEpO2lmKGU9PT1cIiVcIiYmdCE9PVwiJVwiKXt0aHJvdyBuZXcgbihcImludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgY2xvc2luZyBgJWBcIil9ZWxzZSBpZih0PT09XCIlXCImJmUhPT1cIiVcIil7dGhyb3cgbmV3IG4oXCJpbnZhbGlkIGludHJpbnNpYyBzeW50YXgsIGV4cGVjdGVkIG9wZW5pbmcgYCVgXCIpfXZhciBvPVtdO1AocixqLChmdW5jdGlvbihyLGUsdCxuKXtvW28ubGVuZ3RoXT10P1AobixFLFwiJDFcIik6ZXx8cn0pKTtyZXR1cm4gb307dmFyIEI9ZnVuY3Rpb24gZ2V0QmFzZUludHJpbnNpYyhyLGUpe3ZhciB0PXI7dmFyIG87aWYobShiLHQpKXtvPWJbdF07dD1cIiVcIitvWzBdK1wiJVwifWlmKG0oZCx0KSl7dmFyIGk9ZFt0XTtpZihpPT09Yyl7aT12KHQpfWlmKHR5cGVvZiBpPT09XCJ1bmRlZmluZWRcIiYmIWUpe3Rocm93IG5ldyBhKFwiaW50cmluc2ljIFwiK3IrXCIgZXhpc3RzLCBidXQgaXMgbm90IGF2YWlsYWJsZS4gUGxlYXNlIGZpbGUgYW4gaXNzdWUhXCIpfXJldHVybnthbGlhczpvLG5hbWU6dCx2YWx1ZTppfX10aHJvdyBuZXcgbihcImludHJpbnNpYyBcIityK1wiIGRvZXMgbm90IGV4aXN0IVwiKX07ci5leHBvcnRzPWZ1bmN0aW9uIEdldEludHJpbnNpYyhyLGUpe2lmKHR5cGVvZiByIT09XCJzdHJpbmdcInx8ci5sZW5ndGg9PT0wKXt0aHJvdyBuZXcgYShcImludHJpbnNpYyBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nXCIpfWlmKGFyZ3VtZW50cy5sZW5ndGg+MSYmdHlwZW9mIGUhPT1cImJvb2xlYW5cIil7dGhyb3cgbmV3IGEoJ1wiYWxsb3dNaXNzaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBhIGJvb2xlYW4nKX1pZih3KC9eJT9bXiVdKiU/JC8scik9PT1udWxsKXt0aHJvdyBuZXcgbihcImAlYCBtYXkgbm90IGJlIHByZXNlbnQgYW55d2hlcmUgYnV0IGF0IHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiB0aGUgaW50cmluc2ljIG5hbWVcIil9dmFyIHQ9SShyKTt2YXIgaT10Lmxlbmd0aD4wP3RbMF06XCJcIjt2YXIgZj1CKFwiJVwiK2krXCIlXCIsZSk7dmFyIHA9Zi5uYW1lO3ZhciB1PWYudmFsdWU7dmFyIHM9ZmFsc2U7dmFyIGM9Zi5hbGlhcztpZihjKXtpPWNbMF07aCh0LFMoWzAsMV0sYykpfWZvcih2YXIgbD0xLGc9dHJ1ZTtsPHQubGVuZ3RoO2wrPTEpe3ZhciB2PXRbbF07dmFyIGI9Tyh2LDAsMSk7dmFyIEE9Tyh2LC0xKTtpZigoYj09PSdcIid8fGI9PT1cIidcInx8Yj09PVwiYFwifHwoQT09PSdcIid8fEE9PT1cIidcInx8QT09PVwiYFwiKSkmJmIhPT1BKXt0aHJvdyBuZXcgbihcInByb3BlcnR5IG5hbWVzIHdpdGggcXVvdGVzIG11c3QgaGF2ZSBtYXRjaGluZyBxdW90ZXNcIil9aWYodj09PVwiY29uc3RydWN0b3JcInx8IWcpe3M9dHJ1ZX1pKz1cIi5cIit2O3A9XCIlXCIraStcIiVcIjtpZihtKGQscCkpe3U9ZFtwXX1lbHNlIGlmKHUhPW51bGwpe2lmKCEodiBpbiB1KSl7aWYoIWUpe3Rocm93IG5ldyBhKFwiYmFzZSBpbnRyaW5zaWMgZm9yIFwiK3IrXCIgZXhpc3RzLCBidXQgdGhlIHByb3BlcnR5IGlzIG5vdCBhdmFpbGFibGUuXCIpfXJldHVybiB2b2lkIG99aWYoeSYmbCsxPj10Lmxlbmd0aCl7dmFyIFA9eSh1LHYpO2c9ISFQO2lmKGcmJlwiZ2V0XCJpbiBQJiYhKFwib3JpZ2luYWxWYWx1ZVwiaW4gUC5nZXQpKXt1PVAuZ2V0fWVsc2V7dT11W3ZdfX1lbHNle2c9bSh1LHYpO3U9dVt2XX1pZihnJiYhcyl7ZFtwXT11fX19cmV0dXJuIHV9fSw1MDQ6ZnVuY3Rpb24ocil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGU9e2Zvbzp7fX07dmFyIHQ9T2JqZWN0O3IuZXhwb3J0cz1mdW5jdGlvbiBoYXNQcm90bygpe3JldHVybntfX3Byb3RvX186ZX0uZm9vPT09ZS5mb28mJiEoe19fcHJvdG9fXzpudWxsfWluc3RhbmNlb2YgdCl9fSw5NDI6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBvPXR5cGVvZiBTeW1ib2whPT1cInVuZGVmaW5lZFwiJiZTeW1ib2w7dmFyIG49dCg3NzMpO3IuZXhwb3J0cz1mdW5jdGlvbiBoYXNOYXRpdmVTeW1ib2xzKCl7aWYodHlwZW9mIG8hPT1cImZ1bmN0aW9uXCIpe3JldHVybiBmYWxzZX1pZih0eXBlb2YgU3ltYm9sIT09XCJmdW5jdGlvblwiKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIG8oXCJmb29cIikhPT1cInN5bWJvbFwiKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIFN5bWJvbChcImJhclwiKSE9PVwic3ltYm9sXCIpe3JldHVybiBmYWxzZX1yZXR1cm4gbigpfX0sNzczOmZ1bmN0aW9uKHIpe1widXNlIHN0cmljdFwiO3IuZXhwb3J0cz1mdW5jdGlvbiBoYXNTeW1ib2xzKCl7aWYodHlwZW9mIFN5bWJvbCE9PVwiZnVuY3Rpb25cInx8dHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMhPT1cImZ1bmN0aW9uXCIpe3JldHVybiBmYWxzZX1pZih0eXBlb2YgU3ltYm9sLml0ZXJhdG9yPT09XCJzeW1ib2xcIil7cmV0dXJuIHRydWV9dmFyIHI9e307dmFyIGU9U3ltYm9sKFwidGVzdFwiKTt2YXIgdD1PYmplY3QoZSk7aWYodHlwZW9mIGU9PT1cInN0cmluZ1wiKXtyZXR1cm4gZmFsc2V9aWYoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpIT09XCJbb2JqZWN0IFN5bWJvbF1cIil7cmV0dXJuIGZhbHNlfWlmKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSE9PVwiW29iamVjdCBTeW1ib2xdXCIpe3JldHVybiBmYWxzZX12YXIgbz00MjtyW2VdPW87Zm9yKGUgaW4gcil7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBPYmplY3Qua2V5cz09PVwiZnVuY3Rpb25cIiYmT2JqZWN0LmtleXMocikubGVuZ3RoIT09MCl7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcz09PVwiZnVuY3Rpb25cIiYmT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocikubGVuZ3RoIT09MCl7cmV0dXJuIGZhbHNlfXZhciBuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocik7aWYobi5sZW5ndGghPT0xfHxuWzBdIT09ZSl7cmV0dXJuIGZhbHNlfWlmKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocixlKSl7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yPT09XCJmdW5jdGlvblwiKXt2YXIgaT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHIsZSk7aWYoaS52YWx1ZSE9PW98fGkuZW51bWVyYWJsZSE9PXRydWUpe3JldHVybiBmYWxzZX19cmV0dXJuIHRydWV9fSwxMTU6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBvPXR5cGVvZiBTeW1ib2whPT1cInVuZGVmaW5lZFwiJiZTeW1ib2w7dmFyIG49dCg4MzIpO3IuZXhwb3J0cz1mdW5jdGlvbiBoYXNOYXRpdmVTeW1ib2xzKCl7aWYodHlwZW9mIG8hPT1cImZ1bmN0aW9uXCIpe3JldHVybiBmYWxzZX1pZih0eXBlb2YgU3ltYm9sIT09XCJmdW5jdGlvblwiKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIG8oXCJmb29cIikhPT1cInN5bWJvbFwiKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIFN5bWJvbChcImJhclwiKSE9PVwic3ltYm9sXCIpe3JldHVybiBmYWxzZX1yZXR1cm4gbigpfX0sODMyOmZ1bmN0aW9uKHIpe1widXNlIHN0cmljdFwiO3IuZXhwb3J0cz1mdW5jdGlvbiBoYXNTeW1ib2xzKCl7aWYodHlwZW9mIFN5bWJvbCE9PVwiZnVuY3Rpb25cInx8dHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMhPT1cImZ1bmN0aW9uXCIpe3JldHVybiBmYWxzZX1pZih0eXBlb2YgU3ltYm9sLml0ZXJhdG9yPT09XCJzeW1ib2xcIil7cmV0dXJuIHRydWV9dmFyIHI9e307dmFyIGU9U3ltYm9sKFwidGVzdFwiKTt2YXIgdD1PYmplY3QoZSk7aWYodHlwZW9mIGU9PT1cInN0cmluZ1wiKXtyZXR1cm4gZmFsc2V9aWYoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpIT09XCJbb2JqZWN0IFN5bWJvbF1cIil7cmV0dXJuIGZhbHNlfWlmKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSE9PVwiW29iamVjdCBTeW1ib2xdXCIpe3JldHVybiBmYWxzZX12YXIgbz00MjtyW2VdPW87Zm9yKGUgaW4gcil7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBPYmplY3Qua2V5cz09PVwiZnVuY3Rpb25cIiYmT2JqZWN0LmtleXMocikubGVuZ3RoIT09MCl7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcz09PVwiZnVuY3Rpb25cIiYmT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocikubGVuZ3RoIT09MCl7cmV0dXJuIGZhbHNlfXZhciBuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocik7aWYobi5sZW5ndGghPT0xfHxuWzBdIT09ZSl7cmV0dXJuIGZhbHNlfWlmKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocixlKSl7cmV0dXJuIGZhbHNlfWlmKHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yPT09XCJmdW5jdGlvblwiKXt2YXIgaT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHIsZSk7aWYoaS52YWx1ZSE9PW98fGkuZW51bWVyYWJsZSE9PXRydWUpe3JldHVybiBmYWxzZX19cmV0dXJuIHRydWV9fSwxMDE6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBvPXQoMTc0KTtyLmV4cG9ydHM9by5jYWxsKEZ1bmN0aW9uLmNhbGwsT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSl9LDc4MjpmdW5jdGlvbihyKXtpZih0eXBlb2YgT2JqZWN0LmNyZWF0ZT09PVwiZnVuY3Rpb25cIil7ci5leHBvcnRzPWZ1bmN0aW9uIGluaGVyaXRzKHIsZSl7aWYoZSl7ci5zdXBlcl89ZTtyLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6cixlbnVtZXJhYmxlOmZhbHNlLHdyaXRhYmxlOnRydWUsY29uZmlndXJhYmxlOnRydWV9fSl9fX1lbHNle3IuZXhwb3J0cz1mdW5jdGlvbiBpbmhlcml0cyhyLGUpe2lmKGUpe3Iuc3VwZXJfPWU7dmFyIFRlbXBDdG9yPWZ1bmN0aW9uKCl7fTtUZW1wQ3Rvci5wcm90b3R5cGU9ZS5wcm90b3R5cGU7ci5wcm90b3R5cGU9bmV3IFRlbXBDdG9yO3IucHJvdG90eXBlLmNvbnN0cnVjdG9yPXJ9fX19LDE1NzpmdW5jdGlvbihyKXtcInVzZSBzdHJpY3RcIjt2YXIgZT10eXBlb2YgU3ltYm9sPT09XCJmdW5jdGlvblwiJiZ0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnPT09XCJzeW1ib2xcIjt2YXIgdD1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO3ZhciBvPWZ1bmN0aW9uIGlzQXJndW1lbnRzKHIpe2lmKGUmJnImJnR5cGVvZiByPT09XCJvYmplY3RcIiYmU3ltYm9sLnRvU3RyaW5nVGFnIGluIHIpe3JldHVybiBmYWxzZX1yZXR1cm4gdC5jYWxsKHIpPT09XCJbb2JqZWN0IEFyZ3VtZW50c11cIn07dmFyIG49ZnVuY3Rpb24gaXNBcmd1bWVudHMocil7aWYobyhyKSl7cmV0dXJuIHRydWV9cmV0dXJuIHIhPT1udWxsJiZ0eXBlb2Ygcj09PVwib2JqZWN0XCImJnR5cGVvZiByLmxlbmd0aD09PVwibnVtYmVyXCImJnIubGVuZ3RoPj0wJiZ0LmNhbGwocikhPT1cIltvYmplY3QgQXJyYXldXCImJnQuY2FsbChyLmNhbGxlZSk9PT1cIltvYmplY3QgRnVuY3Rpb25dXCJ9O3ZhciBpPWZ1bmN0aW9uKCl7cmV0dXJuIG8oYXJndW1lbnRzKX0oKTtvLmlzTGVnYWN5QXJndW1lbnRzPW47ci5leHBvcnRzPWk/bzpufSwzOTE6ZnVuY3Rpb24ocil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGU9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZzt2YXIgdD1GdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7dmFyIG89L15cXHMqKD86ZnVuY3Rpb24pP1xcKi87dmFyIG49dHlwZW9mIFN5bWJvbD09PVwiZnVuY3Rpb25cIiYmdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZz09PVwic3ltYm9sXCI7dmFyIGk9T2JqZWN0LmdldFByb3RvdHlwZU9mO3ZhciBnZXRHZW5lcmF0b3JGdW5jPWZ1bmN0aW9uKCl7aWYoIW4pe3JldHVybiBmYWxzZX10cnl7cmV0dXJuIEZ1bmN0aW9uKFwicmV0dXJuIGZ1bmN0aW9uKigpIHt9XCIpKCl9Y2F0Y2gocil7fX07dmFyIGE9Z2V0R2VuZXJhdG9yRnVuYygpO3ZhciB5PWE/aShhKTp7fTtyLmV4cG9ydHM9ZnVuY3Rpb24gaXNHZW5lcmF0b3JGdW5jdGlvbihyKXtpZih0eXBlb2YgciE9PVwiZnVuY3Rpb25cIil7cmV0dXJuIGZhbHNlfWlmKG8udGVzdCh0LmNhbGwocikpKXtyZXR1cm4gdHJ1ZX1pZighbil7dmFyIGE9ZS5jYWxsKHIpO3JldHVybiBhPT09XCJbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXVwifXJldHVybiBpKHIpPT09eX19LDk5NDpmdW5jdGlvbihyLGUsdCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG89dCgxNDQpO3ZhciBuPXQoMzQ5KTt2YXIgaT10KDI1Nik7dmFyIGE9aShcIk9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcIik7dmFyIHk9dCg5NDIpKCk7dmFyIGY9eSYmdHlwZW9mIFN5bWJvbC50b1N0cmluZ1RhZz09PVwic3ltYm9sXCI7dmFyIHA9bigpO3ZhciB1PWkoXCJBcnJheS5wcm90b3R5cGUuaW5kZXhPZlwiLHRydWUpfHxmdW5jdGlvbiBpbmRleE9mKHIsZSl7Zm9yKHZhciB0PTA7dDxyLmxlbmd0aDt0Kz0xKXtpZihyW3RdPT09ZSl7cmV0dXJuIHR9fXJldHVybi0xfTt2YXIgcz1pKFwiU3RyaW5nLnByb3RvdHlwZS5zbGljZVwiKTt2YXIgYz17fTt2YXIgbD10KDI0KTt2YXIgZD1PYmplY3QuZ2V0UHJvdG90eXBlT2Y7aWYoZiYmbCYmZCl7byhwLChmdW5jdGlvbihyKXt2YXIgZT1uZXcgZ2xvYmFsW3JdO2lmKCEoU3ltYm9sLnRvU3RyaW5nVGFnIGluIGUpKXt0aHJvdyBuZXcgRXZhbEVycm9yKFwidGhpcyBlbmdpbmUgaGFzIHN1cHBvcnQgZm9yIFN5bWJvbC50b1N0cmluZ1RhZywgYnV0IFwiK3IrXCIgZG9lcyBub3QgaGF2ZSB0aGUgcHJvcGVydHkhIFBsZWFzZSByZXBvcnQgdGhpcy5cIil9dmFyIHQ9ZChlKTt2YXIgbz1sKHQsU3ltYm9sLnRvU3RyaW5nVGFnKTtpZighbyl7dmFyIG49ZCh0KTtvPWwobixTeW1ib2wudG9TdHJpbmdUYWcpfWNbcl09by5nZXR9KSl9dmFyIGc9ZnVuY3Rpb24gdHJ5QWxsVHlwZWRBcnJheXMocil7dmFyIGU9ZmFsc2U7byhjLChmdW5jdGlvbih0LG8pe2lmKCFlKXt0cnl7ZT10LmNhbGwocik9PT1vfWNhdGNoKHIpe319fSkpO3JldHVybiBlfTtyLmV4cG9ydHM9ZnVuY3Rpb24gaXNUeXBlZEFycmF5KHIpe2lmKCFyfHx0eXBlb2YgciE9PVwib2JqZWN0XCIpe3JldHVybiBmYWxzZX1pZighZil7dmFyIGU9cyhhKHIpLDgsLTEpO3JldHVybiB1KHAsZSk+LTF9aWYoIWwpe3JldHVybiBmYWxzZX1yZXR1cm4gZyhyKX19LDM2OTpmdW5jdGlvbihyKXtyLmV4cG9ydHM9ZnVuY3Rpb24gaXNCdWZmZXIocil7cmV0dXJuIHIgaW5zdGFuY2VvZiBCdWZmZXJ9fSw1ODQ6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBvPXQoMTU3KTt2YXIgbj10KDM5MSk7dmFyIGk9dCg0OTApO3ZhciBhPXQoOTk0KTtmdW5jdGlvbiB1bmN1cnJ5VGhpcyhyKXtyZXR1cm4gci5jYWxsLmJpbmQocil9dmFyIHk9dHlwZW9mIEJpZ0ludCE9PVwidW5kZWZpbmVkXCI7dmFyIGY9dHlwZW9mIFN5bWJvbCE9PVwidW5kZWZpbmVkXCI7dmFyIHA9dW5jdXJyeVRoaXMoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyk7dmFyIHU9dW5jdXJyeVRoaXMoTnVtYmVyLnByb3RvdHlwZS52YWx1ZU9mKTt2YXIgcz11bmN1cnJ5VGhpcyhTdHJpbmcucHJvdG90eXBlLnZhbHVlT2YpO3ZhciBjPXVuY3VycnlUaGlzKEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YpO2lmKHkpe3ZhciBsPXVuY3VycnlUaGlzKEJpZ0ludC5wcm90b3R5cGUudmFsdWVPZil9aWYoZil7dmFyIGQ9dW5jdXJyeVRoaXMoU3ltYm9sLnByb3RvdHlwZS52YWx1ZU9mKX1mdW5jdGlvbiBjaGVja0JveGVkUHJpbWl0aXZlKHIsZSl7aWYodHlwZW9mIHIhPT1cIm9iamVjdFwiKXtyZXR1cm4gZmFsc2V9dHJ5e2Uocik7cmV0dXJuIHRydWV9Y2F0Y2gocil7cmV0dXJuIGZhbHNlfX1lLmlzQXJndW1lbnRzT2JqZWN0PW87ZS5pc0dlbmVyYXRvckZ1bmN0aW9uPW47ZS5pc1R5cGVkQXJyYXk9YTtmdW5jdGlvbiBpc1Byb21pc2Uocil7cmV0dXJuIHR5cGVvZiBQcm9taXNlIT09XCJ1bmRlZmluZWRcIiYmciBpbnN0YW5jZW9mIFByb21pc2V8fHIhPT1udWxsJiZ0eXBlb2Ygcj09PVwib2JqZWN0XCImJnR5cGVvZiByLnRoZW49PT1cImZ1bmN0aW9uXCImJnR5cGVvZiByLmNhdGNoPT09XCJmdW5jdGlvblwifWUuaXNQcm9taXNlPWlzUHJvbWlzZTtmdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyhyKXtpZih0eXBlb2YgQXJyYXlCdWZmZXIhPT1cInVuZGVmaW5lZFwiJiZBcnJheUJ1ZmZlci5pc1ZpZXcpe3JldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcocil9cmV0dXJuIGEocil8fGlzRGF0YVZpZXcocil9ZS5pc0FycmF5QnVmZmVyVmlldz1pc0FycmF5QnVmZmVyVmlldztmdW5jdGlvbiBpc1VpbnQ4QXJyYXkocil7cmV0dXJuIGkocik9PT1cIlVpbnQ4QXJyYXlcIn1lLmlzVWludDhBcnJheT1pc1VpbnQ4QXJyYXk7ZnVuY3Rpb24gaXNVaW50OENsYW1wZWRBcnJheShyKXtyZXR1cm4gaShyKT09PVwiVWludDhDbGFtcGVkQXJyYXlcIn1lLmlzVWludDhDbGFtcGVkQXJyYXk9aXNVaW50OENsYW1wZWRBcnJheTtmdW5jdGlvbiBpc1VpbnQxNkFycmF5KHIpe3JldHVybiBpKHIpPT09XCJVaW50MTZBcnJheVwifWUuaXNVaW50MTZBcnJheT1pc1VpbnQxNkFycmF5O2Z1bmN0aW9uIGlzVWludDMyQXJyYXkocil7cmV0dXJuIGkocik9PT1cIlVpbnQzMkFycmF5XCJ9ZS5pc1VpbnQzMkFycmF5PWlzVWludDMyQXJyYXk7ZnVuY3Rpb24gaXNJbnQ4QXJyYXkocil7cmV0dXJuIGkocik9PT1cIkludDhBcnJheVwifWUuaXNJbnQ4QXJyYXk9aXNJbnQ4QXJyYXk7ZnVuY3Rpb24gaXNJbnQxNkFycmF5KHIpe3JldHVybiBpKHIpPT09XCJJbnQxNkFycmF5XCJ9ZS5pc0ludDE2QXJyYXk9aXNJbnQxNkFycmF5O2Z1bmN0aW9uIGlzSW50MzJBcnJheShyKXtyZXR1cm4gaShyKT09PVwiSW50MzJBcnJheVwifWUuaXNJbnQzMkFycmF5PWlzSW50MzJBcnJheTtmdW5jdGlvbiBpc0Zsb2F0MzJBcnJheShyKXtyZXR1cm4gaShyKT09PVwiRmxvYXQzMkFycmF5XCJ9ZS5pc0Zsb2F0MzJBcnJheT1pc0Zsb2F0MzJBcnJheTtmdW5jdGlvbiBpc0Zsb2F0NjRBcnJheShyKXtyZXR1cm4gaShyKT09PVwiRmxvYXQ2NEFycmF5XCJ9ZS5pc0Zsb2F0NjRBcnJheT1pc0Zsb2F0NjRBcnJheTtmdW5jdGlvbiBpc0JpZ0ludDY0QXJyYXkocil7cmV0dXJuIGkocik9PT1cIkJpZ0ludDY0QXJyYXlcIn1lLmlzQmlnSW50NjRBcnJheT1pc0JpZ0ludDY0QXJyYXk7ZnVuY3Rpb24gaXNCaWdVaW50NjRBcnJheShyKXtyZXR1cm4gaShyKT09PVwiQmlnVWludDY0QXJyYXlcIn1lLmlzQmlnVWludDY0QXJyYXk9aXNCaWdVaW50NjRBcnJheTtmdW5jdGlvbiBpc01hcFRvU3RyaW5nKHIpe3JldHVybiBwKHIpPT09XCJbb2JqZWN0IE1hcF1cIn1pc01hcFRvU3RyaW5nLndvcmtpbmc9dHlwZW9mIE1hcCE9PVwidW5kZWZpbmVkXCImJmlzTWFwVG9TdHJpbmcobmV3IE1hcCk7ZnVuY3Rpb24gaXNNYXAocil7aWYodHlwZW9mIE1hcD09PVwidW5kZWZpbmVkXCIpe3JldHVybiBmYWxzZX1yZXR1cm4gaXNNYXBUb1N0cmluZy53b3JraW5nP2lzTWFwVG9TdHJpbmcocik6ciBpbnN0YW5jZW9mIE1hcH1lLmlzTWFwPWlzTWFwO2Z1bmN0aW9uIGlzU2V0VG9TdHJpbmcocil7cmV0dXJuIHAocik9PT1cIltvYmplY3QgU2V0XVwifWlzU2V0VG9TdHJpbmcud29ya2luZz10eXBlb2YgU2V0IT09XCJ1bmRlZmluZWRcIiYmaXNTZXRUb1N0cmluZyhuZXcgU2V0KTtmdW5jdGlvbiBpc1NldChyKXtpZih0eXBlb2YgU2V0PT09XCJ1bmRlZmluZWRcIil7cmV0dXJuIGZhbHNlfXJldHVybiBpc1NldFRvU3RyaW5nLndvcmtpbmc/aXNTZXRUb1N0cmluZyhyKTpyIGluc3RhbmNlb2YgU2V0fWUuaXNTZXQ9aXNTZXQ7ZnVuY3Rpb24gaXNXZWFrTWFwVG9TdHJpbmcocil7cmV0dXJuIHAocik9PT1cIltvYmplY3QgV2Vha01hcF1cIn1pc1dlYWtNYXBUb1N0cmluZy53b3JraW5nPXR5cGVvZiBXZWFrTWFwIT09XCJ1bmRlZmluZWRcIiYmaXNXZWFrTWFwVG9TdHJpbmcobmV3IFdlYWtNYXApO2Z1bmN0aW9uIGlzV2Vha01hcChyKXtpZih0eXBlb2YgV2Vha01hcD09PVwidW5kZWZpbmVkXCIpe3JldHVybiBmYWxzZX1yZXR1cm4gaXNXZWFrTWFwVG9TdHJpbmcud29ya2luZz9pc1dlYWtNYXBUb1N0cmluZyhyKTpyIGluc3RhbmNlb2YgV2Vha01hcH1lLmlzV2Vha01hcD1pc1dlYWtNYXA7ZnVuY3Rpb24gaXNXZWFrU2V0VG9TdHJpbmcocil7cmV0dXJuIHAocik9PT1cIltvYmplY3QgV2Vha1NldF1cIn1pc1dlYWtTZXRUb1N0cmluZy53b3JraW5nPXR5cGVvZiBXZWFrU2V0IT09XCJ1bmRlZmluZWRcIiYmaXNXZWFrU2V0VG9TdHJpbmcobmV3IFdlYWtTZXQpO2Z1bmN0aW9uIGlzV2Vha1NldChyKXtyZXR1cm4gaXNXZWFrU2V0VG9TdHJpbmcocil9ZS5pc1dlYWtTZXQ9aXNXZWFrU2V0O2Z1bmN0aW9uIGlzQXJyYXlCdWZmZXJUb1N0cmluZyhyKXtyZXR1cm4gcChyKT09PVwiW29iamVjdCBBcnJheUJ1ZmZlcl1cIn1pc0FycmF5QnVmZmVyVG9TdHJpbmcud29ya2luZz10eXBlb2YgQXJyYXlCdWZmZXIhPT1cInVuZGVmaW5lZFwiJiZpc0FycmF5QnVmZmVyVG9TdHJpbmcobmV3IEFycmF5QnVmZmVyKTtmdW5jdGlvbiBpc0FycmF5QnVmZmVyKHIpe2lmKHR5cGVvZiBBcnJheUJ1ZmZlcj09PVwidW5kZWZpbmVkXCIpe3JldHVybiBmYWxzZX1yZXR1cm4gaXNBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmc/aXNBcnJheUJ1ZmZlclRvU3RyaW5nKHIpOnIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcn1lLmlzQXJyYXlCdWZmZXI9aXNBcnJheUJ1ZmZlcjtmdW5jdGlvbiBpc0RhdGFWaWV3VG9TdHJpbmcocil7cmV0dXJuIHAocik9PT1cIltvYmplY3QgRGF0YVZpZXddXCJ9aXNEYXRhVmlld1RvU3RyaW5nLndvcmtpbmc9dHlwZW9mIEFycmF5QnVmZmVyIT09XCJ1bmRlZmluZWRcIiYmdHlwZW9mIERhdGFWaWV3IT09XCJ1bmRlZmluZWRcIiYmaXNEYXRhVmlld1RvU3RyaW5nKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSksMCwxKSk7ZnVuY3Rpb24gaXNEYXRhVmlldyhyKXtpZih0eXBlb2YgRGF0YVZpZXc9PT1cInVuZGVmaW5lZFwiKXtyZXR1cm4gZmFsc2V9cmV0dXJuIGlzRGF0YVZpZXdUb1N0cmluZy53b3JraW5nP2lzRGF0YVZpZXdUb1N0cmluZyhyKTpyIGluc3RhbmNlb2YgRGF0YVZpZXd9ZS5pc0RhdGFWaWV3PWlzRGF0YVZpZXc7dmFyIGc9dHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyIT09XCJ1bmRlZmluZWRcIj9TaGFyZWRBcnJheUJ1ZmZlcjp1bmRlZmluZWQ7ZnVuY3Rpb24gaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nKHIpe3JldHVybiBwKHIpPT09XCJbb2JqZWN0IFNoYXJlZEFycmF5QnVmZmVyXVwifWZ1bmN0aW9uIGlzU2hhcmVkQXJyYXlCdWZmZXIocil7aWYodHlwZW9mIGc9PT1cInVuZGVmaW5lZFwiKXtyZXR1cm4gZmFsc2V9aWYodHlwZW9mIGlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZy53b3JraW5nPT09XCJ1bmRlZmluZWRcIil7aXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmc9aXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nKG5ldyBnKX1yZXR1cm4gaXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nLndvcmtpbmc/aXNTaGFyZWRBcnJheUJ1ZmZlclRvU3RyaW5nKHIpOnIgaW5zdGFuY2VvZiBnfWUuaXNTaGFyZWRBcnJheUJ1ZmZlcj1pc1NoYXJlZEFycmF5QnVmZmVyO2Z1bmN0aW9uIGlzQXN5bmNGdW5jdGlvbihyKXtyZXR1cm4gcChyKT09PVwiW29iamVjdCBBc3luY0Z1bmN0aW9uXVwifWUuaXNBc3luY0Z1bmN0aW9uPWlzQXN5bmNGdW5jdGlvbjtmdW5jdGlvbiBpc01hcEl0ZXJhdG9yKHIpe3JldHVybiBwKHIpPT09XCJbb2JqZWN0IE1hcCBJdGVyYXRvcl1cIn1lLmlzTWFwSXRlcmF0b3I9aXNNYXBJdGVyYXRvcjtmdW5jdGlvbiBpc1NldEl0ZXJhdG9yKHIpe3JldHVybiBwKHIpPT09XCJbb2JqZWN0IFNldCBJdGVyYXRvcl1cIn1lLmlzU2V0SXRlcmF0b3I9aXNTZXRJdGVyYXRvcjtmdW5jdGlvbiBpc0dlbmVyYXRvck9iamVjdChyKXtyZXR1cm4gcChyKT09PVwiW29iamVjdCBHZW5lcmF0b3JdXCJ9ZS5pc0dlbmVyYXRvck9iamVjdD1pc0dlbmVyYXRvck9iamVjdDtmdW5jdGlvbiBpc1dlYkFzc2VtYmx5Q29tcGlsZWRNb2R1bGUocil7cmV0dXJuIHAocik9PT1cIltvYmplY3QgV2ViQXNzZW1ibHkuTW9kdWxlXVwifWUuaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlPWlzV2ViQXNzZW1ibHlDb21waWxlZE1vZHVsZTtmdW5jdGlvbiBpc051bWJlck9iamVjdChyKXtyZXR1cm4gY2hlY2tCb3hlZFByaW1pdGl2ZShyLHUpfWUuaXNOdW1iZXJPYmplY3Q9aXNOdW1iZXJPYmplY3Q7ZnVuY3Rpb24gaXNTdHJpbmdPYmplY3Qocil7cmV0dXJuIGNoZWNrQm94ZWRQcmltaXRpdmUocixzKX1lLmlzU3RyaW5nT2JqZWN0PWlzU3RyaW5nT2JqZWN0O2Z1bmN0aW9uIGlzQm9vbGVhbk9iamVjdChyKXtyZXR1cm4gY2hlY2tCb3hlZFByaW1pdGl2ZShyLGMpfWUuaXNCb29sZWFuT2JqZWN0PWlzQm9vbGVhbk9iamVjdDtmdW5jdGlvbiBpc0JpZ0ludE9iamVjdChyKXtyZXR1cm4geSYmY2hlY2tCb3hlZFByaW1pdGl2ZShyLGwpfWUuaXNCaWdJbnRPYmplY3Q9aXNCaWdJbnRPYmplY3Q7ZnVuY3Rpb24gaXNTeW1ib2xPYmplY3Qocil7cmV0dXJuIGYmJmNoZWNrQm94ZWRQcmltaXRpdmUocixkKX1lLmlzU3ltYm9sT2JqZWN0PWlzU3ltYm9sT2JqZWN0O2Z1bmN0aW9uIGlzQm94ZWRQcmltaXRpdmUocil7cmV0dXJuIGlzTnVtYmVyT2JqZWN0KHIpfHxpc1N0cmluZ09iamVjdChyKXx8aXNCb29sZWFuT2JqZWN0KHIpfHxpc0JpZ0ludE9iamVjdChyKXx8aXNTeW1ib2xPYmplY3Qocil9ZS5pc0JveGVkUHJpbWl0aXZlPWlzQm94ZWRQcmltaXRpdmU7ZnVuY3Rpb24gaXNBbnlBcnJheUJ1ZmZlcihyKXtyZXR1cm4gdHlwZW9mIFVpbnQ4QXJyYXkhPT1cInVuZGVmaW5lZFwiJiYoaXNBcnJheUJ1ZmZlcihyKXx8aXNTaGFyZWRBcnJheUJ1ZmZlcihyKSl9ZS5pc0FueUFycmF5QnVmZmVyPWlzQW55QXJyYXlCdWZmZXI7W1wiaXNQcm94eVwiLFwiaXNFeHRlcm5hbFwiLFwiaXNNb2R1bGVOYW1lc3BhY2VPYmplY3RcIl0uZm9yRWFjaCgoZnVuY3Rpb24ocil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUscix7ZW51bWVyYWJsZTpmYWxzZSx2YWx1ZTpmdW5jdGlvbigpe3Rocm93IG5ldyBFcnJvcihyK1wiIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdXNlcmxhbmRcIil9fSl9KSl9LDE3NzpmdW5jdGlvbihyLGUsdCl7dmFyIG89T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnN8fGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMocil7dmFyIGU9T2JqZWN0LmtleXMocik7dmFyIHQ9e307Zm9yKHZhciBvPTA7bzxlLmxlbmd0aDtvKyspe3RbZVtvXV09T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihyLGVbb10pfXJldHVybiB0fTt2YXIgbj0vJVtzZGolXS9nO2UuZm9ybWF0PWZ1bmN0aW9uKHIpe2lmKCFpc1N0cmluZyhyKSl7dmFyIGU9W107Zm9yKHZhciB0PTA7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyl7ZS5wdXNoKGluc3BlY3QoYXJndW1lbnRzW3RdKSl9cmV0dXJuIGUuam9pbihcIiBcIil9dmFyIHQ9MTt2YXIgbz1hcmd1bWVudHM7dmFyIGk9by5sZW5ndGg7dmFyIGE9U3RyaW5nKHIpLnJlcGxhY2UobiwoZnVuY3Rpb24ocil7aWYocj09PVwiJSVcIilyZXR1cm5cIiVcIjtpZih0Pj1pKXJldHVybiByO3N3aXRjaChyKXtjYXNlXCIlc1wiOnJldHVybiBTdHJpbmcob1t0KytdKTtjYXNlXCIlZFwiOnJldHVybiBOdW1iZXIob1t0KytdKTtjYXNlXCIlalwiOnRyeXtyZXR1cm4gSlNPTi5zdHJpbmdpZnkob1t0KytdKX1jYXRjaChyKXtyZXR1cm5cIltDaXJjdWxhcl1cIn1kZWZhdWx0OnJldHVybiByfX0pKTtmb3IodmFyIHk9b1t0XTt0PGk7eT1vWysrdF0pe2lmKGlzTnVsbCh5KXx8IWlzT2JqZWN0KHkpKXthKz1cIiBcIit5fWVsc2V7YSs9XCIgXCIraW5zcGVjdCh5KX19cmV0dXJuIGF9O2UuZGVwcmVjYXRlPWZ1bmN0aW9uKHIsdCl7aWYodHlwZW9mIHByb2Nlc3MhPT1cInVuZGVmaW5lZFwiJiZwcm9jZXNzLm5vRGVwcmVjYXRpb249PT10cnVlKXtyZXR1cm4gcn1pZih0eXBlb2YgcHJvY2Vzcz09PVwidW5kZWZpbmVkXCIpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiBlLmRlcHJlY2F0ZShyLHQpLmFwcGx5KHRoaXMsYXJndW1lbnRzKX19dmFyIG89ZmFsc2U7ZnVuY3Rpb24gZGVwcmVjYXRlZCgpe2lmKCFvKXtpZihwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pe3Rocm93IG5ldyBFcnJvcih0KX1lbHNlIGlmKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbil7Y29uc29sZS50cmFjZSh0KX1lbHNle2NvbnNvbGUuZXJyb3IodCl9bz10cnVlfXJldHVybiByLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1yZXR1cm4gZGVwcmVjYXRlZH07dmFyIGk9e307dmFyIGE9L14kLztpZihwcm9jZXNzLmVudi5OT0RFX0RFQlVHKXt2YXIgeT1wcm9jZXNzLmVudi5OT0RFX0RFQlVHO3k9eS5yZXBsYWNlKC9bfFxcXFx7fSgpW1xcXV4kKz8uXS9nLFwiXFxcXCQmXCIpLnJlcGxhY2UoL1xcKi9nLFwiLipcIikucmVwbGFjZSgvLC9nLFwiJHxeXCIpLnRvVXBwZXJDYXNlKCk7YT1uZXcgUmVnRXhwKFwiXlwiK3krXCIkXCIsXCJpXCIpfWUuZGVidWdsb2c9ZnVuY3Rpb24ocil7cj1yLnRvVXBwZXJDYXNlKCk7aWYoIWlbcl0pe2lmKGEudGVzdChyKSl7dmFyIHQ9cHJvY2Vzcy5waWQ7aVtyXT1mdW5jdGlvbigpe3ZhciBvPWUuZm9ybWF0LmFwcGx5KGUsYXJndW1lbnRzKTtjb25zb2xlLmVycm9yKFwiJXMgJWQ6ICVzXCIscix0LG8pfX1lbHNle2lbcl09ZnVuY3Rpb24oKXt9fX1yZXR1cm4gaVtyXX07ZnVuY3Rpb24gaW5zcGVjdChyLHQpe3ZhciBvPXtzZWVuOltdLHN0eWxpemU6c3R5bGl6ZU5vQ29sb3J9O2lmKGFyZ3VtZW50cy5sZW5ndGg+PTMpby5kZXB0aD1hcmd1bWVudHNbMl07aWYoYXJndW1lbnRzLmxlbmd0aD49NClvLmNvbG9ycz1hcmd1bWVudHNbM107aWYoaXNCb29sZWFuKHQpKXtvLnNob3dIaWRkZW49dH1lbHNlIGlmKHQpe2UuX2V4dGVuZChvLHQpfWlmKGlzVW5kZWZpbmVkKG8uc2hvd0hpZGRlbikpby5zaG93SGlkZGVuPWZhbHNlO2lmKGlzVW5kZWZpbmVkKG8uZGVwdGgpKW8uZGVwdGg9MjtpZihpc1VuZGVmaW5lZChvLmNvbG9ycykpby5jb2xvcnM9ZmFsc2U7aWYoaXNVbmRlZmluZWQoby5jdXN0b21JbnNwZWN0KSlvLmN1c3RvbUluc3BlY3Q9dHJ1ZTtpZihvLmNvbG9ycylvLnN0eWxpemU9c3R5bGl6ZVdpdGhDb2xvcjtyZXR1cm4gZm9ybWF0VmFsdWUobyxyLG8uZGVwdGgpfWUuaW5zcGVjdD1pbnNwZWN0O2luc3BlY3QuY29sb3JzPXtib2xkOlsxLDIyXSxpdGFsaWM6WzMsMjNdLHVuZGVybGluZTpbNCwyNF0saW52ZXJzZTpbNywyN10sd2hpdGU6WzM3LDM5XSxncmV5Ols5MCwzOV0sYmxhY2s6WzMwLDM5XSxibHVlOlszNCwzOV0sY3lhbjpbMzYsMzldLGdyZWVuOlszMiwzOV0sbWFnZW50YTpbMzUsMzldLHJlZDpbMzEsMzldLHllbGxvdzpbMzMsMzldfTtpbnNwZWN0LnN0eWxlcz17c3BlY2lhbDpcImN5YW5cIixudW1iZXI6XCJ5ZWxsb3dcIixib29sZWFuOlwieWVsbG93XCIsdW5kZWZpbmVkOlwiZ3JleVwiLG51bGw6XCJib2xkXCIsc3RyaW5nOlwiZ3JlZW5cIixkYXRlOlwibWFnZW50YVwiLHJlZ2V4cDpcInJlZFwifTtmdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHIsZSl7dmFyIHQ9aW5zcGVjdC5zdHlsZXNbZV07aWYodCl7cmV0dXJuXCJcdTAwMWJbXCIraW5zcGVjdC5jb2xvcnNbdF1bMF0rXCJtXCIrcitcIlx1MDAxYltcIitpbnNwZWN0LmNvbG9yc1t0XVsxXStcIm1cIn1lbHNle3JldHVybiByfX1mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihyLGUpe3JldHVybiByfWZ1bmN0aW9uIGFycmF5VG9IYXNoKHIpe3ZhciBlPXt9O3IuZm9yRWFjaCgoZnVuY3Rpb24ocix0KXtlW3JdPXRydWV9KSk7cmV0dXJuIGV9ZnVuY3Rpb24gZm9ybWF0VmFsdWUocix0LG8pe2lmKHIuY3VzdG9tSW5zcGVjdCYmdCYmaXNGdW5jdGlvbih0Lmluc3BlY3QpJiZ0Lmluc3BlY3QhPT1lLmluc3BlY3QmJiEodC5jb25zdHJ1Y3RvciYmdC5jb25zdHJ1Y3Rvci5wcm90b3R5cGU9PT10KSl7dmFyIG49dC5pbnNwZWN0KG8scik7aWYoIWlzU3RyaW5nKG4pKXtuPWZvcm1hdFZhbHVlKHIsbixvKX1yZXR1cm4gbn12YXIgaT1mb3JtYXRQcmltaXRpdmUocix0KTtpZihpKXtyZXR1cm4gaX12YXIgYT1PYmplY3Qua2V5cyh0KTt2YXIgeT1hcnJheVRvSGFzaChhKTtpZihyLnNob3dIaWRkZW4pe2E9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModCl9aWYoaXNFcnJvcih0KSYmKGEuaW5kZXhPZihcIm1lc3NhZ2VcIik+PTB8fGEuaW5kZXhPZihcImRlc2NyaXB0aW9uXCIpPj0wKSl7cmV0dXJuIGZvcm1hdEVycm9yKHQpfWlmKGEubGVuZ3RoPT09MCl7aWYoaXNGdW5jdGlvbih0KSl7dmFyIGY9dC5uYW1lP1wiOiBcIit0Lm5hbWU6XCJcIjtyZXR1cm4gci5zdHlsaXplKFwiW0Z1bmN0aW9uXCIrZitcIl1cIixcInNwZWNpYWxcIil9aWYoaXNSZWdFeHAodCkpe3JldHVybiByLnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpLFwicmVnZXhwXCIpfWlmKGlzRGF0ZSh0KSl7cmV0dXJuIHIuc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHQpLFwiZGF0ZVwiKX1pZihpc0Vycm9yKHQpKXtyZXR1cm4gZm9ybWF0RXJyb3IodCl9fXZhciBwPVwiXCIsdT1mYWxzZSxzPVtcIntcIixcIn1cIl07aWYoaXNBcnJheSh0KSl7dT10cnVlO3M9W1wiW1wiLFwiXVwiXX1pZihpc0Z1bmN0aW9uKHQpKXt2YXIgYz10Lm5hbWU/XCI6IFwiK3QubmFtZTpcIlwiO3A9XCIgW0Z1bmN0aW9uXCIrYytcIl1cIn1pZihpc1JlZ0V4cCh0KSl7cD1cIiBcIitSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCl9aWYoaXNEYXRlKHQpKXtwPVwiIFwiK0RhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodCl9aWYoaXNFcnJvcih0KSl7cD1cIiBcIitmb3JtYXRFcnJvcih0KX1pZihhLmxlbmd0aD09PTAmJighdXx8dC5sZW5ndGg9PTApKXtyZXR1cm4gc1swXStwK3NbMV19aWYobzwwKXtpZihpc1JlZ0V4cCh0KSl7cmV0dXJuIHIuc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodCksXCJyZWdleHBcIil9ZWxzZXtyZXR1cm4gci5zdHlsaXplKFwiW09iamVjdF1cIixcInNwZWNpYWxcIil9fXIuc2Vlbi5wdXNoKHQpO3ZhciBsO2lmKHUpe2w9Zm9ybWF0QXJyYXkocix0LG8seSxhKX1lbHNle2w9YS5tYXAoKGZ1bmN0aW9uKGUpe3JldHVybiBmb3JtYXRQcm9wZXJ0eShyLHQsbyx5LGUsdSl9KSl9ci5zZWVuLnBvcCgpO3JldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhsLHAscyl9ZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKHIsZSl7aWYoaXNVbmRlZmluZWQoZSkpcmV0dXJuIHIuc3R5bGl6ZShcInVuZGVmaW5lZFwiLFwidW5kZWZpbmVkXCIpO2lmKGlzU3RyaW5nKGUpKXt2YXIgdD1cIidcIitKU09OLnN0cmluZ2lmeShlKS5yZXBsYWNlKC9eXCJ8XCIkL2csXCJcIikucmVwbGFjZSgvJy9nLFwiXFxcXCdcIikucmVwbGFjZSgvXFxcXFwiL2csJ1wiJykrXCInXCI7cmV0dXJuIHIuc3R5bGl6ZSh0LFwic3RyaW5nXCIpfWlmKGlzTnVtYmVyKGUpKXJldHVybiByLnN0eWxpemUoXCJcIitlLFwibnVtYmVyXCIpO2lmKGlzQm9vbGVhbihlKSlyZXR1cm4gci5zdHlsaXplKFwiXCIrZSxcImJvb2xlYW5cIik7aWYoaXNOdWxsKGUpKXJldHVybiByLnN0eWxpemUoXCJudWxsXCIsXCJudWxsXCIpfWZ1bmN0aW9uIGZvcm1hdEVycm9yKHIpe3JldHVyblwiW1wiK0Vycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHIpK1wiXVwifWZ1bmN0aW9uIGZvcm1hdEFycmF5KHIsZSx0LG8sbil7dmFyIGk9W107Zm9yKHZhciBhPTAseT1lLmxlbmd0aDthPHk7KythKXtpZihoYXNPd25Qcm9wZXJ0eShlLFN0cmluZyhhKSkpe2kucHVzaChmb3JtYXRQcm9wZXJ0eShyLGUsdCxvLFN0cmluZyhhKSx0cnVlKSl9ZWxzZXtpLnB1c2goXCJcIil9fW4uZm9yRWFjaCgoZnVuY3Rpb24obil7aWYoIW4ubWF0Y2goL15cXGQrJC8pKXtpLnB1c2goZm9ybWF0UHJvcGVydHkocixlLHQsbyxuLHRydWUpKX19KSk7cmV0dXJuIGl9ZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkocixlLHQsbyxuLGkpe3ZhciBhLHksZjtmPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSxuKXx8e3ZhbHVlOmVbbl19O2lmKGYuZ2V0KXtpZihmLnNldCl7eT1yLnN0eWxpemUoXCJbR2V0dGVyL1NldHRlcl1cIixcInNwZWNpYWxcIil9ZWxzZXt5PXIuc3R5bGl6ZShcIltHZXR0ZXJdXCIsXCJzcGVjaWFsXCIpfX1lbHNle2lmKGYuc2V0KXt5PXIuc3R5bGl6ZShcIltTZXR0ZXJdXCIsXCJzcGVjaWFsXCIpfX1pZighaGFzT3duUHJvcGVydHkobyxuKSl7YT1cIltcIituK1wiXVwifWlmKCF5KXtpZihyLnNlZW4uaW5kZXhPZihmLnZhbHVlKTwwKXtpZihpc051bGwodCkpe3k9Zm9ybWF0VmFsdWUocixmLnZhbHVlLG51bGwpfWVsc2V7eT1mb3JtYXRWYWx1ZShyLGYudmFsdWUsdC0xKX1pZih5LmluZGV4T2YoXCJcXG5cIik+LTEpe2lmKGkpe3k9eS5zcGxpdChcIlxcblwiKS5tYXAoKGZ1bmN0aW9uKHIpe3JldHVyblwiICBcIityfSkpLmpvaW4oXCJcXG5cIikuc3Vic3RyKDIpfWVsc2V7eT1cIlxcblwiK3kuc3BsaXQoXCJcXG5cIikubWFwKChmdW5jdGlvbihyKXtyZXR1cm5cIiAgIFwiK3J9KSkuam9pbihcIlxcblwiKX19fWVsc2V7eT1yLnN0eWxpemUoXCJbQ2lyY3VsYXJdXCIsXCJzcGVjaWFsXCIpfX1pZihpc1VuZGVmaW5lZChhKSl7aWYoaSYmbi5tYXRjaCgvXlxcZCskLykpe3JldHVybiB5fWE9SlNPTi5zdHJpbmdpZnkoXCJcIituKTtpZihhLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSl7YT1hLnN1YnN0cigxLGEubGVuZ3RoLTIpO2E9ci5zdHlsaXplKGEsXCJuYW1lXCIpfWVsc2V7YT1hLnJlcGxhY2UoLycvZyxcIlxcXFwnXCIpLnJlcGxhY2UoL1xcXFxcIi9nLCdcIicpLnJlcGxhY2UoLyheXCJ8XCIkKS9nLFwiJ1wiKTthPXIuc3R5bGl6ZShhLFwic3RyaW5nXCIpfX1yZXR1cm4gYStcIjogXCIreX1mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhyLGUsdCl7dmFyIG89MDt2YXIgbj1yLnJlZHVjZSgoZnVuY3Rpb24ocixlKXtvKys7aWYoZS5pbmRleE9mKFwiXFxuXCIpPj0wKW8rKztyZXR1cm4gcitlLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLFwiXCIpLmxlbmd0aCsxfSksMCk7aWYobj42MCl7cmV0dXJuIHRbMF0rKGU9PT1cIlwiP1wiXCI6ZStcIlxcbiBcIikrXCIgXCIrci5qb2luKFwiLFxcbiAgXCIpK1wiIFwiK3RbMV19cmV0dXJuIHRbMF0rZStcIiBcIityLmpvaW4oXCIsIFwiKStcIiBcIit0WzFdfWUudHlwZXM9dCg1ODQpO2Z1bmN0aW9uIGlzQXJyYXkocil7cmV0dXJuIEFycmF5LmlzQXJyYXkocil9ZS5pc0FycmF5PWlzQXJyYXk7ZnVuY3Rpb24gaXNCb29sZWFuKHIpe3JldHVybiB0eXBlb2Ygcj09PVwiYm9vbGVhblwifWUuaXNCb29sZWFuPWlzQm9vbGVhbjtmdW5jdGlvbiBpc051bGwocil7cmV0dXJuIHI9PT1udWxsfWUuaXNOdWxsPWlzTnVsbDtmdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChyKXtyZXR1cm4gcj09bnVsbH1lLmlzTnVsbE9yVW5kZWZpbmVkPWlzTnVsbE9yVW5kZWZpbmVkO2Z1bmN0aW9uIGlzTnVtYmVyKHIpe3JldHVybiB0eXBlb2Ygcj09PVwibnVtYmVyXCJ9ZS5pc051bWJlcj1pc051bWJlcjtmdW5jdGlvbiBpc1N0cmluZyhyKXtyZXR1cm4gdHlwZW9mIHI9PT1cInN0cmluZ1wifWUuaXNTdHJpbmc9aXNTdHJpbmc7ZnVuY3Rpb24gaXNTeW1ib2wocil7cmV0dXJuIHR5cGVvZiByPT09XCJzeW1ib2xcIn1lLmlzU3ltYm9sPWlzU3ltYm9sO2Z1bmN0aW9uIGlzVW5kZWZpbmVkKHIpe3JldHVybiByPT09dm9pZCAwfWUuaXNVbmRlZmluZWQ9aXNVbmRlZmluZWQ7ZnVuY3Rpb24gaXNSZWdFeHAocil7cmV0dXJuIGlzT2JqZWN0KHIpJiZvYmplY3RUb1N0cmluZyhyKT09PVwiW29iamVjdCBSZWdFeHBdXCJ9ZS5pc1JlZ0V4cD1pc1JlZ0V4cDtlLnR5cGVzLmlzUmVnRXhwPWlzUmVnRXhwO2Z1bmN0aW9uIGlzT2JqZWN0KHIpe3JldHVybiB0eXBlb2Ygcj09PVwib2JqZWN0XCImJnIhPT1udWxsfWUuaXNPYmplY3Q9aXNPYmplY3Q7ZnVuY3Rpb24gaXNEYXRlKHIpe3JldHVybiBpc09iamVjdChyKSYmb2JqZWN0VG9TdHJpbmcocik9PT1cIltvYmplY3QgRGF0ZV1cIn1lLmlzRGF0ZT1pc0RhdGU7ZS50eXBlcy5pc0RhdGU9aXNEYXRlO2Z1bmN0aW9uIGlzRXJyb3Iocil7cmV0dXJuIGlzT2JqZWN0KHIpJiYob2JqZWN0VG9TdHJpbmcocik9PT1cIltvYmplY3QgRXJyb3JdXCJ8fHIgaW5zdGFuY2VvZiBFcnJvcil9ZS5pc0Vycm9yPWlzRXJyb3I7ZS50eXBlcy5pc05hdGl2ZUVycm9yPWlzRXJyb3I7ZnVuY3Rpb24gaXNGdW5jdGlvbihyKXtyZXR1cm4gdHlwZW9mIHI9PT1cImZ1bmN0aW9uXCJ9ZS5pc0Z1bmN0aW9uPWlzRnVuY3Rpb247ZnVuY3Rpb24gaXNQcmltaXRpdmUocil7cmV0dXJuIHI9PT1udWxsfHx0eXBlb2Ygcj09PVwiYm9vbGVhblwifHx0eXBlb2Ygcj09PVwibnVtYmVyXCJ8fHR5cGVvZiByPT09XCJzdHJpbmdcInx8dHlwZW9mIHI9PT1cInN5bWJvbFwifHx0eXBlb2Ygcj09PVwidW5kZWZpbmVkXCJ9ZS5pc1ByaW1pdGl2ZT1pc1ByaW1pdGl2ZTtlLmlzQnVmZmVyPXQoMzY5KTtmdW5jdGlvbiBvYmplY3RUb1N0cmluZyhyKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHIpfWZ1bmN0aW9uIHBhZChyKXtyZXR1cm4gcjwxMD9cIjBcIityLnRvU3RyaW5nKDEwKTpyLnRvU3RyaW5nKDEwKX12YXIgZj1bXCJKYW5cIixcIkZlYlwiLFwiTWFyXCIsXCJBcHJcIixcIk1heVwiLFwiSnVuXCIsXCJKdWxcIixcIkF1Z1wiLFwiU2VwXCIsXCJPY3RcIixcIk5vdlwiLFwiRGVjXCJdO2Z1bmN0aW9uIHRpbWVzdGFtcCgpe3ZhciByPW5ldyBEYXRlO3ZhciBlPVtwYWQoci5nZXRIb3VycygpKSxwYWQoci5nZXRNaW51dGVzKCkpLHBhZChyLmdldFNlY29uZHMoKSldLmpvaW4oXCI6XCIpO3JldHVybltyLmdldERhdGUoKSxmW3IuZ2V0TW9udGgoKV0sZV0uam9pbihcIiBcIil9ZS5sb2c9ZnVuY3Rpb24oKXtjb25zb2xlLmxvZyhcIiVzIC0gJXNcIix0aW1lc3RhbXAoKSxlLmZvcm1hdC5hcHBseShlLGFyZ3VtZW50cykpfTtlLmluaGVyaXRzPXQoNzgyKTtlLl9leHRlbmQ9ZnVuY3Rpb24ocixlKXtpZighZXx8IWlzT2JqZWN0KGUpKXJldHVybiByO3ZhciB0PU9iamVjdC5rZXlzKGUpO3ZhciBvPXQubGVuZ3RoO3doaWxlKG8tLSl7clt0W29dXT1lW3Rbb11dfXJldHVybiByfTtmdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShyLGUpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocixlKX12YXIgcD10eXBlb2YgU3ltYm9sIT09XCJ1bmRlZmluZWRcIj9TeW1ib2woXCJ1dGlsLnByb21pc2lmeS5jdXN0b21cIik6dW5kZWZpbmVkO2UucHJvbWlzaWZ5PWZ1bmN0aW9uIHByb21pc2lmeShyKXtpZih0eXBlb2YgciE9PVwiZnVuY3Rpb25cIil0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcmlnaW5hbFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO2lmKHAmJnJbcF0pe3ZhciBlPXJbcF07aWYodHlwZW9mIGUhPT1cImZ1bmN0aW9uXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInV0aWwucHJvbWlzaWZ5LmN1c3RvbVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHAse3ZhbHVlOmUsZW51bWVyYWJsZTpmYWxzZSx3cml0YWJsZTpmYWxzZSxjb25maWd1cmFibGU6dHJ1ZX0pO3JldHVybiBlfWZ1bmN0aW9uIGUoKXt2YXIgZSx0O3ZhciBvPW5ldyBQcm9taXNlKChmdW5jdGlvbihyLG8pe2U9cjt0PW99KSk7dmFyIG49W107Zm9yKHZhciBpPTA7aTxhcmd1bWVudHMubGVuZ3RoO2krKyl7bi5wdXNoKGFyZ3VtZW50c1tpXSl9bi5wdXNoKChmdW5jdGlvbihyLG8pe2lmKHIpe3Qocil9ZWxzZXtlKG8pfX0pKTt0cnl7ci5hcHBseSh0aGlzLG4pfWNhdGNoKHIpe3Qocil9cmV0dXJuIG99T2JqZWN0LnNldFByb3RvdHlwZU9mKGUsT2JqZWN0LmdldFByb3RvdHlwZU9mKHIpKTtpZihwKU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHAse3ZhbHVlOmUsZW51bWVyYWJsZTpmYWxzZSx3cml0YWJsZTpmYWxzZSxjb25maWd1cmFibGU6dHJ1ZX0pO3JldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLG8ocikpfTtlLnByb21pc2lmeS5jdXN0b209cDtmdW5jdGlvbiBjYWxsYmFja2lmeU9uUmVqZWN0ZWQocixlKXtpZighcil7dmFyIHQ9bmV3IEVycm9yKFwiUHJvbWlzZSB3YXMgcmVqZWN0ZWQgd2l0aCBhIGZhbHN5IHZhbHVlXCIpO3QucmVhc29uPXI7cj10fXJldHVybiBlKHIpfWZ1bmN0aW9uIGNhbGxiYWNraWZ5KHIpe2lmKHR5cGVvZiByIT09XCJmdW5jdGlvblwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcmlnaW5hbFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpfWZ1bmN0aW9uIGNhbGxiYWNraWZpZWQoKXt2YXIgZT1bXTtmb3IodmFyIHQ9MDt0PGFyZ3VtZW50cy5sZW5ndGg7dCsrKXtlLnB1c2goYXJndW1lbnRzW3RdKX12YXIgbz1lLnBvcCgpO2lmKHR5cGVvZiBvIT09XCJmdW5jdGlvblwiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIGxhc3QgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uXCIpfXZhciBuPXRoaXM7dmFyIGNiPWZ1bmN0aW9uKCl7cmV0dXJuIG8uYXBwbHkobixhcmd1bWVudHMpfTtyLmFwcGx5KHRoaXMsZSkudGhlbigoZnVuY3Rpb24ocil7cHJvY2Vzcy5uZXh0VGljayhjYi5iaW5kKG51bGwsbnVsbCxyKSl9KSwoZnVuY3Rpb24ocil7cHJvY2Vzcy5uZXh0VGljayhjYWxsYmFja2lmeU9uUmVqZWN0ZWQuYmluZChudWxsLHIsY2IpKX0pKX1PYmplY3Quc2V0UHJvdG90eXBlT2YoY2FsbGJhY2tpZmllZCxPYmplY3QuZ2V0UHJvdG90eXBlT2YocikpO09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNhbGxiYWNraWZpZWQsbyhyKSk7cmV0dXJuIGNhbGxiYWNraWZpZWR9ZS5jYWxsYmFja2lmeT1jYWxsYmFja2lmeX0sNDkwOmZ1bmN0aW9uKHIsZSx0KXtcInVzZSBzdHJpY3RcIjt2YXIgbz10KDE0NCk7dmFyIG49dCgzNDkpO3ZhciBpPXQoMjU2KTt2YXIgYT1pKFwiT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1wiKTt2YXIgeT10KDk0MikoKTt2YXIgZj15JiZ0eXBlb2YgU3ltYm9sLnRvU3RyaW5nVGFnPT09XCJzeW1ib2xcIjt2YXIgcD1uKCk7dmFyIHU9aShcIlN0cmluZy5wcm90b3R5cGUuc2xpY2VcIik7dmFyIHM9e307dmFyIGM9dCgyNCk7dmFyIGw9T2JqZWN0LmdldFByb3RvdHlwZU9mO2lmKGYmJmMmJmwpe28ocCwoZnVuY3Rpb24ocil7aWYodHlwZW9mIGdsb2JhbFtyXT09PVwiZnVuY3Rpb25cIil7dmFyIGU9bmV3IGdsb2JhbFtyXTtpZighKFN5bWJvbC50b1N0cmluZ1RhZyBpbiBlKSl7dGhyb3cgbmV3IEV2YWxFcnJvcihcInRoaXMgZW5naW5lIGhhcyBzdXBwb3J0IGZvciBTeW1ib2wudG9TdHJpbmdUYWcsIGJ1dCBcIityK1wiIGRvZXMgbm90IGhhdmUgdGhlIHByb3BlcnR5ISBQbGVhc2UgcmVwb3J0IHRoaXMuXCIpfXZhciB0PWwoZSk7dmFyIG89Yyh0LFN5bWJvbC50b1N0cmluZ1RhZyk7aWYoIW8pe3ZhciBuPWwodCk7bz1jKG4sU3ltYm9sLnRvU3RyaW5nVGFnKX1zW3JdPW8uZ2V0fX0pKX12YXIgZD1mdW5jdGlvbiB0cnlBbGxUeXBlZEFycmF5cyhyKXt2YXIgZT1mYWxzZTtvKHMsKGZ1bmN0aW9uKHQsbyl7aWYoIWUpe3RyeXt2YXIgbj10LmNhbGwocik7aWYobj09PW8pe2U9bn19Y2F0Y2gocil7fX19KSk7cmV0dXJuIGV9O3ZhciBnPXQoOTk0KTtyLmV4cG9ydHM9ZnVuY3Rpb24gd2hpY2hUeXBlZEFycmF5KHIpe2lmKCFnKHIpKXtyZXR1cm4gZmFsc2V9aWYoIWYpe3JldHVybiB1KGEociksOCwtMSl9cmV0dXJuIGQocil9fSwzNDk6ZnVuY3Rpb24ocixlLHQpe1widXNlIHN0cmljdFwiO3ZhciBvPXQoOTkyKTtyLmV4cG9ydHM9ZnVuY3Rpb24gYXZhaWxhYmxlVHlwZWRBcnJheXMoKXtyZXR1cm4gbyhbXCJCaWdJbnQ2NEFycmF5XCIsXCJCaWdVaW50NjRBcnJheVwiLFwiRmxvYXQzMkFycmF5XCIsXCJGbG9hdDY0QXJyYXlcIixcIkludDE2QXJyYXlcIixcIkludDMyQXJyYXlcIixcIkludDhBcnJheVwiLFwiVWludDE2QXJyYXlcIixcIlVpbnQzMkFycmF5XCIsXCJVaW50OEFycmF5XCIsXCJVaW50OENsYW1wZWRBcnJheVwiXSwoZnVuY3Rpb24ocil7cmV0dXJuIHR5cGVvZiBnbG9iYWxbcl09PT1cImZ1bmN0aW9uXCJ9KSl9fSwyNDpmdW5jdGlvbihyLGUsdCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIG89dCg1MDApO3ZhciBuPW8oXCIlT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciVcIix0cnVlKTtpZihuKXt0cnl7bihbXSxcImxlbmd0aFwiKX1jYXRjaChyKXtuPW51bGx9fXIuZXhwb3J0cz1ufX07dmFyIGU9e307ZnVuY3Rpb24gX19uY2N3cGNrX3JlcXVpcmVfXyh0KXt2YXIgbz1lW3RdO2lmKG8hPT11bmRlZmluZWQpe3JldHVybiBvLmV4cG9ydHN9dmFyIG49ZVt0XT17ZXhwb3J0czp7fX07dmFyIGk9dHJ1ZTt0cnl7clt0XShuLG4uZXhwb3J0cyxfX25jY3dwY2tfcmVxdWlyZV9fKTtpPWZhbHNlfWZpbmFsbHl7aWYoaSlkZWxldGUgZVt0XX1yZXR1cm4gbi5leHBvcnRzfWlmKHR5cGVvZiBfX25jY3dwY2tfcmVxdWlyZV9fIT09XCJ1bmRlZmluZWRcIilfX25jY3dwY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjt2YXIgdD1fX25jY3dwY2tfcmVxdWlyZV9fKDE3Nyk7bW9kdWxlLmV4cG9ydHM9dH0pKCk7Il0sIm5hbWVzIjpbInIiLCJleHBvcnRzIiwidCIsIm8iLCJmaWx0ZXIiLCJUeXBlRXJyb3IiLCJuIiwiaSIsImxlbmd0aCIsImUiLCJjYWxsIiwiYSIsInB1c2giLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGxCb3VuZEludHJpbnNpYyIsInkiLCJmIiwicCIsInUiLCJ2YWx1ZSIsImNhbGxCaW5kIiwiYXJndW1lbnRzIiwiY29uZmlndXJhYmxlIiwicyIsImFwcGx5QmluZCIsImFwcGx5IiwidG9TdHJpbmciLCJmb3JFYWNoIiwiQXJyYXkiLCJzbGljZSIsImJpbmQiLCJiaW5kZXIiLCJjb25jYXQiLCJNYXRoIiwibWF4IiwiRnVuY3Rpb24iLCJqb2luIiwiRW1wdHkiLCJTeW50YXhFcnJvciIsImdldEV2YWxsZWRDb25zdHJ1Y3RvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsInRocm93VHlwZUVycm9yIiwiY2FsbGVlIiwiZ2V0IiwiZ2V0UHJvdG90eXBlT2YiLCJfX3Byb3RvX18iLCJjIiwiVWludDhBcnJheSIsImwiLCJBZ2dyZWdhdGVFcnJvciIsIkFycmF5QnVmZmVyIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJBdG9taWNzIiwiQmlnSW50IiwiQm9vbGVhbiIsIkRhdGFWaWV3IiwiRGF0ZSIsImRlY29kZVVSSSIsImRlY29kZVVSSUNvbXBvbmVudCIsImVuY29kZVVSSSIsImVuY29kZVVSSUNvbXBvbmVudCIsIkVycm9yIiwiZXZhbCIsIkV2YWxFcnJvciIsIkZsb2F0MzJBcnJheSIsIkZsb2F0NjRBcnJheSIsIkZpbmFsaXphdGlvblJlZ2lzdHJ5IiwiSW50OEFycmF5IiwiSW50MTZBcnJheSIsIkludDMyQXJyYXkiLCJpc0Zpbml0ZSIsImlzTmFOIiwiSlNPTiIsIk1hcCIsIk51bWJlciIsInBhcnNlRmxvYXQiLCJwYXJzZUludCIsIlByb21pc2UiLCJQcm94eSIsIlJhbmdlRXJyb3IiLCJSZWZlcmVuY2VFcnJvciIsIlJlZmxlY3QiLCJSZWdFeHAiLCJTZXQiLCJTaGFyZWRBcnJheUJ1ZmZlciIsIlN0cmluZyIsIlVpbnQ4Q2xhbXBlZEFycmF5IiwiVWludDE2QXJyYXkiLCJVaW50MzJBcnJheSIsIlVSSUVycm9yIiwiV2Vha01hcCIsIldlYWtSZWYiLCJXZWFrU2V0IiwiZCIsImRvRXZhbCIsImciLCJ2IiwiYiIsIkEiLCJtIiwic3BsaWNlIiwiUyIsInJlcGxhY2UiLCJoIiwiUCIsImV4ZWMiLCJPIiwidyIsImoiLCJzdHJpbmdUb1BhdGgiLCJFIiwiZ2V0QmFzZUludHJpbnNpYyIsImFsaWFzIiwibmFtZSIsIkdldEludHJpbnNpYyIsIkJpZ0ludDY0QXJyYXkiLCJCaWdVaW50NjRBcnJheSIsImVycm9yIiwiSSIsIkIiLCJmb28iLCJoYXNQcm90byIsImhhc05hdGl2ZVN5bWJvbHMiLCJoYXNTeW1ib2xzIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwia2V5cyIsImdldE93blByb3BlcnR5TmFtZXMiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsImVudW1lcmFibGUiLCJjcmVhdGUiLCJpbmhlcml0cyIsInN1cGVyXyIsImNvbnN0cnVjdG9yIiwid3JpdGFibGUiLCJUZW1wQ3RvciIsInRvU3RyaW5nVGFnIiwiaXNBcmd1bWVudHMiLCJpc0xlZ2FjeUFyZ3VtZW50cyIsImdldEdlbmVyYXRvckZ1bmMiLCJpc0dlbmVyYXRvckZ1bmN0aW9uIiwidGVzdCIsImluZGV4T2YiLCJnbG9iYWwiLCJ0cnlBbGxUeXBlZEFycmF5cyIsImlzVHlwZWRBcnJheSIsImlzQnVmZmVyIiwiQnVmZmVyIiwidW5jdXJyeVRoaXMiLCJ2YWx1ZU9mIiwiY2hlY2tCb3hlZFByaW1pdGl2ZSIsImlzQXJndW1lbnRzT2JqZWN0IiwiaXNQcm9taXNlIiwidGhlbiIsImNhdGNoIiwiaXNBcnJheUJ1ZmZlclZpZXciLCJpc1ZpZXciLCJpc0RhdGFWaWV3IiwiaXNVaW50OEFycmF5IiwiaXNVaW50OENsYW1wZWRBcnJheSIsImlzVWludDE2QXJyYXkiLCJpc1VpbnQzMkFycmF5IiwiaXNJbnQ4QXJyYXkiLCJpc0ludDE2QXJyYXkiLCJpc0ludDMyQXJyYXkiLCJpc0Zsb2F0MzJBcnJheSIsImlzRmxvYXQ2NEFycmF5IiwiaXNCaWdJbnQ2NEFycmF5IiwiaXNCaWdVaW50NjRBcnJheSIsImlzTWFwVG9TdHJpbmciLCJ3b3JraW5nIiwiaXNNYXAiLCJpc1NldFRvU3RyaW5nIiwiaXNTZXQiLCJpc1dlYWtNYXBUb1N0cmluZyIsImlzV2Vha01hcCIsImlzV2Vha1NldFRvU3RyaW5nIiwiaXNXZWFrU2V0IiwiaXNBcnJheUJ1ZmZlclRvU3RyaW5nIiwiaXNBcnJheUJ1ZmZlciIsImlzRGF0YVZpZXdUb1N0cmluZyIsInVuZGVmaW5lZCIsImlzU2hhcmVkQXJyYXlCdWZmZXJUb1N0cmluZyIsImlzU2hhcmVkQXJyYXlCdWZmZXIiLCJpc0FzeW5jRnVuY3Rpb24iLCJpc01hcEl0ZXJhdG9yIiwiaXNTZXRJdGVyYXRvciIsImlzR2VuZXJhdG9yT2JqZWN0IiwiaXNXZWJBc3NlbWJseUNvbXBpbGVkTW9kdWxlIiwiaXNOdW1iZXJPYmplY3QiLCJpc1N0cmluZ09iamVjdCIsImlzQm9vbGVhbk9iamVjdCIsImlzQmlnSW50T2JqZWN0IiwiaXNTeW1ib2xPYmplY3QiLCJpc0JveGVkUHJpbWl0aXZlIiwiaXNBbnlBcnJheUJ1ZmZlciIsImRlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImZvcm1hdCIsImlzU3RyaW5nIiwiaW5zcGVjdCIsInN0cmluZ2lmeSIsImlzTnVsbCIsImlzT2JqZWN0IiwiZGVwcmVjYXRlIiwicHJvY2VzcyIsIm5vRGVwcmVjYXRpb24iLCJkZXByZWNhdGVkIiwidGhyb3dEZXByZWNhdGlvbiIsInRyYWNlRGVwcmVjYXRpb24iLCJjb25zb2xlIiwidHJhY2UiLCJlbnYiLCJOT0RFX0RFQlVHIiwidG9VcHBlckNhc2UiLCJkZWJ1Z2xvZyIsInBpZCIsInNlZW4iLCJzdHlsaXplIiwic3R5bGl6ZU5vQ29sb3IiLCJkZXB0aCIsImNvbG9ycyIsImlzQm9vbGVhbiIsInNob3dIaWRkZW4iLCJfZXh0ZW5kIiwiaXNVbmRlZmluZWQiLCJjdXN0b21JbnNwZWN0Iiwic3R5bGl6ZVdpdGhDb2xvciIsImZvcm1hdFZhbHVlIiwiYm9sZCIsIml0YWxpYyIsInVuZGVybGluZSIsImludmVyc2UiLCJ3aGl0ZSIsImdyZXkiLCJibGFjayIsImJsdWUiLCJjeWFuIiwiZ3JlZW4iLCJtYWdlbnRhIiwicmVkIiwieWVsbG93Iiwic3R5bGVzIiwic3BlY2lhbCIsIm51bWJlciIsImJvb2xlYW4iLCJudWxsIiwic3RyaW5nIiwiZGF0ZSIsInJlZ2V4cCIsImFycmF5VG9IYXNoIiwiaXNGdW5jdGlvbiIsImZvcm1hdFByaW1pdGl2ZSIsImlzRXJyb3IiLCJmb3JtYXRFcnJvciIsImlzUmVnRXhwIiwiaXNEYXRlIiwiaXNBcnJheSIsInRvVVRDU3RyaW5nIiwiZm9ybWF0QXJyYXkiLCJtYXAiLCJmb3JtYXRQcm9wZXJ0eSIsInBvcCIsInJlZHVjZVRvU2luZ2xlU3RyaW5nIiwiaXNOdW1iZXIiLCJtYXRjaCIsInNldCIsInNwbGl0Iiwic3Vic3RyIiwicmVkdWNlIiwidHlwZXMiLCJpc051bGxPclVuZGVmaW5lZCIsImlzU3ltYm9sIiwib2JqZWN0VG9TdHJpbmciLCJpc05hdGl2ZUVycm9yIiwiaXNQcmltaXRpdmUiLCJwYWQiLCJ0aW1lc3RhbXAiLCJnZXRIb3VycyIsImdldE1pbnV0ZXMiLCJnZXRTZWNvbmRzIiwiZ2V0RGF0ZSIsImdldE1vbnRoIiwibG9nIiwicHJvbWlzaWZ5Iiwic2V0UHJvdG90eXBlT2YiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiY3VzdG9tIiwiY2FsbGJhY2tpZnlPblJlamVjdGVkIiwicmVhc29uIiwiY2FsbGJhY2tpZnkiLCJjYWxsYmFja2lmaWVkIiwiY2IiLCJuZXh0VGljayIsIndoaWNoVHlwZWRBcnJheSIsImF2YWlsYWJsZVR5cGVkQXJyYXlzIiwiX19uY2N3cGNrX3JlcXVpcmVfXyIsImFiIiwiX19kaXJuYW1lIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/util/util.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/page.tsx":
/*!**********************!*\
  !*** ./app/page.tsx ***!
  \**********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/image */ \"(app-pages-browser)/./node_modules/next/dist/api/image.js\");\n/* harmony import */ var _imgly_background_removal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @imgly/background-removal */ \"(app-pages-browser)/./node_modules/@imgly/background-removal/dist/index.mjs\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\nconst Page = ()=>{\n    _s();\n    const [selectedImage, setSelectedImage] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [isImageSetupDone, setIsImageSetupDone] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [removedBgImageUrl, setRemovedBgImageUrl] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [textSets, setTextSets] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const fileInputRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const canvasRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const handleUploadImage = ()=>{\n        if (fileInputRef.current) {\n            fileInputRef.current.click();\n        }\n    };\n    const handleFileChange = async (event)=>{\n        var _event_target_files;\n        const file = (_event_target_files = event.target.files) === null || _event_target_files === void 0 ? void 0 : _event_target_files[0];\n        if (file) {\n            const imageUrl = URL.createObjectURL(file);\n            console.log(\"Selected image:\", imageUrl);\n            setSelectedImage(imageUrl);\n            await setupImage(imageUrl);\n        }\n    };\n    const setupImage = async (imageUrl)=>{\n        try {\n            const imageBlob = await (0,_imgly_background_removal__WEBPACK_IMPORTED_MODULE_3__.removeBackground)(imageUrl);\n            console.log(\"Removed bg image:\", imageBlob);\n            const url = URL.createObjectURL(imageBlob);\n            console.log(\"Removed bg image url:\", url);\n            setRemovedBgImageUrl(url);\n            setIsImageSetupDone(true);\n        } catch (error) {\n            console.error(error);\n        }\n    };\n    const addNewTextSet = ()=>{\n        const newId = Math.max(...textSets.map((set)=>set.id), 0) + 1;\n        setTextSets((prev)=>[\n                ...prev,\n                {\n                    id: newId,\n                    text: \"edit\",\n                    fontFamily: \"Inter\",\n                    top: 0,\n                    left: 0,\n                    color: \"white\",\n                    fontSize: 200,\n                    fontWeight: 800,\n                    opacity: 1,\n                    shadowColor: \"rgba(0, 0, 0, 0.8)\",\n                    shadowSize: 4,\n                    rotation: 0,\n                    tiltX: 0,\n                    tiltY: 0\n                }\n            ]);\n    };\n    const handleAttributeChange = (id, attribute, value)=>{\n        setTextSets((prev)=>prev.map((set)=>set.id === id ? {\n                    ...set,\n                    [attribute]: value\n                } : set));\n    };\n    const removeTextSet = (id)=>{\n        setTextSets((prev)=>prev.filter((set)=>set.id !== id));\n    };\n    const saveCompositeImage = ()=>{\n        if (!canvasRef.current || !isImageSetupDone) return;\n        const canvas = canvasRef.current;\n        const ctx = canvas.getContext(\"2d\");\n        if (!ctx) return;\n        const bgImg = new window.Image();\n        bgImg.crossOrigin = \"anonymous\";\n        bgImg.onload = ()=>{\n            canvas.width = bgImg.width;\n            canvas.height = bgImg.height;\n            ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height);\n            textSets.forEach((textSet)=>{\n                ctx.save();\n                ctx.font = \"\".concat(textSet.fontWeight, \" \").concat(textSet.fontSize * 3, \"px \").concat(textSet.fontFamily);\n                ctx.fillStyle = textSet.color;\n                ctx.globalAlpha = textSet.opacity;\n                ctx.textAlign = \"center\";\n                ctx.textBaseline = \"middle\";\n                const x = canvas.width * (textSet.left + 50) / 100;\n                const y = canvas.height * (50 - textSet.top) / 100;\n                ctx.translate(x, y);\n                const tiltXRad = -textSet.tiltX * Math.PI / 180;\n                const tiltYRad = -textSet.tiltY * Math.PI / 180;\n                ctx.transform(Math.cos(tiltYRad), Math.sin(0), -Math.sin(0), Math.cos(tiltXRad), 0, 0);\n                ctx.rotate(textSet.rotation * Math.PI / 180);\n                ctx.fillText(textSet.text, 0, 0);\n                ctx.restore();\n            });\n            if (removedBgImageUrl) {\n                const removedBgImg = new window.Image();\n                removedBgImg.crossOrigin = \"anonymous\";\n                removedBgImg.onload = ()=>{\n                    ctx.drawImage(removedBgImg, 0, 0, canvas.width, canvas.height);\n                    triggerDownload();\n                };\n                removedBgImg.src = removedBgImageUrl;\n            } else {\n                triggerDownload();\n            }\n        };\n        bgImg.src = selectedImage || \"\";\n        function triggerDownload() {\n            const dataUrl = canvas.toDataURL(\"image/png\");\n            const link = document.createElement(\"a\");\n            link.download = \"text-behind-image.png\";\n            link.href = dataUrl;\n            link.click();\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"flex flex-col h-screen\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"header\", {\n                className: \"flex flex-row items-center justify-between p-5 px-10\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                        className: \"text-4xl md:text-2xl font-semibold tracking-tight\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"block md:hidden\",\n                                children: \"TBI\"\n                            }, void 0, false, {\n                                fileName: \"/Users/amityadav/Desktop/Text-Behind Image/app/page.tsx\",\n                                lineNumber: 148,\n                                columnNumber: 21\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                className: \"hidden md:block\",\n                                children: \"Text behind image editor\"\n                            }, void 0, false, {\n                                fileName: \"/Users/amityadav/Desktop/Text-Behind Image/app/page.tsx\",\n                                lineNumber: 149,\n                                columnNumber: 21\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/amityadav/Desktop/Text-Behind Image/app/page.tsx\",\n                        lineNumber: 147,\n                        columnNumber: 17\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flex gap-4 items-center\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                type: \"file\",\n                                ref: fileInputRef,\n                                style: {\n                                    display: \"none\"\n                                },\n                                onChange: handleFileChange,\n                                accept: \".jpg, .jpeg, .png\"\n                            }, void 0, false, {\n                                fileName: \"/Users/amityadav/Desktop/Text-Behind Image/app/page.tsx\",\n                                lineNumber: 152,\n                                columnNumber: 21\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: handleUploadImage,\n                                className: \"px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600\",\n                                children: \"Upload image\"\n                            }, void 0, false, {\n                                fileName: \"/Users/amityadav/Desktop/Text-Behind Image/app/page.tsx\",\n                                lineNumber: 159,\n                                columnNumber: 21\n                            }, undefined),\n                            selectedImage && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: saveCompositeImage,\n                                className: \"px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600\",\n                                children: \"Save image\"\n                            }, void 0, false, {\n                                fileName: \"/Users/amityadav/Desktop/Text-Behind Image/app/page.tsx\",\n                                lineNumber: 166,\n                                columnNumber: 25\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/amityadav/Desktop/Text-Behind Image/app/page.tsx\",\n                        lineNumber: 151,\n                        columnNumber: 17\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/amityadav/Desktop/Text-Behind Image/app/page.tsx\",\n                lineNumber: 146,\n                columnNumber: 13\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"h-px bg-gray-200 w-full\"\n            }, void 0, false, {\n                fileName: \"/Users/amityadav/Desktop/Text-Behind Image/app/page.tsx\",\n                lineNumber: 175,\n                columnNumber: 13\n            }, undefined),\n            selectedImage ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex flex-col md:flex-row items-start justify-start gap-10 w-full h-screen px-10 mt-2\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flex flex-col items-start justify-start w-full md:w-1/2 gap-4\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"canvas\", {\n                                ref: canvasRef,\n                                style: {\n                                    display: \"none\"\n                                }\n                            }, void 0, false, {\n                                fileName: \"/Users/amityadav/Desktop/Text-Behind Image/app/page.tsx\",\n                                lineNumber: 179,\n                                columnNumber: 25\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"min-h-[400px] w-[80%] p-4 border border-gray-200 rounded-lg relative overflow-hidden\",\n                                children: [\n                                    isImageSetupDone ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_image__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                                        src: selectedImage,\n                                        alt: \"Uploaded\",\n                                        layout: \"fill\",\n                                        objectFit: \"contain\",\n                                        objectPosition: \"center\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/amityadav/Desktop/Text-Behind Image/app/page.tsx\",\n                                        lineNumber: 182,\n                                        columnNumber: 33\n                                    }, undefined) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        className: \"flex items-center w-full gap-2\",\n                                        children: \"Loading, please wait...\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/amityadav/Desktop/Text-Behind Image/app/page.tsx\",\n                                        lineNumber: 190,\n                                        columnNumber: 33\n                                    }, undefined),\n                                    isImageSetupDone && textSets.map((textSet)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                            style: {\n                                                position: \"absolute\",\n                                                top: \"\".concat(50 - textSet.top, \"%\"),\n                                                left: \"\".concat(textSet.left + 50, \"%\"),\n                                                transform: \"\\n                                            translate(-50%, -50%) \\n                                            rotate(\".concat(textSet.rotation, \"deg)\\n                                            perspective(1000px)\\n                                            rotateX(\").concat(textSet.tiltX, \"deg)\\n                                            rotateY(\").concat(textSet.tiltY, \"deg)\\n                                        \"),\n                                                color: textSet.color,\n                                                textAlign: \"center\",\n                                                fontSize: \"\".concat(textSet.fontSize, \"px\"),\n                                                fontWeight: textSet.fontWeight,\n                                                fontFamily: textSet.fontFamily,\n                                                opacity: textSet.opacity,\n                                                transformStyle: \"preserve-3d\"\n                                            },\n                                            children: textSet.text\n                                        }, textSet.id, false, {\n                                            fileName: \"/Users/amityadav/Desktop/Text-Behind Image/app/page.tsx\",\n                                            lineNumber: 193,\n                                            columnNumber: 33\n                                        }, undefined)),\n                                    removedBgImageUrl && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_image__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                                        src: removedBgImageUrl,\n                                        alt: \"Removed bg\",\n                                        layout: \"fill\",\n                                        objectFit: \"contain\",\n                                        objectPosition: \"center\",\n                                        className: \"absolute top-0 left-0 w-full h-full\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/amityadav/Desktop/Text-Behind Image/app/page.tsx\",\n                                        lineNumber: 219,\n                                        columnNumber: 33\n                                    }, undefined)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/amityadav/Desktop/Text-Behind Image/app/page.tsx\",\n                                lineNumber: 180,\n                                columnNumber: 25\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/amityadav/Desktop/Text-Behind Image/app/page.tsx\",\n                        lineNumber: 178,\n                        columnNumber: 21\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"flex flex-col w-full md:w-1/2\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: addNewTextSet,\n                                className: \"px-4 py-2 bg-purple-500 text-white rounded hover:bg-purple-600 flex items-center gap-2\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        children: \"+\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/amityadav/Desktop/Text-Behind Image/app/page.tsx\",\n                                        lineNumber: 235,\n                                        columnNumber: 29\n                                    }, undefined),\n                                    \" Add New Text Set\"\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/amityadav/Desktop/Text-Behind Image/app/page.tsx\",\n                                lineNumber: 231,\n                                columnNumber: 25\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"mt-4\",\n                                children: textSets.map((textSet)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"mb-4 p-4 border border-gray-200 rounded\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"flex justify-between mb-2\",\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                                        type: \"text\",\n                                                        value: textSet.text,\n                                                        onChange: (e)=>handleAttributeChange(textSet.id, \"text\", e.target.value),\n                                                        className: \"border p-1 rounded\"\n                                                    }, void 0, false, {\n                                                        fileName: \"/Users/amityadav/Desktop/Text-Behind Image/app/page.tsx\",\n                                                        lineNumber: 241,\n                                                        columnNumber: 41\n                                                    }, undefined),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                        onClick: ()=>removeTextSet(textSet.id),\n                                                        className: \"px-2 py-1 bg-red-500 text-white rounded hover:bg-red-600\",\n                                                        children: \"Remove\"\n                                                    }, void 0, false, {\n                                                        fileName: \"/Users/amityadav/Desktop/Text-Behind Image/app/page.tsx\",\n                                                        lineNumber: 247,\n                                                        columnNumber: 41\n                                                    }, undefined)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/Users/amityadav/Desktop/Text-Behind Image/app/page.tsx\",\n                                                lineNumber: 240,\n                                                columnNumber: 37\n                                            }, undefined),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \"grid grid-cols-2 gap-2\",\n                                                children: [\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                        children: [\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                                                className: \"block text-sm\",\n                                                                children: \"Font Size\"\n                                                            }, void 0, false, {\n                                                                fileName: \"/Users/amityadav/Desktop/Text-Behind Image/app/page.tsx\",\n                                                                lineNumber: 256,\n                                                                columnNumber: 45\n                                                            }, undefined),\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                                                type: \"range\",\n                                                                min: \"10\",\n                                                                max: \"400\",\n                                                                value: textSet.fontSize,\n                                                                onChange: (e)=>handleAttributeChange(textSet.id, \"fontSize\", parseInt(e.target.value)),\n                                                                className: \"w-full\"\n                                                            }, void 0, false, {\n                                                                fileName: \"/Users/amityadav/Desktop/Text-Behind Image/app/page.tsx\",\n                                                                lineNumber: 257,\n                                                                columnNumber: 45\n                                                            }, undefined)\n                                                        ]\n                                                    }, void 0, true, {\n                                                        fileName: \"/Users/amityadav/Desktop/Text-Behind Image/app/page.tsx\",\n                                                        lineNumber: 255,\n                                                        columnNumber: 41\n                                                    }, undefined),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                        children: [\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                                                className: \"block text-sm\",\n                                                                children: \"Color\"\n                                                            }, void 0, false, {\n                                                                fileName: \"/Users/amityadav/Desktop/Text-Behind Image/app/page.tsx\",\n                                                                lineNumber: 267,\n                                                                columnNumber: 45\n                                                            }, undefined),\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                                                type: \"color\",\n                                                                value: textSet.color,\n                                                                onChange: (e)=>handleAttributeChange(textSet.id, \"color\", e.target.value),\n                                                                className: \"w-full\"\n                                                            }, void 0, false, {\n                                                                fileName: \"/Users/amityadav/Desktop/Text-Behind Image/app/page.tsx\",\n                                                                lineNumber: 268,\n                                                                columnNumber: 45\n                                                            }, undefined)\n                                                        ]\n                                                    }, void 0, true, {\n                                                        fileName: \"/Users/amityadav/Desktop/Text-Behind Image/app/page.tsx\",\n                                                        lineNumber: 266,\n                                                        columnNumber: 41\n                                                    }, undefined),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                        children: [\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                                                className: \"block text-sm\",\n                                                                children: \"Rotation\"\n                                                            }, void 0, false, {\n                                                                fileName: \"/Users/amityadav/Desktop/Text-Behind Image/app/page.tsx\",\n                                                                lineNumber: 276,\n                                                                columnNumber: 45\n                                                            }, undefined),\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                                                type: \"range\",\n                                                                min: \"-180\",\n                                                                max: \"180\",\n                                                                value: textSet.rotation,\n                                                                onChange: (e)=>handleAttributeChange(textSet.id, \"rotation\", parseInt(e.target.value)),\n                                                                className: \"w-full\"\n                                                            }, void 0, false, {\n                                                                fileName: \"/Users/amityadav/Desktop/Text-Behind Image/app/page.tsx\",\n                                                                lineNumber: 277,\n                                                                columnNumber: 45\n                                                            }, undefined)\n                                                        ]\n                                                    }, void 0, true, {\n                                                        fileName: \"/Users/amityadav/Desktop/Text-Behind Image/app/page.tsx\",\n                                                        lineNumber: 275,\n                                                        columnNumber: 41\n                                                    }, undefined),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                        children: [\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                                                className: \"block text-sm\",\n                                                                children: \"Opacity\"\n                                                            }, void 0, false, {\n                                                                fileName: \"/Users/amityadav/Desktop/Text-Behind Image/app/page.tsx\",\n                                                                lineNumber: 287,\n                                                                columnNumber: 45\n                                                            }, undefined),\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                                                type: \"range\",\n                                                                min: \"0\",\n                                                                max: \"1\",\n                                                                step: \"0.1\",\n                                                                value: textSet.opacity,\n                                                                onChange: (e)=>handleAttributeChange(textSet.id, \"opacity\", parseFloat(e.target.value)),\n                                                                className: \"w-full\"\n                                                            }, void 0, false, {\n                                                                fileName: \"/Users/amityadav/Desktop/Text-Behind Image/app/page.tsx\",\n                                                                lineNumber: 288,\n                                                                columnNumber: 45\n                                                            }, undefined)\n                                                        ]\n                                                    }, void 0, true, {\n                                                        fileName: \"/Users/amityadav/Desktop/Text-Behind Image/app/page.tsx\",\n                                                        lineNumber: 286,\n                                                        columnNumber: 41\n                                                    }, undefined),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                        children: [\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                                                className: \"block text-sm\",\n                                                                children: \"Position X\"\n                                                            }, void 0, false, {\n                                                                fileName: \"/Users/amityadav/Desktop/Text-Behind Image/app/page.tsx\",\n                                                                lineNumber: 299,\n                                                                columnNumber: 45\n                                                            }, undefined),\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                                                type: \"range\",\n                                                                min: \"-50\",\n                                                                max: \"50\",\n                                                                value: textSet.left,\n                                                                onChange: (e)=>handleAttributeChange(textSet.id, \"left\", parseInt(e.target.value)),\n                                                                className: \"w-full\"\n                                                            }, void 0, false, {\n                                                                fileName: \"/Users/amityadav/Desktop/Text-Behind Image/app/page.tsx\",\n                                                                lineNumber: 300,\n                                                                columnNumber: 45\n                                                            }, undefined)\n                                                        ]\n                                                    }, void 0, true, {\n                                                        fileName: \"/Users/amityadav/Desktop/Text-Behind Image/app/page.tsx\",\n                                                        lineNumber: 298,\n                                                        columnNumber: 41\n                                                    }, undefined),\n                                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                        children: [\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                                                className: \"block text-sm\",\n                                                                children: \"Position Y\"\n                                                            }, void 0, false, {\n                                                                fileName: \"/Users/amityadav/Desktop/Text-Behind Image/app/page.tsx\",\n                                                                lineNumber: 310,\n                                                                columnNumber: 45\n                                                            }, undefined),\n                                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                                                type: \"range\",\n                                                                min: \"-50\",\n                                                                max: \"50\",\n                                                                value: textSet.top,\n                                                                onChange: (e)=>handleAttributeChange(textSet.id, \"top\", parseInt(e.target.value)),\n                                                                className: \"w-full\"\n                                                            }, void 0, false, {\n                                                                fileName: \"/Users/amityadav/Desktop/Text-Behind Image/app/page.tsx\",\n                                                                lineNumber: 311,\n                                                                columnNumber: 45\n                                                            }, undefined)\n                                                        ]\n                                                    }, void 0, true, {\n                                                        fileName: \"/Users/amityadav/Desktop/Text-Behind Image/app/page.tsx\",\n                                                        lineNumber: 309,\n                                                        columnNumber: 41\n                                                    }, undefined)\n                                                ]\n                                            }, void 0, true, {\n                                                fileName: \"/Users/amityadav/Desktop/Text-Behind Image/app/page.tsx\",\n                                                lineNumber: 254,\n                                                columnNumber: 37\n                                            }, undefined)\n                                        ]\n                                    }, textSet.id, true, {\n                                        fileName: \"/Users/amityadav/Desktop/Text-Behind Image/app/page.tsx\",\n                                        lineNumber: 239,\n                                        columnNumber: 33\n                                    }, undefined))\n                            }, void 0, false, {\n                                fileName: \"/Users/amityadav/Desktop/Text-Behind Image/app/page.tsx\",\n                                lineNumber: 237,\n                                columnNumber: 25\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/amityadav/Desktop/Text-Behind Image/app/page.tsx\",\n                        lineNumber: 230,\n                        columnNumber: 21\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/amityadav/Desktop/Text-Behind Image/app/page.tsx\",\n                lineNumber: 177,\n                columnNumber: 17\n            }, undefined) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"flex items-center justify-center min-h-screen w-full\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                    className: \"text-xl font-semibold\",\n                    children: \"Welcome, get started by uploading an image!\"\n                }, void 0, false, {\n                    fileName: \"/Users/amityadav/Desktop/Text-Behind Image/app/page.tsx\",\n                    lineNumber: 328,\n                    columnNumber: 21\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/Users/amityadav/Desktop/Text-Behind Image/app/page.tsx\",\n                lineNumber: 327,\n                columnNumber: 17\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/amityadav/Desktop/Text-Behind Image/app/page.tsx\",\n        lineNumber: 145,\n        columnNumber: 9\n    }, undefined);\n};\n_s(Page, \"MgiVW0y+UAYQWNzJ+SH1Nf08zUY=\");\n_c = Page;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Page);\nvar _c;\n$RefreshReg$(_c, \"Page\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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R2xCLDhEQUFDRDs7MEVBQ0csOERBQUNxQjtnRUFBTXBCLFdBQVU7MEVBQWdCOzs7Ozs7MEVBQ2pDLDhEQUFDSTtnRUFDR0MsTUFBSztnRUFDTGdCLEtBQUk7Z0VBQ0p0RixLQUFJO2dFQUNKb0IsT0FBT2UsUUFBUTVCLEdBQUc7Z0VBQ2xCbUUsVUFBVSxDQUFDVSxJQUFNbEUsc0JBQXNCaUIsUUFBUWhDLEVBQUUsRUFBRSxPQUFPb0YsU0FBU0gsRUFBRWxHLE1BQU0sQ0FBQ2tDLEtBQUs7Z0VBQ2pGNkMsV0FBVTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt1Q0E5RWhCOUIsUUFBUWhDLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzswQ0F3RnBDLDhEQUFDNkQ7Z0JBQUlDLFdBQVU7MEJBQ1gsNEVBQUNFO29CQUFHRixXQUFVOzhCQUF3Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFLMUQ7R0F0VU1oRztLQUFBQTtBQXdVTiwrREFBZUEsSUFBSUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvcGFnZS50c3g/NzYwMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcblxuaW1wb3J0IFJlYWN0LCB7IHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgSW1hZ2UgZnJvbSAnbmV4dC9pbWFnZSc7XG5pbXBvcnQgeyByZW1vdmVCYWNrZ3JvdW5kIH0gZnJvbSBcIkBpbWdseS9iYWNrZ3JvdW5kLXJlbW92YWxcIjtcblxuY29uc3QgUGFnZSA9ICgpID0+IHtcbiAgICBjb25zdCBbc2VsZWN0ZWRJbWFnZSwgc2V0U2VsZWN0ZWRJbWFnZV0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgICBjb25zdCBbaXNJbWFnZVNldHVwRG9uZSwgc2V0SXNJbWFnZVNldHVwRG9uZV0gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XG4gICAgY29uc3QgW3JlbW92ZWRCZ0ltYWdlVXJsLCBzZXRSZW1vdmVkQmdJbWFnZVVybF0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgICBjb25zdCBbdGV4dFNldHMsIHNldFRleHRTZXRzXSA9IHVzZVN0YXRlPEFycmF5PGFueT4+KFtdKTtcbiAgICBjb25zdCBmaWxlSW5wdXRSZWYgPSB1c2VSZWY8SFRNTElucHV0RWxlbWVudD4obnVsbCk7XG4gICAgY29uc3QgY2FudmFzUmVmID0gdXNlUmVmPEhUTUxDYW52YXNFbGVtZW50PihudWxsKTtcblxuICAgIGNvbnN0IGhhbmRsZVVwbG9hZEltYWdlID0gKCkgPT4ge1xuICAgICAgICBpZiAoZmlsZUlucHV0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGZpbGVJbnB1dFJlZi5jdXJyZW50LmNsaWNrKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgaGFuZGxlRmlsZUNoYW5nZSA9IGFzeW5jIChldmVudDogUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHtcbiAgICAgICAgY29uc3QgZmlsZSA9IGV2ZW50LnRhcmdldC5maWxlcz8uWzBdO1xuICAgICAgICBpZiAoZmlsZSkge1xuICAgICAgICAgICAgY29uc3QgaW1hZ2VVcmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGZpbGUpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1NlbGVjdGVkIGltYWdlOicsIGltYWdlVXJsKTtcbiAgICAgICAgICAgIHNldFNlbGVjdGVkSW1hZ2UoaW1hZ2VVcmwpO1xuICAgICAgICAgICAgYXdhaXQgc2V0dXBJbWFnZShpbWFnZVVybCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3Qgc2V0dXBJbWFnZSA9IGFzeW5jIChpbWFnZVVybDogc3RyaW5nKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBpbWFnZUJsb2IgPSBhd2FpdCByZW1vdmVCYWNrZ3JvdW5kKGltYWdlVXJsKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdSZW1vdmVkIGJnIGltYWdlOicsIGltYWdlQmxvYik7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGltYWdlQmxvYik7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnUmVtb3ZlZCBiZyBpbWFnZSB1cmw6JywgdXJsKTtcbiAgICAgICAgICAgIHNldFJlbW92ZWRCZ0ltYWdlVXJsKHVybCk7XG4gICAgICAgICAgICBzZXRJc0ltYWdlU2V0dXBEb25lKHRydWUpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgYWRkTmV3VGV4dFNldCA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgbmV3SWQgPSBNYXRoLm1heCguLi50ZXh0U2V0cy5tYXAoc2V0ID0+IHNldC5pZCksIDApICsgMTtcbiAgICAgICAgc2V0VGV4dFNldHMocHJldiA9PiBbLi4ucHJldiwge1xuICAgICAgICAgICAgaWQ6IG5ld0lkLFxuICAgICAgICAgICAgdGV4dDogJ2VkaXQnLFxuICAgICAgICAgICAgZm9udEZhbWlseTogJ0ludGVyJyxcbiAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICBjb2xvcjogJ3doaXRlJyxcbiAgICAgICAgICAgIGZvbnRTaXplOiAyMDAsXG4gICAgICAgICAgICBmb250V2VpZ2h0OiA4MDAsXG4gICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgc2hhZG93Q29sb3I6ICdyZ2JhKDAsIDAsIDAsIDAuOCknLFxuICAgICAgICAgICAgc2hhZG93U2l6ZTogNCxcbiAgICAgICAgICAgIHJvdGF0aW9uOiAwLFxuICAgICAgICAgICAgdGlsdFg6IDAsXG4gICAgICAgICAgICB0aWx0WTogMFxuICAgICAgICB9XSk7XG4gICAgfTtcblxuICAgIGNvbnN0IGhhbmRsZUF0dHJpYnV0ZUNoYW5nZSA9IChpZDogbnVtYmVyLCBhdHRyaWJ1dGU6IHN0cmluZywgdmFsdWU6IGFueSkgPT4ge1xuICAgICAgICBzZXRUZXh0U2V0cyhwcmV2ID0+IHByZXYubWFwKHNldCA9PiBcbiAgICAgICAgICAgIHNldC5pZCA9PT0gaWQgPyB7IC4uLnNldCwgW2F0dHJpYnV0ZV06IHZhbHVlIH0gOiBzZXRcbiAgICAgICAgKSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHJlbW92ZVRleHRTZXQgPSAoaWQ6IG51bWJlcikgPT4ge1xuICAgICAgICBzZXRUZXh0U2V0cyhwcmV2ID0+IHByZXYuZmlsdGVyKHNldCA9PiBzZXQuaWQgIT09IGlkKSk7XG4gICAgfTtcblxuICAgIGNvbnN0IHNhdmVDb21wb3NpdGVJbWFnZSA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFjYW52YXNSZWYuY3VycmVudCB8fCAhaXNJbWFnZVNldHVwRG9uZSkgcmV0dXJuO1xuICAgIFxuICAgICAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudDtcbiAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGlmICghY3R4KSByZXR1cm47XG4gICAgXG4gICAgICAgIGNvbnN0IGJnSW1nID0gbmV3IHdpbmRvdy5JbWFnZSgpO1xuICAgICAgICBiZ0ltZy5jcm9zc09yaWdpbiA9IFwiYW5vbnltb3VzXCI7XG4gICAgICAgIGJnSW1nLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IGJnSW1nLndpZHRoO1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGJnSW1nLmhlaWdodDtcbiAgICBcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UoYmdJbWcsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgXG4gICAgICAgICAgICB0ZXh0U2V0cy5mb3JFYWNoKHRleHRTZXQgPT4ge1xuICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY3R4LmZvbnQgPSBgJHt0ZXh0U2V0LmZvbnRXZWlnaHR9ICR7dGV4dFNldC5mb250U2l6ZSAqIDN9cHggJHt0ZXh0U2V0LmZvbnRGYW1pbHl9YDtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGV4dFNldC5jb2xvcjtcbiAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSB0ZXh0U2V0Lm9wYWNpdHk7XG4gICAgICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICBcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gY2FudmFzLndpZHRoICogKHRleHRTZXQubGVmdCArIDUwKSAvIDEwMDtcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gY2FudmFzLmhlaWdodCAqICg1MCAtIHRleHRTZXQudG9wKSAvIDEwMDtcbiAgICBcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNvbnN0IHRpbHRYUmFkID0gKC10ZXh0U2V0LnRpbHRYICogTWF0aC5QSSkgLyAxODA7XG4gICAgICAgICAgICAgICAgY29uc3QgdGlsdFlSYWQgPSAoLXRleHRTZXQudGlsdFkgKiBNYXRoLlBJKSAvIDE4MDtcbiAgICBcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNmb3JtKFxuICAgICAgICAgICAgICAgICAgICBNYXRoLmNvcyh0aWx0WVJhZCksXG4gICAgICAgICAgICAgICAgICAgIE1hdGguc2luKDApLFxuICAgICAgICAgICAgICAgICAgICAtTWF0aC5zaW4oMCksXG4gICAgICAgICAgICAgICAgICAgIE1hdGguY29zKHRpbHRYUmFkKSxcbiAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgICk7XG4gICAgXG4gICAgICAgICAgICAgICAgY3R4LnJvdGF0ZSgodGV4dFNldC5yb3RhdGlvbiAqIE1hdGguUEkpIC8gMTgwKTtcbiAgICBcbiAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQodGV4dFNldC50ZXh0LCAwLCAwKTtcbiAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgXG4gICAgICAgICAgICBpZiAocmVtb3ZlZEJnSW1hZ2VVcmwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZW1vdmVkQmdJbWcgPSBuZXcgd2luZG93LkltYWdlKCk7XG4gICAgICAgICAgICAgICAgcmVtb3ZlZEJnSW1nLmNyb3NzT3JpZ2luID0gXCJhbm9ueW1vdXNcIjtcbiAgICAgICAgICAgICAgICByZW1vdmVkQmdJbWcub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKHJlbW92ZWRCZ0ltZywgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlckRvd25sb2FkKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZW1vdmVkQmdJbWcuc3JjID0gcmVtb3ZlZEJnSW1hZ2VVcmw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyaWdnZXJEb3dubG9hZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBiZ0ltZy5zcmMgPSBzZWxlY3RlZEltYWdlIHx8ICcnO1xuICAgIFxuICAgICAgICBmdW5jdGlvbiB0cmlnZ2VyRG93bmxvYWQoKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhVXJsID0gY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyk7XG4gICAgICAgICAgICBjb25zdCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICAgICAgbGluay5kb3dubG9hZCA9ICd0ZXh0LWJlaGluZC1pbWFnZS5wbmcnO1xuICAgICAgICAgICAgbGluay5ocmVmID0gZGF0YVVybDtcbiAgICAgICAgICAgIGxpbmsuY2xpY2soKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9J2ZsZXggZmxleC1jb2wgaC1zY3JlZW4nPlxuICAgICAgICAgICAgPGhlYWRlciBjbGFzc05hbWU9J2ZsZXggZmxleC1yb3cgaXRlbXMtY2VudGVyIGp1c3RpZnktYmV0d2VlbiBwLTUgcHgtMTAnPlxuICAgICAgICAgICAgICAgIDxoMiBjbGFzc05hbWU9XCJ0ZXh0LTR4bCBtZDp0ZXh0LTJ4bCBmb250LXNlbWlib2xkIHRyYWNraW5nLXRpZ2h0XCI+XG4gICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImJsb2NrIG1kOmhpZGRlblwiPlRCSTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiaGlkZGVuIG1kOmJsb2NrXCI+VGV4dCBiZWhpbmQgaW1hZ2UgZWRpdG9yPC9zcGFuPlxuICAgICAgICAgICAgICAgIDwvaDI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9J2ZsZXggZ2FwLTQgaXRlbXMtY2VudGVyJz5cbiAgICAgICAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwiZmlsZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICByZWY9e2ZpbGVJbnB1dFJlZn1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlPXt7IGRpc3BsYXk6ICdub25lJyB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9e2hhbmRsZUZpbGVDaGFuZ2V9XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2NlcHQ9XCIuanBnLCAuanBlZywgLnBuZ1wiXG4gICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVVcGxvYWRJbWFnZX1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInB4LTQgcHktMiBiZy1ibHVlLTUwMCB0ZXh0LXdoaXRlIHJvdW5kZWQgaG92ZXI6YmctYmx1ZS02MDBcIlxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICBVcGxvYWQgaW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIHtzZWxlY3RlZEltYWdlICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17c2F2ZUNvbXBvc2l0ZUltYWdlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInB4LTQgcHktMiBiZy1ncmVlbi01MDAgdGV4dC13aGl0ZSByb3VuZGVkIGhvdmVyOmJnLWdyZWVuLTYwMFwiXG4gICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU2F2ZSBpbWFnZVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2hlYWRlcj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaC1weCBiZy1ncmF5LTIwMCB3LWZ1bGxcIiAvPlxuICAgICAgICAgICAge3NlbGVjdGVkSW1hZ2UgPyAoXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9J2ZsZXggZmxleC1jb2wgbWQ6ZmxleC1yb3cgaXRlbXMtc3RhcnQganVzdGlmeS1zdGFydCBnYXAtMTAgdy1mdWxsIGgtc2NyZWVuIHB4LTEwIG10LTInPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggZmxleC1jb2wgaXRlbXMtc3RhcnQganVzdGlmeS1zdGFydCB3LWZ1bGwgbWQ6dy0xLzIgZ2FwLTRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxjYW52YXMgcmVmPXtjYW52YXNSZWZ9IHN0eWxlPXt7IGRpc3BsYXk6ICdub25lJyB9fSAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtaW4taC1bNDAwcHhdIHctWzgwJV0gcC00IGJvcmRlciBib3JkZXItZ3JheS0yMDAgcm91bmRlZC1sZyByZWxhdGl2ZSBvdmVyZmxvdy1oaWRkZW5cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7aXNJbWFnZVNldHVwRG9uZSA/IChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPEltYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmM9e3NlbGVjdGVkSW1hZ2V9IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWx0PVwiVXBsb2FkZWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0PVwiZmlsbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RGaXQ9XCJjb250YWluXCIgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RQb3NpdGlvbj1cImNlbnRlclwiIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkgOiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT0nZmxleCBpdGVtcy1jZW50ZXIgdy1mdWxsIGdhcC0yJz5Mb2FkaW5nLCBwbGVhc2Ugd2FpdC4uLjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtpc0ltYWdlU2V0dXBEb25lICYmIHRleHRTZXRzLm1hcCh0ZXh0U2V0ID0+IChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5PXt0ZXh0U2V0LmlkfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b3A6IGAkezUwIC0gdGV4dFNldC50b3B9JWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogYCR7dGV4dFNldC5sZWZ0ICsgNTB9JWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZSgtNTAlLCAtNTAlKSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm90YXRlKCR7dGV4dFNldC5yb3RhdGlvbn1kZWcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlcnNwZWN0aXZlKDEwMDBweClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm90YXRlWCgke3RleHRTZXQudGlsdFh9ZGVnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3RhdGVZKCR7dGV4dFNldC50aWx0WX1kZWcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogdGV4dFNldC5jb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiBgJHt0ZXh0U2V0LmZvbnRTaXplfXB4YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiB0ZXh0U2V0LmZvbnRXZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udEZhbWlseTogdGV4dFNldC5mb250RmFtaWx5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IHRleHRTZXQub3BhY2l0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1TdHlsZTogJ3ByZXNlcnZlLTNkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge3RleHRTZXQudGV4dH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3JlbW92ZWRCZ0ltYWdlVXJsICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPEltYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmM9e3JlbW92ZWRCZ0ltYWdlVXJsfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWx0PVwiUmVtb3ZlZCBiZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXQ9XCJmaWxsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdEZpdD1cImNvbnRhaW5cIiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdFBvc2l0aW9uPVwiY2VudGVyXCIgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJhYnNvbHV0ZSB0b3AtMCBsZWZ0LTAgdy1mdWxsIGgtZnVsbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSdmbGV4IGZsZXgtY29sIHctZnVsbCBtZDp3LTEvMic+XG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s9e2FkZE5ld1RleHRTZXR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwicHgtNCBweS0yIGJnLXB1cnBsZS01MDAgdGV4dC13aGl0ZSByb3VuZGVkIGhvdmVyOmJnLXB1cnBsZS02MDAgZmxleCBpdGVtcy1jZW50ZXIgZ2FwLTJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPis8L3NwYW4+IEFkZCBOZXcgVGV4dCBTZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtdC00XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3RleHRTZXRzLm1hcCh0ZXh0U2V0ID0+IChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBrZXk9e3RleHRTZXQuaWR9IGNsYXNzTmFtZT1cIm1iLTQgcC00IGJvcmRlciBib3JkZXItZ3JheS0yMDAgcm91bmRlZFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4IGp1c3RpZnktYmV0d2VlbiBtYi0yXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e3RleHRTZXQudGV4dH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiBoYW5kbGVBdHRyaWJ1dGVDaGFuZ2UodGV4dFNldC5pZCwgJ3RleHQnLCBlLnRhcmdldC52YWx1ZSl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImJvcmRlciBwLTEgcm91bmRlZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiByZW1vdmVUZXh0U2V0KHRleHRTZXQuaWQpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJweC0yIHB5LTEgYmctcmVkLTUwMCB0ZXh0LXdoaXRlIHJvdW5kZWQgaG92ZXI6YmctcmVkLTYwMFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZW1vdmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJncmlkIGdyaWQtY29scy0yIGdhcC0yXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzTmFtZT1cImJsb2NrIHRleHQtc21cIj5Gb250IFNpemU8L2xhYmVsPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJyYW5nZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW49XCIxMFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXg9XCI0MDBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e3RleHRTZXQuZm9udFNpemV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IGhhbmRsZUF0dHJpYnV0ZUNoYW5nZSh0ZXh0U2V0LmlkLCAnZm9udFNpemUnLCBwYXJzZUludChlLnRhcmdldC52YWx1ZSkpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidy1mdWxsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGFiZWwgY2xhc3NOYW1lPVwiYmxvY2sgdGV4dC1zbVwiPkNvbG9yPC9sYWJlbD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwiY29sb3JcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU9e3RleHRTZXQuY29sb3J9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IGhhbmRsZUF0dHJpYnV0ZUNoYW5nZSh0ZXh0U2V0LmlkLCAnY29sb3InLCBlLnRhcmdldC52YWx1ZSl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3LWZ1bGxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzc05hbWU9XCJibG9jayB0ZXh0LXNtXCI+Um90YXRpb248L2xhYmVsPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU9XCJyYW5nZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW49XCItMTgwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heD1cIjE4MFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17dGV4dFNldC5yb3RhdGlvbn1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT4gaGFuZGxlQXR0cmlidXRlQ2hhbmdlKHRleHRTZXQuaWQsICdyb3RhdGlvbicsIHBhcnNlSW50KGUudGFyZ2V0LnZhbHVlKSl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3LWZ1bGxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzc05hbWU9XCJibG9jayB0ZXh0LXNtXCI+T3BhY2l0eTwvbGFiZWw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cInJhbmdlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbj1cIjBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4PVwiMVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGVwPVwiMC4xXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXt0ZXh0U2V0Lm9wYWNpdHl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IGhhbmRsZUF0dHJpYnV0ZUNoYW5nZSh0ZXh0U2V0LmlkLCAnb3BhY2l0eScsIHBhcnNlRmxvYXQoZS50YXJnZXQudmFsdWUpKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInctZnVsbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGNsYXNzTmFtZT1cImJsb2NrIHRleHQtc21cIj5Qb3NpdGlvbiBYPC9sYWJlbD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwicmFuZ2VcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluPVwiLTUwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heD1cIjUwXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXt0ZXh0U2V0LmxlZnR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IGhhbmRsZUF0dHJpYnV0ZUNoYW5nZSh0ZXh0U2V0LmlkLCAnbGVmdCcsIHBhcnNlSW50KGUudGFyZ2V0LnZhbHVlKSl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ3LWZ1bGxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBjbGFzc05hbWU9XCJibG9jayB0ZXh0LXNtXCI+UG9zaXRpb24gWTwvbGFiZWw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cInJhbmdlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbj1cIi01MFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXg9XCI1MFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZT17dGV4dFNldC50b3B9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IGhhbmRsZUF0dHJpYnV0ZUNoYW5nZSh0ZXh0U2V0LmlkLCAndG9wJywgcGFyc2VJbnQoZS50YXJnZXQudmFsdWUpKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cInctZnVsbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKSl9XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICApIDogKFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPSdmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBtaW4taC1zY3JlZW4gdy1mdWxsJz5cbiAgICAgICAgICAgICAgICAgICAgPGgyIGNsYXNzTmFtZT1cInRleHQteGwgZm9udC1zZW1pYm9sZFwiPldlbGNvbWUsIGdldCBzdGFydGVkIGJ5IHVwbG9hZGluZyBhbiBpbWFnZSE8L2gyPlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKX1cbiAgICAgICAgPC9kaXY+XG4gICAgKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgUGFnZTsgIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJJbWFnZSIsInJlbW92ZUJhY2tncm91bmQiLCJQYWdlIiwic2VsZWN0ZWRJbWFnZSIsInNldFNlbGVjdGVkSW1hZ2UiLCJpc0ltYWdlU2V0dXBEb25lIiwic2V0SXNJbWFnZVNldHVwRG9uZSIsInJlbW92ZWRCZ0ltYWdlVXJsIiwic2V0UmVtb3ZlZEJnSW1hZ2VVcmwiLCJ0ZXh0U2V0cyIsInNldFRleHRTZXRzIiwiZmlsZUlucHV0UmVmIiwiY2FudmFzUmVmIiwiaGFuZGxlVXBsb2FkSW1hZ2UiLCJjdXJyZW50IiwiY2xpY2siLCJoYW5kbGVGaWxlQ2hhbmdlIiwiZXZlbnQiLCJmaWxlIiwidGFyZ2V0IiwiZmlsZXMiLCJpbWFnZVVybCIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsImNvbnNvbGUiLCJsb2ciLCJzZXR1cEltYWdlIiwiaW1hZ2VCbG9iIiwidXJsIiwiZXJyb3IiLCJhZGROZXdUZXh0U2V0IiwibmV3SWQiLCJNYXRoIiwibWF4IiwibWFwIiwic2V0IiwiaWQiLCJwcmV2IiwidGV4dCIsImZvbnRGYW1pbHkiLCJ0b3AiLCJsZWZ0IiwiY29sb3IiLCJmb250U2l6ZSIsImZvbnRXZWlnaHQiLCJvcGFjaXR5Iiwic2hhZG93Q29sb3IiLCJzaGFkb3dTaXplIiwicm90YXRpb24iLCJ0aWx0WCIsInRpbHRZIiwiaGFuZGxlQXR0cmlidXRlQ2hhbmdlIiwiYXR0cmlidXRlIiwidmFsdWUiLCJyZW1vdmVUZXh0U2V0IiwiZmlsdGVyIiwic2F2ZUNvbXBvc2l0ZUltYWdlIiwiY2FudmFzIiwiY3R4IiwiZ2V0Q29udGV4dCIsImJnSW1nIiwid2luZG93IiwiY3Jvc3NPcmlnaW4iLCJvbmxvYWQiLCJ3aWR0aCIsImhlaWdodCIsImRyYXdJbWFnZSIsImZvckVhY2giLCJ0ZXh0U2V0Iiwic2F2ZSIsImZvbnQiLCJmaWxsU3R5bGUiLCJnbG9iYWxBbHBoYSIsInRleHRBbGlnbiIsInRleHRCYXNlbGluZSIsIngiLCJ5IiwidHJhbnNsYXRlIiwidGlsdFhSYWQiLCJQSSIsInRpbHRZUmFkIiwidHJhbnNmb3JtIiwiY29zIiwic2luIiwicm90YXRlIiwiZmlsbFRleHQiLCJyZXN0b3JlIiwicmVtb3ZlZEJnSW1nIiwidHJpZ2dlckRvd25sb2FkIiwic3JjIiwiZGF0YVVybCIsInRvRGF0YVVSTCIsImxpbmsiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJkb3dubG9hZCIsImhyZWYiLCJkaXYiLCJjbGFzc05hbWUiLCJoZWFkZXIiLCJoMiIsInNwYW4iLCJpbnB1dCIsInR5cGUiLCJyZWYiLCJzdHlsZSIsImRpc3BsYXkiLCJvbkNoYW5nZSIsImFjY2VwdCIsImJ1dHRvbiIsIm9uQ2xpY2siLCJhbHQiLCJsYXlvdXQiLCJvYmplY3RGaXQiLCJvYmplY3RQb3NpdGlvbiIsInBvc2l0aW9uIiwidHJhbnNmb3JtU3R5bGUiLCJlIiwibGFiZWwiLCJtaW4iLCJwYXJzZUludCIsInN0ZXAiLCJwYXJzZUZsb2F0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/image-component.js":
/*!**********************************************************!*\
  !*** ./node_modules/next/dist/client/image-component.js ***!
  \**********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"Image\", ({\n    enumerable: true,\n    get: function() {\n        return Image;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _reactdom = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\"));\nconst _head = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../shared/lib/head */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/head.js\"));\nconst _getimgprops = __webpack_require__(/*! ../shared/lib/get-img-props */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/get-img-props.js\");\nconst _imageconfig = __webpack_require__(/*! ../shared/lib/image-config */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js\");\nconst _imageconfigcontextsharedruntime = __webpack_require__(/*! ../shared/lib/image-config-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js\");\nconst _warnonce = __webpack_require__(/*! ../shared/lib/utils/warn-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nconst _routercontextsharedruntime = __webpack_require__(/*! ../shared/lib/router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js\");\nconst _imageloader = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! next/dist/shared/lib/image-loader */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-loader.js\"));\n// This is replaced by webpack define plugin\nconst configEnv = {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[\"*\"],\"remotePatterns\":[]};\nif (false) {}\n// See https://stackoverflow.com/q/39777833/266535 for why we use this ref\n// handler instead of the img's onLoad attribute.\nfunction handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized) {\n    const src = img == null ? void 0 : img.src;\n    if (!img || img[\"data-loaded-src\"] === src) {\n        return;\n    }\n    img[\"data-loaded-src\"] = src;\n    const p = \"decode\" in img ? img.decode() : Promise.resolve();\n    p.catch(()=>{}).then(()=>{\n        if (!img.parentElement || !img.isConnected) {\n            // Exit early in case of race condition:\n            // - onload() is called\n            // - decode() is called but incomplete\n            // - unmount is called\n            // - decode() completes\n            return;\n        }\n        if (placeholder !== \"empty\") {\n            setBlurComplete(true);\n        }\n        if (onLoadRef == null ? void 0 : onLoadRef.current) {\n            // Since we don't have the SyntheticEvent here,\n            // we must create one with the same shape.\n            // See https://reactjs.org/docs/events.html\n            const event = new Event(\"load\");\n            Object.defineProperty(event, \"target\", {\n                writable: false,\n                value: img\n            });\n            let prevented = false;\n            let stopped = false;\n            onLoadRef.current({\n                ...event,\n                nativeEvent: event,\n                currentTarget: img,\n                target: img,\n                isDefaultPrevented: ()=>prevented,\n                isPropagationStopped: ()=>stopped,\n                persist: ()=>{},\n                preventDefault: ()=>{\n                    prevented = true;\n                    event.preventDefault();\n                },\n                stopPropagation: ()=>{\n                    stopped = true;\n                    event.stopPropagation();\n                }\n            });\n        }\n        if (onLoadingCompleteRef == null ? void 0 : onLoadingCompleteRef.current) {\n            onLoadingCompleteRef.current(img);\n        }\n        if (true) {\n            const origSrc = new URL(src, \"http://n\").searchParams.get(\"url\") || src;\n            if (img.getAttribute(\"data-nimg\") === \"fill\") {\n                if (!unoptimized && (!img.getAttribute(\"sizes\") || img.getAttribute(\"sizes\") === \"100vw\")) {\n                    let widthViewportRatio = img.getBoundingClientRect().width / window.innerWidth;\n                    if (widthViewportRatio < 0.6) {\n                        (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" but is missing \"sizes\" prop. Please add it to improve page performance. Read more: https://nextjs.org/docs/api-reference/next/image#sizes');\n                    }\n                }\n                if (img.parentElement) {\n                    const { position } = window.getComputedStyle(img.parentElement);\n                    const valid = [\n                        \"absolute\",\n                        \"fixed\",\n                        \"relative\"\n                    ];\n                    if (!valid.includes(position)) {\n                        (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" and parent element with invalid \"position\". Provided \"' + position + '\" should be one of ' + valid.map(String).join(\",\") + \".\");\n                    }\n                }\n                if (img.height === 0) {\n                    (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has \"fill\" and a height value of 0. This is likely because the parent element of the image has not been styled to have a set height.');\n                }\n            }\n            const heightModified = img.height.toString() !== img.getAttribute(\"height\");\n            const widthModified = img.width.toString() !== img.getAttribute(\"width\");\n            if (heightModified && !widthModified || !heightModified && widthModified) {\n                (0, _warnonce.warnOnce)('Image with src \"' + origSrc + '\" has either width or height modified, but not the other. If you use CSS to change the size of your image, also include the styles \\'width: \"auto\"\\' or \\'height: \"auto\"\\' to maintain the aspect ratio.');\n            }\n        }\n    });\n}\nfunction getDynamicProps(fetchPriority) {\n    const [majorStr, minorStr] = _react.version.split(\".\", 2);\n    const major = parseInt(majorStr, 10);\n    const minor = parseInt(minorStr, 10);\n    if (major > 18 || major === 18 && minor >= 3) {\n        // In React 18.3.0 or newer, we must use camelCase\n        // prop to avoid \"Warning: Invalid DOM property\".\n        // See https://github.com/facebook/react/pull/25927\n        return {\n            fetchPriority\n        };\n    }\n    // In React 18.2.0 or older, we must use lowercase prop\n    // to avoid \"Warning: Invalid DOM property\".\n    return {\n        fetchpriority: fetchPriority\n    };\n}\nconst ImageElement = /*#__PURE__*/ (0, _react.forwardRef)((param, forwardedRef)=>{\n    let { src, srcSet, sizes, height, width, decoding, className, style, fetchPriority, placeholder, loading, unoptimized, fill, onLoadRef, onLoadingCompleteRef, setBlurComplete, setShowAltText, onLoad, onError, ...rest } = param;\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(\"img\", {\n        ...rest,\n        ...getDynamicProps(fetchPriority),\n        // It's intended to keep `loading` before `src` because React updates\n        // props in order which causes Safari/Firefox to not lazy load properly.\n        // See https://github.com/facebook/react/issues/25883\n        loading: loading,\n        width: width,\n        height: height,\n        decoding: decoding,\n        \"data-nimg\": fill ? \"fill\" : \"1\",\n        className: className,\n        style: style,\n        // It's intended to keep `src` the last attribute because React updates\n        // attributes in order. If we keep `src` the first one, Safari will\n        // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n        // updated by React. That causes multiple unnecessary requests if `srcSet`\n        // and `sizes` are defined.\n        // This bug cannot be reproduced in Chrome or Firefox.\n        sizes: sizes,\n        srcSet: srcSet,\n        src: src,\n        ref: (0, _react.useCallback)((img)=>{\n            if (forwardedRef) {\n                if (typeof forwardedRef === \"function\") forwardedRef(img);\n                else if (typeof forwardedRef === \"object\") {\n                    // @ts-ignore - .current is read only it's usually assigned by react internally\n                    forwardedRef.current = img;\n                }\n            }\n            if (!img) {\n                return;\n            }\n            if (onError) {\n                // If the image has an error before react hydrates, then the error is lost.\n                // The workaround is to wait until the image is mounted which is after hydration,\n                // then we set the src again to trigger the error handler (if there was an error).\n                // eslint-disable-next-line no-self-assign\n                img.src = img.src;\n            }\n            if (true) {\n                if (!src) {\n                    console.error('Image is missing required \"src\" property:', img);\n                }\n                if (img.getAttribute(\"alt\") === null) {\n                    console.error('Image is missing required \"alt\" property. Please add Alternative Text to describe the image for screen readers and search engines.');\n                }\n            }\n            if (img.complete) {\n                handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized);\n            }\n        }, [\n            src,\n            placeholder,\n            onLoadRef,\n            onLoadingCompleteRef,\n            setBlurComplete,\n            onError,\n            unoptimized,\n            forwardedRef\n        ]),\n        onLoad: (event)=>{\n            const img = event.currentTarget;\n            handleLoading(img, placeholder, onLoadRef, onLoadingCompleteRef, setBlurComplete, unoptimized);\n        },\n        onError: (event)=>{\n            // if the real image fails to load, this will ensure \"alt\" is visible\n            setShowAltText(true);\n            if (placeholder !== \"empty\") {\n                // If the real image fails to load, this will still remove the placeholder.\n                setBlurComplete(true);\n            }\n            if (onError) {\n                onError(event);\n            }\n        }\n    });\n});\nfunction ImagePreload(param) {\n    let { isAppRouter, imgAttributes } = param;\n    const opts = {\n        as: \"image\",\n        imageSrcSet: imgAttributes.srcSet,\n        imageSizes: imgAttributes.sizes,\n        crossOrigin: imgAttributes.crossOrigin,\n        referrerPolicy: imgAttributes.referrerPolicy,\n        ...getDynamicProps(imgAttributes.fetchPriority)\n    };\n    if (isAppRouter && _reactdom.default.preload) {\n        // See https://github.com/facebook/react/pull/26940\n        _reactdom.default.preload(imgAttributes.src, opts);\n        return null;\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_head.default, {\n        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(\"link\", {\n            rel: \"preload\",\n            // Note how we omit the `href` attribute, as it would only be relevant\n            // for browsers that do not support `imagesrcset`, and in those cases\n            // it would cause the incorrect image to be preloaded.\n            //\n            // https://html.spec.whatwg.org/multipage/semantics.html#attr-link-imagesrcset\n            href: imgAttributes.srcSet ? undefined : imgAttributes.src,\n            ...opts\n        }, \"__nimg-\" + imgAttributes.src + imgAttributes.srcSet + imgAttributes.sizes)\n    });\n}\n_c = ImagePreload;\nconst Image = /*#__PURE__*/ (0, _react.forwardRef)((props, forwardedRef)=>{\n    const pagesRouter = (0, _react.useContext)(_routercontextsharedruntime.RouterContext);\n    // We're in the app directory if there is no pages router.\n    const isAppRouter = !pagesRouter;\n    const configContext = (0, _react.useContext)(_imageconfigcontextsharedruntime.ImageConfigContext);\n    const config = (0, _react.useMemo)(()=>{\n        const c = configEnv || configContext || _imageconfig.imageConfigDefault;\n        const allSizes = [\n            ...c.deviceSizes,\n            ...c.imageSizes\n        ].sort((a, b)=>a - b);\n        const deviceSizes = c.deviceSizes.sort((a, b)=>a - b);\n        return {\n            ...c,\n            allSizes,\n            deviceSizes\n        };\n    }, [\n        configContext\n    ]);\n    const { onLoad, onLoadingComplete } = props;\n    const onLoadRef = (0, _react.useRef)(onLoad);\n    (0, _react.useEffect)(()=>{\n        onLoadRef.current = onLoad;\n    }, [\n        onLoad\n    ]);\n    const onLoadingCompleteRef = (0, _react.useRef)(onLoadingComplete);\n    (0, _react.useEffect)(()=>{\n        onLoadingCompleteRef.current = onLoadingComplete;\n    }, [\n        onLoadingComplete\n    ]);\n    const [blurComplete, setBlurComplete] = (0, _react.useState)(false);\n    const [showAltText, setShowAltText] = (0, _react.useState)(false);\n    const { props: imgAttributes, meta: imgMeta } = (0, _getimgprops.getImgProps)(props, {\n        defaultLoader: _imageloader.default,\n        imgConf: config,\n        blurComplete,\n        showAltText\n    });\n    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n        children: [\n            /*#__PURE__*/ (0, _jsxruntime.jsx)(ImageElement, {\n                ...imgAttributes,\n                unoptimized: imgMeta.unoptimized,\n                placeholder: imgMeta.placeholder,\n                fill: imgMeta.fill,\n                onLoadRef: onLoadRef,\n                onLoadingCompleteRef: onLoadingCompleteRef,\n                setBlurComplete: setBlurComplete,\n                setShowAltText: setShowAltText,\n                ref: forwardedRef\n            }),\n            imgMeta.priority ? /*#__PURE__*/ (0, _jsxruntime.jsx)(ImagePreload, {\n                isAppRouter: isAppRouter,\n                imgAttributes: imgAttributes\n            }) : null\n        ]\n    });\n});\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=image-component.js.map\nvar _c;\n$RefreshReg$(_c, \"ImagePreload\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2ltYWdlLWNvbXBvbmVudC5qcyIsIm1hcHBpbmdzIjoicURBRWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILHlDQUF3QztJQUNwQ0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLDJCQUEyQkMsbUJBQU9BLENBQUMsZ0lBQXlDO0FBQ2xGLE1BQU1DLDRCQUE0QkQsbUJBQU9BLENBQUMsa0lBQTBDO0FBQ3BGLE1BQU1FLGNBQWNGLG1CQUFPQSxDQUFDLHFHQUFtQjtBQUMvQyxNQUFNRyxTQUFTLFdBQVcsR0FBR0YsMEJBQTBCRyxDQUFDLENBQUNKLG1CQUFPQSxDQUFDLG1GQUFPO0FBQ3hFLE1BQU1LLFlBQVksV0FBVyxHQUFHTix5QkFBeUJLLENBQUMsQ0FBQ0osbUJBQU9BLENBQUMsMkZBQVc7QUFDOUUsTUFBTU0sUUFBUSxXQUFXLEdBQUdQLHlCQUF5QkssQ0FBQyxDQUFDSixtQkFBT0EsQ0FBQywyRkFBb0I7QUFDbkYsTUFBTU8sZUFBZVAsbUJBQU9BLENBQUMsNkdBQTZCO0FBQzFELE1BQU1RLGVBQWVSLG1CQUFPQSxDQUFDLDJHQUE0QjtBQUN6RCxNQUFNUyxtQ0FBbUNULG1CQUFPQSxDQUFDLHlKQUFtRDtBQUNwRyxNQUFNVSxZQUFZVixtQkFBT0EsQ0FBQyxpSEFBK0I7QUFDekQsTUFBTVcsOEJBQThCWCxtQkFBT0EsQ0FBQyw2SUFBNkM7QUFDekYsTUFBTVksZUFBZSxXQUFXLEdBQUdiLHlCQUF5QkssQ0FBQyxDQUFDSixtQkFBT0EsQ0FBQyxrSEFBbUM7QUFDekcsNENBQTRDO0FBQzVDLE1BQU1hLFlBQVlDLDZOQUE2QjtBQUMvQyxJQUFJLEtBQTZCLEVBQUUsRUFFbEM7QUFDRCwwRUFBMEU7QUFDMUUsaURBQWlEO0FBQ2pELFNBQVNLLGNBQWNDLEdBQUcsRUFB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LE9BQU9wSCxRQUFRb0gsT0FBTyxDQUFDbUMsVUFBVSxLQUFLLGFBQWE7SUFDckt6SixPQUFPQyxjQUFjLENBQUNDLFFBQVFvSCxPQUFPLEVBQUUsY0FBYztRQUFFbkgsT0FBTztJQUFLO0lBQ25FSCxPQUFPMEosTUFBTSxDQUFDeEosUUFBUW9ILE9BQU8sRUFBRXBIO0lBQy9CeUosT0FBT3pKLE9BQU8sR0FBR0EsUUFBUW9ILE9BQU87QUFDbEMsRUFFQSwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvaW1hZ2UtY29tcG9uZW50LmpzP2FjNDIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW1hZ2VcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEltYWdlO1xuICAgIH1cbn0pO1xuY29uc3QgX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9fL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdFwiKTtcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZFwiKTtcbmNvbnN0IF9qc3hydW50aW1lID0gcmVxdWlyZShcInJlYWN0L2pzeC1ydW50aW1lXCIpO1xuY29uc3QgX3JlYWN0ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLl8ocmVxdWlyZShcInJlYWN0XCIpKTtcbmNvbnN0IF9yZWFjdGRvbSA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0Ll8ocmVxdWlyZShcInJlYWN0LWRvbVwiKSk7XG5jb25zdCBfaGVhZCA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0Ll8ocmVxdWlyZShcIi4uL3NoYXJlZC9saWIvaGVhZFwiKSk7XG5jb25zdCBfZ2V0aW1ncHJvcHMgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9nZXQtaW1nLXByb3BzXCIpO1xuY29uc3QgX2ltYWdlY29uZmlnID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvaW1hZ2UtY29uZmlnXCIpO1xuY29uc3QgX2ltYWdlY29uZmlnY29udGV4dHNoYXJlZHJ1bnRpbWUgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9pbWFnZS1jb25maWctY29udGV4dC5zaGFyZWQtcnVudGltZVwiKTtcbmNvbnN0IF93YXJub25jZSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3V0aWxzL3dhcm4tb25jZVwiKTtcbmNvbnN0IF9yb3V0ZXJjb250ZXh0c2hhcmVkcnVudGltZSA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci1jb250ZXh0LnNoYXJlZC1ydW50aW1lXCIpO1xuY29uc3QgX2ltYWdlbG9hZGVyID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwibmV4dC9kaXN0L3NoYXJlZC9saWIvaW1hZ2UtbG9hZGVyXCIpKTtcbi8vIFRoaXMgaXMgcmVwbGFjZWQgYnkgd2VicGFjayBkZWZpbmUgcGx1Z2luXG5jb25zdCBjb25maWdFbnYgPSBwcm9jZXNzLmVudi5fX05FWFRfSU1BR0VfT1BUUztcbmlmICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgZ2xvYmFsVGhpcy5fX05FWFRfSU1BR0VfSU1QT1JURUQgPSB0cnVlO1xufVxuLy8gU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcS8zOTc3NzgzMy8yNjY1MzUgZm9yIHdoeSB3ZSB1c2UgdGhpcyByZWZcbi8vIGhhbmRsZXIgaW5zdGVhZCBvZiB0aGUgaW1nJ3Mgb25Mb2FkIGF0dHJpYnV0ZS5cbmZ1bmN0aW9uIGhhbmRsZUxvYWRpbmcoaW1nLCBwbGFjZWhvbGRlciwgb25Mb2FkUmVmLCBvbkxvYWRpbmdDb21wbGV0ZVJlZiwgc2V0Qmx1ckNvbXBsZXRlLCB1bm9wdGltaXplZCkge1xuICAgIGNvbnN0IHNyYyA9IGltZyA9PSBudWxsID8gdm9pZCAwIDogaW1nLnNyYztcbiAgICBpZiAoIWltZyB8fCBpbWdbXCJkYXRhLWxvYWRlZC1zcmNcIl0gPT09IHNyYykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGltZ1tcImRhdGEtbG9hZGVkLXNyY1wiXSA9IHNyYztcbiAgICBjb25zdCBwID0gXCJkZWNvZGVcIiBpbiBpbWcgPyBpbWcuZGVjb2RlKCkgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBwLmNhdGNoKCgpPT57fSkudGhlbigoKT0+e1xuICAgICAgICBpZiAoIWltZy5wYXJlbnRFbGVtZW50IHx8ICFpbWcuaXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIC8vIEV4aXQgZWFybHkgaW4gY2FzZSBvZiByYWNlIGNvbmRpdGlvbjpcbiAgICAgICAgICAgIC8vIC0gb25sb2FkKCkgaXMgY2FsbGVkXG4gICAgICAgICAgICAvLyAtIGRlY29kZSgpIGlzIGNhbGxlZCBidXQgaW5jb21wbGV0ZVxuICAgICAgICAgICAgLy8gLSB1bm1vdW50IGlzIGNhbGxlZFxuICAgICAgICAgICAgLy8gLSBkZWNvZGUoKSBjb21wbGV0ZXNcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGxhY2Vob2xkZXIgIT09IFwiZW1wdHlcIikge1xuICAgICAgICAgICAgc2V0Qmx1ckNvbXBsZXRlKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbkxvYWRSZWYgPT0gbnVsbCA/IHZvaWQgMCA6IG9uTG9hZFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAvLyBTaW5jZSB3ZSBkb24ndCBoYXZlIHRoZSBTeW50aGV0aWNFdmVudCBoZXJlLFxuICAgICAgICAgICAgLy8gd2UgbXVzdCBjcmVhdGUgb25lIHdpdGggdGhlIHNhbWUgc2hhcGUuXG4gICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL2V2ZW50cy5odG1sXG4gICAgICAgICAgICBjb25zdCBldmVudCA9IG5ldyBFdmVudChcImxvYWRcIik7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXZlbnQsIFwidGFyZ2V0XCIsIHtcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGltZ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgcHJldmVudGVkID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgb25Mb2FkUmVmLmN1cnJlbnQoe1xuICAgICAgICAgICAgICAgIC4uLmV2ZW50LFxuICAgICAgICAgICAgICAgIG5hdGl2ZUV2ZW50OiBldmVudCxcbiAgICAgICAgICAgICAgICBjdXJyZW50VGFyZ2V0OiBpbWcsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBpbWcsXG4gICAgICAgICAgICAgICAgaXNEZWZhdWx0UHJldmVudGVkOiAoKT0+cHJldmVudGVkLFxuICAgICAgICAgICAgICAgIGlzUHJvcGFnYXRpb25TdG9wcGVkOiAoKT0+c3RvcHBlZCxcbiAgICAgICAgICAgICAgICBwZXJzaXN0OiAoKT0+e30sXG4gICAgICAgICAgICAgICAgcHJldmVudERlZmF1bHQ6ICgpPT57XG4gICAgICAgICAgICAgICAgICAgIHByZXZlbnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzdG9wUHJvcGFnYXRpb246ICgpPT57XG4gICAgICAgICAgICAgICAgICAgIHN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25Mb2FkaW5nQ29tcGxldGVSZWYgPT0gbnVsbCA/IHZvaWQgMCA6IG9uTG9hZGluZ0NvbXBsZXRlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIG9uTG9hZGluZ0NvbXBsZXRlUmVmLmN1cnJlbnQoaW1nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zdCBvcmlnU3JjID0gbmV3IFVSTChzcmMsIFwiaHR0cDovL25cIikuc2VhcmNoUGFyYW1zLmdldChcInVybFwiKSB8fCBzcmM7XG4gICAgICAgICAgICBpZiAoaW1nLmdldEF0dHJpYnV0ZShcImRhdGEtbmltZ1wiKSA9PT0gXCJmaWxsXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXVub3B0aW1pemVkICYmICghaW1nLmdldEF0dHJpYnV0ZShcInNpemVzXCIpIHx8IGltZy5nZXRBdHRyaWJ1dGUoXCJzaXplc1wiKSA9PT0gXCIxMDB2d1wiKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgd2lkdGhWaWV3cG9ydFJhdGlvID0gaW1nLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC8gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3aWR0aFZpZXdwb3J0UmF0aW8gPCAwLjYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfd2Fybm9uY2Uud2Fybk9uY2UpKCdJbWFnZSB3aXRoIHNyYyBcIicgKyBvcmlnU3JjICsgJ1wiIGhhcyBcImZpbGxcIiBidXQgaXMgbWlzc2luZyBcInNpemVzXCIgcHJvcC4gUGxlYXNlIGFkZCBpdCB0byBpbXByb3ZlIHBhZ2UgcGVyZm9ybWFuY2UuIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvYXBpLXJlZmVyZW5jZS9uZXh0L2ltYWdlI3NpemVzJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGltZy5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcG9zaXRpb24gfSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGltZy5wYXJlbnRFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsaWQgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBcImFic29sdXRlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcImZpeGVkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInJlbGF0aXZlXCJcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWxpZC5pbmNsdWRlcyhwb3NpdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBfd2Fybm9uY2Uud2Fybk9uY2UpKCdJbWFnZSB3aXRoIHNyYyBcIicgKyBvcmlnU3JjICsgJ1wiIGhhcyBcImZpbGxcIiBhbmQgcGFyZW50IGVsZW1lbnQgd2l0aCBpbnZhbGlkIFwicG9zaXRpb25cIi4gUHJvdmlkZWQgXCInICsgcG9zaXRpb24gKyAnXCIgc2hvdWxkIGJlIG9uZSBvZiAnICsgdmFsaWQubWFwKFN0cmluZykuam9pbihcIixcIikgKyBcIi5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGltZy5oZWlnaHQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgKDAsIF93YXJub25jZS53YXJuT25jZSkoJ0ltYWdlIHdpdGggc3JjIFwiJyArIG9yaWdTcmMgKyAnXCIgaGFzIFwiZmlsbFwiIGFuZCBhIGhlaWdodCB2YWx1ZSBvZiAwLiBUaGlzIGlzIGxpa2VseSBiZWNhdXNlIHRoZSBwYXJlbnQgZWxlbWVudCBvZiB0aGUgaW1hZ2UgaGFzIG5vdCBiZWVuIHN0eWxlZCB0byBoYXZlIGEgc2V0IGhlaWdodC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWlnaHRNb2RpZmllZCA9IGltZy5oZWlnaHQudG9TdHJpbmcoKSAhPT0gaW1nLmdldEF0dHJpYnV0ZShcImhlaWdodFwiKTtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoTW9kaWZpZWQgPSBpbWcud2lkdGgudG9TdHJpbmcoKSAhPT0gaW1nLmdldEF0dHJpYnV0ZShcIndpZHRoXCIpO1xuICAgICAgICAgICAgaWYgKGhlaWdodE1vZGlmaWVkICYmICF3aWR0aE1vZGlmaWVkIHx8ICFoZWlnaHRNb2RpZmllZCAmJiB3aWR0aE1vZGlmaWVkKSB7XG4gICAgICAgICAgICAgICAgKDAsIF93YXJub25jZS53YXJuT25jZSkoJ0ltYWdlIHdpdGggc3JjIFwiJyArIG9yaWdTcmMgKyAnXCIgaGFzIGVpdGhlciB3aWR0aCBvciBoZWlnaHQgbW9kaWZpZWQsIGJ1dCBub3QgdGhlIG90aGVyLiBJZiB5b3UgdXNlIENTUyB0byBjaGFuZ2UgdGhlIHNpemUgb2YgeW91ciBpbWFnZSwgYWxzbyBpbmNsdWRlIHRoZSBzdHlsZXMgXFwnd2lkdGg6IFwiYXV0b1wiXFwnIG9yIFxcJ2hlaWdodDogXCJhdXRvXCJcXCcgdG8gbWFpbnRhaW4gdGhlIGFzcGVjdCByYXRpby4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0RHluYW1pY1Byb3BzKGZldGNoUHJpb3JpdHkpIHtcbiAgICBjb25zdCBbbWFqb3JTdHIsIG1pbm9yU3RyXSA9IF9yZWFjdC52ZXJzaW9uLnNwbGl0KFwiLlwiLCAyKTtcbiAgICBjb25zdCBtYWpvciA9IHBhcnNlSW50KG1ham9yU3RyLCAxMCk7XG4gICAgY29uc3QgbWlub3IgPSBwYXJzZUludChtaW5vclN0ciwgMTApO1xuICAgIGlmIChtYWpvciA+IDE4IHx8IG1ham9yID09PSAxOCAmJiBtaW5vciA+PSAzKSB7XG4gICAgICAgIC8vIEluIFJlYWN0IDE4LjMuMCBvciBuZXdlciwgd2UgbXVzdCB1c2UgY2FtZWxDYXNlXG4gICAgICAgIC8vIHByb3AgdG8gYXZvaWQgXCJXYXJuaW5nOiBJbnZhbGlkIERPTSBwcm9wZXJ0eVwiLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjU5MjdcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZldGNoUHJpb3JpdHlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gSW4gUmVhY3QgMTguMi4wIG9yIG9sZGVyLCB3ZSBtdXN0IHVzZSBsb3dlcmNhc2UgcHJvcFxuICAgIC8vIHRvIGF2b2lkIFwiV2FybmluZzogSW52YWxpZCBET00gcHJvcGVydHlcIi5cbiAgICByZXR1cm4ge1xuICAgICAgICBmZXRjaHByaW9yaXR5OiBmZXRjaFByaW9yaXR5XG4gICAgfTtcbn1cbmNvbnN0IEltYWdlRWxlbWVudCA9IC8qI19fUFVSRV9fKi8gKDAsIF9yZWFjdC5mb3J3YXJkUmVmKSgocGFyYW0sIGZvcndhcmRlZFJlZik9PntcbiAgICBsZXQgeyBzcmMsIHNyY1NldCwgc2l6ZXMsIGhlaWdodCwgd2lkdGgsIGRlY29kaW5nLCBjbGFzc05hbWUsIHN0eWxlLCBmZXRjaFByaW9yaXR5LCBwbGFjZWhvbGRlciwgbG9hZGluZywgdW5vcHRpbWl6ZWQsIGZpbGwsIG9uTG9hZFJlZiwgb25Mb2FkaW5nQ29tcGxldGVSZWYsIHNldEJsdXJDb21wbGV0ZSwgc2V0U2hvd0FsdFRleHQsIG9uTG9hZCwgb25FcnJvciwgLi4ucmVzdCB9ID0gcGFyYW07XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoXCJpbWdcIiwge1xuICAgICAgICAuLi5yZXN0LFxuICAgICAgICAuLi5nZXREeW5hbWljUHJvcHMoZmV0Y2hQcmlvcml0eSksXG4gICAgICAgIC8vIEl0J3MgaW50ZW5kZWQgdG8ga2VlcCBgbG9hZGluZ2AgYmVmb3JlIGBzcmNgIGJlY2F1c2UgUmVhY3QgdXBkYXRlc1xuICAgICAgICAvLyBwcm9wcyBpbiBvcmRlciB3aGljaCBjYXVzZXMgU2FmYXJpL0ZpcmVmb3ggdG8gbm90IGxhenkgbG9hZCBwcm9wZXJseS5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMjU4ODNcbiAgICAgICAgbG9hZGluZzogbG9hZGluZyxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgZGVjb2Rpbmc6IGRlY29kaW5nLFxuICAgICAgICBcImRhdGEtbmltZ1wiOiBmaWxsID8gXCJmaWxsXCIgOiBcIjFcIixcbiAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUsXG4gICAgICAgIHN0eWxlOiBzdHlsZSxcbiAgICAgICAgLy8gSXQncyBpbnRlbmRlZCB0byBrZWVwIGBzcmNgIHRoZSBsYXN0IGF0dHJpYnV0ZSBiZWNhdXNlIFJlYWN0IHVwZGF0ZXNcbiAgICAgICAgLy8gYXR0cmlidXRlcyBpbiBvcmRlci4gSWYgd2Uga2VlcCBgc3JjYCB0aGUgZmlyc3Qgb25lLCBTYWZhcmkgd2lsbFxuICAgICAgICAvLyBpbW1lZGlhdGVseSBzdGFydCB0byBmZXRjaCBgc3JjYCwgYmVmb3JlIGBzaXplc2AgYW5kIGBzcmNTZXRgIGFyZSBldmVuXG4gICAgICAgIC8vIHVwZGF0ZWQgYnkgUmVhY3QuIFRoYXQgY2F1c2VzIG11bHRpcGxlIHVubmVjZXNzYXJ5IHJlcXVlc3RzIGlmIGBzcmNTZXRgXG4gICAgICAgIC8vIGFuZCBgc2l6ZXNgIGFyZSBkZWZpbmVkLlxuICAgICAgICAvLyBUaGlzIGJ1ZyBjYW5ub3QgYmUgcmVwcm9kdWNlZCBpbiBDaHJvbWUgb3IgRmlyZWZveC5cbiAgICAgICAgc2l6ZXM6IHNpemVzLFxuICAgICAgICBzcmNTZXQ6IHNyY1NldCxcbiAgICAgICAgc3JjOiBzcmMsXG4gICAgICAgIHJlZjogKDAsIF9yZWFjdC51c2VDYWxsYmFjaykoKGltZyk9PntcbiAgICAgICAgICAgIGlmIChmb3J3YXJkZWRSZWYpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZvcndhcmRlZFJlZiA9PT0gXCJmdW5jdGlvblwiKSBmb3J3YXJkZWRSZWYoaW1nKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZm9yd2FyZGVkUmVmID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgLSAuY3VycmVudCBpcyByZWFkIG9ubHkgaXQncyB1c3VhbGx5IGFzc2lnbmVkIGJ5IHJlYWN0IGludGVybmFsbHlcbiAgICAgICAgICAgICAgICAgICAgZm9yd2FyZGVkUmVmLmN1cnJlbnQgPSBpbWc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpbWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25FcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBpbWFnZSBoYXMgYW4gZXJyb3IgYmVmb3JlIHJlYWN0IGh5ZHJhdGVzLCB0aGVuIHRoZSBlcnJvciBpcyBsb3N0LlxuICAgICAgICAgICAgICAgIC8vIFRoZSB3b3JrYXJvdW5kIGlzIHRvIHdhaXQgdW50aWwgdGhlIGltYWdlIGlzIG1vdW50ZWQgd2hpY2ggaXMgYWZ0ZXIgaHlkcmF0aW9uLFxuICAgICAgICAgICAgICAgIC8vIHRoZW4gd2Ugc2V0IHRoZSBzcmMgYWdhaW4gdG8gdHJpZ2dlciB0aGUgZXJyb3IgaGFuZGxlciAoaWYgdGhlcmUgd2FzIGFuIGVycm9yKS5cbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1hc3NpZ25cbiAgICAgICAgICAgICAgICBpbWcuc3JjID0gaW1nLnNyYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNyYykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdJbWFnZSBpcyBtaXNzaW5nIHJlcXVpcmVkIFwic3JjXCIgcHJvcGVydHk6JywgaW1nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGltZy5nZXRBdHRyaWJ1dGUoXCJhbHRcIikgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignSW1hZ2UgaXMgbWlzc2luZyByZXF1aXJlZCBcImFsdFwiIHByb3BlcnR5LiBQbGVhc2UgYWRkIEFsdGVybmF0aXZlIFRleHQgdG8gZGVzY3JpYmUgdGhlIGltYWdlIGZvciBzY3JlZW4gcmVhZGVycyBhbmQgc2VhcmNoIGVuZ2luZXMuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGltZy5jb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZUxvYWRpbmcoaW1nLCBwbGFjZWhvbGRlciwgb25Mb2FkUmVmLCBvbkxvYWRpbmdDb21wbGV0ZVJlZiwgc2V0Qmx1ckNvbXBsZXRlLCB1bm9wdGltaXplZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFtcbiAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAgICAgICAgb25Mb2FkUmVmLFxuICAgICAgICAgICAgb25Mb2FkaW5nQ29tcGxldGVSZWYsXG4gICAgICAgICAgICBzZXRCbHVyQ29tcGxldGUsXG4gICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICAgICAgdW5vcHRpbWl6ZWQsXG4gICAgICAgICAgICBmb3J3YXJkZWRSZWZcbiAgICAgICAgXSksXG4gICAgICAgIG9uTG9hZDogKGV2ZW50KT0+e1xuICAgICAgICAgICAgY29uc3QgaW1nID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgICAgIGhhbmRsZUxvYWRpbmcoaW1nLCBwbGFjZWhvbGRlciwgb25Mb2FkUmVmLCBvbkxvYWRpbmdDb21wbGV0ZVJlZiwgc2V0Qmx1ckNvbXBsZXRlLCB1bm9wdGltaXplZCk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRXJyb3I6IChldmVudCk9PntcbiAgICAgICAgICAgIC8vIGlmIHRoZSByZWFsIGltYWdlIGZhaWxzIHRvIGxvYWQsIHRoaXMgd2lsbCBlbnN1cmUgXCJhbHRcIiBpcyB2aXNpYmxlXG4gICAgICAgICAgICBzZXRTaG93QWx0VGV4dCh0cnVlKTtcbiAgICAgICAgICAgIGlmIChwbGFjZWhvbGRlciAhPT0gXCJlbXB0eVwiKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJlYWwgaW1hZ2UgZmFpbHMgdG8gbG9hZCwgdGhpcyB3aWxsIHN0aWxsIHJlbW92ZSB0aGUgcGxhY2Vob2xkZXIuXG4gICAgICAgICAgICAgICAgc2V0Qmx1ckNvbXBsZXRlKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBvbkVycm9yKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufSk7XG5mdW5jdGlvbiBJbWFnZVByZWxvYWQocGFyYW0pIHtcbiAgICBsZXQgeyBpc0FwcFJvdXRlciwgaW1nQXR0cmlidXRlcyB9ID0gcGFyYW07XG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgYXM6IFwiaW1hZ2VcIixcbiAgICAgICAgaW1hZ2VTcmNTZXQ6IGltZ0F0dHJpYnV0ZXMuc3JjU2V0LFxuICAgICAgICBpbWFnZVNpemVzOiBpbWdBdHRyaWJ1dGVzLnNpemVzLFxuICAgICAgICBjcm9zc09yaWdpbjogaW1nQXR0cmlidXRlcy5jcm9zc09yaWdpbixcbiAgICAgICAgcmVmZXJyZXJQb2xpY3k6IGltZ0F0dHJpYnV0ZXMucmVmZXJyZXJQb2xpY3ksXG4gICAgICAgIC4uLmdldER5bmFtaWNQcm9wcyhpbWdBdHRyaWJ1dGVzLmZldGNoUHJpb3JpdHkpXG4gICAgfTtcbiAgICBpZiAoaXNBcHBSb3V0ZXIgJiYgX3JlYWN0ZG9tLmRlZmF1bHQucHJlbG9hZCkge1xuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjY5NDBcbiAgICAgICAgX3JlYWN0ZG9tLmRlZmF1bHQucHJlbG9hZChpbWdBdHRyaWJ1dGVzLnNyYywgLy8gQHRzLWV4cGVjdC1lcnJvciBUT0RPOiB1cGdyYWRlIHRvIGBAdHlwZXMvcmVhY3QtZG9tQDE4LjMueGBcbiAgICAgICAgb3B0cyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4KShfaGVhZC5kZWZhdWx0LCB7XG4gICAgICAgIGNoaWxkcmVuOiAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3gpKFwibGlua1wiLCB7XG4gICAgICAgICAgICByZWw6IFwicHJlbG9hZFwiLFxuICAgICAgICAgICAgLy8gTm90ZSBob3cgd2Ugb21pdCB0aGUgYGhyZWZgIGF0dHJpYnV0ZSwgYXMgaXQgd291bGQgb25seSBiZSByZWxldmFudFxuICAgICAgICAgICAgLy8gZm9yIGJyb3dzZXJzIHRoYXQgZG8gbm90IHN1cHBvcnQgYGltYWdlc3Jjc2V0YCwgYW5kIGluIHRob3NlIGNhc2VzXG4gICAgICAgICAgICAvLyBpdCB3b3VsZCBjYXVzZSB0aGUgaW5jb3JyZWN0IGltYWdlIHRvIGJlIHByZWxvYWRlZC5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zZW1hbnRpY3MuaHRtbCNhdHRyLWxpbmstaW1hZ2VzcmNzZXRcbiAgICAgICAgICAgIGhyZWY6IGltZ0F0dHJpYnV0ZXMuc3JjU2V0ID8gdW5kZWZpbmVkIDogaW1nQXR0cmlidXRlcy5zcmMsXG4gICAgICAgICAgICAuLi5vcHRzXG4gICAgICAgIH0sIFwiX19uaW1nLVwiICsgaW1nQXR0cmlidXRlcy5zcmMgKyBpbWdBdHRyaWJ1dGVzLnNyY1NldCArIGltZ0F0dHJpYnV0ZXMuc2l6ZXMpXG4gICAgfSk7XG59XG5jb25zdCBJbWFnZSA9IC8qI19fUFVSRV9fKi8gKDAsIF9yZWFjdC5mb3J3YXJkUmVmKSgocHJvcHMsIGZvcndhcmRlZFJlZik9PntcbiAgICBjb25zdCBwYWdlc1JvdXRlciA9ICgwLCBfcmVhY3QudXNlQ29udGV4dCkoX3JvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lLlJvdXRlckNvbnRleHQpO1xuICAgIC8vIFdlJ3JlIGluIHRoZSBhcHAgZGlyZWN0b3J5IGlmIHRoZXJlIGlzIG5vIHBhZ2VzIHJvdXRlci5cbiAgICBjb25zdCBpc0FwcFJvdXRlciA9ICFwYWdlc1JvdXRlcjtcbiAgICBjb25zdCBjb25maWdDb250ZXh0ID0gKDAsIF9yZWFjdC51c2VDb250ZXh0KShfaW1hZ2Vjb25maWdjb250ZXh0c2hhcmVkcnVudGltZS5JbWFnZUNvbmZpZ0NvbnRleHQpO1xuICAgIGNvbnN0IGNvbmZpZyA9ICgwLCBfcmVhY3QudXNlTWVtbykoKCk9PntcbiAgICAgICAgY29uc3QgYyA9IGNvbmZpZ0VudiB8fCBjb25maWdDb250ZXh0IHx8IF9pbWFnZWNvbmZpZy5pbWFnZUNvbmZpZ0RlZmF1bHQ7XG4gICAgICAgIGNvbnN0IGFsbFNpemVzID0gW1xuICAgICAgICAgICAgLi4uYy5kZXZpY2VTaXplcyxcbiAgICAgICAgICAgIC4uLmMuaW1hZ2VTaXplc1xuICAgICAgICBdLnNvcnQoKGEsIGIpPT5hIC0gYik7XG4gICAgICAgIGNvbnN0IGRldmljZVNpemVzID0gYy5kZXZpY2VTaXplcy5zb3J0KChhLCBiKT0+YSAtIGIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uYyxcbiAgICAgICAgICAgIGFsbFNpemVzLFxuICAgICAgICAgICAgZGV2aWNlU2l6ZXNcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIGNvbmZpZ0NvbnRleHRcbiAgICBdKTtcbiAgICBjb25zdCB7IG9uTG9hZCwgb25Mb2FkaW5nQ29tcGxldGUgfSA9IHByb3BzO1xuICAgIGNvbnN0IG9uTG9hZFJlZiA9ICgwLCBfcmVhY3QudXNlUmVmKShvbkxvYWQpO1xuICAgICgwLCBfcmVhY3QudXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICBvbkxvYWRSZWYuY3VycmVudCA9IG9uTG9hZDtcbiAgICB9LCBbXG4gICAgICAgIG9uTG9hZFxuICAgIF0pO1xuICAgIGNvbnN0IG9uTG9hZGluZ0NvbXBsZXRlUmVmID0gKDAsIF9yZWFjdC51c2VSZWYpKG9uTG9hZGluZ0NvbXBsZXRlKTtcbiAgICAoMCwgX3JlYWN0LnVzZUVmZmVjdCkoKCk9PntcbiAgICAgICAgb25Mb2FkaW5nQ29tcGxldGVSZWYuY3VycmVudCA9IG9uTG9hZGluZ0NvbXBsZXRlO1xuICAgIH0sIFtcbiAgICAgICAgb25Mb2FkaW5nQ29tcGxldGVcbiAgICBdKTtcbiAgICBjb25zdCBbYmx1ckNvbXBsZXRlLCBzZXRCbHVyQ29tcGxldGVdID0gKDAsIF9yZWFjdC51c2VTdGF0ZSkoZmFsc2UpO1xuICAgIGNvbnN0IFtzaG93QWx0VGV4dCwgc2V0U2hvd0FsdFRleHRdID0gKDAsIF9yZWFjdC51c2VTdGF0ZSkoZmFsc2UpO1xuICAgIGNvbnN0IHsgcHJvcHM6IGltZ0F0dHJpYnV0ZXMsIG1ldGE6IGltZ01ldGEgfSA9ICgwLCBfZ2V0aW1ncHJvcHMuZ2V0SW1nUHJvcHMpKHByb3BzLCB7XG4gICAgICAgIGRlZmF1bHRMb2FkZXI6IF9pbWFnZWxvYWRlci5kZWZhdWx0LFxuICAgICAgICBpbWdDb25mOiBjb25maWcsXG4gICAgICAgIGJsdXJDb21wbGV0ZSxcbiAgICAgICAgc2hvd0FsdFRleHRcbiAgICB9KTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4cykoX2pzeHJ1bnRpbWUuRnJhZ21lbnQsIHtcbiAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgIC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoSW1hZ2VFbGVtZW50LCB7XG4gICAgICAgICAgICAgICAgLi4uaW1nQXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICB1bm9wdGltaXplZDogaW1nTWV0YS51bm9wdGltaXplZCxcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogaW1nTWV0YS5wbGFjZWhvbGRlcixcbiAgICAgICAgICAgICAgICBmaWxsOiBpbWdNZXRhLmZpbGwsXG4gICAgICAgICAgICAgICAgb25Mb2FkUmVmOiBvbkxvYWRSZWYsXG4gICAgICAgICAgICAgICAgb25Mb2FkaW5nQ29tcGxldGVSZWY6IG9uTG9hZGluZ0NvbXBsZXRlUmVmLFxuICAgICAgICAgICAgICAgIHNldEJsdXJDb21wbGV0ZTogc2V0Qmx1ckNvbXBsZXRlLFxuICAgICAgICAgICAgICAgIHNldFNob3dBbHRUZXh0OiBzZXRTaG93QWx0VGV4dCxcbiAgICAgICAgICAgICAgICByZWY6IGZvcndhcmRlZFJlZlxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBpbWdNZXRhLnByaW9yaXR5ID8gLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4KShJbWFnZVByZWxvYWQsIHtcbiAgICAgICAgICAgICAgICBpc0FwcFJvdXRlcjogaXNBcHBSb3V0ZXIsXG4gICAgICAgICAgICAgICAgaW1nQXR0cmlidXRlczogaW1nQXR0cmlidXRlc1xuICAgICAgICAgICAgfSkgOiBudWxsXG4gICAgICAgIF1cbiAgICB9KTtcbn0pO1xuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbWFnZS1jb21wb25lbnQuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsIkltYWdlIiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwicmVxdWlyZSIsIl9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQiLCJfanN4cnVudGltZSIsIl9yZWFjdCIsIl8iLCJfcmVhY3Rkb20iLCJfaGVhZCIsIl9nZXRpbWdwcm9wcyIsIl9pbWFnZWNvbmZpZyIsIl9pbWFnZWNvbmZpZ2NvbnRleHRzaGFyZWRydW50aW1lIiwiX3dhcm5vbmNlIiwiX3JvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lIiwiX2ltYWdlbG9hZGVyIiwiY29uZmlnRW52IiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9JTUFHRV9PUFRTIiwiZ2xvYmFsVGhpcyIsIl9fTkVYVF9JTUFHRV9JTVBPUlRFRCIsImhhbmRsZUxvYWRpbmciLCJpbWciLCJwbGFjZWhvbGRlciIsIm9uTG9hZFJlZiIsIm9uTG9hZGluZ0NvbXBsZXRlUmVmIiwic2V0Qmx1ckNvbXBsZXRlIiwidW5vcHRpbWl6ZWQiLCJzcmMiLCJwIiwiZGVjb2RlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJjYXRjaCIsInRoZW4iLCJwYXJlbnRFbGVtZW50IiwiaXNDb25uZWN0ZWQiLCJjdXJyZW50IiwiZXZlbnQiLCJFdmVudCIsIndyaXRhYmxlIiwicHJldmVudGVkIiwic3RvcHBlZCIsIm5hdGl2ZUV2ZW50IiwiY3VycmVudFRhcmdldCIsInRhcmdldCIsImlzRGVmYXVsdFByZXZlbnRlZCIsImlzUHJvcGFnYXRpb25TdG9wcGVkIiwicGVyc2lzdCIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwib3JpZ1NyYyIsIlVSTCIsInNlYXJjaFBhcmFtcyIsImdldEF0dHJpYnV0ZSIsIndpZHRoVmlld3BvcnRSYXRpbyIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIndpZHRoIiwid2luZG93IiwiaW5uZXJXaWR0aCIsIndhcm5PbmNlIiwicG9zaXRpb24iLCJnZXRDb21wdXRlZFN0eWxlIiwidmFsaWQiLCJpbmNsdWRlcyIsIm1hcCIsIlN0cmluZyIsImpvaW4iLCJoZWlnaHQiLCJoZWlnaHRNb2RpZmllZCIsInRvU3RyaW5nIiwid2lkdGhNb2RpZmllZCIsImdldER5bmFtaWNQcm9wcyIsImZldGNoUHJpb3JpdHkiLCJtYWpvclN0ciIsIm1pbm9yU3RyIiwidmVyc2lvbiIsInNwbGl0IiwibWFqb3IiLCJwYXJzZUludCIsIm1pbm9yIiwiZmV0Y2hwcmlvcml0eSIsIkltYWdlRWxlbWVudCIsImZvcndhcmRSZWYiLCJwYXJhbSIsImZvcndhcmRlZFJlZiIsInNyY1NldCIsInNpemVzIiwiZGVjb2RpbmciLCJjbGFzc05hbWUiLCJzdHlsZSIsImxvYWRpbmciLCJmaWxsIiwic2V0U2hvd0FsdFRleHQiLCJvbkxvYWQiLCJvbkVycm9yIiwicmVzdCIsImpzeCIsInJlZiIsInVzZUNhbGxiYWNrIiwiY29uc29sZSIsImVycm9yIiwiY29tcGxldGUiLCJJbWFnZVByZWxvYWQiLCJpc0FwcFJvdXRlciIsImltZ0F0dHJpYnV0ZXMiLCJvcHRzIiwiYXMiLCJpbWFnZVNyY1NldCIsImltYWdlU2l6ZXMiLCJjcm9zc09yaWdpbiIsInJlZmVycmVyUG9saWN5IiwiZGVmYXVsdCIsInByZWxvYWQiLCJjaGlsZHJlbiIsInJlbCIsImhyZWYiLCJ1bmRlZmluZWQiLCJwcm9wcyIsInBhZ2VzUm91dGVyIiwidXNlQ29udGV4dCIsIlJvdXRlckNvbnRleHQiLCJjb25maWdDb250ZXh0IiwiSW1hZ2VDb25maWdDb250ZXh0IiwiY29uZmlnIiwidXNlTWVtbyIsImMiLCJpbWFnZUNvbmZpZ0RlZmF1bHQiLCJhbGxTaXplcyIsImRldmljZVNpemVzIiwic29ydCIsImEiLCJiIiwib25Mb2FkaW5nQ29tcGxldGUiLCJ1c2VSZWYiLCJ1c2VFZmZlY3QiLCJibHVyQ29tcGxldGUiLCJ1c2VTdGF0ZSIsInNob3dBbHRUZXh0IiwibWV0YSIsImltZ01ldGEiLCJnZXRJbWdQcm9wcyIsImRlZmF1bHRMb2FkZXIiLCJpbWdDb25mIiwianN4cyIsIkZyYWdtZW50IiwicHJpb3JpdHkiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/image-component.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js":
/*!*************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js ***!
  \*************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"AmpStateContext\", ({\n    enumerable: true,\n    get: function() {\n        return AmpStateContext;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst AmpStateContext = _react.default.createContext({});\nif (true) {\n    AmpStateContext.displayName = \"AmpStateContext\";\n} //# sourceMappingURL=amp-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9hbXAtY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsbURBQWtEO0lBQzlDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsMkJBQTJCQyxtQkFBT0EsQ0FBQyxnSUFBeUM7QUFDbEYsTUFBTUMsU0FBUyxXQUFXLEdBQUdGLHlCQUF5QkcsQ0FBQyxDQUFDRixtQkFBT0EsQ0FBQyxtRkFBTztBQUN2RSxNQUFNRixrQkFBa0JHLE9BQU9FLE9BQU8sQ0FBQ0MsYUFBYSxDQUFDLENBQUM7QUFDdEQsSUFBSUMsSUFBcUMsRUFBRTtJQUN2Q1AsZ0JBQWdCUSxXQUFXLEdBQUc7QUFDbEMsRUFFQSxzREFBc0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL2FtcC1jb250ZXh0LnNoYXJlZC1ydW50aW1lLmpzPzk4YjciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBbXBTdGF0ZUNvbnRleHRcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEFtcFN0YXRlQ29udGV4dDtcbiAgICB9XG59KTtcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHRcIik7XG5jb25zdCBfcmVhY3QgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5jb25zdCBBbXBTdGF0ZUNvbnRleHQgPSBfcmVhY3QuZGVmYXVsdC5jcmVhdGVDb250ZXh0KHt9KTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBBbXBTdGF0ZUNvbnRleHQuZGlzcGxheU5hbWUgPSBcIkFtcFN0YXRlQ29udGV4dFwiO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbXAtY29udGV4dC5zaGFyZWQtcnVudGltZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiQW1wU3RhdGVDb250ZXh0IiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwicmVxdWlyZSIsIl9yZWFjdCIsIl8iLCJkZWZhdWx0IiwiY3JlYXRlQ29udGV4dCIsInByb2Nlc3MiLCJkaXNwbGF5TmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-mode.js":
/*!*******************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/amp-mode.js ***!
  \*******************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"isInAmpMode\", ({\n    enumerable: true,\n    get: function() {\n        return isInAmpMode;\n    }\n}));\nfunction isInAmpMode(param) {\n    let { ampFirst = false, hybrid = false, hasQuery = false } = param === void 0 ? {} : param;\n    return ampFirst || hybrid && hasQuery;\n} //# sourceMappingURL=amp-mode.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9hbXAtbW9kZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsK0NBQThDO0lBQzFDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsU0FBU0EsWUFBWUMsS0FBSztJQUN0QixJQUFJLEVBQUVDLFdBQVcsS0FBSyxFQUFFQyxTQUFTLEtBQUssRUFBRUMsV0FBVyxLQUFLLEVBQUUsR0FBR0gsVUFBVSxLQUFLLElBQUksQ0FBQyxJQUFJQTtJQUNyRixPQUFPQyxZQUFZQyxVQUFVQztBQUNqQyxFQUVBLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvYW1wLW1vZGUuanM/NjIzMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzSW5BbXBNb2RlXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBpc0luQW1wTW9kZTtcbiAgICB9XG59KTtcbmZ1bmN0aW9uIGlzSW5BbXBNb2RlKHBhcmFtKSB7XG4gICAgbGV0IHsgYW1wRmlyc3QgPSBmYWxzZSwgaHlicmlkID0gZmFsc2UsIGhhc1F1ZXJ5ID0gZmFsc2UgfSA9IHBhcmFtID09PSB2b2lkIDAgPyB7fSA6IHBhcmFtO1xuICAgIHJldHVybiBhbXBGaXJzdCB8fCBoeWJyaWQgJiYgaGFzUXVlcnk7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFtcC1tb2RlLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJpc0luQW1wTW9kZSIsInBhcmFtIiwiYW1wRmlyc3QiLCJoeWJyaWQiLCJoYXNRdWVyeSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-mode.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/get-img-props.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/get-img-props.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getImgProps\", ({\n    enumerable: true,\n    get: function() {\n        return getImgProps;\n    }\n}));\nconst _warnonce = __webpack_require__(/*! ./utils/warn-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nconst _imageblursvg = __webpack_require__(/*! ./image-blur-svg */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-blur-svg.js\");\nconst _imageconfig = __webpack_require__(/*! ./image-config */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js\");\nconst VALID_LOADING_VALUES = [\n    \"lazy\",\n    \"eager\",\n    undefined\n];\nfunction isStaticRequire(src) {\n    return src.default !== undefined;\n}\nfunction isStaticImageData(src) {\n    return src.src !== undefined;\n}\nfunction isStaticImport(src) {\n    return typeof src === \"object\" && (isStaticRequire(src) || isStaticImageData(src));\n}\nconst allImgs = new Map();\nlet perfObserver;\nfunction getInt(x) {\n    if (typeof x === \"undefined\") {\n        return x;\n    }\n    if (typeof x === \"number\") {\n        return Number.isFinite(x) ? x : NaN;\n    }\n    if (typeof x === \"string\" && /^[0-9]+$/.test(x)) {\n        return parseInt(x, 10);\n    }\n    return NaN;\n}\nfunction getWidths(param, width, sizes) {\n    let { deviceSizes, allSizes } = param;\n    if (sizes) {\n        // Find all the \"vw\" percent sizes used in the sizes prop\n        const viewportWidthRe = /(^|\\s)(1?\\d?\\d)vw/g;\n        const percentSizes = [];\n        for(let match; match = viewportWidthRe.exec(sizes); match){\n            percentSizes.push(parseInt(match[2]));\n        }\n        if (percentSizes.length) {\n            const smallestRatio = Math.min(...percentSizes) * 0.01;\n            return {\n                widths: allSizes.filter((s)=>s >= deviceSizes[0] * smallestRatio),\n                kind: \"w\"\n            };\n        }\n        return {\n            widths: allSizes,\n            kind: \"w\"\n        };\n    }\n    if (typeof width !== \"number\") {\n        return {\n            widths: deviceSizes,\n            kind: \"w\"\n        };\n    }\n    const widths = [\n        ...new Set(// > are actually 3x in the green color, but only 1.5x in the red and\n        // > blue colors. Showing a 3x resolution image in the app vs a 2x\n        // > resolution image will be visually the same, though the 3x image\n        // > takes significantly more data. Even true 3x resolution screens are\n        // > wasteful as the human eye cannot see that level of detail without\n        // > something like a magnifying glass.\n        // https://blog.twitter.com/engineering/en_us/topics/infrastructure/2019/capping-image-fidelity-on-ultra-high-resolution-devices.html\n        [\n            width,\n            width * 2 /*, width * 3*/ \n        ].map((w)=>allSizes.find((p)=>p >= w) || allSizes[allSizes.length - 1]))\n    ];\n    return {\n        widths,\n        kind: \"x\"\n    };\n}\nfunction generateImgAttrs(param) {\n    let { config, src, unoptimized, width, quality, sizes, loader } = param;\n    if (unoptimized) {\n        return {\n            src,\n            srcSet: undefined,\n            sizes: undefined\n        };\n    }\n    const { widths, kind } = getWidths(config, width, sizes);\n    const last = widths.length - 1;\n    return {\n        sizes: !sizes && kind === \"w\" ? \"100vw\" : sizes,\n        srcSet: widths.map((w, i)=>loader({\n                config,\n                src,\n                quality,\n                width: w\n            }) + \" \" + (kind === \"w\" ? w : i + 1) + kind).join(\", \"),\n        // It's intended to keep `src` the last attribute because React updates\n        // attributes in order. If we keep `src` the first one, Safari will\n        // immediately start to fetch `src`, before `sizes` and `srcSet` are even\n        // updated by React. That causes multiple unnecessary requests if `srcSet`\n        // and `sizes` are defined.\n        // This bug cannot be reproduced in Chrome or Firefox.\n        src: loader({\n            config,\n            src,\n            quality,\n            width: widths[last]\n        })\n    };\n}\nfunction getImgProps(param, _state) {\n    let { src, sizes, unoptimized = false, priority = false, loading, className, quality, width, height, fill = false, style, onLoad, onLoadingComplete, placeholder = \"empty\", blurDataURL, fetchPriority, layout, objectFit, objectPosition, lazyBoundary, lazyRoot, ...rest } = param;\n    const { imgConf, showAltText, blurComplete, defaultLoader } = _state;\n    let config;\n    let c = imgConf || _imageconfig.imageConfigDefault;\n    if (\"allSizes\" in c) {\n        config = c;\n    } else {\n        const allSizes = [\n            ...c.deviceSizes,\n            ...c.imageSizes\n        ].sort((a, b)=>a - b);\n        const deviceSizes = c.deviceSizes.sort((a, b)=>a - b);\n        config = {\n            ...c,\n            allSizes,\n            deviceSizes\n        };\n    }\n    let loader = rest.loader || defaultLoader;\n    // Remove property so it's not spread on <img> element\n    delete rest.loader;\n    delete rest.srcSet;\n    // This special value indicates that the user\n    // didn't define a \"loader\" prop or \"loader\" config.\n    const isDefaultLoader = \"__next_img_default\" in loader;\n    if (isDefaultLoader) {\n        if (config.loader === \"custom\") {\n            throw new Error('Image with src \"' + src + '\" is missing \"loader\" prop.' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader\");\n        }\n    } else {\n        // The user defined a \"loader\" prop or config.\n        // Since the config object is internal only, we\n        // must not pass it to the user-defined \"loader\".\n        const customImageLoader = loader;\n        loader = (obj)=>{\n            const { config: _, ...opts } = obj;\n            return customImageLoader(opts);\n        };\n    }\n    if (layout) {\n        if (layout === \"fill\") {\n            fill = true;\n        }\n        const layoutToStyle = {\n            intrinsic: {\n                maxWidth: \"100%\",\n                height: \"auto\"\n            },\n            responsive: {\n                width: \"100%\",\n                height: \"auto\"\n            }\n        };\n        const layoutToSizes = {\n            responsive: \"100vw\",\n            fill: \"100vw\"\n        };\n        const layoutStyle = layoutToStyle[layout];\n        if (layoutStyle) {\n            style = {\n                ...style,\n                ...layoutStyle\n            };\n        }\n        const layoutSizes = layoutToSizes[layout];\n        if (layoutSizes && !sizes) {\n            sizes = layoutSizes;\n        }\n    }\n    let staticSrc = \"\";\n    let widthInt = getInt(width);\n    let heightInt = getInt(height);\n    let blurWidth;\n    let blurHeight;\n    if (isStaticImport(src)) {\n        const staticImageData = isStaticRequire(src) ? src.default : src;\n        if (!staticImageData.src) {\n            throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include src. Received \" + JSON.stringify(staticImageData));\n        }\n        if (!staticImageData.height || !staticImageData.width) {\n            throw new Error(\"An object should only be passed to the image component src parameter if it comes from a static image import. It must include height and width. Received \" + JSON.stringify(staticImageData));\n        }\n        blurWidth = staticImageData.blurWidth;\n        blurHeight = staticImageData.blurHeight;\n        blurDataURL = blurDataURL || staticImageData.blurDataURL;\n        staticSrc = staticImageData.src;\n        if (!fill) {\n            if (!widthInt && !heightInt) {\n                widthInt = staticImageData.width;\n                heightInt = staticImageData.height;\n            } else if (widthInt && !heightInt) {\n                const ratio = widthInt / staticImageData.width;\n                heightInt = Math.round(staticImageData.height * ratio);\n            } else if (!widthInt && heightInt) {\n                const ratio = heightInt / staticImageData.height;\n                widthInt = Math.round(staticImageData.width * ratio);\n            }\n        }\n    }\n    src = typeof src === \"string\" ? src : staticSrc;\n    let isLazy = !priority && (loading === \"lazy\" || typeof loading === \"undefined\");\n    if (!src || src.startsWith(\"data:\") || src.startsWith(\"blob:\")) {\n        // https://developer.mozilla.org/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\n        unoptimized = true;\n        isLazy = false;\n    }\n    if (config.unoptimized) {\n        unoptimized = true;\n    }\n    if (isDefaultLoader && src.endsWith(\".svg\") && !config.dangerouslyAllowSVG) {\n        // Special case to make svg serve as-is to avoid proxying\n        // through the built-in Image Optimization API.\n        unoptimized = true;\n    }\n    if (priority) {\n        fetchPriority = \"high\";\n    }\n    const qualityInt = getInt(quality);\n    if (true) {\n        if (config.output === \"export\" && isDefaultLoader && !unoptimized) {\n            throw new Error(\"Image Optimization using the default loader is not compatible with `{ output: 'export' }`.\\n  Possible solutions:\\n    - Remove `{ output: 'export' }` and run \\\"next start\\\" to run server mode including the Image Optimization API.\\n    - Configure `{ images: { unoptimized: true } }` in `next.config.js` to disable the Image Optimization API.\\n  Read more: https://nextjs.org/docs/messages/export-image-api\");\n        }\n        if (!src) {\n            // React doesn't show the stack trace and there's\n            // no `src` to help identify which image, so we\n            // instead console.error(ref) during mount.\n            unoptimized = true;\n        } else {\n            if (fill) {\n                if (width) {\n                    throw new Error('Image with src \"' + src + '\" has both \"width\" and \"fill\" properties. Only one should be used.');\n                }\n                if (height) {\n                    throw new Error('Image with src \"' + src + '\" has both \"height\" and \"fill\" properties. Only one should be used.');\n                }\n                if ((style == null ? void 0 : style.position) && style.position !== \"absolute\") {\n                    throw new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.position\" properties. Images with \"fill\" always use position absolute - it cannot be modified.');\n                }\n                if ((style == null ? void 0 : style.width) && style.width !== \"100%\") {\n                    throw new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.width\" properties. Images with \"fill\" always use width 100% - it cannot be modified.');\n                }\n                if ((style == null ? void 0 : style.height) && style.height !== \"100%\") {\n                    throw new Error('Image with src \"' + src + '\" has both \"fill\" and \"style.height\" properties. Images with \"fill\" always use height 100% - it cannot be modified.');\n                }\n            } else {\n                if (typeof widthInt === \"undefined\") {\n                    throw new Error('Image with src \"' + src + '\" is missing required \"width\" property.');\n                } else if (isNaN(widthInt)) {\n                    throw new Error('Image with src \"' + src + '\" has invalid \"width\" property. Expected a numeric value in pixels but received \"' + width + '\".');\n                }\n                if (typeof heightInt === \"undefined\") {\n                    throw new Error('Image with src \"' + src + '\" is missing required \"height\" property.');\n                } else if (isNaN(heightInt)) {\n                    throw new Error('Image with src \"' + src + '\" has invalid \"height\" property. Expected a numeric value in pixels but received \"' + height + '\".');\n                }\n            }\n        }\n        if (!VALID_LOADING_VALUES.includes(loading)) {\n            throw new Error('Image with src \"' + src + '\" has invalid \"loading\" property. Provided \"' + loading + '\" should be one of ' + VALID_LOADING_VALUES.map(String).join(\",\") + \".\");\n        }\n        if (priority && loading === \"lazy\") {\n            throw new Error('Image with src \"' + src + '\" has both \"priority\" and \"loading=\\'lazy\\'\" properties. Only one should be used.');\n        }\n        if (placeholder !== \"empty\" && placeholder !== \"blur\" && !placeholder.startsWith(\"data:image/\")) {\n            throw new Error('Image with src \"' + src + '\" has invalid \"placeholder\" property \"' + placeholder + '\".');\n        }\n        if (placeholder !== \"empty\") {\n            if (widthInt && heightInt && widthInt * heightInt < 1600) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is smaller than 40x40. Consider removing the \"placeholder\" property to improve performance.');\n            }\n        }\n        if (placeholder === \"blur\" && !blurDataURL) {\n            const VALID_BLUR_EXT = [\n                \"jpeg\",\n                \"png\",\n                \"webp\",\n                \"avif\"\n            ] // should match next-image-loader\n            ;\n            throw new Error('Image with src \"' + src + '\" has \"placeholder=\\'blur\\'\" property but is missing the \"blurDataURL\" property.\\n        Possible solutions:\\n          - Add a \"blurDataURL\" property, the contents should be a small Data URL to represent the image\\n          - Change the \"src\" property to a static import with one of the supported file types: ' + VALID_BLUR_EXT.join(\",\") + ' (animated images not supported)\\n          - Remove the \"placeholder\" property, effectively no blur effect\\n        Read more: https://nextjs.org/docs/messages/placeholder-blur-data-url');\n        }\n        if (\"ref\" in rest) {\n            (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is using unsupported \"ref\" property. Consider using the \"onLoad\" property instead.');\n        }\n        if (!unoptimized && !isDefaultLoader) {\n            const urlStr = loader({\n                config,\n                src,\n                width: widthInt || 400,\n                quality: qualityInt || 75\n            });\n            let url;\n            try {\n                url = new URL(urlStr);\n            } catch (err) {}\n            if (urlStr === src || url && url.pathname === src && !url.search) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" has a \"loader\" property that does not implement width. Please implement it or use the \"unoptimized\" property instead.' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-missing-loader-width\");\n            }\n        }\n        if (onLoadingComplete) {\n            (0, _warnonce.warnOnce)('Image with src \"' + src + '\" is using deprecated \"onLoadingComplete\" property. Please use the \"onLoad\" property instead.');\n        }\n        for (const [legacyKey, legacyValue] of Object.entries({\n            layout,\n            objectFit,\n            objectPosition,\n            lazyBoundary,\n            lazyRoot\n        })){\n            if (legacyValue) {\n                (0, _warnonce.warnOnce)('Image with src \"' + src + '\" has legacy prop \"' + legacyKey + '\". Did you forget to run the codemod?' + \"\\nRead more: https://nextjs.org/docs/messages/next-image-upgrade-to-13\");\n            }\n        }\n        if ( true && !perfObserver && window.PerformanceObserver) {\n            perfObserver = new PerformanceObserver((entryList)=>{\n                for (const entry of entryList.getEntries()){\n                    var _entry_element;\n                    // @ts-ignore - missing \"LargestContentfulPaint\" class with \"element\" prop\n                    const imgSrc = (entry == null ? void 0 : (_entry_element = entry.element) == null ? void 0 : _entry_element.src) || \"\";\n                    const lcpImage = allImgs.get(imgSrc);\n                    if (lcpImage && !lcpImage.priority && lcpImage.placeholder === \"empty\" && !lcpImage.src.startsWith(\"data:\") && !lcpImage.src.startsWith(\"blob:\")) {\n                        // https://web.dev/lcp/#measure-lcp-in-javascript\n                        (0, _warnonce.warnOnce)('Image with src \"' + lcpImage.src + '\" was detected as the Largest Contentful Paint (LCP). Please add the \"priority\" property if this image is above the fold.' + \"\\nRead more: https://nextjs.org/docs/api-reference/next/image#priority\");\n                    }\n                }\n            });\n            try {\n                perfObserver.observe({\n                    type: \"largest-contentful-paint\",\n                    buffered: true\n                });\n            } catch (err) {\n                // Log error but don't crash the app\n                console.error(err);\n            }\n        }\n    }\n    const imgStyle = Object.assign(fill ? {\n        position: \"absolute\",\n        height: \"100%\",\n        width: \"100%\",\n        left: 0,\n        top: 0,\n        right: 0,\n        bottom: 0,\n        objectFit,\n        objectPosition\n    } : {}, showAltText ? {} : {\n        color: \"transparent\"\n    }, style);\n    const backgroundImage = !blurComplete && placeholder !== \"empty\" ? placeholder === \"blur\" ? 'url(\"data:image/svg+xml;charset=utf-8,' + (0, _imageblursvg.getImageBlurSvg)({\n        widthInt,\n        heightInt,\n        blurWidth,\n        blurHeight,\n        blurDataURL: blurDataURL || \"\",\n        objectFit: imgStyle.objectFit\n    }) + '\")' : 'url(\"' + placeholder + '\")' // assume `data:image/`\n     : null;\n    let placeholderStyle = backgroundImage ? {\n        backgroundSize: imgStyle.objectFit || \"cover\",\n        backgroundPosition: imgStyle.objectPosition || \"50% 50%\",\n        backgroundRepeat: \"no-repeat\",\n        backgroundImage\n    } : {};\n    if (true) {\n        if (placeholderStyle.backgroundImage && placeholder === \"blur\" && (blurDataURL == null ? void 0 : blurDataURL.startsWith(\"/\"))) {\n            // During `next dev`, we don't want to generate blur placeholders with webpack\n            // because it can delay starting the dev server. Instead, `next-image-loader.js`\n            // will inline a special url to lazily generate the blur placeholder at request time.\n            placeholderStyle.backgroundImage = 'url(\"' + blurDataURL + '\")';\n        }\n    }\n    const imgAttributes = generateImgAttrs({\n        config,\n        src,\n        unoptimized,\n        width: widthInt,\n        quality: qualityInt,\n        sizes,\n        loader\n    });\n    if (true) {\n        if (true) {\n            let fullUrl;\n            try {\n                fullUrl = new URL(imgAttributes.src);\n            } catch (e) {\n                fullUrl = new URL(imgAttributes.src, window.location.href);\n            }\n            allImgs.set(fullUrl.href, {\n                src,\n                priority,\n                placeholder\n            });\n        }\n    }\n    const props = {\n        ...rest,\n        loading: isLazy ? \"lazy\" : loading,\n        fetchPriority,\n        width: widthInt,\n        height: heightInt,\n        decoding: \"async\",\n        className,\n        style: {\n            ...imgStyle,\n            ...placeholderStyle\n        },\n        sizes: imgAttributes.sizes,\n        srcSet: imgAttributes.srcSet,\n        src: imgAttributes.src\n    };\n    const meta = {\n        unoptimized,\n        priority,\n        placeholder,\n        fill\n    };\n    return {\n        props,\n        meta\n    };\n} //# sourceMappingURL=get-img-props.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9nZXQtaW1nLXByb3BzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCwrQ0FBOEM7SUFDMUNJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQyxZQUFZQyxtQkFBT0EsQ0FBQyxxR0FBbUI7QUFDN0MsTUFBTUMsZ0JBQWdCRCxtQkFBT0EsQ0FBQyxtR0FBa0I7QUFDaEQsTUFBTUUsZUFBZUYsbUJBQU9BLENBQUMsK0ZBQWdCO0FBQzdDLE1BQU1HLHVCQUF1QjtJQUN6QjtJQUNBO0lBQ0FDO0NBQ0g7QUFDRCxTQUFTQyxnQkFBZ0JDLEdBQUc7SUFDeEIsT0FBT0EsSUFBSUMsT0FBTyxLQUFLSDtBQUMzQjtBQUNBLFNBQVNJLGtCQUFrQkYsR0FBRztJQUMxQixPQUFPQSxJQUFJQSxHQUFHLEtBQUtGO0FBQ3ZCO0FBQ0EsU0FBU0ssZUFBZUgsR0FBRztJQUN2QixPQUFPLE9BQU9BLFFBQVEsWUFBYUQsQ0FBQUEsZ0JBQWdCQyxRQUFRRSxrQkFBa0JGLElBQUc7QUFDcEY7QUFDQSxNQUFNSSxVQUFVLElBQUlDO0FBQ3BCLElBQUlDO0FBQ0osU0FBU0MsT0FBT0MsQ0FBQztJQUNiLElBQUksT0FBT0EsTUFBTSxhQUFhO1FBQzFCLE9BQU9BO0lBQ1g7SUFDQSxJQUFJLE9BQU9BLE1BQU0sVUFBVTtRQUN2QixPQUFPQyxPQUFPQyxRQUFRLENBQUNGLEtBQUtBLElBQUlHO0lBQ3BDO0lBQ0EsSUFBSSxPQUFPSCxNQUFNLFlBQVksV0FBV0ksSUFBSSxDQUFDSixJQUFJO1FBQzdDLE9BQU9LLFNBQVNMLEdBQUc7SUFDdkI7SUFDQSxPQUFPRztBQUNYO0FBQ0EsU0FBU0csVUFBVUMsS0FBSyxFQUFFQyxLQUFLLEVBQUVDLEtBQUs7SUFDbEMsSUFBSSxF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VXBGLGNBQWM7UUFDL0Q7SUFDSjtJQUNBLE1BQU0wRixnQkFBZ0I3RyxpQkFBaUI7UUFDbkNDO1FBQ0F2QztRQUNBd0M7UUFDQXhCLE9BQU95RTtRQUNQaEQsU0FBUzZEO1FBQ1RyRjtRQUNBeUI7SUFDSjtJQUNBLElBQUk2RCxJQUFxQyxFQUFFO1FBQ3ZDLElBQUksSUFBNkIsRUFBRTtZQUMvQixJQUFJNkM7WUFDSixJQUFJO2dCQUNBQSxVQUFVLElBQUluQyxJQUFJa0MsY0FBY25KLEdBQUc7WUFDdkMsRUFBRSxPQUFPcUosR0FBRztnQkFDUkQsVUFBVSxJQUFJbkMsSUFBSWtDLGNBQWNuSixHQUFHLEVBQUV3SCxPQUFPOEIsUUFBUSxDQUFDQyxJQUFJO1lBQzdEO1lBQ0FuSixRQUFRb0osR0FBRyxDQUFDSixRQUFRRyxJQUFJLEVBQUU7Z0JBQ3RCdko7Z0JBQ0FnRDtnQkFDQVE7WUFDSjtRQUNKO0lBQ0o7SUFDQSxNQUFNaUcsUUFBUTtRQUNWLEdBQUd6RixJQUFJO1FBQ1BmLFNBQVNpRCxTQUFTLFNBQVNqRDtRQUMzQlM7UUFDQTFDLE9BQU95RTtRQUNQdEMsUUFBUXVDO1FBQ1JnRSxVQUFVO1FBQ1Z4RztRQUNBRyxPQUFPO1lBQ0gsR0FBR2lGLFFBQVE7WUFDWCxHQUFHUyxnQkFBZ0I7UUFDdkI7UUFDQTlILE9BQU9rSSxjQUFjbEksS0FBSztRQUMxQjBCLFFBQVF3RyxjQUFjeEcsTUFBTTtRQUM1QjNDLEtBQUttSixjQUFjbkosR0FBRztJQUMxQjtJQUNBLE1BQU0ySixPQUFPO1FBQ1RuSDtRQUNBUTtRQUNBUTtRQUNBSjtJQUNKO0lBQ0EsT0FBTztRQUNIcUc7UUFDQUU7SUFDSjtBQUNKLEVBRUEseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9nZXQtaW1nLXByb3BzLmpzP2JiYWEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRJbWdQcm9wc1wiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0SW1nUHJvcHM7XG4gICAgfVxufSk7XG5jb25zdCBfd2Fybm9uY2UgPSByZXF1aXJlKFwiLi91dGlscy93YXJuLW9uY2VcIik7XG5jb25zdCBfaW1hZ2VibHVyc3ZnID0gcmVxdWlyZShcIi4vaW1hZ2UtYmx1ci1zdmdcIik7XG5jb25zdCBfaW1hZ2Vjb25maWcgPSByZXF1aXJlKFwiLi9pbWFnZS1jb25maWdcIik7XG5jb25zdCBWQUxJRF9MT0FESU5HX1ZBTFVFUyA9IFtcbiAgICBcImxhenlcIixcbiAgICBcImVhZ2VyXCIsXG4gICAgdW5kZWZpbmVkXG5dO1xuZnVuY3Rpb24gaXNTdGF0aWNSZXF1aXJlKHNyYykge1xuICAgIHJldHVybiBzcmMuZGVmYXVsdCAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gaXNTdGF0aWNJbWFnZURhdGEoc3JjKSB7XG4gICAgcmV0dXJuIHNyYy5zcmMgIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGlzU3RhdGljSW1wb3J0KHNyYykge1xuICAgIHJldHVybiB0eXBlb2Ygc3JjID09PSBcIm9iamVjdFwiICYmIChpc1N0YXRpY1JlcXVpcmUoc3JjKSB8fCBpc1N0YXRpY0ltYWdlRGF0YShzcmMpKTtcbn1cbmNvbnN0IGFsbEltZ3MgPSBuZXcgTWFwKCk7XG5sZXQgcGVyZk9ic2VydmVyO1xuZnVuY3Rpb24gZ2V0SW50KHgpIHtcbiAgICBpZiAodHlwZW9mIHggPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgeCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKHgpID8geCA6IE5hTjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB4ID09PSBcInN0cmluZ1wiICYmIC9eWzAtOV0rJC8udGVzdCh4KSkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoeCwgMTApO1xuICAgIH1cbiAgICByZXR1cm4gTmFOO1xufVxuZnVuY3Rpb24gZ2V0V2lkdGhzKHBhcmFtLCB3aWR0aCwgc2l6ZXMpIHtcbiAgICBsZXQgeyBkZXZpY2VTaXplcywgYWxsU2l6ZXMgfSA9IHBhcmFtO1xuICAgIGlmIChzaXplcykge1xuICAgICAgICAvLyBGaW5kIGFsbCB0aGUgXCJ2d1wiIHBlcmNlbnQgc2l6ZXMgdXNlZCBpbiB0aGUgc2l6ZXMgcHJvcFxuICAgICAgICBjb25zdCB2aWV3cG9ydFdpZHRoUmUgPSAvKF58XFxzKSgxP1xcZD9cXGQpdncvZztcbiAgICAgICAgY29uc3QgcGVyY2VudFNpemVzID0gW107XG4gICAgICAgIGZvcihsZXQgbWF0Y2g7IG1hdGNoID0gdmlld3BvcnRXaWR0aFJlLmV4ZWMoc2l6ZXMpOyBtYXRjaCl7XG4gICAgICAgICAgICBwZXJjZW50U2l6ZXMucHVzaChwYXJzZUludChtYXRjaFsyXSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwZXJjZW50U2l6ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBzbWFsbGVzdFJhdGlvID0gTWF0aC5taW4oLi4ucGVyY2VudFNpemVzKSAqIDAuMDE7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpZHRoczogYWxsU2l6ZXMuZmlsdGVyKChzKT0+cyA+PSBkZXZpY2VTaXplc1swXSAqIHNtYWxsZXN0UmF0aW8pLFxuICAgICAgICAgICAgICAgIGtpbmQ6IFwid1wiXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aHM6IGFsbFNpemVzLFxuICAgICAgICAgICAga2luZDogXCJ3XCJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB3aWR0aCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGhzOiBkZXZpY2VTaXplcyxcbiAgICAgICAgICAgIGtpbmQ6IFwid1wiXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHdpZHRocyA9IFtcbiAgICAgICAgLi4ubmV3IFNldCgvLyA+IFRoaXMgbWVhbnMgdGhhdCBtb3N0IE9MRUQgc2NyZWVucyB0aGF0IHNheSB0aGV5IGFyZSAzeCByZXNvbHV0aW9uLFxuICAgICAgICAvLyA+IGFyZSBhY3R1YWxseSAzeCBpbiB0aGUgZ3JlZW4gY29sb3IsIGJ1dCBvbmx5IDEuNXggaW4gdGhlIHJlZCBhbmRcbiAgICAgICAgLy8gPiBibHVlIGNvbG9ycy4gU2hvd2luZyBhIDN4IHJlc29sdXRpb24gaW1hZ2UgaW4gdGhlIGFwcCB2cyBhIDJ4XG4gICAgICAgIC8vID4gcmVzb2x1dGlvbiBpbWFnZSB3aWxsIGJlIHZpc3VhbGx5IHRoZSBzYW1lLCB0aG91Z2ggdGhlIDN4IGltYWdlXG4gICAgICAgIC8vID4gdGFrZXMgc2lnbmlmaWNhbnRseSBtb3JlIGRhdGEuIEV2ZW4gdHJ1ZSAzeCByZXNvbHV0aW9uIHNjcmVlbnMgYXJlXG4gICAgICAgIC8vID4gd2FzdGVmdWwgYXMgdGhlIGh1bWFuIGV5ZSBjYW5ub3Qgc2VlIHRoYXQgbGV2ZWwgb2YgZGV0YWlsIHdpdGhvdXRcbiAgICAgICAgLy8gPiBzb21ldGhpbmcgbGlrZSBhIG1hZ25pZnlpbmcgZ2xhc3MuXG4gICAgICAgIC8vIGh0dHBzOi8vYmxvZy50d2l0dGVyLmNvbS9lbmdpbmVlcmluZy9lbl91cy90b3BpY3MvaW5mcmFzdHJ1Y3R1cmUvMjAxOS9jYXBwaW5nLWltYWdlLWZpZGVsaXR5LW9uLXVsdHJhLWhpZ2gtcmVzb2x1dGlvbi1kZXZpY2VzLmh0bWxcbiAgICAgICAgW1xuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICB3aWR0aCAqIDIgLyosIHdpZHRoICogMyovIFxuICAgICAgICBdLm1hcCgodyk9PmFsbFNpemVzLmZpbmQoKHApPT5wID49IHcpIHx8IGFsbFNpemVzW2FsbFNpemVzLmxlbmd0aCAtIDFdKSlcbiAgICBdO1xuICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRocyxcbiAgICAgICAga2luZDogXCJ4XCJcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVJbWdBdHRycyhwYXJhbSkge1xuICAgIGxldCB7IGNvbmZpZywgc3JjLCB1bm9wdGltaXplZCwgd2lkdGgsIHF1YWxpdHksIHNpemVzLCBsb2FkZXIgfSA9IHBhcmFtO1xuICAgIGlmICh1bm9wdGltaXplZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3JjLFxuICAgICAgICAgICAgc3JjU2V0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzaXplczogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHsgd2lkdGhzLCBraW5kIH0gPSBnZXRXaWR0aHMoY29uZmlnLCB3aWR0aCwgc2l6ZXMpO1xuICAgIGNvbnN0IGxhc3QgPSB3aWR0aHMubGVuZ3RoIC0gMTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzaXplczogIXNpemVzICYmIGtpbmQgPT09IFwid1wiID8gXCIxMDB2d1wiIDogc2l6ZXMsXG4gICAgICAgIHNyY1NldDogd2lkdGhzLm1hcCgodywgaSk9PmxvYWRlcih7XG4gICAgICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgICAgICBxdWFsaXR5LFxuICAgICAgICAgICAgICAgIHdpZHRoOiB3XG4gICAgICAgICAgICB9KSArIFwiIFwiICsgKGtpbmQgPT09IFwid1wiID8gdyA6IGkgKyAxKSArIGtpbmQpLmpvaW4oXCIsIFwiKSxcbiAgICAgICAgLy8gSXQncyBpbnRlbmRlZCB0byBrZWVwIGBzcmNgIHRoZSBsYXN0IGF0dHJpYnV0ZSBiZWNhdXNlIFJlYWN0IHVwZGF0ZXNcbiAgICAgICAgLy8gYXR0cmlidXRlcyBpbiBvcmRlci4gSWYgd2Uga2VlcCBgc3JjYCB0aGUgZmlyc3Qgb25lLCBTYWZhcmkgd2lsbFxuICAgICAgICAvLyBpbW1lZGlhdGVseSBzdGFydCB0byBmZXRjaCBgc3JjYCwgYmVmb3JlIGBzaXplc2AgYW5kIGBzcmNTZXRgIGFyZSBldmVuXG4gICAgICAgIC8vIHVwZGF0ZWQgYnkgUmVhY3QuIFRoYXQgY2F1c2VzIG11bHRpcGxlIHVubmVjZXNzYXJ5IHJlcXVlc3RzIGlmIGBzcmNTZXRgXG4gICAgICAgIC8vIGFuZCBgc2l6ZXNgIGFyZSBkZWZpbmVkLlxuICAgICAgICAvLyBUaGlzIGJ1ZyBjYW5ub3QgYmUgcmVwcm9kdWNlZCBpbiBDaHJvbWUgb3IgRmlyZWZveC5cbiAgICAgICAgc3JjOiBsb2FkZXIoe1xuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgc3JjLFxuICAgICAgICAgICAgcXVhbGl0eSxcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aHNbbGFzdF1cbiAgICAgICAgfSlcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0SW1nUHJvcHMocGFyYW0sIF9zdGF0ZSkge1xuICAgIGxldCB7IHNyYywgc2l6ZXMsIHVub3B0aW1pemVkID0gZmFsc2UsIHByaW9yaXR5ID0gZmFsc2UsIGxvYWRpbmcsIGNsYXNzTmFtZSwgcXVhbGl0eSwgd2lkdGgsIGhlaWdodCwgZmlsbCA9IGZhbHNlLCBzdHlsZSwgb25Mb2FkLCBvbkxvYWRpbmdDb21wbGV0ZSwgcGxhY2Vob2xkZXIgPSBcImVtcHR5XCIsIGJsdXJEYXRhVVJMLCBmZXRjaFByaW9yaXR5LCBsYXlvdXQsIG9iamVjdEZpdCwgb2JqZWN0UG9zaXRpb24sIGxhenlCb3VuZGFyeSwgbGF6eVJvb3QsIC4uLnJlc3QgfSA9IHBhcmFtO1xuICAgIGNvbnN0IHsgaW1nQ29uZiwgc2hvd0FsdFRleHQsIGJsdXJDb21wbGV0ZSwgZGVmYXVsdExvYWRlciB9ID0gX3N0YXRlO1xuICAgIGxldCBjb25maWc7XG4gICAgbGV0IGMgPSBpbWdDb25mIHx8IF9pbWFnZWNvbmZpZy5pbWFnZUNvbmZpZ0RlZmF1bHQ7XG4gICAgaWYgKFwiYWxsU2l6ZXNcIiBpbiBjKSB7XG4gICAgICAgIGNvbmZpZyA9IGM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYWxsU2l6ZXMgPSBbXG4gICAgICAgICAgICAuLi5jLmRldmljZVNpemVzLFxuICAgICAgICAgICAgLi4uYy5pbWFnZVNpemVzXG4gICAgICAgIF0uc29ydCgoYSwgYik9PmEgLSBiKTtcbiAgICAgICAgY29uc3QgZGV2aWNlU2l6ZXMgPSBjLmRldmljZVNpemVzLnNvcnQoKGEsIGIpPT5hIC0gYik7XG4gICAgICAgIGNvbmZpZyA9IHtcbiAgICAgICAgICAgIC4uLmMsXG4gICAgICAgICAgICBhbGxTaXplcyxcbiAgICAgICAgICAgIGRldmljZVNpemVzXG4gICAgICAgIH07XG4gICAgfVxuICAgIGxldCBsb2FkZXIgPSByZXN0LmxvYWRlciB8fCBkZWZhdWx0TG9hZGVyO1xuICAgIC8vIFJlbW92ZSBwcm9wZXJ0eSBzbyBpdCdzIG5vdCBzcHJlYWQgb24gPGltZz4gZWxlbWVudFxuICAgIGRlbGV0ZSByZXN0LmxvYWRlcjtcbiAgICBkZWxldGUgcmVzdC5zcmNTZXQ7XG4gICAgLy8gVGhpcyBzcGVjaWFsIHZhbHVlIGluZGljYXRlcyB0aGF0IHRoZSB1c2VyXG4gICAgLy8gZGlkbid0IGRlZmluZSBhIFwibG9hZGVyXCIgcHJvcCBvciBcImxvYWRlclwiIGNvbmZpZy5cbiAgICBjb25zdCBpc0RlZmF1bHRMb2FkZXIgPSBcIl9fbmV4dF9pbWdfZGVmYXVsdFwiIGluIGxvYWRlcjtcbiAgICBpZiAoaXNEZWZhdWx0TG9hZGVyKSB7XG4gICAgICAgIGlmIChjb25maWcubG9hZGVyID09PSBcImN1c3RvbVwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIHdpdGggc3JjIFwiJyArIHNyYyArICdcIiBpcyBtaXNzaW5nIFwibG9hZGVyXCIgcHJvcC4nICsgXCJcXG5SZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25leHQtaW1hZ2UtbWlzc2luZy1sb2FkZXJcIik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGUgdXNlciBkZWZpbmVkIGEgXCJsb2FkZXJcIiBwcm9wIG9yIGNvbmZpZy5cbiAgICAgICAgLy8gU2luY2UgdGhlIGNvbmZpZyBvYmplY3QgaXMgaW50ZXJuYWwgb25seSwgd2VcbiAgICAgICAgLy8gbXVzdCBub3QgcGFzcyBpdCB0byB0aGUgdXNlci1kZWZpbmVkIFwibG9hZGVyXCIuXG4gICAgICAgIGNvbnN0IGN1c3RvbUltYWdlTG9hZGVyID0gbG9hZGVyO1xuICAgICAgICBsb2FkZXIgPSAob2JqKT0+e1xuICAgICAgICAgICAgY29uc3QgeyBjb25maWc6IF8sIC4uLm9wdHMgfSA9IG9iajtcbiAgICAgICAgICAgIHJldHVybiBjdXN0b21JbWFnZUxvYWRlcihvcHRzKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGxheW91dCkge1xuICAgICAgICBpZiAobGF5b3V0ID09PSBcImZpbGxcIikge1xuICAgICAgICAgICAgZmlsbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGF5b3V0VG9TdHlsZSA9IHtcbiAgICAgICAgICAgIGludHJpbnNpYzoge1xuICAgICAgICAgICAgICAgIG1heFdpZHRoOiBcIjEwMCVcIixcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiYXV0b1wiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzcG9uc2l2ZToge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBcIjEwMCVcIixcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiYXV0b1wiXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGxheW91dFRvU2l6ZXMgPSB7XG4gICAgICAgICAgICByZXNwb25zaXZlOiBcIjEwMHZ3XCIsXG4gICAgICAgICAgICBmaWxsOiBcIjEwMHZ3XCJcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbGF5b3V0U3R5bGUgPSBsYXlvdXRUb1N0eWxlW2xheW91dF07XG4gICAgICAgIGlmIChsYXlvdXRTdHlsZSkge1xuICAgICAgICAgICAgc3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgLi4uc3R5bGUsXG4gICAgICAgICAgICAgICAgLi4ubGF5b3V0U3R5bGVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGF5b3V0U2l6ZXMgPSBsYXlvdXRUb1NpemVzW2xheW91dF07XG4gICAgICAgIGlmIChsYXlvdXRTaXplcyAmJiAhc2l6ZXMpIHtcbiAgICAgICAgICAgIHNpemVzID0gbGF5b3V0U2l6ZXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHN0YXRpY1NyYyA9IFwiXCI7XG4gICAgbGV0IHdpZHRoSW50ID0gZ2V0SW50KHdpZHRoKTtcbiAgICBsZXQgaGVpZ2h0SW50ID0gZ2V0SW50KGhlaWdodCk7XG4gICAgbGV0IGJsdXJXaWR0aDtcbiAgICBsZXQgYmx1ckhlaWdodDtcbiAgICBpZiAoaXNTdGF0aWNJbXBvcnQoc3JjKSkge1xuICAgICAgICBjb25zdCBzdGF0aWNJbWFnZURhdGEgPSBpc1N0YXRpY1JlcXVpcmUoc3JjKSA/IHNyYy5kZWZhdWx0IDogc3JjO1xuICAgICAgICBpZiAoIXN0YXRpY0ltYWdlRGF0YS5zcmMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFuIG9iamVjdCBzaG91bGQgb25seSBiZSBwYXNzZWQgdG8gdGhlIGltYWdlIGNvbXBvbmVudCBzcmMgcGFyYW1ldGVyIGlmIGl0IGNvbWVzIGZyb20gYSBzdGF0aWMgaW1hZ2UgaW1wb3J0LiBJdCBtdXN0IGluY2x1ZGUgc3JjLiBSZWNlaXZlZCBcIiArIEpTT04uc3RyaW5naWZ5KHN0YXRpY0ltYWdlRGF0YSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3RhdGljSW1hZ2VEYXRhLmhlaWdodCB8fCAhc3RhdGljSW1hZ2VEYXRhLndpZHRoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBbiBvYmplY3Qgc2hvdWxkIG9ubHkgYmUgcGFzc2VkIHRvIHRoZSBpbWFnZSBjb21wb25lbnQgc3JjIHBhcmFtZXRlciBpZiBpdCBjb21lcyBmcm9tIGEgc3RhdGljIGltYWdlIGltcG9ydC4gSXQgbXVzdCBpbmNsdWRlIGhlaWdodCBhbmQgd2lkdGguIFJlY2VpdmVkIFwiICsgSlNPTi5zdHJpbmdpZnkoc3RhdGljSW1hZ2VEYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgYmx1cldpZHRoID0gc3RhdGljSW1hZ2VEYXRhLmJsdXJXaWR0aDtcbiAgICAgICAgYmx1ckhlaWdodCA9IHN0YXRpY0ltYWdlRGF0YS5ibHVySGVpZ2h0O1xuICAgICAgICBibHVyRGF0YVVSTCA9IGJsdXJEYXRhVVJMIHx8IHN0YXRpY0ltYWdlRGF0YS5ibHVyRGF0YVVSTDtcbiAgICAgICAgc3RhdGljU3JjID0gc3RhdGljSW1hZ2VEYXRhLnNyYztcbiAgICAgICAgaWYgKCFmaWxsKSB7XG4gICAgICAgICAgICBpZiAoIXdpZHRoSW50ICYmICFoZWlnaHRJbnQpIHtcbiAgICAgICAgICAgICAgICB3aWR0aEludCA9IHN0YXRpY0ltYWdlRGF0YS53aWR0aDtcbiAgICAgICAgICAgICAgICBoZWlnaHRJbnQgPSBzdGF0aWNJbWFnZURhdGEuaGVpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlIGlmICh3aWR0aEludCAmJiAhaGVpZ2h0SW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmF0aW8gPSB3aWR0aEludCAvIHN0YXRpY0ltYWdlRGF0YS53aWR0aDtcbiAgICAgICAgICAgICAgICBoZWlnaHRJbnQgPSBNYXRoLnJvdW5kKHN0YXRpY0ltYWdlRGF0YS5oZWlnaHQgKiByYXRpbyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF3aWR0aEludCAmJiBoZWlnaHRJbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByYXRpbyA9IGhlaWdodEludCAvIHN0YXRpY0ltYWdlRGF0YS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgd2lkdGhJbnQgPSBNYXRoLnJvdW5kKHN0YXRpY0ltYWdlRGF0YS53aWR0aCAqIHJhdGlvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzcmMgPSB0eXBlb2Ygc3JjID09PSBcInN0cmluZ1wiID8gc3JjIDogc3RhdGljU3JjO1xuICAgIGxldCBpc0xhenkgPSAhcHJpb3JpdHkgJiYgKGxvYWRpbmcgPT09IFwibGF6eVwiIHx8IHR5cGVvZiBsb2FkaW5nID09PSBcInVuZGVmaW5lZFwiKTtcbiAgICBpZiAoIXNyYyB8fCBzcmMuc3RhcnRzV2l0aChcImRhdGE6XCIpIHx8IHNyYy5zdGFydHNXaXRoKFwiYmxvYjpcIikpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSFRUUC9CYXNpY3Nfb2ZfSFRUUC9EYXRhX1VSSXNcbiAgICAgICAgdW5vcHRpbWl6ZWQgPSB0cnVlO1xuICAgICAgICBpc0xhenkgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy51bm9wdGltaXplZCkge1xuICAgICAgICB1bm9wdGltaXplZCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChpc0RlZmF1bHRMb2FkZXIgJiYgc3JjLmVuZHNXaXRoKFwiLnN2Z1wiKSAmJiAhY29uZmlnLmRhbmdlcm91c2x5QWxsb3dTVkcpIHtcbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlIHRvIG1ha2Ugc3ZnIHNlcnZlIGFzLWlzIHRvIGF2b2lkIHByb3h5aW5nXG4gICAgICAgIC8vIHRocm91Z2ggdGhlIGJ1aWx0LWluIEltYWdlIE9wdGltaXphdGlvbiBBUEkuXG4gICAgICAgIHVub3B0aW1pemVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHByaW9yaXR5KSB7XG4gICAgICAgIGZldGNoUHJpb3JpdHkgPSBcImhpZ2hcIjtcbiAgICB9XG4gICAgY29uc3QgcXVhbGl0eUludCA9IGdldEludChxdWFsaXR5KTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGlmIChjb25maWcub3V0cHV0ID09PSBcImV4cG9ydFwiICYmIGlzRGVmYXVsdExvYWRlciAmJiAhdW5vcHRpbWl6ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkltYWdlIE9wdGltaXphdGlvbiB1c2luZyB0aGUgZGVmYXVsdCBsb2FkZXIgaXMgbm90IGNvbXBhdGlibGUgd2l0aCBgeyBvdXRwdXQ6ICdleHBvcnQnIH1gLlxcbiAgUG9zc2libGUgc29sdXRpb25zOlxcbiAgICAtIFJlbW92ZSBgeyBvdXRwdXQ6ICdleHBvcnQnIH1gIGFuZCBydW4gXFxcIm5leHQgc3RhcnRcXFwiIHRvIHJ1biBzZXJ2ZXIgbW9kZSBpbmNsdWRpbmcgdGhlIEltYWdlIE9wdGltaXphdGlvbiBBUEkuXFxuICAgIC0gQ29uZmlndXJlIGB7IGltYWdlczogeyB1bm9wdGltaXplZDogdHJ1ZSB9IH1gIGluIGBuZXh0LmNvbmZpZy5qc2AgdG8gZGlzYWJsZSB0aGUgSW1hZ2UgT3B0aW1pemF0aW9uIEFQSS5cXG4gIFJlYWQgbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvZXhwb3J0LWltYWdlLWFwaVwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNyYykge1xuICAgICAgICAgICAgLy8gUmVhY3QgZG9lc24ndCBzaG93IHRoZSBzdGFjayB0cmFjZSBhbmQgdGhlcmUnc1xuICAgICAgICAgICAgLy8gbm8gYHNyY2AgdG8gaGVscCBpZGVudGlmeSB3aGljaCBpbWFnZSwgc28gd2VcbiAgICAgICAgICAgIC8vIGluc3RlYWQgY29uc29sZS5lcnJvcihyZWYpIGR1cmluZyBtb3VudC5cbiAgICAgICAgICAgIHVub3B0aW1pemVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmaWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2Ugd2l0aCBzcmMgXCInICsgc3JjICsgJ1wiIGhhcyBib3RoIFwid2lkdGhcIiBhbmQgXCJmaWxsXCIgcHJvcGVydGllcy4gT25seSBvbmUgc2hvdWxkIGJlIHVzZWQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSB3aXRoIHNyYyBcIicgKyBzcmMgKyAnXCIgaGFzIGJvdGggXCJoZWlnaHRcIiBhbmQgXCJmaWxsXCIgcHJvcGVydGllcy4gT25seSBvbmUgc2hvdWxkIGJlIHVzZWQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgoc3R5bGUgPT0gbnVsbCA/IHZvaWQgMCA6IHN0eWxlLnBvc2l0aW9uKSAmJiBzdHlsZS5wb3NpdGlvbiAhPT0gXCJhYnNvbHV0ZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2Ugd2l0aCBzcmMgXCInICsgc3JjICsgJ1wiIGhhcyBib3RoIFwiZmlsbFwiIGFuZCBcInN0eWxlLnBvc2l0aW9uXCIgcHJvcGVydGllcy4gSW1hZ2VzIHdpdGggXCJmaWxsXCIgYWx3YXlzIHVzZSBwb3NpdGlvbiBhYnNvbHV0ZSAtIGl0IGNhbm5vdCBiZSBtb2RpZmllZC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChzdHlsZSA9PSBudWxsID8gdm9pZCAwIDogc3R5bGUud2lkdGgpICYmIHN0eWxlLndpZHRoICE9PSBcIjEwMCVcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIHdpdGggc3JjIFwiJyArIHNyYyArICdcIiBoYXMgYm90aCBcImZpbGxcIiBhbmQgXCJzdHlsZS53aWR0aFwiIHByb3BlcnRpZXMuIEltYWdlcyB3aXRoIFwiZmlsbFwiIGFsd2F5cyB1c2Ugd2lkdGggMTAwJSAtIGl0IGNhbm5vdCBiZSBtb2RpZmllZC4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKChzdHlsZSA9PSBudWxsID8gdm9pZCAwIDogc3R5bGUuaGVpZ2h0KSAmJiBzdHlsZS5oZWlnaHQgIT09IFwiMTAwJVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2Ugd2l0aCBzcmMgXCInICsgc3JjICsgJ1wiIGhhcyBib3RoIFwiZmlsbFwiIGFuZCBcInN0eWxlLmhlaWdodFwiIHByb3BlcnRpZXMuIEltYWdlcyB3aXRoIFwiZmlsbFwiIGFsd2F5cyB1c2UgaGVpZ2h0IDEwMCUgLSBpdCBjYW5ub3QgYmUgbW9kaWZpZWQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHdpZHRoSW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2Ugd2l0aCBzcmMgXCInICsgc3JjICsgJ1wiIGlzIG1pc3NpbmcgcmVxdWlyZWQgXCJ3aWR0aFwiIHByb3BlcnR5LicpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNOYU4od2lkdGhJbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2Ugd2l0aCBzcmMgXCInICsgc3JjICsgJ1wiIGhhcyBpbnZhbGlkIFwid2lkdGhcIiBwcm9wZXJ0eS4gRXhwZWN0ZWQgYSBudW1lcmljIHZhbHVlIGluIHBpeGVscyBidXQgcmVjZWl2ZWQgXCInICsgd2lkdGggKyAnXCIuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaGVpZ2h0SW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2Ugd2l0aCBzcmMgXCInICsgc3JjICsgJ1wiIGlzIG1pc3NpbmcgcmVxdWlyZWQgXCJoZWlnaHRcIiBwcm9wZXJ0eS4nKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlzTmFOKGhlaWdodEludCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSB3aXRoIHNyYyBcIicgKyBzcmMgKyAnXCIgaGFzIGludmFsaWQgXCJoZWlnaHRcIiBwcm9wZXJ0eS4gRXhwZWN0ZWQgYSBudW1lcmljIHZhbHVlIGluIHBpeGVscyBidXQgcmVjZWl2ZWQgXCInICsgaGVpZ2h0ICsgJ1wiLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIVZBTElEX0xPQURJTkdfVkFMVUVTLmluY2x1ZGVzKGxvYWRpbmcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIHdpdGggc3JjIFwiJyArIHNyYyArICdcIiBoYXMgaW52YWxpZCBcImxvYWRpbmdcIiBwcm9wZXJ0eS4gUHJvdmlkZWQgXCInICsgbG9hZGluZyArICdcIiBzaG91bGQgYmUgb25lIG9mICcgKyBWQUxJRF9MT0FESU5HX1ZBTFVFUy5tYXAoU3RyaW5nKS5qb2luKFwiLFwiKSArIFwiLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJpb3JpdHkgJiYgbG9hZGluZyA9PT0gXCJsYXp5XCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW1hZ2Ugd2l0aCBzcmMgXCInICsgc3JjICsgJ1wiIGhhcyBib3RoIFwicHJpb3JpdHlcIiBhbmQgXCJsb2FkaW5nPVxcJ2xhenlcXCdcIiBwcm9wZXJ0aWVzLiBPbmx5IG9uZSBzaG91bGQgYmUgdXNlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGxhY2Vob2xkZXIgIT09IFwiZW1wdHlcIiAmJiBwbGFjZWhvbGRlciAhPT0gXCJibHVyXCIgJiYgIXBsYWNlaG9sZGVyLnN0YXJ0c1dpdGgoXCJkYXRhOmltYWdlL1wiKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbWFnZSB3aXRoIHNyYyBcIicgKyBzcmMgKyAnXCIgaGFzIGludmFsaWQgXCJwbGFjZWhvbGRlclwiIHByb3BlcnR5IFwiJyArIHBsYWNlaG9sZGVyICsgJ1wiLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwbGFjZWhvbGRlciAhPT0gXCJlbXB0eVwiKSB7XG4gICAgICAgICAgICBpZiAod2lkdGhJbnQgJiYgaGVpZ2h0SW50ICYmIHdpZHRoSW50ICogaGVpZ2h0SW50IDwgMTYwMCkge1xuICAgICAgICAgICAgICAgICgwLCBfd2Fybm9uY2Uud2Fybk9uY2UpKCdJbWFnZSB3aXRoIHNyYyBcIicgKyBzcmMgKyAnXCIgaXMgc21hbGxlciB0aGFuIDQweDQwLiBDb25zaWRlciByZW1vdmluZyB0aGUgXCJwbGFjZWhvbGRlclwiIHByb3BlcnR5IHRvIGltcHJvdmUgcGVyZm9ybWFuY2UuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBsYWNlaG9sZGVyID09PSBcImJsdXJcIiAmJiAhYmx1ckRhdGFVUkwpIHtcbiAgICAgICAgICAgIGNvbnN0IFZBTElEX0JMVVJfRVhUID0gW1xuICAgICAgICAgICAgICAgIFwianBlZ1wiLFxuICAgICAgICAgICAgICAgIFwicG5nXCIsXG4gICAgICAgICAgICAgICAgXCJ3ZWJwXCIsXG4gICAgICAgICAgICAgICAgXCJhdmlmXCJcbiAgICAgICAgICAgIF0gLy8gc2hvdWxkIG1hdGNoIG5leHQtaW1hZ2UtbG9hZGVyXG4gICAgICAgICAgICA7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ltYWdlIHdpdGggc3JjIFwiJyArIHNyYyArICdcIiBoYXMgXCJwbGFjZWhvbGRlcj1cXCdibHVyXFwnXCIgcHJvcGVydHkgYnV0IGlzIG1pc3NpbmcgdGhlIFwiYmx1ckRhdGFVUkxcIiBwcm9wZXJ0eS5cXG4gICAgICAgIFBvc3NpYmxlIHNvbHV0aW9uczpcXG4gICAgICAgICAgLSBBZGQgYSBcImJsdXJEYXRhVVJMXCIgcHJvcGVydHksIHRoZSBjb250ZW50cyBzaG91bGQgYmUgYSBzbWFsbCBEYXRhIFVSTCB0byByZXByZXNlbnQgdGhlIGltYWdlXFxuICAgICAgICAgIC0gQ2hhbmdlIHRoZSBcInNyY1wiIHByb3BlcnR5IHRvIGEgc3RhdGljIGltcG9ydCB3aXRoIG9uZSBvZiB0aGUgc3VwcG9ydGVkIGZpbGUgdHlwZXM6ICcgKyBWQUxJRF9CTFVSX0VYVC5qb2luKFwiLFwiKSArICcgKGFuaW1hdGVkIGltYWdlcyBub3Qgc3VwcG9ydGVkKVxcbiAgICAgICAgICAtIFJlbW92ZSB0aGUgXCJwbGFjZWhvbGRlclwiIHByb3BlcnR5LCBlZmZlY3RpdmVseSBubyBibHVyIGVmZmVjdFxcbiAgICAgICAgUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9wbGFjZWhvbGRlci1ibHVyLWRhdGEtdXJsJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwicmVmXCIgaW4gcmVzdCkge1xuICAgICAgICAgICAgKDAsIF93YXJub25jZS53YXJuT25jZSkoJ0ltYWdlIHdpdGggc3JjIFwiJyArIHNyYyArICdcIiBpcyB1c2luZyB1bnN1cHBvcnRlZCBcInJlZlwiIHByb3BlcnR5LiBDb25zaWRlciB1c2luZyB0aGUgXCJvbkxvYWRcIiBwcm9wZXJ0eSBpbnN0ZWFkLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdW5vcHRpbWl6ZWQgJiYgIWlzRGVmYXVsdExvYWRlcikge1xuICAgICAgICAgICAgY29uc3QgdXJsU3RyID0gbG9hZGVyKHtcbiAgICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgICAgc3JjLFxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aEludCB8fCA0MDAsXG4gICAgICAgICAgICAgICAgcXVhbGl0eTogcXVhbGl0eUludCB8fCA3NVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgdXJsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB1cmwgPSBuZXcgVVJMKHVybFN0cik7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgICAgICBpZiAodXJsU3RyID09PSBzcmMgfHwgdXJsICYmIHVybC5wYXRobmFtZSA9PT0gc3JjICYmICF1cmwuc2VhcmNoKSB7XG4gICAgICAgICAgICAgICAgKDAsIF93YXJub25jZS53YXJuT25jZSkoJ0ltYWdlIHdpdGggc3JjIFwiJyArIHNyYyArICdcIiBoYXMgYSBcImxvYWRlclwiIHByb3BlcnR5IHRoYXQgZG9lcyBub3QgaW1wbGVtZW50IHdpZHRoLiBQbGVhc2UgaW1wbGVtZW50IGl0IG9yIHVzZSB0aGUgXCJ1bm9wdGltaXplZFwiIHByb3BlcnR5IGluc3RlYWQuJyArIFwiXFxuUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LWltYWdlLW1pc3NpbmctbG9hZGVyLXdpZHRoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvbkxvYWRpbmdDb21wbGV0ZSkge1xuICAgICAgICAgICAgKDAsIF93YXJub25jZS53YXJuT25jZSkoJ0ltYWdlIHdpdGggc3JjIFwiJyArIHNyYyArICdcIiBpcyB1c2luZyBkZXByZWNhdGVkIFwib25Mb2FkaW5nQ29tcGxldGVcIiBwcm9wZXJ0eS4gUGxlYXNlIHVzZSB0aGUgXCJvbkxvYWRcIiBwcm9wZXJ0eSBpbnN0ZWFkLicpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW2xlZ2FjeUtleSwgbGVnYWN5VmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHtcbiAgICAgICAgICAgIGxheW91dCxcbiAgICAgICAgICAgIG9iamVjdEZpdCxcbiAgICAgICAgICAgIG9iamVjdFBvc2l0aW9uLFxuICAgICAgICAgICAgbGF6eUJvdW5kYXJ5LFxuICAgICAgICAgICAgbGF6eVJvb3RcbiAgICAgICAgfSkpe1xuICAgICAgICAgICAgaWYgKGxlZ2FjeVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgKDAsIF93YXJub25jZS53YXJuT25jZSkoJ0ltYWdlIHdpdGggc3JjIFwiJyArIHNyYyArICdcIiBoYXMgbGVnYWN5IHByb3AgXCInICsgbGVnYWN5S2V5ICsgJ1wiLiBEaWQgeW91IGZvcmdldCB0byBydW4gdGhlIGNvZGVtb2Q/JyArIFwiXFxuUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LWltYWdlLXVwZ3JhZGUtdG8tMTNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgIXBlcmZPYnNlcnZlciAmJiB3aW5kb3cuUGVyZm9ybWFuY2VPYnNlcnZlcikge1xuICAgICAgICAgICAgcGVyZk9ic2VydmVyID0gbmV3IFBlcmZvcm1hbmNlT2JzZXJ2ZXIoKGVudHJ5TGlzdCk9PntcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJ5TGlzdC5nZXRFbnRyaWVzKCkpe1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2VudHJ5X2VsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgLSBtaXNzaW5nIFwiTGFyZ2VzdENvbnRlbnRmdWxQYWludFwiIGNsYXNzIHdpdGggXCJlbGVtZW50XCIgcHJvcFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbWdTcmMgPSAoZW50cnkgPT0gbnVsbCA/IHZvaWQgMCA6IChfZW50cnlfZWxlbWVudCA9IGVudHJ5LmVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZW50cnlfZWxlbWVudC5zcmMpIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxjcEltYWdlID0gYWxsSW1ncy5nZXQoaW1nU3JjKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxjcEltYWdlICYmICFsY3BJbWFnZS5wcmlvcml0eSAmJiBsY3BJbWFnZS5wbGFjZWhvbGRlciA9PT0gXCJlbXB0eVwiICYmICFsY3BJbWFnZS5zcmMuc3RhcnRzV2l0aChcImRhdGE6XCIpICYmICFsY3BJbWFnZS5zcmMuc3RhcnRzV2l0aChcImJsb2I6XCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL3dlYi5kZXYvbGNwLyNtZWFzdXJlLWxjcC1pbi1qYXZhc2NyaXB0XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgX3dhcm5vbmNlLndhcm5PbmNlKSgnSW1hZ2Ugd2l0aCBzcmMgXCInICsgbGNwSW1hZ2Uuc3JjICsgJ1wiIHdhcyBkZXRlY3RlZCBhcyB0aGUgTGFyZ2VzdCBDb250ZW50ZnVsIFBhaW50IChMQ1ApLiBQbGVhc2UgYWRkIHRoZSBcInByaW9yaXR5XCIgcHJvcGVydHkgaWYgdGhpcyBpbWFnZSBpcyBhYm92ZSB0aGUgZm9sZC4nICsgXCJcXG5SZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwaS1yZWZlcmVuY2UvbmV4dC9pbWFnZSNwcmlvcml0eVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwZXJmT2JzZXJ2ZXIub2JzZXJ2ZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibGFyZ2VzdC1jb250ZW50ZnVsLXBhaW50XCIsXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcmVkOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBMb2cgZXJyb3IgYnV0IGRvbid0IGNyYXNoIHRoZSBhcHBcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaW1nU3R5bGUgPSBPYmplY3QuYXNzaWduKGZpbGwgPyB7XG4gICAgICAgIHBvc2l0aW9uOiBcImFic29sdXRlXCIsXG4gICAgICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgICAgIHdpZHRoOiBcIjEwMCVcIixcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICByaWdodDogMCxcbiAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICBvYmplY3RGaXQsXG4gICAgICAgIG9iamVjdFBvc2l0aW9uXG4gICAgfSA6IHt9LCBzaG93QWx0VGV4dCA/IHt9IDoge1xuICAgICAgICBjb2xvcjogXCJ0cmFuc3BhcmVudFwiXG4gICAgfSwgc3R5bGUpO1xuICAgIGNvbnN0IGJhY2tncm91bmRJbWFnZSA9ICFibHVyQ29tcGxldGUgJiYgcGxhY2Vob2xkZXIgIT09IFwiZW1wdHlcIiA/IHBsYWNlaG9sZGVyID09PSBcImJsdXJcIiA/ICd1cmwoXCJkYXRhOmltYWdlL3N2Zyt4bWw7Y2hhcnNldD11dGYtOCwnICsgKDAsIF9pbWFnZWJsdXJzdmcuZ2V0SW1hZ2VCbHVyU3ZnKSh7XG4gICAgICAgIHdpZHRoSW50LFxuICAgICAgICBoZWlnaHRJbnQsXG4gICAgICAgIGJsdXJXaWR0aCxcbiAgICAgICAgYmx1ckhlaWdodCxcbiAgICAgICAgYmx1ckRhdGFVUkw6IGJsdXJEYXRhVVJMIHx8IFwiXCIsXG4gICAgICAgIG9iamVjdEZpdDogaW1nU3R5bGUub2JqZWN0Rml0XG4gICAgfSkgKyAnXCIpJyA6ICd1cmwoXCInICsgcGxhY2Vob2xkZXIgKyAnXCIpJyAvLyBhc3N1bWUgYGRhdGE6aW1hZ2UvYFxuICAgICA6IG51bGw7XG4gICAgbGV0IHBsYWNlaG9sZGVyU3R5bGUgPSBiYWNrZ3JvdW5kSW1hZ2UgPyB7XG4gICAgICAgIGJhY2tncm91bmRTaXplOiBpbWdTdHlsZS5vYmplY3RGaXQgfHwgXCJjb3ZlclwiLFxuICAgICAgICBiYWNrZ3JvdW5kUG9zaXRpb246IGltZ1N0eWxlLm9iamVjdFBvc2l0aW9uIHx8IFwiNTAlIDUwJVwiLFxuICAgICAgICBiYWNrZ3JvdW5kUmVwZWF0OiBcIm5vLXJlcGVhdFwiLFxuICAgICAgICBiYWNrZ3JvdW5kSW1hZ2VcbiAgICB9IDoge307XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcbiAgICAgICAgaWYgKHBsYWNlaG9sZGVyU3R5bGUuYmFja2dyb3VuZEltYWdlICYmIHBsYWNlaG9sZGVyID09PSBcImJsdXJcIiAmJiAoYmx1ckRhdGFVUkwgPT0gbnVsbCA/IHZvaWQgMCA6IGJsdXJEYXRhVVJMLnN0YXJ0c1dpdGgoXCIvXCIpKSkge1xuICAgICAgICAgICAgLy8gRHVyaW5nIGBuZXh0IGRldmAsIHdlIGRvbid0IHdhbnQgdG8gZ2VuZXJhdGUgYmx1ciBwbGFjZWhvbGRlcnMgd2l0aCB3ZWJwYWNrXG4gICAgICAgICAgICAvLyBiZWNhdXNlIGl0IGNhbiBkZWxheSBzdGFydGluZyB0aGUgZGV2IHNlcnZlci4gSW5zdGVhZCwgYG5leHQtaW1hZ2UtbG9hZGVyLmpzYFxuICAgICAgICAgICAgLy8gd2lsbCBpbmxpbmUgYSBzcGVjaWFsIHVybCB0byBsYXppbHkgZ2VuZXJhdGUgdGhlIGJsdXIgcGxhY2Vob2xkZXIgYXQgcmVxdWVzdCB0aW1lLlxuICAgICAgICAgICAgcGxhY2Vob2xkZXJTdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSAndXJsKFwiJyArIGJsdXJEYXRhVVJMICsgJ1wiKSc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaW1nQXR0cmlidXRlcyA9IGdlbmVyYXRlSW1nQXR0cnMoe1xuICAgICAgICBjb25maWcsXG4gICAgICAgIHNyYyxcbiAgICAgICAgdW5vcHRpbWl6ZWQsXG4gICAgICAgIHdpZHRoOiB3aWR0aEludCxcbiAgICAgICAgcXVhbGl0eTogcXVhbGl0eUludCxcbiAgICAgICAgc2l6ZXMsXG4gICAgICAgIGxvYWRlclxuICAgIH0pO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIGxldCBmdWxsVXJsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmdWxsVXJsID0gbmV3IFVSTChpbWdBdHRyaWJ1dGVzLnNyYyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZnVsbFVybCA9IG5ldyBVUkwoaW1nQXR0cmlidXRlcy5zcmMsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFsbEltZ3Muc2V0KGZ1bGxVcmwuaHJlZiwge1xuICAgICAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgICAgICBwcmlvcml0eSxcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcHJvcHMgPSB7XG4gICAgICAgIC4uLnJlc3QsXG4gICAgICAgIGxvYWRpbmc6IGlzTGF6eSA/IFwibGF6eVwiIDogbG9hZGluZyxcbiAgICAgICAgZmV0Y2hQcmlvcml0eSxcbiAgICAgICAgd2lkdGg6IHdpZHRoSW50LFxuICAgICAgICBoZWlnaHQ6IGhlaWdodEludCxcbiAgICAgICAgZGVjb2Rpbmc6IFwiYXN5bmNcIixcbiAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgLi4uaW1nU3R5bGUsXG4gICAgICAgICAgICAuLi5wbGFjZWhvbGRlclN0eWxlXG4gICAgICAgIH0sXG4gICAgICAgIHNpemVzOiBpbWdBdHRyaWJ1dGVzLnNpemVzLFxuICAgICAgICBzcmNTZXQ6IGltZ0F0dHJpYnV0ZXMuc3JjU2V0LFxuICAgICAgICBzcmM6IGltZ0F0dHJpYnV0ZXMuc3JjXG4gICAgfTtcbiAgICBjb25zdCBtZXRhID0ge1xuICAgICAgICB1bm9wdGltaXplZCxcbiAgICAgICAgcHJpb3JpdHksXG4gICAgICAgIHBsYWNlaG9sZGVyLFxuICAgICAgICBmaWxsXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9wcyxcbiAgICAgICAgbWV0YVxuICAgIH07XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldC1pbWctcHJvcHMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsImdldEltZ1Byb3BzIiwiX3dhcm5vbmNlIiwicmVxdWlyZSIsIl9pbWFnZWJsdXJzdmciLCJfaW1hZ2Vjb25maWciLCJWQUxJRF9MT0FESU5HX1ZBTFVFUyIsInVuZGVmaW5lZCIsImlzU3RhdGljUmVxdWlyZSIsInNyYyIsImRlZmF1bHQiLCJpc1N0YXRpY0ltYWdlRGF0YSIsImlzU3RhdGljSW1wb3J0IiwiYWxsSW1ncyIsIk1hcCIsInBlcmZPYnNlcnZlciIsImdldEludCIsIngiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsIk5hTiIsInRlc3QiLCJwYXJzZUludCIsImdldFdpZHRocyIsInBhcmFtIiwid2lkdGgiLCJzaXplcyIsImRldmljZVNpemVzIiwiYWxsU2l6ZXMiLCJ2aWV3cG9ydFdpZHRoUmUiLCJwZXJjZW50U2l6ZXMiLCJtYXRjaCIsImV4ZWMiLCJwdXNoIiwibGVuZ3RoIiwic21hbGxlc3RSYXRpbyIsIk1hdGgiLCJtaW4iLCJ3aWR0aHMiLCJmaWx0ZXIiLCJzIiwia2luZCIsIlNldCIsIm1hcCIsInciLCJmaW5kIiwicCIsImdlbmVyYXRlSW1nQXR0cnMiLCJjb25maWciLCJ1bm9wdGltaXplZCIsInF1YWxpdHkiLCJsb2FkZXIiLCJzcmNTZXQiLCJsYXN0IiwiaSIsImpvaW4iLCJfc3RhdGUiLCJwcmlvcml0eSIsImxvYWRpbmciLCJjbGFzc05hbWUiLCJoZWlnaHQiLCJmaWxsIiwic3R5bGUiLCJvbkxvYWQiLCJvbkxvYWRpbmdDb21wbGV0ZSIsInBsYWNlaG9sZGVyIiwiYmx1ckRhdGFVUkwiLCJmZXRjaFByaW9yaXR5IiwibGF5b3V0Iiwib2JqZWN0Rml0Iiwib2JqZWN0UG9zaXRpb24iLCJsYXp5Qm91bmRhcnkiLCJsYXp5Um9vdCIsInJlc3QiLCJpbWdDb25mIiwic2hvd0FsdFRleHQiLCJibHVyQ29tcGxldGUiLCJkZWZhdWx0TG9hZGVyIiwiYyIsImltYWdlQ29uZmlnRGVmYXVsdCIsImltYWdlU2l6ZXMiLCJzb3J0IiwiYSIsImIiLCJpc0RlZmF1bHRMb2FkZXIiLCJFcnJvciIsImN1c3RvbUltYWdlTG9hZGVyIiwib2JqIiwiXyIsIm9wdHMiLCJsYXlvdXRUb1N0eWxlIiwiaW50cmluc2ljIiwibWF4V2lkdGgiLCJyZXNwb25zaXZlIiwibGF5b3V0VG9TaXplcyIsImxheW91dFN0eWxlIiwibGF5b3V0U2l6ZXMiLCJzdGF0aWNTcmMiLCJ3aWR0aEludCIsImhlaWdodEludCIsImJsdXJXaWR0aCIsImJsdXJIZWlnaHQiLCJzdGF0aWNJbWFnZURhdGEiLCJKU09OIiwic3RyaW5naWZ5IiwicmF0aW8iLCJyb3VuZCIsImlzTGF6eSIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsImRhbmdlcm91c2x5QWxsb3dTVkciLCJxdWFsaXR5SW50IiwicHJvY2VzcyIsIm91dHB1dCIsInBvc2l0aW9uIiwiaXNOYU4iLCJpbmNsdWRlcyIsIlN0cmluZyIsIndhcm5PbmNlIiwiVkFMSURfQkxVUl9FWFQiLCJ1cmxTdHIiLCJ1cmwiLCJVUkwiLCJlcnIiLCJwYXRobmFtZSIsInNlYXJjaCIsImxlZ2FjeUtleSIsImxlZ2FjeVZhbHVlIiwiZW50cmllcyIsIndpbmRvdyIsIlBlcmZvcm1hbmNlT2JzZXJ2ZXIiLCJlbnRyeUxpc3QiLCJlbnRyeSIsImdldEVudHJpZXMiLCJfZW50cnlfZWxlbWVudCIsImltZ1NyYyIsImVsZW1lbnQiLCJsY3BJbWFnZSIsIm9ic2VydmUiLCJ0eXBlIiwiYnVmZmVyZWQiLCJjb25zb2xlIiwiZXJyb3IiLCJpbWdTdHlsZSIsImFzc2lnbiIsImxlZnQiLCJ0b3AiLCJyaWdodCIsImJvdHRvbSIsImNvbG9yIiwiYmFja2dyb3VuZEltYWdlIiwiZ2V0SW1hZ2VCbHVyU3ZnIiwicGxhY2Vob2xkZXJTdHlsZSIsImJhY2tncm91bmRTaXplIiwiYmFja2dyb3VuZFBvc2l0aW9uIiwiYmFja2dyb3VuZFJlcGVhdCIsImltZ0F0dHJpYnV0ZXMiLCJmdWxsVXJsIiwiZSIsImxvY2F0aW9uIiwiaHJlZiIsInNldCIsInByb3BzIiwiZGVjb2RpbmciLCJtZXRhIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/get-img-props.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/head.js":
/*!***************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/head.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    defaultHead: function() {\n        return defaultHead;\n    },\n    default: function() {\n        return _default;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _sideeffect = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./side-effect */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/side-effect.js\"));\nconst _ampcontextsharedruntime = __webpack_require__(/*! ./amp-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-context.shared-runtime.js\");\nconst _headmanagercontextsharedruntime = __webpack_require__(/*! ./head-manager-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js\");\nconst _ampmode = __webpack_require__(/*! ./amp-mode */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/amp-mode.js\");\nconst _warnonce = __webpack_require__(/*! ./utils/warn-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nfunction defaultHead(inAmpMode) {\n    if (inAmpMode === void 0) inAmpMode = false;\n    const head = [\n        /*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n            charSet: \"utf-8\"\n        })\n    ];\n    if (!inAmpMode) {\n        head.push(/*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n            name: \"viewport\",\n            content: \"width=device-width\"\n        }));\n    }\n    return head;\n}\nfunction onlyReactElement(list, child) {\n    // React children can be \"string\" or \"number\" in this case we ignore them for backwards compat\n    if (typeof child === \"string\" || typeof child === \"number\") {\n        return list;\n    }\n    // Adds support for React.Fragment\n    if (child.type === _react.default.Fragment) {\n        return list.concat(_react.default.Children.toArray(child.props.children).reduce((fragmentList, fragmentChild)=>{\n            if (typeof fragmentChild === \"string\" || typeof fragmentChild === \"number\") {\n                return fragmentList;\n            }\n            return fragmentList.concat(fragmentChild);\n        }, []));\n    }\n    return list.concat(child);\n}\nconst METATYPES = [\n    \"name\",\n    \"httpEquiv\",\n    \"charSet\",\n    \"itemProp\"\n];\n/*\n returns a function for filtering head child elements\n which shouldn't be duplicated, like <title/>\n Also adds support for deduplicated `key` properties\n*/ function unique() {\n    const keys = new Set();\n    const tags = new Set();\n    const metaTypes = new Set();\n    const metaCategories = {};\n    return (h)=>{\n        let isUnique = true;\n        let hasKey = false;\n        if (h.key && typeof h.key !== \"number\" && h.key.indexOf(\"$\") > 0) {\n            hasKey = true;\n            const key = h.key.slice(h.key.indexOf(\"$\") + 1);\n            if (keys.has(key)) {\n                isUnique = false;\n            } else {\n                keys.add(key);\n            }\n        }\n        // eslint-disable-next-line default-case\n        switch(h.type){\n            case \"title\":\n            case \"base\":\n                if (tags.has(h.type)) {\n                    isUnique = false;\n                } else {\n                    tags.add(h.type);\n                }\n                break;\n            case \"meta\":\n                for(let i = 0, len = METATYPES.length; i < len; i++){\n                    const metatype = METATYPES[i];\n                    if (!h.props.hasOwnProperty(metatype)) continue;\n                    if (metatype === \"charSet\") {\n                        if (metaTypes.has(metatype)) {\n                            isUnique = false;\n                        } else {\n                            metaTypes.add(metatype);\n                        }\n                    } else {\n                        const category = h.props[metatype];\n                        const categories = metaCategories[metatype] || new Set();\n                        if ((metatype !== \"name\" || !hasKey) && categories.has(category)) {\n                            isUnique = false;\n                        } else {\n                            categories.add(category);\n                            metaCategories[metatype] = categories;\n                        }\n                    }\n                }\n                break;\n        }\n        return isUnique;\n    };\n}\n/**\n *\n * @param headChildrenElements List of children of <Head>\n */ function reduceComponents(headChildrenElements, props) {\n    const { inAmpMode } = props;\n    return headChildrenElements.reduce(onlyReactElement, []).reverse().concat(defaultHead(inAmpMode).reverse()).filter(unique()).reverse().map((c, i)=>{\n        const key = c.key || i;\n        if (false) {}\n        if (true) {\n            // omit JSON-LD structured data snippets from the warning\n            if (c.type === \"script\" && c.props[\"type\"] !== \"application/ld+json\") {\n                const srcMessage = c.props[\"src\"] ? '<script> tag with src=\"' + c.props[\"src\"] + '\"' : \"inline <script>\";\n                (0, _warnonce.warnOnce)(\"Do not add <script> tags using next/head (see \" + srcMessage + \"). Use next/script instead. \\nSee more info here: https://nextjs.org/docs/messages/no-script-tags-in-head-component\");\n            } else if (c.type === \"link\" && c.props[\"rel\"] === \"stylesheet\") {\n                (0, _warnonce.warnOnce)('Do not add stylesheets using next/head (see <link rel=\"stylesheet\"> tag with href=\"' + c.props[\"href\"] + '\"). Use Document instead. \\nSee more info here: https://nextjs.org/docs/messages/no-stylesheets-in-head-component');\n            }\n        }\n        return /*#__PURE__*/ _react.default.cloneElement(c, {\n            key\n        });\n    });\n}\n/**\n * This component injects elements to `<head>` of your page.\n * To avoid duplicated `tags` in `<head>` you can use the `key` property, which will make sure every tag is only rendered once.\n */ function Head(param) {\n    let { children } = param;\n    const ampState = (0, _react.useContext)(_ampcontextsharedruntime.AmpStateContext);\n    const headManager = (0, _react.useContext)(_headmanagercontextsharedruntime.HeadManagerContext);\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_sideeffect.default, {\n        reduceComponentsToState: reduceComponents,\n        headManager: headManager,\n        inAmpMode: (0, _ampmode.isInAmpMode)(ampState),\n        children: children\n    });\n}\n_c = Head;\nconst _default = Head;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=head.js.map\nvar _c;\n$RefreshReg$(_c, \"Head\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9oZWFkLmpzIiwibWFwcGluZ3MiOiJxREFFYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQUdOO0FBQ0EsU0FBU0csUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSVQsT0FBT0MsY0FBYyxDQUFDTyxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFMLFNBQVM7SUFDYkcsYUFBYTtRQUNULE9BQU9BO0lBQ1g7SUFDQUMsU0FBUztRQUNMLE9BQU9PO0lBQ1g7QUFDSjtBQUNBLE1BQU1DLDJCQUEyQkMsbUJBQU9BLENBQUMsZ0lBQXlDO0FBQ2xGLE1BQU1DLDRCQUE0QkQsbUJBQU9BLENBQUMsa0lBQTBDO0FBQ3BGLE1BQU1FLGNBQWNGLG1CQUFPQSxDQUFDLHFHQUFtQjtBQUMvQyxNQUFNRyxTQUFTLFdBQVcsR0FBR0YsMEJBQTBCRyxDQUFDLENBQUNKLG1CQUFPQSxDQUFDLG1GQUFPO0FBQ3hFLE1BQU1LLGNBQWMsV0FBVyxHQUFHTix5QkFBeUJLLENBQUMsQ0FBQ0osbUJBQU9BLENBQUMsNkZBQWU7QUFDcEYsTUFBTU0sMkJBQTJCTixtQkFBT0EsQ0FBQywySEFBOEI7QUFDdkUsTUFBTU8sbUNBQW1DUCxtQkFBT0EsQ0FBQyw2SUFBdUM7QUFDeEYsTUFBTVEsV0FBV1IsbUJBQU9BLENBQUMsdUZBQVk7QUFDckMsTUFBTVMsWUFBWVQsbUJBQU9BLENBQUMscUdBQW1CO0FBQzdDLFNBQVNWLFlBQVlvQixTQUFTO0lBQzFCLElBQUlBLGNBQWMsS0FBSyxHQUFHQSxZQUFZO0lBQ3RDLE1BQU1DLE9BQU87UUFDVCxXQUFXLEdBQUksSUFBR1QsWUFBWVUsR0FBRyxFQUFFLFFBQVE7WUFDdkND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VSxFQUFFakUseUJBQXlCa0UsZUFBZTtJQUNoRixNQUFNQyxjQUFjLENBQUMsR0FBR3RFLE9BQU9vRSxVQUFVLEVBQUVoRSxpQ0FBaUNtRSxrQkFBa0I7SUFDOUYsT0FBcUIsV0FBSCxHQUFJLElBQUd4RSxZQUFZVSxHQUFHLEVBQUVQLFlBQVlkLE9BQU8sRUFBRTtRQUMzRG9GLHlCQUF5QnhCO1FBQ3pCc0IsYUFBYUE7UUFDYi9ELFdBQVcsQ0FBQyxHQUFHRixTQUFTb0UsV0FBVyxFQUFFTjtRQUNyQzdDLFVBQVVBO0lBQ2Q7QUFDSjtLQVZhMkM7QUFXYixNQUFNdEUsV0FBV3NFO0FBRWpCLElBQUksQ0FBQyxPQUFPakYsUUFBUUksT0FBTyxLQUFLLGNBQWUsT0FBT0osUUFBUUksT0FBTyxLQUFLLFlBQVlKLFFBQVFJLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT0osUUFBUUksT0FBTyxDQUFDc0YsVUFBVSxLQUFLLGFBQWE7SUFDcks1RixPQUFPQyxjQUFjLENBQUNDLFFBQVFJLE9BQU8sRUFBRSxjQUFjO1FBQUVILE9BQU87SUFBSztJQUNuRUgsT0FBTzZGLE1BQU0sQ0FBQzNGLFFBQVFJLE9BQU8sRUFBRUo7SUFDL0JFLE9BQU9GLE9BQU8sR0FBR0EsUUFBUUksT0FBTztBQUNsQyxFQUVBLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvaGVhZC5qcz9mYjVkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIGRlZmF1bHRIZWFkOiBudWxsLFxuICAgIGRlZmF1bHQ6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgZGVmYXVsdEhlYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZGVmYXVsdEhlYWQ7XG4gICAgfSxcbiAgICBkZWZhdWx0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9kZWZhdWx0O1xuICAgIH1cbn0pO1xuY29uc3QgX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9fL19pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdFwiKTtcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZFwiKTtcbmNvbnN0IF9qc3hydW50aW1lID0gcmVxdWlyZShcInJlYWN0L2pzeC1ydW50aW1lXCIpO1xuY29uc3QgX3JlYWN0ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLl8ocmVxdWlyZShcInJlYWN0XCIpKTtcbmNvbnN0IF9zaWRlZWZmZWN0ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwiLi9zaWRlLWVmZmVjdFwiKSk7XG5jb25zdCBfYW1wY29udGV4dHNoYXJlZHJ1bnRpbWUgPSByZXF1aXJlKFwiLi9hbXAtY29udGV4dC5zaGFyZWQtcnVudGltZVwiKTtcbmNvbnN0IF9oZWFkbWFuYWdlcmNvbnRleHRzaGFyZWRydW50aW1lID0gcmVxdWlyZShcIi4vaGVhZC1tYW5hZ2VyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWVcIik7XG5jb25zdCBfYW1wbW9kZSA9IHJlcXVpcmUoXCIuL2FtcC1tb2RlXCIpO1xuY29uc3QgX3dhcm5vbmNlID0gcmVxdWlyZShcIi4vdXRpbHMvd2Fybi1vbmNlXCIpO1xuZnVuY3Rpb24gZGVmYXVsdEhlYWQoaW5BbXBNb2RlKSB7XG4gICAgaWYgKGluQW1wTW9kZSA9PT0gdm9pZCAwKSBpbkFtcE1vZGUgPSBmYWxzZTtcbiAgICBjb25zdCBoZWFkID0gW1xuICAgICAgICAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3gpKFwibWV0YVwiLCB7XG4gICAgICAgICAgICBjaGFyU2V0OiBcInV0Zi04XCJcbiAgICAgICAgfSlcbiAgICBdO1xuICAgIGlmICghaW5BbXBNb2RlKSB7XG4gICAgICAgIGhlYWQucHVzaCgvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3gpKFwibWV0YVwiLCB7XG4gICAgICAgICAgICBuYW1lOiBcInZpZXdwb3J0XCIsXG4gICAgICAgICAgICBjb250ZW50OiBcIndpZHRoPWRldmljZS13aWR0aFwiXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGhlYWQ7XG59XG5mdW5jdGlvbiBvbmx5UmVhY3RFbGVtZW50KGxpc3QsIGNoaWxkKSB7XG4gICAgLy8gUmVhY3QgY2hpbGRyZW4gY2FuIGJlIFwic3RyaW5nXCIgb3IgXCJudW1iZXJcIiBpbiB0aGlzIGNhc2Ugd2UgaWdub3JlIHRoZW0gZm9yIGJhY2t3YXJkcyBjb21wYXRcbiAgICBpZiAodHlwZW9mIGNoaWxkID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBjaGlsZCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG4gICAgLy8gQWRkcyBzdXBwb3J0IGZvciBSZWFjdC5GcmFnbWVudFxuICAgIGlmIChjaGlsZC50eXBlID09PSBfcmVhY3QuZGVmYXVsdC5GcmFnbWVudCkge1xuICAgICAgICByZXR1cm4gbGlzdC5jb25jYXQoLy8gQHRzLWV4cGVjdC1lcnJvciBAdHlwZXMvcmVhY3QgZG9lcyBub3QgcmVtb3ZlIGZyYWdtZW50cyBidXQgdGhpcyBjb3VsZCBhbHNvIHJldHVybiBSZWFjdFBvcnRhbFtdXG4gICAgICAgIF9yZWFjdC5kZWZhdWx0LkNoaWxkcmVuLnRvQXJyYXkoY2hpbGQucHJvcHMuY2hpbGRyZW4pLnJlZHVjZSgvLyBAdHMtZXhwZWN0LWVycm9yIEB0eXBlcy9yZWFjdCBkb2VzIG5vdCByZW1vdmUgZnJhZ21lbnRzIGJ1dCB0aGlzIGNvdWxkIGFsc28gcmV0dXJuIFJlYWN0UG9ydGFsW11cbiAgICAgICAgKGZyYWdtZW50TGlzdCwgZnJhZ21lbnRDaGlsZCk9PntcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZnJhZ21lbnRDaGlsZCA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgZnJhZ21lbnRDaGlsZCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmcmFnbWVudExpc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnJhZ21lbnRMaXN0LmNvbmNhdChmcmFnbWVudENoaWxkKTtcbiAgICAgICAgfSwgW10pKTtcbiAgICB9XG4gICAgcmV0dXJuIGxpc3QuY29uY2F0KGNoaWxkKTtcbn1cbmNvbnN0IE1FVEFUWVBFUyA9IFtcbiAgICBcIm5hbWVcIixcbiAgICBcImh0dHBFcXVpdlwiLFxuICAgIFwiY2hhclNldFwiLFxuICAgIFwiaXRlbVByb3BcIlxuXTtcbi8qXG4gcmV0dXJucyBhIGZ1bmN0aW9uIGZvciBmaWx0ZXJpbmcgaGVhZCBjaGlsZCBlbGVtZW50c1xuIHdoaWNoIHNob3VsZG4ndCBiZSBkdXBsaWNhdGVkLCBsaWtlIDx0aXRsZS8+XG4gQWxzbyBhZGRzIHN1cHBvcnQgZm9yIGRlZHVwbGljYXRlZCBga2V5YCBwcm9wZXJ0aWVzXG4qLyBmdW5jdGlvbiB1bmlxdWUoKSB7XG4gICAgY29uc3Qga2V5cyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCB0YWdzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IG1ldGFUeXBlcyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBtZXRhQ2F0ZWdvcmllcyA9IHt9O1xuICAgIHJldHVybiAoaCk9PntcbiAgICAgICAgbGV0IGlzVW5pcXVlID0gdHJ1ZTtcbiAgICAgICAgbGV0IGhhc0tleSA9IGZhbHNlO1xuICAgICAgICBpZiAoaC5rZXkgJiYgdHlwZW9mIGgua2V5ICE9PSBcIm51bWJlclwiICYmIGgua2V5LmluZGV4T2YoXCIkXCIpID4gMCkge1xuICAgICAgICAgICAgaGFzS2V5ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGgua2V5LnNsaWNlKGgua2V5LmluZGV4T2YoXCIkXCIpICsgMSk7XG4gICAgICAgICAgICBpZiAoa2V5cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGlzVW5pcXVlID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGtleXMuYWRkKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGRlZmF1bHQtY2FzZVxuICAgICAgICBzd2l0Y2goaC50eXBlKXtcbiAgICAgICAgICAgIGNhc2UgXCJ0aXRsZVwiOlxuICAgICAgICAgICAgY2FzZSBcImJhc2VcIjpcbiAgICAgICAgICAgICAgICBpZiAodGFncy5oYXMoaC50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBpc1VuaXF1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhZ3MuYWRkKGgudHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm1ldGFcIjpcbiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwLCBsZW4gPSBNRVRBVFlQRVMubGVuZ3RoOyBpIDwgbGVuOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXRhdHlwZSA9IE1FVEFUWVBFU1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFoLnByb3BzLmhhc093blByb3BlcnR5KG1ldGF0eXBlKSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXRhdHlwZSA9PT0gXCJjaGFyU2V0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRhVHlwZXMuaGFzKG1ldGF0eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzVW5pcXVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFUeXBlcy5hZGQobWV0YXR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2F0ZWdvcnkgPSBoLnByb3BzW21ldGF0eXBlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhdGVnb3JpZXMgPSBtZXRhQ2F0ZWdvcmllc1ttZXRhdHlwZV0gfHwgbmV3IFNldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChtZXRhdHlwZSAhPT0gXCJuYW1lXCIgfHwgIWhhc0tleSkgJiYgY2F0ZWdvcmllcy5oYXMoY2F0ZWdvcnkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNVbmlxdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcmllcy5hZGQoY2F0ZWdvcnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFDYXRlZ29yaWVzW21ldGF0eXBlXSA9IGNhdGVnb3JpZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzVW5pcXVlO1xuICAgIH07XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gaGVhZENoaWxkcmVuRWxlbWVudHMgTGlzdCBvZiBjaGlsZHJlbiBvZiA8SGVhZD5cbiAqLyBmdW5jdGlvbiByZWR1Y2VDb21wb25lbnRzKGhlYWRDaGlsZHJlbkVsZW1lbnRzLCBwcm9wcykge1xuICAgIGNvbnN0IHsgaW5BbXBNb2RlIH0gPSBwcm9wcztcbiAgICByZXR1cm4gaGVhZENoaWxkcmVuRWxlbWVudHMucmVkdWNlKG9ubHlSZWFjdEVsZW1lbnQsIFtdKS5yZXZlcnNlKCkuY29uY2F0KGRlZmF1bHRIZWFkKGluQW1wTW9kZSkucmV2ZXJzZSgpKS5maWx0ZXIodW5pcXVlKCkpLnJldmVyc2UoKS5tYXAoKGMsIGkpPT57XG4gICAgICAgIGNvbnN0IGtleSA9IGMua2V5IHx8IGk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJkZXZlbG9wbWVudFwiICYmIHByb2Nlc3MuZW52Ll9fTkVYVF9PUFRJTUlaRV9GT05UUyAmJiAhaW5BbXBNb2RlKSB7XG4gICAgICAgICAgICBpZiAoYy50eXBlID09PSBcImxpbmtcIiAmJiBjLnByb3BzW1wiaHJlZlwiXSAmJiAvLyBUT0RPKHByYXRlZWtiaEApOiBSZXBsYWNlIHRoaXMgd2l0aCBjb25zdCBmcm9tIGBjb25zdGFudHNgIHdoZW4gdGhlIHRyZWUgc2hha2luZyB3b3Jrcy5cbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICBcImh0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzXCIsXG4gICAgICAgICAgICAgICAgXCJodHRwczovL3VzZS50eXBla2l0Lm5ldC9cIlxuICAgICAgICAgICAgXS5zb21lKCh1cmwpPT5jLnByb3BzW1wiaHJlZlwiXS5zdGFydHNXaXRoKHVybCkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3UHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmMucHJvcHMgfHwge31cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG5ld1Byb3BzW1wiZGF0YS1ocmVmXCJdID0gbmV3UHJvcHNbXCJocmVmXCJdO1xuICAgICAgICAgICAgICAgIG5ld1Byb3BzW1wiaHJlZlwiXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhpcyBhdHRyaWJ1dGUgdG8gbWFrZSBpdCBlYXN5IHRvIGlkZW50aWZ5IG9wdGltaXplZCB0YWdzXG4gICAgICAgICAgICAgICAgbmV3UHJvcHNbXCJkYXRhLW9wdGltaXplZC1mb250c1wiXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY2xvbmVFbGVtZW50KGMsIG5ld1Byb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgICAgICAgLy8gb21pdCBKU09OLUxEIHN0cnVjdHVyZWQgZGF0YSBzbmlwcGV0cyBmcm9tIHRoZSB3YXJuaW5nXG4gICAgICAgICAgICBpZiAoYy50eXBlID09PSBcInNjcmlwdFwiICYmIGMucHJvcHNbXCJ0eXBlXCJdICE9PSBcImFwcGxpY2F0aW9uL2xkK2pzb25cIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNyY01lc3NhZ2UgPSBjLnByb3BzW1wic3JjXCJdID8gJzxzY3JpcHQ+IHRhZyB3aXRoIHNyYz1cIicgKyBjLnByb3BzW1wic3JjXCJdICsgJ1wiJyA6IFwiaW5saW5lIDxzY3JpcHQ+XCI7XG4gICAgICAgICAgICAgICAgKDAsIF93YXJub25jZS53YXJuT25jZSkoXCJEbyBub3QgYWRkIDxzY3JpcHQ+IHRhZ3MgdXNpbmcgbmV4dC9oZWFkIChzZWUgXCIgKyBzcmNNZXNzYWdlICsgXCIpLiBVc2UgbmV4dC9zY3JpcHQgaW5zdGVhZC4gXFxuU2VlIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uby1zY3JpcHQtdGFncy1pbi1oZWFkLWNvbXBvbmVudFwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYy50eXBlID09PSBcImxpbmtcIiAmJiBjLnByb3BzW1wicmVsXCJdID09PSBcInN0eWxlc2hlZXRcIikge1xuICAgICAgICAgICAgICAgICgwLCBfd2Fybm9uY2Uud2Fybk9uY2UpKCdEbyBub3QgYWRkIHN0eWxlc2hlZXRzIHVzaW5nIG5leHQvaGVhZCAoc2VlIDxsaW5rIHJlbD1cInN0eWxlc2hlZXRcIj4gdGFnIHdpdGggaHJlZj1cIicgKyBjLnByb3BzW1wiaHJlZlwiXSArICdcIikuIFVzZSBEb2N1bWVudCBpbnN0ZWFkLiBcXG5TZWUgbW9yZSBpbmZvIGhlcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL25vLXN0eWxlc2hlZXRzLWluLWhlYWQtY29tcG9uZW50Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY2xvbmVFbGVtZW50KGMsIHtcbiAgICAgICAgICAgIGtleVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbi8qKlxuICogVGhpcyBjb21wb25lbnQgaW5qZWN0cyBlbGVtZW50cyB0byBgPGhlYWQ+YCBvZiB5b3VyIHBhZ2UuXG4gKiBUbyBhdm9pZCBkdXBsaWNhdGVkIGB0YWdzYCBpbiBgPGhlYWQ+YCB5b3UgY2FuIHVzZSB0aGUgYGtleWAgcHJvcGVydHksIHdoaWNoIHdpbGwgbWFrZSBzdXJlIGV2ZXJ5IHRhZyBpcyBvbmx5IHJlbmRlcmVkIG9uY2UuXG4gKi8gZnVuY3Rpb24gSGVhZChwYXJhbSkge1xuICAgIGxldCB7IGNoaWxkcmVuIH0gPSBwYXJhbTtcbiAgICBjb25zdCBhbXBTdGF0ZSA9ICgwLCBfcmVhY3QudXNlQ29udGV4dCkoX2FtcGNvbnRleHRzaGFyZWRydW50aW1lLkFtcFN0YXRlQ29udGV4dCk7XG4gICAgY29uc3QgaGVhZE1hbmFnZXIgPSAoMCwgX3JlYWN0LnVzZUNvbnRleHQpKF9oZWFkbWFuYWdlcmNvbnRleHRzaGFyZWRydW50aW1lLkhlYWRNYW5hZ2VyQ29udGV4dCk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoX3NpZGVlZmZlY3QuZGVmYXVsdCwge1xuICAgICAgICByZWR1Y2VDb21wb25lbnRzVG9TdGF0ZTogcmVkdWNlQ29tcG9uZW50cyxcbiAgICAgICAgaGVhZE1hbmFnZXI6IGhlYWRNYW5hZ2VyLFxuICAgICAgICBpbkFtcE1vZGU6ICgwLCBfYW1wbW9kZS5pc0luQW1wTW9kZSkoYW1wU3RhdGUpLFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICB9KTtcbn1cbmNvbnN0IF9kZWZhdWx0ID0gSGVhZDtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVhZC5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJkZWZhdWx0SGVhZCIsImRlZmF1bHQiLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJfZGVmYXVsdCIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkIiwiX2pzeHJ1bnRpbWUiLCJfcmVhY3QiLCJfIiwiX3NpZGVlZmZlY3QiLCJfYW1wY29udGV4dHNoYXJlZHJ1bnRpbWUiLCJfaGVhZG1hbmFnZXJjb250ZXh0c2hhcmVkcnVudGltZSIsIl9hbXBtb2RlIiwiX3dhcm5vbmNlIiwiaW5BbXBNb2RlIiwiaGVhZCIsImpzeCIsImNoYXJTZXQiLCJwdXNoIiwiY29udGVudCIsIm9ubHlSZWFjdEVsZW1lbnQiLCJsaXN0IiwiY2hpbGQiLCJ0eXBlIiwiRnJhZ21lbnQiLCJjb25jYXQiLCJDaGlsZHJlbiIsInRvQXJyYXkiLCJwcm9wcyIsImNoaWxkcmVuIiwicmVkdWNlIiwiZnJhZ21lbnRMaXN0IiwiZnJhZ21lbnRDaGlsZCIsIk1FVEFUWVBFUyIsInVuaXF1ZSIsImtleXMiLCJTZXQiLCJ0YWdzIiwibWV0YVR5cGVzIiwibWV0YUNhdGVnb3JpZXMiLCJoIiwiaXNVbmlxdWUiLCJoYXNLZXkiLCJrZXkiLCJpbmRleE9mIiwic2xpY2UiLCJoYXMiLCJhZGQiLCJpIiwibGVuIiwibGVuZ3RoIiwibWV0YXR5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhdGVnb3J5IiwiY2F0ZWdvcmllcyIsInJlZHVjZUNvbXBvbmVudHMiLCJoZWFkQ2hpbGRyZW5FbGVtZW50cyIsInJldmVyc2UiLCJmaWx0ZXIiLCJtYXAiLCJjIiwicHJvY2VzcyIsImVudiIsIl9fTkVYVF9PUFRJTUlaRV9GT05UUyIsInNvbWUiLCJ1cmwiLCJzdGFydHNXaXRoIiwibmV3UHJvcHMiLCJ1bmRlZmluZWQiLCJjbG9uZUVsZW1lbnQiLCJzcmNNZXNzYWdlIiwid2Fybk9uY2UiLCJIZWFkIiwicGFyYW0iLCJhbXBTdGF0ZSIsInVzZUNvbnRleHQiLCJBbXBTdGF0ZUNvbnRleHQiLCJoZWFkTWFuYWdlciIsIkhlYWRNYW5hZ2VyQ29udGV4dCIsInJlZHVjZUNvbXBvbmVudHNUb1N0YXRlIiwiaXNJbkFtcE1vZGUiLCJfX2VzTW9kdWxlIiwiYXNzaWduIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/head.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-blur-svg.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-blur-svg.js ***!
  \*************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * A shared function, used on both client and server, to generate a SVG blur placeholder.\n */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getImageBlurSvg\", ({\n    enumerable: true,\n    get: function() {\n        return getImageBlurSvg;\n    }\n}));\nfunction getImageBlurSvg(param) {\n    let { widthInt, heightInt, blurWidth, blurHeight, blurDataURL, objectFit } = param;\n    const std = 20;\n    const svgWidth = blurWidth ? blurWidth * 40 : widthInt;\n    const svgHeight = blurHeight ? blurHeight * 40 : heightInt;\n    const viewBox = svgWidth && svgHeight ? \"viewBox='0 0 \" + svgWidth + \" \" + svgHeight + \"'\" : \"\";\n    const preserveAspectRatio = viewBox ? \"none\" : objectFit === \"contain\" ? \"xMidYMid\" : objectFit === \"cover\" ? \"xMidYMid slice\" : \"none\";\n    return \"%3Csvg xmlns='http://www.w3.org/2000/svg' \" + viewBox + \"%3E%3Cfilter id='b' color-interpolation-filters='sRGB'%3E%3CfeGaussianBlur stdDeviation='\" + std + \"'/%3E%3CfeColorMatrix values='1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 100 -1' result='s'/%3E%3CfeFlood x='0' y='0' width='100%25' height='100%25'/%3E%3CfeComposite operator='out' in='s'/%3E%3CfeComposite in2='SourceGraphic'/%3E%3CfeGaussianBlur stdDeviation='\" + std + \"'/%3E%3C/filter%3E%3Cimage width='100%25' height='100%25' x='0' y='0' preserveAspectRatio='\" + preserveAspectRatio + \"' style='filter: url(%23b);' href='\" + blurDataURL + \"'/%3E%3C/svg%3E\";\n} //# sourceMappingURL=image-blur-svg.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1ibHVyLXN2Zy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Q0FFQyxHQUFnQjtBQUNqQkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILG1EQUFrRDtJQUM5Q0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLFNBQVNBLGdCQUFnQkMsS0FBSztJQUMxQixJQUFJLEVBQUVDLFFBQVEsRUFBRUMsU0FBUyxFQUFFQyxTQUFTLEVBQUVDLFVBQVUsRUFBRUMsV0FBVyxFQUFFQyxTQUFTLEVBQUUsR0FBR047SUFDN0UsTUFBTU8sTUFBTTtJQUNaLE1BQU1DLFdBQVdMLFlBQVlBLFlBQVksS0FBS0Y7SUFDOUMsTUFBTVEsWUFBWUwsYUFBYUEsYUFBYSxLQUFLRjtJQUNqRCxNQUFNUSxVQUFVRixZQUFZQyxZQUFZLGtCQUFrQkQsV0FBVyxNQUFNQyxZQUFZLE1BQU07SUFDN0YsTUFBTUUsc0JBQXNCRCxVQUFVLFNBQVNKLGNBQWMsWUFBWSxhQUFhQSxjQUFjLFVBQVUsbUJBQW1CO0lBQ2pJLE9BQU8sK0NBQStDSSxVQUFVLDhGQUE4RkgsTUFBTSxvUUFBb1FBLE1BQU0sZ0dBQWdHSSxzQkFBc0Isd0NBQXdDTixjQUFjO0FBQzlsQixFQUVBLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvaW1hZ2UtYmx1ci1zdmcuanM/OTU3MCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEEgc2hhcmVkIGZ1bmN0aW9uLCB1c2VkIG9uIGJvdGggY2xpZW50IGFuZCBzZXJ2ZXIsIHRvIGdlbmVyYXRlIGEgU1ZHIGJsdXIgcGxhY2Vob2xkZXIuXG4gKi8gXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRJbWFnZUJsdXJTdmdcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGdldEltYWdlQmx1clN2ZztcbiAgICB9XG59KTtcbmZ1bmN0aW9uIGdldEltYWdlQmx1clN2ZyhwYXJhbSkge1xuICAgIGxldCB7IHdpZHRoSW50LCBoZWlnaHRJbnQsIGJsdXJXaWR0aCwgYmx1ckhlaWdodCwgYmx1ckRhdGFVUkwsIG9iamVjdEZpdCB9ID0gcGFyYW07XG4gICAgY29uc3Qgc3RkID0gMjA7XG4gICAgY29uc3Qgc3ZnV2lkdGggPSBibHVyV2lkdGggPyBibHVyV2lkdGggKiA0MCA6IHdpZHRoSW50O1xuICAgIGNvbnN0IHN2Z0hlaWdodCA9IGJsdXJIZWlnaHQgPyBibHVySGVpZ2h0ICogNDAgOiBoZWlnaHRJbnQ7XG4gICAgY29uc3Qgdmlld0JveCA9IHN2Z1dpZHRoICYmIHN2Z0hlaWdodCA/IFwidmlld0JveD0nMCAwIFwiICsgc3ZnV2lkdGggKyBcIiBcIiArIHN2Z0hlaWdodCArIFwiJ1wiIDogXCJcIjtcbiAgICBjb25zdCBwcmVzZXJ2ZUFzcGVjdFJhdGlvID0gdmlld0JveCA/IFwibm9uZVwiIDogb2JqZWN0Rml0ID09PSBcImNvbnRhaW5cIiA/IFwieE1pZFlNaWRcIiA6IG9iamVjdEZpdCA9PT0gXCJjb3ZlclwiID8gXCJ4TWlkWU1pZCBzbGljZVwiIDogXCJub25lXCI7XG4gICAgcmV0dXJuIFwiJTNDc3ZnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycgXCIgKyB2aWV3Qm94ICsgXCIlM0UlM0NmaWx0ZXIgaWQ9J2InIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz0nc1JHQiclM0UlM0NmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249J1wiICsgc3RkICsgXCInLyUzRSUzQ2ZlQ29sb3JNYXRyaXggdmFsdWVzPScxIDAgMCAwIDAgMCAxIDAgMCAwIDAgMCAxIDAgMCAwIDAgMCAxMDAgLTEnIHJlc3VsdD0ncycvJTNFJTNDZmVGbG9vZCB4PScwJyB5PScwJyB3aWR0aD0nMTAwJTI1JyBoZWlnaHQ9JzEwMCUyNScvJTNFJTNDZmVDb21wb3NpdGUgb3BlcmF0b3I9J291dCcgaW49J3MnLyUzRSUzQ2ZlQ29tcG9zaXRlIGluMj0nU291cmNlR3JhcGhpYycvJTNFJTNDZmVHYXVzc2lhbkJsdXIgc3RkRGV2aWF0aW9uPSdcIiArIHN0ZCArIFwiJy8lM0UlM0MvZmlsdGVyJTNFJTNDaW1hZ2Ugd2lkdGg9JzEwMCUyNScgaGVpZ2h0PScxMDAlMjUnIHg9JzAnIHk9JzAnIHByZXNlcnZlQXNwZWN0UmF0aW89J1wiICsgcHJlc2VydmVBc3BlY3RSYXRpbyArIFwiJyBzdHlsZT0nZmlsdGVyOiB1cmwoJTIzYik7JyBocmVmPSdcIiArIGJsdXJEYXRhVVJMICsgXCInLyUzRSUzQy9zdmclM0VcIjtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1hZ2UtYmx1ci1zdmcuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsImdldEltYWdlQmx1clN2ZyIsInBhcmFtIiwid2lkdGhJbnQiLCJoZWlnaHRJbnQiLCJibHVyV2lkdGgiLCJibHVySGVpZ2h0IiwiYmx1ckRhdGFVUkwiLCJvYmplY3RGaXQiLCJzdGQiLCJzdmdXaWR0aCIsInN2Z0hlaWdodCIsInZpZXdCb3giLCJwcmVzZXJ2ZUFzcGVjdFJhdGlvIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-blur-svg.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js ***!
  \**********************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"ImageConfigContext\", ({\n    enumerable: true,\n    get: function() {\n        return ImageConfigContext;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _imageconfig = __webpack_require__(/*! ./image-config */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js\");\nconst ImageConfigContext = _react.default.createContext(_imageconfig.imageConfigDefault);\nif (true) {\n    ImageConfigContext.displayName = \"ImageConfigContext\";\n} //# sourceMappingURL=image-config-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1jb25maWctY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsc0RBQXFEO0lBQ2pESSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsMkJBQTJCQyxtQkFBT0EsQ0FBQyxnSUFBeUM7QUFDbEYsTUFBTUMsU0FBUyxXQUFXLEdBQUdGLHlCQUF5QkcsQ0FBQyxDQUFDRixtQkFBT0EsQ0FBQyxtRkFBTztBQUN2RSxNQUFNRyxlQUFlSCxtQkFBT0EsQ0FBQywrRkFBZ0I7QUFDN0MsTUFBTUYscUJBQXFCRyxPQUFPRyxPQUFPLENBQUNDLGFBQWEsQ0FBQ0YsYUFBYUcsa0JBQWtCO0FBQ3ZGLElBQUlDLElBQXFDLEVBQUU7SUFDdkNULG1CQUFtQlUsV0FBVyxHQUFHO0FBQ3JDLEVBRUEsK0RBQStEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1jb25maWctY29udGV4dC5zaGFyZWQtcnVudGltZS5qcz8yNzhiIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW1hZ2VDb25maWdDb250ZXh0XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBJbWFnZUNvbmZpZ0NvbnRleHQ7XG4gICAgfVxufSk7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0XCIpO1xuY29uc3QgX3JlYWN0ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwicmVhY3RcIikpO1xuY29uc3QgX2ltYWdlY29uZmlnID0gcmVxdWlyZShcIi4vaW1hZ2UtY29uZmlnXCIpO1xuY29uc3QgSW1hZ2VDb25maWdDb250ZXh0ID0gX3JlYWN0LmRlZmF1bHQuY3JlYXRlQ29udGV4dChfaW1hZ2Vjb25maWcuaW1hZ2VDb25maWdEZWZhdWx0KTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBJbWFnZUNvbmZpZ0NvbnRleHQuZGlzcGxheU5hbWUgPSBcIkltYWdlQ29uZmlnQ29udGV4dFwiO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbWFnZS1jb25maWctY29udGV4dC5zaGFyZWQtcnVudGltZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiSW1hZ2VDb25maWdDb250ZXh0IiwiX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0IiwicmVxdWlyZSIsIl9yZWFjdCIsIl8iLCJfaW1hZ2Vjb25maWciLCJkZWZhdWx0IiwiY3JlYXRlQ29udGV4dCIsImltYWdlQ29uZmlnRGVmYXVsdCIsInByb2Nlc3MiLCJkaXNwbGF5TmFtZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-config.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    VALID_LOADERS: function() {\n        return VALID_LOADERS;\n    },\n    imageConfigDefault: function() {\n        return imageConfigDefault;\n    }\n});\nconst VALID_LOADERS = [\n    \"default\",\n    \"imgix\",\n    \"cloudinary\",\n    \"akamai\",\n    \"custom\"\n];\nconst imageConfigDefault = {\n    deviceSizes: [\n        640,\n        750,\n        828,\n        1080,\n        1200,\n        1920,\n        2048,\n        3840\n    ],\n    imageSizes: [\n        16,\n        32,\n        48,\n        64,\n        96,\n        128,\n        256,\n        384\n    ],\n    path: \"/_next/image\",\n    loader: \"default\",\n    loaderFile: \"\",\n    domains: [],\n    disableStaticImages: false,\n    minimumCacheTTL: 60,\n    formats: [\n        \"image/webp\"\n    ],\n    dangerouslyAllowSVG: false,\n    contentSecurityPolicy: \"script-src 'none'; frame-src 'none'; sandbox;\",\n    contentDispositionType: \"inline\",\n    remotePatterns: [],\n    unoptimized: false\n}; //# sourceMappingURL=image-config.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1jb25maWcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0YsS0FBTUMsQ0FBQUEsQ0FHTjtBQUNBLFNBQVNHLFFBQVFDLE1BQU0sRUFBRUMsR0FBRztJQUN4QixJQUFJLElBQUlDLFFBQVFELElBQUlULE9BQU9DLGNBQWMsQ0FBQ08sUUFBUUUsTUFBTTtRQUNwREMsWUFBWTtRQUNaQyxLQUFLSCxHQUFHLENBQUNDLEtBQUs7SUFDbEI7QUFDSjtBQUNBSCxRQUFRTCxTQUFTO0lBQ2JHLGVBQWU7UUFDWCxPQUFPQTtJQUNYO0lBQ0FDLG9CQUFvQjtRQUNoQixPQUFPQTtJQUNYO0FBQ0o7QUFDQSxNQUFNRCxnQkFBZ0I7SUFDbEI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNIO0FBQ0QsTUFBTUMscUJBQXFCO0lBQ3ZCTyxhQUFhO1FBQ1Q7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtLQUNIO0lBQ0RDLFlBQVk7UUFDUjtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO0tBQ0g7SUFDREMsTUFBTTtJQUNOQyxRQUFRO0lBQ1JDLFlBQVk7SUFDWkMsU0FBUyxFQUFFO0lBQ1hDLHFCQUFxQjtJQUNyQkMsaUJBQWlCO0lBQ2pCQyxTQUFTO1FBQ0w7S0FDSDtJQUNEQyxxQkFBcUI7SUFDckJDLHVCQUF1QjtJQUN2QkMsd0JBQXdCO0lBQ3hCQyxnQkFBZ0IsRUFBRTtJQUNsQkMsYUFBYTtBQUNqQixHQUVBLHdDQUF3QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvaW1hZ2UtY29uZmlnLmpzPzMxMjYiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBWQUxJRF9MT0FERVJTOiBudWxsLFxuICAgIGltYWdlQ29uZmlnRGVmYXVsdDogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBWQUxJRF9MT0FERVJTOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFZBTElEX0xPQURFUlM7XG4gICAgfSxcbiAgICBpbWFnZUNvbmZpZ0RlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaW1hZ2VDb25maWdEZWZhdWx0O1xuICAgIH1cbn0pO1xuY29uc3QgVkFMSURfTE9BREVSUyA9IFtcbiAgICBcImRlZmF1bHRcIixcbiAgICBcImltZ2l4XCIsXG4gICAgXCJjbG91ZGluYXJ5XCIsXG4gICAgXCJha2FtYWlcIixcbiAgICBcImN1c3RvbVwiXG5dO1xuY29uc3QgaW1hZ2VDb25maWdEZWZhdWx0ID0ge1xuICAgIGRldmljZVNpemVzOiBbXG4gICAgICAgIDY0MCxcbiAgICAgICAgNzUwLFxuICAgICAgICA4MjgsXG4gICAgICAgIDEwODAsXG4gICAgICAgIDEyMDAsXG4gICAgICAgIDE5MjAsXG4gICAgICAgIDIwNDgsXG4gICAgICAgIDM4NDBcbiAgICBdLFxuICAgIGltYWdlU2l6ZXM6IFtcbiAgICAgICAgMTYsXG4gICAgICAgIDMyLFxuICAgICAgICA0OCxcbiAgICAgICAgNjQsXG4gICAgICAgIDk2LFxuICAgICAgICAxMjgsXG4gICAgICAgIDI1NixcbiAgICAgICAgMzg0XG4gICAgXSxcbiAgICBwYXRoOiBcIi9fbmV4dC9pbWFnZVwiLFxuICAgIGxvYWRlcjogXCJkZWZhdWx0XCIsXG4gICAgbG9hZGVyRmlsZTogXCJcIixcbiAgICBkb21haW5zOiBbXSxcbiAgICBkaXNhYmxlU3RhdGljSW1hZ2VzOiBmYWxzZSxcbiAgICBtaW5pbXVtQ2FjaGVUVEw6IDYwLFxuICAgIGZvcm1hdHM6IFtcbiAgICAgICAgXCJpbWFnZS93ZWJwXCJcbiAgICBdLFxuICAgIGRhbmdlcm91c2x5QWxsb3dTVkc6IGZhbHNlLFxuICAgIGNvbnRlbnRTZWN1cml0eVBvbGljeTogXCJzY3JpcHQtc3JjICdub25lJzsgZnJhbWUtc3JjICdub25lJzsgc2FuZGJveDtcIixcbiAgICBjb250ZW50RGlzcG9zaXRpb25UeXBlOiBcImlubGluZVwiLFxuICAgIHJlbW90ZVBhdHRlcm5zOiBbXSxcbiAgICB1bm9wdGltaXplZDogZmFsc2Vcbn07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWltYWdlLWNvbmZpZy5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJWQUxJRF9MT0FERVJTIiwiaW1hZ2VDb25maWdEZWZhdWx0IiwiX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZGV2aWNlU2l6ZXMiLCJpbWFnZVNpemVzIiwicGF0aCIsImxvYWRlciIsImxvYWRlckZpbGUiLCJkb21haW5zIiwiZGlzYWJsZVN0YXRpY0ltYWdlcyIsIm1pbmltdW1DYWNoZVRUTCIsImZvcm1hdHMiLCJkYW5nZXJvdXNseUFsbG93U1ZHIiwiY29udGVudFNlY3VyaXR5UG9saWN5IiwiY29udGVudERpc3Bvc2l0aW9uVHlwZSIsInJlbW90ZVBhdHRlcm5zIiwidW5vcHRpbWl6ZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-config.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-external.js":
/*!*************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-external.js ***!
  \*************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    getImageProps: function() {\n        return getImageProps;\n    },\n    default: function() {\n        return _default;\n    }\n});\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _getimgprops = __webpack_require__(/*! ./get-img-props */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/get-img-props.js\");\nconst _imagecomponent = __webpack_require__(/*! ../../client/image-component */ \"(app-pages-browser)/./node_modules/next/dist/client/image-component.js\");\nconst _imageloader = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! next/dist/shared/lib/image-loader */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/image-loader.js\"));\nconst getImageProps = (imgProps)=>{\n    const { props } = (0, _getimgprops.getImgProps)(imgProps, {\n        defaultLoader: _imageloader.default,\n        // This is replaced by webpack define plugin\n        imgConf: {\"deviceSizes\":[640,750,828,1080,1200,1920,2048,3840],\"imageSizes\":[16,32,48,64,96,128,256,384],\"path\":\"/_next/image\",\"loader\":\"default\",\"dangerouslyAllowSVG\":false,\"unoptimized\":false,\"domains\":[\"*\"],\"remotePatterns\":[]}\n    });\n    // Normally we don't care about undefined props because we pass to JSX,\n    // but this exported function could be used by the end user for anything\n    // so we delete undefined props to clean it up a little.\n    for (const [key, value] of Object.entries(props)){\n        if (value === undefined) {\n            delete props[key];\n        }\n    }\n    return {\n        props\n    };\n};\nconst _default = _imagecomponent.Image; //# sourceMappingURL=image-external.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1leHRlcm5hbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQUdOO0FBQ0EsU0FBU0csUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSVQsT0FBT0MsY0FBYyxDQUFDTyxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFMLFNBQVM7SUFDYkcsZUFBZTtRQUNYLE9BQU9BO0lBQ1g7SUFDQUMsU0FBUztRQUNMLE9BQU9PO0lBQ1g7QUFDSjtBQUNBLE1BQU1DLDJCQUEyQkMsbUJBQU9BLENBQUMsZ0lBQXlDO0FBQ2xGLE1BQU1DLGVBQWVELG1CQUFPQSxDQUFDLGlHQUFpQjtBQUM5QyxNQUFNRSxrQkFBa0JGLG1CQUFPQSxDQUFDLDRHQUE4QjtBQUM5RCxNQUFNRyxlQUFlLFdBQVcsR0FBR0oseUJBQXlCSyxDQUFDLENBQUNKLG1CQUFPQSxDQUFDLGtIQUFtQztBQUN6RyxNQUFNVixnQkFBZ0IsQ0FBQ2U7SUFDbkIsTUFBTSxFQUFFQyxLQUFLLEVBQUUsR0FBRyxDQUFDLEdBQUdMLGFBQWFNLFdBQVcsRUFBRUYsVUFBVTtRQUN0REcsZUFBZUwsYUFBYVosT0FBTztRQUNuQyw0Q0FBNEM7UUFDNUNrQixTQUFTQyw2TkFBNkI7SUFDMUM7SUFDQSx1RUFBdUU7SUFDdkUsd0VBQXdFO0lBQ3hFLHdEQUF3RDtJQUN4RCxLQUFLLE1BQU0sQ0FBQ0csS0FBS3pCLE1BQU0sSUFBSUgsT0FBTzZCLE9BQU8sQ0FBQ1IsT0FBTztRQUM3QyxJQUFJbEIsVUFBVTJCLFdBQVc7WUFDckIsT0FBT1QsS0FBSyxDQUFDTyxJQUFJO1FBQ3JCO0lBQ0o7SUFDQSxPQUFPO1FBQ0hQO0lBQ0o7QUFDSjtBQUNBLE1BQU1SLFdBQVdJLGdCQUFnQmMsS0FBSyxFQUV0QywwQ0FBMEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL2ltYWdlLWV4dGVybmFsLmpzPzY4Y2IiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBnZXRJbWFnZVByb3BzOiBudWxsLFxuICAgIGRlZmF1bHQ6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgZ2V0SW1hZ2VQcm9wczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRJbWFnZVByb3BzO1xuICAgIH0sXG4gICAgZGVmYXVsdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfZGVmYXVsdDtcbiAgICB9XG59KTtcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHRcIik7XG5jb25zdCBfZ2V0aW1ncHJvcHMgPSByZXF1aXJlKFwiLi9nZXQtaW1nLXByb3BzXCIpO1xuY29uc3QgX2ltYWdlY29tcG9uZW50ID0gcmVxdWlyZShcIi4uLy4uL2NsaWVudC9pbWFnZS1jb21wb25lbnRcIik7XG5jb25zdCBfaW1hZ2Vsb2FkZXIgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCJuZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1sb2FkZXJcIikpO1xuY29uc3QgZ2V0SW1hZ2VQcm9wcyA9IChpbWdQcm9wcyk9PntcbiAgICBjb25zdCB7IHByb3BzIH0gPSAoMCwgX2dldGltZ3Byb3BzLmdldEltZ1Byb3BzKShpbWdQcm9wcywge1xuICAgICAgICBkZWZhdWx0TG9hZGVyOiBfaW1hZ2Vsb2FkZXIuZGVmYXVsdCxcbiAgICAgICAgLy8gVGhpcyBpcyByZXBsYWNlZCBieSB3ZWJwYWNrIGRlZmluZSBwbHVnaW5cbiAgICAgICAgaW1nQ29uZjogcHJvY2Vzcy5lbnYuX19ORVhUX0lNQUdFX09QVFNcbiAgICB9KTtcbiAgICAvLyBOb3JtYWxseSB3ZSBkb24ndCBjYXJlIGFib3V0IHVuZGVmaW5lZCBwcm9wcyBiZWNhdXNlIHdlIHBhc3MgdG8gSlNYLFxuICAgIC8vIGJ1dCB0aGlzIGV4cG9ydGVkIGZ1bmN0aW9uIGNvdWxkIGJlIHVzZWQgYnkgdGhlIGVuZCB1c2VyIGZvciBhbnl0aGluZ1xuICAgIC8vIHNvIHdlIGRlbGV0ZSB1bmRlZmluZWQgcHJvcHMgdG8gY2xlYW4gaXQgdXAgYSBsaXR0bGUuXG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocHJvcHMpKXtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBwcm9wc1trZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHByb3BzXG4gICAgfTtcbn07XG5jb25zdCBfZGVmYXVsdCA9IF9pbWFnZWNvbXBvbmVudC5JbWFnZTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW1hZ2UtZXh0ZXJuYWwuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibW9kdWxlIiwiZ2V0SW1hZ2VQcm9wcyIsImRlZmF1bHQiLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJfZGVmYXVsdCIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJfZ2V0aW1ncHJvcHMiLCJfaW1hZ2Vjb21wb25lbnQiLCJfaW1hZ2Vsb2FkZXIiLCJfIiwiaW1nUHJvcHMiLCJwcm9wcyIsImdldEltZ1Byb3BzIiwiZGVmYXVsdExvYWRlciIsImltZ0NvbmYiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX0lNQUdFX09QVFMiLCJrZXkiLCJlbnRyaWVzIiwidW5kZWZpbmVkIiwiSW1hZ2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-external.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/image-loader.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/image-loader.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return _default;\n    }\n}));\nfunction defaultLoader(param) {\n    let { config, src, width, quality } = param;\n    if (true) {\n        const missingValues = [];\n        // these should always be provided but make sure they are\n        if (!src) missingValues.push(\"src\");\n        if (!width) missingValues.push(\"width\");\n        if (missingValues.length > 0) {\n            throw new Error(\"Next Image Optimization requires \" + missingValues.join(\", \") + \" to be provided. Make sure you pass them as props to the `next/image` component. Received: \" + JSON.stringify({\n                src,\n                width,\n                quality\n            }));\n        }\n        if (src.startsWith(\"//\")) {\n            throw new Error('Failed to parse src \"' + src + '\" on `next/image`, protocol-relative URL (//) must be changed to an absolute URL (http:// or https://)');\n        }\n        if (!src.startsWith(\"/\") && (config.domains || config.remotePatterns)) {\n            let parsedSrc;\n            try {\n                parsedSrc = new URL(src);\n            } catch (err) {\n                console.error(err);\n                throw new Error('Failed to parse src \"' + src + '\" on `next/image`, if using relative image it must start with a leading slash \"/\" or be an absolute URL (http:// or https://)');\n            }\n            if (true) {\n                // We use dynamic require because this should only error in development\n                const { hasMatch } = __webpack_require__(/*! ./match-remote-pattern */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/match-remote-pattern.js\");\n                if (!hasMatch(config.domains, config.remotePatterns, parsedSrc)) {\n                    throw new Error(\"Invalid src prop (\" + src + ') on `next/image`, hostname \"' + parsedSrc.hostname + '\" is not configured under images in your `next.config.js`\\n' + \"See more info: https://nextjs.org/docs/messages/next-image-unconfigured-host\");\n                }\n            }\n        }\n    }\n    return config.path + \"?url=\" + encodeURIComponent(src) + \"&w=\" + width + \"&q=\" + (quality || 75) + ( false ? 0 : \"\");\n}\n// We use this to determine if the import is the default loader\n// or a custom loader defined by the user in next.config.js\ndefaultLoader.__next_img_default = true;\nconst _default = defaultLoader; //# sourceMappingURL=image-loader.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1sb2FkZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILDJDQUEwQztJQUN0Q0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLFNBQVNDLGNBQWNDLEtBQUs7SUFDeEIsSUFBSSxFQUFFQyxNQUFNLEVBQUVDLEdBQUcsRUFBRUMsS0FBSyxFQUFFQyxPQUFPLEVBQUUsR0FBR0o7SUFDdEMsSUFBSUssSUFBcUMsRUFBRTtRQUN2QyxNQUFNQyxnQkFBZ0IsRUFBRTtRQUN4Qix5REFBeUQ7UUFDekQsSUFBSSxDQUFDSixLQUFLSSxjQUFjQyxJQUFJLENBQUM7UUFDN0IsSUFBSSxDQUFDSixPQUFPRyxjQUFjQyxJQUFJLENBQUM7UUFDL0IsSUFBSUQsY0FBY0UsTUFBTSxHQUFHLEdBQUc7WUFDMUIsTUFBTSxJQUFJQyxNQUFNLHNDQUFzQ0gsY0FBY0ksSUFBSSxDQUFDLFFBQVEsZ0dBQWdHQyxLQUFLQyxTQUFTLENBQUM7Z0JBQzVMVjtnQkFDQUM7Z0JBQ0FDO1lBQ0o7UUFDSjtRQUNBLElBQUlGLElBQUlXLFVBQVUsQ0FBQyxPQUFPO1lBQ3RCLE1BQU0sSUFBSUosTUFBTSwwQkFBMEJQLE1BQU07UUFDcEQ7UUFDQSxJQUFJLENBQUNBLElBQUlXLFVBQVUsQ0FBQyxRQUFTWixDQUFBQSxPQUFPYSxPQUFPLElBQUliLE9BQU9jLGNBQWMsR0FBRztZQUNuRSxJQUFJQztZQUNKLElBQUk7Z0JBQ0FBLFlBQVksSUFBSUMsSUFBSWY7WUFDeEIsRUFBRSxPQUFPZ0IsS0FBSztnQkFDVkMsUUFBUUMsS0FBSyxDQUFDRjtnQkFDZCxNQUFNLElBQUlULE1BQU0sMEJBQTBCUCxNQUFNO1lBQ3BEO1lBQ0EsSUFBSUcsSUFDK0IsRUFBRTtnQkFDakMsdUVBQXVFO2dCQUN2RSxNQUFNLEVBQUVrQixRQUFRLEVBQUUsR0FBR0MsbUJBQU9BLENBQUMsK0dBQXdCO2dCQUNyRCxJQUFJLENBQUNELFNBQVN0QixPQUFPYSxPQUFPLEVBQUViLE9BQU9jLGNBQWMsRUFBRUMsWUFBWTtvQkFDN0QsTUFBTSxJQUFJUCxNQUFNLHVCQUF1QlAsTUFBTSxrQ0FBa0NjLFVBQVVTLFFBQVEsR0FBRyxnRUFBZ0U7Z0JBQ3hLO1lBQ0o7UUFDSjtJQUNKO0lBQ0EsT0FBT3hCLE9BQU95QixJQUFJLEdBQUcsVUFBVUMsbUJBQW1CekIsT0FBTyxRQUFRQyxRQUFRLFFBQVNDLENBQUFBLFdBQVcsRUFBQyxJQUFNQyxDQUFBQSxNQUE4QixHQUFHLENBQXdDLEdBQUcsRUFBQztBQUNyTDtBQUNBLCtEQUErRDtBQUMvRCwyREFBMkQ7QUFDM0ROLGNBQWM4QixrQkFBa0IsR0FBRztBQUNuQyxNQUFNL0IsV0FBV0MsZUFFakIsd0NBQXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9pbWFnZS1sb2FkZXIuanM/YzBhMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlZmF1bHRcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9kZWZhdWx0O1xuICAgIH1cbn0pO1xuZnVuY3Rpb24gZGVmYXVsdExvYWRlcihwYXJhbSkge1xuICAgIGxldCB7IGNvbmZpZywgc3JjLCB3aWR0aCwgcXVhbGl0eSB9ID0gcGFyYW07XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBjb25zdCBtaXNzaW5nVmFsdWVzID0gW107XG4gICAgICAgIC8vIHRoZXNlIHNob3VsZCBhbHdheXMgYmUgcHJvdmlkZWQgYnV0IG1ha2Ugc3VyZSB0aGV5IGFyZVxuICAgICAgICBpZiAoIXNyYykgbWlzc2luZ1ZhbHVlcy5wdXNoKFwic3JjXCIpO1xuICAgICAgICBpZiAoIXdpZHRoKSBtaXNzaW5nVmFsdWVzLnB1c2goXCJ3aWR0aFwiKTtcbiAgICAgICAgaWYgKG1pc3NpbmdWYWx1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTmV4dCBJbWFnZSBPcHRpbWl6YXRpb24gcmVxdWlyZXMgXCIgKyBtaXNzaW5nVmFsdWVzLmpvaW4oXCIsIFwiKSArIFwiIHRvIGJlIHByb3ZpZGVkLiBNYWtlIHN1cmUgeW91IHBhc3MgdGhlbSBhcyBwcm9wcyB0byB0aGUgYG5leHQvaW1hZ2VgIGNvbXBvbmVudC4gUmVjZWl2ZWQ6IFwiICsgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHNyYyxcbiAgICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgICBxdWFsaXR5XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNyYy5zdGFydHNXaXRoKFwiLy9cIikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIHBhcnNlIHNyYyBcIicgKyBzcmMgKyAnXCIgb24gYG5leHQvaW1hZ2VgLCBwcm90b2NvbC1yZWxhdGl2ZSBVUkwgKC8vKSBtdXN0IGJlIGNoYW5nZWQgdG8gYW4gYWJzb2x1dGUgVVJMIChodHRwOi8vIG9yIGh0dHBzOi8vKScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc3JjLnN0YXJ0c1dpdGgoXCIvXCIpICYmIChjb25maWcuZG9tYWlucyB8fCBjb25maWcucmVtb3RlUGF0dGVybnMpKSB7XG4gICAgICAgICAgICBsZXQgcGFyc2VkU3JjO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYXJzZWRTcmMgPSBuZXcgVVJMKHNyYyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gcGFyc2Ugc3JjIFwiJyArIHNyYyArICdcIiBvbiBgbmV4dC9pbWFnZWAsIGlmIHVzaW5nIHJlbGF0aXZlIGltYWdlIGl0IG11c3Qgc3RhcnQgd2l0aCBhIGxlYWRpbmcgc2xhc2ggXCIvXCIgb3IgYmUgYW4gYWJzb2x1dGUgVVJMIChodHRwOi8vIG9yIGh0dHBzOi8vKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInRlc3RcIiAmJiAvLyBtaWNyb21hdGNoIGlzbid0IGNvbXBhdGlibGUgd2l0aCBlZGdlIHJ1bnRpbWVcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5FWFRfUlVOVElNRSAhPT0gXCJlZGdlXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSB1c2UgZHluYW1pYyByZXF1aXJlIGJlY2F1c2UgdGhpcyBzaG91bGQgb25seSBlcnJvciBpbiBkZXZlbG9wbWVudFxuICAgICAgICAgICAgICAgIGNvbnN0IHsgaGFzTWF0Y2ggfSA9IHJlcXVpcmUoXCIuL21hdGNoLXJlbW90ZS1wYXR0ZXJuXCIpO1xuICAgICAgICAgICAgICAgIGlmICghaGFzTWF0Y2goY29uZmlnLmRvbWFpbnMsIGNvbmZpZy5yZW1vdGVQYXR0ZXJucywgcGFyc2VkU3JjKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNyYyBwcm9wIChcIiArIHNyYyArICcpIG9uIGBuZXh0L2ltYWdlYCwgaG9zdG5hbWUgXCInICsgcGFyc2VkU3JjLmhvc3RuYW1lICsgJ1wiIGlzIG5vdCBjb25maWd1cmVkIHVuZGVyIGltYWdlcyBpbiB5b3VyIGBuZXh0LmNvbmZpZy5qc2BcXG4nICsgXCJTZWUgbW9yZSBpbmZvOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9uZXh0LWltYWdlLXVuY29uZmlndXJlZC1ob3N0XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29uZmlnLnBhdGggKyBcIj91cmw9XCIgKyBlbmNvZGVVUklDb21wb25lbnQoc3JjKSArIFwiJnc9XCIgKyB3aWR0aCArIFwiJnE9XCIgKyAocXVhbGl0eSB8fCA3NSkgKyAocHJvY2Vzcy5lbnYuTkVYVF9ERVBMT1lNRU5UX0lEID8gXCImZHBsPVwiICsgcHJvY2Vzcy5lbnYuTkVYVF9ERVBMT1lNRU5UX0lEIDogXCJcIik7XG59XG4vLyBXZSB1c2UgdGhpcyB0byBkZXRlcm1pbmUgaWYgdGhlIGltcG9ydCBpcyB0aGUgZGVmYXVsdCBsb2FkZXJcbi8vIG9yIGEgY3VzdG9tIGxvYWRlciBkZWZpbmVkIGJ5IHRoZSB1c2VyIGluIG5leHQuY29uZmlnLmpzXG5kZWZhdWx0TG9hZGVyLl9fbmV4dF9pbWdfZGVmYXVsdCA9IHRydWU7XG5jb25zdCBfZGVmYXVsdCA9IGRlZmF1bHRMb2FkZXI7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWltYWdlLWxvYWRlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX2RlZmF1bHQiLCJkZWZhdWx0TG9hZGVyIiwicGFyYW0iLCJjb25maWciLCJzcmMiLCJ3aWR0aCIsInF1YWxpdHkiLCJwcm9jZXNzIiwibWlzc2luZ1ZhbHVlcyIsInB1c2giLCJsZW5ndGgiLCJFcnJvciIsImpvaW4iLCJKU09OIiwic3RyaW5naWZ5Iiwic3RhcnRzV2l0aCIsImRvbWFpbnMiLCJyZW1vdGVQYXR0ZXJucyIsInBhcnNlZFNyYyIsIlVSTCIsImVyciIsImNvbnNvbGUiLCJlcnJvciIsImVudiIsIk5FWFRfUlVOVElNRSIsImhhc01hdGNoIiwicmVxdWlyZSIsImhvc3RuYW1lIiwicGF0aCIsImVuY29kZVVSSUNvbXBvbmVudCIsIk5FWFRfREVQTE9ZTUVOVF9JRCIsIl9fbmV4dF9pbWdfZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/image-loader.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/match-remote-pattern.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/match-remote-pattern.js ***!
  \*******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    matchRemotePattern: function() {\n        return matchRemotePattern;\n    },\n    hasMatch: function() {\n        return hasMatch;\n    }\n});\nconst _micromatch = __webpack_require__(/*! next/dist/compiled/micromatch */ \"(app-pages-browser)/./node_modules/next/dist/compiled/micromatch/index.js\");\nfunction matchRemotePattern(pattern, url) {\n    if (pattern.protocol !== undefined) {\n        const actualProto = url.protocol.slice(0, -1);\n        if (pattern.protocol !== actualProto) {\n            return false;\n        }\n    }\n    if (pattern.port !== undefined) {\n        if (pattern.port !== url.port) {\n            return false;\n        }\n    }\n    if (pattern.hostname === undefined) {\n        throw new Error(\"Pattern should define hostname but found\\n\" + JSON.stringify(pattern));\n    } else {\n        if (!(0, _micromatch.makeRe)(pattern.hostname).test(url.hostname)) {\n            return false;\n        }\n    }\n    var _pattern_pathname;\n    if (!(0, _micromatch.makeRe)((_pattern_pathname = pattern.pathname) != null ? _pattern_pathname : \"**\").test(url.pathname)) {\n        return false;\n    }\n    return true;\n}\nfunction hasMatch(domains, remotePatterns, url) {\n    return domains.some((domain)=>url.hostname === domain) || remotePatterns.some((p)=>matchRemotePattern(p, url));\n} //# sourceMappingURL=match-remote-pattern.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9tYXRjaC1yZW1vdGUtcGF0dGVybi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRixLQUFNQyxDQUFBQSxDQUdOO0FBQ0EsU0FBU0csUUFBUUMsTUFBTSxFQUFFQyxHQUFHO0lBQ3hCLElBQUksSUFBSUMsUUFBUUQsSUFBSVQsT0FBT0MsY0FBYyxDQUFDTyxRQUFRRSxNQUFNO1FBQ3BEQyxZQUFZO1FBQ1pDLEtBQUtILEdBQUcsQ0FBQ0MsS0FBSztJQUNsQjtBQUNKO0FBQ0FILFFBQVFMLFNBQVM7SUFDYkcsb0JBQW9CO1FBQ2hCLE9BQU9BO0lBQ1g7SUFDQUMsVUFBVTtRQUNOLE9BQU9BO0lBQ1g7QUFDSjtBQUNBLE1BQU1PLGNBQWNDLG1CQUFPQSxDQUFDLGdIQUErQjtBQUMzRCxTQUFTVCxtQkFBbUJVLE9BQU8sRUFBRUMsR0FBRztJQUNwQyxJQUFJRCxRQUFRRSxRQUFRLEtBQUtDLFdBQVc7UUFDaEMsTUFBTUMsY0FBY0gsSUFBSUMsUUFBUSxDQUFDRyxLQUFLLENBQUMsR0FBRyxDQUFDO1FBQzNDLElBQUlMLFFBQVFFLFFBQVEsS0FBS0UsYUFBYTtZQUNsQyxPQUFPO1FBQ1g7SUFDSjtJQUNBLElBQUlKLFFBQVFNLElBQUksS0FBS0gsV0FBVztRQUM1QixJQUFJSCxRQUFRTSxJQUFJLEtBQUtMLElBQUlLLElBQUksRUFBRTtZQUMzQixPQUFPO1FBQ1g7SUFDSjtJQUNBLElBQUlOLFFBQVFPLFFBQVEsS0FBS0osV0FBVztRQUNoQyxNQUFNLElBQUlLLE1BQU0sK0NBQStDQyxLQUFLQyxTQUFTLENBQUNWO0lBQ2xGLE9BQU87UUFDSCxJQUFJLENBQUMsQ0FBQyxHQUFHRixZQUFZYSxNQUFNLEVBQUVYLFFBQVFPLFFBQVEsRUFBRUssSUFBSSxDQUFDWCxJQUFJTSxRQUFRLEdBQUc7WUFDL0QsT0FBTztRQUNYO0lBQ0o7SUFDQSxJQUFJTTtJQUNKLElBQUksQ0FBQyxDQUFDLEdBQUdmLFlBQVlhLE1BQU0sRUFBRSxDQUFDRSxvQkFBb0JiLFFBQVFjLFFBQVEsS0FBSyxPQUFPRCxvQkFBb0IsTUFBTUQsSUFBSSxDQUFDWCxJQUFJYSxRQUFRLEdBQUc7UUFDeEgsT0FBTztJQUNYO0lBQ0EsT0FBTztBQUNYO0FBQ0EsU0FBU3ZCLFNBQVN3QixPQUFPLEVBQUVDLGNBQWMsRUFBRWYsR0FBRztJQUMxQyxPQUFPYyxRQUFRRSxJQUFJLENBQUMsQ0FBQ0MsU0FBU2pCLElBQUlNLFFBQVEsS0FBS1csV0FBV0YsZUFBZUMsSUFBSSxDQUFDLENBQUNFLElBQUk3QixtQkFBbUI2QixHQUFHbEI7QUFDN0csRUFFQSxnREFBZ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL21hdGNoLXJlbW90ZS1wYXR0ZXJuLmpzPzBjOWIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBtYXRjaFJlbW90ZVBhdHRlcm46IG51bGwsXG4gICAgaGFzTWF0Y2g6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgbWF0Y2hSZW1vdGVQYXR0ZXJuOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoUmVtb3RlUGF0dGVybjtcbiAgICB9LFxuICAgIGhhc01hdGNoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGhhc01hdGNoO1xuICAgIH1cbn0pO1xuY29uc3QgX21pY3JvbWF0Y2ggPSByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL21pY3JvbWF0Y2hcIik7XG5mdW5jdGlvbiBtYXRjaFJlbW90ZVBhdHRlcm4ocGF0dGVybiwgdXJsKSB7XG4gICAgaWYgKHBhdHRlcm4ucHJvdG9jb2wgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBhY3R1YWxQcm90byA9IHVybC5wcm90b2NvbC5zbGljZSgwLCAtMSk7XG4gICAgICAgIGlmIChwYXR0ZXJuLnByb3RvY29sICE9PSBhY3R1YWxQcm90bykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwYXR0ZXJuLnBvcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAocGF0dGVybi5wb3J0ICE9PSB1cmwucG9ydCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwYXR0ZXJuLmhvc3RuYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGF0dGVybiBzaG91bGQgZGVmaW5lIGhvc3RuYW1lIGJ1dCBmb3VuZFxcblwiICsgSlNPTi5zdHJpbmdpZnkocGF0dGVybikpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghKDAsIF9taWNyb21hdGNoLm1ha2VSZSkocGF0dGVybi5ob3N0bmFtZSkudGVzdCh1cmwuaG9zdG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIF9wYXR0ZXJuX3BhdGhuYW1lO1xuICAgIGlmICghKDAsIF9taWNyb21hdGNoLm1ha2VSZSkoKF9wYXR0ZXJuX3BhdGhuYW1lID0gcGF0dGVybi5wYXRobmFtZSkgIT0gbnVsbCA/IF9wYXR0ZXJuX3BhdGhuYW1lIDogXCIqKlwiKS50ZXN0KHVybC5wYXRobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGhhc01hdGNoKGRvbWFpbnMsIHJlbW90ZVBhdHRlcm5zLCB1cmwpIHtcbiAgICByZXR1cm4gZG9tYWlucy5zb21lKChkb21haW4pPT51cmwuaG9zdG5hbWUgPT09IGRvbWFpbikgfHwgcmVtb3RlUGF0dGVybnMuc29tZSgocCk9Pm1hdGNoUmVtb3RlUGF0dGVybihwLCB1cmwpKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF0Y2gtcmVtb3RlLXBhdHRlcm4uanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibW9kdWxlIiwibWF0Y2hSZW1vdGVQYXR0ZXJuIiwiaGFzTWF0Y2giLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJfbWljcm9tYXRjaCIsInJlcXVpcmUiLCJwYXR0ZXJuIiwidXJsIiwicHJvdG9jb2wiLCJ1bmRlZmluZWQiLCJhY3R1YWxQcm90byIsInNsaWNlIiwicG9ydCIsImhvc3RuYW1lIiwiRXJyb3IiLCJKU09OIiwic3RyaW5naWZ5IiwibWFrZVJlIiwidGVzdCIsIl9wYXR0ZXJuX3BhdGhuYW1lIiwicGF0aG5hbWUiLCJkb21haW5zIiwicmVtb3RlUGF0dGVybnMiLCJzb21lIiwiZG9tYWluIiwicCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/match-remote-pattern.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js":
/*!****************************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router-context.shared-runtime.js ***!
  \****************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"RouterContext\", ({\n    enumerable: true,\n    get: function() {\n        return RouterContext;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst RouterContext = _react.default.createContext(null);\nif (true) {\n    RouterContext.displayName = \"RouterContext\";\n} //# sourceMappingURL=router-context.shared-runtime.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsaURBQWdEO0lBQzVDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsMkJBQTJCQyxtQkFBT0EsQ0FBQyxnSUFBeUM7QUFDbEYsTUFBTUMsU0FBUyxXQUFXLEdBQUdGLHlCQUF5QkcsQ0FBQyxDQUFDRixtQkFBT0EsQ0FBQyxtRkFBTztBQUN2RSxNQUFNRixnQkFBZ0JHLE9BQU9FLE9BQU8sQ0FBQ0MsYUFBYSxDQUFDO0FBQ25ELElBQUlDLElBQXFDLEVBQUU7SUFDdkNQLGNBQWNRLFdBQVcsR0FBRztBQUNoQyxFQUVBLHlEQUF5RCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyLWNvbnRleHQuc2hhcmVkLXJ1bnRpbWUuanM/OGZhMSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJvdXRlckNvbnRleHRcIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFJvdXRlckNvbnRleHQ7XG4gICAgfVxufSk7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0XCIpO1xuY29uc3QgX3JlYWN0ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwicmVhY3RcIikpO1xuY29uc3QgUm91dGVyQ29udGV4dCA9IF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgUm91dGVyQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiUm91dGVyQ29udGV4dFwiO1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiUm91dGVyQ29udGV4dCIsIl9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCIsInJlcXVpcmUiLCJfcmVhY3QiLCJfIiwiZGVmYXVsdCIsImNyZWF0ZUNvbnRleHQiLCJwcm9jZXNzIiwiZGlzcGxheU5hbWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/router-context.shared-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/shared/lib/side-effect.js":
/*!**********************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/side-effect.js ***!
  \**********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return SideEffect;\n    }\n}));\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nconst isServer = \"object\" === \"undefined\";\nconst useClientOnlyLayoutEffect = isServer ? ()=>{} : _react.useLayoutEffect;\nconst useClientOnlyEffect = isServer ? ()=>{} : _react.useEffect;\nfunction SideEffect(props) {\n    _s();\n    const { headManager, reduceComponentsToState } = props;\n    function emitChange() {\n        if (headManager && headManager.mountedInstances) {\n            const headElements = _react.Children.toArray(Array.from(headManager.mountedInstances).filter(Boolean));\n            headManager.updateHead(reduceComponentsToState(headElements, props));\n        }\n    }\n    if (isServer) {\n        var _headManager_mountedInstances;\n        headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.add(props.children);\n        emitChange();\n    }\n    useClientOnlyLayoutEffect(()=>{\n        var _headManager_mountedInstances;\n        headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.add(props.children);\n        return ()=>{\n            var _headManager_mountedInstances;\n            headManager == null ? void 0 : (_headManager_mountedInstances = headManager.mountedInstances) == null ? void 0 : _headManager_mountedInstances.delete(props.children);\n        };\n    });\n    // We need to call `updateHead` method whenever the `SideEffect` is trigger in all\n    // life-cycles: mount, update, unmount. However, if there are multiple `SideEffect`s\n    // being rendered, we only trigger the method from the last one.\n    // This is ensured by keeping the last unflushed `updateHead` in the `_pendingUpdate`\n    // singleton in the layout effect pass, and actually trigger it in the effect pass.\n    useClientOnlyLayoutEffect(()=>{\n        if (headManager) {\n            headManager._pendingUpdate = emitChange;\n        }\n        return ()=>{\n            if (headManager) {\n                headManager._pendingUpdate = emitChange;\n            }\n        };\n    });\n    useClientOnlyEffect(()=>{\n        if (headManager && headManager._pendingUpdate) {\n            headManager._pendingUpdate();\n            headManager._pendingUpdate = null;\n        }\n        return ()=>{\n            if (headManager && headManager._pendingUpdate) {\n                headManager._pendingUpdate();\n                headManager._pendingUpdate = null;\n            }\n        };\n    });\n    return null;\n} //# sourceMappingURL=side-effect.js.map\n_s(SideEffect, \"gHVkikNHNxjVdD11eJBzaqkCiPY=\", false, function() {\n    return [\n        useClientOnlyLayoutEffect,\n        useClientOnlyLayoutEffect,\n        useClientOnlyEffect\n    ];\n});\n_c = SideEffect;\nvar _c;\n$RefreshReg$(_c, \"SideEffect\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3Qvc2hhcmVkL2xpYi9zaWRlLWVmZmVjdC5qcyIsIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0FBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCwyQ0FBMEM7SUFDdENJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQyxTQUFTQyxtQkFBT0EsQ0FBQyxtRkFBTztBQUM5QixNQUFNQyxXQUFXLGFBQWtCO0FBQ25DLE1BQU1DLDRCQUE0QkQsV0FBVyxLQUFLLElBQUlGLE9BQU9JLGVBQWU7QUFDNUUsTUFBTUMsc0JBQXNCSCxXQUFXLEtBQUssSUFBSUYsT0FBT00sU0FBUztBQUNoRSxTQUFTUCxXQUFXUSxLQUFLOztJQUNyQixNQUFNLEVBQUVDLFdBQVcsRUFBRUMsdUJBQXVCLEVBQUUsR0FBR0Y7SUFDakQsU0FBU0c7UUFDTCxJQUFJRixlQUFlQSxZQUFZRyxnQkFBZ0IsRUFBRTtZQUM3QyxNQUFNQyxlQUFlWixPQUFPYSxRQUFRLENBQUNDLE9BQU8sQ0FBQ0MsTUFBTUMsSUFBSSxDQUFDUixZQUFZRyxnQkFBZ0IsRUFBRU0sTUFBTSxDQUFDQztZQUM3RlYsWUFBWVcsVUFBVSxDQUFDVix3QkFBd0JHLGNBQWNMO1FBQ2pFO0lBQ0o7SUFDQSxJQUFJTCxVQUFVO1FBQ1YsSUFBSWtCO1FBQ0paLGVBQWUsT0FBTyxLQUFLLElBQUksQ0FBQ1ksZ0NBQWdDWixZQUFZRyxnQkFBZ0IsS0FBSyxPQUFPLEtBQUssSUFBSVMsOEJBQThCQyxHQUFHLENBQUNkLE1BQU1lLFFBQVE7UUFDaktaO0lBQ0o7SUFDQVAsMEJBQTBCO1FBQ3RCLElBQUlpQjtRQUNKWixlQUFlLE9BQU8sS0FBSyxJQUFJLENBQUNZLGdDQUFnQ1osWUFBWUcsZ0JBQWdCLEtBQUssT0FBTyxLQUFLLElBQUlTLDhCQUE4QkMsR0FBRyxDQUFDZCxNQUFNZSxRQUFRO1FBQ2pLLE9BQU87WUFDSCxJQUFJRjtZQUNKWixlQUFlLE9BQU8sS0FBSyxJQUFJLENBQUNZLGdDQUFnQ1osWUFBWUcsZ0JBQWdCLEtBQUssT0FBTyxLQUFLLElBQUlTLDhCQUE4QkcsTUFBTSxDQUFDaEIsTUFBTWUsUUFBUTtRQUN4SztJQUNKO0lBQ0Esa0ZBQWtGO0lBQ2xGLG9GQUFvRjtJQUNwRixnRUFBZ0U7SUFDaEUscUZBQXFGO0lBQ3JGLG1GQUFtRjtJQUNuRm5CLDBCQUEwQjtRQUN0QixJQUFJSyxhQUFhO1lBQ2JBLFlBQVlnQixjQUFjLEdBQUdkO1FBQ2pDO1FBQ0EsT0FBTztZQUNILElBQUlGLGFBQWE7Z0JBQ2JBLFlBQVlnQixjQUFjLEdBQUdkO1lBQ2pDO1FBQ0o7SUFDSjtJQUNBTCxvQkFBb0I7UUFDaEIsSUFBSUcsZUFBZUEsWUFBWWdCLGNBQWMsRUFBRTtZQUMzQ2hCLFlBQVlnQixjQUFjO1lBQzFCaEIsWUFBWWdCLGNBQWMsR0FBRztRQUNqQztRQUNBLE9BQU87WUFDSCxJQUFJaEIsZUFBZUEsWUFBWWdCLGNBQWMsRUFBRTtnQkFDM0NoQixZQUFZZ0IsY0FBYztnQkFDMUJoQixZQUFZZ0IsY0FBYyxHQUFHO1lBQ2pDO1FBQ0o7SUFDSjtJQUNBLE9BQU87QUFDWCxFQUVBLHVDQUF1QztHQW5EOUJ6Qjs7UUFhTEk7UUFhQUE7UUFVQUU7OztLQXBDS04iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9zaGFyZWQvbGliL3NpZGUtZWZmZWN0LmpzPzQwOGMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWZhdWx0XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBTaWRlRWZmZWN0O1xuICAgIH1cbn0pO1xuY29uc3QgX3JlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xuY29uc3QgaXNTZXJ2ZXIgPSB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiO1xuY29uc3QgdXNlQ2xpZW50T25seUxheW91dEVmZmVjdCA9IGlzU2VydmVyID8gKCk9Pnt9IDogX3JlYWN0LnVzZUxheW91dEVmZmVjdDtcbmNvbnN0IHVzZUNsaWVudE9ubHlFZmZlY3QgPSBpc1NlcnZlciA/ICgpPT57fSA6IF9yZWFjdC51c2VFZmZlY3Q7XG5mdW5jdGlvbiBTaWRlRWZmZWN0KHByb3BzKSB7XG4gICAgY29uc3QgeyBoZWFkTWFuYWdlciwgcmVkdWNlQ29tcG9uZW50c1RvU3RhdGUgfSA9IHByb3BzO1xuICAgIGZ1bmN0aW9uIGVtaXRDaGFuZ2UoKSB7XG4gICAgICAgIGlmIChoZWFkTWFuYWdlciAmJiBoZWFkTWFuYWdlci5tb3VudGVkSW5zdGFuY2VzKSB7XG4gICAgICAgICAgICBjb25zdCBoZWFkRWxlbWVudHMgPSBfcmVhY3QuQ2hpbGRyZW4udG9BcnJheShBcnJheS5mcm9tKGhlYWRNYW5hZ2VyLm1vdW50ZWRJbnN0YW5jZXMpLmZpbHRlcihCb29sZWFuKSk7XG4gICAgICAgICAgICBoZWFkTWFuYWdlci51cGRhdGVIZWFkKHJlZHVjZUNvbXBvbmVudHNUb1N0YXRlKGhlYWRFbGVtZW50cywgcHJvcHMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNTZXJ2ZXIpIHtcbiAgICAgICAgdmFyIF9oZWFkTWFuYWdlcl9tb3VudGVkSW5zdGFuY2VzO1xuICAgICAgICBoZWFkTWFuYWdlciA9PSBudWxsID8gdm9pZCAwIDogKF9oZWFkTWFuYWdlcl9tb3VudGVkSW5zdGFuY2VzID0gaGVhZE1hbmFnZXIubW91bnRlZEluc3RhbmNlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9oZWFkTWFuYWdlcl9tb3VudGVkSW5zdGFuY2VzLmFkZChwcm9wcy5jaGlsZHJlbik7XG4gICAgICAgIGVtaXRDaGFuZ2UoKTtcbiAgICB9XG4gICAgdXNlQ2xpZW50T25seUxheW91dEVmZmVjdCgoKT0+e1xuICAgICAgICB2YXIgX2hlYWRNYW5hZ2VyX21vdW50ZWRJbnN0YW5jZXM7XG4gICAgICAgIGhlYWRNYW5hZ2VyID09IG51bGwgPyB2b2lkIDAgOiAoX2hlYWRNYW5hZ2VyX21vdW50ZWRJbnN0YW5jZXMgPSBoZWFkTWFuYWdlci5tb3VudGVkSW5zdGFuY2VzKSA9PSBudWxsID8gdm9pZCAwIDogX2hlYWRNYW5hZ2VyX21vdW50ZWRJbnN0YW5jZXMuYWRkKHByb3BzLmNoaWxkcmVuKTtcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICB2YXIgX2hlYWRNYW5hZ2VyX21vdW50ZWRJbnN0YW5jZXM7XG4gICAgICAgICAgICBoZWFkTWFuYWdlciA9PSBudWxsID8gdm9pZCAwIDogKF9oZWFkTWFuYWdlcl9tb3VudGVkSW5zdGFuY2VzID0gaGVhZE1hbmFnZXIubW91bnRlZEluc3RhbmNlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9oZWFkTWFuYWdlcl9tb3VudGVkSW5zdGFuY2VzLmRlbGV0ZShwcm9wcy5jaGlsZHJlbik7XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgLy8gV2UgbmVlZCB0byBjYWxsIGB1cGRhdGVIZWFkYCBtZXRob2Qgd2hlbmV2ZXIgdGhlIGBTaWRlRWZmZWN0YCBpcyB0cmlnZ2VyIGluIGFsbFxuICAgIC8vIGxpZmUtY3ljbGVzOiBtb3VudCwgdXBkYXRlLCB1bm1vdW50LiBIb3dldmVyLCBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgYFNpZGVFZmZlY3Rgc1xuICAgIC8vIGJlaW5nIHJlbmRlcmVkLCB3ZSBvbmx5IHRyaWdnZXIgdGhlIG1ldGhvZCBmcm9tIHRoZSBsYXN0IG9uZS5cbiAgICAvLyBUaGlzIGlzIGVuc3VyZWQgYnkga2VlcGluZyB0aGUgbGFzdCB1bmZsdXNoZWQgYHVwZGF0ZUhlYWRgIGluIHRoZSBgX3BlbmRpbmdVcGRhdGVgXG4gICAgLy8gc2luZ2xldG9uIGluIHRoZSBsYXlvdXQgZWZmZWN0IHBhc3MsIGFuZCBhY3R1YWxseSB0cmlnZ2VyIGl0IGluIHRoZSBlZmZlY3QgcGFzcy5cbiAgICB1c2VDbGllbnRPbmx5TGF5b3V0RWZmZWN0KCgpPT57XG4gICAgICAgIGlmIChoZWFkTWFuYWdlcikge1xuICAgICAgICAgICAgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUgPSBlbWl0Q2hhbmdlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgaWYgKGhlYWRNYW5hZ2VyKSB7XG4gICAgICAgICAgICAgICAgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUgPSBlbWl0Q2hhbmdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHVzZUNsaWVudE9ubHlFZmZlY3QoKCk9PntcbiAgICAgICAgaWYgKGhlYWRNYW5hZ2VyICYmIGhlYWRNYW5hZ2VyLl9wZW5kaW5nVXBkYXRlKSB7XG4gICAgICAgICAgICBoZWFkTWFuYWdlci5fcGVuZGluZ1VwZGF0ZSgpO1xuICAgICAgICAgICAgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKT0+e1xuICAgICAgICAgICAgaWYgKGhlYWRNYW5hZ2VyICYmIGhlYWRNYW5hZ2VyLl9wZW5kaW5nVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgaGVhZE1hbmFnZXIuX3BlbmRpbmdVcGRhdGUoKTtcbiAgICAgICAgICAgICAgICBoZWFkTWFuYWdlci5fcGVuZGluZ1VwZGF0ZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZGUtZWZmZWN0LmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJTaWRlRWZmZWN0IiwiX3JlYWN0IiwicmVxdWlyZSIsImlzU2VydmVyIiwidXNlQ2xpZW50T25seUxheW91dEVmZmVjdCIsInVzZUxheW91dEVmZmVjdCIsInVzZUNsaWVudE9ubHlFZmZlY3QiLCJ1c2VFZmZlY3QiLCJwcm9wcyIsImhlYWRNYW5hZ2VyIiwicmVkdWNlQ29tcG9uZW50c1RvU3RhdGUiLCJlbWl0Q2hhbmdlIiwibW91bnRlZEluc3RhbmNlcyIsImhlYWRFbGVtZW50cyIsIkNoaWxkcmVuIiwidG9BcnJheSIsIkFycmF5IiwiZnJvbSIsImZpbHRlciIsIkJvb2xlYW4iLCJ1cGRhdGVIZWFkIiwiX2hlYWRNYW5hZ2VyX21vdW50ZWRJbnN0YW5jZXMiLCJhZGQiLCJjaGlsZHJlbiIsImRlbGV0ZSIsIl9wZW5kaW5nVXBkYXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/shared/lib/side-effect.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@imgly/background-removal/dist/index.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/@imgly/background-removal/dist/index.mjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   alphamask: function() { return /* binding */ alphamask; },\n/* harmony export */   applySegmentationMask: function() { return /* binding */ applySegmentationMask; },\n/* harmony export */   preload: function() { return /* binding */ preload; },\n/* harmony export */   removeBackground: function() { return /* binding */ removeBackground; },\n/* harmony export */   removeForeground: function() { return /* binding */ removeForeground; },\n/* harmony export */   segmentForeground: function() { return /* binding */ segmentForeground; }\n/* harmony export */ });\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod)=>function __require() {\n        return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {\n            exports: {}\n        }).exports, mod), mod.exports;\n    };\nvar __copyProps = (to, from, except, desc)=>{\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n            get: ()=>from[key],\n            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n        });\n    }\n    return to;\n};\nvar __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM\n    // file that has been converted to a CommonJS file using a Babel-\n    // compatible transform (i.e. \"__esModule\" has not been set), then set\n    // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n    isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n        value: mod,\n        enumerable: true\n    }) : target, mod));\n// ../../node_modules/lodash/lodash.js\nvar require_lodash = __commonJS({\n    \"../../node_modules/lodash/lodash.js\" (exports, module) {\n        (function() {\n            var undefined2;\n            var VERSION = \"4.17.21\";\n            var LARGE_ARRAY_SIZE = 200;\n            var CORE_ERROR_TEXT = \"Unsupported core-js use. Try https://npms.io/search?q=ponyfill.\", FUNC_ERROR_TEXT = \"Expected a function\", INVALID_TEMPL_VAR_ERROR_TEXT = \"Invalid `variable` option passed into `_.template`\";\n            var HASH_UNDEFINED = \"__lodash_hash_undefined__\";\n            var MAX_MEMOIZE_SIZE = 500;\n            var PLACEHOLDER = \"__lodash_placeholder__\";\n            var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;\n            var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;\n            var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;\n            var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = \"...\";\n            var HOT_COUNT = 800, HOT_SPAN = 16;\n            var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;\n            var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;\n            var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;\n            var wrapFlags = [\n                [\n                    \"ary\",\n                    WRAP_ARY_FLAG\n                ],\n                [\n                    \"bind\",\n                    WRAP_BIND_FLAG\n                ],\n                [\n                    \"bindKey\",\n                    WRAP_BIND_KEY_FLAG\n                ],\n                [\n                    \"curry\",\n                    WRAP_CURRY_FLAG\n                ],\n                [\n                    \"curryRight\",\n                    WRAP_CURRY_RIGHT_FLAG\n                ],\n                [\n                    \"flip\",\n                    WRAP_FLIP_FLAG\n                ],\n                [\n                    \"partial\",\n                    WRAP_PARTIAL_FLAG\n                ],\n                [\n                    \"partialRight\",\n                    WRAP_PARTIAL_RIGHT_FLAG\n                ],\n                [\n                    \"rearg\",\n                    WRAP_REARG_FLAG\n                ]\n            ];\n            var argsTag = \"[object Arguments]\", arrayTag = \"[object Array]\", asyncTag = \"[object AsyncFunction]\", boolTag = \"[object Boolean]\", dateTag = \"[object Date]\", domExcTag = \"[object DOMException]\", errorTag = \"[object Error]\", funcTag = \"[object Function]\", genTag = \"[object GeneratorFunction]\", mapTag = \"[object Map]\", numberTag = \"[object Number]\", nullTag = \"[object Null]\", objectTag = \"[object Object]\", promiseTag = \"[object Promise]\", proxyTag = \"[object Proxy]\", regexpTag = \"[object RegExp]\", setTag = \"[object Set]\", stringTag = \"[object String]\", symbolTag = \"[object Symbol]\", undefinedTag = \"[object Undefined]\", weakMapTag = \"[object WeakMap]\", weakSetTag = \"[object WeakSet]\";\n            var arrayBufferTag = \"[object ArrayBuffer]\", dataViewTag = \"[object DataView]\", float32Tag = \"[object Float32Array]\", float64Tag = \"[object Float64Array]\", int8Tag = \"[object Int8Array]\", int16Tag = \"[object Int16Array]\", int32Tag = \"[object Int32Array]\", uint8Tag = \"[object Uint8Array]\", uint8ClampedTag = \"[object Uint8ClampedArray]\", uint16Tag = \"[object Uint16Array]\", uint32Tag = \"[object Uint32Array]\";\n            var reEmptyStringLeading = /\\b__p \\+= '';/g, reEmptyStringMiddle = /\\b(__p \\+=) '' \\+/g, reEmptyStringTrailing = /(__e\\(.*?\\)|\\b__t\\)) \\+\\n'';/g;\n            var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>\"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);\n            var reEscape = /<%-([\\s\\S]+?)%>/g, reEvaluate = /<%([\\s\\S]+?)%>/g, reInterpolate = /<%=([\\s\\S]+?)%>/g;\n            var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/, reIsPlainProp = /^\\w*$/, rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n            var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);\n            var reTrimStart = /^\\s+/;\n            var reWhitespace = /\\s/;\n            var reWrapComment = /\\{(?:\\n\\/\\* \\[wrapped with .+\\] \\*\\/)?\\n?/, reWrapDetails = /\\{\\n\\/\\* \\[wrapped with (.+)\\] \\*/, reSplitDetails = /,? & /;\n            var reAsciiWord = /[^\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\x7f]+/g;\n            var reForbiddenIdentifierChars = /[()=,{}\\[\\]\\/\\s]/;\n            var reEscapeChar = /\\\\(\\\\)?/g;\n            var reEsTemplate = /\\$\\{([^\\\\}]*(?:\\\\.[^\\\\}]*)*)\\}/g;\n            var reFlags = /\\w*$/;\n            var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n            var reIsBinary = /^0b[01]+$/i;\n            var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n            var reIsOctal = /^0o[0-7]+$/i;\n            var reIsUint = /^(?:0|[1-9]\\d*)$/;\n            var reLatin = /[\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\xff\\u0100-\\u017f]/g;\n            var reNoMatch = /($^)/;\n            var reUnescapedString = /['\\n\\r\\u2028\\u2029\\\\]/g;\n            var rsAstralRange = \"\\ud800-\\udfff\", rsComboMarksRange = \"\\\\u0300-\\\\u036f\", reComboHalfMarksRange = \"\\\\ufe20-\\\\ufe2f\", rsComboSymbolsRange = \"\\\\u20d0-\\\\u20ff\", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = \"\\\\u2700-\\\\u27bf\", rsLowerRange = \"a-z\\\\xdf-\\\\xf6\\\\xf8-\\\\xff\", rsMathOpRange = \"\\\\xac\\\\xb1\\\\xd7\\\\xf7\", rsNonCharRange = \"\\\\x00-\\\\x2f\\\\x3a-\\\\x40\\\\x5b-\\\\x60\\\\x7b-\\\\xbf\", rsPunctuationRange = \"\\\\u2000-\\\\u206f\", rsSpaceRange = \" \\\\t\\\\x0b\\\\f\\\\xa0\\\\ufeff\\\\n\\\\r\\\\u2028\\\\u2029\\\\u1680\\\\u180e\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200a\\\\u202f\\\\u205f\\\\u3000\", rsUpperRange = \"A-Z\\\\xc0-\\\\xd6\\\\xd8-\\\\xde\", rsVarRange = \"\\\\ufe0e\\\\ufe0f\", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;\n            var rsApos = \"[']\", rsAstral = \"[\" + rsAstralRange + \"]\", rsBreak = \"[\" + rsBreakRange + \"]\", rsCombo = \"[\" + rsComboRange + \"]\", rsDigits = \"\\\\d+\", rsDingbat = \"[\" + rsDingbatRange + \"]\", rsLower = \"[\" + rsLowerRange + \"]\", rsMisc = \"[^\" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + \"]\", rsFitz = \"\\ud83c[\\udffb-\\udfff]\", rsModifier = \"(?:\" + rsCombo + \"|\" + rsFitz + \")\", rsNonAstral = \"[^\" + rsAstralRange + \"]\", rsRegional = \"(?:\\ud83c[\\udde6-\\uddff]){2}\", rsSurrPair = \"[\\ud800-\\udbff][\\udc00-\\udfff]\", rsUpper = \"[\" + rsUpperRange + \"]\", rsZWJ = \"\\\\u200d\";\n            var rsMiscLower = \"(?:\" + rsLower + \"|\" + rsMisc + \")\", rsMiscUpper = \"(?:\" + rsUpper + \"|\" + rsMisc + \")\", rsOptContrLower = \"(?:\" + rsApos + \"(?:d|ll|m|re|s|t|ve))?\", rsOptContrUpper = \"(?:\" + rsApos + \"(?:D|LL|M|RE|S|T|VE))?\", reOptMod = rsModifier + \"?\", rsOptVar = \"[\" + rsVarRange + \"]?\", rsOptJoin = \"(?:\" + rsZWJ + \"(?:\" + [\n                rsNonAstral,\n                rsRegional,\n                rsSurrPair\n            ].join(\"|\") + \")\" + rsOptVar + reOptMod + \")*\", rsOrdLower = \"\\\\d*(?:1st|2nd|3rd|(?![123])\\\\dth)(?=\\\\b|[A-Z_])\", rsOrdUpper = \"\\\\d*(?:1ST|2ND|3RD|(?![123])\\\\dTH)(?=\\\\b|[a-z_])\", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = \"(?:\" + [\n                rsDingbat,\n                rsRegional,\n                rsSurrPair\n            ].join(\"|\") + \")\" + rsSeq, rsSymbol = \"(?:\" + [\n                rsNonAstral + rsCombo + \"?\",\n                rsCombo,\n                rsRegional,\n                rsSurrPair,\n                rsAstral\n            ].join(\"|\") + \")\";\n            var reApos = RegExp(rsApos, \"g\");\n            var reComboMark = RegExp(rsCombo, \"g\");\n            var reUnicode = RegExp(rsFitz + \"(?=\" + rsFitz + \")|\" + rsSymbol + rsSeq, \"g\");\n            var reUnicodeWord = RegExp([\n                rsUpper + \"?\" + rsLower + \"+\" + rsOptContrLower + \"(?=\" + [\n                    rsBreak,\n                    rsUpper,\n                    \"$\"\n                ].join(\"|\") + \")\",\n                rsMiscUpper + \"+\" + rsOptContrUpper + \"(?=\" + [\n                    rsBreak,\n                    rsUpper + rsMiscLower,\n                    \"$\"\n                ].join(\"|\") + \")\",\n                rsUpper + \"?\" + rsMiscLower + \"+\" + rsOptContrLower,\n                rsUpper + \"+\" + rsOptContrUpper,\n                rsOrdUpper,\n                rsOrdLower,\n                rsDigits,\n                rsEmoji\n            ].join(\"|\"), \"g\");\n            var reHasUnicode = RegExp(\"[\" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + \"]\");\n            var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;\n            var contextProps = [\n                \"Array\",\n                \"Buffer\",\n                \"DataView\",\n                \"Date\",\n                \"Error\",\n                \"Float32Array\",\n                \"Float64Array\",\n                \"Function\",\n                \"Int8Array\",\n                \"Int16Array\",\n                \"Int32Array\",\n                \"Map\",\n                \"Math\",\n                \"Object\",\n                \"Promise\",\n                \"RegExp\",\n                \"Set\",\n                \"String\",\n                \"Symbol\",\n                \"TypeError\",\n                \"Uint8Array\",\n                \"Uint8ClampedArray\",\n                \"Uint16Array\",\n                \"Uint32Array\",\n                \"WeakMap\",\n                \"_\",\n                \"clearTimeout\",\n                \"isFinite\",\n                \"parseInt\",\n                \"setTimeout\"\n            ];\n            var templateCounter = -1;\n            var typedArrayTags = {};\n            typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;\n            typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;\n            var cloneableTags = {};\n            cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\n            cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;\n            var deburredLetters = {\n                // Latin-1 Supplement block.\n                \"\\xc0\": \"A\",\n                \"\\xc1\": \"A\",\n                \"\\xc2\": \"A\",\n                \"\\xc3\": \"A\",\n                \"\\xc4\": \"A\",\n                \"\\xc5\": \"A\",\n                \"\\xe0\": \"a\",\n                \"\\xe1\": \"a\",\n                \"\\xe2\": \"a\",\n                \"\\xe3\": \"a\",\n                \"\\xe4\": \"a\",\n                \"\\xe5\": \"a\",\n                \"\\xc7\": \"C\",\n                \"\\xe7\": \"c\",\n                \"\\xd0\": \"D\",\n                \"\\xf0\": \"d\",\n                \"\\xc8\": \"E\",\n                \"\\xc9\": \"E\",\n                \"\\xca\": \"E\",\n                \"\\xcb\": \"E\",\n                \"\\xe8\": \"e\",\n                \"\\xe9\": \"e\",\n                \"\\xea\": \"e\",\n                \"\\xeb\": \"e\",\n                \"\\xcc\": \"I\",\n                \"\\xcd\": \"I\",\n                \"\\xce\": \"I\",\n                \"\\xcf\": \"I\",\n                \"\\xec\": \"i\",\n                \"\\xed\": \"i\",\n                \"\\xee\": \"i\",\n                \"\\xef\": \"i\",\n                \"\\xd1\": \"N\",\n                \"\\xf1\": \"n\",\n                \"\\xd2\": \"O\",\n                \"\\xd3\": \"O\",\n                \"\\xd4\": \"O\",\n                \"\\xd5\": \"O\",\n                \"\\xd6\": \"O\",\n                \"\\xd8\": \"O\",\n                \"\\xf2\": \"o\",\n                \"\\xf3\": \"o\",\n                \"\\xf4\": \"o\",\n                \"\\xf5\": \"o\",\n                \"\\xf6\": \"o\",\n                \"\\xf8\": \"o\",\n                \"\\xd9\": \"U\",\n                \"\\xda\": \"U\",\n                \"\\xdb\": \"U\",\n                \"\\xdc\": \"U\",\n                \"\\xf9\": \"u\",\n                \"\\xfa\": \"u\",\n                \"\\xfb\": \"u\",\n                \"\\xfc\": \"u\",\n                \"\\xdd\": \"Y\",\n                \"\\xfd\": \"y\",\n                \"\\xff\": \"y\",\n                \"\\xc6\": \"Ae\",\n                \"\\xe6\": \"ae\",\n                \"\\xde\": \"Th\",\n                \"\\xfe\": \"th\",\n                \"\\xdf\": \"ss\",\n                // Latin Extended-A block.\n                \"\": \"A\",\n                \"\": \"A\",\n                \"\": \"A\",\n                \"\": \"a\",\n                \"\": \"a\",\n                \"\": \"a\",\n                \"\": \"C\",\n                \"\": \"C\",\n                \"\": \"C\",\n                \"\": \"C\",\n                \"\": \"c\",\n                \"\": \"c\",\n                \"\": \"c\",\n                \"\": \"c\",\n                \"\": \"D\",\n                \"\": \"D\",\n                \"\": \"d\",\n                \"\": \"d\",\n                \"\": \"E\",\n                \"\": \"E\",\n                \"\": \"E\",\n                \"\": \"E\",\n                \"\": \"E\",\n                \"\": \"e\",\n                \"\": \"e\",\n                \"\": \"e\",\n                \"\": \"e\",\n                \"\": \"e\",\n                \"\": \"G\",\n                \"\": \"G\",\n                \"\": \"G\",\n                \"\": \"G\",\n                \"\": \"g\",\n                \"\": \"g\",\n                \"\": \"g\",\n                \"\": \"g\",\n                \"\": \"H\",\n                \"\": \"H\",\n                \"\": \"h\",\n                \"\": \"h\",\n                \"\": \"I\",\n                \"\": \"I\",\n                \"\": \"I\",\n                \"\": \"I\",\n                \"\": \"I\",\n                \"\": \"i\",\n                \"\": \"i\",\n                \"\": \"i\",\n                \"\": \"i\",\n                \"\": \"i\",\n                \"\": \"J\",\n                \"\": \"j\",\n                \"\": \"K\",\n                \"\": \"k\",\n                \"\": \"k\",\n                \"\": \"L\",\n                \"\": \"L\",\n                \"\": \"L\",\n                \"\": \"L\",\n                \"\": \"L\",\n                \"\": \"l\",\n                \"\": \"l\",\n                \"\": \"l\",\n                \"\": \"l\",\n                \"\": \"l\",\n                \"\": \"N\",\n                \"\": \"N\",\n                \"\": \"N\",\n                \"\": \"N\",\n                \"\": \"n\",\n                \"\": \"n\",\n                \"\": \"n\",\n                \"\": \"n\",\n                \"\": \"O\",\n                \"\": \"O\",\n                \"\": \"O\",\n                \"\": \"o\",\n                \"\": \"o\",\n                \"\": \"o\",\n                \"\": \"R\",\n                \"\": \"R\",\n                \"\": \"R\",\n                \"\": \"r\",\n                \"\": \"r\",\n                \"\": \"r\",\n                \"\": \"S\",\n                \"\": \"S\",\n                \"\": \"S\",\n                \"\": \"S\",\n                \"\": \"s\",\n                \"\": \"s\",\n                \"\": \"s\",\n                \"\": \"s\",\n                \"\": \"T\",\n                \"\": \"T\",\n                \"\": \"T\",\n                \"\": \"t\",\n                \"\": \"t\",\n                \"\": \"t\",\n                \"\": \"U\",\n                \"\": \"U\",\n                \"\": \"U\",\n                \"\": \"U\",\n                \"\": \"U\",\n                \"\": \"U\",\n                \"\": \"u\",\n                \"\": \"u\",\n                \"\": \"u\",\n                \"\": \"u\",\n                \"\": \"u\",\n                \"\": \"u\",\n                \"\": \"W\",\n                \"\": \"w\",\n                \"\": \"Y\",\n                \"\": \"y\",\n                \"\": \"Y\",\n                \"\": \"Z\",\n                \"\": \"Z\",\n                \"\": \"Z\",\n                \"\": \"z\",\n                \"\": \"z\",\n                \"\": \"z\",\n                \"\": \"IJ\",\n                \"\": \"ij\",\n                \"\": \"Oe\",\n                \"\": \"oe\",\n                \"\": \"'n\",\n                \"\": \"s\"\n            };\n            var htmlEscapes = {\n                \"&\": \"&amp;\",\n                \"<\": \"&lt;\",\n                \">\": \"&gt;\",\n                '\"': \"&quot;\",\n                \"'\": \"&#39;\"\n            };\n            var htmlUnescapes = {\n                \"&amp;\": \"&\",\n                \"&lt;\": \"<\",\n                \"&gt;\": \">\",\n                \"&quot;\": '\"',\n                \"&#39;\": \"'\"\n            };\n            var stringEscapes = {\n                \"\\\\\": \"\\\\\",\n                \"'\": \"'\",\n                \"\\n\": \"n\",\n                \"\\r\": \"r\",\n                \"\\u2028\": \"u2028\",\n                \"\\u2029\": \"u2029\"\n            };\n            var freeParseFloat = parseFloat, freeParseInt = parseInt;\n            var freeGlobal = typeof global == \"object\" && global && global.Object === Object && global;\n            var freeSelf = typeof self == \"object\" && self && self.Object === Object && self;\n            var root = freeGlobal || freeSelf || Function(\"return this\")();\n            var freeExports = typeof exports == \"object\" && exports && !exports.nodeType && exports;\n            var freeModule = freeExports && typeof module == \"object\" && module && !module.nodeType && module;\n            var moduleExports = freeModule && freeModule.exports === freeExports;\n            var freeProcess = moduleExports && freeGlobal.process;\n            var nodeUtil = function() {\n                try {\n                    var types = freeModule && freeModule.require && freeModule.require(\"util\").types;\n                    if (types) {\n                        return types;\n                    }\n                    return freeProcess && freeProcess.binding && freeProcess.binding(\"util\");\n                } catch (e) {}\n            }();\n            var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n            function apply(func, thisArg, args) {\n                switch(args.length){\n                    case 0:\n                        return func.call(thisArg);\n                    case 1:\n                        return func.call(thisArg, args[0]);\n                    case 2:\n                        return func.call(thisArg, args[0], args[1]);\n                    case 3:\n                        return func.call(thisArg, args[0], args[1], args[2]);\n                }\n                return func.apply(thisArg, args);\n            }\n            function arrayAggregator(array, setter, iteratee, accumulator) {\n                var index = -1, length = array == null ? 0 : array.length;\n                while(++index < length){\n                    var value = array[index];\n                    setter(accumulator, value, iteratee(value), array);\n                }\n                return accumulator;\n            }\n            function arrayEach(array, iteratee) {\n                var index = -1, length = array == null ? 0 : array.length;\n                while(++index < length){\n                    if (iteratee(array[index], index, array) === false) {\n                        break;\n                    }\n                }\n                return array;\n            }\n            function arrayEachRight(array, iteratee) {\n                var length = array == null ? 0 : array.length;\n                while(length--){\n                    if (iteratee(array[length], length, array) === false) {\n                        break;\n                    }\n                }\n                return array;\n            }\n            function arrayEvery(array, predicate) {\n                var index = -1, length = array == null ? 0 : array.length;\n                while(++index < length){\n                    if (!predicate(array[index], index, array)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n            function arrayFilter(array, predicate) {\n                var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];\n                while(++index < length){\n                    var value = array[index];\n                    if (predicate(value, index, array)) {\n                        result[resIndex++] = value;\n                    }\n                }\n                return result;\n            }\n            function arrayIncludes(array, value) {\n                var length = array == null ? 0 : array.length;\n                return !!length && baseIndexOf(array, value, 0) > -1;\n            }\n            function arrayIncludesWith(array, value, comparator) {\n                var index = -1, length = array == null ? 0 : array.length;\n                while(++index < length){\n                    if (comparator(value, array[index])) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n            function arrayMap(array, iteratee) {\n                var index = -1, length = array == null ? 0 : array.length, result = Array(length);\n                while(++index < length){\n                    result[index] = iteratee(array[index], index, array);\n                }\n                return result;\n            }\n            function arrayPush(array, values) {\n                var index = -1, length = values.length, offset = array.length;\n                while(++index < length){\n                    array[offset + index] = values[index];\n                }\n                return array;\n            }\n            function arrayReduce(array, iteratee, accumulator, initAccum) {\n                var index = -1, length = array == null ? 0 : array.length;\n                if (initAccum && length) {\n                    accumulator = array[++index];\n                }\n                while(++index < length){\n                    accumulator = iteratee(accumulator, array[index], index, array);\n                }\n                return accumulator;\n            }\n            function arrayReduceRight(array, iteratee, accumulator, initAccum) {\n                var length = array == null ? 0 : array.length;\n                if (initAccum && length) {\n                    accumulator = array[--length];\n                }\n                while(length--){\n                    accumulator = iteratee(accumulator, array[length], length, array);\n                }\n                return accumulator;\n            }\n            function arraySome(array, predicate) {\n                var index = -1, length = array == null ? 0 : array.length;\n                while(++index < length){\n                    if (predicate(array[index], index, array)) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n            var asciiSize = baseProperty(\"length\");\n            function asciiToArray(string) {\n                return string.split(\"\");\n            }\n            function asciiWords(string) {\n                return string.match(reAsciiWord) || [];\n            }\n            function baseFindKey(collection, predicate, eachFunc) {\n                var result;\n                eachFunc(collection, function(value, key, collection2) {\n                    if (predicate(value, key, collection2)) {\n                        result = key;\n                        return false;\n                    }\n                });\n                return result;\n            }\n            function baseFindIndex(array, predicate, fromIndex, fromRight) {\n                var length = array.length, index = fromIndex + (fromRight ? 1 : -1);\n                while(fromRight ? index-- : ++index < length){\n                    if (predicate(array[index], index, array)) {\n                        return index;\n                    }\n                }\n                return -1;\n            }\n            function baseIndexOf(array, value, fromIndex) {\n                return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);\n            }\n            function baseIndexOfWith(array, value, fromIndex, comparator) {\n                var index = fromIndex - 1, length = array.length;\n                while(++index < length){\n                    if (comparator(array[index], value)) {\n                        return index;\n                    }\n                }\n                return -1;\n            }\n            function baseIsNaN(value) {\n                return value !== value;\n            }\n            function baseMean(array, iteratee) {\n                var length = array == null ? 0 : array.length;\n                return length ? baseSum(array, iteratee) / length : NAN;\n            }\n            function baseProperty(key) {\n                return function(object) {\n                    return object == null ? undefined2 : object[key];\n                };\n            }\n            function basePropertyOf(object) {\n                return function(key) {\n                    return object == null ? undefined2 : object[key];\n                };\n            }\n            function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {\n                eachFunc(collection, function(value, index, collection2) {\n                    accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);\n                });\n                return accumulator;\n            }\n            function baseSortBy(array, comparer) {\n                var length = array.length;\n                array.sort(comparer);\n                while(length--){\n                    array[length] = array[length].value;\n                }\n                return array;\n            }\n            function baseSum(array, iteratee) {\n                var result, index = -1, length = array.length;\n                while(++index < length){\n                    var current = iteratee(array[index]);\n                    if (current !== undefined2) {\n                        result = result === undefined2 ? current : result + current;\n                    }\n                }\n                return result;\n            }\n            function baseTimes(n, iteratee) {\n                var index = -1, result = Array(n);\n                while(++index < n){\n                    result[index] = iteratee(index);\n                }\n                return result;\n            }\n            function baseToPairs(object, props) {\n                return arrayMap(props, function(key) {\n                    return [\n                        key,\n                        object[key]\n                    ];\n                });\n            }\n            function baseTrim(string) {\n                return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, \"\") : string;\n            }\n            function baseUnary(func) {\n                return function(value) {\n                    return func(value);\n                };\n            }\n            function baseValues(object, props) {\n                return arrayMap(props, function(key) {\n                    return object[key];\n                });\n            }\n            function cacheHas(cache, key) {\n                return cache.has(key);\n            }\n            function charsStartIndex(strSymbols, chrSymbols) {\n                var index = -1, length = strSymbols.length;\n                while(++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1){}\n                return index;\n            }\n            function charsEndIndex(strSymbols, chrSymbols) {\n                var index = strSymbols.length;\n                while(index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1){}\n                return index;\n            }\n            function countHolders(array, placeholder) {\n                var length = array.length, result = 0;\n                while(length--){\n                    if (array[length] === placeholder) {\n                        ++result;\n                    }\n                }\n                return result;\n            }\n            var deburrLetter = basePropertyOf(deburredLetters);\n            var escapeHtmlChar = basePropertyOf(htmlEscapes);\n            function escapeStringChar(chr) {\n                return \"\\\\\" + stringEscapes[chr];\n            }\n            function getValue(object, key) {\n                return object == null ? undefined2 : object[key];\n            }\n            function hasUnicode(string) {\n                return reHasUnicode.test(string);\n            }\n            function hasUnicodeWord(string) {\n                return reHasUnicodeWord.test(string);\n            }\n            function iteratorToArray(iterator) {\n                var data, result = [];\n                while(!(data = iterator.next()).done){\n                    result.push(data.value);\n                }\n                return result;\n            }\n            function mapToArray(map) {\n                var index = -1, result = Array(map.size);\n                map.forEach(function(value, key) {\n                    result[++index] = [\n                        key,\n                        value\n                    ];\n                });\n                return result;\n            }\n            function overArg(func, transform) {\n                return function(arg) {\n                    return func(transform(arg));\n                };\n            }\n            function replaceHolders(array, placeholder) {\n                var index = -1, length = array.length, resIndex = 0, result = [];\n                while(++index < length){\n                    var value = array[index];\n                    if (value === placeholder || value === PLACEHOLDER) {\n                        array[index] = PLACEHOLDER;\n                        result[resIndex++] = index;\n                    }\n                }\n                return result;\n            }\n            function setToArray(set) {\n                var index = -1, result = Array(set.size);\n                set.forEach(function(value) {\n                    result[++index] = value;\n                });\n                return result;\n            }\n            function setToPairs(set) {\n                var index = -1, result = Array(set.size);\n                set.forEach(function(value) {\n                    result[++index] = [\n                        value,\n                        value\n                    ];\n                });\n                return result;\n            }\n            function strictIndexOf(array, value, fromIndex) {\n                var index = fromIndex - 1, length = array.length;\n                while(++index < length){\n                    if (array[index] === value) {\n                        return index;\n                    }\n                }\n                return -1;\n            }\n            function strictLastIndexOf(array, value, fromIndex) {\n                var index = fromIndex + 1;\n                while(index--){\n                    if (array[index] === value) {\n                        return index;\n                    }\n                }\n                return index;\n            }\n            function stringSize(string) {\n                return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);\n            }\n            function stringToArray(string) {\n                return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);\n            }\n            function trimmedEndIndex(string) {\n                var index = string.length;\n                while(index-- && reWhitespace.test(string.charAt(index))){}\n                return index;\n            }\n            var unescapeHtmlChar = basePropertyOf(htmlUnescapes);\n            function unicodeSize(string) {\n                var result = reUnicode.lastIndex = 0;\n                while(reUnicode.test(string)){\n                    ++result;\n                }\n                return result;\n            }\n            function unicodeToArray(string) {\n                return string.match(reUnicode) || [];\n            }\n            function unicodeWords(string) {\n                return string.match(reUnicodeWord) || [];\n            }\n            var runInContext = function runInContext2(context) {\n                context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));\n                var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;\n                var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;\n                var coreJsData = context[\"__core-js_shared__\"];\n                var funcToString = funcProto.toString;\n                var hasOwnProperty = objectProto.hasOwnProperty;\n                var idCounter = 0;\n                var maskSrcKey = function() {\n                    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || \"\");\n                    return uid ? \"Symbol(src)_1.\" + uid : \"\";\n                }();\n                var nativeObjectToString = objectProto.toString;\n                var objectCtorString = funcToString.call(Object2);\n                var oldDash = root._;\n                var reIsNative = RegExp2(\"^\" + funcToString.call(hasOwnProperty).replace(reRegExpChar, \"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\");\n                var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;\n                var defineProperty = function() {\n                    try {\n                        var func = getNative(Object2, \"defineProperty\");\n                        func({}, \"\", {});\n                        return func;\n                    } catch (e) {}\n                }();\n                var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;\n                var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;\n                var DataView = getNative(context, \"DataView\"), Map2 = getNative(context, \"Map\"), Promise2 = getNative(context, \"Promise\"), Set2 = getNative(context, \"Set\"), WeakMap2 = getNative(context, \"WeakMap\"), nativeCreate = getNative(Object2, \"create\");\n                var metaMap = WeakMap2 && new WeakMap2();\n                var realNames = {};\n                var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);\n                var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;\n                function lodash(value) {\n                    if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {\n                        if (value instanceof LodashWrapper) {\n                            return value;\n                        }\n                        if (hasOwnProperty.call(value, \"__wrapped__\")) {\n                            return wrapperClone(value);\n                        }\n                    }\n                    return new LodashWrapper(value);\n                }\n                var baseCreate = function() {\n                    function object() {}\n                    return function(proto) {\n                        if (!isObject(proto)) {\n                            return {};\n                        }\n                        if (objectCreate) {\n                            return objectCreate(proto);\n                        }\n                        object.prototype = proto;\n                        var result2 = new object();\n                        object.prototype = undefined2;\n                        return result2;\n                    };\n                }();\n                function baseLodash() {}\n                function LodashWrapper(value, chainAll) {\n                    this.__wrapped__ = value;\n                    this.__actions__ = [];\n                    this.__chain__ = !!chainAll;\n                    this.__index__ = 0;\n                    this.__values__ = undefined2;\n                }\n                lodash.templateSettings = {\n                    /**\n           * Used to detect `data` property values to be HTML-escaped.\n           *\n           * @memberOf _.templateSettings\n           * @type {RegExp}\n           */ \"escape\": reEscape,\n                    /**\n           * Used to detect code to be evaluated.\n           *\n           * @memberOf _.templateSettings\n           * @type {RegExp}\n           */ \"evaluate\": reEvaluate,\n                    /**\n           * Used to detect `data` property values to inject.\n           *\n           * @memberOf _.templateSettings\n           * @type {RegExp}\n           */ \"interpolate\": reInterpolate,\n                    /**\n           * Used to reference the data object in the template text.\n           *\n           * @memberOf _.templateSettings\n           * @type {string}\n           */ \"variable\": \"\",\n                    /**\n           * Used to import variables into the compiled template.\n           *\n           * @memberOf _.templateSettings\n           * @type {Object}\n           */ \"imports\": {\n                        /**\n             * A reference to the `lodash` function.\n             *\n             * @memberOf _.templateSettings.imports\n             * @type {Function}\n             */ \"_\": lodash\n                    }\n                };\n                lodash.prototype = baseLodash.prototype;\n                lodash.prototype.constructor = lodash;\n                LodashWrapper.prototype = baseCreate(baseLodash.prototype);\n                LodashWrapper.prototype.constructor = LodashWrapper;\n                function LazyWrapper(value) {\n                    this.__wrapped__ = value;\n                    this.__actions__ = [];\n                    this.__dir__ = 1;\n                    this.__filtered__ = false;\n                    this.__iteratees__ = [];\n                    this.__takeCount__ = MAX_ARRAY_LENGTH;\n                    this.__views__ = [];\n                }\n                function lazyClone() {\n                    var result2 = new LazyWrapper(this.__wrapped__);\n                    result2.__actions__ = copyArray(this.__actions__);\n                    result2.__dir__ = this.__dir__;\n                    result2.__filtered__ = this.__filtered__;\n                    result2.__iteratees__ = copyArray(this.__iteratees__);\n                    result2.__takeCount__ = this.__takeCount__;\n                    result2.__views__ = copyArray(this.__views__);\n                    return result2;\n                }\n                function lazyReverse() {\n                    if (this.__filtered__) {\n                        var result2 = new LazyWrapper(this);\n                        result2.__dir__ = -1;\n                        result2.__filtered__ = true;\n                    } else {\n                        result2 = this.clone();\n                        result2.__dir__ *= -1;\n                    }\n                    return result2;\n                }\n                function lazyValue() {\n                    var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);\n                    if (!isArr || !isRight && arrLength == length && takeCount == length) {\n                        return baseWrapperValue(array, this.__actions__);\n                    }\n                    var result2 = [];\n                    outer: while(length-- && resIndex < takeCount){\n                        index += dir;\n                        var iterIndex = -1, value = array[index];\n                        while(++iterIndex < iterLength){\n                            var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);\n                            if (type == LAZY_MAP_FLAG) {\n                                value = computed;\n                            } else if (!computed) {\n                                if (type == LAZY_FILTER_FLAG) {\n                                    continue outer;\n                                } else {\n                                    break outer;\n                                }\n                            }\n                        }\n                        result2[resIndex++] = value;\n                    }\n                    return result2;\n                }\n                LazyWrapper.prototype = baseCreate(baseLodash.prototype);\n                LazyWrapper.prototype.constructor = LazyWrapper;\n                function Hash(entries) {\n                    var index = -1, length = entries == null ? 0 : entries.length;\n                    this.clear();\n                    while(++index < length){\n                        var entry = entries[index];\n                        this.set(entry[0], entry[1]);\n                    }\n                }\n                function hashClear() {\n                    this.__data__ = nativeCreate ? nativeCreate(null) : {};\n                    this.size = 0;\n                }\n                function hashDelete(key) {\n                    var result2 = this.has(key) && delete this.__data__[key];\n                    this.size -= result2 ? 1 : 0;\n                    return result2;\n                }\n                function hashGet(key) {\n                    var data = this.__data__;\n                    if (nativeCreate) {\n                        var result2 = data[key];\n                        return result2 === HASH_UNDEFINED ? undefined2 : result2;\n                    }\n                    return hasOwnProperty.call(data, key) ? data[key] : undefined2;\n                }\n                function hashHas(key) {\n                    var data = this.__data__;\n                    return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);\n                }\n                function hashSet(key, value) {\n                    var data = this.__data__;\n                    this.size += this.has(key) ? 0 : 1;\n                    data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;\n                    return this;\n                }\n                Hash.prototype.clear = hashClear;\n                Hash.prototype[\"delete\"] = hashDelete;\n                Hash.prototype.get = hashGet;\n                Hash.prototype.has = hashHas;\n                Hash.prototype.set = hashSet;\n                function ListCache(entries) {\n                    var index = -1, length = entries == null ? 0 : entries.length;\n                    this.clear();\n                    while(++index < length){\n                        var entry = entries[index];\n                        this.set(entry[0], entry[1]);\n                    }\n                }\n                function listCacheClear() {\n                    this.__data__ = [];\n                    this.size = 0;\n                }\n                function listCacheDelete(key) {\n                    var data = this.__data__, index = assocIndexOf(data, key);\n                    if (index < 0) {\n                        return false;\n                    }\n                    var lastIndex = data.length - 1;\n                    if (index == lastIndex) {\n                        data.pop();\n                    } else {\n                        splice.call(data, index, 1);\n                    }\n                    --this.size;\n                    return true;\n                }\n                function listCacheGet(key) {\n                    var data = this.__data__, index = assocIndexOf(data, key);\n                    return index < 0 ? undefined2 : data[index][1];\n                }\n                function listCacheHas(key) {\n                    return assocIndexOf(this.__data__, key) > -1;\n                }\n                function listCacheSet(key, value) {\n                    var data = this.__data__, index = assocIndexOf(data, key);\n                    if (index < 0) {\n                        ++this.size;\n                        data.push([\n                            key,\n                            value\n                        ]);\n                    } else {\n                        data[index][1] = value;\n                    }\n                    return this;\n                }\n                ListCache.prototype.clear = listCacheClear;\n                ListCache.prototype[\"delete\"] = listCacheDelete;\n                ListCache.prototype.get = listCacheGet;\n                ListCache.prototype.has = listCacheHas;\n                ListCache.prototype.set = listCacheSet;\n                function MapCache(entries) {\n                    var index = -1, length = entries == null ? 0 : entries.length;\n                    this.clear();\n                    while(++index < length){\n                        var entry = entries[index];\n                        this.set(entry[0], entry[1]);\n                    }\n                }\n                function mapCacheClear() {\n                    this.size = 0;\n                    this.__data__ = {\n                        \"hash\": new Hash(),\n                        \"map\": new (Map2 || ListCache)(),\n                        \"string\": new Hash()\n                    };\n                }\n                function mapCacheDelete(key) {\n                    var result2 = getMapData(this, key)[\"delete\"](key);\n                    this.size -= result2 ? 1 : 0;\n                    return result2;\n                }\n                function mapCacheGet(key) {\n                    return getMapData(this, key).get(key);\n                }\n                function mapCacheHas(key) {\n                    return getMapData(this, key).has(key);\n                }\n                function mapCacheSet(key, value) {\n                    var data = getMapData(this, key), size2 = data.size;\n                    data.set(key, value);\n                    this.size += data.size == size2 ? 0 : 1;\n                    return this;\n                }\n                MapCache.prototype.clear = mapCacheClear;\n                MapCache.prototype[\"delete\"] = mapCacheDelete;\n                MapCache.prototype.get = mapCacheGet;\n                MapCache.prototype.has = mapCacheHas;\n                MapCache.prototype.set = mapCacheSet;\n                function SetCache(values2) {\n                    var index = -1, length = values2 == null ? 0 : values2.length;\n                    this.__data__ = new MapCache();\n                    while(++index < length){\n                        this.add(values2[index]);\n                    }\n                }\n                function setCacheAdd(value) {\n                    this.__data__.set(value, HASH_UNDEFINED);\n                    return this;\n                }\n                function setCacheHas(value) {\n                    return this.__data__.has(value);\n                }\n                SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\n                SetCache.prototype.has = setCacheHas;\n                function Stack(entries) {\n                    var data = this.__data__ = new ListCache(entries);\n                    this.size = data.size;\n                }\n                function stackClear() {\n                    this.__data__ = new ListCache();\n                    this.size = 0;\n                }\n                function stackDelete(key) {\n                    var data = this.__data__, result2 = data[\"delete\"](key);\n                    this.size = data.size;\n                    return result2;\n                }\n                function stackGet(key) {\n                    return this.__data__.get(key);\n                }\n                function stackHas(key) {\n                    return this.__data__.has(key);\n                }\n                function stackSet(key, value) {\n                    var data = this.__data__;\n                    if (data instanceof ListCache) {\n                        var pairs = data.__data__;\n                        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {\n                            pairs.push([\n                                key,\n                                value\n                            ]);\n                            this.size = ++data.size;\n                            return this;\n                        }\n                        data = this.__data__ = new MapCache(pairs);\n                    }\n                    data.set(key, value);\n                    this.size = data.size;\n                    return this;\n                }\n                Stack.prototype.clear = stackClear;\n                Stack.prototype[\"delete\"] = stackDelete;\n                Stack.prototype.get = stackGet;\n                Stack.prototype.has = stackHas;\n                Stack.prototype.set = stackSet;\n                function arrayLikeKeys(value, inherited) {\n                    var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;\n                    for(var key in value){\n                        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.\n                        (key == \"length\" || // Node.js 0.10 has enumerable non-index properties on buffers.\n                        isBuff && (key == \"offset\" || key == \"parent\") || // PhantomJS 2 has enumerable non-index properties on typed arrays.\n                        isType && (key == \"buffer\" || key == \"byteLength\" || key == \"byteOffset\") || // Skip index properties.\n                        isIndex(key, length)))) {\n                            result2.push(key);\n                        }\n                    }\n                    return result2;\n                }\n                function arraySample(array) {\n                    var length = array.length;\n                    return length ? array[baseRandom(0, length - 1)] : undefined2;\n                }\n                function arraySampleSize(array, n) {\n                    return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));\n                }\n                function arrayShuffle(array) {\n                    return shuffleSelf(copyArray(array));\n                }\n                function assignMergeValue(object, key, value) {\n                    if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {\n                        baseAssignValue(object, key, value);\n                    }\n                }\n                function assignValue(object, key, value) {\n                    var objValue = object[key];\n                    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {\n                        baseAssignValue(object, key, value);\n                    }\n                }\n                function assocIndexOf(array, key) {\n                    var length = array.length;\n                    while(length--){\n                        if (eq(array[length][0], key)) {\n                            return length;\n                        }\n                    }\n                    return -1;\n                }\n                function baseAggregator(collection, setter, iteratee2, accumulator) {\n                    baseEach(collection, function(value, key, collection2) {\n                        setter(accumulator, value, iteratee2(value), collection2);\n                    });\n                    return accumulator;\n                }\n                function baseAssign(object, source) {\n                    return object && copyObject(source, keys(source), object);\n                }\n                function baseAssignIn(object, source) {\n                    return object && copyObject(source, keysIn(source), object);\n                }\n                function baseAssignValue(object, key, value) {\n                    if (key == \"__proto__\" && defineProperty) {\n                        defineProperty(object, key, {\n                            \"configurable\": true,\n                            \"enumerable\": true,\n                            \"value\": value,\n                            \"writable\": true\n                        });\n                    } else {\n                        object[key] = value;\n                    }\n                }\n                function baseAt(object, paths) {\n                    var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;\n                    while(++index < length){\n                        result2[index] = skip ? undefined2 : get(object, paths[index]);\n                    }\n                    return result2;\n                }\n                function baseClamp(number, lower, upper) {\n                    if (number === number) {\n                        if (upper !== undefined2) {\n                            number = number <= upper ? number : upper;\n                        }\n                        if (lower !== undefined2) {\n                            number = number >= lower ? number : lower;\n                        }\n                    }\n                    return number;\n                }\n                function baseClone(value, bitmask, customizer, key, object, stack) {\n                    var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;\n                    if (customizer) {\n                        result2 = object ? customizer(value, key, object, stack) : customizer(value);\n                    }\n                    if (result2 !== undefined2) {\n                        return result2;\n                    }\n                    if (!isObject(value)) {\n                        return value;\n                    }\n                    var isArr = isArray(value);\n                    if (isArr) {\n                        result2 = initCloneArray(value);\n                        if (!isDeep) {\n                            return copyArray(value, result2);\n                        }\n                    } else {\n                        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;\n                        if (isBuffer(value)) {\n                            return cloneBuffer(value, isDeep);\n                        }\n                        if (tag == objectTag || tag == argsTag || isFunc && !object) {\n                            result2 = isFlat || isFunc ? {} : initCloneObject(value);\n                            if (!isDeep) {\n                                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));\n                            }\n                        } else {\n                            if (!cloneableTags[tag]) {\n                                return object ? value : {};\n                            }\n                            result2 = initCloneByTag(value, tag, isDeep);\n                        }\n                    }\n                    stack || (stack = new Stack());\n                    var stacked = stack.get(value);\n                    if (stacked) {\n                        return stacked;\n                    }\n                    stack.set(value, result2);\n                    if (isSet(value)) {\n                        value.forEach(function(subValue) {\n                            result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\n                        });\n                    } else if (isMap(value)) {\n                        value.forEach(function(subValue, key2) {\n                            result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));\n                        });\n                    }\n                    var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;\n                    var props = isArr ? undefined2 : keysFunc(value);\n                    arrayEach(props || value, function(subValue, key2) {\n                        if (props) {\n                            key2 = subValue;\n                            subValue = value[key2];\n                        }\n                        assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));\n                    });\n                    return result2;\n                }\n                function baseConforms(source) {\n                    var props = keys(source);\n                    return function(object) {\n                        return baseConformsTo(object, source, props);\n                    };\n                }\n                function baseConformsTo(object, source, props) {\n                    var length = props.length;\n                    if (object == null) {\n                        return !length;\n                    }\n                    object = Object2(object);\n                    while(length--){\n                        var key = props[length], predicate = source[key], value = object[key];\n                        if (value === undefined2 && !(key in object) || !predicate(value)) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n                function baseDelay(func, wait, args) {\n                    if (typeof func != \"function\") {\n                        throw new TypeError2(FUNC_ERROR_TEXT);\n                    }\n                    return setTimeout(function() {\n                        func.apply(undefined2, args);\n                    }, wait);\n                }\n                function baseDifference(array, values2, iteratee2, comparator) {\n                    var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;\n                    if (!length) {\n                        return result2;\n                    }\n                    if (iteratee2) {\n                        values2 = arrayMap(values2, baseUnary(iteratee2));\n                    }\n                    if (comparator) {\n                        includes2 = arrayIncludesWith;\n                        isCommon = false;\n                    } else if (values2.length >= LARGE_ARRAY_SIZE) {\n                        includes2 = cacheHas;\n                        isCommon = false;\n                        values2 = new SetCache(values2);\n                    }\n                    outer: while(++index < length){\n                        var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);\n                        value = comparator || value !== 0 ? value : 0;\n                        if (isCommon && computed === computed) {\n                            var valuesIndex = valuesLength;\n                            while(valuesIndex--){\n                                if (values2[valuesIndex] === computed) {\n                                    continue outer;\n                                }\n                            }\n                            result2.push(value);\n                        } else if (!includes2(values2, computed, comparator)) {\n                            result2.push(value);\n                        }\n                    }\n                    return result2;\n                }\n                var baseEach = createBaseEach(baseForOwn);\n                var baseEachRight = createBaseEach(baseForOwnRight, true);\n                function baseEvery(collection, predicate) {\n                    var result2 = true;\n                    baseEach(collection, function(value, index, collection2) {\n                        result2 = !!predicate(value, index, collection2);\n                        return result2;\n                    });\n                    return result2;\n                }\n                function baseExtremum(array, iteratee2, comparator) {\n                    var index = -1, length = array.length;\n                    while(++index < length){\n                        var value = array[index], current = iteratee2(value);\n                        if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {\n                            var computed = current, result2 = value;\n                        }\n                    }\n                    return result2;\n                }\n                function baseFill(array, value, start, end) {\n                    var length = array.length;\n                    start = toInteger(start);\n                    if (start < 0) {\n                        start = -start > length ? 0 : length + start;\n                    }\n                    end = end === undefined2 || end > length ? length : toInteger(end);\n                    if (end < 0) {\n                        end += length;\n                    }\n                    end = start > end ? 0 : toLength(end);\n                    while(start < end){\n                        array[start++] = value;\n                    }\n                    return array;\n                }\n                function baseFilter(collection, predicate) {\n                    var result2 = [];\n                    baseEach(collection, function(value, index, collection2) {\n                        if (predicate(value, index, collection2)) {\n                            result2.push(value);\n                        }\n                    });\n                    return result2;\n                }\n                function baseFlatten(array, depth, predicate, isStrict, result2) {\n                    var index = -1, length = array.length;\n                    predicate || (predicate = isFlattenable);\n                    result2 || (result2 = []);\n                    while(++index < length){\n                        var value = array[index];\n                        if (depth > 0 && predicate(value)) {\n                            if (depth > 1) {\n                                baseFlatten(value, depth - 1, predicate, isStrict, result2);\n                            } else {\n                                arrayPush(result2, value);\n                            }\n                        } else if (!isStrict) {\n                            result2[result2.length] = value;\n                        }\n                    }\n                    return result2;\n                }\n                var baseFor = createBaseFor();\n                var baseForRight = createBaseFor(true);\n                function baseForOwn(object, iteratee2) {\n                    return object && baseFor(object, iteratee2, keys);\n                }\n                function baseForOwnRight(object, iteratee2) {\n                    return object && baseForRight(object, iteratee2, keys);\n                }\n                function baseFunctions(object, props) {\n                    return arrayFilter(props, function(key) {\n                        return isFunction(object[key]);\n                    });\n                }\n                function baseGet(object, path) {\n                    path = castPath(path, object);\n                    var index = 0, length = path.length;\n                    while(object != null && index < length){\n                        object = object[toKey(path[index++])];\n                    }\n                    return index && index == length ? object : undefined2;\n                }\n                function baseGetAllKeys(object, keysFunc, symbolsFunc) {\n                    var result2 = keysFunc(object);\n                    return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));\n                }\n                function baseGetTag(value) {\n                    if (value == null) {\n                        return value === undefined2 ? undefinedTag : nullTag;\n                    }\n                    return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);\n                }\n                function baseGt(value, other) {\n                    return value > other;\n                }\n                function baseHas(object, key) {\n                    return object != null && hasOwnProperty.call(object, key);\n                }\n                function baseHasIn(object, key) {\n                    return object != null && key in Object2(object);\n                }\n                function baseInRange(number, start, end) {\n                    return number >= nativeMin(start, end) && number < nativeMax(start, end);\n                }\n                function baseIntersection(arrays, iteratee2, comparator) {\n                    var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];\n                    while(othIndex--){\n                        var array = arrays[othIndex];\n                        if (othIndex && iteratee2) {\n                            array = arrayMap(array, baseUnary(iteratee2));\n                        }\n                        maxLength = nativeMin(array.length, maxLength);\n                        caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;\n                    }\n                    array = arrays[0];\n                    var index = -1, seen = caches[0];\n                    outer: while(++index < length && result2.length < maxLength){\n                        var value = array[index], computed = iteratee2 ? iteratee2(value) : value;\n                        value = comparator || value !== 0 ? value : 0;\n                        if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {\n                            othIndex = othLength;\n                            while(--othIndex){\n                                var cache = caches[othIndex];\n                                if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {\n                                    continue outer;\n                                }\n                            }\n                            if (seen) {\n                                seen.push(computed);\n                            }\n                            result2.push(value);\n                        }\n                    }\n                    return result2;\n                }\n                function baseInverter(object, setter, iteratee2, accumulator) {\n                    baseForOwn(object, function(value, key, object2) {\n                        setter(accumulator, iteratee2(value), key, object2);\n                    });\n                    return accumulator;\n                }\n                function baseInvoke(object, path, args) {\n                    path = castPath(path, object);\n                    object = parent(object, path);\n                    var func = object == null ? object : object[toKey(last(path))];\n                    return func == null ? undefined2 : apply(func, object, args);\n                }\n                function baseIsArguments(value) {\n                    return isObjectLike(value) && baseGetTag(value) == argsTag;\n                }\n                function baseIsArrayBuffer(value) {\n                    return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;\n                }\n                function baseIsDate(value) {\n                    return isObjectLike(value) && baseGetTag(value) == dateTag;\n                }\n                function baseIsEqual(value, other, bitmask, customizer, stack) {\n                    if (value === other) {\n                        return true;\n                    }\n                    if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {\n                        return value !== value && other !== other;\n                    }\n                    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\n                }\n                function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\n                    var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);\n                    objTag = objTag == argsTag ? objectTag : objTag;\n                    othTag = othTag == argsTag ? objectTag : othTag;\n                    var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;\n                    if (isSameTag && isBuffer(object)) {\n                        if (!isBuffer(other)) {\n                            return false;\n                        }\n                        objIsArr = true;\n                        objIsObj = false;\n                    }\n                    if (isSameTag && !objIsObj) {\n                        stack || (stack = new Stack());\n                        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\n                    }\n                    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\n                        var objIsWrapped = objIsObj && hasOwnProperty.call(object, \"__wrapped__\"), othIsWrapped = othIsObj && hasOwnProperty.call(other, \"__wrapped__\");\n                        if (objIsWrapped || othIsWrapped) {\n                            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;\n                            stack || (stack = new Stack());\n                            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\n                        }\n                    }\n                    if (!isSameTag) {\n                        return false;\n                    }\n                    stack || (stack = new Stack());\n                    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\n                }\n                function baseIsMap(value) {\n                    return isObjectLike(value) && getTag(value) == mapTag;\n                }\n                function baseIsMatch(object, source, matchData, customizer) {\n                    var index = matchData.length, length = index, noCustomizer = !customizer;\n                    if (object == null) {\n                        return !length;\n                    }\n                    object = Object2(object);\n                    while(index--){\n                        var data = matchData[index];\n                        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {\n                            return false;\n                        }\n                    }\n                    while(++index < length){\n                        data = matchData[index];\n                        var key = data[0], objValue = object[key], srcValue = data[1];\n                        if (noCustomizer && data[2]) {\n                            if (objValue === undefined2 && !(key in object)) {\n                                return false;\n                            }\n                        } else {\n                            var stack = new Stack();\n                            if (customizer) {\n                                var result2 = customizer(objValue, srcValue, key, object, source, stack);\n                            }\n                            if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {\n                                return false;\n                            }\n                        }\n                    }\n                    return true;\n                }\n                function baseIsNative(value) {\n                    if (!isObject(value) || isMasked(value)) {\n                        return false;\n                    }\n                    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\n                    return pattern.test(toSource(value));\n                }\n                function baseIsRegExp(value) {\n                    return isObjectLike(value) && baseGetTag(value) == regexpTag;\n                }\n                function baseIsSet(value) {\n                    return isObjectLike(value) && getTag(value) == setTag;\n                }\n                function baseIsTypedArray(value) {\n                    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\n                }\n                function baseIteratee(value) {\n                    if (typeof value == \"function\") {\n                        return value;\n                    }\n                    if (value == null) {\n                        return identity;\n                    }\n                    if (typeof value == \"object\") {\n                        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);\n                    }\n                    return property(value);\n                }\n                function baseKeys(object) {\n                    if (!isPrototype(object)) {\n                        return nativeKeys(object);\n                    }\n                    var result2 = [];\n                    for(var key in Object2(object)){\n                        if (hasOwnProperty.call(object, key) && key != \"constructor\") {\n                            result2.push(key);\n                        }\n                    }\n                    return result2;\n                }\n                function baseKeysIn(object) {\n                    if (!isObject(object)) {\n                        return nativeKeysIn(object);\n                    }\n                    var isProto = isPrototype(object), result2 = [];\n                    for(var key in object){\n                        if (!(key == \"constructor\" && (isProto || !hasOwnProperty.call(object, key)))) {\n                            result2.push(key);\n                        }\n                    }\n                    return result2;\n                }\n                function baseLt(value, other) {\n                    return value < other;\n                }\n                function baseMap(collection, iteratee2) {\n                    var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];\n                    baseEach(collection, function(value, key, collection2) {\n                        result2[++index] = iteratee2(value, key, collection2);\n                    });\n                    return result2;\n                }\n                function baseMatches(source) {\n                    var matchData = getMatchData(source);\n                    if (matchData.length == 1 && matchData[0][2]) {\n                        return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n                    }\n                    return function(object) {\n                        return object === source || baseIsMatch(object, source, matchData);\n                    };\n                }\n                function baseMatchesProperty(path, srcValue) {\n                    if (isKey(path) && isStrictComparable(srcValue)) {\n                        return matchesStrictComparable(toKey(path), srcValue);\n                    }\n                    return function(object) {\n                        var objValue = get(object, path);\n                        return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\n                    };\n                }\n                function baseMerge(object, source, srcIndex, customizer, stack) {\n                    if (object === source) {\n                        return;\n                    }\n                    baseFor(source, function(srcValue, key) {\n                        stack || (stack = new Stack());\n                        if (isObject(srcValue)) {\n                            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n                        } else {\n                            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + \"\", object, source, stack) : undefined2;\n                            if (newValue === undefined2) {\n                                newValue = srcValue;\n                            }\n                            assignMergeValue(object, key, newValue);\n                        }\n                    }, keysIn);\n                }\n                function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n                    var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);\n                    if (stacked) {\n                        assignMergeValue(object, key, stacked);\n                        return;\n                    }\n                    var newValue = customizer ? customizer(objValue, srcValue, key + \"\", object, source, stack) : undefined2;\n                    var isCommon = newValue === undefined2;\n                    if (isCommon) {\n                        var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);\n                        newValue = srcValue;\n                        if (isArr || isBuff || isTyped) {\n                            if (isArray(objValue)) {\n                                newValue = objValue;\n                            } else if (isArrayLikeObject(objValue)) {\n                                newValue = copyArray(objValue);\n                            } else if (isBuff) {\n                                isCommon = false;\n                                newValue = cloneBuffer(srcValue, true);\n                            } else if (isTyped) {\n                                isCommon = false;\n                                newValue = cloneTypedArray(srcValue, true);\n                            } else {\n                                newValue = [];\n                            }\n                        } else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n                            newValue = objValue;\n                            if (isArguments(objValue)) {\n                                newValue = toPlainObject(objValue);\n                            } else if (!isObject(objValue) || isFunction(objValue)) {\n                                newValue = initCloneObject(srcValue);\n                            }\n                        } else {\n                            isCommon = false;\n                        }\n                    }\n                    if (isCommon) {\n                        stack.set(srcValue, newValue);\n                        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n                        stack[\"delete\"](srcValue);\n                    }\n                    assignMergeValue(object, key, newValue);\n                }\n                function baseNth(array, n) {\n                    var length = array.length;\n                    if (!length) {\n                        return;\n                    }\n                    n += n < 0 ? length : 0;\n                    return isIndex(n, length) ? array[n] : undefined2;\n                }\n                function baseOrderBy(collection, iteratees, orders) {\n                    if (iteratees.length) {\n                        iteratees = arrayMap(iteratees, function(iteratee2) {\n                            if (isArray(iteratee2)) {\n                                return function(value) {\n                                    return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);\n                                };\n                            }\n                            return iteratee2;\n                        });\n                    } else {\n                        iteratees = [\n                            identity\n                        ];\n                    }\n                    var index = -1;\n                    iteratees = arrayMap(iteratees, baseUnary(getIteratee()));\n                    var result2 = baseMap(collection, function(value, key, collection2) {\n                        var criteria = arrayMap(iteratees, function(iteratee2) {\n                            return iteratee2(value);\n                        });\n                        return {\n                            \"criteria\": criteria,\n                            \"index\": ++index,\n                            \"value\": value\n                        };\n                    });\n                    return baseSortBy(result2, function(object, other) {\n                        return compareMultiple(object, other, orders);\n                    });\n                }\n                function basePick(object, paths) {\n                    return basePickBy(object, paths, function(value, path) {\n                        return hasIn(object, path);\n                    });\n                }\n                function basePickBy(object, paths, predicate) {\n                    var index = -1, length = paths.length, result2 = {};\n                    while(++index < length){\n                        var path = paths[index], value = baseGet(object, path);\n                        if (predicate(value, path)) {\n                            baseSet(result2, castPath(path, object), value);\n                        }\n                    }\n                    return result2;\n                }\n                function basePropertyDeep(path) {\n                    return function(object) {\n                        return baseGet(object, path);\n                    };\n                }\n                function basePullAll(array, values2, iteratee2, comparator) {\n                    var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;\n                    if (array === values2) {\n                        values2 = copyArray(values2);\n                    }\n                    if (iteratee2) {\n                        seen = arrayMap(array, baseUnary(iteratee2));\n                    }\n                    while(++index < length){\n                        var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;\n                        while((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1){\n                            if (seen !== array) {\n                                splice.call(seen, fromIndex, 1);\n                            }\n                            splice.call(array, fromIndex, 1);\n                        }\n                    }\n                    return array;\n                }\n                function basePullAt(array, indexes) {\n                    var length = array ? indexes.length : 0, lastIndex = length - 1;\n                    while(length--){\n                        var index = indexes[length];\n                        if (length == lastIndex || index !== previous) {\n                            var previous = index;\n                            if (isIndex(index)) {\n                                splice.call(array, index, 1);\n                            } else {\n                                baseUnset(array, index);\n                            }\n                        }\n                    }\n                    return array;\n                }\n                function baseRandom(lower, upper) {\n                    return lower + nativeFloor(nativeRandom() * (upper - lower + 1));\n                }\n                function baseRange(start, end, step, fromRight) {\n                    var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);\n                    while(length--){\n                        result2[fromRight ? length : ++index] = start;\n                        start += step;\n                    }\n                    return result2;\n                }\n                function baseRepeat(string, n) {\n                    var result2 = \"\";\n                    if (!string || n < 1 || n > MAX_SAFE_INTEGER) {\n                        return result2;\n                    }\n                    do {\n                        if (n % 2) {\n                            result2 += string;\n                        }\n                        n = nativeFloor(n / 2);\n                        if (n) {\n                            string += string;\n                        }\n                    }while (n);\n                    return result2;\n                }\n                function baseRest(func, start) {\n                    return setToString(overRest(func, start, identity), func + \"\");\n                }\n                function baseSample(collection) {\n                    return arraySample(values(collection));\n                }\n                function baseSampleSize(collection, n) {\n                    var array = values(collection);\n                    return shuffleSelf(array, baseClamp(n, 0, array.length));\n                }\n                function baseSet(object, path, value, customizer) {\n                    if (!isObject(object)) {\n                        return object;\n                    }\n                    path = castPath(path, object);\n                    var index = -1, length = path.length, lastIndex = length - 1, nested = object;\n                    while(nested != null && ++index < length){\n                        var key = toKey(path[index]), newValue = value;\n                        if (key === \"__proto__\" || key === \"constructor\" || key === \"prototype\") {\n                            return object;\n                        }\n                        if (index != lastIndex) {\n                            var objValue = nested[key];\n                            newValue = customizer ? customizer(objValue, key, nested) : undefined2;\n                            if (newValue === undefined2) {\n                                newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};\n                            }\n                        }\n                        assignValue(nested, key, newValue);\n                        nested = nested[key];\n                    }\n                    return object;\n                }\n                var baseSetData = !metaMap ? identity : function(func, data) {\n                    metaMap.set(func, data);\n                    return func;\n                };\n                var baseSetToString = !defineProperty ? identity : function(func, string) {\n                    return defineProperty(func, \"toString\", {\n                        \"configurable\": true,\n                        \"enumerable\": false,\n                        \"value\": constant(string),\n                        \"writable\": true\n                    });\n                };\n                function baseShuffle(collection) {\n                    return shuffleSelf(values(collection));\n                }\n                function baseSlice(array, start, end) {\n                    var index = -1, length = array.length;\n                    if (start < 0) {\n                        start = -start > length ? 0 : length + start;\n                    }\n                    end = end > length ? length : end;\n                    if (end < 0) {\n                        end += length;\n                    }\n                    length = start > end ? 0 : end - start >>> 0;\n                    start >>>= 0;\n                    var result2 = Array2(length);\n                    while(++index < length){\n                        result2[index] = array[index + start];\n                    }\n                    return result2;\n                }\n                function baseSome(collection, predicate) {\n                    var result2;\n                    baseEach(collection, function(value, index, collection2) {\n                        result2 = predicate(value, index, collection2);\n                        return !result2;\n                    });\n                    return !!result2;\n                }\n                function baseSortedIndex(array, value, retHighest) {\n                    var low = 0, high = array == null ? low : array.length;\n                    if (typeof value == \"number\" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {\n                        while(low < high){\n                            var mid = low + high >>> 1, computed = array[mid];\n                            if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {\n                                low = mid + 1;\n                            } else {\n                                high = mid;\n                            }\n                        }\n                        return high;\n                    }\n                    return baseSortedIndexBy(array, value, identity, retHighest);\n                }\n                function baseSortedIndexBy(array, value, iteratee2, retHighest) {\n                    var low = 0, high = array == null ? 0 : array.length;\n                    if (high === 0) {\n                        return 0;\n                    }\n                    value = iteratee2(value);\n                    var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;\n                    while(low < high){\n                        var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);\n                        if (valIsNaN) {\n                            var setLow = retHighest || othIsReflexive;\n                        } else if (valIsUndefined) {\n                            setLow = othIsReflexive && (retHighest || othIsDefined);\n                        } else if (valIsNull) {\n                            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);\n                        } else if (valIsSymbol) {\n                            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);\n                        } else if (othIsNull || othIsSymbol) {\n                            setLow = false;\n                        } else {\n                            setLow = retHighest ? computed <= value : computed < value;\n                        }\n                        if (setLow) {\n                            low = mid + 1;\n                        } else {\n                            high = mid;\n                        }\n                    }\n                    return nativeMin(high, MAX_ARRAY_INDEX);\n                }\n                function baseSortedUniq(array, iteratee2) {\n                    var index = -1, length = array.length, resIndex = 0, result2 = [];\n                    while(++index < length){\n                        var value = array[index], computed = iteratee2 ? iteratee2(value) : value;\n                        if (!index || !eq(computed, seen)) {\n                            var seen = computed;\n                            result2[resIndex++] = value === 0 ? 0 : value;\n                        }\n                    }\n                    return result2;\n                }\n                function baseToNumber(value) {\n                    if (typeof value == \"number\") {\n                        return value;\n                    }\n                    if (isSymbol(value)) {\n                        return NAN;\n                    }\n                    return +value;\n                }\n                function baseToString(value) {\n                    if (typeof value == \"string\") {\n                        return value;\n                    }\n                    if (isArray(value)) {\n                        return arrayMap(value, baseToString) + \"\";\n                    }\n                    if (isSymbol(value)) {\n                        return symbolToString ? symbolToString.call(value) : \"\";\n                    }\n                    var result2 = value + \"\";\n                    return result2 == \"0\" && 1 / value == -INFINITY ? \"-0\" : result2;\n                }\n                function baseUniq(array, iteratee2, comparator) {\n                    var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;\n                    if (comparator) {\n                        isCommon = false;\n                        includes2 = arrayIncludesWith;\n                    } else if (length >= LARGE_ARRAY_SIZE) {\n                        var set2 = iteratee2 ? null : createSet(array);\n                        if (set2) {\n                            return setToArray(set2);\n                        }\n                        isCommon = false;\n                        includes2 = cacheHas;\n                        seen = new SetCache();\n                    } else {\n                        seen = iteratee2 ? [] : result2;\n                    }\n                    outer: while(++index < length){\n                        var value = array[index], computed = iteratee2 ? iteratee2(value) : value;\n                        value = comparator || value !== 0 ? value : 0;\n                        if (isCommon && computed === computed) {\n                            var seenIndex = seen.length;\n                            while(seenIndex--){\n                                if (seen[seenIndex] === computed) {\n                                    continue outer;\n                                }\n                            }\n                            if (iteratee2) {\n                                seen.push(computed);\n                            }\n                            result2.push(value);\n                        } else if (!includes2(seen, computed, comparator)) {\n                            if (seen !== result2) {\n                                seen.push(computed);\n                            }\n                            result2.push(value);\n                        }\n                    }\n                    return result2;\n                }\n                function baseUnset(object, path) {\n                    path = castPath(path, object);\n                    object = parent(object, path);\n                    return object == null || delete object[toKey(last(path))];\n                }\n                function baseUpdate(object, path, updater, customizer) {\n                    return baseSet(object, path, updater(baseGet(object, path)), customizer);\n                }\n                function baseWhile(array, predicate, isDrop, fromRight) {\n                    var length = array.length, index = fromRight ? length : -1;\n                    while((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)){}\n                    return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);\n                }\n                function baseWrapperValue(value, actions) {\n                    var result2 = value;\n                    if (result2 instanceof LazyWrapper) {\n                        result2 = result2.value();\n                    }\n                    return arrayReduce(actions, function(result3, action) {\n                        return action.func.apply(action.thisArg, arrayPush([\n                            result3\n                        ], action.args));\n                    }, result2);\n                }\n                function baseXor(arrays, iteratee2, comparator) {\n                    var length = arrays.length;\n                    if (length < 2) {\n                        return length ? baseUniq(arrays[0]) : [];\n                    }\n                    var index = -1, result2 = Array2(length);\n                    while(++index < length){\n                        var array = arrays[index], othIndex = -1;\n                        while(++othIndex < length){\n                            if (othIndex != index) {\n                                result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);\n                            }\n                        }\n                    }\n                    return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);\n                }\n                function baseZipObject(props, values2, assignFunc) {\n                    var index = -1, length = props.length, valsLength = values2.length, result2 = {};\n                    while(++index < length){\n                        var value = index < valsLength ? values2[index] : undefined2;\n                        assignFunc(result2, props[index], value);\n                    }\n                    return result2;\n                }\n                function castArrayLikeObject(value) {\n                    return isArrayLikeObject(value) ? value : [];\n                }\n                function castFunction(value) {\n                    return typeof value == \"function\" ? value : identity;\n                }\n                function castPath(value, object) {\n                    if (isArray(value)) {\n                        return value;\n                    }\n                    return isKey(value, object) ? [\n                        value\n                    ] : stringToPath(toString(value));\n                }\n                var castRest = baseRest;\n                function castSlice(array, start, end) {\n                    var length = array.length;\n                    end = end === undefined2 ? length : end;\n                    return !start && end >= length ? array : baseSlice(array, start, end);\n                }\n                var clearTimeout = ctxClearTimeout || function(id) {\n                    return root.clearTimeout(id);\n                };\n                function cloneBuffer(buffer, isDeep) {\n                    if (isDeep) {\n                        return buffer.slice();\n                    }\n                    var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\n                    buffer.copy(result2);\n                    return result2;\n                }\n                function cloneArrayBuffer(arrayBuffer) {\n                    var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);\n                    new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));\n                    return result2;\n                }\n                function cloneDataView(dataView, isDeep) {\n                    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\n                    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\n                }\n                function cloneRegExp(regexp) {\n                    var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));\n                    result2.lastIndex = regexp.lastIndex;\n                    return result2;\n                }\n                function cloneSymbol(symbol) {\n                    return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};\n                }\n                function cloneTypedArray(typedArray, isDeep) {\n                    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\n                    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\n                }\n                function compareAscending(value, other) {\n                    if (value !== other) {\n                        var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);\n                        var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);\n                        if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {\n                            return 1;\n                        }\n                        if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {\n                            return -1;\n                        }\n                    }\n                    return 0;\n                }\n                function compareMultiple(object, other, orders) {\n                    var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;\n                    while(++index < length){\n                        var result2 = compareAscending(objCriteria[index], othCriteria[index]);\n                        if (result2) {\n                            if (index >= ordersLength) {\n                                return result2;\n                            }\n                            var order = orders[index];\n                            return result2 * (order == \"desc\" ? -1 : 1);\n                        }\n                    }\n                    return object.index - other.index;\n                }\n                function composeArgs(args, partials, holders, isCurried) {\n                    var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;\n                    while(++leftIndex < leftLength){\n                        result2[leftIndex] = partials[leftIndex];\n                    }\n                    while(++argsIndex < holdersLength){\n                        if (isUncurried || argsIndex < argsLength) {\n                            result2[holders[argsIndex]] = args[argsIndex];\n                        }\n                    }\n                    while(rangeLength--){\n                        result2[leftIndex++] = args[argsIndex++];\n                    }\n                    return result2;\n                }\n                function composeArgsRight(args, partials, holders, isCurried) {\n                    var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;\n                    while(++argsIndex < rangeLength){\n                        result2[argsIndex] = args[argsIndex];\n                    }\n                    var offset = argsIndex;\n                    while(++rightIndex < rightLength){\n                        result2[offset + rightIndex] = partials[rightIndex];\n                    }\n                    while(++holdersIndex < holdersLength){\n                        if (isUncurried || argsIndex < argsLength) {\n                            result2[offset + holders[holdersIndex]] = args[argsIndex++];\n                        }\n                    }\n                    return result2;\n                }\n                function copyArray(source, array) {\n                    var index = -1, length = source.length;\n                    array || (array = Array2(length));\n                    while(++index < length){\n                        array[index] = source[index];\n                    }\n                    return array;\n                }\n                function copyObject(source, props, object, customizer) {\n                    var isNew = !object;\n                    object || (object = {});\n                    var index = -1, length = props.length;\n                    while(++index < length){\n                        var key = props[index];\n                        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;\n                        if (newValue === undefined2) {\n                            newValue = source[key];\n                        }\n                        if (isNew) {\n                            baseAssignValue(object, key, newValue);\n                        } else {\n                            assignValue(object, key, newValue);\n                        }\n                    }\n                    return object;\n                }\n                function copySymbols(source, object) {\n                    return copyObject(source, getSymbols(source), object);\n                }\n                function copySymbolsIn(source, object) {\n                    return copyObject(source, getSymbolsIn(source), object);\n                }\n                function createAggregator(setter, initializer) {\n                    return function(collection, iteratee2) {\n                        var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};\n                        return func(collection, setter, getIteratee(iteratee2, 2), accumulator);\n                    };\n                }\n                function createAssigner(assigner) {\n                    return baseRest(function(object, sources) {\n                        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;\n                        customizer = assigner.length > 3 && typeof customizer == \"function\" ? (length--, customizer) : undefined2;\n                        if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n                            customizer = length < 3 ? undefined2 : customizer;\n                            length = 1;\n                        }\n                        object = Object2(object);\n                        while(++index < length){\n                            var source = sources[index];\n                            if (source) {\n                                assigner(object, source, index, customizer);\n                            }\n                        }\n                        return object;\n                    });\n                }\n                function createBaseEach(eachFunc, fromRight) {\n                    return function(collection, iteratee2) {\n                        if (collection == null) {\n                            return collection;\n                        }\n                        if (!isArrayLike(collection)) {\n                            return eachFunc(collection, iteratee2);\n                        }\n                        var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);\n                        while(fromRight ? index-- : ++index < length){\n                            if (iteratee2(iterable[index], index, iterable) === false) {\n                                break;\n                            }\n                        }\n                        return collection;\n                    };\n                }\n                function createBaseFor(fromRight) {\n                    return function(object, iteratee2, keysFunc) {\n                        var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;\n                        while(length--){\n                            var key = props[fromRight ? length : ++index];\n                            if (iteratee2(iterable[key], key, iterable) === false) {\n                                break;\n                            }\n                        }\n                        return object;\n                    };\n                }\n                function createBind(func, bitmask, thisArg) {\n                    var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);\n                    function wrapper() {\n                        var fn = this && this !== root && this instanceof wrapper ? Ctor : func;\n                        return fn.apply(isBind ? thisArg : this, arguments);\n                    }\n                    return wrapper;\n                }\n                function createCaseFirst(methodName) {\n                    return function(string) {\n                        string = toString(string);\n                        var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;\n                        var chr = strSymbols ? strSymbols[0] : string.charAt(0);\n                        var trailing = strSymbols ? castSlice(strSymbols, 1).join(\"\") : string.slice(1);\n                        return chr[methodName]() + trailing;\n                    };\n                }\n                function createCompounder(callback) {\n                    return function(string) {\n                        return arrayReduce(words(deburr(string).replace(reApos, \"\")), callback, \"\");\n                    };\n                }\n                function createCtor(Ctor) {\n                    return function() {\n                        var args = arguments;\n                        switch(args.length){\n                            case 0:\n                                return new Ctor();\n                            case 1:\n                                return new Ctor(args[0]);\n                            case 2:\n                                return new Ctor(args[0], args[1]);\n                            case 3:\n                                return new Ctor(args[0], args[1], args[2]);\n                            case 4:\n                                return new Ctor(args[0], args[1], args[2], args[3]);\n                            case 5:\n                                return new Ctor(args[0], args[1], args[2], args[3], args[4]);\n                            case 6:\n                                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);\n                            case 7:\n                                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);\n                        }\n                        var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);\n                        return isObject(result2) ? result2 : thisBinding;\n                    };\n                }\n                function createCurry(func, bitmask, arity) {\n                    var Ctor = createCtor(func);\n                    function wrapper() {\n                        var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);\n                        while(index--){\n                            args[index] = arguments[index];\n                        }\n                        var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);\n                        length -= holders.length;\n                        if (length < arity) {\n                            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined2, args, holders, undefined2, undefined2, arity - length);\n                        }\n                        var fn = this && this !== root && this instanceof wrapper ? Ctor : func;\n                        return apply(fn, this, args);\n                    }\n                    return wrapper;\n                }\n                function createFind(findIndexFunc) {\n                    return function(collection, predicate, fromIndex) {\n                        var iterable = Object2(collection);\n                        if (!isArrayLike(collection)) {\n                            var iteratee2 = getIteratee(predicate, 3);\n                            collection = keys(collection);\n                            predicate = function(key) {\n                                return iteratee2(iterable[key], key, iterable);\n                            };\n                        }\n                        var index = findIndexFunc(collection, predicate, fromIndex);\n                        return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;\n                    };\n                }\n                function createFlow(fromRight) {\n                    return flatRest(function(funcs) {\n                        var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;\n                        if (fromRight) {\n                            funcs.reverse();\n                        }\n                        while(index--){\n                            var func = funcs[index];\n                            if (typeof func != \"function\") {\n                                throw new TypeError2(FUNC_ERROR_TEXT);\n                            }\n                            if (prereq && !wrapper && getFuncName(func) == \"wrapper\") {\n                                var wrapper = new LodashWrapper([], true);\n                            }\n                        }\n                        index = wrapper ? index : length;\n                        while(++index < length){\n                            func = funcs[index];\n                            var funcName = getFuncName(func), data = funcName == \"wrapper\" ? getData(func) : undefined2;\n                            if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {\n                                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);\n                            } else {\n                                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);\n                            }\n                        }\n                        return function() {\n                            var args = arguments, value = args[0];\n                            if (wrapper && args.length == 1 && isArray(value)) {\n                                return wrapper.plant(value).value();\n                            }\n                            var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;\n                            while(++index2 < length){\n                                result2 = funcs[index2].call(this, result2);\n                            }\n                            return result2;\n                        };\n                    });\n                }\n                function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {\n                    var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);\n                    function wrapper() {\n                        var length = arguments.length, args = Array2(length), index = length;\n                        while(index--){\n                            args[index] = arguments[index];\n                        }\n                        if (isCurried) {\n                            var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);\n                        }\n                        if (partials) {\n                            args = composeArgs(args, partials, holders, isCurried);\n                        }\n                        if (partialsRight) {\n                            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);\n                        }\n                        length -= holdersCount;\n                        if (isCurried && length < arity) {\n                            var newHolders = replaceHolders(args, placeholder);\n                            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary2, arity - length);\n                        }\n                        var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;\n                        length = args.length;\n                        if (argPos) {\n                            args = reorder(args, argPos);\n                        } else if (isFlip && length > 1) {\n                            args.reverse();\n                        }\n                        if (isAry && ary2 < length) {\n                            args.length = ary2;\n                        }\n                        if (this && this !== root && this instanceof wrapper) {\n                            fn = Ctor || createCtor(fn);\n                        }\n                        return fn.apply(thisBinding, args);\n                    }\n                    return wrapper;\n                }\n                function createInverter(setter, toIteratee) {\n                    return function(object, iteratee2) {\n                        return baseInverter(object, setter, toIteratee(iteratee2), {});\n                    };\n                }\n                function createMathOperation(operator, defaultValue) {\n                    return function(value, other) {\n                        var result2;\n                        if (value === undefined2 && other === undefined2) {\n                            return defaultValue;\n                        }\n                        if (value !== undefined2) {\n                            result2 = value;\n                        }\n                        if (other !== undefined2) {\n                            if (result2 === undefined2) {\n                                return other;\n                            }\n                            if (typeof value == \"string\" || typeof other == \"string\") {\n                                value = baseToString(value);\n                                other = baseToString(other);\n                            } else {\n                                value = baseToNumber(value);\n                                other = baseToNumber(other);\n                            }\n                            result2 = operator(value, other);\n                        }\n                        return result2;\n                    };\n                }\n                function createOver(arrayFunc) {\n                    return flatRest(function(iteratees) {\n                        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));\n                        return baseRest(function(args) {\n                            var thisArg = this;\n                            return arrayFunc(iteratees, function(iteratee2) {\n                                return apply(iteratee2, thisArg, args);\n                            });\n                        });\n                    });\n                }\n                function createPadding(length, chars) {\n                    chars = chars === undefined2 ? \" \" : baseToString(chars);\n                    var charsLength = chars.length;\n                    if (charsLength < 2) {\n                        return charsLength ? baseRepeat(chars, length) : chars;\n                    }\n                    var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));\n                    return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join(\"\") : result2.slice(0, length);\n                }\n                function createPartial(func, bitmask, thisArg, partials) {\n                    var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);\n                    function wrapper() {\n                        var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;\n                        while(++leftIndex < leftLength){\n                            args[leftIndex] = partials[leftIndex];\n                        }\n                        while(argsLength--){\n                            args[leftIndex++] = arguments[++argsIndex];\n                        }\n                        return apply(fn, isBind ? thisArg : this, args);\n                    }\n                    return wrapper;\n                }\n                function createRange(fromRight) {\n                    return function(start, end, step) {\n                        if (step && typeof step != \"number\" && isIterateeCall(start, end, step)) {\n                            end = step = undefined2;\n                        }\n                        start = toFinite(start);\n                        if (end === undefined2) {\n                            end = start;\n                            start = 0;\n                        } else {\n                            end = toFinite(end);\n                        }\n                        step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);\n                        return baseRange(start, end, step, fromRight);\n                    };\n                }\n                function createRelationalOperation(operator) {\n                    return function(value, other) {\n                        if (!(typeof value == \"string\" && typeof other == \"string\")) {\n                            value = toNumber(value);\n                            other = toNumber(other);\n                        }\n                        return operator(value, other);\n                    };\n                }\n                function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {\n                    var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;\n                    bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;\n                    bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);\n                    if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {\n                        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);\n                    }\n                    var newData = [\n                        func,\n                        bitmask,\n                        thisArg,\n                        newPartials,\n                        newHolders,\n                        newPartialsRight,\n                        newHoldersRight,\n                        argPos,\n                        ary2,\n                        arity\n                    ];\n                    var result2 = wrapFunc.apply(undefined2, newData);\n                    if (isLaziable(func)) {\n                        setData(result2, newData);\n                    }\n                    result2.placeholder = placeholder;\n                    return setWrapToString(result2, func, bitmask);\n                }\n                function createRound(methodName) {\n                    var func = Math2[methodName];\n                    return function(number, precision) {\n                        number = toNumber(number);\n                        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);\n                        if (precision && nativeIsFinite(number)) {\n                            var pair = (toString(number) + \"e\").split(\"e\"), value = func(pair[0] + \"e\" + (+pair[1] + precision));\n                            pair = (toString(value) + \"e\").split(\"e\");\n                            return +(pair[0] + \"e\" + (+pair[1] - precision));\n                        }\n                        return func(number);\n                    };\n                }\n                var createSet = !(Set2 && 1 / setToArray(new Set2([\n                    ,\n                    -0\n                ]))[1] == INFINITY) ? noop : function(values2) {\n                    return new Set2(values2);\n                };\n                function createToPairs(keysFunc) {\n                    return function(object) {\n                        var tag = getTag(object);\n                        if (tag == mapTag) {\n                            return mapToArray(object);\n                        }\n                        if (tag == setTag) {\n                            return setToPairs(object);\n                        }\n                        return baseToPairs(object, keysFunc(object));\n                    };\n                }\n                function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {\n                    var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;\n                    if (!isBindKey && typeof func != \"function\") {\n                        throw new TypeError2(FUNC_ERROR_TEXT);\n                    }\n                    var length = partials ? partials.length : 0;\n                    if (!length) {\n                        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);\n                        partials = holders = undefined2;\n                    }\n                    ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);\n                    arity = arity === undefined2 ? arity : toInteger(arity);\n                    length -= holders ? holders.length : 0;\n                    if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {\n                        var partialsRight = partials, holdersRight = holders;\n                        partials = holders = undefined2;\n                    }\n                    var data = isBindKey ? undefined2 : getData(func);\n                    var newData = [\n                        func,\n                        bitmask,\n                        thisArg,\n                        partials,\n                        holders,\n                        partialsRight,\n                        holdersRight,\n                        argPos,\n                        ary2,\n                        arity\n                    ];\n                    if (data) {\n                        mergeData(newData, data);\n                    }\n                    func = newData[0];\n                    bitmask = newData[1];\n                    thisArg = newData[2];\n                    partials = newData[3];\n                    holders = newData[4];\n                    arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);\n                    if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {\n                        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);\n                    }\n                    if (!bitmask || bitmask == WRAP_BIND_FLAG) {\n                        var result2 = createBind(func, bitmask, thisArg);\n                    } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {\n                        result2 = createCurry(func, bitmask, arity);\n                    } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {\n                        result2 = createPartial(func, bitmask, thisArg, partials);\n                    } else {\n                        result2 = createHybrid.apply(undefined2, newData);\n                    }\n                    var setter = data ? baseSetData : setData;\n                    return setWrapToString(setter(result2, newData), func, bitmask);\n                }\n                function customDefaultsAssignIn(objValue, srcValue, key, object) {\n                    if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {\n                        return srcValue;\n                    }\n                    return objValue;\n                }\n                function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {\n                    if (isObject(objValue) && isObject(srcValue)) {\n                        stack.set(srcValue, objValue);\n                        baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);\n                        stack[\"delete\"](srcValue);\n                    }\n                    return objValue;\n                }\n                function customOmitClone(value) {\n                    return isPlainObject(value) ? undefined2 : value;\n                }\n                function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\n                    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;\n                    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n                        return false;\n                    }\n                    var arrStacked = stack.get(array);\n                    var othStacked = stack.get(other);\n                    if (arrStacked && othStacked) {\n                        return arrStacked == other && othStacked == array;\n                    }\n                    var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;\n                    stack.set(array, other);\n                    stack.set(other, array);\n                    while(++index < arrLength){\n                        var arrValue = array[index], othValue = other[index];\n                        if (customizer) {\n                            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);\n                        }\n                        if (compared !== undefined2) {\n                            if (compared) {\n                                continue;\n                            }\n                            result2 = false;\n                            break;\n                        }\n                        if (seen) {\n                            if (!arraySome(other, function(othValue2, othIndex) {\n                                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {\n                                    return seen.push(othIndex);\n                                }\n                            })) {\n                                result2 = false;\n                                break;\n                            }\n                        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\n                            result2 = false;\n                            break;\n                        }\n                    }\n                    stack[\"delete\"](array);\n                    stack[\"delete\"](other);\n                    return result2;\n                }\n                function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\n                    switch(tag){\n                        case dataViewTag:\n                            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {\n                                return false;\n                            }\n                            object = object.buffer;\n                            other = other.buffer;\n                        case arrayBufferTag:\n                            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {\n                                return false;\n                            }\n                            return true;\n                        case boolTag:\n                        case dateTag:\n                        case numberTag:\n                            return eq(+object, +other);\n                        case errorTag:\n                            return object.name == other.name && object.message == other.message;\n                        case regexpTag:\n                        case stringTag:\n                            return object == other + \"\";\n                        case mapTag:\n                            var convert = mapToArray;\n                        case setTag:\n                            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\n                            convert || (convert = setToArray);\n                            if (object.size != other.size && !isPartial) {\n                                return false;\n                            }\n                            var stacked = stack.get(object);\n                            if (stacked) {\n                                return stacked == other;\n                            }\n                            bitmask |= COMPARE_UNORDERED_FLAG;\n                            stack.set(object, other);\n                            var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\n                            stack[\"delete\"](object);\n                            return result2;\n                        case symbolTag:\n                            if (symbolValueOf) {\n                                return symbolValueOf.call(object) == symbolValueOf.call(other);\n                            }\n                    }\n                    return false;\n                }\n                function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\n                    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;\n                    if (objLength != othLength && !isPartial) {\n                        return false;\n                    }\n                    var index = objLength;\n                    while(index--){\n                        var key = objProps[index];\n                        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n                            return false;\n                        }\n                    }\n                    var objStacked = stack.get(object);\n                    var othStacked = stack.get(other);\n                    if (objStacked && othStacked) {\n                        return objStacked == other && othStacked == object;\n                    }\n                    var result2 = true;\n                    stack.set(object, other);\n                    stack.set(other, object);\n                    var skipCtor = isPartial;\n                    while(++index < objLength){\n                        key = objProps[index];\n                        var objValue = object[key], othValue = other[key];\n                        if (customizer) {\n                            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);\n                        }\n                        if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {\n                            result2 = false;\n                            break;\n                        }\n                        skipCtor || (skipCtor = key == \"constructor\");\n                    }\n                    if (result2 && !skipCtor) {\n                        var objCtor = object.constructor, othCtor = other.constructor;\n                        if (objCtor != othCtor && \"constructor\" in object && \"constructor\" in other && !(typeof objCtor == \"function\" && objCtor instanceof objCtor && typeof othCtor == \"function\" && othCtor instanceof othCtor)) {\n                            result2 = false;\n                        }\n                    }\n                    stack[\"delete\"](object);\n                    stack[\"delete\"](other);\n                    return result2;\n                }\n                function flatRest(func) {\n                    return setToString(overRest(func, undefined2, flatten), func + \"\");\n                }\n                function getAllKeys(object) {\n                    return baseGetAllKeys(object, keys, getSymbols);\n                }\n                function getAllKeysIn(object) {\n                    return baseGetAllKeys(object, keysIn, getSymbolsIn);\n                }\n                var getData = !metaMap ? noop : function(func) {\n                    return metaMap.get(func);\n                };\n                function getFuncName(func) {\n                    var result2 = func.name + \"\", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;\n                    while(length--){\n                        var data = array[length], otherFunc = data.func;\n                        if (otherFunc == null || otherFunc == func) {\n                            return data.name;\n                        }\n                    }\n                    return result2;\n                }\n                function getHolder(func) {\n                    var object = hasOwnProperty.call(lodash, \"placeholder\") ? lodash : func;\n                    return object.placeholder;\n                }\n                function getIteratee() {\n                    var result2 = lodash.iteratee || iteratee;\n                    result2 = result2 === iteratee ? baseIteratee : result2;\n                    return arguments.length ? result2(arguments[0], arguments[1]) : result2;\n                }\n                function getMapData(map2, key) {\n                    var data = map2.__data__;\n                    return isKeyable(key) ? data[typeof key == \"string\" ? \"string\" : \"hash\"] : data.map;\n                }\n                function getMatchData(object) {\n                    var result2 = keys(object), length = result2.length;\n                    while(length--){\n                        var key = result2[length], value = object[key];\n                        result2[length] = [\n                            key,\n                            value,\n                            isStrictComparable(value)\n                        ];\n                    }\n                    return result2;\n                }\n                function getNative(object, key) {\n                    var value = getValue(object, key);\n                    return baseIsNative(value) ? value : undefined2;\n                }\n                function getRawTag(value) {\n                    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];\n                    try {\n                        value[symToStringTag] = undefined2;\n                        var unmasked = true;\n                    } catch (e) {}\n                    var result2 = nativeObjectToString.call(value);\n                    if (unmasked) {\n                        if (isOwn) {\n                            value[symToStringTag] = tag;\n                        } else {\n                            delete value[symToStringTag];\n                        }\n                    }\n                    return result2;\n                }\n                var getSymbols = !nativeGetSymbols ? stubArray : function(object) {\n                    if (object == null) {\n                        return [];\n                    }\n                    object = Object2(object);\n                    return arrayFilter(nativeGetSymbols(object), function(symbol) {\n                        return propertyIsEnumerable.call(object, symbol);\n                    });\n                };\n                var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\n                    var result2 = [];\n                    while(object){\n                        arrayPush(result2, getSymbols(object));\n                        object = getPrototype(object);\n                    }\n                    return result2;\n                };\n                var getTag = baseGetTag;\n                if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {\n                    getTag = function(value) {\n                        var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : \"\";\n                        if (ctorString) {\n                            switch(ctorString){\n                                case dataViewCtorString:\n                                    return dataViewTag;\n                                case mapCtorString:\n                                    return mapTag;\n                                case promiseCtorString:\n                                    return promiseTag;\n                                case setCtorString:\n                                    return setTag;\n                                case weakMapCtorString:\n                                    return weakMapTag;\n                            }\n                        }\n                        return result2;\n                    };\n                }\n                function getView(start, end, transforms) {\n                    var index = -1, length = transforms.length;\n                    while(++index < length){\n                        var data = transforms[index], size2 = data.size;\n                        switch(data.type){\n                            case \"drop\":\n                                start += size2;\n                                break;\n                            case \"dropRight\":\n                                end -= size2;\n                                break;\n                            case \"take\":\n                                end = nativeMin(end, start + size2);\n                                break;\n                            case \"takeRight\":\n                                start = nativeMax(start, end - size2);\n                                break;\n                        }\n                    }\n                    return {\n                        \"start\": start,\n                        \"end\": end\n                    };\n                }\n                function getWrapDetails(source) {\n                    var match = source.match(reWrapDetails);\n                    return match ? match[1].split(reSplitDetails) : [];\n                }\n                function hasPath(object, path, hasFunc) {\n                    path = castPath(path, object);\n                    var index = -1, length = path.length, result2 = false;\n                    while(++index < length){\n                        var key = toKey(path[index]);\n                        if (!(result2 = object != null && hasFunc(object, key))) {\n                            break;\n                        }\n                        object = object[key];\n                    }\n                    if (result2 || ++index != length) {\n                        return result2;\n                    }\n                    length = object == null ? 0 : object.length;\n                    return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));\n                }\n                function initCloneArray(array) {\n                    var length = array.length, result2 = new array.constructor(length);\n                    if (length && typeof array[0] == \"string\" && hasOwnProperty.call(array, \"index\")) {\n                        result2.index = array.index;\n                        result2.input = array.input;\n                    }\n                    return result2;\n                }\n                function initCloneObject(object) {\n                    return typeof object.constructor == \"function\" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};\n                }\n                function initCloneByTag(object, tag, isDeep) {\n                    var Ctor = object.constructor;\n                    switch(tag){\n                        case arrayBufferTag:\n                            return cloneArrayBuffer(object);\n                        case boolTag:\n                        case dateTag:\n                            return new Ctor(+object);\n                        case dataViewTag:\n                            return cloneDataView(object, isDeep);\n                        case float32Tag:\n                        case float64Tag:\n                        case int8Tag:\n                        case int16Tag:\n                        case int32Tag:\n                        case uint8Tag:\n                        case uint8ClampedTag:\n                        case uint16Tag:\n                        case uint32Tag:\n                            return cloneTypedArray(object, isDeep);\n                        case mapTag:\n                            return new Ctor();\n                        case numberTag:\n                        case stringTag:\n                            return new Ctor(object);\n                        case regexpTag:\n                            return cloneRegExp(object);\n                        case setTag:\n                            return new Ctor();\n                        case symbolTag:\n                            return cloneSymbol(object);\n                    }\n                }\n                function insertWrapDetails(source, details) {\n                    var length = details.length;\n                    if (!length) {\n                        return source;\n                    }\n                    var lastIndex = length - 1;\n                    details[lastIndex] = (length > 1 ? \"& \" : \"\") + details[lastIndex];\n                    details = details.join(length > 2 ? \", \" : \" \");\n                    return source.replace(reWrapComment, \"{\\n/* [wrapped with \" + details + \"] */\\n\");\n                }\n                function isFlattenable(value) {\n                    return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);\n                }\n                function isIndex(value, length) {\n                    var type = typeof value;\n                    length = length == null ? MAX_SAFE_INTEGER : length;\n                    return !!length && (type == \"number\" || type != \"symbol\" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;\n                }\n                function isIterateeCall(value, index, object) {\n                    if (!isObject(object)) {\n                        return false;\n                    }\n                    var type = typeof index;\n                    if (type == \"number\" ? isArrayLike(object) && isIndex(index, object.length) : type == \"string\" && index in object) {\n                        return eq(object[index], value);\n                    }\n                    return false;\n                }\n                function isKey(value, object) {\n                    if (isArray(value)) {\n                        return false;\n                    }\n                    var type = typeof value;\n                    if (type == \"number\" || type == \"symbol\" || type == \"boolean\" || value == null || isSymbol(value)) {\n                        return true;\n                    }\n                    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);\n                }\n                function isKeyable(value) {\n                    var type = typeof value;\n                    return type == \"string\" || type == \"number\" || type == \"symbol\" || type == \"boolean\" ? value !== \"__proto__\" : value === null;\n                }\n                function isLaziable(func) {\n                    var funcName = getFuncName(func), other = lodash[funcName];\n                    if (typeof other != \"function\" || !(funcName in LazyWrapper.prototype)) {\n                        return false;\n                    }\n                    if (func === other) {\n                        return true;\n                    }\n                    var data = getData(other);\n                    return !!data && func === data[0];\n                }\n                function isMasked(func) {\n                    return !!maskSrcKey && maskSrcKey in func;\n                }\n                var isMaskable = coreJsData ? isFunction : stubFalse;\n                function isPrototype(value) {\n                    var Ctor = value && value.constructor, proto = typeof Ctor == \"function\" && Ctor.prototype || objectProto;\n                    return value === proto;\n                }\n                function isStrictComparable(value) {\n                    return value === value && !isObject(value);\n                }\n                function matchesStrictComparable(key, srcValue) {\n                    return function(object) {\n                        if (object == null) {\n                            return false;\n                        }\n                        return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));\n                    };\n                }\n                function memoizeCapped(func) {\n                    var result2 = memoize2(func, function(key) {\n                        if (cache.size === MAX_MEMOIZE_SIZE) {\n                            cache.clear();\n                        }\n                        return key;\n                    });\n                    var cache = result2.cache;\n                    return result2;\n                }\n                function mergeData(data, source) {\n                    var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);\n                    var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;\n                    if (!(isCommon || isCombo)) {\n                        return data;\n                    }\n                    if (srcBitmask & WRAP_BIND_FLAG) {\n                        data[2] = source[2];\n                        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;\n                    }\n                    var value = source[3];\n                    if (value) {\n                        var partials = data[3];\n                        data[3] = partials ? composeArgs(partials, value, source[4]) : value;\n                        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];\n                    }\n                    value = source[5];\n                    if (value) {\n                        partials = data[5];\n                        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;\n                        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];\n                    }\n                    value = source[7];\n                    if (value) {\n                        data[7] = value;\n                    }\n                    if (srcBitmask & WRAP_ARY_FLAG) {\n                        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);\n                    }\n                    if (data[9] == null) {\n                        data[9] = source[9];\n                    }\n                    data[0] = source[0];\n                    data[1] = newBitmask;\n                    return data;\n                }\n                function nativeKeysIn(object) {\n                    var result2 = [];\n                    if (object != null) {\n                        for(var key in Object2(object)){\n                            result2.push(key);\n                        }\n                    }\n                    return result2;\n                }\n                function objectToString(value) {\n                    return nativeObjectToString.call(value);\n                }\n                function overRest(func, start, transform2) {\n                    start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);\n                    return function() {\n                        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);\n                        while(++index < length){\n                            array[index] = args[start + index];\n                        }\n                        index = -1;\n                        var otherArgs = Array2(start + 1);\n                        while(++index < start){\n                            otherArgs[index] = args[index];\n                        }\n                        otherArgs[start] = transform2(array);\n                        return apply(func, this, otherArgs);\n                    };\n                }\n                function parent(object, path) {\n                    return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));\n                }\n                function reorder(array, indexes) {\n                    var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);\n                    while(length--){\n                        var index = indexes[length];\n                        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;\n                    }\n                    return array;\n                }\n                function safeGet(object, key) {\n                    if (key === \"constructor\" && typeof object[key] === \"function\") {\n                        return;\n                    }\n                    if (key == \"__proto__\") {\n                        return;\n                    }\n                    return object[key];\n                }\n                var setData = shortOut(baseSetData);\n                var setTimeout = ctxSetTimeout || function(func, wait) {\n                    return root.setTimeout(func, wait);\n                };\n                var setToString = shortOut(baseSetToString);\n                function setWrapToString(wrapper, reference, bitmask) {\n                    var source = reference + \"\";\n                    return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));\n                }\n                function shortOut(func) {\n                    var count = 0, lastCalled = 0;\n                    return function() {\n                        var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);\n                        lastCalled = stamp;\n                        if (remaining > 0) {\n                            if (++count >= HOT_COUNT) {\n                                return arguments[0];\n                            }\n                        } else {\n                            count = 0;\n                        }\n                        return func.apply(undefined2, arguments);\n                    };\n                }\n                function shuffleSelf(array, size2) {\n                    var index = -1, length = array.length, lastIndex = length - 1;\n                    size2 = size2 === undefined2 ? length : size2;\n                    while(++index < size2){\n                        var rand = baseRandom(index, lastIndex), value = array[rand];\n                        array[rand] = array[index];\n                        array[index] = value;\n                    }\n                    array.length = size2;\n                    return array;\n                }\n                var stringToPath = memoizeCapped(function(string) {\n                    var result2 = [];\n                    if (string.charCodeAt(0) === 46) {\n                        result2.push(\"\");\n                    }\n                    string.replace(rePropName, function(match, number, quote, subString) {\n                        result2.push(quote ? subString.replace(reEscapeChar, \"$1\") : number || match);\n                    });\n                    return result2;\n                });\n                function toKey(value) {\n                    if (typeof value == \"string\" || isSymbol(value)) {\n                        return value;\n                    }\n                    var result2 = value + \"\";\n                    return result2 == \"0\" && 1 / value == -INFINITY ? \"-0\" : result2;\n                }\n                function toSource(func) {\n                    if (func != null) {\n                        try {\n                            return funcToString.call(func);\n                        } catch (e) {}\n                        try {\n                            return func + \"\";\n                        } catch (e) {}\n                    }\n                    return \"\";\n                }\n                function updateWrapDetails(details, bitmask) {\n                    arrayEach(wrapFlags, function(pair) {\n                        var value = \"_.\" + pair[0];\n                        if (bitmask & pair[1] && !arrayIncludes(details, value)) {\n                            details.push(value);\n                        }\n                    });\n                    return details.sort();\n                }\n                function wrapperClone(wrapper) {\n                    if (wrapper instanceof LazyWrapper) {\n                        return wrapper.clone();\n                    }\n                    var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);\n                    result2.__actions__ = copyArray(wrapper.__actions__);\n                    result2.__index__ = wrapper.__index__;\n                    result2.__values__ = wrapper.__values__;\n                    return result2;\n                }\n                function chunk(array, size2, guard) {\n                    if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {\n                        size2 = 1;\n                    } else {\n                        size2 = nativeMax(toInteger(size2), 0);\n                    }\n                    var length = array == null ? 0 : array.length;\n                    if (!length || size2 < 1) {\n                        return [];\n                    }\n                    var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));\n                    while(index < length){\n                        result2[resIndex++] = baseSlice(array, index, index += size2);\n                    }\n                    return result2;\n                }\n                function compact(array) {\n                    var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];\n                    while(++index < length){\n                        var value = array[index];\n                        if (value) {\n                            result2[resIndex++] = value;\n                        }\n                    }\n                    return result2;\n                }\n                function concat() {\n                    var length = arguments.length;\n                    if (!length) {\n                        return [];\n                    }\n                    var args = Array2(length - 1), array = arguments[0], index = length;\n                    while(index--){\n                        args[index - 1] = arguments[index];\n                    }\n                    return arrayPush(isArray(array) ? copyArray(array) : [\n                        array\n                    ], baseFlatten(args, 1));\n                }\n                var difference = baseRest(function(array, values2) {\n                    return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];\n                });\n                var differenceBy = baseRest(function(array, values2) {\n                    var iteratee2 = last(values2);\n                    if (isArrayLikeObject(iteratee2)) {\n                        iteratee2 = undefined2;\n                    }\n                    return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];\n                });\n                var differenceWith = baseRest(function(array, values2) {\n                    var comparator = last(values2);\n                    if (isArrayLikeObject(comparator)) {\n                        comparator = undefined2;\n                    }\n                    return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];\n                });\n                function drop(array, n, guard) {\n                    var length = array == null ? 0 : array.length;\n                    if (!length) {\n                        return [];\n                    }\n                    n = guard || n === undefined2 ? 1 : toInteger(n);\n                    return baseSlice(array, n < 0 ? 0 : n, length);\n                }\n                function dropRight(array, n, guard) {\n                    var length = array == null ? 0 : array.length;\n                    if (!length) {\n                        return [];\n                    }\n                    n = guard || n === undefined2 ? 1 : toInteger(n);\n                    n = length - n;\n                    return baseSlice(array, 0, n < 0 ? 0 : n);\n                }\n                function dropRightWhile(array, predicate) {\n                    return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];\n                }\n                function dropWhile(array, predicate) {\n                    return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];\n                }\n                function fill(array, value, start, end) {\n                    var length = array == null ? 0 : array.length;\n                    if (!length) {\n                        return [];\n                    }\n                    if (start && typeof start != \"number\" && isIterateeCall(array, value, start)) {\n                        start = 0;\n                        end = length;\n                    }\n                    return baseFill(array, value, start, end);\n                }\n                function findIndex(array, predicate, fromIndex) {\n                    var length = array == null ? 0 : array.length;\n                    if (!length) {\n                        return -1;\n                    }\n                    var index = fromIndex == null ? 0 : toInteger(fromIndex);\n                    if (index < 0) {\n                        index = nativeMax(length + index, 0);\n                    }\n                    return baseFindIndex(array, getIteratee(predicate, 3), index);\n                }\n                function findLastIndex(array, predicate, fromIndex) {\n                    var length = array == null ? 0 : array.length;\n                    if (!length) {\n                        return -1;\n                    }\n                    var index = length - 1;\n                    if (fromIndex !== undefined2) {\n                        index = toInteger(fromIndex);\n                        index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);\n                    }\n                    return baseFindIndex(array, getIteratee(predicate, 3), index, true);\n                }\n                function flatten(array) {\n                    var length = array == null ? 0 : array.length;\n                    return length ? baseFlatten(array, 1) : [];\n                }\n                function flattenDeep(array) {\n                    var length = array == null ? 0 : array.length;\n                    return length ? baseFlatten(array, INFINITY) : [];\n                }\n                function flattenDepth(array, depth) {\n                    var length = array == null ? 0 : array.length;\n                    if (!length) {\n                        return [];\n                    }\n                    depth = depth === undefined2 ? 1 : toInteger(depth);\n                    return baseFlatten(array, depth);\n                }\n                function fromPairs(pairs) {\n                    var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};\n                    while(++index < length){\n                        var pair = pairs[index];\n                        result2[pair[0]] = pair[1];\n                    }\n                    return result2;\n                }\n                function head(array) {\n                    return array && array.length ? array[0] : undefined2;\n                }\n                function indexOf(array, value, fromIndex) {\n                    var length = array == null ? 0 : array.length;\n                    if (!length) {\n                        return -1;\n                    }\n                    var index = fromIndex == null ? 0 : toInteger(fromIndex);\n                    if (index < 0) {\n                        index = nativeMax(length + index, 0);\n                    }\n                    return baseIndexOf(array, value, index);\n                }\n                function initial(array) {\n                    var length = array == null ? 0 : array.length;\n                    return length ? baseSlice(array, 0, -1) : [];\n                }\n                var intersection = baseRest(function(arrays) {\n                    var mapped = arrayMap(arrays, castArrayLikeObject);\n                    return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];\n                });\n                var intersectionBy = baseRest(function(arrays) {\n                    var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);\n                    if (iteratee2 === last(mapped)) {\n                        iteratee2 = undefined2;\n                    } else {\n                        mapped.pop();\n                    }\n                    return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];\n                });\n                var intersectionWith = baseRest(function(arrays) {\n                    var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);\n                    comparator = typeof comparator == \"function\" ? comparator : undefined2;\n                    if (comparator) {\n                        mapped.pop();\n                    }\n                    return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];\n                });\n                function join(array, separator) {\n                    return array == null ? \"\" : nativeJoin.call(array, separator);\n                }\n                function last(array) {\n                    var length = array == null ? 0 : array.length;\n                    return length ? array[length - 1] : undefined2;\n                }\n                function lastIndexOf(array, value, fromIndex) {\n                    var length = array == null ? 0 : array.length;\n                    if (!length) {\n                        return -1;\n                    }\n                    var index = length;\n                    if (fromIndex !== undefined2) {\n                        index = toInteger(fromIndex);\n                        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);\n                    }\n                    return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);\n                }\n                function nth(array, n) {\n                    return array && array.length ? baseNth(array, toInteger(n)) : undefined2;\n                }\n                var pull = baseRest(pullAll);\n                function pullAll(array, values2) {\n                    return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;\n                }\n                function pullAllBy(array, values2, iteratee2) {\n                    return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;\n                }\n                function pullAllWith(array, values2, comparator) {\n                    return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;\n                }\n                var pullAt = flatRest(function(array, indexes) {\n                    var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);\n                    basePullAt(array, arrayMap(indexes, function(index) {\n                        return isIndex(index, length) ? +index : index;\n                    }).sort(compareAscending));\n                    return result2;\n                });\n                function remove(array, predicate) {\n                    var result2 = [];\n                    if (!(array && array.length)) {\n                        return result2;\n                    }\n                    var index = -1, indexes = [], length = array.length;\n                    predicate = getIteratee(predicate, 3);\n                    while(++index < length){\n                        var value = array[index];\n                        if (predicate(value, index, array)) {\n                            result2.push(value);\n                            indexes.push(index);\n                        }\n                    }\n                    basePullAt(array, indexes);\n                    return result2;\n                }\n                function reverse(array) {\n                    return array == null ? array : nativeReverse.call(array);\n                }\n                function slice(array, start, end) {\n                    var length = array == null ? 0 : array.length;\n                    if (!length) {\n                        return [];\n                    }\n                    if (end && typeof end != \"number\" && isIterateeCall(array, start, end)) {\n                        start = 0;\n                        end = length;\n                    } else {\n                        start = start == null ? 0 : toInteger(start);\n                        end = end === undefined2 ? length : toInteger(end);\n                    }\n                    return baseSlice(array, start, end);\n                }\n                function sortedIndex(array, value) {\n                    return baseSortedIndex(array, value);\n                }\n                function sortedIndexBy(array, value, iteratee2) {\n                    return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));\n                }\n                function sortedIndexOf(array, value) {\n                    var length = array == null ? 0 : array.length;\n                    if (length) {\n                        var index = baseSortedIndex(array, value);\n                        if (index < length && eq(array[index], value)) {\n                            return index;\n                        }\n                    }\n                    return -1;\n                }\n                function sortedLastIndex(array, value) {\n                    return baseSortedIndex(array, value, true);\n                }\n                function sortedLastIndexBy(array, value, iteratee2) {\n                    return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);\n                }\n                function sortedLastIndexOf(array, value) {\n                    var length = array == null ? 0 : array.length;\n                    if (length) {\n                        var index = baseSortedIndex(array, value, true) - 1;\n                        if (eq(array[index], value)) {\n                            return index;\n                        }\n                    }\n                    return -1;\n                }\n                function sortedUniq(array) {\n                    return array && array.length ? baseSortedUniq(array) : [];\n                }\n                function sortedUniqBy(array, iteratee2) {\n                    return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];\n                }\n                function tail(array) {\n                    var length = array == null ? 0 : array.length;\n                    return length ? baseSlice(array, 1, length) : [];\n                }\n                function take(array, n, guard) {\n                    if (!(array && array.length)) {\n                        return [];\n                    }\n                    n = guard || n === undefined2 ? 1 : toInteger(n);\n                    return baseSlice(array, 0, n < 0 ? 0 : n);\n                }\n                function takeRight(array, n, guard) {\n                    var length = array == null ? 0 : array.length;\n                    if (!length) {\n                        return [];\n                    }\n                    n = guard || n === undefined2 ? 1 : toInteger(n);\n                    n = length - n;\n                    return baseSlice(array, n < 0 ? 0 : n, length);\n                }\n                function takeRightWhile(array, predicate) {\n                    return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];\n                }\n                function takeWhile(array, predicate) {\n                    return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];\n                }\n                var union = baseRest(function(arrays) {\n                    return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));\n                });\n                var unionBy = baseRest(function(arrays) {\n                    var iteratee2 = last(arrays);\n                    if (isArrayLikeObject(iteratee2)) {\n                        iteratee2 = undefined2;\n                    }\n                    return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));\n                });\n                var unionWith = baseRest(function(arrays) {\n                    var comparator = last(arrays);\n                    comparator = typeof comparator == \"function\" ? comparator : undefined2;\n                    return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);\n                });\n                function uniq(array) {\n                    return array && array.length ? baseUniq(array) : [];\n                }\n                function uniqBy(array, iteratee2) {\n                    return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];\n                }\n                function uniqWith(array, comparator) {\n                    comparator = typeof comparator == \"function\" ? comparator : undefined2;\n                    return array && array.length ? baseUniq(array, undefined2, comparator) : [];\n                }\n                function unzip(array) {\n                    if (!(array && array.length)) {\n                        return [];\n                    }\n                    var length = 0;\n                    array = arrayFilter(array, function(group) {\n                        if (isArrayLikeObject(group)) {\n                            length = nativeMax(group.length, length);\n                            return true;\n                        }\n                    });\n                    return baseTimes(length, function(index) {\n                        return arrayMap(array, baseProperty(index));\n                    });\n                }\n                function unzipWith(array, iteratee2) {\n                    if (!(array && array.length)) {\n                        return [];\n                    }\n                    var result2 = unzip(array);\n                    if (iteratee2 == null) {\n                        return result2;\n                    }\n                    return arrayMap(result2, function(group) {\n                        return apply(iteratee2, undefined2, group);\n                    });\n                }\n                var without = baseRest(function(array, values2) {\n                    return isArrayLikeObject(array) ? baseDifference(array, values2) : [];\n                });\n                var xor = baseRest(function(arrays) {\n                    return baseXor(arrayFilter(arrays, isArrayLikeObject));\n                });\n                var xorBy = baseRest(function(arrays) {\n                    var iteratee2 = last(arrays);\n                    if (isArrayLikeObject(iteratee2)) {\n                        iteratee2 = undefined2;\n                    }\n                    return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));\n                });\n                var xorWith = baseRest(function(arrays) {\n                    var comparator = last(arrays);\n                    comparator = typeof comparator == \"function\" ? comparator : undefined2;\n                    return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);\n                });\n                var zip = baseRest(unzip);\n                function zipObject(props, values2) {\n                    return baseZipObject(props || [], values2 || [], assignValue);\n                }\n                function zipObjectDeep(props, values2) {\n                    return baseZipObject(props || [], values2 || [], baseSet);\n                }\n                var zipWith = baseRest(function(arrays) {\n                    var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;\n                    iteratee2 = typeof iteratee2 == \"function\" ? (arrays.pop(), iteratee2) : undefined2;\n                    return unzipWith(arrays, iteratee2);\n                });\n                function chain(value) {\n                    var result2 = lodash(value);\n                    result2.__chain__ = true;\n                    return result2;\n                }\n                function tap(value, interceptor) {\n                    interceptor(value);\n                    return value;\n                }\n                function thru(value, interceptor) {\n                    return interceptor(value);\n                }\n                var wrapperAt = flatRest(function(paths) {\n                    var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {\n                        return baseAt(object, paths);\n                    };\n                    if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {\n                        return this.thru(interceptor);\n                    }\n                    value = value.slice(start, +start + (length ? 1 : 0));\n                    value.__actions__.push({\n                        \"func\": thru,\n                        \"args\": [\n                            interceptor\n                        ],\n                        \"thisArg\": undefined2\n                    });\n                    return new LodashWrapper(value, this.__chain__).thru(function(array) {\n                        if (length && !array.length) {\n                            array.push(undefined2);\n                        }\n                        return array;\n                    });\n                });\n                function wrapperChain() {\n                    return chain(this);\n                }\n                function wrapperCommit() {\n                    return new LodashWrapper(this.value(), this.__chain__);\n                }\n                function wrapperNext() {\n                    if (this.__values__ === undefined2) {\n                        this.__values__ = toArray(this.value());\n                    }\n                    var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];\n                    return {\n                        \"done\": done,\n                        \"value\": value\n                    };\n                }\n                function wrapperToIterator() {\n                    return this;\n                }\n                function wrapperPlant(value) {\n                    var result2, parent2 = this;\n                    while(parent2 instanceof baseLodash){\n                        var clone2 = wrapperClone(parent2);\n                        clone2.__index__ = 0;\n                        clone2.__values__ = undefined2;\n                        if (result2) {\n                            previous.__wrapped__ = clone2;\n                        } else {\n                            result2 = clone2;\n                        }\n                        var previous = clone2;\n                        parent2 = parent2.__wrapped__;\n                    }\n                    previous.__wrapped__ = value;\n                    return result2;\n                }\n                function wrapperReverse() {\n                    var value = this.__wrapped__;\n                    if (value instanceof LazyWrapper) {\n                        var wrapped = value;\n                        if (this.__actions__.length) {\n                            wrapped = new LazyWrapper(this);\n                        }\n                        wrapped = wrapped.reverse();\n                        wrapped.__actions__.push({\n                            \"func\": thru,\n                            \"args\": [\n                                reverse\n                            ],\n                            \"thisArg\": undefined2\n                        });\n                        return new LodashWrapper(wrapped, this.__chain__);\n                    }\n                    return this.thru(reverse);\n                }\n                function wrapperValue() {\n                    return baseWrapperValue(this.__wrapped__, this.__actions__);\n                }\n                var countBy = createAggregator(function(result2, value, key) {\n                    if (hasOwnProperty.call(result2, key)) {\n                        ++result2[key];\n                    } else {\n                        baseAssignValue(result2, key, 1);\n                    }\n                });\n                function every(collection, predicate, guard) {\n                    var func = isArray(collection) ? arrayEvery : baseEvery;\n                    if (guard && isIterateeCall(collection, predicate, guard)) {\n                        predicate = undefined2;\n                    }\n                    return func(collection, getIteratee(predicate, 3));\n                }\n                function filter(collection, predicate) {\n                    var func = isArray(collection) ? arrayFilter : baseFilter;\n                    return func(collection, getIteratee(predicate, 3));\n                }\n                var find = createFind(findIndex);\n                var findLast = createFind(findLastIndex);\n                function flatMap(collection, iteratee2) {\n                    return baseFlatten(map(collection, iteratee2), 1);\n                }\n                function flatMapDeep(collection, iteratee2) {\n                    return baseFlatten(map(collection, iteratee2), INFINITY);\n                }\n                function flatMapDepth(collection, iteratee2, depth) {\n                    depth = depth === undefined2 ? 1 : toInteger(depth);\n                    return baseFlatten(map(collection, iteratee2), depth);\n                }\n                function forEach(collection, iteratee2) {\n                    var func = isArray(collection) ? arrayEach : baseEach;\n                    return func(collection, getIteratee(iteratee2, 3));\n                }\n                function forEachRight(collection, iteratee2) {\n                    var func = isArray(collection) ? arrayEachRight : baseEachRight;\n                    return func(collection, getIteratee(iteratee2, 3));\n                }\n                var groupBy = createAggregator(function(result2, value, key) {\n                    if (hasOwnProperty.call(result2, key)) {\n                        result2[key].push(value);\n                    } else {\n                        baseAssignValue(result2, key, [\n                            value\n                        ]);\n                    }\n                });\n                function includes(collection, value, fromIndex, guard) {\n                    collection = isArrayLike(collection) ? collection : values(collection);\n                    fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;\n                    var length = collection.length;\n                    if (fromIndex < 0) {\n                        fromIndex = nativeMax(length + fromIndex, 0);\n                    }\n                    return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;\n                }\n                var invokeMap = baseRest(function(collection, path, args) {\n                    var index = -1, isFunc = typeof path == \"function\", result2 = isArrayLike(collection) ? Array2(collection.length) : [];\n                    baseEach(collection, function(value) {\n                        result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);\n                    });\n                    return result2;\n                });\n                var keyBy = createAggregator(function(result2, value, key) {\n                    baseAssignValue(result2, key, value);\n                });\n                function map(collection, iteratee2) {\n                    var func = isArray(collection) ? arrayMap : baseMap;\n                    return func(collection, getIteratee(iteratee2, 3));\n                }\n                function orderBy(collection, iteratees, orders, guard) {\n                    if (collection == null) {\n                        return [];\n                    }\n                    if (!isArray(iteratees)) {\n                        iteratees = iteratees == null ? [] : [\n                            iteratees\n                        ];\n                    }\n                    orders = guard ? undefined2 : orders;\n                    if (!isArray(orders)) {\n                        orders = orders == null ? [] : [\n                            orders\n                        ];\n                    }\n                    return baseOrderBy(collection, iteratees, orders);\n                }\n                var partition = createAggregator(function(result2, value, key) {\n                    result2[key ? 0 : 1].push(value);\n                }, function() {\n                    return [\n                        [],\n                        []\n                    ];\n                });\n                function reduce(collection, iteratee2, accumulator) {\n                    var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;\n                    return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);\n                }\n                function reduceRight(collection, iteratee2, accumulator) {\n                    var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;\n                    return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);\n                }\n                function reject(collection, predicate) {\n                    var func = isArray(collection) ? arrayFilter : baseFilter;\n                    return func(collection, negate(getIteratee(predicate, 3)));\n                }\n                function sample(collection) {\n                    var func = isArray(collection) ? arraySample : baseSample;\n                    return func(collection);\n                }\n                function sampleSize(collection, n, guard) {\n                    if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {\n                        n = 1;\n                    } else {\n                        n = toInteger(n);\n                    }\n                    var func = isArray(collection) ? arraySampleSize : baseSampleSize;\n                    return func(collection, n);\n                }\n                function shuffle(collection) {\n                    var func = isArray(collection) ? arrayShuffle : baseShuffle;\n                    return func(collection);\n                }\n                function size(collection) {\n                    if (collection == null) {\n                        return 0;\n                    }\n                    if (isArrayLike(collection)) {\n                        return isString(collection) ? stringSize(collection) : collection.length;\n                    }\n                    var tag = getTag(collection);\n                    if (tag == mapTag || tag == setTag) {\n                        return collection.size;\n                    }\n                    return baseKeys(collection).length;\n                }\n                function some(collection, predicate, guard) {\n                    var func = isArray(collection) ? arraySome : baseSome;\n                    if (guard && isIterateeCall(collection, predicate, guard)) {\n                        predicate = undefined2;\n                    }\n                    return func(collection, getIteratee(predicate, 3));\n                }\n                var sortBy = baseRest(function(collection, iteratees) {\n                    if (collection == null) {\n                        return [];\n                    }\n                    var length = iteratees.length;\n                    if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {\n                        iteratees = [];\n                    } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {\n                        iteratees = [\n                            iteratees[0]\n                        ];\n                    }\n                    return baseOrderBy(collection, baseFlatten(iteratees, 1), []);\n                });\n                var now = ctxNow || function() {\n                    return root.Date.now();\n                };\n                function after(n, func) {\n                    if (typeof func != \"function\") {\n                        throw new TypeError2(FUNC_ERROR_TEXT);\n                    }\n                    n = toInteger(n);\n                    return function() {\n                        if (--n < 1) {\n                            return func.apply(this, arguments);\n                        }\n                    };\n                }\n                function ary(func, n, guard) {\n                    n = guard ? undefined2 : n;\n                    n = func && n == null ? func.length : n;\n                    return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);\n                }\n                function before(n, func) {\n                    var result2;\n                    if (typeof func != \"function\") {\n                        throw new TypeError2(FUNC_ERROR_TEXT);\n                    }\n                    n = toInteger(n);\n                    return function() {\n                        if (--n > 0) {\n                            result2 = func.apply(this, arguments);\n                        }\n                        if (n <= 1) {\n                            func = undefined2;\n                        }\n                        return result2;\n                    };\n                }\n                var bind = baseRest(function(func, thisArg, partials) {\n                    var bitmask = WRAP_BIND_FLAG;\n                    if (partials.length) {\n                        var holders = replaceHolders(partials, getHolder(bind));\n                        bitmask |= WRAP_PARTIAL_FLAG;\n                    }\n                    return createWrap(func, bitmask, thisArg, partials, holders);\n                });\n                var bindKey = baseRest(function(object, key, partials) {\n                    var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;\n                    if (partials.length) {\n                        var holders = replaceHolders(partials, getHolder(bindKey));\n                        bitmask |= WRAP_PARTIAL_FLAG;\n                    }\n                    return createWrap(key, bitmask, object, partials, holders);\n                });\n                function curry(func, arity, guard) {\n                    arity = guard ? undefined2 : arity;\n                    var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);\n                    result2.placeholder = curry.placeholder;\n                    return result2;\n                }\n                function curryRight(func, arity, guard) {\n                    arity = guard ? undefined2 : arity;\n                    var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);\n                    result2.placeholder = curryRight.placeholder;\n                    return result2;\n                }\n                function debounce(func, wait, options) {\n                    var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;\n                    if (typeof func != \"function\") {\n                        throw new TypeError2(FUNC_ERROR_TEXT);\n                    }\n                    wait = toNumber(wait) || 0;\n                    if (isObject(options)) {\n                        leading = !!options.leading;\n                        maxing = \"maxWait\" in options;\n                        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n                        trailing = \"trailing\" in options ? !!options.trailing : trailing;\n                    }\n                    function invokeFunc(time) {\n                        var args = lastArgs, thisArg = lastThis;\n                        lastArgs = lastThis = undefined2;\n                        lastInvokeTime = time;\n                        result2 = func.apply(thisArg, args);\n                        return result2;\n                    }\n                    function leadingEdge(time) {\n                        lastInvokeTime = time;\n                        timerId = setTimeout(timerExpired, wait);\n                        return leading ? invokeFunc(time) : result2;\n                    }\n                    function remainingWait(time) {\n                        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;\n                        return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;\n                    }\n                    function shouldInvoke(time) {\n                        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;\n                        return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;\n                    }\n                    function timerExpired() {\n                        var time = now();\n                        if (shouldInvoke(time)) {\n                            return trailingEdge(time);\n                        }\n                        timerId = setTimeout(timerExpired, remainingWait(time));\n                    }\n                    function trailingEdge(time) {\n                        timerId = undefined2;\n                        if (trailing && lastArgs) {\n                            return invokeFunc(time);\n                        }\n                        lastArgs = lastThis = undefined2;\n                        return result2;\n                    }\n                    function cancel() {\n                        if (timerId !== undefined2) {\n                            clearTimeout(timerId);\n                        }\n                        lastInvokeTime = 0;\n                        lastArgs = lastCallTime = lastThis = timerId = undefined2;\n                    }\n                    function flush() {\n                        return timerId === undefined2 ? result2 : trailingEdge(now());\n                    }\n                    function debounced() {\n                        var time = now(), isInvoking = shouldInvoke(time);\n                        lastArgs = arguments;\n                        lastThis = this;\n                        lastCallTime = time;\n                        if (isInvoking) {\n                            if (timerId === undefined2) {\n                                return leadingEdge(lastCallTime);\n                            }\n                            if (maxing) {\n                                clearTimeout(timerId);\n                                timerId = setTimeout(timerExpired, wait);\n                                return invokeFunc(lastCallTime);\n                            }\n                        }\n                        if (timerId === undefined2) {\n                            timerId = setTimeout(timerExpired, wait);\n                        }\n                        return result2;\n                    }\n                    debounced.cancel = cancel;\n                    debounced.flush = flush;\n                    return debounced;\n                }\n                var defer = baseRest(function(func, args) {\n                    return baseDelay(func, 1, args);\n                });\n                var delay = baseRest(function(func, wait, args) {\n                    return baseDelay(func, toNumber(wait) || 0, args);\n                });\n                function flip(func) {\n                    return createWrap(func, WRAP_FLIP_FLAG);\n                }\n                function memoize2(func, resolver) {\n                    if (typeof func != \"function\" || resolver != null && typeof resolver != \"function\") {\n                        throw new TypeError2(FUNC_ERROR_TEXT);\n                    }\n                    var memoized = function() {\n                        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;\n                        if (cache.has(key)) {\n                            return cache.get(key);\n                        }\n                        var result2 = func.apply(this, args);\n                        memoized.cache = cache.set(key, result2) || cache;\n                        return result2;\n                    };\n                    memoized.cache = new (memoize2.Cache || MapCache)();\n                    return memoized;\n                }\n                memoize2.Cache = MapCache;\n                function negate(predicate) {\n                    if (typeof predicate != \"function\") {\n                        throw new TypeError2(FUNC_ERROR_TEXT);\n                    }\n                    return function() {\n                        var args = arguments;\n                        switch(args.length){\n                            case 0:\n                                return !predicate.call(this);\n                            case 1:\n                                return !predicate.call(this, args[0]);\n                            case 2:\n                                return !predicate.call(this, args[0], args[1]);\n                            case 3:\n                                return !predicate.call(this, args[0], args[1], args[2]);\n                        }\n                        return !predicate.apply(this, args);\n                    };\n                }\n                function once(func) {\n                    return before(2, func);\n                }\n                var overArgs = castRest(function(func, transforms) {\n                    transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));\n                    var funcsLength = transforms.length;\n                    return baseRest(function(args) {\n                        var index = -1, length = nativeMin(args.length, funcsLength);\n                        while(++index < length){\n                            args[index] = transforms[index].call(this, args[index]);\n                        }\n                        return apply(func, this, args);\n                    });\n                });\n                var partial = baseRest(function(func, partials) {\n                    var holders = replaceHolders(partials, getHolder(partial));\n                    return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);\n                });\n                var partialRight = baseRest(function(func, partials) {\n                    var holders = replaceHolders(partials, getHolder(partialRight));\n                    return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);\n                });\n                var rearg = flatRest(function(func, indexes) {\n                    return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);\n                });\n                function rest(func, start) {\n                    if (typeof func != \"function\") {\n                        throw new TypeError2(FUNC_ERROR_TEXT);\n                    }\n                    start = start === undefined2 ? start : toInteger(start);\n                    return baseRest(func, start);\n                }\n                function spread(func, start) {\n                    if (typeof func != \"function\") {\n                        throw new TypeError2(FUNC_ERROR_TEXT);\n                    }\n                    start = start == null ? 0 : nativeMax(toInteger(start), 0);\n                    return baseRest(function(args) {\n                        var array = args[start], otherArgs = castSlice(args, 0, start);\n                        if (array) {\n                            arrayPush(otherArgs, array);\n                        }\n                        return apply(func, this, otherArgs);\n                    });\n                }\n                function throttle(func, wait, options) {\n                    var leading = true, trailing = true;\n                    if (typeof func != \"function\") {\n                        throw new TypeError2(FUNC_ERROR_TEXT);\n                    }\n                    if (isObject(options)) {\n                        leading = \"leading\" in options ? !!options.leading : leading;\n                        trailing = \"trailing\" in options ? !!options.trailing : trailing;\n                    }\n                    return debounce(func, wait, {\n                        \"leading\": leading,\n                        \"maxWait\": wait,\n                        \"trailing\": trailing\n                    });\n                }\n                function unary(func) {\n                    return ary(func, 1);\n                }\n                function wrap(value, wrapper) {\n                    return partial(castFunction(wrapper), value);\n                }\n                function castArray() {\n                    if (!arguments.length) {\n                        return [];\n                    }\n                    var value = arguments[0];\n                    return isArray(value) ? value : [\n                        value\n                    ];\n                }\n                function clone(value) {\n                    return baseClone(value, CLONE_SYMBOLS_FLAG);\n                }\n                function cloneWith(value, customizer) {\n                    customizer = typeof customizer == \"function\" ? customizer : undefined2;\n                    return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);\n                }\n                function cloneDeep(value) {\n                    return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);\n                }\n                function cloneDeepWith(value, customizer) {\n                    customizer = typeof customizer == \"function\" ? customizer : undefined2;\n                    return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);\n                }\n                function conformsTo(object, source) {\n                    return source == null || baseConformsTo(object, source, keys(source));\n                }\n                function eq(value, other) {\n                    return value === other || value !== value && other !== other;\n                }\n                var gt = createRelationalOperation(baseGt);\n                var gte = createRelationalOperation(function(value, other) {\n                    return value >= other;\n                });\n                var isArguments = baseIsArguments(function() {\n                    return arguments;\n                }()) ? baseIsArguments : function(value) {\n                    return isObjectLike(value) && hasOwnProperty.call(value, \"callee\") && !propertyIsEnumerable.call(value, \"callee\");\n                };\n                var isArray = Array2.isArray;\n                var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;\n                function isArrayLike(value) {\n                    return value != null && isLength(value.length) && !isFunction(value);\n                }\n                function isArrayLikeObject(value) {\n                    return isObjectLike(value) && isArrayLike(value);\n                }\n                function isBoolean(value) {\n                    return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;\n                }\n                var isBuffer = nativeIsBuffer || stubFalse;\n                var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;\n                function isElement(value) {\n                    return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);\n                }\n                function isEmpty(value) {\n                    if (value == null) {\n                        return true;\n                    }\n                    if (isArrayLike(value) && (isArray(value) || typeof value == \"string\" || typeof value.splice == \"function\" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {\n                        return !value.length;\n                    }\n                    var tag = getTag(value);\n                    if (tag == mapTag || tag == setTag) {\n                        return !value.size;\n                    }\n                    if (isPrototype(value)) {\n                        return !baseKeys(value).length;\n                    }\n                    for(var key in value){\n                        if (hasOwnProperty.call(value, key)) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n                function isEqual(value, other) {\n                    return baseIsEqual(value, other);\n                }\n                function isEqualWith(value, other, customizer) {\n                    customizer = typeof customizer == \"function\" ? customizer : undefined2;\n                    var result2 = customizer ? customizer(value, other) : undefined2;\n                    return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;\n                }\n                function isError(value) {\n                    if (!isObjectLike(value)) {\n                        return false;\n                    }\n                    var tag = baseGetTag(value);\n                    return tag == errorTag || tag == domExcTag || typeof value.message == \"string\" && typeof value.name == \"string\" && !isPlainObject(value);\n                }\n                function isFinite2(value) {\n                    return typeof value == \"number\" && nativeIsFinite(value);\n                }\n                function isFunction(value) {\n                    if (!isObject(value)) {\n                        return false;\n                    }\n                    var tag = baseGetTag(value);\n                    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\n                }\n                function isInteger(value) {\n                    return typeof value == \"number\" && value == toInteger(value);\n                }\n                function isLength(value) {\n                    return typeof value == \"number\" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n                }\n                function isObject(value) {\n                    var type = typeof value;\n                    return value != null && (type == \"object\" || type == \"function\");\n                }\n                function isObjectLike(value) {\n                    return value != null && typeof value == \"object\";\n                }\n                var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\n                function isMatch(object, source) {\n                    return object === source || baseIsMatch(object, source, getMatchData(source));\n                }\n                function isMatchWith(object, source, customizer) {\n                    customizer = typeof customizer == \"function\" ? customizer : undefined2;\n                    return baseIsMatch(object, source, getMatchData(source), customizer);\n                }\n                function isNaN2(value) {\n                    return isNumber(value) && value != +value;\n                }\n                function isNative(value) {\n                    if (isMaskable(value)) {\n                        throw new Error2(CORE_ERROR_TEXT);\n                    }\n                    return baseIsNative(value);\n                }\n                function isNull(value) {\n                    return value === null;\n                }\n                function isNil(value) {\n                    return value == null;\n                }\n                function isNumber(value) {\n                    return typeof value == \"number\" || isObjectLike(value) && baseGetTag(value) == numberTag;\n                }\n                function isPlainObject(value) {\n                    if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n                        return false;\n                    }\n                    var proto = getPrototype(value);\n                    if (proto === null) {\n                        return true;\n                    }\n                    var Ctor = hasOwnProperty.call(proto, \"constructor\") && proto.constructor;\n                    return typeof Ctor == \"function\" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;\n                }\n                var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;\n                function isSafeInteger(value) {\n                    return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;\n                }\n                var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\n                function isString(value) {\n                    return typeof value == \"string\" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;\n                }\n                function isSymbol(value) {\n                    return typeof value == \"symbol\" || isObjectLike(value) && baseGetTag(value) == symbolTag;\n                }\n                var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n                function isUndefined(value) {\n                    return value === undefined2;\n                }\n                function isWeakMap(value) {\n                    return isObjectLike(value) && getTag(value) == weakMapTag;\n                }\n                function isWeakSet(value) {\n                    return isObjectLike(value) && baseGetTag(value) == weakSetTag;\n                }\n                var lt = createRelationalOperation(baseLt);\n                var lte = createRelationalOperation(function(value, other) {\n                    return value <= other;\n                });\n                function toArray(value) {\n                    if (!value) {\n                        return [];\n                    }\n                    if (isArrayLike(value)) {\n                        return isString(value) ? stringToArray(value) : copyArray(value);\n                    }\n                    if (symIterator && value[symIterator]) {\n                        return iteratorToArray(value[symIterator]());\n                    }\n                    var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;\n                    return func(value);\n                }\n                function toFinite(value) {\n                    if (!value) {\n                        return value === 0 ? value : 0;\n                    }\n                    value = toNumber(value);\n                    if (value === INFINITY || value === -INFINITY) {\n                        var sign = value < 0 ? -1 : 1;\n                        return sign * MAX_INTEGER;\n                    }\n                    return value === value ? value : 0;\n                }\n                function toInteger(value) {\n                    var result2 = toFinite(value), remainder = result2 % 1;\n                    return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;\n                }\n                function toLength(value) {\n                    return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;\n                }\n                function toNumber(value) {\n                    if (typeof value == \"number\") {\n                        return value;\n                    }\n                    if (isSymbol(value)) {\n                        return NAN;\n                    }\n                    if (isObject(value)) {\n                        var other = typeof value.valueOf == \"function\" ? value.valueOf() : value;\n                        value = isObject(other) ? other + \"\" : other;\n                    }\n                    if (typeof value != \"string\") {\n                        return value === 0 ? value : +value;\n                    }\n                    value = baseTrim(value);\n                    var isBinary = reIsBinary.test(value);\n                    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;\n                }\n                function toPlainObject(value) {\n                    return copyObject(value, keysIn(value));\n                }\n                function toSafeInteger(value) {\n                    return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;\n                }\n                function toString(value) {\n                    return value == null ? \"\" : baseToString(value);\n                }\n                var assign = createAssigner(function(object, source) {\n                    if (isPrototype(source) || isArrayLike(source)) {\n                        copyObject(source, keys(source), object);\n                        return;\n                    }\n                    for(var key in source){\n                        if (hasOwnProperty.call(source, key)) {\n                            assignValue(object, key, source[key]);\n                        }\n                    }\n                });\n                var assignIn = createAssigner(function(object, source) {\n                    copyObject(source, keysIn(source), object);\n                });\n                var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {\n                    copyObject(source, keysIn(source), object, customizer);\n                });\n                var assignWith = createAssigner(function(object, source, srcIndex, customizer) {\n                    copyObject(source, keys(source), object, customizer);\n                });\n                var at = flatRest(baseAt);\n                function create(prototype, properties) {\n                    var result2 = baseCreate(prototype);\n                    return properties == null ? result2 : baseAssign(result2, properties);\n                }\n                var defaults = baseRest(function(object, sources) {\n                    object = Object2(object);\n                    var index = -1;\n                    var length = sources.length;\n                    var guard = length > 2 ? sources[2] : undefined2;\n                    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n                        length = 1;\n                    }\n                    while(++index < length){\n                        var source = sources[index];\n                        var props = keysIn(source);\n                        var propsIndex = -1;\n                        var propsLength = props.length;\n                        while(++propsIndex < propsLength){\n                            var key = props[propsIndex];\n                            var value = object[key];\n                            if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {\n                                object[key] = source[key];\n                            }\n                        }\n                    }\n                    return object;\n                });\n                var defaultsDeep = baseRest(function(args) {\n                    args.push(undefined2, customDefaultsMerge);\n                    return apply(mergeWith, undefined2, args);\n                });\n                function findKey(object, predicate) {\n                    return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);\n                }\n                function findLastKey(object, predicate) {\n                    return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);\n                }\n                function forIn(object, iteratee2) {\n                    return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);\n                }\n                function forInRight(object, iteratee2) {\n                    return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);\n                }\n                function forOwn(object, iteratee2) {\n                    return object && baseForOwn(object, getIteratee(iteratee2, 3));\n                }\n                function forOwnRight(object, iteratee2) {\n                    return object && baseForOwnRight(object, getIteratee(iteratee2, 3));\n                }\n                function functions(object) {\n                    return object == null ? [] : baseFunctions(object, keys(object));\n                }\n                function functionsIn(object) {\n                    return object == null ? [] : baseFunctions(object, keysIn(object));\n                }\n                function get(object, path, defaultValue) {\n                    var result2 = object == null ? undefined2 : baseGet(object, path);\n                    return result2 === undefined2 ? defaultValue : result2;\n                }\n                function has(object, path) {\n                    return object != null && hasPath(object, path, baseHas);\n                }\n                function hasIn(object, path) {\n                    return object != null && hasPath(object, path, baseHasIn);\n                }\n                var invert = createInverter(function(result2, value, key) {\n                    if (value != null && typeof value.toString != \"function\") {\n                        value = nativeObjectToString.call(value);\n                    }\n                    result2[value] = key;\n                }, constant(identity));\n                var invertBy = createInverter(function(result2, value, key) {\n                    if (value != null && typeof value.toString != \"function\") {\n                        value = nativeObjectToString.call(value);\n                    }\n                    if (hasOwnProperty.call(result2, value)) {\n                        result2[value].push(key);\n                    } else {\n                        result2[value] = [\n                            key\n                        ];\n                    }\n                }, getIteratee);\n                var invoke = baseRest(baseInvoke);\n                function keys(object) {\n                    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n                }\n                function keysIn(object) {\n                    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n                }\n                function mapKeys(object, iteratee2) {\n                    var result2 = {};\n                    iteratee2 = getIteratee(iteratee2, 3);\n                    baseForOwn(object, function(value, key, object2) {\n                        baseAssignValue(result2, iteratee2(value, key, object2), value);\n                    });\n                    return result2;\n                }\n                function mapValues(object, iteratee2) {\n                    var result2 = {};\n                    iteratee2 = getIteratee(iteratee2, 3);\n                    baseForOwn(object, function(value, key, object2) {\n                        baseAssignValue(result2, key, iteratee2(value, key, object2));\n                    });\n                    return result2;\n                }\n                var merge = createAssigner(function(object, source, srcIndex) {\n                    baseMerge(object, source, srcIndex);\n                });\n                var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {\n                    baseMerge(object, source, srcIndex, customizer);\n                });\n                var omit = flatRest(function(object, paths) {\n                    var result2 = {};\n                    if (object == null) {\n                        return result2;\n                    }\n                    var isDeep = false;\n                    paths = arrayMap(paths, function(path) {\n                        path = castPath(path, object);\n                        isDeep || (isDeep = path.length > 1);\n                        return path;\n                    });\n                    copyObject(object, getAllKeysIn(object), result2);\n                    if (isDeep) {\n                        result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);\n                    }\n                    var length = paths.length;\n                    while(length--){\n                        baseUnset(result2, paths[length]);\n                    }\n                    return result2;\n                });\n                function omitBy(object, predicate) {\n                    return pickBy(object, negate(getIteratee(predicate)));\n                }\n                var pick = flatRest(function(object, paths) {\n                    return object == null ? {} : basePick(object, paths);\n                });\n                function pickBy(object, predicate) {\n                    if (object == null) {\n                        return {};\n                    }\n                    var props = arrayMap(getAllKeysIn(object), function(prop) {\n                        return [\n                            prop\n                        ];\n                    });\n                    predicate = getIteratee(predicate);\n                    return basePickBy(object, props, function(value, path) {\n                        return predicate(value, path[0]);\n                    });\n                }\n                function result(object, path, defaultValue) {\n                    path = castPath(path, object);\n                    var index = -1, length = path.length;\n                    if (!length) {\n                        length = 1;\n                        object = undefined2;\n                    }\n                    while(++index < length){\n                        var value = object == null ? undefined2 : object[toKey(path[index])];\n                        if (value === undefined2) {\n                            index = length;\n                            value = defaultValue;\n                        }\n                        object = isFunction(value) ? value.call(object) : value;\n                    }\n                    return object;\n                }\n                function set(object, path, value) {\n                    return object == null ? object : baseSet(object, path, value);\n                }\n                function setWith(object, path, value, customizer) {\n                    customizer = typeof customizer == \"function\" ? customizer : undefined2;\n                    return object == null ? object : baseSet(object, path, value, customizer);\n                }\n                var toPairs = createToPairs(keys);\n                var toPairsIn = createToPairs(keysIn);\n                function transform(object, iteratee2, accumulator) {\n                    var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);\n                    iteratee2 = getIteratee(iteratee2, 4);\n                    if (accumulator == null) {\n                        var Ctor = object && object.constructor;\n                        if (isArrLike) {\n                            accumulator = isArr ? new Ctor() : [];\n                        } else if (isObject(object)) {\n                            accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};\n                        } else {\n                            accumulator = {};\n                        }\n                    }\n                    (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {\n                        return iteratee2(accumulator, value, index, object2);\n                    });\n                    return accumulator;\n                }\n                function unset(object, path) {\n                    return object == null ? true : baseUnset(object, path);\n                }\n                function update(object, path, updater) {\n                    return object == null ? object : baseUpdate(object, path, castFunction(updater));\n                }\n                function updateWith(object, path, updater, customizer) {\n                    customizer = typeof customizer == \"function\" ? customizer : undefined2;\n                    return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);\n                }\n                function values(object) {\n                    return object == null ? [] : baseValues(object, keys(object));\n                }\n                function valuesIn(object) {\n                    return object == null ? [] : baseValues(object, keysIn(object));\n                }\n                function clamp(number, lower, upper) {\n                    if (upper === undefined2) {\n                        upper = lower;\n                        lower = undefined2;\n                    }\n                    if (upper !== undefined2) {\n                        upper = toNumber(upper);\n                        upper = upper === upper ? upper : 0;\n                    }\n                    if (lower !== undefined2) {\n                        lower = toNumber(lower);\n                        lower = lower === lower ? lower : 0;\n                    }\n                    return baseClamp(toNumber(number), lower, upper);\n                }\n                function inRange(number, start, end) {\n                    start = toFinite(start);\n                    if (end === undefined2) {\n                        end = start;\n                        start = 0;\n                    } else {\n                        end = toFinite(end);\n                    }\n                    number = toNumber(number);\n                    return baseInRange(number, start, end);\n                }\n                function random(lower, upper, floating) {\n                    if (floating && typeof floating != \"boolean\" && isIterateeCall(lower, upper, floating)) {\n                        upper = floating = undefined2;\n                    }\n                    if (floating === undefined2) {\n                        if (typeof upper == \"boolean\") {\n                            floating = upper;\n                            upper = undefined2;\n                        } else if (typeof lower == \"boolean\") {\n                            floating = lower;\n                            lower = undefined2;\n                        }\n                    }\n                    if (lower === undefined2 && upper === undefined2) {\n                        lower = 0;\n                        upper = 1;\n                    } else {\n                        lower = toFinite(lower);\n                        if (upper === undefined2) {\n                            upper = lower;\n                            lower = 0;\n                        } else {\n                            upper = toFinite(upper);\n                        }\n                    }\n                    if (lower > upper) {\n                        var temp = lower;\n                        lower = upper;\n                        upper = temp;\n                    }\n                    if (floating || lower % 1 || upper % 1) {\n                        var rand = nativeRandom();\n                        return nativeMin(lower + rand * (upper - lower + freeParseFloat(\"1e-\" + ((rand + \"\").length - 1))), upper);\n                    }\n                    return baseRandom(lower, upper);\n                }\n                var camelCase = createCompounder(function(result2, word, index) {\n                    word = word.toLowerCase();\n                    return result2 + (index ? capitalize(word) : word);\n                });\n                function capitalize(string) {\n                    return upperFirst(toString(string).toLowerCase());\n                }\n                function deburr(string) {\n                    string = toString(string);\n                    return string && string.replace(reLatin, deburrLetter).replace(reComboMark, \"\");\n                }\n                function endsWith(string, target, position) {\n                    string = toString(string);\n                    target = baseToString(target);\n                    var length = string.length;\n                    position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);\n                    var end = position;\n                    position -= target.length;\n                    return position >= 0 && string.slice(position, end) == target;\n                }\n                function escape(string) {\n                    string = toString(string);\n                    return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;\n                }\n                function escapeRegExp(string) {\n                    string = toString(string);\n                    return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, \"\\\\$&\") : string;\n                }\n                var kebabCase = createCompounder(function(result2, word, index) {\n                    return result2 + (index ? \"-\" : \"\") + word.toLowerCase();\n                });\n                var lowerCase = createCompounder(function(result2, word, index) {\n                    return result2 + (index ? \" \" : \"\") + word.toLowerCase();\n                });\n                var lowerFirst = createCaseFirst(\"toLowerCase\");\n                function pad(string, length, chars) {\n                    string = toString(string);\n                    length = toInteger(length);\n                    var strLength = length ? stringSize(string) : 0;\n                    if (!length || strLength >= length) {\n                        return string;\n                    }\n                    var mid = (length - strLength) / 2;\n                    return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);\n                }\n                function padEnd(string, length, chars) {\n                    string = toString(string);\n                    length = toInteger(length);\n                    var strLength = length ? stringSize(string) : 0;\n                    return length && strLength < length ? string + createPadding(length - strLength, chars) : string;\n                }\n                function padStart(string, length, chars) {\n                    string = toString(string);\n                    length = toInteger(length);\n                    var strLength = length ? stringSize(string) : 0;\n                    return length && strLength < length ? createPadding(length - strLength, chars) + string : string;\n                }\n                function parseInt2(string, radix, guard) {\n                    if (guard || radix == null) {\n                        radix = 0;\n                    } else if (radix) {\n                        radix = +radix;\n                    }\n                    return nativeParseInt(toString(string).replace(reTrimStart, \"\"), radix || 0);\n                }\n                function repeat(string, n, guard) {\n                    if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {\n                        n = 1;\n                    } else {\n                        n = toInteger(n);\n                    }\n                    return baseRepeat(toString(string), n);\n                }\n                function replace() {\n                    var args = arguments, string = toString(args[0]);\n                    return args.length < 3 ? string : string.replace(args[1], args[2]);\n                }\n                var snakeCase = createCompounder(function(result2, word, index) {\n                    return result2 + (index ? \"_\" : \"\") + word.toLowerCase();\n                });\n                function split(string, separator, limit) {\n                    if (limit && typeof limit != \"number\" && isIterateeCall(string, separator, limit)) {\n                        separator = limit = undefined2;\n                    }\n                    limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;\n                    if (!limit) {\n                        return [];\n                    }\n                    string = toString(string);\n                    if (string && (typeof separator == \"string\" || separator != null && !isRegExp(separator))) {\n                        separator = baseToString(separator);\n                        if (!separator && hasUnicode(string)) {\n                            return castSlice(stringToArray(string), 0, limit);\n                        }\n                    }\n                    return string.split(separator, limit);\n                }\n                var startCase = createCompounder(function(result2, word, index) {\n                    return result2 + (index ? \" \" : \"\") + upperFirst(word);\n                });\n                function startsWith(string, target, position) {\n                    string = toString(string);\n                    position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);\n                    target = baseToString(target);\n                    return string.slice(position, position + target.length) == target;\n                }\n                function template(string, options, guard) {\n                    var settings = lodash.templateSettings;\n                    if (guard && isIterateeCall(string, options, guard)) {\n                        options = undefined2;\n                    }\n                    string = toString(string);\n                    options = assignInWith({}, options, settings, customDefaultsAssignIn);\n                    var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);\n                    var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = \"__p += '\";\n                    var reDelimiters = RegExp2((options.escape || reNoMatch).source + \"|\" + interpolate.source + \"|\" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + \"|\" + (options.evaluate || reNoMatch).source + \"|$\", \"g\");\n                    var sourceURL = \"//# sourceURL=\" + (hasOwnProperty.call(options, \"sourceURL\") ? (options.sourceURL + \"\").replace(/\\s/g, \" \") : \"lodash.templateSources[\" + ++templateCounter + \"]\") + \"\\n\";\n                    string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {\n                        interpolateValue || (interpolateValue = esTemplateValue);\n                        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);\n                        if (escapeValue) {\n                            isEscaping = true;\n                            source += \"' +\\n__e(\" + escapeValue + \") +\\n'\";\n                        }\n                        if (evaluateValue) {\n                            isEvaluating = true;\n                            source += \"';\\n\" + evaluateValue + \";\\n__p += '\";\n                        }\n                        if (interpolateValue) {\n                            source += \"' +\\n((__t = (\" + interpolateValue + \")) == null ? '' : __t) +\\n'\";\n                        }\n                        index = offset + match.length;\n                        return match;\n                    });\n                    source += \"';\\n\";\n                    var variable = hasOwnProperty.call(options, \"variable\") && options.variable;\n                    if (!variable) {\n                        source = \"with (obj) {\\n\" + source + \"\\n}\\n\";\n                    } else if (reForbiddenIdentifierChars.test(variable)) {\n                        throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);\n                    }\n                    source = (isEvaluating ? source.replace(reEmptyStringLeading, \"\") : source).replace(reEmptyStringMiddle, \"$1\").replace(reEmptyStringTrailing, \"$1;\");\n                    source = \"function(\" + (variable || \"obj\") + \") {\\n\" + (variable ? \"\" : \"obj || (obj = {});\\n\") + \"var __t, __p = ''\" + (isEscaping ? \", __e = _.escape\" : \"\") + (isEvaluating ? \", __j = Array.prototype.join;\\nfunction print() { __p += __j.call(arguments, '') }\\n\" : \";\\n\") + source + \"return __p\\n}\";\n                    var result2 = attempt(function() {\n                        return Function2(importsKeys, sourceURL + \"return \" + source).apply(undefined2, importsValues);\n                    });\n                    result2.source = source;\n                    if (isError(result2)) {\n                        throw result2;\n                    }\n                    return result2;\n                }\n                function toLower(value) {\n                    return toString(value).toLowerCase();\n                }\n                function toUpper(value) {\n                    return toString(value).toUpperCase();\n                }\n                function trim(string, chars, guard) {\n                    string = toString(string);\n                    if (string && (guard || chars === undefined2)) {\n                        return baseTrim(string);\n                    }\n                    if (!string || !(chars = baseToString(chars))) {\n                        return string;\n                    }\n                    var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;\n                    return castSlice(strSymbols, start, end).join(\"\");\n                }\n                function trimEnd(string, chars, guard) {\n                    string = toString(string);\n                    if (string && (guard || chars === undefined2)) {\n                        return string.slice(0, trimmedEndIndex(string) + 1);\n                    }\n                    if (!string || !(chars = baseToString(chars))) {\n                        return string;\n                    }\n                    var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;\n                    return castSlice(strSymbols, 0, end).join(\"\");\n                }\n                function trimStart(string, chars, guard) {\n                    string = toString(string);\n                    if (string && (guard || chars === undefined2)) {\n                        return string.replace(reTrimStart, \"\");\n                    }\n                    if (!string || !(chars = baseToString(chars))) {\n                        return string;\n                    }\n                    var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));\n                    return castSlice(strSymbols, start).join(\"\");\n                }\n                function truncate(string, options) {\n                    var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;\n                    if (isObject(options)) {\n                        var separator = \"separator\" in options ? options.separator : separator;\n                        length = \"length\" in options ? toInteger(options.length) : length;\n                        omission = \"omission\" in options ? baseToString(options.omission) : omission;\n                    }\n                    string = toString(string);\n                    var strLength = string.length;\n                    if (hasUnicode(string)) {\n                        var strSymbols = stringToArray(string);\n                        strLength = strSymbols.length;\n                    }\n                    if (length >= strLength) {\n                        return string;\n                    }\n                    var end = length - stringSize(omission);\n                    if (end < 1) {\n                        return omission;\n                    }\n                    var result2 = strSymbols ? castSlice(strSymbols, 0, end).join(\"\") : string.slice(0, end);\n                    if (separator === undefined2) {\n                        return result2 + omission;\n                    }\n                    if (strSymbols) {\n                        end += result2.length - end;\n                    }\n                    if (isRegExp(separator)) {\n                        if (string.slice(end).search(separator)) {\n                            var match, substring = result2;\n                            if (!separator.global) {\n                                separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + \"g\");\n                            }\n                            separator.lastIndex = 0;\n                            while(match = separator.exec(substring)){\n                                var newEnd = match.index;\n                            }\n                            result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);\n                        }\n                    } else if (string.indexOf(baseToString(separator), end) != end) {\n                        var index = result2.lastIndexOf(separator);\n                        if (index > -1) {\n                            result2 = result2.slice(0, index);\n                        }\n                    }\n                    return result2 + omission;\n                }\n                function unescape(string) {\n                    string = toString(string);\n                    return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;\n                }\n                var upperCase = createCompounder(function(result2, word, index) {\n                    return result2 + (index ? \" \" : \"\") + word.toUpperCase();\n                });\n                var upperFirst = createCaseFirst(\"toUpperCase\");\n                function words(string, pattern, guard) {\n                    string = toString(string);\n                    pattern = guard ? undefined2 : pattern;\n                    if (pattern === undefined2) {\n                        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);\n                    }\n                    return string.match(pattern) || [];\n                }\n                var attempt = baseRest(function(func, args) {\n                    try {\n                        return apply(func, undefined2, args);\n                    } catch (e) {\n                        return isError(e) ? e : new Error2(e);\n                    }\n                });\n                var bindAll = flatRest(function(object, methodNames) {\n                    arrayEach(methodNames, function(key) {\n                        key = toKey(key);\n                        baseAssignValue(object, key, bind(object[key], object));\n                    });\n                    return object;\n                });\n                function cond(pairs) {\n                    var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();\n                    pairs = !length ? [] : arrayMap(pairs, function(pair) {\n                        if (typeof pair[1] != \"function\") {\n                            throw new TypeError2(FUNC_ERROR_TEXT);\n                        }\n                        return [\n                            toIteratee(pair[0]),\n                            pair[1]\n                        ];\n                    });\n                    return baseRest(function(args) {\n                        var index = -1;\n                        while(++index < length){\n                            var pair = pairs[index];\n                            if (apply(pair[0], this, args)) {\n                                return apply(pair[1], this, args);\n                            }\n                        }\n                    });\n                }\n                function conforms(source) {\n                    return baseConforms(baseClone(source, CLONE_DEEP_FLAG));\n                }\n                function constant(value) {\n                    return function() {\n                        return value;\n                    };\n                }\n                function defaultTo(value, defaultValue) {\n                    return value == null || value !== value ? defaultValue : value;\n                }\n                var flow = createFlow();\n                var flowRight = createFlow(true);\n                function identity(value) {\n                    return value;\n                }\n                function iteratee(func) {\n                    return baseIteratee(typeof func == \"function\" ? func : baseClone(func, CLONE_DEEP_FLAG));\n                }\n                function matches(source) {\n                    return baseMatches(baseClone(source, CLONE_DEEP_FLAG));\n                }\n                function matchesProperty(path, srcValue) {\n                    return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));\n                }\n                var method = baseRest(function(path, args) {\n                    return function(object) {\n                        return baseInvoke(object, path, args);\n                    };\n                });\n                var methodOf = baseRest(function(object, args) {\n                    return function(path) {\n                        return baseInvoke(object, path, args);\n                    };\n                });\n                function mixin(object, source, options) {\n                    var props = keys(source), methodNames = baseFunctions(source, props);\n                    if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {\n                        options = source;\n                        source = object;\n                        object = this;\n                        methodNames = baseFunctions(source, keys(source));\n                    }\n                    var chain2 = !(isObject(options) && \"chain\" in options) || !!options.chain, isFunc = isFunction(object);\n                    arrayEach(methodNames, function(methodName) {\n                        var func = source[methodName];\n                        object[methodName] = func;\n                        if (isFunc) {\n                            object.prototype[methodName] = function() {\n                                var chainAll = this.__chain__;\n                                if (chain2 || chainAll) {\n                                    var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);\n                                    actions.push({\n                                        \"func\": func,\n                                        \"args\": arguments,\n                                        \"thisArg\": object\n                                    });\n                                    result2.__chain__ = chainAll;\n                                    return result2;\n                                }\n                                return func.apply(object, arrayPush([\n                                    this.value()\n                                ], arguments));\n                            };\n                        }\n                    });\n                    return object;\n                }\n                function noConflict() {\n                    if (root._ === this) {\n                        root._ = oldDash;\n                    }\n                    return this;\n                }\n                function noop() {}\n                function nthArg(n) {\n                    n = toInteger(n);\n                    return baseRest(function(args) {\n                        return baseNth(args, n);\n                    });\n                }\n                var over = createOver(arrayMap);\n                var overEvery = createOver(arrayEvery);\n                var overSome = createOver(arraySome);\n                function property(path) {\n                    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n                }\n                function propertyOf(object) {\n                    return function(path) {\n                        return object == null ? undefined2 : baseGet(object, path);\n                    };\n                }\n                var range = createRange();\n                var rangeRight = createRange(true);\n                function stubArray() {\n                    return [];\n                }\n                function stubFalse() {\n                    return false;\n                }\n                function stubObject() {\n                    return {};\n                }\n                function stubString() {\n                    return \"\";\n                }\n                function stubTrue() {\n                    return true;\n                }\n                function times(n, iteratee2) {\n                    n = toInteger(n);\n                    if (n < 1 || n > MAX_SAFE_INTEGER) {\n                        return [];\n                    }\n                    var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);\n                    iteratee2 = getIteratee(iteratee2);\n                    n -= MAX_ARRAY_LENGTH;\n                    var result2 = baseTimes(length, iteratee2);\n                    while(++index < n){\n                        iteratee2(index);\n                    }\n                    return result2;\n                }\n                function toPath(value) {\n                    if (isArray(value)) {\n                        return arrayMap(value, toKey);\n                    }\n                    return isSymbol(value) ? [\n                        value\n                    ] : copyArray(stringToPath(toString(value)));\n                }\n                function uniqueId(prefix) {\n                    var id = ++idCounter;\n                    return toString(prefix) + id;\n                }\n                var add = createMathOperation(function(augend, addend) {\n                    return augend + addend;\n                }, 0);\n                var ceil = createRound(\"ceil\");\n                var divide = createMathOperation(function(dividend, divisor) {\n                    return dividend / divisor;\n                }, 1);\n                var floor = createRound(\"floor\");\n                function max(array) {\n                    return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;\n                }\n                function maxBy(array, iteratee2) {\n                    return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;\n                }\n                function mean(array) {\n                    return baseMean(array, identity);\n                }\n                function meanBy(array, iteratee2) {\n                    return baseMean(array, getIteratee(iteratee2, 2));\n                }\n                function min(array) {\n                    return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;\n                }\n                function minBy(array, iteratee2) {\n                    return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;\n                }\n                var multiply = createMathOperation(function(multiplier, multiplicand) {\n                    return multiplier * multiplicand;\n                }, 1);\n                var round = createRound(\"round\");\n                var subtract = createMathOperation(function(minuend, subtrahend) {\n                    return minuend - subtrahend;\n                }, 0);\n                function sum(array) {\n                    return array && array.length ? baseSum(array, identity) : 0;\n                }\n                function sumBy(array, iteratee2) {\n                    return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;\n                }\n                lodash.after = after;\n                lodash.ary = ary;\n                lodash.assign = assign;\n                lodash.assignIn = assignIn;\n                lodash.assignInWith = assignInWith;\n                lodash.assignWith = assignWith;\n                lodash.at = at;\n                lodash.before = before;\n                lodash.bind = bind;\n                lodash.bindAll = bindAll;\n                lodash.bindKey = bindKey;\n                lodash.castArray = castArray;\n                lodash.chain = chain;\n                lodash.chunk = chunk;\n                lodash.compact = compact;\n                lodash.concat = concat;\n                lodash.cond = cond;\n                lodash.conforms = conforms;\n                lodash.constant = constant;\n                lodash.countBy = countBy;\n                lodash.create = create;\n                lodash.curry = curry;\n                lodash.curryRight = curryRight;\n                lodash.debounce = debounce;\n                lodash.defaults = defaults;\n                lodash.defaultsDeep = defaultsDeep;\n                lodash.defer = defer;\n                lodash.delay = delay;\n                lodash.difference = difference;\n                lodash.differenceBy = differenceBy;\n                lodash.differenceWith = differenceWith;\n                lodash.drop = drop;\n                lodash.dropRight = dropRight;\n                lodash.dropRightWhile = dropRightWhile;\n                lodash.dropWhile = dropWhile;\n                lodash.fill = fill;\n                lodash.filter = filter;\n                lodash.flatMap = flatMap;\n                lodash.flatMapDeep = flatMapDeep;\n                lodash.flatMapDepth = flatMapDepth;\n                lodash.flatten = flatten;\n                lodash.flattenDeep = flattenDeep;\n                lodash.flattenDepth = flattenDepth;\n                lodash.flip = flip;\n                lodash.flow = flow;\n                lodash.flowRight = flowRight;\n                lodash.fromPairs = fromPairs;\n                lodash.functions = functions;\n                lodash.functionsIn = functionsIn;\n                lodash.groupBy = groupBy;\n                lodash.initial = initial;\n                lodash.intersection = intersection;\n                lodash.intersectionBy = intersectionBy;\n                lodash.intersectionWith = intersectionWith;\n                lodash.invert = invert;\n                lodash.invertBy = invertBy;\n                lodash.invokeMap = invokeMap;\n                lodash.iteratee = iteratee;\n                lodash.keyBy = keyBy;\n                lodash.keys = keys;\n                lodash.keysIn = keysIn;\n                lodash.map = map;\n                lodash.mapKeys = mapKeys;\n                lodash.mapValues = mapValues;\n                lodash.matches = matches;\n                lodash.matchesProperty = matchesProperty;\n                lodash.memoize = memoize2;\n                lodash.merge = merge;\n                lodash.mergeWith = mergeWith;\n                lodash.method = method;\n                lodash.methodOf = methodOf;\n                lodash.mixin = mixin;\n                lodash.negate = negate;\n                lodash.nthArg = nthArg;\n                lodash.omit = omit;\n                lodash.omitBy = omitBy;\n                lodash.once = once;\n                lodash.orderBy = orderBy;\n                lodash.over = over;\n                lodash.overArgs = overArgs;\n                lodash.overEvery = overEvery;\n                lodash.overSome = overSome;\n                lodash.partial = partial;\n                lodash.partialRight = partialRight;\n                lodash.partition = partition;\n                lodash.pick = pick;\n                lodash.pickBy = pickBy;\n                lodash.property = property;\n                lodash.propertyOf = propertyOf;\n                lodash.pull = pull;\n                lodash.pullAll = pullAll;\n                lodash.pullAllBy = pullAllBy;\n                lodash.pullAllWith = pullAllWith;\n                lodash.pullAt = pullAt;\n                lodash.range = range;\n                lodash.rangeRight = rangeRight;\n                lodash.rearg = rearg;\n                lodash.reject = reject;\n                lodash.remove = remove;\n                lodash.rest = rest;\n                lodash.reverse = reverse;\n                lodash.sampleSize = sampleSize;\n                lodash.set = set;\n                lodash.setWith = setWith;\n                lodash.shuffle = shuffle;\n                lodash.slice = slice;\n                lodash.sortBy = sortBy;\n                lodash.sortedUniq = sortedUniq;\n                lodash.sortedUniqBy = sortedUniqBy;\n                lodash.split = split;\n                lodash.spread = spread;\n                lodash.tail = tail;\n                lodash.take = take;\n                lodash.takeRight = takeRight;\n                lodash.takeRightWhile = takeRightWhile;\n                lodash.takeWhile = takeWhile;\n                lodash.tap = tap;\n                lodash.throttle = throttle;\n                lodash.thru = thru;\n                lodash.toArray = toArray;\n                lodash.toPairs = toPairs;\n                lodash.toPairsIn = toPairsIn;\n                lodash.toPath = toPath;\n                lodash.toPlainObject = toPlainObject;\n                lodash.transform = transform;\n                lodash.unary = unary;\n                lodash.union = union;\n                lodash.unionBy = unionBy;\n                lodash.unionWith = unionWith;\n                lodash.uniq = uniq;\n                lodash.uniqBy = uniqBy;\n                lodash.uniqWith = uniqWith;\n                lodash.unset = unset;\n                lodash.unzip = unzip;\n                lodash.unzipWith = unzipWith;\n                lodash.update = update;\n                lodash.updateWith = updateWith;\n                lodash.values = values;\n                lodash.valuesIn = valuesIn;\n                lodash.without = without;\n                lodash.words = words;\n                lodash.wrap = wrap;\n                lodash.xor = xor;\n                lodash.xorBy = xorBy;\n                lodash.xorWith = xorWith;\n                lodash.zip = zip;\n                lodash.zipObject = zipObject;\n                lodash.zipObjectDeep = zipObjectDeep;\n                lodash.zipWith = zipWith;\n                lodash.entries = toPairs;\n                lodash.entriesIn = toPairsIn;\n                lodash.extend = assignIn;\n                lodash.extendWith = assignInWith;\n                mixin(lodash, lodash);\n                lodash.add = add;\n                lodash.attempt = attempt;\n                lodash.camelCase = camelCase;\n                lodash.capitalize = capitalize;\n                lodash.ceil = ceil;\n                lodash.clamp = clamp;\n                lodash.clone = clone;\n                lodash.cloneDeep = cloneDeep;\n                lodash.cloneDeepWith = cloneDeepWith;\n                lodash.cloneWith = cloneWith;\n                lodash.conformsTo = conformsTo;\n                lodash.deburr = deburr;\n                lodash.defaultTo = defaultTo;\n                lodash.divide = divide;\n                lodash.endsWith = endsWith;\n                lodash.eq = eq;\n                lodash.escape = escape;\n                lodash.escapeRegExp = escapeRegExp;\n                lodash.every = every;\n                lodash.find = find;\n                lodash.findIndex = findIndex;\n                lodash.findKey = findKey;\n                lodash.findLast = findLast;\n                lodash.findLastIndex = findLastIndex;\n                lodash.findLastKey = findLastKey;\n                lodash.floor = floor;\n                lodash.forEach = forEach;\n                lodash.forEachRight = forEachRight;\n                lodash.forIn = forIn;\n                lodash.forInRight = forInRight;\n                lodash.forOwn = forOwn;\n                lodash.forOwnRight = forOwnRight;\n                lodash.get = get;\n                lodash.gt = gt;\n                lodash.gte = gte;\n                lodash.has = has;\n                lodash.hasIn = hasIn;\n                lodash.head = head;\n                lodash.identity = identity;\n                lodash.includes = includes;\n                lodash.indexOf = indexOf;\n                lodash.inRange = inRange;\n                lodash.invoke = invoke;\n                lodash.isArguments = isArguments;\n                lodash.isArray = isArray;\n                lodash.isArrayBuffer = isArrayBuffer;\n                lodash.isArrayLike = isArrayLike;\n                lodash.isArrayLikeObject = isArrayLikeObject;\n                lodash.isBoolean = isBoolean;\n                lodash.isBuffer = isBuffer;\n                lodash.isDate = isDate;\n                lodash.isElement = isElement;\n                lodash.isEmpty = isEmpty;\n                lodash.isEqual = isEqual;\n                lodash.isEqualWith = isEqualWith;\n                lodash.isError = isError;\n                lodash.isFinite = isFinite2;\n                lodash.isFunction = isFunction;\n                lodash.isInteger = isInteger;\n                lodash.isLength = isLength;\n                lodash.isMap = isMap;\n                lodash.isMatch = isMatch;\n                lodash.isMatchWith = isMatchWith;\n                lodash.isNaN = isNaN2;\n                lodash.isNative = isNative;\n                lodash.isNil = isNil;\n                lodash.isNull = isNull;\n                lodash.isNumber = isNumber;\n                lodash.isObject = isObject;\n                lodash.isObjectLike = isObjectLike;\n                lodash.isPlainObject = isPlainObject;\n                lodash.isRegExp = isRegExp;\n                lodash.isSafeInteger = isSafeInteger;\n                lodash.isSet = isSet;\n                lodash.isString = isString;\n                lodash.isSymbol = isSymbol;\n                lodash.isTypedArray = isTypedArray;\n                lodash.isUndefined = isUndefined;\n                lodash.isWeakMap = isWeakMap;\n                lodash.isWeakSet = isWeakSet;\n                lodash.join = join;\n                lodash.kebabCase = kebabCase;\n                lodash.last = last;\n                lodash.lastIndexOf = lastIndexOf;\n                lodash.lowerCase = lowerCase;\n                lodash.lowerFirst = lowerFirst;\n                lodash.lt = lt;\n                lodash.lte = lte;\n                lodash.max = max;\n                lodash.maxBy = maxBy;\n                lodash.mean = mean;\n                lodash.meanBy = meanBy;\n                lodash.min = min;\n                lodash.minBy = minBy;\n                lodash.stubArray = stubArray;\n                lodash.stubFalse = stubFalse;\n                lodash.stubObject = stubObject;\n                lodash.stubString = stubString;\n                lodash.stubTrue = stubTrue;\n                lodash.multiply = multiply;\n                lodash.nth = nth;\n                lodash.noConflict = noConflict;\n                lodash.noop = noop;\n                lodash.now = now;\n                lodash.pad = pad;\n                lodash.padEnd = padEnd;\n                lodash.padStart = padStart;\n                lodash.parseInt = parseInt2;\n                lodash.random = random;\n                lodash.reduce = reduce;\n                lodash.reduceRight = reduceRight;\n                lodash.repeat = repeat;\n                lodash.replace = replace;\n                lodash.result = result;\n                lodash.round = round;\n                lodash.runInContext = runInContext2;\n                lodash.sample = sample;\n                lodash.size = size;\n                lodash.snakeCase = snakeCase;\n                lodash.some = some;\n                lodash.sortedIndex = sortedIndex;\n                lodash.sortedIndexBy = sortedIndexBy;\n                lodash.sortedIndexOf = sortedIndexOf;\n                lodash.sortedLastIndex = sortedLastIndex;\n                lodash.sortedLastIndexBy = sortedLastIndexBy;\n                lodash.sortedLastIndexOf = sortedLastIndexOf;\n                lodash.startCase = startCase;\n                lodash.startsWith = startsWith;\n                lodash.subtract = subtract;\n                lodash.sum = sum;\n                lodash.sumBy = sumBy;\n                lodash.template = template;\n                lodash.times = times;\n                lodash.toFinite = toFinite;\n                lodash.toInteger = toInteger;\n                lodash.toLength = toLength;\n                lodash.toLower = toLower;\n                lodash.toNumber = toNumber;\n                lodash.toSafeInteger = toSafeInteger;\n                lodash.toString = toString;\n                lodash.toUpper = toUpper;\n                lodash.trim = trim;\n                lodash.trimEnd = trimEnd;\n                lodash.trimStart = trimStart;\n                lodash.truncate = truncate;\n                lodash.unescape = unescape;\n                lodash.uniqueId = uniqueId;\n                lodash.upperCase = upperCase;\n                lodash.upperFirst = upperFirst;\n                lodash.each = forEach;\n                lodash.eachRight = forEachRight;\n                lodash.first = head;\n                mixin(lodash, function() {\n                    var source = {};\n                    baseForOwn(lodash, function(func, methodName) {\n                        if (!hasOwnProperty.call(lodash.prototype, methodName)) {\n                            source[methodName] = func;\n                        }\n                    });\n                    return source;\n                }(), {\n                    \"chain\": false\n                });\n                lodash.VERSION = VERSION;\n                arrayEach([\n                    \"bind\",\n                    \"bindKey\",\n                    \"curry\",\n                    \"curryRight\",\n                    \"partial\",\n                    \"partialRight\"\n                ], function(methodName) {\n                    lodash[methodName].placeholder = lodash;\n                });\n                arrayEach([\n                    \"drop\",\n                    \"take\"\n                ], function(methodName, index) {\n                    LazyWrapper.prototype[methodName] = function(n) {\n                        n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);\n                        var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();\n                        if (result2.__filtered__) {\n                            result2.__takeCount__ = nativeMin(n, result2.__takeCount__);\n                        } else {\n                            result2.__views__.push({\n                                \"size\": nativeMin(n, MAX_ARRAY_LENGTH),\n                                \"type\": methodName + (result2.__dir__ < 0 ? \"Right\" : \"\")\n                            });\n                        }\n                        return result2;\n                    };\n                    LazyWrapper.prototype[methodName + \"Right\"] = function(n) {\n                        return this.reverse()[methodName](n).reverse();\n                    };\n                });\n                arrayEach([\n                    \"filter\",\n                    \"map\",\n                    \"takeWhile\"\n                ], function(methodName, index) {\n                    var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;\n                    LazyWrapper.prototype[methodName] = function(iteratee2) {\n                        var result2 = this.clone();\n                        result2.__iteratees__.push({\n                            \"iteratee\": getIteratee(iteratee2, 3),\n                            \"type\": type\n                        });\n                        result2.__filtered__ = result2.__filtered__ || isFilter;\n                        return result2;\n                    };\n                });\n                arrayEach([\n                    \"head\",\n                    \"last\"\n                ], function(methodName, index) {\n                    var takeName = \"take\" + (index ? \"Right\" : \"\");\n                    LazyWrapper.prototype[methodName] = function() {\n                        return this[takeName](1).value()[0];\n                    };\n                });\n                arrayEach([\n                    \"initial\",\n                    \"tail\"\n                ], function(methodName, index) {\n                    var dropName = \"drop\" + (index ? \"\" : \"Right\");\n                    LazyWrapper.prototype[methodName] = function() {\n                        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);\n                    };\n                });\n                LazyWrapper.prototype.compact = function() {\n                    return this.filter(identity);\n                };\n                LazyWrapper.prototype.find = function(predicate) {\n                    return this.filter(predicate).head();\n                };\n                LazyWrapper.prototype.findLast = function(predicate) {\n                    return this.reverse().find(predicate);\n                };\n                LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {\n                    if (typeof path == \"function\") {\n                        return new LazyWrapper(this);\n                    }\n                    return this.map(function(value) {\n                        return baseInvoke(value, path, args);\n                    });\n                });\n                LazyWrapper.prototype.reject = function(predicate) {\n                    return this.filter(negate(getIteratee(predicate)));\n                };\n                LazyWrapper.prototype.slice = function(start, end) {\n                    start = toInteger(start);\n                    var result2 = this;\n                    if (result2.__filtered__ && (start > 0 || end < 0)) {\n                        return new LazyWrapper(result2);\n                    }\n                    if (start < 0) {\n                        result2 = result2.takeRight(-start);\n                    } else if (start) {\n                        result2 = result2.drop(start);\n                    }\n                    if (end !== undefined2) {\n                        end = toInteger(end);\n                        result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);\n                    }\n                    return result2;\n                };\n                LazyWrapper.prototype.takeRightWhile = function(predicate) {\n                    return this.reverse().takeWhile(predicate).reverse();\n                };\n                LazyWrapper.prototype.toArray = function() {\n                    return this.take(MAX_ARRAY_LENGTH);\n                };\n                baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n                    var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? \"take\" + (methodName == \"last\" ? \"Right\" : \"\") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);\n                    if (!lodashFunc) {\n                        return;\n                    }\n                    lodash.prototype[methodName] = function() {\n                        var value = this.__wrapped__, args = isTaker ? [\n                            1\n                        ] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);\n                        var interceptor = function(value2) {\n                            var result3 = lodashFunc.apply(lodash, arrayPush([\n                                value2\n                            ], args));\n                            return isTaker && chainAll ? result3[0] : result3;\n                        };\n                        if (useLazy && checkIteratee && typeof iteratee2 == \"function\" && iteratee2.length != 1) {\n                            isLazy = useLazy = false;\n                        }\n                        var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;\n                        if (!retUnwrapped && useLazy) {\n                            value = onlyLazy ? value : new LazyWrapper(this);\n                            var result2 = func.apply(value, args);\n                            result2.__actions__.push({\n                                \"func\": thru,\n                                \"args\": [\n                                    interceptor\n                                ],\n                                \"thisArg\": undefined2\n                            });\n                            return new LodashWrapper(result2, chainAll);\n                        }\n                        if (isUnwrapped && onlyLazy) {\n                            return func.apply(this, args);\n                        }\n                        result2 = this.thru(interceptor);\n                        return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;\n                    };\n                });\n                arrayEach([\n                    \"pop\",\n                    \"push\",\n                    \"shift\",\n                    \"sort\",\n                    \"splice\",\n                    \"unshift\"\n                ], function(methodName) {\n                    var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? \"tap\" : \"thru\", retUnwrapped = /^(?:pop|shift)$/.test(methodName);\n                    lodash.prototype[methodName] = function() {\n                        var args = arguments;\n                        if (retUnwrapped && !this.__chain__) {\n                            var value = this.value();\n                            return func.apply(isArray(value) ? value : [], args);\n                        }\n                        return this[chainName](function(value2) {\n                            return func.apply(isArray(value2) ? value2 : [], args);\n                        });\n                    };\n                });\n                baseForOwn(LazyWrapper.prototype, function(func, methodName) {\n                    var lodashFunc = lodash[methodName];\n                    if (lodashFunc) {\n                        var key = lodashFunc.name + \"\";\n                        if (!hasOwnProperty.call(realNames, key)) {\n                            realNames[key] = [];\n                        }\n                        realNames[key].push({\n                            \"name\": methodName,\n                            \"func\": lodashFunc\n                        });\n                    }\n                });\n                realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [\n                    {\n                        \"name\": \"wrapper\",\n                        \"func\": undefined2\n                    }\n                ];\n                LazyWrapper.prototype.clone = lazyClone;\n                LazyWrapper.prototype.reverse = lazyReverse;\n                LazyWrapper.prototype.value = lazyValue;\n                lodash.prototype.at = wrapperAt;\n                lodash.prototype.chain = wrapperChain;\n                lodash.prototype.commit = wrapperCommit;\n                lodash.prototype.next = wrapperNext;\n                lodash.prototype.plant = wrapperPlant;\n                lodash.prototype.reverse = wrapperReverse;\n                lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;\n                lodash.prototype.first = lodash.prototype.head;\n                if (symIterator) {\n                    lodash.prototype[symIterator] = wrapperToIterator;\n                }\n                return lodash;\n            };\n            var _ = runInContext();\n            if (typeof define == \"function\" && typeof define.amd == \"object\" && define.amd) {\n                root._ = _;\n                define(function() {\n                    return _;\n                });\n            } else if (freeModule) {\n                (freeModule.exports = _)._ = _;\n                freeExports._ = _;\n            } else {\n                root._ = _;\n            }\n        }).call(exports);\n    }\n});\n// ../../node_modules/iota-array/iota.js\nvar require_iota = __commonJS({\n    \"../../node_modules/iota-array/iota.js\" (exports, module) {\n        \"use strict\";\n        function iota(n) {\n            var result = new Array(n);\n            for(var i = 0; i < n; ++i){\n                result[i] = i;\n            }\n            return result;\n        }\n        module.exports = iota;\n    }\n});\n// ../../node_modules/is-buffer/index.js\nvar require_is_buffer = __commonJS({\n    \"../../node_modules/is-buffer/index.js\" (exports, module) {\n        module.exports = function(obj) {\n            return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);\n        };\n        function isBuffer(obj) {\n            return !!obj.constructor && typeof obj.constructor.isBuffer === \"function\" && obj.constructor.isBuffer(obj);\n        }\n        function isSlowBuffer(obj) {\n            return typeof obj.readFloatLE === \"function\" && typeof obj.slice === \"function\" && isBuffer(obj.slice(0, 0));\n        }\n    }\n});\n// ../../node_modules/ndarray/ndarray.js\nvar require_ndarray = __commonJS({\n    \"../../node_modules/ndarray/ndarray.js\" (exports, module) {\n        var iota = require_iota();\n        var isBuffer = require_is_buffer();\n        var hasTypedArrays = typeof Float64Array !== \"undefined\";\n        function compare1st(a, b) {\n            return a[0] - b[0];\n        }\n        function order() {\n            var stride = this.stride;\n            var terms = new Array(stride.length);\n            var i;\n            for(i = 0; i < terms.length; ++i){\n                terms[i] = [\n                    Math.abs(stride[i]),\n                    i\n                ];\n            }\n            terms.sort(compare1st);\n            var result = new Array(terms.length);\n            for(i = 0; i < result.length; ++i){\n                result[i] = terms[i][1];\n            }\n            return result;\n        }\n        function compileConstructor(dtype, dimension) {\n            var className = [\n                \"View\",\n                dimension,\n                \"d\",\n                dtype\n            ].join(\"\");\n            if (dimension < 0) {\n                className = \"View_Nil\" + dtype;\n            }\n            var useGetters = dtype === \"generic\";\n            if (dimension === -1) {\n                var code = \"function \" + className + \"(a){this.data=a;};var proto=\" + className + \".prototype;proto.dtype='\" + dtype + \"';proto.index=function(){return -1};proto.size=0;proto.dimension=-1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function(){return new \" + className + \"(this.data);};proto.get=proto.set=function(){};proto.pick=function(){return null};return function construct_\" + className + \"(a){return new \" + className + \"(a);}\";\n                var procedure = new Function(code);\n                return procedure();\n            } else if (dimension === 0) {\n                var code = \"function \" + className + \"(a,d) {this.data = a;this.offset = d};var proto=\" + className + \".prototype;proto.dtype='\" + dtype + \"';proto.index=function(){return this.offset};proto.dimension=0;proto.size=1;proto.shape=proto.stride=proto.order=[];proto.lo=proto.hi=proto.transpose=proto.step=function \" + className + \"_copy() {return new \" + className + \"(this.data,this.offset)};proto.pick=function \" + className + \"_pick(){return TrivialArray(this.data);};proto.valueOf=proto.get=function \" + className + \"_get(){return \" + (useGetters ? \"this.data.get(this.offset)\" : \"this.data[this.offset]\") + \"};proto.set=function \" + className + \"_set(v){return \" + (useGetters ? \"this.data.set(this.offset,v)\" : \"this.data[this.offset]=v\") + \"};return function construct_\" + className + \"(a,b,c,d){return new \" + className + \"(a,d)}\";\n                var procedure = new Function(\"TrivialArray\", code);\n                return procedure(CACHED_CONSTRUCTORS[dtype][0]);\n            }\n            var code = [\n                \"'use strict'\"\n            ];\n            var indices = iota(dimension);\n            var args = indices.map(function(i2) {\n                return \"i\" + i2;\n            });\n            var index_str = \"this.offset+\" + indices.map(function(i2) {\n                return \"this.stride[\" + i2 + \"]*i\" + i2;\n            }).join(\"+\");\n            var shapeArg = indices.map(function(i2) {\n                return \"b\" + i2;\n            }).join(\",\");\n            var strideArg = indices.map(function(i2) {\n                return \"c\" + i2;\n            }).join(\",\");\n            code.push(\"function \" + className + \"(a,\" + shapeArg + \",\" + strideArg + \",d){this.data=a\", \"this.shape=[\" + shapeArg + \"]\", \"this.stride=[\" + strideArg + \"]\", \"this.offset=d|0}\", \"var proto=\" + className + \".prototype\", \"proto.dtype='\" + dtype + \"'\", \"proto.dimension=\" + dimension);\n            code.push(\"Object.defineProperty(proto,'size',{get:function \" + className + \"_size(){return \" + indices.map(function(i2) {\n                return \"this.shape[\" + i2 + \"]\";\n            }).join(\"*\"), \"}})\");\n            if (dimension === 1) {\n                code.push(\"proto.order=[0]\");\n            } else {\n                code.push(\"Object.defineProperty(proto,'order',{get:\");\n                if (dimension < 4) {\n                    code.push(\"function \" + className + \"_order(){\");\n                    if (dimension === 2) {\n                        code.push(\"return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})\");\n                    } else if (dimension === 3) {\n                        code.push(\"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);if(s0>s1){if(s1>s2){return [2,1,0];}else if(s0>s2){return [1,2,0];}else{return [1,0,2];}}else if(s0>s2){return [2,0,1];}else if(s2>s1){return [0,1,2];}else{return [0,2,1];}}})\");\n                    }\n                } else {\n                    code.push(\"ORDER})\");\n                }\n            }\n            code.push(\"proto.set=function \" + className + \"_set(\" + args.join(\",\") + \",v){\");\n            if (useGetters) {\n                code.push(\"return this.data.set(\" + index_str + \",v)}\");\n            } else {\n                code.push(\"return this.data[\" + index_str + \"]=v}\");\n            }\n            code.push(\"proto.get=function \" + className + \"_get(\" + args.join(\",\") + \"){\");\n            if (useGetters) {\n                code.push(\"return this.data.get(\" + index_str + \")}\");\n            } else {\n                code.push(\"return this.data[\" + index_str + \"]}\");\n            }\n            code.push(\"proto.index=function \" + className + \"_index(\", args.join(), \"){return \" + index_str + \"}\");\n            code.push(\"proto.hi=function \" + className + \"_hi(\" + args.join(\",\") + \"){return new \" + className + \"(this.data,\" + indices.map(function(i2) {\n                return [\n                    \"(typeof i\",\n                    i2,\n                    \"!=='number'||i\",\n                    i2,\n                    \"<0)?this.shape[\",\n                    i2,\n                    \"]:i\",\n                    i2,\n                    \"|0\"\n                ].join(\"\");\n            }).join(\",\") + \",\" + indices.map(function(i2) {\n                return \"this.stride[\" + i2 + \"]\";\n            }).join(\",\") + \",this.offset)}\");\n            var a_vars = indices.map(function(i2) {\n                return \"a\" + i2 + \"=this.shape[\" + i2 + \"]\";\n            });\n            var c_vars = indices.map(function(i2) {\n                return \"c\" + i2 + \"=this.stride[\" + i2 + \"]\";\n            });\n            code.push(\"proto.lo=function \" + className + \"_lo(\" + args.join(\",\") + \"){var b=this.offset,d=0,\" + a_vars.join(\",\") + \",\" + c_vars.join(\",\"));\n            for(var i = 0; i < dimension; ++i){\n                code.push(\"if(typeof i\" + i + \"==='number'&&i\" + i + \">=0){d=i\" + i + \"|0;b+=c\" + i + \"*d;a\" + i + \"-=d}\");\n            }\n            code.push(\"return new \" + className + \"(this.data,\" + indices.map(function(i2) {\n                return \"a\" + i2;\n            }).join(\",\") + \",\" + indices.map(function(i2) {\n                return \"c\" + i2;\n            }).join(\",\") + \",b)}\");\n            code.push(\"proto.step=function \" + className + \"_step(\" + args.join(\",\") + \"){var \" + indices.map(function(i2) {\n                return \"a\" + i2 + \"=this.shape[\" + i2 + \"]\";\n            }).join(\",\") + \",\" + indices.map(function(i2) {\n                return \"b\" + i2 + \"=this.stride[\" + i2 + \"]\";\n            }).join(\",\") + \",c=this.offset,d=0,ceil=Math.ceil\");\n            for(var i = 0; i < dimension; ++i){\n                code.push(\"if(typeof i\" + i + \"==='number'){d=i\" + i + \"|0;if(d<0){c+=b\" + i + \"*(a\" + i + \"-1);a\" + i + \"=ceil(-a\" + i + \"/d)}else{a\" + i + \"=ceil(a\" + i + \"/d)}b\" + i + \"*=d}\");\n            }\n            code.push(\"return new \" + className + \"(this.data,\" + indices.map(function(i2) {\n                return \"a\" + i2;\n            }).join(\",\") + \",\" + indices.map(function(i2) {\n                return \"b\" + i2;\n            }).join(\",\") + \",c)}\");\n            var tShape = new Array(dimension);\n            var tStride = new Array(dimension);\n            for(var i = 0; i < dimension; ++i){\n                tShape[i] = \"a[i\" + i + \"]\";\n                tStride[i] = \"b[i\" + i + \"]\";\n            }\n            code.push(\"proto.transpose=function \" + className + \"_transpose(\" + args + \"){\" + args.map(function(n, idx) {\n                return n + \"=(\" + n + \"===undefined?\" + idx + \":\" + n + \"|0)\";\n            }).join(\";\"), \"var a=this.shape,b=this.stride;return new \" + className + \"(this.data,\" + tShape.join(\",\") + \",\" + tStride.join(\",\") + \",this.offset)}\");\n            code.push(\"proto.pick=function \" + className + \"_pick(\" + args + \"){var a=[],b=[],c=this.offset\");\n            for(var i = 0; i < dimension; ++i){\n                code.push(\"if(typeof i\" + i + \"==='number'&&i\" + i + \">=0){c=(c+this.stride[\" + i + \"]*i\" + i + \")|0}else{a.push(this.shape[\" + i + \"]);b.push(this.stride[\" + i + \"])}\");\n            }\n            code.push(\"var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}\");\n            code.push(\"return function construct_\" + className + \"(data,shape,stride,offset){return new \" + className + \"(data,\" + indices.map(function(i2) {\n                return \"shape[\" + i2 + \"]\";\n            }).join(\",\") + \",\" + indices.map(function(i2) {\n                return \"stride[\" + i2 + \"]\";\n            }).join(\",\") + \",offset)}\");\n            var procedure = new Function(\"CTOR_LIST\", \"ORDER\", code.join(\"\\n\"));\n            return procedure(CACHED_CONSTRUCTORS[dtype], order);\n        }\n        function arrayDType(data) {\n            if (isBuffer(data)) {\n                return \"buffer\";\n            }\n            if (hasTypedArrays) {\n                switch(Object.prototype.toString.call(data)){\n                    case \"[object Float64Array]\":\n                        return \"float64\";\n                    case \"[object Float32Array]\":\n                        return \"float32\";\n                    case \"[object Int8Array]\":\n                        return \"int8\";\n                    case \"[object Int16Array]\":\n                        return \"int16\";\n                    case \"[object Int32Array]\":\n                        return \"int32\";\n                    case \"[object Uint8Array]\":\n                        return \"uint8\";\n                    case \"[object Uint16Array]\":\n                        return \"uint16\";\n                    case \"[object Uint32Array]\":\n                        return \"uint32\";\n                    case \"[object Uint8ClampedArray]\":\n                        return \"uint8_clamped\";\n                    case \"[object BigInt64Array]\":\n                        return \"bigint64\";\n                    case \"[object BigUint64Array]\":\n                        return \"biguint64\";\n                }\n            }\n            if (Array.isArray(data)) {\n                return \"array\";\n            }\n            return \"generic\";\n        }\n        var CACHED_CONSTRUCTORS = {\n            \"float32\": [],\n            \"float64\": [],\n            \"int8\": [],\n            \"int16\": [],\n            \"int32\": [],\n            \"uint8\": [],\n            \"uint16\": [],\n            \"uint32\": [],\n            \"array\": [],\n            \"uint8_clamped\": [],\n            \"bigint64\": [],\n            \"biguint64\": [],\n            \"buffer\": [],\n            \"generic\": []\n        };\n        function wrappedNDArrayCtor(data, shape, stride, offset) {\n            if (data === void 0) {\n                var ctor = CACHED_CONSTRUCTORS.array[0];\n                return ctor([]);\n            } else if (typeof data === \"number\") {\n                data = [\n                    data\n                ];\n            }\n            if (shape === void 0) {\n                shape = [\n                    data.length\n                ];\n            }\n            var d = shape.length;\n            if (stride === void 0) {\n                stride = new Array(d);\n                for(var i = d - 1, sz = 1; i >= 0; --i){\n                    stride[i] = sz;\n                    sz *= shape[i];\n                }\n            }\n            if (offset === void 0) {\n                offset = 0;\n                for(var i = 0; i < d; ++i){\n                    if (stride[i] < 0) {\n                        offset -= (shape[i] - 1) * stride[i];\n                    }\n                }\n            }\n            var dtype = arrayDType(data);\n            var ctor_list = CACHED_CONSTRUCTORS[dtype];\n            while(ctor_list.length <= d + 1){\n                ctor_list.push(compileConstructor(dtype, ctor_list.length - 1));\n            }\n            var ctor = ctor_list[d + 1];\n            return ctor(data, shape, stride, offset);\n        }\n        module.exports = wrappedNDArrayCtor;\n    }\n});\n// src/api/v1.ts\nvar import_lodash = __toESM(require_lodash());\n// src/utils.ts\nvar import_ndarray2 = __toESM(require_ndarray());\n// src/MimeType.ts\nvar MimeType = class _MimeType {\n    toString() {\n        const paramsStr = [];\n        for(const key in this.params){\n            const value = this.params[key];\n            paramsStr.push(\"\".concat(key, \"=\").concat(value));\n        }\n        return [\n            this.type,\n            ...paramsStr\n        ].join(\";\");\n    }\n    static create(type, params) {\n        return new _MimeType(type, params);\n    }\n    isIdentical(other) {\n        return this.type === other.type && this.params === other.params;\n    }\n    isEqual(other) {\n        return this.type === other.type;\n    }\n    static fromString(mimeType) {\n        const [type, ...paramsArr] = mimeType.split(\";\");\n        const params = {};\n        for (const param of paramsArr){\n            const [key, value] = param.split(\"=\");\n            params[key.trim()] = value.trim();\n        }\n        return new _MimeType(type, params);\n    }\n    constructor(type, params){\n        this.type = \"application/octet-stream\";\n        this.params = {};\n        this.type = type;\n        this.params = params;\n    }\n};\n// src/codecs.ts\nvar import_ndarray = __toESM(require_ndarray());\nasync function imageDecode(blob) {\n    const mime = MimeType.fromString(blob.type);\n    switch(mime.type){\n        case \"image/x-alpha8\":\n            {\n                const width = parseInt(mime.params[\"width\"]);\n                const height = parseInt(mime.params[\"height\"]);\n                return (0, import_ndarray.default)(new Uint8Array(await blob.arrayBuffer()), [\n                    height,\n                    width,\n                    1\n                ]);\n            }\n        case \"image/x-rgba8\":\n            {\n                const width = parseInt(mime.params[\"width\"]);\n                const height = parseInt(mime.params[\"height\"]);\n                return (0, import_ndarray.default)(new Uint8Array(await blob.arrayBuffer()), [\n                    height,\n                    width,\n                    4\n                ]);\n            }\n        case \"application/octet-stream\":\n        case \"image/png\":\n        case \"image/jpeg\":\n        case \"image/jpg\":\n        case \"image/webp\":\n            {\n                const imageBitmap = await createImageBitmap(blob);\n                const imageData = imageBitmapToImageData(imageBitmap);\n                return (0, import_ndarray.default)(new Uint8Array(imageData.data), [\n                    imageData.height,\n                    imageData.width,\n                    4\n                ]);\n            }\n        default:\n            throw new Error(\"Invalid format: \".concat(mime.type, \" with params: \").concat(mime.params));\n    }\n}\nasync function imageEncode(imageTensor) {\n    let quality = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0.8, format = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"image/png\";\n    const [height, width, channels] = imageTensor.shape;\n    switch(format){\n        case \"image/x-alpha8\":\n        case \"image/x-rgba8\":\n            {\n                const mime = MimeType.create(format, {\n                    width: width.toString(),\n                    height: height.toString()\n                });\n                return new Blob([\n                    imageTensor.data\n                ], {\n                    type: mime.toString()\n                });\n            }\n        case \"image/png\":\n        case \"image/jpeg\":\n        case \"image/webp\":\n            {\n                const imageData = new ImageData(new Uint8ClampedArray(imageTensor.data), width, height);\n                var canvas = createCanvas(imageData.width, imageData.height);\n                var ctx = canvas.getContext(\"2d\");\n                ctx.putImageData(imageData, 0, 0);\n                return canvas.convertToBlob({\n                    quality,\n                    type: format\n                });\n            }\n        default:\n            throw new Error(\"Invalid format: \".concat(format));\n    }\n}\n// src/url.ts\nfunction isAbsoluteURI(url) {\n    const regExp = new RegExp(\"^(?:[a-z+]+:)?//\", \"i\");\n    return regExp.test(url);\n}\nfunction ensureAbsoluteURI(url, baseUrl) {\n    if (isAbsoluteURI(url)) {\n        return url;\n    } else {\n        return new URL(url, baseUrl).href;\n    }\n}\n// src/utils.ts\nfunction imageBitmapToImageData(imageBitmap) {\n    var canvas = createCanvas(imageBitmap.width, imageBitmap.height);\n    var ctx = canvas.getContext(\"2d\");\n    ctx.drawImage(imageBitmap, 0, 0);\n    return ctx.getImageData(0, 0, canvas.width, canvas.height);\n}\nfunction createTypeArray(length) {\n    if (typeof Uint8Array !== \"undefined\") {\n        return new Uint8Array(length);\n    } else if (typeof Uint8ClampedArray !== \"undefined\") {\n        return new Uint8ClampedArray(length);\n    } else if (typeof Uint16Array !== \"undefined\") {\n        return new Uint16Array(length);\n    } else if (typeof Uint32Array !== \"undefined\") {\n        return new Uint32Array(length);\n    } else if (typeof Float32Array !== \"undefined\") {\n        return new Float32Array(length);\n    } else if (typeof Float64Array !== \"undefined\") {\n        return new Float64Array(length);\n    } else {\n        throw new Error(\"TypedArray not supported\");\n    }\n}\nfunction tensorResizeBilinear(imageTensor, newWidth, newHeight) {\n    let proportional = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;\n    const [srcHeight, srcWidth, srcChannels] = imageTensor.shape;\n    let scaleX = srcWidth / newWidth;\n    let scaleY = srcHeight / newHeight;\n    if (proportional) {\n        const downscaling = Math.max(scaleX, scaleY) > 1;\n        scaleX = scaleY = downscaling ? Math.max(scaleX, scaleY) : Math.min(scaleX, scaleY);\n    }\n    const resizedImageData = (0, import_ndarray2.default)(createTypeArray(srcChannels * newWidth * newHeight), [\n        newHeight,\n        newWidth,\n        srcChannels\n    ]);\n    for(let y = 0; y < newHeight; y++){\n        for(let x = 0; x < newWidth; x++){\n            const srcX = x * scaleX;\n            const srcY = y * scaleY;\n            const x1 = Math.max(Math.floor(srcX), 0);\n            const x2 = Math.min(Math.ceil(srcX), srcWidth - 1);\n            const y1 = Math.max(Math.floor(srcY), 0);\n            const y2 = Math.min(Math.ceil(srcY), srcHeight - 1);\n            const dx = srcX - x1;\n            const dy = srcY - y1;\n            for(let c = 0; c < srcChannels; c++){\n                const p1 = imageTensor.get(y1, x1, c);\n                const p2 = imageTensor.get(y1, x2, c);\n                const p3 = imageTensor.get(y2, x1, c);\n                const p4 = imageTensor.get(y2, x2, c);\n                const interpolatedValue = (1 - dx) * (1 - dy) * p1 + dx * (1 - dy) * p2 + (1 - dx) * dy * p3 + dx * dy * p4;\n                resizedImageData.set(y, x, c, interpolatedValue);\n            }\n        }\n    }\n    return resizedImageData;\n}\nfunction tensorHWCtoBCHW(imageTensor) {\n    let mean = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [\n        128,\n        128,\n        128\n    ], std = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [\n        256,\n        256,\n        256\n    ];\n    var imageBufferData = imageTensor.data;\n    const [srcHeight, srcWidth, srcChannels] = imageTensor.shape;\n    const stride = srcHeight * srcWidth;\n    const float32Data = new Float32Array(3 * stride);\n    for(let i = 0, j = 0; i < imageBufferData.length; i += 4, j += 1){\n        float32Data[j] = (imageBufferData[i] - mean[0]) / std[0];\n        float32Data[j + stride] = (imageBufferData[i + 1] - mean[1]) / std[1];\n        float32Data[j + stride + stride] = (imageBufferData[i + 2] - mean[2]) / std[2];\n    }\n    return (0, import_ndarray2.default)(float32Data, [\n        1,\n        3,\n        srcHeight,\n        srcWidth\n    ]);\n}\nasync function imageSourceToImageData(image, config) {\n    if (typeof image === \"string\") {\n        image = ensureAbsoluteURI(image, config.publicPath);\n        image = new URL(image);\n    }\n    if (image instanceof URL) {\n        const response = await fetch(image, {});\n        image = await response.blob();\n    }\n    if (image instanceof ArrayBuffer || ArrayBuffer.isView(image)) {\n        image = new Blob([\n            image\n        ]);\n    }\n    if (image instanceof Blob) {\n        image = await imageDecode(image);\n    }\n    return image;\n}\nfunction convertFloat32ToUint8(float32Array) {\n    const uint8Array = new Uint8Array(float32Array.data.length);\n    for(let i = 0; i < float32Array.data.length; i++){\n        uint8Array[i] = float32Array.data[i] * 255;\n    }\n    return (0, import_ndarray2.default)(uint8Array, float32Array.shape);\n}\nfunction createCanvas(width, height) {\n    let canvas = void 0;\n    if (typeof OffscreenCanvas !== \"undefined\") {\n        canvas = new OffscreenCanvas(width, height);\n    } else {\n        canvas = document.createElement(\"canvas\");\n    }\n    if (!canvas) {\n        throw new Error(\"Canvas nor OffscreenCanvas are available in the current context.\");\n    }\n    return canvas;\n}\n// src/onnx.ts\nvar import_ndarray3 = __toESM(require_ndarray());\n// src/capabilities.js\nvar webgpu = async ()=>{\n    if (navigator.gpu === void 0) return false;\n    const adapter = await navigator.gpu.requestAdapter();\n    return adapter !== null;\n};\nvar maxNumThreads = ()=>{\n    var _navigator_hardwareConcurrency;\n    return (_navigator_hardwareConcurrency = navigator.hardwareConcurrency) !== null && _navigator_hardwareConcurrency !== void 0 ? _navigator_hardwareConcurrency : 4;\n};\n// src/resource.ts\nasync function loadAsUrl(url, config) {\n    return URL.createObjectURL(await loadAsBlob(url, config));\n}\nasync function loadAsBlob(key, config) {\n    const resourceUrl = new URL(\"resources.json\", config.publicPath);\n    const resourceResponse = await fetch(resourceUrl);\n    if (!resourceResponse.ok) {\n        throw new Error(\"Resource metadata not found. Ensure that the config.publicPath is configured correctly.\");\n    }\n    const resourceMap = await resourceResponse.json();\n    const entry = resourceMap[key];\n    if (!entry) {\n        throw new Error(\"Resource \".concat(key, \" not found. Ensure that the config.publicPath is configured correctly.\"));\n    }\n    const chunks = entry.chunks;\n    let downloadedSize = 0;\n    const responses = chunks.map(async (chunk)=>{\n        const chunkSize = chunk.offsets[1] - chunk.offsets[0];\n        const url = config.publicPath ? new URL(chunk.name, config.publicPath).toString() : chunk.name;\n        const response = await fetch(url, config.fetchArgs);\n        const blob = await response.blob();\n        if (chunkSize !== blob.size) {\n            throw new Error(\"Failed to fetch \".concat(key, \" with size \").concat(chunkSize, \" but got \").concat(blob.size));\n        }\n        if (config.progress) {\n            downloadedSize += chunkSize;\n            config.progress(\"fetch:\".concat(key), downloadedSize, entry.size);\n        }\n        return blob;\n    });\n    const allChunkData = await Promise.all(responses);\n    const data = new Blob(allChunkData, {\n        type: entry.mime\n    });\n    if (data.size !== entry.size) {\n        throw new Error(\"Failed to fetch \".concat(key, \" with size \").concat(entry.size, \" but got \").concat(data.size));\n    }\n    return data;\n}\n// src/onnx.ts\nvar ort = null;\nvar getOrt = async (useWebGPU)=>{\n    if (ort !== null) {\n        return ort;\n    }\n    if (useWebGPU) {\n        ort = (await __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_onnxruntime-web_dist_ort_webgpu_bundle_min_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! onnxruntime-web/webgpu */ \"(app-pages-browser)/./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs?4709\"))).default;\n    } else {\n        ort = (await __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_onnxruntime-web_dist_ort_bundle_min_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! onnxruntime-web */ \"(app-pages-browser)/./node_modules/onnxruntime-web/dist/ort.bundle.min.mjs?3f47\"))).default;\n    }\n    return ort;\n};\nasync function createOnnxSession(model, config) {\n    const useWebGPU = config.device === \"gpu\" && await webgpu();\n    const proxyToWorker = useWebGPU && config.proxyToWorker;\n    const executionProviders = [\n        useWebGPU ? \"webgpu\" : \"wasm\"\n    ];\n    const ort2 = await getOrt(useWebGPU);\n    if (config.debug) {\n        console.debug(\"\tUsing WebGPU:\", useWebGPU);\n        console.debug(\"\tProxy to Worker:\", proxyToWorker);\n        ort2.env.debug = true;\n        ort2.env.logLevel = \"verbose\";\n    }\n    ort2.env.wasm.numThreads = maxNumThreads();\n    ort2.env.wasm.proxy = proxyToWorker;\n    const baseFilePath = useWebGPU ? \"/onnxruntime-web/ort-wasm-simd-threaded.jsep\" : \"/onnxruntime-web/ort-wasm-simd-threaded\";\n    const wasmPath = await loadAsUrl(\"\".concat(baseFilePath, \".wasm\"), config);\n    const mjsPath = await loadAsUrl(\"\".concat(baseFilePath, \".mjs\"), config);\n    ort2.env.wasm.wasmPaths = {\n        mjs: mjsPath,\n        wasm: wasmPath\n    };\n    if (config.debug) {\n        console.debug(\"ort.env.wasm:\", ort2.env.wasm);\n    }\n    const ortConfig = {\n        executionProviders,\n        graphOptimizationLevel: \"all\",\n        executionMode: \"parallel\",\n        enableCpuMemArena: true\n    };\n    const session = await ort2.InferenceSession.create(model, ortConfig).catch((e)=>{\n        throw new Error('Failed to create session: \"'.concat(e, '\". Please check if the publicPath is set correctly.'));\n    });\n    return session;\n}\nasync function runOnnxSession(session, inputs, outputs, config) {\n    const useWebGPU = config.device === \"gpu\" && await webgpu();\n    const ort2 = await getOrt(useWebGPU);\n    const feeds = {};\n    for (const [key, tensor] of inputs){\n        feeds[key] = new ort2.Tensor(\"float32\", new Float32Array(tensor.data), tensor.shape);\n    }\n    const outputData = await session.run(feeds, {});\n    const outputKVPairs = [];\n    for (const key of outputs){\n        const output = outputData[key];\n        const shape = output.dims;\n        const data = output.data;\n        const tensor = (0, import_ndarray3.default)(data, shape);\n        outputKVPairs.push(tensor);\n    }\n    return outputKVPairs;\n}\n// ../../node_modules/zod/lib/index.mjs\nvar util;\n(function(util2) {\n    util2.assertEqual = (val)=>val;\n    function assertIs(_arg) {}\n    util2.assertIs = assertIs;\n    function assertNever(_x) {\n        throw new Error();\n    }\n    util2.assertNever = assertNever;\n    util2.arrayToEnum = (items)=>{\n        const obj = {};\n        for (const item of items){\n            obj[item] = item;\n        }\n        return obj;\n    };\n    util2.getValidEnumValues = (obj)=>{\n        const validKeys = util2.objectKeys(obj).filter((k)=>typeof obj[obj[k]] !== \"number\");\n        const filtered = {};\n        for (const k of validKeys){\n            filtered[k] = obj[k];\n        }\n        return util2.objectValues(filtered);\n    };\n    util2.objectValues = (obj)=>{\n        return util2.objectKeys(obj).map(function(e) {\n            return obj[e];\n        });\n    };\n    util2.objectKeys = typeof Object.keys === \"function\" ? (obj)=>Object.keys(obj) : (object)=>{\n        const keys = [];\n        for(const key in object){\n            if (Object.prototype.hasOwnProperty.call(object, key)) {\n                keys.push(key);\n            }\n        }\n        return keys;\n    };\n    util2.find = (arr, checker)=>{\n        for (const item of arr){\n            if (checker(item)) return item;\n        }\n        return void 0;\n    };\n    util2.isInteger = typeof Number.isInteger === \"function\" ? (val)=>Number.isInteger(val) : (val)=>typeof val === \"number\" && isFinite(val) && Math.floor(val) === val;\n    function joinValues(array) {\n        let separator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \" | \";\n        return array.map((val)=>typeof val === \"string\" ? \"'\".concat(val, \"'\") : val).join(separator);\n    }\n    util2.joinValues = joinValues;\n    util2.jsonStringifyReplacer = (_, value)=>{\n        if (typeof value === \"bigint\") {\n            return value.toString();\n        }\n        return value;\n    };\n})(util || (util = {}));\nvar objectUtil;\n(function(objectUtil2) {\n    objectUtil2.mergeShapes = (first, second)=>{\n        return {\n            ...first,\n            ...second\n        };\n    };\n})(objectUtil || (objectUtil = {}));\nvar ZodParsedType = util.arrayToEnum([\n    \"string\",\n    \"nan\",\n    \"number\",\n    \"integer\",\n    \"float\",\n    \"boolean\",\n    \"date\",\n    \"bigint\",\n    \"symbol\",\n    \"function\",\n    \"undefined\",\n    \"null\",\n    \"array\",\n    \"object\",\n    \"unknown\",\n    \"promise\",\n    \"void\",\n    \"never\",\n    \"map\",\n    \"set\"\n]);\nvar getParsedType = (data)=>{\n    const t = typeof data;\n    switch(t){\n        case \"undefined\":\n            return ZodParsedType.undefined;\n        case \"string\":\n            return ZodParsedType.string;\n        case \"number\":\n            return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;\n        case \"boolean\":\n            return ZodParsedType.boolean;\n        case \"function\":\n            return ZodParsedType.function;\n        case \"bigint\":\n            return ZodParsedType.bigint;\n        case \"symbol\":\n            return ZodParsedType.symbol;\n        case \"object\":\n            if (Array.isArray(data)) {\n                return ZodParsedType.array;\n            }\n            if (data === null) {\n                return ZodParsedType.null;\n            }\n            if (data.then && typeof data.then === \"function\" && data.catch && typeof data.catch === \"function\") {\n                return ZodParsedType.promise;\n            }\n            if (typeof Map !== \"undefined\" && data instanceof Map) {\n                return ZodParsedType.map;\n            }\n            if (typeof Set !== \"undefined\" && data instanceof Set) {\n                return ZodParsedType.set;\n            }\n            if (typeof Date !== \"undefined\" && data instanceof Date) {\n                return ZodParsedType.date;\n            }\n            return ZodParsedType.object;\n        default:\n            return ZodParsedType.unknown;\n    }\n};\nvar ZodIssueCode = util.arrayToEnum([\n    \"invalid_type\",\n    \"invalid_literal\",\n    \"custom\",\n    \"invalid_union\",\n    \"invalid_union_discriminator\",\n    \"invalid_enum_value\",\n    \"unrecognized_keys\",\n    \"invalid_arguments\",\n    \"invalid_return_type\",\n    \"invalid_date\",\n    \"invalid_string\",\n    \"too_small\",\n    \"too_big\",\n    \"invalid_intersection_types\",\n    \"not_multiple_of\",\n    \"not_finite\"\n]);\nvar quotelessJson = (obj)=>{\n    const json = JSON.stringify(obj, null, 2);\n    return json.replace(/\"([^\"]+)\":/g, \"$1:\");\n};\nvar ZodError = class _ZodError extends Error {\n    get errors() {\n        return this.issues;\n    }\n    format(_mapper) {\n        const mapper = _mapper || function(issue) {\n            return issue.message;\n        };\n        const fieldErrors = {\n            _errors: []\n        };\n        const processError = (error)=>{\n            for (const issue of error.issues){\n                if (issue.code === \"invalid_union\") {\n                    issue.unionErrors.map(processError);\n                } else if (issue.code === \"invalid_return_type\") {\n                    processError(issue.returnTypeError);\n                } else if (issue.code === \"invalid_arguments\") {\n                    processError(issue.argumentsError);\n                } else if (issue.path.length === 0) {\n                    fieldErrors._errors.push(mapper(issue));\n                } else {\n                    let curr = fieldErrors;\n                    let i = 0;\n                    while(i < issue.path.length){\n                        const el = issue.path[i];\n                        const terminal = i === issue.path.length - 1;\n                        if (!terminal) {\n                            curr[el] = curr[el] || {\n                                _errors: []\n                            };\n                        } else {\n                            curr[el] = curr[el] || {\n                                _errors: []\n                            };\n                            curr[el]._errors.push(mapper(issue));\n                        }\n                        curr = curr[el];\n                        i++;\n                    }\n                }\n            }\n        };\n        processError(this);\n        return fieldErrors;\n    }\n    static assert(value) {\n        if (!(value instanceof _ZodError)) {\n            throw new Error(\"Not a ZodError: \".concat(value));\n        }\n    }\n    toString() {\n        return this.message;\n    }\n    get message() {\n        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);\n    }\n    get isEmpty() {\n        return this.issues.length === 0;\n    }\n    flatten() {\n        let mapper = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : (issue)=>issue.message;\n        const fieldErrors = {};\n        const formErrors = [];\n        for (const sub of this.issues){\n            if (sub.path.length > 0) {\n                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];\n                fieldErrors[sub.path[0]].push(mapper(sub));\n            } else {\n                formErrors.push(mapper(sub));\n            }\n        }\n        return {\n            formErrors,\n            fieldErrors\n        };\n    }\n    get formErrors() {\n        return this.flatten();\n    }\n    constructor(issues){\n        var _this;\n        super(), _this = this;\n        this.issues = [];\n        this.addIssue = (sub)=>{\n            this.issues = [\n                ...this.issues,\n                sub\n            ];\n        };\n        this.addIssues = function() {\n            let subs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];\n            _this.issues = [\n                ..._this.issues,\n                ...subs\n            ];\n        };\n        const actualProto = new.target.prototype;\n        if (Object.setPrototypeOf) {\n            Object.setPrototypeOf(this, actualProto);\n        } else {\n            this.__proto__ = actualProto;\n        }\n        this.name = \"ZodError\";\n        this.issues = issues;\n    }\n};\nZodError.create = (issues)=>{\n    const error = new ZodError(issues);\n    return error;\n};\nvar errorMap = (issue, _ctx)=>{\n    let message;\n    switch(issue.code){\n        case ZodIssueCode.invalid_type:\n            if (issue.received === ZodParsedType.undefined) {\n                message = \"Required\";\n            } else {\n                message = \"Expected \".concat(issue.expected, \", received \").concat(issue.received);\n            }\n            break;\n        case ZodIssueCode.invalid_literal:\n            message = \"Invalid literal value, expected \".concat(JSON.stringify(issue.expected, util.jsonStringifyReplacer));\n            break;\n        case ZodIssueCode.unrecognized_keys:\n            message = \"Unrecognized key(s) in object: \".concat(util.joinValues(issue.keys, \", \"));\n            break;\n        case ZodIssueCode.invalid_union:\n            message = \"Invalid input\";\n            break;\n        case ZodIssueCode.invalid_union_discriminator:\n            message = \"Invalid discriminator value. Expected \".concat(util.joinValues(issue.options));\n            break;\n        case ZodIssueCode.invalid_enum_value:\n            message = \"Invalid enum value. Expected \".concat(util.joinValues(issue.options), \", received '\").concat(issue.received, \"'\");\n            break;\n        case ZodIssueCode.invalid_arguments:\n            message = \"Invalid function arguments\";\n            break;\n        case ZodIssueCode.invalid_return_type:\n            message = \"Invalid function return type\";\n            break;\n        case ZodIssueCode.invalid_date:\n            message = \"Invalid date\";\n            break;\n        case ZodIssueCode.invalid_string:\n            if (typeof issue.validation === \"object\") {\n                if (\"includes\" in issue.validation) {\n                    message = 'Invalid input: must include \"'.concat(issue.validation.includes, '\"');\n                    if (typeof issue.validation.position === \"number\") {\n                        message = \"\".concat(message, \" at one or more positions greater than or equal to \").concat(issue.validation.position);\n                    }\n                } else if (\"startsWith\" in issue.validation) {\n                    message = 'Invalid input: must start with \"'.concat(issue.validation.startsWith, '\"');\n                } else if (\"endsWith\" in issue.validation) {\n                    message = 'Invalid input: must end with \"'.concat(issue.validation.endsWith, '\"');\n                } else {\n                    util.assertNever(issue.validation);\n                }\n            } else if (issue.validation !== \"regex\") {\n                message = \"Invalid \".concat(issue.validation);\n            } else {\n                message = \"Invalid\";\n            }\n            break;\n        case ZodIssueCode.too_small:\n            if (issue.type === \"array\") message = \"Array must contain \".concat(issue.exact ? \"exactly\" : issue.inclusive ? \"at least\" : \"more than\", \" \").concat(issue.minimum, \" element(s)\");\n            else if (issue.type === \"string\") message = \"String must contain \".concat(issue.exact ? \"exactly\" : issue.inclusive ? \"at least\" : \"over\", \" \").concat(issue.minimum, \" character(s)\");\n            else if (issue.type === \"number\") message = \"Number must be \".concat(issue.exact ? \"exactly equal to \" : issue.inclusive ? \"greater than or equal to \" : \"greater than \").concat(issue.minimum);\n            else if (issue.type === \"date\") message = \"Date must be \".concat(issue.exact ? \"exactly equal to \" : issue.inclusive ? \"greater than or equal to \" : \"greater than \").concat(new Date(Number(issue.minimum)));\n            else message = \"Invalid input\";\n            break;\n        case ZodIssueCode.too_big:\n            if (issue.type === \"array\") message = \"Array must contain \".concat(issue.exact ? \"exactly\" : issue.inclusive ? \"at most\" : \"less than\", \" \").concat(issue.maximum, \" element(s)\");\n            else if (issue.type === \"string\") message = \"String must contain \".concat(issue.exact ? \"exactly\" : issue.inclusive ? \"at most\" : \"under\", \" \").concat(issue.maximum, \" character(s)\");\n            else if (issue.type === \"number\") message = \"Number must be \".concat(issue.exact ? \"exactly\" : issue.inclusive ? \"less than or equal to\" : \"less than\", \" \").concat(issue.maximum);\n            else if (issue.type === \"bigint\") message = \"BigInt must be \".concat(issue.exact ? \"exactly\" : issue.inclusive ? \"less than or equal to\" : \"less than\", \" \").concat(issue.maximum);\n            else if (issue.type === \"date\") message = \"Date must be \".concat(issue.exact ? \"exactly\" : issue.inclusive ? \"smaller than or equal to\" : \"smaller than\", \" \").concat(new Date(Number(issue.maximum)));\n            else message = \"Invalid input\";\n            break;\n        case ZodIssueCode.custom:\n            message = \"Invalid input\";\n            break;\n        case ZodIssueCode.invalid_intersection_types:\n            message = \"Intersection results could not be merged\";\n            break;\n        case ZodIssueCode.not_multiple_of:\n            message = \"Number must be a multiple of \".concat(issue.multipleOf);\n            break;\n        case ZodIssueCode.not_finite:\n            message = \"Number must be finite\";\n            break;\n        default:\n            message = _ctx.defaultError;\n            util.assertNever(issue);\n    }\n    return {\n        message\n    };\n};\nvar overrideErrorMap = errorMap;\nfunction setErrorMap(map) {\n    overrideErrorMap = map;\n}\nfunction getErrorMap() {\n    return overrideErrorMap;\n}\nvar makeIssue = (params)=>{\n    const { data, path, errorMaps, issueData } = params;\n    const fullPath = [\n        ...path,\n        ...issueData.path || []\n    ];\n    const fullIssue = {\n        ...issueData,\n        path: fullPath\n    };\n    if (issueData.message !== void 0) {\n        return {\n            ...issueData,\n            path: fullPath,\n            message: issueData.message\n        };\n    }\n    let errorMessage = \"\";\n    const maps = errorMaps.filter((m)=>!!m).slice().reverse();\n    for (const map of maps){\n        errorMessage = map(fullIssue, {\n            data,\n            defaultError: errorMessage\n        }).message;\n    }\n    return {\n        ...issueData,\n        path: fullPath,\n        message: errorMessage\n    };\n};\nvar EMPTY_PATH = [];\nfunction addIssueToContext(ctx, issueData) {\n    const overrideMap = getErrorMap();\n    const issue = makeIssue({\n        issueData,\n        data: ctx.data,\n        path: ctx.path,\n        errorMaps: [\n            ctx.common.contextualErrorMap,\n            ctx.schemaErrorMap,\n            overrideMap,\n            overrideMap === errorMap ? void 0 : errorMap\n        ].filter((x)=>!!x)\n    });\n    ctx.common.issues.push(issue);\n}\nvar ParseStatus = class _ParseStatus {\n    dirty() {\n        if (this.value === \"valid\") this.value = \"dirty\";\n    }\n    abort() {\n        if (this.value !== \"aborted\") this.value = \"aborted\";\n    }\n    static mergeArray(status, results) {\n        const arrayValue = [];\n        for (const s of results){\n            if (s.status === \"aborted\") return INVALID;\n            if (s.status === \"dirty\") status.dirty();\n            arrayValue.push(s.value);\n        }\n        return {\n            status: status.value,\n            value: arrayValue\n        };\n    }\n    static async mergeObjectAsync(status, pairs) {\n        const syncPairs = [];\n        for (const pair of pairs){\n            const key = await pair.key;\n            const value = await pair.value;\n            syncPairs.push({\n                key,\n                value\n            });\n        }\n        return _ParseStatus.mergeObjectSync(status, syncPairs);\n    }\n    static mergeObjectSync(status, pairs) {\n        const finalObject = {};\n        for (const pair of pairs){\n            const { key, value } = pair;\n            if (key.status === \"aborted\") return INVALID;\n            if (value.status === \"aborted\") return INVALID;\n            if (key.status === \"dirty\") status.dirty();\n            if (value.status === \"dirty\") status.dirty();\n            if (key.value !== \"__proto__\" && (typeof value.value !== \"undefined\" || pair.alwaysSet)) {\n                finalObject[key.value] = value.value;\n            }\n        }\n        return {\n            status: status.value,\n            value: finalObject\n        };\n    }\n    constructor(){\n        this.value = \"valid\";\n    }\n};\nvar INVALID = Object.freeze({\n    status: \"aborted\"\n});\nvar DIRTY = (value)=>({\n        status: \"dirty\",\n        value\n    });\n_c = DIRTY;\nvar OK = (value)=>({\n        status: \"valid\",\n        value\n    });\n_c1 = OK;\nvar isAborted = (x)=>x.status === \"aborted\";\nvar isDirty = (x)=>x.status === \"dirty\";\nvar isValid = (x)=>x.status === \"valid\";\nvar isAsync = (x)=>typeof Promise !== \"undefined\" && x instanceof Promise;\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n}\nvar errorUtil;\n(function(errorUtil2) {\n    errorUtil2.errToObj = (message)=>typeof message === \"string\" ? {\n            message\n        } : message || {};\n    errorUtil2.toString = (message)=>typeof message === \"string\" ? message : message === null || message === void 0 ? void 0 : message.message;\n})(errorUtil || (errorUtil = {}));\nvar _ZodEnum_cache;\nvar _ZodNativeEnum_cache;\nvar ParseInputLazyPath = class {\n    get path() {\n        if (!this._cachedPath.length) {\n            if (this._key instanceof Array) {\n                this._cachedPath.push(...this._path, ...this._key);\n            } else {\n                this._cachedPath.push(...this._path, this._key);\n            }\n        }\n        return this._cachedPath;\n    }\n    constructor(parent, value, path, key){\n        this._cachedPath = [];\n        this.parent = parent;\n        this.data = value;\n        this._path = path;\n        this._key = key;\n    }\n};\nvar handleResult = (ctx, result)=>{\n    if (isValid(result)) {\n        return {\n            success: true,\n            data: result.value\n        };\n    } else {\n        if (!ctx.common.issues.length) {\n            throw new Error(\"Validation failed but no issues detected.\");\n        }\n        return {\n            success: false,\n            get error () {\n                if (this._error) return this._error;\n                const error = new ZodError(ctx.common.issues);\n                this._error = error;\n                return this._error;\n            }\n        };\n    }\n};\nfunction processCreateParams(params) {\n    if (!params) return {};\n    const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;\n    if (errorMap2 && (invalid_type_error || required_error)) {\n        throw new Error('Can\\'t use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.');\n    }\n    if (errorMap2) return {\n        errorMap: errorMap2,\n        description\n    };\n    const customMap = (iss, ctx)=>{\n        var _a, _b;\n        const { message } = params;\n        if (iss.code === \"invalid_enum_value\") {\n            return {\n                message: message !== null && message !== void 0 ? message : ctx.defaultError\n            };\n        }\n        if (typeof ctx.data === \"undefined\") {\n            return {\n                message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError\n            };\n        }\n        if (iss.code !== \"invalid_type\") return {\n            message: ctx.defaultError\n        };\n        return {\n            message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError\n        };\n    };\n    return {\n        errorMap: customMap,\n        description\n    };\n}\nvar ZodType = class {\n    get description() {\n        return this._def.description;\n    }\n    _getType(input) {\n        return getParsedType(input.data);\n    }\n    _getOrReturnCtx(input, ctx) {\n        return ctx || {\n            common: input.parent.common,\n            data: input.data,\n            parsedType: getParsedType(input.data),\n            schemaErrorMap: this._def.errorMap,\n            path: input.path,\n            parent: input.parent\n        };\n    }\n    _processInputParams(input) {\n        return {\n            status: new ParseStatus(),\n            ctx: {\n                common: input.parent.common,\n                data: input.data,\n                parsedType: getParsedType(input.data),\n                schemaErrorMap: this._def.errorMap,\n                path: input.path,\n                parent: input.parent\n            }\n        };\n    }\n    _parseSync(input) {\n        const result = this._parse(input);\n        if (isAsync(result)) {\n            throw new Error(\"Synchronous parse encountered promise.\");\n        }\n        return result;\n    }\n    _parseAsync(input) {\n        const result = this._parse(input);\n        return Promise.resolve(result);\n    }\n    parse(data, params) {\n        const result = this.safeParse(data, params);\n        if (result.success) return result.data;\n        throw result.error;\n    }\n    safeParse(data, params) {\n        var _a;\n        const ctx = {\n            common: {\n                issues: [],\n                async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,\n                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap\n            },\n            path: (params === null || params === void 0 ? void 0 : params.path) || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data)\n        };\n        const result = this._parseSync({\n            data,\n            path: ctx.path,\n            parent: ctx\n        });\n        return handleResult(ctx, result);\n    }\n    async parseAsync(data, params) {\n        const result = await this.safeParseAsync(data, params);\n        if (result.success) return result.data;\n        throw result.error;\n    }\n    async safeParseAsync(data, params) {\n        const ctx = {\n            common: {\n                issues: [],\n                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,\n                async: true\n            },\n            path: (params === null || params === void 0 ? void 0 : params.path) || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data)\n        };\n        const maybeAsyncResult = this._parse({\n            data,\n            path: ctx.path,\n            parent: ctx\n        });\n        const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));\n        return handleResult(ctx, result);\n    }\n    refine(check, message) {\n        const getIssueProperties = (val)=>{\n            if (typeof message === \"string\" || typeof message === \"undefined\") {\n                return {\n                    message\n                };\n            } else if (typeof message === \"function\") {\n                return message(val);\n            } else {\n                return message;\n            }\n        };\n        return this._refinement((val, ctx)=>{\n            const result = check(val);\n            const setError = ()=>ctx.addIssue({\n                    code: ZodIssueCode.custom,\n                    ...getIssueProperties(val)\n                });\n            if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n                return result.then((data)=>{\n                    if (!data) {\n                        setError();\n                        return false;\n                    } else {\n                        return true;\n                    }\n                });\n            }\n            if (!result) {\n                setError();\n                return false;\n            } else {\n                return true;\n            }\n        });\n    }\n    refinement(check, refinementData) {\n        return this._refinement((val, ctx)=>{\n            if (!check(val)) {\n                ctx.addIssue(typeof refinementData === \"function\" ? refinementData(val, ctx) : refinementData);\n                return false;\n            } else {\n                return true;\n            }\n        });\n    }\n    _refinement(refinement) {\n        return new ZodEffects({\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: {\n                type: \"refinement\",\n                refinement\n            }\n        });\n    }\n    superRefine(refinement) {\n        return this._refinement(refinement);\n    }\n    optional() {\n        return ZodOptional.create(this, this._def);\n    }\n    nullable() {\n        return ZodNullable.create(this, this._def);\n    }\n    nullish() {\n        return this.nullable().optional();\n    }\n    array() {\n        return ZodArray.create(this, this._def);\n    }\n    promise() {\n        return ZodPromise.create(this, this._def);\n    }\n    or(option) {\n        return ZodUnion.create([\n            this,\n            option\n        ], this._def);\n    }\n    and(incoming) {\n        return ZodIntersection.create(this, incoming, this._def);\n    }\n    transform(transform) {\n        return new ZodEffects({\n            ...processCreateParams(this._def),\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: {\n                type: \"transform\",\n                transform\n            }\n        });\n    }\n    default(def) {\n        const defaultValueFunc = typeof def === \"function\" ? def : ()=>def;\n        return new ZodDefault({\n            ...processCreateParams(this._def),\n            innerType: this,\n            defaultValue: defaultValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodDefault\n        });\n    }\n    brand() {\n        return new ZodBranded({\n            typeName: ZodFirstPartyTypeKind.ZodBranded,\n            type: this,\n            ...processCreateParams(this._def)\n        });\n    }\n    catch(def) {\n        const catchValueFunc = typeof def === \"function\" ? def : ()=>def;\n        return new ZodCatch({\n            ...processCreateParams(this._def),\n            innerType: this,\n            catchValue: catchValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodCatch\n        });\n    }\n    describe(description) {\n        const This = this.constructor;\n        return new This({\n            ...this._def,\n            description\n        });\n    }\n    pipe(target) {\n        return ZodPipeline.create(this, target);\n    }\n    readonly() {\n        return ZodReadonly.create(this);\n    }\n    isOptional() {\n        return this.safeParse(void 0).success;\n    }\n    isNullable() {\n        return this.safeParse(null).success;\n    }\n    constructor(def){\n        this.spa = this.safeParseAsync;\n        this._def = def;\n        this.parse = this.parse.bind(this);\n        this.safeParse = this.safeParse.bind(this);\n        this.parseAsync = this.parseAsync.bind(this);\n        this.safeParseAsync = this.safeParseAsync.bind(this);\n        this.spa = this.spa.bind(this);\n        this.refine = this.refine.bind(this);\n        this.refinement = this.refinement.bind(this);\n        this.superRefine = this.superRefine.bind(this);\n        this.optional = this.optional.bind(this);\n        this.nullable = this.nullable.bind(this);\n        this.nullish = this.nullish.bind(this);\n        this.array = this.array.bind(this);\n        this.promise = this.promise.bind(this);\n        this.or = this.or.bind(this);\n        this.and = this.and.bind(this);\n        this.transform = this.transform.bind(this);\n        this.brand = this.brand.bind(this);\n        this.default = this.default.bind(this);\n        this.catch = this.catch.bind(this);\n        this.describe = this.describe.bind(this);\n        this.pipe = this.pipe.bind(this);\n        this.readonly = this.readonly.bind(this);\n        this.isNullable = this.isNullable.bind(this);\n        this.isOptional = this.isOptional.bind(this);\n    }\n};\nvar cuidRegex = /^c[^\\s-]{8,}$/i;\nvar cuid2Regex = /^[0-9a-z]+$/;\nvar ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;\nvar uuidRegex = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/i;\nvar nanoidRegex = /^[a-z0-9_-]{21}$/i;\nvar durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\\d+Y)|(?:[-+]?\\d+[.,]\\d+Y$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:(?:[-+]?\\d+W)|(?:[-+]?\\d+[.,]\\d+W$))?(?:(?:[-+]?\\d+D)|(?:[-+]?\\d+[.,]\\d+D$))?(?:T(?=[\\d+-])(?:(?:[-+]?\\d+H)|(?:[-+]?\\d+[.,]\\d+H$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:[-+]?\\d+(?:[.,]\\d+)?S)?)??$/;\nvar emailRegex = /^(?!\\.)(?!.*\\.\\.)([A-Z0-9_'+\\-\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i;\nvar _emojiRegex = \"^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$\";\nvar emojiRegex;\nvar ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;\nvar ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;\nvar base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;\nvar dateRegexSource = \"((\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\\\d|30)|(02)-(0[1-9]|1\\\\d|2[0-8])))\";\nvar dateRegex = new RegExp(\"^\".concat(dateRegexSource, \"$\"));\nfunction timeRegexSource(args) {\n    let regex = \"([01]\\\\d|2[0-3]):[0-5]\\\\d:[0-5]\\\\d\";\n    if (args.precision) {\n        regex = \"\".concat(regex, \"\\\\.\\\\d{\").concat(args.precision, \"}\");\n    } else if (args.precision == null) {\n        regex = \"\".concat(regex, \"(\\\\.\\\\d+)?\");\n    }\n    return regex;\n}\nfunction timeRegex(args) {\n    return new RegExp(\"^\".concat(timeRegexSource(args), \"$\"));\n}\nfunction datetimeRegex(args) {\n    let regex = \"\".concat(dateRegexSource, \"T\").concat(timeRegexSource(args));\n    const opts = [];\n    opts.push(args.local ? \"Z?\" : \"Z\");\n    if (args.offset) opts.push(\"([+-]\\\\d{2}:?\\\\d{2})\");\n    regex = \"\".concat(regex, \"(\").concat(opts.join(\"|\"), \")\");\n    return new RegExp(\"^\".concat(regex, \"$\"));\n}\nfunction isValidIP(ip, version) {\n    if ((version === \"v4\" || !version) && ipv4Regex.test(ip)) {\n        return true;\n    }\n    if ((version === \"v6\" || !version) && ipv6Regex.test(ip)) {\n        return true;\n    }\n    return false;\n}\nvar ZodString = class _ZodString extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = String(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.string) {\n            const ctx2 = this._getOrReturnCtx(input);\n            addIssueToContext(ctx2, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.string,\n                received: ctx2.parsedType\n            });\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = void 0;\n        for (const check of this._def.checks){\n            if (check.kind === \"min\") {\n                if (input.data.length < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"max\") {\n                if (input.data.length > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"length\") {\n                const tooBig = input.data.length > check.value;\n                const tooSmall = input.data.length < check.value;\n                if (tooBig || tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    if (tooBig) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_big,\n                            maximum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message\n                        });\n                    } else if (tooSmall) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_small,\n                            minimum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message\n                        });\n                    }\n                    status.dirty();\n                }\n            } else if (check.kind === \"email\") {\n                if (!emailRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"email\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"emoji\") {\n                if (!emojiRegex) {\n                    emojiRegex = new RegExp(_emojiRegex, \"u\");\n                }\n                if (!emojiRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"emoji\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"uuid\") {\n                if (!uuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"uuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"nanoid\") {\n                if (!nanoidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"nanoid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"cuid\") {\n                if (!cuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"cuid2\") {\n                if (!cuid2Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid2\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"ulid\") {\n                if (!ulidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ulid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"url\") {\n                try {\n                    new URL(input.data);\n                } catch (_a) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"url\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"regex\") {\n                check.regex.lastIndex = 0;\n                const testResult = check.regex.test(input.data);\n                if (!testResult) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"regex\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"trim\") {\n                input.data = input.data.trim();\n            } else if (check.kind === \"includes\") {\n                if (!input.data.includes(check.value, check.position)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: {\n                            includes: check.value,\n                            position: check.position\n                        },\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"toLowerCase\") {\n                input.data = input.data.toLowerCase();\n            } else if (check.kind === \"toUpperCase\") {\n                input.data = input.data.toUpperCase();\n            } else if (check.kind === \"startsWith\") {\n                if (!input.data.startsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: {\n                            startsWith: check.value\n                        },\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"endsWith\") {\n                if (!input.data.endsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: {\n                            endsWith: check.value\n                        },\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"datetime\") {\n                const regex = datetimeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"datetime\",\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"date\") {\n                const regex = dateRegex;\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"date\",\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"time\") {\n                const regex = timeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"time\",\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"duration\") {\n                if (!durationRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"duration\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"ip\") {\n                if (!isValidIP(input.data, check.version)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"ip\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"base64\") {\n                if (!base64Regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"base64\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else {\n                util.assertNever(check);\n            }\n        }\n        return {\n            status: status.value,\n            value: input.data\n        };\n    }\n    _regex(regex, validation, message) {\n        return this.refinement((data)=>regex.test(data), {\n            validation,\n            code: ZodIssueCode.invalid_string,\n            ...errorUtil.errToObj(message)\n        });\n    }\n    _addCheck(check) {\n        return new _ZodString({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                check\n            ]\n        });\n    }\n    email(message) {\n        return this._addCheck({\n            kind: \"email\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    url(message) {\n        return this._addCheck({\n            kind: \"url\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    emoji(message) {\n        return this._addCheck({\n            kind: \"emoji\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    uuid(message) {\n        return this._addCheck({\n            kind: \"uuid\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    nanoid(message) {\n        return this._addCheck({\n            kind: \"nanoid\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    cuid(message) {\n        return this._addCheck({\n            kind: \"cuid\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    cuid2(message) {\n        return this._addCheck({\n            kind: \"cuid2\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    ulid(message) {\n        return this._addCheck({\n            kind: \"ulid\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    base64(message) {\n        return this._addCheck({\n            kind: \"base64\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    ip(options) {\n        return this._addCheck({\n            kind: \"ip\",\n            ...errorUtil.errToObj(options)\n        });\n    }\n    datetime(options) {\n        var _a, _b;\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"datetime\",\n                precision: null,\n                offset: false,\n                local: false,\n                message: options\n            });\n        }\n        return this._addCheck({\n            kind: \"datetime\",\n            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === \"undefined\" ? null : options === null || options === void 0 ? void 0 : options.precision,\n            offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,\n            local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,\n            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)\n        });\n    }\n    date(message) {\n        return this._addCheck({\n            kind: \"date\",\n            message\n        });\n    }\n    time(options) {\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"time\",\n                precision: null,\n                message: options\n            });\n        }\n        return this._addCheck({\n            kind: \"time\",\n            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === \"undefined\" ? null : options === null || options === void 0 ? void 0 : options.precision,\n            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)\n        });\n    }\n    duration(message) {\n        return this._addCheck({\n            kind: \"duration\",\n            ...errorUtil.errToObj(message)\n        });\n    }\n    regex(regex, message) {\n        return this._addCheck({\n            kind: \"regex\",\n            regex,\n            ...errorUtil.errToObj(message)\n        });\n    }\n    includes(value, options) {\n        return this._addCheck({\n            kind: \"includes\",\n            value,\n            position: options === null || options === void 0 ? void 0 : options.position,\n            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)\n        });\n    }\n    startsWith(value, message) {\n        return this._addCheck({\n            kind: \"startsWith\",\n            value,\n            ...errorUtil.errToObj(message)\n        });\n    }\n    endsWith(value, message) {\n        return this._addCheck({\n            kind: \"endsWith\",\n            value,\n            ...errorUtil.errToObj(message)\n        });\n    }\n    min(minLength, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minLength,\n            ...errorUtil.errToObj(message)\n        });\n    }\n    max(maxLength, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxLength,\n            ...errorUtil.errToObj(message)\n        });\n    }\n    length(len, message) {\n        return this._addCheck({\n            kind: \"length\",\n            value: len,\n            ...errorUtil.errToObj(message)\n        });\n    }\n    /**\n   * @deprecated Use z.string().min(1) instead.\n   * @see {@link ZodString.min}\n   */ nonempty(message) {\n        return this.min(1, errorUtil.errToObj(message));\n    }\n    trim() {\n        return new _ZodString({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind: \"trim\"\n                }\n            ]\n        });\n    }\n    toLowerCase() {\n        return new _ZodString({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind: \"toLowerCase\"\n                }\n            ]\n        });\n    }\n    toUpperCase() {\n        return new _ZodString({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind: \"toUpperCase\"\n                }\n            ]\n        });\n    }\n    get isDatetime() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"datetime\");\n    }\n    get isDate() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"date\");\n    }\n    get isTime() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"time\");\n    }\n    get isDuration() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"duration\");\n    }\n    get isEmail() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"email\");\n    }\n    get isURL() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"url\");\n    }\n    get isEmoji() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"emoji\");\n    }\n    get isUUID() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"uuid\");\n    }\n    get isNANOID() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"nanoid\");\n    }\n    get isCUID() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"cuid\");\n    }\n    get isCUID2() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"cuid2\");\n    }\n    get isULID() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"ulid\");\n    }\n    get isIP() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"ip\");\n    }\n    get isBase64() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"base64\");\n    }\n    get minLength() {\n        let min = null;\n        for (const ch of this._def.checks){\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min) min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxLength() {\n        let max = null;\n        for (const ch of this._def.checks){\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max) max = ch.value;\n            }\n        }\n        return max;\n    }\n};\nZodString.create = (params)=>{\n    var _a;\n    return new ZodString({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodString,\n        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,\n        ...processCreateParams(params)\n    });\n};\nfunction floatSafeRemainder(val, step) {\n    const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n    const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n    const valInt = parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n    const stepInt = parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n    return valInt % stepInt / Math.pow(10, decCount);\n}\nvar ZodNumber = class _ZodNumber extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Number(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.number) {\n            const ctx2 = this._getOrReturnCtx(input);\n            addIssueToContext(ctx2, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.number,\n                received: ctx2.parsedType\n            });\n            return INVALID;\n        }\n        let ctx = void 0;\n        const status = new ParseStatus();\n        for (const check of this._def.checks){\n            if (check.kind === \"int\") {\n                if (!util.isInteger(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_type,\n                        expected: \"integer\",\n                        received: \"float\",\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"min\") {\n                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"max\") {\n                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"multipleOf\") {\n                if (floatSafeRemainder(input.data, check.value) !== 0) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"finite\") {\n                if (!Number.isFinite(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_finite,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else {\n                util.assertNever(check);\n            }\n        }\n        return {\n            status: status.value,\n            value: input.data\n        };\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new _ZodNumber({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message)\n                }\n            ]\n        });\n    }\n    _addCheck(check) {\n        return new _ZodNumber({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                check\n            ]\n        });\n    }\n    int(message) {\n        return this._addCheck({\n            kind: \"int\",\n            message: errorUtil.toString(message)\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message)\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message)\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message)\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message)\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value,\n            message: errorUtil.toString(message)\n        });\n    }\n    finite(message) {\n        return this._addCheck({\n            kind: \"finite\",\n            message: errorUtil.toString(message)\n        });\n    }\n    safe(message) {\n        return this._addCheck({\n            kind: \"min\",\n            inclusive: true,\n            value: Number.MIN_SAFE_INTEGER,\n            message: errorUtil.toString(message)\n        })._addCheck({\n            kind: \"max\",\n            inclusive: true,\n            value: Number.MAX_SAFE_INTEGER,\n            message: errorUtil.toString(message)\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks){\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min) min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks){\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max) max = ch.value;\n            }\n        }\n        return max;\n    }\n    get isInt() {\n        return !!this._def.checks.find((ch)=>ch.kind === \"int\" || ch.kind === \"multipleOf\" && util.isInteger(ch.value));\n    }\n    get isFinite() {\n        let max = null, min = null;\n        for (const ch of this._def.checks){\n            if (ch.kind === \"finite\" || ch.kind === \"int\" || ch.kind === \"multipleOf\") {\n                return true;\n            } else if (ch.kind === \"min\") {\n                if (min === null || ch.value > min) min = ch.value;\n            } else if (ch.kind === \"max\") {\n                if (max === null || ch.value < max) max = ch.value;\n            }\n        }\n        return Number.isFinite(min) && Number.isFinite(max);\n    }\n    constructor(){\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n        this.step = this.multipleOf;\n    }\n};\nZodNumber.create = (params)=>{\n    return new ZodNumber({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodNumber,\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n        ...processCreateParams(params)\n    });\n};\nvar ZodBigInt = class _ZodBigInt extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = BigInt(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.bigint) {\n            const ctx2 = this._getOrReturnCtx(input);\n            addIssueToContext(ctx2, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.bigint,\n                received: ctx2.parsedType\n            });\n            return INVALID;\n        }\n        let ctx = void 0;\n        const status = new ParseStatus();\n        for (const check of this._def.checks){\n            if (check.kind === \"min\") {\n                const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        type: \"bigint\",\n                        minimum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"max\") {\n                const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        type: \"bigint\",\n                        maximum: check.value,\n                        inclusive: check.inclusive,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"multipleOf\") {\n                if (input.data % check.value !== BigInt(0)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message\n                    });\n                    status.dirty();\n                }\n            } else {\n                util.assertNever(check);\n            }\n        }\n        return {\n            status: status.value,\n            value: input.data\n        };\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new _ZodBigInt({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message)\n                }\n            ]\n        });\n    }\n    _addCheck(check) {\n        return new _ZodBigInt({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                check\n            ]\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message)\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: false,\n            message: errorUtil.toString(message)\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message)\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: BigInt(0),\n            inclusive: true,\n            message: errorUtil.toString(message)\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value,\n            message: errorUtil.toString(message)\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks){\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min) min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks){\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max) max = ch.value;\n            }\n        }\n        return max;\n    }\n    constructor(){\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n    }\n};\nZodBigInt.create = (params)=>{\n    var _a;\n    return new ZodBigInt({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodBigInt,\n        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,\n        ...processCreateParams(params)\n    });\n};\nvar ZodBoolean = class extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Boolean(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.boolean) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.boolean,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n};\nZodBoolean.create = (params)=>{\n    return new ZodBoolean({\n        typeName: ZodFirstPartyTypeKind.ZodBoolean,\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n        ...processCreateParams(params)\n    });\n};\nvar ZodDate = class _ZodDate extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = new Date(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.date) {\n            const ctx2 = this._getOrReturnCtx(input);\n            addIssueToContext(ctx2, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.date,\n                received: ctx2.parsedType\n            });\n            return INVALID;\n        }\n        if (isNaN(input.data.getTime())) {\n            const ctx2 = this._getOrReturnCtx(input);\n            addIssueToContext(ctx2, {\n                code: ZodIssueCode.invalid_date\n            });\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = void 0;\n        for (const check of this._def.checks){\n            if (check.kind === \"min\") {\n                if (input.data.getTime() < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        minimum: check.value,\n                        type: \"date\"\n                    });\n                    status.dirty();\n                }\n            } else if (check.kind === \"max\") {\n                if (input.data.getTime() > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        maximum: check.value,\n                        type: \"date\"\n                    });\n                    status.dirty();\n                }\n            } else {\n                util.assertNever(check);\n            }\n        }\n        return {\n            status: status.value,\n            value: new Date(input.data.getTime())\n        };\n    }\n    _addCheck(check) {\n        return new _ZodDate({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                check\n            ]\n        });\n    }\n    min(minDate, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minDate.getTime(),\n            message: errorUtil.toString(message)\n        });\n    }\n    max(maxDate, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxDate.getTime(),\n            message: errorUtil.toString(message)\n        });\n    }\n    get minDate() {\n        let min = null;\n        for (const ch of this._def.checks){\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min) min = ch.value;\n            }\n        }\n        return min != null ? new Date(min) : null;\n    }\n    get maxDate() {\n        let max = null;\n        for (const ch of this._def.checks){\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max) max = ch.value;\n            }\n        }\n        return max != null ? new Date(max) : null;\n    }\n};\nZodDate.create = (params)=>{\n    return new ZodDate({\n        checks: [],\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n        typeName: ZodFirstPartyTypeKind.ZodDate,\n        ...processCreateParams(params)\n    });\n};\nvar ZodSymbol = class extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.symbol) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.symbol,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n};\nZodSymbol.create = (params)=>{\n    return new ZodSymbol({\n        typeName: ZodFirstPartyTypeKind.ZodSymbol,\n        ...processCreateParams(params)\n    });\n};\nvar ZodUndefined = class extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.undefined,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n};\nZodUndefined.create = (params)=>{\n    return new ZodUndefined({\n        typeName: ZodFirstPartyTypeKind.ZodUndefined,\n        ...processCreateParams(params)\n    });\n};\nvar ZodNull = class extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.null) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.null,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n};\nZodNull.create = (params)=>{\n    return new ZodNull({\n        typeName: ZodFirstPartyTypeKind.ZodNull,\n        ...processCreateParams(params)\n    });\n};\nvar ZodAny = class extends ZodType {\n    _parse(input) {\n        return OK(input.data);\n    }\n    constructor(){\n        super(...arguments);\n        this._any = true;\n    }\n};\nZodAny.create = (params)=>{\n    return new ZodAny({\n        typeName: ZodFirstPartyTypeKind.ZodAny,\n        ...processCreateParams(params)\n    });\n};\nvar ZodUnknown = class extends ZodType {\n    _parse(input) {\n        return OK(input.data);\n    }\n    constructor(){\n        super(...arguments);\n        this._unknown = true;\n    }\n};\nZodUnknown.create = (params)=>{\n    return new ZodUnknown({\n        typeName: ZodFirstPartyTypeKind.ZodUnknown,\n        ...processCreateParams(params)\n    });\n};\nvar ZodNever = class extends ZodType {\n    _parse(input) {\n        const ctx = this._getOrReturnCtx(input);\n        addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.never,\n            received: ctx.parsedType\n        });\n        return INVALID;\n    }\n};\nZodNever.create = (params)=>{\n    return new ZodNever({\n        typeName: ZodFirstPartyTypeKind.ZodNever,\n        ...processCreateParams(params)\n    });\n};\nvar ZodVoid = class extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.void,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n};\nZodVoid.create = (params)=>{\n    return new ZodVoid({\n        typeName: ZodFirstPartyTypeKind.ZodVoid,\n        ...processCreateParams(params)\n    });\n};\nvar ZodArray = class _ZodArray extends ZodType {\n    _parse(input) {\n        const { ctx, status } = this._processInputParams(input);\n        const def = this._def;\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        if (def.exactLength !== null) {\n            const tooBig = ctx.data.length > def.exactLength.value;\n            const tooSmall = ctx.data.length < def.exactLength.value;\n            if (tooBig || tooSmall) {\n                addIssueToContext(ctx, {\n                    code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,\n                    minimum: tooSmall ? def.exactLength.value : void 0,\n                    maximum: tooBig ? def.exactLength.value : void 0,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: true,\n                    message: def.exactLength.message\n                });\n                status.dirty();\n            }\n        }\n        if (def.minLength !== null) {\n            if (ctx.data.length < def.minLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minLength.message\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxLength !== null) {\n            if (ctx.data.length > def.maxLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxLength.message\n                });\n                status.dirty();\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.all([\n                ...ctx.data\n            ].map((item, i)=>{\n                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n            })).then((result2)=>{\n                return ParseStatus.mergeArray(status, result2);\n            });\n        }\n        const result = [\n            ...ctx.data\n        ].map((item, i)=>{\n            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n        });\n        return ParseStatus.mergeArray(status, result);\n    }\n    get element() {\n        return this._def.type;\n    }\n    min(minLength, message) {\n        return new _ZodArray({\n            ...this._def,\n            minLength: {\n                value: minLength,\n                message: errorUtil.toString(message)\n            }\n        });\n    }\n    max(maxLength, message) {\n        return new _ZodArray({\n            ...this._def,\n            maxLength: {\n                value: maxLength,\n                message: errorUtil.toString(message)\n            }\n        });\n    }\n    length(len, message) {\n        return new _ZodArray({\n            ...this._def,\n            exactLength: {\n                value: len,\n                message: errorUtil.toString(message)\n            }\n        });\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n};\nZodArray.create = (schema, params)=>{\n    return new ZodArray({\n        type: schema,\n        minLength: null,\n        maxLength: null,\n        exactLength: null,\n        typeName: ZodFirstPartyTypeKind.ZodArray,\n        ...processCreateParams(params)\n    });\n};\nfunction deepPartialify(schema) {\n    if (schema instanceof ZodObject) {\n        const newShape = {};\n        for(const key in schema.shape){\n            const fieldSchema = schema.shape[key];\n            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));\n        }\n        return new ZodObject({\n            ...schema._def,\n            shape: ()=>newShape\n        });\n    } else if (schema instanceof ZodArray) {\n        return new ZodArray({\n            ...schema._def,\n            type: deepPartialify(schema.element)\n        });\n    } else if (schema instanceof ZodOptional) {\n        return ZodOptional.create(deepPartialify(schema.unwrap()));\n    } else if (schema instanceof ZodNullable) {\n        return ZodNullable.create(deepPartialify(schema.unwrap()));\n    } else if (schema instanceof ZodTuple) {\n        return ZodTuple.create(schema.items.map((item)=>deepPartialify(item)));\n    } else {\n        return schema;\n    }\n}\nvar ZodObject = class _ZodObject extends ZodType {\n    _getCached() {\n        if (this._cached !== null) return this._cached;\n        const shape = this._def.shape();\n        const keys = util.objectKeys(shape);\n        return this._cached = {\n            shape,\n            keys\n        };\n    }\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.object) {\n            const ctx2 = this._getOrReturnCtx(input);\n            addIssueToContext(ctx2, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx2.parsedType\n            });\n            return INVALID;\n        }\n        const { status, ctx } = this._processInputParams(input);\n        const { shape, keys: shapeKeys } = this._getCached();\n        const extraKeys = [];\n        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === \"strip\")) {\n            for(const key in ctx.data){\n                if (!shapeKeys.includes(key)) {\n                    extraKeys.push(key);\n                }\n            }\n        }\n        const pairs = [];\n        for (const key of shapeKeys){\n            const keyValidator = shape[key];\n            const value = ctx.data[key];\n            pairs.push({\n                key: {\n                    status: \"valid\",\n                    value: key\n                },\n                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n                alwaysSet: key in ctx.data\n            });\n        }\n        if (this._def.catchall instanceof ZodNever) {\n            const unknownKeys = this._def.unknownKeys;\n            if (unknownKeys === \"passthrough\") {\n                for (const key of extraKeys){\n                    pairs.push({\n                        key: {\n                            status: \"valid\",\n                            value: key\n                        },\n                        value: {\n                            status: \"valid\",\n                            value: ctx.data[key]\n                        }\n                    });\n                }\n            } else if (unknownKeys === \"strict\") {\n                if (extraKeys.length > 0) {\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.unrecognized_keys,\n                        keys: extraKeys\n                    });\n                    status.dirty();\n                }\n            } else if (unknownKeys === \"strip\") ;\n            else {\n                throw new Error(\"Internal ZodObject error: invalid unknownKeys value.\");\n            }\n        } else {\n            const catchall = this._def.catchall;\n            for (const key of extraKeys){\n                const value = ctx.data[key];\n                pairs.push({\n                    key: {\n                        status: \"valid\",\n                        value: key\n                    },\n                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n                    alwaysSet: key in ctx.data\n                });\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.resolve().then(async ()=>{\n                const syncPairs = [];\n                for (const pair of pairs){\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    syncPairs.push({\n                        key,\n                        value,\n                        alwaysSet: pair.alwaysSet\n                    });\n                }\n                return syncPairs;\n            }).then((syncPairs)=>{\n                return ParseStatus.mergeObjectSync(status, syncPairs);\n            });\n        } else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get shape() {\n        return this._def.shape();\n    }\n    strict(message) {\n        errorUtil.errToObj;\n        return new _ZodObject({\n            ...this._def,\n            unknownKeys: \"strict\",\n            ...message !== void 0 ? {\n                errorMap: (issue, ctx)=>{\n                    var _a, _b, _c, _d;\n                    const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;\n                    if (issue.code === \"unrecognized_keys\") return {\n                        message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError\n                    };\n                    return {\n                        message: defaultError\n                    };\n                }\n            } : {}\n        });\n    }\n    strip() {\n        return new _ZodObject({\n            ...this._def,\n            unknownKeys: \"strip\"\n        });\n    }\n    passthrough() {\n        return new _ZodObject({\n            ...this._def,\n            unknownKeys: \"passthrough\"\n        });\n    }\n    // const AugmentFactory =\n    //   <Def extends ZodObjectDef>(def: Def) =>\n    //   <Augmentation extends ZodRawShape>(\n    //     augmentation: Augmentation\n    //   ): ZodObject<\n    //     extendShape<ReturnType<Def[\"shape\"]>, Augmentation>,\n    //     Def[\"unknownKeys\"],\n    //     Def[\"catchall\"]\n    //   > => {\n    //     return new ZodObject({\n    //       ...def,\n    //       shape: () => ({\n    //         ...def.shape(),\n    //         ...augmentation,\n    //       }),\n    //     }) as any;\n    //   };\n    extend(augmentation) {\n        return new _ZodObject({\n            ...this._def,\n            shape: ()=>({\n                    ...this._def.shape(),\n                    ...augmentation\n                })\n        });\n    }\n    /**\n   * Prior to zod@1.0.12 there was a bug in the\n   * inferred type of merged objects. Please\n   * upgrade if you are experiencing issues.\n   */ merge(merging) {\n        const merged = new _ZodObject({\n            unknownKeys: merging._def.unknownKeys,\n            catchall: merging._def.catchall,\n            shape: ()=>({\n                    ...this._def.shape(),\n                    ...merging._def.shape()\n                }),\n            typeName: ZodFirstPartyTypeKind.ZodObject\n        });\n        return merged;\n    }\n    // merge<\n    //   Incoming extends AnyZodObject,\n    //   Augmentation extends Incoming[\"shape\"],\n    //   NewOutput extends {\n    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_output\"]\n    //       : k extends keyof Output\n    //       ? Output[k]\n    //       : never;\n    //   },\n    //   NewInput extends {\n    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n    //       ? Augmentation[k][\"_input\"]\n    //       : k extends keyof Input\n    //       ? Input[k]\n    //       : never;\n    //   }\n    // >(\n    //   merging: Incoming\n    // ): ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"],\n    //   NewOutput,\n    //   NewInput\n    // > {\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    setKey(key, schema) {\n        return this.augment({\n            [key]: schema\n        });\n    }\n    // merge<Incoming extends AnyZodObject>(\n    //   merging: Incoming\n    // ): //ZodObject<T & Incoming[\"_shape\"], UnknownKeys, Catchall> = (merging) => {\n    // ZodObject<\n    //   extendShape<T, ReturnType<Incoming[\"_def\"][\"shape\"]>>,\n    //   Incoming[\"_def\"][\"unknownKeys\"],\n    //   Incoming[\"_def\"][\"catchall\"]\n    // > {\n    //   // const mergedShape = objectUtil.mergeShapes(\n    //   //   this._def.shape(),\n    //   //   merging._def.shape()\n    //   // );\n    //   const merged: any = new ZodObject({\n    //     unknownKeys: merging._def.unknownKeys,\n    //     catchall: merging._def.catchall,\n    //     shape: () =>\n    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n    //     typeName: ZodFirstPartyTypeKind.ZodObject,\n    //   }) as any;\n    //   return merged;\n    // }\n    catchall(index) {\n        return new _ZodObject({\n            ...this._def,\n            catchall: index\n        });\n    }\n    pick(mask) {\n        const shape = {};\n        util.objectKeys(mask).forEach((key)=>{\n            if (mask[key] && this.shape[key]) {\n                shape[key] = this.shape[key];\n            }\n        });\n        return new _ZodObject({\n            ...this._def,\n            shape: ()=>shape\n        });\n    }\n    omit(mask) {\n        const shape = {};\n        util.objectKeys(this.shape).forEach((key)=>{\n            if (!mask[key]) {\n                shape[key] = this.shape[key];\n            }\n        });\n        return new _ZodObject({\n            ...this._def,\n            shape: ()=>shape\n        });\n    }\n    /**\n   * @deprecated\n   */ deepPartial() {\n        return deepPartialify(this);\n    }\n    partial(mask) {\n        const newShape = {};\n        util.objectKeys(this.shape).forEach((key)=>{\n            const fieldSchema = this.shape[key];\n            if (mask && !mask[key]) {\n                newShape[key] = fieldSchema;\n            } else {\n                newShape[key] = fieldSchema.optional();\n            }\n        });\n        return new _ZodObject({\n            ...this._def,\n            shape: ()=>newShape\n        });\n    }\n    required(mask) {\n        const newShape = {};\n        util.objectKeys(this.shape).forEach((key)=>{\n            if (mask && !mask[key]) {\n                newShape[key] = this.shape[key];\n            } else {\n                const fieldSchema = this.shape[key];\n                let newField = fieldSchema;\n                while(newField instanceof ZodOptional){\n                    newField = newField._def.innerType;\n                }\n                newShape[key] = newField;\n            }\n        });\n        return new _ZodObject({\n            ...this._def,\n            shape: ()=>newShape\n        });\n    }\n    keyof() {\n        return createZodEnum(util.objectKeys(this.shape));\n    }\n    constructor(){\n        super(...arguments);\n        this._cached = null;\n        this.nonstrict = this.passthrough;\n        this.augment = this.extend;\n    }\n};\nZodObject.create = (shape, params)=>{\n    return new ZodObject({\n        shape: ()=>shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params)\n    });\n};\nZodObject.strictCreate = (shape, params)=>{\n    return new ZodObject({\n        shape: ()=>shape,\n        unknownKeys: \"strict\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params)\n    });\n};\nZodObject.lazycreate = (shape, params)=>{\n    return new ZodObject({\n        shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params)\n    });\n};\nvar ZodUnion = class extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const options = this._def.options;\n        function handleResults(results) {\n            for (const result of results){\n                if (result.result.status === \"valid\") {\n                    return result.result;\n                }\n            }\n            for (const result of results){\n                if (result.result.status === \"dirty\") {\n                    ctx.common.issues.push(...result.ctx.common.issues);\n                    return result.result;\n                }\n            }\n            const unionErrors = results.map((result)=>new ZodError(result.ctx.common.issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return Promise.all(options.map(async (option)=>{\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: []\n                    },\n                    parent: null\n                };\n                return {\n                    result: await option._parseAsync({\n                        data: ctx.data,\n                        path: ctx.path,\n                        parent: childCtx\n                    }),\n                    ctx: childCtx\n                };\n            })).then(handleResults);\n        } else {\n            let dirty = void 0;\n            const issues = [];\n            for (const option of options){\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: []\n                    },\n                    parent: null\n                };\n                const result = option._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: childCtx\n                });\n                if (result.status === \"valid\") {\n                    return result;\n                } else if (result.status === \"dirty\" && !dirty) {\n                    dirty = {\n                        result,\n                        ctx: childCtx\n                    };\n                }\n                if (childCtx.common.issues.length) {\n                    issues.push(childCtx.common.issues);\n                }\n            }\n            if (dirty) {\n                ctx.common.issues.push(...dirty.ctx.common.issues);\n                return dirty.result;\n            }\n            const unionErrors = issues.map((issues2)=>new ZodError(issues2));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors\n            });\n            return INVALID;\n        }\n    }\n    get options() {\n        return this._def.options;\n    }\n};\nZodUnion.create = (types, params)=>{\n    return new ZodUnion({\n        options: types,\n        typeName: ZodFirstPartyTypeKind.ZodUnion,\n        ...processCreateParams(params)\n    });\n};\nvar getDiscriminator = (type)=>{\n    if (type instanceof ZodLazy) {\n        return getDiscriminator(type.schema);\n    } else if (type instanceof ZodEffects) {\n        return getDiscriminator(type.innerType());\n    } else if (type instanceof ZodLiteral) {\n        return [\n            type.value\n        ];\n    } else if (type instanceof ZodEnum) {\n        return type.options;\n    } else if (type instanceof ZodNativeEnum) {\n        return util.objectValues(type.enum);\n    } else if (type instanceof ZodDefault) {\n        return getDiscriminator(type._def.innerType);\n    } else if (type instanceof ZodUndefined) {\n        return [\n            void 0\n        ];\n    } else if (type instanceof ZodNull) {\n        return [\n            null\n        ];\n    } else if (type instanceof ZodOptional) {\n        return [\n            void 0,\n            ...getDiscriminator(type.unwrap())\n        ];\n    } else if (type instanceof ZodNullable) {\n        return [\n            null,\n            ...getDiscriminator(type.unwrap())\n        ];\n    } else if (type instanceof ZodBranded) {\n        return getDiscriminator(type.unwrap());\n    } else if (type instanceof ZodReadonly) {\n        return getDiscriminator(type.unwrap());\n    } else if (type instanceof ZodCatch) {\n        return getDiscriminator(type._def.innerType);\n    } else {\n        return [];\n    }\n};\nvar ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        const discriminator = this.discriminator;\n        const discriminatorValue = ctx.data[discriminator];\n        const option = this.optionsMap.get(discriminatorValue);\n        if (!option) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union_discriminator,\n                options: Array.from(this.optionsMap.keys()),\n                path: [\n                    discriminator\n                ]\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return option._parseAsync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx\n            });\n        } else {\n            return option._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx\n            });\n        }\n    }\n    get discriminator() {\n        return this._def.discriminator;\n    }\n    get options() {\n        return this._def.options;\n    }\n    get optionsMap() {\n        return this._def.optionsMap;\n    }\n    /**\n   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.\n   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must\n   * have a different value for each object in the union.\n   * @param discriminator the name of the discriminator property\n   * @param types an array of object schemas\n   * @param params\n   */ static create(discriminator, options, params) {\n        const optionsMap = /* @__PURE__ */ new Map();\n        for (const type of options){\n            const discriminatorValues = getDiscriminator(type.shape[discriminator]);\n            if (!discriminatorValues.length) {\n                throw new Error(\"A discriminator value for key `\".concat(discriminator, \"` could not be extracted from all schema options\"));\n            }\n            for (const value of discriminatorValues){\n                if (optionsMap.has(value)) {\n                    throw new Error(\"Discriminator property \".concat(String(discriminator), \" has duplicate value \").concat(String(value)));\n                }\n                optionsMap.set(value, type);\n            }\n        }\n        return new _ZodDiscriminatedUnion({\n            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\n            discriminator,\n            options,\n            optionsMap,\n            ...processCreateParams(params)\n        });\n    }\n};\nfunction mergeValues(a, b) {\n    const aType = getParsedType(a);\n    const bType = getParsedType(b);\n    if (a === b) {\n        return {\n            valid: true,\n            data: a\n        };\n    } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {\n        const bKeys = util.objectKeys(b);\n        const sharedKeys = util.objectKeys(a).filter((key)=>bKeys.indexOf(key) !== -1);\n        const newObj = {\n            ...a,\n            ...b\n        };\n        for (const key of sharedKeys){\n            const sharedValue = mergeValues(a[key], b[key]);\n            if (!sharedValue.valid) {\n                return {\n                    valid: false\n                };\n            }\n            newObj[key] = sharedValue.data;\n        }\n        return {\n            valid: true,\n            data: newObj\n        };\n    } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {\n        if (a.length !== b.length) {\n            return {\n                valid: false\n            };\n        }\n        const newArray = [];\n        for(let index = 0; index < a.length; index++){\n            const itemA = a[index];\n            const itemB = b[index];\n            const sharedValue = mergeValues(itemA, itemB);\n            if (!sharedValue.valid) {\n                return {\n                    valid: false\n                };\n            }\n            newArray.push(sharedValue.data);\n        }\n        return {\n            valid: true,\n            data: newArray\n        };\n    } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {\n        return {\n            valid: true,\n            data: a\n        };\n    } else {\n        return {\n            valid: false\n        };\n    }\n}\nvar ZodIntersection = class extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const handleParsed = (parsedLeft, parsedRight)=>{\n            if (isAborted(parsedLeft) || isAborted(parsedRight)) {\n                return INVALID;\n            }\n            const merged = mergeValues(parsedLeft.value, parsedRight.value);\n            if (!merged.valid) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.invalid_intersection_types\n                });\n                return INVALID;\n            }\n            if (isDirty(parsedLeft) || isDirty(parsedRight)) {\n                status.dirty();\n            }\n            return {\n                status: status.value,\n                value: merged.data\n            };\n        };\n        if (ctx.common.async) {\n            return Promise.all([\n                this._def.left._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx\n                }),\n                this._def.right._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx\n                })\n            ]).then((param)=>{\n                let [left, right] = param;\n                return handleParsed(left, right);\n            });\n        } else {\n            return handleParsed(this._def.left._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx\n            }), this._def.right._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx\n            }));\n        }\n    }\n};\nZodIntersection.create = (left, right, params)=>{\n    return new ZodIntersection({\n        left,\n        right,\n        typeName: ZodFirstPartyTypeKind.ZodIntersection,\n        ...processCreateParams(params)\n    });\n};\nvar ZodTuple = class _ZodTuple extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        if (ctx.data.length < this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_small,\n                minimum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\"\n            });\n            return INVALID;\n        }\n        const rest = this._def.rest;\n        if (!rest && ctx.data.length > this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_big,\n                maximum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\"\n            });\n            status.dirty();\n        }\n        const items = [\n            ...ctx.data\n        ].map((item, itemIndex)=>{\n            const schema = this._def.items[itemIndex] || this._def.rest;\n            if (!schema) return null;\n            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\n        }).filter((x)=>!!x);\n        if (ctx.common.async) {\n            return Promise.all(items).then((results)=>{\n                return ParseStatus.mergeArray(status, results);\n            });\n        } else {\n            return ParseStatus.mergeArray(status, items);\n        }\n    }\n    get items() {\n        return this._def.items;\n    }\n    rest(rest) {\n        return new _ZodTuple({\n            ...this._def,\n            rest\n        });\n    }\n};\nZodTuple.create = (schemas, params)=>{\n    if (!Array.isArray(schemas)) {\n        throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\n    }\n    return new ZodTuple({\n        items: schemas,\n        typeName: ZodFirstPartyTypeKind.ZodTuple,\n        rest: null,\n        ...processCreateParams(params)\n    });\n};\nvar ZodRecord = class _ZodRecord extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        const pairs = [];\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        for(const key in ctx.data){\n            pairs.push({\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\n                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),\n                alwaysSet: key in ctx.data\n            });\n        }\n        if (ctx.common.async) {\n            return ParseStatus.mergeObjectAsync(status, pairs);\n        } else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get element() {\n        return this._def.valueType;\n    }\n    static create(first, second, third) {\n        if (second instanceof ZodType) {\n            return new _ZodRecord({\n                keyType: first,\n                valueType: second,\n                typeName: ZodFirstPartyTypeKind.ZodRecord,\n                ...processCreateParams(third)\n            });\n        }\n        return new _ZodRecord({\n            keyType: ZodString.create(),\n            valueType: first,\n            typeName: ZodFirstPartyTypeKind.ZodRecord,\n            ...processCreateParams(second)\n        });\n    }\n};\nvar ZodMap = class extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.map) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.map,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        const pairs = [\n            ...ctx.data.entries()\n        ].map((param, index)=>{\n            let [key, value] = param;\n            return {\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [\n                    index,\n                    \"key\"\n                ])),\n                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [\n                    index,\n                    \"value\"\n                ]))\n            };\n        });\n        if (ctx.common.async) {\n            const finalMap = /* @__PURE__ */ new Map();\n            return Promise.resolve().then(async ()=>{\n                for (const pair of pairs){\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    if (key.status === \"aborted\" || value.status === \"aborted\") {\n                        return INVALID;\n                    }\n                    if (key.status === \"dirty\" || value.status === \"dirty\") {\n                        status.dirty();\n                    }\n                    finalMap.set(key.value, value.value);\n                }\n                return {\n                    status: status.value,\n                    value: finalMap\n                };\n            });\n        } else {\n            const finalMap = /* @__PURE__ */ new Map();\n            for (const pair of pairs){\n                const key = pair.key;\n                const value = pair.value;\n                if (key.status === \"aborted\" || value.status === \"aborted\") {\n                    return INVALID;\n                }\n                if (key.status === \"dirty\" || value.status === \"dirty\") {\n                    status.dirty();\n                }\n                finalMap.set(key.value, value.value);\n            }\n            return {\n                status: status.value,\n                value: finalMap\n            };\n        }\n    }\n};\nZodMap.create = (keyType, valueType, params)=>{\n    return new ZodMap({\n        valueType,\n        keyType,\n        typeName: ZodFirstPartyTypeKind.ZodMap,\n        ...processCreateParams(params)\n    });\n};\nvar ZodSet = class _ZodSet extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.set) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.set,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        const def = this._def;\n        if (def.minSize !== null) {\n            if (ctx.data.size < def.minSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minSize.message\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxSize !== null) {\n            if (ctx.data.size > def.maxSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxSize.message\n                });\n                status.dirty();\n            }\n        }\n        const valueType = this._def.valueType;\n        function finalizeSet(elements2) {\n            const parsedSet = /* @__PURE__ */ new Set();\n            for (const element of elements2){\n                if (element.status === \"aborted\") return INVALID;\n                if (element.status === \"dirty\") status.dirty();\n                parsedSet.add(element.value);\n            }\n            return {\n                status: status.value,\n                value: parsedSet\n            };\n        }\n        const elements = [\n            ...ctx.data.values()\n        ].map((item, i)=>valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));\n        if (ctx.common.async) {\n            return Promise.all(elements).then((elements2)=>finalizeSet(elements2));\n        } else {\n            return finalizeSet(elements);\n        }\n    }\n    min(minSize, message) {\n        return new _ZodSet({\n            ...this._def,\n            minSize: {\n                value: minSize,\n                message: errorUtil.toString(message)\n            }\n        });\n    }\n    max(maxSize, message) {\n        return new _ZodSet({\n            ...this._def,\n            maxSize: {\n                value: maxSize,\n                message: errorUtil.toString(message)\n            }\n        });\n    }\n    size(size, message) {\n        return this.min(size, message).max(size, message);\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n};\nZodSet.create = (valueType, params)=>{\n    return new ZodSet({\n        valueType,\n        minSize: null,\n        maxSize: null,\n        typeName: ZodFirstPartyTypeKind.ZodSet,\n        ...processCreateParams(params)\n    });\n};\nvar ZodFunction = class _ZodFunction extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.function) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.function,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        function makeArgsIssue(args, error) {\n            return makeIssue({\n                data: args,\n                path: ctx.path,\n                errorMaps: [\n                    ctx.common.contextualErrorMap,\n                    ctx.schemaErrorMap,\n                    getErrorMap(),\n                    errorMap\n                ].filter((x)=>!!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_arguments,\n                    argumentsError: error\n                }\n            });\n        }\n        function makeReturnsIssue(returns, error) {\n            return makeIssue({\n                data: returns,\n                path: ctx.path,\n                errorMaps: [\n                    ctx.common.contextualErrorMap,\n                    ctx.schemaErrorMap,\n                    getErrorMap(),\n                    errorMap\n                ].filter((x)=>!!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_return_type,\n                    returnTypeError: error\n                }\n            });\n        }\n        const params = {\n            errorMap: ctx.common.contextualErrorMap\n        };\n        const fn = ctx.data;\n        if (this._def.returns instanceof ZodPromise) {\n            const me = this;\n            return OK(async function() {\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                const error = new ZodError([]);\n                const parsedArgs = await me._def.args.parseAsync(args, params).catch((e)=>{\n                    error.addIssue(makeArgsIssue(args, e));\n                    throw error;\n                });\n                const result = await Reflect.apply(fn, this, parsedArgs);\n                const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e)=>{\n                    error.addIssue(makeReturnsIssue(result, e));\n                    throw error;\n                });\n                return parsedReturns;\n            });\n        } else {\n            const me = this;\n            return OK(function() {\n                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n                    args[_key] = arguments[_key];\n                }\n                const parsedArgs = me._def.args.safeParse(args, params);\n                if (!parsedArgs.success) {\n                    throw new ZodError([\n                        makeArgsIssue(args, parsedArgs.error)\n                    ]);\n                }\n                const result = Reflect.apply(fn, this, parsedArgs.data);\n                const parsedReturns = me._def.returns.safeParse(result, params);\n                if (!parsedReturns.success) {\n                    throw new ZodError([\n                        makeReturnsIssue(result, parsedReturns.error)\n                    ]);\n                }\n                return parsedReturns.data;\n            });\n        }\n    }\n    parameters() {\n        return this._def.args;\n    }\n    returnType() {\n        return this._def.returns;\n    }\n    args() {\n        for(var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++){\n            items[_key] = arguments[_key];\n        }\n        return new _ZodFunction({\n            ...this._def,\n            args: ZodTuple.create(items).rest(ZodUnknown.create())\n        });\n    }\n    returns(returnType) {\n        return new _ZodFunction({\n            ...this._def,\n            returns: returnType\n        });\n    }\n    implement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    strictImplement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    static create(args, returns, params) {\n        return new _ZodFunction({\n            args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),\n            returns: returns || ZodUnknown.create(),\n            typeName: ZodFirstPartyTypeKind.ZodFunction,\n            ...processCreateParams(params)\n        });\n    }\n    constructor(){\n        super(...arguments);\n        this.validate = this.implement;\n    }\n};\nvar ZodLazy = class extends ZodType {\n    get schema() {\n        return this._def.getter();\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const lazySchema = this._def.getter();\n        return lazySchema._parse({\n            data: ctx.data,\n            path: ctx.path,\n            parent: ctx\n        });\n    }\n};\nZodLazy.create = (getter, params)=>{\n    return new ZodLazy({\n        getter,\n        typeName: ZodFirstPartyTypeKind.ZodLazy,\n        ...processCreateParams(params)\n    });\n};\nvar ZodLiteral = class extends ZodType {\n    _parse(input) {\n        if (input.data !== this._def.value) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_literal,\n                expected: this._def.value\n            });\n            return INVALID;\n        }\n        return {\n            status: \"valid\",\n            value: input.data\n        };\n    }\n    get value() {\n        return this._def.value;\n    }\n};\nZodLiteral.create = (value, params)=>{\n    return new ZodLiteral({\n        value,\n        typeName: ZodFirstPartyTypeKind.ZodLiteral,\n        ...processCreateParams(params)\n    });\n};\nfunction createZodEnum(values, params) {\n    return new ZodEnum({\n        values,\n        typeName: ZodFirstPartyTypeKind.ZodEnum,\n        ...processCreateParams(params)\n    });\n}\nvar ZodEnum = class _ZodEnum extends ZodType {\n    _parse(input) {\n        if (typeof input.data !== \"string\") {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type\n            });\n            return INVALID;\n        }\n        if (!__classPrivateFieldGet(this, _ZodEnum_cache, \"f\")) {\n            __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), \"f\");\n        }\n        if (!__classPrivateFieldGet(this, _ZodEnum_cache, \"f\").has(input.data)) {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get options() {\n        return this._def.values;\n    }\n    get enum() {\n        const enumValues = {};\n        for (const val of this._def.values){\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Values() {\n        const enumValues = {};\n        for (const val of this._def.values){\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Enum() {\n        const enumValues = {};\n        for (const val of this._def.values){\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    extract(values) {\n        let newDef = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this._def;\n        return _ZodEnum.create(values, {\n            ...this._def,\n            ...newDef\n        });\n    }\n    exclude(values) {\n        let newDef = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this._def;\n        return _ZodEnum.create(this.options.filter((opt)=>!values.includes(opt)), {\n            ...this._def,\n            ...newDef\n        });\n    }\n    constructor(){\n        super(...arguments);\n        _ZodEnum_cache.set(this, void 0);\n    }\n};\n_ZodEnum_cache = /* @__PURE__ */ new WeakMap();\nZodEnum.create = createZodEnum;\nvar ZodNativeEnum = class extends ZodType {\n    _parse(input) {\n        const nativeEnumValues = util.getValidEnumValues(this._def.values);\n        const ctx = this._getOrReturnCtx(input);\n        if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type\n            });\n            return INVALID;\n        }\n        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, \"f\")) {\n            __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), \"f\");\n        }\n        if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, \"f\").has(input.data)) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get enum() {\n        return this._def.values;\n    }\n    constructor(){\n        super(...arguments);\n        _ZodNativeEnum_cache.set(this, void 0);\n    }\n};\n_ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();\nZodNativeEnum.create = (values, params)=>{\n    return new ZodNativeEnum({\n        values,\n        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,\n        ...processCreateParams(params)\n    });\n};\nvar ZodPromise = class extends ZodType {\n    unwrap() {\n        return this._def.type;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.promise,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);\n        return OK(promisified.then((data)=>{\n            return this._def.type.parseAsync(data, {\n                path: ctx.path,\n                errorMap: ctx.common.contextualErrorMap\n            });\n        }));\n    }\n};\nZodPromise.create = (schema, params)=>{\n    return new ZodPromise({\n        type: schema,\n        typeName: ZodFirstPartyTypeKind.ZodPromise,\n        ...processCreateParams(params)\n    });\n};\nvar ZodEffects = class extends ZodType {\n    innerType() {\n        return this._def.schema;\n    }\n    sourceType() {\n        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const effect = this._def.effect || null;\n        const checkCtx = {\n            addIssue: (arg)=>{\n                addIssueToContext(ctx, arg);\n                if (arg.fatal) {\n                    status.abort();\n                } else {\n                    status.dirty();\n                }\n            },\n            get path () {\n                return ctx.path;\n            }\n        };\n        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\n        if (effect.type === \"preprocess\") {\n            const processed = effect.transform(ctx.data, checkCtx);\n            if (ctx.common.async) {\n                return Promise.resolve(processed).then(async (processed2)=>{\n                    if (status.value === \"aborted\") return INVALID;\n                    const result = await this._def.schema._parseAsync({\n                        data: processed2,\n                        path: ctx.path,\n                        parent: ctx\n                    });\n                    if (result.status === \"aborted\") return INVALID;\n                    if (result.status === \"dirty\") return DIRTY(result.value);\n                    if (status.value === \"dirty\") return DIRTY(result.value);\n                    return result;\n                });\n            } else {\n                if (status.value === \"aborted\") return INVALID;\n                const result = this._def.schema._parseSync({\n                    data: processed,\n                    path: ctx.path,\n                    parent: ctx\n                });\n                if (result.status === \"aborted\") return INVALID;\n                if (result.status === \"dirty\") return DIRTY(result.value);\n                if (status.value === \"dirty\") return DIRTY(result.value);\n                return result;\n            }\n        }\n        if (effect.type === \"refinement\") {\n            const executeRefinement = (acc)=>{\n                const result = effect.refinement(acc, checkCtx);\n                if (ctx.common.async) {\n                    return Promise.resolve(result);\n                }\n                if (result instanceof Promise) {\n                    throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n                }\n                return acc;\n            };\n            if (ctx.common.async === false) {\n                const inner = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx\n                });\n                if (inner.status === \"aborted\") return INVALID;\n                if (inner.status === \"dirty\") status.dirty();\n                executeRefinement(inner.value);\n                return {\n                    status: status.value,\n                    value: inner.value\n                };\n            } else {\n                return this._def.schema._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx\n                }).then((inner)=>{\n                    if (inner.status === \"aborted\") return INVALID;\n                    if (inner.status === \"dirty\") status.dirty();\n                    return executeRefinement(inner.value).then(()=>{\n                        return {\n                            status: status.value,\n                            value: inner.value\n                        };\n                    });\n                });\n            }\n        }\n        if (effect.type === \"transform\") {\n            if (ctx.common.async === false) {\n                const base = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx\n                });\n                if (!isValid(base)) return base;\n                const result = effect.transform(base.value, checkCtx);\n                if (result instanceof Promise) {\n                    throw new Error(\"Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.\");\n                }\n                return {\n                    status: status.value,\n                    value: result\n                };\n            } else {\n                return this._def.schema._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx\n                }).then((base)=>{\n                    if (!isValid(base)) return base;\n                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result)=>({\n                            status: status.value,\n                            value: result\n                        }));\n                });\n            }\n        }\n        util.assertNever(effect);\n    }\n};\nZodEffects.create = (schema, effect, params)=>{\n    return new ZodEffects({\n        schema,\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        effect,\n        ...processCreateParams(params)\n    });\n};\nZodEffects.createWithPreprocess = (preprocess, schema, params)=>{\n    return new ZodEffects({\n        schema,\n        effect: {\n            type: \"preprocess\",\n            transform: preprocess\n        },\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        ...processCreateParams(params)\n    });\n};\nvar ZodOptional = class extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.undefined) {\n            return OK(void 0);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n};\nZodOptional.create = (type, params)=>{\n    return new ZodOptional({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodOptional,\n        ...processCreateParams(params)\n    });\n};\nvar ZodNullable = class extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.null) {\n            return OK(null);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n};\nZodNullable.create = (type, params)=>{\n    return new ZodNullable({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodNullable,\n        ...processCreateParams(params)\n    });\n};\nvar ZodDefault = class extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        let data = ctx.data;\n        if (ctx.parsedType === ZodParsedType.undefined) {\n            data = this._def.defaultValue();\n        }\n        return this._def.innerType._parse({\n            data,\n            path: ctx.path,\n            parent: ctx\n        });\n    }\n    removeDefault() {\n        return this._def.innerType;\n    }\n};\nZodDefault.create = (type, params)=>{\n    return new ZodDefault({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodDefault,\n        defaultValue: typeof params.default === \"function\" ? params.default : ()=>params.default,\n        ...processCreateParams(params)\n    });\n};\nvar ZodCatch = class extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const newCtx = {\n            ...ctx,\n            common: {\n                ...ctx.common,\n                issues: []\n            }\n        };\n        const result = this._def.innerType._parse({\n            data: newCtx.data,\n            path: newCtx.path,\n            parent: {\n                ...newCtx\n            }\n        });\n        if (isAsync(result)) {\n            return result.then((result2)=>{\n                return {\n                    status: \"valid\",\n                    value: result2.status === \"valid\" ? result2.value : this._def.catchValue({\n                        get error () {\n                            return new ZodError(newCtx.common.issues);\n                        },\n                        input: newCtx.data\n                    })\n                };\n            });\n        } else {\n            return {\n                status: \"valid\",\n                value: result.status === \"valid\" ? result.value : this._def.catchValue({\n                    get error () {\n                        return new ZodError(newCtx.common.issues);\n                    },\n                    input: newCtx.data\n                })\n            };\n        }\n    }\n    removeCatch() {\n        return this._def.innerType;\n    }\n};\nZodCatch.create = (type, params)=>{\n    return new ZodCatch({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodCatch,\n        catchValue: typeof params.catch === \"function\" ? params.catch : ()=>params.catch,\n        ...processCreateParams(params)\n    });\n};\nvar ZodNaN = class extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.nan) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.nan,\n                received: ctx.parsedType\n            });\n            return INVALID;\n        }\n        return {\n            status: \"valid\",\n            value: input.data\n        };\n    }\n};\nZodNaN.create = (params)=>{\n    return new ZodNaN({\n        typeName: ZodFirstPartyTypeKind.ZodNaN,\n        ...processCreateParams(params)\n    });\n};\nvar BRAND = Symbol(\"zod_brand\");\nvar ZodBranded = class extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const data = ctx.data;\n        return this._def.type._parse({\n            data,\n            path: ctx.path,\n            parent: ctx\n        });\n    }\n    unwrap() {\n        return this._def.type;\n    }\n};\nvar ZodPipeline = class _ZodPipeline extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.common.async) {\n            const handleAsync = async ()=>{\n                const inResult = await this._def.in._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx\n                });\n                if (inResult.status === \"aborted\") return INVALID;\n                if (inResult.status === \"dirty\") {\n                    status.dirty();\n                    return DIRTY(inResult.value);\n                } else {\n                    return this._def.out._parseAsync({\n                        data: inResult.value,\n                        path: ctx.path,\n                        parent: ctx\n                    });\n                }\n            };\n            return handleAsync();\n        } else {\n            const inResult = this._def.in._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx\n            });\n            if (inResult.status === \"aborted\") return INVALID;\n            if (inResult.status === \"dirty\") {\n                status.dirty();\n                return {\n                    status: \"dirty\",\n                    value: inResult.value\n                };\n            } else {\n                return this._def.out._parseSync({\n                    data: inResult.value,\n                    path: ctx.path,\n                    parent: ctx\n                });\n            }\n        }\n    }\n    static create(a, b) {\n        return new _ZodPipeline({\n            in: a,\n            out: b,\n            typeName: ZodFirstPartyTypeKind.ZodPipeline\n        });\n    }\n};\nvar ZodReadonly = class extends ZodType {\n    _parse(input) {\n        const result = this._def.innerType._parse(input);\n        const freeze = (data)=>{\n            if (isValid(data)) {\n                data.value = Object.freeze(data.value);\n            }\n            return data;\n        };\n        return isAsync(result) ? result.then((data)=>freeze(data)) : freeze(result);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n};\nZodReadonly.create = (type, params)=>{\n    return new ZodReadonly({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodReadonly,\n        ...processCreateParams(params)\n    });\n};\nfunction custom(check) {\n    let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, fatal = arguments.length > 2 ? arguments[2] : void 0;\n    if (check) return ZodAny.create().superRefine((data, ctx)=>{\n        var _a, _b;\n        if (!check(data)) {\n            const p = typeof params === \"function\" ? params(data) : typeof params === \"string\" ? {\n                message: params\n            } : params;\n            const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;\n            const p2 = typeof p === \"string\" ? {\n                message: p\n            } : p;\n            ctx.addIssue({\n                code: \"custom\",\n                ...p2,\n                fatal: _fatal\n            });\n        }\n    });\n    return ZodAny.create();\n}\nvar late = {\n    object: ZodObject.lazycreate\n};\nvar ZodFirstPartyTypeKind;\n(function(ZodFirstPartyTypeKind2) {\n    ZodFirstPartyTypeKind2[\"ZodString\"] = \"ZodString\";\n    ZodFirstPartyTypeKind2[\"ZodNumber\"] = \"ZodNumber\";\n    ZodFirstPartyTypeKind2[\"ZodNaN\"] = \"ZodNaN\";\n    ZodFirstPartyTypeKind2[\"ZodBigInt\"] = \"ZodBigInt\";\n    ZodFirstPartyTypeKind2[\"ZodBoolean\"] = \"ZodBoolean\";\n    ZodFirstPartyTypeKind2[\"ZodDate\"] = \"ZodDate\";\n    ZodFirstPartyTypeKind2[\"ZodSymbol\"] = \"ZodSymbol\";\n    ZodFirstPartyTypeKind2[\"ZodUndefined\"] = \"ZodUndefined\";\n    ZodFirstPartyTypeKind2[\"ZodNull\"] = \"ZodNull\";\n    ZodFirstPartyTypeKind2[\"ZodAny\"] = \"ZodAny\";\n    ZodFirstPartyTypeKind2[\"ZodUnknown\"] = \"ZodUnknown\";\n    ZodFirstPartyTypeKind2[\"ZodNever\"] = \"ZodNever\";\n    ZodFirstPartyTypeKind2[\"ZodVoid\"] = \"ZodVoid\";\n    ZodFirstPartyTypeKind2[\"ZodArray\"] = \"ZodArray\";\n    ZodFirstPartyTypeKind2[\"ZodObject\"] = \"ZodObject\";\n    ZodFirstPartyTypeKind2[\"ZodUnion\"] = \"ZodUnion\";\n    ZodFirstPartyTypeKind2[\"ZodDiscriminatedUnion\"] = \"ZodDiscriminatedUnion\";\n    ZodFirstPartyTypeKind2[\"ZodIntersection\"] = \"ZodIntersection\";\n    ZodFirstPartyTypeKind2[\"ZodTuple\"] = \"ZodTuple\";\n    ZodFirstPartyTypeKind2[\"ZodRecord\"] = \"ZodRecord\";\n    ZodFirstPartyTypeKind2[\"ZodMap\"] = \"ZodMap\";\n    ZodFirstPartyTypeKind2[\"ZodSet\"] = \"ZodSet\";\n    ZodFirstPartyTypeKind2[\"ZodFunction\"] = \"ZodFunction\";\n    ZodFirstPartyTypeKind2[\"ZodLazy\"] = \"ZodLazy\";\n    ZodFirstPartyTypeKind2[\"ZodLiteral\"] = \"ZodLiteral\";\n    ZodFirstPartyTypeKind2[\"ZodEnum\"] = \"ZodEnum\";\n    ZodFirstPartyTypeKind2[\"ZodEffects\"] = \"ZodEffects\";\n    ZodFirstPartyTypeKind2[\"ZodNativeEnum\"] = \"ZodNativeEnum\";\n    ZodFirstPartyTypeKind2[\"ZodOptional\"] = \"ZodOptional\";\n    ZodFirstPartyTypeKind2[\"ZodNullable\"] = \"ZodNullable\";\n    ZodFirstPartyTypeKind2[\"ZodDefault\"] = \"ZodDefault\";\n    ZodFirstPartyTypeKind2[\"ZodCatch\"] = \"ZodCatch\";\n    ZodFirstPartyTypeKind2[\"ZodPromise\"] = \"ZodPromise\";\n    ZodFirstPartyTypeKind2[\"ZodBranded\"] = \"ZodBranded\";\n    ZodFirstPartyTypeKind2[\"ZodPipeline\"] = \"ZodPipeline\";\n    ZodFirstPartyTypeKind2[\"ZodReadonly\"] = \"ZodReadonly\";\n})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));\nvar instanceOfType = function(cls) {\n    let params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {\n        message: \"Input not instance of \".concat(cls.name)\n    };\n    return custom((data)=>data instanceof cls, params);\n};\nvar stringType = ZodString.create;\nvar numberType = ZodNumber.create;\nvar nanType = ZodNaN.create;\nvar bigIntType = ZodBigInt.create;\nvar booleanType = ZodBoolean.create;\nvar dateType = ZodDate.create;\nvar symbolType = ZodSymbol.create;\nvar undefinedType = ZodUndefined.create;\nvar nullType = ZodNull.create;\nvar anyType = ZodAny.create;\nvar unknownType = ZodUnknown.create;\nvar neverType = ZodNever.create;\nvar voidType = ZodVoid.create;\nvar arrayType = ZodArray.create;\nvar objectType = ZodObject.create;\nvar strictObjectType = ZodObject.strictCreate;\nvar unionType = ZodUnion.create;\nvar discriminatedUnionType = ZodDiscriminatedUnion.create;\nvar intersectionType = ZodIntersection.create;\nvar tupleType = ZodTuple.create;\nvar recordType = ZodRecord.create;\nvar mapType = ZodMap.create;\nvar setType = ZodSet.create;\nvar functionType = ZodFunction.create;\nvar lazyType = ZodLazy.create;\nvar literalType = ZodLiteral.create;\nvar enumType = ZodEnum.create;\nvar nativeEnumType = ZodNativeEnum.create;\nvar promiseType = ZodPromise.create;\nvar effectsType = ZodEffects.create;\nvar optionalType = ZodOptional.create;\nvar nullableType = ZodNullable.create;\nvar preprocessType = ZodEffects.createWithPreprocess;\nvar pipelineType = ZodPipeline.create;\nvar ostring = ()=>stringType().optional();\nvar onumber = ()=>numberType().optional();\nvar oboolean = ()=>booleanType().optional();\nvar coerce = {\n    string: (arg)=>ZodString.create({\n            ...arg,\n            coerce: true\n        }),\n    number: (arg)=>ZodNumber.create({\n            ...arg,\n            coerce: true\n        }),\n    boolean: (arg)=>ZodBoolean.create({\n            ...arg,\n            coerce: true\n        }),\n    bigint: (arg)=>ZodBigInt.create({\n            ...arg,\n            coerce: true\n        }),\n    date: (arg)=>ZodDate.create({\n            ...arg,\n            coerce: true\n        })\n};\nvar NEVER = INVALID;\nvar z = /* @__PURE__ */ Object.freeze({\n    __proto__: null,\n    defaultErrorMap: errorMap,\n    setErrorMap,\n    getErrorMap,\n    makeIssue,\n    EMPTY_PATH,\n    addIssueToContext,\n    ParseStatus,\n    INVALID,\n    DIRTY,\n    OK,\n    isAborted,\n    isDirty,\n    isValid,\n    isAsync,\n    get util () {\n        return util;\n    },\n    get objectUtil () {\n        return objectUtil;\n    },\n    ZodParsedType,\n    getParsedType,\n    ZodType,\n    datetimeRegex,\n    ZodString,\n    ZodNumber,\n    ZodBigInt,\n    ZodBoolean,\n    ZodDate,\n    ZodSymbol,\n    ZodUndefined,\n    ZodNull,\n    ZodAny,\n    ZodUnknown,\n    ZodNever,\n    ZodVoid,\n    ZodArray,\n    ZodObject,\n    ZodUnion,\n    ZodDiscriminatedUnion,\n    ZodIntersection,\n    ZodTuple,\n    ZodRecord,\n    ZodMap,\n    ZodSet,\n    ZodFunction,\n    ZodLazy,\n    ZodLiteral,\n    ZodEnum,\n    ZodNativeEnum,\n    ZodPromise,\n    ZodEffects,\n    ZodTransformer: ZodEffects,\n    ZodOptional,\n    ZodNullable,\n    ZodDefault,\n    ZodCatch,\n    ZodNaN,\n    BRAND,\n    ZodBranded,\n    ZodPipeline,\n    ZodReadonly,\n    custom,\n    Schema: ZodType,\n    ZodSchema: ZodType,\n    late,\n    get ZodFirstPartyTypeKind () {\n        return ZodFirstPartyTypeKind;\n    },\n    coerce,\n    any: anyType,\n    array: arrayType,\n    bigint: bigIntType,\n    boolean: booleanType,\n    date: dateType,\n    discriminatedUnion: discriminatedUnionType,\n    effect: effectsType,\n    \"enum\": enumType,\n    \"function\": functionType,\n    \"instanceof\": instanceOfType,\n    intersection: intersectionType,\n    lazy: lazyType,\n    literal: literalType,\n    map: mapType,\n    nan: nanType,\n    nativeEnum: nativeEnumType,\n    never: neverType,\n    \"null\": nullType,\n    nullable: nullableType,\n    number: numberType,\n    object: objectType,\n    oboolean,\n    onumber,\n    optional: optionalType,\n    ostring,\n    pipeline: pipelineType,\n    preprocess: preprocessType,\n    promise: promiseType,\n    record: recordType,\n    set: setType,\n    strictObject: strictObjectType,\n    string: stringType,\n    symbol: symbolType,\n    transformer: effectsType,\n    tuple: tupleType,\n    \"undefined\": undefinedType,\n    union: unionType,\n    unknown: unknownType,\n    \"void\": voidType,\n    NEVER,\n    ZodIssueCode,\n    quotelessJson,\n    ZodError\n});\n// package.json\nvar package_default = {\n    name: \"@imgly/background-removal\",\n    version: \"1.5.8\",\n    description: \"Background Removal in the Browser\",\n    keywords: [\n        \"background-removal\",\n        \"client-side\",\n        \"data-privacy\",\n        \"image-segmentation\",\n        \"image-matting\",\n        \"onnx\"\n    ],\n    repository: {\n        type: \"git\",\n        url: \"git+https://github.com/imgly/background-removal-js.git\"\n    },\n    license: \"SEE LICENSE IN LICENSE.md\",\n    author: {\n        name: \"IMG.LY GmbH\",\n        email: \"support@img.ly\",\n        url: \"https://img.ly\"\n    },\n    bugs: {\n        email: \"support@img.ly\"\n    },\n    source: \"./src/index.ts\",\n    main: \"./dist/index.cjs\",\n    module: \"./dist/index.mjs\",\n    types: \"./dist/src/index.d.ts\",\n    exports: {\n        \".\": {\n            require: \"./dist/index.cjs\",\n            import: \"./dist/index.mjs\",\n            types: \"./dist/src/index.d.ts\"\n        }\n    },\n    homepage: \"https://img.ly/showcases/cesdk/web/background-removal\",\n    files: [\n        \"LICENSE.md\",\n        \"README.md\",\n        \"CHANGELOG.md\",\n        \"ThirdPartyLicenses.json\",\n        \"dist/\",\n        \"bin/\"\n    ],\n    scripts: {\n        start: \"npm run watch\",\n        clean: \"npx rimraf dist\",\n        test: \"true\",\n        resources: \"node ../../scripts/package-resources.mjs\",\n        \"changelog:create\": \"node ../../scripts/changelog/changelog-create.mjs\",\n        \"changelog:generate\": \"node ../../scripts/changelog/changelog-generate.mjs\",\n        build: \"npm run clean && npm run types && npm run resources && npm run changelog:generate && node scripts/build.mjs\",\n        types: \" npx tsc --declaration --emitDeclarationOnly --declarationDir dist --declarationMap\",\n        watch: \"npm run clean && npm run resources && npm run changelog:generate && node scripts/watch.mjs\",\n        \"publish:latest\": \"npm publish --tag latest --access public\",\n        \"publish:next\": \"npm publish --tag next --access public\",\n        \"package:pack\": \"npm pack . --pack-destination ../../releases\",\n        lint: \"npx prettier --write .\"\n    },\n    dependencies: {\n        \"lodash-es\": \"^4.17.21\",\n        ndarray: \"~1.0.0\",\n        zod: \"^3.23.8\"\n    },\n    peerDependencies: {\n        \"onnxruntime-web\": \"1.21.0-dev.20250114-228dd16893\"\n    },\n    devDependencies: {\n        \"@types/lodash-es\": \"^4.17.12\",\n        \"@types/ndarray\": \"~1.0.14\",\n        \"@types/node\": \"~20.3.0\",\n        assert: \"~2.0.0\",\n        esbuild: \"~0.18.0\",\n        glob: \"~10.3.0\",\n        \"npm-dts\": \"~1.3.0\",\n        process: \"~0.11.0\",\n        \"ts-loader\": \"~9.4.0\",\n        tslib: \"~2.5.0\",\n        typescript: \"~5.1.0\",\n        util: \"~0.12.0\",\n        webpack: \"~5.85.0\",\n        \"webpack-cli\": \"~5.1.0\"\n    },\n    bundleDependencies: []\n};\n// src/schema.ts\nvar ConfigSchema = z.object({\n    publicPath: z.string().optional().describe(\"The public path to the wasm files and the onnx model.\").default(\"https://staticimgly.com/@imgly/background-removal-data/${PACKAGE_VERSION}/dist/\").transform((val)=>{\n        return val.replace(\"${PACKAGE_NAME}\", package_default.name).replace(\"${PACKAGE_VERSION}\", package_default.version);\n    }),\n    debug: z.boolean().default(false).describe(\"Whether to enable debug logging.\"),\n    rescale: z.boolean().default(true).describe(\"Whether to rescale the image.\"),\n    device: z.enum([\n        \"cpu\",\n        \"gpu\"\n    ]).default(\"cpu\").describe(\"The device to run the model on.\"),\n    proxyToWorker: z.boolean().default(false).describe(\"Whether to proxy inference to a web worker.\"),\n    fetchArgs: z.any().default({}).describe(\"Arguments to pass to fetch when loading the model.\"),\n    progress: z.function().args(z.string(), z.number(), z.number()).returns(z.void()).describe(\"Progress callback.\").optional(),\n    model: z.preprocess((val)=>{\n        switch(val){\n            case \"large\":\n                return \"isnet\";\n            case \"small\":\n                return \"isnet_quint8\";\n            case \"medium\":\n                return \"isnet_fp16\";\n            default:\n                return val;\n        }\n    }, z.enum([\n        \"isnet\",\n        \"isnet_fp16\",\n        \"isnet_quint8\"\n    ])).default(\"medium\"),\n    output: z.object({\n        format: z.enum([\n            \"image/png\",\n            \"image/jpeg\",\n            \"image/webp\",\n            \"image/x-rgba8\",\n            \"image/x-alpha8\"\n        ]).default(\"image/png\"),\n        quality: z.number().default(0.8)\n    }).default({})\n}).default({}).transform(_c2 = (config)=>{\n    if (config.debug) console.log(\"Config:\", config);\n    if (config.debug && !config.progress) {\n        var _config_progress;\n        config.progress = (_config_progress = config.progress) !== null && _config_progress !== void 0 ? _config_progress : (key, current, total)=>{\n            console.debug(\"Downloading \".concat(key, \": \").concat(current, \" of \").concat(total));\n        };\n        if (!crossOriginIsolated) {\n            if (config.debug) console.debug(\"Cross-Origin-Isolated is not enabled. Performance will be degraded. Please see  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer.\");\n        }\n    }\n    return config;\n});\n_c3 = ConfigSchema;\nfunction validateConfig(configuration) {\n    return ConfigSchema.parse(configuration !== null && configuration !== void 0 ? configuration : {});\n}\n// src/inference.ts\nvar import_ndarray4 = __toESM(require_ndarray());\nasync function initBase(config) {\n    if (config.debug) console.debug(\"Loading model...\", config.model);\n    const model = config.model;\n    const blob = await loadAsBlob(\"/models/\".concat(model), config);\n    const arrayBuffer = await blob.arrayBuffer();\n    const session = await createOnnxSession(arrayBuffer, config);\n    return session;\n}\nasync function initInference(config) {\n    config = validateConfig(config);\n    const base = await initBase(config);\n    return {\n        config,\n        session: {\n            base\n        }\n    };\n}\nasync function runInference(imageTensor, config, session) {\n    const resolution = 1024;\n    const [srcHeight, srcWidth, srcChannels] = imageTensor.shape;\n    const keepAspect = false;\n    let resizedImageTensor = tensorResizeBilinear(imageTensor, resolution, resolution, keepAspect);\n    const inputTensor = tensorHWCtoBCHW(resizedImageTensor);\n    let predictionsDict = await runOnnxSession(session.base, [\n        [\n            \"input\",\n            inputTensor\n        ]\n    ], [\n        \"output\"\n    ], config);\n    let alphamask2 = (0, import_ndarray4.default)(predictionsDict[0].data, [\n        resolution,\n        resolution,\n        1\n    ]);\n    let alphamaskU8 = convertFloat32ToUint8(alphamask2);\n    if (config.rescale) {\n        alphamaskU8 = tensorResizeBilinear(alphamaskU8, srcWidth, srcHeight, keepAspect);\n        return [\n            alphamaskU8,\n            imageTensor\n        ];\n    } else {\n        return [\n            alphamaskU8,\n            resizedImageTensor\n        ];\n    }\n}\n// src/api/v1.ts\nvar init = (0, import_lodash.memoize)(initInference, (config)=>JSON.stringify(config));\nasync function preload(configuration) {\n    await init(configuration);\n    return;\n}\nasync function removeBackground(image, configuration) {\n    var _config_progress, _config_progress1, _config_progress2, _config_progress3;\n    const { config, session } = await init(configuration);\n    if (config.progress) config.progress(\"compute:decode\", 0, 4);\n    const inputImageTensor = await imageSourceToImageData(image, config);\n    (_config_progress = config.progress) === null || _config_progress === void 0 ? void 0 : _config_progress.call(config, \"compute:inference\", 1, 4);\n    const [alphamask2, imageTensor] = await runInference(inputImageTensor, config, session);\n    (_config_progress1 = config.progress) === null || _config_progress1 === void 0 ? void 0 : _config_progress1.call(config, \"compute:mask\", 2, 4);\n    const outImageTensor = imageTensor;\n    const [width, height] = outImageTensor.shape;\n    const stride = width * height;\n    for(let i = 0; i < stride; i += 1){\n        outImageTensor.data[4 * i + 3] = alphamask2.data[i];\n    }\n    (_config_progress2 = config.progress) === null || _config_progress2 === void 0 ? void 0 : _config_progress2.call(config, \"compute:encode\", 3, 4);\n    const outImage = await imageEncode(outImageTensor, config.output.quality, config.output.format);\n    (_config_progress3 = config.progress) === null || _config_progress3 === void 0 ? void 0 : _config_progress3.call(config, \"compute:encode\", 4, 4);\n    return outImage;\n}\nasync function removeForeground(image, configuration) {\n    const { config, session } = await init(configuration);\n    const imageTensor = await imageSourceToImageData(image, config);\n    const [alphamask2, imageInput] = await runInference(imageTensor, config, session);\n    const outImageTensor = imageInput;\n    const [width, height, channels] = outImageTensor.shape;\n    const stride = width * height;\n    for(let i = 0; i < stride; i += 1){\n        outImageTensor.data[4 * i + 3] = 255 - alphamask2.data[i];\n    }\n    const outImage = await imageEncode(outImageTensor, config.output.quality, config.output.format);\n    return outImage;\n}\nvar alphamask = segmentForeground;\nasync function segmentForeground(image, configuration) {\n    const { config, session } = await init(configuration);\n    const imageTensor = await imageSourceToImageData(image, config);\n    let [height, width, channels] = imageTensor.shape;\n    const [alphamask2, imageInput] = await runInference(imageTensor, config, session);\n    const stride = width * height;\n    const outImageTensor = imageTensor;\n    for(let i = 0; i < stride; i += 1){\n        const index = 4 * i;\n        let alpha = alphamask2.data[i];\n        outImageTensor.data[index] = 255;\n        outImageTensor.data[index + 1] = 255;\n        outImageTensor.data[index + 2] = 255;\n        outImageTensor.data[index + 3] = alpha;\n    }\n    const outImage = await imageEncode(outImageTensor, config.output.quality, config.output.format);\n    return outImage;\n}\nasync function applySegmentationMask(image, mask, config) {\n    config = validateConfig(config);\n    const imageTensor = await imageSourceToImageData(image, config);\n    const [imageHeight, imageWidth, imageChannels] = imageTensor.shape;\n    const maskTensor = await imageSourceToImageData(mask, config);\n    const [maskHeight, maskWidth, maskChannels] = maskTensor.shape;\n    const alphaMask = maskHeight !== imageHeight || maskWidth !== imageWidth ? tensorResizeBilinear(maskTensor, imageWidth, imageHeight) : maskTensor;\n    const stride = imageWidth * imageHeight;\n    for(let i = 0; i < stride; i += 1){\n        const idxImage = imageChannels * i;\n        const idxMask = maskChannels * i;\n        imageTensor.data[idxImage + 3] = alphaMask.data[idxMask + 3];\n    }\n    const outImage = await imageEncode(imageTensor, config.output.quality, config.output.format);\n    return outImage;\n}\n /*! Bundled license information:\n\nlodash/lodash.js:\n  (**\n   * @license\n   * Lodash <https://lodash.com/>\n   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>\n   * Released under MIT license <https://lodash.com/license>\n   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n   *)\n\nis-buffer/index.js:\n  (*!\n   * Determine if an object is a Buffer\n   *\n   * @author   Feross Aboukhadijeh <https://feross.org>\n   * @license  MIT\n   *)\n*/  //# sourceMappingURL=index.mjs.map\nvar _c, _c1, _c2, _c3;\n$RefreshReg$(_c, \"DIRTY\");\n$RefreshReg$(_c1, \"OK\");\n$RefreshReg$(_c2, 'ConfigSchema$z.object({\\n  publicPath: z.string().optional().describe(\"The public path to the wasm files and the onnx model.\").default(\\n    \"https://staticimgly.com/@imgly/background-removal-data/${PACKAGE_VERSION}/dist/\"\\n  ).transform((val) => {\\n    return val.replace(\"${PACKAGE_NAME}\", package_default.name).replace(\"${PACKAGE_VERSION}\", package_default.version);\\n  }),\\n  debug: z.boolean().default(false).describe(\"Whether to enable debug logging.\"),\\n  rescale: z.boolean().default(true).describe(\"Whether to rescale the image.\"),\\n  device: z.enum([\"cpu\", \"gpu\"]).default(\"cpu\").describe(\"The device to run the model on.\"),\\n  proxyToWorker: z.boolean().default(false).describe(\"Whether to proxy inference to a web worker.\"),\\n  fetchArgs: z.any().default({}).describe(\"Arguments to pass to fetch when loading the model.\"),\\n  progress: z.function().args(z.string(), z.number(), z.number()).returns(z.void()).describe(\"Progress callback.\").optional(),\\n  model: z.preprocess(\\n    (val) => {\\n      switch (val) {\\n        case \"large\":\\n          return \"isnet\";\\n        case \"small\":\\n          return \"isnet_quint8\";\\n        case \"medium\":\\n          return \"isnet_fp16\";\\n        default:\\n          return val;\\n      }\\n    },\\n    z.enum([\"isnet\", \"isnet_fp16\", \"isnet_quint8\"])\\n  ).default(\"medium\"),\\n  output: z.object({\\n    format: z.enum([\\n      \"image/png\",\\n      \"image/jpeg\",\\n      \"image/webp\",\\n      \"image/x-rgba8\",\\n      \"image/x-alpha8\"\\n    ]).default(\"image/png\"),\\n    quality: z.number().default(0.8)\\n  }).default({})\\n}).default({}).transform');\n$RefreshReg$(_c3, \"ConfigSchema\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AaW1nbHkvYmFja2dyb3VuZC1yZW1vdmFsL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBLElBQUlBLFdBQVdDLE9BQU9DLE1BQU07QUFDNUIsSUFBSUMsWUFBWUYsT0FBT0csY0FBYztBQUNyQyxJQUFJQyxtQkFBbUJKLE9BQU9LLHdCQUF3QjtBQUN0RCxJQUFJQyxvQkFBb0JOLE9BQU9PLG1CQUFtQjtBQUNsRCxJQUFJQyxlQUFlUixPQUFPUyxjQUFjO0FBQ3hDLElBQUlDLGVBQWVWLE9BQU9XLFNBQVMsQ0FBQ0MsY0FBYztBQUNsRCxJQUFJQyxhQUFhLENBQUNDLElBQUlDLE1BQVEsU0FBU0M7UUFDckMsT0FBT0QsT0FBTyxDQUFDLEdBQUdELEVBQUUsQ0FBQ1Isa0JBQWtCUSxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQ0MsTUFBTTtZQUFFRSxTQUFTLENBQUM7UUFBRSxHQUFHQSxPQUFPLEVBQUVGLE1BQU1BLElBQUlFLE9BQU87SUFDcEc7QUFDQSxJQUFJQyxjQUFjLENBQUNDLElBQUlDLE1BQU1DLFFBQVFDO0lBQ25DLElBQUlGLFFBQVEsT0FBT0EsU0FBUyxZQUFZLE9BQU9BLFNBQVMsWUFBWTtRQUNsRSxLQUFLLElBQUlHLE9BQU9qQixrQkFBa0JjLE1BQ2hDLElBQUksQ0FBQ1YsYUFBYWMsSUFBSSxDQUFDTCxJQUFJSSxRQUFRQSxRQUFRRixRQUN6Q25CLFVBQVVpQixJQUFJSSxLQUFLO1lBQUVFLEtBQUssSUFBTUwsSUFBSSxDQUFDRyxJQUFJO1lBQUVHLFlBQVksQ0FBRUosQ0FBQUEsT0FBT2xCLGlCQUFpQmdCLE1BQU1HLElBQUcsS0FBTUQsS0FBS0ksVUFBVTtRQUFDO0lBQ3RIO0lBQ0EsT0FBT1A7QUFDVDtBQUNBLElBQUlRLFVBQVUsQ0FBQ1osS0FBS2EsWUFBWUMsU0FBWUEsQ0FBQUEsU0FBU2QsT0FBTyxPQUFPaEIsU0FBU1MsYUFBYU8sUUFB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QkFDUixRQUFRO2dCQUNSLFFBQVE7Z0JBQ1IsUUFBUTtnQkFDUixRQUFRO2dCQUNSLFFBQVE7Z0JBQ1IsUUFBUTtnQkFDUixRQUFRO2dCQUNSLFFBQVE7Z0JBQ1IsUUFBUTtnQkFDUixRQUFRO2dCQUNSLFFBQVE7Z0JBQ1IsUUFBUTtnQkFDUixRQUFRO2dCQUNSLFFBQVE7Z0JBQ1IsUUFBUTtnQkFDUixRQUFRO2dCQUNSLFFBQVE7Z0JBQ1IsUUFBUTtnQkFDUixRQUFRO2dCQUNSLFFBQVE7Z0JBQ1IsUUFBUTtnQkFDUixRQUFRO2dCQUNSLFFBQVE7Z0JBQ1IsUUFBUTtnQkFDUixRQUFRO2dCQUNSLFFBQVE7Z0JBQ1IsUUFBUTtnQkFDUixRQUFRO2dCQUNSLFFBQVE7Z0JBQ1IsUUFBUTtnQkFDUixRQUFRO2dCQUNSLFFBQVE7Z0JBQ1IsUUFBUTtnQkFDUixRQUFRO2dCQUNSLFFBQVE7Z0JBQ1IsUUFBUTtnQkFDUixRQUFRO2dCQUNSLFFBQVE7Z0JBQ1IsUUFBUTtnQkFDUixRQUFRO2dCQUNSLFFBQVE7Z0JBQ1IsUUFBUTtnQkFDUixRQUFRO2dCQUNSLFFBQVE7Z0JBQ1IsUUFBUTtnQkFDUiwwQkFBMEI7Z0JBQzFCLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNWLEtBQVU7Z0JBQ1YsS0FBVTtnQkFDVixLQUFVO2dCQUNW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R0QsVUFBVTl0RCxJQUFJLENBQUNndUQsVUFBVSxFQUFFO0lBQzlEO0lBQ0EsTUFBTWhCLFdBQVcsTUFBTXJzQixZQUNyQkMsYUFDQTRELE9BQU8wRSxNQUFNLENBQUNySSxPQUFPLEVBQ3JCMkQsT0FBTzBFLE1BQU0sQ0FBQ3BJLE1BQU07SUFFdEIsT0FBT2tzQjtBQUNUO0FBUUUsQ0FDRjs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQW1CQSxJQUNBLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGltZ2x5L2JhY2tncm91bmQtcmVtb3ZhbC9kaXN0L2luZGV4Lm1qcz9iOWMyIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19jb21tb25KUyA9IChjYiwgbW9kKSA9PiBmdW5jdGlvbiBfX3JlcXVpcmUoKSB7XG4gIHJldHVybiBtb2QgfHwgKDAsIGNiW19fZ2V0T3duUHJvcE5hbWVzKGNiKVswXV0pKChtb2QgPSB7IGV4cG9ydHM6IHt9IH0pLmV4cG9ydHMsIG1vZCksIG1vZC5leHBvcnRzO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvRVNNID0gKG1vZCwgaXNOb2RlTW9kZSwgdGFyZ2V0KSA9PiAodGFyZ2V0ID0gbW9kICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kKSkgOiB7fSwgX19jb3B5UHJvcHMoXG4gIC8vIElmIHRoZSBpbXBvcnRlciBpcyBpbiBub2RlIGNvbXBhdGliaWxpdHkgbW9kZSBvciB0aGlzIGlzIG5vdCBhbiBFU01cbiAgLy8gZmlsZSB0aGF0IGhhcyBiZWVuIGNvbnZlcnRlZCB0byBhIENvbW1vbkpTIGZpbGUgdXNpbmcgYSBCYWJlbC1cbiAgLy8gY29tcGF0aWJsZSB0cmFuc2Zvcm0gKGkuZS4gXCJfX2VzTW9kdWxlXCIgaGFzIG5vdCBiZWVuIHNldCksIHRoZW4gc2V0XG4gIC8vIFwiZGVmYXVsdFwiIHRvIHRoZSBDb21tb25KUyBcIm1vZHVsZS5leHBvcnRzXCIgZm9yIG5vZGUgY29tcGF0aWJpbGl0eS5cbiAgaXNOb2RlTW9kZSB8fCAhbW9kIHx8ICFtb2QuX19lc01vZHVsZSA/IF9fZGVmUHJvcCh0YXJnZXQsIFwiZGVmYXVsdFwiLCB7IHZhbHVlOiBtb2QsIGVudW1lcmFibGU6IHRydWUgfSkgOiB0YXJnZXQsXG4gIG1vZFxuKSk7XG5cbi8vIC4uLy4uL25vZGVfbW9kdWxlcy9sb2Rhc2gvbG9kYXNoLmpzXG52YXIgcmVxdWlyZV9sb2Rhc2ggPSBfX2NvbW1vbkpTKHtcbiAgXCIuLi8uLi9ub2RlX21vZHVsZXMvbG9kYXNoL2xvZGFzaC5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIChmdW5jdGlvbigpIHtcbiAgICAgIHZhciB1bmRlZmluZWQyO1xuICAgICAgdmFyIFZFUlNJT04gPSBcIjQuMTcuMjFcIjtcbiAgICAgIHZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuICAgICAgdmFyIENPUkVfRVJST1JfVEVYVCA9IFwiVW5zdXBwb3J0ZWQgY29yZS1qcyB1c2UuIFRyeSBodHRwczovL25wbXMuaW8vc2VhcmNoP3E9cG9ueWZpbGwuXCIsIEZVTkNfRVJST1JfVEVYVCA9IFwiRXhwZWN0ZWQgYSBmdW5jdGlvblwiLCBJTlZBTElEX1RFTVBMX1ZBUl9FUlJPUl9URVhUID0gXCJJbnZhbGlkIGB2YXJpYWJsZWAgb3B0aW9uIHBhc3NlZCBpbnRvIGBfLnRlbXBsYXRlYFwiO1xuICAgICAgdmFyIEhBU0hfVU5ERUZJTkVEID0gXCJfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fXCI7XG4gICAgICB2YXIgTUFYX01FTU9JWkVfU0laRSA9IDUwMDtcbiAgICAgIHZhciBQTEFDRUhPTERFUiA9IFwiX19sb2Rhc2hfcGxhY2Vob2xkZXJfX1wiO1xuICAgICAgdmFyIENMT05FX0RFRVBfRkxBRyA9IDEsIENMT05FX0ZMQVRfRkxBRyA9IDIsIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG4gICAgICB2YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLCBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcbiAgICAgIHZhciBXUkFQX0JJTkRfRkxBRyA9IDEsIFdSQVBfQklORF9LRVlfRkxBRyA9IDIsIFdSQVBfQ1VSUllfQk9VTkRfRkxBRyA9IDQsIFdSQVBfQ1VSUllfRkxBRyA9IDgsIFdSQVBfQ1VSUllfUklHSFRfRkxBRyA9IDE2LCBXUkFQX1BBUlRJQUxfRkxBRyA9IDMyLCBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyA9IDY0LCBXUkFQX0FSWV9GTEFHID0gMTI4LCBXUkFQX1JFQVJHX0ZMQUcgPSAyNTYsIFdSQVBfRkxJUF9GTEFHID0gNTEyO1xuICAgICAgdmFyIERFRkFVTFRfVFJVTkNfTEVOR1RIID0gMzAsIERFRkFVTFRfVFJVTkNfT01JU1NJT04gPSBcIi4uLlwiO1xuICAgICAgdmFyIEhPVF9DT1VOVCA9IDgwMCwgSE9UX1NQQU4gPSAxNjtcbiAgICAgIHZhciBMQVpZX0ZJTFRFUl9GTEFHID0gMSwgTEFaWV9NQVBfRkxBRyA9IDIsIExBWllfV0hJTEVfRkxBRyA9IDM7XG4gICAgICB2YXIgSU5GSU5JVFkgPSAxIC8gMCwgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTEsIE1BWF9JTlRFR0VSID0gMTc5NzY5MzEzNDg2MjMxNTdlMjkyLCBOQU4gPSAwIC8gMDtcbiAgICAgIHZhciBNQVhfQVJSQVlfTEVOR1RIID0gNDI5NDk2NzI5NSwgTUFYX0FSUkFZX0lOREVYID0gTUFYX0FSUkFZX0xFTkdUSCAtIDEsIEhBTEZfTUFYX0FSUkFZX0xFTkdUSCA9IE1BWF9BUlJBWV9MRU5HVEggPj4+IDE7XG4gICAgICB2YXIgd3JhcEZsYWdzID0gW1xuICAgICAgICBbXCJhcnlcIiwgV1JBUF9BUllfRkxBR10sXG4gICAgICAgIFtcImJpbmRcIiwgV1JBUF9CSU5EX0ZMQUddLFxuICAgICAgICBbXCJiaW5kS2V5XCIsIFdSQVBfQklORF9LRVlfRkxBR10sXG4gICAgICAgIFtcImN1cnJ5XCIsIFdSQVBfQ1VSUllfRkxBR10sXG4gICAgICAgIFtcImN1cnJ5UmlnaHRcIiwgV1JBUF9DVVJSWV9SSUdIVF9GTEFHXSxcbiAgICAgICAgW1wiZmxpcFwiLCBXUkFQX0ZMSVBfRkxBR10sXG4gICAgICAgIFtcInBhcnRpYWxcIiwgV1JBUF9QQVJUSUFMX0ZMQUddLFxuICAgICAgICBbXCJwYXJ0aWFsUmlnaHRcIiwgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUddLFxuICAgICAgICBbXCJyZWFyZ1wiLCBXUkFQX1JFQVJHX0ZMQUddXG4gICAgICBdO1xuICAgICAgdmFyIGFyZ3NUYWcgPSBcIltvYmplY3QgQXJndW1lbnRzXVwiLCBhcnJheVRhZyA9IFwiW29iamVjdCBBcnJheV1cIiwgYXN5bmNUYWcgPSBcIltvYmplY3QgQXN5bmNGdW5jdGlvbl1cIiwgYm9vbFRhZyA9IFwiW29iamVjdCBCb29sZWFuXVwiLCBkYXRlVGFnID0gXCJbb2JqZWN0IERhdGVdXCIsIGRvbUV4Y1RhZyA9IFwiW29iamVjdCBET01FeGNlcHRpb25dXCIsIGVycm9yVGFnID0gXCJbb2JqZWN0IEVycm9yXVwiLCBmdW5jVGFnID0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiLCBnZW5UYWcgPSBcIltvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dXCIsIG1hcFRhZyA9IFwiW29iamVjdCBNYXBdXCIsIG51bWJlclRhZyA9IFwiW29iamVjdCBOdW1iZXJdXCIsIG51bGxUYWcgPSBcIltvYmplY3QgTnVsbF1cIiwgb2JqZWN0VGFnID0gXCJbb2JqZWN0IE9iamVjdF1cIiwgcHJvbWlzZVRhZyA9IFwiW29iamVjdCBQcm9taXNlXVwiLCBwcm94eVRhZyA9IFwiW29iamVjdCBQcm94eV1cIiwgcmVnZXhwVGFnID0gXCJbb2JqZWN0IFJlZ0V4cF1cIiwgc2V0VGFnID0gXCJbb2JqZWN0IFNldF1cIiwgc3RyaW5nVGFnID0gXCJbb2JqZWN0IFN0cmluZ11cIiwgc3ltYm9sVGFnID0gXCJbb2JqZWN0IFN5bWJvbF1cIiwgdW5kZWZpbmVkVGFnID0gXCJbb2JqZWN0IFVuZGVmaW5lZF1cIiwgd2Vha01hcFRhZyA9IFwiW29iamVjdCBXZWFrTWFwXVwiLCB3ZWFrU2V0VGFnID0gXCJbb2JqZWN0IFdlYWtTZXRdXCI7XG4gICAgICB2YXIgYXJyYXlCdWZmZXJUYWcgPSBcIltvYmplY3QgQXJyYXlCdWZmZXJdXCIsIGRhdGFWaWV3VGFnID0gXCJbb2JqZWN0IERhdGFWaWV3XVwiLCBmbG9hdDMyVGFnID0gXCJbb2JqZWN0IEZsb2F0MzJBcnJheV1cIiwgZmxvYXQ2NFRhZyA9IFwiW29iamVjdCBGbG9hdDY0QXJyYXldXCIsIGludDhUYWcgPSBcIltvYmplY3QgSW50OEFycmF5XVwiLCBpbnQxNlRhZyA9IFwiW29iamVjdCBJbnQxNkFycmF5XVwiLCBpbnQzMlRhZyA9IFwiW29iamVjdCBJbnQzMkFycmF5XVwiLCB1aW50OFRhZyA9IFwiW29iamVjdCBVaW50OEFycmF5XVwiLCB1aW50OENsYW1wZWRUYWcgPSBcIltvYmplY3QgVWludDhDbGFtcGVkQXJyYXldXCIsIHVpbnQxNlRhZyA9IFwiW29iamVjdCBVaW50MTZBcnJheV1cIiwgdWludDMyVGFnID0gXCJbb2JqZWN0IFVpbnQzMkFycmF5XVwiO1xuICAgICAgdmFyIHJlRW1wdHlTdHJpbmdMZWFkaW5nID0gL1xcYl9fcCBcXCs9ICcnOy9nLCByZUVtcHR5U3RyaW5nTWlkZGxlID0gL1xcYihfX3AgXFwrPSkgJycgXFwrL2csIHJlRW1wdHlTdHJpbmdUcmFpbGluZyA9IC8oX19lXFwoLio/XFwpfFxcYl9fdFxcKSkgXFwrXFxuJyc7L2c7XG4gICAgICB2YXIgcmVFc2NhcGVkSHRtbCA9IC8mKD86YW1wfGx0fGd0fHF1b3R8IzM5KTsvZywgcmVVbmVzY2FwZWRIdG1sID0gL1smPD5cIiddL2csIHJlSGFzRXNjYXBlZEh0bWwgPSBSZWdFeHAocmVFc2NhcGVkSHRtbC5zb3VyY2UpLCByZUhhc1VuZXNjYXBlZEh0bWwgPSBSZWdFeHAocmVVbmVzY2FwZWRIdG1sLnNvdXJjZSk7XG4gICAgICB2YXIgcmVFc2NhcGUgPSAvPCUtKFtcXHNcXFNdKz8pJT4vZywgcmVFdmFsdWF0ZSA9IC88JShbXFxzXFxTXSs/KSU+L2csIHJlSW50ZXJwb2xhdGUgPSAvPCU9KFtcXHNcXFNdKz8pJT4vZztcbiAgICAgIHZhciByZUlzRGVlcFByb3AgPSAvXFwufFxcWyg/OlteW1xcXV0qfChbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqP1xcMSlcXF0vLCByZUlzUGxhaW5Qcm9wID0gL15cXHcqJC8sIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG4gICAgICB2YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nLCByZUhhc1JlZ0V4cENoYXIgPSBSZWdFeHAocmVSZWdFeHBDaGFyLnNvdXJjZSk7XG4gICAgICB2YXIgcmVUcmltU3RhcnQgPSAvXlxccysvO1xuICAgICAgdmFyIHJlV2hpdGVzcGFjZSA9IC9cXHMvO1xuICAgICAgdmFyIHJlV3JhcENvbW1lbnQgPSAvXFx7KD86XFxuXFwvXFwqIFxcW3dyYXBwZWQgd2l0aCAuK1xcXSBcXCpcXC8pP1xcbj8vLCByZVdyYXBEZXRhaWxzID0gL1xce1xcblxcL1xcKiBcXFt3cmFwcGVkIHdpdGggKC4rKVxcXSBcXCovLCByZVNwbGl0RGV0YWlscyA9IC8sPyAmIC87XG4gICAgICB2YXIgcmVBc2NpaVdvcmQgPSAvW15cXHgwMC1cXHgyZlxceDNhLVxceDQwXFx4NWItXFx4NjBcXHg3Yi1cXHg3Zl0rL2c7XG4gICAgICB2YXIgcmVGb3JiaWRkZW5JZGVudGlmaWVyQ2hhcnMgPSAvWygpPSx7fVxcW1xcXVxcL1xcc10vO1xuICAgICAgdmFyIHJlRXNjYXBlQ2hhciA9IC9cXFxcKFxcXFwpPy9nO1xuICAgICAgdmFyIHJlRXNUZW1wbGF0ZSA9IC9cXCRcXHsoW15cXFxcfV0qKD86XFxcXC5bXlxcXFx9XSopKilcXH0vZztcbiAgICAgIHZhciByZUZsYWdzID0gL1xcdyokLztcbiAgICAgIHZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG4gICAgICB2YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcbiAgICAgIHZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuICAgICAgdmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG4gICAgICB2YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuICAgICAgdmFyIHJlTGF0aW4gPSAvW1xceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHhmZlxcdTAxMDAtXFx1MDE3Zl0vZztcbiAgICAgIHZhciByZU5vTWF0Y2ggPSAvKCReKS87XG4gICAgICB2YXIgcmVVbmVzY2FwZWRTdHJpbmcgPSAvWydcXG5cXHJcXHUyMDI4XFx1MjAyOVxcXFxdL2c7XG4gICAgICB2YXIgcnNBc3RyYWxSYW5nZSA9IFwiXFxcXHVkODAwLVxcXFx1ZGZmZlwiLCByc0NvbWJvTWFya3NSYW5nZSA9IFwiXFxcXHUwMzAwLVxcXFx1MDM2ZlwiLCByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSBcIlxcXFx1ZmUyMC1cXFxcdWZlMmZcIiwgcnNDb21ib1N5bWJvbHNSYW5nZSA9IFwiXFxcXHUyMGQwLVxcXFx1MjBmZlwiLCByc0NvbWJvUmFuZ2UgPSByc0NvbWJvTWFya3NSYW5nZSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UsIHJzRGluZ2JhdFJhbmdlID0gXCJcXFxcdTI3MDAtXFxcXHUyN2JmXCIsIHJzTG93ZXJSYW5nZSA9IFwiYS16XFxcXHhkZi1cXFxceGY2XFxcXHhmOC1cXFxceGZmXCIsIHJzTWF0aE9wUmFuZ2UgPSBcIlxcXFx4YWNcXFxceGIxXFxcXHhkN1xcXFx4ZjdcIiwgcnNOb25DaGFyUmFuZ2UgPSBcIlxcXFx4MDAtXFxcXHgyZlxcXFx4M2EtXFxcXHg0MFxcXFx4NWItXFxcXHg2MFxcXFx4N2ItXFxcXHhiZlwiLCByc1B1bmN0dWF0aW9uUmFuZ2UgPSBcIlxcXFx1MjAwMC1cXFxcdTIwNmZcIiwgcnNTcGFjZVJhbmdlID0gXCIgXFxcXHRcXFxceDBiXFxcXGZcXFxceGEwXFxcXHVmZWZmXFxcXG5cXFxcclxcXFx1MjAyOFxcXFx1MjAyOVxcXFx1MTY4MFxcXFx1MTgwZVxcXFx1MjAwMFxcXFx1MjAwMVxcXFx1MjAwMlxcXFx1MjAwM1xcXFx1MjAwNFxcXFx1MjAwNVxcXFx1MjAwNlxcXFx1MjAwN1xcXFx1MjAwOFxcXFx1MjAwOVxcXFx1MjAwYVxcXFx1MjAyZlxcXFx1MjA1ZlxcXFx1MzAwMFwiLCByc1VwcGVyUmFuZ2UgPSBcIkEtWlxcXFx4YzAtXFxcXHhkNlxcXFx4ZDgtXFxcXHhkZVwiLCByc1ZhclJhbmdlID0gXCJcXFxcdWZlMGVcXFxcdWZlMGZcIiwgcnNCcmVha1JhbmdlID0gcnNNYXRoT3BSYW5nZSArIHJzTm9uQ2hhclJhbmdlICsgcnNQdW5jdHVhdGlvblJhbmdlICsgcnNTcGFjZVJhbmdlO1xuICAgICAgdmFyIHJzQXBvcyA9IFwiWydcXHUyMDE5XVwiLCByc0FzdHJhbCA9IFwiW1wiICsgcnNBc3RyYWxSYW5nZSArIFwiXVwiLCByc0JyZWFrID0gXCJbXCIgKyByc0JyZWFrUmFuZ2UgKyBcIl1cIiwgcnNDb21ibyA9IFwiW1wiICsgcnNDb21ib1JhbmdlICsgXCJdXCIsIHJzRGlnaXRzID0gXCJcXFxcZCtcIiwgcnNEaW5nYmF0ID0gXCJbXCIgKyByc0RpbmdiYXRSYW5nZSArIFwiXVwiLCByc0xvd2VyID0gXCJbXCIgKyByc0xvd2VyUmFuZ2UgKyBcIl1cIiwgcnNNaXNjID0gXCJbXlwiICsgcnNBc3RyYWxSYW5nZSArIHJzQnJlYWtSYW5nZSArIHJzRGlnaXRzICsgcnNEaW5nYmF0UmFuZ2UgKyByc0xvd2VyUmFuZ2UgKyByc1VwcGVyUmFuZ2UgKyBcIl1cIiwgcnNGaXR6ID0gXCJcXFxcdWQ4M2NbXFxcXHVkZmZiLVxcXFx1ZGZmZl1cIiwgcnNNb2RpZmllciA9IFwiKD86XCIgKyByc0NvbWJvICsgXCJ8XCIgKyByc0ZpdHogKyBcIilcIiwgcnNOb25Bc3RyYWwgPSBcIlteXCIgKyByc0FzdHJhbFJhbmdlICsgXCJdXCIsIHJzUmVnaW9uYWwgPSBcIig/OlxcXFx1ZDgzY1tcXFxcdWRkZTYtXFxcXHVkZGZmXSl7Mn1cIiwgcnNTdXJyUGFpciA9IFwiW1xcXFx1ZDgwMC1cXFxcdWRiZmZdW1xcXFx1ZGMwMC1cXFxcdWRmZmZdXCIsIHJzVXBwZXIgPSBcIltcIiArIHJzVXBwZXJSYW5nZSArIFwiXVwiLCByc1pXSiA9IFwiXFxcXHUyMDBkXCI7XG4gICAgICB2YXIgcnNNaXNjTG93ZXIgPSBcIig/OlwiICsgcnNMb3dlciArIFwifFwiICsgcnNNaXNjICsgXCIpXCIsIHJzTWlzY1VwcGVyID0gXCIoPzpcIiArIHJzVXBwZXIgKyBcInxcIiArIHJzTWlzYyArIFwiKVwiLCByc09wdENvbnRyTG93ZXIgPSBcIig/OlwiICsgcnNBcG9zICsgXCIoPzpkfGxsfG18cmV8c3x0fHZlKSk/XCIsIHJzT3B0Q29udHJVcHBlciA9IFwiKD86XCIgKyByc0Fwb3MgKyBcIig/OkR8TEx8TXxSRXxTfFR8VkUpKT9cIiwgcmVPcHRNb2QgPSByc01vZGlmaWVyICsgXCI/XCIsIHJzT3B0VmFyID0gXCJbXCIgKyByc1ZhclJhbmdlICsgXCJdP1wiLCByc09wdEpvaW4gPSBcIig/OlwiICsgcnNaV0ogKyBcIig/OlwiICsgW3JzTm9uQXN0cmFsLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKFwifFwiKSArIFwiKVwiICsgcnNPcHRWYXIgKyByZU9wdE1vZCArIFwiKSpcIiwgcnNPcmRMb3dlciA9IFwiXFxcXGQqKD86MXN0fDJuZHwzcmR8KD8hWzEyM10pXFxcXGR0aCkoPz1cXFxcYnxbQS1aX10pXCIsIHJzT3JkVXBwZXIgPSBcIlxcXFxkKig/OjFTVHwyTkR8M1JEfCg/IVsxMjNdKVxcXFxkVEgpKD89XFxcXGJ8W2Etel9dKVwiLCByc1NlcSA9IHJzT3B0VmFyICsgcmVPcHRNb2QgKyByc09wdEpvaW4sIHJzRW1vamkgPSBcIig/OlwiICsgW3JzRGluZ2JhdCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbihcInxcIikgKyBcIilcIiArIHJzU2VxLCByc1N5bWJvbCA9IFwiKD86XCIgKyBbcnNOb25Bc3RyYWwgKyByc0NvbWJvICsgXCI/XCIsIHJzQ29tYm8sIHJzUmVnaW9uYWwsIHJzU3VyclBhaXIsIHJzQXN0cmFsXS5qb2luKFwifFwiKSArIFwiKVwiO1xuICAgICAgdmFyIHJlQXBvcyA9IFJlZ0V4cChyc0Fwb3MsIFwiZ1wiKTtcbiAgICAgIHZhciByZUNvbWJvTWFyayA9IFJlZ0V4cChyc0NvbWJvLCBcImdcIik7XG4gICAgICB2YXIgcmVVbmljb2RlID0gUmVnRXhwKHJzRml0eiArIFwiKD89XCIgKyByc0ZpdHogKyBcIil8XCIgKyByc1N5bWJvbCArIHJzU2VxLCBcImdcIik7XG4gICAgICB2YXIgcmVVbmljb2RlV29yZCA9IFJlZ0V4cChbXG4gICAgICAgIHJzVXBwZXIgKyBcIj9cIiArIHJzTG93ZXIgKyBcIitcIiArIHJzT3B0Q29udHJMb3dlciArIFwiKD89XCIgKyBbcnNCcmVhaywgcnNVcHBlciwgXCIkXCJdLmpvaW4oXCJ8XCIpICsgXCIpXCIsXG4gICAgICAgIHJzTWlzY1VwcGVyICsgXCIrXCIgKyByc09wdENvbnRyVXBwZXIgKyBcIig/PVwiICsgW3JzQnJlYWssIHJzVXBwZXIgKyByc01pc2NMb3dlciwgXCIkXCJdLmpvaW4oXCJ8XCIpICsgXCIpXCIsXG4gICAgICAgIHJzVXBwZXIgKyBcIj9cIiArIHJzTWlzY0xvd2VyICsgXCIrXCIgKyByc09wdENvbnRyTG93ZXIsXG4gICAgICAgIHJzVXBwZXIgKyBcIitcIiArIHJzT3B0Q29udHJVcHBlcixcbiAgICAgICAgcnNPcmRVcHBlcixcbiAgICAgICAgcnNPcmRMb3dlcixcbiAgICAgICAgcnNEaWdpdHMsXG4gICAgICAgIHJzRW1vamlcbiAgICAgIF0uam9pbihcInxcIiksIFwiZ1wiKTtcbiAgICAgIHZhciByZUhhc1VuaWNvZGUgPSBSZWdFeHAoXCJbXCIgKyByc1pXSiArIHJzQXN0cmFsUmFuZ2UgKyByc0NvbWJvUmFuZ2UgKyByc1ZhclJhbmdlICsgXCJdXCIpO1xuICAgICAgdmFyIHJlSGFzVW5pY29kZVdvcmQgPSAvW2Etel1bQS1aXXxbQS1aXXsyfVthLXpdfFswLTldW2EtekEtWl18W2EtekEtWl1bMC05XXxbXmEtekEtWjAtOSBdLztcbiAgICAgIHZhciBjb250ZXh0UHJvcHMgPSBbXG4gICAgICAgIFwiQXJyYXlcIixcbiAgICAgICAgXCJCdWZmZXJcIixcbiAgICAgICAgXCJEYXRhVmlld1wiLFxuICAgICAgICBcIkRhdGVcIixcbiAgICAgICAgXCJFcnJvclwiLFxuICAgICAgICBcIkZsb2F0MzJBcnJheVwiLFxuICAgICAgICBcIkZsb2F0NjRBcnJheVwiLFxuICAgICAgICBcIkZ1bmN0aW9uXCIsXG4gICAgICAgIFwiSW50OEFycmF5XCIsXG4gICAgICAgIFwiSW50MTZBcnJheVwiLFxuICAgICAgICBcIkludDMyQXJyYXlcIixcbiAgICAgICAgXCJNYXBcIixcbiAgICAgICAgXCJNYXRoXCIsXG4gICAgICAgIFwiT2JqZWN0XCIsXG4gICAgICAgIFwiUHJvbWlzZVwiLFxuICAgICAgICBcIlJlZ0V4cFwiLFxuICAgICAgICBcIlNldFwiLFxuICAgICAgICBcIlN0cmluZ1wiLFxuICAgICAgICBcIlN5bWJvbFwiLFxuICAgICAgICBcIlR5cGVFcnJvclwiLFxuICAgICAgICBcIlVpbnQ4QXJyYXlcIixcbiAgICAgICAgXCJVaW50OENsYW1wZWRBcnJheVwiLFxuICAgICAgICBcIlVpbnQxNkFycmF5XCIsXG4gICAgICAgIFwiVWludDMyQXJyYXlcIixcbiAgICAgICAgXCJXZWFrTWFwXCIsXG4gICAgICAgIFwiX1wiLFxuICAgICAgICBcImNsZWFyVGltZW91dFwiLFxuICAgICAgICBcImlzRmluaXRlXCIsXG4gICAgICAgIFwicGFyc2VJbnRcIixcbiAgICAgICAgXCJzZXRUaW1lb3V0XCJcbiAgICAgIF07XG4gICAgICB2YXIgdGVtcGxhdGVDb3VudGVyID0gLTE7XG4gICAgICB2YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbiAgICAgIHR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG4gICAgICB0eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPSB0eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9IHR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID0gdHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG4gICAgICB2YXIgY2xvbmVhYmxlVGFncyA9IHt9O1xuICAgICAgY2xvbmVhYmxlVGFnc1thcmdzVGFnXSA9IGNsb25lYWJsZVRhZ3NbYXJyYXlUYWddID0gY2xvbmVhYmxlVGFnc1thcnJheUJ1ZmZlclRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGFWaWV3VGFnXSA9IGNsb25lYWJsZVRhZ3NbYm9vbFRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGVUYWddID0gY2xvbmVhYmxlVGFnc1tmbG9hdDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZmxvYXQ2NFRhZ10gPSBjbG9uZWFibGVUYWdzW2ludDhUYWddID0gY2xvbmVhYmxlVGFnc1tpbnQxNlRhZ10gPSBjbG9uZWFibGVUYWdzW2ludDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbbWFwVGFnXSA9IGNsb25lYWJsZVRhZ3NbbnVtYmVyVGFnXSA9IGNsb25lYWJsZVRhZ3Nbb2JqZWN0VGFnXSA9IGNsb25lYWJsZVRhZ3NbcmVnZXhwVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc2V0VGFnXSA9IGNsb25lYWJsZVRhZ3Nbc3RyaW5nVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc3ltYm9sVGFnXSA9IGNsb25lYWJsZVRhZ3NbdWludDhUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50OENsYW1wZWRUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50MTZUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbiAgICAgIGNsb25lYWJsZVRhZ3NbZXJyb3JUYWddID0gY2xvbmVhYmxlVGFnc1tmdW5jVGFnXSA9IGNsb25lYWJsZVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcbiAgICAgIHZhciBkZWJ1cnJlZExldHRlcnMgPSB7XG4gICAgICAgIC8vIExhdGluLTEgU3VwcGxlbWVudCBibG9jay5cbiAgICAgICAgXCJcXHhDMFwiOiBcIkFcIixcbiAgICAgICAgXCJcXHhDMVwiOiBcIkFcIixcbiAgICAgICAgXCJcXHhDMlwiOiBcIkFcIixcbiAgICAgICAgXCJcXHhDM1wiOiBcIkFcIixcbiAgICAgICAgXCJcXHhDNFwiOiBcIkFcIixcbiAgICAgICAgXCJcXHhDNVwiOiBcIkFcIixcbiAgICAgICAgXCJcXHhFMFwiOiBcImFcIixcbiAgICAgICAgXCJcXHhFMVwiOiBcImFcIixcbiAgICAgICAgXCJcXHhFMlwiOiBcImFcIixcbiAgICAgICAgXCJcXHhFM1wiOiBcImFcIixcbiAgICAgICAgXCJcXHhFNFwiOiBcImFcIixcbiAgICAgICAgXCJcXHhFNVwiOiBcImFcIixcbiAgICAgICAgXCJcXHhDN1wiOiBcIkNcIixcbiAgICAgICAgXCJcXHhFN1wiOiBcImNcIixcbiAgICAgICAgXCJcXHhEMFwiOiBcIkRcIixcbiAgICAgICAgXCJcXHhGMFwiOiBcImRcIixcbiAgICAgICAgXCJcXHhDOFwiOiBcIkVcIixcbiAgICAgICAgXCJcXHhDOVwiOiBcIkVcIixcbiAgICAgICAgXCJcXHhDQVwiOiBcIkVcIixcbiAgICAgICAgXCJcXHhDQlwiOiBcIkVcIixcbiAgICAgICAgXCJcXHhFOFwiOiBcImVcIixcbiAgICAgICAgXCJcXHhFOVwiOiBcImVcIixcbiAgICAgICAgXCJcXHhFQVwiOiBcImVcIixcbiAgICAgICAgXCJcXHhFQlwiOiBcImVcIixcbiAgICAgICAgXCJcXHhDQ1wiOiBcIklcIixcbiAgICAgICAgXCJcXHhDRFwiOiBcIklcIixcbiAgICAgICAgXCJcXHhDRVwiOiBcIklcIixcbiAgICAgICAgXCJcXHhDRlwiOiBcIklcIixcbiAgICAgICAgXCJcXHhFQ1wiOiBcImlcIixcbiAgICAgICAgXCJcXHhFRFwiOiBcImlcIixcbiAgICAgICAgXCJcXHhFRVwiOiBcImlcIixcbiAgICAgICAgXCJcXHhFRlwiOiBcImlcIixcbiAgICAgICAgXCJcXHhEMVwiOiBcIk5cIixcbiAgICAgICAgXCJcXHhGMVwiOiBcIm5cIixcbiAgICAgICAgXCJcXHhEMlwiOiBcIk9cIixcbiAgICAgICAgXCJcXHhEM1wiOiBcIk9cIixcbiAgICAgICAgXCJcXHhENFwiOiBcIk9cIixcbiAgICAgICAgXCJcXHhENVwiOiBcIk9cIixcbiAgICAgICAgXCJcXHhENlwiOiBcIk9cIixcbiAgICAgICAgXCJcXHhEOFwiOiBcIk9cIixcbiAgICAgICAgXCJcXHhGMlwiOiBcIm9cIixcbiAgICAgICAgXCJcXHhGM1wiOiBcIm9cIixcbiAgICAgICAgXCJcXHhGNFwiOiBcIm9cIixcbiAgICAgICAgXCJcXHhGNVwiOiBcIm9cIixcbiAgICAgICAgXCJcXHhGNlwiOiBcIm9cIixcbiAgICAgICAgXCJcXHhGOFwiOiBcIm9cIixcbiAgICAgICAgXCJcXHhEOVwiOiBcIlVcIixcbiAgICAgICAgXCJcXHhEQVwiOiBcIlVcIixcbiAgICAgICAgXCJcXHhEQlwiOiBcIlVcIixcbiAgICAgICAgXCJcXHhEQ1wiOiBcIlVcIixcbiAgICAgICAgXCJcXHhGOVwiOiBcInVcIixcbiAgICAgICAgXCJcXHhGQVwiOiBcInVcIixcbiAgICAgICAgXCJcXHhGQlwiOiBcInVcIixcbiAgICAgICAgXCJcXHhGQ1wiOiBcInVcIixcbiAgICAgICAgXCJcXHhERFwiOiBcIllcIixcbiAgICAgICAgXCJcXHhGRFwiOiBcInlcIixcbiAgICAgICAgXCJcXHhGRlwiOiBcInlcIixcbiAgICAgICAgXCJcXHhDNlwiOiBcIkFlXCIsXG4gICAgICAgIFwiXFx4RTZcIjogXCJhZVwiLFxuICAgICAgICBcIlxceERFXCI6IFwiVGhcIixcbiAgICAgICAgXCJcXHhGRVwiOiBcInRoXCIsXG4gICAgICAgIFwiXFx4REZcIjogXCJzc1wiLFxuICAgICAgICAvLyBMYXRpbiBFeHRlbmRlZC1BIGJsb2NrLlxuICAgICAgICBcIlxcdTAxMDBcIjogXCJBXCIsXG4gICAgICAgIFwiXFx1MDEwMlwiOiBcIkFcIixcbiAgICAgICAgXCJcXHUwMTA0XCI6IFwiQVwiLFxuICAgICAgICBcIlxcdTAxMDFcIjogXCJhXCIsXG4gICAgICAgIFwiXFx1MDEwM1wiOiBcImFcIixcbiAgICAgICAgXCJcXHUwMTA1XCI6IFwiYVwiLFxuICAgICAgICBcIlxcdTAxMDZcIjogXCJDXCIsXG4gICAgICAgIFwiXFx1MDEwOFwiOiBcIkNcIixcbiAgICAgICAgXCJcXHUwMTBBXCI6IFwiQ1wiLFxuICAgICAgICBcIlxcdTAxMENcIjogXCJDXCIsXG4gICAgICAgIFwiXFx1MDEwN1wiOiBcImNcIixcbiAgICAgICAgXCJcXHUwMTA5XCI6IFwiY1wiLFxuICAgICAgICBcIlxcdTAxMEJcIjogXCJjXCIsXG4gICAgICAgIFwiXFx1MDEwRFwiOiBcImNcIixcbiAgICAgICAgXCJcXHUwMTBFXCI6IFwiRFwiLFxuICAgICAgICBcIlxcdTAxMTBcIjogXCJEXCIsXG4gICAgICAgIFwiXFx1MDEwRlwiOiBcImRcIixcbiAgICAgICAgXCJcXHUwMTExXCI6IFwiZFwiLFxuICAgICAgICBcIlxcdTAxMTJcIjogXCJFXCIsXG4gICAgICAgIFwiXFx1MDExNFwiOiBcIkVcIixcbiAgICAgICAgXCJcXHUwMTE2XCI6IFwiRVwiLFxuICAgICAgICBcIlxcdTAxMThcIjogXCJFXCIsXG4gICAgICAgIFwiXFx1MDExQVwiOiBcIkVcIixcbiAgICAgICAgXCJcXHUwMTEzXCI6IFwiZVwiLFxuICAgICAgICBcIlxcdTAxMTVcIjogXCJlXCIsXG4gICAgICAgIFwiXFx1MDExN1wiOiBcImVcIixcbiAgICAgICAgXCJcXHUwMTE5XCI6IFwiZVwiLFxuICAgICAgICBcIlxcdTAxMUJcIjogXCJlXCIsXG4gICAgICAgIFwiXFx1MDExQ1wiOiBcIkdcIixcbiAgICAgICAgXCJcXHUwMTFFXCI6IFwiR1wiLFxuICAgICAgICBcIlxcdTAxMjBcIjogXCJHXCIsXG4gICAgICAgIFwiXFx1MDEyMlwiOiBcIkdcIixcbiAgICAgICAgXCJcXHUwMTFEXCI6IFwiZ1wiLFxuICAgICAgICBcIlxcdTAxMUZcIjogXCJnXCIsXG4gICAgICAgIFwiXFx1MDEyMVwiOiBcImdcIixcbiAgICAgICAgXCJcXHUwMTIzXCI6IFwiZ1wiLFxuICAgICAgICBcIlxcdTAxMjRcIjogXCJIXCIsXG4gICAgICAgIFwiXFx1MDEyNlwiOiBcIkhcIixcbiAgICAgICAgXCJcXHUwMTI1XCI6IFwiaFwiLFxuICAgICAgICBcIlxcdTAxMjdcIjogXCJoXCIsXG4gICAgICAgIFwiXFx1MDEyOFwiOiBcIklcIixcbiAgICAgICAgXCJcXHUwMTJBXCI6IFwiSVwiLFxuICAgICAgICBcIlxcdTAxMkNcIjogXCJJXCIsXG4gICAgICAgIFwiXFx1MDEyRVwiOiBcIklcIixcbiAgICAgICAgXCJcXHUwMTMwXCI6IFwiSVwiLFxuICAgICAgICBcIlxcdTAxMjlcIjogXCJpXCIsXG4gICAgICAgIFwiXFx1MDEyQlwiOiBcImlcIixcbiAgICAgICAgXCJcXHUwMTJEXCI6IFwiaVwiLFxuICAgICAgICBcIlxcdTAxMkZcIjogXCJpXCIsXG4gICAgICAgIFwiXFx1MDEzMVwiOiBcImlcIixcbiAgICAgICAgXCJcXHUwMTM0XCI6IFwiSlwiLFxuICAgICAgICBcIlxcdTAxMzVcIjogXCJqXCIsXG4gICAgICAgIFwiXFx1MDEzNlwiOiBcIktcIixcbiAgICAgICAgXCJcXHUwMTM3XCI6IFwia1wiLFxuICAgICAgICBcIlxcdTAxMzhcIjogXCJrXCIsXG4gICAgICAgIFwiXFx1MDEzOVwiOiBcIkxcIixcbiAgICAgICAgXCJcXHUwMTNCXCI6IFwiTFwiLFxuICAgICAgICBcIlxcdTAxM0RcIjogXCJMXCIsXG4gICAgICAgIFwiXFx1MDEzRlwiOiBcIkxcIixcbiAgICAgICAgXCJcXHUwMTQxXCI6IFwiTFwiLFxuICAgICAgICBcIlxcdTAxM0FcIjogXCJsXCIsXG4gICAgICAgIFwiXFx1MDEzQ1wiOiBcImxcIixcbiAgICAgICAgXCJcXHUwMTNFXCI6IFwibFwiLFxuICAgICAgICBcIlxcdTAxNDBcIjogXCJsXCIsXG4gICAgICAgIFwiXFx1MDE0MlwiOiBcImxcIixcbiAgICAgICAgXCJcXHUwMTQzXCI6IFwiTlwiLFxuICAgICAgICBcIlxcdTAxNDVcIjogXCJOXCIsXG4gICAgICAgIFwiXFx1MDE0N1wiOiBcIk5cIixcbiAgICAgICAgXCJcXHUwMTRBXCI6IFwiTlwiLFxuICAgICAgICBcIlxcdTAxNDRcIjogXCJuXCIsXG4gICAgICAgIFwiXFx1MDE0NlwiOiBcIm5cIixcbiAgICAgICAgXCJcXHUwMTQ4XCI6IFwiblwiLFxuICAgICAgICBcIlxcdTAxNEJcIjogXCJuXCIsXG4gICAgICAgIFwiXFx1MDE0Q1wiOiBcIk9cIixcbiAgICAgICAgXCJcXHUwMTRFXCI6IFwiT1wiLFxuICAgICAgICBcIlxcdTAxNTBcIjogXCJPXCIsXG4gICAgICAgIFwiXFx1MDE0RFwiOiBcIm9cIixcbiAgICAgICAgXCJcXHUwMTRGXCI6IFwib1wiLFxuICAgICAgICBcIlxcdTAxNTFcIjogXCJvXCIsXG4gICAgICAgIFwiXFx1MDE1NFwiOiBcIlJcIixcbiAgICAgICAgXCJcXHUwMTU2XCI6IFwiUlwiLFxuICAgICAgICBcIlxcdTAxNThcIjogXCJSXCIsXG4gICAgICAgIFwiXFx1MDE1NVwiOiBcInJcIixcbiAgICAgICAgXCJcXHUwMTU3XCI6IFwiclwiLFxuICAgICAgICBcIlxcdTAxNTlcIjogXCJyXCIsXG4gICAgICAgIFwiXFx1MDE1QVwiOiBcIlNcIixcbiAgICAgICAgXCJcXHUwMTVDXCI6IFwiU1wiLFxuICAgICAgICBcIlxcdTAxNUVcIjogXCJTXCIsXG4gICAgICAgIFwiXFx1MDE2MFwiOiBcIlNcIixcbiAgICAgICAgXCJcXHUwMTVCXCI6IFwic1wiLFxuICAgICAgICBcIlxcdTAxNURcIjogXCJzXCIsXG4gICAgICAgIFwiXFx1MDE1RlwiOiBcInNcIixcbiAgICAgICAgXCJcXHUwMTYxXCI6IFwic1wiLFxuICAgICAgICBcIlxcdTAxNjJcIjogXCJUXCIsXG4gICAgICAgIFwiXFx1MDE2NFwiOiBcIlRcIixcbiAgICAgICAgXCJcXHUwMTY2XCI6IFwiVFwiLFxuICAgICAgICBcIlxcdTAxNjNcIjogXCJ0XCIsXG4gICAgICAgIFwiXFx1MDE2NVwiOiBcInRcIixcbiAgICAgICAgXCJcXHUwMTY3XCI6IFwidFwiLFxuICAgICAgICBcIlxcdTAxNjhcIjogXCJVXCIsXG4gICAgICAgIFwiXFx1MDE2QVwiOiBcIlVcIixcbiAgICAgICAgXCJcXHUwMTZDXCI6IFwiVVwiLFxuICAgICAgICBcIlxcdTAxNkVcIjogXCJVXCIsXG4gICAgICAgIFwiXFx1MDE3MFwiOiBcIlVcIixcbiAgICAgICAgXCJcXHUwMTcyXCI6IFwiVVwiLFxuICAgICAgICBcIlxcdTAxNjlcIjogXCJ1XCIsXG4gICAgICAgIFwiXFx1MDE2QlwiOiBcInVcIixcbiAgICAgICAgXCJcXHUwMTZEXCI6IFwidVwiLFxuICAgICAgICBcIlxcdTAxNkZcIjogXCJ1XCIsXG4gICAgICAgIFwiXFx1MDE3MVwiOiBcInVcIixcbiAgICAgICAgXCJcXHUwMTczXCI6IFwidVwiLFxuICAgICAgICBcIlxcdTAxNzRcIjogXCJXXCIsXG4gICAgICAgIFwiXFx1MDE3NVwiOiBcIndcIixcbiAgICAgICAgXCJcXHUwMTc2XCI6IFwiWVwiLFxuICAgICAgICBcIlxcdTAxNzdcIjogXCJ5XCIsXG4gICAgICAgIFwiXFx1MDE3OFwiOiBcIllcIixcbiAgICAgICAgXCJcXHUwMTc5XCI6IFwiWlwiLFxuICAgICAgICBcIlxcdTAxN0JcIjogXCJaXCIsXG4gICAgICAgIFwiXFx1MDE3RFwiOiBcIlpcIixcbiAgICAgICAgXCJcXHUwMTdBXCI6IFwielwiLFxuICAgICAgICBcIlxcdTAxN0NcIjogXCJ6XCIsXG4gICAgICAgIFwiXFx1MDE3RVwiOiBcInpcIixcbiAgICAgICAgXCJcXHUwMTMyXCI6IFwiSUpcIixcbiAgICAgICAgXCJcXHUwMTMzXCI6IFwiaWpcIixcbiAgICAgICAgXCJcXHUwMTUyXCI6IFwiT2VcIixcbiAgICAgICAgXCJcXHUwMTUzXCI6IFwib2VcIixcbiAgICAgICAgXCJcXHUwMTQ5XCI6IFwiJ25cIixcbiAgICAgICAgXCJcXHUwMTdGXCI6IFwic1wiXG4gICAgICB9O1xuICAgICAgdmFyIGh0bWxFc2NhcGVzID0ge1xuICAgICAgICBcIiZcIjogXCImYW1wO1wiLFxuICAgICAgICBcIjxcIjogXCImbHQ7XCIsXG4gICAgICAgIFwiPlwiOiBcIiZndDtcIixcbiAgICAgICAgJ1wiJzogXCImcXVvdDtcIixcbiAgICAgICAgXCInXCI6IFwiJiMzOTtcIlxuICAgICAgfTtcbiAgICAgIHZhciBodG1sVW5lc2NhcGVzID0ge1xuICAgICAgICBcIiZhbXA7XCI6IFwiJlwiLFxuICAgICAgICBcIiZsdDtcIjogXCI8XCIsXG4gICAgICAgIFwiJmd0O1wiOiBcIj5cIixcbiAgICAgICAgXCImcXVvdDtcIjogJ1wiJyxcbiAgICAgICAgXCImIzM5O1wiOiBcIidcIlxuICAgICAgfTtcbiAgICAgIHZhciBzdHJpbmdFc2NhcGVzID0ge1xuICAgICAgICBcIlxcXFxcIjogXCJcXFxcXCIsXG4gICAgICAgIFwiJ1wiOiBcIidcIixcbiAgICAgICAgXCJcXG5cIjogXCJuXCIsXG4gICAgICAgIFwiXFxyXCI6IFwiclwiLFxuICAgICAgICBcIlxcdTIwMjhcIjogXCJ1MjAyOFwiLFxuICAgICAgICBcIlxcdTIwMjlcIjogXCJ1MjAyOVwiXG4gICAgICB9O1xuICAgICAgdmFyIGZyZWVQYXJzZUZsb2F0ID0gcGFyc2VGbG9hdCwgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG4gICAgICB2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gXCJvYmplY3RcIiAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcbiAgICAgIHZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09IFwib2JqZWN0XCIgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG4gICAgICB2YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xuICAgICAgdmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG4gICAgICB2YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gXCJvYmplY3RcIiAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG4gICAgICB2YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcbiAgICAgIHZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuICAgICAgdmFyIG5vZGVVdGlsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIHR5cGVzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlKFwidXRpbFwiKS50eXBlcztcbiAgICAgICAgICBpZiAodHlwZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlcztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZyhcInV0aWxcIik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgfVxuICAgICAgfSgpO1xuICAgICAgdmFyIG5vZGVJc0FycmF5QnVmZmVyID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNBcnJheUJ1ZmZlciwgbm9kZUlzRGF0ZSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzRGF0ZSwgbm9kZUlzTWFwID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNNYXAsIG5vZGVJc1JlZ0V4cCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzUmVnRXhwLCBub2RlSXNTZXQgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1NldCwgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcbiAgICAgIGZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdKTtcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBhcnJheUFnZ3JlZ2F0b3IoYXJyYXksIHNldHRlciwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLCBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgICAgc2V0dGVyKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaXRlcmF0ZWUodmFsdWUpLCBhcnJheSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSwgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBhcnJheUVhY2hSaWdodChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbbGVuZ3RoXSwgbGVuZ3RoLCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYXJyYXlFdmVyeShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLCBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAoIXByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLCBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCwgcmVzSW5kZXggPSAwLCByZXN1bHQgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBhcnJheUluY2x1ZGVzKGFycmF5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICAgIHJldHVybiAhIWxlbmd0aCAmJiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIDApID4gLTE7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBhcnJheUluY2x1ZGVzV2l0aChhcnJheSwgdmFsdWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmIChjb21wYXJhdG9yKHZhbHVlLCBhcnJheVtpbmRleF0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLCBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCwgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSwgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCwgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGFycmF5W29mZnNldCArIGluZGV4XSA9IHZhbHVlc1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYXJyYXlSZWR1Y2UoYXJyYXksIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLCBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgaWYgKGluaXRBY2N1bSAmJiBsZW5ndGgpIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IGFycmF5WysraW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgYWNjdW11bGF0b3IgPSBpdGVyYXRlZShhY2N1bXVsYXRvciwgYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGFycmF5UmVkdWNlUmlnaHQoYXJyYXksIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgaWYgKGluaXRBY2N1bSAmJiBsZW5ndGgpIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IGFycmF5Wy0tbGVuZ3RoXTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtsZW5ndGhdLCBsZW5ndGgsIGFycmF5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSwgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgYXNjaWlTaXplID0gYmFzZVByb3BlcnR5KFwibGVuZ3RoXCIpO1xuICAgICAgZnVuY3Rpb24gYXNjaWlUb0FycmF5KHN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyaW5nLnNwbGl0KFwiXCIpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYXNjaWlXb3JkcyhzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5tYXRjaChyZUFzY2lpV29yZCkgfHwgW107XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBiYXNlRmluZEtleShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGVhY2hGdW5jKSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24yKSB7XG4gICAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uMikpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGtleTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYmFzZUZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgsIGZyb21SaWdodCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLCBpbmRleCA9IGZyb21JbmRleCArIChmcm9tUmlnaHQgPyAxIDogLTEpO1xuICAgICAgICB3aGlsZSAoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkgOiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXNOYU4sIGZyb21JbmRleCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBiYXNlSW5kZXhPZldpdGgoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgsIGNvbXBhcmF0b3IpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmIChjb21wYXJhdG9yKGFycmF5W2luZGV4XSwgdmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGJhc2VJc05hTih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYmFzZU1lYW4oYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VTdW0oYXJyYXksIGl0ZXJhdGVlKSAvIGxlbmd0aCA6IE5BTjtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZDIgOiBvYmplY3Rba2V5XTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGJhc2VQcm9wZXJ0eU9mKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkMiA6IG9iamVjdFtrZXldO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYmFzZVJlZHVjZShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgZWFjaEZ1bmMpIHtcbiAgICAgICAgZWFjaEZ1bmMoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uMikge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0gaW5pdEFjY3VtID8gKGluaXRBY2N1bSA9IGZhbHNlLCB2YWx1ZSkgOiBpdGVyYXRlZShhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uMik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBiYXNlU29ydEJ5KGFycmF5LCBjb21wYXJlcikge1xuICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICBhcnJheS5zb3J0KGNvbXBhcmVyKTtcbiAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgYXJyYXlbbGVuZ3RoXSA9IGFycmF5W2xlbmd0aF0udmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYmFzZVN1bShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCwgaW5kZXggPSAtMSwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIHZhciBjdXJyZW50ID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdKTtcbiAgICAgICAgICBpZiAoY3VycmVudCAhPT0gdW5kZWZpbmVkMikge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ID09PSB1bmRlZmluZWQyID8gY3VycmVudCA6IHJlc3VsdCArIGN1cnJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsIHJlc3VsdCA9IEFycmF5KG4pO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICAgICAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBiYXNlVG9QYWlycyhvYmplY3QsIHByb3BzKSB7XG4gICAgICAgIHJldHVybiBhcnJheU1hcChwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIFtrZXksIG9iamVjdFtrZXldXTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBiYXNlVHJpbShzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZyA/IHN0cmluZy5zbGljZSgwLCB0cmltbWVkRW5kSW5kZXgoc3RyaW5nKSArIDEpLnJlcGxhY2UocmVUcmltU3RhcnQsIFwiXCIpIDogc3RyaW5nO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gYmFzZVZhbHVlcyhvYmplY3QsIHByb3BzKSB7XG4gICAgICAgIHJldHVybiBhcnJheU1hcChwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdFtrZXldO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGNhY2hlSGFzKGNhY2hlLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlLmhhcyhrZXkpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gY2hhcnNTdGFydEluZGV4KHN0clN5bWJvbHMsIGNoclN5bWJvbHMpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IHN0clN5bWJvbHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiBiYXNlSW5kZXhPZihjaHJTeW1ib2xzLCBzdHJTeW1ib2xzW2luZGV4XSwgMCkgPiAtMSkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGNoYXJzRW5kSW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scykge1xuICAgICAgICB2YXIgaW5kZXggPSBzdHJTeW1ib2xzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGluZGV4LS0gJiYgYmFzZUluZGV4T2YoY2hyU3ltYm9scywgc3RyU3ltYm9sc1tpbmRleF0sIDApID4gLTEpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBjb3VudEhvbGRlcnMoYXJyYXksIHBsYWNlaG9sZGVyKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsIHJlc3VsdCA9IDA7XG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgIGlmIChhcnJheVtsZW5ndGhdID09PSBwbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgKytyZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICB2YXIgZGVidXJyTGV0dGVyID0gYmFzZVByb3BlcnR5T2YoZGVidXJyZWRMZXR0ZXJzKTtcbiAgICAgIHZhciBlc2NhcGVIdG1sQ2hhciA9IGJhc2VQcm9wZXJ0eU9mKGh0bWxFc2NhcGVzKTtcbiAgICAgIGZ1bmN0aW9uIGVzY2FwZVN0cmluZ0NoYXIoY2hyKSB7XG4gICAgICAgIHJldHVybiBcIlxcXFxcIiArIHN0cmluZ0VzY2FwZXNbY2hyXTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZDIgOiBvYmplY3Rba2V5XTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGhhc1VuaWNvZGUoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiByZUhhc1VuaWNvZGUudGVzdChzdHJpbmcpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gaGFzVW5pY29kZVdvcmQoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiByZUhhc1VuaWNvZGVXb3JkLnRlc3Qoc3RyaW5nKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGl0ZXJhdG9yVG9BcnJheShpdGVyYXRvcikge1xuICAgICAgICB2YXIgZGF0YSwgcmVzdWx0ID0gW107XG4gICAgICAgIHdoaWxlICghKGRhdGEgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChkYXRhLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbWFwVG9BcnJheShtYXApIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcbiAgICAgICAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcmVwbGFjZUhvbGRlcnMoYXJyYXksIHBsYWNlaG9sZGVyKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLCBsZW5ndGggPSBhcnJheS5sZW5ndGgsIHJlc0luZGV4ID0gMCwgcmVzdWx0ID0gW107XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gcGxhY2Vob2xkZXIgfHwgdmFsdWUgPT09IFBMQUNFSE9MREVSKSB7XG4gICAgICAgICAgICBhcnJheVtpbmRleF0gPSBQTEFDRUhPTERFUjtcbiAgICAgICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IGluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcbiAgICAgICAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBzZXRUb1BhaXJzKHNldCkge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSwgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuICAgICAgICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHJlc3VsdFsrK2luZGV4XSA9IFt2YWx1ZSwgdmFsdWVdO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHN0cmljdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHN0cmljdExhc3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgICAgIHZhciBpbmRleCA9IGZyb21JbmRleCArIDE7XG4gICAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gc3RyaW5nU2l6ZShzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIGhhc1VuaWNvZGUoc3RyaW5nKSA/IHVuaWNvZGVTaXplKHN0cmluZykgOiBhc2NpaVNpemUoc3RyaW5nKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHN0cmluZ1RvQXJyYXkoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBoYXNVbmljb2RlKHN0cmluZykgPyB1bmljb2RlVG9BcnJheShzdHJpbmcpIDogYXNjaWlUb0FycmF5KHN0cmluZyk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB0cmltbWVkRW5kSW5kZXgoc3RyaW5nKSB7XG4gICAgICAgIHZhciBpbmRleCA9IHN0cmluZy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpbmRleC0tICYmIHJlV2hpdGVzcGFjZS50ZXN0KHN0cmluZy5jaGFyQXQoaW5kZXgpKSkge1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICAgIHZhciB1bmVzY2FwZUh0bWxDaGFyID0gYmFzZVByb3BlcnR5T2YoaHRtbFVuZXNjYXBlcyk7XG4gICAgICBmdW5jdGlvbiB1bmljb2RlU2l6ZShzdHJpbmcpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlVW5pY29kZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAocmVVbmljb2RlLnRlc3Qoc3RyaW5nKSkge1xuICAgICAgICAgICsrcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB1bmljb2RlVG9BcnJheShzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5tYXRjaChyZVVuaWNvZGUpIHx8IFtdO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdW5pY29kZVdvcmRzKHN0cmluZykge1xuICAgICAgICByZXR1cm4gc3RyaW5nLm1hdGNoKHJlVW5pY29kZVdvcmQpIHx8IFtdO1xuICAgICAgfVxuICAgICAgdmFyIHJ1bkluQ29udGV4dCA9IGZ1bmN0aW9uIHJ1bkluQ29udGV4dDIoY29udGV4dCkge1xuICAgICAgICBjb250ZXh0ID0gY29udGV4dCA9PSBudWxsID8gcm9vdCA6IF8uZGVmYXVsdHMocm9vdC5PYmplY3QoKSwgY29udGV4dCwgXy5waWNrKHJvb3QsIGNvbnRleHRQcm9wcykpO1xuICAgICAgICB2YXIgQXJyYXkyID0gY29udGV4dC5BcnJheSwgRGF0ZTIgPSBjb250ZXh0LkRhdGUsIEVycm9yMiA9IGNvbnRleHQuRXJyb3IsIEZ1bmN0aW9uMiA9IGNvbnRleHQuRnVuY3Rpb24sIE1hdGgyID0gY29udGV4dC5NYXRoLCBPYmplY3QyID0gY29udGV4dC5PYmplY3QsIFJlZ0V4cDIgPSBjb250ZXh0LlJlZ0V4cCwgU3RyaW5nMiA9IGNvbnRleHQuU3RyaW5nLCBUeXBlRXJyb3IyID0gY29udGV4dC5UeXBlRXJyb3I7XG4gICAgICAgIHZhciBhcnJheVByb3RvID0gQXJyYXkyLnByb3RvdHlwZSwgZnVuY1Byb3RvID0gRnVuY3Rpb24yLnByb3RvdHlwZSwgb2JqZWN0UHJvdG8gPSBPYmplY3QyLnByb3RvdHlwZTtcbiAgICAgICAgdmFyIGNvcmVKc0RhdGEgPSBjb250ZXh0W1wiX19jb3JlLWpzX3NoYXJlZF9fXCJdO1xuICAgICAgICB2YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuICAgICAgICB2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcbiAgICAgICAgdmFyIGlkQ291bnRlciA9IDA7XG4gICAgICAgIHZhciBtYXNrU3JjS2V5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHVpZCA9IC9bXi5dKyQvLmV4ZWMoY29yZUpzRGF0YSAmJiBjb3JlSnNEYXRhLmtleXMgJiYgY29yZUpzRGF0YS5rZXlzLklFX1BST1RPIHx8IFwiXCIpO1xuICAgICAgICAgIHJldHVybiB1aWQgPyBcIlN5bWJvbChzcmMpXzEuXCIgKyB1aWQgOiBcIlwiO1xuICAgICAgICB9KCk7XG4gICAgICAgIHZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuICAgICAgICB2YXIgb2JqZWN0Q3RvclN0cmluZyA9IGZ1bmNUb1N0cmluZy5jYWxsKE9iamVjdDIpO1xuICAgICAgICB2YXIgb2xkRGFzaCA9IHJvb3QuXztcbiAgICAgICAgdmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAyKFxuICAgICAgICAgIFwiXlwiICsgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCBcIlxcXFwkJlwiKS5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCBcIiQxLio/XCIpICsgXCIkXCJcbiAgICAgICAgKTtcbiAgICAgICAgdmFyIEJ1ZmZlcjIgPSBtb2R1bGVFeHBvcnRzID8gY29udGV4dC5CdWZmZXIgOiB1bmRlZmluZWQyLCBTeW1ib2wyID0gY29udGV4dC5TeW1ib2wsIFVpbnQ4QXJyYXkyID0gY29udGV4dC5VaW50OEFycmF5LCBhbGxvY1Vuc2FmZSA9IEJ1ZmZlcjIgPyBCdWZmZXIyLmFsbG9jVW5zYWZlIDogdW5kZWZpbmVkMiwgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QyLmdldFByb3RvdHlwZU9mLCBPYmplY3QyKSwgb2JqZWN0Q3JlYXRlID0gT2JqZWN0Mi5jcmVhdGUsIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGUsIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlLCBzcHJlYWRhYmxlU3ltYm9sID0gU3ltYm9sMiA/IFN5bWJvbDIuaXNDb25jYXRTcHJlYWRhYmxlIDogdW5kZWZpbmVkMiwgc3ltSXRlcmF0b3IgPSBTeW1ib2wyID8gU3ltYm9sMi5pdGVyYXRvciA6IHVuZGVmaW5lZDIsIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sMiA/IFN5bWJvbDIudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQyO1xuICAgICAgICB2YXIgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGZ1bmMgPSBnZXROYXRpdmUoT2JqZWN0MiwgXCJkZWZpbmVQcm9wZXJ0eVwiKTtcbiAgICAgICAgICAgIGZ1bmMoe30sIFwiXCIsIHt9KTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB9XG4gICAgICAgIH0oKTtcbiAgICAgICAgdmFyIGN0eENsZWFyVGltZW91dCA9IGNvbnRleHQuY2xlYXJUaW1lb3V0ICE9PSByb290LmNsZWFyVGltZW91dCAmJiBjb250ZXh0LmNsZWFyVGltZW91dCwgY3R4Tm93ID0gRGF0ZTIgJiYgRGF0ZTIubm93ICE9PSByb290LkRhdGUubm93ICYmIERhdGUyLm5vdywgY3R4U2V0VGltZW91dCA9IGNvbnRleHQuc2V0VGltZW91dCAhPT0gcm9vdC5zZXRUaW1lb3V0ICYmIGNvbnRleHQuc2V0VGltZW91dDtcbiAgICAgICAgdmFyIG5hdGl2ZUNlaWwgPSBNYXRoMi5jZWlsLCBuYXRpdmVGbG9vciA9IE1hdGgyLmZsb29yLCBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0Mi5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyMiA/IEJ1ZmZlcjIuaXNCdWZmZXIgOiB1bmRlZmluZWQyLCBuYXRpdmVJc0Zpbml0ZSA9IGNvbnRleHQuaXNGaW5pdGUsIG5hdGl2ZUpvaW4gPSBhcnJheVByb3RvLmpvaW4sIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdDIua2V5cywgT2JqZWN0MiksIG5hdGl2ZU1heCA9IE1hdGgyLm1heCwgbmF0aXZlTWluID0gTWF0aDIubWluLCBuYXRpdmVOb3cgPSBEYXRlMi5ub3csIG5hdGl2ZVBhcnNlSW50ID0gY29udGV4dC5wYXJzZUludCwgbmF0aXZlUmFuZG9tID0gTWF0aDIucmFuZG9tLCBuYXRpdmVSZXZlcnNlID0gYXJyYXlQcm90by5yZXZlcnNlO1xuICAgICAgICB2YXIgRGF0YVZpZXcgPSBnZXROYXRpdmUoY29udGV4dCwgXCJEYXRhVmlld1wiKSwgTWFwMiA9IGdldE5hdGl2ZShjb250ZXh0LCBcIk1hcFwiKSwgUHJvbWlzZTIgPSBnZXROYXRpdmUoY29udGV4dCwgXCJQcm9taXNlXCIpLCBTZXQyID0gZ2V0TmF0aXZlKGNvbnRleHQsIFwiU2V0XCIpLCBXZWFrTWFwMiA9IGdldE5hdGl2ZShjb250ZXh0LCBcIldlYWtNYXBcIiksIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QyLCBcImNyZWF0ZVwiKTtcbiAgICAgICAgdmFyIG1ldGFNYXAgPSBXZWFrTWFwMiAmJiBuZXcgV2Vha01hcDIoKTtcbiAgICAgICAgdmFyIHJlYWxOYW1lcyA9IHt9O1xuICAgICAgICB2YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLCBtYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoTWFwMiksIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZTIpLCBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0MiksIHdlYWtNYXBDdG9yU3RyaW5nID0gdG9Tb3VyY2UoV2Vha01hcDIpO1xuICAgICAgICB2YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wyID8gU3ltYm9sMi5wcm90b3R5cGUgOiB1bmRlZmluZWQyLCBzeW1ib2xWYWx1ZU9mID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by52YWx1ZU9mIDogdW5kZWZpbmVkMiwgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkMjtcbiAgICAgICAgZnVuY3Rpb24gbG9kYXNoKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzQXJyYXkodmFsdWUpICYmICEodmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExvZGFzaFdyYXBwZXIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIFwiX193cmFwcGVkX19cIikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHdyYXBwZXJDbG9uZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJhc2VDcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBmdW5jdGlvbiBvYmplY3QoKSB7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgICAgICAgICAgaWYgKCFpc09iamVjdChwcm90bykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iamVjdENyZWF0ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0Q3JlYXRlKHByb3RvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9iamVjdC5wcm90b3R5cGUgPSBwcm90bztcbiAgICAgICAgICAgIHZhciByZXN1bHQyID0gbmV3IG9iamVjdCgpO1xuICAgICAgICAgICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDI7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgICB9O1xuICAgICAgICB9KCk7XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VMb2Rhc2goKSB7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gTG9kYXNoV3JhcHBlcih2YWx1ZSwgY2hhaW5BbGwpIHtcbiAgICAgICAgICB0aGlzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5fX2FjdGlvbnNfXyA9IFtdO1xuICAgICAgICAgIHRoaXMuX19jaGFpbl9fID0gISFjaGFpbkFsbDtcbiAgICAgICAgICB0aGlzLl9faW5kZXhfXyA9IDA7XG4gICAgICAgICAgdGhpcy5fX3ZhbHVlc19fID0gdW5kZWZpbmVkMjtcbiAgICAgICAgfVxuICAgICAgICBsb2Rhc2gudGVtcGxhdGVTZXR0aW5ncyA9IHtcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGJlIEhUTUwtZXNjYXBlZC5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAgICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgICAgICAgICAqL1xuICAgICAgICAgIFwiZXNjYXBlXCI6IHJlRXNjYXBlLFxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGNvZGUgdG8gYmUgZXZhbHVhdGVkLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICAgICAqIEB0eXBlIHtSZWdFeHB9XG4gICAgICAgICAgICovXG4gICAgICAgICAgXCJldmFsdWF0ZVwiOiByZUV2YWx1YXRlLFxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gaW5qZWN0LlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICAgICAqIEB0eXBlIHtSZWdFeHB9XG4gICAgICAgICAgICovXG4gICAgICAgICAgXCJpbnRlcnBvbGF0ZVwiOiByZUludGVycG9sYXRlLFxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFVzZWQgdG8gcmVmZXJlbmNlIHRoZSBkYXRhIG9iamVjdCBpbiB0aGUgdGVtcGxhdGUgdGV4dC5cbiAgICAgICAgICAgKlxuICAgICAgICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICAgICAqL1xuICAgICAgICAgIFwidmFyaWFibGVcIjogXCJcIixcbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBVc2VkIHRvIGltcG9ydCB2YXJpYWJsZXMgaW50byB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICAgICAgICpcbiAgICAgICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBcImltcG9ydHNcIjoge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzXG4gICAgICAgICAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiX1wiOiBsb2Rhc2hcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGxvZGFzaC5wcm90b3R5cGUgPSBiYXNlTG9kYXNoLnByb3RvdHlwZTtcbiAgICAgICAgbG9kYXNoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGxvZGFzaDtcbiAgICAgICAgTG9kYXNoV3JhcHBlci5wcm90b3R5cGUgPSBiYXNlQ3JlYXRlKGJhc2VMb2Rhc2gucHJvdG90eXBlKTtcbiAgICAgICAgTG9kYXNoV3JhcHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMb2Rhc2hXcmFwcGVyO1xuICAgICAgICBmdW5jdGlvbiBMYXp5V3JhcHBlcih2YWx1ZSkge1xuICAgICAgICAgIHRoaXMuX193cmFwcGVkX18gPSB2YWx1ZTtcbiAgICAgICAgICB0aGlzLl9fYWN0aW9uc19fID0gW107XG4gICAgICAgICAgdGhpcy5fX2Rpcl9fID0gMTtcbiAgICAgICAgICB0aGlzLl9fZmlsdGVyZWRfXyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuX19pdGVyYXRlZXNfXyA9IFtdO1xuICAgICAgICAgIHRoaXMuX190YWtlQ291bnRfXyA9IE1BWF9BUlJBWV9MRU5HVEg7XG4gICAgICAgICAgdGhpcy5fX3ZpZXdzX18gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsYXp5Q2xvbmUoKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdDIgPSBuZXcgTGF6eVdyYXBwZXIodGhpcy5fX3dyYXBwZWRfXyk7XG4gICAgICAgICAgcmVzdWx0Mi5fX2FjdGlvbnNfXyA9IGNvcHlBcnJheSh0aGlzLl9fYWN0aW9uc19fKTtcbiAgICAgICAgICByZXN1bHQyLl9fZGlyX18gPSB0aGlzLl9fZGlyX187XG4gICAgICAgICAgcmVzdWx0Mi5fX2ZpbHRlcmVkX18gPSB0aGlzLl9fZmlsdGVyZWRfXztcbiAgICAgICAgICByZXN1bHQyLl9faXRlcmF0ZWVzX18gPSBjb3B5QXJyYXkodGhpcy5fX2l0ZXJhdGVlc19fKTtcbiAgICAgICAgICByZXN1bHQyLl9fdGFrZUNvdW50X18gPSB0aGlzLl9fdGFrZUNvdW50X187XG4gICAgICAgICAgcmVzdWx0Mi5fX3ZpZXdzX18gPSBjb3B5QXJyYXkodGhpcy5fX3ZpZXdzX18pO1xuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGxhenlSZXZlcnNlKCkge1xuICAgICAgICAgIGlmICh0aGlzLl9fZmlsdGVyZWRfXykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDIgPSBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICAgICAgICByZXN1bHQyLl9fZGlyX18gPSAtMTtcbiAgICAgICAgICAgIHJlc3VsdDIuX19maWx0ZXJlZF9fID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MiA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgICAgIHJlc3VsdDIuX19kaXJfXyAqPSAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbGF6eVZhbHVlKCkge1xuICAgICAgICAgIHZhciBhcnJheSA9IHRoaXMuX193cmFwcGVkX18udmFsdWUoKSwgZGlyID0gdGhpcy5fX2Rpcl9fLCBpc0FyciA9IGlzQXJyYXkoYXJyYXkpLCBpc1JpZ2h0ID0gZGlyIDwgMCwgYXJyTGVuZ3RoID0gaXNBcnIgPyBhcnJheS5sZW5ndGggOiAwLCB2aWV3ID0gZ2V0VmlldygwLCBhcnJMZW5ndGgsIHRoaXMuX192aWV3c19fKSwgc3RhcnQgPSB2aWV3LnN0YXJ0LCBlbmQgPSB2aWV3LmVuZCwgbGVuZ3RoID0gZW5kIC0gc3RhcnQsIGluZGV4ID0gaXNSaWdodCA/IGVuZCA6IHN0YXJ0IC0gMSwgaXRlcmF0ZWVzID0gdGhpcy5fX2l0ZXJhdGVlc19fLCBpdGVyTGVuZ3RoID0gaXRlcmF0ZWVzLmxlbmd0aCwgcmVzSW5kZXggPSAwLCB0YWtlQ291bnQgPSBuYXRpdmVNaW4obGVuZ3RoLCB0aGlzLl9fdGFrZUNvdW50X18pO1xuICAgICAgICAgIGlmICghaXNBcnIgfHwgIWlzUmlnaHQgJiYgYXJyTGVuZ3RoID09IGxlbmd0aCAmJiB0YWtlQ291bnQgPT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gYmFzZVdyYXBwZXJWYWx1ZShhcnJheSwgdGhpcy5fX2FjdGlvbnNfXyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZXN1bHQyID0gW107XG4gICAgICAgICAgb3V0ZXI6XG4gICAgICAgICAgICB3aGlsZSAobGVuZ3RoLS0gJiYgcmVzSW5kZXggPCB0YWtlQ291bnQpIHtcbiAgICAgICAgICAgICAgaW5kZXggKz0gZGlyO1xuICAgICAgICAgICAgICB2YXIgaXRlckluZGV4ID0gLTEsIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICAgICAgICB3aGlsZSAoKytpdGVySW5kZXggPCBpdGVyTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBpdGVyYXRlZXNbaXRlckluZGV4XSwgaXRlcmF0ZWUyID0gZGF0YS5pdGVyYXRlZSwgdHlwZSA9IGRhdGEudHlwZSwgY29tcHV0ZWQgPSBpdGVyYXRlZTIodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09IExBWllfTUFQX0ZMQUcpIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gY29tcHV0ZWQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlID09IExBWllfRklMVEVSX0ZMQUcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0MltyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZSA9IGJhc2VDcmVhdGUoYmFzZUxvZGFzaC5wcm90b3R5cGUpO1xuICAgICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMYXp5V3JhcHBlcjtcbiAgICAgICAgZnVuY3Rpb24gSGFzaChlbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcbiAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgICAgICAgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaGFzaENsZWFyKCkge1xuICAgICAgICAgIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGhhc2hEZWxldGUoa2V5KSB7XG4gICAgICAgICAgdmFyIHJlc3VsdDIgPSB0aGlzLmhhcyhrZXkpICYmIGRlbGV0ZSB0aGlzLl9fZGF0YV9fW2tleV07XG4gICAgICAgICAgdGhpcy5zaXplIC09IHJlc3VsdDIgPyAxIDogMDtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBoYXNoR2V0KGtleSkge1xuICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgICAgICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0MiA9IGRhdGFba2V5XTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQyID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZDIgOiByZXN1bHQyO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkMjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgICAgICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gZGF0YVtrZXldICE9PSB1bmRlZmluZWQyIDogaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgICAgICAgICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICAgICAgICAgIGRhdGFba2V5XSA9IG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkMiA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG4gICAgICAgIEhhc2gucHJvdG90eXBlW1wiZGVsZXRlXCJdID0gaGFzaERlbGV0ZTtcbiAgICAgICAgSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbiAgICAgICAgSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbiAgICAgICAgSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcbiAgICAgICAgZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSAtMSwgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuICAgICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgICAgICAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YV9fID0gW107XG4gICAgICAgICAgdGhpcy5zaXplID0gMDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLCBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuICAgICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgICAgICAgICBpZiAoaW5kZXggPT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgICBkYXRhLnBvcCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzcGxpY2UuY2FsbChkYXRhLCBpbmRleCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC0tdGhpcy5zaXplO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGxpc3RDYWNoZUdldChrZXkpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG4gICAgICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZDIgOiBkYXRhW2luZGV4XVsxXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbGlzdENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG4gICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgKyt0aGlzLnNpemU7XG4gICAgICAgICAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuICAgICAgICBMaXN0Q2FjaGUucHJvdG90eXBlW1wiZGVsZXRlXCJdID0gbGlzdENhY2hlRGVsZXRlO1xuICAgICAgICBMaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbiAgICAgICAgTGlzdENhY2hlLnByb3RvdHlwZS5oYXMgPSBsaXN0Q2FjaGVIYXM7XG4gICAgICAgIExpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuICAgICAgICBmdW5jdGlvbiBNYXBDYWNoZShlbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcbiAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgICAgICAgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgICAgIHRoaXMuX19kYXRhX18gPSB7XG4gICAgICAgICAgICBcImhhc2hcIjogbmV3IEhhc2goKSxcbiAgICAgICAgICAgIFwibWFwXCI6IG5ldyAoTWFwMiB8fCBMaXN0Q2FjaGUpKCksXG4gICAgICAgICAgICBcInN0cmluZ1wiOiBuZXcgSGFzaCgpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IGdldE1hcERhdGEodGhpcywga2V5KVtcImRlbGV0ZVwiXShrZXkpO1xuICAgICAgICAgIHRoaXMuc2l6ZSAtPSByZXN1bHQyID8gMSA6IDA7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWFwQ2FjaGVHZXQoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgICAgICAgICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1hcENhY2hlU2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSwgc2l6ZTIgPSBkYXRhLnNpemU7XG4gICAgICAgICAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgdGhpcy5zaXplICs9IGRhdGEuc2l6ZSA9PSBzaXplMiA/IDAgOiAxO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIE1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG4gICAgICAgIE1hcENhY2hlLnByb3RvdHlwZVtcImRlbGV0ZVwiXSA9IG1hcENhY2hlRGVsZXRlO1xuICAgICAgICBNYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG4gICAgICAgIE1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbiAgICAgICAgTWFwQ2FjaGUucHJvdG90eXBlLnNldCA9IG1hcENhY2hlU2V0O1xuICAgICAgICBmdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMyKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IHZhbHVlczIgPT0gbnVsbCA/IDAgOiB2YWx1ZXMyLmxlbmd0aDtcbiAgICAgICAgICB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKCk7XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkKHZhbHVlczJbaW5kZXhdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0Q2FjaGVBZGQodmFsdWUpIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNldENhY2hlSGFzKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBTZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBzZXRDYWNoZUFkZDtcbiAgICAgICAgU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuICAgICAgICBmdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgICAgICAgICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZSgpO1xuICAgICAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLCByZXN1bHQyID0gZGF0YVtcImRlbGV0ZVwiXShrZXkpO1xuICAgICAgICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgICAgICAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgICAgICAgICAgaWYgKCFNYXAyIHx8IHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSB7XG4gICAgICAgICAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgICAgICAgICAgdGhpcy5zaXplID0gKytkYXRhLnNpemU7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICB0aGlzLnNpemUgPSBkYXRhLnNpemU7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcbiAgICAgICAgU3RhY2sucHJvdG90eXBlW1wiZGVsZXRlXCJdID0gc3RhY2tEZWxldGU7XG4gICAgICAgIFN0YWNrLnByb3RvdHlwZS5nZXQgPSBzdGFja0dldDtcbiAgICAgICAgU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuICAgICAgICBTdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG4gICAgICAgIGZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICAgICAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLCBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLCBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSwgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLCByZXN1bHQyID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcyKSA6IFtdLCBsZW5ndGggPSByZXN1bHQyLmxlbmd0aDtcbiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmICEoc2tpcEluZGV4ZXMgJiYgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICAgKGtleSA9PSBcImxlbmd0aFwiIHx8IC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAgaXNCdWZmICYmIChrZXkgPT0gXCJvZmZzZXRcIiB8fCBrZXkgPT0gXCJwYXJlbnRcIikgfHwgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAgaXNUeXBlICYmIChrZXkgPT0gXCJidWZmZXJcIiB8fCBrZXkgPT0gXCJieXRlTGVuZ3RoXCIgfHwga2V5ID09IFwiYnl0ZU9mZnNldFwiKSB8fCAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKSkpKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhcnJheVNhbXBsZShhcnJheSkge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIGxlbmd0aCA/IGFycmF5W2Jhc2VSYW5kb20oMCwgbGVuZ3RoIC0gMSldIDogdW5kZWZpbmVkMjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhcnJheVNhbXBsZVNpemUoYXJyYXksIG4pIHtcbiAgICAgICAgICByZXR1cm4gc2h1ZmZsZVNlbGYoY29weUFycmF5KGFycmF5KSwgYmFzZUNsYW1wKG4sIDAsIGFycmF5Lmxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFycmF5U2h1ZmZsZShhcnJheSkge1xuICAgICAgICAgIHJldHVybiBzaHVmZmxlU2VsZihjb3B5QXJyYXkoYXJyYXkpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkMiAmJiAhZXEob2JqZWN0W2tleV0sIHZhbHVlKSB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkMiAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG4gICAgICAgICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gICAgICAgICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDIgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlQWdncmVnYXRvcihjb2xsZWN0aW9uLCBzZXR0ZXIsIGl0ZXJhdGVlMiwgYWNjdW11bGF0b3IpIHtcbiAgICAgICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uMikge1xuICAgICAgICAgICAgc2V0dGVyKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaXRlcmF0ZWUyKHZhbHVlKSwgY29sbGVjdGlvbjIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlQXNzaWduKG9iamVjdCwgc291cmNlKSB7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VBc3NpZ25JbihvYmplY3QsIHNvdXJjZSkge1xuICAgICAgICAgIHJldHVybiBvYmplY3QgJiYgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgICBpZiAoa2V5ID09IFwiX19wcm90b19fXCIgJiYgZGVmaW5lUHJvcGVydHkpIHtcbiAgICAgICAgICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG4gICAgICAgICAgICAgIFwiY29uZmlndXJhYmxlXCI6IHRydWUsXG4gICAgICAgICAgICAgIFwiZW51bWVyYWJsZVwiOiB0cnVlLFxuICAgICAgICAgICAgICBcInZhbHVlXCI6IHZhbHVlLFxuICAgICAgICAgICAgICBcIndyaXRhYmxlXCI6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlQXQob2JqZWN0LCBwYXRocykge1xuICAgICAgICAgIHZhciBpbmRleCA9IC0xLCBsZW5ndGggPSBwYXRocy5sZW5ndGgsIHJlc3VsdDIgPSBBcnJheTIobGVuZ3RoKSwgc2tpcCA9IG9iamVjdCA9PSBudWxsO1xuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQyW2luZGV4XSA9IHNraXAgPyB1bmRlZmluZWQyIDogZ2V0KG9iamVjdCwgcGF0aHNbaW5kZXhdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZUNsYW1wKG51bWJlciwgbG93ZXIsIHVwcGVyKSB7XG4gICAgICAgICAgaWYgKG51bWJlciA9PT0gbnVtYmVyKSB7XG4gICAgICAgICAgICBpZiAodXBwZXIgIT09IHVuZGVmaW5lZDIpIHtcbiAgICAgICAgICAgICAgbnVtYmVyID0gbnVtYmVyIDw9IHVwcGVyID8gbnVtYmVyIDogdXBwZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobG93ZXIgIT09IHVuZGVmaW5lZDIpIHtcbiAgICAgICAgICAgICAgbnVtYmVyID0gbnVtYmVyID49IGxvd2VyID8gbnVtYmVyIDogbG93ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZUNsb25lKHZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIG9iamVjdCwgc3RhY2spIHtcbiAgICAgICAgICB2YXIgcmVzdWx0MiwgaXNEZWVwID0gYml0bWFzayAmIENMT05FX0RFRVBfRkxBRywgaXNGbGF0ID0gYml0bWFzayAmIENMT05FX0ZMQVRfRkxBRywgaXNGdWxsID0gYml0bWFzayAmIENMT05FX1NZTUJPTFNfRkxBRztcbiAgICAgICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICAgICAgcmVzdWx0MiA9IG9iamVjdCA/IGN1c3RvbWl6ZXIodmFsdWUsIGtleSwgb2JqZWN0LCBzdGFjaykgOiBjdXN0b21pemVyKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDIgIT09IHVuZGVmaW5lZDIpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgICAgICAgICBpZiAoaXNBcnIpIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBpbml0Q2xvbmVBcnJheSh2YWx1ZSk7XG4gICAgICAgICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICAgICAgICByZXR1cm4gY29weUFycmF5KHZhbHVlLCByZXN1bHQyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSksIGlzRnVuYyA9IHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG4gICAgICAgICAgICBpZiAoaXNCdWZmZXIodmFsdWUpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjbG9uZUJ1ZmZlcih2YWx1ZSwgaXNEZWVwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YWcgPT0gb2JqZWN0VGFnIHx8IHRhZyA9PSBhcmdzVGFnIHx8IGlzRnVuYyAmJiAhb2JqZWN0KSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBpc0ZsYXQgfHwgaXNGdW5jID8ge30gOiBpbml0Q2xvbmVPYmplY3QodmFsdWUpO1xuICAgICAgICAgICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc0ZsYXQgPyBjb3B5U3ltYm9sc0luKHZhbHVlLCBiYXNlQXNzaWduSW4ocmVzdWx0MiwgdmFsdWUpKSA6IGNvcHlTeW1ib2xzKHZhbHVlLCBiYXNlQXNzaWduKHJlc3VsdDIsIHZhbHVlKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmICghY2xvbmVhYmxlVGFnc1t0YWddKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdCA/IHZhbHVlIDoge307XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0MiA9IGluaXRDbG9uZUJ5VGFnKHZhbHVlLCB0YWcsIGlzRGVlcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjaygpKTtcbiAgICAgICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldCh2YWx1ZSk7XG4gICAgICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFja2VkO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdGFjay5zZXQodmFsdWUsIHJlc3VsdDIpO1xuICAgICAgICAgIGlmIChpc1NldCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24oc3ViVmFsdWUpIHtcbiAgICAgICAgICAgICAgcmVzdWx0Mi5hZGQoYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdWJWYWx1ZSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzTWFwKHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbihzdWJWYWx1ZSwga2V5Mikge1xuICAgICAgICAgICAgICByZXN1bHQyLnNldChrZXkyLCBiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleTIsIHZhbHVlLCBzdGFjaykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBrZXlzRnVuYyA9IGlzRnVsbCA/IGlzRmxhdCA/IGdldEFsbEtleXNJbiA6IGdldEFsbEtleXMgOiBpc0ZsYXQgPyBrZXlzSW4gOiBrZXlzO1xuICAgICAgICAgIHZhciBwcm9wcyA9IGlzQXJyID8gdW5kZWZpbmVkMiA6IGtleXNGdW5jKHZhbHVlKTtcbiAgICAgICAgICBhcnJheUVhY2gocHJvcHMgfHwgdmFsdWUsIGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkyKSB7XG4gICAgICAgICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgICAgICAga2V5MiA9IHN1YlZhbHVlO1xuICAgICAgICAgICAgICBzdWJWYWx1ZSA9IHZhbHVlW2tleTJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzaWduVmFsdWUocmVzdWx0Miwga2V5MiwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXkyLCB2YWx1ZSwgc3RhY2spKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlQ29uZm9ybXMoc291cmNlKSB7XG4gICAgICAgICAgdmFyIHByb3BzID0ga2V5cyhzb3VyY2UpO1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBiYXNlQ29uZm9ybXNUbyhvYmplY3QsIHNvdXJjZSwgcHJvcHMpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZUNvbmZvcm1zVG8ob2JqZWN0LCBzb3VyY2UsIHByb3BzKSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcbiAgICAgICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAhbGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvYmplY3QgPSBPYmplY3QyKG9iamVjdCk7XG4gICAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gcHJvcHNbbGVuZ3RoXSwgcHJlZGljYXRlID0gc291cmNlW2tleV0sIHZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZDIgJiYgIShrZXkgaW4gb2JqZWN0KSB8fCAhcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VEZWxheShmdW5jLCB3YWl0LCBhcmdzKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBmdW5jICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjIoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBmdW5jLmFwcGx5KHVuZGVmaW5lZDIsIGFyZ3MpO1xuICAgICAgICAgIH0sIHdhaXQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VEaWZmZXJlbmNlKGFycmF5LCB2YWx1ZXMyLCBpdGVyYXRlZTIsIGNvbXBhcmF0b3IpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSAtMSwgaW5jbHVkZXMyID0gYXJyYXlJbmNsdWRlcywgaXNDb21tb24gPSB0cnVlLCBsZW5ndGggPSBhcnJheS5sZW5ndGgsIHJlc3VsdDIgPSBbXSwgdmFsdWVzTGVuZ3RoID0gdmFsdWVzMi5sZW5ndGg7XG4gICAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXRlcmF0ZWUyKSB7XG4gICAgICAgICAgICB2YWx1ZXMyID0gYXJyYXlNYXAodmFsdWVzMiwgYmFzZVVuYXJ5KGl0ZXJhdGVlMikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29tcGFyYXRvcikge1xuICAgICAgICAgICAgaW5jbHVkZXMyID0gYXJyYXlJbmNsdWRlc1dpdGg7XG4gICAgICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWVzMi5sZW5ndGggPj0gTEFSR0VfQVJSQVlfU0laRSkge1xuICAgICAgICAgICAgaW5jbHVkZXMyID0gY2FjaGVIYXM7XG4gICAgICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICAgICAgdmFsdWVzMiA9IG5ldyBTZXRDYWNoZSh2YWx1ZXMyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3V0ZXI6XG4gICAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sIGNvbXB1dGVkID0gaXRlcmF0ZWUyID09IG51bGwgPyB2YWx1ZSA6IGl0ZXJhdGVlMih2YWx1ZSk7XG4gICAgICAgICAgICAgIHZhbHVlID0gY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCA/IHZhbHVlIDogMDtcbiAgICAgICAgICAgICAgaWYgKGlzQ29tbW9uICYmIGNvbXB1dGVkID09PSBjb21wdXRlZCkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZXNJbmRleCA9IHZhbHVlc0xlbmd0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAodmFsdWVzSW5kZXgtLSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlczJbdmFsdWVzSW5kZXhdID09PSBjb21wdXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0Mi5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICghaW5jbHVkZXMyKHZhbHVlczIsIGNvbXB1dGVkLCBjb21wYXJhdG9yKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdDIucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmFzZUVhY2ggPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duKTtcbiAgICAgICAgdmFyIGJhc2VFYWNoUmlnaHQgPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duUmlnaHQsIHRydWUpO1xuICAgICAgICBmdW5jdGlvbiBiYXNlRXZlcnkoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdDIgPSB0cnVlO1xuICAgICAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbjIpIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSAhIXByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24yKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VFeHRyZW11bShhcnJheSwgaXRlcmF0ZWUyLCBjb21wYXJhdG9yKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLCBjdXJyZW50ID0gaXRlcmF0ZWUyKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50ICE9IG51bGwgJiYgKGNvbXB1dGVkID09PSB1bmRlZmluZWQyID8gY3VycmVudCA9PT0gY3VycmVudCAmJiAhaXNTeW1ib2woY3VycmVudCkgOiBjb21wYXJhdG9yKGN1cnJlbnQsIGNvbXB1dGVkKSkpIHtcbiAgICAgICAgICAgICAgdmFyIGNvbXB1dGVkID0gY3VycmVudCwgcmVzdWx0MiA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlRmlsbChhcnJheSwgdmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICAgIHN0YXJ0ID0gdG9JbnRlZ2VyKHN0YXJ0KTtcbiAgICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICBzdGFydCA9IC1zdGFydCA+IGxlbmd0aCA/IDAgOiBsZW5ndGggKyBzdGFydDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZW5kID0gZW5kID09PSB1bmRlZmluZWQyIHx8IGVuZCA+IGxlbmd0aCA/IGxlbmd0aCA6IHRvSW50ZWdlcihlbmQpO1xuICAgICAgICAgIGlmIChlbmQgPCAwKSB7XG4gICAgICAgICAgICBlbmQgKz0gbGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbmQgPSBzdGFydCA+IGVuZCA/IDAgOiB0b0xlbmd0aChlbmQpO1xuICAgICAgICAgIHdoaWxlIChzdGFydCA8IGVuZCkge1xuICAgICAgICAgICAgYXJyYXlbc3RhcnQrK10gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VGaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdDIgPSBbXTtcbiAgICAgICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24yKSB7XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbjIpKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZUZsYXR0ZW4oYXJyYXksIGRlcHRoLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQyKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICBwcmVkaWNhdGUgfHwgKHByZWRpY2F0ZSA9IGlzRmxhdHRlbmFibGUpO1xuICAgICAgICAgIHJlc3VsdDIgfHwgKHJlc3VsdDIgPSBbXSk7XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgICAgIGlmIChkZXB0aCA+IDAgJiYgcHJlZGljYXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgICBpZiAoZGVwdGggPiAxKSB7XG4gICAgICAgICAgICAgICAgYmFzZUZsYXR0ZW4odmFsdWUsIGRlcHRoIC0gMSwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0Mik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXJyYXlQdXNoKHJlc3VsdDIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICghaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MltyZXN1bHQyLmxlbmd0aF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJhc2VGb3IgPSBjcmVhdGVCYXNlRm9yKCk7XG4gICAgICAgIHZhciBiYXNlRm9yUmlnaHQgPSBjcmVhdGVCYXNlRm9yKHRydWUpO1xuICAgICAgICBmdW5jdGlvbiBiYXNlRm9yT3duKG9iamVjdCwgaXRlcmF0ZWUyKSB7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUyLCBrZXlzKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlRm9yT3duUmlnaHQob2JqZWN0LCBpdGVyYXRlZTIpIHtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3JSaWdodChvYmplY3QsIGl0ZXJhdGVlMiwga2V5cyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZUZ1bmN0aW9ucyhvYmplY3QsIHByb3BzKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5RmlsdGVyKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKG9iamVjdFtrZXldKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgcGF0aCkge1xuICAgICAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICAgICAgICAgIHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgb2JqZWN0ID0gb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXgrK10pXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCA/IG9iamVjdCA6IHVuZGVmaW5lZDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzRnVuYywgc3ltYm9sc0Z1bmMpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IGtleXNGdW5jKG9iamVjdCk7XG4gICAgICAgICAgcmV0dXJuIGlzQXJyYXkob2JqZWN0KSA/IHJlc3VsdDIgOiBhcnJheVB1c2gocmVzdWx0Miwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZDIgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0Mih2YWx1ZSkgPyBnZXRSYXdUYWcodmFsdWUpIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VHdCh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUgPiBvdGhlcjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlSGFzKG9iamVjdCwga2V5KSB7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VIYXNJbihvYmplY3QsIGtleSkge1xuICAgICAgICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBrZXkgaW4gT2JqZWN0MihvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VJblJhbmdlKG51bWJlciwgc3RhcnQsIGVuZCkge1xuICAgICAgICAgIHJldHVybiBudW1iZXIgPj0gbmF0aXZlTWluKHN0YXJ0LCBlbmQpICYmIG51bWJlciA8IG5hdGl2ZU1heChzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlSW50ZXJzZWN0aW9uKGFycmF5cywgaXRlcmF0ZWUyLCBjb21wYXJhdG9yKSB7XG4gICAgICAgICAgdmFyIGluY2x1ZGVzMiA9IGNvbXBhcmF0b3IgPyBhcnJheUluY2x1ZGVzV2l0aCA6IGFycmF5SW5jbHVkZXMsIGxlbmd0aCA9IGFycmF5c1swXS5sZW5ndGgsIG90aExlbmd0aCA9IGFycmF5cy5sZW5ndGgsIG90aEluZGV4ID0gb3RoTGVuZ3RoLCBjYWNoZXMgPSBBcnJheTIob3RoTGVuZ3RoKSwgbWF4TGVuZ3RoID0gSW5maW5pdHksIHJlc3VsdDIgPSBbXTtcbiAgICAgICAgICB3aGlsZSAob3RoSW5kZXgtLSkge1xuICAgICAgICAgICAgdmFyIGFycmF5ID0gYXJyYXlzW290aEluZGV4XTtcbiAgICAgICAgICAgIGlmIChvdGhJbmRleCAmJiBpdGVyYXRlZTIpIHtcbiAgICAgICAgICAgICAgYXJyYXkgPSBhcnJheU1hcChhcnJheSwgYmFzZVVuYXJ5KGl0ZXJhdGVlMikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWF4TGVuZ3RoID0gbmF0aXZlTWluKGFycmF5Lmxlbmd0aCwgbWF4TGVuZ3RoKTtcbiAgICAgICAgICAgIGNhY2hlc1tvdGhJbmRleF0gPSAhY29tcGFyYXRvciAmJiAoaXRlcmF0ZWUyIHx8IGxlbmd0aCA+PSAxMjAgJiYgYXJyYXkubGVuZ3RoID49IDEyMCkgPyBuZXcgU2V0Q2FjaGUob3RoSW5kZXggJiYgYXJyYXkpIDogdW5kZWZpbmVkMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXJyYXkgPSBhcnJheXNbMF07XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIHNlZW4gPSBjYWNoZXNbMF07XG4gICAgICAgICAgb3V0ZXI6XG4gICAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCAmJiByZXN1bHQyLmxlbmd0aCA8IG1heExlbmd0aCkge1xuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sIGNvbXB1dGVkID0gaXRlcmF0ZWUyID8gaXRlcmF0ZWUyKHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICAgICAgICB2YWx1ZSA9IGNvbXBhcmF0b3IgfHwgdmFsdWUgIT09IDAgPyB2YWx1ZSA6IDA7XG4gICAgICAgICAgICAgIGlmICghKHNlZW4gPyBjYWNoZUhhcyhzZWVuLCBjb21wdXRlZCkgOiBpbmNsdWRlczIocmVzdWx0MiwgY29tcHV0ZWQsIGNvbXBhcmF0b3IpKSkge1xuICAgICAgICAgICAgICAgIG90aEluZGV4ID0gb3RoTGVuZ3RoO1xuICAgICAgICAgICAgICAgIHdoaWxlICgtLW90aEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgY2FjaGUgPSBjYWNoZXNbb3RoSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgaWYgKCEoY2FjaGUgPyBjYWNoZUhhcyhjYWNoZSwgY29tcHV0ZWQpIDogaW5jbHVkZXMyKGFycmF5c1tvdGhJbmRleF0sIGNvbXB1dGVkLCBjb21wYXJhdG9yKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZWVuKSB7XG4gICAgICAgICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQyLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZUludmVydGVyKG9iamVjdCwgc2V0dGVyLCBpdGVyYXRlZTIsIGFjY3VtdWxhdG9yKSB7XG4gICAgICAgICAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdDIpIHtcbiAgICAgICAgICAgIHNldHRlcihhY2N1bXVsYXRvciwgaXRlcmF0ZWUyKHZhbHVlKSwga2V5LCBvYmplY3QyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZUludm9rZShvYmplY3QsIHBhdGgsIGFyZ3MpIHtcbiAgICAgICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgICAgICAgICBvYmplY3QgPSBwYXJlbnQob2JqZWN0LCBwYXRoKTtcbiAgICAgICAgICB2YXIgZnVuYyA9IG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogb2JqZWN0W3RvS2V5KGxhc3QocGF0aCkpXTtcbiAgICAgICAgICByZXR1cm4gZnVuYyA9PSBudWxsID8gdW5kZWZpbmVkMiA6IGFwcGx5KGZ1bmMsIG9iamVjdCwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlSXNBcnJheUJ1ZmZlcih2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFycmF5QnVmZmVyVGFnO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VJc0RhdGUodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBkYXRlVGFnO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgICAgICAgICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAhaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiYXNlSXNFcXVhbERlZXAodmFsdWUsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBiYXNlSXNFcXVhbCwgc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gICAgICAgICAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLCBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLCBvYmpUYWcgPSBvYmpJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG9iamVjdCksIG90aFRhZyA9IG90aElzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob3RoZXIpO1xuICAgICAgICAgIG9ialRhZyA9IG9ialRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb2JqVGFnO1xuICAgICAgICAgIG90aFRhZyA9IG90aFRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb3RoVGFnO1xuICAgICAgICAgIHZhciBvYmpJc09iaiA9IG9ialRhZyA9PSBvYmplY3RUYWcsIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZywgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcbiAgICAgICAgICBpZiAoaXNTYW1lVGFnICYmIGlzQnVmZmVyKG9iamVjdCkpIHtcbiAgICAgICAgICAgIGlmICghaXNCdWZmZXIob3RoZXIpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICAgICAgICAgIG9iaklzT2JqID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgICAgICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2soKSk7XG4gICAgICAgICAgICByZXR1cm4gb2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSA6IGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHKSkge1xuICAgICAgICAgICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBcIl9fd3JhcHBlZF9fXCIpLCBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBcIl9fd3JhcHBlZF9fXCIpO1xuICAgICAgICAgICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgICAgICAgICAgdmFyIG9ialVud3JhcHBlZCA9IG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LCBvdGhVbndyYXBwZWQgPSBvdGhJc1dyYXBwZWQgPyBvdGhlci52YWx1ZSgpIDogb3RoZXI7XG4gICAgICAgICAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjaygpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWlzU2FtZVRhZykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2soKSk7XG4gICAgICAgICAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlSXNNYXAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IG1hcFRhZztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgbWF0Y2hEYXRhLCBjdXN0b21pemVyKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gbWF0Y2hEYXRhLmxlbmd0aCwgbGVuZ3RoID0gaW5kZXgsIG5vQ3VzdG9taXplciA9ICFjdXN0b21pemVyO1xuICAgICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuICFsZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9iamVjdCA9IE9iamVjdDIob2JqZWN0KTtcbiAgICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdID8gZGF0YVsxXSAhPT0gb2JqZWN0W2RhdGFbMF1dIDogIShkYXRhWzBdIGluIG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgICAgICAgICB2YXIga2V5ID0gZGF0YVswXSwgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSwgc3JjVmFsdWUgPSBkYXRhWzFdO1xuICAgICAgICAgICAgaWYgKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKSB7XG4gICAgICAgICAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkMiAmJiAhKGtleSBpbiBvYmplY3QpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgc3RhY2sgPSBuZXcgU3RhY2soKTtcbiAgICAgICAgICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MiA9IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjayk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCEocmVzdWx0MiA9PT0gdW5kZWZpbmVkMiA/IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHLCBjdXN0b21pemVyLCBzdGFjaykgOiByZXN1bHQyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgICAgICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gICAgICAgICAgcmV0dXJuIHBhdHRlcm4udGVzdCh0b1NvdXJjZSh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VJc1JlZ0V4cCh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHJlZ2V4cFRhZztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlSXNTZXQodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IHNldFRhZztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlSXRlcmF0ZWUodmFsdWUpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGlkZW50aXR5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0FycmF5KHZhbHVlKSA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKSA6IGJhc2VNYXRjaGVzKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgICAgICAgICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZXN1bHQyID0gW107XG4gICAgICAgICAgZm9yICh2YXIga2V5IGluIE9iamVjdDIob2JqZWN0KSkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgICAgICAgICAgcmVzdWx0Mi5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VLZXlzSW4ob2JqZWN0KSB7XG4gICAgICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpc1Byb3RvID0gaXNQcm90b3R5cGUob2JqZWN0KSwgcmVzdWx0MiA9IFtdO1xuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgIGlmICghKGtleSA9PSBcImNvbnN0cnVjdG9yXCIgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgICAgICAgICAgcmVzdWx0Mi5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VMdCh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUgPCBvdGhlcjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlTWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlMikge1xuICAgICAgICAgIHZhciBpbmRleCA9IC0xLCByZXN1bHQyID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheTIoY29sbGVjdGlvbi5sZW5ndGgpIDogW107XG4gICAgICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbjIpIHtcbiAgICAgICAgICAgIHJlc3VsdDJbKytpbmRleF0gPSBpdGVyYXRlZTIodmFsdWUsIGtleSwgY29sbGVjdGlvbjIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VNYXRjaGVzKHNvdXJjZSkge1xuICAgICAgICAgIHZhciBtYXRjaERhdGEgPSBnZXRNYXRjaERhdGEoc291cmNlKTtcbiAgICAgICAgICBpZiAobWF0Y2hEYXRhLmxlbmd0aCA9PSAxICYmIG1hdGNoRGF0YVswXVsyXSkge1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKG1hdGNoRGF0YVswXVswXSwgbWF0Y2hEYXRhWzBdWzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICAgICAgICAgIGlmIChpc0tleShwYXRoKSAmJiBpc1N0cmljdENvbXBhcmFibGUoc3JjVmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUodG9LZXkocGF0aCksIHNyY1ZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgICAgdmFyIG9ialZhbHVlID0gZ2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICAgICAgICByZXR1cm4gb2JqVmFsdWUgPT09IHVuZGVmaW5lZDIgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlID8gaGFzSW4ob2JqZWN0LCBwYXRoKSA6IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gICAgICAgICAgaWYgKG9iamVjdCA9PT0gc291cmNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGJhc2VGb3Ioc291cmNlLCBmdW5jdGlvbihzcmNWYWx1ZSwga2V5KSB7XG4gICAgICAgICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2soKSk7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3Qoc3JjVmFsdWUpKSB7XG4gICAgICAgICAgICAgIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIGJhc2VNZXJnZSwgY3VzdG9taXplciwgc3RhY2spO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIoc2FmZUdldChvYmplY3QsIGtleSksIHNyY1ZhbHVlLCBrZXkgKyBcIlwiLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spIDogdW5kZWZpbmVkMjtcbiAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQyKSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBzcmNWYWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwga2V5c0luKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBtZXJnZUZ1bmMsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gICAgICAgICAgdmFyIG9ialZhbHVlID0gc2FmZUdldChvYmplY3QsIGtleSksIHNyY1ZhbHVlID0gc2FmZUdldChzb3VyY2UsIGtleSksIHN0YWNrZWQgPSBzdGFjay5nZXQoc3JjVmFsdWUpO1xuICAgICAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgICAgICBhc3NpZ25NZXJnZVZhbHVlKG9iamVjdCwga2V5LCBzdGFja2VkKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXkgKyBcIlwiLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spIDogdW5kZWZpbmVkMjtcbiAgICAgICAgICB2YXIgaXNDb21tb24gPSBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkMjtcbiAgICAgICAgICBpZiAoaXNDb21tb24pIHtcbiAgICAgICAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkoc3JjVmFsdWUpLCBpc0J1ZmYgPSAhaXNBcnIgJiYgaXNCdWZmZXIoc3JjVmFsdWUpLCBpc1R5cGVkID0gIWlzQXJyICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHNyY1ZhbHVlKTtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgICAgICAgICBpZiAoaXNBcnIgfHwgaXNCdWZmIHx8IGlzVHlwZWQpIHtcbiAgICAgICAgICAgICAgaWYgKGlzQXJyYXkob2JqVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5TGlrZU9iamVjdChvYmpWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IGNvcHlBcnJheShvYmpWYWx1ZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNCdWZmKSB7XG4gICAgICAgICAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IGNsb25lQnVmZmVyKHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc1R5cGVkKSB7XG4gICAgICAgICAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IGNsb25lVHlwZWRBcnJheShzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBbXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHNyY1ZhbHVlKSB8fCBpc0FyZ3VtZW50cyhzcmNWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgbmV3VmFsdWUgPSBvYmpWYWx1ZTtcbiAgICAgICAgICAgICAgaWYgKGlzQXJndW1lbnRzKG9ialZhbHVlKSkge1xuICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gdG9QbGFpbk9iamVjdChvYmpWYWx1ZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWlzT2JqZWN0KG9ialZhbHVlKSB8fCBpc0Z1bmN0aW9uKG9ialZhbHVlKSkge1xuICAgICAgICAgICAgICAgIG5ld1ZhbHVlID0gaW5pdENsb25lT2JqZWN0KHNyY1ZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQ29tbW9uKSB7XG4gICAgICAgICAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIG1lcmdlRnVuYyhuZXdWYWx1ZSwgc3JjVmFsdWUsIHNyY0luZGV4LCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgICAgICAgICBzdGFja1tcImRlbGV0ZVwiXShzcmNWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlTnRoKGFycmF5LCBuKSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuICs9IG4gPCAwID8gbGVuZ3RoIDogMDtcbiAgICAgICAgICByZXR1cm4gaXNJbmRleChuLCBsZW5ndGgpID8gYXJyYXlbbl0gOiB1bmRlZmluZWQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzKSB7XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGl0ZXJhdGVlcyA9IGFycmF5TWFwKGl0ZXJhdGVlcywgZnVuY3Rpb24oaXRlcmF0ZWUyKSB7XG4gICAgICAgICAgICAgIGlmIChpc0FycmF5KGl0ZXJhdGVlMikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlR2V0KHZhbHVlLCBpdGVyYXRlZTIubGVuZ3RoID09PSAxID8gaXRlcmF0ZWUyWzBdIDogaXRlcmF0ZWUyKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBpdGVyYXRlZTI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaXRlcmF0ZWVzID0gW2lkZW50aXR5XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgICAgaXRlcmF0ZWVzID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBiYXNlVW5hcnkoZ2V0SXRlcmF0ZWUoKSkpO1xuICAgICAgICAgIHZhciByZXN1bHQyID0gYmFzZU1hcChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uMikge1xuICAgICAgICAgICAgdmFyIGNyaXRlcmlhID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBmdW5jdGlvbihpdGVyYXRlZTIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdGVlMih2YWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7IFwiY3JpdGVyaWFcIjogY3JpdGVyaWEsIFwiaW5kZXhcIjogKytpbmRleCwgXCJ2YWx1ZVwiOiB2YWx1ZSB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBiYXNlU29ydEJ5KHJlc3VsdDIsIGZ1bmN0aW9uKG9iamVjdCwgb3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlUGljayhvYmplY3QsIHBhdGhzKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VQaWNrQnkob2JqZWN0LCBwYXRocywgZnVuY3Rpb24odmFsdWUsIHBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBoYXNJbihvYmplY3QsIHBhdGgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VQaWNrQnkob2JqZWN0LCBwYXRocywgcHJlZGljYXRlKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCwgcmVzdWx0MiA9IHt9O1xuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgcGF0aCA9IHBhdGhzW2luZGV4XSwgdmFsdWUgPSBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBwYXRoKSkge1xuICAgICAgICAgICAgICBiYXNlU2V0KHJlc3VsdDIsIGNhc3RQYXRoKHBhdGgsIG9iamVjdCksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZVByb3BlcnR5RGVlcChwYXRoKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VQdWxsQWxsKGFycmF5LCB2YWx1ZXMyLCBpdGVyYXRlZTIsIGNvbXBhcmF0b3IpIHtcbiAgICAgICAgICB2YXIgaW5kZXhPZjIgPSBjb21wYXJhdG9yID8gYmFzZUluZGV4T2ZXaXRoIDogYmFzZUluZGV4T2YsIGluZGV4ID0gLTEsIGxlbmd0aCA9IHZhbHVlczIubGVuZ3RoLCBzZWVuID0gYXJyYXk7XG4gICAgICAgICAgaWYgKGFycmF5ID09PSB2YWx1ZXMyKSB7XG4gICAgICAgICAgICB2YWx1ZXMyID0gY29weUFycmF5KHZhbHVlczIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXRlcmF0ZWUyKSB7XG4gICAgICAgICAgICBzZWVuID0gYXJyYXlNYXAoYXJyYXksIGJhc2VVbmFyeShpdGVyYXRlZTIpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBmcm9tSW5kZXggPSAwLCB2YWx1ZSA9IHZhbHVlczJbaW5kZXhdLCBjb21wdXRlZCA9IGl0ZXJhdGVlMiA/IGl0ZXJhdGVlMih2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgICAgIHdoaWxlICgoZnJvbUluZGV4ID0gaW5kZXhPZjIoc2VlbiwgY29tcHV0ZWQsIGZyb21JbmRleCwgY29tcGFyYXRvcikpID4gLTEpIHtcbiAgICAgICAgICAgICAgaWYgKHNlZW4gIT09IGFycmF5KSB7XG4gICAgICAgICAgICAgICAgc3BsaWNlLmNhbGwoc2VlbiwgZnJvbUluZGV4LCAxKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzcGxpY2UuY2FsbChhcnJheSwgZnJvbUluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VQdWxsQXQoYXJyYXksIGluZGV4ZXMpIHtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBpbmRleGVzLmxlbmd0aCA6IDAsIGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG4gICAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBpbmRleGVzW2xlbmd0aF07XG4gICAgICAgICAgICBpZiAobGVuZ3RoID09IGxhc3RJbmRleCB8fCBpbmRleCAhPT0gcHJldmlvdXMpIHtcbiAgICAgICAgICAgICAgdmFyIHByZXZpb3VzID0gaW5kZXg7XG4gICAgICAgICAgICAgIGlmIChpc0luZGV4KGluZGV4KSkge1xuICAgICAgICAgICAgICAgIHNwbGljZS5jYWxsKGFycmF5LCBpbmRleCwgMSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYmFzZVVuc2V0KGFycmF5LCBpbmRleCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VSYW5kb20obG93ZXIsIHVwcGVyKSB7XG4gICAgICAgICAgcmV0dXJuIGxvd2VyICsgbmF0aXZlRmxvb3IobmF0aXZlUmFuZG9tKCkgKiAodXBwZXIgLSBsb3dlciArIDEpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlUmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCwgZnJvbVJpZ2h0KSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IG5hdGl2ZU1heChuYXRpdmVDZWlsKChlbmQgLSBzdGFydCkgLyAoc3RlcCB8fCAxKSksIDApLCByZXN1bHQyID0gQXJyYXkyKGxlbmd0aCk7XG4gICAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgICByZXN1bHQyW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdID0gc3RhcnQ7XG4gICAgICAgICAgICBzdGFydCArPSBzdGVwO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlUmVwZWF0KHN0cmluZywgbikge1xuICAgICAgICAgIHZhciByZXN1bHQyID0gXCJcIjtcbiAgICAgICAgICBpZiAoIXN0cmluZyB8fCBuIDwgMSB8fCBuID4gTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGlmIChuICUgMikge1xuICAgICAgICAgICAgICByZXN1bHQyICs9IHN0cmluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG4gPSBuYXRpdmVGbG9vcihuIC8gMik7XG4gICAgICAgICAgICBpZiAobikge1xuICAgICAgICAgICAgICBzdHJpbmcgKz0gc3RyaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKG4pO1xuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VSZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gICAgICAgICAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eSksIGZ1bmMgKyBcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlU2FtcGxlKGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gYXJyYXlTYW1wbGUodmFsdWVzKGNvbGxlY3Rpb24pKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlU2FtcGxlU2l6ZShjb2xsZWN0aW9uLCBuKSB7XG4gICAgICAgICAgdmFyIGFycmF5ID0gdmFsdWVzKGNvbGxlY3Rpb24pO1xuICAgICAgICAgIHJldHVybiBzaHVmZmxlU2VsZihhcnJheSwgYmFzZUNsYW1wKG4sIDAsIGFycmF5Lmxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcikge1xuICAgICAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IHBhdGgubGVuZ3RoLCBsYXN0SW5kZXggPSBsZW5ndGggLSAxLCBuZXN0ZWQgPSBvYmplY3Q7XG4gICAgICAgICAgd2hpbGUgKG5lc3RlZCAhPSBudWxsICYmICsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSksIG5ld1ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcIl9fcHJvdG9fX1wiIHx8IGtleSA9PT0gXCJjb25zdHJ1Y3RvclwiIHx8IGtleSA9PT0gXCJwcm90b3R5cGVcIikge1xuICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluZGV4ICE9IGxhc3RJbmRleCkge1xuICAgICAgICAgICAgICB2YXIgb2JqVmFsdWUgPSBuZXN0ZWRba2V5XTtcbiAgICAgICAgICAgICAgbmV3VmFsdWUgPSBjdXN0b21pemVyID8gY3VzdG9taXplcihvYmpWYWx1ZSwga2V5LCBuZXN0ZWQpIDogdW5kZWZpbmVkMjtcbiAgICAgICAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQyKSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWUgPSBpc09iamVjdChvYmpWYWx1ZSkgPyBvYmpWYWx1ZSA6IGlzSW5kZXgocGF0aFtpbmRleCArIDFdKSA/IFtdIDoge307XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2lnblZhbHVlKG5lc3RlZCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICBuZXN0ZWQgPSBuZXN0ZWRba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmFzZVNldERhdGEgPSAhbWV0YU1hcCA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgZGF0YSkge1xuICAgICAgICAgIG1ldGFNYXAuc2V0KGZ1bmMsIGRhdGEpO1xuICAgICAgICAgIHJldHVybiBmdW5jO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgYmFzZVNldFRvU3RyaW5nID0gIWRlZmluZVByb3BlcnR5ID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBzdHJpbmcpIHtcbiAgICAgICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkoZnVuYywgXCJ0b1N0cmluZ1wiLCB7XG4gICAgICAgICAgICBcImNvbmZpZ3VyYWJsZVwiOiB0cnVlLFxuICAgICAgICAgICAgXCJlbnVtZXJhYmxlXCI6IGZhbHNlLFxuICAgICAgICAgICAgXCJ2YWx1ZVwiOiBjb25zdGFudChzdHJpbmcpLFxuICAgICAgICAgICAgXCJ3cml0YWJsZVwiOiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VTaHVmZmxlKGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gc2h1ZmZsZVNlbGYodmFsdWVzKGNvbGxlY3Rpb24pKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSAtMSwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gLXN0YXJ0ID4gbGVuZ3RoID8gMCA6IGxlbmd0aCArIHN0YXJ0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbmQgPSBlbmQgPiBsZW5ndGggPyBsZW5ndGggOiBlbmQ7XG4gICAgICAgICAgaWYgKGVuZCA8IDApIHtcbiAgICAgICAgICAgIGVuZCArPSBsZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxlbmd0aCA9IHN0YXJ0ID4gZW5kID8gMCA6IGVuZCAtIHN0YXJ0ID4+PiAwO1xuICAgICAgICAgIHN0YXJ0ID4+Pj0gMDtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IEFycmF5MihsZW5ndGgpO1xuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQyW2luZGV4XSA9IGFycmF5W2luZGV4ICsgc3RhcnRdO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlU29tZShjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0MjtcbiAgICAgICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24yKSB7XG4gICAgICAgICAgICByZXN1bHQyID0gcHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbjIpO1xuICAgICAgICAgICAgcmV0dXJuICFyZXN1bHQyO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiAhIXJlc3VsdDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSwgcmV0SGlnaGVzdCkge1xuICAgICAgICAgIHZhciBsb3cgPSAwLCBoaWdoID0gYXJyYXkgPT0gbnVsbCA/IGxvdyA6IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIgJiYgdmFsdWUgPT09IHZhbHVlICYmIGhpZ2ggPD0gSEFMRl9NQVhfQVJSQVlfTEVOR1RIKSB7XG4gICAgICAgICAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgICAgICAgICB2YXIgbWlkID0gbG93ICsgaGlnaCA+Pj4gMSwgY29tcHV0ZWQgPSBhcnJheVttaWRdO1xuICAgICAgICAgICAgICBpZiAoY29tcHV0ZWQgIT09IG51bGwgJiYgIWlzU3ltYm9sKGNvbXB1dGVkKSAmJiAocmV0SGlnaGVzdCA/IGNvbXB1dGVkIDw9IHZhbHVlIDogY29tcHV0ZWQgPCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBoaWdoO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBpZGVudGl0eSwgcmV0SGlnaGVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBpdGVyYXRlZTIsIHJldEhpZ2hlc3QpIHtcbiAgICAgICAgICB2YXIgbG93ID0gMCwgaGlnaCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgICAgIGlmIChoaWdoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWUgPSBpdGVyYXRlZTIodmFsdWUpO1xuICAgICAgICAgIHZhciB2YWxJc05hTiA9IHZhbHVlICE9PSB2YWx1ZSwgdmFsSXNOdWxsID0gdmFsdWUgPT09IG51bGwsIHZhbElzU3ltYm9sID0gaXNTeW1ib2wodmFsdWUpLCB2YWxJc1VuZGVmaW5lZCA9IHZhbHVlID09PSB1bmRlZmluZWQyO1xuICAgICAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgICAgICB2YXIgbWlkID0gbmF0aXZlRmxvb3IoKGxvdyArIGhpZ2gpIC8gMiksIGNvbXB1dGVkID0gaXRlcmF0ZWUyKGFycmF5W21pZF0pLCBvdGhJc0RlZmluZWQgPSBjb21wdXRlZCAhPT0gdW5kZWZpbmVkMiwgb3RoSXNOdWxsID0gY29tcHV0ZWQgPT09IG51bGwsIG90aElzUmVmbGV4aXZlID0gY29tcHV0ZWQgPT09IGNvbXB1dGVkLCBvdGhJc1N5bWJvbCA9IGlzU3ltYm9sKGNvbXB1dGVkKTtcbiAgICAgICAgICAgIGlmICh2YWxJc05hTikge1xuICAgICAgICAgICAgICB2YXIgc2V0TG93ID0gcmV0SGlnaGVzdCB8fCBvdGhJc1JlZmxleGl2ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsSXNVbmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgc2V0TG93ID0gb3RoSXNSZWZsZXhpdmUgJiYgKHJldEhpZ2hlc3QgfHwgb3RoSXNEZWZpbmVkKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsSXNOdWxsKSB7XG4gICAgICAgICAgICAgIHNldExvdyA9IG90aElzUmVmbGV4aXZlICYmIG90aElzRGVmaW5lZCAmJiAocmV0SGlnaGVzdCB8fCAhb3RoSXNOdWxsKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsSXNTeW1ib2wpIHtcbiAgICAgICAgICAgICAgc2V0TG93ID0gb3RoSXNSZWZsZXhpdmUgJiYgb3RoSXNEZWZpbmVkICYmICFvdGhJc051bGwgJiYgKHJldEhpZ2hlc3QgfHwgIW90aElzU3ltYm9sKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3RoSXNOdWxsIHx8IG90aElzU3ltYm9sKSB7XG4gICAgICAgICAgICAgIHNldExvdyA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2V0TG93ID0gcmV0SGlnaGVzdCA/IGNvbXB1dGVkIDw9IHZhbHVlIDogY29tcHV0ZWQgPCB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZXRMb3cpIHtcbiAgICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuYXRpdmVNaW4oaGlnaCwgTUFYX0FSUkFZX0lOREVYKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlU29ydGVkVW5pcShhcnJheSwgaXRlcmF0ZWUyKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCwgcmVzSW5kZXggPSAwLCByZXN1bHQyID0gW107XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSwgY29tcHV0ZWQgPSBpdGVyYXRlZTIgPyBpdGVyYXRlZTIodmFsdWUpIDogdmFsdWU7XG4gICAgICAgICAgICBpZiAoIWluZGV4IHx8ICFlcShjb21wdXRlZCwgc2VlbikpIHtcbiAgICAgICAgICAgICAgdmFyIHNlZW4gPSBjb21wdXRlZDtcbiAgICAgICAgICAgICAgcmVzdWx0MltyZXNJbmRleCsrXSA9IHZhbHVlID09PSAwID8gMCA6IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlVG9OdW1iZXIodmFsdWUpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5BTjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuICt2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIGJhc2VUb1N0cmluZykgKyBcIlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6IFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZXN1bHQyID0gdmFsdWUgKyBcIlwiO1xuICAgICAgICAgIHJldHVybiByZXN1bHQyID09IFwiMFwiICYmIDEgLyB2YWx1ZSA9PSAtSU5GSU5JVFkgPyBcIi0wXCIgOiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VVbmlxKGFycmF5LCBpdGVyYXRlZTIsIGNvbXBhcmF0b3IpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSAtMSwgaW5jbHVkZXMyID0gYXJyYXlJbmNsdWRlcywgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLCBpc0NvbW1vbiA9IHRydWUsIHJlc3VsdDIgPSBbXSwgc2VlbiA9IHJlc3VsdDI7XG4gICAgICAgICAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICAgICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgICAgICBpbmNsdWRlczIgPSBhcnJheUluY2x1ZGVzV2l0aDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxlbmd0aCA+PSBMQVJHRV9BUlJBWV9TSVpFKSB7XG4gICAgICAgICAgICB2YXIgc2V0MiA9IGl0ZXJhdGVlMiA/IG51bGwgOiBjcmVhdGVTZXQoYXJyYXkpO1xuICAgICAgICAgICAgaWYgKHNldDIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHNldFRvQXJyYXkoc2V0Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICAgICAgaW5jbHVkZXMyID0gY2FjaGVIYXM7XG4gICAgICAgICAgICBzZWVuID0gbmV3IFNldENhY2hlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlZW4gPSBpdGVyYXRlZTIgPyBbXSA6IHJlc3VsdDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dGVyOlxuICAgICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLCBjb21wdXRlZCA9IGl0ZXJhdGVlMiA/IGl0ZXJhdGVlMih2YWx1ZSkgOiB2YWx1ZTtcbiAgICAgICAgICAgICAgdmFsdWUgPSBjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwID8gdmFsdWUgOiAwO1xuICAgICAgICAgICAgICBpZiAoaXNDb21tb24gJiYgY29tcHV0ZWQgPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlZW5JbmRleCA9IHNlZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzZWVuSW5kZXgtLSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHNlZW5bc2VlbkluZGV4XSA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpdGVyYXRlZTIpIHtcbiAgICAgICAgICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdDIucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWluY2x1ZGVzMihzZWVuLCBjb21wdXRlZCwgY29tcGFyYXRvcikpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VlbiAhPT0gcmVzdWx0Mikge1xuICAgICAgICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0Mi5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VVbnNldChvYmplY3QsIHBhdGgpIHtcbiAgICAgICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgICAgICAgICBvYmplY3QgPSBwYXJlbnQob2JqZWN0LCBwYXRoKTtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgfHwgZGVsZXRlIG9iamVjdFt0b0tleShsYXN0KHBhdGgpKV07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZVVwZGF0ZShvYmplY3QsIHBhdGgsIHVwZGF0ZXIsIGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgICByZXR1cm4gYmFzZVNldChvYmplY3QsIHBhdGgsIHVwZGF0ZXIoYmFzZUdldChvYmplY3QsIHBhdGgpKSwgY3VzdG9taXplcik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmFzZVdoaWxlKGFycmF5LCBwcmVkaWNhdGUsIGlzRHJvcCwgZnJvbVJpZ2h0KSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCwgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMTtcbiAgICAgICAgICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSAmJiBwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpc0Ryb3AgPyBiYXNlU2xpY2UoYXJyYXksIGZyb21SaWdodCA/IDAgOiBpbmRleCwgZnJvbVJpZ2h0ID8gaW5kZXggKyAxIDogbGVuZ3RoKSA6IGJhc2VTbGljZShhcnJheSwgZnJvbVJpZ2h0ID8gaW5kZXggKyAxIDogMCwgZnJvbVJpZ2h0ID8gbGVuZ3RoIDogaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGJhc2VXcmFwcGVyVmFsdWUodmFsdWUsIGFjdGlvbnMpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IHZhbHVlO1xuICAgICAgICAgIGlmIChyZXN1bHQyIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSByZXN1bHQyLnZhbHVlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhcnJheVJlZHVjZShhY3Rpb25zLCBmdW5jdGlvbihyZXN1bHQzLCBhY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb24uZnVuYy5hcHBseShhY3Rpb24udGhpc0FyZywgYXJyYXlQdXNoKFtyZXN1bHQzXSwgYWN0aW9uLmFyZ3MpKTtcbiAgICAgICAgICB9LCByZXN1bHQyKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlWG9yKGFycmF5cywgaXRlcmF0ZWUyLCBjb21wYXJhdG9yKSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGFycmF5cy5sZW5ndGg7XG4gICAgICAgICAgaWYgKGxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlVW5pcShhcnJheXNbMF0pIDogW107XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpbmRleCA9IC0xLCByZXN1bHQyID0gQXJyYXkyKGxlbmd0aCk7XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBhcnJheSA9IGFycmF5c1tpbmRleF0sIG90aEluZGV4ID0gLTE7XG4gICAgICAgICAgICB3aGlsZSAoKytvdGhJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICBpZiAob3RoSW5kZXggIT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQyW2luZGV4XSA9IGJhc2VEaWZmZXJlbmNlKHJlc3VsdDJbaW5kZXhdIHx8IGFycmF5LCBhcnJheXNbb3RoSW5kZXhdLCBpdGVyYXRlZTIsIGNvbXBhcmF0b3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihyZXN1bHQyLCAxKSwgaXRlcmF0ZWUyLCBjb21wYXJhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBiYXNlWmlwT2JqZWN0KHByb3BzLCB2YWx1ZXMyLCBhc3NpZ25GdW5jKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IHByb3BzLmxlbmd0aCwgdmFsc0xlbmd0aCA9IHZhbHVlczIubGVuZ3RoLCByZXN1bHQyID0ge307XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGluZGV4IDwgdmFsc0xlbmd0aCA/IHZhbHVlczJbaW5kZXhdIDogdW5kZWZpbmVkMjtcbiAgICAgICAgICAgIGFzc2lnbkZ1bmMocmVzdWx0MiwgcHJvcHNbaW5kZXhdLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNhc3RBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpID8gdmFsdWUgOiBbXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjYXN0RnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09IFwiZnVuY3Rpb25cIiA/IHZhbHVlIDogaWRlbnRpdHk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUsIG9iamVjdCkge1xuICAgICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhc3RSZXN0ID0gYmFzZVJlc3Q7XG4gICAgICAgIGZ1bmN0aW9uIGNhc3RTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgICAgICAgZW5kID0gZW5kID09PSB1bmRlZmluZWQyID8gbGVuZ3RoIDogZW5kO1xuICAgICAgICAgIHJldHVybiAhc3RhcnQgJiYgZW5kID49IGxlbmd0aCA/IGFycmF5IDogYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2xlYXJUaW1lb3V0ID0gY3R4Q2xlYXJUaW1lb3V0IHx8IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgcmV0dXJuIHJvb3QuY2xlYXJUaW1lb3V0KGlkKTtcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcbiAgICAgICAgICBpZiAoaXNEZWVwKSB7XG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyLnNsaWNlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBsZW5ndGggPSBidWZmZXIubGVuZ3RoLCByZXN1bHQyID0gYWxsb2NVbnNhZmUgPyBhbGxvY1Vuc2FmZShsZW5ndGgpIDogbmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuICAgICAgICAgIGJ1ZmZlci5jb3B5KHJlc3VsdDIpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNsb25lQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICBuZXcgVWludDhBcnJheTIocmVzdWx0Mikuc2V0KG5ldyBVaW50OEFycmF5MihhcnJheUJ1ZmZlcikpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNsb25lRGF0YVZpZXcoZGF0YVZpZXcsIGlzRGVlcCkge1xuICAgICAgICAgIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKGRhdGFWaWV3LmJ1ZmZlcikgOiBkYXRhVmlldy5idWZmZXI7XG4gICAgICAgICAgcmV0dXJuIG5ldyBkYXRhVmlldy5jb25zdHJ1Y3RvcihidWZmZXIsIGRhdGFWaWV3LmJ5dGVPZmZzZXQsIGRhdGFWaWV3LmJ5dGVMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNsb25lUmVnRXhwKHJlZ2V4cCkge1xuICAgICAgICAgIHZhciByZXN1bHQyID0gbmV3IHJlZ2V4cC5jb25zdHJ1Y3RvcihyZWdleHAuc291cmNlLCByZUZsYWdzLmV4ZWMocmVnZXhwKSk7XG4gICAgICAgICAgcmVzdWx0Mi5sYXN0SW5kZXggPSByZWdleHAubGFzdEluZGV4O1xuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNsb25lU3ltYm9sKHN5bWJvbCkge1xuICAgICAgICAgIHJldHVybiBzeW1ib2xWYWx1ZU9mID8gT2JqZWN0MihzeW1ib2xWYWx1ZU9mLmNhbGwoc3ltYm9sKSkgOiB7fTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjbG9uZVR5cGVkQXJyYXkodHlwZWRBcnJheSwgaXNEZWVwKSB7XG4gICAgICAgICAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIodHlwZWRBcnJheS5idWZmZXIpIDogdHlwZWRBcnJheS5idWZmZXI7XG4gICAgICAgICAgcmV0dXJuIG5ldyB0eXBlZEFycmF5LmNvbnN0cnVjdG9yKGJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5Lmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY29tcGFyZUFzY2VuZGluZyh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IG90aGVyKSB7XG4gICAgICAgICAgICB2YXIgdmFsSXNEZWZpbmVkID0gdmFsdWUgIT09IHVuZGVmaW5lZDIsIHZhbElzTnVsbCA9IHZhbHVlID09PSBudWxsLCB2YWxJc1JlZmxleGl2ZSA9IHZhbHVlID09PSB2YWx1ZSwgdmFsSXNTeW1ib2wgPSBpc1N5bWJvbCh2YWx1ZSk7XG4gICAgICAgICAgICB2YXIgb3RoSXNEZWZpbmVkID0gb3RoZXIgIT09IHVuZGVmaW5lZDIsIG90aElzTnVsbCA9IG90aGVyID09PSBudWxsLCBvdGhJc1JlZmxleGl2ZSA9IG90aGVyID09PSBvdGhlciwgb3RoSXNTeW1ib2wgPSBpc1N5bWJvbChvdGhlcik7XG4gICAgICAgICAgICBpZiAoIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wgJiYgIXZhbElzU3ltYm9sICYmIHZhbHVlID4gb3RoZXIgfHwgdmFsSXNTeW1ib2wgJiYgb3RoSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlICYmICFvdGhJc051bGwgJiYgIW90aElzU3ltYm9sIHx8IHZhbElzTnVsbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUgfHwgIXZhbElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSB8fCAhdmFsSXNSZWZsZXhpdmUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXZhbElzTnVsbCAmJiAhdmFsSXNTeW1ib2wgJiYgIW90aElzU3ltYm9sICYmIHZhbHVlIDwgb3RoZXIgfHwgb3RoSXNTeW1ib2wgJiYgdmFsSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlICYmICF2YWxJc051bGwgJiYgIXZhbElzU3ltYm9sIHx8IG90aElzTnVsbCAmJiB2YWxJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUgfHwgIW90aElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSB8fCAhb3RoSXNSZWZsZXhpdmUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIG9iakNyaXRlcmlhID0gb2JqZWN0LmNyaXRlcmlhLCBvdGhDcml0ZXJpYSA9IG90aGVyLmNyaXRlcmlhLCBsZW5ndGggPSBvYmpDcml0ZXJpYS5sZW5ndGgsIG9yZGVyc0xlbmd0aCA9IG9yZGVycy5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQyID0gY29tcGFyZUFzY2VuZGluZyhvYmpDcml0ZXJpYVtpbmRleF0sIG90aENyaXRlcmlhW2luZGV4XSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0Mikge1xuICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gb3JkZXJzTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIG9yZGVyID0gb3JkZXJzW2luZGV4XTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDIgKiAob3JkZXIgPT0gXCJkZXNjXCIgPyAtMSA6IDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb2JqZWN0LmluZGV4IC0gb3RoZXIuaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY29tcG9zZUFyZ3MoYXJncywgcGFydGlhbHMsIGhvbGRlcnMsIGlzQ3VycmllZCkge1xuICAgICAgICAgIHZhciBhcmdzSW5kZXggPSAtMSwgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoLCBob2xkZXJzTGVuZ3RoID0gaG9sZGVycy5sZW5ndGgsIGxlZnRJbmRleCA9IC0xLCBsZWZ0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLCByYW5nZUxlbmd0aCA9IG5hdGl2ZU1heChhcmdzTGVuZ3RoIC0gaG9sZGVyc0xlbmd0aCwgMCksIHJlc3VsdDIgPSBBcnJheTIobGVmdExlbmd0aCArIHJhbmdlTGVuZ3RoKSwgaXNVbmN1cnJpZWQgPSAhaXNDdXJyaWVkO1xuICAgICAgICAgIHdoaWxlICgrK2xlZnRJbmRleCA8IGxlZnRMZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdDJbbGVmdEluZGV4XSA9IHBhcnRpYWxzW2xlZnRJbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlICgrK2FyZ3NJbmRleCA8IGhvbGRlcnNMZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChpc1VuY3VycmllZCB8fCBhcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDJbaG9sZGVyc1thcmdzSW5kZXhdXSA9IGFyZ3NbYXJnc0luZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKHJhbmdlTGVuZ3RoLS0pIHtcbiAgICAgICAgICAgIHJlc3VsdDJbbGVmdEluZGV4KytdID0gYXJnc1thcmdzSW5kZXgrK107XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNvbXBvc2VBcmdzUmlnaHQoYXJncywgcGFydGlhbHMsIGhvbGRlcnMsIGlzQ3VycmllZCkge1xuICAgICAgICAgIHZhciBhcmdzSW5kZXggPSAtMSwgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoLCBob2xkZXJzSW5kZXggPSAtMSwgaG9sZGVyc0xlbmd0aCA9IGhvbGRlcnMubGVuZ3RoLCByaWdodEluZGV4ID0gLTEsIHJpZ2h0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLCByYW5nZUxlbmd0aCA9IG5hdGl2ZU1heChhcmdzTGVuZ3RoIC0gaG9sZGVyc0xlbmd0aCwgMCksIHJlc3VsdDIgPSBBcnJheTIocmFuZ2VMZW5ndGggKyByaWdodExlbmd0aCksIGlzVW5jdXJyaWVkID0gIWlzQ3VycmllZDtcbiAgICAgICAgICB3aGlsZSAoKythcmdzSW5kZXggPCByYW5nZUxlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0MlthcmdzSW5kZXhdID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gYXJnc0luZGV4O1xuICAgICAgICAgIHdoaWxlICgrK3JpZ2h0SW5kZXggPCByaWdodExlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0MltvZmZzZXQgKyByaWdodEluZGV4XSA9IHBhcnRpYWxzW3JpZ2h0SW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAoKytob2xkZXJzSW5kZXggPCBob2xkZXJzTGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaXNVbmN1cnJpZWQgfHwgYXJnc0luZGV4IDwgYXJnc0xlbmd0aCkge1xuICAgICAgICAgICAgICByZXN1bHQyW29mZnNldCArIGhvbGRlcnNbaG9sZGVyc0luZGV4XV0gPSBhcmdzW2FyZ3NJbmRleCsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSAtMSwgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgICAgICAgICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheTIobGVuZ3RoKSk7XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICAgICAgICAgIHZhciBpc05ldyA9ICFvYmplY3Q7XG4gICAgICAgICAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSkgOiB1bmRlZmluZWQyO1xuICAgICAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQyKSB7XG4gICAgICAgICAgICAgIG5ld1ZhbHVlID0gc291cmNlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNOZXcpIHtcbiAgICAgICAgICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNvcHlTeW1ib2xzKHNvdXJjZSwgb2JqZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzKHNvdXJjZSksIG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY29weVN5bWJvbHNJbihzb3VyY2UsIG9iamVjdCkge1xuICAgICAgICAgIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9sc0luKHNvdXJjZSksIG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlQWdncmVnYXRvcihzZXR0ZXIsIGluaXRpYWxpemVyKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlMikge1xuICAgICAgICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlBZ2dyZWdhdG9yIDogYmFzZUFnZ3JlZ2F0b3IsIGFjY3VtdWxhdG9yID0gaW5pdGlhbGl6ZXIgPyBpbml0aWFsaXplcigpIDoge307XG4gICAgICAgICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBzZXR0ZXIsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlMiwgMiksIGFjY3VtdWxhdG9yKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUFzc2lnbmVyKGFzc2lnbmVyKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLCBjdXN0b21pemVyID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQyLCBndWFyZCA9IGxlbmd0aCA+IDIgPyBzb3VyY2VzWzJdIDogdW5kZWZpbmVkMjtcbiAgICAgICAgICAgIGN1c3RvbWl6ZXIgPSBhc3NpZ25lci5sZW5ndGggPiAzICYmIHR5cGVvZiBjdXN0b21pemVyID09IFwiZnVuY3Rpb25cIiA/IChsZW5ndGgtLSwgY3VzdG9taXplcikgOiB1bmRlZmluZWQyO1xuICAgICAgICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoIDwgMyA/IHVuZGVmaW5lZDIgOiBjdXN0b21pemVyO1xuICAgICAgICAgICAgICBsZW5ndGggPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqZWN0ID0gT2JqZWN0MihvYmplY3QpO1xuICAgICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgICAgICAgICBpZiAoc291cmNlKSB7XG4gICAgICAgICAgICAgICAgYXNzaWduZXIob2JqZWN0LCBzb3VyY2UsIGluZGV4LCBjdXN0b21pemVyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVCYXNlRWFjaChlYWNoRnVuYywgZnJvbVJpZ2h0KSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlMikge1xuICAgICAgICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGgsIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTEsIGl0ZXJhYmxlID0gT2JqZWN0Mihjb2xsZWN0aW9uKTtcbiAgICAgICAgICAgIHdoaWxlIChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICBpZiAoaXRlcmF0ZWUyKGl0ZXJhYmxlW2luZGV4XSwgaW5kZXgsIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QsIGl0ZXJhdGVlMiwga2V5c0Z1bmMpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IC0xLCBpdGVyYWJsZSA9IE9iamVjdDIob2JqZWN0KSwgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLCBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICAgICAgdmFyIGtleSA9IHByb3BzW2Zyb21SaWdodCA/IGxlbmd0aCA6ICsraW5kZXhdO1xuICAgICAgICAgICAgICBpZiAoaXRlcmF0ZWUyKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlQmluZChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnKSB7XG4gICAgICAgICAgdmFyIGlzQmluZCA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRywgQ3RvciA9IGNyZWF0ZUN0b3IoZnVuYyk7XG4gICAgICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgICAgIHZhciBmbiA9IHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlciA/IEN0b3IgOiBmdW5jO1xuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVDYXNlRmlyc3QobWV0aG9kTmFtZSkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICAgICAgICB2YXIgc3RyU3ltYm9scyA9IGhhc1VuaWNvZGUoc3RyaW5nKSA/IHN0cmluZ1RvQXJyYXkoc3RyaW5nKSA6IHVuZGVmaW5lZDI7XG4gICAgICAgICAgICB2YXIgY2hyID0gc3RyU3ltYm9scyA/IHN0clN5bWJvbHNbMF0gOiBzdHJpbmcuY2hhckF0KDApO1xuICAgICAgICAgICAgdmFyIHRyYWlsaW5nID0gc3RyU3ltYm9scyA/IGNhc3RTbGljZShzdHJTeW1ib2xzLCAxKS5qb2luKFwiXCIpIDogc3RyaW5nLnNsaWNlKDEpO1xuICAgICAgICAgICAgcmV0dXJuIGNoclttZXRob2ROYW1lXSgpICsgdHJhaWxpbmc7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVDb21wb3VuZGVyKGNhbGxiYWNrKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5UmVkdWNlKHdvcmRzKGRlYnVycihzdHJpbmcpLnJlcGxhY2UocmVBcG9zLCBcIlwiKSksIGNhbGxiYWNrLCBcIlwiKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUN0b3IoQ3Rvcikge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDdG9yKCk7XG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSk7XG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSk7XG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSk7XG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSwgYXJnc1s1XSk7XG4gICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEN0b3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSwgYXJnc1s1XSwgYXJnc1s2XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdGhpc0JpbmRpbmcgPSBiYXNlQ3JlYXRlKEN0b3IucHJvdG90eXBlKSwgcmVzdWx0MiA9IEN0b3IuYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdDIpID8gcmVzdWx0MiA6IHRoaXNCaW5kaW5nO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlQ3VycnkoZnVuYywgYml0bWFzaywgYXJpdHkpIHtcbiAgICAgICAgICB2YXIgQ3RvciA9IGNyZWF0ZUN0b3IoZnVuYyk7XG4gICAgICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkyKGxlbmd0aCksIGluZGV4ID0gbGVuZ3RoLCBwbGFjZWhvbGRlciA9IGdldEhvbGRlcih3cmFwcGVyKTtcbiAgICAgICAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgICAgICAgIGFyZ3NbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBob2xkZXJzID0gbGVuZ3RoIDwgMyAmJiBhcmdzWzBdICE9PSBwbGFjZWhvbGRlciAmJiBhcmdzW2xlbmd0aCAtIDFdICE9PSBwbGFjZWhvbGRlciA/IFtdIDogcmVwbGFjZUhvbGRlcnMoYXJncywgcGxhY2Vob2xkZXIpO1xuICAgICAgICAgICAgbGVuZ3RoIC09IGhvbGRlcnMubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGxlbmd0aCA8IGFyaXR5KSB7XG4gICAgICAgICAgICAgIHJldHVybiBjcmVhdGVSZWN1cnJ5KFxuICAgICAgICAgICAgICAgIGZ1bmMsXG4gICAgICAgICAgICAgICAgYml0bWFzayxcbiAgICAgICAgICAgICAgICBjcmVhdGVIeWJyaWQsXG4gICAgICAgICAgICAgICAgd3JhcHBlci5wbGFjZWhvbGRlcixcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQyLFxuICAgICAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICAgICAgaG9sZGVycyxcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQyLFxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZDIsXG4gICAgICAgICAgICAgICAgYXJpdHkgLSBsZW5ndGhcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBmbiA9IHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlciA/IEN0b3IgOiBmdW5jO1xuICAgICAgICAgICAgcmV0dXJuIGFwcGx5KGZuLCB0aGlzLCBhcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlRmluZChmaW5kSW5kZXhGdW5jKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gICAgICAgICAgICB2YXIgaXRlcmFibGUgPSBPYmplY3QyKGNvbGxlY3Rpb24pO1xuICAgICAgICAgICAgaWYgKCFpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgICAgICAgICB2YXIgaXRlcmF0ZWUyID0gZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKTtcbiAgICAgICAgICAgICAgY29sbGVjdGlvbiA9IGtleXMoY29sbGVjdGlvbik7XG4gICAgICAgICAgICAgIHByZWRpY2F0ZSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVyYXRlZTIoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBmaW5kSW5kZXhGdW5jKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZnJvbUluZGV4KTtcbiAgICAgICAgICAgIHJldHVybiBpbmRleCA+IC0xID8gaXRlcmFibGVbaXRlcmF0ZWUyID8gY29sbGVjdGlvbltpbmRleF0gOiBpbmRleF0gOiB1bmRlZmluZWQyO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlRmxvdyhmcm9tUmlnaHQpIHtcbiAgICAgICAgICByZXR1cm4gZmxhdFJlc3QoZnVuY3Rpb24oZnVuY3MpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBmdW5jcy5sZW5ndGgsIGluZGV4ID0gbGVuZ3RoLCBwcmVyZXEgPSBMb2Rhc2hXcmFwcGVyLnByb3RvdHlwZS50aHJ1O1xuICAgICAgICAgICAgaWYgKGZyb21SaWdodCkge1xuICAgICAgICAgICAgICBmdW5jcy5yZXZlcnNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICAgICAgICB2YXIgZnVuYyA9IGZ1bmNzW2luZGV4XTtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmdW5jICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IyKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHByZXJlcSAmJiAhd3JhcHBlciAmJiBnZXRGdW5jTmFtZShmdW5jKSA9PSBcIndyYXBwZXJcIikge1xuICAgICAgICAgICAgICAgIHZhciB3cmFwcGVyID0gbmV3IExvZGFzaFdyYXBwZXIoW10sIHRydWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmRleCA9IHdyYXBwZXIgPyBpbmRleCA6IGxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGZ1bmMgPSBmdW5jc1tpbmRleF07XG4gICAgICAgICAgICAgIHZhciBmdW5jTmFtZSA9IGdldEZ1bmNOYW1lKGZ1bmMpLCBkYXRhID0gZnVuY05hbWUgPT0gXCJ3cmFwcGVyXCIgPyBnZXREYXRhKGZ1bmMpIDogdW5kZWZpbmVkMjtcbiAgICAgICAgICAgICAgaWYgKGRhdGEgJiYgaXNMYXppYWJsZShkYXRhWzBdKSAmJiBkYXRhWzFdID09IChXUkFQX0FSWV9GTEFHIHwgV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9QQVJUSUFMX0ZMQUcgfCBXUkFQX1JFQVJHX0ZMQUcpICYmICFkYXRhWzRdLmxlbmd0aCAmJiBkYXRhWzldID09IDEpIHtcbiAgICAgICAgICAgICAgICB3cmFwcGVyID0gd3JhcHBlcltnZXRGdW5jTmFtZShkYXRhWzBdKV0uYXBwbHkod3JhcHBlciwgZGF0YVszXSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgd3JhcHBlciA9IGZ1bmMubGVuZ3RoID09IDEgJiYgaXNMYXppYWJsZShmdW5jKSA/IHdyYXBwZXJbZnVuY05hbWVdKCkgOiB3cmFwcGVyLnRocnUoZnVuYyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsIHZhbHVlID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgaWYgKHdyYXBwZXIgJiYgYXJncy5sZW5ndGggPT0gMSAmJiBpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVyLnBsYW50KHZhbHVlKS52YWx1ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBpbmRleDIgPSAwLCByZXN1bHQyID0gbGVuZ3RoID8gZnVuY3NbaW5kZXgyXS5hcHBseSh0aGlzLCBhcmdzKSA6IHZhbHVlO1xuICAgICAgICAgICAgICB3aGlsZSAoKytpbmRleDIgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQyID0gZnVuY3NbaW5kZXgyXS5jYWxsKHRoaXMsIHJlc3VsdDIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVIeWJyaWQoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCwgYXJnUG9zLCBhcnkyLCBhcml0eSkge1xuICAgICAgICAgIHZhciBpc0FyeSA9IGJpdG1hc2sgJiBXUkFQX0FSWV9GTEFHLCBpc0JpbmQgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0ZMQUcsIGlzQmluZEtleSA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfS0VZX0ZMQUcsIGlzQ3VycmllZCA9IGJpdG1hc2sgJiAoV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9DVVJSWV9SSUdIVF9GTEFHKSwgaXNGbGlwID0gYml0bWFzayAmIFdSQVBfRkxJUF9GTEFHLCBDdG9yID0gaXNCaW5kS2V5ID8gdW5kZWZpbmVkMiA6IGNyZWF0ZUN0b3IoZnVuYyk7XG4gICAgICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkyKGxlbmd0aCksIGluZGV4ID0gbGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgICAgICAgYXJnc1tpbmRleF0gPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzQ3VycmllZCkge1xuICAgICAgICAgICAgICB2YXIgcGxhY2Vob2xkZXIgPSBnZXRIb2xkZXIod3JhcHBlciksIGhvbGRlcnNDb3VudCA9IGNvdW50SG9sZGVycyhhcmdzLCBwbGFjZWhvbGRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFydGlhbHMpIHtcbiAgICAgICAgICAgICAgYXJncyA9IGNvbXBvc2VBcmdzKGFyZ3MsIHBhcnRpYWxzLCBob2xkZXJzLCBpc0N1cnJpZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcnRpYWxzUmlnaHQpIHtcbiAgICAgICAgICAgICAgYXJncyA9IGNvbXBvc2VBcmdzUmlnaHQoYXJncywgcGFydGlhbHNSaWdodCwgaG9sZGVyc1JpZ2h0LCBpc0N1cnJpZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGVuZ3RoIC09IGhvbGRlcnNDb3VudDtcbiAgICAgICAgICAgIGlmIChpc0N1cnJpZWQgJiYgbGVuZ3RoIDwgYXJpdHkpIHtcbiAgICAgICAgICAgICAgdmFyIG5ld0hvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhhcmdzLCBwbGFjZWhvbGRlcik7XG4gICAgICAgICAgICAgIHJldHVybiBjcmVhdGVSZWN1cnJ5KFxuICAgICAgICAgICAgICAgIGZ1bmMsXG4gICAgICAgICAgICAgICAgYml0bWFzayxcbiAgICAgICAgICAgICAgICBjcmVhdGVIeWJyaWQsXG4gICAgICAgICAgICAgICAgd3JhcHBlci5wbGFjZWhvbGRlcixcbiAgICAgICAgICAgICAgICB0aGlzQXJnLFxuICAgICAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICAgICAgbmV3SG9sZGVycyxcbiAgICAgICAgICAgICAgICBhcmdQb3MsXG4gICAgICAgICAgICAgICAgYXJ5MixcbiAgICAgICAgICAgICAgICBhcml0eSAtIGxlbmd0aFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRoaXNCaW5kaW5nID0gaXNCaW5kID8gdGhpc0FyZyA6IHRoaXMsIGZuID0gaXNCaW5kS2V5ID8gdGhpc0JpbmRpbmdbZnVuY10gOiBmdW5jO1xuICAgICAgICAgICAgbGVuZ3RoID0gYXJncy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoYXJnUG9zKSB7XG4gICAgICAgICAgICAgIGFyZ3MgPSByZW9yZGVyKGFyZ3MsIGFyZ1Bvcyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzRmxpcCAmJiBsZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgIGFyZ3MucmV2ZXJzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzQXJ5ICYmIGFyeTIgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgYXJncy5sZW5ndGggPSBhcnkyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikge1xuICAgICAgICAgICAgICBmbiA9IEN0b3IgfHwgY3JlYXRlQ3Rvcihmbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVJbnZlcnRlcihzZXR0ZXIsIHRvSXRlcmF0ZWUpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZTIpIHtcbiAgICAgICAgICAgIHJldHVybiBiYXNlSW52ZXJ0ZXIob2JqZWN0LCBzZXR0ZXIsIHRvSXRlcmF0ZWUoaXRlcmF0ZWUyKSwge30pO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlTWF0aE9wZXJhdGlvbihvcGVyYXRvciwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDI7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZDIgJiYgb3RoZXIgPT09IHVuZGVmaW5lZDIpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkMikge1xuICAgICAgICAgICAgICByZXN1bHQyID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3RoZXIgIT09IHVuZGVmaW5lZDIpIHtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdDIgPT09IHVuZGVmaW5lZDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBvdGhlciA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBiYXNlVG9TdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgICAgIG90aGVyID0gYmFzZVRvU3RyaW5nKG90aGVyKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGJhc2VUb051bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICAgICAgb3RoZXIgPSBiYXNlVG9OdW1iZXIob3RoZXIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBvcGVyYXRvcih2YWx1ZSwgb3RoZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVPdmVyKGFycmF5RnVuYykge1xuICAgICAgICAgIHJldHVybiBmbGF0UmVzdChmdW5jdGlvbihpdGVyYXRlZXMpIHtcbiAgICAgICAgICAgIGl0ZXJhdGVlcyA9IGFycmF5TWFwKGl0ZXJhdGVlcywgYmFzZVVuYXJ5KGdldEl0ZXJhdGVlKCkpKTtcbiAgICAgICAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgICAgICAgIHZhciB0aGlzQXJnID0gdGhpcztcbiAgICAgICAgICAgICAgcmV0dXJuIGFycmF5RnVuYyhpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcHBseShpdGVyYXRlZTIsIHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVBhZGRpbmcobGVuZ3RoLCBjaGFycykge1xuICAgICAgICAgIGNoYXJzID0gY2hhcnMgPT09IHVuZGVmaW5lZDIgPyBcIiBcIiA6IGJhc2VUb1N0cmluZyhjaGFycyk7XG4gICAgICAgICAgdmFyIGNoYXJzTGVuZ3RoID0gY2hhcnMubGVuZ3RoO1xuICAgICAgICAgIGlmIChjaGFyc0xlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFyc0xlbmd0aCA/IGJhc2VSZXBlYXQoY2hhcnMsIGxlbmd0aCkgOiBjaGFycztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJlc3VsdDIgPSBiYXNlUmVwZWF0KGNoYXJzLCBuYXRpdmVDZWlsKGxlbmd0aCAvIHN0cmluZ1NpemUoY2hhcnMpKSk7XG4gICAgICAgICAgcmV0dXJuIGhhc1VuaWNvZGUoY2hhcnMpID8gY2FzdFNsaWNlKHN0cmluZ1RvQXJyYXkocmVzdWx0MiksIDAsIGxlbmd0aCkuam9pbihcIlwiKSA6IHJlc3VsdDIuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVQYXJ0aWFsKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzKSB7XG4gICAgICAgICAgdmFyIGlzQmluZCA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRywgQ3RvciA9IGNyZWF0ZUN0b3IoZnVuYyk7XG4gICAgICAgICAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICAgICAgICAgIHZhciBhcmdzSW5kZXggPSAtMSwgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGgsIGxlZnRJbmRleCA9IC0xLCBsZWZ0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLCBhcmdzID0gQXJyYXkyKGxlZnRMZW5ndGggKyBhcmdzTGVuZ3RoKSwgZm4gPSB0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIgPyBDdG9yIDogZnVuYztcbiAgICAgICAgICAgIHdoaWxlICgrK2xlZnRJbmRleCA8IGxlZnRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgYXJnc1tsZWZ0SW5kZXhdID0gcGFydGlhbHNbbGVmdEluZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChhcmdzTGVuZ3RoLS0pIHtcbiAgICAgICAgICAgICAgYXJnc1tsZWZ0SW5kZXgrK10gPSBhcmd1bWVudHNbKythcmdzSW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFwcGx5KGZuLCBpc0JpbmQgPyB0aGlzQXJnIDogdGhpcywgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVJhbmdlKGZyb21SaWdodCkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbihzdGFydCwgZW5kLCBzdGVwKSB7XG4gICAgICAgICAgICBpZiAoc3RlcCAmJiB0eXBlb2Ygc3RlcCAhPSBcIm51bWJlclwiICYmIGlzSXRlcmF0ZWVDYWxsKHN0YXJ0LCBlbmQsIHN0ZXApKSB7XG4gICAgICAgICAgICAgIGVuZCA9IHN0ZXAgPSB1bmRlZmluZWQyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnQgPSB0b0Zpbml0ZShzdGFydCk7XG4gICAgICAgICAgICBpZiAoZW5kID09PSB1bmRlZmluZWQyKSB7XG4gICAgICAgICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbmQgPSB0b0Zpbml0ZShlbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RlcCA9IHN0ZXAgPT09IHVuZGVmaW5lZDIgPyBzdGFydCA8IGVuZCA/IDEgOiAtMSA6IHRvRmluaXRlKHN0ZXApO1xuICAgICAgICAgICAgcmV0dXJuIGJhc2VSYW5nZShzdGFydCwgZW5kLCBzdGVwLCBmcm9tUmlnaHQpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlUmVsYXRpb25hbE9wZXJhdGlvbihvcGVyYXRvcikge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgICAgIGlmICghKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBvdGhlciA9PSBcInN0cmluZ1wiKSkge1xuICAgICAgICAgICAgICB2YWx1ZSA9IHRvTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgICAgb3RoZXIgPSB0b051bWJlcihvdGhlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3BlcmF0b3IodmFsdWUsIG90aGVyKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVJlY3VycnkoZnVuYywgYml0bWFzaywgd3JhcEZ1bmMsIHBsYWNlaG9sZGVyLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgYXJnUG9zLCBhcnkyLCBhcml0eSkge1xuICAgICAgICAgIHZhciBpc0N1cnJ5ID0gYml0bWFzayAmIFdSQVBfQ1VSUllfRkxBRywgbmV3SG9sZGVycyA9IGlzQ3VycnkgPyBob2xkZXJzIDogdW5kZWZpbmVkMiwgbmV3SG9sZGVyc1JpZ2h0ID0gaXNDdXJyeSA/IHVuZGVmaW5lZDIgOiBob2xkZXJzLCBuZXdQYXJ0aWFscyA9IGlzQ3VycnkgPyBwYXJ0aWFscyA6IHVuZGVmaW5lZDIsIG5ld1BhcnRpYWxzUmlnaHQgPSBpc0N1cnJ5ID8gdW5kZWZpbmVkMiA6IHBhcnRpYWxzO1xuICAgICAgICAgIGJpdG1hc2sgfD0gaXNDdXJyeSA/IFdSQVBfUEFSVElBTF9GTEFHIDogV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUc7XG4gICAgICAgICAgYml0bWFzayAmPSB+KGlzQ3VycnkgPyBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRyA6IFdSQVBfUEFSVElBTF9GTEFHKTtcbiAgICAgICAgICBpZiAoIShiaXRtYXNrICYgV1JBUF9DVVJSWV9CT1VORF9GTEFHKSkge1xuICAgICAgICAgICAgYml0bWFzayAmPSB+KFdSQVBfQklORF9GTEFHIHwgV1JBUF9CSU5EX0tFWV9GTEFHKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG5ld0RhdGEgPSBbXG4gICAgICAgICAgICBmdW5jLFxuICAgICAgICAgICAgYml0bWFzayxcbiAgICAgICAgICAgIHRoaXNBcmcsXG4gICAgICAgICAgICBuZXdQYXJ0aWFscyxcbiAgICAgICAgICAgIG5ld0hvbGRlcnMsXG4gICAgICAgICAgICBuZXdQYXJ0aWFsc1JpZ2h0LFxuICAgICAgICAgICAgbmV3SG9sZGVyc1JpZ2h0LFxuICAgICAgICAgICAgYXJnUG9zLFxuICAgICAgICAgICAgYXJ5MixcbiAgICAgICAgICAgIGFyaXR5XG4gICAgICAgICAgXTtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IHdyYXBGdW5jLmFwcGx5KHVuZGVmaW5lZDIsIG5ld0RhdGEpO1xuICAgICAgICAgIGlmIChpc0xhemlhYmxlKGZ1bmMpKSB7XG4gICAgICAgICAgICBzZXREYXRhKHJlc3VsdDIsIG5ld0RhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQyLnBsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXI7XG4gICAgICAgICAgcmV0dXJuIHNldFdyYXBUb1N0cmluZyhyZXN1bHQyLCBmdW5jLCBiaXRtYXNrKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVSb3VuZChtZXRob2ROYW1lKSB7XG4gICAgICAgICAgdmFyIGZ1bmMgPSBNYXRoMlttZXRob2ROYW1lXTtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24obnVtYmVyLCBwcmVjaXNpb24pIHtcbiAgICAgICAgICAgIG51bWJlciA9IHRvTnVtYmVyKG51bWJlcik7XG4gICAgICAgICAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24gPT0gbnVsbCA/IDAgOiBuYXRpdmVNaW4odG9JbnRlZ2VyKHByZWNpc2lvbiksIDI5Mik7XG4gICAgICAgICAgICBpZiAocHJlY2lzaW9uICYmIG5hdGl2ZUlzRmluaXRlKG51bWJlcikpIHtcbiAgICAgICAgICAgICAgdmFyIHBhaXIgPSAodG9TdHJpbmcobnVtYmVyKSArIFwiZVwiKS5zcGxpdChcImVcIiksIHZhbHVlID0gZnVuYyhwYWlyWzBdICsgXCJlXCIgKyAoK3BhaXJbMV0gKyBwcmVjaXNpb24pKTtcbiAgICAgICAgICAgICAgcGFpciA9ICh0b1N0cmluZyh2YWx1ZSkgKyBcImVcIikuc3BsaXQoXCJlXCIpO1xuICAgICAgICAgICAgICByZXR1cm4gKyhwYWlyWzBdICsgXCJlXCIgKyAoK3BhaXJbMV0gLSBwcmVjaXNpb24pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmdW5jKG51bWJlcik7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY3JlYXRlU2V0ID0gIShTZXQyICYmIDEgLyBzZXRUb0FycmF5KG5ldyBTZXQyKFssIC0wXSkpWzFdID09IElORklOSVRZKSA/IG5vb3AgOiBmdW5jdGlvbih2YWx1ZXMyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBTZXQyKHZhbHVlczIpO1xuICAgICAgICB9O1xuICAgICAgICBmdW5jdGlvbiBjcmVhdGVUb1BhaXJzKGtleXNGdW5jKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgICAgdmFyIHRhZyA9IGdldFRhZyhvYmplY3QpO1xuICAgICAgICAgICAgaWYgKHRhZyA9PSBtYXBUYWcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG1hcFRvQXJyYXkob2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YWcgPT0gc2V0VGFnKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZXRUb1BhaXJzKG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYmFzZVRvUGFpcnMob2JqZWN0LCBrZXlzRnVuYyhvYmplY3QpKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVdyYXAoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIGFyZ1BvcywgYXJ5MiwgYXJpdHkpIHtcbiAgICAgICAgICB2YXIgaXNCaW5kS2V5ID0gYml0bWFzayAmIFdSQVBfQklORF9LRVlfRkxBRztcbiAgICAgICAgICBpZiAoIWlzQmluZEtleSAmJiB0eXBlb2YgZnVuYyAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IyKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBsZW5ndGggPSBwYXJ0aWFscyA/IHBhcnRpYWxzLmxlbmd0aCA6IDA7XG4gICAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIGJpdG1hc2sgJj0gfihXUkFQX1BBUlRJQUxfRkxBRyB8IFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHKTtcbiAgICAgICAgICAgIHBhcnRpYWxzID0gaG9sZGVycyA9IHVuZGVmaW5lZDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFyeTIgPSBhcnkyID09PSB1bmRlZmluZWQyID8gYXJ5MiA6IG5hdGl2ZU1heCh0b0ludGVnZXIoYXJ5MiksIDApO1xuICAgICAgICAgIGFyaXR5ID0gYXJpdHkgPT09IHVuZGVmaW5lZDIgPyBhcml0eSA6IHRvSW50ZWdlcihhcml0eSk7XG4gICAgICAgICAgbGVuZ3RoIC09IGhvbGRlcnMgPyBob2xkZXJzLmxlbmd0aCA6IDA7XG4gICAgICAgICAgaWYgKGJpdG1hc2sgJiBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRykge1xuICAgICAgICAgICAgdmFyIHBhcnRpYWxzUmlnaHQgPSBwYXJ0aWFscywgaG9sZGVyc1JpZ2h0ID0gaG9sZGVycztcbiAgICAgICAgICAgIHBhcnRpYWxzID0gaG9sZGVycyA9IHVuZGVmaW5lZDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBkYXRhID0gaXNCaW5kS2V5ID8gdW5kZWZpbmVkMiA6IGdldERhdGEoZnVuYyk7XG4gICAgICAgICAgdmFyIG5ld0RhdGEgPSBbXG4gICAgICAgICAgICBmdW5jLFxuICAgICAgICAgICAgYml0bWFzayxcbiAgICAgICAgICAgIHRoaXNBcmcsXG4gICAgICAgICAgICBwYXJ0aWFscyxcbiAgICAgICAgICAgIGhvbGRlcnMsXG4gICAgICAgICAgICBwYXJ0aWFsc1JpZ2h0LFxuICAgICAgICAgICAgaG9sZGVyc1JpZ2h0LFxuICAgICAgICAgICAgYXJnUG9zLFxuICAgICAgICAgICAgYXJ5MixcbiAgICAgICAgICAgIGFyaXR5XG4gICAgICAgICAgXTtcbiAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgbWVyZ2VEYXRhKG5ld0RhdGEsIGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jID0gbmV3RGF0YVswXTtcbiAgICAgICAgICBiaXRtYXNrID0gbmV3RGF0YVsxXTtcbiAgICAgICAgICB0aGlzQXJnID0gbmV3RGF0YVsyXTtcbiAgICAgICAgICBwYXJ0aWFscyA9IG5ld0RhdGFbM107XG4gICAgICAgICAgaG9sZGVycyA9IG5ld0RhdGFbNF07XG4gICAgICAgICAgYXJpdHkgPSBuZXdEYXRhWzldID0gbmV3RGF0YVs5XSA9PT0gdW5kZWZpbmVkMiA/IGlzQmluZEtleSA/IDAgOiBmdW5jLmxlbmd0aCA6IG5hdGl2ZU1heChuZXdEYXRhWzldIC0gbGVuZ3RoLCAwKTtcbiAgICAgICAgICBpZiAoIWFyaXR5ICYmIGJpdG1hc2sgJiAoV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9DVVJSWV9SSUdIVF9GTEFHKSkge1xuICAgICAgICAgICAgYml0bWFzayAmPSB+KFdSQVBfQ1VSUllfRkxBRyB8IFdSQVBfQ1VSUllfUklHSFRfRkxBRyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghYml0bWFzayB8fCBiaXRtYXNrID09IFdSQVBfQklORF9GTEFHKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0MiA9IGNyZWF0ZUJpbmQoZnVuYywgYml0bWFzaywgdGhpc0FyZyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChiaXRtYXNrID09IFdSQVBfQ1VSUllfRkxBRyB8fCBiaXRtYXNrID09IFdSQVBfQ1VSUllfUklHSFRfRkxBRykge1xuICAgICAgICAgICAgcmVzdWx0MiA9IGNyZWF0ZUN1cnJ5KGZ1bmMsIGJpdG1hc2ssIGFyaXR5KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKChiaXRtYXNrID09IFdSQVBfUEFSVElBTF9GTEFHIHx8IGJpdG1hc2sgPT0gKFdSQVBfQklORF9GTEFHIHwgV1JBUF9QQVJUSUFMX0ZMQUcpKSAmJiAhaG9sZGVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBjcmVhdGVQYXJ0aWFsKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MiA9IGNyZWF0ZUh5YnJpZC5hcHBseSh1bmRlZmluZWQyLCBuZXdEYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHNldHRlciA9IGRhdGEgPyBiYXNlU2V0RGF0YSA6IHNldERhdGE7XG4gICAgICAgICAgcmV0dXJuIHNldFdyYXBUb1N0cmluZyhzZXR0ZXIocmVzdWx0MiwgbmV3RGF0YSksIGZ1bmMsIGJpdG1hc2spO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGN1c3RvbURlZmF1bHRzQXNzaWduSW4ob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkMiB8fCBlcShvYmpWYWx1ZSwgb2JqZWN0UHJvdG9ba2V5XSkgJiYgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3JjVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvYmpWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjdXN0b21EZWZhdWx0c01lcmdlKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spIHtcbiAgICAgICAgICBpZiAoaXNPYmplY3Qob2JqVmFsdWUpICYmIGlzT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgICAgICAgICAgc3RhY2suc2V0KHNyY1ZhbHVlLCBvYmpWYWx1ZSk7XG4gICAgICAgICAgICBiYXNlTWVyZ2Uob2JqVmFsdWUsIHNyY1ZhbHVlLCB1bmRlZmluZWQyLCBjdXN0b21EZWZhdWx0c01lcmdlLCBzdGFjayk7XG4gICAgICAgICAgICBzdGFja1tcImRlbGV0ZVwiXShzcmNWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvYmpWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjdXN0b21PbWl0Q2xvbmUodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaXNQbGFpbk9iamVjdCh2YWx1ZSkgPyB1bmRlZmluZWQyIDogdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gICAgICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRywgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLCBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG4gICAgICAgICAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgYXJyU3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gICAgICAgICAgdmFyIG90aFN0YWNrZWQgPSBzdGFjay5nZXQob3RoZXIpO1xuICAgICAgICAgIGlmIChhcnJTdGFja2VkICYmIG90aFN0YWNrZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnJTdGFja2VkID09IG90aGVyICYmIG90aFN0YWNrZWQgPT0gYXJyYXk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpbmRleCA9IC0xLCByZXN1bHQyID0gdHJ1ZSwgc2VlbiA9IGJpdG1hc2sgJiBDT01QQVJFX1VOT1JERVJFRF9GTEFHID8gbmV3IFNldENhY2hlKCkgOiB1bmRlZmluZWQyO1xuICAgICAgICAgIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICAgICAgICAgIHN0YWNrLnNldChvdGhlciwgYXJyYXkpO1xuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgYXJyVmFsdWUgPSBhcnJheVtpbmRleF0sIG90aFZhbHVlID0gb3RoZXJbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsID8gY3VzdG9taXplcihvdGhWYWx1ZSwgYXJyVmFsdWUsIGluZGV4LCBvdGhlciwgYXJyYXksIHN0YWNrKSA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29tcGFyZWQgIT09IHVuZGVmaW5lZDIpIHtcbiAgICAgICAgICAgICAgaWYgKGNvbXBhcmVkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0MiA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWVuKSB7XG4gICAgICAgICAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZTIsIG90aEluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjYWNoZUhhcyhzZWVuLCBvdGhJbmRleCkgJiYgKGFyclZhbHVlID09PSBvdGhWYWx1ZTIgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZTIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIShhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKGFyclZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spKSkge1xuICAgICAgICAgICAgICByZXN1bHQyID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzdGFja1tcImRlbGV0ZVwiXShhcnJheSk7XG4gICAgICAgICAgc3RhY2tbXCJkZWxldGVcIl0ob3RoZXIpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgdGFnLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gICAgICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICAgICAgICAgIGlmIChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoIHx8IG9iamVjdC5ieXRlT2Zmc2V0ICE9IG90aGVyLmJ5dGVPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgb2JqZWN0ID0gb2JqZWN0LmJ1ZmZlcjtcbiAgICAgICAgICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG4gICAgICAgICAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgICAgICAgICBpZiAob2JqZWN0LmJ5dGVMZW5ndGggIT0gb3RoZXIuYnl0ZUxlbmd0aCB8fCAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5MihvYmplY3QpLCBuZXcgVWludDhBcnJheTIob3RoZXIpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGNhc2UgYm9vbFRhZzpcbiAgICAgICAgICAgIGNhc2UgZGF0ZVRhZzpcbiAgICAgICAgICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgICAgICAgICByZXR1cm4gZXEoK29iamVjdCwgK290aGVyKTtcbiAgICAgICAgICAgIGNhc2UgZXJyb3JUYWc6XG4gICAgICAgICAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG4gICAgICAgICAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgICAgICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgICAgICAgICByZXR1cm4gb2JqZWN0ID09IG90aGVyICsgXCJcIjtcbiAgICAgICAgICAgIGNhc2UgbWFwVGFnOlxuICAgICAgICAgICAgICB2YXIgY29udmVydCA9IG1hcFRvQXJyYXk7XG4gICAgICAgICAgICBjYXNlIHNldFRhZzpcbiAgICAgICAgICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRztcbiAgICAgICAgICAgICAgY29udmVydCB8fCAoY29udmVydCA9IHNldFRvQXJyYXkpO1xuICAgICAgICAgICAgICBpZiAob2JqZWN0LnNpemUgIT0gb3RoZXIuc2l6ZSAmJiAhaXNQYXJ0aWFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KG9iamVjdCk7XG4gICAgICAgICAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYml0bWFzayB8PSBDT01QQVJFX1VOT1JERVJFRF9GTEFHO1xuICAgICAgICAgICAgICBzdGFjay5zZXQob2JqZWN0LCBvdGhlcik7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQyID0gZXF1YWxBcnJheXMoY29udmVydChvYmplY3QpLCBjb252ZXJ0KG90aGVyKSwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICAgICAgICAgIHN0YWNrW1wiZGVsZXRlXCJdKG9iamVjdCk7XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICAgICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICAgICAgICAgIGlmIChzeW1ib2xWYWx1ZU9mKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gICAgICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRywgb2JqUHJvcHMgPSBnZXRBbGxLZXlzKG9iamVjdCksIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCwgb3RoUHJvcHMgPSBnZXRBbGxLZXlzKG90aGVyKSwgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuICAgICAgICAgIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoO1xuICAgICAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gb2JqUHJvcHNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKCEoaXNQYXJ0aWFsID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgb2JqU3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgICAgIHZhciBvdGhTdGFja2VkID0gc3RhY2suZ2V0KG90aGVyKTtcbiAgICAgICAgICBpZiAob2JqU3RhY2tlZCAmJiBvdGhTdGFja2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqU3RhY2tlZCA9PSBvdGhlciAmJiBvdGhTdGFja2VkID09IG9iamVjdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJlc3VsdDIgPSB0cnVlO1xuICAgICAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgICAgICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG4gICAgICAgICAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgb2JqTGVuZ3RoKSB7XG4gICAgICAgICAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgICAgICAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSwgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuICAgICAgICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsID8gY3VzdG9taXplcihvdGhWYWx1ZSwgb2JqVmFsdWUsIGtleSwgb3RoZXIsIG9iamVjdCwgc3RhY2spIDogY3VzdG9taXplcihvYmpWYWx1ZSwgb3RoVmFsdWUsIGtleSwgb2JqZWN0LCBvdGhlciwgc3RhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZDIgPyBvYmpWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIDogY29tcGFyZWQpKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gXCJjb25zdHJ1Y3RvclwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDIgJiYgIXNraXBDdG9yKSB7XG4gICAgICAgICAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3Rvciwgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJiAoXCJjb25zdHJ1Y3RvclwiIGluIG9iamVjdCAmJiBcImNvbnN0cnVjdG9yXCIgaW4gb3RoZXIpICYmICEodHlwZW9mIG9iakN0b3IgPT0gXCJmdW5jdGlvblwiICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmIHR5cGVvZiBvdGhDdG9yID09IFwiZnVuY3Rpb25cIiAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MiA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzdGFja1tcImRlbGV0ZVwiXShvYmplY3QpO1xuICAgICAgICAgIHN0YWNrW1wiZGVsZXRlXCJdKG90aGVyKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmbGF0UmVzdChmdW5jKSB7XG4gICAgICAgICAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHVuZGVmaW5lZDIsIGZsYXR0ZW4pLCBmdW5jICsgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0QWxsS2V5cyhvYmplY3QpIHtcbiAgICAgICAgICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRBbGxLZXlzSW4ob2JqZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0luLCBnZXRTeW1ib2xzSW4pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBnZXREYXRhID0gIW1ldGFNYXAgPyBub29wIDogZnVuY3Rpb24oZnVuYykge1xuICAgICAgICAgIHJldHVybiBtZXRhTWFwLmdldChmdW5jKTtcbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gZ2V0RnVuY05hbWUoZnVuYykge1xuICAgICAgICAgIHZhciByZXN1bHQyID0gZnVuYy5uYW1lICsgXCJcIiwgYXJyYXkgPSByZWFsTmFtZXNbcmVzdWx0Ml0sIGxlbmd0aCA9IGhhc093blByb3BlcnR5LmNhbGwocmVhbE5hbWVzLCByZXN1bHQyKSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IGFycmF5W2xlbmd0aF0sIG90aGVyRnVuYyA9IGRhdGEuZnVuYztcbiAgICAgICAgICAgIGlmIChvdGhlckZ1bmMgPT0gbnVsbCB8fCBvdGhlckZ1bmMgPT0gZnVuYykge1xuICAgICAgICAgICAgICByZXR1cm4gZGF0YS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRIb2xkZXIoZnVuYykge1xuICAgICAgICAgIHZhciBvYmplY3QgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKGxvZGFzaCwgXCJwbGFjZWhvbGRlclwiKSA/IGxvZGFzaCA6IGZ1bmM7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdC5wbGFjZWhvbGRlcjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRJdGVyYXRlZSgpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IGxvZGFzaC5pdGVyYXRlZSB8fCBpdGVyYXRlZTtcbiAgICAgICAgICByZXN1bHQyID0gcmVzdWx0MiA9PT0gaXRlcmF0ZWUgPyBiYXNlSXRlcmF0ZWUgOiByZXN1bHQyO1xuICAgICAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gcmVzdWx0Mihhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSkgOiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldE1hcERhdGEobWFwMiwga2V5KSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSBtYXAyLl9fZGF0YV9fO1xuICAgICAgICAgIHJldHVybiBpc0tleWFibGUoa2V5KSA/IGRhdGFbdHlwZW9mIGtleSA9PSBcInN0cmluZ1wiID8gXCJzdHJpbmdcIiA6IFwiaGFzaFwiXSA6IGRhdGEubWFwO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IGtleXMob2JqZWN0KSwgbGVuZ3RoID0gcmVzdWx0Mi5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gcmVzdWx0MltsZW5ndGhdLCB2YWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgICAgICAgcmVzdWx0MltsZW5ndGhdID0gW2tleSwgdmFsdWUsIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSldO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gICAgICAgICAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLCB0YWcgPSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDI7XG4gICAgICAgICAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHJlc3VsdDIgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICAgICAgICBpZiAodW5tYXNrZWQpIHtcbiAgICAgICAgICAgIGlmIChpc093bikge1xuICAgICAgICAgICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZ2V0U3ltYm9scyA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIG9iamVjdCA9IE9iamVjdDIob2JqZWN0KTtcbiAgICAgICAgICByZXR1cm4gYXJyYXlGaWx0ZXIobmF0aXZlR2V0U3ltYm9scyhvYmplY3QpLCBmdW5jdGlvbihzeW1ib2wpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGdldFN5bWJvbHNJbiA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgICAgdmFyIHJlc3VsdDIgPSBbXTtcbiAgICAgICAgICB3aGlsZSAob2JqZWN0KSB7XG4gICAgICAgICAgICBhcnJheVB1c2gocmVzdWx0MiwgZ2V0U3ltYm9scyhvYmplY3QpKTtcbiAgICAgICAgICAgIG9iamVjdCA9IGdldFByb3RvdHlwZShvYmplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG4gICAgICAgIGlmIChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnIHx8IE1hcDIgJiYgZ2V0VGFnKG5ldyBNYXAyKCkpICE9IG1hcFRhZyB8fCBQcm9taXNlMiAmJiBnZXRUYWcoUHJvbWlzZTIucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnIHx8IFNldDIgJiYgZ2V0VGFnKG5ldyBTZXQyKCkpICE9IHNldFRhZyB8fCBXZWFrTWFwMiAmJiBnZXRUYWcobmV3IFdlYWtNYXAyKCkpICE9IHdlYWtNYXBUYWcpIHtcbiAgICAgICAgICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdDIgPSBiYXNlR2V0VGFnKHZhbHVlKSwgQ3RvciA9IHJlc3VsdDIgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQyLCBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogXCJcIjtcbiAgICAgICAgICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICAgICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFWaWV3VGFnO1xuICAgICAgICAgICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBtYXBUYWc7XG4gICAgICAgICAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICAgICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzZXRUYWc7XG4gICAgICAgICAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzpcbiAgICAgICAgICAgICAgICAgIHJldHVybiB3ZWFrTWFwVGFnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGdldFZpZXcoc3RhcnQsIGVuZCwgdHJhbnNmb3Jtcykge1xuICAgICAgICAgIHZhciBpbmRleCA9IC0xLCBsZW5ndGggPSB0cmFuc2Zvcm1zLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSB0cmFuc2Zvcm1zW2luZGV4XSwgc2l6ZTIgPSBkYXRhLnNpemU7XG4gICAgICAgICAgICBzd2l0Y2ggKGRhdGEudHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFwiZHJvcFwiOlxuICAgICAgICAgICAgICAgIHN0YXJ0ICs9IHNpemUyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwiZHJvcFJpZ2h0XCI6XG4gICAgICAgICAgICAgICAgZW5kIC09IHNpemUyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwidGFrZVwiOlxuICAgICAgICAgICAgICAgIGVuZCA9IG5hdGl2ZU1pbihlbmQsIHN0YXJ0ICsgc2l6ZTIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIFwidGFrZVJpZ2h0XCI6XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQsIGVuZCAtIHNpemUyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHsgXCJzdGFydFwiOiBzdGFydCwgXCJlbmRcIjogZW5kIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0V3JhcERldGFpbHMoc291cmNlKSB7XG4gICAgICAgICAgdmFyIG1hdGNoID0gc291cmNlLm1hdGNoKHJlV3JhcERldGFpbHMpO1xuICAgICAgICAgIHJldHVybiBtYXRjaCA/IG1hdGNoWzFdLnNwbGl0KHJlU3BsaXREZXRhaWxzKSA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBoYXNGdW5jKSB7XG4gICAgICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IHBhdGgubGVuZ3RoLCByZXN1bHQyID0gZmFsc2U7XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSB0b0tleShwYXRoW2luZGV4XSk7XG4gICAgICAgICAgICBpZiAoIShyZXN1bHQyID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQyIHx8ICsraW5kZXggIT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogb2JqZWN0Lmxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSAmJiAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGluaXRDbG9uZUFycmF5KGFycmF5KSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCwgcmVzdWx0MiA9IG5ldyBhcnJheS5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuICAgICAgICAgIGlmIChsZW5ndGggJiYgdHlwZW9mIGFycmF5WzBdID09IFwic3RyaW5nXCIgJiYgaGFzT3duUHJvcGVydHkuY2FsbChhcnJheSwgXCJpbmRleFwiKSkge1xuICAgICAgICAgICAgcmVzdWx0Mi5pbmRleCA9IGFycmF5LmluZGV4O1xuICAgICAgICAgICAgcmVzdWx0Mi5pbnB1dCA9IGFycmF5LmlucHV0O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgPT0gXCJmdW5jdGlvblwiICYmICFpc1Byb3RvdHlwZShvYmplY3QpID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSkgOiB7fTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpbml0Q2xvbmVCeVRhZyhvYmplY3QsIHRhZywgaXNEZWVwKSB7XG4gICAgICAgICAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gICAgICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICAgICAgICAgIHJldHVybiBjbG9uZUFycmF5QnVmZmVyKG9iamVjdCk7XG4gICAgICAgICAgICBjYXNlIGJvb2xUYWc6XG4gICAgICAgICAgICBjYXNlIGRhdGVUYWc6XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgQ3Rvcigrb2JqZWN0KTtcbiAgICAgICAgICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICAgICAgICAgIHJldHVybiBjbG9uZURhdGFWaWV3KG9iamVjdCwgaXNEZWVwKTtcbiAgICAgICAgICAgIGNhc2UgZmxvYXQzMlRhZzpcbiAgICAgICAgICAgIGNhc2UgZmxvYXQ2NFRhZzpcbiAgICAgICAgICAgIGNhc2UgaW50OFRhZzpcbiAgICAgICAgICAgIGNhc2UgaW50MTZUYWc6XG4gICAgICAgICAgICBjYXNlIGludDMyVGFnOlxuICAgICAgICAgICAgY2FzZSB1aW50OFRhZzpcbiAgICAgICAgICAgIGNhc2UgdWludDhDbGFtcGVkVGFnOlxuICAgICAgICAgICAgY2FzZSB1aW50MTZUYWc6XG4gICAgICAgICAgICBjYXNlIHVpbnQzMlRhZzpcbiAgICAgICAgICAgICAgcmV0dXJuIGNsb25lVHlwZWRBcnJheShvYmplY3QsIGlzRGVlcCk7XG4gICAgICAgICAgICBjYXNlIG1hcFRhZzpcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDdG9yKCk7XG4gICAgICAgICAgICBjYXNlIG51bWJlclRhZzpcbiAgICAgICAgICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgICAgICAgICByZXR1cm4gbmV3IEN0b3Iob2JqZWN0KTtcbiAgICAgICAgICAgIGNhc2UgcmVnZXhwVGFnOlxuICAgICAgICAgICAgICByZXR1cm4gY2xvbmVSZWdFeHAob2JqZWN0KTtcbiAgICAgICAgICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgICAgICAgICByZXR1cm4gbmV3IEN0b3IoKTtcbiAgICAgICAgICAgIGNhc2Ugc3ltYm9sVGFnOlxuICAgICAgICAgICAgICByZXR1cm4gY2xvbmVTeW1ib2wob2JqZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaW5zZXJ0V3JhcERldGFpbHMoc291cmNlLCBkZXRhaWxzKSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGRldGFpbHMubGVuZ3RoO1xuICAgICAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gc291cmNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcbiAgICAgICAgICBkZXRhaWxzW2xhc3RJbmRleF0gPSAobGVuZ3RoID4gMSA/IFwiJiBcIiA6IFwiXCIpICsgZGV0YWlsc1tsYXN0SW5kZXhdO1xuICAgICAgICAgIGRldGFpbHMgPSBkZXRhaWxzLmpvaW4obGVuZ3RoID4gMiA/IFwiLCBcIiA6IFwiIFwiKTtcbiAgICAgICAgICByZXR1cm4gc291cmNlLnJlcGxhY2UocmVXcmFwQ29tbWVudCwgXCJ7XFxuLyogW3dyYXBwZWQgd2l0aCBcIiArIGRldGFpbHMgKyBcIl0gKi9cXG5cIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNGbGF0dGVuYWJsZSh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBpc0FycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkgfHwgISEoc3ByZWFkYWJsZVN5bWJvbCAmJiB2YWx1ZSAmJiB2YWx1ZVtzcHJlYWRhYmxlU3ltYm9sXSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICAgICAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICAgICAgICAgIHJldHVybiAhIWxlbmd0aCAmJiAodHlwZSA9PSBcIm51bWJlclwiIHx8IHR5cGUgIT0gXCJzeW1ib2xcIiAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkgJiYgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzSXRlcmF0ZWVDYWxsKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gICAgICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICAgICAgICAgIGlmICh0eXBlID09IFwibnVtYmVyXCIgPyBpc0FycmF5TGlrZShvYmplY3QpICYmIGlzSW5kZXgoaW5kZXgsIG9iamVjdC5sZW5ndGgpIDogdHlwZSA9PSBcInN0cmluZ1wiICYmIGluZGV4IGluIG9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGVxKG9iamVjdFtpbmRleF0sIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICAgICAgaWYgKHR5cGUgPT0gXCJudW1iZXJcIiB8fCB0eXBlID09IFwic3ltYm9sXCIgfHwgdHlwZSA9PSBcImJvb2xlYW5cIiB8fCB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHwgb2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0MihvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICAgICAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgICAgIHJldHVybiB0eXBlID09IFwic3RyaW5nXCIgfHwgdHlwZSA9PSBcIm51bWJlclwiIHx8IHR5cGUgPT0gXCJzeW1ib2xcIiB8fCB0eXBlID09IFwiYm9vbGVhblwiID8gdmFsdWUgIT09IFwiX19wcm90b19fXCIgOiB2YWx1ZSA9PT0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0xhemlhYmxlKGZ1bmMpIHtcbiAgICAgICAgICB2YXIgZnVuY05hbWUgPSBnZXRGdW5jTmFtZShmdW5jKSwgb3RoZXIgPSBsb2Rhc2hbZnVuY05hbWVdO1xuICAgICAgICAgIGlmICh0eXBlb2Ygb3RoZXIgIT0gXCJmdW5jdGlvblwiIHx8ICEoZnVuY05hbWUgaW4gTGF6eVdyYXBwZXIucHJvdG90eXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZnVuYyA9PT0gb3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZGF0YSA9IGdldERhdGEob3RoZXIpO1xuICAgICAgICAgIHJldHVybiAhIWRhdGEgJiYgZnVuYyA9PT0gZGF0YVswXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gICAgICAgICAgcmV0dXJuICEhbWFza1NyY0tleSAmJiBtYXNrU3JjS2V5IGluIGZ1bmM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlzTWFza2FibGUgPSBjb3JlSnNEYXRhID8gaXNGdW5jdGlvbiA6IHN0dWJGYWxzZTtcbiAgICAgICAgZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgICAgICAgICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLCBwcm90byA9IHR5cGVvZiBDdG9yID09IFwiZnVuY3Rpb25cIiAmJiBDdG9yLnByb3RvdHlwZSB8fCBvYmplY3RQcm90bztcbiAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgJiYgIWlzT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShrZXksIHNyY1ZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvYmplY3Rba2V5XSA9PT0gc3JjVmFsdWUgJiYgKHNyY1ZhbHVlICE9PSB1bmRlZmluZWQyIHx8IGtleSBpbiBPYmplY3QyKG9iamVjdCkpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWVtb2l6ZUNhcHBlZChmdW5jKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdDIgPSBtZW1vaXplMihmdW5jLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICAgICAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBjYWNoZSA9IHJlc3VsdDIuY2FjaGU7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWVyZ2VEYXRhKGRhdGEsIHNvdXJjZSkge1xuICAgICAgICAgIHZhciBiaXRtYXNrID0gZGF0YVsxXSwgc3JjQml0bWFzayA9IHNvdXJjZVsxXSwgbmV3Qml0bWFzayA9IGJpdG1hc2sgfCBzcmNCaXRtYXNrLCBpc0NvbW1vbiA9IG5ld0JpdG1hc2sgPCAoV1JBUF9CSU5EX0ZMQUcgfCBXUkFQX0JJTkRfS0VZX0ZMQUcgfCBXUkFQX0FSWV9GTEFHKTtcbiAgICAgICAgICB2YXIgaXNDb21ibyA9IHNyY0JpdG1hc2sgPT0gV1JBUF9BUllfRkxBRyAmJiBiaXRtYXNrID09IFdSQVBfQ1VSUllfRkxBRyB8fCBzcmNCaXRtYXNrID09IFdSQVBfQVJZX0ZMQUcgJiYgYml0bWFzayA9PSBXUkFQX1JFQVJHX0ZMQUcgJiYgZGF0YVs3XS5sZW5ndGggPD0gc291cmNlWzhdIHx8IHNyY0JpdG1hc2sgPT0gKFdSQVBfQVJZX0ZMQUcgfCBXUkFQX1JFQVJHX0ZMQUcpICYmIHNvdXJjZVs3XS5sZW5ndGggPD0gc291cmNlWzhdICYmIGJpdG1hc2sgPT0gV1JBUF9DVVJSWV9GTEFHO1xuICAgICAgICAgIGlmICghKGlzQ29tbW9uIHx8IGlzQ29tYm8pKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNyY0JpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRykge1xuICAgICAgICAgICAgZGF0YVsyXSA9IHNvdXJjZVsyXTtcbiAgICAgICAgICAgIG5ld0JpdG1hc2sgfD0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHID8gMCA6IFdSQVBfQ1VSUllfQk9VTkRfRkxBRztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHZhbHVlID0gc291cmNlWzNdO1xuICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHBhcnRpYWxzID0gZGF0YVszXTtcbiAgICAgICAgICAgIGRhdGFbM10gPSBwYXJ0aWFscyA/IGNvbXBvc2VBcmdzKHBhcnRpYWxzLCB2YWx1ZSwgc291cmNlWzRdKSA6IHZhbHVlO1xuICAgICAgICAgICAgZGF0YVs0XSA9IHBhcnRpYWxzID8gcmVwbGFjZUhvbGRlcnMoZGF0YVszXSwgUExBQ0VIT0xERVIpIDogc291cmNlWzRdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZSA9IHNvdXJjZVs1XTtcbiAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHBhcnRpYWxzID0gZGF0YVs1XTtcbiAgICAgICAgICAgIGRhdGFbNV0gPSBwYXJ0aWFscyA/IGNvbXBvc2VBcmdzUmlnaHQocGFydGlhbHMsIHZhbHVlLCBzb3VyY2VbNl0pIDogdmFsdWU7XG4gICAgICAgICAgICBkYXRhWzZdID0gcGFydGlhbHMgPyByZXBsYWNlSG9sZGVycyhkYXRhWzVdLCBQTEFDRUhPTERFUikgOiBzb3VyY2VbNl07XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbHVlID0gc291cmNlWzddO1xuICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgZGF0YVs3XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3JjQml0bWFzayAmIFdSQVBfQVJZX0ZMQUcpIHtcbiAgICAgICAgICAgIGRhdGFbOF0gPSBkYXRhWzhdID09IG51bGwgPyBzb3VyY2VbOF0gOiBuYXRpdmVNaW4oZGF0YVs4XSwgc291cmNlWzhdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRhdGFbOV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgZGF0YVs5XSA9IHNvdXJjZVs5XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YVswXSA9IHNvdXJjZVswXTtcbiAgICAgICAgICBkYXRhWzFdID0gbmV3Qml0bWFzaztcbiAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gICAgICAgICAgdmFyIHJlc3VsdDIgPSBbXTtcbiAgICAgICAgICBpZiAob2JqZWN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBPYmplY3QyKG9iamVjdCkpIHtcbiAgICAgICAgICAgICAgcmVzdWx0Mi5wdXNoKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCB0cmFuc2Zvcm0yKSB7XG4gICAgICAgICAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZDIgPyBmdW5jLmxlbmd0aCAtIDEgOiBzdGFydCwgMCk7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsIGluZGV4ID0gLTEsIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSwgYXJyYXkgPSBBcnJheTIobGVuZ3RoKTtcbiAgICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICAgICAgdmFyIG90aGVyQXJncyA9IEFycmF5MihzdGFydCArIDEpO1xuICAgICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgICAgICAgICBvdGhlckFyZ3NbaW5kZXhdID0gYXJnc1tpbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdGhlckFyZ3Nbc3RhcnRdID0gdHJhbnNmb3JtMihhcnJheSk7XG4gICAgICAgICAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHBhcmVudChvYmplY3QsIHBhdGgpIHtcbiAgICAgICAgICByZXR1cm4gcGF0aC5sZW5ndGggPCAyID8gb2JqZWN0IDogYmFzZUdldChvYmplY3QsIGJhc2VTbGljZShwYXRoLCAwLCAtMSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlb3JkZXIoYXJyYXksIGluZGV4ZXMpIHtcbiAgICAgICAgICB2YXIgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLCBsZW5ndGggPSBuYXRpdmVNaW4oaW5kZXhlcy5sZW5ndGgsIGFyckxlbmd0aCksIG9sZEFycmF5ID0gY29weUFycmF5KGFycmF5KTtcbiAgICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGluZGV4ZXNbbGVuZ3RoXTtcbiAgICAgICAgICAgIGFycmF5W2xlbmd0aF0gPSBpc0luZGV4KGluZGV4LCBhcnJMZW5ndGgpID8gb2xkQXJyYXlbaW5kZXhdIDogdW5kZWZpbmVkMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNhZmVHZXQob2JqZWN0LCBrZXkpIHtcbiAgICAgICAgICBpZiAoa2V5ID09PSBcImNvbnN0cnVjdG9yXCIgJiYgdHlwZW9mIG9iamVjdFtrZXldID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGtleSA9PSBcIl9fcHJvdG9fX1wiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvYmplY3Rba2V5XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2V0RGF0YSA9IHNob3J0T3V0KGJhc2VTZXREYXRhKTtcbiAgICAgICAgdmFyIHNldFRpbWVvdXQgPSBjdHhTZXRUaW1lb3V0IHx8IGZ1bmN0aW9uKGZ1bmMsIHdhaXQpIHtcbiAgICAgICAgICByZXR1cm4gcm9vdC5zZXRUaW1lb3V0KGZ1bmMsIHdhaXQpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgc2V0VG9TdHJpbmcgPSBzaG9ydE91dChiYXNlU2V0VG9TdHJpbmcpO1xuICAgICAgICBmdW5jdGlvbiBzZXRXcmFwVG9TdHJpbmcod3JhcHBlciwgcmVmZXJlbmNlLCBiaXRtYXNrKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IHJlZmVyZW5jZSArIFwiXCI7XG4gICAgICAgICAgcmV0dXJuIHNldFRvU3RyaW5nKHdyYXBwZXIsIGluc2VydFdyYXBEZXRhaWxzKHNvdXJjZSwgdXBkYXRlV3JhcERldGFpbHMoZ2V0V3JhcERldGFpbHMoc291cmNlKSwgYml0bWFzaykpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzaG9ydE91dChmdW5jKSB7XG4gICAgICAgICAgdmFyIGNvdW50ID0gMCwgbGFzdENhbGxlZCA9IDA7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHN0YW1wID0gbmF0aXZlTm93KCksIHJlbWFpbmluZyA9IEhPVF9TUEFOIC0gKHN0YW1wIC0gbGFzdENhbGxlZCk7XG4gICAgICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICAgICAgICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgICAgICAgICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb3VudCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQyLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2h1ZmZsZVNlbGYoYXJyYXksIHNpemUyKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCwgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcbiAgICAgICAgICBzaXplMiA9IHNpemUyID09PSB1bmRlZmluZWQyID8gbGVuZ3RoIDogc2l6ZTI7XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBzaXplMikge1xuICAgICAgICAgICAgdmFyIHJhbmQgPSBiYXNlUmFuZG9tKGluZGV4LCBsYXN0SW5kZXgpLCB2YWx1ZSA9IGFycmF5W3JhbmRdO1xuICAgICAgICAgICAgYXJyYXlbcmFuZF0gPSBhcnJheVtpbmRleF07XG4gICAgICAgICAgICBhcnJheVtpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXJyYXkubGVuZ3RoID0gc2l6ZTI7XG4gICAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICAgIHZhciByZXN1bHQyID0gW107XG4gICAgICAgICAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KDApID09PSA0Nikge1xuICAgICAgICAgICAgcmVzdWx0Mi5wdXNoKFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHJpbmcucmVwbGFjZShyZVByb3BOYW1lLCBmdW5jdGlvbihtYXRjaCwgbnVtYmVyLCBxdW90ZSwgc3ViU3RyaW5nKSB7XG4gICAgICAgICAgICByZXN1bHQyLnB1c2gocXVvdGUgPyBzdWJTdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsIFwiJDFcIikgOiBudW1iZXIgfHwgbWF0Y2gpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZXN1bHQyID0gdmFsdWUgKyBcIlwiO1xuICAgICAgICAgIHJldHVybiByZXN1bHQyID09IFwiMFwiICYmIDEgLyB2YWx1ZSA9PSAtSU5GSU5JVFkgPyBcIi0wXCIgOiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgICAgICAgICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZnVuYyArIFwiXCI7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVdyYXBEZXRhaWxzKGRldGFpbHMsIGJpdG1hc2spIHtcbiAgICAgICAgICBhcnJheUVhY2god3JhcEZsYWdzLCBmdW5jdGlvbihwYWlyKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBcIl8uXCIgKyBwYWlyWzBdO1xuICAgICAgICAgICAgaWYgKGJpdG1hc2sgJiBwYWlyWzFdICYmICFhcnJheUluY2x1ZGVzKGRldGFpbHMsIHZhbHVlKSkge1xuICAgICAgICAgICAgICBkZXRhaWxzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBkZXRhaWxzLnNvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB3cmFwcGVyQ2xvbmUod3JhcHBlcikge1xuICAgICAgICAgIGlmICh3cmFwcGVyIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB3cmFwcGVyLmNsb25lKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZXN1bHQyID0gbmV3IExvZGFzaFdyYXBwZXIod3JhcHBlci5fX3dyYXBwZWRfXywgd3JhcHBlci5fX2NoYWluX18pO1xuICAgICAgICAgIHJlc3VsdDIuX19hY3Rpb25zX18gPSBjb3B5QXJyYXkod3JhcHBlci5fX2FjdGlvbnNfXyk7XG4gICAgICAgICAgcmVzdWx0Mi5fX2luZGV4X18gPSB3cmFwcGVyLl9faW5kZXhfXztcbiAgICAgICAgICByZXN1bHQyLl9fdmFsdWVzX18gPSB3cmFwcGVyLl9fdmFsdWVzX187XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2h1bmsoYXJyYXksIHNpemUyLCBndWFyZCkge1xuICAgICAgICAgIGlmIChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKGFycmF5LCBzaXplMiwgZ3VhcmQpIDogc2l6ZTIgPT09IHVuZGVmaW5lZDIpIHtcbiAgICAgICAgICAgIHNpemUyID0gMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2l6ZTIgPSBuYXRpdmVNYXgodG9JbnRlZ2VyKHNpemUyKSwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICBpZiAoIWxlbmd0aCB8fCBzaXplMiA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGluZGV4ID0gMCwgcmVzSW5kZXggPSAwLCByZXN1bHQyID0gQXJyYXkyKG5hdGl2ZUNlaWwobGVuZ3RoIC8gc2l6ZTIpKTtcbiAgICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdDJbcmVzSW5kZXgrK10gPSBiYXNlU2xpY2UoYXJyYXksIGluZGV4LCBpbmRleCArPSBzaXplMik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNvbXBhY3QoYXJyYXkpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSAtMSwgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsIHJlc0luZGV4ID0gMCwgcmVzdWx0MiA9IFtdO1xuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MltyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjb25jYXQoKSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheTIobGVuZ3RoIC0gMSksIGFycmF5ID0gYXJndW1lbnRzWzBdLCBpbmRleCA9IGxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICAgICAgYXJnc1tpbmRleCAtIDFdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGFycmF5UHVzaChpc0FycmF5KGFycmF5KSA/IGNvcHlBcnJheShhcnJheSkgOiBbYXJyYXldLCBiYXNlRmxhdHRlbihhcmdzLCAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRpZmZlcmVuY2UgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheSwgdmFsdWVzMikge1xuICAgICAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdChhcnJheSkgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgYmFzZUZsYXR0ZW4odmFsdWVzMiwgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpKSA6IFtdO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGRpZmZlcmVuY2VCeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMyKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdGVlMiA9IGxhc3QodmFsdWVzMik7XG4gICAgICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGl0ZXJhdGVlMikpIHtcbiAgICAgICAgICAgIGl0ZXJhdGVlMiA9IHVuZGVmaW5lZDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdChhcnJheSkgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgYmFzZUZsYXR0ZW4odmFsdWVzMiwgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpLCBnZXRJdGVyYXRlZShpdGVyYXRlZTIsIDIpKSA6IFtdO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGRpZmZlcmVuY2VXaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXksIHZhbHVlczIpIHtcbiAgICAgICAgICB2YXIgY29tcGFyYXRvciA9IGxhc3QodmFsdWVzMik7XG4gICAgICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGNvbXBhcmF0b3IpKSB7XG4gICAgICAgICAgICBjb21wYXJhdG9yID0gdW5kZWZpbmVkMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KSA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCBiYXNlRmxhdHRlbih2YWx1ZXMyLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSksIHVuZGVmaW5lZDIsIGNvbXBhcmF0b3IpIDogW107XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiBkcm9wKGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuID0gZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkMiA/IDEgOiB0b0ludGVnZXIobik7XG4gICAgICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgbiA8IDAgPyAwIDogbiwgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkcm9wUmlnaHQoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgfVxuICAgICAgICAgIG4gPSBndWFyZCB8fCBuID09PSB1bmRlZmluZWQyID8gMSA6IHRvSW50ZWdlcihuKTtcbiAgICAgICAgICBuID0gbGVuZ3RoIC0gbjtcbiAgICAgICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCAwLCBuIDwgMCA/IDAgOiBuKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkcm9wUmlnaHRXaGlsZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5ICYmIGFycmF5Lmxlbmd0aCA/IGJhc2VXaGlsZShhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgdHJ1ZSwgdHJ1ZSkgOiBbXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkcm9wV2hpbGUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgICAgIHJldHVybiBhcnJheSAmJiBhcnJheS5sZW5ndGggPyBiYXNlV2hpbGUoYXJyYXksIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIHRydWUpIDogW107XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZmlsbChhcnJheSwgdmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXJ0ICYmIHR5cGVvZiBzdGFydCAhPSBcIm51bWJlclwiICYmIGlzSXRlcmF0ZWVDYWxsKGFycmF5LCB2YWx1ZSwgc3RhcnQpKSB7XG4gICAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiYXNlRmlsbChhcnJheSwgdmFsdWUsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGluZGV4ID0gZnJvbUluZGV4ID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgaW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYmFzZUZpbmRJbmRleChhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZpbmRMYXN0SW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpbmRleCA9IGxlbmd0aCAtIDE7XG4gICAgICAgICAgaWYgKGZyb21JbmRleCAhPT0gdW5kZWZpbmVkMikge1xuICAgICAgICAgICAgaW5kZXggPSB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgICAgICAgICAgIGluZGV4ID0gZnJvbUluZGV4IDwgMCA/IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMCkgOiBuYXRpdmVNaW4oaW5kZXgsIGxlbmd0aCAtIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYmFzZUZpbmRJbmRleChhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgaW5kZXgsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXkpIHtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCAxKSA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZsYXR0ZW5EZWVwKGFycmF5KSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlRmxhdHRlbihhcnJheSwgSU5GSU5JVFkpIDogW107XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZmxhdHRlbkRlcHRoKGFycmF5LCBkZXB0aCkge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZXB0aCA9IGRlcHRoID09PSB1bmRlZmluZWQyID8gMSA6IHRvSW50ZWdlcihkZXB0aCk7XG4gICAgICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZnJvbVBhaXJzKHBhaXJzKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gLTEsIGxlbmd0aCA9IHBhaXJzID09IG51bGwgPyAwIDogcGFpcnMubGVuZ3RoLCByZXN1bHQyID0ge307XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBwYWlyID0gcGFpcnNbaW5kZXhdO1xuICAgICAgICAgICAgcmVzdWx0MltwYWlyWzBdXSA9IHBhaXJbMV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGhlYWQoYXJyYXkpIHtcbiAgICAgICAgICByZXR1cm4gYXJyYXkgJiYgYXJyYXkubGVuZ3RoID8gYXJyYXlbMF0gOiB1bmRlZmluZWQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGluZGV4ID0gZnJvbUluZGV4ID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgaW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaW5pdGlhbChhcnJheSkge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gbGVuZ3RoID8gYmFzZVNsaWNlKGFycmF5LCAwLCAtMSkgOiBbXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW50ZXJzZWN0aW9uID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICAgICAgdmFyIG1hcHBlZCA9IGFycmF5TWFwKGFycmF5cywgY2FzdEFycmF5TGlrZU9iamVjdCk7XG4gICAgICAgICAgcmV0dXJuIG1hcHBlZC5sZW5ndGggJiYgbWFwcGVkWzBdID09PSBhcnJheXNbMF0gPyBiYXNlSW50ZXJzZWN0aW9uKG1hcHBlZCkgOiBbXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBpbnRlcnNlY3Rpb25CeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgICAgIHZhciBpdGVyYXRlZTIgPSBsYXN0KGFycmF5cyksIG1hcHBlZCA9IGFycmF5TWFwKGFycmF5cywgY2FzdEFycmF5TGlrZU9iamVjdCk7XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlMiA9PT0gbGFzdChtYXBwZWQpKSB7XG4gICAgICAgICAgICBpdGVyYXRlZTIgPSB1bmRlZmluZWQyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXBwZWQucG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBtYXBwZWQubGVuZ3RoICYmIG1hcHBlZFswXSA9PT0gYXJyYXlzWzBdID8gYmFzZUludGVyc2VjdGlvbihtYXBwZWQsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlMiwgMikpIDogW107XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgaW50ZXJzZWN0aW9uV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgICAgIHZhciBjb21wYXJhdG9yID0gbGFzdChhcnJheXMpLCBtYXBwZWQgPSBhcnJheU1hcChhcnJheXMsIGNhc3RBcnJheUxpa2VPYmplY3QpO1xuICAgICAgICAgIGNvbXBhcmF0b3IgPSB0eXBlb2YgY29tcGFyYXRvciA9PSBcImZ1bmN0aW9uXCIgPyBjb21wYXJhdG9yIDogdW5kZWZpbmVkMjtcbiAgICAgICAgICBpZiAoY29tcGFyYXRvcikge1xuICAgICAgICAgICAgbWFwcGVkLnBvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWFwcGVkLmxlbmd0aCAmJiBtYXBwZWRbMF0gPT09IGFycmF5c1swXSA/IGJhc2VJbnRlcnNlY3Rpb24obWFwcGVkLCB1bmRlZmluZWQyLCBjb21wYXJhdG9yKSA6IFtdO1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gam9pbihhcnJheSwgc2VwYXJhdG9yKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5ID09IG51bGwgPyBcIlwiIDogbmF0aXZlSm9pbi5jYWxsKGFycmF5LCBzZXBhcmF0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGxhc3QoYXJyYXkpIHtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIGxlbmd0aCA/IGFycmF5W2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkMjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBsYXN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaW5kZXggPSBsZW5ndGg7XG4gICAgICAgICAgaWYgKGZyb21JbmRleCAhPT0gdW5kZWZpbmVkMikge1xuICAgICAgICAgICAgaW5kZXggPSB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgICAgICAgICAgIGluZGV4ID0gaW5kZXggPCAwID8gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKSA6IG5hdGl2ZU1pbihpbmRleCwgbGVuZ3RoIC0gMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPyBzdHJpY3RMYXN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGluZGV4KSA6IGJhc2VGaW5kSW5kZXgoYXJyYXksIGJhc2VJc05hTiwgaW5kZXgsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG50aChhcnJheSwgbikge1xuICAgICAgICAgIHJldHVybiBhcnJheSAmJiBhcnJheS5sZW5ndGggPyBiYXNlTnRoKGFycmF5LCB0b0ludGVnZXIobikpIDogdW5kZWZpbmVkMjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHVsbCA9IGJhc2VSZXN0KHB1bGxBbGwpO1xuICAgICAgICBmdW5jdGlvbiBwdWxsQWxsKGFycmF5LCB2YWx1ZXMyKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5ICYmIGFycmF5Lmxlbmd0aCAmJiB2YWx1ZXMyICYmIHZhbHVlczIubGVuZ3RoID8gYmFzZVB1bGxBbGwoYXJyYXksIHZhbHVlczIpIDogYXJyYXk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcHVsbEFsbEJ5KGFycmF5LCB2YWx1ZXMyLCBpdGVyYXRlZTIpIHtcbiAgICAgICAgICByZXR1cm4gYXJyYXkgJiYgYXJyYXkubGVuZ3RoICYmIHZhbHVlczIgJiYgdmFsdWVzMi5sZW5ndGggPyBiYXNlUHVsbEFsbChhcnJheSwgdmFsdWVzMiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUyLCAyKSkgOiBhcnJheTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBwdWxsQWxsV2l0aChhcnJheSwgdmFsdWVzMiwgY29tcGFyYXRvcikge1xuICAgICAgICAgIHJldHVybiBhcnJheSAmJiBhcnJheS5sZW5ndGggJiYgdmFsdWVzMiAmJiB2YWx1ZXMyLmxlbmd0aCA/IGJhc2VQdWxsQWxsKGFycmF5LCB2YWx1ZXMyLCB1bmRlZmluZWQyLCBjb21wYXJhdG9yKSA6IGFycmF5O1xuICAgICAgICB9XG4gICAgICAgIHZhciBwdWxsQXQgPSBmbGF0UmVzdChmdW5jdGlvbihhcnJheSwgaW5kZXhlcykge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCwgcmVzdWx0MiA9IGJhc2VBdChhcnJheSwgaW5kZXhlcyk7XG4gICAgICAgICAgYmFzZVB1bGxBdChhcnJheSwgYXJyYXlNYXAoaW5kZXhlcywgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0luZGV4KGluZGV4LCBsZW5ndGgpID8gK2luZGV4IDogaW5kZXg7XG4gICAgICAgICAgfSkuc29ydChjb21wYXJlQXNjZW5kaW5nKSk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiByZW1vdmUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgICAgIHZhciByZXN1bHQyID0gW107XG4gICAgICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpbmRleCA9IC0xLCBpbmRleGVzID0gW10sIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICBwcmVkaWNhdGUgPSBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpO1xuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgIGluZGV4ZXMucHVzaChpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJhc2VQdWxsQXQoYXJyYXksIGluZGV4ZXMpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJldmVyc2UoYXJyYXkpIHtcbiAgICAgICAgICByZXR1cm4gYXJyYXkgPT0gbnVsbCA/IGFycmF5IDogbmF0aXZlUmV2ZXJzZS5jYWxsKGFycmF5KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZW5kICYmIHR5cGVvZiBlbmQgIT0gXCJudW1iZXJcIiAmJiBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgc3RhcnQsIGVuZCkpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgICAgIGVuZCA9IGxlbmd0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhcnQgPSBzdGFydCA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihzdGFydCk7XG4gICAgICAgICAgICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZDIgPyBsZW5ndGggOiB0b0ludGVnZXIoZW5kKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc29ydGVkSW5kZXgoYXJyYXksIHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBpdGVyYXRlZTIpIHtcbiAgICAgICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBnZXRJdGVyYXRlZShpdGVyYXRlZTIsIDIpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzb3J0ZWRJbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA8IGxlbmd0aCAmJiBlcShhcnJheVtpbmRleF0sIHZhbHVlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzb3J0ZWRMYXN0SW5kZXgoYXJyYXksIHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNvcnRlZExhc3RJbmRleEJ5KGFycmF5LCB2YWx1ZSwgaXRlcmF0ZWUyKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleEJ5KGFycmF5LCB2YWx1ZSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUyLCAyKSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc29ydGVkTGFzdEluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgICAgIGlmIChsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUsIHRydWUpIC0gMTtcbiAgICAgICAgICAgIGlmIChlcShhcnJheVtpbmRleF0sIHZhbHVlKSkge1xuICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzb3J0ZWRVbmlxKGFycmF5KSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5ICYmIGFycmF5Lmxlbmd0aCA/IGJhc2VTb3J0ZWRVbmlxKGFycmF5KSA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNvcnRlZFVuaXFCeShhcnJheSwgaXRlcmF0ZWUyKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5ICYmIGFycmF5Lmxlbmd0aCA/IGJhc2VTb3J0ZWRVbmlxKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZTIsIDIpKSA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRhaWwoYXJyYXkpIHtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VTbGljZShhcnJheSwgMSwgbGVuZ3RoKSA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRha2UoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuID0gZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkMiA/IDEgOiB0b0ludGVnZXIobik7XG4gICAgICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgMCwgbiA8IDAgPyAwIDogbik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdGFrZVJpZ2h0KGFycmF5LCBuLCBndWFyZCkge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuID0gZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkMiA/IDEgOiB0b0ludGVnZXIobik7XG4gICAgICAgICAgbiA9IGxlbmd0aCAtIG47XG4gICAgICAgICAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgbiA8IDAgPyAwIDogbiwgbGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB0YWtlUmlnaHRXaGlsZShhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5ICYmIGFycmF5Lmxlbmd0aCA/IGJhc2VXaGlsZShhcnJheSwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgZmFsc2UsIHRydWUpIDogW107XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdGFrZVdoaWxlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgICAgICByZXR1cm4gYXJyYXkgJiYgYXJyYXkubGVuZ3RoID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKSA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1bmlvbiA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcnJheXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgdW5pb25CeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgICAgIHZhciBpdGVyYXRlZTIgPSBsYXN0KGFycmF5cyk7XG4gICAgICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGl0ZXJhdGVlMikpIHtcbiAgICAgICAgICAgIGl0ZXJhdGVlMiA9IHVuZGVmaW5lZDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcnJheXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUyLCAyKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgdW5pb25XaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICAgICAgdmFyIGNvbXBhcmF0b3IgPSBsYXN0KGFycmF5cyk7XG4gICAgICAgICAgY29tcGFyYXRvciA9IHR5cGVvZiBjb21wYXJhdG9yID09IFwiZnVuY3Rpb25cIiA/IGNvbXBhcmF0b3IgOiB1bmRlZmluZWQyO1xuICAgICAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcnJheXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSwgdW5kZWZpbmVkMiwgY29tcGFyYXRvcik7XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiB1bmlxKGFycmF5KSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5ICYmIGFycmF5Lmxlbmd0aCA/IGJhc2VVbmlxKGFycmF5KSA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHVuaXFCeShhcnJheSwgaXRlcmF0ZWUyKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5ICYmIGFycmF5Lmxlbmd0aCA/IGJhc2VVbmlxKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZTIsIDIpKSA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHVuaXFXaXRoKGFycmF5LCBjb21wYXJhdG9yKSB7XG4gICAgICAgICAgY29tcGFyYXRvciA9IHR5cGVvZiBjb21wYXJhdG9yID09IFwiZnVuY3Rpb25cIiA/IGNvbXBhcmF0b3IgOiB1bmRlZmluZWQyO1xuICAgICAgICAgIHJldHVybiBhcnJheSAmJiBhcnJheS5sZW5ndGggPyBiYXNlVW5pcShhcnJheSwgdW5kZWZpbmVkMiwgY29tcGFyYXRvcikgOiBbXTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB1bnppcChhcnJheSkge1xuICAgICAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgICAgICAgYXJyYXkgPSBhcnJheUZpbHRlcihhcnJheSwgZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgICAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChncm91cCkpIHtcbiAgICAgICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGdyb3VwLmxlbmd0aCwgbGVuZ3RoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIGJhc2VUaW1lcyhsZW5ndGgsIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXlNYXAoYXJyYXksIGJhc2VQcm9wZXJ0eShpbmRleCkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHVuemlwV2l0aChhcnJheSwgaXRlcmF0ZWUyKSB7XG4gICAgICAgICAgaWYgKCEoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IHVuemlwKGFycmF5KTtcbiAgICAgICAgICBpZiAoaXRlcmF0ZWUyID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYXJyYXlNYXAocmVzdWx0MiwgZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgICAgICAgIHJldHVybiBhcHBseShpdGVyYXRlZTIsIHVuZGVmaW5lZDIsIGdyb3VwKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2l0aG91dCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMyKSB7XG4gICAgICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KSA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCB2YWx1ZXMyKSA6IFtdO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHhvciA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgICAgIHJldHVybiBiYXNlWG9yKGFycmF5RmlsdGVyKGFycmF5cywgaXNBcnJheUxpa2VPYmplY3QpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB4b3JCeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgICAgIHZhciBpdGVyYXRlZTIgPSBsYXN0KGFycmF5cyk7XG4gICAgICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGl0ZXJhdGVlMikpIHtcbiAgICAgICAgICAgIGl0ZXJhdGVlMiA9IHVuZGVmaW5lZDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiYXNlWG9yKGFycmF5RmlsdGVyKGFycmF5cywgaXNBcnJheUxpa2VPYmplY3QpLCBnZXRJdGVyYXRlZShpdGVyYXRlZTIsIDIpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB4b3JXaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICAgICAgdmFyIGNvbXBhcmF0b3IgPSBsYXN0KGFycmF5cyk7XG4gICAgICAgICAgY29tcGFyYXRvciA9IHR5cGVvZiBjb21wYXJhdG9yID09IFwiZnVuY3Rpb25cIiA/IGNvbXBhcmF0b3IgOiB1bmRlZmluZWQyO1xuICAgICAgICAgIHJldHVybiBiYXNlWG9yKGFycmF5RmlsdGVyKGFycmF5cywgaXNBcnJheUxpa2VPYmplY3QpLCB1bmRlZmluZWQyLCBjb21wYXJhdG9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB6aXAgPSBiYXNlUmVzdCh1bnppcCk7XG4gICAgICAgIGZ1bmN0aW9uIHppcE9iamVjdChwcm9wcywgdmFsdWVzMikge1xuICAgICAgICAgIHJldHVybiBiYXNlWmlwT2JqZWN0KHByb3BzIHx8IFtdLCB2YWx1ZXMyIHx8IFtdLCBhc3NpZ25WYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gemlwT2JqZWN0RGVlcChwcm9wcywgdmFsdWVzMikge1xuICAgICAgICAgIHJldHVybiBiYXNlWmlwT2JqZWN0KHByb3BzIHx8IFtdLCB2YWx1ZXMyIHx8IFtdLCBiYXNlU2V0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgemlwV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBhcnJheXMubGVuZ3RoLCBpdGVyYXRlZTIgPSBsZW5ndGggPiAxID8gYXJyYXlzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkMjtcbiAgICAgICAgICBpdGVyYXRlZTIgPSB0eXBlb2YgaXRlcmF0ZWUyID09IFwiZnVuY3Rpb25cIiA/IChhcnJheXMucG9wKCksIGl0ZXJhdGVlMikgOiB1bmRlZmluZWQyO1xuICAgICAgICAgIHJldHVybiB1bnppcFdpdGgoYXJyYXlzLCBpdGVyYXRlZTIpO1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gY2hhaW4odmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IGxvZGFzaCh2YWx1ZSk7XG4gICAgICAgICAgcmVzdWx0Mi5fX2NoYWluX18gPSB0cnVlO1xuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRhcCh2YWx1ZSwgaW50ZXJjZXB0b3IpIHtcbiAgICAgICAgICBpbnRlcmNlcHRvcih2YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRocnUodmFsdWUsIGludGVyY2VwdG9yKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyY2VwdG9yKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd3JhcHBlckF0ID0gZmxhdFJlc3QoZnVuY3Rpb24ocGF0aHMpIHtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gcGF0aHMubGVuZ3RoLCBzdGFydCA9IGxlbmd0aCA/IHBhdGhzWzBdIDogMCwgdmFsdWUgPSB0aGlzLl9fd3JhcHBlZF9fLCBpbnRlcmNlcHRvciA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGJhc2VBdChvYmplY3QsIHBhdGhzKTtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChsZW5ndGggPiAxIHx8IHRoaXMuX19hY3Rpb25zX18ubGVuZ3RoIHx8ICEodmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikgfHwgIWlzSW5kZXgoc3RhcnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50aHJ1KGludGVyY2VwdG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZShzdGFydCwgK3N0YXJ0ICsgKGxlbmd0aCA/IDEgOiAwKSk7XG4gICAgICAgICAgdmFsdWUuX19hY3Rpb25zX18ucHVzaCh7XG4gICAgICAgICAgICBcImZ1bmNcIjogdGhydSxcbiAgICAgICAgICAgIFwiYXJnc1wiOiBbaW50ZXJjZXB0b3JdLFxuICAgICAgICAgICAgXCJ0aGlzQXJnXCI6IHVuZGVmaW5lZDJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIodmFsdWUsIHRoaXMuX19jaGFpbl9fKS50aHJ1KGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICAgICAgICBpZiAobGVuZ3RoICYmICFhcnJheS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgYXJyYXkucHVzaCh1bmRlZmluZWQyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZ1bmN0aW9uIHdyYXBwZXJDaGFpbigpIHtcbiAgICAgICAgICByZXR1cm4gY2hhaW4odGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gd3JhcHBlckNvbW1pdCgpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIodGhpcy52YWx1ZSgpLCB0aGlzLl9fY2hhaW5fXyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gd3JhcHBlck5leHQoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX192YWx1ZXNfXyA9PT0gdW5kZWZpbmVkMikge1xuICAgICAgICAgICAgdGhpcy5fX3ZhbHVlc19fID0gdG9BcnJheSh0aGlzLnZhbHVlKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZG9uZSA9IHRoaXMuX19pbmRleF9fID49IHRoaXMuX192YWx1ZXNfXy5sZW5ndGgsIHZhbHVlID0gZG9uZSA/IHVuZGVmaW5lZDIgOiB0aGlzLl9fdmFsdWVzX19bdGhpcy5fX2luZGV4X18rK107XG4gICAgICAgICAgcmV0dXJuIHsgXCJkb25lXCI6IGRvbmUsIFwidmFsdWVcIjogdmFsdWUgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB3cmFwcGVyVG9JdGVyYXRvcigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB3cmFwcGVyUGxhbnQodmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0MiwgcGFyZW50MiA9IHRoaXM7XG4gICAgICAgICAgd2hpbGUgKHBhcmVudDIgaW5zdGFuY2VvZiBiYXNlTG9kYXNoKSB7XG4gICAgICAgICAgICB2YXIgY2xvbmUyID0gd3JhcHBlckNsb25lKHBhcmVudDIpO1xuICAgICAgICAgICAgY2xvbmUyLl9faW5kZXhfXyA9IDA7XG4gICAgICAgICAgICBjbG9uZTIuX192YWx1ZXNfXyA9IHVuZGVmaW5lZDI7XG4gICAgICAgICAgICBpZiAocmVzdWx0Mikge1xuICAgICAgICAgICAgICBwcmV2aW91cy5fX3dyYXBwZWRfXyA9IGNsb25lMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBjbG9uZTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcHJldmlvdXMgPSBjbG9uZTI7XG4gICAgICAgICAgICBwYXJlbnQyID0gcGFyZW50Mi5fX3dyYXBwZWRfXztcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJldmlvdXMuX193cmFwcGVkX18gPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB3cmFwcGVyUmV2ZXJzZSgpIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9fd3JhcHBlZF9fO1xuICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB7XG4gICAgICAgICAgICB2YXIgd3JhcHBlZCA9IHZhbHVlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX19hY3Rpb25zX18ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHdyYXBwZWQgPSBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cmFwcGVkID0gd3JhcHBlZC5yZXZlcnNlKCk7XG4gICAgICAgICAgICB3cmFwcGVkLl9fYWN0aW9uc19fLnB1c2goe1xuICAgICAgICAgICAgICBcImZ1bmNcIjogdGhydSxcbiAgICAgICAgICAgICAgXCJhcmdzXCI6IFtyZXZlcnNlXSxcbiAgICAgICAgICAgICAgXCJ0aGlzQXJnXCI6IHVuZGVmaW5lZDJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHdyYXBwZWQsIHRoaXMuX19jaGFpbl9fKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMudGhydShyZXZlcnNlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB3cmFwcGVyVmFsdWUoKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VXcmFwcGVyVmFsdWUodGhpcy5fX3dyYXBwZWRfXywgdGhpcy5fX2FjdGlvbnNfXyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvdW50QnkgPSBjcmVhdGVBZ2dyZWdhdG9yKGZ1bmN0aW9uKHJlc3VsdDIsIHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQyLCBrZXkpKSB7XG4gICAgICAgICAgICArK3Jlc3VsdDJba2V5XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdDIsIGtleSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gZXZlcnkoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBndWFyZCkge1xuICAgICAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RXZlcnkgOiBiYXNlRXZlcnk7XG4gICAgICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpKSB7XG4gICAgICAgICAgICBwcmVkaWNhdGUgPSB1bmRlZmluZWQyO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlGaWx0ZXIgOiBiYXNlRmlsdGVyO1xuICAgICAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmaW5kID0gY3JlYXRlRmluZChmaW5kSW5kZXgpO1xuICAgICAgICB2YXIgZmluZExhc3QgPSBjcmVhdGVGaW5kKGZpbmRMYXN0SW5kZXgpO1xuICAgICAgICBmdW5jdGlvbiBmbGF0TWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlMikge1xuICAgICAgICAgIHJldHVybiBiYXNlRmxhdHRlbihtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUyKSwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZmxhdE1hcERlZXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUyKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZTIpLCBJTkZJTklUWSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZmxhdE1hcERlcHRoKGNvbGxlY3Rpb24sIGl0ZXJhdGVlMiwgZGVwdGgpIHtcbiAgICAgICAgICBkZXB0aCA9IGRlcHRoID09PSB1bmRlZmluZWQyID8gMSA6IHRvSW50ZWdlcihkZXB0aCk7XG4gICAgICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZTIpLCBkZXB0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZm9yRWFjaChjb2xsZWN0aW9uLCBpdGVyYXRlZTIpIHtcbiAgICAgICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheUVhY2ggOiBiYXNlRWFjaDtcbiAgICAgICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZTIsIDMpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmb3JFYWNoUmlnaHQoY29sbGVjdGlvbiwgaXRlcmF0ZWUyKSB7XG4gICAgICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlFYWNoUmlnaHQgOiBiYXNlRWFjaFJpZ2h0O1xuICAgICAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlMiwgMykpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBncm91cEJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQyLCB2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0Miwga2V5KSkge1xuICAgICAgICAgICAgcmVzdWx0MltrZXldLnB1c2godmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0Miwga2V5LCBbdmFsdWVdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiBpbmNsdWRlcyhjb2xsZWN0aW9uLCB2YWx1ZSwgZnJvbUluZGV4LCBndWFyZCkge1xuICAgICAgICAgIGNvbGxlY3Rpb24gPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IGNvbGxlY3Rpb24gOiB2YWx1ZXMoY29sbGVjdGlvbik7XG4gICAgICAgICAgZnJvbUluZGV4ID0gZnJvbUluZGV4ICYmICFndWFyZCA/IHRvSW50ZWdlcihmcm9tSW5kZXgpIDogMDtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG4gICAgICAgICAgaWYgKGZyb21JbmRleCA8IDApIHtcbiAgICAgICAgICAgIGZyb21JbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBmcm9tSW5kZXgsIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaXNTdHJpbmcoY29sbGVjdGlvbikgPyBmcm9tSW5kZXggPD0gbGVuZ3RoICYmIGNvbGxlY3Rpb24uaW5kZXhPZih2YWx1ZSwgZnJvbUluZGV4KSA+IC0xIDogISFsZW5ndGggJiYgYmFzZUluZGV4T2YoY29sbGVjdGlvbiwgdmFsdWUsIGZyb21JbmRleCkgPiAtMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW52b2tlTWFwID0gYmFzZVJlc3QoZnVuY3Rpb24oY29sbGVjdGlvbiwgcGF0aCwgYXJncykge1xuICAgICAgICAgIHZhciBpbmRleCA9IC0xLCBpc0Z1bmMgPSB0eXBlb2YgcGF0aCA9PSBcImZ1bmN0aW9uXCIsIHJlc3VsdDIgPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IEFycmF5Mihjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcbiAgICAgICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgcmVzdWx0MlsrK2luZGV4XSA9IGlzRnVuYyA/IGFwcGx5KHBhdGgsIHZhbHVlLCBhcmdzKSA6IGJhc2VJbnZva2UodmFsdWUsIHBhdGgsIGFyZ3MpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGtleUJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQyLCB2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdDIsIGtleSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gbWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlMikge1xuICAgICAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5TWFwIDogYmFzZU1hcDtcbiAgICAgICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShpdGVyYXRlZTIsIDMpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzLCBndWFyZCkge1xuICAgICAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpc0FycmF5KGl0ZXJhdGVlcykpIHtcbiAgICAgICAgICAgIGl0ZXJhdGVlcyA9IGl0ZXJhdGVlcyA9PSBudWxsID8gW10gOiBbaXRlcmF0ZWVzXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3JkZXJzID0gZ3VhcmQgPyB1bmRlZmluZWQyIDogb3JkZXJzO1xuICAgICAgICAgIGlmICghaXNBcnJheShvcmRlcnMpKSB7XG4gICAgICAgICAgICBvcmRlcnMgPSBvcmRlcnMgPT0gbnVsbCA/IFtdIDogW29yZGVyc107XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBpdGVyYXRlZXMsIG9yZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcnRpdGlvbiA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0MiwgdmFsdWUsIGtleSkge1xuICAgICAgICAgIHJlc3VsdDJba2V5ID8gMCA6IDFdLnB1c2godmFsdWUpO1xuICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gW1tdLCBbXV07XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiByZWR1Y2UoY29sbGVjdGlvbiwgaXRlcmF0ZWUyLCBhY2N1bXVsYXRvcikge1xuICAgICAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5UmVkdWNlIDogYmFzZVJlZHVjZSwgaW5pdEFjY3VtID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUyLCA0KSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgYmFzZUVhY2gpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNvbGxlY3Rpb24sIGl0ZXJhdGVlMiwgYWNjdW11bGF0b3IpIHtcbiAgICAgICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVJlZHVjZVJpZ2h0IDogYmFzZVJlZHVjZSwgaW5pdEFjY3VtID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUyLCA0KSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgYmFzZUVhY2hSaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RmlsdGVyIDogYmFzZUZpbHRlcjtcbiAgICAgICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBuZWdhdGUoZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNhbXBsZShjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTYW1wbGUgOiBiYXNlU2FtcGxlO1xuICAgICAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNhbXBsZVNpemUoY29sbGVjdGlvbiwgbiwgZ3VhcmQpIHtcbiAgICAgICAgICBpZiAoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBuLCBndWFyZCkgOiBuID09PSB1bmRlZmluZWQyKSB7XG4gICAgICAgICAgICBuID0gMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTYW1wbGVTaXplIDogYmFzZVNhbXBsZVNpemU7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgbik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2h1ZmZsZShjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTaHVmZmxlIDogYmFzZVNodWZmbGU7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2l6ZShjb2xsZWN0aW9uKSB7XG4gICAgICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0FycmF5TGlrZShjb2xsZWN0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzU3RyaW5nKGNvbGxlY3Rpb24pID8gc3RyaW5nU2l6ZShjb2xsZWN0aW9uKSA6IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdGFnID0gZ2V0VGFnKGNvbGxlY3Rpb24pO1xuICAgICAgICAgIGlmICh0YWcgPT0gbWFwVGFnIHx8IHRhZyA9PSBzZXRUYWcpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0aW9uLnNpemU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiYXNlS2V5cyhjb2xsZWN0aW9uKS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc29tZShjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGd1YXJkKSB7XG4gICAgICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTb21lIDogYmFzZVNvbWU7XG4gICAgICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpKSB7XG4gICAgICAgICAgICBwcmVkaWNhdGUgPSB1bmRlZmluZWQyO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc29ydEJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWVzKSB7XG4gICAgICAgICAgaWYgKGNvbGxlY3Rpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbGVuZ3RoID0gaXRlcmF0ZWVzLmxlbmd0aDtcbiAgICAgICAgICBpZiAobGVuZ3RoID4gMSAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBpdGVyYXRlZXNbMF0sIGl0ZXJhdGVlc1sxXSkpIHtcbiAgICAgICAgICAgIGl0ZXJhdGVlcyA9IFtdO1xuICAgICAgICAgIH0gZWxzZSBpZiAobGVuZ3RoID4gMiAmJiBpc0l0ZXJhdGVlQ2FsbChpdGVyYXRlZXNbMF0sIGl0ZXJhdGVlc1sxXSwgaXRlcmF0ZWVzWzJdKSkge1xuICAgICAgICAgICAgaXRlcmF0ZWVzID0gW2l0ZXJhdGVlc1swXV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiYXNlT3JkZXJCeShjb2xsZWN0aW9uLCBiYXNlRmxhdHRlbihpdGVyYXRlZXMsIDEpLCBbXSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbm93ID0gY3R4Tm93IHx8IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiByb290LkRhdGUubm93KCk7XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIGFmdGVyKG4sIGZ1bmMpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yMihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICgtLW4gPCAxKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBhcnkoZnVuYywgbiwgZ3VhcmQpIHtcbiAgICAgICAgICBuID0gZ3VhcmQgPyB1bmRlZmluZWQyIDogbjtcbiAgICAgICAgICBuID0gZnVuYyAmJiBuID09IG51bGwgPyBmdW5jLmxlbmd0aCA6IG47XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9BUllfRkxBRywgdW5kZWZpbmVkMiwgdW5kZWZpbmVkMiwgdW5kZWZpbmVkMiwgdW5kZWZpbmVkMiwgbik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gYmVmb3JlKG4sIGZ1bmMpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0MjtcbiAgICAgICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yMihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICgtLW4gPiAwKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobiA8PSAxKSB7XG4gICAgICAgICAgICAgIGZ1bmMgPSB1bmRlZmluZWQyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmluZCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHRoaXNBcmcsIHBhcnRpYWxzKSB7XG4gICAgICAgICAgdmFyIGJpdG1hc2sgPSBXUkFQX0JJTkRfRkxBRztcbiAgICAgICAgICBpZiAocGFydGlhbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBnZXRIb2xkZXIoYmluZCkpO1xuICAgICAgICAgICAgYml0bWFzayB8PSBXUkFQX1BBUlRJQUxfRkxBRztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGJpbmRLZXkgPSBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIGtleSwgcGFydGlhbHMpIHtcbiAgICAgICAgICB2YXIgYml0bWFzayA9IFdSQVBfQklORF9GTEFHIHwgV1JBUF9CSU5EX0tFWV9GTEFHO1xuICAgICAgICAgIGlmIChwYXJ0aWFscy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGdldEhvbGRlcihiaW5kS2V5KSk7XG4gICAgICAgICAgICBiaXRtYXNrIHw9IFdSQVBfUEFSVElBTF9GTEFHO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY3JlYXRlV3JhcChrZXksIGJpdG1hc2ssIG9iamVjdCwgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gY3VycnkoZnVuYywgYXJpdHksIGd1YXJkKSB7XG4gICAgICAgICAgYXJpdHkgPSBndWFyZCA/IHVuZGVmaW5lZDIgOiBhcml0eTtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9DVVJSWV9GTEFHLCB1bmRlZmluZWQyLCB1bmRlZmluZWQyLCB1bmRlZmluZWQyLCB1bmRlZmluZWQyLCB1bmRlZmluZWQyLCBhcml0eSk7XG4gICAgICAgICAgcmVzdWx0Mi5wbGFjZWhvbGRlciA9IGN1cnJ5LnBsYWNlaG9sZGVyO1xuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGN1cnJ5UmlnaHQoZnVuYywgYXJpdHksIGd1YXJkKSB7XG4gICAgICAgICAgYXJpdHkgPSBndWFyZCA/IHVuZGVmaW5lZDIgOiBhcml0eTtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9DVVJSWV9SSUdIVF9GTEFHLCB1bmRlZmluZWQyLCB1bmRlZmluZWQyLCB1bmRlZmluZWQyLCB1bmRlZmluZWQyLCB1bmRlZmluZWQyLCBhcml0eSk7XG4gICAgICAgICAgcmVzdWx0Mi5wbGFjZWhvbGRlciA9IGN1cnJ5UmlnaHQucGxhY2Vob2xkZXI7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgICAgICAgIHZhciBsYXN0QXJncywgbGFzdFRoaXMsIG1heFdhaXQsIHJlc3VsdDIsIHRpbWVySWQsIGxhc3RDYWxsVGltZSwgbGFzdEludm9rZVRpbWUgPSAwLCBsZWFkaW5nID0gZmFsc2UsIG1heGluZyA9IGZhbHNlLCB0cmFpbGluZyA9IHRydWU7XG4gICAgICAgICAgaWYgKHR5cGVvZiBmdW5jICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjIoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2FpdCA9IHRvTnVtYmVyKHdhaXQpIHx8IDA7XG4gICAgICAgICAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgICAgICBsZWFkaW5nID0gISFvcHRpb25zLmxlYWRpbmc7XG4gICAgICAgICAgICBtYXhpbmcgPSBcIm1heFdhaXRcIiBpbiBvcHRpb25zO1xuICAgICAgICAgICAgbWF4V2FpdCA9IG1heGluZyA/IG5hdGl2ZU1heCh0b051bWJlcihvcHRpb25zLm1heFdhaXQpIHx8IDAsIHdhaXQpIDogbWF4V2FpdDtcbiAgICAgICAgICAgIHRyYWlsaW5nID0gXCJ0cmFpbGluZ1wiIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gaW52b2tlRnVuYyh0aW1lKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IGxhc3RBcmdzLCB0aGlzQXJnID0gbGFzdFRoaXM7XG4gICAgICAgICAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkMjtcbiAgICAgICAgICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIGxlYWRpbmdFZGdlKHRpbWUpIHtcbiAgICAgICAgICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAgICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgICAgICByZXR1cm4gbGVhZGluZyA/IGludm9rZUZ1bmModGltZSkgOiByZXN1bHQyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiByZW1haW5pbmdXYWl0KHRpbWUpIHtcbiAgICAgICAgICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsIHRpbWVXYWl0aW5nID0gd2FpdCAtIHRpbWVTaW5jZUxhc3RDYWxsO1xuICAgICAgICAgICAgcmV0dXJuIG1heGluZyA/IG5hdGl2ZU1pbih0aW1lV2FpdGluZywgbWF4V2FpdCAtIHRpbWVTaW5jZUxhc3RJbnZva2UpIDogdGltZVdhaXRpbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XG4gICAgICAgICAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLCB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lO1xuICAgICAgICAgICAgcmV0dXJuIGxhc3RDYWxsVGltZSA9PT0gdW5kZWZpbmVkMiB8fCB0aW1lU2luY2VMYXN0Q2FsbCA+PSB3YWl0IHx8IHRpbWVTaW5jZUxhc3RDYWxsIDwgMCB8fCBtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiB0aW1lckV4cGlyZWQoKSB7XG4gICAgICAgICAgICB2YXIgdGltZSA9IG5vdygpO1xuICAgICAgICAgICAgaWYgKHNob3VsZEludm9rZSh0aW1lKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCByZW1haW5pbmdXYWl0KHRpbWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gdHJhaWxpbmdFZGdlKHRpbWUpIHtcbiAgICAgICAgICAgIHRpbWVySWQgPSB1bmRlZmluZWQyO1xuICAgICAgICAgICAgaWYgKHRyYWlsaW5nICYmIGxhc3RBcmdzKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDI7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgICAgICAgICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZDIpIHtcbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdEludm9rZVRpbWUgPSAwO1xuICAgICAgICAgICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aW1lcklkID09PSB1bmRlZmluZWQyID8gcmVzdWx0MiA6IHRyYWlsaW5nRWRnZShub3coKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICAgICAgICAgIHZhciB0aW1lID0gbm93KCksIGlzSW52b2tpbmcgPSBzaG91bGRJbnZva2UodGltZSk7XG4gICAgICAgICAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIGxhc3RUaGlzID0gdGhpcztcbiAgICAgICAgICAgIGxhc3RDYWxsVGltZSA9IHRpbWU7XG4gICAgICAgICAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgICAgICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgICAgICAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW52b2tlRnVuYyhsYXN0Q2FsbFRpbWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkMikge1xuICAgICAgICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlYm91bmNlZC5jYW5jZWwgPSBjYW5jZWw7XG4gICAgICAgICAgZGVib3VuY2VkLmZsdXNoID0gZmx1c2g7XG4gICAgICAgICAgcmV0dXJuIGRlYm91bmNlZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVmZXIgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBhcmdzKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VEZWxheShmdW5jLCAxLCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBkZWxheSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIGFyZ3MpIHtcbiAgICAgICAgICByZXR1cm4gYmFzZURlbGF5KGZ1bmMsIHRvTnVtYmVyKHdhaXQpIHx8IDAsIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gZmxpcChmdW5jKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9GTElQX0ZMQUcpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1lbW9pemUyKGZ1bmMsIHJlc29sdmVyKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBmdW5jICE9IFwiZnVuY3Rpb25cIiB8fCByZXNvbHZlciAhPSBudWxsICYmIHR5cGVvZiByZXNvbHZlciAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IyKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLCBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuICAgICAgICAgICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXN1bHQyID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0MikgfHwgY2FjaGU7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgICB9O1xuICAgICAgICAgIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplMi5DYWNoZSB8fCBNYXBDYWNoZSkoKTtcbiAgICAgICAgICByZXR1cm4gbWVtb2l6ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgbWVtb2l6ZTIuQ2FjaGUgPSBNYXBDYWNoZTtcbiAgICAgICAgZnVuY3Rpb24gbmVnYXRlKHByZWRpY2F0ZSkge1xuICAgICAgICAgIGlmICh0eXBlb2YgcHJlZGljYXRlICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjIoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzLCBhcmdzWzBdKTtcbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICFwcmVkaWNhdGUuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBvbmNlKGZ1bmMpIHtcbiAgICAgICAgICByZXR1cm4gYmVmb3JlKDIsIGZ1bmMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdmVyQXJncyA9IGNhc3RSZXN0KGZ1bmN0aW9uKGZ1bmMsIHRyYW5zZm9ybXMpIHtcbiAgICAgICAgICB0cmFuc2Zvcm1zID0gdHJhbnNmb3Jtcy5sZW5ndGggPT0gMSAmJiBpc0FycmF5KHRyYW5zZm9ybXNbMF0pID8gYXJyYXlNYXAodHJhbnNmb3Jtc1swXSwgYmFzZVVuYXJ5KGdldEl0ZXJhdGVlKCkpKSA6IGFycmF5TWFwKGJhc2VGbGF0dGVuKHRyYW5zZm9ybXMsIDEpLCBiYXNlVW5hcnkoZ2V0SXRlcmF0ZWUoKSkpO1xuICAgICAgICAgIHZhciBmdW5jc0xlbmd0aCA9IHRyYW5zZm9ybXMubGVuZ3RoO1xuICAgICAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSAtMSwgbGVuZ3RoID0gbmF0aXZlTWluKGFyZ3MubGVuZ3RoLCBmdW5jc0xlbmd0aCk7XG4gICAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICBhcmdzW2luZGV4XSA9IHRyYW5zZm9ybXNbaW5kZXhdLmNhbGwodGhpcywgYXJnc1tpbmRleF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIGFyZ3MpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHBhcnRpYWwgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBwYXJ0aWFscykge1xuICAgICAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGdldEhvbGRlcihwYXJ0aWFsKSk7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9QQVJUSUFMX0ZMQUcsIHVuZGVmaW5lZDIsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBwYXJ0aWFsUmlnaHQgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBwYXJ0aWFscykge1xuICAgICAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGdldEhvbGRlcihwYXJ0aWFsUmlnaHQpKTtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX1BBUlRJQUxfUklHSFRfRkxBRywgdW5kZWZpbmVkMiwgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHJlYXJnID0gZmxhdFJlc3QoZnVuY3Rpb24oZnVuYywgaW5kZXhlcykge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfUkVBUkdfRkxBRywgdW5kZWZpbmVkMiwgdW5kZWZpbmVkMiwgdW5kZWZpbmVkMiwgaW5kZXhlcyk7XG4gICAgICAgIH0pO1xuICAgICAgICBmdW5jdGlvbiByZXN0KGZ1bmMsIHN0YXJ0KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBmdW5jICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcjIoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RhcnQgPSBzdGFydCA9PT0gdW5kZWZpbmVkMiA/IHN0YXJ0IDogdG9JbnRlZ2VyKHN0YXJ0KTtcbiAgICAgICAgICByZXR1cm4gYmFzZVJlc3QoZnVuYywgc3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHNwcmVhZChmdW5jLCBzdGFydCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IyKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXJ0ID0gc3RhcnQgPT0gbnVsbCA/IDAgOiBuYXRpdmVNYXgodG9JbnRlZ2VyKHN0YXJ0KSwgMCk7XG4gICAgICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgICAgIHZhciBhcnJheSA9IGFyZ3Nbc3RhcnRdLCBvdGhlckFyZ3MgPSBjYXN0U2xpY2UoYXJncywgMCwgc3RhcnQpO1xuICAgICAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgICAgIGFycmF5UHVzaChvdGhlckFyZ3MsIGFycmF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcHBseShmdW5jLCB0aGlzLCBvdGhlckFyZ3MpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRocm90dGxlKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICAgICAgICB2YXIgbGVhZGluZyA9IHRydWUsIHRyYWlsaW5nID0gdHJ1ZTtcbiAgICAgICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yMihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgICAgIGxlYWRpbmcgPSBcImxlYWRpbmdcIiBpbiBvcHRpb25zID8gISFvcHRpb25zLmxlYWRpbmcgOiBsZWFkaW5nO1xuICAgICAgICAgICAgdHJhaWxpbmcgPSBcInRyYWlsaW5nXCIgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZGVib3VuY2UoZnVuYywgd2FpdCwge1xuICAgICAgICAgICAgXCJsZWFkaW5nXCI6IGxlYWRpbmcsXG4gICAgICAgICAgICBcIm1heFdhaXRcIjogd2FpdCxcbiAgICAgICAgICAgIFwidHJhaWxpbmdcIjogdHJhaWxpbmdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB1bmFyeShmdW5jKSB7XG4gICAgICAgICAgcmV0dXJuIGFyeShmdW5jLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB3cmFwKHZhbHVlLCB3cmFwcGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnRpYWwoY2FzdEZ1bmN0aW9uKHdyYXBwZXIpLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2FzdEFycmF5KCkge1xuICAgICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdmFsdWUgPSBhcmd1bWVudHNbMF07XG4gICAgICAgICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNsb25lKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfU1lNQk9MU19GTEFHKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjbG9uZVdpdGgodmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gXCJmdW5jdGlvblwiID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDI7XG4gICAgICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfU1lNQk9MU19GTEFHLCBjdXN0b21pemVyKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjbG9uZURlZXAodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9ERUVQX0ZMQUcgfCBDTE9ORV9TWU1CT0xTX0ZMQUcpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNsb25lRGVlcFdpdGgodmFsdWUsIGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gXCJmdW5jdGlvblwiID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDI7XG4gICAgICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfREVFUF9GTEFHIHwgQ0xPTkVfU1lNQk9MU19GTEFHLCBjdXN0b21pemVyKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjb25mb3Jtc1RvKG9iamVjdCwgc291cmNlKSB7XG4gICAgICAgICAgcmV0dXJuIHNvdXJjZSA9PSBudWxsIHx8IGJhc2VDb25mb3Jtc1RvKG9iamVjdCwgc291cmNlLCBrZXlzKHNvdXJjZSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZ3QgPSBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKGJhc2VHdCk7XG4gICAgICAgIHZhciBndGUgPSBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAgICAgIHJldHVybiB2YWx1ZSA+PSBvdGhlcjtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gYXJndW1lbnRzO1xuICAgICAgICB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBcImNhbGxlZVwiKSAmJiAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgXCJjYWxsZWVcIik7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBpc0FycmF5ID0gQXJyYXkyLmlzQXJyYXk7XG4gICAgICAgIHZhciBpc0FycmF5QnVmZmVyID0gbm9kZUlzQXJyYXlCdWZmZXIgPyBiYXNlVW5hcnkobm9kZUlzQXJyYXlCdWZmZXIpIDogYmFzZUlzQXJyYXlCdWZmZXI7XG4gICAgICAgIGZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSBmYWxzZSB8fCBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGJvb2xUYWc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuICAgICAgICB2YXIgaXNEYXRlID0gbm9kZUlzRGF0ZSA/IGJhc2VVbmFyeShub2RlSXNEYXRlKSA6IGJhc2VJc0RhdGU7XG4gICAgICAgIGZ1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIHZhbHVlLm5vZGVUeXBlID09PSAxICYmICFpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNBcnJheUxpa2UodmFsdWUpICYmIChpc0FycmF5KHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUuc3BsaWNlID09IFwiZnVuY3Rpb25cIiB8fCBpc0J1ZmZlcih2YWx1ZSkgfHwgaXNUeXBlZEFycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gIXZhbHVlLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSk7XG4gICAgICAgICAgaWYgKHRhZyA9PSBtYXBUYWcgfHwgdGFnID09IHNldFRhZykge1xuICAgICAgICAgICAgcmV0dXJuICF2YWx1ZS5zaXplO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNQcm90b3R5cGUodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gIWJhc2VLZXlzKHZhbHVlKS5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0VxdWFsKHZhbHVlLCBvdGhlcikge1xuICAgICAgICAgIHJldHVybiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzRXF1YWxXaXRoKHZhbHVlLCBvdGhlciwgY3VzdG9taXplcikge1xuICAgICAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSBcImZ1bmN0aW9uXCIgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkMjtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IGN1c3RvbWl6ZXIgPyBjdXN0b21pemVyKHZhbHVlLCBvdGhlcikgOiB1bmRlZmluZWQyO1xuICAgICAgICAgIHJldHVybiByZXN1bHQyID09PSB1bmRlZmluZWQyID8gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCB1bmRlZmluZWQyLCBjdXN0b21pemVyKSA6ICEhcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0Vycm9yKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gdGFnID09IGVycm9yVGFnIHx8IHRhZyA9PSBkb21FeGNUYWcgfHwgdHlwZW9mIHZhbHVlLm1lc3NhZ2UgPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgdmFsdWUubmFtZSA9PSBcInN0cmluZ1wiICYmICFpc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0Zpbml0ZTIodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIgJiYgbmF0aXZlSXNGaW5pdGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0ludGVnZXIodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIgJiYgdmFsdWUgPT0gdG9JbnRlZ2VyKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIiAmJiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSBcIm9iamVjdFwiIHx8IHR5cGUgPT0gXCJmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNNYXAgPSBub2RlSXNNYXAgPyBiYXNlVW5hcnkobm9kZUlzTWFwKSA6IGJhc2VJc01hcDtcbiAgICAgICAgZnVuY3Rpb24gaXNNYXRjaChvYmplY3QsIHNvdXJjZSkge1xuICAgICAgICAgIHJldHVybiBvYmplY3QgPT09IHNvdXJjZSB8fCBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgZ2V0TWF0Y2hEYXRhKHNvdXJjZSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzTWF0Y2hXaXRoKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyKSB7XG4gICAgICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09IFwiZnVuY3Rpb25cIiA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQyO1xuICAgICAgICAgIHJldHVybiBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgZ2V0TWF0Y2hEYXRhKHNvdXJjZSksIGN1c3RvbWl6ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzTmFOMih2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBpc051bWJlcih2YWx1ZSkgJiYgdmFsdWUgIT0gK3ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzTmF0aXZlKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKGlzTWFza2FibGUodmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IyKENPUkVfRVJST1JfVEVYVCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzTnVsbCh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc05pbCh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSBcIm51bWJlclwiIHx8IGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gbnVtYmVyVGFnO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgICAgICAgICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgYmFzZUdldFRhZyh2YWx1ZSkgIT0gb2JqZWN0VGFnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBwcm90byA9IGdldFByb3RvdHlwZSh2YWx1ZSk7XG4gICAgICAgICAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCBcImNvbnN0cnVjdG9yXCIpICYmIHByb3RvLmNvbnN0cnVjdG9yO1xuICAgICAgICAgIHJldHVybiB0eXBlb2YgQ3RvciA9PSBcImZ1bmN0aW9uXCIgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiYgZnVuY1RvU3RyaW5nLmNhbGwoQ3RvcikgPT0gb2JqZWN0Q3RvclN0cmluZztcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNSZWdFeHAgPSBub2RlSXNSZWdFeHAgPyBiYXNlVW5hcnkobm9kZUlzUmVnRXhwKSA6IGJhc2VJc1JlZ0V4cDtcbiAgICAgICAgZnVuY3Rpb24gaXNTYWZlSW50ZWdlcih2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBpc0ludGVnZXIodmFsdWUpICYmIHZhbHVlID49IC1NQVhfU0FGRV9JTlRFR0VSICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlzU2V0ID0gbm9kZUlzU2V0ID8gYmFzZVVuYXJ5KG5vZGVJc1NldCkgOiBiYXNlSXNTZXQ7XG4gICAgICAgIGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiIHx8ICFpc0FycmF5KHZhbHVlKSAmJiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN0cmluZ1RhZztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gXCJzeW1ib2xcIiB8fCBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHN5bWJvbFRhZztcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG4gICAgICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGlzV2Vha01hcCh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gd2Vha01hcFRhZztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpc1dlYWtTZXQodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSB3ZWFrU2V0VGFnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsdCA9IGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oYmFzZUx0KTtcbiAgICAgICAgdmFyIGx0ZSA9IGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlIDw9IG90aGVyO1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSkge1xuICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzU3RyaW5nKHZhbHVlKSA/IHN0cmluZ1RvQXJyYXkodmFsdWUpIDogY29weUFycmF5KHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN5bUl0ZXJhdG9yICYmIHZhbHVlW3N5bUl0ZXJhdG9yXSkge1xuICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVG9BcnJheSh2YWx1ZVtzeW1JdGVyYXRvcl0oKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpLCBmdW5jID0gdGFnID09IG1hcFRhZyA/IG1hcFRvQXJyYXkgOiB0YWcgPT0gc2V0VGFnID8gc2V0VG9BcnJheSA6IHZhbHVlcztcbiAgICAgICAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdG9GaW5pdGUodmFsdWUpIHtcbiAgICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbHVlID0gdG9OdW1iZXIodmFsdWUpO1xuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gSU5GSU5JVFkgfHwgdmFsdWUgPT09IC1JTkZJTklUWSkge1xuICAgICAgICAgICAgdmFyIHNpZ24gPSB2YWx1ZSA8IDAgPyAtMSA6IDE7XG4gICAgICAgICAgICByZXR1cm4gc2lnbiAqIE1BWF9JTlRFR0VSO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gdmFsdWUgOiAwO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRvSW50ZWdlcih2YWx1ZSkge1xuICAgICAgICAgIHZhciByZXN1bHQyID0gdG9GaW5pdGUodmFsdWUpLCByZW1haW5kZXIgPSByZXN1bHQyICUgMTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0MiA9PT0gcmVzdWx0MiA/IHJlbWFpbmRlciA/IHJlc3VsdDIgLSByZW1haW5kZXIgOiByZXN1bHQyIDogMDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB0b0xlbmd0aCh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZSA/IGJhc2VDbGFtcCh0b0ludGVnZXIodmFsdWUpLCAwLCBNQVhfQVJSQVlfTEVOR1RIKSA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5BTjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gXCJmdW5jdGlvblwiID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgICAgICAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IG90aGVyICsgXCJcIiA6IG90aGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZSA9IGJhc2VUcmltKHZhbHVlKTtcbiAgICAgICAgICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICAgICAgICAgIHJldHVybiBpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpIDogcmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB0b1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGNvcHlPYmplY3QodmFsdWUsIGtleXNJbih2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRvU2FmZUludGVnZXIodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUgPyBiYXNlQ2xhbXAodG9JbnRlZ2VyKHZhbHVlKSwgLU1BWF9TQUZFX0lOVEVHRVIsIE1BWF9TQUZFX0lOVEVHRVIpIDogdmFsdWUgPT09IDAgPyB2YWx1ZSA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhc3NpZ24gPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSkge1xuICAgICAgICAgIGlmIChpc1Byb3RvdHlwZShzb3VyY2UpIHx8IGlzQXJyYXlMaWtlKHNvdXJjZSkpIHtcbiAgICAgICAgICAgIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBhc3NpZ25JbiA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlKSB7XG4gICAgICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGFzc2lnbkluV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICAgICAgICAgIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0LCBjdXN0b21pemVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBhc3NpZ25XaXRoID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKSB7XG4gICAgICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0LCBjdXN0b21pemVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBhdCA9IGZsYXRSZXN0KGJhc2VBdCk7XG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZShwcm90b3R5cGUsIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IGJhc2VDcmVhdGUocHJvdG90eXBlKTtcbiAgICAgICAgICByZXR1cm4gcHJvcGVydGllcyA9PSBudWxsID8gcmVzdWx0MiA6IGJhc2VBc3NpZ24ocmVzdWx0MiwgcHJvcGVydGllcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlZmF1bHRzID0gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgICAgICAgb2JqZWN0ID0gT2JqZWN0MihvYmplY3QpO1xuICAgICAgICAgIHZhciBpbmRleCA9IC0xO1xuICAgICAgICAgIHZhciBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aDtcbiAgICAgICAgICB2YXIgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDI7XG4gICAgICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgICAgICAgbGVuZ3RoID0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IGtleXNJbihzb3VyY2UpO1xuICAgICAgICAgICAgdmFyIHByb3BzSW5kZXggPSAtMTtcbiAgICAgICAgICAgIHZhciBwcm9wc0xlbmd0aCA9IHByb3BzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlICgrK3Byb3BzSW5kZXggPCBwcm9wc0xlbmd0aCkge1xuICAgICAgICAgICAgICB2YXIga2V5ID0gcHJvcHNbcHJvcHNJbmRleF07XG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZDIgfHwgZXEodmFsdWUsIG9iamVjdFByb3RvW2tleV0pICYmICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICAgICAgICAgIG9iamVjdFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBkZWZhdWx0c0RlZXAgPSBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgICAgYXJncy5wdXNoKHVuZGVmaW5lZDIsIGN1c3RvbURlZmF1bHRzTWVyZ2UpO1xuICAgICAgICAgIHJldHVybiBhcHBseShtZXJnZVdpdGgsIHVuZGVmaW5lZDIsIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gZmluZEtleShvYmplY3QsIHByZWRpY2F0ZSkge1xuICAgICAgICAgIHJldHVybiBiYXNlRmluZEtleShvYmplY3QsIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGJhc2VGb3JPd24pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZpbmRMYXN0S2V5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VGaW5kS2V5KG9iamVjdCwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgYmFzZUZvck93blJpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmb3JJbihvYmplY3QsIGl0ZXJhdGVlMikge1xuICAgICAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VGb3Iob2JqZWN0LCBnZXRJdGVyYXRlZShpdGVyYXRlZTIsIDMpLCBrZXlzSW4pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZvckluUmlnaHQob2JqZWN0LCBpdGVyYXRlZTIpIHtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlRm9yUmlnaHQob2JqZWN0LCBnZXRJdGVyYXRlZShpdGVyYXRlZTIsIDMpLCBrZXlzSW4pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZvck93bihvYmplY3QsIGl0ZXJhdGVlMikge1xuICAgICAgICAgIHJldHVybiBvYmplY3QgJiYgYmFzZUZvck93bihvYmplY3QsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlMiwgMykpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZvck93blJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUyKSB7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yT3duUmlnaHQob2JqZWN0LCBnZXRJdGVyYXRlZShpdGVyYXRlZTIsIDMpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmdW5jdGlvbnMob2JqZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlRnVuY3Rpb25zKG9iamVjdCwga2V5cyhvYmplY3QpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmdW5jdGlvbnNJbihvYmplY3QpIHtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VGdW5jdGlvbnMob2JqZWN0LCBrZXlzSW4ob2JqZWN0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdDIgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZDIgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDIgPT09IHVuZGVmaW5lZDIgPyBkZWZhdWx0VmFsdWUgOiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGhhcyhvYmplY3QsIHBhdGgpIHtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXMpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICAgICAgICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhc0luKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW52ZXJ0ID0gY3JlYXRlSW52ZXJ0ZXIoZnVuY3Rpb24ocmVzdWx0MiwgdmFsdWUsIGtleSkge1xuICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZS50b1N0cmluZyAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdDJbdmFsdWVdID0ga2V5O1xuICAgICAgICB9LCBjb25zdGFudChpZGVudGl0eSkpO1xuICAgICAgICB2YXIgaW52ZXJ0QnkgPSBjcmVhdGVJbnZlcnRlcihmdW5jdGlvbihyZXN1bHQyLCB2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdmFsdWUgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0MiwgdmFsdWUpKSB7XG4gICAgICAgICAgICByZXN1bHQyW3ZhbHVlXS5wdXNoKGtleSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDJbdmFsdWVdID0gW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9LCBnZXRJdGVyYXRlZSk7XG4gICAgICAgIHZhciBpbnZva2UgPSBiYXNlUmVzdChiYXNlSW52b2tlKTtcbiAgICAgICAgZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgICAgICAgICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICAgICAgICAgIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QsIHRydWUpIDogYmFzZUtleXNJbihvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1hcEtleXMob2JqZWN0LCBpdGVyYXRlZTIpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IHt9O1xuICAgICAgICAgIGl0ZXJhdGVlMiA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlMiwgMyk7XG4gICAgICAgICAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdDIpIHtcbiAgICAgICAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQyLCBpdGVyYXRlZTIodmFsdWUsIGtleSwgb2JqZWN0MiksIHZhbHVlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtYXBWYWx1ZXMob2JqZWN0LCBpdGVyYXRlZTIpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IHt9O1xuICAgICAgICAgIGl0ZXJhdGVlMiA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlMiwgMyk7XG4gICAgICAgICAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdDIpIHtcbiAgICAgICAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQyLCBrZXksIGl0ZXJhdGVlMih2YWx1ZSwga2V5LCBvYmplY3QyKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1lcmdlID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KSB7XG4gICAgICAgICAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbWVyZ2VXaXRoID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4LCBjdXN0b21pemVyKSB7XG4gICAgICAgICAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcik7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgb21pdCA9IGZsYXRSZXN0KGZ1bmN0aW9uKG9iamVjdCwgcGF0aHMpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IHt9O1xuICAgICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpc0RlZXAgPSBmYWxzZTtcbiAgICAgICAgICBwYXRocyA9IGFycmF5TWFwKHBhdGhzLCBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgICAgICAgICAgIGlzRGVlcCB8fCAoaXNEZWVwID0gcGF0aC5sZW5ndGggPiAxKTtcbiAgICAgICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvcHlPYmplY3Qob2JqZWN0LCBnZXRBbGxLZXlzSW4ob2JqZWN0KSwgcmVzdWx0Mik7XG4gICAgICAgICAgaWYgKGlzRGVlcCkge1xuICAgICAgICAgICAgcmVzdWx0MiA9IGJhc2VDbG9uZShyZXN1bHQyLCBDTE9ORV9ERUVQX0ZMQUcgfCBDTE9ORV9GTEFUX0ZMQUcgfCBDTE9ORV9TWU1CT0xTX0ZMQUcsIGN1c3RvbU9taXRDbG9uZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBsZW5ndGggPSBwYXRocy5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgICAgICBiYXNlVW5zZXQocmVzdWx0MiwgcGF0aHNbbGVuZ3RoXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gb21pdEJ5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIHBpY2tCeShvYmplY3QsIG5lZ2F0ZShnZXRJdGVyYXRlZShwcmVkaWNhdGUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBpY2sgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIHBhdGhzKSB7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8ge30gOiBiYXNlUGljayhvYmplY3QsIHBhdGhzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZ1bmN0aW9uIHBpY2tCeShvYmplY3QsIHByZWRpY2F0ZSkge1xuICAgICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgcHJvcHMgPSBhcnJheU1hcChnZXRBbGxLZXlzSW4ob2JqZWN0KSwgZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICAgICAgcmV0dXJuIFtwcm9wXTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwcmVkaWNhdGUgPSBnZXRJdGVyYXRlZShwcmVkaWNhdGUpO1xuICAgICAgICAgIHJldHVybiBiYXNlUGlja0J5KG9iamVjdCwgcHJvcHMsIGZ1bmN0aW9uKHZhbHVlLCBwYXRoKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJlZGljYXRlKHZhbHVlLCBwYXRoWzBdKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZXN1bHQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgICAgICAgICB2YXIgaW5kZXggPSAtMSwgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG4gICAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIGxlbmd0aCA9IDE7XG4gICAgICAgICAgICBvYmplY3QgPSB1bmRlZmluZWQyO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQyIDogb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXhdKV07XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZDIpIHtcbiAgICAgICAgICAgICAgaW5kZXggPSBsZW5ndGg7XG4gICAgICAgICAgICAgIHZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqZWN0ID0gaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZS5jYWxsKG9iamVjdCkgOiB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc2V0V2l0aChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKSB7XG4gICAgICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09IFwiZnVuY3Rpb25cIiA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQyO1xuICAgICAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRvUGFpcnMgPSBjcmVhdGVUb1BhaXJzKGtleXMpO1xuICAgICAgICB2YXIgdG9QYWlyc0luID0gY3JlYXRlVG9QYWlycyhrZXlzSW4pO1xuICAgICAgICBmdW5jdGlvbiB0cmFuc2Zvcm0ob2JqZWN0LCBpdGVyYXRlZTIsIGFjY3VtdWxhdG9yKSB7XG4gICAgICAgICAgdmFyIGlzQXJyID0gaXNBcnJheShvYmplY3QpLCBpc0Fyckxpa2UgPSBpc0FyciB8fCBpc0J1ZmZlcihvYmplY3QpIHx8IGlzVHlwZWRBcnJheShvYmplY3QpO1xuICAgICAgICAgIGl0ZXJhdGVlMiA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlMiwgNCk7XG4gICAgICAgICAgaWYgKGFjY3VtdWxhdG9yID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBDdG9yID0gb2JqZWN0ICYmIG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIGlmIChpc0Fyckxpa2UpIHtcbiAgICAgICAgICAgICAgYWNjdW11bGF0b3IgPSBpc0FyciA/IG5ldyBDdG9yKCkgOiBbXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICAgICAgICBhY2N1bXVsYXRvciA9IGlzRnVuY3Rpb24oQ3RvcikgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKSA6IHt9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYWNjdW11bGF0b3IgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgKGlzQXJyTGlrZSA/IGFycmF5RWFjaCA6IGJhc2VGb3JPd24pKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBvYmplY3QyKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlcmF0ZWUyKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIG9iamVjdDIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB1bnNldChvYmplY3QsIHBhdGgpIHtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB0cnVlIDogYmFzZVVuc2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlKG9iamVjdCwgcGF0aCwgdXBkYXRlcikge1xuICAgICAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VVcGRhdGUob2JqZWN0LCBwYXRoLCBjYXN0RnVuY3Rpb24odXBkYXRlcikpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVdpdGgob2JqZWN0LCBwYXRoLCB1cGRhdGVyLCBjdXN0b21pemVyKSB7XG4gICAgICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09IFwiZnVuY3Rpb25cIiA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQyO1xuICAgICAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VVcGRhdGUob2JqZWN0LCBwYXRoLCBjYXN0RnVuY3Rpb24odXBkYXRlciksIGN1c3RvbWl6ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZhbHVlcyhvYmplY3QpIHtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VWYWx1ZXMob2JqZWN0LCBrZXlzKG9iamVjdCkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHZhbHVlc0luKG9iamVjdCkge1xuICAgICAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZVZhbHVlcyhvYmplY3QsIGtleXNJbihvYmplY3QpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjbGFtcChudW1iZXIsIGxvd2VyLCB1cHBlcikge1xuICAgICAgICAgIGlmICh1cHBlciA9PT0gdW5kZWZpbmVkMikge1xuICAgICAgICAgICAgdXBwZXIgPSBsb3dlcjtcbiAgICAgICAgICAgIGxvd2VyID0gdW5kZWZpbmVkMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHVwcGVyICE9PSB1bmRlZmluZWQyKSB7XG4gICAgICAgICAgICB1cHBlciA9IHRvTnVtYmVyKHVwcGVyKTtcbiAgICAgICAgICAgIHVwcGVyID0gdXBwZXIgPT09IHVwcGVyID8gdXBwZXIgOiAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobG93ZXIgIT09IHVuZGVmaW5lZDIpIHtcbiAgICAgICAgICAgIGxvd2VyID0gdG9OdW1iZXIobG93ZXIpO1xuICAgICAgICAgICAgbG93ZXIgPSBsb3dlciA9PT0gbG93ZXIgPyBsb3dlciA6IDA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiYXNlQ2xhbXAodG9OdW1iZXIobnVtYmVyKSwgbG93ZXIsIHVwcGVyKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpblJhbmdlKG51bWJlciwgc3RhcnQsIGVuZCkge1xuICAgICAgICAgIHN0YXJ0ID0gdG9GaW5pdGUoc3RhcnQpO1xuICAgICAgICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZDIpIHtcbiAgICAgICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbmQgPSB0b0Zpbml0ZShlbmQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBudW1iZXIgPSB0b051bWJlcihudW1iZXIpO1xuICAgICAgICAgIHJldHVybiBiYXNlSW5SYW5nZShudW1iZXIsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJhbmRvbShsb3dlciwgdXBwZXIsIGZsb2F0aW5nKSB7XG4gICAgICAgICAgaWYgKGZsb2F0aW5nICYmIHR5cGVvZiBmbG9hdGluZyAhPSBcImJvb2xlYW5cIiAmJiBpc0l0ZXJhdGVlQ2FsbChsb3dlciwgdXBwZXIsIGZsb2F0aW5nKSkge1xuICAgICAgICAgICAgdXBwZXIgPSBmbG9hdGluZyA9IHVuZGVmaW5lZDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmbG9hdGluZyA9PT0gdW5kZWZpbmVkMikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB1cHBlciA9PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICBmbG9hdGluZyA9IHVwcGVyO1xuICAgICAgICAgICAgICB1cHBlciA9IHVuZGVmaW5lZDI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsb3dlciA9PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICBmbG9hdGluZyA9IGxvd2VyO1xuICAgICAgICAgICAgICBsb3dlciA9IHVuZGVmaW5lZDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsb3dlciA9PT0gdW5kZWZpbmVkMiAmJiB1cHBlciA9PT0gdW5kZWZpbmVkMikge1xuICAgICAgICAgICAgbG93ZXIgPSAwO1xuICAgICAgICAgICAgdXBwZXIgPSAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb3dlciA9IHRvRmluaXRlKGxvd2VyKTtcbiAgICAgICAgICAgIGlmICh1cHBlciA9PT0gdW5kZWZpbmVkMikge1xuICAgICAgICAgICAgICB1cHBlciA9IGxvd2VyO1xuICAgICAgICAgICAgICBsb3dlciA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB1cHBlciA9IHRvRmluaXRlKHVwcGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxvd2VyID4gdXBwZXIpIHtcbiAgICAgICAgICAgIHZhciB0ZW1wID0gbG93ZXI7XG4gICAgICAgICAgICBsb3dlciA9IHVwcGVyO1xuICAgICAgICAgICAgdXBwZXIgPSB0ZW1wO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZmxvYXRpbmcgfHwgbG93ZXIgJSAxIHx8IHVwcGVyICUgMSkge1xuICAgICAgICAgICAgdmFyIHJhbmQgPSBuYXRpdmVSYW5kb20oKTtcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVNaW4obG93ZXIgKyByYW5kICogKHVwcGVyIC0gbG93ZXIgKyBmcmVlUGFyc2VGbG9hdChcIjFlLVwiICsgKChyYW5kICsgXCJcIikubGVuZ3RoIC0gMSkpKSwgdXBwZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYmFzZVJhbmRvbShsb3dlciwgdXBwZXIpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjYW1lbENhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdDIsIHdvcmQsIGluZGV4KSB7XG4gICAgICAgICAgd29yZCA9IHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0MiArIChpbmRleCA/IGNhcGl0YWxpemUod29yZCkgOiB3b3JkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyaW5nKSB7XG4gICAgICAgICAgcmV0dXJuIHVwcGVyRmlyc3QodG9TdHJpbmcoc3RyaW5nKS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBkZWJ1cnIoc3RyaW5nKSB7XG4gICAgICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgICAgICByZXR1cm4gc3RyaW5nICYmIHN0cmluZy5yZXBsYWNlKHJlTGF0aW4sIGRlYnVyckxldHRlcikucmVwbGFjZShyZUNvbWJvTWFyaywgXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZW5kc1dpdGgoc3RyaW5nLCB0YXJnZXQsIHBvc2l0aW9uKSB7XG4gICAgICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgICAgICB0YXJnZXQgPSBiYXNlVG9TdHJpbmcodGFyZ2V0KTtcbiAgICAgICAgICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uID09PSB1bmRlZmluZWQyID8gbGVuZ3RoIDogYmFzZUNsYW1wKHRvSW50ZWdlcihwb3NpdGlvbiksIDAsIGxlbmd0aCk7XG4gICAgICAgICAgdmFyIGVuZCA9IHBvc2l0aW9uO1xuICAgICAgICAgIHBvc2l0aW9uIC09IHRhcmdldC5sZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIHBvc2l0aW9uID49IDAgJiYgc3RyaW5nLnNsaWNlKHBvc2l0aW9uLCBlbmQpID09IHRhcmdldDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBlc2NhcGUoc3RyaW5nKSB7XG4gICAgICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgICAgICByZXR1cm4gc3RyaW5nICYmIHJlSGFzVW5lc2NhcGVkSHRtbC50ZXN0KHN0cmluZykgPyBzdHJpbmcucmVwbGFjZShyZVVuZXNjYXBlZEh0bWwsIGVzY2FwZUh0bWxDaGFyKSA6IHN0cmluZztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyaW5nKSB7XG4gICAgICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgICAgICByZXR1cm4gc3RyaW5nICYmIHJlSGFzUmVnRXhwQ2hhci50ZXN0KHN0cmluZykgPyBzdHJpbmcucmVwbGFjZShyZVJlZ0V4cENoYXIsIFwiXFxcXCQmXCIpIDogc3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZWJhYkNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdDIsIHdvcmQsIGluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDIgKyAoaW5kZXggPyBcIi1cIiA6IFwiXCIpICsgd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGxvd2VyQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0Miwgd29yZCwgaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0MiArIChpbmRleCA/IFwiIFwiIDogXCJcIikgKyB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbG93ZXJGaXJzdCA9IGNyZWF0ZUNhc2VGaXJzdChcInRvTG93ZXJDYXNlXCIpO1xuICAgICAgICBmdW5jdGlvbiBwYWQoc3RyaW5nLCBsZW5ndGgsIGNoYXJzKSB7XG4gICAgICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgICAgICBsZW5ndGggPSB0b0ludGVnZXIobGVuZ3RoKTtcbiAgICAgICAgICB2YXIgc3RyTGVuZ3RoID0gbGVuZ3RoID8gc3RyaW5nU2l6ZShzdHJpbmcpIDogMDtcbiAgICAgICAgICBpZiAoIWxlbmd0aCB8fCBzdHJMZW5ndGggPj0gbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbWlkID0gKGxlbmd0aCAtIHN0ckxlbmd0aCkgLyAyO1xuICAgICAgICAgIHJldHVybiBjcmVhdGVQYWRkaW5nKG5hdGl2ZUZsb29yKG1pZCksIGNoYXJzKSArIHN0cmluZyArIGNyZWF0ZVBhZGRpbmcobmF0aXZlQ2VpbChtaWQpLCBjaGFycyk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcGFkRW5kKHN0cmluZywgbGVuZ3RoLCBjaGFycykge1xuICAgICAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICAgICAgbGVuZ3RoID0gdG9JbnRlZ2VyKGxlbmd0aCk7XG4gICAgICAgICAgdmFyIHN0ckxlbmd0aCA9IGxlbmd0aCA/IHN0cmluZ1NpemUoc3RyaW5nKSA6IDA7XG4gICAgICAgICAgcmV0dXJuIGxlbmd0aCAmJiBzdHJMZW5ndGggPCBsZW5ndGggPyBzdHJpbmcgKyBjcmVhdGVQYWRkaW5nKGxlbmd0aCAtIHN0ckxlbmd0aCwgY2hhcnMpIDogc3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHBhZFN0YXJ0KHN0cmluZywgbGVuZ3RoLCBjaGFycykge1xuICAgICAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICAgICAgbGVuZ3RoID0gdG9JbnRlZ2VyKGxlbmd0aCk7XG4gICAgICAgICAgdmFyIHN0ckxlbmd0aCA9IGxlbmd0aCA/IHN0cmluZ1NpemUoc3RyaW5nKSA6IDA7XG4gICAgICAgICAgcmV0dXJuIGxlbmd0aCAmJiBzdHJMZW5ndGggPCBsZW5ndGggPyBjcmVhdGVQYWRkaW5nKGxlbmd0aCAtIHN0ckxlbmd0aCwgY2hhcnMpICsgc3RyaW5nIDogc3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlSW50MihzdHJpbmcsIHJhZGl4LCBndWFyZCkge1xuICAgICAgICAgIGlmIChndWFyZCB8fCByYWRpeCA9PSBudWxsKSB7XG4gICAgICAgICAgICByYWRpeCA9IDA7XG4gICAgICAgICAgfSBlbHNlIGlmIChyYWRpeCkge1xuICAgICAgICAgICAgcmFkaXggPSArcmFkaXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuYXRpdmVQYXJzZUludCh0b1N0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVUcmltU3RhcnQsIFwiXCIpLCByYWRpeCB8fCAwKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZXBlYXQoc3RyaW5nLCBuLCBndWFyZCkge1xuICAgICAgICAgIGlmIChndWFyZCA/IGlzSXRlcmF0ZWVDYWxsKHN0cmluZywgbiwgZ3VhcmQpIDogbiA9PT0gdW5kZWZpbmVkMikge1xuICAgICAgICAgICAgbiA9IDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBiYXNlUmVwZWF0KHRvU3RyaW5nKHN0cmluZyksIG4pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlcGxhY2UoKSB7XG4gICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsIHN0cmluZyA9IHRvU3RyaW5nKGFyZ3NbMF0pO1xuICAgICAgICAgIHJldHVybiBhcmdzLmxlbmd0aCA8IDMgPyBzdHJpbmcgOiBzdHJpbmcucmVwbGFjZShhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc25ha2VDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQyLCB3b3JkLCBpbmRleCkge1xuICAgICAgICAgIHJldHVybiByZXN1bHQyICsgKGluZGV4ID8gXCJfXCIgOiBcIlwiKSArIHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZ1bmN0aW9uIHNwbGl0KHN0cmluZywgc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgICAgIGlmIChsaW1pdCAmJiB0eXBlb2YgbGltaXQgIT0gXCJudW1iZXJcIiAmJiBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIHNlcGFyYXRvciwgbGltaXQpKSB7XG4gICAgICAgICAgICBzZXBhcmF0b3IgPSBsaW1pdCA9IHVuZGVmaW5lZDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxpbWl0ID0gbGltaXQgPT09IHVuZGVmaW5lZDIgPyBNQVhfQVJSQVlfTEVOR1RIIDogbGltaXQgPj4+IDA7XG4gICAgICAgICAgaWYgKCFsaW1pdCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgICAgIGlmIChzdHJpbmcgJiYgKHR5cGVvZiBzZXBhcmF0b3IgPT0gXCJzdHJpbmdcIiB8fCBzZXBhcmF0b3IgIT0gbnVsbCAmJiAhaXNSZWdFeHAoc2VwYXJhdG9yKSkpIHtcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IGJhc2VUb1N0cmluZyhzZXBhcmF0b3IpO1xuICAgICAgICAgICAgaWYgKCFzZXBhcmF0b3IgJiYgaGFzVW5pY29kZShzdHJpbmcpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjYXN0U2xpY2Uoc3RyaW5nVG9BcnJheShzdHJpbmcpLCAwLCBsaW1pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzdHJpbmcuc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXJ0Q2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0Miwgd29yZCwgaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0MiArIChpbmRleCA/IFwiIFwiIDogXCJcIikgKyB1cHBlckZpcnN0KHdvcmQpO1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gc3RhcnRzV2l0aChzdHJpbmcsIHRhcmdldCwgcG9zaXRpb24pIHtcbiAgICAgICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gPT0gbnVsbCA/IDAgOiBiYXNlQ2xhbXAodG9JbnRlZ2VyKHBvc2l0aW9uKSwgMCwgc3RyaW5nLmxlbmd0aCk7XG4gICAgICAgICAgdGFyZ2V0ID0gYmFzZVRvU3RyaW5nKHRhcmdldCk7XG4gICAgICAgICAgcmV0dXJuIHN0cmluZy5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyB0YXJnZXQubGVuZ3RoKSA9PSB0YXJnZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdGVtcGxhdGUoc3RyaW5nLCBvcHRpb25zLCBndWFyZCkge1xuICAgICAgICAgIHZhciBzZXR0aW5ncyA9IGxvZGFzaC50ZW1wbGF0ZVNldHRpbmdzO1xuICAgICAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIG9wdGlvbnMsIGd1YXJkKSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHVuZGVmaW5lZDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICAgICAgb3B0aW9ucyA9IGFzc2lnbkluV2l0aCh7fSwgb3B0aW9ucywgc2V0dGluZ3MsIGN1c3RvbURlZmF1bHRzQXNzaWduSW4pO1xuICAgICAgICAgIHZhciBpbXBvcnRzID0gYXNzaWduSW5XaXRoKHt9LCBvcHRpb25zLmltcG9ydHMsIHNldHRpbmdzLmltcG9ydHMsIGN1c3RvbURlZmF1bHRzQXNzaWduSW4pLCBpbXBvcnRzS2V5cyA9IGtleXMoaW1wb3J0cyksIGltcG9ydHNWYWx1ZXMgPSBiYXNlVmFsdWVzKGltcG9ydHMsIGltcG9ydHNLZXlzKTtcbiAgICAgICAgICB2YXIgaXNFc2NhcGluZywgaXNFdmFsdWF0aW5nLCBpbmRleCA9IDAsIGludGVycG9sYXRlID0gb3B0aW9ucy5pbnRlcnBvbGF0ZSB8fCByZU5vTWF0Y2gsIHNvdXJjZSA9IFwiX19wICs9ICdcIjtcbiAgICAgICAgICB2YXIgcmVEZWxpbWl0ZXJzID0gUmVnRXhwMihcbiAgICAgICAgICAgIChvcHRpb25zLmVzY2FwZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArIFwifFwiICsgaW50ZXJwb2xhdGUuc291cmNlICsgXCJ8XCIgKyAoaW50ZXJwb2xhdGUgPT09IHJlSW50ZXJwb2xhdGUgPyByZUVzVGVtcGxhdGUgOiByZU5vTWF0Y2gpLnNvdXJjZSArIFwifFwiICsgKG9wdGlvbnMuZXZhbHVhdGUgfHwgcmVOb01hdGNoKS5zb3VyY2UgKyBcInwkXCIsXG4gICAgICAgICAgICBcImdcIlxuICAgICAgICAgICk7XG4gICAgICAgICAgdmFyIHNvdXJjZVVSTCA9IFwiLy8jIHNvdXJjZVVSTD1cIiArIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIFwic291cmNlVVJMXCIpID8gKG9wdGlvbnMuc291cmNlVVJMICsgXCJcIikucmVwbGFjZSgvXFxzL2csIFwiIFwiKSA6IFwibG9kYXNoLnRlbXBsYXRlU291cmNlc1tcIiArICsrdGVtcGxhdGVDb3VudGVyICsgXCJdXCIpICsgXCJcXG5cIjtcbiAgICAgICAgICBzdHJpbmcucmVwbGFjZShyZURlbGltaXRlcnMsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGVWYWx1ZSwgaW50ZXJwb2xhdGVWYWx1ZSwgZXNUZW1wbGF0ZVZhbHVlLCBldmFsdWF0ZVZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgICAgIGludGVycG9sYXRlVmFsdWUgfHwgKGludGVycG9sYXRlVmFsdWUgPSBlc1RlbXBsYXRlVmFsdWUpO1xuICAgICAgICAgICAgc291cmNlICs9IHN0cmluZy5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKHJlVW5lc2NhcGVkU3RyaW5nLCBlc2NhcGVTdHJpbmdDaGFyKTtcbiAgICAgICAgICAgIGlmIChlc2NhcGVWYWx1ZSkge1xuICAgICAgICAgICAgICBpc0VzY2FwaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgc291cmNlICs9IFwiJyArXFxuX19lKFwiICsgZXNjYXBlVmFsdWUgKyBcIikgK1xcbidcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChldmFsdWF0ZVZhbHVlKSB7XG4gICAgICAgICAgICAgIGlzRXZhbHVhdGluZyA9IHRydWU7XG4gICAgICAgICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZVZhbHVlICsgXCI7XFxuX19wICs9ICdcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbnRlcnBvbGF0ZVZhbHVlKSB7XG4gICAgICAgICAgICAgIHNvdXJjZSArPSBcIicgK1xcbigoX190ID0gKFwiICsgaW50ZXJwb2xhdGVWYWx1ZSArIFwiKSkgPT0gbnVsbCA/ICcnIDogX190KSArXFxuJ1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc291cmNlICs9IFwiJztcXG5cIjtcbiAgICAgICAgICB2YXIgdmFyaWFibGUgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIFwidmFyaWFibGVcIikgJiYgb3B0aW9ucy52YXJpYWJsZTtcbiAgICAgICAgICBpZiAoIXZhcmlhYmxlKSB7XG4gICAgICAgICAgICBzb3VyY2UgPSBcIndpdGggKG9iaikge1xcblwiICsgc291cmNlICsgXCJcXG59XFxuXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChyZUZvcmJpZGRlbklkZW50aWZpZXJDaGFycy50ZXN0KHZhcmlhYmxlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yMihJTlZBTElEX1RFTVBMX1ZBUl9FUlJPUl9URVhUKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc291cmNlID0gKGlzRXZhbHVhdGluZyA/IHNvdXJjZS5yZXBsYWNlKHJlRW1wdHlTdHJpbmdMZWFkaW5nLCBcIlwiKSA6IHNvdXJjZSkucmVwbGFjZShyZUVtcHR5U3RyaW5nTWlkZGxlLCBcIiQxXCIpLnJlcGxhY2UocmVFbXB0eVN0cmluZ1RyYWlsaW5nLCBcIiQxO1wiKTtcbiAgICAgICAgICBzb3VyY2UgPSBcImZ1bmN0aW9uKFwiICsgKHZhcmlhYmxlIHx8IFwib2JqXCIpICsgXCIpIHtcXG5cIiArICh2YXJpYWJsZSA/IFwiXCIgOiBcIm9iaiB8fCAob2JqID0ge30pO1xcblwiKSArIFwidmFyIF9fdCwgX19wID0gJydcIiArIChpc0VzY2FwaW5nID8gXCIsIF9fZSA9IF8uZXNjYXBlXCIgOiBcIlwiKSArIChpc0V2YWx1YXRpbmcgPyBcIiwgX19qID0gQXJyYXkucHJvdG90eXBlLmpvaW47XFxuZnVuY3Rpb24gcHJpbnQoKSB7IF9fcCArPSBfX2ouY2FsbChhcmd1bWVudHMsICcnKSB9XFxuXCIgOiBcIjtcXG5cIikgKyBzb3VyY2UgKyBcInJldHVybiBfX3BcXG59XCI7XG4gICAgICAgICAgdmFyIHJlc3VsdDIgPSBhdHRlbXB0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uMihpbXBvcnRzS2V5cywgc291cmNlVVJMICsgXCJyZXR1cm4gXCIgKyBzb3VyY2UpLmFwcGx5KHVuZGVmaW5lZDIsIGltcG9ydHNWYWx1ZXMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlc3VsdDIuc291cmNlID0gc291cmNlO1xuICAgICAgICAgIGlmIChpc0Vycm9yKHJlc3VsdDIpKSB7XG4gICAgICAgICAgICB0aHJvdyByZXN1bHQyO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB0b0xvd2VyKHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHRvU3RyaW5nKHZhbHVlKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRvVXBwZXIodmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gdG9TdHJpbmcodmFsdWUpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdHJpbShzdHJpbmcsIGNoYXJzLCBndWFyZCkge1xuICAgICAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICAgICAgaWYgKHN0cmluZyAmJiAoZ3VhcmQgfHwgY2hhcnMgPT09IHVuZGVmaW5lZDIpKSB7XG4gICAgICAgICAgICByZXR1cm4gYmFzZVRyaW0oc3RyaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFzdHJpbmcgfHwgIShjaGFycyA9IGJhc2VUb1N0cmluZyhjaGFycykpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgc3RyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoc3RyaW5nKSwgY2hyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoY2hhcnMpLCBzdGFydCA9IGNoYXJzU3RhcnRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSwgZW5kID0gY2hhcnNFbmRJbmRleChzdHJTeW1ib2xzLCBjaHJTeW1ib2xzKSArIDE7XG4gICAgICAgICAgcmV0dXJuIGNhc3RTbGljZShzdHJTeW1ib2xzLCBzdGFydCwgZW5kKS5qb2luKFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRyaW1FbmQoc3RyaW5nLCBjaGFycywgZ3VhcmQpIHtcbiAgICAgICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgICAgIGlmIChzdHJpbmcgJiYgKGd1YXJkIHx8IGNoYXJzID09PSB1bmRlZmluZWQyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5zbGljZSgwLCB0cmltbWVkRW5kSW5kZXgoc3RyaW5nKSArIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXN0cmluZyB8fCAhKGNoYXJzID0gYmFzZVRvU3RyaW5nKGNoYXJzKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBzdHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShzdHJpbmcpLCBlbmQgPSBjaGFyc0VuZEluZGV4KHN0clN5bWJvbHMsIHN0cmluZ1RvQXJyYXkoY2hhcnMpKSArIDE7XG4gICAgICAgICAgcmV0dXJuIGNhc3RTbGljZShzdHJTeW1ib2xzLCAwLCBlbmQpLmpvaW4oXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdHJpbVN0YXJ0KHN0cmluZywgY2hhcnMsIGd1YXJkKSB7XG4gICAgICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgICAgICBpZiAoc3RyaW5nICYmIChndWFyZCB8fCBjaGFycyA9PT0gdW5kZWZpbmVkMikpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcucmVwbGFjZShyZVRyaW1TdGFydCwgXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghc3RyaW5nIHx8ICEoY2hhcnMgPSBiYXNlVG9TdHJpbmcoY2hhcnMpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHN0clN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KHN0cmluZyksIHN0YXJ0ID0gY2hhcnNTdGFydEluZGV4KHN0clN5bWJvbHMsIHN0cmluZ1RvQXJyYXkoY2hhcnMpKTtcbiAgICAgICAgICByZXR1cm4gY2FzdFNsaWNlKHN0clN5bWJvbHMsIHN0YXJ0KS5qb2luKFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRydW5jYXRlKHN0cmluZywgb3B0aW9ucykge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBERUZBVUxUX1RSVU5DX0xFTkdUSCwgb21pc3Npb24gPSBERUZBVUxUX1RSVU5DX09NSVNTSU9OO1xuICAgICAgICAgIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICAgICAgdmFyIHNlcGFyYXRvciA9IFwic2VwYXJhdG9yXCIgaW4gb3B0aW9ucyA/IG9wdGlvbnMuc2VwYXJhdG9yIDogc2VwYXJhdG9yO1xuICAgICAgICAgICAgbGVuZ3RoID0gXCJsZW5ndGhcIiBpbiBvcHRpb25zID8gdG9JbnRlZ2VyKG9wdGlvbnMubGVuZ3RoKSA6IGxlbmd0aDtcbiAgICAgICAgICAgIG9taXNzaW9uID0gXCJvbWlzc2lvblwiIGluIG9wdGlvbnMgPyBiYXNlVG9TdHJpbmcob3B0aW9ucy5vbWlzc2lvbikgOiBvbWlzc2lvbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgICAgICB2YXIgc3RyTGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgICAgICBpZiAoaGFzVW5pY29kZShzdHJpbmcpKSB7XG4gICAgICAgICAgICB2YXIgc3RyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoc3RyaW5nKTtcbiAgICAgICAgICAgIHN0ckxlbmd0aCA9IHN0clN5bWJvbHMubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobGVuZ3RoID49IHN0ckxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGVuZCA9IGxlbmd0aCAtIHN0cmluZ1NpemUob21pc3Npb24pO1xuICAgICAgICAgIGlmIChlbmQgPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gb21pc3Npb247XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciByZXN1bHQyID0gc3RyU3ltYm9scyA/IGNhc3RTbGljZShzdHJTeW1ib2xzLCAwLCBlbmQpLmpvaW4oXCJcIikgOiBzdHJpbmcuc2xpY2UoMCwgZW5kKTtcbiAgICAgICAgICBpZiAoc2VwYXJhdG9yID09PSB1bmRlZmluZWQyKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0MiArIG9taXNzaW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RyU3ltYm9scykge1xuICAgICAgICAgICAgZW5kICs9IHJlc3VsdDIubGVuZ3RoIC0gZW5kO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNSZWdFeHAoc2VwYXJhdG9yKSkge1xuICAgICAgICAgICAgaWYgKHN0cmluZy5zbGljZShlbmQpLnNlYXJjaChzZXBhcmF0b3IpKSB7XG4gICAgICAgICAgICAgIHZhciBtYXRjaCwgc3Vic3RyaW5nID0gcmVzdWx0MjtcbiAgICAgICAgICAgICAgaWYgKCFzZXBhcmF0b3IuZ2xvYmFsKSB7XG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yID0gUmVnRXhwMihzZXBhcmF0b3Iuc291cmNlLCB0b1N0cmluZyhyZUZsYWdzLmV4ZWMoc2VwYXJhdG9yKSkgKyBcImdcIik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc2VwYXJhdG9yLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICAgIHdoaWxlIChtYXRjaCA9IHNlcGFyYXRvci5leGVjKHN1YnN0cmluZykpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3RW5kID0gbWF0Y2guaW5kZXg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0MiA9IHJlc3VsdDIuc2xpY2UoMCwgbmV3RW5kID09PSB1bmRlZmluZWQyID8gZW5kIDogbmV3RW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHN0cmluZy5pbmRleE9mKGJhc2VUb1N0cmluZyhzZXBhcmF0b3IpLCBlbmQpICE9IGVuZCkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gcmVzdWx0Mi5sYXN0SW5kZXhPZihzZXBhcmF0b3IpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MiA9IHJlc3VsdDIuc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0MiArIG9taXNzaW9uO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHVuZXNjYXBlKHN0cmluZykge1xuICAgICAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICAgICAgcmV0dXJuIHN0cmluZyAmJiByZUhhc0VzY2FwZWRIdG1sLnRlc3Qoc3RyaW5nKSA/IHN0cmluZy5yZXBsYWNlKHJlRXNjYXBlZEh0bWwsIHVuZXNjYXBlSHRtbENoYXIpIDogc3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1cHBlckNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdDIsIHdvcmQsIGluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDIgKyAoaW5kZXggPyBcIiBcIiA6IFwiXCIpICsgd29yZC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHVwcGVyRmlyc3QgPSBjcmVhdGVDYXNlRmlyc3QoXCJ0b1VwcGVyQ2FzZVwiKTtcbiAgICAgICAgZnVuY3Rpb24gd29yZHMoc3RyaW5nLCBwYXR0ZXJuLCBndWFyZCkge1xuICAgICAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICAgICAgcGF0dGVybiA9IGd1YXJkID8gdW5kZWZpbmVkMiA6IHBhdHRlcm47XG4gICAgICAgICAgaWYgKHBhdHRlcm4gPT09IHVuZGVmaW5lZDIpIHtcbiAgICAgICAgICAgIHJldHVybiBoYXNVbmljb2RlV29yZChzdHJpbmcpID8gdW5pY29kZVdvcmRzKHN0cmluZykgOiBhc2NpaVdvcmRzKHN0cmluZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzdHJpbmcubWF0Y2gocGF0dGVybikgfHwgW107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGF0dGVtcHQgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBhcmdzKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhcHBseShmdW5jLCB1bmRlZmluZWQyLCBhcmdzKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNFcnJvcihlKSA/IGUgOiBuZXcgRXJyb3IyKGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBiaW5kQWxsID0gZmxhdFJlc3QoZnVuY3Rpb24ob2JqZWN0LCBtZXRob2ROYW1lcykge1xuICAgICAgICAgIGFycmF5RWFjaChtZXRob2ROYW1lcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBrZXkgPSB0b0tleShrZXkpO1xuICAgICAgICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBiaW5kKG9iamVjdFtrZXldLCBvYmplY3QpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gY29uZChwYWlycykge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBwYWlycyA9PSBudWxsID8gMCA6IHBhaXJzLmxlbmd0aCwgdG9JdGVyYXRlZSA9IGdldEl0ZXJhdGVlKCk7XG4gICAgICAgICAgcGFpcnMgPSAhbGVuZ3RoID8gW10gOiBhcnJheU1hcChwYWlycywgZnVuY3Rpb24ocGFpcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYWlyWzFdICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yMihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFt0b0l0ZXJhdGVlKHBhaXJbMF0pLCBwYWlyWzFdXTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgICB2YXIgcGFpciA9IHBhaXJzW2luZGV4XTtcbiAgICAgICAgICAgICAgaWYgKGFwcGx5KHBhaXJbMF0sIHRoaXMsIGFyZ3MpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFwcGx5KHBhaXJbMV0sIHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY29uZm9ybXMoc291cmNlKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VDb25mb3JtcyhiYXNlQ2xvbmUoc291cmNlLCBDTE9ORV9ERUVQX0ZMQUcpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGRlZmF1bHRUbyh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlID09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlID8gZGVmYXVsdFZhbHVlIDogdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZsb3cgPSBjcmVhdGVGbG93KCk7XG4gICAgICAgIHZhciBmbG93UmlnaHQgPSBjcmVhdGVGbG93KHRydWUpO1xuICAgICAgICBmdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBpdGVyYXRlZShmdW5jKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VJdGVyYXRlZSh0eXBlb2YgZnVuYyA9PSBcImZ1bmN0aW9uXCIgPyBmdW5jIDogYmFzZUNsb25lKGZ1bmMsIENMT05FX0RFRVBfRkxBRykpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1hdGNoZXMoc291cmNlKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VNYXRjaGVzKGJhc2VDbG9uZShzb3VyY2UsIENMT05FX0RFRVBfRkxBRykpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICAgICAgICAgIHJldHVybiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsIGJhc2VDbG9uZShzcmNWYWx1ZSwgQ0xPTkVfREVFUF9GTEFHKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1ldGhvZCA9IGJhc2VSZXN0KGZ1bmN0aW9uKHBhdGgsIGFyZ3MpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gYmFzZUludm9rZShvYmplY3QsIHBhdGgsIGFyZ3MpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbWV0aG9kT2YgPSBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIGFyZ3MpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGJhc2VJbnZva2Uob2JqZWN0LCBwYXRoLCBhcmdzKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgZnVuY3Rpb24gbWl4aW4ob2JqZWN0LCBzb3VyY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgICB2YXIgcHJvcHMgPSBrZXlzKHNvdXJjZSksIG1ldGhvZE5hbWVzID0gYmFzZUZ1bmN0aW9ucyhzb3VyY2UsIHByb3BzKTtcbiAgICAgICAgICBpZiAob3B0aW9ucyA9PSBudWxsICYmICEoaXNPYmplY3Qoc291cmNlKSAmJiAobWV0aG9kTmFtZXMubGVuZ3RoIHx8ICFwcm9wcy5sZW5ndGgpKSkge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHNvdXJjZTtcbiAgICAgICAgICAgIHNvdXJjZSA9IG9iamVjdDtcbiAgICAgICAgICAgIG9iamVjdCA9IHRoaXM7XG4gICAgICAgICAgICBtZXRob2ROYW1lcyA9IGJhc2VGdW5jdGlvbnMoc291cmNlLCBrZXlzKHNvdXJjZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgY2hhaW4yID0gIShpc09iamVjdChvcHRpb25zKSAmJiBcImNoYWluXCIgaW4gb3B0aW9ucykgfHwgISFvcHRpb25zLmNoYWluLCBpc0Z1bmMgPSBpc0Z1bmN0aW9uKG9iamVjdCk7XG4gICAgICAgICAgYXJyYXlFYWNoKG1ldGhvZE5hbWVzLCBmdW5jdGlvbihtZXRob2ROYW1lKSB7XG4gICAgICAgICAgICB2YXIgZnVuYyA9IHNvdXJjZVttZXRob2ROYW1lXTtcbiAgICAgICAgICAgIG9iamVjdFttZXRob2ROYW1lXSA9IGZ1bmM7XG4gICAgICAgICAgICBpZiAoaXNGdW5jKSB7XG4gICAgICAgICAgICAgIG9iamVjdC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hhaW5BbGwgPSB0aGlzLl9fY2hhaW5fXztcbiAgICAgICAgICAgICAgICBpZiAoY2hhaW4yIHx8IGNoYWluQWxsKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0MiA9IG9iamVjdCh0aGlzLl9fd3JhcHBlZF9fKSwgYWN0aW9ucyA9IHJlc3VsdDIuX19hY3Rpb25zX18gPSBjb3B5QXJyYXkodGhpcy5fX2FjdGlvbnNfXyk7XG4gICAgICAgICAgICAgICAgICBhY3Rpb25zLnB1c2goeyBcImZ1bmNcIjogZnVuYywgXCJhcmdzXCI6IGFyZ3VtZW50cywgXCJ0aGlzQXJnXCI6IG9iamVjdCB9KTtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdDIuX19jaGFpbl9fID0gY2hhaW5BbGw7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkob2JqZWN0LCBhcnJheVB1c2goW3RoaXMudmFsdWUoKV0sIGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbm9Db25mbGljdCgpIHtcbiAgICAgICAgICBpZiAocm9vdC5fID09PSB0aGlzKSB7XG4gICAgICAgICAgICByb290Ll8gPSBvbGREYXNoO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBub29wKCkge1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG50aEFyZyhuKSB7XG4gICAgICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgICAgICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIGJhc2VOdGgoYXJncywgbik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG92ZXIgPSBjcmVhdGVPdmVyKGFycmF5TWFwKTtcbiAgICAgICAgdmFyIG92ZXJFdmVyeSA9IGNyZWF0ZU92ZXIoYXJyYXlFdmVyeSk7XG4gICAgICAgIHZhciBvdmVyU29tZSA9IGNyZWF0ZU92ZXIoYXJyYXlTb21lKTtcbiAgICAgICAgZnVuY3Rpb24gcHJvcGVydHkocGF0aCkge1xuICAgICAgICAgIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eSh0b0tleShwYXRoKSkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHByb3BlcnR5T2Yob2JqZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZDIgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmFuZ2UgPSBjcmVhdGVSYW5nZSgpO1xuICAgICAgICB2YXIgcmFuZ2VSaWdodCA9IGNyZWF0ZVJhbmdlKHRydWUpO1xuICAgICAgICBmdW5jdGlvbiBzdHViQXJyYXkoKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc3R1Yk9iamVjdCgpIHtcbiAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gc3R1YlN0cmluZygpIHtcbiAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzdHViVHJ1ZSgpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB0aW1lcyhuLCBpdGVyYXRlZTIpIHtcbiAgICAgICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgICAgIGlmIChuIDwgMSB8fCBuID4gTUFYX1NBRkVfSU5URUdFUikge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaW5kZXggPSBNQVhfQVJSQVlfTEVOR1RILCBsZW5ndGggPSBuYXRpdmVNaW4obiwgTUFYX0FSUkFZX0xFTkdUSCk7XG4gICAgICAgICAgaXRlcmF0ZWUyID0gZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUyKTtcbiAgICAgICAgICBuIC09IE1BWF9BUlJBWV9MRU5HVEg7XG4gICAgICAgICAgdmFyIHJlc3VsdDIgPSBiYXNlVGltZXMobGVuZ3RoLCBpdGVyYXRlZTIpO1xuICAgICAgICAgIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgICAgICAgICAgaXRlcmF0ZWUyKGluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gdG9QYXRoKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXlNYXAodmFsdWUsIHRvS2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGlzU3ltYm9sKHZhbHVlKSA/IFt2YWx1ZV0gOiBjb3B5QXJyYXkoc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHVuaXF1ZUlkKHByZWZpeCkge1xuICAgICAgICAgIHZhciBpZCA9ICsraWRDb3VudGVyO1xuICAgICAgICAgIHJldHVybiB0b1N0cmluZyhwcmVmaXgpICsgaWQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFkZCA9IGNyZWF0ZU1hdGhPcGVyYXRpb24oZnVuY3Rpb24oYXVnZW5kLCBhZGRlbmQpIHtcbiAgICAgICAgICByZXR1cm4gYXVnZW5kICsgYWRkZW5kO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgdmFyIGNlaWwgPSBjcmVhdGVSb3VuZChcImNlaWxcIik7XG4gICAgICAgIHZhciBkaXZpZGUgPSBjcmVhdGVNYXRoT3BlcmF0aW9uKGZ1bmN0aW9uKGRpdmlkZW5kLCBkaXZpc29yKSB7XG4gICAgICAgICAgcmV0dXJuIGRpdmlkZW5kIC8gZGl2aXNvcjtcbiAgICAgICAgfSwgMSk7XG4gICAgICAgIHZhciBmbG9vciA9IGNyZWF0ZVJvdW5kKFwiZmxvb3JcIik7XG4gICAgICAgIGZ1bmN0aW9uIG1heChhcnJheSkge1xuICAgICAgICAgIHJldHVybiBhcnJheSAmJiBhcnJheS5sZW5ndGggPyBiYXNlRXh0cmVtdW0oYXJyYXksIGlkZW50aXR5LCBiYXNlR3QpIDogdW5kZWZpbmVkMjtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtYXhCeShhcnJheSwgaXRlcmF0ZWUyKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5ICYmIGFycmF5Lmxlbmd0aCA/IGJhc2VFeHRyZW11bShhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUyLCAyKSwgYmFzZUd0KSA6IHVuZGVmaW5lZDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWVhbihhcnJheSkge1xuICAgICAgICAgIHJldHVybiBiYXNlTWVhbihhcnJheSwgaWRlbnRpdHkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1lYW5CeShhcnJheSwgaXRlcmF0ZWUyKSB7XG4gICAgICAgICAgcmV0dXJuIGJhc2VNZWFuKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZTIsIDIpKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtaW4oYXJyYXkpIHtcbiAgICAgICAgICByZXR1cm4gYXJyYXkgJiYgYXJyYXkubGVuZ3RoID8gYmFzZUV4dHJlbXVtKGFycmF5LCBpZGVudGl0eSwgYmFzZUx0KSA6IHVuZGVmaW5lZDI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWluQnkoYXJyYXksIGl0ZXJhdGVlMikge1xuICAgICAgICAgIHJldHVybiBhcnJheSAmJiBhcnJheS5sZW5ndGggPyBiYXNlRXh0cmVtdW0oYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlMiwgMiksIGJhc2VMdCkgOiB1bmRlZmluZWQyO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtdWx0aXBseSA9IGNyZWF0ZU1hdGhPcGVyYXRpb24oZnVuY3Rpb24obXVsdGlwbGllciwgbXVsdGlwbGljYW5kKSB7XG4gICAgICAgICAgcmV0dXJuIG11bHRpcGxpZXIgKiBtdWx0aXBsaWNhbmQ7XG4gICAgICAgIH0sIDEpO1xuICAgICAgICB2YXIgcm91bmQgPSBjcmVhdGVSb3VuZChcInJvdW5kXCIpO1xuICAgICAgICB2YXIgc3VidHJhY3QgPSBjcmVhdGVNYXRoT3BlcmF0aW9uKGZ1bmN0aW9uKG1pbnVlbmQsIHN1YnRyYWhlbmQpIHtcbiAgICAgICAgICByZXR1cm4gbWludWVuZCAtIHN1YnRyYWhlbmQ7XG4gICAgICAgIH0sIDApO1xuICAgICAgICBmdW5jdGlvbiBzdW0oYXJyYXkpIHtcbiAgICAgICAgICByZXR1cm4gYXJyYXkgJiYgYXJyYXkubGVuZ3RoID8gYmFzZVN1bShhcnJheSwgaWRlbnRpdHkpIDogMDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzdW1CeShhcnJheSwgaXRlcmF0ZWUyKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5ICYmIGFycmF5Lmxlbmd0aCA/IGJhc2VTdW0oYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlMiwgMikpIDogMDtcbiAgICAgICAgfVxuICAgICAgICBsb2Rhc2guYWZ0ZXIgPSBhZnRlcjtcbiAgICAgICAgbG9kYXNoLmFyeSA9IGFyeTtcbiAgICAgICAgbG9kYXNoLmFzc2lnbiA9IGFzc2lnbjtcbiAgICAgICAgbG9kYXNoLmFzc2lnbkluID0gYXNzaWduSW47XG4gICAgICAgIGxvZGFzaC5hc3NpZ25JbldpdGggPSBhc3NpZ25JbldpdGg7XG4gICAgICAgIGxvZGFzaC5hc3NpZ25XaXRoID0gYXNzaWduV2l0aDtcbiAgICAgICAgbG9kYXNoLmF0ID0gYXQ7XG4gICAgICAgIGxvZGFzaC5iZWZvcmUgPSBiZWZvcmU7XG4gICAgICAgIGxvZGFzaC5iaW5kID0gYmluZDtcbiAgICAgICAgbG9kYXNoLmJpbmRBbGwgPSBiaW5kQWxsO1xuICAgICAgICBsb2Rhc2guYmluZEtleSA9IGJpbmRLZXk7XG4gICAgICAgIGxvZGFzaC5jYXN0QXJyYXkgPSBjYXN0QXJyYXk7XG4gICAgICAgIGxvZGFzaC5jaGFpbiA9IGNoYWluO1xuICAgICAgICBsb2Rhc2guY2h1bmsgPSBjaHVuaztcbiAgICAgICAgbG9kYXNoLmNvbXBhY3QgPSBjb21wYWN0O1xuICAgICAgICBsb2Rhc2guY29uY2F0ID0gY29uY2F0O1xuICAgICAgICBsb2Rhc2guY29uZCA9IGNvbmQ7XG4gICAgICAgIGxvZGFzaC5jb25mb3JtcyA9IGNvbmZvcm1zO1xuICAgICAgICBsb2Rhc2guY29uc3RhbnQgPSBjb25zdGFudDtcbiAgICAgICAgbG9kYXNoLmNvdW50QnkgPSBjb3VudEJ5O1xuICAgICAgICBsb2Rhc2guY3JlYXRlID0gY3JlYXRlO1xuICAgICAgICBsb2Rhc2guY3VycnkgPSBjdXJyeTtcbiAgICAgICAgbG9kYXNoLmN1cnJ5UmlnaHQgPSBjdXJyeVJpZ2h0O1xuICAgICAgICBsb2Rhc2guZGVib3VuY2UgPSBkZWJvdW5jZTtcbiAgICAgICAgbG9kYXNoLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4gICAgICAgIGxvZGFzaC5kZWZhdWx0c0RlZXAgPSBkZWZhdWx0c0RlZXA7XG4gICAgICAgIGxvZGFzaC5kZWZlciA9IGRlZmVyO1xuICAgICAgICBsb2Rhc2guZGVsYXkgPSBkZWxheTtcbiAgICAgICAgbG9kYXNoLmRpZmZlcmVuY2UgPSBkaWZmZXJlbmNlO1xuICAgICAgICBsb2Rhc2guZGlmZmVyZW5jZUJ5ID0gZGlmZmVyZW5jZUJ5O1xuICAgICAgICBsb2Rhc2guZGlmZmVyZW5jZVdpdGggPSBkaWZmZXJlbmNlV2l0aDtcbiAgICAgICAgbG9kYXNoLmRyb3AgPSBkcm9wO1xuICAgICAgICBsb2Rhc2guZHJvcFJpZ2h0ID0gZHJvcFJpZ2h0O1xuICAgICAgICBsb2Rhc2guZHJvcFJpZ2h0V2hpbGUgPSBkcm9wUmlnaHRXaGlsZTtcbiAgICAgICAgbG9kYXNoLmRyb3BXaGlsZSA9IGRyb3BXaGlsZTtcbiAgICAgICAgbG9kYXNoLmZpbGwgPSBmaWxsO1xuICAgICAgICBsb2Rhc2guZmlsdGVyID0gZmlsdGVyO1xuICAgICAgICBsb2Rhc2guZmxhdE1hcCA9IGZsYXRNYXA7XG4gICAgICAgIGxvZGFzaC5mbGF0TWFwRGVlcCA9IGZsYXRNYXBEZWVwO1xuICAgICAgICBsb2Rhc2guZmxhdE1hcERlcHRoID0gZmxhdE1hcERlcHRoO1xuICAgICAgICBsb2Rhc2guZmxhdHRlbiA9IGZsYXR0ZW47XG4gICAgICAgIGxvZGFzaC5mbGF0dGVuRGVlcCA9IGZsYXR0ZW5EZWVwO1xuICAgICAgICBsb2Rhc2guZmxhdHRlbkRlcHRoID0gZmxhdHRlbkRlcHRoO1xuICAgICAgICBsb2Rhc2guZmxpcCA9IGZsaXA7XG4gICAgICAgIGxvZGFzaC5mbG93ID0gZmxvdztcbiAgICAgICAgbG9kYXNoLmZsb3dSaWdodCA9IGZsb3dSaWdodDtcbiAgICAgICAgbG9kYXNoLmZyb21QYWlycyA9IGZyb21QYWlycztcbiAgICAgICAgbG9kYXNoLmZ1bmN0aW9ucyA9IGZ1bmN0aW9ucztcbiAgICAgICAgbG9kYXNoLmZ1bmN0aW9uc0luID0gZnVuY3Rpb25zSW47XG4gICAgICAgIGxvZGFzaC5ncm91cEJ5ID0gZ3JvdXBCeTtcbiAgICAgICAgbG9kYXNoLmluaXRpYWwgPSBpbml0aWFsO1xuICAgICAgICBsb2Rhc2guaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uO1xuICAgICAgICBsb2Rhc2guaW50ZXJzZWN0aW9uQnkgPSBpbnRlcnNlY3Rpb25CeTtcbiAgICAgICAgbG9kYXNoLmludGVyc2VjdGlvbldpdGggPSBpbnRlcnNlY3Rpb25XaXRoO1xuICAgICAgICBsb2Rhc2guaW52ZXJ0ID0gaW52ZXJ0O1xuICAgICAgICBsb2Rhc2guaW52ZXJ0QnkgPSBpbnZlcnRCeTtcbiAgICAgICAgbG9kYXNoLmludm9rZU1hcCA9IGludm9rZU1hcDtcbiAgICAgICAgbG9kYXNoLml0ZXJhdGVlID0gaXRlcmF0ZWU7XG4gICAgICAgIGxvZGFzaC5rZXlCeSA9IGtleUJ5O1xuICAgICAgICBsb2Rhc2gua2V5cyA9IGtleXM7XG4gICAgICAgIGxvZGFzaC5rZXlzSW4gPSBrZXlzSW47XG4gICAgICAgIGxvZGFzaC5tYXAgPSBtYXA7XG4gICAgICAgIGxvZGFzaC5tYXBLZXlzID0gbWFwS2V5cztcbiAgICAgICAgbG9kYXNoLm1hcFZhbHVlcyA9IG1hcFZhbHVlcztcbiAgICAgICAgbG9kYXNoLm1hdGNoZXMgPSBtYXRjaGVzO1xuICAgICAgICBsb2Rhc2gubWF0Y2hlc1Byb3BlcnR5ID0gbWF0Y2hlc1Byb3BlcnR5O1xuICAgICAgICBsb2Rhc2gubWVtb2l6ZSA9IG1lbW9pemUyO1xuICAgICAgICBsb2Rhc2gubWVyZ2UgPSBtZXJnZTtcbiAgICAgICAgbG9kYXNoLm1lcmdlV2l0aCA9IG1lcmdlV2l0aDtcbiAgICAgICAgbG9kYXNoLm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgICAgbG9kYXNoLm1ldGhvZE9mID0gbWV0aG9kT2Y7XG4gICAgICAgIGxvZGFzaC5taXhpbiA9IG1peGluO1xuICAgICAgICBsb2Rhc2gubmVnYXRlID0gbmVnYXRlO1xuICAgICAgICBsb2Rhc2gubnRoQXJnID0gbnRoQXJnO1xuICAgICAgICBsb2Rhc2gub21pdCA9IG9taXQ7XG4gICAgICAgIGxvZGFzaC5vbWl0QnkgPSBvbWl0Qnk7XG4gICAgICAgIGxvZGFzaC5vbmNlID0gb25jZTtcbiAgICAgICAgbG9kYXNoLm9yZGVyQnkgPSBvcmRlckJ5O1xuICAgICAgICBsb2Rhc2gub3ZlciA9IG92ZXI7XG4gICAgICAgIGxvZGFzaC5vdmVyQXJncyA9IG92ZXJBcmdzO1xuICAgICAgICBsb2Rhc2gub3ZlckV2ZXJ5ID0gb3ZlckV2ZXJ5O1xuICAgICAgICBsb2Rhc2gub3ZlclNvbWUgPSBvdmVyU29tZTtcbiAgICAgICAgbG9kYXNoLnBhcnRpYWwgPSBwYXJ0aWFsO1xuICAgICAgICBsb2Rhc2gucGFydGlhbFJpZ2h0ID0gcGFydGlhbFJpZ2h0O1xuICAgICAgICBsb2Rhc2gucGFydGl0aW9uID0gcGFydGl0aW9uO1xuICAgICAgICBsb2Rhc2gucGljayA9IHBpY2s7XG4gICAgICAgIGxvZGFzaC5waWNrQnkgPSBwaWNrQnk7XG4gICAgICAgIGxvZGFzaC5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgICAgICBsb2Rhc2gucHJvcGVydHlPZiA9IHByb3BlcnR5T2Y7XG4gICAgICAgIGxvZGFzaC5wdWxsID0gcHVsbDtcbiAgICAgICAgbG9kYXNoLnB1bGxBbGwgPSBwdWxsQWxsO1xuICAgICAgICBsb2Rhc2gucHVsbEFsbEJ5ID0gcHVsbEFsbEJ5O1xuICAgICAgICBsb2Rhc2gucHVsbEFsbFdpdGggPSBwdWxsQWxsV2l0aDtcbiAgICAgICAgbG9kYXNoLnB1bGxBdCA9IHB1bGxBdDtcbiAgICAgICAgbG9kYXNoLnJhbmdlID0gcmFuZ2U7XG4gICAgICAgIGxvZGFzaC5yYW5nZVJpZ2h0ID0gcmFuZ2VSaWdodDtcbiAgICAgICAgbG9kYXNoLnJlYXJnID0gcmVhcmc7XG4gICAgICAgIGxvZGFzaC5yZWplY3QgPSByZWplY3Q7XG4gICAgICAgIGxvZGFzaC5yZW1vdmUgPSByZW1vdmU7XG4gICAgICAgIGxvZGFzaC5yZXN0ID0gcmVzdDtcbiAgICAgICAgbG9kYXNoLnJldmVyc2UgPSByZXZlcnNlO1xuICAgICAgICBsb2Rhc2guc2FtcGxlU2l6ZSA9IHNhbXBsZVNpemU7XG4gICAgICAgIGxvZGFzaC5zZXQgPSBzZXQ7XG4gICAgICAgIGxvZGFzaC5zZXRXaXRoID0gc2V0V2l0aDtcbiAgICAgICAgbG9kYXNoLnNodWZmbGUgPSBzaHVmZmxlO1xuICAgICAgICBsb2Rhc2guc2xpY2UgPSBzbGljZTtcbiAgICAgICAgbG9kYXNoLnNvcnRCeSA9IHNvcnRCeTtcbiAgICAgICAgbG9kYXNoLnNvcnRlZFVuaXEgPSBzb3J0ZWRVbmlxO1xuICAgICAgICBsb2Rhc2guc29ydGVkVW5pcUJ5ID0gc29ydGVkVW5pcUJ5O1xuICAgICAgICBsb2Rhc2guc3BsaXQgPSBzcGxpdDtcbiAgICAgICAgbG9kYXNoLnNwcmVhZCA9IHNwcmVhZDtcbiAgICAgICAgbG9kYXNoLnRhaWwgPSB0YWlsO1xuICAgICAgICBsb2Rhc2gudGFrZSA9IHRha2U7XG4gICAgICAgIGxvZGFzaC50YWtlUmlnaHQgPSB0YWtlUmlnaHQ7XG4gICAgICAgIGxvZGFzaC50YWtlUmlnaHRXaGlsZSA9IHRha2VSaWdodFdoaWxlO1xuICAgICAgICBsb2Rhc2gudGFrZVdoaWxlID0gdGFrZVdoaWxlO1xuICAgICAgICBsb2Rhc2gudGFwID0gdGFwO1xuICAgICAgICBsb2Rhc2gudGhyb3R0bGUgPSB0aHJvdHRsZTtcbiAgICAgICAgbG9kYXNoLnRocnUgPSB0aHJ1O1xuICAgICAgICBsb2Rhc2gudG9BcnJheSA9IHRvQXJyYXk7XG4gICAgICAgIGxvZGFzaC50b1BhaXJzID0gdG9QYWlycztcbiAgICAgICAgbG9kYXNoLnRvUGFpcnNJbiA9IHRvUGFpcnNJbjtcbiAgICAgICAgbG9kYXNoLnRvUGF0aCA9IHRvUGF0aDtcbiAgICAgICAgbG9kYXNoLnRvUGxhaW5PYmplY3QgPSB0b1BsYWluT2JqZWN0O1xuICAgICAgICBsb2Rhc2gudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgICAgICBsb2Rhc2gudW5hcnkgPSB1bmFyeTtcbiAgICAgICAgbG9kYXNoLnVuaW9uID0gdW5pb247XG4gICAgICAgIGxvZGFzaC51bmlvbkJ5ID0gdW5pb25CeTtcbiAgICAgICAgbG9kYXNoLnVuaW9uV2l0aCA9IHVuaW9uV2l0aDtcbiAgICAgICAgbG9kYXNoLnVuaXEgPSB1bmlxO1xuICAgICAgICBsb2Rhc2gudW5pcUJ5ID0gdW5pcUJ5O1xuICAgICAgICBsb2Rhc2gudW5pcVdpdGggPSB1bmlxV2l0aDtcbiAgICAgICAgbG9kYXNoLnVuc2V0ID0gdW5zZXQ7XG4gICAgICAgIGxvZGFzaC51bnppcCA9IHVuemlwO1xuICAgICAgICBsb2Rhc2gudW56aXBXaXRoID0gdW56aXBXaXRoO1xuICAgICAgICBsb2Rhc2gudXBkYXRlID0gdXBkYXRlO1xuICAgICAgICBsb2Rhc2gudXBkYXRlV2l0aCA9IHVwZGF0ZVdpdGg7XG4gICAgICAgIGxvZGFzaC52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgICAgIGxvZGFzaC52YWx1ZXNJbiA9IHZhbHVlc0luO1xuICAgICAgICBsb2Rhc2gud2l0aG91dCA9IHdpdGhvdXQ7XG4gICAgICAgIGxvZGFzaC53b3JkcyA9IHdvcmRzO1xuICAgICAgICBsb2Rhc2gud3JhcCA9IHdyYXA7XG4gICAgICAgIGxvZGFzaC54b3IgPSB4b3I7XG4gICAgICAgIGxvZGFzaC54b3JCeSA9IHhvckJ5O1xuICAgICAgICBsb2Rhc2gueG9yV2l0aCA9IHhvcldpdGg7XG4gICAgICAgIGxvZGFzaC56aXAgPSB6aXA7XG4gICAgICAgIGxvZGFzaC56aXBPYmplY3QgPSB6aXBPYmplY3Q7XG4gICAgICAgIGxvZGFzaC56aXBPYmplY3REZWVwID0gemlwT2JqZWN0RGVlcDtcbiAgICAgICAgbG9kYXNoLnppcFdpdGggPSB6aXBXaXRoO1xuICAgICAgICBsb2Rhc2guZW50cmllcyA9IHRvUGFpcnM7XG4gICAgICAgIGxvZGFzaC5lbnRyaWVzSW4gPSB0b1BhaXJzSW47XG4gICAgICAgIGxvZGFzaC5leHRlbmQgPSBhc3NpZ25JbjtcbiAgICAgICAgbG9kYXNoLmV4dGVuZFdpdGggPSBhc3NpZ25JbldpdGg7XG4gICAgICAgIG1peGluKGxvZGFzaCwgbG9kYXNoKTtcbiAgICAgICAgbG9kYXNoLmFkZCA9IGFkZDtcbiAgICAgICAgbG9kYXNoLmF0dGVtcHQgPSBhdHRlbXB0O1xuICAgICAgICBsb2Rhc2guY2FtZWxDYXNlID0gY2FtZWxDYXNlO1xuICAgICAgICBsb2Rhc2guY2FwaXRhbGl6ZSA9IGNhcGl0YWxpemU7XG4gICAgICAgIGxvZGFzaC5jZWlsID0gY2VpbDtcbiAgICAgICAgbG9kYXNoLmNsYW1wID0gY2xhbXA7XG4gICAgICAgIGxvZGFzaC5jbG9uZSA9IGNsb25lO1xuICAgICAgICBsb2Rhc2guY2xvbmVEZWVwID0gY2xvbmVEZWVwO1xuICAgICAgICBsb2Rhc2guY2xvbmVEZWVwV2l0aCA9IGNsb25lRGVlcFdpdGg7XG4gICAgICAgIGxvZGFzaC5jbG9uZVdpdGggPSBjbG9uZVdpdGg7XG4gICAgICAgIGxvZGFzaC5jb25mb3Jtc1RvID0gY29uZm9ybXNUbztcbiAgICAgICAgbG9kYXNoLmRlYnVyciA9IGRlYnVycjtcbiAgICAgICAgbG9kYXNoLmRlZmF1bHRUbyA9IGRlZmF1bHRUbztcbiAgICAgICAgbG9kYXNoLmRpdmlkZSA9IGRpdmlkZTtcbiAgICAgICAgbG9kYXNoLmVuZHNXaXRoID0gZW5kc1dpdGg7XG4gICAgICAgIGxvZGFzaC5lcSA9IGVxO1xuICAgICAgICBsb2Rhc2guZXNjYXBlID0gZXNjYXBlO1xuICAgICAgICBsb2Rhc2guZXNjYXBlUmVnRXhwID0gZXNjYXBlUmVnRXhwO1xuICAgICAgICBsb2Rhc2guZXZlcnkgPSBldmVyeTtcbiAgICAgICAgbG9kYXNoLmZpbmQgPSBmaW5kO1xuICAgICAgICBsb2Rhc2guZmluZEluZGV4ID0gZmluZEluZGV4O1xuICAgICAgICBsb2Rhc2guZmluZEtleSA9IGZpbmRLZXk7XG4gICAgICAgIGxvZGFzaC5maW5kTGFzdCA9IGZpbmRMYXN0O1xuICAgICAgICBsb2Rhc2guZmluZExhc3RJbmRleCA9IGZpbmRMYXN0SW5kZXg7XG4gICAgICAgIGxvZGFzaC5maW5kTGFzdEtleSA9IGZpbmRMYXN0S2V5O1xuICAgICAgICBsb2Rhc2guZmxvb3IgPSBmbG9vcjtcbiAgICAgICAgbG9kYXNoLmZvckVhY2ggPSBmb3JFYWNoO1xuICAgICAgICBsb2Rhc2guZm9yRWFjaFJpZ2h0ID0gZm9yRWFjaFJpZ2h0O1xuICAgICAgICBsb2Rhc2guZm9ySW4gPSBmb3JJbjtcbiAgICAgICAgbG9kYXNoLmZvckluUmlnaHQgPSBmb3JJblJpZ2h0O1xuICAgICAgICBsb2Rhc2guZm9yT3duID0gZm9yT3duO1xuICAgICAgICBsb2Rhc2guZm9yT3duUmlnaHQgPSBmb3JPd25SaWdodDtcbiAgICAgICAgbG9kYXNoLmdldCA9IGdldDtcbiAgICAgICAgbG9kYXNoLmd0ID0gZ3Q7XG4gICAgICAgIGxvZGFzaC5ndGUgPSBndGU7XG4gICAgICAgIGxvZGFzaC5oYXMgPSBoYXM7XG4gICAgICAgIGxvZGFzaC5oYXNJbiA9IGhhc0luO1xuICAgICAgICBsb2Rhc2guaGVhZCA9IGhlYWQ7XG4gICAgICAgIGxvZGFzaC5pZGVudGl0eSA9IGlkZW50aXR5O1xuICAgICAgICBsb2Rhc2guaW5jbHVkZXMgPSBpbmNsdWRlcztcbiAgICAgICAgbG9kYXNoLmluZGV4T2YgPSBpbmRleE9mO1xuICAgICAgICBsb2Rhc2guaW5SYW5nZSA9IGluUmFuZ2U7XG4gICAgICAgIGxvZGFzaC5pbnZva2UgPSBpbnZva2U7XG4gICAgICAgIGxvZGFzaC5pc0FyZ3VtZW50cyA9IGlzQXJndW1lbnRzO1xuICAgICAgICBsb2Rhc2guaXNBcnJheSA9IGlzQXJyYXk7XG4gICAgICAgIGxvZGFzaC5pc0FycmF5QnVmZmVyID0gaXNBcnJheUJ1ZmZlcjtcbiAgICAgICAgbG9kYXNoLmlzQXJyYXlMaWtlID0gaXNBcnJheUxpa2U7XG4gICAgICAgIGxvZGFzaC5pc0FycmF5TGlrZU9iamVjdCA9IGlzQXJyYXlMaWtlT2JqZWN0O1xuICAgICAgICBsb2Rhc2guaXNCb29sZWFuID0gaXNCb29sZWFuO1xuICAgICAgICBsb2Rhc2guaXNCdWZmZXIgPSBpc0J1ZmZlcjtcbiAgICAgICAgbG9kYXNoLmlzRGF0ZSA9IGlzRGF0ZTtcbiAgICAgICAgbG9kYXNoLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbiAgICAgICAgbG9kYXNoLmlzRW1wdHkgPSBpc0VtcHR5O1xuICAgICAgICBsb2Rhc2guaXNFcXVhbCA9IGlzRXF1YWw7XG4gICAgICAgIGxvZGFzaC5pc0VxdWFsV2l0aCA9IGlzRXF1YWxXaXRoO1xuICAgICAgICBsb2Rhc2guaXNFcnJvciA9IGlzRXJyb3I7XG4gICAgICAgIGxvZGFzaC5pc0Zpbml0ZSA9IGlzRmluaXRlMjtcbiAgICAgICAgbG9kYXNoLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuICAgICAgICBsb2Rhc2guaXNJbnRlZ2VyID0gaXNJbnRlZ2VyO1xuICAgICAgICBsb2Rhc2guaXNMZW5ndGggPSBpc0xlbmd0aDtcbiAgICAgICAgbG9kYXNoLmlzTWFwID0gaXNNYXA7XG4gICAgICAgIGxvZGFzaC5pc01hdGNoID0gaXNNYXRjaDtcbiAgICAgICAgbG9kYXNoLmlzTWF0Y2hXaXRoID0gaXNNYXRjaFdpdGg7XG4gICAgICAgIGxvZGFzaC5pc05hTiA9IGlzTmFOMjtcbiAgICAgICAgbG9kYXNoLmlzTmF0aXZlID0gaXNOYXRpdmU7XG4gICAgICAgIGxvZGFzaC5pc05pbCA9IGlzTmlsO1xuICAgICAgICBsb2Rhc2guaXNOdWxsID0gaXNOdWxsO1xuICAgICAgICBsb2Rhc2guaXNOdW1iZXIgPSBpc051bWJlcjtcbiAgICAgICAgbG9kYXNoLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG4gICAgICAgIGxvZGFzaC5pc09iamVjdExpa2UgPSBpc09iamVjdExpa2U7XG4gICAgICAgIGxvZGFzaC5pc1BsYWluT2JqZWN0ID0gaXNQbGFpbk9iamVjdDtcbiAgICAgICAgbG9kYXNoLmlzUmVnRXhwID0gaXNSZWdFeHA7XG4gICAgICAgIGxvZGFzaC5pc1NhZmVJbnRlZ2VyID0gaXNTYWZlSW50ZWdlcjtcbiAgICAgICAgbG9kYXNoLmlzU2V0ID0gaXNTZXQ7XG4gICAgICAgIGxvZGFzaC5pc1N0cmluZyA9IGlzU3RyaW5nO1xuICAgICAgICBsb2Rhc2guaXNTeW1ib2wgPSBpc1N5bWJvbDtcbiAgICAgICAgbG9kYXNoLmlzVHlwZWRBcnJheSA9IGlzVHlwZWRBcnJheTtcbiAgICAgICAgbG9kYXNoLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG4gICAgICAgIGxvZGFzaC5pc1dlYWtNYXAgPSBpc1dlYWtNYXA7XG4gICAgICAgIGxvZGFzaC5pc1dlYWtTZXQgPSBpc1dlYWtTZXQ7XG4gICAgICAgIGxvZGFzaC5qb2luID0gam9pbjtcbiAgICAgICAgbG9kYXNoLmtlYmFiQ2FzZSA9IGtlYmFiQ2FzZTtcbiAgICAgICAgbG9kYXNoLmxhc3QgPSBsYXN0O1xuICAgICAgICBsb2Rhc2gubGFzdEluZGV4T2YgPSBsYXN0SW5kZXhPZjtcbiAgICAgICAgbG9kYXNoLmxvd2VyQ2FzZSA9IGxvd2VyQ2FzZTtcbiAgICAgICAgbG9kYXNoLmxvd2VyRmlyc3QgPSBsb3dlckZpcnN0O1xuICAgICAgICBsb2Rhc2gubHQgPSBsdDtcbiAgICAgICAgbG9kYXNoLmx0ZSA9IGx0ZTtcbiAgICAgICAgbG9kYXNoLm1heCA9IG1heDtcbiAgICAgICAgbG9kYXNoLm1heEJ5ID0gbWF4Qnk7XG4gICAgICAgIGxvZGFzaC5tZWFuID0gbWVhbjtcbiAgICAgICAgbG9kYXNoLm1lYW5CeSA9IG1lYW5CeTtcbiAgICAgICAgbG9kYXNoLm1pbiA9IG1pbjtcbiAgICAgICAgbG9kYXNoLm1pbkJ5ID0gbWluQnk7XG4gICAgICAgIGxvZGFzaC5zdHViQXJyYXkgPSBzdHViQXJyYXk7XG4gICAgICAgIGxvZGFzaC5zdHViRmFsc2UgPSBzdHViRmFsc2U7XG4gICAgICAgIGxvZGFzaC5zdHViT2JqZWN0ID0gc3R1Yk9iamVjdDtcbiAgICAgICAgbG9kYXNoLnN0dWJTdHJpbmcgPSBzdHViU3RyaW5nO1xuICAgICAgICBsb2Rhc2guc3R1YlRydWUgPSBzdHViVHJ1ZTtcbiAgICAgICAgbG9kYXNoLm11bHRpcGx5ID0gbXVsdGlwbHk7XG4gICAgICAgIGxvZGFzaC5udGggPSBudGg7XG4gICAgICAgIGxvZGFzaC5ub0NvbmZsaWN0ID0gbm9Db25mbGljdDtcbiAgICAgICAgbG9kYXNoLm5vb3AgPSBub29wO1xuICAgICAgICBsb2Rhc2gubm93ID0gbm93O1xuICAgICAgICBsb2Rhc2gucGFkID0gcGFkO1xuICAgICAgICBsb2Rhc2gucGFkRW5kID0gcGFkRW5kO1xuICAgICAgICBsb2Rhc2gucGFkU3RhcnQgPSBwYWRTdGFydDtcbiAgICAgICAgbG9kYXNoLnBhcnNlSW50ID0gcGFyc2VJbnQyO1xuICAgICAgICBsb2Rhc2gucmFuZG9tID0gcmFuZG9tO1xuICAgICAgICBsb2Rhc2gucmVkdWNlID0gcmVkdWNlO1xuICAgICAgICBsb2Rhc2gucmVkdWNlUmlnaHQgPSByZWR1Y2VSaWdodDtcbiAgICAgICAgbG9kYXNoLnJlcGVhdCA9IHJlcGVhdDtcbiAgICAgICAgbG9kYXNoLnJlcGxhY2UgPSByZXBsYWNlO1xuICAgICAgICBsb2Rhc2gucmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICBsb2Rhc2gucm91bmQgPSByb3VuZDtcbiAgICAgICAgbG9kYXNoLnJ1bkluQ29udGV4dCA9IHJ1bkluQ29udGV4dDI7XG4gICAgICAgIGxvZGFzaC5zYW1wbGUgPSBzYW1wbGU7XG4gICAgICAgIGxvZGFzaC5zaXplID0gc2l6ZTtcbiAgICAgICAgbG9kYXNoLnNuYWtlQ2FzZSA9IHNuYWtlQ2FzZTtcbiAgICAgICAgbG9kYXNoLnNvbWUgPSBzb21lO1xuICAgICAgICBsb2Rhc2guc29ydGVkSW5kZXggPSBzb3J0ZWRJbmRleDtcbiAgICAgICAgbG9kYXNoLnNvcnRlZEluZGV4QnkgPSBzb3J0ZWRJbmRleEJ5O1xuICAgICAgICBsb2Rhc2guc29ydGVkSW5kZXhPZiA9IHNvcnRlZEluZGV4T2Y7XG4gICAgICAgIGxvZGFzaC5zb3J0ZWRMYXN0SW5kZXggPSBzb3J0ZWRMYXN0SW5kZXg7XG4gICAgICAgIGxvZGFzaC5zb3J0ZWRMYXN0SW5kZXhCeSA9IHNvcnRlZExhc3RJbmRleEJ5O1xuICAgICAgICBsb2Rhc2guc29ydGVkTGFzdEluZGV4T2YgPSBzb3J0ZWRMYXN0SW5kZXhPZjtcbiAgICAgICAgbG9kYXNoLnN0YXJ0Q2FzZSA9IHN0YXJ0Q2FzZTtcbiAgICAgICAgbG9kYXNoLnN0YXJ0c1dpdGggPSBzdGFydHNXaXRoO1xuICAgICAgICBsb2Rhc2guc3VidHJhY3QgPSBzdWJ0cmFjdDtcbiAgICAgICAgbG9kYXNoLnN1bSA9IHN1bTtcbiAgICAgICAgbG9kYXNoLnN1bUJ5ID0gc3VtQnk7XG4gICAgICAgIGxvZGFzaC50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgICAgICBsb2Rhc2gudGltZXMgPSB0aW1lcztcbiAgICAgICAgbG9kYXNoLnRvRmluaXRlID0gdG9GaW5pdGU7XG4gICAgICAgIGxvZGFzaC50b0ludGVnZXIgPSB0b0ludGVnZXI7XG4gICAgICAgIGxvZGFzaC50b0xlbmd0aCA9IHRvTGVuZ3RoO1xuICAgICAgICBsb2Rhc2gudG9Mb3dlciA9IHRvTG93ZXI7XG4gICAgICAgIGxvZGFzaC50b051bWJlciA9IHRvTnVtYmVyO1xuICAgICAgICBsb2Rhc2gudG9TYWZlSW50ZWdlciA9IHRvU2FmZUludGVnZXI7XG4gICAgICAgIGxvZGFzaC50b1N0cmluZyA9IHRvU3RyaW5nO1xuICAgICAgICBsb2Rhc2gudG9VcHBlciA9IHRvVXBwZXI7XG4gICAgICAgIGxvZGFzaC50cmltID0gdHJpbTtcbiAgICAgICAgbG9kYXNoLnRyaW1FbmQgPSB0cmltRW5kO1xuICAgICAgICBsb2Rhc2gudHJpbVN0YXJ0ID0gdHJpbVN0YXJ0O1xuICAgICAgICBsb2Rhc2gudHJ1bmNhdGUgPSB0cnVuY2F0ZTtcbiAgICAgICAgbG9kYXNoLnVuZXNjYXBlID0gdW5lc2NhcGU7XG4gICAgICAgIGxvZGFzaC51bmlxdWVJZCA9IHVuaXF1ZUlkO1xuICAgICAgICBsb2Rhc2gudXBwZXJDYXNlID0gdXBwZXJDYXNlO1xuICAgICAgICBsb2Rhc2gudXBwZXJGaXJzdCA9IHVwcGVyRmlyc3Q7XG4gICAgICAgIGxvZGFzaC5lYWNoID0gZm9yRWFjaDtcbiAgICAgICAgbG9kYXNoLmVhY2hSaWdodCA9IGZvckVhY2hSaWdodDtcbiAgICAgICAgbG9kYXNoLmZpcnN0ID0gaGVhZDtcbiAgICAgICAgbWl4aW4obG9kYXNoLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgc291cmNlID0ge307XG4gICAgICAgICAgYmFzZUZvck93bihsb2Rhc2gsIGZ1bmN0aW9uKGZ1bmMsIG1ldGhvZE5hbWUpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChsb2Rhc2gucHJvdG90eXBlLCBtZXRob2ROYW1lKSkge1xuICAgICAgICAgICAgICBzb3VyY2VbbWV0aG9kTmFtZV0gPSBmdW5jO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICAgIH0oKSwgeyBcImNoYWluXCI6IGZhbHNlIH0pO1xuICAgICAgICBsb2Rhc2guVkVSU0lPTiA9IFZFUlNJT047XG4gICAgICAgIGFycmF5RWFjaChbXCJiaW5kXCIsIFwiYmluZEtleVwiLCBcImN1cnJ5XCIsIFwiY3VycnlSaWdodFwiLCBcInBhcnRpYWxcIiwgXCJwYXJ0aWFsUmlnaHRcIl0sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgICBsb2Rhc2hbbWV0aG9kTmFtZV0ucGxhY2Vob2xkZXIgPSBsb2Rhc2g7XG4gICAgICAgIH0pO1xuICAgICAgICBhcnJheUVhY2goW1wiZHJvcFwiLCBcInRha2VcIl0sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24obikge1xuICAgICAgICAgICAgbiA9IG4gPT09IHVuZGVmaW5lZDIgPyAxIDogbmF0aXZlTWF4KHRvSW50ZWdlcihuKSwgMCk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0MiA9IHRoaXMuX19maWx0ZXJlZF9fICYmICFpbmRleCA/IG5ldyBMYXp5V3JhcHBlcih0aGlzKSA6IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQyLl9fZmlsdGVyZWRfXykge1xuICAgICAgICAgICAgICByZXN1bHQyLl9fdGFrZUNvdW50X18gPSBuYXRpdmVNaW4obiwgcmVzdWx0Mi5fX3Rha2VDb3VudF9fKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIuX192aWV3c19fLnB1c2goe1xuICAgICAgICAgICAgICAgIFwic2l6ZVwiOiBuYXRpdmVNaW4obiwgTUFYX0FSUkFZX0xFTkdUSCksXG4gICAgICAgICAgICAgICAgXCJ0eXBlXCI6IG1ldGhvZE5hbWUgKyAocmVzdWx0Mi5fX2Rpcl9fIDwgMCA/IFwiUmlnaHRcIiA6IFwiXCIpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDI7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZSArIFwiUmlnaHRcIl0gPSBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKClbbWV0aG9kTmFtZV0obikucmV2ZXJzZSgpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBhcnJheUVhY2goW1wiZmlsdGVyXCIsIFwibWFwXCIsIFwidGFrZVdoaWxlXCJdLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgICAgIHZhciB0eXBlID0gaW5kZXggKyAxLCBpc0ZpbHRlciA9IHR5cGUgPT0gTEFaWV9GSUxURVJfRkxBRyB8fCB0eXBlID09IExBWllfV0hJTEVfRkxBRztcbiAgICAgICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbihpdGVyYXRlZTIpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQyID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgcmVzdWx0Mi5fX2l0ZXJhdGVlc19fLnB1c2goe1xuICAgICAgICAgICAgICBcIml0ZXJhdGVlXCI6IGdldEl0ZXJhdGVlKGl0ZXJhdGVlMiwgMyksXG4gICAgICAgICAgICAgIFwidHlwZVwiOiB0eXBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlc3VsdDIuX19maWx0ZXJlZF9fID0gcmVzdWx0Mi5fX2ZpbHRlcmVkX18gfHwgaXNGaWx0ZXI7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgYXJyYXlFYWNoKFtcImhlYWRcIiwgXCJsYXN0XCJdLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgICAgIHZhciB0YWtlTmFtZSA9IFwidGFrZVwiICsgKGluZGV4ID8gXCJSaWdodFwiIDogXCJcIik7XG4gICAgICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1t0YWtlTmFtZV0oMSkudmFsdWUoKVswXTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgYXJyYXlFYWNoKFtcImluaXRpYWxcIiwgXCJ0YWlsXCJdLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgICAgIHZhciBkcm9wTmFtZSA9IFwiZHJvcFwiICsgKGluZGV4ID8gXCJcIiA6IFwiUmlnaHRcIik7XG4gICAgICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fX2ZpbHRlcmVkX18gPyBuZXcgTGF6eVdyYXBwZXIodGhpcykgOiB0aGlzW2Ryb3BOYW1lXSgxKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmNvbXBhY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIoaWRlbnRpdHkpO1xuICAgICAgICB9O1xuICAgICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlcihwcmVkaWNhdGUpLmhlYWQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmZpbmRMYXN0ID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpLmZpbmQocHJlZGljYXRlKTtcbiAgICAgICAgfTtcbiAgICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLmludm9rZU1hcCA9IGJhc2VSZXN0KGZ1bmN0aW9uKHBhdGgsIGFyZ3MpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHBhdGggPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExhenlXcmFwcGVyKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBiYXNlSW52b2tlKHZhbHVlLCBwYXRoLCBhcmdzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5yZWplY3QgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIobmVnYXRlKGdldEl0ZXJhdGVlKHByZWRpY2F0ZSkpKTtcbiAgICAgICAgfTtcbiAgICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oc3RhcnQsIGVuZCkge1xuICAgICAgICAgIHN0YXJ0ID0gdG9JbnRlZ2VyKHN0YXJ0KTtcbiAgICAgICAgICB2YXIgcmVzdWx0MiA9IHRoaXM7XG4gICAgICAgICAgaWYgKHJlc3VsdDIuX19maWx0ZXJlZF9fICYmIChzdGFydCA+IDAgfHwgZW5kIDwgMCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGF6eVdyYXBwZXIocmVzdWx0Mik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSByZXN1bHQyLnRha2VSaWdodCgtc3RhcnQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhcnQpIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSByZXN1bHQyLmRyb3Aoc3RhcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZW5kICE9PSB1bmRlZmluZWQyKSB7XG4gICAgICAgICAgICBlbmQgPSB0b0ludGVnZXIoZW5kKTtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBlbmQgPCAwID8gcmVzdWx0Mi5kcm9wUmlnaHQoLWVuZCkgOiByZXN1bHQyLnRha2UoZW5kIC0gc3RhcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgICAgfTtcbiAgICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnRha2VSaWdodFdoaWxlID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpLnRha2VXaGlsZShwcmVkaWNhdGUpLnJldmVyc2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy50YWtlKE1BWF9BUlJBWV9MRU5HVEgpO1xuICAgICAgICB9O1xuICAgICAgICBiYXNlRm9yT3duKExhenlXcmFwcGVyLnByb3RvdHlwZSwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgICAgIHZhciBjaGVja0l0ZXJhdGVlID0gL14oPzpmaWx0ZXJ8ZmluZHxtYXB8cmVqZWN0KXxXaGlsZSQvLnRlc3QobWV0aG9kTmFtZSksIGlzVGFrZXIgPSAvXig/OmhlYWR8bGFzdCkkLy50ZXN0KG1ldGhvZE5hbWUpLCBsb2Rhc2hGdW5jID0gbG9kYXNoW2lzVGFrZXIgPyBcInRha2VcIiArIChtZXRob2ROYW1lID09IFwibGFzdFwiID8gXCJSaWdodFwiIDogXCJcIikgOiBtZXRob2ROYW1lXSwgcmV0VW53cmFwcGVkID0gaXNUYWtlciB8fCAvXmZpbmQvLnRlc3QobWV0aG9kTmFtZSk7XG4gICAgICAgICAgaWYgKCFsb2Rhc2hGdW5jKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX193cmFwcGVkX18sIGFyZ3MgPSBpc1Rha2VyID8gWzFdIDogYXJndW1lbnRzLCBpc0xhenkgPSB2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyLCBpdGVyYXRlZTIgPSBhcmdzWzBdLCB1c2VMYXp5ID0gaXNMYXp5IHx8IGlzQXJyYXkodmFsdWUpO1xuICAgICAgICAgICAgdmFyIGludGVyY2VwdG9yID0gZnVuY3Rpb24odmFsdWUyKSB7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQzID0gbG9kYXNoRnVuYy5hcHBseShsb2Rhc2gsIGFycmF5UHVzaChbdmFsdWUyXSwgYXJncykpO1xuICAgICAgICAgICAgICByZXR1cm4gaXNUYWtlciAmJiBjaGFpbkFsbCA/IHJlc3VsdDNbMF0gOiByZXN1bHQzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh1c2VMYXp5ICYmIGNoZWNrSXRlcmF0ZWUgJiYgdHlwZW9mIGl0ZXJhdGVlMiA9PSBcImZ1bmN0aW9uXCIgJiYgaXRlcmF0ZWUyLmxlbmd0aCAhPSAxKSB7XG4gICAgICAgICAgICAgIGlzTGF6eSA9IHVzZUxhenkgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjaGFpbkFsbCA9IHRoaXMuX19jaGFpbl9fLCBpc0h5YnJpZCA9ICEhdGhpcy5fX2FjdGlvbnNfXy5sZW5ndGgsIGlzVW53cmFwcGVkID0gcmV0VW53cmFwcGVkICYmICFjaGFpbkFsbCwgb25seUxhenkgPSBpc0xhenkgJiYgIWlzSHlicmlkO1xuICAgICAgICAgICAgaWYgKCFyZXRVbndyYXBwZWQgJiYgdXNlTGF6eSkge1xuICAgICAgICAgICAgICB2YWx1ZSA9IG9ubHlMYXp5ID8gdmFsdWUgOiBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICAgICAgICAgIHZhciByZXN1bHQyID0gZnVuYy5hcHBseSh2YWx1ZSwgYXJncyk7XG4gICAgICAgICAgICAgIHJlc3VsdDIuX19hY3Rpb25zX18ucHVzaCh7IFwiZnVuY1wiOiB0aHJ1LCBcImFyZ3NcIjogW2ludGVyY2VwdG9yXSwgXCJ0aGlzQXJnXCI6IHVuZGVmaW5lZDIgfSk7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcihyZXN1bHQyLCBjaGFpbkFsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNVbndyYXBwZWQgJiYgb25seUxhenkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQyID0gdGhpcy50aHJ1KGludGVyY2VwdG9yKTtcbiAgICAgICAgICAgIHJldHVybiBpc1Vud3JhcHBlZCA/IGlzVGFrZXIgPyByZXN1bHQyLnZhbHVlKClbMF0gOiByZXN1bHQyLnZhbHVlKCkgOiByZXN1bHQyO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBhcnJheUVhY2goW1wicG9wXCIsIFwicHVzaFwiLCBcInNoaWZ0XCIsIFwic29ydFwiLCBcInNwbGljZVwiLCBcInVuc2hpZnRcIl0sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgICB2YXIgZnVuYyA9IGFycmF5UHJvdG9bbWV0aG9kTmFtZV0sIGNoYWluTmFtZSA9IC9eKD86cHVzaHxzb3J0fHVuc2hpZnQpJC8udGVzdChtZXRob2ROYW1lKSA/IFwidGFwXCIgOiBcInRocnVcIiwgcmV0VW53cmFwcGVkID0gL14oPzpwb3B8c2hpZnQpJC8udGVzdChtZXRob2ROYW1lKTtcbiAgICAgICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgICAgICAgIGlmIChyZXRVbndyYXBwZWQgJiYgIXRoaXMuX19jaGFpbl9fKSB7XG4gICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWUoKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFtdLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzW2NoYWluTmFtZV0oZnVuY3Rpb24odmFsdWUyKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jLmFwcGx5KGlzQXJyYXkodmFsdWUyKSA/IHZhbHVlMiA6IFtdLCBhcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBiYXNlRm9yT3duKExhenlXcmFwcGVyLnByb3RvdHlwZSwgZnVuY3Rpb24oZnVuYywgbWV0aG9kTmFtZSkge1xuICAgICAgICAgIHZhciBsb2Rhc2hGdW5jID0gbG9kYXNoW21ldGhvZE5hbWVdO1xuICAgICAgICAgIGlmIChsb2Rhc2hGdW5jKSB7XG4gICAgICAgICAgICB2YXIga2V5ID0gbG9kYXNoRnVuYy5uYW1lICsgXCJcIjtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChyZWFsTmFtZXMsIGtleSkpIHtcbiAgICAgICAgICAgICAgcmVhbE5hbWVzW2tleV0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlYWxOYW1lc1trZXldLnB1c2goeyBcIm5hbWVcIjogbWV0aG9kTmFtZSwgXCJmdW5jXCI6IGxvZGFzaEZ1bmMgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmVhbE5hbWVzW2NyZWF0ZUh5YnJpZCh1bmRlZmluZWQyLCBXUkFQX0JJTkRfS0VZX0ZMQUcpLm5hbWVdID0gW3tcbiAgICAgICAgICBcIm5hbWVcIjogXCJ3cmFwcGVyXCIsXG4gICAgICAgICAgXCJmdW5jXCI6IHVuZGVmaW5lZDJcbiAgICAgICAgfV07XG4gICAgICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5jbG9uZSA9IGxhenlDbG9uZTtcbiAgICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnJldmVyc2UgPSBsYXp5UmV2ZXJzZTtcbiAgICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnZhbHVlID0gbGF6eVZhbHVlO1xuICAgICAgICBsb2Rhc2gucHJvdG90eXBlLmF0ID0gd3JhcHBlckF0O1xuICAgICAgICBsb2Rhc2gucHJvdG90eXBlLmNoYWluID0gd3JhcHBlckNoYWluO1xuICAgICAgICBsb2Rhc2gucHJvdG90eXBlLmNvbW1pdCA9IHdyYXBwZXJDb21taXQ7XG4gICAgICAgIGxvZGFzaC5wcm90b3R5cGUubmV4dCA9IHdyYXBwZXJOZXh0O1xuICAgICAgICBsb2Rhc2gucHJvdG90eXBlLnBsYW50ID0gd3JhcHBlclBsYW50O1xuICAgICAgICBsb2Rhc2gucHJvdG90eXBlLnJldmVyc2UgPSB3cmFwcGVyUmV2ZXJzZTtcbiAgICAgICAgbG9kYXNoLnByb3RvdHlwZS50b0pTT04gPSBsb2Rhc2gucHJvdG90eXBlLnZhbHVlT2YgPSBsb2Rhc2gucHJvdG90eXBlLnZhbHVlID0gd3JhcHBlclZhbHVlO1xuICAgICAgICBsb2Rhc2gucHJvdG90eXBlLmZpcnN0ID0gbG9kYXNoLnByb3RvdHlwZS5oZWFkO1xuICAgICAgICBpZiAoc3ltSXRlcmF0b3IpIHtcbiAgICAgICAgICBsb2Rhc2gucHJvdG90eXBlW3N5bUl0ZXJhdG9yXSA9IHdyYXBwZXJUb0l0ZXJhdG9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2Rhc2g7XG4gICAgICB9O1xuICAgICAgdmFyIF8gPSBydW5JbkNvbnRleHQoKTtcbiAgICAgIGlmICh0eXBlb2YgZGVmaW5lID09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZGVmaW5lLmFtZCA9PSBcIm9iamVjdFwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgcm9vdC5fID0gXztcbiAgICAgICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBfO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoZnJlZU1vZHVsZSkge1xuICAgICAgICAoZnJlZU1vZHVsZS5leHBvcnRzID0gXykuXyA9IF87XG4gICAgICAgIGZyZWVFeHBvcnRzLl8gPSBfO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5fID0gXztcbiAgICAgIH1cbiAgICB9KS5jYWxsKGV4cG9ydHMpO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2lvdGEtYXJyYXkvaW90YS5qc1xudmFyIHJlcXVpcmVfaW90YSA9IF9fY29tbW9uSlMoe1xuICBcIi4uLy4uL25vZGVfbW9kdWxlcy9pb3RhLWFycmF5L2lvdGEuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBmdW5jdGlvbiBpb3RhKG4pIHtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkobik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICByZXN1bHRbaV0gPSBpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBpb3RhO1xuICB9XG59KTtcblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qc1xudmFyIHJlcXVpcmVfaXNfYnVmZmVyID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgKGlzQnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikgfHwgISFvYmouX2lzQnVmZmVyKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGlzQnVmZmVyKG9iaikge1xuICAgICAgcmV0dXJuICEhb2JqLmNvbnN0cnVjdG9yICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNTbG93QnVmZmVyKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmoucmVhZEZsb2F0TEUgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygb2JqLnNsaWNlID09PSBcImZ1bmN0aW9uXCIgJiYgaXNCdWZmZXIob2JqLnNsaWNlKDAsIDApKTtcbiAgICB9XG4gIH1cbn0pO1xuXG4vLyAuLi8uLi9ub2RlX21vZHVsZXMvbmRhcnJheS9uZGFycmF5LmpzXG52YXIgcmVxdWlyZV9uZGFycmF5ID0gX19jb21tb25KUyh7XG4gIFwiLi4vLi4vbm9kZV9tb2R1bGVzL25kYXJyYXkvbmRhcnJheS5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIHZhciBpb3RhID0gcmVxdWlyZV9pb3RhKCk7XG4gICAgdmFyIGlzQnVmZmVyID0gcmVxdWlyZV9pc19idWZmZXIoKTtcbiAgICB2YXIgaGFzVHlwZWRBcnJheXMgPSB0eXBlb2YgRmxvYXQ2NEFycmF5ICE9PSBcInVuZGVmaW5lZFwiO1xuICAgIGZ1bmN0aW9uIGNvbXBhcmUxc3QoYSwgYikge1xuICAgICAgcmV0dXJuIGFbMF0gLSBiWzBdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvcmRlcigpIHtcbiAgICAgIHZhciBzdHJpZGUgPSB0aGlzLnN0cmlkZTtcbiAgICAgIHZhciB0ZXJtcyA9IG5ldyBBcnJheShzdHJpZGUubGVuZ3RoKTtcbiAgICAgIHZhciBpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHRlcm1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHRlcm1zW2ldID0gW01hdGguYWJzKHN0cmlkZVtpXSksIGldO1xuICAgICAgfVxuICAgICAgdGVybXMuc29ydChjb21wYXJlMXN0KTtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkodGVybXMubGVuZ3RoKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcmVzdWx0W2ldID0gdGVybXNbaV1bMV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21waWxlQ29uc3RydWN0b3IoZHR5cGUsIGRpbWVuc2lvbikge1xuICAgICAgdmFyIGNsYXNzTmFtZSA9IFtcIlZpZXdcIiwgZGltZW5zaW9uLCBcImRcIiwgZHR5cGVdLmpvaW4oXCJcIik7XG4gICAgICBpZiAoZGltZW5zaW9uIDwgMCkge1xuICAgICAgICBjbGFzc05hbWUgPSBcIlZpZXdfTmlsXCIgKyBkdHlwZTtcbiAgICAgIH1cbiAgICAgIHZhciB1c2VHZXR0ZXJzID0gZHR5cGUgPT09IFwiZ2VuZXJpY1wiO1xuICAgICAgaWYgKGRpbWVuc2lvbiA9PT0gLTEpIHtcbiAgICAgICAgdmFyIGNvZGUgPSBcImZ1bmN0aW9uIFwiICsgY2xhc3NOYW1lICsgXCIoYSl7dGhpcy5kYXRhPWE7fTt2YXIgcHJvdG89XCIgKyBjbGFzc05hbWUgKyBcIi5wcm90b3R5cGU7cHJvdG8uZHR5cGU9J1wiICsgZHR5cGUgKyBcIic7cHJvdG8uaW5kZXg9ZnVuY3Rpb24oKXtyZXR1cm4gLTF9O3Byb3RvLnNpemU9MDtwcm90by5kaW1lbnNpb249LTE7cHJvdG8uc2hhcGU9cHJvdG8uc3RyaWRlPXByb3RvLm9yZGVyPVtdO3Byb3RvLmxvPXByb3RvLmhpPXByb3RvLnRyYW5zcG9zZT1wcm90by5zdGVwPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBcIiArIGNsYXNzTmFtZSArIFwiKHRoaXMuZGF0YSk7fTtwcm90by5nZXQ9cHJvdG8uc2V0PWZ1bmN0aW9uKCl7fTtwcm90by5waWNrPWZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9O3JldHVybiBmdW5jdGlvbiBjb25zdHJ1Y3RfXCIgKyBjbGFzc05hbWUgKyBcIihhKXtyZXR1cm4gbmV3IFwiICsgY2xhc3NOYW1lICsgXCIoYSk7fVwiO1xuICAgICAgICB2YXIgcHJvY2VkdXJlID0gbmV3IEZ1bmN0aW9uKGNvZGUpO1xuICAgICAgICByZXR1cm4gcHJvY2VkdXJlKCk7XG4gICAgICB9IGVsc2UgaWYgKGRpbWVuc2lvbiA9PT0gMCkge1xuICAgICAgICB2YXIgY29kZSA9IFwiZnVuY3Rpb24gXCIgKyBjbGFzc05hbWUgKyBcIihhLGQpIHt0aGlzLmRhdGEgPSBhO3RoaXMub2Zmc2V0ID0gZH07dmFyIHByb3RvPVwiICsgY2xhc3NOYW1lICsgXCIucHJvdG90eXBlO3Byb3RvLmR0eXBlPSdcIiArIGR0eXBlICsgXCInO3Byb3RvLmluZGV4PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub2Zmc2V0fTtwcm90by5kaW1lbnNpb249MDtwcm90by5zaXplPTE7cHJvdG8uc2hhcGU9cHJvdG8uc3RyaWRlPXByb3RvLm9yZGVyPVtdO3Byb3RvLmxvPXByb3RvLmhpPXByb3RvLnRyYW5zcG9zZT1wcm90by5zdGVwPWZ1bmN0aW9uIFwiICsgY2xhc3NOYW1lICsgXCJfY29weSgpIHtyZXR1cm4gbmV3IFwiICsgY2xhc3NOYW1lICsgXCIodGhpcy5kYXRhLHRoaXMub2Zmc2V0KX07cHJvdG8ucGljaz1mdW5jdGlvbiBcIiArIGNsYXNzTmFtZSArIFwiX3BpY2soKXtyZXR1cm4gVHJpdmlhbEFycmF5KHRoaXMuZGF0YSk7fTtwcm90by52YWx1ZU9mPXByb3RvLmdldD1mdW5jdGlvbiBcIiArIGNsYXNzTmFtZSArIFwiX2dldCgpe3JldHVybiBcIiArICh1c2VHZXR0ZXJzID8gXCJ0aGlzLmRhdGEuZ2V0KHRoaXMub2Zmc2V0KVwiIDogXCJ0aGlzLmRhdGFbdGhpcy5vZmZzZXRdXCIpICsgXCJ9O3Byb3RvLnNldD1mdW5jdGlvbiBcIiArIGNsYXNzTmFtZSArIFwiX3NldCh2KXtyZXR1cm4gXCIgKyAodXNlR2V0dGVycyA/IFwidGhpcy5kYXRhLnNldCh0aGlzLm9mZnNldCx2KVwiIDogXCJ0aGlzLmRhdGFbdGhpcy5vZmZzZXRdPXZcIikgKyBcIn07cmV0dXJuIGZ1bmN0aW9uIGNvbnN0cnVjdF9cIiArIGNsYXNzTmFtZSArIFwiKGEsYixjLGQpe3JldHVybiBuZXcgXCIgKyBjbGFzc05hbWUgKyBcIihhLGQpfVwiO1xuICAgICAgICB2YXIgcHJvY2VkdXJlID0gbmV3IEZ1bmN0aW9uKFwiVHJpdmlhbEFycmF5XCIsIGNvZGUpO1xuICAgICAgICByZXR1cm4gcHJvY2VkdXJlKENBQ0hFRF9DT05TVFJVQ1RPUlNbZHR5cGVdWzBdKTtcbiAgICAgIH1cbiAgICAgIHZhciBjb2RlID0gW1wiJ3VzZSBzdHJpY3QnXCJdO1xuICAgICAgdmFyIGluZGljZXMgPSBpb3RhKGRpbWVuc2lvbik7XG4gICAgICB2YXIgYXJncyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgIHJldHVybiBcImlcIiArIGkyO1xuICAgICAgfSk7XG4gICAgICB2YXIgaW5kZXhfc3RyID0gXCJ0aGlzLm9mZnNldCtcIiArIGluZGljZXMubWFwKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgIHJldHVybiBcInRoaXMuc3RyaWRlW1wiICsgaTIgKyBcIl0qaVwiICsgaTI7XG4gICAgICB9KS5qb2luKFwiK1wiKTtcbiAgICAgIHZhciBzaGFwZUFyZyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgIHJldHVybiBcImJcIiArIGkyO1xuICAgICAgfSkuam9pbihcIixcIik7XG4gICAgICB2YXIgc3RyaWRlQXJnID0gaW5kaWNlcy5tYXAoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgcmV0dXJuIFwiY1wiICsgaTI7XG4gICAgICB9KS5qb2luKFwiLFwiKTtcbiAgICAgIGNvZGUucHVzaChcbiAgICAgICAgXCJmdW5jdGlvbiBcIiArIGNsYXNzTmFtZSArIFwiKGEsXCIgKyBzaGFwZUFyZyArIFwiLFwiICsgc3RyaWRlQXJnICsgXCIsZCl7dGhpcy5kYXRhPWFcIixcbiAgICAgICAgXCJ0aGlzLnNoYXBlPVtcIiArIHNoYXBlQXJnICsgXCJdXCIsXG4gICAgICAgIFwidGhpcy5zdHJpZGU9W1wiICsgc3RyaWRlQXJnICsgXCJdXCIsXG4gICAgICAgIFwidGhpcy5vZmZzZXQ9ZHwwfVwiLFxuICAgICAgICBcInZhciBwcm90bz1cIiArIGNsYXNzTmFtZSArIFwiLnByb3RvdHlwZVwiLFxuICAgICAgICBcInByb3RvLmR0eXBlPSdcIiArIGR0eXBlICsgXCInXCIsXG4gICAgICAgIFwicHJvdG8uZGltZW5zaW9uPVwiICsgZGltZW5zaW9uXG4gICAgICApO1xuICAgICAgY29kZS5wdXNoKFxuICAgICAgICBcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywnc2l6ZScse2dldDpmdW5jdGlvbiBcIiArIGNsYXNzTmFtZSArIFwiX3NpemUoKXtyZXR1cm4gXCIgKyBpbmRpY2VzLm1hcChmdW5jdGlvbihpMikge1xuICAgICAgICAgIHJldHVybiBcInRoaXMuc2hhcGVbXCIgKyBpMiArIFwiXVwiO1xuICAgICAgICB9KS5qb2luKFwiKlwiKSxcbiAgICAgICAgXCJ9fSlcIlxuICAgICAgKTtcbiAgICAgIGlmIChkaW1lbnNpb24gPT09IDEpIHtcbiAgICAgICAgY29kZS5wdXNoKFwicHJvdG8ub3JkZXI9WzBdXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29kZS5wdXNoKFwiT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCdvcmRlcicse2dldDpcIik7XG4gICAgICAgIGlmIChkaW1lbnNpb24gPCA0KSB7XG4gICAgICAgICAgY29kZS5wdXNoKFwiZnVuY3Rpb24gXCIgKyBjbGFzc05hbWUgKyBcIl9vcmRlcigpe1wiKTtcbiAgICAgICAgICBpZiAoZGltZW5zaW9uID09PSAyKSB7XG4gICAgICAgICAgICBjb2RlLnB1c2goXCJyZXR1cm4gKE1hdGguYWJzKHRoaXMuc3RyaWRlWzBdKT5NYXRoLmFicyh0aGlzLnN0cmlkZVsxXSkpP1sxLDBdOlswLDFdfX0pXCIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZGltZW5zaW9uID09PSAzKSB7XG4gICAgICAgICAgICBjb2RlLnB1c2goXG4gICAgICAgICAgICAgIFwidmFyIHMwPU1hdGguYWJzKHRoaXMuc3RyaWRlWzBdKSxzMT1NYXRoLmFicyh0aGlzLnN0cmlkZVsxXSksczI9TWF0aC5hYnModGhpcy5zdHJpZGVbMl0pO2lmKHMwPnMxKXtpZihzMT5zMil7cmV0dXJuIFsyLDEsMF07fWVsc2UgaWYoczA+czIpe3JldHVybiBbMSwyLDBdO31lbHNle3JldHVybiBbMSwwLDJdO319ZWxzZSBpZihzMD5zMil7cmV0dXJuIFsyLDAsMV07fWVsc2UgaWYoczI+czEpe3JldHVybiBbMCwxLDJdO31lbHNle3JldHVybiBbMCwyLDFdO319fSlcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29kZS5wdXNoKFwiT1JERVJ9KVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29kZS5wdXNoKFxuICAgICAgICBcInByb3RvLnNldD1mdW5jdGlvbiBcIiArIGNsYXNzTmFtZSArIFwiX3NldChcIiArIGFyZ3Muam9pbihcIixcIikgKyBcIix2KXtcIlxuICAgICAgKTtcbiAgICAgIGlmICh1c2VHZXR0ZXJzKSB7XG4gICAgICAgIGNvZGUucHVzaChcInJldHVybiB0aGlzLmRhdGEuc2V0KFwiICsgaW5kZXhfc3RyICsgXCIsdil9XCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29kZS5wdXNoKFwicmV0dXJuIHRoaXMuZGF0YVtcIiArIGluZGV4X3N0ciArIFwiXT12fVwiKTtcbiAgICAgIH1cbiAgICAgIGNvZGUucHVzaChcInByb3RvLmdldD1mdW5jdGlvbiBcIiArIGNsYXNzTmFtZSArIFwiX2dldChcIiArIGFyZ3Muam9pbihcIixcIikgKyBcIil7XCIpO1xuICAgICAgaWYgKHVzZUdldHRlcnMpIHtcbiAgICAgICAgY29kZS5wdXNoKFwicmV0dXJuIHRoaXMuZGF0YS5nZXQoXCIgKyBpbmRleF9zdHIgKyBcIil9XCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29kZS5wdXNoKFwicmV0dXJuIHRoaXMuZGF0YVtcIiArIGluZGV4X3N0ciArIFwiXX1cIik7XG4gICAgICB9XG4gICAgICBjb2RlLnB1c2goXG4gICAgICAgIFwicHJvdG8uaW5kZXg9ZnVuY3Rpb24gXCIgKyBjbGFzc05hbWUgKyBcIl9pbmRleChcIixcbiAgICAgICAgYXJncy5qb2luKCksXG4gICAgICAgIFwiKXtyZXR1cm4gXCIgKyBpbmRleF9zdHIgKyBcIn1cIlxuICAgICAgKTtcbiAgICAgIGNvZGUucHVzaChcInByb3RvLmhpPWZ1bmN0aW9uIFwiICsgY2xhc3NOYW1lICsgXCJfaGkoXCIgKyBhcmdzLmpvaW4oXCIsXCIpICsgXCIpe3JldHVybiBuZXcgXCIgKyBjbGFzc05hbWUgKyBcIih0aGlzLmRhdGEsXCIgKyBpbmRpY2VzLm1hcChmdW5jdGlvbihpMikge1xuICAgICAgICByZXR1cm4gW1wiKHR5cGVvZiBpXCIsIGkyLCBcIiE9PSdudW1iZXInfHxpXCIsIGkyLCBcIjwwKT90aGlzLnNoYXBlW1wiLCBpMiwgXCJdOmlcIiwgaTIsIFwifDBcIl0uam9pbihcIlwiKTtcbiAgICAgIH0pLmpvaW4oXCIsXCIpICsgXCIsXCIgKyBpbmRpY2VzLm1hcChmdW5jdGlvbihpMikge1xuICAgICAgICByZXR1cm4gXCJ0aGlzLnN0cmlkZVtcIiArIGkyICsgXCJdXCI7XG4gICAgICB9KS5qb2luKFwiLFwiKSArIFwiLHRoaXMub2Zmc2V0KX1cIik7XG4gICAgICB2YXIgYV92YXJzID0gaW5kaWNlcy5tYXAoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgcmV0dXJuIFwiYVwiICsgaTIgKyBcIj10aGlzLnNoYXBlW1wiICsgaTIgKyBcIl1cIjtcbiAgICAgIH0pO1xuICAgICAgdmFyIGNfdmFycyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgIHJldHVybiBcImNcIiArIGkyICsgXCI9dGhpcy5zdHJpZGVbXCIgKyBpMiArIFwiXVwiO1xuICAgICAgfSk7XG4gICAgICBjb2RlLnB1c2goXCJwcm90by5sbz1mdW5jdGlvbiBcIiArIGNsYXNzTmFtZSArIFwiX2xvKFwiICsgYXJncy5qb2luKFwiLFwiKSArIFwiKXt2YXIgYj10aGlzLm9mZnNldCxkPTAsXCIgKyBhX3ZhcnMuam9pbihcIixcIikgKyBcIixcIiArIGNfdmFycy5qb2luKFwiLFwiKSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbWVuc2lvbjsgKytpKSB7XG4gICAgICAgIGNvZGUucHVzaChcbiAgICAgICAgICBcImlmKHR5cGVvZiBpXCIgKyBpICsgXCI9PT0nbnVtYmVyJyYmaVwiICsgaSArIFwiPj0wKXtkPWlcIiArIGkgKyBcInwwO2IrPWNcIiArIGkgKyBcIipkO2FcIiArIGkgKyBcIi09ZH1cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29kZS5wdXNoKFwicmV0dXJuIG5ldyBcIiArIGNsYXNzTmFtZSArIFwiKHRoaXMuZGF0YSxcIiArIGluZGljZXMubWFwKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgIHJldHVybiBcImFcIiArIGkyO1xuICAgICAgfSkuam9pbihcIixcIikgKyBcIixcIiArIGluZGljZXMubWFwKGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgIHJldHVybiBcImNcIiArIGkyO1xuICAgICAgfSkuam9pbihcIixcIikgKyBcIixiKX1cIik7XG4gICAgICBjb2RlLnB1c2goXCJwcm90by5zdGVwPWZ1bmN0aW9uIFwiICsgY2xhc3NOYW1lICsgXCJfc3RlcChcIiArIGFyZ3Muam9pbihcIixcIikgKyBcIil7dmFyIFwiICsgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgcmV0dXJuIFwiYVwiICsgaTIgKyBcIj10aGlzLnNoYXBlW1wiICsgaTIgKyBcIl1cIjtcbiAgICAgIH0pLmpvaW4oXCIsXCIpICsgXCIsXCIgKyBpbmRpY2VzLm1hcChmdW5jdGlvbihpMikge1xuICAgICAgICByZXR1cm4gXCJiXCIgKyBpMiArIFwiPXRoaXMuc3RyaWRlW1wiICsgaTIgKyBcIl1cIjtcbiAgICAgIH0pLmpvaW4oXCIsXCIpICsgXCIsYz10aGlzLm9mZnNldCxkPTAsY2VpbD1NYXRoLmNlaWxcIik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbWVuc2lvbjsgKytpKSB7XG4gICAgICAgIGNvZGUucHVzaChcbiAgICAgICAgICBcImlmKHR5cGVvZiBpXCIgKyBpICsgXCI9PT0nbnVtYmVyJyl7ZD1pXCIgKyBpICsgXCJ8MDtpZihkPDApe2MrPWJcIiArIGkgKyBcIiooYVwiICsgaSArIFwiLTEpO2FcIiArIGkgKyBcIj1jZWlsKC1hXCIgKyBpICsgXCIvZCl9ZWxzZXthXCIgKyBpICsgXCI9Y2VpbChhXCIgKyBpICsgXCIvZCl9YlwiICsgaSArIFwiKj1kfVwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb2RlLnB1c2goXCJyZXR1cm4gbmV3IFwiICsgY2xhc3NOYW1lICsgXCIodGhpcy5kYXRhLFwiICsgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgcmV0dXJuIFwiYVwiICsgaTI7XG4gICAgICB9KS5qb2luKFwiLFwiKSArIFwiLFwiICsgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgcmV0dXJuIFwiYlwiICsgaTI7XG4gICAgICB9KS5qb2luKFwiLFwiKSArIFwiLGMpfVwiKTtcbiAgICAgIHZhciB0U2hhcGUgPSBuZXcgQXJyYXkoZGltZW5zaW9uKTtcbiAgICAgIHZhciB0U3RyaWRlID0gbmV3IEFycmF5KGRpbWVuc2lvbik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpbWVuc2lvbjsgKytpKSB7XG4gICAgICAgIHRTaGFwZVtpXSA9IFwiYVtpXCIgKyBpICsgXCJdXCI7XG4gICAgICAgIHRTdHJpZGVbaV0gPSBcImJbaVwiICsgaSArIFwiXVwiO1xuICAgICAgfVxuICAgICAgY29kZS5wdXNoKFxuICAgICAgICBcInByb3RvLnRyYW5zcG9zZT1mdW5jdGlvbiBcIiArIGNsYXNzTmFtZSArIFwiX3RyYW5zcG9zZShcIiArIGFyZ3MgKyBcIil7XCIgKyBhcmdzLm1hcChmdW5jdGlvbihuLCBpZHgpIHtcbiAgICAgICAgICByZXR1cm4gbiArIFwiPShcIiArIG4gKyBcIj09PXVuZGVmaW5lZD9cIiArIGlkeCArIFwiOlwiICsgbiArIFwifDApXCI7XG4gICAgICAgIH0pLmpvaW4oXCI7XCIpLFxuICAgICAgICBcInZhciBhPXRoaXMuc2hhcGUsYj10aGlzLnN0cmlkZTtyZXR1cm4gbmV3IFwiICsgY2xhc3NOYW1lICsgXCIodGhpcy5kYXRhLFwiICsgdFNoYXBlLmpvaW4oXCIsXCIpICsgXCIsXCIgKyB0U3RyaWRlLmpvaW4oXCIsXCIpICsgXCIsdGhpcy5vZmZzZXQpfVwiXG4gICAgICApO1xuICAgICAgY29kZS5wdXNoKFwicHJvdG8ucGljaz1mdW5jdGlvbiBcIiArIGNsYXNzTmFtZSArIFwiX3BpY2soXCIgKyBhcmdzICsgXCIpe3ZhciBhPVtdLGI9W10sYz10aGlzLm9mZnNldFwiKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGltZW5zaW9uOyArK2kpIHtcbiAgICAgICAgY29kZS5wdXNoKFwiaWYodHlwZW9mIGlcIiArIGkgKyBcIj09PSdudW1iZXInJiZpXCIgKyBpICsgXCI+PTApe2M9KGMrdGhpcy5zdHJpZGVbXCIgKyBpICsgXCJdKmlcIiArIGkgKyBcIil8MH1lbHNle2EucHVzaCh0aGlzLnNoYXBlW1wiICsgaSArIFwiXSk7Yi5wdXNoKHRoaXMuc3RyaWRlW1wiICsgaSArIFwiXSl9XCIpO1xuICAgICAgfVxuICAgICAgY29kZS5wdXNoKFwidmFyIGN0b3I9Q1RPUl9MSVNUW2EubGVuZ3RoKzFdO3JldHVybiBjdG9yKHRoaXMuZGF0YSxhLGIsYyl9XCIpO1xuICAgICAgY29kZS5wdXNoKFwicmV0dXJuIGZ1bmN0aW9uIGNvbnN0cnVjdF9cIiArIGNsYXNzTmFtZSArIFwiKGRhdGEsc2hhcGUsc3RyaWRlLG9mZnNldCl7cmV0dXJuIG5ldyBcIiArIGNsYXNzTmFtZSArIFwiKGRhdGEsXCIgKyBpbmRpY2VzLm1hcChmdW5jdGlvbihpMikge1xuICAgICAgICByZXR1cm4gXCJzaGFwZVtcIiArIGkyICsgXCJdXCI7XG4gICAgICB9KS5qb2luKFwiLFwiKSArIFwiLFwiICsgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaTIpIHtcbiAgICAgICAgcmV0dXJuIFwic3RyaWRlW1wiICsgaTIgKyBcIl1cIjtcbiAgICAgIH0pLmpvaW4oXCIsXCIpICsgXCIsb2Zmc2V0KX1cIik7XG4gICAgICB2YXIgcHJvY2VkdXJlID0gbmV3IEZ1bmN0aW9uKFwiQ1RPUl9MSVNUXCIsIFwiT1JERVJcIiwgY29kZS5qb2luKFwiXFxuXCIpKTtcbiAgICAgIHJldHVybiBwcm9jZWR1cmUoQ0FDSEVEX0NPTlNUUlVDVE9SU1tkdHlwZV0sIG9yZGVyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXJyYXlEVHlwZShkYXRhKSB7XG4gICAgICBpZiAoaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuIFwiYnVmZmVyXCI7XG4gICAgICB9XG4gICAgICBpZiAoaGFzVHlwZWRBcnJheXMpIHtcbiAgICAgICAgc3dpdGNoIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZGF0YSkpIHtcbiAgICAgICAgICBjYXNlIFwiW29iamVjdCBGbG9hdDY0QXJyYXldXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJmbG9hdDY0XCI7XG4gICAgICAgICAgY2FzZSBcIltvYmplY3QgRmxvYXQzMkFycmF5XVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiZmxvYXQzMlwiO1xuICAgICAgICAgIGNhc2UgXCJbb2JqZWN0IEludDhBcnJheV1cIjpcbiAgICAgICAgICAgIHJldHVybiBcImludDhcIjtcbiAgICAgICAgICBjYXNlIFwiW29iamVjdCBJbnQxNkFycmF5XVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiaW50MTZcIjtcbiAgICAgICAgICBjYXNlIFwiW29iamVjdCBJbnQzMkFycmF5XVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiaW50MzJcIjtcbiAgICAgICAgICBjYXNlIFwiW29iamVjdCBVaW50OEFycmF5XVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwidWludDhcIjtcbiAgICAgICAgICBjYXNlIFwiW29iamVjdCBVaW50MTZBcnJheV1cIjpcbiAgICAgICAgICAgIHJldHVybiBcInVpbnQxNlwiO1xuICAgICAgICAgIGNhc2UgXCJbb2JqZWN0IFVpbnQzMkFycmF5XVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwidWludDMyXCI7XG4gICAgICAgICAgY2FzZSBcIltvYmplY3QgVWludDhDbGFtcGVkQXJyYXldXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJ1aW50OF9jbGFtcGVkXCI7XG4gICAgICAgICAgY2FzZSBcIltvYmplY3QgQmlnSW50NjRBcnJheV1cIjpcbiAgICAgICAgICAgIHJldHVybiBcImJpZ2ludDY0XCI7XG4gICAgICAgICAgY2FzZSBcIltvYmplY3QgQmlnVWludDY0QXJyYXldXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJiaWd1aW50NjRcIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuIFwiYXJyYXlcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcImdlbmVyaWNcIjtcbiAgICB9XG4gICAgdmFyIENBQ0hFRF9DT05TVFJVQ1RPUlMgPSB7XG4gICAgICBcImZsb2F0MzJcIjogW10sXG4gICAgICBcImZsb2F0NjRcIjogW10sXG4gICAgICBcImludDhcIjogW10sXG4gICAgICBcImludDE2XCI6IFtdLFxuICAgICAgXCJpbnQzMlwiOiBbXSxcbiAgICAgIFwidWludDhcIjogW10sXG4gICAgICBcInVpbnQxNlwiOiBbXSxcbiAgICAgIFwidWludDMyXCI6IFtdLFxuICAgICAgXCJhcnJheVwiOiBbXSxcbiAgICAgIFwidWludDhfY2xhbXBlZFwiOiBbXSxcbiAgICAgIFwiYmlnaW50NjRcIjogW10sXG4gICAgICBcImJpZ3VpbnQ2NFwiOiBbXSxcbiAgICAgIFwiYnVmZmVyXCI6IFtdLFxuICAgICAgXCJnZW5lcmljXCI6IFtdXG4gICAgfTtcbiAgICBmdW5jdGlvbiB3cmFwcGVkTkRBcnJheUN0b3IoZGF0YSwgc2hhcGUsIHN0cmlkZSwgb2Zmc2V0KSB7XG4gICAgICBpZiAoZGF0YSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHZhciBjdG9yID0gQ0FDSEVEX0NPTlNUUlVDVE9SUy5hcnJheVswXTtcbiAgICAgICAgcmV0dXJuIGN0b3IoW10pO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBkYXRhID0gW2RhdGFdO1xuICAgICAgfVxuICAgICAgaWYgKHNoYXBlID09PSB2b2lkIDApIHtcbiAgICAgICAgc2hhcGUgPSBbZGF0YS5sZW5ndGhdO1xuICAgICAgfVxuICAgICAgdmFyIGQgPSBzaGFwZS5sZW5ndGg7XG4gICAgICBpZiAoc3RyaWRlID09PSB2b2lkIDApIHtcbiAgICAgICAgc3RyaWRlID0gbmV3IEFycmF5KGQpO1xuICAgICAgICBmb3IgKHZhciBpID0gZCAtIDEsIHN6ID0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICBzdHJpZGVbaV0gPSBzejtcbiAgICAgICAgICBzeiAqPSBzaGFwZVtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9mZnNldCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZDsgKytpKSB7XG4gICAgICAgICAgaWYgKHN0cmlkZVtpXSA8IDApIHtcbiAgICAgICAgICAgIG9mZnNldCAtPSAoc2hhcGVbaV0gLSAxKSAqIHN0cmlkZVtpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBkdHlwZSA9IGFycmF5RFR5cGUoZGF0YSk7XG4gICAgICB2YXIgY3Rvcl9saXN0ID0gQ0FDSEVEX0NPTlNUUlVDVE9SU1tkdHlwZV07XG4gICAgICB3aGlsZSAoY3Rvcl9saXN0Lmxlbmd0aCA8PSBkICsgMSkge1xuICAgICAgICBjdG9yX2xpc3QucHVzaChjb21waWxlQ29uc3RydWN0b3IoZHR5cGUsIGN0b3JfbGlzdC5sZW5ndGggLSAxKSk7XG4gICAgICB9XG4gICAgICB2YXIgY3RvciA9IGN0b3JfbGlzdFtkICsgMV07XG4gICAgICByZXR1cm4gY3RvcihkYXRhLCBzaGFwZSwgc3RyaWRlLCBvZmZzZXQpO1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHdyYXBwZWROREFycmF5Q3RvcjtcbiAgfVxufSk7XG5cbi8vIHNyYy9hcGkvdjEudHNcbnZhciBpbXBvcnRfbG9kYXNoID0gX190b0VTTShyZXF1aXJlX2xvZGFzaCgpKTtcblxuLy8gc3JjL3V0aWxzLnRzXG52YXIgaW1wb3J0X25kYXJyYXkyID0gX190b0VTTShyZXF1aXJlX25kYXJyYXkoKSk7XG5cbi8vIHNyYy9NaW1lVHlwZS50c1xudmFyIE1pbWVUeXBlID0gY2xhc3MgX01pbWVUeXBlIHtcbiAgY29uc3RydWN0b3IodHlwZSwgcGFyYW1zKSB7XG4gICAgdGhpcy50eXBlID0gXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIjtcbiAgICB0aGlzLnBhcmFtcyA9IHt9O1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgY29uc3QgcGFyYW1zU3RyID0gW107XG4gICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5wYXJhbXMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5wYXJhbXNba2V5XTtcbiAgICAgIHBhcmFtc1N0ci5wdXNoKGAke2tleX09JHt2YWx1ZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIFt0aGlzLnR5cGUsIC4uLnBhcmFtc1N0cl0uam9pbihcIjtcIik7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZSh0eXBlLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IF9NaW1lVHlwZSh0eXBlLCBwYXJhbXMpO1xuICB9XG4gIGlzSWRlbnRpY2FsKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gb3RoZXIudHlwZSAmJiB0aGlzLnBhcmFtcyA9PT0gb3RoZXIucGFyYW1zO1xuICB9XG4gIGlzRXF1YWwob3RoZXIpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlID09PSBvdGhlci50eXBlO1xuICB9XG4gIHN0YXRpYyBmcm9tU3RyaW5nKG1pbWVUeXBlKSB7XG4gICAgY29uc3QgW3R5cGUsIC4uLnBhcmFtc0Fycl0gPSBtaW1lVHlwZS5zcGxpdChcIjtcIik7XG4gICAgY29uc3QgcGFyYW1zID0ge307XG4gICAgZm9yIChjb25zdCBwYXJhbSBvZiBwYXJhbXNBcnIpIHtcbiAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IHBhcmFtLnNwbGl0KFwiPVwiKTtcbiAgICAgIHBhcmFtc1trZXkudHJpbSgpXSA9IHZhbHVlLnRyaW0oKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfTWltZVR5cGUodHlwZSwgcGFyYW1zKTtcbiAgfVxufTtcblxuLy8gc3JjL2NvZGVjcy50c1xudmFyIGltcG9ydF9uZGFycmF5ID0gX190b0VTTShyZXF1aXJlX25kYXJyYXkoKSk7XG5hc3luYyBmdW5jdGlvbiBpbWFnZURlY29kZShibG9iKSB7XG4gIGNvbnN0IG1pbWUgPSBNaW1lVHlwZS5mcm9tU3RyaW5nKGJsb2IudHlwZSk7XG4gIHN3aXRjaCAobWltZS50eXBlKSB7XG4gICAgY2FzZSBcImltYWdlL3gtYWxwaGE4XCI6IHtcbiAgICAgIGNvbnN0IHdpZHRoID0gcGFyc2VJbnQobWltZS5wYXJhbXNbXCJ3aWR0aFwiXSk7XG4gICAgICBjb25zdCBoZWlnaHQgPSBwYXJzZUludChtaW1lLnBhcmFtc1tcImhlaWdodFwiXSk7XG4gICAgICByZXR1cm4gKDAsIGltcG9ydF9uZGFycmF5LmRlZmF1bHQpKG5ldyBVaW50OEFycmF5KGF3YWl0IGJsb2IuYXJyYXlCdWZmZXIoKSksIFtcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgMVxuICAgICAgXSk7XG4gICAgfVxuICAgIGNhc2UgXCJpbWFnZS94LXJnYmE4XCI6IHtcbiAgICAgIGNvbnN0IHdpZHRoID0gcGFyc2VJbnQobWltZS5wYXJhbXNbXCJ3aWR0aFwiXSk7XG4gICAgICBjb25zdCBoZWlnaHQgPSBwYXJzZUludChtaW1lLnBhcmFtc1tcImhlaWdodFwiXSk7XG4gICAgICByZXR1cm4gKDAsIGltcG9ydF9uZGFycmF5LmRlZmF1bHQpKG5ldyBVaW50OEFycmF5KGF3YWl0IGJsb2IuYXJyYXlCdWZmZXIoKSksIFtcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgNFxuICAgICAgXSk7XG4gICAgfVxuICAgIGNhc2UgXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIjpcbiAgICBjYXNlIGBpbWFnZS9wbmdgOlxuICAgIGNhc2UgYGltYWdlL2pwZWdgOlxuICAgIGNhc2UgYGltYWdlL2pwZ2A6XG4gICAgY2FzZSBgaW1hZ2Uvd2VicGA6IHtcbiAgICAgIGNvbnN0IGltYWdlQml0bWFwID0gYXdhaXQgY3JlYXRlSW1hZ2VCaXRtYXAoYmxvYik7XG4gICAgICBjb25zdCBpbWFnZURhdGEgPSBpbWFnZUJpdG1hcFRvSW1hZ2VEYXRhKGltYWdlQml0bWFwKTtcbiAgICAgIHJldHVybiAoMCwgaW1wb3J0X25kYXJyYXkuZGVmYXVsdCkobmV3IFVpbnQ4QXJyYXkoaW1hZ2VEYXRhLmRhdGEpLCBbXG4gICAgICAgIGltYWdlRGF0YS5oZWlnaHQsXG4gICAgICAgIGltYWdlRGF0YS53aWR0aCxcbiAgICAgICAgNFxuICAgICAgXSk7XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBJbnZhbGlkIGZvcm1hdDogJHttaW1lLnR5cGV9IHdpdGggcGFyYW1zOiAke21pbWUucGFyYW1zfWBcbiAgICAgICk7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGltYWdlRW5jb2RlKGltYWdlVGVuc29yLCBxdWFsaXR5ID0gMC44LCBmb3JtYXQgPSBcImltYWdlL3BuZ1wiKSB7XG4gIGNvbnN0IFtoZWlnaHQsIHdpZHRoLCBjaGFubmVsc10gPSBpbWFnZVRlbnNvci5zaGFwZTtcbiAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICBjYXNlIFwiaW1hZ2UveC1hbHBoYThcIjpcbiAgICBjYXNlIFwiaW1hZ2UveC1yZ2JhOFwiOiB7XG4gICAgICBjb25zdCBtaW1lID0gTWltZVR5cGUuY3JlYXRlKGZvcm1hdCwge1xuICAgICAgICB3aWR0aDogd2lkdGgudG9TdHJpbmcoKSxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQudG9TdHJpbmcoKVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IEJsb2IoW2ltYWdlVGVuc29yLmRhdGFdLCB7IHR5cGU6IG1pbWUudG9TdHJpbmcoKSB9KTtcbiAgICB9XG4gICAgY2FzZSBgaW1hZ2UvcG5nYDpcbiAgICBjYXNlIGBpbWFnZS9qcGVnYDpcbiAgICBjYXNlIGBpbWFnZS93ZWJwYDoge1xuICAgICAgY29uc3QgaW1hZ2VEYXRhID0gbmV3IEltYWdlRGF0YShcbiAgICAgICAgbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGltYWdlVGVuc29yLmRhdGEpLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgaGVpZ2h0XG4gICAgICApO1xuICAgICAgdmFyIGNhbnZhcyA9IGNyZWF0ZUNhbnZhcyhpbWFnZURhdGEud2lkdGgsIGltYWdlRGF0YS5oZWlnaHQpO1xuICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICBjdHgucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG4gICAgICByZXR1cm4gY2FudmFzLmNvbnZlcnRUb0Jsb2IoeyBxdWFsaXR5LCB0eXBlOiBmb3JtYXQgfSk7XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZm9ybWF0OiAke2Zvcm1hdH1gKTtcbiAgfVxufVxuXG4vLyBzcmMvdXJsLnRzXG5mdW5jdGlvbiBpc0Fic29sdXRlVVJJKHVybCkge1xuICBjb25zdCByZWdFeHAgPSBuZXcgUmVnRXhwKFwiXig/OlthLXorXSs6KT8vL1wiLCBcImlcIik7XG4gIHJldHVybiByZWdFeHAudGVzdCh1cmwpO1xufVxuZnVuY3Rpb24gZW5zdXJlQWJzb2x1dGVVUkkodXJsLCBiYXNlVXJsKSB7XG4gIGlmIChpc0Fic29sdXRlVVJJKHVybCkpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgVVJMKHVybCwgYmFzZVVybCkuaHJlZjtcbiAgfVxufVxuXG4vLyBzcmMvdXRpbHMudHNcbmZ1bmN0aW9uIGltYWdlQml0bWFwVG9JbWFnZURhdGEoaW1hZ2VCaXRtYXApIHtcbiAgdmFyIGNhbnZhcyA9IGNyZWF0ZUNhbnZhcyhpbWFnZUJpdG1hcC53aWR0aCwgaW1hZ2VCaXRtYXAuaGVpZ2h0KTtcbiAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gIGN0eC5kcmF3SW1hZ2UoaW1hZ2VCaXRtYXAsIDAsIDApO1xuICByZXR1cm4gY3R4LmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xufVxuZnVuY3Rpb24gY3JlYXRlVHlwZUFycmF5KGxlbmd0aCkge1xuICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGxlbmd0aCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIFVpbnQxNkFycmF5ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50MTZBcnJheShsZW5ndGgpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBVaW50MzJBcnJheSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiBuZXcgVWludDMyQXJyYXkobGVuZ3RoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgRmxvYXQzMkFycmF5ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkobGVuZ3RoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgRmxvYXQ2NEFycmF5ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIG5ldyBGbG9hdDY0QXJyYXkobGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUeXBlZEFycmF5IG5vdCBzdXBwb3J0ZWRcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIHRlbnNvclJlc2l6ZUJpbGluZWFyKGltYWdlVGVuc29yLCBuZXdXaWR0aCwgbmV3SGVpZ2h0LCBwcm9wb3J0aW9uYWwgPSBmYWxzZSkge1xuICBjb25zdCBbc3JjSGVpZ2h0LCBzcmNXaWR0aCwgc3JjQ2hhbm5lbHNdID0gaW1hZ2VUZW5zb3Iuc2hhcGU7XG4gIGxldCBzY2FsZVggPSBzcmNXaWR0aCAvIG5ld1dpZHRoO1xuICBsZXQgc2NhbGVZID0gc3JjSGVpZ2h0IC8gbmV3SGVpZ2h0O1xuICBpZiAocHJvcG9ydGlvbmFsKSB7XG4gICAgY29uc3QgZG93bnNjYWxpbmcgPSBNYXRoLm1heChzY2FsZVgsIHNjYWxlWSkgPiAxO1xuICAgIHNjYWxlWCA9IHNjYWxlWSA9IGRvd25zY2FsaW5nID8gTWF0aC5tYXgoc2NhbGVYLCBzY2FsZVkpIDogTWF0aC5taW4oc2NhbGVYLCBzY2FsZVkpO1xuICB9XG4gIGNvbnN0IHJlc2l6ZWRJbWFnZURhdGEgPSAoMCwgaW1wb3J0X25kYXJyYXkyLmRlZmF1bHQpKFxuICAgIGNyZWF0ZVR5cGVBcnJheShzcmNDaGFubmVscyAqIG5ld1dpZHRoICogbmV3SGVpZ2h0KSxcbiAgICBbbmV3SGVpZ2h0LCBuZXdXaWR0aCwgc3JjQ2hhbm5lbHNdXG4gICk7XG4gIGZvciAobGV0IHkgPSAwOyB5IDwgbmV3SGVpZ2h0OyB5KyspIHtcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IG5ld1dpZHRoOyB4KyspIHtcbiAgICAgIGNvbnN0IHNyY1ggPSB4ICogc2NhbGVYO1xuICAgICAgY29uc3Qgc3JjWSA9IHkgKiBzY2FsZVk7XG4gICAgICBjb25zdCB4MSA9IE1hdGgubWF4KE1hdGguZmxvb3Ioc3JjWCksIDApO1xuICAgICAgY29uc3QgeDIgPSBNYXRoLm1pbihNYXRoLmNlaWwoc3JjWCksIHNyY1dpZHRoIC0gMSk7XG4gICAgICBjb25zdCB5MSA9IE1hdGgubWF4KE1hdGguZmxvb3Ioc3JjWSksIDApO1xuICAgICAgY29uc3QgeTIgPSBNYXRoLm1pbihNYXRoLmNlaWwoc3JjWSksIHNyY0hlaWdodCAtIDEpO1xuICAgICAgY29uc3QgZHggPSBzcmNYIC0geDE7XG4gICAgICBjb25zdCBkeSA9IHNyY1kgLSB5MTtcbiAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgc3JjQ2hhbm5lbHM7IGMrKykge1xuICAgICAgICBjb25zdCBwMSA9IGltYWdlVGVuc29yLmdldCh5MSwgeDEsIGMpO1xuICAgICAgICBjb25zdCBwMiA9IGltYWdlVGVuc29yLmdldCh5MSwgeDIsIGMpO1xuICAgICAgICBjb25zdCBwMyA9IGltYWdlVGVuc29yLmdldCh5MiwgeDEsIGMpO1xuICAgICAgICBjb25zdCBwNCA9IGltYWdlVGVuc29yLmdldCh5MiwgeDIsIGMpO1xuICAgICAgICBjb25zdCBpbnRlcnBvbGF0ZWRWYWx1ZSA9ICgxIC0gZHgpICogKDEgLSBkeSkgKiBwMSArIGR4ICogKDEgLSBkeSkgKiBwMiArICgxIC0gZHgpICogZHkgKiBwMyArIGR4ICogZHkgKiBwNDtcbiAgICAgICAgcmVzaXplZEltYWdlRGF0YS5zZXQoeSwgeCwgYywgaW50ZXJwb2xhdGVkVmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzaXplZEltYWdlRGF0YTtcbn1cbmZ1bmN0aW9uIHRlbnNvckhXQ3RvQkNIVyhpbWFnZVRlbnNvciwgbWVhbiA9IFsxMjgsIDEyOCwgMTI4XSwgc3RkID0gWzI1NiwgMjU2LCAyNTZdKSB7XG4gIHZhciBpbWFnZUJ1ZmZlckRhdGEgPSBpbWFnZVRlbnNvci5kYXRhO1xuICBjb25zdCBbc3JjSGVpZ2h0LCBzcmNXaWR0aCwgc3JjQ2hhbm5lbHNdID0gaW1hZ2VUZW5zb3Iuc2hhcGU7XG4gIGNvbnN0IHN0cmlkZSA9IHNyY0hlaWdodCAqIHNyY1dpZHRoO1xuICBjb25zdCBmbG9hdDMyRGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoMyAqIHN0cmlkZSk7XG4gIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IGltYWdlQnVmZmVyRGF0YS5sZW5ndGg7IGkgKz0gNCwgaiArPSAxKSB7XG4gICAgZmxvYXQzMkRhdGFbal0gPSAoaW1hZ2VCdWZmZXJEYXRhW2ldIC0gbWVhblswXSkgLyBzdGRbMF07XG4gICAgZmxvYXQzMkRhdGFbaiArIHN0cmlkZV0gPSAoaW1hZ2VCdWZmZXJEYXRhW2kgKyAxXSAtIG1lYW5bMV0pIC8gc3RkWzFdO1xuICAgIGZsb2F0MzJEYXRhW2ogKyBzdHJpZGUgKyBzdHJpZGVdID0gKGltYWdlQnVmZmVyRGF0YVtpICsgMl0gLSBtZWFuWzJdKSAvIHN0ZFsyXTtcbiAgfVxuICByZXR1cm4gKDAsIGltcG9ydF9uZGFycmF5Mi5kZWZhdWx0KShmbG9hdDMyRGF0YSwgWzEsIDMsIHNyY0hlaWdodCwgc3JjV2lkdGhdKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGltYWdlU291cmNlVG9JbWFnZURhdGEoaW1hZ2UsIGNvbmZpZykge1xuICBpZiAodHlwZW9mIGltYWdlID09PSBcInN0cmluZ1wiKSB7XG4gICAgaW1hZ2UgPSBlbnN1cmVBYnNvbHV0ZVVSSShpbWFnZSwgY29uZmlnLnB1YmxpY1BhdGgpO1xuICAgIGltYWdlID0gbmV3IFVSTChpbWFnZSk7XG4gIH1cbiAgaWYgKGltYWdlIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChpbWFnZSwge30pO1xuICAgIGltYWdlID0gYXdhaXQgcmVzcG9uc2UuYmxvYigpO1xuICB9XG4gIGlmIChpbWFnZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyhpbWFnZSkpIHtcbiAgICBpbWFnZSA9IG5ldyBCbG9iKFtpbWFnZV0pO1xuICB9XG4gIGlmIChpbWFnZSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICBpbWFnZSA9IGF3YWl0IGltYWdlRGVjb2RlKGltYWdlKTtcbiAgfVxuICByZXR1cm4gaW1hZ2U7XG59XG5mdW5jdGlvbiBjb252ZXJ0RmxvYXQzMlRvVWludDgoZmxvYXQzMkFycmF5KSB7XG4gIGNvbnN0IHVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShmbG9hdDMyQXJyYXkuZGF0YS5sZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGZsb2F0MzJBcnJheS5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgdWludDhBcnJheVtpXSA9IGZsb2F0MzJBcnJheS5kYXRhW2ldICogMjU1O1xuICB9XG4gIHJldHVybiAoMCwgaW1wb3J0X25kYXJyYXkyLmRlZmF1bHQpKHVpbnQ4QXJyYXksIGZsb2F0MzJBcnJheS5zaGFwZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCkge1xuICBsZXQgY2FudmFzID0gdm9pZCAwO1xuICBpZiAodHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGNhbnZhcyA9IG5ldyBPZmZzY3JlZW5DYW52YXMod2lkdGgsIGhlaWdodCk7XG4gIH0gZWxzZSB7XG4gICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgfVxuICBpZiAoIWNhbnZhcykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBDYW52YXMgbm9yIE9mZnNjcmVlbkNhbnZhcyBhcmUgYXZhaWxhYmxlIGluIHRoZSBjdXJyZW50IGNvbnRleHQuYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGNhbnZhcztcbn1cblxuLy8gc3JjL29ubngudHNcbnZhciBpbXBvcnRfbmRhcnJheTMgPSBfX3RvRVNNKHJlcXVpcmVfbmRhcnJheSgpKTtcblxuLy8gc3JjL2NhcGFiaWxpdGllcy5qc1xudmFyIHdlYmdwdSA9IGFzeW5jICgpID0+IHtcbiAgaWYgKG5hdmlnYXRvci5ncHUgPT09IHZvaWQgMClcbiAgICByZXR1cm4gZmFsc2U7XG4gIGNvbnN0IGFkYXB0ZXIgPSBhd2FpdCBuYXZpZ2F0b3IuZ3B1LnJlcXVlc3RBZGFwdGVyKCk7XG4gIHJldHVybiBhZGFwdGVyICE9PSBudWxsO1xufTtcbnZhciBtYXhOdW1UaHJlYWRzID0gKCkgPT4gbmF2aWdhdG9yLmhhcmR3YXJlQ29uY3VycmVuY3kgPz8gNDtcblxuLy8gc3JjL3Jlc291cmNlLnRzXG5hc3luYyBmdW5jdGlvbiBsb2FkQXNVcmwodXJsLCBjb25maWcpIHtcbiAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwoYXdhaXQgbG9hZEFzQmxvYih1cmwsIGNvbmZpZykpO1xufVxuYXN5bmMgZnVuY3Rpb24gbG9hZEFzQmxvYihrZXksIGNvbmZpZykge1xuICBjb25zdCByZXNvdXJjZVVybCA9IG5ldyBVUkwoXCJyZXNvdXJjZXMuanNvblwiLCBjb25maWcucHVibGljUGF0aCk7XG4gIGNvbnN0IHJlc291cmNlUmVzcG9uc2UgPSBhd2FpdCBmZXRjaChyZXNvdXJjZVVybCk7XG4gIGlmICghcmVzb3VyY2VSZXNwb25zZS5vaykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBSZXNvdXJjZSBtZXRhZGF0YSBub3QgZm91bmQuIEVuc3VyZSB0aGF0IHRoZSBjb25maWcucHVibGljUGF0aCBpcyBjb25maWd1cmVkIGNvcnJlY3RseS5gXG4gICAgKTtcbiAgfVxuICBjb25zdCByZXNvdXJjZU1hcCA9IGF3YWl0IHJlc291cmNlUmVzcG9uc2UuanNvbigpO1xuICBjb25zdCBlbnRyeSA9IHJlc291cmNlTWFwW2tleV07XG4gIGlmICghZW50cnkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgUmVzb3VyY2UgJHtrZXl9IG5vdCBmb3VuZC4gRW5zdXJlIHRoYXQgdGhlIGNvbmZpZy5wdWJsaWNQYXRoIGlzIGNvbmZpZ3VyZWQgY29ycmVjdGx5LmBcbiAgICApO1xuICB9XG4gIGNvbnN0IGNodW5rcyA9IGVudHJ5LmNodW5rcztcbiAgbGV0IGRvd25sb2FkZWRTaXplID0gMDtcbiAgY29uc3QgcmVzcG9uc2VzID0gY2h1bmtzLm1hcChhc3luYyAoY2h1bmspID0+IHtcbiAgICBjb25zdCBjaHVua1NpemUgPSBjaHVuay5vZmZzZXRzWzFdIC0gY2h1bmsub2Zmc2V0c1swXTtcbiAgICBjb25zdCB1cmwgPSBjb25maWcucHVibGljUGF0aCA/IG5ldyBVUkwoY2h1bmsubmFtZSwgY29uZmlnLnB1YmxpY1BhdGgpLnRvU3RyaW5nKCkgOiBjaHVuay5uYW1lO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsLCBjb25maWcuZmV0Y2hBcmdzKTtcbiAgICBjb25zdCBibG9iID0gYXdhaXQgcmVzcG9uc2UuYmxvYigpO1xuICAgIGlmIChjaHVua1NpemUgIT09IGJsb2Iuc2l6ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgRmFpbGVkIHRvIGZldGNoICR7a2V5fSB3aXRoIHNpemUgJHtjaHVua1NpemV9IGJ1dCBnb3QgJHtibG9iLnNpemV9YFxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5wcm9ncmVzcykge1xuICAgICAgZG93bmxvYWRlZFNpemUgKz0gY2h1bmtTaXplO1xuICAgICAgY29uZmlnLnByb2dyZXNzKGBmZXRjaDoke2tleX1gLCBkb3dubG9hZGVkU2l6ZSwgZW50cnkuc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiBibG9iO1xuICB9KTtcbiAgY29uc3QgYWxsQ2h1bmtEYXRhID0gYXdhaXQgUHJvbWlzZS5hbGwocmVzcG9uc2VzKTtcbiAgY29uc3QgZGF0YSA9IG5ldyBCbG9iKGFsbENodW5rRGF0YSwgeyB0eXBlOiBlbnRyeS5taW1lIH0pO1xuICBpZiAoZGF0YS5zaXplICE9PSBlbnRyeS5zaXplKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYEZhaWxlZCB0byBmZXRjaCAke2tleX0gd2l0aCBzaXplICR7ZW50cnkuc2l6ZX0gYnV0IGdvdCAke2RhdGEuc2l6ZX1gXG4gICAgKTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxuLy8gc3JjL29ubngudHNcbnZhciBvcnQgPSBudWxsO1xudmFyIGdldE9ydCA9IGFzeW5jICh1c2VXZWJHUFUpID0+IHtcbiAgaWYgKG9ydCAhPT0gbnVsbCkge1xuICAgIHJldHVybiBvcnQ7XG4gIH1cbiAgaWYgKHVzZVdlYkdQVSkge1xuICAgIG9ydCA9IChhd2FpdCBpbXBvcnQoXCJvbm54cnVudGltZS13ZWIvd2ViZ3B1XCIpKS5kZWZhdWx0O1xuICB9IGVsc2Uge1xuICAgIG9ydCA9IChhd2FpdCBpbXBvcnQoXCJvbm54cnVudGltZS13ZWJcIikpLmRlZmF1bHQ7XG4gIH1cbiAgcmV0dXJuIG9ydDtcbn07XG5hc3luYyBmdW5jdGlvbiBjcmVhdGVPbm54U2Vzc2lvbihtb2RlbCwgY29uZmlnKSB7XG4gIGNvbnN0IHVzZVdlYkdQVSA9IGNvbmZpZy5kZXZpY2UgPT09IFwiZ3B1XCIgJiYgYXdhaXQgd2ViZ3B1KCk7XG4gIGNvbnN0IHByb3h5VG9Xb3JrZXIgPSB1c2VXZWJHUFUgJiYgY29uZmlnLnByb3h5VG9Xb3JrZXI7XG4gIGNvbnN0IGV4ZWN1dGlvblByb3ZpZGVycyA9IFt1c2VXZWJHUFUgPyBcIndlYmdwdVwiIDogXCJ3YXNtXCJdO1xuICBjb25zdCBvcnQyID0gYXdhaXQgZ2V0T3J0KHVzZVdlYkdQVSk7XG4gIGlmIChjb25maWcuZGVidWcpIHtcbiAgICBjb25zb2xlLmRlYnVnKFwiXHRVc2luZyBXZWJHUFU6XCIsIHVzZVdlYkdQVSk7XG4gICAgY29uc29sZS5kZWJ1ZyhcIlx0UHJveHkgdG8gV29ya2VyOlwiLCBwcm94eVRvV29ya2VyKTtcbiAgICBvcnQyLmVudi5kZWJ1ZyA9IHRydWU7XG4gICAgb3J0Mi5lbnYubG9nTGV2ZWwgPSBcInZlcmJvc2VcIjtcbiAgfVxuICBvcnQyLmVudi53YXNtLm51bVRocmVhZHMgPSBtYXhOdW1UaHJlYWRzKCk7XG4gIG9ydDIuZW52Lndhc20ucHJveHkgPSBwcm94eVRvV29ya2VyO1xuICBjb25zdCBiYXNlRmlsZVBhdGggPSB1c2VXZWJHUFUgPyBcIi9vbm54cnVudGltZS13ZWIvb3J0LXdhc20tc2ltZC10aHJlYWRlZC5qc2VwXCIgOiBcIi9vbm54cnVudGltZS13ZWIvb3J0LXdhc20tc2ltZC10aHJlYWRlZFwiO1xuICBjb25zdCB3YXNtUGF0aCA9IGF3YWl0IGxvYWRBc1VybChgJHtiYXNlRmlsZVBhdGh9Lndhc21gLCBjb25maWcpO1xuICBjb25zdCBtanNQYXRoID0gYXdhaXQgbG9hZEFzVXJsKGAke2Jhc2VGaWxlUGF0aH0ubWpzYCwgY29uZmlnKTtcbiAgb3J0Mi5lbnYud2FzbS53YXNtUGF0aHMgPSB7XG4gICAgbWpzOiBtanNQYXRoLFxuICAgIHdhc206IHdhc21QYXRoXG4gIH07XG4gIGlmIChjb25maWcuZGVidWcpIHtcbiAgICBjb25zb2xlLmRlYnVnKFwib3J0LmVudi53YXNtOlwiLCBvcnQyLmVudi53YXNtKTtcbiAgfVxuICBjb25zdCBvcnRDb25maWcgPSB7XG4gICAgZXhlY3V0aW9uUHJvdmlkZXJzLFxuICAgIGdyYXBoT3B0aW1pemF0aW9uTGV2ZWw6IFwiYWxsXCIsXG4gICAgZXhlY3V0aW9uTW9kZTogXCJwYXJhbGxlbFwiLFxuICAgIGVuYWJsZUNwdU1lbUFyZW5hOiB0cnVlXG4gIH07XG4gIGNvbnN0IHNlc3Npb24gPSBhd2FpdCBvcnQyLkluZmVyZW5jZVNlc3Npb24uY3JlYXRlKG1vZGVsLCBvcnRDb25maWcpLmNhdGNoKFxuICAgIChlKSA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBGYWlsZWQgdG8gY3JlYXRlIHNlc3Npb246IFwiJHtlfVwiLiBQbGVhc2UgY2hlY2sgaWYgdGhlIHB1YmxpY1BhdGggaXMgc2V0IGNvcnJlY3RseS5gXG4gICAgICApO1xuICAgIH1cbiAgKTtcbiAgcmV0dXJuIHNlc3Npb247XG59XG5hc3luYyBmdW5jdGlvbiBydW5Pbm54U2Vzc2lvbihzZXNzaW9uLCBpbnB1dHMsIG91dHB1dHMsIGNvbmZpZykge1xuICBjb25zdCB1c2VXZWJHUFUgPSBjb25maWcuZGV2aWNlID09PSBcImdwdVwiICYmIGF3YWl0IHdlYmdwdSgpO1xuICBjb25zdCBvcnQyID0gYXdhaXQgZ2V0T3J0KHVzZVdlYkdQVSk7XG4gIGNvbnN0IGZlZWRzID0ge307XG4gIGZvciAoY29uc3QgW2tleSwgdGVuc29yXSBvZiBpbnB1dHMpIHtcbiAgICBmZWVkc1trZXldID0gbmV3IG9ydDIuVGVuc29yKFxuICAgICAgXCJmbG9hdDMyXCIsXG4gICAgICBuZXcgRmxvYXQzMkFycmF5KHRlbnNvci5kYXRhKSxcbiAgICAgIHRlbnNvci5zaGFwZVxuICAgICk7XG4gIH1cbiAgY29uc3Qgb3V0cHV0RGF0YSA9IGF3YWl0IHNlc3Npb24ucnVuKGZlZWRzLCB7fSk7XG4gIGNvbnN0IG91dHB1dEtWUGFpcnMgPSBbXTtcbiAgZm9yIChjb25zdCBrZXkgb2Ygb3V0cHV0cykge1xuICAgIGNvbnN0IG91dHB1dCA9IG91dHB1dERhdGFba2V5XTtcbiAgICBjb25zdCBzaGFwZSA9IG91dHB1dC5kaW1zO1xuICAgIGNvbnN0IGRhdGEgPSBvdXRwdXQuZGF0YTtcbiAgICBjb25zdCB0ZW5zb3IgPSAoMCwgaW1wb3J0X25kYXJyYXkzLmRlZmF1bHQpKGRhdGEsIHNoYXBlKTtcbiAgICBvdXRwdXRLVlBhaXJzLnB1c2godGVuc29yKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0S1ZQYWlycztcbn1cblxuLy8gLi4vLi4vbm9kZV9tb2R1bGVzL3pvZC9saWIvaW5kZXgubWpzXG52YXIgdXRpbDtcbihmdW5jdGlvbih1dGlsMikge1xuICB1dGlsMi5hc3NlcnRFcXVhbCA9ICh2YWwpID0+IHZhbDtcbiAgZnVuY3Rpb24gYXNzZXJ0SXMoX2FyZykge1xuICB9XG4gIHV0aWwyLmFzc2VydElzID0gYXNzZXJ0SXM7XG4gIGZ1bmN0aW9uIGFzc2VydE5ldmVyKF94KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gIH1cbiAgdXRpbDIuYXNzZXJ0TmV2ZXIgPSBhc3NlcnROZXZlcjtcbiAgdXRpbDIuYXJyYXlUb0VudW0gPSAoaXRlbXMpID0+IHtcbiAgICBjb25zdCBvYmogPSB7fTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgIG9ialtpdGVtXSA9IGl0ZW07XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH07XG4gIHV0aWwyLmdldFZhbGlkRW51bVZhbHVlcyA9IChvYmopID0+IHtcbiAgICBjb25zdCB2YWxpZEtleXMgPSB1dGlsMi5vYmplY3RLZXlzKG9iaikuZmlsdGVyKChrKSA9PiB0eXBlb2Ygb2JqW29ialtrXV0gIT09IFwibnVtYmVyXCIpO1xuICAgIGNvbnN0IGZpbHRlcmVkID0ge307XG4gICAgZm9yIChjb25zdCBrIG9mIHZhbGlkS2V5cykge1xuICAgICAgZmlsdGVyZWRba10gPSBvYmpba107XG4gICAgfVxuICAgIHJldHVybiB1dGlsMi5vYmplY3RWYWx1ZXMoZmlsdGVyZWQpO1xuICB9O1xuICB1dGlsMi5vYmplY3RWYWx1ZXMgPSAob2JqKSA9PiB7XG4gICAgcmV0dXJuIHV0aWwyLm9iamVjdEtleXMob2JqKS5tYXAoZnVuY3Rpb24oZSkge1xuICAgICAgcmV0dXJuIG9ialtlXTtcbiAgICB9KTtcbiAgfTtcbiAgdXRpbDIub2JqZWN0S2V5cyA9IHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gXCJmdW5jdGlvblwiID8gKG9iaikgPT4gT2JqZWN0LmtleXMob2JqKSA6IChvYmplY3QpID0+IHtcbiAgICBjb25zdCBrZXlzID0gW107XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtleXM7XG4gIH07XG4gIHV0aWwyLmZpbmQgPSAoYXJyLCBjaGVja2VyKSA9PiB7XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGFycikge1xuICAgICAgaWYgKGNoZWNrZXIoaXRlbSkpXG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9O1xuICB1dGlsMi5pc0ludGVnZXIgPSB0eXBlb2YgTnVtYmVyLmlzSW50ZWdlciA9PT0gXCJmdW5jdGlvblwiID8gKHZhbCkgPT4gTnVtYmVyLmlzSW50ZWdlcih2YWwpIDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiAmJiBpc0Zpbml0ZSh2YWwpICYmIE1hdGguZmxvb3IodmFsKSA9PT0gdmFsO1xuICBmdW5jdGlvbiBqb2luVmFsdWVzKGFycmF5LCBzZXBhcmF0b3IgPSBcIiB8IFwiKSB7XG4gICAgcmV0dXJuIGFycmF5Lm1hcCgodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiID8gYCcke3ZhbH0nYCA6IHZhbCkuam9pbihzZXBhcmF0b3IpO1xuICB9XG4gIHV0aWwyLmpvaW5WYWx1ZXMgPSBqb2luVmFsdWVzO1xuICB1dGlsMi5qc29uU3RyaW5naWZ5UmVwbGFjZXIgPSAoXywgdmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiKSB7XG4gICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufSkodXRpbCB8fCAodXRpbCA9IHt9KSk7XG52YXIgb2JqZWN0VXRpbDtcbihmdW5jdGlvbihvYmplY3RVdGlsMikge1xuICBvYmplY3RVdGlsMi5tZXJnZVNoYXBlcyA9IChmaXJzdCwgc2Vjb25kKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmZpcnN0LFxuICAgICAgLi4uc2Vjb25kXG4gICAgICAvLyBzZWNvbmQgb3ZlcndyaXRlcyBmaXJzdFxuICAgIH07XG4gIH07XG59KShvYmplY3RVdGlsIHx8IChvYmplY3RVdGlsID0ge30pKTtcbnZhciBab2RQYXJzZWRUeXBlID0gdXRpbC5hcnJheVRvRW51bShbXG4gIFwic3RyaW5nXCIsXG4gIFwibmFuXCIsXG4gIFwibnVtYmVyXCIsXG4gIFwiaW50ZWdlclwiLFxuICBcImZsb2F0XCIsXG4gIFwiYm9vbGVhblwiLFxuICBcImRhdGVcIixcbiAgXCJiaWdpbnRcIixcbiAgXCJzeW1ib2xcIixcbiAgXCJmdW5jdGlvblwiLFxuICBcInVuZGVmaW5lZFwiLFxuICBcIm51bGxcIixcbiAgXCJhcnJheVwiLFxuICBcIm9iamVjdFwiLFxuICBcInVua25vd25cIixcbiAgXCJwcm9taXNlXCIsXG4gIFwidm9pZFwiLFxuICBcIm5ldmVyXCIsXG4gIFwibWFwXCIsXG4gIFwic2V0XCJcbl0pO1xudmFyIGdldFBhcnNlZFR5cGUgPSAoZGF0YSkgPT4ge1xuICBjb25zdCB0ID0gdHlwZW9mIGRhdGE7XG4gIHN3aXRjaCAodCkge1xuICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZDtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5zdHJpbmc7XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgcmV0dXJuIGlzTmFOKGRhdGEpID8gWm9kUGFyc2VkVHlwZS5uYW4gOiBab2RQYXJzZWRUeXBlLm51bWJlcjtcbiAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuYm9vbGVhbjtcbiAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmZ1bmN0aW9uO1xuICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmJpZ2ludDtcbiAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5zeW1ib2w7XG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuYXJyYXk7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5udWxsO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEudGhlbiAmJiB0eXBlb2YgZGF0YS50aGVuID09PSBcImZ1bmN0aW9uXCIgJiYgZGF0YS5jYXRjaCAmJiB0eXBlb2YgZGF0YS5jYXRjaCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnByb21pc2U7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIE1hcCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkYXRhIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLm1hcDtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgU2V0ICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuc2V0O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBEYXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmRhdGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5vYmplY3Q7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnVua25vd247XG4gIH1cbn07XG52YXIgWm9kSXNzdWVDb2RlID0gdXRpbC5hcnJheVRvRW51bShbXG4gIFwiaW52YWxpZF90eXBlXCIsXG4gIFwiaW52YWxpZF9saXRlcmFsXCIsXG4gIFwiY3VzdG9tXCIsXG4gIFwiaW52YWxpZF91bmlvblwiLFxuICBcImludmFsaWRfdW5pb25fZGlzY3JpbWluYXRvclwiLFxuICBcImludmFsaWRfZW51bV92YWx1ZVwiLFxuICBcInVucmVjb2duaXplZF9rZXlzXCIsXG4gIFwiaW52YWxpZF9hcmd1bWVudHNcIixcbiAgXCJpbnZhbGlkX3JldHVybl90eXBlXCIsXG4gIFwiaW52YWxpZF9kYXRlXCIsXG4gIFwiaW52YWxpZF9zdHJpbmdcIixcbiAgXCJ0b29fc21hbGxcIixcbiAgXCJ0b29fYmlnXCIsXG4gIFwiaW52YWxpZF9pbnRlcnNlY3Rpb25fdHlwZXNcIixcbiAgXCJub3RfbXVsdGlwbGVfb2ZcIixcbiAgXCJub3RfZmluaXRlXCJcbl0pO1xudmFyIHF1b3RlbGVzc0pzb24gPSAob2JqKSA9PiB7XG4gIGNvbnN0IGpzb24gPSBKU09OLnN0cmluZ2lmeShvYmosIG51bGwsIDIpO1xuICByZXR1cm4ganNvbi5yZXBsYWNlKC9cIihbXlwiXSspXCI6L2csIFwiJDE6XCIpO1xufTtcbnZhciBab2RFcnJvciA9IGNsYXNzIF9ab2RFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoaXNzdWVzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmlzc3VlcyA9IFtdO1xuICAgIHRoaXMuYWRkSXNzdWUgPSAoc3ViKSA9PiB7XG4gICAgICB0aGlzLmlzc3VlcyA9IFsuLi50aGlzLmlzc3Vlcywgc3ViXTtcbiAgICB9O1xuICAgIHRoaXMuYWRkSXNzdWVzID0gKHN1YnMgPSBbXSkgPT4ge1xuICAgICAgdGhpcy5pc3N1ZXMgPSBbLi4udGhpcy5pc3N1ZXMsIC4uLnN1YnNdO1xuICAgIH07XG4gICAgY29uc3QgYWN0dWFsUHJvdG8gPSBuZXcudGFyZ2V0LnByb3RvdHlwZTtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgYWN0dWFsUHJvdG8pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9fcHJvdG9fXyA9IGFjdHVhbFByb3RvO1xuICAgIH1cbiAgICB0aGlzLm5hbWUgPSBcIlpvZEVycm9yXCI7XG4gICAgdGhpcy5pc3N1ZXMgPSBpc3N1ZXM7XG4gIH1cbiAgZ2V0IGVycm9ycygpIHtcbiAgICByZXR1cm4gdGhpcy5pc3N1ZXM7XG4gIH1cbiAgZm9ybWF0KF9tYXBwZXIpIHtcbiAgICBjb25zdCBtYXBwZXIgPSBfbWFwcGVyIHx8IGZ1bmN0aW9uKGlzc3VlKSB7XG4gICAgICByZXR1cm4gaXNzdWUubWVzc2FnZTtcbiAgICB9O1xuICAgIGNvbnN0IGZpZWxkRXJyb3JzID0geyBfZXJyb3JzOiBbXSB9O1xuICAgIGNvbnN0IHByb2Nlc3NFcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBlcnJvci5pc3N1ZXMpIHtcbiAgICAgICAgaWYgKGlzc3VlLmNvZGUgPT09IFwiaW52YWxpZF91bmlvblwiKSB7XG4gICAgICAgICAgaXNzdWUudW5pb25FcnJvcnMubWFwKHByb2Nlc3NFcnJvcik7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNzdWUuY29kZSA9PT0gXCJpbnZhbGlkX3JldHVybl90eXBlXCIpIHtcbiAgICAgICAgICBwcm9jZXNzRXJyb3IoaXNzdWUucmV0dXJuVHlwZUVycm9yKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc3N1ZS5jb2RlID09PSBcImludmFsaWRfYXJndW1lbnRzXCIpIHtcbiAgICAgICAgICBwcm9jZXNzRXJyb3IoaXNzdWUuYXJndW1lbnRzRXJyb3IpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzc3VlLnBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgZmllbGRFcnJvcnMuX2Vycm9ycy5wdXNoKG1hcHBlcihpc3N1ZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBjdXJyID0gZmllbGRFcnJvcnM7XG4gICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgIHdoaWxlIChpIDwgaXNzdWUucGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsID0gaXNzdWUucGF0aFtpXTtcbiAgICAgICAgICAgIGNvbnN0IHRlcm1pbmFsID0gaSA9PT0gaXNzdWUucGF0aC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgaWYgKCF0ZXJtaW5hbCkge1xuICAgICAgICAgICAgICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IHsgX2Vycm9yczogW10gfTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGN1cnJbZWxdID0gY3VycltlbF0gfHwgeyBfZXJyb3JzOiBbXSB9O1xuICAgICAgICAgICAgICBjdXJyW2VsXS5fZXJyb3JzLnB1c2gobWFwcGVyKGlzc3VlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyID0gY3VycltlbF07XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICBwcm9jZXNzRXJyb3IodGhpcyk7XG4gICAgcmV0dXJuIGZpZWxkRXJyb3JzO1xuICB9XG4gIHN0YXRpYyBhc3NlcnQodmFsdWUpIHtcbiAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIF9ab2RFcnJvcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm90IGEgWm9kRXJyb3I6ICR7dmFsdWV9YCk7XG4gICAgfVxuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XG4gIH1cbiAgZ2V0IG1lc3NhZ2UoKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuaXNzdWVzLCB1dGlsLmpzb25TdHJpbmdpZnlSZXBsYWNlciwgMik7XG4gIH1cbiAgZ2V0IGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNzdWVzLmxlbmd0aCA9PT0gMDtcbiAgfVxuICBmbGF0dGVuKG1hcHBlciA9IChpc3N1ZSkgPT4gaXNzdWUubWVzc2FnZSkge1xuICAgIGNvbnN0IGZpZWxkRXJyb3JzID0ge307XG4gICAgY29uc3QgZm9ybUVycm9ycyA9IFtdO1xuICAgIGZvciAoY29uc3Qgc3ViIG9mIHRoaXMuaXNzdWVzKSB7XG4gICAgICBpZiAoc3ViLnBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICBmaWVsZEVycm9yc1tzdWIucGF0aFswXV0gPSBmaWVsZEVycm9yc1tzdWIucGF0aFswXV0gfHwgW107XG4gICAgICAgIGZpZWxkRXJyb3JzW3N1Yi5wYXRoWzBdXS5wdXNoKG1hcHBlcihzdWIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcm1FcnJvcnMucHVzaChtYXBwZXIoc3ViKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGZvcm1FcnJvcnMsIGZpZWxkRXJyb3JzIH07XG4gIH1cbiAgZ2V0IGZvcm1FcnJvcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmxhdHRlbigpO1xuICB9XG59O1xuWm9kRXJyb3IuY3JlYXRlID0gKGlzc3VlcykgPT4ge1xuICBjb25zdCBlcnJvciA9IG5ldyBab2RFcnJvcihpc3N1ZXMpO1xuICByZXR1cm4gZXJyb3I7XG59O1xudmFyIGVycm9yTWFwID0gKGlzc3VlLCBfY3R4KSA9PiB7XG4gIGxldCBtZXNzYWdlO1xuICBzd2l0Y2ggKGlzc3VlLmNvZGUpIHtcbiAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGU6XG4gICAgICBpZiAoaXNzdWUucmVjZWl2ZWQgPT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBcIlJlcXVpcmVkXCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXNzYWdlID0gYEV4cGVjdGVkICR7aXNzdWUuZXhwZWN0ZWR9LCByZWNlaXZlZCAke2lzc3VlLnJlY2VpdmVkfWA7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2xpdGVyYWw6XG4gICAgICBtZXNzYWdlID0gYEludmFsaWQgbGl0ZXJhbCB2YWx1ZSwgZXhwZWN0ZWQgJHtKU09OLnN0cmluZ2lmeShpc3N1ZS5leHBlY3RlZCwgdXRpbC5qc29uU3RyaW5naWZ5UmVwbGFjZXIpfWA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFpvZElzc3VlQ29kZS51bnJlY29nbml6ZWRfa2V5czpcbiAgICAgIG1lc3NhZ2UgPSBgVW5yZWNvZ25pemVkIGtleShzKSBpbiBvYmplY3Q6ICR7dXRpbC5qb2luVmFsdWVzKGlzc3VlLmtleXMsIFwiLCBcIil9YDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb246XG4gICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXRgO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbl9kaXNjcmltaW5hdG9yOlxuICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGRpc2NyaW1pbmF0b3IgdmFsdWUuIEV4cGVjdGVkICR7dXRpbC5qb2luVmFsdWVzKGlzc3VlLm9wdGlvbnMpfWA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2VudW1fdmFsdWU6XG4gICAgICBtZXNzYWdlID0gYEludmFsaWQgZW51bSB2YWx1ZS4gRXhwZWN0ZWQgJHt1dGlsLmpvaW5WYWx1ZXMoaXNzdWUub3B0aW9ucyl9LCByZWNlaXZlZCAnJHtpc3N1ZS5yZWNlaXZlZH0nYDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfYXJndW1lbnRzOlxuICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGZ1bmN0aW9uIGFyZ3VtZW50c2A7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3JldHVybl90eXBlOlxuICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGZ1bmN0aW9uIHJldHVybiB0eXBlYDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfZGF0ZTpcbiAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBkYXRlYDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nOlxuICAgICAgaWYgKHR5cGVvZiBpc3N1ZS52YWxpZGF0aW9uID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmIChcImluY2x1ZGVzXCIgaW4gaXNzdWUudmFsaWRhdGlvbikge1xuICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dDogbXVzdCBpbmNsdWRlIFwiJHtpc3N1ZS52YWxpZGF0aW9uLmluY2x1ZGVzfVwiYDtcbiAgICAgICAgICBpZiAodHlwZW9mIGlzc3VlLnZhbGlkYXRpb24ucG9zaXRpb24gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgJHttZXNzYWdlfSBhdCBvbmUgb3IgbW9yZSBwb3NpdGlvbnMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICR7aXNzdWUudmFsaWRhdGlvbi5wb3NpdGlvbn1gO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChcInN0YXJ0c1dpdGhcIiBpbiBpc3N1ZS52YWxpZGF0aW9uKSB7XG4gICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0OiBtdXN0IHN0YXJ0IHdpdGggXCIke2lzc3VlLnZhbGlkYXRpb24uc3RhcnRzV2l0aH1cImA7XG4gICAgICAgIH0gZWxzZSBpZiAoXCJlbmRzV2l0aFwiIGluIGlzc3VlLnZhbGlkYXRpb24pIHtcbiAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXQ6IG11c3QgZW5kIHdpdGggXCIke2lzc3VlLnZhbGlkYXRpb24uZW5kc1dpdGh9XCJgO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoaXNzdWUudmFsaWRhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNzdWUudmFsaWRhdGlvbiAhPT0gXCJyZWdleFwiKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCAke2lzc3VlLnZhbGlkYXRpb259YDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lc3NhZ2UgPSBcIkludmFsaWRcIjtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWm9kSXNzdWVDb2RlLnRvb19zbWFsbDpcbiAgICAgIGlmIChpc3N1ZS50eXBlID09PSBcImFycmF5XCIpXG4gICAgICAgIG1lc3NhZ2UgPSBgQXJyYXkgbXVzdCBjb250YWluICR7aXNzdWUuZXhhY3QgPyBcImV4YWN0bHlcIiA6IGlzc3VlLmluY2x1c2l2ZSA/IGBhdCBsZWFzdGAgOiBgbW9yZSB0aGFuYH0gJHtpc3N1ZS5taW5pbXVtfSBlbGVtZW50KHMpYDtcbiAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwic3RyaW5nXCIpXG4gICAgICAgIG1lc3NhZ2UgPSBgU3RyaW5nIG11c3QgY29udGFpbiAke2lzc3VlLmV4YWN0ID8gXCJleGFjdGx5XCIgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbGVhc3RgIDogYG92ZXJgfSAke2lzc3VlLm1pbmltdW19IGNoYXJhY3RlcihzKWA7XG4gICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcIm51bWJlclwiKVxuICAgICAgICBtZXNzYWdlID0gYE51bWJlciBtdXN0IGJlICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseSBlcXVhbCB0byBgIDogaXNzdWUuaW5jbHVzaXZlID8gYGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgIDogYGdyZWF0ZXIgdGhhbiBgfSR7aXNzdWUubWluaW11bX1gO1xuICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJkYXRlXCIpXG4gICAgICAgIG1lc3NhZ2UgPSBgRGF0ZSBtdXN0IGJlICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseSBlcXVhbCB0byBgIDogaXNzdWUuaW5jbHVzaXZlID8gYGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgIDogYGdyZWF0ZXIgdGhhbiBgfSR7bmV3IERhdGUoTnVtYmVyKGlzc3VlLm1pbmltdW0pKX1gO1xuICAgICAgZWxzZVxuICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkIGlucHV0XCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFpvZElzc3VlQ29kZS50b29fYmlnOlxuICAgICAgaWYgKGlzc3VlLnR5cGUgPT09IFwiYXJyYXlcIilcbiAgICAgICAgbWVzc2FnZSA9IGBBcnJheSBtdXN0IGNvbnRhaW4gJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5YCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBhdCBtb3N0YCA6IGBsZXNzIHRoYW5gfSAke2lzc3VlLm1heGltdW19IGVsZW1lbnQocylgO1xuICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgbWVzc2FnZSA9IGBTdHJpbmcgbXVzdCBjb250YWluICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseWAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbW9zdGAgOiBgdW5kZXJgfSAke2lzc3VlLm1heGltdW19IGNoYXJhY3RlcihzKWA7XG4gICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcIm51bWJlclwiKVxuICAgICAgICBtZXNzYWdlID0gYE51bWJlciBtdXN0IGJlICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseWAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgbGVzcyB0aGFuIG9yIGVxdWFsIHRvYCA6IGBsZXNzIHRoYW5gfSAke2lzc3VlLm1heGltdW19YDtcbiAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwiYmlnaW50XCIpXG4gICAgICAgIG1lc3NhZ2UgPSBgQmlnSW50IG11c3QgYmUgJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5YCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBsZXNzIHRoYW4gb3IgZXF1YWwgdG9gIDogYGxlc3MgdGhhbmB9ICR7aXNzdWUubWF4aW11bX1gO1xuICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJkYXRlXCIpXG4gICAgICAgIG1lc3NhZ2UgPSBgRGF0ZSBtdXN0IGJlICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseWAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgc21hbGxlciB0aGFuIG9yIGVxdWFsIHRvYCA6IGBzbWFsbGVyIHRoYW5gfSAke25ldyBEYXRlKE51bWJlcihpc3N1ZS5tYXhpbXVtKSl9YDtcbiAgICAgIGVsc2VcbiAgICAgICAgbWVzc2FnZSA9IFwiSW52YWxpZCBpbnB1dFwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBab2RJc3N1ZUNvZGUuY3VzdG9tOlxuICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0YDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfaW50ZXJzZWN0aW9uX3R5cGVzOlxuICAgICAgbWVzc2FnZSA9IGBJbnRlcnNlY3Rpb24gcmVzdWx0cyBjb3VsZCBub3QgYmUgbWVyZ2VkYDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWm9kSXNzdWVDb2RlLm5vdF9tdWx0aXBsZV9vZjpcbiAgICAgIG1lc3NhZ2UgPSBgTnVtYmVyIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAke2lzc3VlLm11bHRpcGxlT2Z9YDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWm9kSXNzdWVDb2RlLm5vdF9maW5pdGU6XG4gICAgICBtZXNzYWdlID0gXCJOdW1iZXIgbXVzdCBiZSBmaW5pdGVcIjtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBtZXNzYWdlID0gX2N0eC5kZWZhdWx0RXJyb3I7XG4gICAgICB1dGlsLmFzc2VydE5ldmVyKGlzc3VlKTtcbiAgfVxuICByZXR1cm4geyBtZXNzYWdlIH07XG59O1xudmFyIG92ZXJyaWRlRXJyb3JNYXAgPSBlcnJvck1hcDtcbmZ1bmN0aW9uIHNldEVycm9yTWFwKG1hcCkge1xuICBvdmVycmlkZUVycm9yTWFwID0gbWFwO1xufVxuZnVuY3Rpb24gZ2V0RXJyb3JNYXAoKSB7XG4gIHJldHVybiBvdmVycmlkZUVycm9yTWFwO1xufVxudmFyIG1ha2VJc3N1ZSA9IChwYXJhbXMpID0+IHtcbiAgY29uc3QgeyBkYXRhLCBwYXRoLCBlcnJvck1hcHMsIGlzc3VlRGF0YSB9ID0gcGFyYW1zO1xuICBjb25zdCBmdWxsUGF0aCA9IFsuLi5wYXRoLCAuLi5pc3N1ZURhdGEucGF0aCB8fCBbXV07XG4gIGNvbnN0IGZ1bGxJc3N1ZSA9IHtcbiAgICAuLi5pc3N1ZURhdGEsXG4gICAgcGF0aDogZnVsbFBhdGhcbiAgfTtcbiAgaWYgKGlzc3VlRGF0YS5tZXNzYWdlICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uaXNzdWVEYXRhLFxuICAgICAgcGF0aDogZnVsbFBhdGgsXG4gICAgICBtZXNzYWdlOiBpc3N1ZURhdGEubWVzc2FnZVxuICAgIH07XG4gIH1cbiAgbGV0IGVycm9yTWVzc2FnZSA9IFwiXCI7XG4gIGNvbnN0IG1hcHMgPSBlcnJvck1hcHMuZmlsdGVyKChtKSA9PiAhIW0pLnNsaWNlKCkucmV2ZXJzZSgpO1xuICBmb3IgKGNvbnN0IG1hcCBvZiBtYXBzKSB7XG4gICAgZXJyb3JNZXNzYWdlID0gbWFwKGZ1bGxJc3N1ZSwgeyBkYXRhLCBkZWZhdWx0RXJyb3I6IGVycm9yTWVzc2FnZSB9KS5tZXNzYWdlO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uaXNzdWVEYXRhLFxuICAgIHBhdGg6IGZ1bGxQYXRoLFxuICAgIG1lc3NhZ2U6IGVycm9yTWVzc2FnZVxuICB9O1xufTtcbnZhciBFTVBUWV9QQVRIID0gW107XG5mdW5jdGlvbiBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIGlzc3VlRGF0YSkge1xuICBjb25zdCBvdmVycmlkZU1hcCA9IGdldEVycm9yTWFwKCk7XG4gIGNvbnN0IGlzc3VlID0gbWFrZUlzc3VlKHtcbiAgICBpc3N1ZURhdGEsXG4gICAgZGF0YTogY3R4LmRhdGEsXG4gICAgcGF0aDogY3R4LnBhdGgsXG4gICAgZXJyb3JNYXBzOiBbXG4gICAgICBjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCxcbiAgICAgIGN0eC5zY2hlbWFFcnJvck1hcCxcbiAgICAgIG92ZXJyaWRlTWFwLFxuICAgICAgb3ZlcnJpZGVNYXAgPT09IGVycm9yTWFwID8gdm9pZCAwIDogZXJyb3JNYXBcbiAgICAgIC8vIHRoZW4gZ2xvYmFsIGRlZmF1bHQgbWFwXG4gICAgXS5maWx0ZXIoKHgpID0+ICEheClcbiAgfSk7XG4gIGN0eC5jb21tb24uaXNzdWVzLnB1c2goaXNzdWUpO1xufVxudmFyIFBhcnNlU3RhdHVzID0gY2xhc3MgX1BhcnNlU3RhdHVzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy52YWx1ZSA9IFwidmFsaWRcIjtcbiAgfVxuICBkaXJ0eSgpIHtcbiAgICBpZiAodGhpcy52YWx1ZSA9PT0gXCJ2YWxpZFwiKVxuICAgICAgdGhpcy52YWx1ZSA9IFwiZGlydHlcIjtcbiAgfVxuICBhYm9ydCgpIHtcbiAgICBpZiAodGhpcy52YWx1ZSAhPT0gXCJhYm9ydGVkXCIpXG4gICAgICB0aGlzLnZhbHVlID0gXCJhYm9ydGVkXCI7XG4gIH1cbiAgc3RhdGljIG1lcmdlQXJyYXkoc3RhdHVzLCByZXN1bHRzKSB7XG4gICAgY29uc3QgYXJyYXlWYWx1ZSA9IFtdO1xuICAgIGZvciAoY29uc3QgcyBvZiByZXN1bHRzKSB7XG4gICAgICBpZiAocy5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgIGlmIChzLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgIGFycmF5VmFsdWUucHVzaChzLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBhcnJheVZhbHVlIH07XG4gIH1cbiAgc3RhdGljIGFzeW5jIG1lcmdlT2JqZWN0QXN5bmMoc3RhdHVzLCBwYWlycykge1xuICAgIGNvbnN0IHN5bmNQYWlycyA9IFtdO1xuICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgY29uc3Qga2V5ID0gYXdhaXQgcGFpci5rZXk7XG4gICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHBhaXIudmFsdWU7XG4gICAgICBzeW5jUGFpcnMucHVzaCh7XG4gICAgICAgIGtleSxcbiAgICAgICAgdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gX1BhcnNlU3RhdHVzLm1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHN5bmNQYWlycyk7XG4gIH1cbiAgc3RhdGljIG1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHBhaXJzKSB7XG4gICAgY29uc3QgZmluYWxPYmplY3QgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcbiAgICAgIGNvbnN0IHsga2V5LCB2YWx1ZSB9ID0gcGFpcjtcbiAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICBpZiAodmFsdWUuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgIGlmICh2YWx1ZS5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICBpZiAoa2V5LnZhbHVlICE9PSBcIl9fcHJvdG9fX1wiICYmICh0eXBlb2YgdmFsdWUudmFsdWUgIT09IFwidW5kZWZpbmVkXCIgfHwgcGFpci5hbHdheXNTZXQpKSB7XG4gICAgICAgIGZpbmFsT2JqZWN0W2tleS52YWx1ZV0gPSB2YWx1ZS52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBmaW5hbE9iamVjdCB9O1xuICB9XG59O1xudmFyIElOVkFMSUQgPSBPYmplY3QuZnJlZXplKHtcbiAgc3RhdHVzOiBcImFib3J0ZWRcIlxufSk7XG52YXIgRElSVFkgPSAodmFsdWUpID0+ICh7IHN0YXR1czogXCJkaXJ0eVwiLCB2YWx1ZSB9KTtcbnZhciBPSyA9ICh2YWx1ZSkgPT4gKHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlIH0pO1xudmFyIGlzQWJvcnRlZCA9ICh4KSA9PiB4LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCI7XG52YXIgaXNEaXJ0eSA9ICh4KSA9PiB4LnN0YXR1cyA9PT0gXCJkaXJ0eVwiO1xudmFyIGlzVmFsaWQgPSAoeCkgPT4geC5zdGF0dXMgPT09IFwidmFsaWRcIjtcbnZhciBpc0FzeW5jID0gKHgpID0+IHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiICYmIHggaW5zdGFuY2VvZiBQcm9taXNlO1xuZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG59XG5mdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgaWYgKGtpbmQgPT09IFwibVwiKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gIGlmIChraW5kID09PSBcImFcIiAmJiAhZilcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gIHJldHVybiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpLCB2YWx1ZTtcbn1cbnZhciBlcnJvclV0aWw7XG4oZnVuY3Rpb24oZXJyb3JVdGlsMikge1xuICBlcnJvclV0aWwyLmVyclRvT2JqID0gKG1lc3NhZ2UpID0+IHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiID8geyBtZXNzYWdlIH0gOiBtZXNzYWdlIHx8IHt9O1xuICBlcnJvclV0aWwyLnRvU3RyaW5nID0gKG1lc3NhZ2UpID0+IHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiID8gbWVzc2FnZSA6IG1lc3NhZ2UgPT09IG51bGwgfHwgbWVzc2FnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWVzc2FnZS5tZXNzYWdlO1xufSkoZXJyb3JVdGlsIHx8IChlcnJvclV0aWwgPSB7fSkpO1xudmFyIF9ab2RFbnVtX2NhY2hlO1xudmFyIF9ab2ROYXRpdmVFbnVtX2NhY2hlO1xudmFyIFBhcnNlSW5wdXRMYXp5UGF0aCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IocGFyZW50LCB2YWx1ZSwgcGF0aCwga2V5KSB7XG4gICAgdGhpcy5fY2FjaGVkUGF0aCA9IFtdO1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIHRoaXMuZGF0YSA9IHZhbHVlO1xuICAgIHRoaXMuX3BhdGggPSBwYXRoO1xuICAgIHRoaXMuX2tleSA9IGtleTtcbiAgfVxuICBnZXQgcGF0aCgpIHtcbiAgICBpZiAoIXRoaXMuX2NhY2hlZFBhdGgubGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5fa2V5IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgdGhpcy5fY2FjaGVkUGF0aC5wdXNoKC4uLnRoaXMuX3BhdGgsIC4uLnRoaXMuX2tleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jYWNoZWRQYXRoLnB1c2goLi4udGhpcy5fcGF0aCwgdGhpcy5fa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZFBhdGg7XG4gIH1cbn07XG52YXIgaGFuZGxlUmVzdWx0ID0gKGN0eCwgcmVzdWx0KSA9PiB7XG4gIGlmIChpc1ZhbGlkKHJlc3VsdCkpIHtcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBkYXRhOiByZXN1bHQudmFsdWUgfTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWN0eC5jb21tb24uaXNzdWVzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsaWRhdGlvbiBmYWlsZWQgYnV0IG5vIGlzc3VlcyBkZXRlY3RlZC5cIik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGdldCBlcnJvcigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Vycm9yKVxuICAgICAgICAgIHJldHVybiB0aGlzLl9lcnJvcjtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgWm9kRXJyb3IoY3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICB0aGlzLl9lcnJvciA9IGVycm9yO1xuICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3I7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcbmZ1bmN0aW9uIHByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSB7XG4gIGlmICghcGFyYW1zKVxuICAgIHJldHVybiB7fTtcbiAgY29uc3QgeyBlcnJvck1hcDogZXJyb3JNYXAyLCBpbnZhbGlkX3R5cGVfZXJyb3IsIHJlcXVpcmVkX2Vycm9yLCBkZXNjcmlwdGlvbiB9ID0gcGFyYW1zO1xuICBpZiAoZXJyb3JNYXAyICYmIChpbnZhbGlkX3R5cGVfZXJyb3IgfHwgcmVxdWlyZWRfZXJyb3IpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCB1c2UgXCJpbnZhbGlkX3R5cGVfZXJyb3JcIiBvciBcInJlcXVpcmVkX2Vycm9yXCIgaW4gY29uanVuY3Rpb24gd2l0aCBjdXN0b20gZXJyb3IgbWFwLmApO1xuICB9XG4gIGlmIChlcnJvck1hcDIpXG4gICAgcmV0dXJuIHsgZXJyb3JNYXA6IGVycm9yTWFwMiwgZGVzY3JpcHRpb24gfTtcbiAgY29uc3QgY3VzdG9tTWFwID0gKGlzcywgY3R4KSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCB7IG1lc3NhZ2UgfSA9IHBhcmFtcztcbiAgICBpZiAoaXNzLmNvZGUgPT09IFwiaW52YWxpZF9lbnVtX3ZhbHVlXCIpIHtcbiAgICAgIHJldHVybiB7IG1lc3NhZ2U6IG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6IGN0eC5kZWZhdWx0RXJyb3IgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjdHguZGF0YSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHsgbWVzc2FnZTogKF9hID0gbWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgPyBtZXNzYWdlIDogcmVxdWlyZWRfZXJyb3IpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGN0eC5kZWZhdWx0RXJyb3IgfTtcbiAgICB9XG4gICAgaWYgKGlzcy5jb2RlICE9PSBcImludmFsaWRfdHlwZVwiKVxuICAgICAgcmV0dXJuIHsgbWVzc2FnZTogY3R4LmRlZmF1bHRFcnJvciB9O1xuICAgIHJldHVybiB7IG1lc3NhZ2U6IChfYiA9IG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6IGludmFsaWRfdHlwZV9lcnJvcikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogY3R4LmRlZmF1bHRFcnJvciB9O1xuICB9O1xuICByZXR1cm4geyBlcnJvck1hcDogY3VzdG9tTWFwLCBkZXNjcmlwdGlvbiB9O1xufVxudmFyIFpvZFR5cGUgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGRlZikge1xuICAgIHRoaXMuc3BhID0gdGhpcy5zYWZlUGFyc2VBc3luYztcbiAgICB0aGlzLl9kZWYgPSBkZWY7XG4gICAgdGhpcy5wYXJzZSA9IHRoaXMucGFyc2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLnNhZmVQYXJzZSA9IHRoaXMuc2FmZVBhcnNlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5wYXJzZUFzeW5jID0gdGhpcy5wYXJzZUFzeW5jLmJpbmQodGhpcyk7XG4gICAgdGhpcy5zYWZlUGFyc2VBc3luYyA9IHRoaXMuc2FmZVBhcnNlQXN5bmMuYmluZCh0aGlzKTtcbiAgICB0aGlzLnNwYSA9IHRoaXMuc3BhLmJpbmQodGhpcyk7XG4gICAgdGhpcy5yZWZpbmUgPSB0aGlzLnJlZmluZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMucmVmaW5lbWVudCA9IHRoaXMucmVmaW5lbWVudC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuc3VwZXJSZWZpbmUgPSB0aGlzLnN1cGVyUmVmaW5lLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vcHRpb25hbCA9IHRoaXMub3B0aW9uYWwuYmluZCh0aGlzKTtcbiAgICB0aGlzLm51bGxhYmxlID0gdGhpcy5udWxsYWJsZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMubnVsbGlzaCA9IHRoaXMubnVsbGlzaC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuYXJyYXkgPSB0aGlzLmFycmF5LmJpbmQodGhpcyk7XG4gICAgdGhpcy5wcm9taXNlID0gdGhpcy5wcm9taXNlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5vciA9IHRoaXMub3IuYmluZCh0aGlzKTtcbiAgICB0aGlzLmFuZCA9IHRoaXMuYW5kLmJpbmQodGhpcyk7XG4gICAgdGhpcy50cmFuc2Zvcm0gPSB0aGlzLnRyYW5zZm9ybS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuYnJhbmQgPSB0aGlzLmJyYW5kLmJpbmQodGhpcyk7XG4gICAgdGhpcy5kZWZhdWx0ID0gdGhpcy5kZWZhdWx0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5jYXRjaCA9IHRoaXMuY2F0Y2guYmluZCh0aGlzKTtcbiAgICB0aGlzLmRlc2NyaWJlID0gdGhpcy5kZXNjcmliZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMucGlwZSA9IHRoaXMucGlwZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMucmVhZG9ubHkgPSB0aGlzLnJlYWRvbmx5LmJpbmQodGhpcyk7XG4gICAgdGhpcy5pc051bGxhYmxlID0gdGhpcy5pc051bGxhYmxlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5pc09wdGlvbmFsID0gdGhpcy5pc09wdGlvbmFsLmJpbmQodGhpcyk7XG4gIH1cbiAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuZGVzY3JpcHRpb247XG4gIH1cbiAgX2dldFR5cGUoaW5wdXQpIHtcbiAgICByZXR1cm4gZ2V0UGFyc2VkVHlwZShpbnB1dC5kYXRhKTtcbiAgfVxuICBfZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCkge1xuICAgIHJldHVybiBjdHggfHwge1xuICAgICAgY29tbW9uOiBpbnB1dC5wYXJlbnQuY29tbW9uLFxuICAgICAgZGF0YTogaW5wdXQuZGF0YSxcbiAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoaW5wdXQuZGF0YSksXG4gICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgcGF0aDogaW5wdXQucGF0aCxcbiAgICAgIHBhcmVudDogaW5wdXQucGFyZW50XG4gICAgfTtcbiAgfVxuICBfcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1czogbmV3IFBhcnNlU3RhdHVzKCksXG4gICAgICBjdHg6IHtcbiAgICAgICAgY29tbW9uOiBpbnB1dC5wYXJlbnQuY29tbW9uLFxuICAgICAgICBkYXRhOiBpbnB1dC5kYXRhLFxuICAgICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGlucHV0LmRhdGEpLFxuICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICBwYXRoOiBpbnB1dC5wYXRoLFxuICAgICAgICBwYXJlbnQ6IGlucHV0LnBhcmVudFxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgX3BhcnNlU3luYyhpbnB1dCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlKGlucHV0KTtcbiAgICBpZiAoaXNBc3luYyhyZXN1bHQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTeW5jaHJvbm91cyBwYXJzZSBlbmNvdW50ZXJlZCBwcm9taXNlLlwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBfcGFyc2VBc3luYyhpbnB1dCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlKGlucHV0KTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gIH1cbiAgcGFyc2UoZGF0YSwgcGFyYW1zKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5zYWZlUGFyc2UoZGF0YSwgcGFyYW1zKTtcbiAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpXG4gICAgICByZXR1cm4gcmVzdWx0LmRhdGE7XG4gICAgdGhyb3cgcmVzdWx0LmVycm9yO1xuICB9XG4gIHNhZmVQYXJzZShkYXRhLCBwYXJhbXMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgY3R4ID0ge1xuICAgICAgY29tbW9uOiB7XG4gICAgICAgIGlzc3VlczogW10sXG4gICAgICAgIGFzeW5jOiAoX2EgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuYXN5bmMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlLFxuICAgICAgICBjb250ZXh0dWFsRXJyb3JNYXA6IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5lcnJvck1hcFxuICAgICAgfSxcbiAgICAgIHBhdGg6IChwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMucGF0aCkgfHwgW10sXG4gICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgZGF0YSxcbiAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoZGF0YSlcbiAgICB9O1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlU3luYyh7IGRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KTtcbiAgICByZXR1cm4gaGFuZGxlUmVzdWx0KGN0eCwgcmVzdWx0KTtcbiAgfVxuICBhc3luYyBwYXJzZUFzeW5jKGRhdGEsIHBhcmFtcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuc2FmZVBhcnNlQXN5bmMoZGF0YSwgcGFyYW1zKTtcbiAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpXG4gICAgICByZXR1cm4gcmVzdWx0LmRhdGE7XG4gICAgdGhyb3cgcmVzdWx0LmVycm9yO1xuICB9XG4gIGFzeW5jIHNhZmVQYXJzZUFzeW5jKGRhdGEsIHBhcmFtcykge1xuICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgIGNvbW1vbjoge1xuICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICBjb250ZXh0dWFsRXJyb3JNYXA6IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5lcnJvck1hcCxcbiAgICAgICAgYXN5bmM6IHRydWVcbiAgICAgIH0sXG4gICAgICBwYXRoOiAocGFyYW1zID09PSBudWxsIHx8IHBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyYW1zLnBhdGgpIHx8IFtdLFxuICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgIGRhdGEsXG4gICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGRhdGEpXG4gICAgfTtcbiAgICBjb25zdCBtYXliZUFzeW5jUmVzdWx0ID0gdGhpcy5fcGFyc2UoeyBkYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgKGlzQXN5bmMobWF5YmVBc3luY1Jlc3VsdCkgPyBtYXliZUFzeW5jUmVzdWx0IDogUHJvbWlzZS5yZXNvbHZlKG1heWJlQXN5bmNSZXN1bHQpKTtcbiAgICByZXR1cm4gaGFuZGxlUmVzdWx0KGN0eCwgcmVzdWx0KTtcbiAgfVxuICByZWZpbmUoY2hlY2ssIG1lc3NhZ2UpIHtcbiAgICBjb25zdCBnZXRJc3N1ZVByb3BlcnRpZXMgPSAodmFsKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIG1lc3NhZ2UgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIHsgbWVzc2FnZSB9O1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBtZXNzYWdlKHZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB0aGlzLl9yZWZpbmVtZW50KCh2YWwsIGN0eCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gY2hlY2sodmFsKTtcbiAgICAgIGNvbnN0IHNldEVycm9yID0gKCkgPT4gY3R4LmFkZElzc3VlKHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmN1c3RvbSxcbiAgICAgICAgLi4uZ2V0SXNzdWVQcm9wZXJ0aWVzKHZhbClcbiAgICAgIH0pO1xuICAgICAgaWYgKHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiICYmIHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICBzZXRFcnJvcigpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgc2V0RXJyb3IoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmVmaW5lbWVudChjaGVjaywgcmVmaW5lbWVudERhdGEpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVmaW5lbWVudCgodmFsLCBjdHgpID0+IHtcbiAgICAgIGlmICghY2hlY2sodmFsKSkge1xuICAgICAgICBjdHguYWRkSXNzdWUodHlwZW9mIHJlZmluZW1lbnREYXRhID09PSBcImZ1bmN0aW9uXCIgPyByZWZpbmVtZW50RGF0YSh2YWwsIGN0eCkgOiByZWZpbmVtZW50RGF0YSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF9yZWZpbmVtZW50KHJlZmluZW1lbnQpIHtcbiAgICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xuICAgICAgc2NoZW1hOiB0aGlzLFxuICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzLFxuICAgICAgZWZmZWN0OiB7IHR5cGU6IFwicmVmaW5lbWVudFwiLCByZWZpbmVtZW50IH1cbiAgICB9KTtcbiAgfVxuICBzdXBlclJlZmluZShyZWZpbmVtZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlZmluZW1lbnQocmVmaW5lbWVudCk7XG4gIH1cbiAgb3B0aW9uYWwoKSB7XG4gICAgcmV0dXJuIFpvZE9wdGlvbmFsLmNyZWF0ZSh0aGlzLCB0aGlzLl9kZWYpO1xuICB9XG4gIG51bGxhYmxlKCkge1xuICAgIHJldHVybiBab2ROdWxsYWJsZS5jcmVhdGUodGhpcywgdGhpcy5fZGVmKTtcbiAgfVxuICBudWxsaXNoKCkge1xuICAgIHJldHVybiB0aGlzLm51bGxhYmxlKCkub3B0aW9uYWwoKTtcbiAgfVxuICBhcnJheSgpIHtcbiAgICByZXR1cm4gWm9kQXJyYXkuY3JlYXRlKHRoaXMsIHRoaXMuX2RlZik7XG4gIH1cbiAgcHJvbWlzZSgpIHtcbiAgICByZXR1cm4gWm9kUHJvbWlzZS5jcmVhdGUodGhpcywgdGhpcy5fZGVmKTtcbiAgfVxuICBvcihvcHRpb24pIHtcbiAgICByZXR1cm4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBvcHRpb25dLCB0aGlzLl9kZWYpO1xuICB9XG4gIGFuZChpbmNvbWluZykge1xuICAgIHJldHVybiBab2RJbnRlcnNlY3Rpb24uY3JlYXRlKHRoaXMsIGluY29taW5nLCB0aGlzLl9kZWYpO1xuICB9XG4gIHRyYW5zZm9ybSh0cmFuc2Zvcm0pIHtcbiAgICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xuICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlzLl9kZWYpLFxuICAgICAgc2NoZW1hOiB0aGlzLFxuICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzLFxuICAgICAgZWZmZWN0OiB7IHR5cGU6IFwidHJhbnNmb3JtXCIsIHRyYW5zZm9ybSB9XG4gICAgfSk7XG4gIH1cbiAgZGVmYXVsdChkZWYpIHtcbiAgICBjb25zdCBkZWZhdWx0VmFsdWVGdW5jID0gdHlwZW9mIGRlZiA9PT0gXCJmdW5jdGlvblwiID8gZGVmIDogKCkgPT4gZGVmO1xuICAgIHJldHVybiBuZXcgWm9kRGVmYXVsdCh7XG4gICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXMuX2RlZiksXG4gICAgICBpbm5lclR5cGU6IHRoaXMsXG4gICAgICBkZWZhdWx0VmFsdWU6IGRlZmF1bHRWYWx1ZUZ1bmMsXG4gICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZERlZmF1bHRcbiAgICB9KTtcbiAgfVxuICBicmFuZCgpIHtcbiAgICByZXR1cm4gbmV3IFpvZEJyYW5kZWQoe1xuICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RCcmFuZGVkLFxuICAgICAgdHlwZTogdGhpcyxcbiAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcy5fZGVmKVxuICAgIH0pO1xuICB9XG4gIGNhdGNoKGRlZikge1xuICAgIGNvbnN0IGNhdGNoVmFsdWVGdW5jID0gdHlwZW9mIGRlZiA9PT0gXCJmdW5jdGlvblwiID8gZGVmIDogKCkgPT4gZGVmO1xuICAgIHJldHVybiBuZXcgWm9kQ2F0Y2goe1xuICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlzLl9kZWYpLFxuICAgICAgaW5uZXJUeXBlOiB0aGlzLFxuICAgICAgY2F0Y2hWYWx1ZTogY2F0Y2hWYWx1ZUZ1bmMsXG4gICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZENhdGNoXG4gICAgfSk7XG4gIH1cbiAgZGVzY3JpYmUoZGVzY3JpcHRpb24pIHtcbiAgICBjb25zdCBUaGlzID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gbmV3IFRoaXMoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgZGVzY3JpcHRpb25cbiAgICB9KTtcbiAgfVxuICBwaXBlKHRhcmdldCkge1xuICAgIHJldHVybiBab2RQaXBlbGluZS5jcmVhdGUodGhpcywgdGFyZ2V0KTtcbiAgfVxuICByZWFkb25seSgpIHtcbiAgICByZXR1cm4gWm9kUmVhZG9ubHkuY3JlYXRlKHRoaXMpO1xuICB9XG4gIGlzT3B0aW9uYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2FmZVBhcnNlKHZvaWQgMCkuc3VjY2VzcztcbiAgfVxuICBpc051bGxhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLnNhZmVQYXJzZShudWxsKS5zdWNjZXNzO1xuICB9XG59O1xudmFyIGN1aWRSZWdleCA9IC9eY1teXFxzLV17OCx9JC9pO1xudmFyIGN1aWQyUmVnZXggPSAvXlswLTlhLXpdKyQvO1xudmFyIHVsaWRSZWdleCA9IC9eWzAtOUEtSEpLTU5QLVRWLVpdezI2fSQvO1xudmFyIHV1aWRSZWdleCA9IC9eWzAtOWEtZkEtRl17OH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17MTJ9JC9pO1xudmFyIG5hbm9pZFJlZ2V4ID0gL15bYS16MC05Xy1dezIxfSQvaTtcbnZhciBkdXJhdGlvblJlZ2V4ID0gL15bLStdP1AoPyEkKSg/Oig/OlstK10/XFxkK1kpfCg/OlstK10/XFxkK1suLF1cXGQrWSQpKT8oPzooPzpbLStdP1xcZCtNKXwoPzpbLStdP1xcZCtbLixdXFxkK00kKSk/KD86KD86Wy0rXT9cXGQrVyl8KD86Wy0rXT9cXGQrWy4sXVxcZCtXJCkpPyg/Oig/OlstK10/XFxkK0QpfCg/OlstK10/XFxkK1suLF1cXGQrRCQpKT8oPzpUKD89W1xcZCstXSkoPzooPzpbLStdP1xcZCtIKXwoPzpbLStdP1xcZCtbLixdXFxkK0gkKSk/KD86KD86Wy0rXT9cXGQrTSl8KD86Wy0rXT9cXGQrWy4sXVxcZCtNJCkpPyg/OlstK10/XFxkKyg/OlsuLF1cXGQrKT9TKT8pPz8kLztcbnZhciBlbWFpbFJlZ2V4ID0gL14oPyFcXC4pKD8hLipcXC5cXC4pKFtBLVowLTlfJytcXC1cXC5dKilbQS1aMC05XystXUAoW0EtWjAtOV1bQS1aMC05XFwtXSpcXC4pK1tBLVpdezIsfSQvaTtcbnZhciBfZW1vamlSZWdleCA9IGBeKFxcXFxwe0V4dGVuZGVkX1BpY3RvZ3JhcGhpY318XFxcXHB7RW1vamlfQ29tcG9uZW50fSkrJGA7XG52YXIgZW1vamlSZWdleDtcbnZhciBpcHY0UmVnZXggPSAvXig/Oig/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSlcXC4pezN9KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKSQvO1xudmFyIGlwdjZSZWdleCA9IC9eKChbYS1mMC05XXsxLDR9Oil7N318OjooW2EtZjAtOV17MSw0fTopezAsNn18KFthLWYwLTldezEsNH06KXsxfTooW2EtZjAtOV17MSw0fTopezAsNX18KFthLWYwLTldezEsNH06KXsyfTooW2EtZjAtOV17MSw0fTopezAsNH18KFthLWYwLTldezEsNH06KXszfTooW2EtZjAtOV17MSw0fTopezAsM318KFthLWYwLTldezEsNH06KXs0fTooW2EtZjAtOV17MSw0fTopezAsMn18KFthLWYwLTldezEsNH06KXs1fTooW2EtZjAtOV17MSw0fTopezAsMX0pKFthLWYwLTldezEsNH18KCgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpXFwuKXszfSgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpKSQvO1xudmFyIGJhc2U2NFJlZ2V4ID0gL14oWzAtOWEtekEtWisvXXs0fSkqKChbMC05YS16QS1aKy9dezJ9PT0pfChbMC05YS16QS1aKy9dezN9PSkpPyQvO1xudmFyIGRhdGVSZWdleFNvdXJjZSA9IGAoKFxcXFxkXFxcXGRbMjQ2OF1bMDQ4XXxcXFxcZFxcXFxkWzEzNTc5XVsyNl18XFxcXGRcXFxcZDBbNDhdfFswMjQ2OF1bMDQ4XTAwfFsxMzU3OV1bMjZdMDApLTAyLTI5fFxcXFxkezR9LSgoMFsxMzU3OF18MVswMl0pLSgwWzEtOV18WzEyXVxcXFxkfDNbMDFdKXwoMFs0NjldfDExKS0oMFsxLTldfFsxMl1cXFxcZHwzMCl8KDAyKS0oMFsxLTldfDFcXFxcZHwyWzAtOF0pKSlgO1xudmFyIGRhdGVSZWdleCA9IG5ldyBSZWdFeHAoYF4ke2RhdGVSZWdleFNvdXJjZX0kYCk7XG5mdW5jdGlvbiB0aW1lUmVnZXhTb3VyY2UoYXJncykge1xuICBsZXQgcmVnZXggPSBgKFswMV1cXFxcZHwyWzAtM10pOlswLTVdXFxcXGQ6WzAtNV1cXFxcZGA7XG4gIGlmIChhcmdzLnByZWNpc2lvbikge1xuICAgIHJlZ2V4ID0gYCR7cmVnZXh9XFxcXC5cXFxcZHske2FyZ3MucHJlY2lzaW9ufX1gO1xuICB9IGVsc2UgaWYgKGFyZ3MucHJlY2lzaW9uID09IG51bGwpIHtcbiAgICByZWdleCA9IGAke3JlZ2V4fShcXFxcLlxcXFxkKyk/YDtcbiAgfVxuICByZXR1cm4gcmVnZXg7XG59XG5mdW5jdGlvbiB0aW1lUmVnZXgoYXJncykge1xuICByZXR1cm4gbmV3IFJlZ0V4cChgXiR7dGltZVJlZ2V4U291cmNlKGFyZ3MpfSRgKTtcbn1cbmZ1bmN0aW9uIGRhdGV0aW1lUmVnZXgoYXJncykge1xuICBsZXQgcmVnZXggPSBgJHtkYXRlUmVnZXhTb3VyY2V9VCR7dGltZVJlZ2V4U291cmNlKGFyZ3MpfWA7XG4gIGNvbnN0IG9wdHMgPSBbXTtcbiAgb3B0cy5wdXNoKGFyZ3MubG9jYWwgPyBgWj9gIDogYFpgKTtcbiAgaWYgKGFyZ3Mub2Zmc2V0KVxuICAgIG9wdHMucHVzaChgKFsrLV1cXFxcZHsyfTo/XFxcXGR7Mn0pYCk7XG4gIHJlZ2V4ID0gYCR7cmVnZXh9KCR7b3B0cy5qb2luKFwifFwiKX0pYDtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoYF4ke3JlZ2V4fSRgKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRJUChpcCwgdmVyc2lvbikge1xuICBpZiAoKHZlcnNpb24gPT09IFwidjRcIiB8fCAhdmVyc2lvbikgJiYgaXB2NFJlZ2V4LnRlc3QoaXApKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKCh2ZXJzaW9uID09PSBcInY2XCIgfHwgIXZlcnNpb24pICYmIGlwdjZSZWdleC50ZXN0KGlwKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbnZhciBab2RTdHJpbmcgPSBjbGFzcyBfWm9kU3RyaW5nIGV4dGVuZHMgWm9kVHlwZSB7XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XG4gICAgICBpbnB1dC5kYXRhID0gU3RyaW5nKGlucHV0LmRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuc3RyaW5nKSB7XG4gICAgICBjb25zdCBjdHgyID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4Miwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5zdHJpbmcsXG4gICAgICAgIHJlY2VpdmVkOiBjdHgyLnBhcnNlZFR5cGVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBQYXJzZVN0YXR1cygpO1xuICAgIGxldCBjdHggPSB2b2lkIDA7XG4gICAgZm9yIChjb25zdCBjaGVjayBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICBpZiAoY2hlY2sua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICBpZiAoaW5wdXQuZGF0YS5sZW5ndGggPCBjaGVjay52YWx1ZSkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgIGlmIChpbnB1dC5kYXRhLmxlbmd0aCA+IGNoZWNrLnZhbHVlKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImxlbmd0aFwiKSB7XG4gICAgICAgIGNvbnN0IHRvb0JpZyA9IGlucHV0LmRhdGEubGVuZ3RoID4gY2hlY2sudmFsdWU7XG4gICAgICAgIGNvbnN0IHRvb1NtYWxsID0gaW5wdXQuZGF0YS5sZW5ndGggPCBjaGVjay52YWx1ZTtcbiAgICAgICAgaWYgKHRvb0JpZyB8fCB0b29TbWFsbCkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGlmICh0b29CaWcpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgZXhhY3Q6IHRydWUsXG4gICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAodG9vU21hbGwpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICBleGFjdDogdHJ1ZSxcbiAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZW1haWxcIikge1xuICAgICAgICBpZiAoIWVtYWlsUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJlbWFpbFwiLFxuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZW1vamlcIikge1xuICAgICAgICBpZiAoIWVtb2ppUmVnZXgpIHtcbiAgICAgICAgICBlbW9qaVJlZ2V4ID0gbmV3IFJlZ0V4cChfZW1vamlSZWdleCwgXCJ1XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZW1vamlSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uOiBcImVtb2ppXCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ1dWlkXCIpIHtcbiAgICAgICAgaWYgKCF1dWlkUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ1dWlkXCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJuYW5vaWRcIikge1xuICAgICAgICBpZiAoIW5hbm9pZFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb246IFwibmFub2lkXCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJjdWlkXCIpIHtcbiAgICAgICAgaWYgKCFjdWlkUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJjdWlkXCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJjdWlkMlwiKSB7XG4gICAgICAgIGlmICghY3VpZDJSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uOiBcImN1aWQyXCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ1bGlkXCIpIHtcbiAgICAgICAgaWYgKCF1bGlkUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ1bGlkXCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ1cmxcIikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG5ldyBVUkwoaW5wdXQuZGF0YSk7XG4gICAgICAgIH0gY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uOiBcInVybFwiLFxuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwicmVnZXhcIikge1xuICAgICAgICBjaGVjay5yZWdleC5sYXN0SW5kZXggPSAwO1xuICAgICAgICBjb25zdCB0ZXN0UmVzdWx0ID0gY2hlY2sucmVnZXgudGVzdChpbnB1dC5kYXRhKTtcbiAgICAgICAgaWYgKCF0ZXN0UmVzdWx0KSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uOiBcInJlZ2V4XCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ0cmltXCIpIHtcbiAgICAgICAgaW5wdXQuZGF0YSA9IGlucHV0LmRhdGEudHJpbSgpO1xuICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImluY2x1ZGVzXCIpIHtcbiAgICAgICAgaWYgKCFpbnB1dC5kYXRhLmluY2x1ZGVzKGNoZWNrLnZhbHVlLCBjaGVjay5wb3NpdGlvbikpIHtcbiAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgIHZhbGlkYXRpb246IHsgaW5jbHVkZXM6IGNoZWNrLnZhbHVlLCBwb3NpdGlvbjogY2hlY2sucG9zaXRpb24gfSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInRvTG93ZXJDYXNlXCIpIHtcbiAgICAgICAgaW5wdXQuZGF0YSA9IGlucHV0LmRhdGEudG9Mb3dlckNhc2UoKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ0b1VwcGVyQ2FzZVwiKSB7XG4gICAgICAgIGlucHV0LmRhdGEgPSBpbnB1dC5kYXRhLnRvVXBwZXJDYXNlKCk7XG4gICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwic3RhcnRzV2l0aFwiKSB7XG4gICAgICAgIGlmICghaW5wdXQuZGF0YS5zdGFydHNXaXRoKGNoZWNrLnZhbHVlKSkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgdmFsaWRhdGlvbjogeyBzdGFydHNXaXRoOiBjaGVjay52YWx1ZSB9LFxuICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZW5kc1dpdGhcIikge1xuICAgICAgICBpZiAoIWlucHV0LmRhdGEuZW5kc1dpdGgoY2hlY2sudmFsdWUpKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICB2YWxpZGF0aW9uOiB7IGVuZHNXaXRoOiBjaGVjay52YWx1ZSB9LFxuICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZGF0ZXRpbWVcIikge1xuICAgICAgICBjb25zdCByZWdleCA9IGRhdGV0aW1lUmVnZXgoY2hlY2spO1xuICAgICAgICBpZiAoIXJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgIHZhbGlkYXRpb246IFwiZGF0ZXRpbWVcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImRhdGVcIikge1xuICAgICAgICBjb25zdCByZWdleCA9IGRhdGVSZWdleDtcbiAgICAgICAgaWYgKCFyZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICB2YWxpZGF0aW9uOiBcImRhdGVcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInRpbWVcIikge1xuICAgICAgICBjb25zdCByZWdleCA9IHRpbWVSZWdleChjaGVjayk7XG4gICAgICAgIGlmICghcmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ0aW1lXCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJkdXJhdGlvblwiKSB7XG4gICAgICAgIGlmICghZHVyYXRpb25SZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uOiBcImR1cmF0aW9uXCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJpcFwiKSB7XG4gICAgICAgIGlmICghaXNWYWxpZElQKGlucHV0LmRhdGEsIGNoZWNrLnZlcnNpb24pKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uOiBcImlwXCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJiYXNlNjRcIikge1xuICAgICAgICBpZiAoIWJhc2U2NFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb246IFwiYmFzZTY0XCIsXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgfVxuICBfcmVnZXgocmVnZXgsIHZhbGlkYXRpb24sIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5yZWZpbmVtZW50KChkYXRhKSA9PiByZWdleC50ZXN0KGRhdGEpLCB7XG4gICAgICB2YWxpZGF0aW9uLFxuICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgX2FkZENoZWNrKGNoZWNrKSB7XG4gICAgcmV0dXJuIG5ldyBfWm9kU3RyaW5nKHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXVxuICAgIH0pO1xuICB9XG4gIGVtYWlsKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImVtYWlsXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgfVxuICB1cmwobWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwidXJsXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgfVxuICBlbW9qaShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJlbW9qaVwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gIH1cbiAgdXVpZChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJ1dWlkXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgfVxuICBuYW5vaWQobWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwibmFub2lkXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgfVxuICBjdWlkKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImN1aWRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICB9XG4gIGN1aWQyKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImN1aWQyXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgfVxuICB1bGlkKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcInVsaWRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICB9XG4gIGJhc2U2NChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJiYXNlNjRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICB9XG4gIGlwKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImlwXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihvcHRpb25zKSB9KTtcbiAgfVxuICBkYXRldGltZShvcHRpb25zKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgIGtpbmQ6IFwiZGF0ZXRpbWVcIixcbiAgICAgICAgcHJlY2lzaW9uOiBudWxsLFxuICAgICAgICBvZmZzZXQ6IGZhbHNlLFxuICAgICAgICBsb2NhbDogZmFsc2UsXG4gICAgICAgIG1lc3NhZ2U6IG9wdGlvbnNcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJkYXRldGltZVwiLFxuICAgICAgcHJlY2lzaW9uOiB0eXBlb2YgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmVjaXNpb24pID09PSBcInVuZGVmaW5lZFwiID8gbnVsbCA6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmVjaXNpb24sXG4gICAgICBvZmZzZXQ6IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vZmZzZXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlLFxuICAgICAgbG9jYWw6IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5sb2NhbCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2UsXG4gICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgZGF0ZShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJkYXRlXCIsIG1lc3NhZ2UgfSk7XG4gIH1cbiAgdGltZShvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICBraW5kOiBcInRpbWVcIixcbiAgICAgICAgcHJlY2lzaW9uOiBudWxsLFxuICAgICAgICBtZXNzYWdlOiBvcHRpb25zXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwidGltZVwiLFxuICAgICAgcHJlY2lzaW9uOiB0eXBlb2YgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmVjaXNpb24pID09PSBcInVuZGVmaW5lZFwiID8gbnVsbCA6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmVjaXNpb24sXG4gICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgZHVyYXRpb24obWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiZHVyYXRpb25cIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICB9XG4gIHJlZ2V4KHJlZ2V4LCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwicmVnZXhcIixcbiAgICAgIHJlZ2V4LFxuICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgaW5jbHVkZXModmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJpbmNsdWRlc1wiLFxuICAgICAgdmFsdWUsXG4gICAgICBwb3NpdGlvbjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnBvc2l0aW9uLFxuICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tZXNzYWdlKVxuICAgIH0pO1xuICB9XG4gIHN0YXJ0c1dpdGgodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJzdGFydHNXaXRoXCIsXG4gICAgICB2YWx1ZSxcbiAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKVxuICAgIH0pO1xuICB9XG4gIGVuZHNXaXRoKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwiZW5kc1dpdGhcIixcbiAgICAgIHZhbHVlLFxuICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgbWluKG1pbkxlbmd0aCwgbWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgdmFsdWU6IG1pbkxlbmd0aCxcbiAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKVxuICAgIH0pO1xuICB9XG4gIG1heChtYXhMZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJtYXhcIixcbiAgICAgIHZhbHVlOiBtYXhMZW5ndGgsXG4gICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSlcbiAgICB9KTtcbiAgfVxuICBsZW5ndGgobGVuLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibGVuZ3RoXCIsXG4gICAgICB2YWx1ZTogbGVuLFxuICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB6LnN0cmluZygpLm1pbigxKSBpbnN0ZWFkLlxuICAgKiBAc2VlIHtAbGluayBab2RTdHJpbmcubWlufVxuICAgKi9cbiAgbm9uZW1wdHkobWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLm1pbigxLCBlcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkpO1xuICB9XG4gIHRyaW0oKSB7XG4gICAgcmV0dXJuIG5ldyBfWm9kU3RyaW5nKHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIHsga2luZDogXCJ0cmltXCIgfV1cbiAgICB9KTtcbiAgfVxuICB0b0xvd2VyQ2FzZSgpIHtcbiAgICByZXR1cm4gbmV3IF9ab2RTdHJpbmcoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgeyBraW5kOiBcInRvTG93ZXJDYXNlXCIgfV1cbiAgICB9KTtcbiAgfVxuICB0b1VwcGVyQ2FzZSgpIHtcbiAgICByZXR1cm4gbmV3IF9ab2RTdHJpbmcoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgeyBraW5kOiBcInRvVXBwZXJDYXNlXCIgfV1cbiAgICB9KTtcbiAgfVxuICBnZXQgaXNEYXRldGltZSgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImRhdGV0aW1lXCIpO1xuICB9XG4gIGdldCBpc0RhdGUoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJkYXRlXCIpO1xuICB9XG4gIGdldCBpc1RpbWUoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJ0aW1lXCIpO1xuICB9XG4gIGdldCBpc0R1cmF0aW9uKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiZHVyYXRpb25cIik7XG4gIH1cbiAgZ2V0IGlzRW1haWwoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJlbWFpbFwiKTtcbiAgfVxuICBnZXQgaXNVUkwoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJ1cmxcIik7XG4gIH1cbiAgZ2V0IGlzRW1vamkoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJlbW9qaVwiKTtcbiAgfVxuICBnZXQgaXNVVUlEKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwidXVpZFwiKTtcbiAgfVxuICBnZXQgaXNOQU5PSUQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJuYW5vaWRcIik7XG4gIH1cbiAgZ2V0IGlzQ1VJRCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImN1aWRcIik7XG4gIH1cbiAgZ2V0IGlzQ1VJRDIoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJjdWlkMlwiKTtcbiAgfVxuICBnZXQgaXNVTElEKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwidWxpZFwiKTtcbiAgfVxuICBnZXQgaXNJUCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImlwXCIpO1xuICB9XG4gIGdldCBpc0Jhc2U2NCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImJhc2U2NFwiKTtcbiAgfVxuICBnZXQgbWluTGVuZ3RoKCkge1xuICAgIGxldCBtaW4gPSBudWxsO1xuICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcbiAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1pbjtcbiAgfVxuICBnZXQgbWF4TGVuZ3RoKCkge1xuICAgIGxldCBtYXggPSBudWxsO1xuICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcbiAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1heDtcbiAgfVxufTtcblpvZFN0cmluZy5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gIHZhciBfYTtcbiAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xuICAgIGNoZWNrczogW10sXG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RTdHJpbmcsXG4gICAgY29lcmNlOiAoX2EgPSBwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuY29lcmNlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZSxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xuZnVuY3Rpb24gZmxvYXRTYWZlUmVtYWluZGVyKHZhbCwgc3RlcCkge1xuICBjb25zdCB2YWxEZWNDb3VudCA9ICh2YWwudG9TdHJpbmcoKS5zcGxpdChcIi5cIilbMV0gfHwgXCJcIikubGVuZ3RoO1xuICBjb25zdCBzdGVwRGVjQ291bnQgPSAoc3RlcC50b1N0cmluZygpLnNwbGl0KFwiLlwiKVsxXSB8fCBcIlwiKS5sZW5ndGg7XG4gIGNvbnN0IGRlY0NvdW50ID0gdmFsRGVjQ291bnQgPiBzdGVwRGVjQ291bnQgPyB2YWxEZWNDb3VudCA6IHN0ZXBEZWNDb3VudDtcbiAgY29uc3QgdmFsSW50ID0gcGFyc2VJbnQodmFsLnRvRml4ZWQoZGVjQ291bnQpLnJlcGxhY2UoXCIuXCIsIFwiXCIpKTtcbiAgY29uc3Qgc3RlcEludCA9IHBhcnNlSW50KHN0ZXAudG9GaXhlZChkZWNDb3VudCkucmVwbGFjZShcIi5cIiwgXCJcIikpO1xuICByZXR1cm4gdmFsSW50ICUgc3RlcEludCAvIE1hdGgucG93KDEwLCBkZWNDb3VudCk7XG59XG52YXIgWm9kTnVtYmVyID0gY2xhc3MgX1pvZE51bWJlciBleHRlbmRzIFpvZFR5cGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMubWluID0gdGhpcy5ndGU7XG4gICAgdGhpcy5tYXggPSB0aGlzLmx0ZTtcbiAgICB0aGlzLnN0ZXAgPSB0aGlzLm11bHRpcGxlT2Y7XG4gIH1cbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UpIHtcbiAgICAgIGlucHV0LmRhdGEgPSBOdW1iZXIoaW5wdXQuZGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5udW1iZXIpIHtcbiAgICAgIGNvbnN0IGN0eDIgPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgyLCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm51bWJlcixcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eDIucGFyc2VkVHlwZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgbGV0IGN0eCA9IHZvaWQgMDtcbiAgICBjb25zdCBzdGF0dXMgPSBuZXcgUGFyc2VTdGF0dXMoKTtcbiAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgIGlmIChjaGVjay5raW5kID09PSBcImludFwiKSB7XG4gICAgICAgIGlmICghdXRpbC5pc0ludGVnZXIoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICBleHBlY3RlZDogXCJpbnRlZ2VyXCIsXG4gICAgICAgICAgICByZWNlaXZlZDogXCJmbG9hdFwiLFxuICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgY29uc3QgdG9vU21hbGwgPSBjaGVjay5pbmNsdXNpdmUgPyBpbnB1dC5kYXRhIDwgY2hlY2sudmFsdWUgOiBpbnB1dC5kYXRhIDw9IGNoZWNrLnZhbHVlO1xuICAgICAgICBpZiAodG9vU21hbGwpIHtcbiAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IGNoZWNrLmluY2x1c2l2ZSxcbiAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgIGNvbnN0IHRvb0JpZyA9IGNoZWNrLmluY2x1c2l2ZSA/IGlucHV0LmRhdGEgPiBjaGVjay52YWx1ZSA6IGlucHV0LmRhdGEgPj0gY2hlY2sudmFsdWU7XG4gICAgICAgIGlmICh0b29CaWcpIHtcbiAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXG4gICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtdWx0aXBsZU9mXCIpIHtcbiAgICAgICAgaWYgKGZsb2F0U2FmZVJlbWFpbmRlcihpbnB1dC5kYXRhLCBjaGVjay52YWx1ZSkgIT09IDApIHtcbiAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5ub3RfbXVsdGlwbGVfb2YsXG4gICAgICAgICAgICBtdWx0aXBsZU9mOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImZpbml0ZVwiKSB7XG4gICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUubm90X2Zpbml0ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXRpbC5hc3NlcnROZXZlcihjaGVjayk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICB9XG4gIGd0ZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICB9XG4gIGd0KHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtaW5cIiwgdmFsdWUsIGZhbHNlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICB9XG4gIGx0ZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICB9XG4gIGx0KHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtYXhcIiwgdmFsdWUsIGZhbHNlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICB9XG4gIHNldExpbWl0KGtpbmQsIHZhbHVlLCBpbmNsdXNpdmUsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbmV3IF9ab2ROdW1iZXIoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgY2hlY2tzOiBbXG4gICAgICAgIC4uLnRoaXMuX2RlZi5jaGVja3MsXG4gICAgICAgIHtcbiAgICAgICAgICBraW5kLFxuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGluY2x1c2l2ZSxcbiAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSlcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0pO1xuICB9XG4gIF9hZGRDaGVjayhjaGVjaykge1xuICAgIHJldHVybiBuZXcgX1pvZE51bWJlcih7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCBjaGVja11cbiAgICB9KTtcbiAgfVxuICBpbnQobWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcImludFwiLFxuICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgcG9zaXRpdmUobWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgdmFsdWU6IDAsXG4gICAgICBpbmNsdXNpdmU6IGZhbHNlLFxuICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgbmVnYXRpdmUobWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgdmFsdWU6IDAsXG4gICAgICBpbmNsdXNpdmU6IGZhbHNlLFxuICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgbm9ucG9zaXRpdmUobWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgdmFsdWU6IDAsXG4gICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSlcbiAgICB9KTtcbiAgfVxuICBub25uZWdhdGl2ZShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICB2YWx1ZTogMCxcbiAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKVxuICAgIH0pO1xuICB9XG4gIG11bHRpcGxlT2YodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJtdWx0aXBsZU9mXCIsXG4gICAgICB2YWx1ZSxcbiAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKVxuICAgIH0pO1xuICB9XG4gIGZpbml0ZShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwiZmluaXRlXCIsXG4gICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSlcbiAgICB9KTtcbiAgfVxuICBzYWZlKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJtaW5cIixcbiAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUixcbiAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKVxuICAgIH0pLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgdmFsdWU6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgZ2V0IG1pblZhbHVlKCkge1xuICAgIGxldCBtaW4gPSBudWxsO1xuICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcbiAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1pbjtcbiAgfVxuICBnZXQgbWF4VmFsdWUoKSB7XG4gICAgbGV0IG1heCA9IG51bGw7XG4gICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KVxuICAgICAgICAgIG1heCA9IGNoLnZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF4O1xuICB9XG4gIGdldCBpc0ludCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImludFwiIHx8IGNoLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiICYmIHV0aWwuaXNJbnRlZ2VyKGNoLnZhbHVlKSk7XG4gIH1cbiAgZ2V0IGlzRmluaXRlKCkge1xuICAgIGxldCBtYXggPSBudWxsLCBtaW4gPSBudWxsO1xuICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgaWYgKGNoLmtpbmQgPT09IFwiZmluaXRlXCIgfHwgY2gua2luZCA9PT0gXCJpbnRcIiB8fCBjaC5raW5kID09PSBcIm11bHRpcGxlT2ZcIikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxuICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgIGlmIChtYXggPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgpXG4gICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUobWluKSAmJiBOdW1iZXIuaXNGaW5pdGUobWF4KTtcbiAgfVxufTtcblpvZE51bWJlci5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kTnVtYmVyKHtcbiAgICBjaGVja3M6IFtdLFxuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTnVtYmVyLFxuICAgIGNvZXJjZTogKHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5jb2VyY2UpIHx8IGZhbHNlLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG52YXIgWm9kQmlnSW50ID0gY2xhc3MgX1pvZEJpZ0ludCBleHRlbmRzIFpvZFR5cGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMubWluID0gdGhpcy5ndGU7XG4gICAgdGhpcy5tYXggPSB0aGlzLmx0ZTtcbiAgfVxuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgaW5wdXQuZGF0YSA9IEJpZ0ludChpbnB1dC5kYXRhKTtcbiAgICB9XG4gICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmJpZ2ludCkge1xuICAgICAgY29uc3QgY3R4MiA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eDIsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuYmlnaW50LFxuICAgICAgICByZWNlaXZlZDogY3R4Mi5wYXJzZWRUeXBlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgICBsZXQgY3R4ID0gdm9pZCAwO1xuICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBQYXJzZVN0YXR1cygpO1xuICAgIGZvciAoY29uc3QgY2hlY2sgb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgaWYgKGNoZWNrLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgY29uc3QgdG9vU21hbGwgPSBjaGVjay5pbmNsdXNpdmUgPyBpbnB1dC5kYXRhIDwgY2hlY2sudmFsdWUgOiBpbnB1dC5kYXRhIDw9IGNoZWNrLnZhbHVlO1xuICAgICAgICBpZiAodG9vU21hbGwpIHtcbiAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICB0eXBlOiBcImJpZ2ludFwiLFxuICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IGNoZWNrLmluY2x1c2l2ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgIGNvbnN0IHRvb0JpZyA9IGNoZWNrLmluY2x1c2l2ZSA/IGlucHV0LmRhdGEgPiBjaGVjay52YWx1ZSA6IGlucHV0LmRhdGEgPj0gY2hlY2sudmFsdWU7XG4gICAgICAgIGlmICh0b29CaWcpIHtcbiAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgdHlwZTogXCJiaWdpbnRcIixcbiAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtdWx0aXBsZU9mXCIpIHtcbiAgICAgICAgaWYgKGlucHV0LmRhdGEgJSBjaGVjay52YWx1ZSAhPT0gQmlnSW50KDApKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUubm90X211bHRpcGxlX29mLFxuICAgICAgICAgICAgbXVsdGlwbGVPZjogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgfVxuICBndGUodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1pblwiLCB2YWx1ZSwgdHJ1ZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgfVxuICBndCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCBmYWxzZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgfVxuICBsdGUodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCB2YWx1ZSwgdHJ1ZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgfVxuICBsdCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCBmYWxzZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgfVxuICBzZXRMaW1pdChraW5kLCB2YWx1ZSwgaW5jbHVzaXZlLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG5ldyBfWm9kQmlnSW50KHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIGNoZWNrczogW1xuICAgICAgICAuLi50aGlzLl9kZWYuY2hlY2tzLFxuICAgICAgICB7XG4gICAgICAgICAga2luZCxcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBpbmNsdXNpdmUsXG4gICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9KTtcbiAgfVxuICBfYWRkQ2hlY2soY2hlY2spIHtcbiAgICByZXR1cm4gbmV3IF9ab2RCaWdJbnQoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdXG4gICAgfSk7XG4gIH1cbiAgcG9zaXRpdmUobWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcbiAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSlcbiAgICB9KTtcbiAgfVxuICBuZWdhdGl2ZShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICB2YWx1ZTogQmlnSW50KDApLFxuICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcbiAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKVxuICAgIH0pO1xuICB9XG4gIG5vbnBvc2l0aXZlKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJtYXhcIixcbiAgICAgIHZhbHVlOiBCaWdJbnQoMCksXG4gICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSlcbiAgICB9KTtcbiAgfVxuICBub25uZWdhdGl2ZShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICB2YWx1ZTogQmlnSW50KDApLFxuICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgbXVsdGlwbGVPZih2YWx1ZSwgbWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm11bHRpcGxlT2ZcIixcbiAgICAgIHZhbHVlLFxuICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgZ2V0IG1pblZhbHVlKCkge1xuICAgIGxldCBtaW4gPSBudWxsO1xuICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcbiAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1pbjtcbiAgfVxuICBnZXQgbWF4VmFsdWUoKSB7XG4gICAgbGV0IG1heCA9IG51bGw7XG4gICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KVxuICAgICAgICAgIG1heCA9IGNoLnZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF4O1xuICB9XG59O1xuWm9kQmlnSW50LmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgdmFyIF9hO1xuICByZXR1cm4gbmV3IFpvZEJpZ0ludCh7XG4gICAgY2hlY2tzOiBbXSxcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEJpZ0ludCxcbiAgICBjb2VyY2U6IChfYSA9IHBhcmFtcyA9PT0gbnVsbCB8fCBwYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmFtcy5jb2VyY2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG52YXIgWm9kQm9vbGVhbiA9IGNsYXNzIGV4dGVuZHMgWm9kVHlwZSB7XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XG4gICAgICBpbnB1dC5kYXRhID0gQm9vbGVhbihpbnB1dC5kYXRhKTtcbiAgICB9XG4gICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmJvb2xlYW4pIHtcbiAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5ib29sZWFuLFxuICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgfVxufTtcblpvZEJvb2xlYW4uY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZEJvb2xlYW4oe1xuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQm9vbGVhbixcbiAgICBjb2VyY2U6IChwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuY29lcmNlKSB8fCBmYWxzZSxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xudmFyIFpvZERhdGUgPSBjbGFzcyBfWm9kRGF0ZSBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgaW5wdXQuZGF0YSA9IG5ldyBEYXRlKGlucHV0LmRhdGEpO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuZGF0ZSkge1xuICAgICAgY29uc3QgY3R4MiA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eDIsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuZGF0ZSxcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eDIucGFyc2VkVHlwZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgaWYgKGlzTmFOKGlucHV0LmRhdGEuZ2V0VGltZSgpKSkge1xuICAgICAgY29uc3QgY3R4MiA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eDIsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfZGF0ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgY29uc3Qgc3RhdHVzID0gbmV3IFBhcnNlU3RhdHVzKCk7XG4gICAgbGV0IGN0eCA9IHZvaWQgMDtcbiAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgIGlmIChjaGVjay5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgIGlmIChpbnB1dC5kYXRhLmdldFRpbWUoKSA8IGNoZWNrLnZhbHVlKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgdHlwZTogXCJkYXRlXCJcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgIGlmIChpbnB1dC5kYXRhLmdldFRpbWUoKSA+IGNoZWNrLnZhbHVlKSB7XG4gICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICBtYXhpbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgIHR5cGU6IFwiZGF0ZVwiXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzOiBzdGF0dXMudmFsdWUsXG4gICAgICB2YWx1ZTogbmV3IERhdGUoaW5wdXQuZGF0YS5nZXRUaW1lKCkpXG4gICAgfTtcbiAgfVxuICBfYWRkQ2hlY2soY2hlY2spIHtcbiAgICByZXR1cm4gbmV3IF9ab2REYXRlKHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXVxuICAgIH0pO1xuICB9XG4gIG1pbihtaW5EYXRlLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICB2YWx1ZTogbWluRGF0ZS5nZXRUaW1lKCksXG4gICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSlcbiAgICB9KTtcbiAgfVxuICBtYXgobWF4RGF0ZSwgbWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgdmFsdWU6IG1heERhdGUuZ2V0VGltZSgpLFxuICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgZ2V0IG1pbkRhdGUoKSB7XG4gICAgbGV0IG1pbiA9IG51bGw7XG4gICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxuICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWluICE9IG51bGwgPyBuZXcgRGF0ZShtaW4pIDogbnVsbDtcbiAgfVxuICBnZXQgbWF4RGF0ZSgpIHtcbiAgICBsZXQgbWF4ID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgIGlmIChtYXggPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgpXG4gICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXggIT0gbnVsbCA/IG5ldyBEYXRlKG1heCkgOiBudWxsO1xuICB9XG59O1xuWm9kRGF0ZS5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kRGF0ZSh7XG4gICAgY2hlY2tzOiBbXSxcbiAgICBjb2VyY2U6IChwYXJhbXMgPT09IG51bGwgfHwgcGFyYW1zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXMuY29lcmNlKSB8fCBmYWxzZSxcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZERhdGUsXG4gICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufTtcbnZhciBab2RTeW1ib2wgPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuc3ltYm9sKSB7XG4gICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuc3ltYm9sLFxuICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgfVxufTtcblpvZFN5bWJvbC5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kU3ltYm9sKHtcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFN5bWJvbCxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xudmFyIFpvZFVuZGVmaW5lZCA9IGNsYXNzIGV4dGVuZHMgWm9kVHlwZSB7XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS51bmRlZmluZWQsXG4gICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICB9XG59O1xuWm9kVW5kZWZpbmVkLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgcmV0dXJuIG5ldyBab2RVbmRlZmluZWQoe1xuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVW5kZWZpbmVkLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG52YXIgWm9kTnVsbCA9IGNsYXNzIGV4dGVuZHMgWm9kVHlwZSB7XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5udWxsKSB7XG4gICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubnVsbCxcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gIH1cbn07XG5ab2ROdWxsLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgcmV0dXJuIG5ldyBab2ROdWxsKHtcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE51bGwsXG4gICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufTtcbnZhciBab2RBbnkgPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuX2FueSA9IHRydWU7XG4gIH1cbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICB9XG59O1xuWm9kQW55LmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgcmV0dXJuIG5ldyBab2RBbnkoe1xuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQW55LFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG52YXIgWm9kVW5rbm93biA9IGNsYXNzIGV4dGVuZHMgWm9kVHlwZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5fdW5rbm93biA9IHRydWU7XG4gIH1cbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICB9XG59O1xuWm9kVW5rbm93bi5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kVW5rbm93bih7XG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RVbmtub3duLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG52YXIgWm9kTmV2ZXIgPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubmV2ZXIsXG4gICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGVcbiAgICB9KTtcbiAgICByZXR1cm4gSU5WQUxJRDtcbiAgfVxufTtcblpvZE5ldmVyLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgcmV0dXJuIG5ldyBab2ROZXZlcih7XG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROZXZlcixcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xudmFyIFpvZFZvaWQgPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUudm9pZCxcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gIH1cbn07XG5ab2RWb2lkLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgcmV0dXJuIG5ldyBab2RWb2lkKHtcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFZvaWQsXG4gICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufTtcbnZhciBab2RBcnJheSA9IGNsYXNzIF9ab2RBcnJheSBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCB7IGN0eCwgc3RhdHVzIH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgIGNvbnN0IGRlZiA9IHRoaXMuX2RlZjtcbiAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuYXJyYXkpIHtcbiAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5hcnJheSxcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgICBpZiAoZGVmLmV4YWN0TGVuZ3RoICE9PSBudWxsKSB7XG4gICAgICBjb25zdCB0b29CaWcgPSBjdHguZGF0YS5sZW5ndGggPiBkZWYuZXhhY3RMZW5ndGgudmFsdWU7XG4gICAgICBjb25zdCB0b29TbWFsbCA9IGN0eC5kYXRhLmxlbmd0aCA8IGRlZi5leGFjdExlbmd0aC52YWx1ZTtcbiAgICAgIGlmICh0b29CaWcgfHwgdG9vU21hbGwpIHtcbiAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgY29kZTogdG9vQmlnID8gWm9kSXNzdWVDb2RlLnRvb19iaWcgOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgIG1pbmltdW06IHRvb1NtYWxsID8gZGVmLmV4YWN0TGVuZ3RoLnZhbHVlIDogdm9pZCAwLFxuICAgICAgICAgIG1heGltdW06IHRvb0JpZyA/IGRlZi5leGFjdExlbmd0aC52YWx1ZSA6IHZvaWQgMCxcbiAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgIGV4YWN0OiB0cnVlLFxuICAgICAgICAgIG1lc3NhZ2U6IGRlZi5leGFjdExlbmd0aC5tZXNzYWdlXG4gICAgICAgIH0pO1xuICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlZi5taW5MZW5ndGggIT09IG51bGwpIHtcbiAgICAgIGlmIChjdHguZGF0YS5sZW5ndGggPCBkZWYubWluTGVuZ3RoLnZhbHVlKSB7XG4gICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgbWluaW11bTogZGVmLm1pbkxlbmd0aC52YWx1ZSxcbiAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICBtZXNzYWdlOiBkZWYubWluTGVuZ3RoLm1lc3NhZ2VcbiAgICAgICAgfSk7XG4gICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVmLm1heExlbmd0aCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGN0eC5kYXRhLmxlbmd0aCA+IGRlZi5tYXhMZW5ndGgudmFsdWUpIHtcbiAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgbWF4aW11bTogZGVmLm1heExlbmd0aC52YWx1ZSxcbiAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICBtZXNzYWdlOiBkZWYubWF4TGVuZ3RoLm1lc3NhZ2VcbiAgICAgICAgfSk7XG4gICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFsuLi5jdHguZGF0YV0ubWFwKChpdGVtLCBpKSA9PiB7XG4gICAgICAgIHJldHVybiBkZWYudHlwZS5fcGFyc2VBc3luYyhuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGkpKTtcbiAgICAgIH0pKS50aGVuKChyZXN1bHQyKSA9PiB7XG4gICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0Mik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gWy4uLmN0eC5kYXRhXS5tYXAoKGl0ZW0sIGkpID0+IHtcbiAgICAgIHJldHVybiBkZWYudHlwZS5fcGFyc2VTeW5jKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBpdGVtLCBjdHgucGF0aCwgaSkpO1xuICAgIH0pO1xuICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0KTtcbiAgfVxuICBnZXQgZWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGU7XG4gIH1cbiAgbWluKG1pbkxlbmd0aCwgbWVzc2FnZSkge1xuICAgIHJldHVybiBuZXcgX1pvZEFycmF5KHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIG1pbkxlbmd0aDogeyB2YWx1ZTogbWluTGVuZ3RoLCBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfVxuICAgIH0pO1xuICB9XG4gIG1heChtYXhMZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbmV3IF9ab2RBcnJheSh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBtYXhMZW5ndGg6IHsgdmFsdWU6IG1heExlbmd0aCwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH1cbiAgICB9KTtcbiAgfVxuICBsZW5ndGgobGVuLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG5ldyBfWm9kQXJyYXkoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgZXhhY3RMZW5ndGg6IHsgdmFsdWU6IGxlbiwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH1cbiAgICB9KTtcbiAgfVxuICBub25lbXB0eShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMubWluKDEsIG1lc3NhZ2UpO1xuICB9XG59O1xuWm9kQXJyYXkuY3JlYXRlID0gKHNjaGVtYSwgcGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kQXJyYXkoe1xuICAgIHR5cGU6IHNjaGVtYSxcbiAgICBtaW5MZW5ndGg6IG51bGwsXG4gICAgbWF4TGVuZ3RoOiBudWxsLFxuICAgIGV4YWN0TGVuZ3RoOiBudWxsLFxuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQXJyYXksXG4gICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufTtcbmZ1bmN0aW9uIGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYSkge1xuICBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kT2JqZWN0KSB7XG4gICAgY29uc3QgbmV3U2hhcGUgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEuc2hhcGUpIHtcbiAgICAgIGNvbnN0IGZpZWxkU2NoZW1hID0gc2NoZW1hLnNoYXBlW2tleV07XG4gICAgICBuZXdTaGFwZVtrZXldID0gWm9kT3B0aW9uYWwuY3JlYXRlKGRlZXBQYXJ0aWFsaWZ5KGZpZWxkU2NoZW1hKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgIC4uLnNjaGVtYS5fZGVmLFxuICAgICAgc2hhcGU6ICgpID0+IG5ld1NoYXBlXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kQXJyYXkpIHtcbiAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgIC4uLnNjaGVtYS5fZGVmLFxuICAgICAgdHlwZTogZGVlcFBhcnRpYWxpZnkoc2NoZW1hLmVsZW1lbnQpXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kT3B0aW9uYWwpIHtcbiAgICByZXR1cm4gWm9kT3B0aW9uYWwuY3JlYXRlKGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYS51bndyYXAoKSkpO1xuICB9IGVsc2UgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFpvZE51bGxhYmxlKSB7XG4gICAgcmV0dXJuIFpvZE51bGxhYmxlLmNyZWF0ZShkZWVwUGFydGlhbGlmeShzY2hlbWEudW53cmFwKCkpKTtcbiAgfSBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RUdXBsZSkge1xuICAgIHJldHVybiBab2RUdXBsZS5jcmVhdGUoc2NoZW1hLml0ZW1zLm1hcCgoaXRlbSkgPT4gZGVlcFBhcnRpYWxpZnkoaXRlbSkpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc2NoZW1hO1xuICB9XG59XG52YXIgWm9kT2JqZWN0ID0gY2xhc3MgX1pvZE9iamVjdCBleHRlbmRzIFpvZFR5cGUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMuX2NhY2hlZCA9IG51bGw7XG4gICAgdGhpcy5ub25zdHJpY3QgPSB0aGlzLnBhc3N0aHJvdWdoO1xuICAgIHRoaXMuYXVnbWVudCA9IHRoaXMuZXh0ZW5kO1xuICB9XG4gIF9nZXRDYWNoZWQoKSB7XG4gICAgaWYgKHRoaXMuX2NhY2hlZCAhPT0gbnVsbClcbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZWQ7XG4gICAgY29uc3Qgc2hhcGUgPSB0aGlzLl9kZWYuc2hhcGUoKTtcbiAgICBjb25zdCBrZXlzID0gdXRpbC5vYmplY3RLZXlzKHNoYXBlKTtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkID0geyBzaGFwZSwga2V5cyB9O1xuICB9XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgIGNvbnN0IGN0eDIgPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgyLCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm9iamVjdCxcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eDIucGFyc2VkVHlwZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICBjb25zdCB7IHNoYXBlLCBrZXlzOiBzaGFwZUtleXMgfSA9IHRoaXMuX2dldENhY2hlZCgpO1xuICAgIGNvbnN0IGV4dHJhS2V5cyA9IFtdO1xuICAgIGlmICghKHRoaXMuX2RlZi5jYXRjaGFsbCBpbnN0YW5jZW9mIFpvZE5ldmVyICYmIHRoaXMuX2RlZi51bmtub3duS2V5cyA9PT0gXCJzdHJpcFwiKSkge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gY3R4LmRhdGEpIHtcbiAgICAgICAgaWYgKCFzaGFwZUtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgIGV4dHJhS2V5cy5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcGFpcnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBzaGFwZUtleXMpIHtcbiAgICAgIGNvbnN0IGtleVZhbGlkYXRvciA9IHNoYXBlW2tleV07XG4gICAgICBjb25zdCB2YWx1ZSA9IGN0eC5kYXRhW2tleV07XG4gICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAga2V5OiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZToga2V5IH0sXG4gICAgICAgIHZhbHVlOiBrZXlWYWxpZGF0b3IuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIGtleSkpLFxuICAgICAgICBhbHdheXNTZXQ6IGtleSBpbiBjdHguZGF0YVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9kZWYuY2F0Y2hhbGwgaW5zdGFuY2VvZiBab2ROZXZlcikge1xuICAgICAgY29uc3QgdW5rbm93bktleXMgPSB0aGlzLl9kZWYudW5rbm93bktleXM7XG4gICAgICBpZiAodW5rbm93bktleXMgPT09IFwicGFzc3Rocm91Z2hcIikge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBleHRyYUtleXMpIHtcbiAgICAgICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAgICAgIGtleTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGtleSB9LFxuICAgICAgICAgICAgdmFsdWU6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBjdHguZGF0YVtrZXldIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh1bmtub3duS2V5cyA9PT0gXCJzdHJpY3RcIikge1xuICAgICAgICBpZiAoZXh0cmFLZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS51bnJlY29nbml6ZWRfa2V5cyxcbiAgICAgICAgICAgIGtleXM6IGV4dHJhS2V5c1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHVua25vd25LZXlzID09PSBcInN0cmlwXCIpXG4gICAgICAgIDtcbiAgICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludGVybmFsIFpvZE9iamVjdCBlcnJvcjogaW52YWxpZCB1bmtub3duS2V5cyB2YWx1ZS5gKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY2F0Y2hhbGwgPSB0aGlzLl9kZWYuY2F0Y2hhbGw7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBleHRyYUtleXMpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBjdHguZGF0YVtrZXldO1xuICAgICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAgICBrZXk6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBrZXkgfSxcbiAgICAgICAgICB2YWx1ZTogY2F0Y2hhbGwuX3BhcnNlKFxuICAgICAgICAgICAgbmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIHZhbHVlLCBjdHgucGF0aCwga2V5KVxuICAgICAgICAgICAgLy8sIGN0eC5jaGlsZChrZXkpLCB2YWx1ZSwgZ2V0UGFyc2VkVHlwZSh2YWx1ZSlcbiAgICAgICAgICApLFxuICAgICAgICAgIGFsd2F5c1NldDoga2V5IGluIGN0eC5kYXRhXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBzeW5jUGFpcnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgcGFpci5rZXk7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBwYWlyLnZhbHVlO1xuICAgICAgICAgIHN5bmNQYWlycy5wdXNoKHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgYWx3YXlzU2V0OiBwYWlyLmFsd2F5c1NldFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzeW5jUGFpcnM7XG4gICAgICB9KS50aGVuKChzeW5jUGFpcnMpID0+IHtcbiAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHN5bmNQYWlycyk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHBhaXJzKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHNoYXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuc2hhcGUoKTtcbiAgfVxuICBzdHJpY3QobWVzc2FnZSkge1xuICAgIGVycm9yVXRpbC5lcnJUb09iajtcbiAgICByZXR1cm4gbmV3IF9ab2RPYmplY3Qoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgdW5rbm93bktleXM6IFwic3RyaWN0XCIsXG4gICAgICAuLi5tZXNzYWdlICE9PSB2b2lkIDAgPyB7XG4gICAgICAgIGVycm9yTWFwOiAoaXNzdWUsIGN0eCkgPT4ge1xuICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgICBjb25zdCBkZWZhdWx0RXJyb3IgPSAoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLl9kZWYpLmVycm9yTWFwKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgaXNzdWUsIGN0eCkubWVzc2FnZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogY3R4LmRlZmF1bHRFcnJvcjtcbiAgICAgICAgICBpZiAoaXNzdWUuY29kZSA9PT0gXCJ1bnJlY29nbml6ZWRfa2V5c1wiKVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgbWVzc2FnZTogKF9kID0gZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLm1lc3NhZ2UpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGRlZmF1bHRFcnJvclxuICAgICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWVzc2FnZTogZGVmYXVsdEVycm9yXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSA6IHt9XG4gICAgfSk7XG4gIH1cbiAgc3RyaXAoKSB7XG4gICAgcmV0dXJuIG5ldyBfWm9kT2JqZWN0KHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIHVua25vd25LZXlzOiBcInN0cmlwXCJcbiAgICB9KTtcbiAgfVxuICBwYXNzdGhyb3VnaCgpIHtcbiAgICByZXR1cm4gbmV3IF9ab2RPYmplY3Qoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgdW5rbm93bktleXM6IFwicGFzc3Rocm91Z2hcIlxuICAgIH0pO1xuICB9XG4gIC8vIGNvbnN0IEF1Z21lbnRGYWN0b3J5ID1cbiAgLy8gICA8RGVmIGV4dGVuZHMgWm9kT2JqZWN0RGVmPihkZWY6IERlZikgPT5cbiAgLy8gICA8QXVnbWVudGF0aW9uIGV4dGVuZHMgWm9kUmF3U2hhcGU+KFxuICAvLyAgICAgYXVnbWVudGF0aW9uOiBBdWdtZW50YXRpb25cbiAgLy8gICApOiBab2RPYmplY3Q8XG4gIC8vICAgICBleHRlbmRTaGFwZTxSZXR1cm5UeXBlPERlZltcInNoYXBlXCJdPiwgQXVnbWVudGF0aW9uPixcbiAgLy8gICAgIERlZltcInVua25vd25LZXlzXCJdLFxuICAvLyAgICAgRGVmW1wiY2F0Y2hhbGxcIl1cbiAgLy8gICA+ID0+IHtcbiAgLy8gICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgLy8gICAgICAgLi4uZGVmLFxuICAvLyAgICAgICBzaGFwZTogKCkgPT4gKHtcbiAgLy8gICAgICAgICAuLi5kZWYuc2hhcGUoKSxcbiAgLy8gICAgICAgICAuLi5hdWdtZW50YXRpb24sXG4gIC8vICAgICAgIH0pLFxuICAvLyAgICAgfSkgYXMgYW55O1xuICAvLyAgIH07XG4gIGV4dGVuZChhdWdtZW50YXRpb24pIHtcbiAgICByZXR1cm4gbmV3IF9ab2RPYmplY3Qoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgc2hhcGU6ICgpID0+ICh7XG4gICAgICAgIC4uLnRoaXMuX2RlZi5zaGFwZSgpLFxuICAgICAgICAuLi5hdWdtZW50YXRpb25cbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFByaW9yIHRvIHpvZEAxLjAuMTIgdGhlcmUgd2FzIGEgYnVnIGluIHRoZVxuICAgKiBpbmZlcnJlZCB0eXBlIG9mIG1lcmdlZCBvYmplY3RzLiBQbGVhc2VcbiAgICogdXBncmFkZSBpZiB5b3UgYXJlIGV4cGVyaWVuY2luZyBpc3N1ZXMuXG4gICAqL1xuICBtZXJnZShtZXJnaW5nKSB7XG4gICAgY29uc3QgbWVyZ2VkID0gbmV3IF9ab2RPYmplY3Qoe1xuICAgICAgdW5rbm93bktleXM6IG1lcmdpbmcuX2RlZi51bmtub3duS2V5cyxcbiAgICAgIGNhdGNoYWxsOiBtZXJnaW5nLl9kZWYuY2F0Y2hhbGwsXG4gICAgICBzaGFwZTogKCkgPT4gKHtcbiAgICAgICAgLi4udGhpcy5fZGVmLnNoYXBlKCksXG4gICAgICAgIC4uLm1lcmdpbmcuX2RlZi5zaGFwZSgpXG4gICAgICB9KSxcbiAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0XG4gICAgfSk7XG4gICAgcmV0dXJuIG1lcmdlZDtcbiAgfVxuICAvLyBtZXJnZTxcbiAgLy8gICBJbmNvbWluZyBleHRlbmRzIEFueVpvZE9iamVjdCxcbiAgLy8gICBBdWdtZW50YXRpb24gZXh0ZW5kcyBJbmNvbWluZ1tcInNoYXBlXCJdLFxuICAvLyAgIE5ld091dHB1dCBleHRlbmRzIHtcbiAgLy8gICAgIFtrIGluIGtleW9mIEF1Z21lbnRhdGlvbiB8IGtleW9mIE91dHB1dF06IGsgZXh0ZW5kcyBrZXlvZiBBdWdtZW50YXRpb25cbiAgLy8gICAgICAgPyBBdWdtZW50YXRpb25ba11bXCJfb3V0cHV0XCJdXG4gIC8vICAgICAgIDogayBleHRlbmRzIGtleW9mIE91dHB1dFxuICAvLyAgICAgICA/IE91dHB1dFtrXVxuICAvLyAgICAgICA6IG5ldmVyO1xuICAvLyAgIH0sXG4gIC8vICAgTmV3SW5wdXQgZXh0ZW5kcyB7XG4gIC8vICAgICBbayBpbiBrZXlvZiBBdWdtZW50YXRpb24gfCBrZXlvZiBJbnB1dF06IGsgZXh0ZW5kcyBrZXlvZiBBdWdtZW50YXRpb25cbiAgLy8gICAgICAgPyBBdWdtZW50YXRpb25ba11bXCJfaW5wdXRcIl1cbiAgLy8gICAgICAgOiBrIGV4dGVuZHMga2V5b2YgSW5wdXRcbiAgLy8gICAgICAgPyBJbnB1dFtrXVxuICAvLyAgICAgICA6IG5ldmVyO1xuICAvLyAgIH1cbiAgLy8gPihcbiAgLy8gICBtZXJnaW5nOiBJbmNvbWluZ1xuICAvLyApOiBab2RPYmplY3Q8XG4gIC8vICAgZXh0ZW5kU2hhcGU8VCwgUmV0dXJuVHlwZTxJbmNvbWluZ1tcIl9kZWZcIl1bXCJzaGFwZVwiXT4+LFxuICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcInVua25vd25LZXlzXCJdLFxuICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcImNhdGNoYWxsXCJdLFxuICAvLyAgIE5ld091dHB1dCxcbiAgLy8gICBOZXdJbnB1dFxuICAvLyA+IHtcbiAgLy8gICBjb25zdCBtZXJnZWQ6IGFueSA9IG5ldyBab2RPYmplY3Qoe1xuICAvLyAgICAgdW5rbm93bktleXM6IG1lcmdpbmcuX2RlZi51bmtub3duS2V5cyxcbiAgLy8gICAgIGNhdGNoYWxsOiBtZXJnaW5nLl9kZWYuY2F0Y2hhbGwsXG4gIC8vICAgICBzaGFwZTogKCkgPT5cbiAgLy8gICAgICAgb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyh0aGlzLl9kZWYuc2hhcGUoKSwgbWVyZ2luZy5fZGVmLnNoYXBlKCkpLFxuICAvLyAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gIC8vICAgfSkgYXMgYW55O1xuICAvLyAgIHJldHVybiBtZXJnZWQ7XG4gIC8vIH1cbiAgc2V0S2V5KGtleSwgc2NoZW1hKSB7XG4gICAgcmV0dXJuIHRoaXMuYXVnbWVudCh7IFtrZXldOiBzY2hlbWEgfSk7XG4gIH1cbiAgLy8gbWVyZ2U8SW5jb21pbmcgZXh0ZW5kcyBBbnlab2RPYmplY3Q+KFxuICAvLyAgIG1lcmdpbmc6IEluY29taW5nXG4gIC8vICk6IC8vWm9kT2JqZWN0PFQgJiBJbmNvbWluZ1tcIl9zaGFwZVwiXSwgVW5rbm93bktleXMsIENhdGNoYWxsPiA9IChtZXJnaW5nKSA9PiB7XG4gIC8vIFpvZE9iamVjdDxcbiAgLy8gICBleHRlbmRTaGFwZTxULCBSZXR1cm5UeXBlPEluY29taW5nW1wiX2RlZlwiXVtcInNoYXBlXCJdPj4sXG4gIC8vICAgSW5jb21pbmdbXCJfZGVmXCJdW1widW5rbm93bktleXNcIl0sXG4gIC8vICAgSW5jb21pbmdbXCJfZGVmXCJdW1wiY2F0Y2hhbGxcIl1cbiAgLy8gPiB7XG4gIC8vICAgLy8gY29uc3QgbWVyZ2VkU2hhcGUgPSBvYmplY3RVdGlsLm1lcmdlU2hhcGVzKFxuICAvLyAgIC8vICAgdGhpcy5fZGVmLnNoYXBlKCksXG4gIC8vICAgLy8gICBtZXJnaW5nLl9kZWYuc2hhcGUoKVxuICAvLyAgIC8vICk7XG4gIC8vICAgY29uc3QgbWVyZ2VkOiBhbnkgPSBuZXcgWm9kT2JqZWN0KHtcbiAgLy8gICAgIHVua25vd25LZXlzOiBtZXJnaW5nLl9kZWYudW5rbm93bktleXMsXG4gIC8vICAgICBjYXRjaGFsbDogbWVyZ2luZy5fZGVmLmNhdGNoYWxsLFxuICAvLyAgICAgc2hhcGU6ICgpID0+XG4gIC8vICAgICAgIG9iamVjdFV0aWwubWVyZ2VTaGFwZXModGhpcy5fZGVmLnNoYXBlKCksIG1lcmdpbmcuX2RlZi5zaGFwZSgpKSxcbiAgLy8gICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAvLyAgIH0pIGFzIGFueTtcbiAgLy8gICByZXR1cm4gbWVyZ2VkO1xuICAvLyB9XG4gIGNhdGNoYWxsKGluZGV4KSB7XG4gICAgcmV0dXJuIG5ldyBfWm9kT2JqZWN0KHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIGNhdGNoYWxsOiBpbmRleFxuICAgIH0pO1xuICB9XG4gIHBpY2sobWFzaykge1xuICAgIGNvbnN0IHNoYXBlID0ge307XG4gICAgdXRpbC5vYmplY3RLZXlzKG1hc2spLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgaWYgKG1hc2tba2V5XSAmJiB0aGlzLnNoYXBlW2tleV0pIHtcbiAgICAgICAgc2hhcGVba2V5XSA9IHRoaXMuc2hhcGVba2V5XTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IF9ab2RPYmplY3Qoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgc2hhcGU6ICgpID0+IHNoYXBlXG4gICAgfSk7XG4gIH1cbiAgb21pdChtYXNrKSB7XG4gICAgY29uc3Qgc2hhcGUgPSB7fTtcbiAgICB1dGlsLm9iamVjdEtleXModGhpcy5zaGFwZSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICBpZiAoIW1hc2tba2V5XSkge1xuICAgICAgICBzaGFwZVtrZXldID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgX1pvZE9iamVjdCh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBzaGFwZTogKCkgPT4gc2hhcGVcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIGRlZXBQYXJ0aWFsKCkge1xuICAgIHJldHVybiBkZWVwUGFydGlhbGlmeSh0aGlzKTtcbiAgfVxuICBwYXJ0aWFsKG1hc2spIHtcbiAgICBjb25zdCBuZXdTaGFwZSA9IHt9O1xuICAgIHV0aWwub2JqZWN0S2V5cyh0aGlzLnNoYXBlKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGNvbnN0IGZpZWxkU2NoZW1hID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgaWYgKG1hc2sgJiYgIW1hc2tba2V5XSkge1xuICAgICAgICBuZXdTaGFwZVtrZXldID0gZmllbGRTY2hlbWE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdTaGFwZVtrZXldID0gZmllbGRTY2hlbWEub3B0aW9uYWwoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IF9ab2RPYmplY3Qoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgc2hhcGU6ICgpID0+IG5ld1NoYXBlXG4gICAgfSk7XG4gIH1cbiAgcmVxdWlyZWQobWFzaykge1xuICAgIGNvbnN0IG5ld1NoYXBlID0ge307XG4gICAgdXRpbC5vYmplY3RLZXlzKHRoaXMuc2hhcGUpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgaWYgKG1hc2sgJiYgIW1hc2tba2V5XSkge1xuICAgICAgICBuZXdTaGFwZVtrZXldID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZmllbGRTY2hlbWEgPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgIGxldCBuZXdGaWVsZCA9IGZpZWxkU2NoZW1hO1xuICAgICAgICB3aGlsZSAobmV3RmllbGQgaW5zdGFuY2VvZiBab2RPcHRpb25hbCkge1xuICAgICAgICAgIG5ld0ZpZWxkID0gbmV3RmllbGQuX2RlZi5pbm5lclR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgbmV3U2hhcGVba2V5XSA9IG5ld0ZpZWxkO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgX1pvZE9iamVjdCh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBzaGFwZTogKCkgPT4gbmV3U2hhcGVcbiAgICB9KTtcbiAgfVxuICBrZXlvZigpIHtcbiAgICByZXR1cm4gY3JlYXRlWm9kRW51bSh1dGlsLm9iamVjdEtleXModGhpcy5zaGFwZSkpO1xuICB9XG59O1xuWm9kT2JqZWN0LmNyZWF0ZSA9IChzaGFwZSwgcGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICBzaGFwZTogKCkgPT4gc2hhcGUsXG4gICAgdW5rbm93bktleXM6IFwic3RyaXBcIixcbiAgICBjYXRjaGFsbDogWm9kTmV2ZXIuY3JlYXRlKCksXG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufTtcblpvZE9iamVjdC5zdHJpY3RDcmVhdGUgPSAoc2hhcGUsIHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgc2hhcGU6ICgpID0+IHNoYXBlLFxuICAgIHVua25vd25LZXlzOiBcInN0cmljdFwiLFxuICAgIGNhdGNoYWxsOiBab2ROZXZlci5jcmVhdGUoKSxcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xuWm9kT2JqZWN0LmxhenljcmVhdGUgPSAoc2hhcGUsIHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgc2hhcGUsXG4gICAgdW5rbm93bktleXM6IFwic3RyaXBcIixcbiAgICBjYXRjaGFsbDogWm9kTmV2ZXIuY3JlYXRlKCksXG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufTtcbnZhciBab2RVbmlvbiA9IGNsYXNzIGV4dGVuZHMgWm9kVHlwZSB7XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9kZWYub3B0aW9ucztcbiAgICBmdW5jdGlvbiBoYW5kbGVSZXN1bHRzKHJlc3VsdHMpIHtcbiAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICAgICAgaWYgKHJlc3VsdC5yZXN1bHQuc3RhdHVzID09PSBcInZhbGlkXCIpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICBpZiAocmVzdWx0LnJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgIGN0eC5jb21tb24uaXNzdWVzLnB1c2goLi4ucmVzdWx0LmN0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgdW5pb25FcnJvcnMgPSByZXN1bHRzLm1hcCgocmVzdWx0KSA9PiBuZXcgWm9kRXJyb3IocmVzdWx0LmN0eC5jb21tb24uaXNzdWVzKSk7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb24sXG4gICAgICAgIHVuaW9uRXJyb3JzXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKG9wdGlvbnMubWFwKGFzeW5jIChvcHRpb24pID0+IHtcbiAgICAgICAgY29uc3QgY2hpbGRDdHggPSB7XG4gICAgICAgICAgLi4uY3R4LFxuICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgLi4uY3R4LmNvbW1vbixcbiAgICAgICAgICAgIGlzc3VlczogW11cbiAgICAgICAgICB9LFxuICAgICAgICAgIHBhcmVudDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc3VsdDogYXdhaXQgb3B0aW9uLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICBwYXJlbnQ6IGNoaWxkQ3R4XG4gICAgICAgICAgfSksXG4gICAgICAgICAgY3R4OiBjaGlsZEN0eFxuICAgICAgICB9O1xuICAgICAgfSkpLnRoZW4oaGFuZGxlUmVzdWx0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBkaXJ0eSA9IHZvaWQgMDtcbiAgICAgIGNvbnN0IGlzc3VlcyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBvcHRpb24gb2Ygb3B0aW9ucykge1xuICAgICAgICBjb25zdCBjaGlsZEN0eCA9IHtcbiAgICAgICAgICAuLi5jdHgsXG4gICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAuLi5jdHguY29tbW9uLFxuICAgICAgICAgICAgaXNzdWVzOiBbXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcGFyZW50OiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG9wdGlvbi5fcGFyc2VTeW5jKHtcbiAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICBwYXJlbnQ6IGNoaWxkQ3R4XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJ2YWxpZFwiKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIgJiYgIWRpcnR5KSB7XG4gICAgICAgICAgZGlydHkgPSB7IHJlc3VsdCwgY3R4OiBjaGlsZEN0eCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZEN0eC5jb21tb24uaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICAgIGlzc3Vlcy5wdXNoKGNoaWxkQ3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZGlydHkpIHtcbiAgICAgICAgY3R4LmNvbW1vbi5pc3N1ZXMucHVzaCguLi5kaXJ0eS5jdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgIHJldHVybiBkaXJ0eS5yZXN1bHQ7XG4gICAgICB9XG4gICAgICBjb25zdCB1bmlvbkVycm9ycyA9IGlzc3Vlcy5tYXAoKGlzc3VlczIpID0+IG5ldyBab2RFcnJvcihpc3N1ZXMyKSk7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb24sXG4gICAgICAgIHVuaW9uRXJyb3JzXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgfVxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLm9wdGlvbnM7XG4gIH1cbn07XG5ab2RVbmlvbi5jcmVhdGUgPSAodHlwZXMsIHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZFVuaW9uKHtcbiAgICBvcHRpb25zOiB0eXBlcyxcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFVuaW9uLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG52YXIgZ2V0RGlzY3JpbWluYXRvciA9ICh0eXBlKSA9PiB7XG4gIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTGF6eSkge1xuICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUuc2NoZW1hKTtcbiAgfSBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kRWZmZWN0cykge1xuICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUuaW5uZXJUeXBlKCkpO1xuICB9IGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RMaXRlcmFsKSB7XG4gICAgcmV0dXJuIFt0eXBlLnZhbHVlXTtcbiAgfSBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kRW51bSkge1xuICAgIHJldHVybiB0eXBlLm9wdGlvbnM7XG4gIH0gZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZE5hdGl2ZUVudW0pIHtcbiAgICByZXR1cm4gdXRpbC5vYmplY3RWYWx1ZXModHlwZS5lbnVtKTtcbiAgfSBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kRGVmYXVsdCkge1xuICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUuX2RlZi5pbm5lclR5cGUpO1xuICB9IGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RVbmRlZmluZWQpIHtcbiAgICByZXR1cm4gW3ZvaWQgMF07XG4gIH0gZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZE51bGwpIHtcbiAgICByZXR1cm4gW251bGxdO1xuICB9IGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RPcHRpb25hbCkge1xuICAgIHJldHVybiBbdm9pZCAwLCAuLi5nZXREaXNjcmltaW5hdG9yKHR5cGUudW53cmFwKCkpXTtcbiAgfSBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTnVsbGFibGUpIHtcbiAgICByZXR1cm4gW251bGwsIC4uLmdldERpc2NyaW1pbmF0b3IodHlwZS51bndyYXAoKSldO1xuICB9IGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RCcmFuZGVkKSB7XG4gICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS51bndyYXAoKSk7XG4gIH0gZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZFJlYWRvbmx5KSB7XG4gICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS51bndyYXAoKSk7XG4gIH0gZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZENhdGNoKSB7XG4gICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS5fZGVmLmlubmVyVHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59O1xudmFyIFpvZERpc2NyaW1pbmF0ZWRVbmlvbiA9IGNsYXNzIF9ab2REaXNjcmltaW5hdGVkVW5pb24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm9iamVjdCkge1xuICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm9iamVjdCxcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgICBjb25zdCBkaXNjcmltaW5hdG9yID0gdGhpcy5kaXNjcmltaW5hdG9yO1xuICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JWYWx1ZSA9IGN0eC5kYXRhW2Rpc2NyaW1pbmF0b3JdO1xuICAgIGNvbnN0IG9wdGlvbiA9IHRoaXMub3B0aW9uc01hcC5nZXQoZGlzY3JpbWluYXRvclZhbHVlKTtcbiAgICBpZiAoIW9wdGlvbikge1xuICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uX2Rpc2NyaW1pbmF0b3IsXG4gICAgICAgIG9wdGlvbnM6IEFycmF5LmZyb20odGhpcy5vcHRpb25zTWFwLmtleXMoKSksXG4gICAgICAgIHBhdGg6IFtkaXNjcmltaW5hdG9yXVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgIHJldHVybiBvcHRpb24uX3BhcnNlQXN5bmMoe1xuICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgIHBhcmVudDogY3R4XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9wdGlvbi5fcGFyc2VTeW5jKHtcbiAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICBwYXJlbnQ6IGN0eFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGdldCBkaXNjcmltaW5hdG9yKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuZGlzY3JpbWluYXRvcjtcbiAgfVxuICBnZXQgb3B0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLm9wdGlvbnM7XG4gIH1cbiAgZ2V0IG9wdGlvbnNNYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5vcHRpb25zTWFwO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY29uc3RydWN0b3Igb2YgdGhlIGRpc2NyaW1pbmF0ZWQgdW5pb24gc2NoZW1hLiBJdHMgYmVoYXZpb3VyIGlzIHZlcnkgc2ltaWxhciB0byB0aGF0IG9mIHRoZSBub3JtYWwgei51bmlvbigpIGNvbnN0cnVjdG9yLlxuICAgKiBIb3dldmVyLCBpdCBvbmx5IGFsbG93cyBhIHVuaW9uIG9mIG9iamVjdHMsIGFsbCBvZiB3aGljaCBuZWVkIHRvIHNoYXJlIGEgZGlzY3JpbWluYXRvciBwcm9wZXJ0eS4gVGhpcyBwcm9wZXJ0eSBtdXN0XG4gICAqIGhhdmUgYSBkaWZmZXJlbnQgdmFsdWUgZm9yIGVhY2ggb2JqZWN0IGluIHRoZSB1bmlvbi5cbiAgICogQHBhcmFtIGRpc2NyaW1pbmF0b3IgdGhlIG5hbWUgb2YgdGhlIGRpc2NyaW1pbmF0b3IgcHJvcGVydHlcbiAgICogQHBhcmFtIHR5cGVzIGFuIGFycmF5IG9mIG9iamVjdCBzY2hlbWFzXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICovXG4gIHN0YXRpYyBjcmVhdGUoZGlzY3JpbWluYXRvciwgb3B0aW9ucywgcGFyYW1zKSB7XG4gICAgY29uc3Qgb3B0aW9uc01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCB0eXBlIG9mIG9wdGlvbnMpIHtcbiAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JWYWx1ZXMgPSBnZXREaXNjcmltaW5hdG9yKHR5cGUuc2hhcGVbZGlzY3JpbWluYXRvcl0pO1xuICAgICAgaWYgKCFkaXNjcmltaW5hdG9yVmFsdWVzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEgZGlzY3JpbWluYXRvciB2YWx1ZSBmb3Iga2V5IFxcYCR7ZGlzY3JpbWluYXRvcn1cXGAgY291bGQgbm90IGJlIGV4dHJhY3RlZCBmcm9tIGFsbCBzY2hlbWEgb3B0aW9uc2ApO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBkaXNjcmltaW5hdG9yVmFsdWVzKSB7XG4gICAgICAgIGlmIChvcHRpb25zTWFwLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERpc2NyaW1pbmF0b3IgcHJvcGVydHkgJHtTdHJpbmcoZGlzY3JpbWluYXRvcil9IGhhcyBkdXBsaWNhdGUgdmFsdWUgJHtTdHJpbmcodmFsdWUpfWApO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnNNYXAuc2V0KHZhbHVlLCB0eXBlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBfWm9kRGlzY3JpbWluYXRlZFVuaW9uKHtcbiAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRGlzY3JpbWluYXRlZFVuaW9uLFxuICAgICAgZGlzY3JpbWluYXRvcixcbiAgICAgIG9wdGlvbnMsXG4gICAgICBvcHRpb25zTWFwLFxuICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gICAgfSk7XG4gIH1cbn07XG5mdW5jdGlvbiBtZXJnZVZhbHVlcyhhLCBiKSB7XG4gIGNvbnN0IGFUeXBlID0gZ2V0UGFyc2VkVHlwZShhKTtcbiAgY29uc3QgYlR5cGUgPSBnZXRQYXJzZWRUeXBlKGIpO1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBhIH07XG4gIH0gZWxzZSBpZiAoYVR5cGUgPT09IFpvZFBhcnNlZFR5cGUub2JqZWN0ICYmIGJUeXBlID09PSBab2RQYXJzZWRUeXBlLm9iamVjdCkge1xuICAgIGNvbnN0IGJLZXlzID0gdXRpbC5vYmplY3RLZXlzKGIpO1xuICAgIGNvbnN0IHNoYXJlZEtleXMgPSB1dGlsLm9iamVjdEtleXMoYSkuZmlsdGVyKChrZXkpID0+IGJLZXlzLmluZGV4T2Yoa2V5KSAhPT0gLTEpO1xuICAgIGNvbnN0IG5ld09iaiA9IHsgLi4uYSwgLi4uYiB9O1xuICAgIGZvciAoY29uc3Qga2V5IG9mIHNoYXJlZEtleXMpIHtcbiAgICAgIGNvbnN0IHNoYXJlZFZhbHVlID0gbWVyZ2VWYWx1ZXMoYVtrZXldLCBiW2tleV0pO1xuICAgICAgaWYgKCFzaGFyZWRWYWx1ZS52YWxpZCkge1xuICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgICAgIH1cbiAgICAgIG5ld09ialtrZXldID0gc2hhcmVkVmFsdWUuZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IG5ld09iaiB9O1xuICB9IGVsc2UgaWYgKGFUeXBlID09PSBab2RQYXJzZWRUeXBlLmFycmF5ICYmIGJUeXBlID09PSBab2RQYXJzZWRUeXBlLmFycmF5KSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlIH07XG4gICAgfVxuICAgIGNvbnN0IG5ld0FycmF5ID0gW107XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGEubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBjb25zdCBpdGVtQSA9IGFbaW5kZXhdO1xuICAgICAgY29uc3QgaXRlbUIgPSBiW2luZGV4XTtcbiAgICAgIGNvbnN0IHNoYXJlZFZhbHVlID0gbWVyZ2VWYWx1ZXMoaXRlbUEsIGl0ZW1CKTtcbiAgICAgIGlmICghc2hhcmVkVmFsdWUudmFsaWQpIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlIH07XG4gICAgICB9XG4gICAgICBuZXdBcnJheS5wdXNoKHNoYXJlZFZhbHVlLmRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZGF0YTogbmV3QXJyYXkgfTtcbiAgfSBlbHNlIGlmIChhVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5kYXRlICYmIGJUeXBlID09PSBab2RQYXJzZWRUeXBlLmRhdGUgJiYgK2EgPT09ICtiKSB7XG4gICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IGEgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgfVxufVxudmFyIFpvZEludGVyc2VjdGlvbiA9IGNsYXNzIGV4dGVuZHMgWm9kVHlwZSB7XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgY29uc3QgaGFuZGxlUGFyc2VkID0gKHBhcnNlZExlZnQsIHBhcnNlZFJpZ2h0KSA9PiB7XG4gICAgICBpZiAoaXNBYm9ydGVkKHBhcnNlZExlZnQpIHx8IGlzQWJvcnRlZChwYXJzZWRSaWdodCkpIHtcbiAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICB9XG4gICAgICBjb25zdCBtZXJnZWQgPSBtZXJnZVZhbHVlcyhwYXJzZWRMZWZ0LnZhbHVlLCBwYXJzZWRSaWdodC52YWx1ZSk7XG4gICAgICBpZiAoIW1lcmdlZC52YWxpZCkge1xuICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9pbnRlcnNlY3Rpb25fdHlwZXNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGlydHkocGFyc2VkTGVmdCkgfHwgaXNEaXJ0eShwYXJzZWRSaWdodCkpIHtcbiAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IG1lcmdlZC5kYXRhIH07XG4gICAgfTtcbiAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgdGhpcy5fZGVmLmxlZnQuX3BhcnNlQXN5bmMoe1xuICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgIHBhcmVudDogY3R4XG4gICAgICAgIH0pLFxuICAgICAgICB0aGlzLl9kZWYucmlnaHQuX3BhcnNlQXN5bmMoe1xuICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgIHBhcmVudDogY3R4XG4gICAgICAgIH0pXG4gICAgICBdKS50aGVuKChbbGVmdCwgcmlnaHRdKSA9PiBoYW5kbGVQYXJzZWQobGVmdCwgcmlnaHQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGhhbmRsZVBhcnNlZCh0aGlzLl9kZWYubGVmdC5fcGFyc2VTeW5jKHtcbiAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICBwYXJlbnQ6IGN0eFxuICAgICAgfSksIHRoaXMuX2RlZi5yaWdodC5fcGFyc2VTeW5jKHtcbiAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICBwYXJlbnQ6IGN0eFxuICAgICAgfSkpO1xuICAgIH1cbiAgfVxufTtcblpvZEludGVyc2VjdGlvbi5jcmVhdGUgPSAobGVmdCwgcmlnaHQsIHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZEludGVyc2VjdGlvbih7XG4gICAgbGVmdCxcbiAgICByaWdodCxcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEludGVyc2VjdGlvbixcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xudmFyIFpvZFR1cGxlID0gY2xhc3MgX1pvZFR1cGxlIGV4dGVuZHMgWm9kVHlwZSB7XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmFycmF5KSB7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuYXJyYXksXG4gICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgaWYgKGN0eC5kYXRhLmxlbmd0aCA8IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgpIHtcbiAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICBtaW5pbXVtOiB0aGlzLl9kZWYuaXRlbXMubGVuZ3RoLFxuICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgdHlwZTogXCJhcnJheVwiXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgICBjb25zdCByZXN0ID0gdGhpcy5fZGVmLnJlc3Q7XG4gICAgaWYgKCFyZXN0ICYmIGN0eC5kYXRhLmxlbmd0aCA+IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgpIHtcbiAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgbWF4aW11bTogdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCxcbiAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgIHR5cGU6IFwiYXJyYXlcIlxuICAgICAgfSk7XG4gICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICB9XG4gICAgY29uc3QgaXRlbXMgPSBbLi4uY3R4LmRhdGFdLm1hcCgoaXRlbSwgaXRlbUluZGV4KSA9PiB7XG4gICAgICBjb25zdCBzY2hlbWEgPSB0aGlzLl9kZWYuaXRlbXNbaXRlbUluZGV4XSB8fCB0aGlzLl9kZWYucmVzdDtcbiAgICAgIGlmICghc2NoZW1hKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIHJldHVybiBzY2hlbWEuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBpdGVtLCBjdHgucGF0aCwgaXRlbUluZGV4KSk7XG4gICAgfSkuZmlsdGVyKCh4KSA9PiAhIXgpO1xuICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoaXRlbXMpLnRoZW4oKHJlc3VsdHMpID0+IHtcbiAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlQXJyYXkoc3RhdHVzLCByZXN1bHRzKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIGl0ZW1zKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGl0ZW1zKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuaXRlbXM7XG4gIH1cbiAgcmVzdChyZXN0KSB7XG4gICAgcmV0dXJuIG5ldyBfWm9kVHVwbGUoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgcmVzdFxuICAgIH0pO1xuICB9XG59O1xuWm9kVHVwbGUuY3JlYXRlID0gKHNjaGVtYXMsIHBhcmFtcykgPT4ge1xuICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbXVzdCBwYXNzIGFuIGFycmF5IG9mIHNjaGVtYXMgdG8gei50dXBsZShbIC4uLiBdKVwiKTtcbiAgfVxuICByZXR1cm4gbmV3IFpvZFR1cGxlKHtcbiAgICBpdGVtczogc2NoZW1hcyxcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFR1cGxlLFxuICAgIHJlc3Q6IG51bGwsXG4gICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufTtcbnZhciBab2RSZWNvcmQgPSBjbGFzcyBfWm9kUmVjb3JkIGV4dGVuZHMgWm9kVHlwZSB7XG4gIGdldCBrZXlTY2hlbWEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5rZXlUeXBlO1xuICB9XG4gIGdldCB2YWx1ZVNjaGVtYSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgfVxuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5vYmplY3QsXG4gICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgY29uc3QgcGFpcnMgPSBbXTtcbiAgICBjb25zdCBrZXlUeXBlID0gdGhpcy5fZGVmLmtleVR5cGU7XG4gICAgY29uc3QgdmFsdWVUeXBlID0gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBjdHguZGF0YSkge1xuICAgICAgcGFpcnMucHVzaCh7XG4gICAgICAgIGtleToga2V5VHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGtleSwgY3R4LnBhdGgsIGtleSkpLFxuICAgICAgICB2YWx1ZTogdmFsdWVUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgY3R4LmRhdGFba2V5XSwgY3R4LnBhdGgsIGtleSkpLFxuICAgICAgICBhbHdheXNTZXQ6IGtleSBpbiBjdHguZGF0YVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RBc3luYyhzdGF0dXMsIHBhaXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHBhaXJzKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZShmaXJzdCwgc2Vjb25kLCB0aGlyZCkge1xuICAgIGlmIChzZWNvbmQgaW5zdGFuY2VvZiBab2RUeXBlKSB7XG4gICAgICByZXR1cm4gbmV3IF9ab2RSZWNvcmQoe1xuICAgICAgICBrZXlUeXBlOiBmaXJzdCxcbiAgICAgICAgdmFsdWVUeXBlOiBzZWNvbmQsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUmVjb3JkLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXJkKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgX1pvZFJlY29yZCh7XG4gICAgICBrZXlUeXBlOiBab2RTdHJpbmcuY3JlYXRlKCksXG4gICAgICB2YWx1ZVR5cGU6IGZpcnN0LFxuICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RSZWNvcmQsXG4gICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHNlY29uZClcbiAgICB9KTtcbiAgfVxufTtcbnZhciBab2RNYXAgPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xuICBnZXQga2V5U2NoZW1hKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYua2V5VHlwZTtcbiAgfVxuICBnZXQgdmFsdWVTY2hlbWEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gIH1cbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubWFwKSB7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubWFwLFxuICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIGNvbnN0IGtleVR5cGUgPSB0aGlzLl9kZWYua2V5VHlwZTtcbiAgICBjb25zdCB2YWx1ZVR5cGUgPSB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgIGNvbnN0IHBhaXJzID0gWy4uLmN0eC5kYXRhLmVudHJpZXMoKV0ubWFwKChba2V5LCB2YWx1ZV0sIGluZGV4KSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBrZXk6IGtleVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBrZXksIGN0eC5wYXRoLCBbaW5kZXgsIFwia2V5XCJdKSksXG4gICAgICAgIHZhbHVlOiB2YWx1ZVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIFtpbmRleCwgXCJ2YWx1ZVwiXSkpXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICBjb25zdCBmaW5hbE1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihhc3luYyAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IHBhaXIua2V5O1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgcGFpci52YWx1ZTtcbiAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImFib3J0ZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImRpcnR5XCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmaW5hbE1hcC5zZXQoa2V5LnZhbHVlLCB2YWx1ZS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBmaW5hbE1hcCB9O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZpbmFsTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICBjb25zdCBrZXkgPSBwYWlyLmtleTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwYWlyLnZhbHVlO1xuICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImFib3J0ZWRcIikge1xuICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImRpcnR5XCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbE1hcC5zZXQoa2V5LnZhbHVlLCB2YWx1ZS52YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGZpbmFsTWFwIH07XG4gICAgfVxuICB9XG59O1xuWm9kTWFwLmNyZWF0ZSA9IChrZXlUeXBlLCB2YWx1ZVR5cGUsIHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZE1hcCh7XG4gICAgdmFsdWVUeXBlLFxuICAgIGtleVR5cGUsXG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RNYXAsXG4gICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufTtcbnZhciBab2RTZXQgPSBjbGFzcyBfWm9kU2V0IGV4dGVuZHMgWm9kVHlwZSB7XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnNldCkge1xuICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnNldCxcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgICBjb25zdCBkZWYgPSB0aGlzLl9kZWY7XG4gICAgaWYgKGRlZi5taW5TaXplICE9PSBudWxsKSB7XG4gICAgICBpZiAoY3R4LmRhdGEuc2l6ZSA8IGRlZi5taW5TaXplLnZhbHVlKSB7XG4gICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgbWluaW11bTogZGVmLm1pblNpemUudmFsdWUsXG4gICAgICAgICAgdHlwZTogXCJzZXRcIixcbiAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgIG1lc3NhZ2U6IGRlZi5taW5TaXplLm1lc3NhZ2VcbiAgICAgICAgfSk7XG4gICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVmLm1heFNpemUgIT09IG51bGwpIHtcbiAgICAgIGlmIChjdHguZGF0YS5zaXplID4gZGVmLm1heFNpemUudmFsdWUpIHtcbiAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgbWF4aW11bTogZGVmLm1heFNpemUudmFsdWUsXG4gICAgICAgICAgdHlwZTogXCJzZXRcIixcbiAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgIG1lc3NhZ2U6IGRlZi5tYXhTaXplLm1lc3NhZ2VcbiAgICAgICAgfSk7XG4gICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB2YWx1ZVR5cGUgPSB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgIGZ1bmN0aW9uIGZpbmFsaXplU2V0KGVsZW1lbnRzMikge1xuICAgICAgY29uc3QgcGFyc2VkU2V0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50czIpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgaWYgKGVsZW1lbnQuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIHBhcnNlZFNldC5hZGQoZWxlbWVudC52YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IHBhcnNlZFNldCB9O1xuICAgIH1cbiAgICBjb25zdCBlbGVtZW50cyA9IFsuLi5jdHguZGF0YS52YWx1ZXMoKV0ubWFwKChpdGVtLCBpKSA9PiB2YWx1ZVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBpdGVtLCBjdHgucGF0aCwgaSkpKTtcbiAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGVsZW1lbnRzKS50aGVuKChlbGVtZW50czIpID0+IGZpbmFsaXplU2V0KGVsZW1lbnRzMikpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmluYWxpemVTZXQoZWxlbWVudHMpO1xuICAgIH1cbiAgfVxuICBtaW4obWluU2l6ZSwgbWVzc2FnZSkge1xuICAgIHJldHVybiBuZXcgX1pvZFNldCh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBtaW5TaXplOiB7IHZhbHVlOiBtaW5TaXplLCBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfVxuICAgIH0pO1xuICB9XG4gIG1heChtYXhTaXplLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG5ldyBfWm9kU2V0KHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIG1heFNpemU6IHsgdmFsdWU6IG1heFNpemUsIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9XG4gICAgfSk7XG4gIH1cbiAgc2l6ZShzaXplLCBtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMubWluKHNpemUsIG1lc3NhZ2UpLm1heChzaXplLCBtZXNzYWdlKTtcbiAgfVxuICBub25lbXB0eShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMubWluKDEsIG1lc3NhZ2UpO1xuICB9XG59O1xuWm9kU2V0LmNyZWF0ZSA9ICh2YWx1ZVR5cGUsIHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZFNldCh7XG4gICAgdmFsdWVUeXBlLFxuICAgIG1pblNpemU6IG51bGwsXG4gICAgbWF4U2l6ZTogbnVsbCxcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFNldCxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xudmFyIFpvZEZ1bmN0aW9uID0gY2xhc3MgX1pvZEZ1bmN0aW9uIGV4dGVuZHMgWm9kVHlwZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy52YWxpZGF0ZSA9IHRoaXMuaW1wbGVtZW50O1xuICB9XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5mdW5jdGlvbikge1xuICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmZ1bmN0aW9uLFxuICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VBcmdzSXNzdWUoYXJncywgZXJyb3IpIHtcbiAgICAgIHJldHVybiBtYWtlSXNzdWUoe1xuICAgICAgICBkYXRhOiBhcmdzLFxuICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgZXJyb3JNYXBzOiBbXG4gICAgICAgICAgY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsXG4gICAgICAgICAgY3R4LnNjaGVtYUVycm9yTWFwLFxuICAgICAgICAgIGdldEVycm9yTWFwKCksXG4gICAgICAgICAgZXJyb3JNYXBcbiAgICAgICAgXS5maWx0ZXIoKHgpID0+ICEheCksXG4gICAgICAgIGlzc3VlRGF0YToge1xuICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2FyZ3VtZW50cyxcbiAgICAgICAgICBhcmd1bWVudHNFcnJvcjogZXJyb3JcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VSZXR1cm5zSXNzdWUocmV0dXJucywgZXJyb3IpIHtcbiAgICAgIHJldHVybiBtYWtlSXNzdWUoe1xuICAgICAgICBkYXRhOiByZXR1cm5zLFxuICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgZXJyb3JNYXBzOiBbXG4gICAgICAgICAgY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsXG4gICAgICAgICAgY3R4LnNjaGVtYUVycm9yTWFwLFxuICAgICAgICAgIGdldEVycm9yTWFwKCksXG4gICAgICAgICAgZXJyb3JNYXBcbiAgICAgICAgXS5maWx0ZXIoKHgpID0+ICEheCksXG4gICAgICAgIGlzc3VlRGF0YToge1xuICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3JldHVybl90eXBlLFxuICAgICAgICAgIHJldHVyblR5cGVFcnJvcjogZXJyb3JcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHBhcmFtcyA9IHsgZXJyb3JNYXA6IGN0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwIH07XG4gICAgY29uc3QgZm4gPSBjdHguZGF0YTtcbiAgICBpZiAodGhpcy5fZGVmLnJldHVybnMgaW5zdGFuY2VvZiBab2RQcm9taXNlKSB7XG4gICAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgICByZXR1cm4gT0soYXN5bmMgZnVuY3Rpb24oLi4uYXJncykge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBab2RFcnJvcihbXSk7XG4gICAgICAgIGNvbnN0IHBhcnNlZEFyZ3MgPSBhd2FpdCBtZS5fZGVmLmFyZ3MucGFyc2VBc3luYyhhcmdzLCBwYXJhbXMpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgZXJyb3IuYWRkSXNzdWUobWFrZUFyZ3NJc3N1ZShhcmdzLCBlKSk7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBSZWZsZWN0LmFwcGx5KGZuLCB0aGlzLCBwYXJzZWRBcmdzKTtcbiAgICAgICAgY29uc3QgcGFyc2VkUmV0dXJucyA9IGF3YWl0IG1lLl9kZWYucmV0dXJucy5fZGVmLnR5cGUucGFyc2VBc3luYyhyZXN1bHQsIHBhcmFtcykuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICBlcnJvci5hZGRJc3N1ZShtYWtlUmV0dXJuc0lzc3VlKHJlc3VsdCwgZSkpO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBhcnNlZFJldHVybnM7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbWUgPSB0aGlzO1xuICAgICAgcmV0dXJuIE9LKGZ1bmN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkQXJncyA9IG1lLl9kZWYuYXJncy5zYWZlUGFyc2UoYXJncywgcGFyYW1zKTtcbiAgICAgICAgaWYgKCFwYXJzZWRBcmdzLnN1Y2Nlc3MpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgWm9kRXJyb3IoW21ha2VBcmdzSXNzdWUoYXJncywgcGFyc2VkQXJncy5lcnJvcildKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LmFwcGx5KGZuLCB0aGlzLCBwYXJzZWRBcmdzLmRhdGEpO1xuICAgICAgICBjb25zdCBwYXJzZWRSZXR1cm5zID0gbWUuX2RlZi5yZXR1cm5zLnNhZmVQYXJzZShyZXN1bHQsIHBhcmFtcyk7XG4gICAgICAgIGlmICghcGFyc2VkUmV0dXJucy5zdWNjZXNzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFpvZEVycm9yKFttYWtlUmV0dXJuc0lzc3VlKHJlc3VsdCwgcGFyc2VkUmV0dXJucy5lcnJvcildKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VkUmV0dXJucy5kYXRhO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHBhcmFtZXRlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5hcmdzO1xuICB9XG4gIHJldHVyblR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5yZXR1cm5zO1xuICB9XG4gIGFyZ3MoLi4uaXRlbXMpIHtcbiAgICByZXR1cm4gbmV3IF9ab2RGdW5jdGlvbih7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBhcmdzOiBab2RUdXBsZS5jcmVhdGUoaXRlbXMpLnJlc3QoWm9kVW5rbm93bi5jcmVhdGUoKSlcbiAgICB9KTtcbiAgfVxuICByZXR1cm5zKHJldHVyblR5cGUpIHtcbiAgICByZXR1cm4gbmV3IF9ab2RGdW5jdGlvbih7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICByZXR1cm5zOiByZXR1cm5UeXBlXG4gICAgfSk7XG4gIH1cbiAgaW1wbGVtZW50KGZ1bmMpIHtcbiAgICBjb25zdCB2YWxpZGF0ZWRGdW5jID0gdGhpcy5wYXJzZShmdW5jKTtcbiAgICByZXR1cm4gdmFsaWRhdGVkRnVuYztcbiAgfVxuICBzdHJpY3RJbXBsZW1lbnQoZnVuYykge1xuICAgIGNvbnN0IHZhbGlkYXRlZEZ1bmMgPSB0aGlzLnBhcnNlKGZ1bmMpO1xuICAgIHJldHVybiB2YWxpZGF0ZWRGdW5jO1xuICB9XG4gIHN0YXRpYyBjcmVhdGUoYXJncywgcmV0dXJucywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBfWm9kRnVuY3Rpb24oe1xuICAgICAgYXJnczogYXJncyA/IGFyZ3MgOiBab2RUdXBsZS5jcmVhdGUoW10pLnJlc3QoWm9kVW5rbm93bi5jcmVhdGUoKSksXG4gICAgICByZXR1cm5zOiByZXR1cm5zIHx8IFpvZFVua25vd24uY3JlYXRlKCksXG4gICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEZ1bmN0aW9uLFxuICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gICAgfSk7XG4gIH1cbn07XG52YXIgWm9kTGF6eSA9IGNsYXNzIGV4dGVuZHMgWm9kVHlwZSB7XG4gIGdldCBzY2hlbWEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5nZXR0ZXIoKTtcbiAgfVxuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICBjb25zdCBsYXp5U2NoZW1hID0gdGhpcy5fZGVmLmdldHRlcigpO1xuICAgIHJldHVybiBsYXp5U2NoZW1hLl9wYXJzZSh7IGRhdGE6IGN0eC5kYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSk7XG4gIH1cbn07XG5ab2RMYXp5LmNyZWF0ZSA9IChnZXR0ZXIsIHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZExhenkoe1xuICAgIGdldHRlcixcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZExhenksXG4gICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufTtcbnZhciBab2RMaXRlcmFsID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgaWYgKGlucHV0LmRhdGEgIT09IHRoaXMuX2RlZi52YWx1ZSkge1xuICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIHJlY2VpdmVkOiBjdHguZGF0YSxcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfbGl0ZXJhbCxcbiAgICAgICAgZXhwZWN0ZWQ6IHRoaXMuX2RlZi52YWx1ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gIH1cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWU7XG4gIH1cbn07XG5ab2RMaXRlcmFsLmNyZWF0ZSA9ICh2YWx1ZSwgcGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kTGl0ZXJhbCh7XG4gICAgdmFsdWUsXG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RMaXRlcmFsLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG5mdW5jdGlvbiBjcmVhdGVab2RFbnVtKHZhbHVlcywgcGFyYW1zKSB7XG4gIHJldHVybiBuZXcgWm9kRW51bSh7XG4gICAgdmFsdWVzLFxuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRW51bSxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59XG52YXIgWm9kRW51bSA9IGNsYXNzIF9ab2RFbnVtIGV4dGVuZHMgWm9kVHlwZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgX1pvZEVudW1fY2FjaGUuc2V0KHRoaXMsIHZvaWQgMCk7XG4gIH1cbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dC5kYXRhICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICBjb25zdCBleHBlY3RlZFZhbHVlcyA9IHRoaXMuX2RlZi52YWx1ZXM7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgZXhwZWN0ZWQ6IHV0aWwuam9pblZhbHVlcyhleHBlY3RlZFZhbHVlcyksXG4gICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9ab2RFbnVtX2NhY2hlLCBcImZcIikpIHtcbiAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1pvZEVudW1fY2FjaGUsIG5ldyBTZXQodGhpcy5fZGVmLnZhbHVlcyksIFwiZlwiKTtcbiAgICB9XG4gICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9ab2RFbnVtX2NhY2hlLCBcImZcIikuaGFzKGlucHV0LmRhdGEpKSB7XG4gICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICBjb25zdCBleHBlY3RlZFZhbHVlcyA9IHRoaXMuX2RlZi52YWx1ZXM7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eC5kYXRhLFxuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9lbnVtX3ZhbHVlLFxuICAgICAgICBvcHRpb25zOiBleHBlY3RlZFZhbHVlc1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICB9XG4gIGdldCBvcHRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVzO1xuICB9XG4gIGdldCBlbnVtKCkge1xuICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHZhbCBvZiB0aGlzLl9kZWYudmFsdWVzKSB7XG4gICAgICBlbnVtVmFsdWVzW3ZhbF0gPSB2YWw7XG4gICAgfVxuICAgIHJldHVybiBlbnVtVmFsdWVzO1xuICB9XG4gIGdldCBWYWx1ZXMoKSB7XG4gICAgY29uc3QgZW51bVZhbHVlcyA9IHt9O1xuICAgIGZvciAoY29uc3QgdmFsIG9mIHRoaXMuX2RlZi52YWx1ZXMpIHtcbiAgICAgIGVudW1WYWx1ZXNbdmFsXSA9IHZhbDtcbiAgICB9XG4gICAgcmV0dXJuIGVudW1WYWx1ZXM7XG4gIH1cbiAgZ2V0IEVudW0oKSB7XG4gICAgY29uc3QgZW51bVZhbHVlcyA9IHt9O1xuICAgIGZvciAoY29uc3QgdmFsIG9mIHRoaXMuX2RlZi52YWx1ZXMpIHtcbiAgICAgIGVudW1WYWx1ZXNbdmFsXSA9IHZhbDtcbiAgICB9XG4gICAgcmV0dXJuIGVudW1WYWx1ZXM7XG4gIH1cbiAgZXh0cmFjdCh2YWx1ZXMsIG5ld0RlZiA9IHRoaXMuX2RlZikge1xuICAgIHJldHVybiBfWm9kRW51bS5jcmVhdGUodmFsdWVzLCB7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAuLi5uZXdEZWZcbiAgICB9KTtcbiAgfVxuICBleGNsdWRlKHZhbHVlcywgbmV3RGVmID0gdGhpcy5fZGVmKSB7XG4gICAgcmV0dXJuIF9ab2RFbnVtLmNyZWF0ZSh0aGlzLm9wdGlvbnMuZmlsdGVyKChvcHQpID0+ICF2YWx1ZXMuaW5jbHVkZXMob3B0KSksIHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIC4uLm5ld0RlZlxuICAgIH0pO1xuICB9XG59O1xuX1pvZEVudW1fY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcblpvZEVudW0uY3JlYXRlID0gY3JlYXRlWm9kRW51bTtcbnZhciBab2ROYXRpdmVFbnVtID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICBfWm9kTmF0aXZlRW51bV9jYWNoZS5zZXQodGhpcywgdm9pZCAwKTtcbiAgfVxuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCBuYXRpdmVFbnVtVmFsdWVzID0gdXRpbC5nZXRWYWxpZEVudW1WYWx1ZXModGhpcy5fZGVmLnZhbHVlcyk7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5zdHJpbmcgJiYgY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubnVtYmVyKSB7XG4gICAgICBjb25zdCBleHBlY3RlZFZhbHVlcyA9IHV0aWwub2JqZWN0VmFsdWVzKG5hdGl2ZUVudW1WYWx1ZXMpO1xuICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIGV4cGVjdGVkOiB1dGlsLmpvaW5WYWx1ZXMoZXhwZWN0ZWRWYWx1ZXMpLFxuICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfWm9kTmF0aXZlRW51bV9jYWNoZSwgXCJmXCIpKSB7XG4gICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9ab2ROYXRpdmVFbnVtX2NhY2hlLCBuZXcgU2V0KHV0aWwuZ2V0VmFsaWRFbnVtVmFsdWVzKHRoaXMuX2RlZi52YWx1ZXMpKSwgXCJmXCIpO1xuICAgIH1cbiAgICBpZiAoIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1pvZE5hdGl2ZUVudW1fY2FjaGUsIFwiZlwiKS5oYXMoaW5wdXQuZGF0YSkpIHtcbiAgICAgIGNvbnN0IGV4cGVjdGVkVmFsdWVzID0gdXRpbC5vYmplY3RWYWx1ZXMobmF0aXZlRW51bVZhbHVlcyk7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eC5kYXRhLFxuICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9lbnVtX3ZhbHVlLFxuICAgICAgICBvcHRpb25zOiBleHBlY3RlZFZhbHVlc1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICB9XG4gIGdldCBlbnVtKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVzO1xuICB9XG59O1xuX1pvZE5hdGl2ZUVudW1fY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcblpvZE5hdGl2ZUVudW0uY3JlYXRlID0gKHZhbHVlcywgcGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kTmF0aXZlRW51bSh7XG4gICAgdmFsdWVzLFxuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTmF0aXZlRW51bSxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xudmFyIFpvZFByb21pc2UgPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xuICB1bndyYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi50eXBlO1xuICB9XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5wcm9taXNlICYmIGN0eC5jb21tb24uYXN5bmMgPT09IGZhbHNlKSB7XG4gICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUucHJvbWlzZSxcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgICBjb25zdCBwcm9taXNpZmllZCA9IGN0eC5wYXJzZWRUeXBlID09PSBab2RQYXJzZWRUeXBlLnByb21pc2UgPyBjdHguZGF0YSA6IFByb21pc2UucmVzb2x2ZShjdHguZGF0YSk7XG4gICAgcmV0dXJuIE9LKHByb21pc2lmaWVkLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZS5wYXJzZUFzeW5jKGRhdGEsIHtcbiAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgIGVycm9yTWFwOiBjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcFxuICAgICAgfSk7XG4gICAgfSkpO1xuICB9XG59O1xuWm9kUHJvbWlzZS5jcmVhdGUgPSAoc2NoZW1hLCBwYXJhbXMpID0+IHtcbiAgcmV0dXJuIG5ldyBab2RQcm9taXNlKHtcbiAgICB0eXBlOiBzY2hlbWEsXG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RQcm9taXNlLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG52YXIgWm9kRWZmZWN0cyA9IGNsYXNzIGV4dGVuZHMgWm9kVHlwZSB7XG4gIGlubmVyVHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYTtcbiAgfVxuICBzb3VyY2VUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hLl9kZWYudHlwZU5hbWUgPT09IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzID8gdGhpcy5fZGVmLnNjaGVtYS5zb3VyY2VUeXBlKCkgOiB0aGlzLl9kZWYuc2NoZW1hO1xuICB9XG4gIF9wYXJzZShpbnB1dCkge1xuICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgY29uc3QgZWZmZWN0ID0gdGhpcy5fZGVmLmVmZmVjdCB8fCBudWxsO1xuICAgIGNvbnN0IGNoZWNrQ3R4ID0ge1xuICAgICAgYWRkSXNzdWU6IChhcmcpID0+IHtcbiAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCBhcmcpO1xuICAgICAgICBpZiAoYXJnLmZhdGFsKSB7XG4gICAgICAgICAgc3RhdHVzLmFib3J0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBnZXQgcGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIGN0eC5wYXRoO1xuICAgICAgfVxuICAgIH07XG4gICAgY2hlY2tDdHguYWRkSXNzdWUgPSBjaGVja0N0eC5hZGRJc3N1ZS5iaW5kKGNoZWNrQ3R4KTtcbiAgICBpZiAoZWZmZWN0LnR5cGUgPT09IFwicHJlcHJvY2Vzc1wiKSB7XG4gICAgICBjb25zdCBwcm9jZXNzZWQgPSBlZmZlY3QudHJhbnNmb3JtKGN0eC5kYXRhLCBjaGVja0N0eCk7XG4gICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHByb2Nlc3NlZCkudGhlbihhc3luYyAocHJvY2Vzc2VkMikgPT4ge1xuICAgICAgICAgIGlmIChzdGF0dXMudmFsdWUgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICBkYXRhOiBwcm9jZXNzZWQyLFxuICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICBwYXJlbnQ6IGN0eFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICByZXR1cm4gRElSVFkocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICBpZiAoc3RhdHVzLnZhbHVlID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICByZXR1cm4gRElSVFkocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChzdGF0dXMudmFsdWUgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZVN5bmMoe1xuICAgICAgICAgIGRhdGE6IHByb2Nlc3NlZCxcbiAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICBwYXJlbnQ6IGN0eFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgIHJldHVybiBESVJUWShyZXN1bHQudmFsdWUpO1xuICAgICAgICBpZiAoc3RhdHVzLnZhbHVlID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgcmV0dXJuIERJUlRZKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlZmZlY3QudHlwZSA9PT0gXCJyZWZpbmVtZW50XCIpIHtcbiAgICAgIGNvbnN0IGV4ZWN1dGVSZWZpbmVtZW50ID0gKGFjYykgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBlZmZlY3QucmVmaW5lbWVudChhY2MsIGNoZWNrQ3R4KTtcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBc3luYyByZWZpbmVtZW50IGVuY291bnRlcmVkIGR1cmluZyBzeW5jaHJvbm91cyBwYXJzZSBvcGVyYXRpb24uIFVzZSAucGFyc2VBc3luYyBpbnN0ZWFkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgfTtcbiAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jID09PSBmYWxzZSkge1xuICAgICAgICBjb25zdCBpbm5lciA9IHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlU3luYyh7XG4gICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgcGFyZW50OiBjdHhcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpbm5lci5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIGV4ZWN1dGVSZWZpbmVtZW50KGlubmVyLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBpbm5lci52YWx1ZSB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlQXN5bmMoeyBkYXRhOiBjdHguZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pLnRoZW4oKGlubmVyKSA9PiB7XG4gICAgICAgICAgaWYgKGlubmVyLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICByZXR1cm4gZXhlY3V0ZVJlZmluZW1lbnQoaW5uZXIudmFsdWUpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBpbm5lci52YWx1ZSB9O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVmZmVjdC50eXBlID09PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgYmFzZSA9IHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlU3luYyh7XG4gICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgcGFyZW50OiBjdHhcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghaXNWYWxpZChiYXNlKSlcbiAgICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZWZmZWN0LnRyYW5zZm9ybShiYXNlLnZhbHVlLCBjaGVja0N0eCk7XG4gICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBc3luY2hyb25vdXMgdHJhbnNmb3JtIGVuY291bnRlcmVkIGR1cmluZyBzeW5jaHJvbm91cyBwYXJzZSBvcGVyYXRpb24uIFVzZSAucGFyc2VBc3luYyBpbnN0ZWFkLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogcmVzdWx0IH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VBc3luYyh7IGRhdGE6IGN0eC5kYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSkudGhlbigoYmFzZSkgPT4ge1xuICAgICAgICAgIGlmICghaXNWYWxpZChiYXNlKSlcbiAgICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZWZmZWN0LnRyYW5zZm9ybShiYXNlLnZhbHVlLCBjaGVja0N0eCkpLnRoZW4oKHJlc3VsdCkgPT4gKHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiByZXN1bHQgfSkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdXRpbC5hc3NlcnROZXZlcihlZmZlY3QpO1xuICB9XG59O1xuWm9kRWZmZWN0cy5jcmVhdGUgPSAoc2NoZW1hLCBlZmZlY3QsIHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xuICAgIHNjaGVtYSxcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXG4gICAgZWZmZWN0LFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG5ab2RFZmZlY3RzLmNyZWF0ZVdpdGhQcmVwcm9jZXNzID0gKHByZXByb2Nlc3MsIHNjaGVtYSwgcGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kRWZmZWN0cyh7XG4gICAgc2NoZW1hLFxuICAgIGVmZmVjdDogeyB0eXBlOiBcInByZXByb2Nlc3NcIiwgdHJhbnNmb3JtOiBwcmVwcm9jZXNzIH0sXG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG52YXIgWm9kT3B0aW9uYWwgPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgaWYgKHBhcnNlZFR5cGUgPT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gT0sodm9pZCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKGlucHV0KTtcbiAgfVxuICB1bndyYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XG4gIH1cbn07XG5ab2RPcHRpb25hbC5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kT3B0aW9uYWwoe1xuICAgIGlubmVyVHlwZTogdHlwZSxcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9wdGlvbmFsLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG52YXIgWm9kTnVsbGFibGUgPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgaWYgKHBhcnNlZFR5cGUgPT09IFpvZFBhcnNlZFR5cGUubnVsbCkge1xuICAgICAgcmV0dXJuIE9LKG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoaW5wdXQpO1xuICB9XG4gIHVud3JhcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgfVxufTtcblpvZE51bGxhYmxlLmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcbiAgcmV0dXJuIG5ldyBab2ROdWxsYWJsZSh7XG4gICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTnVsbGFibGUsXG4gICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpXG4gIH0pO1xufTtcbnZhciBab2REZWZhdWx0ID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgbGV0IGRhdGEgPSBjdHguZGF0YTtcbiAgICBpZiAoY3R4LnBhcnNlZFR5cGUgPT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICBkYXRhID0gdGhpcy5fZGVmLmRlZmF1bHRWYWx1ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2Uoe1xuICAgICAgZGF0YSxcbiAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgcGFyZW50OiBjdHhcbiAgICB9KTtcbiAgfVxuICByZW1vdmVEZWZhdWx0KCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICB9XG59O1xuWm9kRGVmYXVsdC5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kRGVmYXVsdCh7XG4gICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRGVmYXVsdCxcbiAgICBkZWZhdWx0VmFsdWU6IHR5cGVvZiBwYXJhbXMuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiID8gcGFyYW1zLmRlZmF1bHQgOiAoKSA9PiBwYXJhbXMuZGVmYXVsdCxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xudmFyIFpvZENhdGNoID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgY29uc3QgbmV3Q3R4ID0ge1xuICAgICAgLi4uY3R4LFxuICAgICAgY29tbW9uOiB7XG4gICAgICAgIC4uLmN0eC5jb21tb24sXG4gICAgICAgIGlzc3VlczogW11cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKHtcbiAgICAgIGRhdGE6IG5ld0N0eC5kYXRhLFxuICAgICAgcGF0aDogbmV3Q3R4LnBhdGgsXG4gICAgICBwYXJlbnQ6IHtcbiAgICAgICAgLi4ubmV3Q3R4XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGlzQXN5bmMocmVzdWx0KSkge1xuICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChyZXN1bHQyKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3RhdHVzOiBcInZhbGlkXCIsXG4gICAgICAgICAgdmFsdWU6IHJlc3VsdDIuc3RhdHVzID09PSBcInZhbGlkXCIgPyByZXN1bHQyLnZhbHVlIDogdGhpcy5fZGVmLmNhdGNoVmFsdWUoe1xuICAgICAgICAgICAgZ2V0IGVycm9yKCkge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IFpvZEVycm9yKG5ld0N0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbnB1dDogbmV3Q3R4LmRhdGFcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YXR1czogXCJ2YWxpZFwiLFxuICAgICAgICB2YWx1ZTogcmVzdWx0LnN0YXR1cyA9PT0gXCJ2YWxpZFwiID8gcmVzdWx0LnZhbHVlIDogdGhpcy5fZGVmLmNhdGNoVmFsdWUoe1xuICAgICAgICAgIGdldCBlcnJvcigpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgWm9kRXJyb3IobmV3Q3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgaW5wdXQ6IG5ld0N0eC5kYXRhXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICByZW1vdmVDYXRjaCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgfVxufTtcblpvZENhdGNoLmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcbiAgcmV0dXJuIG5ldyBab2RDYXRjaCh7XG4gICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQ2F0Y2gsXG4gICAgY2F0Y2hWYWx1ZTogdHlwZW9mIHBhcmFtcy5jYXRjaCA9PT0gXCJmdW5jdGlvblwiID8gcGFyYW1zLmNhdGNoIDogKCkgPT4gcGFyYW1zLmNhdGNoLFxuICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKVxuICB9KTtcbn07XG52YXIgWm9kTmFOID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm5hbikge1xuICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm5hbixcbiAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgICByZXR1cm4geyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgfVxufTtcblpvZE5hTi5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gIHJldHVybiBuZXcgWm9kTmFOKHtcbiAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE5hTixcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xudmFyIEJSQU5EID0gU3ltYm9sKFwiem9kX2JyYW5kXCIpO1xudmFyIFpvZEJyYW5kZWQgPSBjbGFzcyBleHRlbmRzIFpvZFR5cGUge1xuICBfcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICBjb25zdCBkYXRhID0gY3R4LmRhdGE7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi50eXBlLl9wYXJzZSh7XG4gICAgICBkYXRhLFxuICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICBwYXJlbnQ6IGN0eFxuICAgIH0pO1xuICB9XG4gIHVud3JhcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGU7XG4gIH1cbn07XG52YXIgWm9kUGlwZWxpbmUgPSBjbGFzcyBfWm9kUGlwZWxpbmUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgY29uc3QgaGFuZGxlQXN5bmMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGluUmVzdWx0ID0gYXdhaXQgdGhpcy5fZGVmLmluLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICBwYXJlbnQ6IGN0eFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGluUmVzdWx0LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIGlmIChpblJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgIHJldHVybiBESVJUWShpblJlc3VsdC52YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5vdXQuX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgZGF0YTogaW5SZXN1bHQudmFsdWUsXG4gICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgIHBhcmVudDogY3R4XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gaGFuZGxlQXN5bmMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaW5SZXN1bHQgPSB0aGlzLl9kZWYuaW4uX3BhcnNlU3luYyh7XG4gICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgcGFyZW50OiBjdHhcbiAgICAgIH0pO1xuICAgICAgaWYgKGluUmVzdWx0LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgaWYgKGluUmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSB7XG4gICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN0YXR1czogXCJkaXJ0eVwiLFxuICAgICAgICAgIHZhbHVlOiBpblJlc3VsdC52YWx1ZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5vdXQuX3BhcnNlU3luYyh7XG4gICAgICAgICAgZGF0YTogaW5SZXN1bHQudmFsdWUsXG4gICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgcGFyZW50OiBjdHhcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHN0YXRpYyBjcmVhdGUoYSwgYikge1xuICAgIHJldHVybiBuZXcgX1pvZFBpcGVsaW5lKHtcbiAgICAgIGluOiBhLFxuICAgICAgb3V0OiBiLFxuICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RQaXBlbGluZVxuICAgIH0pO1xuICB9XG59O1xudmFyIFpvZFJlYWRvbmx5ID0gY2xhc3MgZXh0ZW5kcyBab2RUeXBlIHtcbiAgX3BhcnNlKGlucHV0KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoaW5wdXQpO1xuICAgIGNvbnN0IGZyZWV6ZSA9IChkYXRhKSA9PiB7XG4gICAgICBpZiAoaXNWYWxpZChkYXRhKSkge1xuICAgICAgICBkYXRhLnZhbHVlID0gT2JqZWN0LmZyZWV6ZShkYXRhLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG4gICAgcmV0dXJuIGlzQXN5bmMocmVzdWx0KSA/IHJlc3VsdC50aGVuKChkYXRhKSA9PiBmcmVlemUoZGF0YSkpIDogZnJlZXplKHJlc3VsdCk7XG4gIH1cbiAgdW53cmFwKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICB9XG59O1xuWm9kUmVhZG9ubHkuY3JlYXRlID0gKHR5cGUsIHBhcmFtcykgPT4ge1xuICByZXR1cm4gbmV3IFpvZFJlYWRvbmx5KHtcbiAgICBpbm5lclR5cGU6IHR5cGUsXG4gICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RSZWFkb25seSxcbiAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcylcbiAgfSk7XG59O1xuZnVuY3Rpb24gY3VzdG9tKGNoZWNrLCBwYXJhbXMgPSB7fSwgZmF0YWwpIHtcbiAgaWYgKGNoZWNrKVxuICAgIHJldHVybiBab2RBbnkuY3JlYXRlKCkuc3VwZXJSZWZpbmUoKGRhdGEsIGN0eCkgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGlmICghY2hlY2soZGF0YSkpIHtcbiAgICAgICAgY29uc3QgcCA9IHR5cGVvZiBwYXJhbXMgPT09IFwiZnVuY3Rpb25cIiA/IHBhcmFtcyhkYXRhKSA6IHR5cGVvZiBwYXJhbXMgPT09IFwic3RyaW5nXCIgPyB7IG1lc3NhZ2U6IHBhcmFtcyB9IDogcGFyYW1zO1xuICAgICAgICBjb25zdCBfZmF0YWwgPSAoX2IgPSAoX2EgPSBwLmZhdGFsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYXRhbCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdHJ1ZTtcbiAgICAgICAgY29uc3QgcDIgPSB0eXBlb2YgcCA9PT0gXCJzdHJpbmdcIiA/IHsgbWVzc2FnZTogcCB9IDogcDtcbiAgICAgICAgY3R4LmFkZElzc3VlKHsgY29kZTogXCJjdXN0b21cIiwgLi4ucDIsIGZhdGFsOiBfZmF0YWwgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIHJldHVybiBab2RBbnkuY3JlYXRlKCk7XG59XG52YXIgbGF0ZSA9IHtcbiAgb2JqZWN0OiBab2RPYmplY3QubGF6eWNyZWF0ZVxufTtcbnZhciBab2RGaXJzdFBhcnR5VHlwZUtpbmQ7XG4oZnVuY3Rpb24oWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMikge1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kU3RyaW5nXCJdID0gXCJab2RTdHJpbmdcIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZE51bWJlclwiXSA9IFwiWm9kTnVtYmVyXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2ROYU5cIl0gPSBcIlpvZE5hTlwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kQmlnSW50XCJdID0gXCJab2RCaWdJbnRcIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZEJvb2xlYW5cIl0gPSBcIlpvZEJvb2xlYW5cIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZERhdGVcIl0gPSBcIlpvZERhdGVcIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZFN5bWJvbFwiXSA9IFwiWm9kU3ltYm9sXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RVbmRlZmluZWRcIl0gPSBcIlpvZFVuZGVmaW5lZFwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kTnVsbFwiXSA9IFwiWm9kTnVsbFwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kQW55XCJdID0gXCJab2RBbnlcIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZFVua25vd25cIl0gPSBcIlpvZFVua25vd25cIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZE5ldmVyXCJdID0gXCJab2ROZXZlclwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kVm9pZFwiXSA9IFwiWm9kVm9pZFwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kQXJyYXlcIl0gPSBcIlpvZEFycmF5XCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RPYmplY3RcIl0gPSBcIlpvZE9iamVjdFwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kVW5pb25cIl0gPSBcIlpvZFVuaW9uXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2REaXNjcmltaW5hdGVkVW5pb25cIl0gPSBcIlpvZERpc2NyaW1pbmF0ZWRVbmlvblwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kSW50ZXJzZWN0aW9uXCJdID0gXCJab2RJbnRlcnNlY3Rpb25cIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZFR1cGxlXCJdID0gXCJab2RUdXBsZVwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kUmVjb3JkXCJdID0gXCJab2RSZWNvcmRcIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZE1hcFwiXSA9IFwiWm9kTWFwXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RTZXRcIl0gPSBcIlpvZFNldFwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kRnVuY3Rpb25cIl0gPSBcIlpvZEZ1bmN0aW9uXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RMYXp5XCJdID0gXCJab2RMYXp5XCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RMaXRlcmFsXCJdID0gXCJab2RMaXRlcmFsXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RFbnVtXCJdID0gXCJab2RFbnVtXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RFZmZlY3RzXCJdID0gXCJab2RFZmZlY3RzXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2ROYXRpdmVFbnVtXCJdID0gXCJab2ROYXRpdmVFbnVtXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RPcHRpb25hbFwiXSA9IFwiWm9kT3B0aW9uYWxcIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZE51bGxhYmxlXCJdID0gXCJab2ROdWxsYWJsZVwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kRGVmYXVsdFwiXSA9IFwiWm9kRGVmYXVsdFwiO1xuICBab2RGaXJzdFBhcnR5VHlwZUtpbmQyW1wiWm9kQ2F0Y2hcIl0gPSBcIlpvZENhdGNoXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RQcm9taXNlXCJdID0gXCJab2RQcm9taXNlXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RCcmFuZGVkXCJdID0gXCJab2RCcmFuZGVkXCI7XG4gIFpvZEZpcnN0UGFydHlUeXBlS2luZDJbXCJab2RQaXBlbGluZVwiXSA9IFwiWm9kUGlwZWxpbmVcIjtcbiAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMltcIlpvZFJlYWRvbmx5XCJdID0gXCJab2RSZWFkb25seVwiO1xufSkoWm9kRmlyc3RQYXJ0eVR5cGVLaW5kIHx8IChab2RGaXJzdFBhcnR5VHlwZUtpbmQgPSB7fSkpO1xudmFyIGluc3RhbmNlT2ZUeXBlID0gKGNscywgcGFyYW1zID0ge1xuICBtZXNzYWdlOiBgSW5wdXQgbm90IGluc3RhbmNlIG9mICR7Y2xzLm5hbWV9YFxufSkgPT4gY3VzdG9tKChkYXRhKSA9PiBkYXRhIGluc3RhbmNlb2YgY2xzLCBwYXJhbXMpO1xudmFyIHN0cmluZ1R5cGUgPSBab2RTdHJpbmcuY3JlYXRlO1xudmFyIG51bWJlclR5cGUgPSBab2ROdW1iZXIuY3JlYXRlO1xudmFyIG5hblR5cGUgPSBab2ROYU4uY3JlYXRlO1xudmFyIGJpZ0ludFR5cGUgPSBab2RCaWdJbnQuY3JlYXRlO1xudmFyIGJvb2xlYW5UeXBlID0gWm9kQm9vbGVhbi5jcmVhdGU7XG52YXIgZGF0ZVR5cGUgPSBab2REYXRlLmNyZWF0ZTtcbnZhciBzeW1ib2xUeXBlID0gWm9kU3ltYm9sLmNyZWF0ZTtcbnZhciB1bmRlZmluZWRUeXBlID0gWm9kVW5kZWZpbmVkLmNyZWF0ZTtcbnZhciBudWxsVHlwZSA9IFpvZE51bGwuY3JlYXRlO1xudmFyIGFueVR5cGUgPSBab2RBbnkuY3JlYXRlO1xudmFyIHVua25vd25UeXBlID0gWm9kVW5rbm93bi5jcmVhdGU7XG52YXIgbmV2ZXJUeXBlID0gWm9kTmV2ZXIuY3JlYXRlO1xudmFyIHZvaWRUeXBlID0gWm9kVm9pZC5jcmVhdGU7XG52YXIgYXJyYXlUeXBlID0gWm9kQXJyYXkuY3JlYXRlO1xudmFyIG9iamVjdFR5cGUgPSBab2RPYmplY3QuY3JlYXRlO1xudmFyIHN0cmljdE9iamVjdFR5cGUgPSBab2RPYmplY3Quc3RyaWN0Q3JlYXRlO1xudmFyIHVuaW9uVHlwZSA9IFpvZFVuaW9uLmNyZWF0ZTtcbnZhciBkaXNjcmltaW5hdGVkVW5pb25UeXBlID0gWm9kRGlzY3JpbWluYXRlZFVuaW9uLmNyZWF0ZTtcbnZhciBpbnRlcnNlY3Rpb25UeXBlID0gWm9kSW50ZXJzZWN0aW9uLmNyZWF0ZTtcbnZhciB0dXBsZVR5cGUgPSBab2RUdXBsZS5jcmVhdGU7XG52YXIgcmVjb3JkVHlwZSA9IFpvZFJlY29yZC5jcmVhdGU7XG52YXIgbWFwVHlwZSA9IFpvZE1hcC5jcmVhdGU7XG52YXIgc2V0VHlwZSA9IFpvZFNldC5jcmVhdGU7XG52YXIgZnVuY3Rpb25UeXBlID0gWm9kRnVuY3Rpb24uY3JlYXRlO1xudmFyIGxhenlUeXBlID0gWm9kTGF6eS5jcmVhdGU7XG52YXIgbGl0ZXJhbFR5cGUgPSBab2RMaXRlcmFsLmNyZWF0ZTtcbnZhciBlbnVtVHlwZSA9IFpvZEVudW0uY3JlYXRlO1xudmFyIG5hdGl2ZUVudW1UeXBlID0gWm9kTmF0aXZlRW51bS5jcmVhdGU7XG52YXIgcHJvbWlzZVR5cGUgPSBab2RQcm9taXNlLmNyZWF0ZTtcbnZhciBlZmZlY3RzVHlwZSA9IFpvZEVmZmVjdHMuY3JlYXRlO1xudmFyIG9wdGlvbmFsVHlwZSA9IFpvZE9wdGlvbmFsLmNyZWF0ZTtcbnZhciBudWxsYWJsZVR5cGUgPSBab2ROdWxsYWJsZS5jcmVhdGU7XG52YXIgcHJlcHJvY2Vzc1R5cGUgPSBab2RFZmZlY3RzLmNyZWF0ZVdpdGhQcmVwcm9jZXNzO1xudmFyIHBpcGVsaW5lVHlwZSA9IFpvZFBpcGVsaW5lLmNyZWF0ZTtcbnZhciBvc3RyaW5nID0gKCkgPT4gc3RyaW5nVHlwZSgpLm9wdGlvbmFsKCk7XG52YXIgb251bWJlciA9ICgpID0+IG51bWJlclR5cGUoKS5vcHRpb25hbCgpO1xudmFyIG9ib29sZWFuID0gKCkgPT4gYm9vbGVhblR5cGUoKS5vcHRpb25hbCgpO1xudmFyIGNvZXJjZSA9IHtcbiAgc3RyaW5nOiAoYXJnKSA9PiBab2RTdHJpbmcuY3JlYXRlKHsgLi4uYXJnLCBjb2VyY2U6IHRydWUgfSksXG4gIG51bWJlcjogKGFyZykgPT4gWm9kTnVtYmVyLmNyZWF0ZSh7IC4uLmFyZywgY29lcmNlOiB0cnVlIH0pLFxuICBib29sZWFuOiAoYXJnKSA9PiBab2RCb29sZWFuLmNyZWF0ZSh7XG4gICAgLi4uYXJnLFxuICAgIGNvZXJjZTogdHJ1ZVxuICB9KSxcbiAgYmlnaW50OiAoYXJnKSA9PiBab2RCaWdJbnQuY3JlYXRlKHsgLi4uYXJnLCBjb2VyY2U6IHRydWUgfSksXG4gIGRhdGU6IChhcmcpID0+IFpvZERhdGUuY3JlYXRlKHsgLi4uYXJnLCBjb2VyY2U6IHRydWUgfSlcbn07XG52YXIgTkVWRVIgPSBJTlZBTElEO1xudmFyIHogPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgZGVmYXVsdEVycm9yTWFwOiBlcnJvck1hcCxcbiAgc2V0RXJyb3JNYXAsXG4gIGdldEVycm9yTWFwLFxuICBtYWtlSXNzdWUsXG4gIEVNUFRZX1BBVEgsXG4gIGFkZElzc3VlVG9Db250ZXh0LFxuICBQYXJzZVN0YXR1cyxcbiAgSU5WQUxJRCxcbiAgRElSVFksXG4gIE9LLFxuICBpc0Fib3J0ZWQsXG4gIGlzRGlydHksXG4gIGlzVmFsaWQsXG4gIGlzQXN5bmMsXG4gIGdldCB1dGlsKCkge1xuICAgIHJldHVybiB1dGlsO1xuICB9LFxuICBnZXQgb2JqZWN0VXRpbCgpIHtcbiAgICByZXR1cm4gb2JqZWN0VXRpbDtcbiAgfSxcbiAgWm9kUGFyc2VkVHlwZSxcbiAgZ2V0UGFyc2VkVHlwZSxcbiAgWm9kVHlwZSxcbiAgZGF0ZXRpbWVSZWdleCxcbiAgWm9kU3RyaW5nLFxuICBab2ROdW1iZXIsXG4gIFpvZEJpZ0ludCxcbiAgWm9kQm9vbGVhbixcbiAgWm9kRGF0ZSxcbiAgWm9kU3ltYm9sLFxuICBab2RVbmRlZmluZWQsXG4gIFpvZE51bGwsXG4gIFpvZEFueSxcbiAgWm9kVW5rbm93bixcbiAgWm9kTmV2ZXIsXG4gIFpvZFZvaWQsXG4gIFpvZEFycmF5LFxuICBab2RPYmplY3QsXG4gIFpvZFVuaW9uLFxuICBab2REaXNjcmltaW5hdGVkVW5pb24sXG4gIFpvZEludGVyc2VjdGlvbixcbiAgWm9kVHVwbGUsXG4gIFpvZFJlY29yZCxcbiAgWm9kTWFwLFxuICBab2RTZXQsXG4gIFpvZEZ1bmN0aW9uLFxuICBab2RMYXp5LFxuICBab2RMaXRlcmFsLFxuICBab2RFbnVtLFxuICBab2ROYXRpdmVFbnVtLFxuICBab2RQcm9taXNlLFxuICBab2RFZmZlY3RzLFxuICBab2RUcmFuc2Zvcm1lcjogWm9kRWZmZWN0cyxcbiAgWm9kT3B0aW9uYWwsXG4gIFpvZE51bGxhYmxlLFxuICBab2REZWZhdWx0LFxuICBab2RDYXRjaCxcbiAgWm9kTmFOLFxuICBCUkFORCxcbiAgWm9kQnJhbmRlZCxcbiAgWm9kUGlwZWxpbmUsXG4gIFpvZFJlYWRvbmx5LFxuICBjdXN0b20sXG4gIFNjaGVtYTogWm9kVHlwZSxcbiAgWm9kU2NoZW1hOiBab2RUeXBlLFxuICBsYXRlLFxuICBnZXQgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kKCkge1xuICAgIHJldHVybiBab2RGaXJzdFBhcnR5VHlwZUtpbmQ7XG4gIH0sXG4gIGNvZXJjZSxcbiAgYW55OiBhbnlUeXBlLFxuICBhcnJheTogYXJyYXlUeXBlLFxuICBiaWdpbnQ6IGJpZ0ludFR5cGUsXG4gIGJvb2xlYW46IGJvb2xlYW5UeXBlLFxuICBkYXRlOiBkYXRlVHlwZSxcbiAgZGlzY3JpbWluYXRlZFVuaW9uOiBkaXNjcmltaW5hdGVkVW5pb25UeXBlLFxuICBlZmZlY3Q6IGVmZmVjdHNUeXBlLFxuICBcImVudW1cIjogZW51bVR5cGUsXG4gIFwiZnVuY3Rpb25cIjogZnVuY3Rpb25UeXBlLFxuICBcImluc3RhbmNlb2ZcIjogaW5zdGFuY2VPZlR5cGUsXG4gIGludGVyc2VjdGlvbjogaW50ZXJzZWN0aW9uVHlwZSxcbiAgbGF6eTogbGF6eVR5cGUsXG4gIGxpdGVyYWw6IGxpdGVyYWxUeXBlLFxuICBtYXA6IG1hcFR5cGUsXG4gIG5hbjogbmFuVHlwZSxcbiAgbmF0aXZlRW51bTogbmF0aXZlRW51bVR5cGUsXG4gIG5ldmVyOiBuZXZlclR5cGUsXG4gIFwibnVsbFwiOiBudWxsVHlwZSxcbiAgbnVsbGFibGU6IG51bGxhYmxlVHlwZSxcbiAgbnVtYmVyOiBudW1iZXJUeXBlLFxuICBvYmplY3Q6IG9iamVjdFR5cGUsXG4gIG9ib29sZWFuLFxuICBvbnVtYmVyLFxuICBvcHRpb25hbDogb3B0aW9uYWxUeXBlLFxuICBvc3RyaW5nLFxuICBwaXBlbGluZTogcGlwZWxpbmVUeXBlLFxuICBwcmVwcm9jZXNzOiBwcmVwcm9jZXNzVHlwZSxcbiAgcHJvbWlzZTogcHJvbWlzZVR5cGUsXG4gIHJlY29yZDogcmVjb3JkVHlwZSxcbiAgc2V0OiBzZXRUeXBlLFxuICBzdHJpY3RPYmplY3Q6IHN0cmljdE9iamVjdFR5cGUsXG4gIHN0cmluZzogc3RyaW5nVHlwZSxcbiAgc3ltYm9sOiBzeW1ib2xUeXBlLFxuICB0cmFuc2Zvcm1lcjogZWZmZWN0c1R5cGUsXG4gIHR1cGxlOiB0dXBsZVR5cGUsXG4gIFwidW5kZWZpbmVkXCI6IHVuZGVmaW5lZFR5cGUsXG4gIHVuaW9uOiB1bmlvblR5cGUsXG4gIHVua25vd246IHVua25vd25UeXBlLFxuICBcInZvaWRcIjogdm9pZFR5cGUsXG4gIE5FVkVSLFxuICBab2RJc3N1ZUNvZGUsXG4gIHF1b3RlbGVzc0pzb24sXG4gIFpvZEVycm9yXG59KTtcblxuLy8gcGFja2FnZS5qc29uXG52YXIgcGFja2FnZV9kZWZhdWx0ID0ge1xuICBuYW1lOiBcIkBpbWdseS9iYWNrZ3JvdW5kLXJlbW92YWxcIixcbiAgdmVyc2lvbjogXCIxLjUuOFwiLFxuICBkZXNjcmlwdGlvbjogXCJCYWNrZ3JvdW5kIFJlbW92YWwgaW4gdGhlIEJyb3dzZXJcIixcbiAga2V5d29yZHM6IFtcbiAgICBcImJhY2tncm91bmQtcmVtb3ZhbFwiLFxuICAgIFwiY2xpZW50LXNpZGVcIixcbiAgICBcImRhdGEtcHJpdmFjeVwiLFxuICAgIFwiaW1hZ2Utc2VnbWVudGF0aW9uXCIsXG4gICAgXCJpbWFnZS1tYXR0aW5nXCIsXG4gICAgXCJvbm54XCJcbiAgXSxcbiAgcmVwb3NpdG9yeToge1xuICAgIHR5cGU6IFwiZ2l0XCIsXG4gICAgdXJsOiBcImdpdCtodHRwczovL2dpdGh1Yi5jb20vaW1nbHkvYmFja2dyb3VuZC1yZW1vdmFsLWpzLmdpdFwiXG4gIH0sXG4gIGxpY2Vuc2U6IFwiU0VFIExJQ0VOU0UgSU4gTElDRU5TRS5tZFwiLFxuICBhdXRob3I6IHtcbiAgICBuYW1lOiBcIklNRy5MWSBHbWJIXCIsXG4gICAgZW1haWw6IFwic3VwcG9ydEBpbWcubHlcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9pbWcubHlcIlxuICB9LFxuICBidWdzOiB7XG4gICAgZW1haWw6IFwic3VwcG9ydEBpbWcubHlcIlxuICB9LFxuICBzb3VyY2U6IFwiLi9zcmMvaW5kZXgudHNcIixcbiAgbWFpbjogXCIuL2Rpc3QvaW5kZXguY2pzXCIsXG4gIG1vZHVsZTogXCIuL2Rpc3QvaW5kZXgubWpzXCIsXG4gIHR5cGVzOiBcIi4vZGlzdC9zcmMvaW5kZXguZC50c1wiLFxuICBleHBvcnRzOiB7XG4gICAgXCIuXCI6IHtcbiAgICAgIHJlcXVpcmU6IFwiLi9kaXN0L2luZGV4LmNqc1wiLFxuICAgICAgaW1wb3J0OiBcIi4vZGlzdC9pbmRleC5tanNcIixcbiAgICAgIHR5cGVzOiBcIi4vZGlzdC9zcmMvaW5kZXguZC50c1wiXG4gICAgfVxuICB9LFxuICBob21lcGFnZTogXCJodHRwczovL2ltZy5seS9zaG93Y2FzZXMvY2VzZGsvd2ViL2JhY2tncm91bmQtcmVtb3ZhbFwiLFxuICBmaWxlczogW1xuICAgIFwiTElDRU5TRS5tZFwiLFxuICAgIFwiUkVBRE1FLm1kXCIsXG4gICAgXCJDSEFOR0VMT0cubWRcIixcbiAgICBcIlRoaXJkUGFydHlMaWNlbnNlcy5qc29uXCIsXG4gICAgXCJkaXN0L1wiLFxuICAgIFwiYmluL1wiXG4gIF0sXG4gIHNjcmlwdHM6IHtcbiAgICBzdGFydDogXCJucG0gcnVuIHdhdGNoXCIsXG4gICAgY2xlYW46IFwibnB4IHJpbXJhZiBkaXN0XCIsXG4gICAgdGVzdDogXCJ0cnVlXCIsXG4gICAgcmVzb3VyY2VzOiBcIm5vZGUgLi4vLi4vc2NyaXB0cy9wYWNrYWdlLXJlc291cmNlcy5tanNcIixcbiAgICBcImNoYW5nZWxvZzpjcmVhdGVcIjogXCJub2RlIC4uLy4uL3NjcmlwdHMvY2hhbmdlbG9nL2NoYW5nZWxvZy1jcmVhdGUubWpzXCIsXG4gICAgXCJjaGFuZ2Vsb2c6Z2VuZXJhdGVcIjogXCJub2RlIC4uLy4uL3NjcmlwdHMvY2hhbmdlbG9nL2NoYW5nZWxvZy1nZW5lcmF0ZS5tanNcIixcbiAgICBidWlsZDogXCJucG0gcnVuIGNsZWFuICYmIG5wbSBydW4gdHlwZXMgJiYgbnBtIHJ1biByZXNvdXJjZXMgJiYgbnBtIHJ1biBjaGFuZ2Vsb2c6Z2VuZXJhdGUgJiYgbm9kZSBzY3JpcHRzL2J1aWxkLm1qc1wiLFxuICAgIHR5cGVzOiBcIiBucHggdHNjIC0tZGVjbGFyYXRpb24gLS1lbWl0RGVjbGFyYXRpb25Pbmx5IC0tZGVjbGFyYXRpb25EaXIgZGlzdCAtLWRlY2xhcmF0aW9uTWFwXCIsXG4gICAgd2F0Y2g6IFwibnBtIHJ1biBjbGVhbiAmJiBucG0gcnVuIHJlc291cmNlcyAmJiBucG0gcnVuIGNoYW5nZWxvZzpnZW5lcmF0ZSAmJiBub2RlIHNjcmlwdHMvd2F0Y2gubWpzXCIsXG4gICAgXCJwdWJsaXNoOmxhdGVzdFwiOiBcIm5wbSBwdWJsaXNoIC0tdGFnIGxhdGVzdCAtLWFjY2VzcyBwdWJsaWNcIixcbiAgICBcInB1Ymxpc2g6bmV4dFwiOiBcIm5wbSBwdWJsaXNoIC0tdGFnIG5leHQgLS1hY2Nlc3MgcHVibGljXCIsXG4gICAgXCJwYWNrYWdlOnBhY2tcIjogXCJucG0gcGFjayAuIC0tcGFjay1kZXN0aW5hdGlvbiAuLi8uLi9yZWxlYXNlc1wiLFxuICAgIGxpbnQ6IFwibnB4IHByZXR0aWVyIC0td3JpdGUgLlwiXG4gIH0sXG4gIGRlcGVuZGVuY2llczoge1xuICAgIFwibG9kYXNoLWVzXCI6IFwiXjQuMTcuMjFcIixcbiAgICBuZGFycmF5OiBcIn4xLjAuMFwiLFxuICAgIHpvZDogXCJeMy4yMy44XCJcbiAgfSxcbiAgcGVlckRlcGVuZGVuY2llczoge1xuICAgIFwib25ueHJ1bnRpbWUtd2ViXCI6IFwiMS4yMS4wLWRldi4yMDI1MDExNC0yMjhkZDE2ODkzXCJcbiAgfSxcbiAgZGV2RGVwZW5kZW5jaWVzOiB7XG4gICAgXCJAdHlwZXMvbG9kYXNoLWVzXCI6IFwiXjQuMTcuMTJcIixcbiAgICBcIkB0eXBlcy9uZGFycmF5XCI6IFwifjEuMC4xNFwiLFxuICAgIFwiQHR5cGVzL25vZGVcIjogXCJ+MjAuMy4wXCIsXG4gICAgYXNzZXJ0OiBcIn4yLjAuMFwiLFxuICAgIGVzYnVpbGQ6IFwifjAuMTguMFwiLFxuICAgIGdsb2I6IFwifjEwLjMuMFwiLFxuICAgIFwibnBtLWR0c1wiOiBcIn4xLjMuMFwiLFxuICAgIHByb2Nlc3M6IFwifjAuMTEuMFwiLFxuICAgIFwidHMtbG9hZGVyXCI6IFwifjkuNC4wXCIsXG4gICAgdHNsaWI6IFwifjIuNS4wXCIsXG4gICAgdHlwZXNjcmlwdDogXCJ+NS4xLjBcIixcbiAgICB1dGlsOiBcIn4wLjEyLjBcIixcbiAgICB3ZWJwYWNrOiBcIn41Ljg1LjBcIixcbiAgICBcIndlYnBhY2stY2xpXCI6IFwifjUuMS4wXCJcbiAgfSxcbiAgYnVuZGxlRGVwZW5kZW5jaWVzOiBbXVxufTtcblxuLy8gc3JjL3NjaGVtYS50c1xudmFyIENvbmZpZ1NjaGVtYSA9IHoub2JqZWN0KHtcbiAgcHVibGljUGF0aDogei5zdHJpbmcoKS5vcHRpb25hbCgpLmRlc2NyaWJlKFwiVGhlIHB1YmxpYyBwYXRoIHRvIHRoZSB3YXNtIGZpbGVzIGFuZCB0aGUgb25ueCBtb2RlbC5cIikuZGVmYXVsdChcbiAgICBcImh0dHBzOi8vc3RhdGljaW1nbHkuY29tL0BpbWdseS9iYWNrZ3JvdW5kLXJlbW92YWwtZGF0YS8ke1BBQ0tBR0VfVkVSU0lPTn0vZGlzdC9cIlxuICApLnRyYW5zZm9ybSgodmFsKSA9PiB7XG4gICAgcmV0dXJuIHZhbC5yZXBsYWNlKFwiJHtQQUNLQUdFX05BTUV9XCIsIHBhY2thZ2VfZGVmYXVsdC5uYW1lKS5yZXBsYWNlKFwiJHtQQUNLQUdFX1ZFUlNJT059XCIsIHBhY2thZ2VfZGVmYXVsdC52ZXJzaW9uKTtcbiAgfSksXG4gIGRlYnVnOiB6LmJvb2xlYW4oKS5kZWZhdWx0KGZhbHNlKS5kZXNjcmliZShcIldoZXRoZXIgdG8gZW5hYmxlIGRlYnVnIGxvZ2dpbmcuXCIpLFxuICByZXNjYWxlOiB6LmJvb2xlYW4oKS5kZWZhdWx0KHRydWUpLmRlc2NyaWJlKFwiV2hldGhlciB0byByZXNjYWxlIHRoZSBpbWFnZS5cIiksXG4gIGRldmljZTogei5lbnVtKFtcImNwdVwiLCBcImdwdVwiXSkuZGVmYXVsdChcImNwdVwiKS5kZXNjcmliZShcIlRoZSBkZXZpY2UgdG8gcnVuIHRoZSBtb2RlbCBvbi5cIiksXG4gIHByb3h5VG9Xb3JrZXI6IHouYm9vbGVhbigpLmRlZmF1bHQoZmFsc2UpLmRlc2NyaWJlKFwiV2hldGhlciB0byBwcm94eSBpbmZlcmVuY2UgdG8gYSB3ZWIgd29ya2VyLlwiKSxcbiAgZmV0Y2hBcmdzOiB6LmFueSgpLmRlZmF1bHQoe30pLmRlc2NyaWJlKFwiQXJndW1lbnRzIHRvIHBhc3MgdG8gZmV0Y2ggd2hlbiBsb2FkaW5nIHRoZSBtb2RlbC5cIiksXG4gIHByb2dyZXNzOiB6LmZ1bmN0aW9uKCkuYXJncyh6LnN0cmluZygpLCB6Lm51bWJlcigpLCB6Lm51bWJlcigpKS5yZXR1cm5zKHoudm9pZCgpKS5kZXNjcmliZShcIlByb2dyZXNzIGNhbGxiYWNrLlwiKS5vcHRpb25hbCgpLFxuICBtb2RlbDogei5wcmVwcm9jZXNzKFxuICAgICh2YWwpID0+IHtcbiAgICAgIHN3aXRjaCAodmFsKSB7XG4gICAgICAgIGNhc2UgXCJsYXJnZVwiOlxuICAgICAgICAgIHJldHVybiBcImlzbmV0XCI7XG4gICAgICAgIGNhc2UgXCJzbWFsbFwiOlxuICAgICAgICAgIHJldHVybiBcImlzbmV0X3F1aW50OFwiO1xuICAgICAgICBjYXNlIFwibWVkaXVtXCI6XG4gICAgICAgICAgcmV0dXJuIFwiaXNuZXRfZnAxNlwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9XG4gICAgfSxcbiAgICB6LmVudW0oW1wiaXNuZXRcIiwgXCJpc25ldF9mcDE2XCIsIFwiaXNuZXRfcXVpbnQ4XCJdKVxuICApLmRlZmF1bHQoXCJtZWRpdW1cIiksXG4gIG91dHB1dDogei5vYmplY3Qoe1xuICAgIGZvcm1hdDogei5lbnVtKFtcbiAgICAgIFwiaW1hZ2UvcG5nXCIsXG4gICAgICBcImltYWdlL2pwZWdcIixcbiAgICAgIFwiaW1hZ2Uvd2VicFwiLFxuICAgICAgXCJpbWFnZS94LXJnYmE4XCIsXG4gICAgICBcImltYWdlL3gtYWxwaGE4XCJcbiAgICBdKS5kZWZhdWx0KFwiaW1hZ2UvcG5nXCIpLFxuICAgIHF1YWxpdHk6IHoubnVtYmVyKCkuZGVmYXVsdCgwLjgpXG4gIH0pLmRlZmF1bHQoe30pXG59KS5kZWZhdWx0KHt9KS50cmFuc2Zvcm0oKGNvbmZpZykgPT4ge1xuICBpZiAoY29uZmlnLmRlYnVnKVxuICAgIGNvbnNvbGUubG9nKFwiQ29uZmlnOlwiLCBjb25maWcpO1xuICBpZiAoY29uZmlnLmRlYnVnICYmICFjb25maWcucHJvZ3Jlc3MpIHtcbiAgICBjb25maWcucHJvZ3Jlc3MgPSBjb25maWcucHJvZ3Jlc3MgPz8gKChrZXksIGN1cnJlbnQsIHRvdGFsKSA9PiB7XG4gICAgICBjb25zb2xlLmRlYnVnKGBEb3dubG9hZGluZyAke2tleX06ICR7Y3VycmVudH0gb2YgJHt0b3RhbH1gKTtcbiAgICB9KTtcbiAgICBpZiAoIWNyb3NzT3JpZ2luSXNvbGF0ZWQpIHtcbiAgICAgIGlmIChjb25maWcuZGVidWcpXG4gICAgICAgIGNvbnNvbGUuZGVidWcoXG4gICAgICAgICAgXCJDcm9zcy1PcmlnaW4tSXNvbGF0ZWQgaXMgbm90IGVuYWJsZWQuIFBlcmZvcm1hbmNlIHdpbGwgYmUgZGVncmFkZWQuIFBsZWFzZSBzZWUgIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1NoYXJlZEFycmF5QnVmZmVyLlwiXG4gICAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb25maWc7XG59KTtcbmZ1bmN0aW9uIHZhbGlkYXRlQ29uZmlnKGNvbmZpZ3VyYXRpb24pIHtcbiAgcmV0dXJuIENvbmZpZ1NjaGVtYS5wYXJzZShjb25maWd1cmF0aW9uID8/IHt9KTtcbn1cblxuLy8gc3JjL2luZmVyZW5jZS50c1xudmFyIGltcG9ydF9uZGFycmF5NCA9IF9fdG9FU00ocmVxdWlyZV9uZGFycmF5KCkpO1xuYXN5bmMgZnVuY3Rpb24gaW5pdEJhc2UoY29uZmlnKSB7XG4gIGlmIChjb25maWcuZGVidWcpXG4gICAgY29uc29sZS5kZWJ1ZyhcIkxvYWRpbmcgbW9kZWwuLi5cIiwgY29uZmlnLm1vZGVsKTtcbiAgY29uc3QgbW9kZWwgPSBjb25maWcubW9kZWw7XG4gIGNvbnN0IGJsb2IgPSBhd2FpdCBsb2FkQXNCbG9iKGAvbW9kZWxzLyR7bW9kZWx9YCwgY29uZmlnKTtcbiAgY29uc3QgYXJyYXlCdWZmZXIgPSBhd2FpdCBibG9iLmFycmF5QnVmZmVyKCk7XG4gIGNvbnN0IHNlc3Npb24gPSBhd2FpdCBjcmVhdGVPbm54U2Vzc2lvbihhcnJheUJ1ZmZlciwgY29uZmlnKTtcbiAgcmV0dXJuIHNlc3Npb247XG59XG5hc3luYyBmdW5jdGlvbiBpbml0SW5mZXJlbmNlKGNvbmZpZykge1xuICBjb25maWcgPSB2YWxpZGF0ZUNvbmZpZyhjb25maWcpO1xuICBjb25zdCBiYXNlID0gYXdhaXQgaW5pdEJhc2UoY29uZmlnKTtcbiAgcmV0dXJuIHsgY29uZmlnLCBzZXNzaW9uOiB7IGJhc2UgfSB9O1xufVxuYXN5bmMgZnVuY3Rpb24gcnVuSW5mZXJlbmNlKGltYWdlVGVuc29yLCBjb25maWcsIHNlc3Npb24pIHtcbiAgY29uc3QgcmVzb2x1dGlvbiA9IDEwMjQ7XG4gIGNvbnN0IFtzcmNIZWlnaHQsIHNyY1dpZHRoLCBzcmNDaGFubmVsc10gPSBpbWFnZVRlbnNvci5zaGFwZTtcbiAgY29uc3Qga2VlcEFzcGVjdCA9IGZhbHNlO1xuICBsZXQgcmVzaXplZEltYWdlVGVuc29yID0gdGVuc29yUmVzaXplQmlsaW5lYXIoXG4gICAgaW1hZ2VUZW5zb3IsXG4gICAgcmVzb2x1dGlvbixcbiAgICByZXNvbHV0aW9uLFxuICAgIGtlZXBBc3BlY3RcbiAgKTtcbiAgY29uc3QgaW5wdXRUZW5zb3IgPSB0ZW5zb3JIV0N0b0JDSFcocmVzaXplZEltYWdlVGVuc29yKTtcbiAgbGV0IHByZWRpY3Rpb25zRGljdCA9IGF3YWl0IHJ1bk9ubnhTZXNzaW9uKFxuICAgIHNlc3Npb24uYmFzZSxcbiAgICBbW1wiaW5wdXRcIiwgaW5wdXRUZW5zb3JdXSxcbiAgICBbXCJvdXRwdXRcIl0sXG4gICAgY29uZmlnXG4gICk7XG4gIGxldCBhbHBoYW1hc2syID0gKDAsIGltcG9ydF9uZGFycmF5NC5kZWZhdWx0KShwcmVkaWN0aW9uc0RpY3RbMF0uZGF0YSwgW3Jlc29sdXRpb24sIHJlc29sdXRpb24sIDFdKTtcbiAgbGV0IGFscGhhbWFza1U4ID0gY29udmVydEZsb2F0MzJUb1VpbnQ4KGFscGhhbWFzazIpO1xuICBpZiAoY29uZmlnLnJlc2NhbGUpIHtcbiAgICBhbHBoYW1hc2tVOCA9IHRlbnNvclJlc2l6ZUJpbGluZWFyKFxuICAgICAgYWxwaGFtYXNrVTgsXG4gICAgICBzcmNXaWR0aCxcbiAgICAgIHNyY0hlaWdodCxcbiAgICAgIGtlZXBBc3BlY3RcbiAgICApO1xuICAgIHJldHVybiBbYWxwaGFtYXNrVTgsIGltYWdlVGVuc29yXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW2FscGhhbWFza1U4LCByZXNpemVkSW1hZ2VUZW5zb3JdO1xuICB9XG59XG5cbi8vIHNyYy9hcGkvdjEudHNcbnZhciBpbml0ID0gKDAsIGltcG9ydF9sb2Rhc2gubWVtb2l6ZSkoaW5pdEluZmVyZW5jZSwgKGNvbmZpZykgPT4gSlNPTi5zdHJpbmdpZnkoY29uZmlnKSk7XG5hc3luYyBmdW5jdGlvbiBwcmVsb2FkKGNvbmZpZ3VyYXRpb24pIHtcbiAgYXdhaXQgaW5pdChjb25maWd1cmF0aW9uKTtcbiAgcmV0dXJuO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVtb3ZlQmFja2dyb3VuZChpbWFnZSwgY29uZmlndXJhdGlvbikge1xuICBjb25zdCB7IGNvbmZpZywgc2Vzc2lvbiB9ID0gYXdhaXQgaW5pdChjb25maWd1cmF0aW9uKTtcbiAgaWYgKGNvbmZpZy5wcm9ncmVzcylcbiAgICBjb25maWcucHJvZ3Jlc3MoXCJjb21wdXRlOmRlY29kZVwiLCAwLCA0KTtcbiAgY29uc3QgaW5wdXRJbWFnZVRlbnNvciA9IGF3YWl0IGltYWdlU291cmNlVG9JbWFnZURhdGEoaW1hZ2UsIGNvbmZpZyk7XG4gIGNvbmZpZy5wcm9ncmVzcz8uKFwiY29tcHV0ZTppbmZlcmVuY2VcIiwgMSwgNCk7XG4gIGNvbnN0IFthbHBoYW1hc2syLCBpbWFnZVRlbnNvcl0gPSBhd2FpdCBydW5JbmZlcmVuY2UoXG4gICAgaW5wdXRJbWFnZVRlbnNvcixcbiAgICBjb25maWcsXG4gICAgc2Vzc2lvblxuICApO1xuICBjb25maWcucHJvZ3Jlc3M/LihcImNvbXB1dGU6bWFza1wiLCAyLCA0KTtcbiAgY29uc3Qgb3V0SW1hZ2VUZW5zb3IgPSBpbWFnZVRlbnNvcjtcbiAgY29uc3QgW3dpZHRoLCBoZWlnaHRdID0gb3V0SW1hZ2VUZW5zb3Iuc2hhcGU7XG4gIGNvbnN0IHN0cmlkZSA9IHdpZHRoICogaGVpZ2h0O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmlkZTsgaSArPSAxKSB7XG4gICAgb3V0SW1hZ2VUZW5zb3IuZGF0YVs0ICogaSArIDNdID0gYWxwaGFtYXNrMi5kYXRhW2ldO1xuICB9XG4gIGNvbmZpZy5wcm9ncmVzcz8uKFwiY29tcHV0ZTplbmNvZGVcIiwgMywgNCk7XG4gIGNvbnN0IG91dEltYWdlID0gYXdhaXQgaW1hZ2VFbmNvZGUoXG4gICAgb3V0SW1hZ2VUZW5zb3IsXG4gICAgY29uZmlnLm91dHB1dC5xdWFsaXR5LFxuICAgIGNvbmZpZy5vdXRwdXQuZm9ybWF0XG4gICk7XG4gIGNvbmZpZy5wcm9ncmVzcz8uKFwiY29tcHV0ZTplbmNvZGVcIiwgNCwgNCk7XG4gIHJldHVybiBvdXRJbWFnZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHJlbW92ZUZvcmVncm91bmQoaW1hZ2UsIGNvbmZpZ3VyYXRpb24pIHtcbiAgY29uc3QgeyBjb25maWcsIHNlc3Npb24gfSA9IGF3YWl0IGluaXQoY29uZmlndXJhdGlvbik7XG4gIGNvbnN0IGltYWdlVGVuc29yID0gYXdhaXQgaW1hZ2VTb3VyY2VUb0ltYWdlRGF0YShpbWFnZSwgY29uZmlnKTtcbiAgY29uc3QgW2FscGhhbWFzazIsIGltYWdlSW5wdXRdID0gYXdhaXQgcnVuSW5mZXJlbmNlKFxuICAgIGltYWdlVGVuc29yLFxuICAgIGNvbmZpZyxcbiAgICBzZXNzaW9uXG4gICk7XG4gIGNvbnN0IG91dEltYWdlVGVuc29yID0gaW1hZ2VJbnB1dDtcbiAgY29uc3QgW3dpZHRoLCBoZWlnaHQsIGNoYW5uZWxzXSA9IG91dEltYWdlVGVuc29yLnNoYXBlO1xuICBjb25zdCBzdHJpZGUgPSB3aWR0aCAqIGhlaWdodDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpZGU7IGkgKz0gMSkge1xuICAgIG91dEltYWdlVGVuc29yLmRhdGFbNCAqIGkgKyAzXSA9IDI1NSAtIGFscGhhbWFzazIuZGF0YVtpXTtcbiAgfVxuICBjb25zdCBvdXRJbWFnZSA9IGF3YWl0IGltYWdlRW5jb2RlKFxuICAgIG91dEltYWdlVGVuc29yLFxuICAgIGNvbmZpZy5vdXRwdXQucXVhbGl0eSxcbiAgICBjb25maWcub3V0cHV0LmZvcm1hdFxuICApO1xuICByZXR1cm4gb3V0SW1hZ2U7XG59XG52YXIgYWxwaGFtYXNrID0gc2VnbWVudEZvcmVncm91bmQ7XG5hc3luYyBmdW5jdGlvbiBzZWdtZW50Rm9yZWdyb3VuZChpbWFnZSwgY29uZmlndXJhdGlvbikge1xuICBjb25zdCB7IGNvbmZpZywgc2Vzc2lvbiB9ID0gYXdhaXQgaW5pdChjb25maWd1cmF0aW9uKTtcbiAgY29uc3QgaW1hZ2VUZW5zb3IgPSBhd2FpdCBpbWFnZVNvdXJjZVRvSW1hZ2VEYXRhKGltYWdlLCBjb25maWcpO1xuICBsZXQgW2hlaWdodCwgd2lkdGgsIGNoYW5uZWxzXSA9IGltYWdlVGVuc29yLnNoYXBlO1xuICBjb25zdCBbYWxwaGFtYXNrMiwgaW1hZ2VJbnB1dF0gPSBhd2FpdCBydW5JbmZlcmVuY2UoXG4gICAgaW1hZ2VUZW5zb3IsXG4gICAgY29uZmlnLFxuICAgIHNlc3Npb25cbiAgKTtcbiAgY29uc3Qgc3RyaWRlID0gd2lkdGggKiBoZWlnaHQ7XG4gIGNvbnN0IG91dEltYWdlVGVuc29yID0gaW1hZ2VUZW5zb3I7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaWRlOyBpICs9IDEpIHtcbiAgICBjb25zdCBpbmRleCA9IDQgKiBpO1xuICAgIGxldCBhbHBoYSA9IGFscGhhbWFzazIuZGF0YVtpXTtcbiAgICBvdXRJbWFnZVRlbnNvci5kYXRhW2luZGV4XSA9IDI1NTtcbiAgICBvdXRJbWFnZVRlbnNvci5kYXRhW2luZGV4ICsgMV0gPSAyNTU7XG4gICAgb3V0SW1hZ2VUZW5zb3IuZGF0YVtpbmRleCArIDJdID0gMjU1O1xuICAgIG91dEltYWdlVGVuc29yLmRhdGFbaW5kZXggKyAzXSA9IGFscGhhO1xuICB9XG4gIGNvbnN0IG91dEltYWdlID0gYXdhaXQgaW1hZ2VFbmNvZGUoXG4gICAgb3V0SW1hZ2VUZW5zb3IsXG4gICAgY29uZmlnLm91dHB1dC5xdWFsaXR5LFxuICAgIGNvbmZpZy5vdXRwdXQuZm9ybWF0XG4gICk7XG4gIHJldHVybiBvdXRJbWFnZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGFwcGx5U2VnbWVudGF0aW9uTWFzayhpbWFnZSwgbWFzaywgY29uZmlnKSB7XG4gIGNvbmZpZyA9IHZhbGlkYXRlQ29uZmlnKGNvbmZpZyk7XG4gIGNvbnN0IGltYWdlVGVuc29yID0gYXdhaXQgaW1hZ2VTb3VyY2VUb0ltYWdlRGF0YShpbWFnZSwgY29uZmlnKTtcbiAgY29uc3QgW2ltYWdlSGVpZ2h0LCBpbWFnZVdpZHRoLCBpbWFnZUNoYW5uZWxzXSA9IGltYWdlVGVuc29yLnNoYXBlO1xuICBjb25zdCBtYXNrVGVuc29yID0gYXdhaXQgaW1hZ2VTb3VyY2VUb0ltYWdlRGF0YShtYXNrLCBjb25maWcpO1xuICBjb25zdCBbbWFza0hlaWdodCwgbWFza1dpZHRoLCBtYXNrQ2hhbm5lbHNdID0gbWFza1RlbnNvci5zaGFwZTtcbiAgY29uc3QgYWxwaGFNYXNrID0gbWFza0hlaWdodCAhPT0gaW1hZ2VIZWlnaHQgfHwgbWFza1dpZHRoICE9PSBpbWFnZVdpZHRoID8gdGVuc29yUmVzaXplQmlsaW5lYXIobWFza1RlbnNvciwgaW1hZ2VXaWR0aCwgaW1hZ2VIZWlnaHQpIDogbWFza1RlbnNvcjtcbiAgY29uc3Qgc3RyaWRlID0gaW1hZ2VXaWR0aCAqIGltYWdlSGVpZ2h0O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmlkZTsgaSArPSAxKSB7XG4gICAgY29uc3QgaWR4SW1hZ2UgPSBpbWFnZUNoYW5uZWxzICogaTtcbiAgICBjb25zdCBpZHhNYXNrID0gbWFza0NoYW5uZWxzICogaTtcbiAgICBpbWFnZVRlbnNvci5kYXRhW2lkeEltYWdlICsgM10gPSBhbHBoYU1hc2suZGF0YVtpZHhNYXNrICsgM107XG4gIH1cbiAgY29uc3Qgb3V0SW1hZ2UgPSBhd2FpdCBpbWFnZUVuY29kZShcbiAgICBpbWFnZVRlbnNvcixcbiAgICBjb25maWcub3V0cHV0LnF1YWxpdHksXG4gICAgY29uZmlnLm91dHB1dC5mb3JtYXRcbiAgKTtcbiAgcmV0dXJuIG91dEltYWdlO1xufVxuZXhwb3J0IHtcbiAgYWxwaGFtYXNrLFxuICBhcHBseVNlZ21lbnRhdGlvbk1hc2ssXG4gIHByZWxvYWQsXG4gIHJlbW92ZUJhY2tncm91bmQsXG4gIHJlbW92ZUZvcmVncm91bmQsXG4gIHNlZ21lbnRGb3JlZ3JvdW5kXG59O1xuLyohIEJ1bmRsZWQgbGljZW5zZSBpbmZvcm1hdGlvbjpcblxubG9kYXNoL2xvZGFzaC5qczpcbiAgKCoqXG4gICAqIEBsaWNlbnNlXG4gICAqIExvZGFzaCA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAgICogQ29weXJpZ2h0IE9wZW5KUyBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vb3BlbmpzZi5vcmcvPlxuICAgKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gICAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gICAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICAgKilcblxuaXMtYnVmZmVyL2luZGV4LmpzOlxuICAoKiFcbiAgICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlclxuICAgKlxuICAgKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICAgKiBAbGljZW5zZSAgTUlUXG4gICAqKVxuKi9cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6WyJfX2NyZWF0ZSIsIk9iamVjdCIsImNyZWF0ZSIsIl9fZGVmUHJvcCIsImRlZmluZVByb3BlcnR5IiwiX19nZXRPd25Qcm9wRGVzYyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9fZ2V0T3duUHJvcE5hbWVzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIl9fZ2V0UHJvdG9PZiIsImdldFByb3RvdHlwZU9mIiwiX19oYXNPd25Qcm9wIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJfX2NvbW1vbkpTIiwiY2IiLCJtb2QiLCJfX3JlcXVpcmUiLCJleHBvcnRzIiwiX19jb3B5UHJvcHMiLCJ0byIsImZyb20iLCJleGNlcHQiLCJkZXNjIiwia2V5IiwiY2FsbCIsImdldCIsImVudW1lcmFibGUiLCJfX3RvRVNNIiwiaXNOb2RlTW9kZSIsInRhcmdldCIsIl9fZXNNb2R1bGUiLCJ2YWx1ZSIsInJlcXVpcmVfbG9kYXNoIiwibW9kdWxlIiwidW5kZWZpbmVkMiIsIlZFUlNJT04iLCJMQVJHRV9BUlJBWV9TSVpFIiwiQ09SRV9FUlJPUl9URVhUIiwiRlVOQ19FUlJPUl9URVhUIiwiSU5WQUxJRF9URU1QTF9WQVJfRVJST1JfVEVYVCIsIkhBU0hfVU5ERUZJTkVEIiwiTUFYX01FTU9JWkVfU0laRSIsIlBMQUNFSE9MREVSIiwiQ0xPTkVfREVFUF9GTEFHIiwiQ0xPTkVfRkxBVF9GTEFHIiwiQ0xPTkVfU1lNQk9MU19GTEFHIiwiQ09NUEFSRV9QQVJUSUFMX0ZMQUciLCJDT01QQVJFX1VOT1JERVJFRF9GTEFHIiwiV1JBUF9CSU5EX0ZMQUciLCJXUkFQX0JJTkRfS0VZX0ZMQUciLCJXUkFQX0NVUlJZX0JPVU5EX0ZMQUciLCJXUkFQX0NVUlJZX0ZMQUciLCJXUkFQX0NVUlJZX1JJR0hUX0ZMQUciLCJXUkFQX1BBUlRJQUxfRkxBRyIsIldSQVBfUEFSVElBTF9SSUdIVF9GTEFHIiwiV1JBUF9BUllfRkxBRyIsIldSQVBfUkVBUkdfRkxBRyIsIldSQVBfRkxJUF9GTEFHIiwiREVGQVVMVF9UUlVOQ19MRU5HVEgiLCJERUZBVUxUX1RSVU5DX09NSVNTSU9OIiwiSE9UX0NPVU5UIiwiSE9UX1NQQU4iLCJMQVpZX0ZJTFRFUl9GTEFHIiwiTEFaWV9NQVBfRkxBRyIsIkxBWllfV0hJTEVfRkxBRyIsIklORklOSVRZIiwiTUFYX1NBRkVfSU5URUdFUiIsIk1BWF9JTlRFR0VSIiwiTkFOIiwiTUFYX0FSUkFZX0xFTkdUSCIsIk1BWF9BUlJBWV9JTkRFWCIsIkhBTEZfTUFYX0FSUkFZX0xFTkdUSCIsIndyYXBGbGFncyIsImFyZ3NUYWciLCJhcnJheVRhZyIsImFzeW5jVGFnIiwiYm9vbFRhZyIsImRhdGVUYWciLCJkb21FeGNUYWciLCJlcnJvclRhZyIsImZ1bmNUYWciLCJnZW5UYWciLCJtYXBUYWciLCJudW1iZXJUYWciLCJudWxsVGFnIiwib2JqZWN0VGFnIiwicHJvbWlzZVRhZyIsInByb3h5VGFnIiwicmVnZXhwVGFnIiwic2V0VGFnIiwic3RyaW5nVGFnIiwic3ltYm9sVGFnIiwidW5kZWZpbmVkVGFnIiwid2Vha01hcFRhZyIsIndlYWtTZXRUYWciLCJhcnJheUJ1ZmZlclRhZyIsImRhdGFWaWV3VGFnIiwiZmxvYXQzMlRhZyIsImZsb2F0NjRUYWciLCJpbnQ4VGFnIiwiaW50MTZUYWciLCJpbnQzMlRhZyIsInVpbnQ4VGFnIiwidWludDhDbGFtcGVkVGFnIiwidWludDE2VGFnIiwidWludDMyVGFnIiwicmVFbXB0eVN0cmluZ0xlYWRpbmciLCJyZUVtcHR5U3RyaW5nTWlkZGxlIiwicmVFbXB0eVN0cmluZ1RyYWlsaW5nIiwicmVFc2NhcGVkSHRtbCIsInJlVW5lc2NhcGVkSHRtbCIsInJlSGFzRXNjYXBlZEh0bWwiLCJSZWdFeHAiLCJzb3VyY2UiLCJyZUhhc1VuZXNjYXBlZEh0bWwiLCJyZUVzY2FwZSIsInJlRXZhbHVhdGUiLCJyZUludGVycG9sYXRlIiwicmVJc0RlZXBQcm9wIiwicmVJc1BsYWluUHJvcCIsInJlUHJvcE5hbWUiLCJyZVJlZ0V4cENoYXIiLCJyZUhhc1JlZ0V4cENoYXIiLCJyZVRyaW1TdGFydCIsInJlV2hpdGVzcGFjZSIsInJlV3JhcENvbW1lbnQiLCJyZVdyYXBEZXRhaWxzIiwicmVTcGxpdERldGFpbHMiLCJyZUFzY2lpV29yZCIsInJlRm9yYmlkZGVuSWRlbnRpZmllckNoYXJzIiwicmVFc2NhcGVDaGFyIiwicmVFc1RlbXBsYXRlIiwicmVGbGFncyIsInJlSXNCYWRIZXgiLCJyZUlzQmluYXJ5IiwicmVJc0hvc3RDdG9yIiwicmVJc09jdGFsIiwicmVJc1VpbnQiLCJyZUxhdGluIiwicmVOb01hdGNoIiwicmVVbmVzY2FwZWRTdHJpbmciLCJyc0FzdHJhbFJhbmdlIiwicnNDb21ib01hcmtzUmFuZ2UiLCJyZUNvbWJvSGFsZk1hcmtzUmFuZ2UiLCJyc0NvbWJvU3ltYm9sc1JhbmdlIiwicnNDb21ib1JhbmdlIiwicnNEaW5nYmF0UmFuZ2UiLCJyc0xvd2VyUmFuZ2UiLCJyc01hdGhPcFJhbmdlIiwicnNOb25DaGFyUmFuZ2UiLCJyc1B1bmN0dWF0aW9uUmFuZ2UiLCJyc1NwYWNlUmFuZ2UiLCJyc1VwcGVyUmFuZ2UiLCJyc1ZhclJhbmdlIiwicnNCcmVha1JhbmdlIiwicnNBcG9zIiwicnNBc3RyYWwiLCJyc0JyZWFrIiwicnNDb21ibyIsInJzRGlnaXRzIiwicnNEaW5nYmF0IiwicnNMb3dlciIsInJzTWlzYyIsInJzRml0eiIsInJzTW9kaWZpZXIiLCJyc05vbkFzdHJhbCIsInJzUmVnaW9uYWwiLCJyc1N1cnJQYWlyIiwicnNVcHBlciIsInJzWldKIiwicnNNaXNjTG93ZXIiLCJyc01pc2NVcHBlciIsInJzT3B0Q29udHJMb3dlciIsInJzT3B0Q29udHJVcHBlciIsInJlT3B0TW9kIiwicnNPcHRWYXIiLCJyc09wdEpvaW4iLCJqb2luIiwicnNPcmRMb3dlciIsInJzT3JkVXBwZXIiLCJyc1NlcSIsInJzRW1vamkiLCJyc1N5bWJvbCIsInJlQXBvcyIsInJlQ29tYm9NYXJrIiwicmVVbmljb2RlIiwicmVVbmljb2RlV29yZCIsInJlSGFzVW5pY29kZSIsInJlSGFzVW5pY29kZVdvcmQiLCJjb250ZXh0UHJvcHMiLCJ0ZW1wbGF0ZUNvdW50ZXIiLCJ0eXBlZEFycmF5VGFncyIsImNsb25lYWJsZVRhZ3MiLCJkZWJ1cnJlZExldHRlcnMiLCJodG1sRXNjYXBlcyIsImh0bWxVbmVzY2FwZXMiLCJzdHJpbmdFc2NhcGVzIiwiZnJlZVBhcnNlRmxvYXQiLCJwYXJzZUZsb2F0IiwiZnJlZVBhcnNlSW50IiwicGFyc2VJbnQiLCJmcmVlR2xvYmFsIiwiZ2xvYmFsIiwiZnJlZVNlbGYiLCJzZWxmIiwicm9vdCIsIkZ1bmN0aW9uIiwiZnJlZUV4cG9ydHMiLCJub2RlVHlwZSIsImZyZWVNb2R1bGUiLCJtb2R1bGVFeHBvcnRzIiwiZnJlZVByb2Nlc3MiLCJwcm9jZXNzIiwibm9kZVV0aWwiLCJ0eXBlcyIsInJlcXVpcmUiLCJiaW5kaW5nIiwiZSIsIm5vZGVJc0FycmF5QnVmZmVyIiwiaXNBcnJheUJ1ZmZlciIsIm5vZGVJc0RhdGUiLCJpc0RhdGUiLCJub2RlSXNNYXAiLCJpc01hcCIsIm5vZGVJc1JlZ0V4cCIsImlzUmVnRXhwIiwibm9kZUlzU2V0IiwiaXNTZXQiLCJub2RlSXNUeXBlZEFycmF5IiwiaXNUeXBlZEFycmF5IiwiYXBwbHkiLCJmdW5jIiwidGhpc0FyZyIsImFyZ3MiLCJsZW5ndGgiLCJhcnJheUFnZ3JlZ2F0b3IiLCJhcnJheSIsInNldHRlciIsIml0ZXJhdGVlIiwiYWNjdW11bGF0b3IiLCJpbmRleCIsImFycmF5RWFjaCIsImFycmF5RWFjaFJpZ2h0IiwiYXJyYXlFdmVyeSIsInByZWRpY2F0ZSIsImFycmF5RmlsdGVyIiwicmVzSW5kZXgiLCJyZXN1bHQiLCJhcnJheUluY2x1ZGVzIiwiYmFzZUluZGV4T2YiLCJhcnJheUluY2x1ZGVzV2l0aCIsImNvbXBhcmF0b3IiLCJhcnJheU1hcCIsIkFycmF5IiwiYXJyYXlQdXNoIiwidmFsdWVzIiwib2Zmc2V0IiwiYXJyYXlSZWR1Y2UiLCJpbml0QWNjdW0iLCJhcnJheVJlZHVjZVJpZ2h0IiwiYXJyYXlTb21lIiwiYXNjaWlTaXplIiwiYmFzZVByb3BlcnR5IiwiYXNjaWlUb0FycmF5Iiwic3RyaW5nIiwic3BsaXQiLCJhc2NpaVdvcmRzIiwibWF0Y2giLCJiYXNlRmluZEtleSIsImNvbGxlY3Rpb24iLCJlYWNoRnVuYyIsImNvbGxlY3Rpb24yIiwiYmFzZUZpbmRJbmRleCIsImZyb21JbmRleCIsImZyb21SaWdodCIsInN0cmljdEluZGV4T2YiLCJiYXNlSXNOYU4iLCJiYXNlSW5kZXhPZldpdGgiLCJiYXNlTWVhbiIsImJhc2VTdW0iLCJvYmplY3QiLCJiYXNlUHJvcGVydHlPZiIsImJhc2VSZWR1Y2UiLCJiYXNlU29ydEJ5IiwiY29tcGFyZXIiLCJzb3J0IiwiY3VycmVudCIsImJhc2VUaW1lcyIsIm4iLCJiYXNlVG9QYWlycyIsInByb3BzIiwiYmFzZVRyaW0iLCJzbGljZSIsInRyaW1tZWRFbmRJbmRleCIsInJlcGxhY2UiLCJiYXNlVW5hcnkiLCJiYXNlVmFsdWVzIiwiY2FjaGVIYXMiLCJjYWNoZSIsImhhcyIsImNoYXJzU3RhcnRJbmRleCIsInN0clN5bWJvbHMiLCJjaHJTeW1ib2xzIiwiY2hhcnNFbmRJbmRleCIsImNvdW50SG9sZGVycyIsInBsYWNlaG9sZGVyIiwiZGVidXJyTGV0dGVyIiwiZXNjYXBlSHRtbENoYXIiLCJlc2NhcGVTdHJpbmdDaGFyIiwiY2hyIiwiZ2V0VmFsdWUiLCJoYXNVbmljb2RlIiwidGVzdCIsImhhc1VuaWNvZGVXb3JkIiwiaXRlcmF0b3JUb0FycmF5IiwiaXRlcmF0b3IiLCJkYXRhIiwibmV4dCIsImRvbmUiLCJwdXNoIiwibWFwVG9BcnJheSIsIm1hcCIsInNpemUiLCJmb3JFYWNoIiwib3ZlckFyZyIsInRyYW5zZm9ybSIsImFyZyIsInJlcGxhY2VIb2xkZXJzIiwic2V0VG9BcnJheSIsInNldCIsInNldFRvUGFpcnMiLCJzdHJpY3RMYXN0SW5kZXhPZiIsInN0cmluZ1NpemUiLCJ1bmljb2RlU2l6ZSIsInN0cmluZ1RvQXJyYXkiLCJ1bmljb2RlVG9BcnJheSIsImNoYXJBdCIsInVuZXNjYXBlSHRtbENoYXIiLCJsYXN0SW5kZXgiLCJ1bmljb2RlV29yZHMiLCJydW5JbkNvbnRleHQiLCJydW5JbkNvbnRleHQyIiwiY29udGV4dCIsIl8iLCJkZWZhdWx0cyIsInBpY2siLCJBcnJheTIiLCJEYXRlMiIsIkRhdGUiLCJFcnJvcjIiLCJFcnJvciIsIkZ1bmN0aW9uMiIsIk1hdGgyIiwiTWF0aCIsIk9iamVjdDIiLCJSZWdFeHAyIiwiU3RyaW5nMiIsIlN0cmluZyIsIlR5cGVFcnJvcjIiLCJUeXBlRXJyb3IiLCJhcnJheVByb3RvIiwiZnVuY1Byb3RvIiwib2JqZWN0UHJvdG8iLCJjb3JlSnNEYXRhIiwiZnVuY1RvU3RyaW5nIiwidG9TdHJpbmciLCJpZENvdW50ZXIiLCJtYXNrU3JjS2V5IiwidWlkIiwiZXhlYyIsImtleXMiLCJJRV9QUk9UTyIsIm5hdGl2ZU9iamVjdFRvU3RyaW5nIiwib2JqZWN0Q3RvclN0cmluZyIsIm9sZERhc2giLCJyZUlzTmF0aXZlIiwiQnVmZmVyMiIsIkJ1ZmZlciIsIlN5bWJvbDIiLCJTeW1ib2wiLCJVaW50OEFycmF5MiIsIlVpbnQ4QXJyYXkiLCJhbGxvY1Vuc2FmZSIsImdldFByb3RvdHlwZSIsIm9iamVjdENyZWF0ZSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwic3BsaWNlIiwic3ByZWFkYWJsZVN5bWJvbCIsImlzQ29uY2F0U3ByZWFkYWJsZSIsInN5bUl0ZXJhdG9yIiwic3ltVG9TdHJpbmdUYWciLCJ0b1N0cmluZ1RhZyIsImdldE5hdGl2ZSIsImN0eENsZWFyVGltZW91dCIsImNsZWFyVGltZW91dCIsImN0eE5vdyIsIm5vdyIsImN0eFNldFRpbWVvdXQiLCJzZXRUaW1lb3V0IiwibmF0aXZlQ2VpbCIsImNlaWwiLCJuYXRpdmVGbG9vciIsImZsb29yIiwibmF0aXZlR2V0U3ltYm9scyIsImdldE93blByb3BlcnR5U3ltYm9scyIsIm5hdGl2ZUlzQnVmZmVyIiwiaXNCdWZmZXIiLCJuYXRpdmVJc0Zpbml0ZSIsImlzRmluaXRlIiwibmF0aXZlSm9pbiIsIm5hdGl2ZUtleXMiLCJuYXRpdmVNYXgiLCJtYXgiLCJuYXRpdmVNaW4iLCJtaW4iLCJuYXRpdmVOb3ciLCJuYXRpdmVQYXJzZUludCIsIm5hdGl2ZVJhbmRvbSIsInJhbmRvbSIsIm5hdGl2ZVJldmVyc2UiLCJyZXZlcnNlIiwiRGF0YVZpZXciLCJNYXAyIiwiUHJvbWlzZTIiLCJTZXQyIiwiV2Vha01hcDIiLCJuYXRpdmVDcmVhdGUiLCJtZXRhTWFwIiwicmVhbE5hbWVzIiwiZGF0YVZpZXdDdG9yU3RyaW5nIiwidG9Tb3VyY2UiLCJtYXBDdG9yU3RyaW5nIiwicHJvbWlzZUN0b3JTdHJpbmciLCJzZXRDdG9yU3RyaW5nIiwid2Vha01hcEN0b3JTdHJpbmciLCJzeW1ib2xQcm90byIsInN5bWJvbFZhbHVlT2YiLCJ2YWx1ZU9mIiwic3ltYm9sVG9TdHJpbmciLCJsb2Rhc2giLCJpc09iamVjdExpa2UiLCJpc0FycmF5IiwiTGF6eVdyYXBwZXIiLCJMb2Rhc2hXcmFwcGVyIiwid3JhcHBlckNsb25lIiwiYmFzZUNyZWF0ZSIsInByb3RvIiwiaXNPYmplY3QiLCJyZXN1bHQyIiwiYmFzZUxvZGFzaCIsImNoYWluQWxsIiwiX193cmFwcGVkX18iLCJfX2FjdGlvbnNfXyIsIl9fY2hhaW5fXyIsIl9faW5kZXhfXyIsIl9fdmFsdWVzX18iLCJ0ZW1wbGF0ZVNldHRpbmdzIiwiY29uc3RydWN0b3IiLCJfX2Rpcl9fIiwiX19maWx0ZXJlZF9fIiwiX19pdGVyYXRlZXNfXyIsIl9fdGFrZUNvdW50X18iLCJfX3ZpZXdzX18iLCJsYXp5Q2xvbmUiLCJjb3B5QXJyYXkiLCJsYXp5UmV2ZXJzZSIsImNsb25lIiwibGF6eVZhbHVlIiwiZGlyIiwiaXNBcnIiLCJpc1JpZ2h0IiwiYXJyTGVuZ3RoIiwidmlldyIsImdldFZpZXciLCJzdGFydCIsImVuZCIsIml0ZXJhdGVlcyIsIml0ZXJMZW5ndGgiLCJ0YWtlQ291bnQiLCJiYXNlV3JhcHBlclZhbHVlIiwib3V0ZXIiLCJpdGVySW5kZXgiLCJpdGVyYXRlZTIiLCJ0eXBlIiwiY29tcHV0ZWQiLCJIYXNoIiwiZW50cmllcyIsImNsZWFyIiwiZW50cnkiLCJoYXNoQ2xlYXIiLCJfX2RhdGFfXyIsImhhc2hEZWxldGUiLCJoYXNoR2V0IiwiaGFzaEhhcyIsImhhc2hTZXQiLCJMaXN0Q2FjaGUiLCJsaXN0Q2FjaGVDbGVhciIsImxpc3RDYWNoZURlbGV0ZSIsImFzc29jSW5kZXhPZiIsInBvcCIsImxpc3RDYWNoZUdldCIsImxpc3RDYWNoZUhhcyIsImxpc3RDYWNoZVNldCIsIk1hcENhY2hlIiwibWFwQ2FjaGVDbGVhciIsIm1hcENhY2hlRGVsZXRlIiwiZ2V0TWFwRGF0YSIsIm1hcENhY2hlR2V0IiwibWFwQ2FjaGVIYXMiLCJtYXBDYWNoZVNldCIsInNpemUyIiwiU2V0Q2FjaGUiLCJ2YWx1ZXMyIiwiYWRkIiwic2V0Q2FjaGVBZGQiLCJzZXRDYWNoZUhhcyIsIlN0YWNrIiwic3RhY2tDbGVhciIsInN0YWNrRGVsZXRlIiwic3RhY2tHZXQiLCJzdGFja0hhcyIsInN0YWNrU2V0IiwicGFpcnMiLCJhcnJheUxpa2VLZXlzIiwiaW5oZXJpdGVkIiwiaXNBcmciLCJpc0FyZ3VtZW50cyIsImlzQnVmZiIsImlzVHlwZSIsInNraXBJbmRleGVzIiwiaXNJbmRleCIsImFycmF5U2FtcGxlIiwiYmFzZVJhbmRvbSIsImFycmF5U2FtcGxlU2l6ZSIsInNodWZmbGVTZWxmIiwiYmFzZUNsYW1wIiwiYXJyYXlTaHVmZmxlIiwiYXNzaWduTWVyZ2VWYWx1ZSIsImVxIiwiYmFzZUFzc2lnblZhbHVlIiwiYXNzaWduVmFsdWUiLCJvYmpWYWx1ZSIsImJhc2VBZ2dyZWdhdG9yIiwiYmFzZUVhY2giLCJiYXNlQXNzaWduIiwiY29weU9iamVjdCIsImJhc2VBc3NpZ25JbiIsImtleXNJbiIsImJhc2VBdCIsInBhdGhzIiwic2tpcCIsIm51bWJlciIsImxvd2VyIiwidXBwZXIiLCJiYXNlQ2xvbmUiLCJiaXRtYXNrIiwiY3VzdG9taXplciIsInN0YWNrIiwiaXNEZWVwIiwiaXNGbGF0IiwiaXNGdWxsIiwiaW5pdENsb25lQXJyYXkiLCJ0YWciLCJnZXRUYWciLCJpc0Z1bmMiLCJjbG9uZUJ1ZmZlciIsImluaXRDbG9uZU9iamVjdCIsImNvcHlTeW1ib2xzSW4iLCJjb3B5U3ltYm9scyIsImluaXRDbG9uZUJ5VGFnIiwic3RhY2tlZCIsInN1YlZhbHVlIiwia2V5MiIsImtleXNGdW5jIiwiZ2V0QWxsS2V5c0luIiwiZ2V0QWxsS2V5cyIsImJhc2VDb25mb3JtcyIsImJhc2VDb25mb3Jtc1RvIiwiYmFzZURlbGF5Iiwid2FpdCIsImJhc2VEaWZmZXJlbmNlIiwiaW5jbHVkZXMyIiwiaXNDb21tb24iLCJ2YWx1ZXNMZW5ndGgiLCJ2YWx1ZXNJbmRleCIsImNyZWF0ZUJhc2VFYWNoIiwiYmFzZUZvck93biIsImJhc2VFYWNoUmlnaHQiLCJiYXNlRm9yT3duUmlnaHQiLCJiYXNlRXZlcnkiLCJiYXNlRXh0cmVtdW0iLCJpc1N5bWJvbCIsImJhc2VGaWxsIiwidG9JbnRlZ2VyIiwidG9MZW5ndGgiLCJiYXNlRmlsdGVyIiwiYmFzZUZsYXR0ZW4iLCJkZXB0aCIsImlzU3RyaWN0IiwiaXNGbGF0dGVuYWJsZSIsImJhc2VGb3IiLCJjcmVhdGVCYXNlRm9yIiwiYmFzZUZvclJpZ2h0IiwiYmFzZUZ1bmN0aW9ucyIsImlzRnVuY3Rpb24iLCJiYXNlR2V0IiwicGF0aCIsImNhc3RQYXRoIiwidG9LZXkiLCJiYXNlR2V0QWxsS2V5cyIsInN5bWJvbHNGdW5jIiwiYmFzZUdldFRhZyIsImdldFJhd1RhZyIsIm9iamVjdFRvU3RyaW5nIiwiYmFzZUd0Iiwib3RoZXIiLCJiYXNlSGFzIiwiYmFzZUhhc0luIiwiYmFzZUluUmFuZ2UiLCJiYXNlSW50ZXJzZWN0aW9uIiwiYXJyYXlzIiwib3RoTGVuZ3RoIiwib3RoSW5kZXgiLCJjYWNoZXMiLCJtYXhMZW5ndGgiLCJJbmZpbml0eSIsInNlZW4iLCJiYXNlSW52ZXJ0ZXIiLCJvYmplY3QyIiwiYmFzZUludm9rZSIsInBhcmVudCIsImxhc3QiLCJiYXNlSXNBcmd1bWVudHMiLCJiYXNlSXNBcnJheUJ1ZmZlciIsImJhc2VJc0RhdGUiLCJiYXNlSXNFcXVhbCIsImJhc2VJc0VxdWFsRGVlcCIsImVxdWFsRnVuYyIsIm9iaklzQXJyIiwib3RoSXNBcnIiLCJvYmpUYWciLCJvdGhUYWciLCJvYmpJc09iaiIsIm90aElzT2JqIiwiaXNTYW1lVGFnIiwiZXF1YWxBcnJheXMiLCJlcXVhbEJ5VGFnIiwib2JqSXNXcmFwcGVkIiwib3RoSXNXcmFwcGVkIiwib2JqVW53cmFwcGVkIiwib3RoVW53cmFwcGVkIiwiZXF1YWxPYmplY3RzIiwiYmFzZUlzTWFwIiwiYmFzZUlzTWF0Y2giLCJtYXRjaERhdGEiLCJub0N1c3RvbWl6ZXIiLCJzcmNWYWx1ZSIsImJhc2VJc05hdGl2ZSIsImlzTWFza2VkIiwicGF0dGVybiIsImJhc2VJc1JlZ0V4cCIsImJhc2VJc1NldCIsImJhc2VJc1R5cGVkQXJyYXkiLCJpc0xlbmd0aCIsImJhc2VJdGVyYXRlZSIsImlkZW50aXR5IiwiYmFzZU1hdGNoZXNQcm9wZXJ0eSIsImJhc2VNYXRjaGVzIiwicHJvcGVydHkiLCJiYXNlS2V5cyIsImlzUHJvdG90eXBlIiwiYmFzZUtleXNJbiIsIm5hdGl2ZUtleXNJbiIsImlzUHJvdG8iLCJiYXNlTHQiLCJiYXNlTWFwIiwiaXNBcnJheUxpa2UiLCJnZXRNYXRjaERhdGEiLCJtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSIsImlzS2V5IiwiaXNTdHJpY3RDb21wYXJhYmxlIiwiaGFzSW4iLCJiYXNlTWVyZ2UiLCJzcmNJbmRleCIsImJhc2VNZXJnZURlZXAiLCJuZXdWYWx1ZSIsInNhZmVHZXQiLCJtZXJnZUZ1bmMiLCJpc1R5cGVkIiwiaXNBcnJheUxpa2VPYmplY3QiLCJjbG9uZVR5cGVkQXJyYXkiLCJpc1BsYWluT2JqZWN0IiwidG9QbGFpbk9iamVjdCIsImJhc2VOdGgiLCJiYXNlT3JkZXJCeSIsIm9yZGVycyIsImdldEl0ZXJhdGVlIiwiY3JpdGVyaWEiLCJjb21wYXJlTXVsdGlwbGUiLCJiYXNlUGljayIsImJhc2VQaWNrQnkiLCJiYXNlU2V0IiwiYmFzZVByb3BlcnR5RGVlcCIsImJhc2VQdWxsQWxsIiwiaW5kZXhPZjIiLCJiYXNlUHVsbEF0IiwiaW5kZXhlcyIsInByZXZpb3VzIiwiYmFzZVVuc2V0IiwiYmFzZVJhbmdlIiwic3RlcCIsImJhc2VSZXBlYXQiLCJiYXNlUmVzdCIsInNldFRvU3RyaW5nIiwib3ZlclJlc3QiLCJiYXNlU2FtcGxlIiwiYmFzZVNhbXBsZVNpemUiLCJuZXN0ZWQiLCJiYXNlU2V0RGF0YSIsImJhc2VTZXRUb1N0cmluZyIsImNvbnN0YW50IiwiYmFzZVNodWZmbGUiLCJiYXNlU2xpY2UiLCJiYXNlU29tZSIsImJhc2VTb3J0ZWRJbmRleCIsInJldEhpZ2hlc3QiLCJsb3ciLCJoaWdoIiwibWlkIiwiYmFzZVNvcnRlZEluZGV4QnkiLCJ2YWxJc05hTiIsInZhbElzTnVsbCIsInZhbElzU3ltYm9sIiwidmFsSXNVbmRlZmluZWQiLCJvdGhJc0RlZmluZWQiLCJvdGhJc051bGwiLCJvdGhJc1JlZmxleGl2ZSIsIm90aElzU3ltYm9sIiwic2V0TG93IiwiYmFzZVNvcnRlZFVuaXEiLCJiYXNlVG9OdW1iZXIiLCJiYXNlVG9TdHJpbmciLCJiYXNlVW5pcSIsInNldDIiLCJjcmVhdGVTZXQiLCJzZWVuSW5kZXgiLCJiYXNlVXBkYXRlIiwidXBkYXRlciIsImJhc2VXaGlsZSIsImlzRHJvcCIsImFjdGlvbnMiLCJyZXN1bHQzIiwiYWN0aW9uIiwiYmFzZVhvciIsImJhc2VaaXBPYmplY3QiLCJhc3NpZ25GdW5jIiwidmFsc0xlbmd0aCIsImNhc3RBcnJheUxpa2VPYmplY3QiLCJjYXN0RnVuY3Rpb24iLCJzdHJpbmdUb1BhdGgiLCJjYXN0UmVzdCIsImNhc3RTbGljZSIsImlkIiwiYnVmZmVyIiwiY29weSIsImNsb25lQXJyYXlCdWZmZXIiLCJhcnJheUJ1ZmZlciIsImJ5dGVMZW5ndGgiLCJjbG9uZURhdGFWaWV3IiwiZGF0YVZpZXciLCJieXRlT2Zmc2V0IiwiY2xvbmVSZWdFeHAiLCJyZWdleHAiLCJjbG9uZVN5bWJvbCIsInN5bWJvbCIsInR5cGVkQXJyYXkiLCJjb21wYXJlQXNjZW5kaW5nIiwidmFsSXNEZWZpbmVkIiwidmFsSXNSZWZsZXhpdmUiLCJvYmpDcml0ZXJpYSIsIm90aENyaXRlcmlhIiwib3JkZXJzTGVuZ3RoIiwib3JkZXIiLCJjb21wb3NlQXJncyIsInBhcnRpYWxzIiwiaG9sZGVycyIsImlzQ3VycmllZCIsImFyZ3NJbmRleCIsImFyZ3NMZW5ndGgiLCJob2xkZXJzTGVuZ3RoIiwibGVmdEluZGV4IiwibGVmdExlbmd0aCIsInJhbmdlTGVuZ3RoIiwiaXNVbmN1cnJpZWQiLCJjb21wb3NlQXJnc1JpZ2h0IiwiaG9sZGVyc0luZGV4IiwicmlnaHRJbmRleCIsInJpZ2h0TGVuZ3RoIiwiaXNOZXciLCJnZXRTeW1ib2xzIiwiZ2V0U3ltYm9sc0luIiwiY3JlYXRlQWdncmVnYXRvciIsImluaXRpYWxpemVyIiwiY3JlYXRlQXNzaWduZXIiLCJhc3NpZ25lciIsInNvdXJjZXMiLCJndWFyZCIsImlzSXRlcmF0ZWVDYWxsIiwiaXRlcmFibGUiLCJjcmVhdGVCaW5kIiwiaXNCaW5kIiwiQ3RvciIsImNyZWF0ZUN0b3IiLCJ3cmFwcGVyIiwiZm4iLCJhcmd1bWVudHMiLCJjcmVhdGVDYXNlRmlyc3QiLCJtZXRob2ROYW1lIiwidHJhaWxpbmciLCJjcmVhdGVDb21wb3VuZGVyIiwiY2FsbGJhY2siLCJ3b3JkcyIsImRlYnVyciIsInRoaXNCaW5kaW5nIiwiY3JlYXRlQ3VycnkiLCJhcml0eSIsImdldEhvbGRlciIsImNyZWF0ZVJlY3VycnkiLCJjcmVhdGVIeWJyaWQiLCJjcmVhdGVGaW5kIiwiZmluZEluZGV4RnVuYyIsImNyZWF0ZUZsb3ciLCJmbGF0UmVzdCIsImZ1bmNzIiwicHJlcmVxIiwidGhydSIsImdldEZ1bmNOYW1lIiwiZnVuY05hbWUiLCJnZXREYXRhIiwiaXNMYXppYWJsZSIsInBsYW50IiwiaW5kZXgyIiwicGFydGlhbHNSaWdodCIsImhvbGRlcnNSaWdodCIsImFyZ1BvcyIsImFyeTIiLCJpc0FyeSIsImlzQmluZEtleSIsImlzRmxpcCIsImhvbGRlcnNDb3VudCIsIm5ld0hvbGRlcnMiLCJyZW9yZGVyIiwiY3JlYXRlSW52ZXJ0ZXIiLCJ0b0l0ZXJhdGVlIiwiY3JlYXRlTWF0aE9wZXJhdGlvbiIsIm9wZXJhdG9yIiwiZGVmYXVsdFZhbHVlIiwiY3JlYXRlT3ZlciIsImFycmF5RnVuYyIsImNyZWF0ZVBhZGRpbmciLCJjaGFycyIsImNoYXJzTGVuZ3RoIiwiY3JlYXRlUGFydGlhbCIsImNyZWF0ZVJhbmdlIiwidG9GaW5pdGUiLCJjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uIiwidG9OdW1iZXIiLCJ3cmFwRnVuYyIsImlzQ3VycnkiLCJuZXdIb2xkZXJzUmlnaHQiLCJuZXdQYXJ0aWFscyIsIm5ld1BhcnRpYWxzUmlnaHQiLCJuZXdEYXRhIiwic2V0RGF0YSIsInNldFdyYXBUb1N0cmluZyIsImNyZWF0ZVJvdW5kIiwicHJlY2lzaW9uIiwicGFpciIsIm5vb3AiLCJjcmVhdGVUb1BhaXJzIiwiY3JlYXRlV3JhcCIsIm1lcmdlRGF0YSIsImN1c3RvbURlZmF1bHRzQXNzaWduSW4iLCJjdXN0b21EZWZhdWx0c01lcmdlIiwiY3VzdG9tT21pdENsb25lIiwiaXNQYXJ0aWFsIiwiYXJyU3RhY2tlZCIsIm90aFN0YWNrZWQiLCJhcnJWYWx1ZSIsIm90aFZhbHVlIiwiY29tcGFyZWQiLCJvdGhWYWx1ZTIiLCJuYW1lIiwibWVzc2FnZSIsImNvbnZlcnQiLCJvYmpQcm9wcyIsIm9iakxlbmd0aCIsIm90aFByb3BzIiwib2JqU3RhY2tlZCIsInNraXBDdG9yIiwib2JqQ3RvciIsIm90aEN0b3IiLCJmbGF0dGVuIiwib3RoZXJGdW5jIiwibWFwMiIsImlzS2V5YWJsZSIsImlzT3duIiwidW5tYXNrZWQiLCJzdHViQXJyYXkiLCJBcnJheUJ1ZmZlciIsInJlc29sdmUiLCJjdG9yU3RyaW5nIiwidHJhbnNmb3JtcyIsImdldFdyYXBEZXRhaWxzIiwiaGFzUGF0aCIsImhhc0Z1bmMiLCJpbnB1dCIsImluc2VydFdyYXBEZXRhaWxzIiwiZGV0YWlscyIsImlzTWFza2FibGUiLCJzdHViRmFsc2UiLCJtZW1vaXplQ2FwcGVkIiwibWVtb2l6ZTIiLCJzcmNCaXRtYXNrIiwibmV3Qml0bWFzayIsImlzQ29tYm8iLCJ0cmFuc2Zvcm0yIiwib3RoZXJBcmdzIiwib2xkQXJyYXkiLCJzaG9ydE91dCIsInJlZmVyZW5jZSIsInVwZGF0ZVdyYXBEZXRhaWxzIiwiY291bnQiLCJsYXN0Q2FsbGVkIiwic3RhbXAiLCJyZW1haW5pbmciLCJyYW5kIiwiY2hhckNvZGVBdCIsInF1b3RlIiwic3ViU3RyaW5nIiwiY2h1bmsiLCJjb21wYWN0IiwiY29uY2F0IiwiZGlmZmVyZW5jZSIsImRpZmZlcmVuY2VCeSIsImRpZmZlcmVuY2VXaXRoIiwiZHJvcCIsImRyb3BSaWdodCIsImRyb3BSaWdodFdoaWxlIiwiZHJvcFdoaWxlIiwiZmlsbCIsImZpbmRJbmRleCIsImZpbmRMYXN0SW5kZXgiLCJmbGF0dGVuRGVlcCIsImZsYXR0ZW5EZXB0aCIsImZyb21QYWlycyIsImhlYWQiLCJpbmRleE9mIiwiaW5pdGlhbCIsImludGVyc2VjdGlvbiIsIm1hcHBlZCIsImludGVyc2VjdGlvbkJ5IiwiaW50ZXJzZWN0aW9uV2l0aCIsInNlcGFyYXRvciIsImxhc3RJbmRleE9mIiwibnRoIiwicHVsbCIsInB1bGxBbGwiLCJwdWxsQWxsQnkiLCJwdWxsQWxsV2l0aCIsInB1bGxBdCIsInJlbW92ZSIsInNvcnRlZEluZGV4Iiwic29ydGVkSW5kZXhCeSIsInNvcnRlZEluZGV4T2YiLCJzb3J0ZWRMYXN0SW5kZXgiLCJzb3J0ZWRMYXN0SW5kZXhCeSIsInNvcnRlZExhc3RJbmRleE9mIiwic29ydGVkVW5pcSIsInNvcnRlZFVuaXFCeSIsInRhaWwiLCJ0YWtlIiwidGFrZVJpZ2h0IiwidGFrZVJpZ2h0V2hpbGUiLCJ0YWtlV2hpbGUiLCJ1bmlvbiIsInVuaW9uQnkiLCJ1bmlvbldpdGgiLCJ1bmlxIiwidW5pcUJ5IiwidW5pcVdpdGgiLCJ1bnppcCIsImdyb3VwIiwidW56aXBXaXRoIiwid2l0aG91dCIsInhvciIsInhvckJ5IiwieG9yV2l0aCIsInppcCIsInppcE9iamVjdCIsInppcE9iamVjdERlZXAiLCJ6aXBXaXRoIiwiY2hhaW4iLCJ0YXAiLCJpbnRlcmNlcHRvciIsIndyYXBwZXJBdCIsIndyYXBwZXJDaGFpbiIsIndyYXBwZXJDb21taXQiLCJ3cmFwcGVyTmV4dCIsInRvQXJyYXkiLCJ3cmFwcGVyVG9JdGVyYXRvciIsIndyYXBwZXJQbGFudCIsInBhcmVudDIiLCJjbG9uZTIiLCJ3cmFwcGVyUmV2ZXJzZSIsIndyYXBwZWQiLCJ3cmFwcGVyVmFsdWUiLCJjb3VudEJ5IiwiZXZlcnkiLCJmaWx0ZXIiLCJmaW5kIiwiZmluZExhc3QiLCJmbGF0TWFwIiwiZmxhdE1hcERlZXAiLCJmbGF0TWFwRGVwdGgiLCJmb3JFYWNoUmlnaHQiLCJncm91cEJ5IiwiaW5jbHVkZXMiLCJpc1N0cmluZyIsImludm9rZU1hcCIsImtleUJ5Iiwib3JkZXJCeSIsInBhcnRpdGlvbiIsInJlZHVjZSIsInJlZHVjZVJpZ2h0IiwicmVqZWN0IiwibmVnYXRlIiwic2FtcGxlIiwic2FtcGxlU2l6ZSIsInNodWZmbGUiLCJzb21lIiwic29ydEJ5IiwiYWZ0ZXIiLCJhcnkiLCJiZWZvcmUiLCJiaW5kIiwiYmluZEtleSIsImN1cnJ5IiwiY3VycnlSaWdodCIsImRlYm91bmNlIiwib3B0aW9ucyIsImxhc3RBcmdzIiwibGFzdFRoaXMiLCJtYXhXYWl0IiwidGltZXJJZCIsImxhc3RDYWxsVGltZSIsImxhc3RJbnZva2VUaW1lIiwibGVhZGluZyIsIm1heGluZyIsImludm9rZUZ1bmMiLCJ0aW1lIiwibGVhZGluZ0VkZ2UiLCJ0aW1lckV4cGlyZWQiLCJyZW1haW5pbmdXYWl0IiwidGltZVNpbmNlTGFzdENhbGwiLCJ0aW1lU2luY2VMYXN0SW52b2tlIiwidGltZVdhaXRpbmciLCJzaG91bGRJbnZva2UiLCJ0cmFpbGluZ0VkZ2UiLCJjYW5jZWwiLCJmbHVzaCIsImRlYm91bmNlZCIsImlzSW52b2tpbmciLCJkZWZlciIsImRlbGF5IiwiZmxpcCIsInJlc29sdmVyIiwibWVtb2l6ZWQiLCJDYWNoZSIsIm9uY2UiLCJvdmVyQXJncyIsImZ1bmNzTGVuZ3RoIiwicGFydGlhbCIsInBhcnRpYWxSaWdodCIsInJlYXJnIiwicmVzdCIsInNwcmVhZCIsInRocm90dGxlIiwidW5hcnkiLCJ3cmFwIiwiY2FzdEFycmF5IiwiY2xvbmVXaXRoIiwiY2xvbmVEZWVwIiwiY2xvbmVEZWVwV2l0aCIsImNvbmZvcm1zVG8iLCJndCIsImd0ZSIsImlzQm9vbGVhbiIsImlzRWxlbWVudCIsImlzRW1wdHkiLCJpc0VxdWFsIiwiaXNFcXVhbFdpdGgiLCJpc0Vycm9yIiwiaXNGaW5pdGUyIiwiaXNJbnRlZ2VyIiwiaXNNYXRjaCIsImlzTWF0Y2hXaXRoIiwiaXNOYU4yIiwiaXNOdW1iZXIiLCJpc05hdGl2ZSIsImlzTnVsbCIsImlzTmlsIiwiaXNTYWZlSW50ZWdlciIsImlzVW5kZWZpbmVkIiwiaXNXZWFrTWFwIiwiaXNXZWFrU2V0IiwibHQiLCJsdGUiLCJzaWduIiwicmVtYWluZGVyIiwiaXNCaW5hcnkiLCJ0b1NhZmVJbnRlZ2VyIiwiYXNzaWduIiwiYXNzaWduSW4iLCJhc3NpZ25JbldpdGgiLCJhc3NpZ25XaXRoIiwiYXQiLCJwcm9wZXJ0aWVzIiwicHJvcHNJbmRleCIsInByb3BzTGVuZ3RoIiwiZGVmYXVsdHNEZWVwIiwibWVyZ2VXaXRoIiwiZmluZEtleSIsImZpbmRMYXN0S2V5IiwiZm9ySW4iLCJmb3JJblJpZ2h0IiwiZm9yT3duIiwiZm9yT3duUmlnaHQiLCJmdW5jdGlvbnMiLCJmdW5jdGlvbnNJbiIsImludmVydCIsImludmVydEJ5IiwiaW52b2tlIiwibWFwS2V5cyIsIm1hcFZhbHVlcyIsIm1lcmdlIiwib21pdCIsIm9taXRCeSIsInBpY2tCeSIsInByb3AiLCJzZXRXaXRoIiwidG9QYWlycyIsInRvUGFpcnNJbiIsImlzQXJyTGlrZSIsInVuc2V0IiwidXBkYXRlIiwidXBkYXRlV2l0aCIsInZhbHVlc0luIiwiY2xhbXAiLCJpblJhbmdlIiwiZmxvYXRpbmciLCJ0ZW1wIiwiY2FtZWxDYXNlIiwid29yZCIsInRvTG93ZXJDYXNlIiwiY2FwaXRhbGl6ZSIsInVwcGVyRmlyc3QiLCJlbmRzV2l0aCIsInBvc2l0aW9uIiwiZXNjYXBlIiwiZXNjYXBlUmVnRXhwIiwia2ViYWJDYXNlIiwibG93ZXJDYXNlIiwibG93ZXJGaXJzdCIsInBhZCIsInN0ckxlbmd0aCIsInBhZEVuZCIsInBhZFN0YXJ0IiwicGFyc2VJbnQyIiwicmFkaXgiLCJyZXBlYXQiLCJzbmFrZUNhc2UiLCJsaW1pdCIsInN0YXJ0Q2FzZSIsInN0YXJ0c1dpdGgiLCJ0ZW1wbGF0ZSIsInNldHRpbmdzIiwiaW1wb3J0cyIsImltcG9ydHNLZXlzIiwiaW1wb3J0c1ZhbHVlcyIsImlzRXNjYXBpbmciLCJpc0V2YWx1YXRpbmciLCJpbnRlcnBvbGF0ZSIsInJlRGVsaW1pdGVycyIsImV2YWx1YXRlIiwic291cmNlVVJMIiwiZXNjYXBlVmFsdWUiLCJpbnRlcnBvbGF0ZVZhbHVlIiwiZXNUZW1wbGF0ZVZhbHVlIiwiZXZhbHVhdGVWYWx1ZSIsInZhcmlhYmxlIiwiYXR0ZW1wdCIsInRvTG93ZXIiLCJ0b1VwcGVyIiwidG9VcHBlckNhc2UiLCJ0cmltIiwidHJpbUVuZCIsInRyaW1TdGFydCIsInRydW5jYXRlIiwib21pc3Npb24iLCJzZWFyY2giLCJzdWJzdHJpbmciLCJuZXdFbmQiLCJ1bmVzY2FwZSIsInVwcGVyQ2FzZSIsImJpbmRBbGwiLCJtZXRob2ROYW1lcyIsImNvbmQiLCJjb25mb3JtcyIsImRlZmF1bHRUbyIsImZsb3ciLCJmbG93UmlnaHQiLCJtYXRjaGVzIiwibWF0Y2hlc1Byb3BlcnR5IiwibWV0aG9kIiwibWV0aG9kT2YiLCJtaXhpbiIsImNoYWluMiIsIm5vQ29uZmxpY3QiLCJudGhBcmciLCJvdmVyIiwib3ZlckV2ZXJ5Iiwib3ZlclNvbWUiLCJwcm9wZXJ0eU9mIiwicmFuZ2UiLCJyYW5nZVJpZ2h0Iiwic3R1Yk9iamVjdCIsInN0dWJTdHJpbmciLCJzdHViVHJ1ZSIsInRpbWVzIiwidG9QYXRoIiwidW5pcXVlSWQiLCJwcmVmaXgiLCJhdWdlbmQiLCJhZGRlbmQiLCJkaXZpZGUiLCJkaXZpZGVuZCIsImRpdmlzb3IiLCJtYXhCeSIsIm1lYW4iLCJtZWFuQnkiLCJtaW5CeSIsIm11bHRpcGx5IiwibXVsdGlwbGllciIsIm11bHRpcGxpY2FuZCIsInJvdW5kIiwic3VidHJhY3QiLCJtaW51ZW5kIiwic3VidHJhaGVuZCIsInN1bSIsInN1bUJ5IiwibWVtb2l6ZSIsImVudHJpZXNJbiIsImV4dGVuZCIsImV4dGVuZFdpdGgiLCJpc05hTiIsImVhY2giLCJlYWNoUmlnaHQiLCJmaXJzdCIsImlzRmlsdGVyIiwidGFrZU5hbWUiLCJkcm9wTmFtZSIsImNoZWNrSXRlcmF0ZWUiLCJpc1Rha2VyIiwibG9kYXNoRnVuYyIsInJldFVud3JhcHBlZCIsImlzTGF6eSIsInVzZUxhenkiLCJ2YWx1ZTIiLCJpc0h5YnJpZCIsImlzVW53cmFwcGVkIiwib25seUxhenkiLCJjaGFpbk5hbWUiLCJjb21taXQiLCJ0b0pTT04iLCJkZWZpbmUiLCJhbWQiLCJyZXF1aXJlX2lvdGEiLCJpb3RhIiwiaSIsInJlcXVpcmVfaXNfYnVmZmVyIiwib2JqIiwiaXNTbG93QnVmZmVyIiwiX2lzQnVmZmVyIiwicmVhZEZsb2F0TEUiLCJyZXF1aXJlX25kYXJyYXkiLCJoYXNUeXBlZEFycmF5cyIsIkZsb2F0NjRBcnJheSIsImNvbXBhcmUxc3QiLCJhIiwiYiIsInN0cmlkZSIsInRlcm1zIiwiYWJzIiwiY29tcGlsZUNvbnN0cnVjdG9yIiwiZHR5cGUiLCJkaW1lbnNpb24iLCJjbGFzc05hbWUiLCJ1c2VHZXR0ZXJzIiwiY29kZSIsInByb2NlZHVyZSIsIkNBQ0hFRF9DT05TVFJVQ1RPUlMiLCJpbmRpY2VzIiwiaTIiLCJpbmRleF9zdHIiLCJzaGFwZUFyZyIsInN0cmlkZUFyZyIsImFfdmFycyIsImNfdmFycyIsInRTaGFwZSIsInRTdHJpZGUiLCJpZHgiLCJhcnJheURUeXBlIiwid3JhcHBlZE5EQXJyYXlDdG9yIiwic2hhcGUiLCJjdG9yIiwiZCIsInN6IiwiY3Rvcl9saXN0IiwiaW1wb3J0X2xvZGFzaCIsImltcG9ydF9uZGFycmF5MiIsIk1pbWVUeXBlIiwiX01pbWVUeXBlIiwicGFyYW1zU3RyIiwicGFyYW1zIiwiaXNJZGVudGljYWwiLCJmcm9tU3RyaW5nIiwibWltZVR5cGUiLCJwYXJhbXNBcnIiLCJwYXJhbSIsImltcG9ydF9uZGFycmF5IiwiaW1hZ2VEZWNvZGUiLCJibG9iIiwibWltZSIsIndpZHRoIiwiaGVpZ2h0IiwiZGVmYXVsdCIsImltYWdlQml0bWFwIiwiY3JlYXRlSW1hZ2VCaXRtYXAiLCJpbWFnZURhdGEiLCJpbWFnZUJpdG1hcFRvSW1hZ2VEYXRhIiwiaW1hZ2VFbmNvZGUiLCJpbWFnZVRlbnNvciIsInF1YWxpdHkiLCJmb3JtYXQiLCJjaGFubmVscyIsIkJsb2IiLCJJbWFnZURhdGEiLCJVaW50OENsYW1wZWRBcnJheSIsImNhbnZhcyIsImNyZWF0ZUNhbnZhcyIsImN0eCIsImdldENvbnRleHQiLCJwdXRJbWFnZURhdGEiLCJjb252ZXJ0VG9CbG9iIiwiaXNBYnNvbHV0ZVVSSSIsInVybCIsInJlZ0V4cCIsImVuc3VyZUFic29sdXRlVVJJIiwiYmFzZVVybCIsIlVSTCIsImhyZWYiLCJkcmF3SW1hZ2UiLCJnZXRJbWFnZURhdGEiLCJjcmVhdGVUeXBlQXJyYXkiLCJVaW50MTZBcnJheSIsIlVpbnQzMkFycmF5IiwiRmxvYXQzMkFycmF5IiwidGVuc29yUmVzaXplQmlsaW5lYXIiLCJuZXdXaWR0aCIsIm5ld0hlaWdodCIsInByb3BvcnRpb25hbCIsInNyY0hlaWdodCIsInNyY1dpZHRoIiwic3JjQ2hhbm5lbHMiLCJzY2FsZVgiLCJzY2FsZVkiLCJkb3duc2NhbGluZyIsInJlc2l6ZWRJbWFnZURhdGEiLCJ5IiwieCIsInNyY1giLCJzcmNZIiwieDEiLCJ4MiIsInkxIiwieTIiLCJkeCIsImR5IiwiYyIsInAxIiwicDIiLCJwMyIsInA0IiwiaW50ZXJwb2xhdGVkVmFsdWUiLCJ0ZW5zb3JIV0N0b0JDSFciLCJzdGQiLCJpbWFnZUJ1ZmZlckRhdGEiLCJmbG9hdDMyRGF0YSIsImoiLCJpbWFnZVNvdXJjZVRvSW1hZ2VEYXRhIiwiaW1hZ2UiLCJjb25maWciLCJwdWJsaWNQYXRoIiwicmVzcG9uc2UiLCJmZXRjaCIsImlzVmlldyIsImNvbnZlcnRGbG9hdDMyVG9VaW50OCIsImZsb2F0MzJBcnJheSIsInVpbnQ4QXJyYXkiLCJPZmZzY3JlZW5DYW52YXMiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJpbXBvcnRfbmRhcnJheTMiLCJ3ZWJncHUiLCJuYXZpZ2F0b3IiLCJncHUiLCJhZGFwdGVyIiwicmVxdWVzdEFkYXB0ZXIiLCJtYXhOdW1UaHJlYWRzIiwiaGFyZHdhcmVDb25jdXJyZW5jeSIsImxvYWRBc1VybCIsImNyZWF0ZU9iamVjdFVSTCIsImxvYWRBc0Jsb2IiLCJyZXNvdXJjZVVybCIsInJlc291cmNlUmVzcG9uc2UiLCJvayIsInJlc291cmNlTWFwIiwianNvbiIsImNodW5rcyIsImRvd25sb2FkZWRTaXplIiwicmVzcG9uc2VzIiwiY2h1bmtTaXplIiwib2Zmc2V0cyIsImZldGNoQXJncyIsInByb2dyZXNzIiwiYWxsQ2h1bmtEYXRhIiwiUHJvbWlzZSIsImFsbCIsIm9ydCIsImdldE9ydCIsInVzZVdlYkdQVSIsImNyZWF0ZU9ubnhTZXNzaW9uIiwibW9kZWwiLCJkZXZpY2UiLCJwcm94eVRvV29ya2VyIiwiZXhlY3V0aW9uUHJvdmlkZXJzIiwib3J0MiIsImRlYnVnIiwiY29uc29sZSIsImVudiIsImxvZ0xldmVsIiwid2FzbSIsIm51bVRocmVhZHMiLCJwcm94eSIsImJhc2VGaWxlUGF0aCIsIndhc21QYXRoIiwibWpzUGF0aCIsIndhc21QYXRocyIsIm1qcyIsIm9ydENvbmZpZyIsImdyYXBoT3B0aW1pemF0aW9uTGV2ZWwiLCJleGVjdXRpb25Nb2RlIiwiZW5hYmxlQ3B1TWVtQXJlbmEiLCJzZXNzaW9uIiwiSW5mZXJlbmNlU2Vzc2lvbiIsImNhdGNoIiwicnVuT25ueFNlc3Npb24iLCJpbnB1dHMiLCJvdXRwdXRzIiwiZmVlZHMiLCJ0ZW5zb3IiLCJUZW5zb3IiLCJvdXRwdXREYXRhIiwicnVuIiwib3V0cHV0S1ZQYWlycyIsIm91dHB1dCIsImRpbXMiLCJ1dGlsIiwidXRpbDIiLCJhc3NlcnRFcXVhbCIsInZhbCIsImFzc2VydElzIiwiX2FyZyIsImFzc2VydE5ldmVyIiwiX3giLCJhcnJheVRvRW51bSIsIml0ZW1zIiwiaXRlbSIsImdldFZhbGlkRW51bVZhbHVlcyIsInZhbGlkS2V5cyIsIm9iamVjdEtleXMiLCJrIiwiZmlsdGVyZWQiLCJvYmplY3RWYWx1ZXMiLCJhcnIiLCJjaGVja2VyIiwiTnVtYmVyIiwiam9pblZhbHVlcyIsImpzb25TdHJpbmdpZnlSZXBsYWNlciIsIm9iamVjdFV0aWwiLCJvYmplY3RVdGlsMiIsIm1lcmdlU2hhcGVzIiwic2Vjb25kIiwiWm9kUGFyc2VkVHlwZSIsImdldFBhcnNlZFR5cGUiLCJ0IiwidW5kZWZpbmVkIiwibmFuIiwiYm9vbGVhbiIsImZ1bmN0aW9uIiwiYmlnaW50IiwibnVsbCIsInRoZW4iLCJwcm9taXNlIiwiTWFwIiwiU2V0IiwiZGF0ZSIsInVua25vd24iLCJab2RJc3N1ZUNvZGUiLCJxdW90ZWxlc3NKc29uIiwiSlNPTiIsInN0cmluZ2lmeSIsIlpvZEVycm9yIiwiX1pvZEVycm9yIiwiZXJyb3JzIiwiaXNzdWVzIiwiX21hcHBlciIsIm1hcHBlciIsImlzc3VlIiwiZmllbGRFcnJvcnMiLCJfZXJyb3JzIiwicHJvY2Vzc0Vycm9yIiwiZXJyb3IiLCJ1bmlvbkVycm9ycyIsInJldHVyblR5cGVFcnJvciIsImFyZ3VtZW50c0Vycm9yIiwiY3VyciIsImVsIiwidGVybWluYWwiLCJhc3NlcnQiLCJmb3JtRXJyb3JzIiwic3ViIiwiYWRkSXNzdWUiLCJhZGRJc3N1ZXMiLCJzdWJzIiwiYWN0dWFsUHJvdG8iLCJzZXRQcm90b3R5cGVPZiIsIl9fcHJvdG9fXyIsImVycm9yTWFwIiwiX2N0eCIsImludmFsaWRfdHlwZSIsInJlY2VpdmVkIiwiZXhwZWN0ZWQiLCJpbnZhbGlkX2xpdGVyYWwiLCJ1bnJlY29nbml6ZWRfa2V5cyIsImludmFsaWRfdW5pb24iLCJpbnZhbGlkX3VuaW9uX2Rpc2NyaW1pbmF0b3IiLCJpbnZhbGlkX2VudW1fdmFsdWUiLCJpbnZhbGlkX2FyZ3VtZW50cyIsImludmFsaWRfcmV0dXJuX3R5cGUiLCJpbnZhbGlkX2RhdGUiLCJpbnZhbGlkX3N0cmluZyIsInZhbGlkYXRpb24iLCJ0b29fc21hbGwiLCJleGFjdCIsImluY2x1c2l2ZSIsIm1pbmltdW0iLCJ0b29fYmlnIiwibWF4aW11bSIsImN1c3RvbSIsImludmFsaWRfaW50ZXJzZWN0aW9uX3R5cGVzIiwibm90X211bHRpcGxlX29mIiwibXVsdGlwbGVPZiIsIm5vdF9maW5pdGUiLCJkZWZhdWx0RXJyb3IiLCJvdmVycmlkZUVycm9yTWFwIiwic2V0RXJyb3JNYXAiLCJnZXRFcnJvck1hcCIsIm1ha2VJc3N1ZSIsImVycm9yTWFwcyIsImlzc3VlRGF0YSIsImZ1bGxQYXRoIiwiZnVsbElzc3VlIiwiZXJyb3JNZXNzYWdlIiwibWFwcyIsIm0iLCJFTVBUWV9QQVRIIiwiYWRkSXNzdWVUb0NvbnRleHQiLCJvdmVycmlkZU1hcCIsImNvbW1vbiIsImNvbnRleHR1YWxFcnJvck1hcCIsInNjaGVtYUVycm9yTWFwIiwiUGFyc2VTdGF0dXMiLCJfUGFyc2VTdGF0dXMiLCJkaXJ0eSIsImFib3J0IiwibWVyZ2VBcnJheSIsInN0YXR1cyIsInJlc3VsdHMiLCJhcnJheVZhbHVlIiwicyIsIklOVkFMSUQiLCJtZXJnZU9iamVjdEFzeW5jIiwic3luY1BhaXJzIiwibWVyZ2VPYmplY3RTeW5jIiwiZmluYWxPYmplY3QiLCJhbHdheXNTZXQiLCJmcmVlemUiLCJESVJUWSIsIk9LIiwiaXNBYm9ydGVkIiwiaXNEaXJ0eSIsImlzVmFsaWQiLCJpc0FzeW5jIiwiX19jbGFzc1ByaXZhdGVGaWVsZEdldCIsInJlY2VpdmVyIiwic3RhdGUiLCJraW5kIiwiZiIsIl9fY2xhc3NQcml2YXRlRmllbGRTZXQiLCJlcnJvclV0aWwiLCJlcnJvclV0aWwyIiwiZXJyVG9PYmoiLCJfWm9kRW51bV9jYWNoZSIsIl9ab2ROYXRpdmVFbnVtX2NhY2hlIiwiUGFyc2VJbnB1dExhenlQYXRoIiwiX2NhY2hlZFBhdGgiLCJfa2V5IiwiX3BhdGgiLCJoYW5kbGVSZXN1bHQiLCJzdWNjZXNzIiwiX2Vycm9yIiwicHJvY2Vzc0NyZWF0ZVBhcmFtcyIsImVycm9yTWFwMiIsImludmFsaWRfdHlwZV9lcnJvciIsInJlcXVpcmVkX2Vycm9yIiwiZGVzY3JpcHRpb24iLCJjdXN0b21NYXAiLCJpc3MiLCJfYSIsIl9iIiwiWm9kVHlwZSIsIl9kZWYiLCJfZ2V0VHlwZSIsIl9nZXRPclJldHVybkN0eCIsInBhcnNlZFR5cGUiLCJfcHJvY2Vzc0lucHV0UGFyYW1zIiwiX3BhcnNlU3luYyIsIl9wYXJzZSIsIl9wYXJzZUFzeW5jIiwicGFyc2UiLCJzYWZlUGFyc2UiLCJhc3luYyIsInBhcnNlQXN5bmMiLCJzYWZlUGFyc2VBc3luYyIsIm1heWJlQXN5bmNSZXN1bHQiLCJyZWZpbmUiLCJjaGVjayIsImdldElzc3VlUHJvcGVydGllcyIsIl9yZWZpbmVtZW50Iiwic2V0RXJyb3IiLCJyZWZpbmVtZW50IiwicmVmaW5lbWVudERhdGEiLCJab2RFZmZlY3RzIiwic2NoZW1hIiwidHlwZU5hbWUiLCJab2RGaXJzdFBhcnR5VHlwZUtpbmQiLCJlZmZlY3QiLCJzdXBlclJlZmluZSIsIm9wdGlvbmFsIiwiWm9kT3B0aW9uYWwiLCJudWxsYWJsZSIsIlpvZE51bGxhYmxlIiwibnVsbGlzaCIsIlpvZEFycmF5IiwiWm9kUHJvbWlzZSIsIm9yIiwib3B0aW9uIiwiWm9kVW5pb24iLCJhbmQiLCJpbmNvbWluZyIsIlpvZEludGVyc2VjdGlvbiIsImRlZiIsImRlZmF1bHRWYWx1ZUZ1bmMiLCJab2REZWZhdWx0IiwiaW5uZXJUeXBlIiwiYnJhbmQiLCJab2RCcmFuZGVkIiwiY2F0Y2hWYWx1ZUZ1bmMiLCJab2RDYXRjaCIsImNhdGNoVmFsdWUiLCJkZXNjcmliZSIsIlRoaXMiLCJwaXBlIiwiWm9kUGlwZWxpbmUiLCJyZWFkb25seSIsIlpvZFJlYWRvbmx5IiwiaXNPcHRpb25hbCIsImlzTnVsbGFibGUiLCJzcGEiLCJjdWlkUmVnZXgiLCJjdWlkMlJlZ2V4IiwidWxpZFJlZ2V4IiwidXVpZFJlZ2V4IiwibmFub2lkUmVnZXgiLCJkdXJhdGlvblJlZ2V4IiwiZW1haWxSZWdleCIsIl9lbW9qaVJlZ2V4IiwiZW1vamlSZWdleCIsImlwdjRSZWdleCIsImlwdjZSZWdleCIsImJhc2U2NFJlZ2V4IiwiZGF0ZVJlZ2V4U291cmNlIiwiZGF0ZVJlZ2V4IiwidGltZVJlZ2V4U291cmNlIiwicmVnZXgiLCJ0aW1lUmVnZXgiLCJkYXRldGltZVJlZ2V4Iiwib3B0cyIsImxvY2FsIiwiaXNWYWxpZElQIiwiaXAiLCJ2ZXJzaW9uIiwiWm9kU3RyaW5nIiwiX1pvZFN0cmluZyIsImNvZXJjZSIsImN0eDIiLCJjaGVja3MiLCJ0b29CaWciLCJ0b29TbWFsbCIsInRlc3RSZXN1bHQiLCJfcmVnZXgiLCJfYWRkQ2hlY2siLCJlbWFpbCIsImVtb2ppIiwidXVpZCIsIm5hbm9pZCIsImN1aWQiLCJjdWlkMiIsInVsaWQiLCJiYXNlNjQiLCJkYXRldGltZSIsImR1cmF0aW9uIiwibWluTGVuZ3RoIiwibGVuIiwibm9uZW1wdHkiLCJpc0RhdGV0aW1lIiwiY2giLCJpc1RpbWUiLCJpc0R1cmF0aW9uIiwiaXNFbWFpbCIsImlzVVJMIiwiaXNFbW9qaSIsImlzVVVJRCIsImlzTkFOT0lEIiwiaXNDVUlEIiwiaXNDVUlEMiIsImlzVUxJRCIsImlzSVAiLCJpc0Jhc2U2NCIsImZsb2F0U2FmZVJlbWFpbmRlciIsInZhbERlY0NvdW50Iiwic3RlcERlY0NvdW50IiwiZGVjQ291bnQiLCJ2YWxJbnQiLCJ0b0ZpeGVkIiwic3RlcEludCIsInBvdyIsIlpvZE51bWJlciIsIl9ab2ROdW1iZXIiLCJzZXRMaW1pdCIsImludCIsInBvc2l0aXZlIiwibmVnYXRpdmUiLCJub25wb3NpdGl2ZSIsIm5vbm5lZ2F0aXZlIiwiZmluaXRlIiwic2FmZSIsIk1JTl9TQUZFX0lOVEVHRVIiLCJtaW5WYWx1ZSIsIm1heFZhbHVlIiwiaXNJbnQiLCJab2RCaWdJbnQiLCJfWm9kQmlnSW50IiwiQmlnSW50IiwiWm9kQm9vbGVhbiIsIkJvb2xlYW4iLCJab2REYXRlIiwiX1pvZERhdGUiLCJnZXRUaW1lIiwibWluRGF0ZSIsIm1heERhdGUiLCJab2RTeW1ib2wiLCJab2RVbmRlZmluZWQiLCJab2ROdWxsIiwiWm9kQW55IiwiX2FueSIsIlpvZFVua25vd24iLCJfdW5rbm93biIsIlpvZE5ldmVyIiwibmV2ZXIiLCJab2RWb2lkIiwidm9pZCIsIl9ab2RBcnJheSIsImV4YWN0TGVuZ3RoIiwiZWxlbWVudCIsImRlZXBQYXJ0aWFsaWZ5IiwiWm9kT2JqZWN0IiwibmV3U2hhcGUiLCJmaWVsZFNjaGVtYSIsInVud3JhcCIsIlpvZFR1cGxlIiwiX1pvZE9iamVjdCIsIl9nZXRDYWNoZWQiLCJfY2FjaGVkIiwic2hhcGVLZXlzIiwiZXh0cmFLZXlzIiwiY2F0Y2hhbGwiLCJ1bmtub3duS2V5cyIsImtleVZhbGlkYXRvciIsInN0cmljdCIsIl9jIiwiX2QiLCJzdHJpcCIsInBhc3N0aHJvdWdoIiwiYXVnbWVudGF0aW9uIiwibWVyZ2luZyIsIm1lcmdlZCIsInNldEtleSIsImF1Z21lbnQiLCJtYXNrIiwiZGVlcFBhcnRpYWwiLCJyZXF1aXJlZCIsIm5ld0ZpZWxkIiwia2V5b2YiLCJjcmVhdGVab2RFbnVtIiwibm9uc3RyaWN0Iiwic3RyaWN0Q3JlYXRlIiwibGF6eWNyZWF0ZSIsImhhbmRsZVJlc3VsdHMiLCJjaGlsZEN0eCIsImlzc3VlczIiLCJnZXREaXNjcmltaW5hdG9yIiwiWm9kTGF6eSIsIlpvZExpdGVyYWwiLCJab2RFbnVtIiwiWm9kTmF0aXZlRW51bSIsImVudW0iLCJab2REaXNjcmltaW5hdGVkVW5pb24iLCJfWm9kRGlzY3JpbWluYXRlZFVuaW9uIiwiZGlzY3JpbWluYXRvciIsImRpc2NyaW1pbmF0b3JWYWx1ZSIsIm9wdGlvbnNNYXAiLCJkaXNjcmltaW5hdG9yVmFsdWVzIiwibWVyZ2VWYWx1ZXMiLCJhVHlwZSIsImJUeXBlIiwidmFsaWQiLCJiS2V5cyIsInNoYXJlZEtleXMiLCJuZXdPYmoiLCJzaGFyZWRWYWx1ZSIsIm5ld0FycmF5IiwiaXRlbUEiLCJpdGVtQiIsImhhbmRsZVBhcnNlZCIsInBhcnNlZExlZnQiLCJwYXJzZWRSaWdodCIsImxlZnQiLCJyaWdodCIsIl9ab2RUdXBsZSIsIml0ZW1JbmRleCIsInNjaGVtYXMiLCJab2RSZWNvcmQiLCJfWm9kUmVjb3JkIiwia2V5U2NoZW1hIiwia2V5VHlwZSIsInZhbHVlU2NoZW1hIiwidmFsdWVUeXBlIiwidGhpcmQiLCJab2RNYXAiLCJmaW5hbE1hcCIsIlpvZFNldCIsIl9ab2RTZXQiLCJtaW5TaXplIiwibWF4U2l6ZSIsImZpbmFsaXplU2V0IiwiZWxlbWVudHMyIiwicGFyc2VkU2V0IiwiZWxlbWVudHMiLCJab2RGdW5jdGlvbiIsIl9ab2RGdW5jdGlvbiIsIm1ha2VBcmdzSXNzdWUiLCJtYWtlUmV0dXJuc0lzc3VlIiwicmV0dXJucyIsIm1lIiwicGFyc2VkQXJncyIsIlJlZmxlY3QiLCJwYXJzZWRSZXR1cm5zIiwicGFyYW1ldGVycyIsInJldHVyblR5cGUiLCJpbXBsZW1lbnQiLCJ2YWxpZGF0ZWRGdW5jIiwic3RyaWN0SW1wbGVtZW50IiwidmFsaWRhdGUiLCJnZXR0ZXIiLCJsYXp5U2NoZW1hIiwiX1pvZEVudW0iLCJleHBlY3RlZFZhbHVlcyIsImVudW1WYWx1ZXMiLCJWYWx1ZXMiLCJFbnVtIiwiZXh0cmFjdCIsIm5ld0RlZiIsImV4Y2x1ZGUiLCJvcHQiLCJXZWFrTWFwIiwibmF0aXZlRW51bVZhbHVlcyIsInByb21pc2lmaWVkIiwic291cmNlVHlwZSIsImNoZWNrQ3R4IiwiZmF0YWwiLCJwcm9jZXNzZWQiLCJwcm9jZXNzZWQyIiwiZXhlY3V0ZVJlZmluZW1lbnQiLCJhY2MiLCJpbm5lciIsImJhc2UiLCJjcmVhdGVXaXRoUHJlcHJvY2VzcyIsInByZXByb2Nlc3MiLCJyZW1vdmVEZWZhdWx0IiwibmV3Q3R4IiwicmVtb3ZlQ2F0Y2giLCJab2ROYU4iLCJCUkFORCIsIl9ab2RQaXBlbGluZSIsImhhbmRsZUFzeW5jIiwiaW5SZXN1bHQiLCJpbiIsIm91dCIsInAiLCJfZmF0YWwiLCJsYXRlIiwiWm9kRmlyc3RQYXJ0eVR5cGVLaW5kMiIsImluc3RhbmNlT2ZUeXBlIiwiY2xzIiwic3RyaW5nVHlwZSIsIm51bWJlclR5cGUiLCJuYW5UeXBlIiwiYmlnSW50VHlwZSIsImJvb2xlYW5UeXBlIiwiZGF0ZVR5cGUiLCJzeW1ib2xUeXBlIiwidW5kZWZpbmVkVHlwZSIsIm51bGxUeXBlIiwiYW55VHlwZSIsInVua25vd25UeXBlIiwibmV2ZXJUeXBlIiwidm9pZFR5cGUiLCJhcnJheVR5cGUiLCJvYmplY3RUeXBlIiwic3RyaWN0T2JqZWN0VHlwZSIsInVuaW9uVHlwZSIsImRpc2NyaW1pbmF0ZWRVbmlvblR5cGUiLCJpbnRlcnNlY3Rpb25UeXBlIiwidHVwbGVUeXBlIiwicmVjb3JkVHlwZSIsIm1hcFR5cGUiLCJzZXRUeXBlIiwiZnVuY3Rpb25UeXBlIiwibGF6eVR5cGUiLCJsaXRlcmFsVHlwZSIsImVudW1UeXBlIiwibmF0aXZlRW51bVR5cGUiLCJwcm9taXNlVHlwZSIsImVmZmVjdHNUeXBlIiwib3B0aW9uYWxUeXBlIiwibnVsbGFibGVUeXBlIiwicHJlcHJvY2Vzc1R5cGUiLCJwaXBlbGluZVR5cGUiLCJvc3RyaW5nIiwib251bWJlciIsIm9ib29sZWFuIiwiTkVWRVIiLCJ6IiwiZGVmYXVsdEVycm9yTWFwIiwiWm9kVHJhbnNmb3JtZXIiLCJTY2hlbWEiLCJab2RTY2hlbWEiLCJhbnkiLCJkaXNjcmltaW5hdGVkVW5pb24iLCJsYXp5IiwibGl0ZXJhbCIsIm5hdGl2ZUVudW0iLCJwaXBlbGluZSIsInJlY29yZCIsInN0cmljdE9iamVjdCIsInRyYW5zZm9ybWVyIiwidHVwbGUiLCJwYWNrYWdlX2RlZmF1bHQiLCJrZXl3b3JkcyIsInJlcG9zaXRvcnkiLCJsaWNlbnNlIiwiYXV0aG9yIiwiYnVncyIsIm1haW4iLCJpbXBvcnQiLCJob21lcGFnZSIsImZpbGVzIiwic2NyaXB0cyIsImNsZWFuIiwicmVzb3VyY2VzIiwiYnVpbGQiLCJ3YXRjaCIsImxpbnQiLCJkZXBlbmRlbmNpZXMiLCJuZGFycmF5Iiwiem9kIiwicGVlckRlcGVuZGVuY2llcyIsImRldkRlcGVuZGVuY2llcyIsImVzYnVpbGQiLCJnbG9iIiwidHNsaWIiLCJ0eXBlc2NyaXB0Iiwid2VicGFjayIsImJ1bmRsZURlcGVuZGVuY2llcyIsIkNvbmZpZ1NjaGVtYSIsInJlc2NhbGUiLCJsb2ciLCJ0b3RhbCIsImNyb3NzT3JpZ2luSXNvbGF0ZWQiLCJ2YWxpZGF0ZUNvbmZpZyIsImNvbmZpZ3VyYXRpb24iLCJpbXBvcnRfbmRhcnJheTQiLCJpbml0QmFzZSIsImluaXRJbmZlcmVuY2UiLCJydW5JbmZlcmVuY2UiLCJyZXNvbHV0aW9uIiwia2VlcEFzcGVjdCIsInJlc2l6ZWRJbWFnZVRlbnNvciIsImlucHV0VGVuc29yIiwicHJlZGljdGlvbnNEaWN0IiwiYWxwaGFtYXNrMiIsImFscGhhbWFza1U4IiwiaW5pdCIsInByZWxvYWQiLCJyZW1vdmVCYWNrZ3JvdW5kIiwiaW5wdXRJbWFnZVRlbnNvciIsIm91dEltYWdlVGVuc29yIiwib3V0SW1hZ2UiLCJyZW1vdmVGb3JlZ3JvdW5kIiwiaW1hZ2VJbnB1dCIsImFscGhhbWFzayIsInNlZ21lbnRGb3JlZ3JvdW5kIiwiYWxwaGEiLCJhcHBseVNlZ21lbnRhdGlvbk1hc2siLCJpbWFnZUhlaWdodCIsImltYWdlV2lkdGgiLCJpbWFnZUNoYW5uZWxzIiwibWFza1RlbnNvciIsIm1hc2tIZWlnaHQiLCJtYXNrV2lkdGgiLCJtYXNrQ2hhbm5lbHMiLCJhbHBoYU1hc2siLCJpZHhJbWFnZSIsImlkeE1hc2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@imgly/background-removal/dist/index.mjs\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Famityadav%2FDesktop%2FText-Behind%20Image%2Fapp%2Fpage.tsx&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);