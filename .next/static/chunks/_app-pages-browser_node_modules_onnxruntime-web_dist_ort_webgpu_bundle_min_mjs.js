"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_onnxruntime-web_dist_ort_webgpu_bundle_min_mjs"],{

/***/ "(app-pages-browser)/./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs?7f57":
/*!*********************************************************************!*\
  !*** ./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs ***!
  \*********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/media/ort.webgpu.bundle.min.5535e168.mjs";

/***/ }),

/***/ "(app-pages-browser)/./node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm":
/*!****************************************************************************!*\
  !*** ./node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm ***!
  \****************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

module.exports = __webpack_require__.p + "static/media/ort-wasm-simd-threaded.jsep.da7a4538.wasm";

/***/ }),

/***/ "(app-pages-browser)/./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs?4709":
/*!*********************************************************************!*\
  !*** ./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InferenceSession: function() { return /* binding */ Fp; },\n/* harmony export */   TRACE: function() { return /* binding */ wr; },\n/* harmony export */   TRACE_FUNC_BEGIN: function() { return /* binding */ Ue; },\n/* harmony export */   TRACE_FUNC_END: function() { return /* binding */ De; },\n/* harmony export */   Tensor: function() { return /* binding */ He; },\n/* harmony export */   \"default\": function() { return /* binding */ $1; },\n/* harmony export */   env: function() { return /* binding */ ve; },\n/* harmony export */   registerBackend: function() { return /* binding */ St; }\n/* harmony export */ });\n/*!\n * ONNX Runtime Web v1.21.0-dev.20250114-228dd16893\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */ var Un = Object.defineProperty;\nvar Vp = Object.getOwnPropertyDescriptor;\nvar Wp = Object.getOwnPropertyNames;\nvar Lp = Object.prototype.hasOwnProperty;\nvar Nn = ((e1)=>typeof require < \"u\" ? require : typeof Proxy < \"u\" ? new Proxy(e1, {\n        get: (t, r)=>(typeof require < \"u\" ? require : t)[r]\n    }) : e1)(function(e1) {\n    if (typeof require < \"u\") return require.apply(this, arguments);\n    throw Error('Dynamic require of \"' + e1 + '\" is not supported');\n});\nvar U = (e1, t)=>()=>(e1 && (t = e1(e1 = 0)), t);\nvar Ft = (e1, t)=>{\n    for(var r in t)Un(e1, r, {\n        get: t[r],\n        enumerable: !0\n    });\n}, Gp = (e1, t, r, n)=>{\n    if (t && typeof t == \"object\" || typeof t == \"function\") for (let o of Wp(t))!Lp.call(e1, o) && o !== r && Un(e1, o, {\n        get: ()=>t[o],\n        enumerable: !(n = Vp(t, o)) || n.enumerable\n    });\n    return e1;\n};\nvar br = (e1)=>Gp(Un({}, \"__esModule\", {\n        value: !0\n    }), e1);\nvar yr, xt, St, Hp, Ji, Vn = U(()=>{\n    \"use strict\";\n    yr = new Map, xt = [], St = (e1, t, r)=>{\n        if (t && typeof t.init == \"function\" && typeof t.createInferenceSessionHandler == \"function\") {\n            let n = yr.get(e1);\n            if (n === void 0) yr.set(e1, {\n                backend: t,\n                priority: r\n            });\n            else {\n                if (n.priority > r) return;\n                if (n.priority === r && n.backend !== t) throw new Error('cannot register backend \"'.concat(e1, '\" using priority ').concat(r));\n            }\n            if (r >= 0) {\n                let o = xt.indexOf(e1);\n                o !== -1 && xt.splice(o, 1);\n                for(let i = 0; i < xt.length; i++)if (yr.get(xt[i]).priority <= r) {\n                    xt.splice(i, 0, e1);\n                    return;\n                }\n                xt.push(e1);\n            }\n            return;\n        }\n        throw new TypeError(\"not a valid backend\");\n    }, Hp = async (e1)=>{\n        let t = yr.get(e1);\n        if (!t) return \"backend not found.\";\n        if (t.initialized) return t.backend;\n        if (t.aborted) return t.error;\n        {\n            let r = !!t.initPromise;\n            try {\n                return r || (t.initPromise = t.backend.init(e1)), await t.initPromise, t.initialized = !0, t.backend;\n            } catch (n) {\n                return r || (t.error = \"\".concat(n), t.aborted = !0), t.error;\n            } finally{\n                delete t.initPromise;\n            }\n        }\n    }, Ji = async (e1)=>{\n        let t = e1.executionProviders || [], r = t.map((l)=>typeof l == \"string\" ? l : l.name), n = r.length === 0 ? xt : r, o, i = [], a = new Set;\n        for (let l of n){\n            let p = await Hp(l);\n            typeof p == \"string\" ? i.push({\n                name: l,\n                err: p\n            }) : (o || (o = p), o === p && a.add(l));\n        }\n        if (!o) throw new Error(\"no available backend found. ERR: \".concat(i.map((l)=>\"[\".concat(l.name, \"] \").concat(l.err)).join(\", \")));\n        for (let { name: l, err: p } of i)r.includes(l) && console.warn('removing requested execution provider \"'.concat(l, '\" from session options because it is not available: ').concat(p));\n        let d = t.filter((l)=>a.has(typeof l == \"string\" ? l : l.name));\n        return [\n            o,\n            new Proxy(e1, {\n                get: (l, p)=>p === \"executionProviders\" ? d : Reflect.get(l, p)\n            })\n        ];\n    };\n});\nvar ea = U(()=>{\n    \"use strict\";\n    Vn();\n});\nvar ta, ra = U(()=>{\n    \"use strict\";\n    ta = \"1.21.0-dev.20241212-1f88284f96\";\n});\nvar na, Re, Wn = U(()=>{\n    \"use strict\";\n    ra();\n    na = \"warning\", Re = {\n        wasm: {},\n        webgl: {},\n        webgpu: {},\n        versions: {\n            common: ta\n        },\n        set logLevel (e){\n            if (e !== void 0) {\n                if (typeof e != \"string\" || [\n                    \"verbose\",\n                    \"info\",\n                    \"warning\",\n                    \"error\",\n                    \"fatal\"\n                ].indexOf(e) === -1) throw new Error(\"Unsupported logging level: \".concat(e));\n                na = e;\n            }\n        },\n        get logLevel () {\n            return na;\n        }\n    };\n    Object.defineProperty(Re, \"logLevel\", {\n        enumerable: !0\n    });\n});\nvar ve, oa = U(()=>{\n    \"use strict\";\n    Wn();\n    ve = Re;\n});\nvar ia, aa, sa = U(()=>{\n    \"use strict\";\n    ia = (e1, t)=>{\n        let r = typeof document < \"u\" ? document.createElement(\"canvas\") : new OffscreenCanvas(1, 1);\n        r.width = e1.dims[3], r.height = e1.dims[2];\n        let n = r.getContext(\"2d\");\n        if (n != null) {\n            let o, i;\n            (t === null || t === void 0 ? void 0 : t.tensorLayout) !== void 0 && t.tensorLayout === \"NHWC\" ? (o = e1.dims[2], i = e1.dims[3]) : (o = e1.dims[3], i = e1.dims[2]);\n            let a = (t === null || t === void 0 ? void 0 : t.format) !== void 0 ? t.format : \"RGB\", d = t === null || t === void 0 ? void 0 : t.norm, l, p;\n            d === void 0 || d.mean === void 0 ? l = [\n                255,\n                255,\n                255,\n                255\n            ] : typeof d.mean == \"number\" ? l = [\n                d.mean,\n                d.mean,\n                d.mean,\n                d.mean\n            ] : (l = [\n                d.mean[0],\n                d.mean[1],\n                d.mean[2],\n                0\n            ], d.mean[3] !== void 0 && (l[3] = d.mean[3])), d === void 0 || d.bias === void 0 ? p = [\n                0,\n                0,\n                0,\n                0\n            ] : typeof d.bias == \"number\" ? p = [\n                d.bias,\n                d.bias,\n                d.bias,\n                d.bias\n            ] : (p = [\n                d.bias[0],\n                d.bias[1],\n                d.bias[2],\n                0\n            ], d.bias[3] !== void 0 && (p[3] = d.bias[3]));\n            let m = i * o, u = 0, h = m, _ = m * 2, y = -1;\n            a === \"RGBA\" ? (u = 0, h = m, _ = m * 2, y = m * 3) : a === \"RGB\" ? (u = 0, h = m, _ = m * 2) : a === \"RBG\" && (u = 0, _ = m, h = m * 2);\n            for(let g = 0; g < i; g++)for(let x = 0; x < o; x++){\n                let $ = (e1.data[u++] - p[0]) * l[0], v = (e1.data[h++] - p[1]) * l[1], S = (e1.data[_++] - p[2]) * l[2], T = y === -1 ? 255 : (e1.data[y++] - p[3]) * l[3];\n                n.fillStyle = \"rgba(\" + $ + \",\" + v + \",\" + S + \",\" + T + \")\", n.fillRect(x, g, 1, 1);\n            }\n            if (\"toDataURL\" in r) return r.toDataURL();\n            throw new Error(\"toDataURL is not supported\");\n        } else throw new Error(\"Can not access image data\");\n    }, aa = (e1, t)=>{\n        let r = typeof document < \"u\" ? document.createElement(\"canvas\").getContext(\"2d\") : new OffscreenCanvas(1, 1).getContext(\"2d\"), n;\n        if (r != null) {\n            let o, i, a;\n            (t === null || t === void 0 ? void 0 : t.tensorLayout) !== void 0 && t.tensorLayout === \"NHWC\" ? (o = e1.dims[2], i = e1.dims[1], a = e1.dims[3]) : (o = e1.dims[3], i = e1.dims[2], a = e1.dims[1]);\n            let d = t !== void 0 && t.format !== void 0 ? t.format : \"RGB\", l = t === null || t === void 0 ? void 0 : t.norm, p, m;\n            l === void 0 || l.mean === void 0 ? p = [\n                255,\n                255,\n                255,\n                255\n            ] : typeof l.mean == \"number\" ? p = [\n                l.mean,\n                l.mean,\n                l.mean,\n                l.mean\n            ] : (p = [\n                l.mean[0],\n                l.mean[1],\n                l.mean[2],\n                255\n            ], l.mean[3] !== void 0 && (p[3] = l.mean[3])), l === void 0 || l.bias === void 0 ? m = [\n                0,\n                0,\n                0,\n                0\n            ] : typeof l.bias == \"number\" ? m = [\n                l.bias,\n                l.bias,\n                l.bias,\n                l.bias\n            ] : (m = [\n                l.bias[0],\n                l.bias[1],\n                l.bias[2],\n                0\n            ], l.bias[3] !== void 0 && (m[3] = l.bias[3]));\n            let u = i * o;\n            if (t !== void 0 && (t.format !== void 0 && a === 4 && t.format !== \"RGBA\" || a === 3 && t.format !== \"RGB\" && t.format !== \"BGR\")) throw new Error(\"Tensor format doesn't match input tensor dims\");\n            let h = 4, _ = 0, y = 1, g = 2, x = 3, $ = 0, v = u, S = u * 2, T = -1;\n            d === \"RGBA\" ? ($ = 0, v = u, S = u * 2, T = u * 3) : d === \"RGB\" ? ($ = 0, v = u, S = u * 2) : d === \"RBG\" && ($ = 0, S = u, v = u * 2), n = r.createImageData(o, i);\n            for(let A = 0; A < i * o; _ += h, y += h, g += h, x += h, A++)n.data[_] = (e1.data[$++] - m[0]) * p[0], n.data[y] = (e1.data[v++] - m[1]) * p[1], n.data[g] = (e1.data[S++] - m[2]) * p[2], n.data[x] = T === -1 ? 255 : (e1.data[T++] - m[3]) * p[3];\n        } else throw new Error(\"Can not access image data\");\n        return n;\n    };\n});\nvar Ln, ua, da, la, ca, pa, ma = U(()=>{\n    \"use strict\";\n    _r();\n    Ln = (e1, t)=>{\n        if (e1 === void 0) throw new Error(\"Image buffer must be defined\");\n        if (t.height === void 0 || t.width === void 0) throw new Error(\"Image height and width must be defined\");\n        if (t.tensorLayout === \"NHWC\") throw new Error(\"NHWC Tensor layout is not supported yet\");\n        var _t_norm;\n        let { height: r, width: n } = t, o = (_t_norm = t.norm) !== null && _t_norm !== void 0 ? _t_norm : {\n            mean: 255,\n            bias: 0\n        }, i, a;\n        var _o_mean_, _o_bias_;\n        typeof o.mean == \"number\" ? i = [\n            o.mean,\n            o.mean,\n            o.mean,\n            o.mean\n        ] : i = [\n            o.mean[0],\n            o.mean[1],\n            o.mean[2],\n            (_o_mean_ = o.mean[3]) !== null && _o_mean_ !== void 0 ? _o_mean_ : 255\n        ], typeof o.bias == \"number\" ? a = [\n            o.bias,\n            o.bias,\n            o.bias,\n            o.bias\n        ] : a = [\n            o.bias[0],\n            o.bias[1],\n            o.bias[2],\n            (_o_bias_ = o.bias[3]) !== null && _o_bias_ !== void 0 ? _o_bias_ : 0\n        ];\n        let d = t.format !== void 0 ? t.format : \"RGBA\", l = t.tensorFormat !== void 0 && t.tensorFormat !== void 0 ? t.tensorFormat : \"RGB\", p = r * n, m = l === \"RGBA\" ? new Float32Array(p * 4) : new Float32Array(p * 3), u = 4, h = 0, _ = 1, y = 2, g = 3, x = 0, $ = p, v = p * 2, S = -1;\n        d === \"RGB\" && (u = 3, h = 0, _ = 1, y = 2, g = -1), l === \"RGBA\" ? S = p * 3 : l === \"RBG\" ? (x = 0, v = p, $ = p * 2) : l === \"BGR\" && (v = 0, $ = p, x = p * 2);\n        for(let A = 0; A < p; A++, h += u, y += u, _ += u, g += u)m[x++] = (e1[h] + a[0]) / i[0], m[$++] = (e1[_] + a[1]) / i[1], m[v++] = (e1[y] + a[2]) / i[2], S !== -1 && g !== -1 && (m[S++] = (e1[g] + a[3]) / i[3]);\n        return l === \"RGBA\" ? new ze(\"float32\", m, [\n            1,\n            4,\n            r,\n            n\n        ]) : new ze(\"float32\", m, [\n            1,\n            3,\n            r,\n            n\n        ]);\n    }, ua = async (e1, t)=>{\n        let r = typeof HTMLImageElement < \"u\" && e1 instanceof HTMLImageElement, n = typeof ImageData < \"u\" && e1 instanceof ImageData, o = typeof ImageBitmap < \"u\" && e1 instanceof ImageBitmap, i = typeof e1 == \"string\", a, d = t !== null && t !== void 0 ? t : {}, l = ()=>{\n            if (typeof document < \"u\") return document.createElement(\"canvas\");\n            if (typeof OffscreenCanvas < \"u\") return new OffscreenCanvas(1, 1);\n            throw new Error(\"Canvas is not supported\");\n        }, p = (m)=>typeof HTMLCanvasElement < \"u\" && m instanceof HTMLCanvasElement || m instanceof OffscreenCanvas ? m.getContext(\"2d\") : null;\n        if (r) {\n            let m = l();\n            m.width = e1.width, m.height = e1.height;\n            let u = p(m);\n            if (u != null) {\n                let h = e1.height, _ = e1.width;\n                if (t !== void 0 && t.resizedHeight !== void 0 && t.resizedWidth !== void 0 && (h = t.resizedHeight, _ = t.resizedWidth), t !== void 0) {\n                    if (d = t, t.tensorFormat !== void 0) throw new Error(\"Image input config format must be RGBA for HTMLImageElement\");\n                    d.tensorFormat = \"RGBA\", d.height = h, d.width = _;\n                } else d.tensorFormat = \"RGBA\", d.height = h, d.width = _;\n                u.drawImage(e1, 0, 0), a = u.getImageData(0, 0, _, h).data;\n            } else throw new Error(\"Can not access image data\");\n        } else if (n) {\n            let m, u;\n            if (t !== void 0 && t.resizedWidth !== void 0 && t.resizedHeight !== void 0 ? (m = t.resizedHeight, u = t.resizedWidth) : (m = e1.height, u = e1.width), t !== void 0 && (d = t), d.format = \"RGBA\", d.height = m, d.width = u, t !== void 0) {\n                let h = l();\n                h.width = u, h.height = m;\n                let _ = p(h);\n                if (_ != null) _.putImageData(e1, 0, 0), a = _.getImageData(0, 0, u, m).data;\n                else throw new Error(\"Can not access image data\");\n            } else a = e1.data;\n        } else if (o) {\n            if (t === void 0) throw new Error(\"Please provide image config with format for Imagebitmap\");\n            let m = l();\n            m.width = e1.width, m.height = e1.height;\n            let u = p(m);\n            if (u != null) {\n                let h = e1.height, _ = e1.width;\n                return u.drawImage(e1, 0, 0, _, h), a = u.getImageData(0, 0, _, h).data, d.height = h, d.width = _, Ln(a, d);\n            } else throw new Error(\"Can not access image data\");\n        } else {\n            if (i) return new Promise((m, u)=>{\n                let h = l(), _ = p(h);\n                if (!e1 || !_) return u();\n                let y = new Image;\n                y.crossOrigin = \"Anonymous\", y.src = e1, y.onload = ()=>{\n                    h.width = y.width, h.height = y.height, _.drawImage(y, 0, 0, h.width, h.height);\n                    let g = _.getImageData(0, 0, h.width, h.height);\n                    d.height = h.height, d.width = h.width, m(Ln(g.data, d));\n                };\n            });\n            throw new Error(\"Input data provided is not supported - aborted tensor creation\");\n        }\n        if (a !== void 0) return Ln(a, d);\n        throw new Error(\"Input data provided is not supported - aborted tensor creation\");\n    }, da = (e1, t)=>{\n        let { width: r, height: n, download: o, dispose: i } = t, a = [\n            1,\n            n,\n            r,\n            4\n        ];\n        return new ze({\n            location: \"texture\",\n            type: \"float32\",\n            texture: e1,\n            dims: a,\n            download: o,\n            dispose: i\n        });\n    }, la = (e1, t)=>{\n        let { dataType: r, dims: n, download: o, dispose: i } = t;\n        return new ze({\n            location: \"gpu-buffer\",\n            type: r !== null && r !== void 0 ? r : \"float32\",\n            gpuBuffer: e1,\n            dims: n,\n            download: o,\n            dispose: i\n        });\n    }, ca = (e1, t)=>{\n        let { dataType: r, dims: n, download: o, dispose: i } = t;\n        return new ze({\n            location: \"ml-tensor\",\n            type: r !== null && r !== void 0 ? r : \"float32\",\n            mlTensor: e1,\n            dims: n,\n            download: o,\n            dispose: i\n        });\n    }, pa = (e1, t, r)=>new ze({\n            location: \"cpu-pinned\",\n            type: e1,\n            data: t,\n            dims: r !== null && r !== void 0 ? r : [\n                t.length\n            ]\n        });\n});\nvar Tt, qt, fa, ha, ga = U(()=>{\n    \"use strict\";\n    Tt = new Map([\n        [\n            \"float32\",\n            Float32Array\n        ],\n        [\n            \"uint8\",\n            Uint8Array\n        ],\n        [\n            \"int8\",\n            Int8Array\n        ],\n        [\n            \"uint16\",\n            Uint16Array\n        ],\n        [\n            \"int16\",\n            Int16Array\n        ],\n        [\n            \"int32\",\n            Int32Array\n        ],\n        [\n            \"bool\",\n            Uint8Array\n        ],\n        [\n            \"float64\",\n            Float64Array\n        ],\n        [\n            \"uint32\",\n            Uint32Array\n        ],\n        [\n            \"int4\",\n            Uint8Array\n        ],\n        [\n            \"uint4\",\n            Uint8Array\n        ]\n    ]), qt = new Map([\n        [\n            Float32Array,\n            \"float32\"\n        ],\n        [\n            Uint8Array,\n            \"uint8\"\n        ],\n        [\n            Int8Array,\n            \"int8\"\n        ],\n        [\n            Uint16Array,\n            \"uint16\"\n        ],\n        [\n            Int16Array,\n            \"int16\"\n        ],\n        [\n            Int32Array,\n            \"int32\"\n        ],\n        [\n            Float64Array,\n            \"float64\"\n        ],\n        [\n            Uint32Array,\n            \"uint32\"\n        ]\n    ]), fa = !1, ha = ()=>{\n        if (!fa) {\n            fa = !0;\n            let e1 = typeof BigInt64Array < \"u\" && BigInt64Array.from, t = typeof BigUint64Array < \"u\" && BigUint64Array.from, r = typeof Float16Array < \"u\" && Float16Array.from;\n            e1 && (Tt.set(\"int64\", BigInt64Array), qt.set(BigInt64Array, \"int64\")), t && (Tt.set(\"uint64\", BigUint64Array), qt.set(BigUint64Array, \"uint64\")), r ? (Tt.set(\"float16\", Float16Array), qt.set(Float16Array, \"float16\")) : Tt.set(\"float16\", Uint16Array);\n        }\n    };\n});\nvar ba, ya, _a = U(()=>{\n    \"use strict\";\n    _r();\n    ba = (e1)=>{\n        let t = 1;\n        for(let r = 0; r < e1.length; r++){\n            let n = e1[r];\n            if (typeof n != \"number\" || !Number.isSafeInteger(n)) throw new TypeError(\"dims[\".concat(r, \"] must be an integer, got: \").concat(n));\n            if (n < 0) throw new RangeError(\"dims[\".concat(r, \"] must be a non-negative integer, got: \").concat(n));\n            t *= n;\n        }\n        return t;\n    }, ya = (e1, t)=>{\n        switch(e1.location){\n            case \"cpu\":\n                return new ze(e1.type, e1.data, t);\n            case \"cpu-pinned\":\n                return new ze({\n                    location: \"cpu-pinned\",\n                    data: e1.data,\n                    type: e1.type,\n                    dims: t\n                });\n            case \"texture\":\n                return new ze({\n                    location: \"texture\",\n                    texture: e1.texture,\n                    type: e1.type,\n                    dims: t\n                });\n            case \"gpu-buffer\":\n                return new ze({\n                    location: \"gpu-buffer\",\n                    gpuBuffer: e1.gpuBuffer,\n                    type: e1.type,\n                    dims: t\n                });\n            case \"ml-tensor\":\n                return new ze({\n                    location: \"ml-tensor\",\n                    mlTensor: e1.mlTensor,\n                    type: e1.type,\n                    dims: t\n                });\n            default:\n                throw new Error(\"tensorReshape: tensor location \".concat(e1.location, \" is not supported\"));\n        }\n    };\n});\nvar ze, _r = U(()=>{\n    \"use strict\";\n    sa();\n    ma();\n    ga();\n    _a();\n    ze = class {\n        static async fromImage(t, r) {\n            return ua(t, r);\n        }\n        static fromTexture(t, r) {\n            return da(t, r);\n        }\n        static fromGpuBuffer(t, r) {\n            return la(t, r);\n        }\n        static fromMLTensor(t, r) {\n            return ca(t, r);\n        }\n        static fromPinnedBuffer(t, r, n) {\n            return pa(t, r, n);\n        }\n        toDataURL(t) {\n            return ia(this, t);\n        }\n        toImageData(t) {\n            return aa(this, t);\n        }\n        get data() {\n            if (this.ensureValid(), !this.cpuData) throw new Error(\"The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.\");\n            return this.cpuData;\n        }\n        get location() {\n            return this.dataLocation;\n        }\n        get texture() {\n            if (this.ensureValid(), !this.gpuTextureData) throw new Error(\"The data is not stored as a WebGL texture.\");\n            return this.gpuTextureData;\n        }\n        get gpuBuffer() {\n            if (this.ensureValid(), !this.gpuBufferData) throw new Error(\"The data is not stored as a WebGPU buffer.\");\n            return this.gpuBufferData;\n        }\n        get mlTensor() {\n            if (this.ensureValid(), !this.mlTensorData) throw new Error(\"The data is not stored as a WebNN MLTensor.\");\n            return this.mlTensorData;\n        }\n        async getData(t) {\n            switch(this.ensureValid(), this.dataLocation){\n                case \"cpu\":\n                case \"cpu-pinned\":\n                    return this.data;\n                case \"texture\":\n                case \"gpu-buffer\":\n                case \"ml-tensor\":\n                    {\n                        if (!this.downloader) throw new Error(\"The current tensor is not created with a specified data downloader.\");\n                        if (this.isDownloading) throw new Error(\"The current tensor is being downloaded.\");\n                        try {\n                            this.isDownloading = !0;\n                            let r = await this.downloader();\n                            return this.downloader = void 0, this.dataLocation = \"cpu\", this.cpuData = r, t && this.disposer && (this.disposer(), this.disposer = void 0), r;\n                        } finally{\n                            this.isDownloading = !1;\n                        }\n                    }\n                default:\n                    throw new Error(\"cannot get data from location: \".concat(this.dataLocation));\n            }\n        }\n        dispose() {\n            if (this.isDownloading) throw new Error(\"The current tensor is being downloaded.\");\n            this.disposer && (this.disposer(), this.disposer = void 0), this.cpuData = void 0, this.gpuTextureData = void 0, this.gpuBufferData = void 0, this.mlTensorData = void 0, this.downloader = void 0, this.isDownloading = void 0, this.dataLocation = \"none\";\n        }\n        ensureValid() {\n            if (this.dataLocation === \"none\") throw new Error(\"The tensor is disposed.\");\n        }\n        reshape(t) {\n            if (this.ensureValid(), this.downloader || this.disposer) throw new Error(\"Cannot reshape a tensor that owns GPU resource.\");\n            return ya(this, t);\n        }\n        constructor(t, r, n){\n            ha();\n            let o, i;\n            if (typeof t == \"object\" && \"location\" in t) switch(this.dataLocation = t.location, o = t.type, i = t.dims, t.location){\n                case \"cpu-pinned\":\n                    {\n                        let d = Tt.get(o);\n                        if (!d) throw new TypeError('unsupported type \"'.concat(o, '\" to create tensor from pinned buffer'));\n                        if (!(t.data instanceof d)) throw new TypeError(\"buffer should be of type \".concat(d.name));\n                        this.cpuData = t.data;\n                        break;\n                    }\n                case \"texture\":\n                    {\n                        if (o !== \"float32\") throw new TypeError('unsupported type \"'.concat(o, '\" to create tensor from texture'));\n                        this.gpuTextureData = t.texture, this.downloader = t.download, this.disposer = t.dispose;\n                        break;\n                    }\n                case \"gpu-buffer\":\n                    {\n                        if (o !== \"float32\" && o !== \"float16\" && o !== \"int32\" && o !== \"int64\" && o !== \"uint32\" && o !== \"uint8\" && o !== \"bool\" && o !== \"uint4\" && o !== \"int4\") throw new TypeError('unsupported type \"'.concat(o, '\" to create tensor from gpu buffer'));\n                        this.gpuBufferData = t.gpuBuffer, this.downloader = t.download, this.disposer = t.dispose;\n                        break;\n                    }\n                case \"ml-tensor\":\n                    {\n                        if (o !== \"float32\" && o !== \"float16\" && o !== \"int32\" && o !== \"int64\" && o !== \"uint32\" && o !== \"uint64\" && o !== \"int8\" && o !== \"uint8\" && o !== \"bool\" && o !== \"uint4\" && o !== \"int4\") throw new TypeError('unsupported type \"'.concat(o, '\" to create tensor from MLTensor'));\n                        this.mlTensorData = t.mlTensor, this.downloader = t.download, this.disposer = t.dispose;\n                        break;\n                    }\n                default:\n                    throw new Error(\"Tensor constructor: unsupported location '\".concat(this.dataLocation, \"'\"));\n            }\n            else {\n                let d, l;\n                if (typeof t == \"string\") if (o = t, l = n, t === \"string\") {\n                    if (!Array.isArray(r)) throw new TypeError(\"A string tensor's data must be a string array.\");\n                    d = r;\n                } else {\n                    let p = Tt.get(t);\n                    if (p === void 0) throw new TypeError(\"Unsupported tensor type: \".concat(t, \".\"));\n                    if (Array.isArray(r)) {\n                        if (t === \"float16\" && p === Uint16Array || t === \"uint4\" || t === \"int4\") throw new TypeError(\"Creating a \".concat(t, \" tensor from number array is not supported. Please use \").concat(p.name, \" as data.\"));\n                        t === \"uint64\" || t === \"int64\" ? d = p.from(r, BigInt) : d = p.from(r);\n                    } else if (r instanceof p) d = r;\n                    else if (r instanceof Uint8ClampedArray) if (t === \"uint8\") d = Uint8Array.from(r);\n                    else throw new TypeError(\"A Uint8ClampedArray tensor's data must be type of uint8\");\n                    else throw new TypeError(\"A \".concat(o, \" tensor's data must be type of \").concat(p));\n                }\n                else if (l = r, Array.isArray(t)) {\n                    if (t.length === 0) throw new TypeError(\"Tensor type cannot be inferred from an empty array.\");\n                    let p = typeof t[0];\n                    if (p === \"string\") o = \"string\", d = t;\n                    else if (p === \"boolean\") o = \"bool\", d = Uint8Array.from(t);\n                    else throw new TypeError(\"Invalid element type of data array: \".concat(p, \".\"));\n                } else if (t instanceof Uint8ClampedArray) o = \"uint8\", d = Uint8Array.from(t);\n                else {\n                    let p = qt.get(t.constructor);\n                    if (p === void 0) throw new TypeError(\"Unsupported type for tensor data: \".concat(t.constructor, \".\"));\n                    o = p, d = t;\n                }\n                if (l === void 0) l = [\n                    d.length\n                ];\n                else if (!Array.isArray(l)) throw new TypeError(\"A tensor's dims must be a number array\");\n                i = l, this.cpuData = d, this.dataLocation = \"cpu\";\n            }\n            let a = ba(i);\n            if (this.cpuData && a !== this.cpuData.length && !((o === \"uint4\" || o === \"int4\") && Math.ceil(a / 2) === this.cpuData.length)) throw new Error(\"Tensor's size(\".concat(a, \") does not match data length(\").concat(this.cpuData.length, \").\"));\n            this.type = o, this.dims = i, this.size = a;\n        }\n    };\n});\nvar He, Gn = U(()=>{\n    \"use strict\";\n    _r();\n    He = ze;\n});\nvar wr, wa, Ue, De, Hn = U(()=>{\n    \"use strict\";\n    Wn();\n    wr = (e1, t)=>{\n        (typeof Re.trace > \"u\" ? !Re.wasm.trace : !Re.trace) || console.timeStamp(\"\".concat(e1, \"::ORT::\").concat(t));\n    }, wa = (e1, t)=>{\n        var _stack;\n        let r = ((_stack = new Error().stack) === null || _stack === void 0 ? void 0 : _stack.split(/\\r\\n|\\r|\\n/g)) || [], n = !1;\n        for(let o = 0; o < r.length; o++){\n            if (n && !r[o].includes(\"TRACE_FUNC\")) {\n                let i = \"FUNC_\".concat(e1, \"::\").concat(r[o].trim().split(\" \")[1]);\n                t && (i += \"::\".concat(t)), wr(\"CPU\", i);\n                return;\n            }\n            r[o].includes(\"TRACE_FUNC\") && (n = !0);\n        }\n    }, Ue = (e1)=>{\n        (typeof Re.trace > \"u\" ? !Re.wasm.trace : !Re.trace) || wa(\"BEGIN\", e1);\n    }, De = (e1)=>{\n        (typeof Re.trace > \"u\" ? !Re.wasm.trace : !Re.trace) || wa(\"END\", e1);\n    };\n});\nvar vr, va = U(()=>{\n    \"use strict\";\n    Vn();\n    Gn();\n    Hn();\n    vr = class e1 {\n        async run(t, r, n) {\n            Ue();\n            let o = {}, i = {};\n            if (typeof t != \"object\" || t === null || t instanceof He || Array.isArray(t)) throw new TypeError(\"'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.\");\n            let a = !0;\n            if (typeof r == \"object\") {\n                if (r === null) throw new TypeError(\"Unexpected argument[1]: cannot be null.\");\n                if (r instanceof He) throw new TypeError(\"'fetches' cannot be a Tensor\");\n                if (Array.isArray(r)) {\n                    if (r.length === 0) throw new TypeError(\"'fetches' cannot be an empty array.\");\n                    a = !1;\n                    for (let p of r){\n                        if (typeof p != \"string\") throw new TypeError(\"'fetches' must be a string array or an object.\");\n                        if (this.outputNames.indexOf(p) === -1) throw new RangeError(\"'fetches' contains invalid output name: \".concat(p, \".\"));\n                        o[p] = null;\n                    }\n                    if (typeof n == \"object\" && n !== null) i = n;\n                    else if (typeof n < \"u\") throw new TypeError(\"'options' must be an object.\");\n                } else {\n                    let p = !1, m = Object.getOwnPropertyNames(r);\n                    for (let u of this.outputNames)if (m.indexOf(u) !== -1) {\n                        let h = r[u];\n                        (h === null || h instanceof He) && (p = !0, a = !1, o[u] = h);\n                    }\n                    if (p) {\n                        if (typeof n == \"object\" && n !== null) i = n;\n                        else if (typeof n < \"u\") throw new TypeError(\"'options' must be an object.\");\n                    } else i = r;\n                }\n            } else if (typeof r < \"u\") throw new TypeError(\"Unexpected argument[1]: must be 'fetches' or 'options'.\");\n            for (let p of this.inputNames)if (typeof t[p] > \"u\") throw new Error(\"input '\".concat(p, \"' is missing in 'feeds'.\"));\n            if (a) for (let p of this.outputNames)o[p] = null;\n            let d = await this.handler.run(t, o, i), l = {};\n            for(let p in d)if (Object.hasOwnProperty.call(d, p)) {\n                let m = d[p];\n                m instanceof He ? l[p] = m : l[p] = new He(m.type, m.data, m.dims);\n            }\n            return De(), l;\n        }\n        async release() {\n            return this.handler.dispose();\n        }\n        static async create(t, r, n, o) {\n            Ue();\n            let i, a = {};\n            if (typeof t == \"string\") {\n                if (i = t, typeof r == \"object\" && r !== null) a = r;\n                else if (typeof r < \"u\") throw new TypeError(\"'options' must be an object.\");\n            } else if (t instanceof Uint8Array) {\n                if (i = t, typeof r == \"object\" && r !== null) a = r;\n                else if (typeof r < \"u\") throw new TypeError(\"'options' must be an object.\");\n            } else if (t instanceof ArrayBuffer || typeof SharedArrayBuffer < \"u\" && t instanceof SharedArrayBuffer) {\n                let m = t, u = 0, h = t.byteLength;\n                if (typeof r == \"object\" && r !== null) a = r;\n                else if (typeof r == \"number\") {\n                    if (u = r, !Number.isSafeInteger(u)) throw new RangeError(\"'byteOffset' must be an integer.\");\n                    if (u < 0 || u >= m.byteLength) throw new RangeError(\"'byteOffset' is out of range [0, \".concat(m.byteLength, \").\"));\n                    if (h = t.byteLength - u, typeof n == \"number\") {\n                        if (h = n, !Number.isSafeInteger(h)) throw new RangeError(\"'byteLength' must be an integer.\");\n                        if (h <= 0 || u + h > m.byteLength) throw new RangeError(\"'byteLength' is out of range (0, \".concat(m.byteLength - u, \"].\"));\n                        if (typeof o == \"object\" && o !== null) a = o;\n                        else if (typeof o < \"u\") throw new TypeError(\"'options' must be an object.\");\n                    } else if (typeof n < \"u\") throw new TypeError(\"'byteLength' must be a number.\");\n                } else if (typeof r < \"u\") throw new TypeError(\"'options' must be an object.\");\n                i = new Uint8Array(m, u, h);\n            } else throw new TypeError(\"Unexpected argument[0]: must be 'path' or 'buffer'.\");\n            let [d, l] = await Ji(a), p = await d.createInferenceSessionHandler(i, l);\n            return De(), new e1(p);\n        }\n        startProfiling() {\n            this.handler.startProfiling();\n        }\n        endProfiling() {\n            this.handler.endProfiling();\n        }\n        get inputNames() {\n            return this.handler.inputNames;\n        }\n        get outputNames() {\n            return this.handler.outputNames;\n        }\n        constructor(t){\n            this.handler = t;\n        }\n    };\n});\nvar Fp, $a = U(()=>{\n    \"use strict\";\n    va();\n    Fp = vr;\n});\nvar xa = U(()=>{\n    \"use strict\";\n});\nvar Sa = U(_c1 = ()=>{\n    \"use strict\";\n});\n_c2 = Sa;\nvar Ta = U(_c3 = ()=>{\n    \"use strict\";\n});\n_c4 = Ta;\nvar Ia = U(_c5 = ()=>{\n    \"use strict\";\n});\n_c6 = Ia;\nvar Fn = {};\nFt(Fn, {\n    InferenceSession: ()=>Fp,\n    TRACE: ()=>wr,\n    TRACE_FUNC_BEGIN: ()=>Ue,\n    TRACE_FUNC_END: ()=>De,\n    Tensor: ()=>He,\n    env: ()=>ve,\n    registerBackend: ()=>St\n});\nvar We = U(_c7 = ()=>{\n    \"use strict\";\n    ea();\n    oa();\n    $a();\n    Gn();\n    xa();\n    Sa();\n    Hn();\n    Ta();\n    Ia();\n});\n_c8 = We;\nvar $r = U(()=>{\n    \"use strict\";\n});\nvar Ea = {};\nFt(Ea, {\n    default: ()=>qp\n});\nvar Aa, ka, qp, Pa = U(()=>{\n    \"use strict\";\n    var _globalThis_self;\n    qn();\n    gt();\n    xr();\n    Aa = \"ort-wasm-proxy-worker\", ka = ((_globalThis_self = globalThis.self) === null || _globalThis_self === void 0 ? void 0 : _globalThis_self.name) === Aa;\n    ka && (self.onmessage = (e1)=>{\n        let { type: t, in: r } = e1.data;\n        try {\n            switch(t){\n                case \"init-wasm\":\n                    Sr(r.wasm).then(()=>{\n                        Tr(r).then(()=>{\n                            postMessage({\n                                type: t\n                            });\n                        }, (n)=>{\n                            postMessage({\n                                type: t,\n                                err: n\n                            });\n                        });\n                    }, (n)=>{\n                        postMessage({\n                            type: t,\n                            err: n\n                        });\n                    });\n                    break;\n                case \"init-ep\":\n                    {\n                        let { epName: n, env: o } = r;\n                        Ir(o, n).then(()=>{\n                            postMessage({\n                                type: t\n                            });\n                        }, (i)=>{\n                            postMessage({\n                                type: t,\n                                err: i\n                            });\n                        });\n                        break;\n                    }\n                case \"copy-from\":\n                    {\n                        let { buffer: n } = r, o = Kt(n);\n                        postMessage({\n                            type: t,\n                            out: o\n                        });\n                        break;\n                    }\n                case \"create\":\n                    {\n                        let { model: n, options: o } = r;\n                        Cr(n, o).then((i)=>{\n                            postMessage({\n                                type: t,\n                                out: i\n                            });\n                        }, (i)=>{\n                            postMessage({\n                                type: t,\n                                err: i\n                            });\n                        });\n                        break;\n                    }\n                case \"release\":\n                    Ar(r), postMessage({\n                        type: t\n                    });\n                    break;\n                case \"run\":\n                    {\n                        let { sessionId: n, inputIndices: o, inputs: i, outputIndices: a, options: d } = r;\n                        kr(n, o, i, a, new Array(a.length).fill(null), d).then((l)=>{\n                            l.some((p)=>p[3] !== \"cpu\") ? postMessage({\n                                type: t,\n                                err: \"Proxy does not support non-cpu tensor location.\"\n                            }) : postMessage({\n                                type: t,\n                                out: l\n                            }, Pr([\n                                ...i,\n                                ...l\n                            ]));\n                        }, (l)=>{\n                            postMessage({\n                                type: t,\n                                err: l\n                            });\n                        });\n                        break;\n                    }\n                case \"end-profiling\":\n                    Er(r), postMessage({\n                        type: t\n                    });\n                    break;\n                default:\n            }\n        } catch (n) {\n            postMessage({\n                type: t,\n                err: n\n            });\n        }\n    });\n    qp = ka ? null : (e1)=>new Worker(e1 !== null && e1 !== void 0 ? e1 : Ne, {\n            type: \"module\",\n            name: Aa\n        });\n});\nvar Oa = {};\nFt(Oa, {\n    default: ()=>Kp\n});\nvar Kn, za, Kp, Da = U(()=>{\n    \"use strict\";\n    var _globalThis_self;\n    za = (Kn = \"file:///Users/amityadav/Desktop/Text-Behind%20Image/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs\", async function() {\n        let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        function t() {\n            return se.buffer != J.buffer && ye(), J;\n        }\n        function r() {\n            return se.buffer != J.buffer && ye(), ne;\n        }\n        function n() {\n            return se.buffer != J.buffer && ye(), be;\n        }\n        function o() {\n            return se.buffer != J.buffer && ye(), Oe;\n        }\n        function i() {\n            return se.buffer != J.buffer && ye(), $e;\n        }\n        function a() {\n            return se.buffer != J.buffer && ye(), le;\n        }\n        function d() {\n            return se.buffer != J.buffer && ye(), W;\n        }\n        function l() {\n            return se.buffer != J.buffer && ye(), Ge;\n        }\n        var p, m, u = Object.assign({}, e1), h = new Promise((s, c)=>{\n            p = s, m = c;\n        }), _ = \"object\" == \"object\", y = typeof importScripts == \"function\", g = y && self.name == \"em-pthread\";\n        u.mountExternalData = (s, c)=>{\n            s.startsWith(\"./\") && (s = s.substring(2)), (u.Fb || (u.Fb = new Map)).set(s, c);\n        }, u.unmountExternalData = ()=>{\n            delete u.Fb;\n        };\n        var _globalThis_SharedArrayBuffer;\n        var x = (_globalThis_SharedArrayBuffer = globalThis.SharedArrayBuffer) !== null && _globalThis_SharedArrayBuffer !== void 0 ? _globalThis_SharedArrayBuffer : new WebAssembly.Memory({\n            initial: 0,\n            maximum: 0,\n            shared: !0\n        }).buffer.constructor;\n        let $ = ()=>{\n            let s = (f, b, w)=>function() {\n                    for(var _len = arguments.length, I = new Array(_len), _key = 0; _key < _len; _key++){\n                        I[_key] = arguments[_key];\n                    }\n                    let O = Xe, B = b === null || b === void 0 ? void 0 : b();\n                    I = f(...I);\n                    let L = b === null || b === void 0 ? void 0 : b();\n                    return B !== L && (f = L, w(B), b = w = null), Xe != O ? new Promise((H, X)=>{\n                        En = {\n                            resolve: H,\n                            reject: X\n                        };\n                    }) : I;\n                }, c = (f)=>async function() {\n                    for(var _len = arguments.length, b = new Array(_len), _key = 0; _key < _len; _key++){\n                        b[_key] = arguments[_key];\n                    }\n                    try {\n                        var _u_Hb;\n                        if (u.Gb) throw Error(\"Session already started\");\n                        let w = u.Gb = {\n                            hc: b[0],\n                            errors: []\n                        }, I = await f(...b);\n                        if (u.Gb !== w) throw Error(\"Session mismatch\");\n                        (_u_Hb = u.Hb) === null || _u_Hb === void 0 ? void 0 : _u_Hb.flush();\n                        let O = w.errors;\n                        if (0 < O.length) {\n                            let B = await Promise.all(O);\n                            if (B = B.filter((L)=>L), 0 < B.length) throw Error(B.join(\"\\n\"));\n                        }\n                        return I;\n                    } finally{\n                        u.Gb = null;\n                    }\n                };\n            u._OrtCreateSession = s(u._OrtCreateSession, ()=>u._OrtCreateSession, (f)=>u._OrtCreateSession = f), u._OrtRun = c(s(u._OrtRun, ()=>u._OrtRun, (f)=>u._OrtRun = f)), u._OrtRunWithBinding = c(s(u._OrtRunWithBinding, ()=>u._OrtRunWithBinding, (f)=>u._OrtRunWithBinding = f)), u._OrtBindInput = s(u._OrtBindInput, ()=>u._OrtBindInput, (f)=>u._OrtBindInput = f), $ = void 0;\n        };\n        u.jsepInit = (s, c)=>{\n            if ($ === null || $ === void 0 ? void 0 : $(), s === \"webgpu\") {\n                [u.Hb, u.Vb, u.Zb, u.Ob, u.Yb, u.kb, u.$b, u.cc, u.Wb, u.Xb, u.ac] = c;\n                let f = u.Hb;\n                u.jsepRegisterBuffer = (b, w, I, O)=>f.registerBuffer(b, w, I, O), u.jsepGetBuffer = (b)=>f.getBuffer(b), u.jsepCreateDownloader = (b, w, I)=>f.createDownloader(b, w, I), u.jsepOnCreateSession = (b)=>{\n                    f.onCreateSession(b);\n                }, u.jsepOnReleaseSession = (b)=>{\n                    f.onReleaseSession(b);\n                }, u.jsepOnRunStart = (b)=>f.onRunStart(b), u.dc = (b, w)=>{\n                    f.upload(b, w);\n                };\n            } else if (s === \"webnn\") {\n                [u.Hb, u.bc, u.Pb, u.jsepEnsureTensor, u.ec, u.jsepDownloadTensor] = c, u.jsepReleaseTensorId = u.Pb;\n                let f = u.Hb;\n                u.jsepOnRunStart = (b)=>f.onRunStart(b), u.jsepRegisterMLContext = (b, w)=>{\n                    f.registerMLContext(b, w);\n                }, u.jsepOnReleaseSession = (b)=>{\n                    f.onReleaseSession(b);\n                }, u.jsepCreateMLTensorDownloader = (b, w)=>f.createMLTensorDownloader(b, w), u.jsepRegisterMLTensor = (b, w, I)=>f.registerMLTensor(b, w, I), u.jsepCreateMLContext = (b)=>f.createMLContext(b), u.jsepRegisterMLConstant = (b, w, I, O, B)=>f.registerMLConstant(b, w, I, O, B, u.Fb);\n            }\n        };\n        var v, S, T = Object.assign({}, u), A = \"./this.program\", k = (s, c)=>{\n            throw c;\n        }, P = \"\";\n        (_ || y) && (y ? P = self.location.href : typeof document < \"u\" && document.currentScript && (P = document.currentScript.src), Kn && (P = Kn), P = P.startsWith(\"blob:\") ? \"\" : P.substr(0, P.replace(/[?#].*/, \"\").lastIndexOf(\"/\") + 1), y && (S = (s)=>{\n            var c = new XMLHttpRequest;\n            return c.open(\"GET\", s, !1), c.responseType = \"arraybuffer\", c.send(null), new Uint8Array(c.response);\n        }), v = (s, c, f)=>{\n            var b = new XMLHttpRequest;\n            b.open(\"GET\", s, !0), b.responseType = \"arraybuffer\", b.onload = ()=>{\n                b.status == 200 || b.status == 0 && b.response ? c(b.response) : f();\n            }, b.onerror = f, b.send(null);\n        });\n        var D, R = console.log.bind(console), G = console.error.bind(console), K = R, j = G;\n        if (Object.assign(u, T), T = null, g) {\n            let s = function(c) {\n                try {\n                    var f = c.data, b = f.cmd;\n                    if (b === \"load\") {\n                        let w = [];\n                        self.onmessage = (I)=>w.push(I), self.startWorker = ()=>{\n                            postMessage({\n                                cmd: \"loaded\"\n                            });\n                            for (let I of w)s(I);\n                            self.onmessage = s;\n                        };\n                        for (let I of f.handlers)u[I] && !u[I].proxy || (u[I] = function() {\n                            for(var _len = arguments.length, O = new Array(_len), _key = 0; _key < _len; _key++){\n                                O[_key] = arguments[_key];\n                            }\n                            postMessage({\n                                Nb: \"callHandler\",\n                                pc: I,\n                                args: O\n                            });\n                        }, I == \"print\" && (K = u[I]), I == \"printErr\" && (j = u[I]));\n                        se = f.wasmMemory, ye(), V(f.wasmModule);\n                    } else if (b === \"run\") {\n                        Dn(f.pthread_ptr, 0, 0, 1, 0, 0), An(f.pthread_ptr), xc(), Ho(), Q || (Wi(), Q = !0);\n                        try {\n                            Sc(f.start_routine, f.arg);\n                        } catch (w) {\n                            if (w != \"unwind\") throw w;\n                        }\n                    } else b === \"cancel\" ? Mt() && hr(-1) : f.target !== \"setimmediate\" && (b === \"checkMailbox\" ? Q && ir() : b && (j(\"worker: received unknown command \".concat(b)), j(f)));\n                } catch (w) {\n                    throw Li(), w;\n                }\n            };\n            var wg = s, V, Q = !1;\n            j = function() {\n                for(var _len = arguments.length, c = new Array(_len), _key = 0; _key < _len; _key++){\n                    c[_key] = arguments[_key];\n                }\n                c = c.join(\" \"), console.error(c);\n            }, self.alert = function() {\n                for(var _len = arguments.length, c = new Array(_len), _key = 0; _key < _len; _key++){\n                    c[_key] = arguments[_key];\n                }\n                postMessage({\n                    Nb: \"alert\",\n                    text: c.join(\" \"),\n                    rc: Mt()\n                });\n            }, u.instantiateWasm = (c, f)=>new Promise((b)=>{\n                    V = (w)=>{\n                        w = new WebAssembly.Instance(w, No()), f(w), b();\n                    };\n                }), self.onunhandledrejection = (c)=>{\n                throw c.reason || c;\n            }, self.onmessage = s;\n        }\n        u.wasmBinary && (D = u.wasmBinary);\n        var se, Y, ee, J, ne, be, Oe, $e, le, W, q, he, Ge, we = !1;\n        function ye() {\n            var s = se.buffer;\n            u.HEAP8 = J = new Int8Array(s), u.HEAP16 = be = new Int16Array(s), u.HEAPU8 = ne = new Uint8Array(s), u.HEAPU16 = Oe = new Uint16Array(s), u.HEAP32 = $e = new Int32Array(s), u.HEAPU32 = le = new Uint32Array(s), u.HEAPF32 = W = new Float32Array(s), u.HEAPF64 = Ge = new Float64Array(s), u.HEAP64 = q = new BigInt64Array(s), u.HEAPU64 = he = new BigUint64Array(s);\n        }\n        if (!g) {\n            if (!((se = new WebAssembly.Memory({\n                initial: 256,\n                maximum: 65536,\n                shared: !0\n            })).buffer instanceof x)) throw j(\"requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag\"), Error(\"bad memory\");\n            ye();\n        }\n        var Ye = [], Lt = [], fn = [], Gt = 0, hn = null, Ht = null;\n        function Do() {\n            if (--Gt == 0 && (hn !== null && (clearInterval(hn), hn = null), Ht)) {\n                var s = Ht;\n                Ht = null, s();\n            }\n        }\n        function ct(s) {\n            throw j(s = \"Aborted(\" + s + \")\"), we = !0, ee = 1, s = new WebAssembly.RuntimeError(s + \". Build with -sASSERTIONS for more info.\"), m(s), s;\n        }\n        var gn, Bo = (s)=>s.startsWith(\"data:application/octet-stream;base64,\"), Mo = (s)=>s.startsWith(\"file://\");\n        function Ro(s) {\n            if (s == gn && D) return new Uint8Array(D);\n            if (S) return S(s);\n            throw \"both async and sync fetching of the wasm failed\";\n        }\n        function Uo(s, c, f) {\n            return (function(b) {\n                if (!D && (_ || y)) {\n                    if (typeof fetch == \"function\" && !Mo(b)) return fetch(b, {\n                        credentials: \"same-origin\"\n                    }).then((w)=>{\n                        if (!w.ok) throw \"failed to load wasm binary file at '\".concat(b, \"'\");\n                        return w.arrayBuffer();\n                    }).catch(()=>Ro(b));\n                    if (v) return new Promise((w, I)=>{\n                        v(b, (O)=>w(new Uint8Array(O)), I);\n                    });\n                }\n                return Promise.resolve().then(()=>Ro(b));\n            })(s).then((b)=>WebAssembly.instantiate(b, c)).then(f, (b)=>{\n                j(\"failed to asynchronously prepare wasm: \".concat(b)), ct(b);\n            });\n        }\n        function No() {\n            return {\n                a: {\n                    O: $c,\n                    Aa: vc,\n                    b: Ic,\n                    aa: jo,\n                    B: Qo,\n                    qa: Xo,\n                    Y: ei,\n                    _: ti,\n                    ra: ri,\n                    oa: ni,\n                    ha: oi,\n                    na: ii,\n                    L: ai,\n                    Z: si,\n                    W: ui,\n                    pa: di,\n                    X: li,\n                    va: Cc,\n                    F: kc,\n                    Q: Ec,\n                    P: zc,\n                    E: Dc,\n                    u: Bc,\n                    q: Mc,\n                    G: Rc,\n                    A: Hc,\n                    R: Fc,\n                    ua: qc,\n                    ka: Kc,\n                    U: jc,\n                    ba: Yc,\n                    H: Zc,\n                    ja: An,\n                    ta: Qc,\n                    t: Xc,\n                    Ba: Jc,\n                    x: rp,\n                    n: np,\n                    l: ip,\n                    c: In,\n                    o: ap,\n                    j: dp,\n                    w: lp,\n                    p: cp,\n                    f: pp,\n                    s: mp,\n                    m: fp,\n                    e: hp,\n                    k: gp,\n                    i: bp,\n                    h: yp,\n                    d: _p,\n                    ea: wp,\n                    fa: vp,\n                    ga: $p,\n                    ca: Si,\n                    da: Ti,\n                    T: xp,\n                    g: Sp,\n                    D: Tp,\n                    I: Ip,\n                    M: Cp,\n                    y: Ap,\n                    sa: kp,\n                    V: Ep,\n                    v: Ci,\n                    z: Pp,\n                    N: zp,\n                    S: Op,\n                    za: Dp,\n                    ya: Bp,\n                    la: Ei,\n                    ma: Pi,\n                    $: vn,\n                    C: zi,\n                    K: Oi,\n                    ia: Di,\n                    J: Bi,\n                    a: se,\n                    xa: wn,\n                    wa: Ui,\n                    r: Up\n                }\n            };\n        }\n        var bn = {\n            913700: (s, c, f, b, w)=>{\n                if (u === void 0 || !u.Fb) return 1;\n                if ((s = Ce(Number(s >>> 0))).startsWith(\"./\") && (s = s.substring(2)), !(s = u.Fb.get(s))) return 2;\n                if (c = Number(c >>> 0), f = Number(f >>> 0), b = Number(b >>> 0), c + f > s.byteLength) return 3;\n                try {\n                    let I = s.subarray(c, c + f);\n                    switch(w){\n                        case 0:\n                            r().set(I, b >>> 0);\n                            break;\n                        case 1:\n                            u.dc(b, I);\n                            break;\n                        default:\n                            return 4;\n                    }\n                    return 0;\n                } catch (e1) {\n                    return 4;\n                }\n            },\n            914415: (s, c, f)=>{\n                u.ec(s, r().subarray(c >>> 0, c + f >>> 0));\n            },\n            914478: ()=>u.bc(),\n            914519: (s)=>{\n                u.Pb(s);\n            },\n            914555: ()=>{\n                u.Wb();\n            },\n            914586: ()=>{\n                u.Xb();\n            },\n            914615: ()=>{\n                u.ac();\n            },\n            914640: (s)=>u.Vb(s),\n            914673: (s)=>u.Zb(s),\n            914705: (s, c, f)=>{\n                u.Ob(Number(s), Number(c), Number(f), !0);\n            },\n            914768: (s, c, f)=>{\n                u.Ob(Number(s), Number(c), Number(f));\n            },\n            914825: ()=>typeof wasmOffsetConverter < \"u\",\n            914882: (s)=>{\n                u.kb(\"Abs\", s, void 0);\n            },\n            914933: (s)=>{\n                u.kb(\"Neg\", s, void 0);\n            },\n            914984: (s)=>{\n                u.kb(\"Floor\", s, void 0);\n            },\n            915037: (s)=>{\n                u.kb(\"Ceil\", s, void 0);\n            },\n            915089: (s)=>{\n                u.kb(\"Reciprocal\", s, void 0);\n            },\n            915147: (s)=>{\n                u.kb(\"Sqrt\", s, void 0);\n            },\n            915199: (s)=>{\n                u.kb(\"Exp\", s, void 0);\n            },\n            915250: (s)=>{\n                u.kb(\"Erf\", s, void 0);\n            },\n            915301: (s)=>{\n                u.kb(\"Sigmoid\", s, void 0);\n            },\n            915356: (s, c, f)=>{\n                u.kb(\"HardSigmoid\", s, {\n                    alpha: c,\n                    beta: f\n                });\n            },\n            915435: (s)=>{\n                u.kb(\"Log\", s, void 0);\n            },\n            915486: (s)=>{\n                u.kb(\"Sin\", s, void 0);\n            },\n            915537: (s)=>{\n                u.kb(\"Cos\", s, void 0);\n            },\n            915588: (s)=>{\n                u.kb(\"Tan\", s, void 0);\n            },\n            915639: (s)=>{\n                u.kb(\"Asin\", s, void 0);\n            },\n            915691: (s)=>{\n                u.kb(\"Acos\", s, void 0);\n            },\n            915743: (s)=>{\n                u.kb(\"Atan\", s, void 0);\n            },\n            915795: (s)=>{\n                u.kb(\"Sinh\", s, void 0);\n            },\n            915847: (s)=>{\n                u.kb(\"Cosh\", s, void 0);\n            },\n            915899: (s)=>{\n                u.kb(\"Asinh\", s, void 0);\n            },\n            915952: (s)=>{\n                u.kb(\"Acosh\", s, void 0);\n            },\n            916005: (s)=>{\n                u.kb(\"Atanh\", s, void 0);\n            },\n            916058: (s)=>{\n                u.kb(\"Tanh\", s, void 0);\n            },\n            916110: (s)=>{\n                u.kb(\"Not\", s, void 0);\n            },\n            916161: (s, c, f)=>{\n                u.kb(\"Clip\", s, {\n                    min: c,\n                    max: f\n                });\n            },\n            916230: (s)=>{\n                u.kb(\"Clip\", s, void 0);\n            },\n            916282: (s, c)=>{\n                u.kb(\"Elu\", s, {\n                    alpha: c\n                });\n            },\n            916340: (s)=>{\n                u.kb(\"Gelu\", s, void 0);\n            },\n            916392: (s)=>{\n                u.kb(\"Relu\", s, void 0);\n            },\n            916444: (s, c)=>{\n                u.kb(\"LeakyRelu\", s, {\n                    alpha: c\n                });\n            },\n            916508: (s, c)=>{\n                u.kb(\"ThresholdedRelu\", s, {\n                    alpha: c\n                });\n            },\n            916578: (s, c)=>{\n                u.kb(\"Cast\", s, {\n                    to: c\n                });\n            },\n            916636: (s)=>{\n                u.kb(\"Add\", s, void 0);\n            },\n            916687: (s)=>{\n                u.kb(\"Sub\", s, void 0);\n            },\n            916738: (s)=>{\n                u.kb(\"Mul\", s, void 0);\n            },\n            916789: (s)=>{\n                u.kb(\"Div\", s, void 0);\n            },\n            916840: (s)=>{\n                u.kb(\"Pow\", s, void 0);\n            },\n            916891: (s)=>{\n                u.kb(\"Equal\", s, void 0);\n            },\n            916944: (s)=>{\n                u.kb(\"Greater\", s, void 0);\n            },\n            916999: (s)=>{\n                u.kb(\"GreaterOrEqual\", s, void 0);\n            },\n            917061: (s)=>{\n                u.kb(\"Less\", s, void 0);\n            },\n            917113: (s)=>{\n                u.kb(\"LessOrEqual\", s, void 0);\n            },\n            917172: (s, c, f, b, w)=>{\n                u.kb(\"ReduceMean\", s, {\n                    keepDims: !!c,\n                    noopWithEmptyAxes: !!f,\n                    axes: b ? Array.from(i().subarray(Number(b) >>> 0, Number(w) >>> 0)) : []\n                });\n            },\n            917347: (s, c, f, b, w)=>{\n                u.kb(\"ReduceMax\", s, {\n                    keepDims: !!c,\n                    noopWithEmptyAxes: !!f,\n                    axes: b ? Array.from(i().subarray(Number(b) >>> 0, Number(w) >>> 0)) : []\n                });\n            },\n            917521: (s, c, f, b, w)=>{\n                u.kb(\"ReduceMin\", s, {\n                    keepDims: !!c,\n                    noopWithEmptyAxes: !!f,\n                    axes: b ? Array.from(i().subarray(Number(b) >>> 0, Number(w) >>> 0)) : []\n                });\n            },\n            917695: (s, c, f, b, w)=>{\n                u.kb(\"ReduceProd\", s, {\n                    keepDims: !!c,\n                    noopWithEmptyAxes: !!f,\n                    axes: b ? Array.from(i().subarray(Number(b) >>> 0, Number(w) >>> 0)) : []\n                });\n            },\n            917870: (s, c, f, b, w)=>{\n                u.kb(\"ReduceSum\", s, {\n                    keepDims: !!c,\n                    noopWithEmptyAxes: !!f,\n                    axes: b ? Array.from(i().subarray(Number(b) >>> 0, Number(w) >>> 0)) : []\n                });\n            },\n            918044: (s, c, f, b, w)=>{\n                u.kb(\"ReduceL1\", s, {\n                    keepDims: !!c,\n                    noopWithEmptyAxes: !!f,\n                    axes: b ? Array.from(i().subarray(Number(b) >>> 0, Number(w) >>> 0)) : []\n                });\n            },\n            918217: (s, c, f, b, w)=>{\n                u.kb(\"ReduceL2\", s, {\n                    keepDims: !!c,\n                    noopWithEmptyAxes: !!f,\n                    axes: b ? Array.from(i().subarray(Number(b) >>> 0, Number(w) >>> 0)) : []\n                });\n            },\n            918390: (s, c, f, b, w)=>{\n                u.kb(\"ReduceLogSum\", s, {\n                    keepDims: !!c,\n                    noopWithEmptyAxes: !!f,\n                    axes: b ? Array.from(i().subarray(Number(b) >>> 0, Number(w) >>> 0)) : []\n                });\n            },\n            918567: (s, c, f, b, w)=>{\n                u.kb(\"ReduceSumSquare\", s, {\n                    keepDims: !!c,\n                    noopWithEmptyAxes: !!f,\n                    axes: b ? Array.from(i().subarray(Number(b) >>> 0, Number(w) >>> 0)) : []\n                });\n            },\n            918747: (s, c, f, b, w)=>{\n                u.kb(\"ReduceLogSumExp\", s, {\n                    keepDims: !!c,\n                    noopWithEmptyAxes: !!f,\n                    axes: b ? Array.from(i().subarray(Number(b) >>> 0, Number(w) >>> 0)) : []\n                });\n            },\n            918927: (s)=>{\n                u.kb(\"Where\", s, void 0);\n            },\n            918980: (s, c, f)=>{\n                u.kb(\"Transpose\", s, {\n                    perm: c ? Array.from(i().subarray(Number(c) >>> 0, Number(f) >>> 0)) : []\n                });\n            },\n            919104: (s, c, f, b)=>{\n                u.kb(\"DepthToSpace\", s, {\n                    blocksize: c,\n                    mode: Ce(f),\n                    format: b ? \"NHWC\" : \"NCHW\"\n                });\n            },\n            919237: (s, c, f, b)=>{\n                u.kb(\"DepthToSpace\", s, {\n                    blocksize: c,\n                    mode: Ce(f),\n                    format: b ? \"NHWC\" : \"NCHW\"\n                });\n            },\n            919370: (s, c, f, b, w, I, O, B, L, H, X, ce, ge, z, de)=>{\n                u.kb(\"ConvTranspose\", s, {\n                    format: L ? \"NHWC\" : \"NCHW\",\n                    autoPad: c,\n                    dilations: [\n                        f\n                    ],\n                    group: b,\n                    kernelShape: [\n                        w\n                    ],\n                    pads: [\n                        I,\n                        O\n                    ],\n                    strides: [\n                        B\n                    ],\n                    wIsConst: ()=>!!t()[H >>> 0],\n                    outputPadding: X ? Array.from(i().subarray(Number(X) >>> 0, Number(ce) >>> 0)) : [],\n                    outputShape: ge ? Array.from(i().subarray(Number(ge) >>> 0, Number(z) >>> 0)) : [],\n                    activation: Ce(de)\n                });\n            },\n            919803: (s, c, f, b, w, I, O, B, L, H, X, ce, ge, z)=>{\n                u.kb(\"ConvTranspose\", s, {\n                    format: B ? \"NHWC\" : \"NCHW\",\n                    autoPad: c,\n                    dilations: Array.from(i().subarray(Number(f) >>> 0, 2 + (Number(f) >>> 0) >>> 0)),\n                    group: b,\n                    kernelShape: Array.from(i().subarray(Number(w) >>> 0, 2 + (Number(w) >>> 0) >>> 0)),\n                    pads: Array.from(i().subarray(Number(I) >>> 0, 4 + (Number(I) >>> 0) >>> 0)),\n                    strides: Array.from(i().subarray(Number(O) >>> 0, 2 + (Number(O) >>> 0) >>> 0)),\n                    wIsConst: ()=>!!t()[L >>> 0],\n                    outputPadding: H ? Array.from(i().subarray(Number(H) >>> 0, Number(X) >>> 0)) : [],\n                    outputShape: ce ? Array.from(i().subarray(Number(ce) >>> 0, Number(ge) >>> 0)) : [],\n                    activation: Ce(z)\n                });\n            },\n            920464: (s, c, f, b, w, I, O, B, L, H, X, ce, ge, z, de)=>{\n                u.kb(\"ConvTranspose\", s, {\n                    format: L ? \"NHWC\" : \"NCHW\",\n                    autoPad: c,\n                    dilations: [\n                        f\n                    ],\n                    group: b,\n                    kernelShape: [\n                        w\n                    ],\n                    pads: [\n                        I,\n                        O\n                    ],\n                    strides: [\n                        B\n                    ],\n                    wIsConst: ()=>!!t()[H >>> 0],\n                    outputPadding: X ? Array.from(i().subarray(Number(X) >>> 0, Number(ce) >>> 0)) : [],\n                    outputShape: ge ? Array.from(i().subarray(Number(ge) >>> 0, Number(z) >>> 0)) : [],\n                    activation: Ce(de)\n                });\n            },\n            920897: (s, c, f, b, w, I, O, B, L, H, X, ce, ge, z)=>{\n                u.kb(\"ConvTranspose\", s, {\n                    format: B ? \"NHWC\" : \"NCHW\",\n                    autoPad: c,\n                    dilations: Array.from(i().subarray(Number(f) >>> 0, 2 + (Number(f) >>> 0) >>> 0)),\n                    group: b,\n                    kernelShape: Array.from(i().subarray(Number(w) >>> 0, 2 + (Number(w) >>> 0) >>> 0)),\n                    pads: Array.from(i().subarray(Number(I) >>> 0, 4 + (Number(I) >>> 0) >>> 0)),\n                    strides: Array.from(i().subarray(Number(O) >>> 0, 2 + (Number(O) >>> 0) >>> 0)),\n                    wIsConst: ()=>!!t()[L >>> 0],\n                    outputPadding: H ? Array.from(i().subarray(Number(H) >>> 0, Number(X) >>> 0)) : [],\n                    outputShape: ce ? Array.from(i().subarray(Number(ce) >>> 0, Number(ge) >>> 0)) : [],\n                    activation: Ce(z)\n                });\n            },\n            921558: (s, c)=>{\n                u.kb(\"GlobalAveragePool\", s, {\n                    format: c ? \"NHWC\" : \"NCHW\"\n                });\n            },\n            921649: (s, c, f, b, w, I, O, B, L, H, X, ce, ge, z)=>{\n                u.kb(\"AveragePool\", s, {\n                    format: z ? \"NHWC\" : \"NCHW\",\n                    auto_pad: c,\n                    ceil_mode: f,\n                    count_include_pad: b,\n                    storage_order: w,\n                    dilations: I ? Array.from(i().subarray(Number(I) >>> 0, Number(O) >>> 0)) : [],\n                    kernel_shape: B ? Array.from(i().subarray(Number(B) >>> 0, Number(L) >>> 0)) : [],\n                    pads: H ? Array.from(i().subarray(Number(H) >>> 0, Number(X) >>> 0)) : [],\n                    strides: ce ? Array.from(i().subarray(Number(ce) >>> 0, Number(ge) >>> 0)) : []\n                });\n            },\n            922128: (s, c)=>{\n                u.kb(\"GlobalAveragePool\", s, {\n                    format: c ? \"NHWC\" : \"NCHW\"\n                });\n            },\n            922219: (s, c, f, b, w, I, O, B, L, H, X, ce, ge, z)=>{\n                u.kb(\"AveragePool\", s, {\n                    format: z ? \"NHWC\" : \"NCHW\",\n                    auto_pad: c,\n                    ceil_mode: f,\n                    count_include_pad: b,\n                    storage_order: w,\n                    dilations: I ? Array.from(i().subarray(Number(I) >>> 0, Number(O) >>> 0)) : [],\n                    kernel_shape: B ? Array.from(i().subarray(Number(B) >>> 0, Number(L) >>> 0)) : [],\n                    pads: H ? Array.from(i().subarray(Number(H) >>> 0, Number(X) >>> 0)) : [],\n                    strides: ce ? Array.from(i().subarray(Number(ce) >>> 0, Number(ge) >>> 0)) : []\n                });\n            },\n            922698: (s, c)=>{\n                u.kb(\"GlobalMaxPool\", s, {\n                    format: c ? \"NHWC\" : \"NCHW\"\n                });\n            },\n            922785: (s, c, f, b, w, I, O, B, L, H, X, ce, ge, z)=>{\n                u.kb(\"MaxPool\", s, {\n                    format: z ? \"NHWC\" : \"NCHW\",\n                    auto_pad: c,\n                    ceil_mode: f,\n                    count_include_pad: b,\n                    storage_order: w,\n                    dilations: I ? Array.from(i().subarray(Number(I) >>> 0, Number(O) >>> 0)) : [],\n                    kernel_shape: B ? Array.from(i().subarray(Number(B) >>> 0, Number(L) >>> 0)) : [],\n                    pads: H ? Array.from(i().subarray(Number(H) >>> 0, Number(X) >>> 0)) : [],\n                    strides: ce ? Array.from(i().subarray(Number(ce) >>> 0, Number(ge) >>> 0)) : []\n                });\n            },\n            923260: (s, c)=>{\n                u.kb(\"GlobalMaxPool\", s, {\n                    format: c ? \"NHWC\" : \"NCHW\"\n                });\n            },\n            923347: (s, c, f, b, w, I, O, B, L, H, X, ce, ge, z)=>{\n                u.kb(\"MaxPool\", s, {\n                    format: z ? \"NHWC\" : \"NCHW\",\n                    auto_pad: c,\n                    ceil_mode: f,\n                    count_include_pad: b,\n                    storage_order: w,\n                    dilations: I ? Array.from(i().subarray(Number(I) >>> 0, Number(O) >>> 0)) : [],\n                    kernel_shape: B ? Array.from(i().subarray(Number(B) >>> 0, Number(L) >>> 0)) : [],\n                    pads: H ? Array.from(i().subarray(Number(H) >>> 0, Number(X) >>> 0)) : [],\n                    strides: ce ? Array.from(i().subarray(Number(ce) >>> 0, Number(ge) >>> 0)) : []\n                });\n            },\n            923822: (s, c, f, b, w)=>{\n                u.kb(\"Gemm\", s, {\n                    alpha: c,\n                    beta: f,\n                    transA: b,\n                    transB: w\n                });\n            },\n            923926: (s)=>{\n                u.kb(\"MatMul\", s, void 0);\n            },\n            923980: (s, c, f, b)=>{\n                u.kb(\"ArgMax\", s, {\n                    keepDims: !!c,\n                    selectLastIndex: !!f,\n                    axis: b\n                });\n            },\n            924088: (s, c, f, b)=>{\n                u.kb(\"ArgMin\", s, {\n                    keepDims: !!c,\n                    selectLastIndex: !!f,\n                    axis: b\n                });\n            },\n            924196: (s, c)=>{\n                u.kb(\"Softmax\", s, {\n                    axis: c\n                });\n            },\n            924259: (s, c)=>{\n                u.kb(\"Concat\", s, {\n                    axis: c\n                });\n            },\n            924319: (s, c, f, b, w)=>{\n                u.kb(\"Split\", s, {\n                    axis: c,\n                    numOutputs: f,\n                    splitSizes: b ? Array.from(i().subarray(Number(b) >>> 0, Number(w) >>> 0)) : []\n                });\n            },\n            924475: (s)=>{\n                u.kb(\"Expand\", s, void 0);\n            },\n            924529: (s, c)=>{\n                u.kb(\"Gather\", s, {\n                    axis: Number(c)\n                });\n            },\n            924600: (s, c)=>{\n                u.kb(\"GatherElements\", s, {\n                    axis: Number(c)\n                });\n            },\n            924679: (s, c)=>{\n                u.kb(\"GatherND\", s, {\n                    batch_dims: Number(c)\n                });\n            },\n            924758: (s, c, f, b, w, I, O, B, L, H, X)=>{\n                u.kb(\"Resize\", s, {\n                    antialias: c,\n                    axes: f ? Array.from(i().subarray(Number(f) >>> 0, Number(b) >>> 0)) : [],\n                    coordinateTransformMode: Ce(w),\n                    cubicCoeffA: I,\n                    excludeOutside: O,\n                    extrapolationValue: B,\n                    keepAspectRatioPolicy: Ce(L),\n                    mode: Ce(H),\n                    nearestMode: Ce(X)\n                });\n            },\n            925120: (s, c, f, b, w, I, O)=>{\n                u.kb(\"Slice\", s, {\n                    starts: c ? Array.from(i().subarray(Number(c) >>> 0, Number(f) >>> 0)) : [],\n                    ends: b ? Array.from(i().subarray(Number(b) >>> 0, Number(w) >>> 0)) : [],\n                    axes: I ? Array.from(i().subarray(Number(I) >>> 0, Number(O) >>> 0)) : []\n                });\n            },\n            925384: (s)=>{\n                u.kb(\"Tile\", s, void 0);\n            },\n            925436: (s, c, f)=>{\n                u.kb(\"InstanceNormalization\", s, {\n                    epsilon: c,\n                    format: f ? \"NHWC\" : \"NCHW\"\n                });\n            },\n            925550: (s, c, f)=>{\n                u.kb(\"InstanceNormalization\", s, {\n                    epsilon: c,\n                    format: f ? \"NHWC\" : \"NCHW\"\n                });\n            },\n            925664: (s)=>{\n                u.kb(\"Range\", s, void 0);\n            },\n            925717: (s, c)=>{\n                u.kb(\"Einsum\", s, {\n                    equation: Ce(c)\n                });\n            },\n            925798: (s, c, f, b, w)=>{\n                u.kb(\"Pad\", s, {\n                    mode: c,\n                    value: f,\n                    pads: b ? Array.from(i().subarray(Number(b) >>> 0, Number(w) >>> 0)) : []\n                });\n            },\n            925941: (s, c, f, b, w, I)=>{\n                u.kb(\"BatchNormalization\", s, {\n                    epsilon: c,\n                    momentum: f,\n                    spatial: !!w,\n                    trainingMode: !!b,\n                    format: I ? \"NHWC\" : \"NCHW\"\n                });\n            },\n            926110: (s, c, f, b, w, I)=>{\n                u.kb(\"BatchNormalization\", s, {\n                    epsilon: c,\n                    momentum: f,\n                    spatial: !!w,\n                    trainingMode: !!b,\n                    format: I ? \"NHWC\" : \"NCHW\"\n                });\n            },\n            926279: (s, c, f)=>{\n                u.kb(\"CumSum\", s, {\n                    exclusive: Number(c),\n                    reverse: Number(f)\n                });\n            },\n            926376: (s, c, f)=>{\n                u.kb(\"DequantizeLinear\", s, {\n                    axis: c,\n                    blockSize: f\n                });\n            },\n            926466: (s, c, f, b, w)=>{\n                u.kb(\"GridSample\", s, {\n                    align_corners: c,\n                    mode: Ce(f),\n                    padding_mode: Ce(b),\n                    format: w ? \"NHWC\" : \"NCHW\"\n                });\n            },\n            926636: (s, c, f, b, w)=>{\n                u.kb(\"GridSample\", s, {\n                    align_corners: c,\n                    mode: Ce(f),\n                    padding_mode: Ce(b),\n                    format: w ? \"NHWC\" : \"NCHW\"\n                });\n            },\n            926806: (s, c, f, b, w, I, O, B, L)=>{\n                u.kb(\"Attention\", s, {\n                    numHeads: c,\n                    isUnidirectional: f,\n                    maskFilterValue: b,\n                    scale: w,\n                    doRotary: I,\n                    qkvHiddenSizes: O ? Array.from(i().subarray(Number(B) >>> 0, Number(B) + O >>> 0)) : [],\n                    pastPresentShareBuffer: !!L\n                });\n            },\n            927078: (s)=>{\n                u.kb(\"BiasAdd\", s, void 0);\n            },\n            927133: (s)=>{\n                u.kb(\"BiasSplitGelu\", s, void 0);\n            },\n            927194: (s)=>{\n                u.kb(\"FastGelu\", s, void 0);\n            },\n            927250: (s, c, f, b, w, I, O, B, L, H, X, ce, ge, z, de, Te)=>{\n                u.kb(\"Conv\", s, {\n                    format: ce ? \"NHWC\" : \"NCHW\",\n                    auto_pad: c,\n                    dilations: f ? Array.from(i().subarray(Number(f) >>> 0, Number(b) >>> 0)) : [],\n                    group: w,\n                    kernel_shape: I ? Array.from(i().subarray(Number(I) >>> 0, Number(O) >>> 0)) : [],\n                    pads: B ? Array.from(i().subarray(Number(B) >>> 0, Number(L) >>> 0)) : [],\n                    strides: H ? Array.from(i().subarray(Number(H) >>> 0, Number(X) >>> 0)) : [],\n                    w_is_const: ()=>!!t()[Number(ge) >>> 0],\n                    activation: Ce(z),\n                    activation_params: de ? Array.from(d().subarray(Number(de) >>> 0, Number(Te) >>> 0)) : []\n                });\n            },\n            927834: (s)=>{\n                u.kb(\"Gelu\", s, void 0);\n            },\n            927886: (s, c, f, b, w, I, O, B, L)=>{\n                u.kb(\"GroupQueryAttention\", s, {\n                    numHeads: c,\n                    kvNumHeads: f,\n                    scale: b,\n                    softcap: w,\n                    doRotary: I,\n                    rotaryInterleaved: O,\n                    smoothSoftmax: B,\n                    localWindowSize: L\n                });\n            },\n            928103: (s, c, f, b)=>{\n                u.kb(\"LayerNormalization\", s, {\n                    axis: c,\n                    epsilon: f,\n                    simplified: !!b\n                });\n            },\n            928214: (s, c, f, b)=>{\n                u.kb(\"LayerNormalization\", s, {\n                    axis: c,\n                    epsilon: f,\n                    simplified: !!b\n                });\n            },\n            928325: (s, c, f, b, w, I)=>{\n                u.kb(\"MatMulNBits\", s, {\n                    k: c,\n                    n: f,\n                    accuracyLevel: b,\n                    bits: w,\n                    blockSize: I\n                });\n            },\n            928452: (s, c, f, b, w, I)=>{\n                u.kb(\"MultiHeadAttention\", s, {\n                    numHeads: c,\n                    isUnidirectional: f,\n                    maskFilterValue: b,\n                    scale: w,\n                    doRotary: I\n                });\n            },\n            928611: (s, c)=>{\n                u.kb(\"QuickGelu\", s, {\n                    alpha: c\n                });\n            },\n            928675: (s, c, f, b, w)=>{\n                u.kb(\"RotaryEmbedding\", s, {\n                    interleaved: !!c,\n                    numHeads: f,\n                    rotaryEmbeddingDim: b,\n                    scale: w\n                });\n            },\n            928814: (s, c, f)=>{\n                u.kb(\"SkipLayerNormalization\", s, {\n                    epsilon: c,\n                    simplified: !!f\n                });\n            },\n            928916: (s, c, f)=>{\n                u.kb(\"SkipLayerNormalization\", s, {\n                    epsilon: c,\n                    simplified: !!f\n                });\n            },\n            929018: (s, c, f, b)=>{\n                u.kb(\"GatherBlockQuantized\", s, {\n                    gatherAxis: c,\n                    quantizeAxis: f,\n                    blockSize: b\n                });\n            },\n            929139: (s)=>{\n                u.$b(s);\n            },\n            929173: (s, c)=>u.cc(Number(s), Number(c), u.Gb.hc, u.Gb.errors)\n        };\n        function vc(s, c, f) {\n            return _i(async ()=>{\n                await u.Yb(Number(s), Number(c), Number(f));\n            });\n        }\n        function $c() {\n            return typeof wasmOffsetConverter < \"u\";\n        }\n        function yn(s) {\n            this.name = \"ExitStatus\", this.message = \"Program terminated with exit(\".concat(s, \")\"), this.status = s;\n        }\n        var _n = (s)=>{\n            s.terminate(), s.onmessage = ()=>{};\n        }, Vo = (s)=>{\n            pt.length == 0 && (qo(), Fo(pt[0]));\n            var c = pt.pop();\n            if (!c) return 6;\n            vt.push(c), Ze[s.Bb] = c, c.Bb = s.Bb;\n            var f = {\n                cmd: \"run\",\n                start_routine: s.ic,\n                arg: s.Rb,\n                pthread_ptr: s.Bb\n            };\n            return c.postMessage(f, s.nc), 0;\n        }, wt = 0, xe = function(s, c) {\n            for(var _len = arguments.length, f = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++){\n                f[_key - 2] = arguments[_key];\n            }\n            for(var b = 2 * f.length, w = Rn(), I = Mn(8 * b), O = I >>> 3, B = 0; B < f.length; B++){\n                var L = f[B];\n                typeof L == \"bigint\" ? (q[O + 2 * B] = 1n, q[O + 2 * B + 1] = L) : (q[O + 2 * B] = 0n, l()[O + 2 * B + 1 >>> 0] = L);\n            }\n            return s = Gi(s, 0, b, I, c), gr(w), s;\n        };\n        function wn(s) {\n            if (g) return xe(0, 1, s);\n            if (ee = s, !(0 < wt)) {\n                for (var c of vt)_n(c);\n                for (c of pt)_n(c);\n                pt = [], vt = [], Ze = [], we = !0;\n            }\n            k(s, new yn(s));\n        }\n        function Wo(s) {\n            if (g) return xe(1, 0, s);\n            vn(s);\n        }\n        var vn = (s)=>{\n            if (ee = s, g) throw Wo(s), \"unwind\";\n            wn(s);\n        }, pt = [], vt = [], Lo = [], Ze = {}, Go = (s)=>{\n            var c = s.Bb;\n            delete Ze[c], pt.push(s), vt.splice(vt.indexOf(s), 1), s.Bb = 0, Bn(c);\n        };\n        function Ho() {\n            Lo.forEach((s)=>s());\n        }\n        var Fo = (s)=>new Promise((c)=>{\n                s.onmessage = (w)=>{\n                    var I = (w = w.data).cmd;\n                    if (w.targetThread && w.targetThread != Mt()) {\n                        var O = Ze[w.targetThread];\n                        O ? O.postMessage(w, w.transferList) : j('Internal error! Worker sent a message \"'.concat(I, '\" to target pthread ').concat(w.targetThread, \", but that thread no longer exists!\"));\n                    } else I === \"checkMailbox\" ? ir() : I === \"spawnThread\" ? Vo(w) : I === \"cleanupThread\" ? Go(Ze[w.thread]) : I === \"killThread\" ? (w = w.thread, I = Ze[w], delete Ze[w], _n(I), Bn(w), vt.splice(vt.indexOf(I), 1), I.Bb = 0) : I === \"cancelThread\" ? Ze[w.thread].postMessage({\n                        cmd: \"cancel\"\n                    }) : I === \"loaded\" ? (s.loaded = !0, c(s)) : I === \"alert\" ? alert(\"Thread \".concat(w.threadId, \": \").concat(w.text)) : w.target === \"setimmediate\" ? s.postMessage(w) : I === \"callHandler\" ? u[w.handler](...w.args) : I && j(\"worker sent an unknown command \".concat(I));\n                }, s.onerror = (w)=>{\n                    throw j(\"worker sent an error! \".concat(w.filename, \":\").concat(w.lineno, \": \").concat(w.message)), w;\n                };\n                var f, b = [];\n                for (f of [])u.hasOwnProperty(f) && b.push(f);\n                s.postMessage({\n                    cmd: \"load\",\n                    handlers: b,\n                    wasmMemory: se,\n                    wasmModule: Y\n                });\n            });\n        function qo() {\n            var s = new Worker(\"file:///Users/amityadav/Desktop/Text-Behind%20Image/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs\".startsWith(\"file:\") ? /* asset import */ new __webpack_require__.U(__webpack_require__(/*! ort.webgpu.bundle.min.mjs */ \"(app-pages-browser)/./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs?7f57\")) : new URL(\"file:///Users/amityadav/Desktop/Text-Behind%20Image/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs\"), {\n                type: \"module\",\n                workerData: \"em-pthread\",\n                name: \"em-pthread\"\n            });\n            pt.push(s);\n        }\n        var or = (s)=>{\n            for(; 0 < s.length;)s.shift()(u);\n        }, xc = ()=>{\n            var s = Mt(), c = a()[s + 52 >>> 2 >>> 0];\n            s = a()[s + 56 >>> 2 >>> 0], Fi(c, c - s), gr(c);\n        }, Sc = (s, c)=>{\n            wt = 0, s = qi(s, c), 0 < wt ? ee = s : hr(s);\n        };\n        class Tc {\n            constructor(c){\n                this.Kb = c - 24;\n            }\n        }\n        function Ic(s, c, f) {\n            var b = new Tc(s >>>= 0);\n            throw c >>>= 0, f >>>= 0, a()[b.Kb + 16 >>> 2 >>> 0] = 0, a()[b.Kb + 4 >>> 2 >>> 0] = c, a()[b.Kb + 8 >>> 2 >>> 0] = f, s;\n        }\n        function Ko(s, c, f, b) {\n            return g ? xe(2, 1, s, c, f, b) : jo(s, c, f, b);\n        }\n        function jo(s, c, f, b) {\n            if (s >>>= 0, c >>>= 0, f >>>= 0, b >>>= 0, x === void 0) return j(\"Current environment does not support SharedArrayBuffer, pthreads are not available!\"), 6;\n            var w = [];\n            return g && w.length === 0 ? Ko(s, c, f, b) : (s = {\n                ic: f,\n                Bb: s,\n                Rb: b,\n                nc: w\n            }, g ? (s.Nb = \"spawnThread\", postMessage(s, w), 0) : Vo(s));\n        }\n        var Yo = typeof TextDecoder < \"u\" ? new TextDecoder(\"utf8\") : void 0, Zo = (s, c, f)=>{\n            var b = (c >>>= 0) + f;\n            for(f = c; s[f] && !(f >= b);)++f;\n            if (16 < f - c && s.buffer && Yo) return Yo.decode(s.buffer instanceof x ? s.slice(c, f) : s.subarray(c, f));\n            for(b = \"\"; c < f;){\n                var w = s[c++];\n                if (128 & w) {\n                    var I = 63 & s[c++];\n                    if ((224 & w) == 192) b += String.fromCharCode((31 & w) << 6 | I);\n                    else {\n                        var O = 63 & s[c++];\n                        65536 > (w = (240 & w) == 224 ? (15 & w) << 12 | I << 6 | O : (7 & w) << 18 | I << 12 | O << 6 | 63 & s[c++]) ? b += String.fromCharCode(w) : (w -= 65536, b += String.fromCharCode(55296 | w >> 10, 56320 | 1023 & w));\n                    }\n                } else b += String.fromCharCode(w);\n            }\n            return b;\n        }, Ce = (s, c)=>(s >>>= 0) ? Zo(r(), s, c) : \"\";\n        function Qo(s, c, f) {\n            return g ? xe(3, 1, s, c, f) : 0;\n        }\n        function Xo(s, c) {\n            if (g) return xe(4, 1, s, c);\n        }\n        var $n = (s)=>{\n            for(var c = 0, f = 0; f < s.length; ++f){\n                var b = s.charCodeAt(f);\n                127 >= b ? c++ : 2047 >= b ? c += 2 : 55296 <= b && 57343 >= b ? (c += 4, ++f) : c += 3;\n            }\n            return c;\n        }, Jo = (s, c, f, b)=>{\n            if (!(0 < b)) return 0;\n            var w = f >>>= 0;\n            b = f + b - 1;\n            for(var I = 0; I < s.length; ++I){\n                var O = s.charCodeAt(I);\n                if (55296 <= O && 57343 >= O && (O = 65536 + ((1023 & O) << 10) | 1023 & s.charCodeAt(++I)), 127 >= O) {\n                    if (f >= b) break;\n                    c[f++ >>> 0] = O;\n                } else {\n                    if (2047 >= O) {\n                        if (f + 1 >= b) break;\n                        c[f++ >>> 0] = 192 | O >> 6;\n                    } else {\n                        if (65535 >= O) {\n                            if (f + 2 >= b) break;\n                            c[f++ >>> 0] = 224 | O >> 12;\n                        } else {\n                            if (f + 3 >= b) break;\n                            c[f++ >>> 0] = 240 | O >> 18, c[f++ >>> 0] = 128 | O >> 12 & 63;\n                        }\n                        c[f++ >>> 0] = 128 | O >> 6 & 63;\n                    }\n                    c[f++ >>> 0] = 128 | 63 & O;\n                }\n            }\n            return c[f >>> 0] = 0, f - w;\n        }, Ot = (s, c, f)=>Jo(s, r(), c, f);\n        function ei(s, c) {\n            if (g) return xe(5, 1, s, c);\n        }\n        function ti(s, c, f) {\n            if (g) return xe(6, 1, s, c, f);\n        }\n        function ri(s, c, f) {\n            return g ? xe(7, 1, s, c, f) : 0;\n        }\n        function ni(s, c) {\n            if (g) return xe(8, 1, s, c);\n        }\n        function oi(s, c, f) {\n            if (g) return xe(9, 1, s, c, f);\n        }\n        function ii(s, c, f, b) {\n            if (g) return xe(10, 1, s, c, f, b);\n        }\n        function ai(s, c, f, b) {\n            if (g) return xe(11, 1, s, c, f, b);\n        }\n        function si(s, c, f, b) {\n            if (g) return xe(12, 1, s, c, f, b);\n        }\n        function ui(s) {\n            if (g) return xe(13, 1, s);\n        }\n        function di(s, c) {\n            if (g) return xe(14, 1, s, c);\n        }\n        function li(s, c, f) {\n            if (g) return xe(15, 1, s, c, f);\n        }\n        var ci, mt, Cc = ()=>{\n            ct(\"\");\n        }, Qe = (s)=>{\n            for(var c = \"\"; r()[s >>> 0];)c += ci[r()[s++ >>> 0]];\n            return c;\n        }, xn = {}, Sn = {}, Ac = {};\n        function st(s, c) {\n            let f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n            if (!(\"argPackAdvance\" in c)) throw new TypeError(\"registerType registeredInstance requires argPackAdvance\");\n            return function(b, w) {\n                let I = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n                var O = w.name;\n                if (!b) throw new mt('type \"'.concat(O, '\" must have a positive integer typeid pointer'));\n                if (Sn.hasOwnProperty(b)) {\n                    if (I.Tb) return;\n                    throw new mt(\"Cannot register type '\".concat(O, \"' twice\"));\n                }\n                Sn[b] = w, delete Ac[b], xn.hasOwnProperty(b) && (w = xn[b], delete xn[b], w.forEach((B)=>B()));\n            }(s, c, f);\n        }\n        var pi = (s, c, f)=>{\n            switch(c){\n                case 1:\n                    return f ? (b)=>t()[b >>> 0] : (b)=>r()[b >>> 0];\n                case 2:\n                    return f ? (b)=>n()[b >>> 1 >>> 0] : (b)=>o()[b >>> 1 >>> 0];\n                case 4:\n                    return f ? (b)=>i()[b >>> 2 >>> 0] : (b)=>a()[b >>> 2 >>> 0];\n                case 8:\n                    return f ? (b)=>q[b >>> 3] : (b)=>he[b >>> 3];\n                default:\n                    throw new TypeError(\"invalid integer width (\".concat(c, \"): \").concat(s));\n            }\n        };\n        function kc(s, c, f) {\n            f >>>= 0, st(s >>>= 0, {\n                name: c = Qe(c >>> 0),\n                fromWireType: (b)=>b,\n                toWireType: function(b, w) {\n                    if (typeof w != \"bigint\" && typeof w != \"number\") throw w = w === null ? \"null\" : (b = typeof w) == \"object\" || b === \"array\" || b === \"function\" ? w.toString() : \"\" + w, new TypeError('Cannot convert \"'.concat(w, '\" to ').concat(this.name));\n                    return typeof w == \"number\" && (w = BigInt(w)), w;\n                },\n                argPackAdvance: ft,\n                readValueFromPointer: pi(c, f, c.indexOf(\"u\") == -1),\n                Eb: null\n            });\n        }\n        var ft = 8;\n        function Ec(s, c, f, b) {\n            st(s >>>= 0, {\n                name: c = Qe(c >>> 0),\n                fromWireType: function(w) {\n                    return !!w;\n                },\n                toWireType: function(w, I) {\n                    return I ? f : b;\n                },\n                argPackAdvance: ft,\n                readValueFromPointer: function(w) {\n                    return this.fromWireType(r()[w >>> 0]);\n                },\n                Eb: null\n            });\n        }\n        var Tn = [], ut = [];\n        function In(s) {\n            9 < (s >>>= 0) && --ut[s + 1] == 0 && (ut[s] = void 0, Tn.push(s));\n        }\n        var Me = (s)=>{\n            if (!s) throw new mt(\"Cannot use deleted val. handle = \" + s);\n            return ut[s];\n        }, Ve = (s)=>{\n            switch(s){\n                case void 0:\n                    return 2;\n                case null:\n                    return 4;\n                case !0:\n                    return 6;\n                case !1:\n                    return 8;\n                default:\n                    let c = Tn.pop() || ut.length;\n                    return ut[c] = s, ut[c + 1] = 1, c;\n            }\n        };\n        function Cn(s) {\n            return this.fromWireType(a()[s >>> 2 >>> 0]);\n        }\n        var Pc = {\n            name: \"emscripten::val\",\n            fromWireType: (s)=>{\n                var c = Me(s);\n                return In(s), c;\n            },\n            toWireType: (s, c)=>Ve(c),\n            argPackAdvance: ft,\n            readValueFromPointer: Cn,\n            Eb: null\n        };\n        function zc(s) {\n            return st(s >>> 0, Pc);\n        }\n        var Oc = (s, c)=>{\n            switch(c){\n                case 4:\n                    return function(f) {\n                        return this.fromWireType(d()[f >>> 2 >>> 0]);\n                    };\n                case 8:\n                    return function(f) {\n                        return this.fromWireType(l()[f >>> 3 >>> 0]);\n                    };\n                default:\n                    throw new TypeError(\"invalid float width (\".concat(c, \"): \").concat(s));\n            }\n        };\n        function Dc(s, c, f) {\n            f >>>= 0, st(s >>>= 0, {\n                name: c = Qe(c >>> 0),\n                fromWireType: (b)=>b,\n                toWireType: (b, w)=>w,\n                argPackAdvance: ft,\n                readValueFromPointer: Oc(c, f),\n                Eb: null\n            });\n        }\n        function Bc(s, c, f, b, w) {\n            if (s >>>= 0, f >>>= 0, c = Qe(c >>> 0), w === -1 && (w = 4294967295), w = (B)=>B, b === 0) {\n                var I = 32 - 8 * f;\n                w = (B)=>B << I >>> I;\n            }\n            var O = c.includes(\"unsigned\") ? function(B, L) {\n                return L >>> 0;\n            } : function(B, L) {\n                return L;\n            };\n            st(s, {\n                name: c,\n                fromWireType: w,\n                toWireType: O,\n                argPackAdvance: ft,\n                readValueFromPointer: pi(c, f, b !== 0),\n                Eb: null\n            });\n        }\n        function Mc(s, c, f) {\n            function b(I) {\n                var O = a()[I >>> 2 >>> 0];\n                return I = a()[I + 4 >>> 2 >>> 0], new w(t().buffer, I, O);\n            }\n            var w = [\n                Int8Array,\n                Uint8Array,\n                Int16Array,\n                Uint16Array,\n                Int32Array,\n                Uint32Array,\n                Float32Array,\n                Float64Array,\n                BigInt64Array,\n                BigUint64Array\n            ][c];\n            st(s >>>= 0, {\n                name: f = Qe(f >>> 0),\n                fromWireType: b,\n                argPackAdvance: ft,\n                readValueFromPointer: b\n            }, {\n                Tb: !0\n            });\n        }\n        function Rc(s, c) {\n            s >>>= 0;\n            var f = (c = Qe(c >>> 0)) === \"std::string\";\n            st(s, {\n                name: c,\n                fromWireType: function(b) {\n                    var w = a()[b >>> 2 >>> 0], I = b + 4;\n                    if (f) for(var O = I, B = 0; B <= w; ++B){\n                        var L = I + B;\n                        if (B == w || r()[L >>> 0] == 0) {\n                            if (O = Ce(O, L - O), H === void 0) var H = O;\n                            else H += String.fromCharCode(0), H += O;\n                            O = L + 1;\n                        }\n                    }\n                    else {\n                        for(H = Array(w), B = 0; B < w; ++B)H[B] = String.fromCharCode(r()[I + B >>> 0]);\n                        H = H.join(\"\");\n                    }\n                    return Je(b), H;\n                },\n                toWireType: function(b, w) {\n                    w instanceof ArrayBuffer && (w = new Uint8Array(w));\n                    var I = typeof w == \"string\";\n                    if (!(I || w instanceof Uint8Array || w instanceof Uint8ClampedArray || w instanceof Int8Array)) throw new mt(\"Cannot pass non-string to std::string\");\n                    var O = f && I ? $n(w) : w.length, B = fr(4 + O + 1), L = B + 4;\n                    if (a()[B >>> 2 >>> 0] = O, f && I) Ot(w, L, O + 1);\n                    else if (I) for(I = 0; I < O; ++I){\n                        var H = w.charCodeAt(I);\n                        if (255 < H) throw Je(L), new mt(\"String has UTF-16 code units that do not fit in 8 bits\");\n                        r()[L + I >>> 0] = H;\n                    }\n                    else for(I = 0; I < O; ++I)r()[L + I >>> 0] = w[I];\n                    return b !== null && b.push(Je, B), B;\n                },\n                argPackAdvance: ft,\n                readValueFromPointer: Cn,\n                Eb (b) {\n                    Je(b);\n                }\n            });\n        }\n        var mi = typeof TextDecoder < \"u\" ? new TextDecoder(\"utf-16le\") : void 0, Uc = (s, c)=>{\n            for(var f = s >> 1, b = f + c / 2; !(f >= b) && o()[f >>> 0];)++f;\n            if (32 < (f <<= 1) - s && mi) return mi.decode(r().slice(s, f));\n            for(f = \"\", b = 0; !(b >= c / 2); ++b){\n                var w = n()[s + 2 * b >>> 1 >>> 0];\n                if (w == 0) break;\n                f += String.fromCharCode(w);\n            }\n            return f;\n        }, Nc = (s, c, f)=>{\n            if (f !== null && f !== void 0 ? f : f = 2147483647, 2 > f) return 0;\n            var b = c;\n            f = (f -= 2) < 2 * s.length ? f / 2 : s.length;\n            for(var w = 0; w < f; ++w){\n                var I = s.charCodeAt(w);\n                n()[c >>> 1 >>> 0] = I, c += 2;\n            }\n            return n()[c >>> 1 >>> 0] = 0, c - b;\n        }, Vc = (s)=>2 * s.length, Wc = (s, c)=>{\n            for(var f = 0, b = \"\"; !(f >= c / 4);){\n                var w = i()[s + 4 * f >>> 2 >>> 0];\n                if (w == 0) break;\n                ++f, 65536 <= w ? (w -= 65536, b += String.fromCharCode(55296 | w >> 10, 56320 | 1023 & w)) : b += String.fromCharCode(w);\n            }\n            return b;\n        }, Lc = (s, c, f)=>{\n            if (c >>>= 0, f !== null && f !== void 0 ? f : f = 2147483647, 4 > f) return 0;\n            var b = c;\n            f = b + f - 4;\n            for(var w = 0; w < s.length; ++w){\n                var I = s.charCodeAt(w);\n                if (55296 <= I && 57343 >= I && (I = 65536 + ((1023 & I) << 10) | 1023 & s.charCodeAt(++w)), i()[c >>> 2 >>> 0] = I, (c += 4) + 4 > f) break;\n            }\n            return i()[c >>> 2 >>> 0] = 0, c - b;\n        }, Gc = (s)=>{\n            for(var c = 0, f = 0; f < s.length; ++f){\n                var b = s.charCodeAt(f);\n                55296 <= b && 57343 >= b && ++f, c += 4;\n            }\n            return c;\n        };\n        function Hc(s, c, f) {\n            if (s >>>= 0, c >>>= 0, f = Qe(f >>>= 0), c === 2) var b = Uc, w = Nc, I = Vc, O = (B)=>o()[B >>> 1 >>> 0];\n            else c === 4 && (b = Wc, w = Lc, I = Gc, O = (B)=>a()[B >>> 2 >>> 0]);\n            st(s, {\n                name: f,\n                fromWireType: (B)=>{\n                    for(var L, H = a()[B >>> 2 >>> 0], X = B + 4, ce = 0; ce <= H; ++ce){\n                        var ge = B + 4 + ce * c;\n                        ce != H && O(ge) != 0 || (X = b(X, ge - X), L === void 0 ? L = X : (L += String.fromCharCode(0), L += X), X = ge + c);\n                    }\n                    return Je(B), L;\n                },\n                toWireType: (B, L)=>{\n                    if (typeof L != \"string\") throw new mt(\"Cannot pass non-string to C++ string type \".concat(f));\n                    var H = I(L), X = fr(4 + H + c);\n                    return a()[X >>> 2 >>> 0] = H / c, w(L, X + 4, H + c), B !== null && B.push(Je, X), X;\n                },\n                argPackAdvance: ft,\n                readValueFromPointer: Cn,\n                Eb (B) {\n                    Je(B);\n                }\n            });\n        }\n        function Fc(s, c) {\n            st(s >>>= 0, {\n                Ub: !0,\n                name: c = Qe(c >>> 0),\n                argPackAdvance: 0,\n                fromWireType: ()=>{},\n                toWireType: ()=>{}\n            });\n        }\n        var qc = ()=>1;\n        function Kc(s) {\n            Dn(s >>> 0, !y, 1, !_, 131072, !1), Ho();\n        }\n        var fi = (s)=>{\n            if (!we) try {\n                if (s(), !(0 < wt)) try {\n                    g ? hr(ee) : vn(ee);\n                } catch (c) {\n                    c instanceof yn || c == \"unwind\" || k(1, c);\n                }\n            } catch (c) {\n                c instanceof yn || c == \"unwind\" || k(1, c);\n            }\n        };\n        function An(s) {\n            s >>>= 0, typeof Atomics.oc == \"function\" && (Atomics.oc(i(), s >>> 2, s).value.then(ir), s += 128, Atomics.store(i(), s >>> 2, 1));\n        }\n        var ir = ()=>{\n            var s = Mt();\n            s && (An(s), fi(Hi));\n        };\n        function jc(s, c) {\n            (s >>>= 0) == c >>> 0 ? setTimeout(ir) : g ? postMessage({\n                targetThread: s,\n                cmd: \"checkMailbox\"\n            }) : (s = Ze[s]) && s.postMessage({\n                cmd: \"checkMailbox\"\n            });\n        }\n        var kn = [];\n        function Yc(s, c, f, b, w) {\n            for(c >>>= 0, b /= 2, kn.length = b, f = w >>> 0 >>> 3, w = 0; w < b; w++)kn[w] = q[f + 2 * w] ? q[f + 2 * w + 1] : l()[f + 2 * w + 1 >>> 0];\n            return (c ? bn[c] : Np[s])(...kn);\n        }\n        function Zc(s) {\n            s >>>= 0, g ? postMessage({\n                cmd: \"cleanupThread\",\n                thread: s\n            }) : Go(Ze[s]);\n        }\n        function Qc(s) {}\n        var ar = (s, c)=>{\n            var f = Sn[s];\n            if (f === void 0) throw s = Vi(s), f = Qe(s), Je(s), new mt(\"\".concat(c, \" has unknown type \").concat(f));\n            return f;\n        }, hi = (s, c, f)=>{\n            var b = [];\n            return s = s.toWireType(b, f), b.length && (a()[c >>> 2 >>> 0] = Ve(b)), s;\n        };\n        function Xc(s, c, f) {\n            return c >>>= 0, f >>>= 0, s = Me(s >>> 0), c = ar(c, \"emval::as\"), hi(c, f, s);\n        }\n        function Jc(s, c) {\n            return c >>>= 0, s = Me(s >>> 0), (c = ar(c, \"emval::as\")).toWireType(null, s);\n        }\n        var sr = (s)=>{\n            try {\n                s();\n            } catch (c) {\n                ct(c);\n            }\n        }, ht = 0, Xe = null, gi = 0, ur = [], bi = {}, yi = {}, ep = 0, En = null, tp = [];\n        function _i(s) {\n            return function(c) {\n                if (!we) {\n                    if (ht === 0) {\n                        var f = !1, b = !1;\n                        c(function() {\n                            let w = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;\n                            if (!we && (gi = w, f = !0, b)) {\n                                ht = 2, sr(()=>Yi(Xe)), typeof Browser < \"u\" && Browser.Lb.Sb && Browser.Lb.resume(), w = !1;\n                                try {\n                                    var I = function() {\n                                        var L = i()[Xe + 8 >>> 2 >>> 0];\n                                        return L = Z[yi[L]], --wt, L();\n                                    }();\n                                } catch (L) {\n                                    I = L, w = !0;\n                                }\n                                var O = !1;\n                                if (!Xe) {\n                                    var B = En;\n                                    B && (En = null, (w ? B.reject : B.resolve)(I), O = !0);\n                                }\n                                if (w && !O) throw I;\n                            }\n                        }), b = !0, f || (ht = 1, Xe = function() {\n                            var w = fr(65548), I = w + 12;\n                            a()[w >>> 2 >>> 0] = I, a()[w + 4 >>> 2 >>> 0] = I + 65536, I = ur[0];\n                            var O = bi[I];\n                            return O === void 0 && (O = ep++, bi[I] = O, yi[O] = I), I = O, i()[w + 8 >>> 2 >>> 0] = I, w;\n                        }(), typeof Browser < \"u\" && Browser.Lb.Sb && Browser.Lb.pause(), sr(()=>Ki(Xe)));\n                    } else ht === 2 ? (ht = 0, sr(Zi), Je(Xe), Xe = null, tp.forEach(fi)) : ct(\"invalid state: \".concat(ht));\n                    return gi;\n                }\n            }((c)=>{\n                s().then(c);\n            });\n        }\n        function rp(s) {\n            return s >>>= 0, _i(()=>(s = Me(s)).then(Ve));\n        }\n        var dr = [];\n        function np(s, c, f, b) {\n            return f >>>= 0, b >>>= 0, (s = dr[s >>> 0])(null, c = Me(c >>> 0), f, b);\n        }\n        var op = {}, lr = (s)=>{\n            var c = op[s];\n            return c === void 0 ? Qe(s) : c;\n        };\n        function ip(s, c, f, b, w) {\n            return f >>>= 0, b >>>= 0, w >>>= 0, (s = dr[s >>> 0])(c = Me(c >>> 0), c[f = lr(f)], b, w);\n        }\n        var wi = ()=>typeof globalThis == \"object\" ? globalThis : Function(\"return this\")();\n        function ap(s) {\n            return (s >>>= 0) == 0 ? Ve(wi()) : (s = lr(s), Ve(wi()[s]));\n        }\n        var sp = (s)=>{\n            var c = dr.length;\n            return dr.push(s), c;\n        }, up = (s, c)=>{\n            for(var f = Array(s), b = 0; b < s; ++b)f[b] = ar(a()[c + 4 * b >>> 2 >>> 0], \"parameter \" + b);\n            return f;\n        }, vi = (s, c)=>Object.defineProperty(c, \"name\", {\n                value: s\n            });\n        function dp(s, c, f) {\n            var b = (c = up(s, c >>> 0)).shift();\n            s--;\n            var w = \"return function (obj, func, destructorsRef, args) {\\n\", I = 0, O = [];\n            f === 0 && O.push(\"obj\");\n            for(var B = [\n                \"retType\"\n            ], L = [\n                b\n            ], H = 0; H < s; ++H)O.push(\"arg\" + H), B.push(\"argType\" + H), L.push(c[H]), w += \"  var arg\".concat(H, \" = argType\").concat(H, \".readValueFromPointer(args\").concat(I ? \"+\" + I : \"\", \");\\n\"), I += c[H].argPackAdvance;\n            return w += \"  var rv = \".concat(f === 1 ? \"new func\" : \"func.call\", \"(\").concat(O.join(\", \"), \");\\n\"), b.Ub || (B.push(\"emval_returnValue\"), L.push(hi), w += \"  return emval_returnValue(retType, destructorsRef, rv);\\n\"), B.push(w + \"};\\n\"), s = (function(X) {\n                var ce = Function;\n                if (!(ce instanceof Function)) throw new TypeError(\"new_ called with constructor type \".concat(typeof ce, \" which is not a function\"));\n                var ge = vi(ce.name || \"unknownFunctionName\", function() {});\n                return ge.prototype = ce.prototype, ge = new ge, (X = ce.apply(ge, X)) instanceof Object ? X : ge;\n            })(B)(...L), f = \"methodCaller<(\".concat(c.map((X)=>X.name).join(\", \"), \") => \").concat(b.name, \">\"), sp(vi(f, s));\n        }\n        function lp(s) {\n            return s = lr(s >>> 0), Ve(u[s]);\n        }\n        function cp(s, c) {\n            return c >>>= 0, s = Me(s >>> 0), c = Me(c), Ve(s[c]);\n        }\n        function pp(s) {\n            9 < (s >>>= 0) && (ut[s + 1] += 1);\n        }\n        function mp() {\n            return Ve([]);\n        }\n        function fp(s) {\n            s = Me(s >>> 0);\n            for(var c = Array(s.length), f = 0; f < s.length; f++)c[f] = s[f];\n            return Ve(c);\n        }\n        function hp(s) {\n            return Ve(lr(s >>> 0));\n        }\n        function gp() {\n            return Ve({});\n        }\n        function bp(s) {\n            for(var c = Me(s >>>= 0); c.length;){\n                var f = c.pop();\n                c.pop()(f);\n            }\n            In(s);\n        }\n        function yp(s, c, f) {\n            c >>>= 0, f >>>= 0, s = Me(s >>> 0), c = Me(c), f = Me(f), s[c] = f;\n        }\n        function _p(s, c) {\n            return c >>>= 0, s = (s = ar(s >>> 0, \"_emval_take_value\")).readValueFromPointer(c), Ve(s);\n        }\n        function wp(s, c) {\n            s = -9007199254740992 > s || 9007199254740992 < s ? NaN : Number(s), c >>>= 0, s = new Date(1e3 * s), i()[c >>> 2 >>> 0] = s.getUTCSeconds(), i()[c + 4 >>> 2 >>> 0] = s.getUTCMinutes(), i()[c + 8 >>> 2 >>> 0] = s.getUTCHours(), i()[c + 12 >>> 2 >>> 0] = s.getUTCDate(), i()[c + 16 >>> 2 >>> 0] = s.getUTCMonth(), i()[c + 20 >>> 2 >>> 0] = s.getUTCFullYear() - 1900, i()[c + 24 >>> 2 >>> 0] = s.getUTCDay(), s = (s.getTime() - Date.UTC(s.getUTCFullYear(), 0, 1, 0, 0, 0, 0)) / 864e5 | 0, i()[c + 28 >>> 2 >>> 0] = s;\n        }\n        var Dt = (s)=>s % 4 == 0 && (s % 100 != 0 || s % 400 == 0), $i = [\n            0,\n            31,\n            60,\n            91,\n            121,\n            152,\n            182,\n            213,\n            244,\n            274,\n            305,\n            335\n        ], xi = [\n            0,\n            31,\n            59,\n            90,\n            120,\n            151,\n            181,\n            212,\n            243,\n            273,\n            304,\n            334\n        ];\n        function vp(s, c) {\n            s = -9007199254740992 > s || 9007199254740992 < s ? NaN : Number(s), c >>>= 0, s = new Date(1e3 * s), i()[c >>> 2 >>> 0] = s.getSeconds(), i()[c + 4 >>> 2 >>> 0] = s.getMinutes(), i()[c + 8 >>> 2 >>> 0] = s.getHours(), i()[c + 12 >>> 2 >>> 0] = s.getDate(), i()[c + 16 >>> 2 >>> 0] = s.getMonth(), i()[c + 20 >>> 2 >>> 0] = s.getFullYear() - 1900, i()[c + 24 >>> 2 >>> 0] = s.getDay();\n            var f = (Dt(s.getFullYear()) ? $i : xi)[s.getMonth()] + s.getDate() - 1 | 0;\n            i()[c + 28 >>> 2 >>> 0] = f, i()[c + 36 >>> 2 >>> 0] = -60 * s.getTimezoneOffset(), f = new Date(s.getFullYear(), 6, 1).getTimezoneOffset();\n            var b = new Date(s.getFullYear(), 0, 1).getTimezoneOffset();\n            s = 0 | (f != b && s.getTimezoneOffset() == Math.min(b, f)), i()[c + 32 >>> 2 >>> 0] = s;\n        }\n        function $p(s) {\n            s >>>= 0;\n            var c = new Date(i()[s + 20 >>> 2 >>> 0] + 1900, i()[s + 16 >>> 2 >>> 0], i()[s + 12 >>> 2 >>> 0], i()[s + 8 >>> 2 >>> 0], i()[s + 4 >>> 2 >>> 0], i()[s >>> 2 >>> 0], 0), f = i()[s + 32 >>> 2 >>> 0], b = c.getTimezoneOffset(), w = new Date(c.getFullYear(), 6, 1).getTimezoneOffset(), I = new Date(c.getFullYear(), 0, 1).getTimezoneOffset(), O = Math.min(I, w);\n            return 0 > f ? i()[s + 32 >>> 2 >>> 0] = +(w != I && O == b) : 0 < f != (O == b) && (w = Math.max(I, w), c.setTime(c.getTime() + 6e4 * ((0 < f ? O : w) - b))), i()[s + 24 >>> 2 >>> 0] = c.getDay(), f = (Dt(c.getFullYear()) ? $i : xi)[c.getMonth()] + c.getDate() - 1 | 0, i()[s + 28 >>> 2 >>> 0] = f, i()[s >>> 2 >>> 0] = c.getSeconds(), i()[s + 4 >>> 2 >>> 0] = c.getMinutes(), i()[s + 8 >>> 2 >>> 0] = c.getHours(), i()[s + 12 >>> 2 >>> 0] = c.getDate(), i()[s + 16 >>> 2 >>> 0] = c.getMonth(), i()[s + 20 >>> 2 >>> 0] = c.getYear(), s = c.getTime(), BigInt(isNaN(s) ? -1 : s / 1e3);\n        }\n        function Si(s, c, f, b, w, I, O) {\n            return g ? xe(16, 1, s, c, f, b, w, I, O) : -52;\n        }\n        function Ti(s, c, f, b, w, I) {\n            if (g) return xe(17, 1, s, c, f, b, w, I);\n        }\n        function xp(s, c, f, b) {\n            s >>>= 0, c >>>= 0, f >>>= 0, b >>>= 0;\n            var w = new Date().getFullYear(), I = new Date(w, 0, 1), O = new Date(w, 6, 1);\n            w = I.getTimezoneOffset();\n            var B = O.getTimezoneOffset(), L = Math.max(w, B);\n            a()[s >>> 2 >>> 0] = 60 * L, i()[c >>> 2 >>> 0] = +(w != B), I = (s = (H)=>H.toLocaleTimeString(void 0, {\n                    hour12: !1,\n                    timeZoneName: \"short\"\n                }).split(\" \")[1])(I), O = s(O), B < w ? (Ot(I, f, 17), Ot(O, b, 17)) : (Ot(I, b, 17), Ot(O, f, 17));\n        }\n        var Pn = [], Ii = (s, c)=>{\n            Pn.length = 0;\n            for(var f; f = r()[s++ >>> 0];){\n                var b = f != 105;\n                c += (b &= f != 112) && c % 8 ? 4 : 0, Pn.push(f == 112 ? a()[c >>> 2 >>> 0] : f == 106 ? q[c >>> 3] : f == 105 ? i()[c >>> 2 >>> 0] : l()[c >>> 3 >>> 0]), c += b ? 8 : 4;\n            }\n            return Pn;\n        };\n        function Sp(s, c, f) {\n            return s >>>= 0, c = Ii(c >>> 0, f >>> 0), bn[s](...c);\n        }\n        function Tp(s, c, f) {\n            return s >>>= 0, c = Ii(c >>> 0, f >>> 0), bn[s](...c);\n        }\n        var Ip = ()=>{}, Cp = ()=>Date.now();\n        function Ap(s, c) {\n            return j(Ce(s >>> 0, c >>> 0));\n        }\n        var Ci, kp = ()=>{\n            throw wt += 1, \"unwind\";\n        };\n        function Ep() {\n            return 4294901760;\n        }\n        Ci = ()=>performance.timeOrigin + performance.now();\n        var Pp = ()=>navigator.hardwareConcurrency;\n        function zp() {\n            return ct(\"Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER\"), 0;\n        }\n        function Op(s) {\n            s >>>= 0;\n            var c = r().length;\n            if (s <= c || 4294901760 < s) return !1;\n            for(var f = 1; 4 >= f; f *= 2){\n                var b = c * (1 + .2 / f);\n                b = Math.min(b, s + 100663296);\n                var w = Math;\n                b = Math.max(s, b);\n                e: {\n                    w = (w.min.call(w, 4294901760, b + (65536 - b % 65536) % 65536) - se.buffer.byteLength + 65535) / 65536;\n                    try {\n                        se.grow(w), ye();\n                        var I = 1;\n                        break e;\n                    } catch (e1) {}\n                    I = void 0;\n                }\n                if (I) return !0;\n            }\n            return !1;\n        }\n        var cr = ()=>(ct(\"Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER\"), 0), Bt = {}, Ai = (s)=>{\n            s.forEach((c)=>{\n                var f = cr();\n                f && (Bt[f] = c);\n            });\n        };\n        function Dp() {\n            var s = Error().stack.toString().split(\"\\n\");\n            return s[0] == \"Error\" && s.shift(), Ai(s), Bt.Qb = cr(), Bt.fc = s, Bt.Qb;\n        }\n        function Bp(s, c, f) {\n            if (s >>>= 0, c >>>= 0, Bt.Qb == s) var b = Bt.fc;\n            else (b = Error().stack.toString().split(\"\\n\"))[0] == \"Error\" && b.shift(), Ai(b);\n            for(var w = 3; b[w] && cr() != s;)++w;\n            for(s = 0; s < f && b[s + w]; ++s)i()[c + 4 * s >>> 2 >>> 0] = cr();\n            return s;\n        }\n        var zn, On = {}, ki = ()=>{\n            if (!zn) {\n                var s, c = {\n                    USER: \"web_user\",\n                    LOGNAME: \"web_user\",\n                    PATH: \"/\",\n                    PWD: \"/\",\n                    HOME: \"/home/web_user\",\n                    LANG: (typeof navigator == \"object\" && navigator.languages && navigator.languages[0] || \"C\").replace(\"-\", \"_\") + \".UTF-8\",\n                    _: A || \"./this.program\"\n                };\n                for(s in On)On[s] === void 0 ? delete c[s] : c[s] = On[s];\n                var f = [];\n                for(s in c)f.push(\"\".concat(s, \"=\").concat(c[s]));\n                zn = f;\n            }\n            return zn;\n        };\n        function Ei(s, c) {\n            if (g) return xe(18, 1, s, c);\n            s >>>= 0, c >>>= 0;\n            var f = 0;\n            return ki().forEach((b, w)=>{\n                var I = c + f;\n                for(w = a()[s + 4 * w >>> 2 >>> 0] = I, I = 0; I < b.length; ++I)t()[w++ >>> 0] = b.charCodeAt(I);\n                t()[w >>> 0] = 0, f += b.length + 1;\n            }), 0;\n        }\n        function Pi(s, c) {\n            if (g) return xe(19, 1, s, c);\n            s >>>= 0, c >>>= 0;\n            var f = ki();\n            a()[s >>> 2 >>> 0] = f.length;\n            var b = 0;\n            return f.forEach((w)=>b += w.length + 1), a()[c >>> 2 >>> 0] = b, 0;\n        }\n        function zi(s) {\n            return g ? xe(20, 1, s) : 52;\n        }\n        function Oi(s, c, f, b) {\n            return g ? xe(21, 1, s, c, f, b) : 52;\n        }\n        function Di(s, c, f, b) {\n            return g ? xe(22, 1, s, c, f, b) : 70;\n        }\n        var Mp = [\n            null,\n            [],\n            []\n        ];\n        function Bi(s, c, f, b) {\n            if (g) return xe(23, 1, s, c, f, b);\n            c >>>= 0, f >>>= 0, b >>>= 0;\n            for(var w = 0, I = 0; I < f; I++){\n                var O = a()[c >>> 2 >>> 0], B = a()[c + 4 >>> 2 >>> 0];\n                c += 8;\n                for(var L = 0; L < B; L++){\n                    var H = r()[O + L >>> 0], X = Mp[s];\n                    H === 0 || H === 10 ? ((s === 1 ? K : j)(Zo(X, 0)), X.length = 0) : X.push(H);\n                }\n                w += B;\n            }\n            return a()[b >>> 2 >>> 0] = w, 0;\n        }\n        var Mi = [\n            31,\n            29,\n            31,\n            30,\n            31,\n            30,\n            31,\n            31,\n            30,\n            31,\n            30,\n            31\n        ], Ri = [\n            31,\n            28,\n            31,\n            30,\n            31,\n            30,\n            31,\n            31,\n            30,\n            31,\n            30,\n            31\n        ], Rp = (s, c)=>{\n            t().set(s, c >>> 0);\n        };\n        function Ui(s, c, f, b) {\n            function w(z, de, Te) {\n                for(z = typeof z == \"number\" ? z.toString() : z || \"\"; z.length < de;)z = Te[0] + z;\n                return z;\n            }\n            function I(z, de) {\n                return w(z, de, \"0\");\n            }\n            function O(z, de) {\n                function Te(Xi) {\n                    return 0 > Xi ? -1 : 0 < Xi ? 1 : 0;\n                }\n                var $t;\n                return ($t = Te(z.getFullYear() - de.getFullYear())) === 0 && ($t = Te(z.getMonth() - de.getMonth())) === 0 && ($t = Te(z.getDate() - de.getDate())), $t;\n            }\n            function B(z) {\n                switch(z.getDay()){\n                    case 0:\n                        return new Date(z.getFullYear() - 1, 11, 29);\n                    case 1:\n                        return z;\n                    case 2:\n                        return new Date(z.getFullYear(), 0, 3);\n                    case 3:\n                        return new Date(z.getFullYear(), 0, 2);\n                    case 4:\n                        return new Date(z.getFullYear(), 0, 1);\n                    case 5:\n                        return new Date(z.getFullYear() - 1, 11, 31);\n                    case 6:\n                        return new Date(z.getFullYear() - 1, 11, 30);\n                }\n            }\n            function L(z) {\n                var de = z.Cb;\n                for(z = new Date(new Date(z.Db + 1900, 0, 1).getTime()); 0 < de;){\n                    var Te = z.getMonth(), $t = (Dt(z.getFullYear()) ? Mi : Ri)[Te];\n                    if (!(de > $t - z.getDate())) {\n                        z.setDate(z.getDate() + de);\n                        break;\n                    }\n                    de -= $t - z.getDate() + 1, z.setDate(1), 11 > Te ? z.setMonth(Te + 1) : (z.setMonth(0), z.setFullYear(z.getFullYear() + 1));\n                }\n                return Te = new Date(z.getFullYear() + 1, 0, 4), de = B(new Date(z.getFullYear(), 0, 4)), Te = B(Te), 0 >= O(de, z) ? 0 >= O(Te, z) ? z.getFullYear() + 1 : z.getFullYear() : z.getFullYear() - 1;\n            }\n            s >>>= 0, c >>>= 0, f >>>= 0, b >>>= 0;\n            var H = a()[b + 40 >>> 2 >>> 0];\n            for(var X in b = {\n                lc: i()[b >>> 2 >>> 0],\n                kc: i()[b + 4 >>> 2 >>> 0],\n                Ib: i()[b + 8 >>> 2 >>> 0],\n                Mb: i()[b + 12 >>> 2 >>> 0],\n                Jb: i()[b + 16 >>> 2 >>> 0],\n                Db: i()[b + 20 >>> 2 >>> 0],\n                vb: i()[b + 24 >>> 2 >>> 0],\n                Cb: i()[b + 28 >>> 2 >>> 0],\n                sc: i()[b + 32 >>> 2 >>> 0],\n                jc: i()[b + 36 >>> 2 >>> 0],\n                mc: H ? Ce(H) : \"\"\n            }, f = Ce(f), H = {\n                \"%c\": \"%a %b %d %H:%M:%S %Y\",\n                \"%D\": \"%m/%d/%y\",\n                \"%F\": \"%Y-%m-%d\",\n                \"%h\": \"%b\",\n                \"%r\": \"%I:%M:%S %p\",\n                \"%R\": \"%H:%M\",\n                \"%T\": \"%H:%M:%S\",\n                \"%x\": \"%m/%d/%y\",\n                \"%X\": \"%H:%M:%S\",\n                \"%Ec\": \"%c\",\n                \"%EC\": \"%C\",\n                \"%Ex\": \"%m/%d/%y\",\n                \"%EX\": \"%H:%M:%S\",\n                \"%Ey\": \"%y\",\n                \"%EY\": \"%Y\",\n                \"%Od\": \"%d\",\n                \"%Oe\": \"%e\",\n                \"%OH\": \"%H\",\n                \"%OI\": \"%I\",\n                \"%Om\": \"%m\",\n                \"%OM\": \"%M\",\n                \"%OS\": \"%S\",\n                \"%Ou\": \"%u\",\n                \"%OU\": \"%U\",\n                \"%OV\": \"%V\",\n                \"%Ow\": \"%w\",\n                \"%OW\": \"%W\",\n                \"%Oy\": \"%y\"\n            })f = f.replace(new RegExp(X, \"g\"), H[X]);\n            var ce = \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\".split(\" \"), ge = \"January February March April May June July August September October November December\".split(\" \");\n            for(X in H = {\n                \"%a\": (z)=>ce[z.vb].substring(0, 3),\n                \"%A\": (z)=>ce[z.vb],\n                \"%b\": (z)=>ge[z.Jb].substring(0, 3),\n                \"%B\": (z)=>ge[z.Jb],\n                \"%C\": (z)=>I((z.Db + 1900) / 100 | 0, 2),\n                \"%d\": (z)=>I(z.Mb, 2),\n                \"%e\": (z)=>w(z.Mb, 2, \" \"),\n                \"%g\": (z)=>L(z).toString().substring(2),\n                \"%G\": L,\n                \"%H\": (z)=>I(z.Ib, 2),\n                \"%I\": (z)=>((z = z.Ib) == 0 ? z = 12 : 12 < z && (z -= 12), I(z, 2)),\n                \"%j\": (z)=>{\n                    for(var de = 0, Te = 0; Te <= z.Jb - 1; de += (Dt(z.Db + 1900) ? Mi : Ri)[Te++]);\n                    return I(z.Mb + de, 3);\n                },\n                \"%m\": (z)=>I(z.Jb + 1, 2),\n                \"%M\": (z)=>I(z.kc, 2),\n                \"%n\": ()=>\"\\n\",\n                \"%p\": (z)=>0 <= z.Ib && 12 > z.Ib ? \"AM\" : \"PM\",\n                \"%S\": (z)=>I(z.lc, 2),\n                \"%t\": ()=>\"\t\",\n                \"%u\": (z)=>z.vb || 7,\n                \"%U\": (z)=>I(Math.floor((z.Cb + 7 - z.vb) / 7), 2),\n                \"%V\": (z)=>{\n                    var de = Math.floor((z.Cb + 7 - (z.vb + 6) % 7) / 7);\n                    if (2 >= (z.vb + 371 - z.Cb - 2) % 7 && de++, de) de == 53 && ((Te = (z.vb + 371 - z.Cb) % 7) == 4 || Te == 3 && Dt(z.Db) || (de = 1));\n                    else {\n                        de = 52;\n                        var Te = (z.vb + 7 - z.Cb - 1) % 7;\n                        (Te == 4 || Te == 5 && Dt(z.Db % 400 - 1)) && de++;\n                    }\n                    return I(de, 2);\n                },\n                \"%w\": (z)=>z.vb,\n                \"%W\": (z)=>I(Math.floor((z.Cb + 7 - (z.vb + 6) % 7) / 7), 2),\n                \"%y\": (z)=>(z.Db + 1900).toString().substring(2),\n                \"%Y\": (z)=>z.Db + 1900,\n                \"%z\": (z)=>{\n                    var de = 0 <= (z = z.jc);\n                    return z = Math.abs(z) / 60, (de ? \"+\" : \"-\") + (\"0000\" + (z / 60 * 100 + z % 60)).slice(-4);\n                },\n                \"%Z\": (z)=>z.mc,\n                \"%%\": ()=>\"%\"\n            }, f = f.replace(/%%/g, \"\\x00\\x00\"), H)f.includes(X) && (f = f.replace(new RegExp(X, \"g\"), H[X](b)));\n            return X = function(z) {\n                var de = Array($n(z) + 1);\n                return Jo(z, de, 0, de.length), de;\n            }(f = f.replace(/\\0\\0/g, \"%\")), X.length > c ? 0 : (Rp(X, s), X.length - 1);\n        }\n        function Up(s, c, f, b) {\n            return Ui(s >>> 0, c >>> 0, f >>> 0, b >>> 0);\n        }\n        g || function() {\n            for(var s = u.numThreads - 1; s--;)qo();\n            Ye.unshift(()=>{\n                Gt++, function(c) {\n                    g ? c() : Promise.all(pt.map(Fo)).then(c);\n                }(()=>Do());\n            });\n        }();\n        for(var Ni = Array(256), pr = 0; 256 > pr; ++pr)Ni[pr] = String.fromCharCode(pr);\n        ci = Ni, mt = u.BindingError = class extends Error {\n            constructor(s){\n                super(s), this.name = \"BindingError\";\n            }\n        }, u.InternalError = class extends Error {\n            constructor(s){\n                super(s), this.name = \"InternalError\";\n            }\n        }, ut.push(0, 1, void 0, 1, null, 1, !0, 1, !1, 1), u.count_emval_handles = ()=>ut.length / 2 - 5 - Tn.length;\n        var Np = [\n            wn,\n            Wo,\n            Ko,\n            Qo,\n            Xo,\n            ei,\n            ti,\n            ri,\n            ni,\n            oi,\n            ii,\n            ai,\n            si,\n            ui,\n            di,\n            li,\n            Si,\n            Ti,\n            Ei,\n            Pi,\n            zi,\n            Oi,\n            Di,\n            Bi\n        ], Z = function() {\n            function s(f, b) {\n                return Z = f.exports, Z = function() {\n                    var w = Z, I = {};\n                    for (let [O, B] of Object.entries(w))I[O] = typeof B == \"function\" ? function() {\n                        for(var _len = arguments.length, L = new Array(_len), _key = 0; _key < _len; _key++){\n                            L[_key] = arguments[_key];\n                        }\n                        ur.push(O);\n                        try {\n                            return B(...L);\n                        } finally{\n                            we || (ur.pop(), Xe && ht === 1 && ur.length === 0 && (ht = 0, wt += 1, sr(ji), typeof Fibers < \"u\" && Fibers.tc()));\n                        }\n                    } : B;\n                    return I;\n                }(), Z = function() {\n                    var w = Z, I = (B)=>(L)=>B(L) >>> 0, O = (B)=>()=>B() >>> 0;\n                    return (w = Object.assign({}, w)).Da = I(w.Da), w.gb = O(w.gb), w.ib = I(w.ib), w.emscripten_main_runtime_thread_id = O(w.emscripten_main_runtime_thread_id), w.tb = I(w.tb), w.ub = O(w.ub), w;\n                }(), Lo.push(Z.jb), Lt.unshift(Z.Ca), Y = b, Do(), Z;\n            }\n            var c = No();\n            if (Gt++, u.instantiateWasm) try {\n                return u.instantiateWasm(c, s);\n            } catch (f) {\n                j(\"Module.instantiateWasm callback failed with error: \".concat(f)), m(f);\n            }\n            return gn || (gn = u.locateFile ? Bo(\"ort-wasm-simd-threaded.jsep.wasm\") ? \"ort-wasm-simd-threaded.jsep.wasm\" : u.locateFile ? u.locateFile(\"ort-wasm-simd-threaded.jsep.wasm\", P) : P + \"ort-wasm-simd-threaded.jsep.wasm\" : /* asset import */ new __webpack_require__.U(__webpack_require__(/*! ort-wasm-simd-threaded.jsep.wasm */ \"(app-pages-browser)/./node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm\")).href), (function(f, b) {\n                var w = gn;\n                return D || typeof WebAssembly.instantiateStreaming != \"function\" || Bo(w) || Mo(w) || typeof fetch != \"function\" ? Uo(w, f, b) : fetch(w, {\n                    credentials: \"same-origin\"\n                }).then((I)=>WebAssembly.instantiateStreaming(I, f).then(b, function(O) {\n                        return j(\"wasm streaming compile failed: \".concat(O)), j(\"falling back to ArrayBuffer instantiation\"), Uo(w, f, b);\n                    }));\n            })(c, function(f) {\n                s(f.instance, f.module);\n            }).catch(m), {};\n        }(), Vi = (s)=>(Vi = Z.Da)(s), Wi = ()=>(Wi = Z.Ea)();\n        u._OrtInit = (s, c)=>(u._OrtInit = Z.Fa)(s, c), u._OrtGetLastError = (s, c)=>(u._OrtGetLastError = Z.Ga)(s, c), u._OrtCreateSessionOptions = (s, c, f, b, w, I, O, B, L, H)=>(u._OrtCreateSessionOptions = Z.Ha)(s, c, f, b, w, I, O, B, L, H), u._OrtAppendExecutionProvider = (s, c)=>(u._OrtAppendExecutionProvider = Z.Ia)(s, c), u._OrtAddFreeDimensionOverride = (s, c, f)=>(u._OrtAddFreeDimensionOverride = Z.Ja)(s, c, f), u._OrtAddSessionConfigEntry = (s, c, f)=>(u._OrtAddSessionConfigEntry = Z.Ka)(s, c, f), u._OrtReleaseSessionOptions = (s)=>(u._OrtReleaseSessionOptions = Z.La)(s), u._OrtCreateSession = (s, c, f)=>(u._OrtCreateSession = Z.Ma)(s, c, f), u._OrtReleaseSession = (s)=>(u._OrtReleaseSession = Z.Na)(s), u._OrtGetInputOutputCount = (s, c, f)=>(u._OrtGetInputOutputCount = Z.Oa)(s, c, f), u._OrtGetInputName = (s, c)=>(u._OrtGetInputName = Z.Pa)(s, c), u._OrtGetOutputName = (s, c)=>(u._OrtGetOutputName = Z.Qa)(s, c), u._OrtFree = (s)=>(u._OrtFree = Z.Ra)(s), u._OrtCreateTensor = (s, c, f, b, w, I)=>(u._OrtCreateTensor = Z.Sa)(s, c, f, b, w, I), u._OrtGetTensorData = (s, c, f, b, w)=>(u._OrtGetTensorData = Z.Ta)(s, c, f, b, w), u._OrtReleaseTensor = (s)=>(u._OrtReleaseTensor = Z.Ua)(s), u._OrtCreateRunOptions = (s, c, f, b)=>(u._OrtCreateRunOptions = Z.Va)(s, c, f, b), u._OrtAddRunConfigEntry = (s, c, f)=>(u._OrtAddRunConfigEntry = Z.Wa)(s, c, f), u._OrtReleaseRunOptions = (s)=>(u._OrtReleaseRunOptions = Z.Xa)(s), u._OrtCreateBinding = (s)=>(u._OrtCreateBinding = Z.Ya)(s), u._OrtBindInput = (s, c, f)=>(u._OrtBindInput = Z.Za)(s, c, f), u._OrtBindOutput = (s, c, f, b)=>(u._OrtBindOutput = Z._a)(s, c, f, b), u._OrtClearBoundOutputs = (s)=>(u._OrtClearBoundOutputs = Z.$a)(s), u._OrtReleaseBinding = (s)=>(u._OrtReleaseBinding = Z.ab)(s), u._OrtRunWithBinding = (s, c, f, b, w)=>(u._OrtRunWithBinding = Z.bb)(s, c, f, b, w), u._OrtRun = (s, c, f, b, w, I, O, B)=>(u._OrtRun = Z.cb)(s, c, f, b, w, I, O, B), u._OrtEndProfiling = (s)=>(u._OrtEndProfiling = Z.db)(s), u._JsepOutput = (s, c, f)=>(u._JsepOutput = Z.eb)(s, c, f), u._JsepGetNodeName = (s)=>(u._JsepGetNodeName = Z.fb)(s);\n        var mr, Mt = ()=>(Mt = Z.gb)(), Je = u._free = (s)=>(Je = u._free = Z.hb)(s), fr = u._malloc = (s)=>(fr = u._malloc = Z.ib)(s), Dn = (s, c, f, b, w, I)=>(Dn = Z.lb)(s, c, f, b, w, I), Li = ()=>(Li = Z.mb)(), Gi = (s, c, f, b, w)=>(Gi = Z.nb)(s, c, f, b, w), Bn = (s)=>(Bn = Z.ob)(s), hr = (s)=>(hr = Z.pb)(s), Hi = ()=>(Hi = Z.qb)(), Fi = (s, c)=>(Fi = Z.rb)(s, c), gr = (s)=>(gr = Z.sb)(s), Mn = (s)=>(Mn = Z.tb)(s), Rn = ()=>(Rn = Z.ub)(), qi = u.dynCall_ii = (s, c)=>(qi = u.dynCall_ii = Z.wb)(s, c), Ki = (s)=>(Ki = Z.xb)(s), ji = ()=>(ji = Z.yb)(), Yi = (s)=>(Yi = Z.zb)(s), Zi = ()=>(Zi = Z.Ab)();\n        function Qi() {\n            0 < Gt || (g ? (p(u), g || or(Lt), startWorker(u)) : (or(Ye), 0 < Gt || mr || (mr = !0, u.calledRun = !0, we || (g || or(Lt), p(u), g || or(fn)))));\n        }\n        return u.___start_em_js = 929301, u.___stop_em_js = 929547, u.stackSave = ()=>Rn(), u.stackRestore = (s)=>gr(s), u.stackAlloc = (s)=>Mn(s), u.setValue = function(s, c) {\n            let f = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"i8\";\n            switch(f.endsWith(\"*\") && (f = \"*\"), f){\n                case \"i1\":\n                case \"i8\":\n                    t()[s >>> 0] = c;\n                    break;\n                case \"i16\":\n                    n()[s >>> 1 >>> 0] = c;\n                    break;\n                case \"i32\":\n                    i()[s >>> 2 >>> 0] = c;\n                    break;\n                case \"i64\":\n                    q[s >>> 3] = BigInt(c);\n                    break;\n                case \"float\":\n                    d()[s >>> 2 >>> 0] = c;\n                    break;\n                case \"double\":\n                    l()[s >>> 3 >>> 0] = c;\n                    break;\n                case \"*\":\n                    a()[s >>> 2 >>> 0] = c;\n                    break;\n                default:\n                    ct(\"invalid type for setValue: \".concat(f));\n            }\n        }, u.getValue = function(s) {\n            let c = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"i8\";\n            switch(c.endsWith(\"*\") && (c = \"*\"), c){\n                case \"i1\":\n                case \"i8\":\n                    return t()[s >>> 0];\n                case \"i16\":\n                    return n()[s >>> 1 >>> 0];\n                case \"i32\":\n                    return i()[s >>> 2 >>> 0];\n                case \"i64\":\n                    return q[s >>> 3];\n                case \"float\":\n                    return d()[s >>> 2 >>> 0];\n                case \"double\":\n                    return l()[s >>> 3 >>> 0];\n                case \"*\":\n                    return a()[s >>> 2 >>> 0];\n                default:\n                    ct(\"invalid type for getValue: \".concat(c));\n            }\n        }, u.UTF8ToString = Ce, u.stringToUTF8 = Ot, u.lengthBytesUTF8 = $n, Ht = function s() {\n            mr || Qi(), mr || (Ht = s);\n        }, Qi(), u.PTR_SIZE = 4, h;\n    }), Kp = za;\n    ((_globalThis_self = globalThis.self) === null || _globalThis_self === void 0 ? void 0 : _globalThis_self.name) === \"em-pthread\" && za();\n});\nvar Ra, jp, Ne, Ua, jn, Yp, Zp, Na, Qp, Ba, Va, Ma, Wa, xr = U(()=>{\n    \"use strict\";\n    $r();\n    Ra =  false || typeof location > \"u\" ? void 0 : location.origin, jp = ()=>{\n        var _url;\n        if (true) return ((_url = \"file:///Users/amityadav/Desktop/Text-Behind%20Image/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs\") === null || _url === void 0 ? void 0 : _url.startsWith(\"file:\")) ? new URL(/* asset import */ new __webpack_require__.U(__webpack_require__(/*! ort.webgpu.bundle.min.mjs */ \"(app-pages-browser)/./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs?7f57\")).href, Ra).href : \"file:///Users/amityadav/Desktop/Text-Behind%20Image/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs\";\n    }, Ne = jp(), Ua = ()=>{\n        if (Ne && !Ne.startsWith(\"blob:\")) return Ne.substring(0, Ne.lastIndexOf(\"/\") + 1);\n    }, jn = (e1, t)=>{\n        try {\n            let r = t !== null && t !== void 0 ? t : Ne;\n            return (r ? new URL(e1, r) : new URL(e1)).origin === Ra;\n        } catch (e1) {\n            return !1;\n        }\n    }, Yp = (e1, t)=>{\n        let r = t !== null && t !== void 0 ? t : Ne;\n        try {\n            return (r ? new URL(e1, r) : new URL(e1)).href;\n        } catch (e1) {\n            return;\n        }\n    }, Zp = (e1, t)=>\"\".concat(t !== null && t !== void 0 ? t : \"./\").concat(e1), Na = async (e1)=>{\n        let r = await (await fetch(e1, {\n            credentials: \"same-origin\"\n        })).blob();\n        return URL.createObjectURL(r);\n    }, Qp = async (e1)=>(await import(/*webpackIgnore:true*/ e1)).default, Ba = (Pa(), br(Ea)).default, Va = async ()=>{\n        if (!Ne) throw new Error(\"Failed to load proxy worker: cannot determine the script source URL.\");\n        if (jn(Ne)) return [\n            void 0,\n            Ba()\n        ];\n        let e1 = await Na(Ne);\n        return [\n            e1,\n            Ba(e1)\n        ];\n    }, Ma = (Da(), br(Oa)).default, Wa = async (e1, t, r)=>{\n        if (!e1 && !t && Ma && Ne && jn(Ne)) return [\n            void 0,\n            Ma\n        ];\n        {\n            let n = \"ort-wasm-simd-threaded.jsep.mjs\", o = e1 !== null && e1 !== void 0 ? e1 : Yp(n, t), i =  true && r && o && !jn(o, t), a = i ? await Na(o) : o !== null && o !== void 0 ? o : Zp(n, t);\n            return [\n                i ? a : void 0,\n                await Qp(a)\n            ];\n        }\n    };\n});\nvar Yn, Zn, zr, La, Xp, Jp, Sr, Ie, gt = U(()=>{\n    \"use strict\";\n    xr();\n    Zn = !1, zr = !1, La = !1, Xp = ()=>{\n        if (typeof SharedArrayBuffer > \"u\") return !1;\n        try {\n            return typeof MessageChannel < \"u\" && new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)), WebAssembly.validate(new Uint8Array([\n                0,\n                97,\n                115,\n                109,\n                1,\n                0,\n                0,\n                0,\n                1,\n                4,\n                1,\n                96,\n                0,\n                0,\n                3,\n                2,\n                1,\n                0,\n                5,\n                4,\n                1,\n                3,\n                1,\n                1,\n                10,\n                11,\n                1,\n                9,\n                0,\n                65,\n                0,\n                254,\n                16,\n                2,\n                0,\n                26,\n                11\n            ]));\n        } catch (e1) {\n            return !1;\n        }\n    }, Jp = ()=>{\n        try {\n            return WebAssembly.validate(new Uint8Array([\n                0,\n                97,\n                115,\n                109,\n                1,\n                0,\n                0,\n                0,\n                1,\n                4,\n                1,\n                96,\n                0,\n                0,\n                3,\n                2,\n                1,\n                0,\n                10,\n                30,\n                1,\n                28,\n                0,\n                65,\n                0,\n                253,\n                15,\n                253,\n                12,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                0,\n                253,\n                186,\n                1,\n                26,\n                11\n            ]));\n        } catch (e1) {\n            return !1;\n        }\n    }, Sr = async (e1)=>{\n        if (Zn) return Promise.resolve();\n        if (zr) throw new Error(\"multiple calls to 'initializeWebAssembly()' detected.\");\n        if (La) throw new Error(\"previous call to 'initializeWebAssembly()' failed.\");\n        zr = !0;\n        let t = e1.initTimeout, r = e1.numThreads;\n        if (!Jp()) throw new Error(\"WebAssembly SIMD is not supported in the current environment.\");\n        let n = Xp();\n        r > 1 && !n && (typeof self < \"u\" && !self.crossOriginIsolated && console.warn(\"env.wasm.numThreads is set to \" + r + \", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info.\"), console.warn(\"WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading.\"), e1.numThreads = r = 1);\n        var _a_href, _l_href;\n        let o = e1.wasmPaths, i = typeof o == \"string\" ? o : void 0, a = o === null || o === void 0 ? void 0 : o.mjs, d = (_a_href = a === null || a === void 0 ? void 0 : a.href) !== null && _a_href !== void 0 ? _a_href : a, l = o === null || o === void 0 ? void 0 : o.wasm, p = (_l_href = l === null || l === void 0 ? void 0 : l.href) !== null && _l_href !== void 0 ? _l_href : l, m = e1.wasmBinary, [u, h] = await Wa(d, i, r > 1), _ = !1, y = [];\n        if (t > 0 && y.push(new Promise((g)=>{\n            setTimeout(()=>{\n                _ = !0, g();\n            }, t);\n        })), y.push(new Promise((g, x)=>{\n            let $ = {\n                numThreads: r\n            };\n            if (m) $.wasmBinary = m;\n            else if (p || i) $.locateFile = (v)=>p !== null && p !== void 0 ? p : i + v;\n            else if (d && d.indexOf(\"blob:\") !== 0) $.locateFile = (v)=>new URL(v, d).href;\n            else if (u) {\n                let v = Ua();\n                v && ($.locateFile = (S)=>v + S);\n            }\n            h($).then((v)=>{\n                zr = !1, Zn = !0, Yn = v, g(), u && URL.revokeObjectURL(u);\n            }, (v)=>{\n                zr = !1, La = !0, x(v);\n            });\n        })), await Promise.race(y), _) throw new Error(\"WebAssembly backend initializing failed due to timeout: \".concat(t, \"ms\"));\n    }, Ie = ()=>{\n        if (Zn && Yn) return Yn;\n        throw new Error(\"WebAssembly is not initialized yet.\");\n    };\n});\nvar ke, jt, pe, Or = U(()=>{\n    \"use strict\";\n    gt();\n    ke = (e1, t)=>{\n        let r = Ie(), n = r.lengthBytesUTF8(e1) + 1, o = r._malloc(n);\n        return r.stringToUTF8(e1, o, n), t.push(o), o;\n    }, jt = (e1, t, r, n)=>{\n        if (typeof e1 == \"object\" && e1 !== null) {\n            if (r.has(e1)) throw new Error(\"Circular reference in options\");\n            r.add(e1);\n        }\n        Object.entries(e1).forEach((param)=>{\n            let [o, i] = param;\n            let a = t ? t + o : o;\n            if (typeof i == \"object\") jt(i, a + \".\", r, n);\n            else if (typeof i == \"string\" || typeof i == \"number\") n(a, i.toString());\n            else if (typeof i == \"boolean\") n(a, i ? \"1\" : \"0\");\n            else throw new Error(\"Can't handle extra config type: \".concat(typeof i));\n        });\n    }, pe = (e1)=>{\n        let t = Ie(), r = t.stackSave();\n        try {\n            let n = t.PTR_SIZE, o = t.stackAlloc(2 * n);\n            t._OrtGetLastError(o, o + n);\n            let i = Number(t.getValue(o, n === 4 ? \"i32\" : \"i64\")), a = t.getValue(o + n, \"*\"), d = a ? t.UTF8ToString(a) : \"\";\n            throw new Error(\"\".concat(e1, \" ERROR_CODE: \").concat(i, \", ERROR_MESSAGE: \").concat(d));\n        } finally{\n            t.stackRestore(r);\n        }\n    };\n});\nvar Ga, Ha = U(()=>{\n    \"use strict\";\n    gt();\n    Or();\n    Ga = (e1)=>{\n        let t = Ie(), r = 0, n = [], o = e1 || {};\n        try {\n            if ((e1 === null || e1 === void 0 ? void 0 : e1.logSeverityLevel) === void 0) o.logSeverityLevel = 2;\n            else if (typeof e1.logSeverityLevel != \"number\" || !Number.isInteger(e1.logSeverityLevel) || e1.logSeverityLevel < 0 || e1.logSeverityLevel > 4) throw new Error(\"log serverity level is not valid: \".concat(e1.logSeverityLevel));\n            if ((e1 === null || e1 === void 0 ? void 0 : e1.logVerbosityLevel) === void 0) o.logVerbosityLevel = 0;\n            else if (typeof e1.logVerbosityLevel != \"number\" || !Number.isInteger(e1.logVerbosityLevel)) throw new Error(\"log verbosity level is not valid: \".concat(e1.logVerbosityLevel));\n            (e1 === null || e1 === void 0 ? void 0 : e1.terminate) === void 0 && (o.terminate = !1);\n            let i = 0;\n            return (e1 === null || e1 === void 0 ? void 0 : e1.tag) !== void 0 && (i = ke(e1.tag, n)), r = t._OrtCreateRunOptions(o.logSeverityLevel, o.logVerbosityLevel, !!o.terminate, i), r === 0 && pe(\"Can't create run options.\"), (e1 === null || e1 === void 0 ? void 0 : e1.extra) !== void 0 && jt(e1.extra, \"\", new WeakSet, (a, d)=>{\n                let l = ke(a, n), p = ke(d, n);\n                t._OrtAddRunConfigEntry(r, l, p) !== 0 && pe(\"Can't set a run config entry: \".concat(a, \" - \").concat(d, \".\"));\n            }), [\n                r,\n                n\n            ];\n        } catch (i) {\n            throw r !== 0 && t._OrtReleaseRunOptions(r), n.forEach((a)=>t._free(a)), i;\n        }\n    };\n});\nvar em, tm, rm, nm, Fa, qa = U(()=>{\n    \"use strict\";\n    gt();\n    Or();\n    em = (e1)=>{\n        switch(e1){\n            case \"disabled\":\n                return 0;\n            case \"basic\":\n                return 1;\n            case \"extended\":\n                return 2;\n            case \"all\":\n                return 99;\n            default:\n                throw new Error(\"unsupported graph optimization level: \".concat(e1));\n        }\n    }, tm = (e1)=>{\n        switch(e1){\n            case \"sequential\":\n                return 0;\n            case \"parallel\":\n                return 1;\n            default:\n                throw new Error(\"unsupported execution mode: \".concat(e1));\n        }\n    }, rm = (e1)=>{\n        e1.extra || (e1.extra = {}), e1.extra.session || (e1.extra.session = {});\n        let t = e1.extra.session;\n        t.use_ort_model_bytes_directly || (t.use_ort_model_bytes_directly = \"1\"), e1.executionProviders && e1.executionProviders.some((r)=>(typeof r == \"string\" ? r : r.name) === \"webgpu\") && (e1.enableMemPattern = !1);\n    }, nm = (e1, t, r)=>{\n        for (let n of t){\n            let o = typeof n == \"string\" ? n : n.name;\n            switch(o){\n                case \"webnn\":\n                    if (o = \"WEBNN\", typeof n != \"string\") {\n                        let d = n === null || n === void 0 ? void 0 : n.deviceType;\n                        if (d) {\n                            let l = ke(\"deviceType\", r), p = ke(d, r);\n                            Ie()._OrtAddSessionConfigEntry(e1, l, p) !== 0 && pe(\"Can't set a session config entry: 'deviceType' - \".concat(d, \".\"));\n                        }\n                    }\n                    break;\n                case \"webgpu\":\n                    if (o = \"JS\", typeof n != \"string\") {\n                        let a = n;\n                        if (a === null || a === void 0 ? void 0 : a.preferredLayout) {\n                            if (a.preferredLayout !== \"NCHW\" && a.preferredLayout !== \"NHWC\") throw new Error(\"preferredLayout must be either 'NCHW' or 'NHWC': \".concat(a.preferredLayout));\n                            let d = ke(\"preferredLayout\", r), l = ke(a.preferredLayout, r);\n                            Ie()._OrtAddSessionConfigEntry(e1, d, l) !== 0 && pe(\"Can't set a session config entry: 'preferredLayout' - \".concat(a.preferredLayout, \".\"));\n                        }\n                    }\n                    break;\n                case \"wasm\":\n                case \"cpu\":\n                    continue;\n                default:\n                    throw new Error(\"not supported execution provider: \".concat(o));\n            }\n            let i = ke(o, r);\n            Ie()._OrtAppendExecutionProvider(e1, i) !== 0 && pe(\"Can't append execution provider: \".concat(o, \".\"));\n        }\n    }, Fa = (e1)=>{\n        let t = Ie(), r = 0, n = [], o = e1 || {};\n        rm(o);\n        try {\n            var _o_graphOptimizationLevel, _o_executionMode, _o_logSeverityLevel;\n            let i = em((_o_graphOptimizationLevel = o.graphOptimizationLevel) !== null && _o_graphOptimizationLevel !== void 0 ? _o_graphOptimizationLevel : \"all\"), a = tm((_o_executionMode = o.executionMode) !== null && _o_executionMode !== void 0 ? _o_executionMode : \"sequential\"), d = typeof o.logId == \"string\" ? ke(o.logId, n) : 0, l = (_o_logSeverityLevel = o.logSeverityLevel) !== null && _o_logSeverityLevel !== void 0 ? _o_logSeverityLevel : 2;\n            if (!Number.isInteger(l) || l < 0 || l > 4) throw new Error(\"log serverity level is not valid: \".concat(l));\n            var _o_logVerbosityLevel;\n            let p = (_o_logVerbosityLevel = o.logVerbosityLevel) !== null && _o_logVerbosityLevel !== void 0 ? _o_logVerbosityLevel : 0;\n            if (!Number.isInteger(p) || p < 0 || p > 4) throw new Error(\"log verbosity level is not valid: \".concat(p));\n            let m = typeof o.optimizedModelFilePath == \"string\" ? ke(o.optimizedModelFilePath, n) : 0;\n            if (r = t._OrtCreateSessionOptions(i, !!o.enableCpuMemArena, !!o.enableMemPattern, a, !!o.enableProfiling, 0, d, l, p, m), r === 0 && pe(\"Can't create session options.\"), o.executionProviders && nm(r, o.executionProviders, n), o.enableGraphCapture !== void 0) {\n                if (typeof o.enableGraphCapture != \"boolean\") throw new Error(\"enableGraphCapture must be a boolean value: \".concat(o.enableGraphCapture));\n                let u = ke(\"enableGraphCapture\", n), h = ke(o.enableGraphCapture.toString(), n);\n                t._OrtAddSessionConfigEntry(r, u, h) !== 0 && pe(\"Can't set a session config entry: 'enableGraphCapture' - \".concat(o.enableGraphCapture, \".\"));\n            }\n            if (o.freeDimensionOverrides) for (let [u, h] of Object.entries(o.freeDimensionOverrides)){\n                if (typeof u != \"string\") throw new Error(\"free dimension override name must be a string: \".concat(u));\n                if (typeof h != \"number\" || !Number.isInteger(h) || h < 0) throw new Error(\"free dimension override value must be a non-negative integer: \".concat(h));\n                let _ = ke(u, n);\n                t._OrtAddFreeDimensionOverride(r, _, h) !== 0 && pe(\"Can't set a free dimension override: \".concat(u, \" - \").concat(h, \".\"));\n            }\n            return o.extra !== void 0 && jt(o.extra, \"\", new WeakSet, (u, h)=>{\n                let _ = ke(u, n), y = ke(h, n);\n                t._OrtAddSessionConfigEntry(r, _, y) !== 0 && pe(\"Can't set a session config entry: \".concat(u, \" - \").concat(h, \".\"));\n            }), [\n                r,\n                n\n            ];\n        } catch (i) {\n            throw r !== 0 && t._OrtReleaseSessionOptions(r) !== 0 && pe(\"Can't release session options.\"), n.forEach((a)=>t._free(a)), i;\n        }\n    };\n});\nvar Yt, bt, Ct, Dr, Zt, Br, Mr, Qn, te = U(()=>{\n    \"use strict\";\n    Yt = (e1)=>{\n        switch(e1){\n            case \"int8\":\n                return 3;\n            case \"uint8\":\n                return 2;\n            case \"bool\":\n                return 9;\n            case \"int16\":\n                return 5;\n            case \"uint16\":\n                return 4;\n            case \"int32\":\n                return 6;\n            case \"uint32\":\n                return 12;\n            case \"float16\":\n                return 10;\n            case \"float32\":\n                return 1;\n            case \"float64\":\n                return 11;\n            case \"string\":\n                return 8;\n            case \"int64\":\n                return 7;\n            case \"uint64\":\n                return 13;\n            case \"int4\":\n                return 22;\n            case \"uint4\":\n                return 21;\n            default:\n                throw new Error(\"unsupported data type: \".concat(e1));\n        }\n    }, bt = (e1)=>{\n        switch(e1){\n            case 3:\n                return \"int8\";\n            case 2:\n                return \"uint8\";\n            case 9:\n                return \"bool\";\n            case 5:\n                return \"int16\";\n            case 4:\n                return \"uint16\";\n            case 6:\n                return \"int32\";\n            case 12:\n                return \"uint32\";\n            case 10:\n                return \"float16\";\n            case 1:\n                return \"float32\";\n            case 11:\n                return \"float64\";\n            case 8:\n                return \"string\";\n            case 7:\n                return \"int64\";\n            case 13:\n                return \"uint64\";\n            case 22:\n                return \"int4\";\n            case 21:\n                return \"uint4\";\n            default:\n                throw new Error(\"unsupported data type: \".concat(e1));\n        }\n    }, Ct = (e1, t)=>{\n        let r = [\n            -1,\n            4,\n            1,\n            1,\n            2,\n            2,\n            4,\n            8,\n            -1,\n            1,\n            2,\n            8,\n            4,\n            8,\n            -1,\n            -1,\n            -1,\n            -1,\n            -1,\n            -1,\n            -1,\n            .5,\n            .5\n        ][e1], n = typeof t == \"number\" ? t : t.reduce((o, i)=>o * i, 1);\n        return r > 0 ? Math.ceil(n * r) : void 0;\n    }, Dr = (e1)=>{\n        switch(e1){\n            case \"float16\":\n                return typeof Float16Array < \"u\" && Float16Array.from ? Float16Array : Uint16Array;\n            case \"float32\":\n                return Float32Array;\n            case \"uint8\":\n                return Uint8Array;\n            case \"int8\":\n                return Int8Array;\n            case \"uint16\":\n                return Uint16Array;\n            case \"int16\":\n                return Int16Array;\n            case \"int32\":\n                return Int32Array;\n            case \"bool\":\n                return Uint8Array;\n            case \"float64\":\n                return Float64Array;\n            case \"uint32\":\n                return Uint32Array;\n            case \"int64\":\n                return BigInt64Array;\n            case \"uint64\":\n                return BigUint64Array;\n            default:\n                throw new Error(\"unsupported type: \".concat(e1));\n        }\n    }, Zt = (e1)=>{\n        switch(e1){\n            case \"verbose\":\n                return 0;\n            case \"info\":\n                return 1;\n            case \"warning\":\n                return 2;\n            case \"error\":\n                return 3;\n            case \"fatal\":\n                return 4;\n            default:\n                throw new Error(\"unsupported logging level: \".concat(e1));\n        }\n    }, Br = (e1)=>e1 === \"float32\" || e1 === \"float16\" || e1 === \"int32\" || e1 === \"int64\" || e1 === \"uint32\" || e1 === \"uint8\" || e1 === \"bool\" || e1 === \"uint4\" || e1 === \"int4\", Mr = (e1)=>e1 === \"float32\" || e1 === \"float16\" || e1 === \"int32\" || e1 === \"int64\" || e1 === \"uint32\" || e1 === \"uint64\" || e1 === \"int8\" || e1 === \"uint8\" || e1 === \"bool\" || e1 === \"uint4\" || e1 === \"int4\", Qn = (e1)=>{\n        switch(e1){\n            case \"none\":\n                return 0;\n            case \"cpu\":\n                return 1;\n            case \"cpu-pinned\":\n                return 2;\n            case \"texture\":\n                return 3;\n            case \"gpu-buffer\":\n                return 4;\n            case \"ml-tensor\":\n                return 5;\n            default:\n                throw new Error(\"unsupported data location: \".concat(e1));\n        }\n    };\n});\nvar Qt, Xn = U(()=>{\n    \"use strict\";\n    $r();\n    Qt = async (e1)=>{\n        if (typeof e1 == \"string\") if (false) {}\n        else {\n            let t = await fetch(e1);\n            if (!t.ok) throw new Error(\"failed to load external data file: \".concat(e1));\n            let r = t.headers.get(\"Content-Length\"), n = r ? parseInt(r, 10) : 0;\n            if (n < 1073741824) return new Uint8Array(await t.arrayBuffer());\n            {\n                if (!t.body) throw new Error(\"failed to load external data file: \".concat(e1, \", no response body.\"));\n                let o = t.body.getReader(), i;\n                try {\n                    i = new ArrayBuffer(n);\n                } catch (d) {\n                    if (d instanceof RangeError) {\n                        let l = Math.ceil(n / 65536);\n                        i = new WebAssembly.Memory({\n                            initial: l,\n                            maximum: l\n                        }).buffer;\n                    } else throw d;\n                }\n                let a = 0;\n                for(;;){\n                    let { done: d, value: l } = await o.read();\n                    if (d) break;\n                    let p = l.byteLength;\n                    new Uint8Array(i, a, p).set(l), a += p;\n                }\n                return new Uint8Array(i, 0, n);\n            }\n        }\n        else return e1 instanceof Blob ? new Uint8Array(await e1.arrayBuffer()) : e1 instanceof Uint8Array ? e1 : new Uint8Array(e1);\n    };\n});\nvar om, im, Ka, ja, Rr, am, ue, et = U(()=>{\n    \"use strict\";\n    te();\n    om = [\n        \"V\",\n        \"I\",\n        \"W\",\n        \"E\",\n        \"F\"\n    ], im = (e1, t)=>{\n        console.log(\"[\".concat(om[e1], \",\").concat(new Date().toISOString(), \"]\").concat(t));\n    }, Rr = (e1, t)=>{\n        Ka = e1, ja = t;\n    }, am = (e1, t)=>{\n        let r = Zt(e1), n = Zt(Ka);\n        r >= n && im(r, typeof t == \"function\" ? t() : t);\n    }, ue = function() {\n        for(var _len = arguments.length, e1 = new Array(_len), _key = 0; _key < _len; _key++){\n            e1[_key] = arguments[_key];\n        }\n        ja && am(...e1);\n    };\n});\nvar Ur, Jn = U(()=>{\n    \"use strict\";\n    te();\n    Ur = (e1, t)=>new (Dr(t))(e1);\n});\nvar Nr = U(_c9 = ()=>{\n    \"use strict\";\n});\n_c10 = Nr;\nvar Ya, eo, to, sm, um, Za, no, ro, Xa, Ja = U(()=>{\n    \"use strict\";\n    et();\n    Nr();\n    Ya = new Map([\n        [\n            64,\n            250\n        ],\n        [\n            128,\n            200\n        ],\n        [\n            256,\n            200\n        ],\n        [\n            512,\n            200\n        ],\n        [\n            2048,\n            230\n        ],\n        [\n            4096,\n            200\n        ],\n        [\n            8192,\n            50\n        ],\n        [\n            16384,\n            50\n        ],\n        [\n            32768,\n            50\n        ],\n        [\n            65536,\n            50\n        ],\n        [\n            131072,\n            50\n        ],\n        [\n            262144,\n            50\n        ],\n        [\n            524288,\n            50\n        ],\n        [\n            1048576,\n            50\n        ],\n        [\n            2097152,\n            30\n        ],\n        [\n            4194304,\n            20\n        ],\n        [\n            8388608,\n            10\n        ],\n        [\n            12582912,\n            10\n        ],\n        [\n            16777216,\n            10\n        ],\n        [\n            26214400,\n            15\n        ],\n        [\n            33554432,\n            22\n        ],\n        [\n            44236800,\n            2\n        ],\n        [\n            58982400,\n            6\n        ],\n        [\n            67108864,\n            6\n        ],\n        [\n            134217728,\n            6\n        ],\n        [\n            167772160,\n            6\n        ]\n    ]), eo = [], to = (e1)=>Math.ceil(Number(e1) / 16) * 16, sm = (e1)=>{\n        for(let t = 0; t < eo.length; t++){\n            let r = eo[t];\n            if (e1 <= r) return r;\n        }\n        return Math.ceil(e1 / 16) * 16;\n    }, um = 1, Za = ()=>um++, no = async (e1, t, r, n)=>{\n        let o = to(r), i = e1.device.createBuffer({\n            size: o,\n            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ\n        });\n        try {\n            let a = e1.getCommandEncoder();\n            e1.endComputePass(), a.copyBufferToBuffer(t, 0, i, 0, o), e1.flush(), await i.mapAsync(GPUMapMode.READ);\n            let d = i.getMappedRange();\n            if (n) {\n                let l = n();\n                return l.set(new Uint8Array(d, 0, r)), l;\n            } else return new Uint8Array(d.slice(0, r));\n        } finally{\n            i.destroy();\n        }\n    }, ro = class {\n        upload(t, r) {\n            let n = r.buffer, o = r.byteOffset, i = r.byteLength, a = to(i), d = this.storageCache.get(t);\n            if (!d) throw new Error(\"gpu data for uploading does not exist\");\n            if (Number(d.originalSize) !== i) throw new Error(\"inconsistent data size. gpu data size=\".concat(d.originalSize, \", data size=\").concat(i));\n            let l = this.backend.device.createBuffer({\n                mappedAtCreation: !0,\n                size: a,\n                usage: GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC\n            }), p = l.getMappedRange();\n            new Uint8Array(p).set(new Uint8Array(n, o, i)), l.unmap();\n            let m = this.backend.device.createCommandEncoder();\n            m.copyBufferToBuffer(l, 0, d.gpuData.buffer, 0, a), this.backend.device.queue.submit([\n                m.finish()\n            ]), l.destroy(), ue(\"verbose\", ()=>\"[WebGPU] GpuDataManager.upload(id=\".concat(t, \")\"));\n        }\n        memcpy(t, r) {\n            let n = this.storageCache.get(t);\n            if (!n) throw new Error(\"source gpu data for memcpy does not exist\");\n            let o = this.storageCache.get(r);\n            if (!o) throw new Error(\"destination gpu data for memcpy does not exist\");\n            if (n.originalSize !== o.originalSize) throw new Error(\"inconsistent source and destination gpu data size\");\n            let i = to(n.originalSize), a = this.backend.getCommandEncoder();\n            this.backend.endComputePass(), a.copyBufferToBuffer(n.gpuData.buffer, 0, o.gpuData.buffer, 0, i);\n        }\n        registerExternalBuffer(t, r, n) {\n            let o;\n            if (n) {\n                if (o = n[0], t === n[1]) return ue(\"verbose\", ()=>\"[WebGPU] GpuDataManager.registerExternalBuffer(size=\".concat(r, \") => id=\").concat(o, \", buffer is the same, skip.\")), o;\n                if (this.backend.capturedCommandList.has(this.backend.currentSessionId)) throw new Error(\"Registering a different external buffer under graph capture mode is not supported yet.\\n             Please use the previous external buffer!\");\n            } else o = Za();\n            return this.storageCache.set(o, {\n                gpuData: {\n                    id: o,\n                    type: 0,\n                    buffer: t\n                },\n                originalSize: r\n            }), ue(\"verbose\", ()=>\"[WebGPU] GpuDataManager.registerExternalBuffer(size=\".concat(r, \") => id=\").concat(o, \", registered.\")), o;\n        }\n        unregisterExternalBuffer(t) {\n            t !== void 0 && (this.storageCache.delete(t), ue(\"verbose\", ()=>\"[WebGPU] GpuDataManager.unregisterExternalBuffer() => id=\".concat(t)));\n        }\n        create(t) {\n            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST;\n            let n = sm(t), o, i = (r & GPUBufferUsage.STORAGE) === GPUBufferUsage.STORAGE, a = (r & GPUBufferUsage.UNIFORM) === GPUBufferUsage.UNIFORM;\n            if (i || a) {\n                let p = (i ? this.freeBuffers : this.freeUniformBuffers).get(n);\n                p ? p.length > 0 ? o = p.pop() : o = this.backend.device.createBuffer({\n                    size: n,\n                    usage: r\n                }) : o = this.backend.device.createBuffer({\n                    size: n,\n                    usage: r\n                });\n            } else o = this.backend.device.createBuffer({\n                size: n,\n                usage: r\n            });\n            let d = {\n                id: Za(),\n                type: 0,\n                buffer: o\n            };\n            return this.storageCache.set(d.id, {\n                gpuData: d,\n                originalSize: Number(t)\n            }), ue(\"verbose\", ()=>\"[WebGPU] GpuDataManager.create(size=\".concat(t, \") => id=\").concat(d.id)), d;\n        }\n        get(t) {\n            var _this_storageCache_get;\n            return (_this_storageCache_get = this.storageCache.get(t)) === null || _this_storageCache_get === void 0 ? void 0 : _this_storageCache_get.gpuData;\n        }\n        release(t) {\n            let r = typeof t == \"bigint\" ? Number(t) : t, n = this.storageCache.get(r);\n            if (!n) {\n                if (this.storageCache.size === 0) return 0;\n                throw new Error(\"releasing data does not exist\");\n            }\n            return ue(\"verbose\", ()=>\"[WebGPU] GpuDataManager.release(id=\".concat(r, \"), gpuDataId=\").concat(n.gpuData.id)), this.storageCache.delete(r), this.buffersPending.push(n.gpuData.buffer), n.originalSize;\n        }\n        async download(t, r) {\n            let n = this.storageCache.get(Number(t));\n            if (!n) throw new Error(\"data does not exist\");\n            await no(this.backend, n.gpuData.buffer, n.originalSize, r);\n        }\n        refreshPendingBuffers() {\n            if (this.buffersPending.length !== 0) if (this.backend.sessionStatus === \"default\") {\n                for (let t of this.buffersPending){\n                    let r = Ya.get(t.size);\n                    if ((t.usage & GPUBufferUsage.STORAGE) === GPUBufferUsage.STORAGE) {\n                        let n = this.freeBuffers.get(t.size) || [];\n                        r === void 0 || n.length >= r ? t.destroy() : n.push(t);\n                    } else if ((t.usage & GPUBufferUsage.UNIFORM) === GPUBufferUsage.UNIFORM) {\n                        let n = this.freeUniformBuffers.get(t.size) || [];\n                        r === void 0 || n.length >= r ? t.destroy() : n.push(t);\n                    } else t.destroy();\n                }\n                this.buffersPending = [];\n            } else {\n                let t = this.capturedPendingBuffers.get(this.backend.currentSessionId);\n                t || (t = [], this.capturedPendingBuffers.set(this.backend.currentSessionId, t));\n                for (let r of this.buffersPending)t.push(r);\n                this.buffersPending = [];\n            }\n        }\n        dispose() {\n            this.freeBuffers.forEach((t)=>{\n                t.forEach((r)=>{\n                    r.destroy();\n                });\n            }), this.freeUniformBuffers.forEach((t)=>{\n                t.forEach((r)=>{\n                    r.destroy();\n                });\n            }), this.storageCache.forEach((t)=>{\n                t.gpuData.buffer.destroy();\n            }), this.capturedPendingBuffers.forEach((t)=>{\n                t.forEach((r)=>{\n                    r.destroy();\n                });\n            }), this.storageCache = new Map, this.freeBuffers = new Map, this.freeUniformBuffers = new Map, this.capturedPendingBuffers = new Map;\n        }\n        onCreateSession() {\n            this.sessionCount += 1;\n        }\n        onReleaseSession(t) {\n            let r = this.capturedPendingBuffers.get(t);\n            r && (r.forEach((n)=>{\n                n.destroy();\n            }), this.capturedPendingBuffers.delete(t)), this.sessionCount -= 1, this.sessionCount === 0 && (ue(\"warning\", ()=>\"[WebGPU] Clearing webgpu buffer cache\"), this.storageCache.forEach((n)=>{\n                n.gpuData.buffer.destroy();\n            }), this.storageCache = new Map);\n        }\n        constructor(t){\n            this.backend = t;\n            this.storageCache = new Map, this.freeBuffers = new Map, this.freeUniformBuffers = new Map, this.buffersPending = [], this.capturedPendingBuffers = new Map;\n            for (let [r] of Ya)eo.push(r), this.freeBuffers.set(r, []), this.freeUniformBuffers.set(r, []);\n            this.sessionCount = 0;\n        }\n    }, Xa = function() {\n        for(var _len = arguments.length, e1 = new Array(_len), _key = 0; _key < _len; _key++){\n            e1[_key] = arguments[_key];\n        }\n        return new ro(...e1);\n    };\n});\nvar oo, re, Se = U(()=>{\n    \"use strict\";\n    oo = class {\n        get cacheKey() {\n            return this.key || (this.key = Object.getOwnPropertyNames(this).sort().map((t)=>\"\".concat(this[t])).join(\";\")), this.key;\n        }\n        constructor(t){\n            Object.assign(this, t);\n        }\n    }, re = (e1)=>new oo(e1);\n});\nvar io, tt, C, At, Vr, es, ts, oe = U(()=>{\n    \"use strict\";\n    io = class {\n        static calcMatMulShape(t, r) {\n            return t[1] !== r[0] ? void 0 : [\n                t[0],\n                r[1]\n            ];\n        }\n    }, tt = class {\n        static calcShape(t, r) {\n            let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;\n            let o = t.length, i = r.length;\n            if (o === 0) return r;\n            if (i === 0) return t;\n            let a = Math.max(t.length, r.length), d = new Array(a);\n            if (n) {\n                if (o < 2 || i < 2) return;\n                let l = io.calcMatMulShape([\n                    t[o - 2],\n                    t[o - 1]\n                ], [\n                    r[i - 2],\n                    r[i - 1]\n                ]);\n                if (l === void 0) return;\n                [d[a - 2], d[a - 1]] = l;\n            }\n            for(let l = n ? 3 : 1; l <= a; l++){\n                let p = o - l < 0 ? 1 : t[o - l], m = i - l < 0 ? 1 : r[i - l];\n                if (p !== m && p > 1 && m > 1) return;\n                let u = Math.max(p, m);\n                if (p && m) d[a - l] = Math.max(p, m);\n                else {\n                    if (u > 1) return;\n                    d[a - l] = 0;\n                }\n            }\n            return d;\n        }\n        static isValidBroadcast(t, r) {\n            let n = t.length, o = r.length;\n            if (n > o) return !1;\n            for(let i = 1; i <= n; i++)if (t[n - i] !== 1 && t[n - i] !== r[o - i]) return !1;\n            return !0;\n        }\n    }, C = class e1 {\n        static size(t) {\n            return e1.getSizeFromDimensionRange(t, 0, t.length);\n        }\n        static convertShape(t) {\n            let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 4;\n            let n = t.length;\n            if (n === 0) return [];\n            let o = new Array(n), i = n - 1;\n            for(; i >= 0;){\n                if (t[i] % r === 0) {\n                    o[i] = t[i] / r;\n                    break;\n                }\n                if (r % t[i] !== 0) throw new Error(\"cannot convert shape\");\n                o[i] = 1, r /= t[i], i--;\n            }\n            for(i--; i >= 0; i--)o[i] = t[i];\n            return o;\n        }\n        static sizeFromDimension(t, r) {\n            if (r < 0 || r > t.length) throw new Error(\"invalid dimension of \".concat(r, \" for sizeFromDimension as Tensor has \").concat(t.length, \" dimensions.\"));\n            return e1.getSizeFromDimensionRange(t, r, t.length);\n        }\n        static sizeToDimension(t, r) {\n            if (r < 0 || r > t.length) throw new Error(\"invalid dimension of \".concat(r, \" for sizeToDimension as Tensor has \").concat(t.length, \" dimensions.\"));\n            return e1.getSizeFromDimensionRange(t, 0, r);\n        }\n        static getSizeFromDimensionRange(t, r, n) {\n            let o = 1;\n            for(let i = r; i < n; i++){\n                if (t[i] < 0) throw new Error(\"cannot get valid size from specified dimension range. Most likely the range contains negative values in them.\");\n                o *= Number(t[i]);\n            }\n            return o;\n        }\n        static computeStrides(t) {\n            let r = t.length;\n            if (r === 0) return [];\n            if (r === 1) return [\n                1\n            ];\n            let n = new Array(r);\n            n[r - 1] = 1, n[r - 2] = t[r - 1];\n            for(let o = r - 3; o >= 0; --o)n[o] = n[o + 1] * t[o + 1];\n            return n;\n        }\n        static normalizeAxis(t, r) {\n            if (t < -r && t >= r) throw new Error(\"unsupported axis for this operation.\");\n            return t < 0 ? t + r : t;\n        }\n        static normalizeAxes(t, r) {\n            return t.map((n)=>this.normalizeAxis(n, r !== null && r !== void 0 ? r : t.length));\n        }\n        static sortBasedOnPerm(t, r) {\n            return r ? r.map((n)=>t[n]) : t.slice().reverse();\n        }\n        static padShape(t, r) {\n            let n = t.length;\n            return t.map((o, i)=>o + r[i] + r[i + n]);\n        }\n        static areEqual(t, r) {\n            return t.length !== r.length ? !1 : t.every((n, o)=>n === r[o]);\n        }\n    }, At = class e1 {\n        static adjustPoolAttributes(t, r, n, o, i, a) {\n            if (!t && n.length !== r.length - 2) throw new Error(\"length of specified kernel shapes should be 2 less than length of input dimensions\");\n            if (t) for(let d = 0; d < r.length - 2; d++)d >= n.length ? n.push(r[d + 2]) : n[d] = r[d + 2];\n            for(let d = 0; d < n.length; d++)if (d < o.length) {\n                if (o[d] < 0) throw new Error(\"strides should be greater than or equal to 1\");\n            } else o.push(1);\n            for(let d = 0; d < n.length; d++)if (d < i.length) {\n                if (i[d] < 0) throw new Error(\"dilations should be greater than or equal to 1\");\n            } else i.push(1);\n            for(let d = 0; d < n.length * 2; d++)if (d < a.length) {\n                if (a[d] < 0) throw new Error(\"pad should be greater than or equal to 1\");\n            } else a.push(0);\n            for(let d = 0; d < n.length; d++){\n                if (n[d] <= 0) throw new Error(\"kernel shapes need to be greater than 0\");\n                if (a[d] >= n[d] || a[d + n.length] >= n[d]) throw new Error(\"pads should be smaller than kernel\");\n            }\n        }\n        static adjustPadsBasedOnAutoPad(t, r, n, o, i, a, d) {\n            if (d) {\n                if (i.length !== 2 * (t.length - 2)) throw new Error(\"length of pads should be twice the length of data dimensions\");\n                if (r.length !== t.length - 2) throw new Error(\"length of strides should be the length of data dimensions\");\n                if (o.length !== t.length - 2) throw new Error(\"length of kernel shapes should be the length of data dimensions\");\n                for(let l = 0; l < t.length - 2; l++)e1.adjustPadAndReturnShape(t[l + (a ? 1 : 2)], r[l], n[l], o[l], i, l, l + t.length - 2, d);\n            }\n        }\n        static computePoolOutputShape(t, r, n, o, i, a, d) {\n            if (r.length <= 0) throw new Error(\"input shape must be of size greater than 0\");\n            let l = [\n                r[0],\n                r[1]\n            ];\n            return e1.computeShapeHelper(t, r, l, n, o, i, a, d), l;\n        }\n        static computeConvOutputShape(t, r, n, o, i, a, d) {\n            if (t.length <= 0 || r.length <= 0) throw new Error(\"invalid input tensor dims or invalid filter tensor dims\");\n            let l = [\n                t[0],\n                r[0]\n            ];\n            return e1.computeShapeHelper(!1, t, l, n, o, i, a, d), l;\n        }\n        static computeShapeHelper(t, r, n, o, i, a, d, l) {\n            if (t) for(let p = 0; p < r.length - 2; p++)n.push(1);\n            else for(let p = 0; p < r.length - 2; p++)n.push(e1.adjustPadAndReturnShape(r[p + 2], o[p], i[p], a[p], d, p, p + r.length - 2, l));\n        }\n        static adjustPadAndReturnShape(t, r, n, o, i, a, d, l) {\n            let p = n * (o - 1) + 1;\n            if (l && l !== \"NOTSET\") switch(l){\n                case \"VALID\":\n                    return i[a] = 0, i[d] = 0, Math.floor((t - p) / r + 1);\n                case \"SAME_LOWER\":\n                case \"SAME_UPPER\":\n                    if (n !== 1) throw new Error(\"Dilation not supported for SAME_UPPER or SAME_LOWER\");\n                    {\n                        let u = ((t + r - 1) / r - 1) * r + o - t;\n                        return i[a] = Math.floor(l === \"SAME_LOWER\" ? (u + 1) / 2 : u / 2), i[d] = u - i[a], Math.floor((t + u - o) / r + 1);\n                    }\n                default:\n                    throw new Error(\"Unsupported AutoPad type\");\n            }\n            else return Math.floor((t + i[a] + i[d] - p) / r + 1);\n        }\n    }, Vr = class {\n        static getShapeOfGemmResult(t, r, n, o, i) {\n            if (t.length !== 2 || n.length !== 2) throw new Error(\"shape need to be of size 2\");\n            let a, d, l;\n            r ? (a = t[1], d = t[0]) : (a = t[0], d = t[1]);\n            let p = -1;\n            if (o ? (l = n[0], p = 1) : (l = n[1], p = 0), n[p] !== d) throw new Error(\"dimension mismatch\");\n            if (a <= 0 || l <= 0 || d <= 0) throw new Error(\"invalid shape specified\");\n            if (i && !tt.isValidBroadcast(i, [\n                a,\n                l\n            ])) throw new Error(\"gemm: invalid bias shape for broadcast\");\n            return [\n                a,\n                l,\n                d\n            ];\n        }\n    }, es = -34028234663852886e22, ts = 34028234663852886e22;\n});\nvar kt, so, _e, Ee, N, me, uo, Et, Fe, F, Wr, E, M, rs, Lr, ao, ns, ae = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    kt = 64, so = (e1, t)=>{\n        if (t === 3) throw new Error(\"vec3 has same alignment as vec4, use vec4 instead\");\n        switch(Number(e1)){\n            case 10:\n                return t > 1 ? \"vec\".concat(t, \"<f16>\") : \"f16\";\n            case 1:\n                return t > 1 ? \"vec\".concat(t, \"<f32>\") : \"f32\";\n            case 6:\n                return t > 1 ? \"vec\".concat(t, \"<i32>\") : \"i32\";\n            case 12:\n                return t > 1 ? \"vec\".concat(t, \"<u32>\") : \"u32\";\n            case 7:\n                if (t > 1) throw new Error(\"currently not supported vecX of uint64 yet\");\n                return [\n                    \"vec2<u32>\",\n                    \"i32\"\n                ];\n            case 13:\n                if (t > 1) throw new Error(\"currently not supported vecX of uint64 yet\");\n                return [\n                    \"vec2<u32>\",\n                    \"u32\"\n                ];\n            case 9:\n                if (t !== 4) throw new Error(\"bool must be vec4\");\n                return [\n                    \"u32\",\n                    \"vec4<bool>\"\n                ];\n            case 22:\n                return \"i32\";\n            case 21:\n                return \"u32\";\n            default:\n                throw new Error(\"Unknown data type: \".concat(e1));\n        }\n    }, _e = function(e1) {\n        let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n        let r = so(e1, t);\n        return typeof r == \"string\" ? r : r[0];\n    }, Ee = function(e1) {\n        let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n        let r = so(e1, t);\n        return typeof r == \"string\" ? r : r[1];\n    }, N = function() {\n        for(var _len = arguments.length, e1 = new Array(_len), _key = 0; _key < _len; _key++){\n            e1[_key] = arguments[_key];\n        }\n        let t = [];\n        return e1.forEach((r)=>{\n            r.length !== 0 && t.push({\n                type: 12,\n                data: r\n            }, {\n                type: 12,\n                data: C.computeStrides(r)\n            });\n        }), t;\n    }, me = (e1)=>e1 % 4 === 0 ? 4 : e1 % 2 === 0 ? 2 : 1, uo = function() {\n        let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"f32\", t = arguments.length > 1 ? arguments[1] : void 0, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"0\";\n        return !t || t === 1 ? \"\".concat(e1, \"(\").concat(r, \")\") : \"vec\".concat(t, \"<\").concat(e1, \">(\").concat(r, \")\");\n    }, Et = (e1, t, r)=>e1 === \"f32\" ? r : t === 1 ? \"f32(\".concat(r, \")\") : \"vec\".concat(t, \"<f32>(\").concat(r, \")\"), Fe = (e1, t)=>t === 4 ? \"(\".concat(e1, \".x + \").concat(e1, \".y + \").concat(e1, \".z + \").concat(e1, \".w)\") : t === 2 ? \"(\".concat(e1, \".x + \").concat(e1, \".y)\") : t === 3 ? \"(\".concat(e1, \".x + \").concat(e1, \".y + \").concat(e1, \".z)\") : e1, F = (e1, t, r, n)=>e1.startsWith(\"uniforms.\") && r > 4 ? typeof t == \"string\" ? n === \"f16\" ? \"\".concat(e1, \"[(\").concat(t, \") / 8][(\").concat(t, \") % 8 / 4][(\").concat(t, \") % 8 % 4]\") : \"\".concat(e1, \"[(\").concat(t, \") / 4][(\").concat(t, \") % 4]\") : n === \"f16\" ? \"\".concat(e1, \"[\").concat(Math.floor(t / 8), \"][\").concat(Math.floor(t % 8 / 4), \"][\").concat(t % 8 % 4, \"]\") : \"\".concat(e1, \"[\").concat(Math.floor(t / 4), \"][\").concat(t % 4, \"]\") : r > 1 ? \"\".concat(e1, \"[\").concat(t, \"]\") : e1, Wr = (e1, t, r, n, o)=>{\n        let i = typeof r == \"number\", a = i ? r : r.length, d = [\n            ...new Array(a).keys()\n        ], l = a < 2 ? \"u32\" : a <= 4 ? \"vec\".concat(a, \"<u32>\") : \"array<u32, \".concat(a, \">\"), p = so(t, o), m = typeof p == \"string\" ? p : p[1], u = typeof p == \"string\" ? p : p[0], h = {\n            indices: l,\n            value: m,\n            storage: u,\n            tensor: t\n        }, _ = (W)=>typeof W == \"string\" ? W : \"\".concat(W, \"u\"), y = {\n            offsetToIndices: !1,\n            indicesToOffset: !1,\n            broadcastedIndicesToOffset: !1,\n            set: !1,\n            setByIndices: !1,\n            get: !1,\n            getByIndices: !1\n        }, g = i ? \"uniforms.\" : \"\", x = \"\".concat(g).concat(e1, \"_shape\"), $ = \"\".concat(g).concat(e1, \"_strides\"), v = \"\";\n        for(let W = 0; W < a - 1; W++)v += \"\\n    let dim\".concat(W, \" = current / \").concat(F($, W, a), \";\\n    let rest\").concat(W, \" = current % \").concat(F($, W, a), \";\\n    indices[\").concat(W, \"] = dim\").concat(W, \";\\n    current = rest\").concat(W, \";\\n    \");\n        v += \"indices[\".concat(a - 1, \"] = current;\");\n        let S = a < 2 ? \"\" : \"\\n  fn o2i_\".concat(e1, \"(offset: u32) -> \").concat(h.indices, \" {\\n    var indices: \").concat(h.indices, \";\\n    var current = offset;\\n    \").concat(v, \"\\n    return indices;\\n  }\"), T = (W)=>(y.offsetToIndices = !0, a < 2 ? W : \"o2i_\".concat(e1, \"(\").concat(W, \")\")), A = [];\n        if (a >= 2) for(let W = a - 1; W >= 0; W--)A.push(\"\".concat(F($, W, a), \" * (indices[\").concat(W, \"])\"));\n        let k = a < 2 ? \"\" : \"\\n  fn i2o_\".concat(e1, \"(indices: \").concat(h.indices, \") -> u32 {\\n    return \").concat(A.join(\"+\"), \";\\n  }\"), P = (W)=>(y.indicesToOffset = !0, a < 2 ? W : \"i2o_\".concat(e1, \"(\").concat(W, \")\")), D = function() {\n            for(var _len = arguments.length, W = new Array(_len), _key = 0; _key < _len; _key++){\n                W[_key] = arguments[_key];\n            }\n            return a === 0 ? \"0u\" : \"\".concat(h.indices, \"(\").concat(W.map(_).join(\",\"), \")\");\n        }, R = (W, q)=>a < 2 ? \"\".concat(W) : \"\".concat(F(W, q, a)), G = (W, q, he)=>a < 2 ? \"\".concat(W, \"=\").concat(he, \";\") : \"\".concat(F(W, q, a), \"=\").concat(he, \";\"), K = {}, j = (W, q)=>{\n            y.broadcastedIndicesToOffset = !0;\n            let he = \"\".concat(q.name, \"broadcastedIndicesTo\").concat(e1, \"Offset\");\n            if (he in K) return \"\".concat(he, \"(\").concat(W, \")\");\n            let Ge = [];\n            for(let we = a - 1; we >= 0; we--){\n                let ye = q.indicesGet(\"outputIndices\", we + q.rank - a);\n                Ge.push(\"\".concat(R($, we), \" * (\").concat(ye, \" % \").concat(R(x, we), \")\"));\n            }\n            return K[he] = \"fn \".concat(he, \"(outputIndices: \").concat(q.type.indices, \") -> u32 {\\n             return \").concat(Ge.length > 0 ? Ge.join(\"+\") : \"0u\", \";\\n           }\"), \"\".concat(he, \"(\").concat(W, \")\");\n        }, V = (W, q)=>(()=>{\n                if (h.storage === h.value) return \"\".concat(e1, \"[\").concat(W, \"]=\").concat(q, \";\");\n                if (h.storage === \"vec2<u32>\" && h.value === \"i32\") return \"\".concat(e1, \"[\").concat(W, \"]=vec2<u32>(u32(\").concat(q, \"), select(0u, 0xFFFFFFFFu, \").concat(q, \" < 0));\");\n                if (h.storage === \"vec2<u32>\" && h.value === \"u32\") return \"\".concat(e1, \"[\").concat(W, \"]=vec2<u32>(u32(\").concat(q, \"), 0u);\");\n                if (h.storage === \"u32\" && h.value === \"vec4<bool>\") return \"\".concat(e1, \"[\").concat(W, \"]=dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(\").concat(q, \"));\");\n                throw new Error(\"not supported combination of storage type \".concat(h.storage, \" and value type \").concat(h.value, \" yet\"));\n            })(), Q = (W)=>(()=>{\n                if (h.storage === h.value) return \"\".concat(e1, \"[\").concat(W, \"]\");\n                if (h.storage === \"vec2<u32>\" && h.value === \"i32\") return \"i32(\".concat(e1, \"[\").concat(W, \"].x)\");\n                if (h.storage === \"vec2<u32>\" && h.value === \"u32\") return \"u32(\".concat(e1, \"[\").concat(W, \"].x)\");\n                if (h.storage === \"u32\" && h.value === \"vec4<bool>\") return \"vec4<bool>(bool(\".concat(e1, \"[\").concat(W, \"] & 0xFFu), bool(\").concat(e1, \"[\").concat(W, \"] & 0xFF00u), bool(\").concat(e1, \"[\").concat(W, \"] & 0xFF0000u), bool(\").concat(e1, \"[\").concat(W, \"] & 0xFF000000u))\");\n                throw new Error(\"not supported combination of storage type \".concat(h.storage, \" and value type \").concat(h.value, \" yet\"));\n            })(), se = a < 2 ? \"\" : \"\\n  fn get_\".concat(e1, \"ByIndices(indices: \").concat(h.indices, \") -> \").concat(m, \" {\\n    return \").concat(Q(\"i2o_\".concat(e1, \"(indices)\")), \";\\n  }\"), Y = a < 2 ? \"\" : (()=>{\n            let W = d.map((he)=>\"d\".concat(he, \": u32\")).join(\", \"), q = d.map((he)=>\"d\".concat(he)).join(\", \");\n            return \"\\n  fn get_\".concat(e1, \"(\").concat(W, \") -> \").concat(m, \" {\\n    return get_\").concat(e1, \"ByIndices(\").concat(D(q), \");\\n  }\");\n        })(), ee = function() {\n            for(var _len = arguments.length, W = new Array(_len), _key = 0; _key < _len; _key++){\n                W[_key] = arguments[_key];\n            }\n            if (W.length !== a) throw new Error(\"indices length must be \".concat(a));\n            let q = W.map(_).join(\",\");\n            return a === 0 ? Q(\"0u\") : a === 1 ? Q(q[0]) : (y.get = !0, y.getByIndices = !0, y.indicesToOffset = !0, \"get_\".concat(e1, \"(\").concat(q, \")\"));\n        }, J = (W)=>a < 2 ? Q(W) : (y.getByIndices = !0, y.indicesToOffset = !0, \"get_\".concat(e1, \"ByIndices(\").concat(W, \")\")), ne = a < 2 ? \"\" : \"\\n  fn set_\".concat(e1, \"ByIndices(indices: \").concat(h.indices, \", value: \").concat(m, \") {\\n    \").concat(V(\"i2o_\".concat(e1, \"(indices)\"), \"value\"), \"\\n  }\"), be = a < 2 ? \"\" : (()=>{\n            let W = d.map((he)=>\"d\".concat(he, \": u32\")).join(\", \"), q = d.map((he)=>\"d\".concat(he)).join(\", \");\n            return \"\\n  fn set_\".concat(e1, \"(\").concat(W, \", value: \").concat(m, \") {\\n    set_\").concat(e1, \"ByIndices(\").concat(D(q), \", value);\\n  }\");\n        })();\n        return {\n            impl: ()=>{\n                let W = [], q = !1;\n                return y.offsetToIndices && (W.push(S), q = !0), y.indicesToOffset && (W.push(k), q = !0), y.broadcastedIndicesToOffset && (Object.values(K).forEach((he)=>W.push(he)), q = !0), y.set && (W.push(be), q = !0), y.setByIndices && (W.push(ne), q = !0), y.get && (W.push(Y), q = !0), y.getByIndices && (W.push(se), q = !0), !i && q && W.unshift(\"const \".concat(x, \" = \").concat(h.indices, \"(\").concat(r.join(\",\"), \");\"), \"const \".concat($, \" = \").concat(h.indices, \"(\").concat(C.computeStrides(r).join(\",\"), \");\")), W.join(\"\\n\");\n            },\n            type: h,\n            offsetToIndices: T,\n            indicesToOffset: P,\n            broadcastedIndicesToOffset: j,\n            indices: D,\n            indicesGet: R,\n            indicesSet: G,\n            set: function() {\n                for(var _len = arguments.length, W = new Array(_len), _key = 0; _key < _len; _key++){\n                    W[_key] = arguments[_key];\n                }\n                if (W.length !== a + 1) throw new Error(\"indices length must be \".concat(a));\n                let q = W[a];\n                if (typeof q != \"string\") throw new Error(\"value must be string\");\n                let he = W.slice(0, a).map(_).join(\",\");\n                return a === 0 ? V(\"0u\", q) : a === 1 ? V(he[0], q) : (y.set = !0, y.setByIndices = !0, y.indicesToOffset = !0, \"set_\".concat(e1, \"(\").concat(he, \", \").concat(q, \")\"));\n            },\n            setByOffset: V,\n            setByIndices: (W, q)=>a < 2 ? V(W, q) : (y.setByIndices = !0, y.indicesToOffset = !0, \"set_\".concat(e1, \"ByIndices(\").concat(W, \", \").concat(q, \");\")),\n            get: ee,\n            getByOffset: Q,\n            getByIndices: J,\n            usage: n,\n            name: e1,\n            strides: $,\n            shape: x,\n            rank: a\n        };\n    }, E = function(e1, t, r) {\n        let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;\n        return Wr(e1, t, r, \"input\", n);\n    }, M = function(e1, t, r) {\n        let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;\n        return Wr(e1, t, r, \"output\", n);\n    }, rs = (e1, t, r)=>Wr(e1, t, r, \"atomicOutput\", 1), Lr = function(e1, t, r) {\n        let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;\n        return Wr(e1, t, r, \"internal\", n);\n    }, ao = class {\n        guardAgainstOutOfBoundsWorkgroupSizes(t) {\n            return \"if (global_idx >= \".concat(typeof t == \"number\" ? \"\".concat(t, \"u\") : t, \") { return; }\");\n        }\n        mainStart() {\n            let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : kt;\n            let r = typeof t == \"number\" ? t : t[0], n = typeof t == \"number\" ? 1 : t[1], o = typeof t == \"number\" ? 1 : t[2];\n            if (r > this.limits.maxComputeWorkgroupSizeX || n > this.limits.maxComputeWorkgroupSizeY || o > this.limits.maxComputeWorkgroupSizeZ) throw new Error(\"workgroup size [\".concat(r, \", \").concat(n, \", \").concat(o, \"] exceeds the maximum workgroup size [\").concat(this.limits.maxComputeWorkgroupSizeX, \", \").concat(this.limits.maxComputeWorkgroupSizeY, \", \").concat(this.limits.maxComputeWorkgroupSizeZ, \"].\"));\n            if (r * n * o > this.limits.maxComputeInvocationsPerWorkgroup) throw new Error(\"workgroup size [\".concat(r, \", \").concat(n, \", \").concat(o, \"] exceeds the maximum workgroup invocations \").concat(this.limits.maxComputeInvocationsPerWorkgroup, \".\"));\n            let i = this.normalizedDispatchGroup[1] === 1 && this.normalizedDispatchGroup[2] === 1, a = i ? \"@builtin(global_invocation_id) global_id : vec3<u32>,\\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\\n    @builtin(local_invocation_index) local_idx : u32,\\n    @builtin(local_invocation_id) local_id : vec3<u32>\" : \"@builtin(global_invocation_id) global_id : vec3<u32>,\\n                                             @builtin(local_invocation_id) local_id : vec3<u32>,\\n    @builtin(local_invocation_index) local_idx : u32,\\n    @builtin(workgroup_id) workgroup_id : vec3<u32>,\\n    @builtin(num_workgroups) num_workgroups : vec3<u32>\", d = i ? \"let global_idx = global_id.x;\\n         let workgroup_index = workgroup_id.x;\" : \"let workgroup_index = workgroup_id.z * num_workgroups[0] * num_workgroups[1] +\\n             workgroup_id.y * num_workgroups[0] + workgroup_id.x;\\n         let global_idx = workgroup_index * \".concat(r * n * o, \"u + local_idx;\");\n            return \"@compute @workgroup_size(\".concat(r, \", \").concat(n, \", \").concat(o, \")\\n  fn main(\").concat(a, \") {\\n    \").concat(d, \"\\n  \");\n        }\n        appendVariableUniforms(t) {\n            t.rank !== 0 && (t.shape.startsWith(\"uniforms.\") && this.uniforms.push({\n                name: t.shape.replace(\"uniforms.\", \"\"),\n                type: \"u32\",\n                length: t.rank\n            }), t.strides.startsWith(\"uniforms.\") && this.uniforms.push({\n                name: t.strides.replace(\"uniforms.\", \"\"),\n                type: \"u32\",\n                length: t.rank\n            }));\n        }\n        declareVariable(t, r) {\n            if (t.usage === \"internal\") throw new Error(\"cannot use internal variable with declareVariable(). use registerInternalVariables() instead.\");\n            this.variables.push(t), this.appendVariableUniforms(t);\n            let n = t.usage === \"input\" ? \"read\" : \"read_write\", o = t.usage === \"atomicOutput\" ? \"atomic<i32>\" : t.type.storage;\n            return \"@group(0) @binding(\".concat(r, \") var<storage, \").concat(n, \"> \").concat(t.name, \": array<\").concat(o, \">;\");\n        }\n        declareVariables() {\n            for(var _len = arguments.length, t = new Array(_len), _key = 0; _key < _len; _key++){\n                t[_key] = arguments[_key];\n            }\n            return t.map((r)=>this.declareVariable(r, this.variableIndex++)).join(\"\\n\");\n        }\n        registerInternalVariable(t) {\n            if (t.usage !== \"internal\") throw new Error(\"cannot use input or output variable with registerInternalVariable(). use declareVariables() instead.\");\n            this.internalVariables.push(t), this.appendVariableUniforms(t);\n        }\n        registerInternalVariables() {\n            for(var _len = arguments.length, t = new Array(_len), _key = 0; _key < _len; _key++){\n                t[_key] = arguments[_key];\n            }\n            return t.forEach((r)=>this.registerInternalVariable(r)), this;\n        }\n        registerUniform(t, r) {\n            let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;\n            return this.uniforms.push({\n                name: t,\n                type: r,\n                length: n\n            }), this;\n        }\n        registerUniforms(t) {\n            return this.uniforms = this.uniforms.concat(t), this;\n        }\n        uniformDeclaration() {\n            if (this.uniforms.length === 0) return \"\";\n            let t = [];\n            for (let { name: r, type: n, length: o } of this.uniforms)if (o && o > 4) n === \"f16\" ? t.push(\"@align(16) \".concat(r, \":array<mat2x4<\").concat(n, \">, \").concat(Math.ceil(o / 8), \">\")) : t.push(\"\".concat(r, \":array<vec4<\").concat(n, \">, \").concat(Math.ceil(o / 4), \">\"));\n            else {\n                let i = o == null || o === 1 ? n : \"vec\".concat(o, \"<\").concat(n, \">\");\n                t.push(\"\".concat(r, \":\").concat(i));\n            }\n            return \"\\n      struct Uniforms { \".concat(t.join(\", \"), \" };\\n      @group(0) @binding(\").concat(this.variableIndex, \") var<uniform> uniforms: Uniforms;\");\n        }\n        get additionalImplementations() {\n            return this.uniformDeclaration() + this.variables.map((t)=>t.impl()).join(\"\\n\") + this.internalVariables.map((t)=>t.impl()).join(\"\\n\");\n        }\n        get variablesInfo() {\n            if (this.uniforms.length === 0) return;\n            let t = (r)=>[\n                    12,\n                    10,\n                    1,\n                    6\n                ][[\n                    \"u32\",\n                    \"f16\",\n                    \"f32\",\n                    \"i32\"\n                ].indexOf(r)];\n            return this.uniforms.map((r)=>{\n                var _r_length;\n                return [\n                    t(r.type),\n                    (_r_length = r.length) !== null && _r_length !== void 0 ? _r_length : 1\n                ];\n            });\n        }\n        constructor(t, r){\n            this.normalizedDispatchGroup = t;\n            this.limits = r;\n            this.internalVariables = [];\n            this.variables = [];\n            this.uniforms = [];\n            this.variableIndex = 0;\n        }\n    }, ns = (e1, t)=>new ao(e1, t);\n});\nvar dm, os, lm, cm, pm, mm, Pe, is, as, dt = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    dm = (e1, t)=>{\n        if (!e1 || e1.length !== 1) throw new Error(\"Transpose requires 1 input.\");\n        if (t.length !== 0 && t.length !== e1[0].dims.length) throw new Error(\"perm size \".concat(t.length, \" does not match input rank \").concat(e1[0].dims.length));\n    }, os = (e1, t)=>t.length !== 0 ? t : [\n            ...new Array(e1).keys()\n        ].reverse(), lm = (e1, t)=>C.sortBasedOnPerm(e1, os(e1.length, t)), cm = (e1, t, r, n)=>{\n        let o = \"fn perm(i: \".concat(n.type.indices, \") -> \").concat(r.type.indices, \" {\\n    var a: \").concat(r.type.indices, \";\");\n        for(let i = 0; i < t; ++i)o += \"a[\".concat(e1[i], \"]=i[\").concat(i, \"];\");\n        return o += \"return a;}\";\n    }, pm = (e1, t)=>{\n        let r = [], n = [];\n        for(let o = 0; o < e1.length; ++o)e1[o] !== 1 && r.push(e1[o]), e1[t[o]] !== 1 && n.push(t[o]);\n        return {\n            newShape: r,\n            newPerm: n\n        };\n    }, mm = (e1, t)=>{\n        let r = 0;\n        for(let n = 0; n < e1.length; ++n)if (t[e1[n]] !== 1) {\n            if (e1[n] < r) return !1;\n            r = e1[n];\n        }\n        return !0;\n    }, Pe = (e1, t)=>{\n        let r = e1.dataType, n = e1.dims.length, o = os(n, t), i = lm(e1.dims, o), a = e1.dims, d = i, l = n < 2 || mm(o, e1.dims), p;\n        if (l) return p = (g)=>{\n            let x = E(\"input\", r, a, 4), $ = M(\"output\", r, d, 4);\n            return \"\\n  \".concat(g.registerUniform(\"output_size\", \"u32\").declareVariables(x, $), \"\\n  \").concat(g.mainStart(), \"\\n    \").concat(g.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\"), \"\\n    output[global_idx] = input[global_idx];\\n  }\");\n        }, {\n            name: \"TransposeCopy\",\n            shaderCache: {\n                inputDependencies: [\n                    \"type\"\n                ]\n            },\n            getRunData: ()=>{\n                let g = C.size(i);\n                return {\n                    outputs: [\n                        {\n                            dims: i,\n                            dataType: e1.dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(g / 64 / 4)\n                    },\n                    programUniforms: [\n                        {\n                            type: 12,\n                            data: Math.ceil(g / 4)\n                        }\n                    ]\n                };\n            },\n            getShaderSource: p\n        };\n        let { newShape: m, newPerm: u } = pm(e1.dims, o), h = C.areEqual(u, [\n            2,\n            3,\n            1\n        ]), _ = C.areEqual(u, [\n            3,\n            1,\n            2\n        ]);\n        if (m.length === 2 || h || _) {\n            a = h ? [\n                m[0],\n                m[1] * m[2]\n            ] : _ ? [\n                m[0] * m[1],\n                m[2]\n            ] : m, d = [\n                a[1],\n                a[0]\n            ];\n            let g = 16;\n            return p = (x)=>{\n                let $ = E(\"a\", r, a.length), v = M(\"output\", r, d.length);\n                return \"\\n  \".concat(x.registerUniform(\"output_size\", \"u32\").declareVariables($, v), \"\\n  var<workgroup> tile : array<array<\").concat(v.type.value, \", \").concat(g + 1, \">, \").concat(g, \">;\\n  \").concat(x.mainStart([\n                    g,\n                    g,\n                    1\n                ]), \"\\n    let stride = (uniforms.output_shape[1] - 1) / \").concat(g, \" + 1;\\n    let workgroup_id_x = workgroup_index % stride;\\n    let workgroup_id_y = workgroup_index / stride;\\n    let input_col = workgroup_id_y * \").concat(g, \"u + local_id.x;\\n    let input_row = workgroup_id_x * \").concat(g, \"u + local_id.y;\\n    if (input_row < uniforms.a_shape[0] && input_col < uniforms.a_shape[1]) {\\n      tile[local_id.y][local_id.x] = \").concat($.getByIndices(\"\".concat($.type.indices, \"(input_row, input_col)\")), \";\\n    }\\n    workgroupBarrier();\\n\\n    let output_col = workgroup_id_x * \").concat(g, \"u + local_id.x;\\n    let output_row = workgroup_id_y * \").concat(g, \"u + local_id.y;\\n    if (output_row < uniforms.output_shape[0] && output_col < uniforms.output_shape[1]) {\\n      \").concat(v.setByIndices(\"\".concat(v.type.indices, \"(output_row, output_col)\"), \"tile[local_id.x][local_id.y]\"), \"\\n    }\\n  }\");\n            }, {\n                name: \"TransposeShared\",\n                shaderCache: {\n                    inputDependencies: [\n                        \"type\"\n                    ]\n                },\n                getRunData: ()=>{\n                    let x = C.size(i);\n                    return {\n                        outputs: [\n                            {\n                                dims: i,\n                                dataType: e1.dataType\n                            }\n                        ],\n                        dispatchGroup: {\n                            x: Math.ceil(d[1] / g),\n                            y: Math.ceil(d[0] / g)\n                        },\n                        programUniforms: [\n                            {\n                                type: 12,\n                                data: x\n                            },\n                            ...N(a, d)\n                        ]\n                    };\n                },\n                getShaderSource: p\n            };\n        }\n        return p = (g)=>{\n            let x = E(\"a\", r, a.length), $ = M(\"output\", r, d.length);\n            return \"\\n  \".concat(g.registerUniform(\"output_size\", \"u32\").declareVariables(x, $), \"\\n\\n  \").concat(cm(o, n, x, $), \"\\n\\n  \").concat(g.mainStart(), \"\\n    \").concat(g.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\"), \"\\n\\n    let indices = \").concat($.offsetToIndices(\"global_idx\"), \";\\n    let aIndices = perm(indices);\\n\\n    \").concat($.setByOffset(\"global_idx\", x.getByIndices(\"aIndices\")), \"\\n  }\");\n        }, {\n            name: \"Transpose\",\n            shaderCache: {\n                hint: \"\".concat(t),\n                inputDependencies: [\n                    \"rank\"\n                ]\n            },\n            getRunData: ()=>{\n                let g = C.size(i);\n                return {\n                    outputs: [\n                        {\n                            dims: i,\n                            dataType: e1.dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(g / 64)\n                    },\n                    programUniforms: [\n                        {\n                            type: 12,\n                            data: g\n                        },\n                        ...N(a, d)\n                    ]\n                };\n            },\n            getShaderSource: p\n        };\n    }, is = (e1, t)=>{\n        dm(e1.inputs, t.perm), e1.compute(Pe(e1.inputs[0], t.perm));\n    }, as = (e1)=>re({\n            perm: e1.perm\n        });\n});\nvar fm, hm, gm, bm, ym, _m, wm, vm, $m, xm, rt, ss, us, ds, ls, cs, ps, ms, fs, hs, gs, bs = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    ae();\n    Gr();\n    dt();\n    fm = {\n        max: \"select(bestValue, candidate, candidate > bestValue)\",\n        min: \"select(bestValue, candidate, candidate < bestValue)\",\n        mean: \"bestValue + candidate\",\n        sum: \"bestValue + candidate\",\n        prod: \"bestValue * candidate\",\n        sumSquare: \"bestValue + candidate * candidate\",\n        logSumExp: \"bestValue + exp(candidate)\",\n        l1: \"bestValue + abs(candidate)\",\n        l2: \"bestValue + candidate * candidate\",\n        logSum: \"bestValue + candidate\"\n    }, hm = {\n        max: \"select(bestValue, candidate, candidate > bestValue)\",\n        min: \"select(bestValue, candidate, candidate < bestValue)\",\n        mean: \"bestValue + candidate\",\n        sum: \"bestValue + candidate\",\n        prod: \"bestValue * candidate\",\n        sumSquare: \"bestValue + candidate\",\n        logSumExp: \"bestValue + candidate\",\n        l1: \"bestValue + candidate\",\n        l2: \"bestValue + candidate\",\n        logSum: \"bestValue + candidate\"\n    }, gm = {\n        max: \"_A[offset]\",\n        min: \"_A[offset]\",\n        mean: \"0\",\n        sum: \"0\",\n        prod: \"1\",\n        sumSquare: \"0\",\n        logSumExp: \"0\",\n        l1: \"0\",\n        l2: \"0\",\n        logSum: \"0\"\n    }, bm = {\n        max: \"bestValue\",\n        min: \"bestValue\",\n        sum: \"bestValue\",\n        prod: \"bestValue\",\n        sumSquare: \"bestValue\",\n        logSumExp: \"log(bestValue)\",\n        l1: \"bestValue\",\n        l2: \"sqrt(bestValue)\",\n        logSum: \"log(bestValue)\"\n    }, ym = (e1, t)=>{\n        let r = [];\n        for(let n = t - e1; n < t; ++n)r.push(n);\n        return r;\n    }, _m = (e1, t)=>{\n        let r = [], n = e1.length;\n        for(let i = 0; i < n; i++)t.indexOf(i) === -1 && r.push(e1[i]);\n        let o = t.map((i)=>e1[i]);\n        return [\n            r,\n            o\n        ];\n    }, wm = (e1, t)=>{\n        let r = e1.length + t.length, n = [], o = 0;\n        for(let i = 0; i < r; i++)t.indexOf(i) === -1 ? n.push(e1[o++]) : n.push(1);\n        return n;\n    }, vm = (e1, t)=>{\n        for(let r = 0; r < e1.length; ++r)if (e1[e1.length - r - 1] !== t - 1 - r) return !1;\n        return !0;\n    }, $m = (e1, t)=>{\n        let r = [];\n        if (!vm(e1, t)) {\n            for(let n = 0; n < t; ++n)e1.indexOf(n) === -1 && r.push(n);\n            e1.forEach((n)=>r.push(n));\n        }\n        return r;\n    }, xm = (e1, t, r, n, o, i, a)=>{\n        let d = r[0].dims, l = C.size(i), p = C.size(a), m = E(\"_A\", r[0].dataType, d), u = M(\"output\", o, i), h = 64;\n        l === 1 && (h = 256);\n        let _ = \"\\n          var<workgroup> aBestValues : array<f32, \".concat(h, \">;\\n       \"), y = (g)=>\"\\n        \".concat(g.registerUniform(\"reduceSize\", \"u32\").declareVariables(m, u), \"\\n        \").concat(_, \"\\n        fn DIV_CEIL(a : u32, b : u32) -> u32 {\\n          return ((a - 1u) / b + 1u);\\n         }\\n         \").concat(g.mainStart(h), \"\\n\\n          let outputIndex = global_idx / \").concat(h, \";\\n          let offset = outputIndex * uniforms.reduceSize;\\n\\n          var bestValue = f32(\").concat(gm[n], \");\\n          let Length = uniforms.reduceSize;\\n          for (var k = local_idx; k < Length; k = k + \").concat(h, \") {\\n           let candidate = f32(\").concat(m.getByOffset(\"offset + k\"), \");\\n           bestValue = \").concat(fm[n], \";\\n          }\\n          aBestValues[local_idx] = bestValue;\\n          workgroupBarrier();\\n\\n         var reduceSize = min(Length, \").concat(h, \"u);\\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\\n             currentSize = reduceSize / 2u) {\\n           let interval = DIV_CEIL(reduceSize, 2u);\\n           if (local_idx < currentSize) {\\n            let candidate = aBestValues[local_idx + interval];\\n            bestValue = \").concat(hm[n], \";\\n            aBestValues[local_idx] = bestValue;\\n           }\\n           reduceSize = interval;\\n           workgroupBarrier();\\n         }\\n\\n         if (local_idx == 0u) {\\n          \").concat(u.setByOffset(\"outputIndex\", \"\".concat(n === \"mean\" ? \"\".concat(u.type.storage, \"(bestValue / f32(uniforms.reduceSize))\") : \"\".concat(u.type.storage, \"(\").concat(bm[n], \")\"))), \";\\n         }\\n        }\");\n        return {\n            name: e1,\n            shaderCache: {\n                hint: \"\".concat(t, \";\").concat(h),\n                inputDependencies: [\n                    \"type\"\n                ]\n            },\n            getShaderSource: y,\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: i,\n                            dataType: o\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: l\n                    },\n                    programUniforms: [\n                        {\n                            type: 12,\n                            data: p\n                        }\n                    ]\n                })\n        };\n    }, rt = (e1, t, r, n)=>{\n        let o = e1.inputs.length === 1 ? r : lo(e1.inputs, r), i = o.axes;\n        i.length === 0 && !o.noopWithEmptyAxes && (i = e1.inputs[0].dims.map((_, y)=>y));\n        let a = C.normalizeAxes(i, e1.inputs[0].dims.length), d = a, l = e1.inputs[0], p = $m(d, e1.inputs[0].dims.length);\n        p.length > 0 && (l = e1.compute(Pe(e1.inputs[0], p), {\n            inputs: [\n                0\n            ],\n            outputs: [\n                -1\n            ]\n        })[0], d = ym(d.length, l.dims.length));\n        let [m, u] = _m(l.dims, d), h = m;\n        o.keepDims && (h = wm(m, a)), e1.compute(xm(t, o.cacheKey, [\n            l\n        ], n, e1.inputs[0].dataType, h, u), {\n            inputs: [\n                l\n            ]\n        });\n    }, ss = (e1, t)=>{\n        rt(e1, \"ReduceMeanShared\", t, \"mean\");\n    }, us = (e1, t)=>{\n        rt(e1, \"ReduceL1Shared\", t, \"l1\");\n    }, ds = (e1, t)=>{\n        rt(e1, \"ReduceL2Shared\", t, \"l2\");\n    }, ls = (e1, t)=>{\n        rt(e1, \"ReduceLogSumExpShared\", t, \"logSumExp\");\n    }, cs = (e1, t)=>{\n        rt(e1, \"ReduceMaxShared\", t, \"max\");\n    }, ps = (e1, t)=>{\n        rt(e1, \"ReduceMinShared\", t, \"min\");\n    }, ms = (e1, t)=>{\n        rt(e1, \"ReduceProdShared\", t, \"prod\");\n    }, fs = (e1, t)=>{\n        rt(e1, \"ReduceSumShared\", t, \"sum\");\n    }, hs = (e1, t)=>{\n        rt(e1, \"ReduceSumSquareShared\", t, \"sumSquare\");\n    }, gs = (e1, t)=>{\n        rt(e1, \"ReduceLogSumShared\", t, \"logSum\");\n    };\n});\nvar nt, Sm, Hr, lo, ot, Tm, Im, Cm, Am, km, Em, Pm, zm, Om, Dm, it, ys, _s, ws, vs, $s, xs, Ss, Ts, Is, Cs, Gr = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    bs();\n    nt = (e1)=>{\n        if (!e1 || e1.length === 0 || e1.length > 2) throw new Error(\"Reduce op requires 1 or 2 inputs.\");\n        if (e1.length === 2 && e1[1].dims.length !== 1) throw new Error(\"Invalid axes input dims.\");\n    }, Sm = (e1)=>[\n            \"\",\n            \"\",\n            \"var value = \".concat(e1.getByIndices(\"input_indices\"), \";\"),\n            \"\"\n        ], Hr = function(e1, t, r, n, o, i) {\n        let a = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : !1, d = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : !1;\n        let l = [], p = r[0].dims, m = p.length, u = C.normalizeAxes(o, m), h = !d && u.length === 0;\n        p.forEach((x, $)=>{\n            h || u.indexOf($) >= 0 ? a && l.push(1) : l.push(x);\n        });\n        let _ = l.length, y = C.size(l);\n        return {\n            name: e1,\n            shaderCache: t,\n            getShaderSource: (x)=>{\n                let $ = [], v = E(\"_A\", r[0].dataType, m), S = M(\"output\", i, _), T = n(v, S, u), A = T[2];\n                for(let k = 0, P = 0; k < m; k++)h || u.indexOf(k) >= 0 ? (a && P++, A = \"for(var j\".concat(k, \": u32 = 0; j\").concat(k, \" < \").concat(p[k], \"; j\").concat(k, \"++) {\\n                  \").concat(T[2].includes(\"last_index\") ? \"let last_index = j\".concat(k, \";\") : \"\", \"\\n                  \").concat(v.indicesSet(\"input_indices\", k, \"j\".concat(k)), \"\\n                  \").concat(A, \"\\n                }\")) : ($.push(\"\".concat(v.indicesSet(\"input_indices\", k, S.indicesGet(\"output_indices\", P)), \";\")), P++);\n                return \"\\n\\n        \".concat(x.registerUniform(\"output_size\", \"u32\").declareVariables(v, S), \"\\n\\n        \").concat(x.mainStart(), \"\\n          \").concat(x.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\"), \"\\n          var input_indices: \").concat(v.type.indices, \";\\n          let output_indices = \").concat(S.offsetToIndices(\"global_idx\"), \";\\n\\n          \").concat($.join(\"\\n\"), \"\\n          \").concat(T[0], \"       // init ops for reduce max/min\\n          \").concat(T[1], \"\\n          \").concat(A, \"\\n          \").concat(T[3], \"\\n          \").concat(T.length === 4 ? S.setByOffset(\"global_idx\", \"value\") : T.slice(4).join(\"\\n\"), \"\\n        }\");\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: l,\n                            dataType: i\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(y / 64)\n                    },\n                    programUniforms: [\n                        {\n                            type: 12,\n                            data: y\n                        },\n                        ...N(p, l)\n                    ]\n                })\n        };\n    }, lo = (e1, t)=>{\n        let r = [];\n        return e1[1].dims[0] > 0 && e1[1].getBigInt64Array().forEach((n)=>r.push(Number(n))), re({\n            axes: r,\n            keepDims: t.keepDims,\n            noopWithEmptyAxes: t.noopWithEmptyAxes\n        });\n    }, ot = (e1, t, r, n)=>{\n        let o = e1.inputs, i = o.length === 1 ? r : lo(o, r);\n        e1.compute(Hr(t, {\n            hint: i.cacheKey,\n            inputDependencies: [\n                \"rank\"\n            ]\n        }, [\n            o[0]\n        ], i.noopWithEmptyAxes && i.axes.length === 0 ? Sm : n, i.axes, o[0].dataType, i.keepDims, i.noopWithEmptyAxes), {\n            inputs: [\n                0\n            ]\n        });\n    }, Tm = (e1, t)=>{\n        nt(e1.inputs), ot(e1, \"ReduceLogSum\", t, (n, o)=>[\n                \"var value = \".concat(o.type.storage, \"(0);\"),\n                \"\",\n                \"value += \".concat(n.getByIndices(\"input_indices\"), \";\"),\n                \"value = log(value);\"\n            ]);\n    }, Im = (e1, t)=>{\n        nt(e1.inputs), ot(e1, \"ReduceL1\", t, (n, o)=>[\n                \"var value = \".concat(o.type.storage, \"(0);\"),\n                \"\",\n                \"value += abs(\".concat(n.getByIndices(\"input_indices\"), \");\"),\n                \"\"\n            ]);\n    }, Cm = (e1, t)=>{\n        nt(e1.inputs), ot(e1, \"ReduceL2\", t, (n, o)=>[\n                \"var t = \".concat(o.type.value, \"(0); var value = \").concat(o.type.value, \"(0);\"),\n                \"\",\n                \"t = \".concat(n.getByIndices(\"input_indices\"), \"; value += (t * t);\"),\n                \"value = sqrt(value);\"\n            ]);\n    }, Am = (e1, t)=>{\n        nt(e1.inputs), ot(e1, \"ReduceLogSumExp\", t, (n, o)=>[\n                \"var value = \".concat(o.type.storage, \"(0);\"),\n                \"\",\n                \"value += exp(\".concat(n.getByIndices(\"input_indices\"), \");\"),\n                \"value = log(value);\"\n            ]);\n    }, km = (e1, t)=>{\n        nt(e1.inputs), ot(e1, \"ReduceMax\", t, (n, o, i)=>{\n            let a = [];\n            for(let d = 0; d < n.rank; d++)(i.indexOf(d) >= 0 || i.length === 0) && a.push(n.indicesSet(\"input_indices\", d, 0));\n            return [\n                \"\".concat(a.join(\"\\n\")),\n                \"var value = \".concat(n.getByIndices(\"input_indices\"), \";\"),\n                \"value = max(value, \".concat(n.getByIndices(\"input_indices\"), \");\"),\n                \"\"\n            ];\n        });\n    }, Em = (e1, t)=>{\n        nt(e1.inputs), ot(e1, \"ReduceMean\", t, (n, o, i)=>{\n            let a = 1;\n            for(let d = 0; d < n.rank; d++)(i.indexOf(d) >= 0 || i.length === 0) && (a *= e1.inputs[0].dims[d]);\n            return [\n                \"var sum = f32(0);\",\n                \"\",\n                \"sum += f32(\".concat(n.getByIndices(\"input_indices\"), \");\"),\n                \"let value = \".concat(o.type.value, \"(sum / \").concat(a, \");\")\n            ];\n        });\n    }, Pm = (e1, t)=>{\n        nt(e1.inputs), ot(e1, \"ReduceMin\", t, (n, o, i)=>{\n            let a = [];\n            for(let d = 0; d < n.rank; d++)(i.indexOf(d) >= 0 || i.length === 0) && a.push(\"input_indices[\".concat(d, \"] = 0;\"));\n            return [\n                \"\".concat(a.join(\"\\n\")),\n                \"var value = \".concat(n.getByIndices(\"input_indices\"), \";\"),\n                \"value = min(value, \".concat(n.getByIndices(\"input_indices\"), \");\"),\n                \"\"\n            ];\n        });\n    }, zm = (e1, t)=>{\n        nt(e1.inputs), ot(e1, \"ReduceProd\", t, (n, o)=>[\n                \"var value = \".concat(o.type.storage, \"(1);\"),\n                \"\",\n                \"value *= \".concat(n.getByIndices(\"input_indices\"), \";\"),\n                \"\"\n            ]);\n    }, Om = (e1, t)=>{\n        nt(e1.inputs), ot(e1, \"ReduceSum\", t, (n, o)=>[\n                \"var value = \".concat(o.type.storage, \"(0);\"),\n                \"\",\n                \"value += \".concat(n.getByIndices(\"input_indices\"), \";\"),\n                \"\"\n            ]);\n    }, Dm = (e1, t)=>{\n        nt(e1.inputs), ot(e1, \"ReduceSumSquare\", t, (n, o)=>[\n                \"var t = \".concat(o.type.value, \"(0); var value = \").concat(o.type.value, \"(0);\"),\n                \"\",\n                \"t = \".concat(n.getByIndices(\"input_indices\"), \"; value += t * t;\"),\n                \"\"\n            ]);\n    }, it = (e1, t, r)=>{\n        if (t.length === 0) return r;\n        let n = 1, o = 1;\n        for(let i = 0; i < t.length; i++)t.indexOf(i) === -1 ? n *= e1[i] : o *= e1[i];\n        return o < 32 && n > 1024;\n    }, ys = (e1, t)=>{\n        it(e1.inputs[0].dims, t.axes, t.noopWithEmptyAxes) ? Em(e1, t) : ss(e1, t);\n    }, _s = (e1, t)=>{\n        it(e1.inputs[0].dims, t.axes, t.noopWithEmptyAxes) ? Im(e1, t) : us(e1, t);\n    }, ws = (e1, t)=>{\n        it(e1.inputs[0].dims, t.axes, t.noopWithEmptyAxes) ? Cm(e1, t) : ds(e1, t);\n    }, vs = (e1, t)=>{\n        it(e1.inputs[0].dims, t.axes, t.noopWithEmptyAxes) ? Am(e1, t) : ls(e1, t);\n    }, $s = (e1, t)=>{\n        it(e1.inputs[0].dims, t.axes, t.noopWithEmptyAxes) ? km(e1, t) : cs(e1, t);\n    }, xs = (e1, t)=>{\n        it(e1.inputs[0].dims, t.axes, t.noopWithEmptyAxes) ? Pm(e1, t) : ps(e1, t);\n    }, Ss = (e1, t)=>{\n        it(e1.inputs[0].dims, t.axes, t.noopWithEmptyAxes) ? zm(e1, t) : ms(e1, t);\n    }, Ts = (e1, t)=>{\n        it(e1.inputs[0].dims, t.axes, t.noopWithEmptyAxes) ? Om(e1, t) : fs(e1, t);\n    }, Is = (e1, t)=>{\n        it(e1.inputs[0].dims, t.axes, t.noopWithEmptyAxes) ? Dm(e1, t) : hs(e1, t);\n    }, Cs = (e1, t)=>{\n        it(e1.inputs[0].dims, t.axes, t.noopWithEmptyAxes) ? Tm(e1, t) : gs(e1, t);\n    };\n});\nvar As, ks, Es, co, Ps = U(()=>{\n    \"use strict\";\n    te();\n    Se();\n    Gr();\n    As = (e1)=>{\n        if (!e1 || e1.length === 0 || e1.length > 2) throw new Error(\"ArgMinMaxOp op requires 1 or 2 inputs.\");\n        if (e1[0].dataType !== 1) throw new Error(\"Invalid input type.\");\n    }, ks = (e1, t)=>{\n        As(e1.inputs);\n        let r = (n, o, i)=>{\n            let a = [];\n            for(let d = 0; d < n.rank; d++)(i.indexOf(d) >= 0 || i.length === 0) && a.push(\"input_indices[\".concat(d, \"] = 0;\"));\n            return [\n                \"\".concat(a.join(\"\\n\")),\n                \"var value = \".concat(n.getByIndices(\"input_indices\"), \";\\nvar best_index : i32 = 0;\"),\n                \"if (\".concat(n.getByIndices(\"input_indices\"), \" \").concat(t.selectLastIndex > 0 ? \"<=\" : \"<\", \" value) {\\n         value = \").concat(n.getByIndices(\"input_indices\"), \";\\n         best_index = i32(last_index);\\n       }\"),\n                \"\",\n                o.setByOffset(\"global_idx\", \"best_index\")\n            ];\n        };\n        e1.compute(Hr(\"ArgMin\", {\n            hint: t.cacheKey,\n            inputDependencies: [\n                \"rank\"\n            ]\n        }, [\n            e1.inputs[0]\n        ], r, [\n            t.axis\n        ], 7, t.keepDims), {\n            inputs: [\n                0\n            ]\n        });\n    }, Es = (e1, t)=>{\n        As(e1.inputs);\n        let r = (n, o, i)=>{\n            let a = [];\n            for(let d = 0; d < n.rank; d++)(i.indexOf(d) >= 0 || i.length === 0) && a.push(\"input_indices[\".concat(d, \"] = 0;\"));\n            return [\n                \"\".concat(a.join(\"\\n\")),\n                \"var value = \".concat(n.getByIndices(\"input_indices\"), \";\\nvar best_index : i32 = 0;\"),\n                \"if (\".concat(n.getByIndices(\"input_indices\"), \" \").concat(t.selectLastIndex > 0 ? \">=\" : \">\", \" value) {\\n         value = \").concat(n.getByIndices(\"input_indices\"), \";\\n         best_index = i32(last_index);\\n       }\"),\n                \"\",\n                o.setByOffset(\"global_idx\", \"best_index\")\n            ];\n        };\n        e1.compute(Hr(\"argMax\", {\n            hint: t.cacheKey,\n            inputDependencies: [\n                \"rank\"\n            ]\n        }, [\n            e1.inputs[0]\n        ], r, [\n            t.axis\n        ], 7, t.keepDims), {\n            inputs: [\n                0\n            ]\n        });\n    }, co = (e1)=>re(e1);\n});\nvar Bm, po, Mm, Rm, Um, Rt, Nm, zs, Fr = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Nr();\n    ae();\n    Bm = (e1, t)=>{\n        let r = e1[0], n = e1[1], o = e1[2], i = e1[3], a = e1[4], d = e1[5];\n        if (a && d) throw new Error(\"Attention cannot have both past and attention_bias\");\n        if (r.dims.length !== 3) throw new Error('Input \"input\" must have 3 dimensions');\n        let l = r.dims[0], p = r.dims[1], m = r.dims[2];\n        if (o.dims.length !== 1) throw new Error('Input \"bias\" is expected to have 1 dimensions');\n        if (n.dims.length !== 2) throw new Error('Input \"weights\" is expected to have 2 dimensions');\n        if (n.dims[0] !== m) throw new Error(\"Input 1 dimension 0 should have same length as dimension 2 of input 0\");\n        if (o.dims[0] !== n.dims[1]) throw new Error('Input \"bias\" dimension 0 should have same length as dimension 1 of input \"weights\"');\n        let u = o.dims[0] / 3, h = u, _ = h;\n        if (t.qkvHiddenSizes.length > 0) {\n            if (t.qkvHiddenSizes.length !== 3) throw new Error(\"qkv_hidden_sizes attribute should have 3 elements\");\n            for (let S of t.qkvHiddenSizes)if (S % t.numHeads !== 0) throw new Error(\"qkv_hidden_sizes should be divisible by num_heads\");\n            u = t.qkvHiddenSizes[0], h = t.qkvHiddenSizes[1], _ = t.qkvHiddenSizes[2];\n        }\n        let y = p;\n        if (u !== h) throw new Error(\"qkv_hidden_sizes first element should be same as the second\");\n        if (o.dims[0] !== u + h + _) throw new Error('Input \"bias\" dimension 0 should have same length as sum of Q/K/V hidden sizes');\n        let g = 0;\n        if (a) {\n            if (h !== _) throw new Error('Input \"past\" expect k_hidden_size == v_hidden_size');\n            if (a.dims.length !== 5) throw new Error('Input \"past\" must have 5 dimensions');\n            if (a.dims[0] !== 2) throw new Error('Input \"past\" first dimension must be 2');\n            if (a.dims[1] !== l) throw new Error('Input \"past\" second dimension must be batch_size');\n            if (a.dims[2] !== t.numHeads) throw new Error('Input \"past\" third dimension must be num_heads');\n            if (a.dims[4] !== h / t.numHeads) throw new Error('Input \"past\" fifth dimension must be k_hidden_size / num_heads');\n            t.pastPresentShareBuffer || (g = a.dims[3]);\n        }\n        let x = y + g, $ = -1, v = 0;\n        if (i) throw new Error(\"Mask not supported\");\n        if (a) throw new Error(\"past is not supported\");\n        if (d) {\n            if (d.dims.length !== 4) throw new Error('Input \"attention_bias\" must have 4 dimensions');\n            if (d.dims[0] !== l || d.dims[1] !== t.numHeads || d.dims[2] !== p || d.dims[3] !== x) throw new Error('Expect \"attention_bias\" shape (batch_size, num_heads, sequence_length, total_sequence_length)');\n        }\n        return {\n            batchSize: l,\n            sequenceLength: p,\n            pastSequenceLength: g,\n            kvSequenceLength: y,\n            totalSequenceLength: x,\n            maxSequenceLength: $,\n            inputHiddenSize: m,\n            hiddenSize: u,\n            vHiddenSize: _,\n            headSize: Math.floor(u / t.numHeads),\n            vHeadSize: Math.floor(_ / t.numHeads),\n            numHeads: t.numHeads,\n            isUnidirectional: !1,\n            pastPresentShareBuffer: !1,\n            maskFilterValue: t.maskFilterValue,\n            maskType: v,\n            scale: t.scale,\n            broadcastResPosBias: !1,\n            passPastInKv: !1,\n            qkvFormat: 1\n        };\n    }, po = (e1, t, r)=>t && e1 ? \"\\n      let total_sequence_length_input = u32(\".concat(t.getByOffset(\"0\"), \");\\n      let present_sequence_length = max(total_sequence_length_input, uniforms.past_sequence_length);\\n      let is_subsequent_prompt: bool = sequence_length > 1 && sequence_length != total_sequence_length_input;\\n      let is_first_prompt: bool = is_subsequent_prompt == false && sequence_length == total_sequence_length_input;\\n      total_sequence_length = u32(\").concat(e1 === null || e1 === void 0 ? void 0 : e1.getByOffset(\"batchIdx\"), \") + 1;\\n      var past_sequence_length: u32 = 0;\\n      if (is_first_prompt == false) {\\n        past_sequence_length = total_sequence_length - sequence_length;\\n      }\\n       \") : \"\\n    \".concat(r ? \"let past_sequence_length = uniforms.past_sequence_length\" : \"\", \";\\n    let present_sequence_length = total_sequence_length;\\n    \"), Mm = (e1, t, r, n, o, i, a, d)=>{\n        let l = me(a ? 1 : i), p = 64, m = i / l;\n        m < p && (p = 32);\n        let u = Math.ceil(i / l / p), h = [\n            {\n                type: 12,\n                data: t\n            },\n            {\n                type: 12,\n                data: r\n            },\n            {\n                type: 12,\n                data: n\n            },\n            {\n                type: 12,\n                data: o\n            },\n            {\n                type: 12,\n                data: m\n            },\n            {\n                type: 12,\n                data: u\n            }\n        ], _ = _e(e1.dataType, l), y = Ee(1, l), g = [\n            \"type\"\n        ];\n        a && g.push(\"type\"), d && g.push(\"type\");\n        let x = ($)=>{\n            let v = M(\"x\", e1.dataType, e1.dims, l), S = [\n                v\n            ], T = a ? E(\"seq_lens\", a.dataType, a.dims) : void 0;\n            T && S.push(T);\n            let A = d ? E(\"total_sequence_length_input\", d.dataType, d.dims) : void 0;\n            A && S.push(A);\n            let k = Ee(e1.dataType), P = [\n                {\n                    name: \"batch_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"num_heads\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"past_sequence_length\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"sequence_length\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"total_sequence_length\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"elements_per_thread\",\n                    type: \"u32\"\n                }\n            ];\n            return \"\\n  var<workgroup> thread_max: array<f32, \".concat(p, \">;\\n  var<workgroup> thread_sum: array<f32, \").concat(p, \">;\\n  \").concat($.registerUniforms(P).declareVariables(...S), \"\\n  \").concat($.mainStart([\n                p,\n                1,\n                1\n            ]), \"\\n    let batchIdx = workgroup_id.z / uniforms.num_heads;\\n    let headIdx = workgroup_id.z % uniforms.num_heads;\\n    let sequence_length = uniforms.sequence_length;\\n    var total_sequence_length = uniforms.total_sequence_length;\\n    \").concat(po(T, A, !1), \"\\n    let local_offset = local_idx * uniforms.elements_per_thread;\\n    let offset = (global_idx / \").concat(p, \") * uniforms.total_sequence_length + local_offset;\\n    let seq_causal_length = \").concat(a ? \"u32(past_sequence_length + workgroup_id.y + 1)\" : \"total_sequence_length\", \";\\n    var thread_max_vector = \").concat(y, \"(-3.402823e+38f);\\n    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\\n      thread_max_vector = max(\").concat(y, \"(x[offset + i]), thread_max_vector);\\n    }\\n    thread_max[local_idx] = \").concat((()=>{\n                switch(l){\n                    case 1:\n                        return \"thread_max_vector\";\n                    case 2:\n                        return \"max(thread_max_vector.x, thread_max_vector.y)\";\n                    case 4:\n                        return \"max(max(thread_max_vector.x, thread_max_vector.y), max(thread_max_vector.z, thread_max_vector.w))\";\n                    default:\n                        throw new Error(\"Unsupported components: \".concat(l));\n                }\n            })(), \";\\n    workgroupBarrier();\\n\\n    var max_value =  f32(-3.402823e+38f);\\n    for (var i = 0u; i < \").concat(p, \"; i++) {\\n      max_value = max(thread_max[i], max_value);\\n    }\\n\\n    var sum_vector = \").concat(y, \"(0);\\n    for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\\n      sum_vector += exp(\").concat(y, \"(x[offset + i]) - max_value);\\n    }\\n    thread_sum[local_idx] = \").concat((()=>{\n                switch(l){\n                    case 1:\n                        return \"sum_vector\";\n                    case 2:\n                        return \"sum_vector.x + sum_vector.y\";\n                    case 4:\n                        return \"sum_vector.x + sum_vector.y + sum_vector.z + sum_vector.w\";\n                    default:\n                        throw new Error(\"Unsupported components: \".concat(l));\n                }\n            })(), \";\\n    workgroupBarrier();\\n\\n    var sum: f32 = 0;\\n    for (var i = 0u; i < \").concat(p, \"; i++) {\\n      sum += thread_sum[i];\\n    }\\n\\n    if (sum == 0) {\\n      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\\n        x[offset + i] = \").concat(v.type.value, \"(\").concat(k, \"(1.0) / \").concat(k, \"(seq_causal_length));\\n      }\\n    } else {\\n      for (var i: u32 = 0; i < uniforms.elements_per_thread && i + local_offset < seq_causal_length; i++) {\\n        var f32input = \").concat(y, \"(x[offset + i]);\\n        x[offset + i] = \").concat(v.type.value, \"(exp(f32input - max_value) / sum);\\n      }\\n    }\\n      \").concat(a ? \"\\n        for (var total_seq_id: u32 = seq_causal_length; total_seq_id + local_offset < uniforms.total_sequence_length; total_seq_id++) {\\n          x[offset + total_seq_id] = \".concat(v.type.value, \"(\").concat(k, \"(0));\\n        }\") : \"\", \";\\n  }\");\n        };\n        return {\n            name: \"AttentionProbsSoftmax\",\n            shaderCache: {\n                hint: \"\".concat(p, \";\").concat(_, \";\").concat(l),\n                inputDependencies: g\n            },\n            getShaderSource: x,\n            getRunData: ()=>({\n                    outputs: [],\n                    dispatchGroup: {\n                        x: Math.ceil(i / p),\n                        y: o,\n                        z: t * r\n                    },\n                    programUniforms: h\n                })\n        };\n    }, Rm = (e1, t, r, n, o, i, a, d, l)=>{\n        let p = a + i.kvSequenceLength, m = [\n            i.batchSize,\n            i.numHeads,\n            i.sequenceLength,\n            p\n        ], u = e1 > 1 && n, h = i.kvNumHeads ? i.kvNumHeads : i.numHeads, _ = u ? [\n            i.batchSize,\n            h,\n            p,\n            i.headSize\n        ] : void 0, y = i.nReps ? i.nReps : 1, g = i.scale === 0 ? 1 / Math.sqrt(i.headSize) : i.scale, x = me(i.headSize), $ = i.headSize / x, v = 12, S = {\n            x: Math.ceil(p / v),\n            y: Math.ceil(i.sequenceLength / v),\n            z: i.batchSize * i.numHeads\n        }, T = [\n            {\n                type: 12,\n                data: i.sequenceLength\n            },\n            {\n                type: 12,\n                data: $\n            },\n            {\n                type: 12,\n                data: p\n            },\n            {\n                type: 12,\n                data: i.numHeads\n            },\n            {\n                type: 12,\n                data: i.headSize\n            },\n            {\n                type: 1,\n                data: g\n            },\n            {\n                type: 12,\n                data: a\n            },\n            {\n                type: 12,\n                data: i.kvSequenceLength\n            },\n            {\n                type: 12,\n                data: y\n            }\n        ], A = u && n && C.size(n.dims) > 0, k = [\n            \"type\",\n            \"type\"\n        ];\n        A && k.push(\"type\"), o && k.push(\"type\"), d && k.push(\"type\"), l && k.push(\"type\");\n        let P = [\n            {\n                dims: m,\n                dataType: t.dataType,\n                gpuDataType: 0\n            }\n        ];\n        u && P.push({\n            dims: _,\n            dataType: t.dataType,\n            gpuDataType: 0\n        });\n        let D = (R)=>{\n            let G = E(\"q\", t.dataType, t.dims, x), K = E(\"key\", r.dataType, r.dims, x), j = [\n                G,\n                K\n            ];\n            if (A) {\n                let ne = E(\"past_key\", n.dataType, n.dims, x);\n                j.push(ne);\n            }\n            o && j.push(E(\"attention_bias\", o.dataType, o.dims));\n            let V = d ? E(\"seq_lens\", d.dataType, d.dims) : void 0;\n            V && j.push(V);\n            let Q = l ? E(\"total_sequence_length_input\", l.dataType, l.dims) : void 0;\n            Q && j.push(Q);\n            let se = M(\"output\", t.dataType, m), Y = [\n                se\n            ];\n            u && Y.push(M(\"present_key\", t.dataType, _, x));\n            let ee = Ee(1, x), J = [\n                {\n                    name: \"M\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"K\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"N\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"num_heads\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"head_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"alpha\",\n                    type: \"f32\"\n                },\n                {\n                    name: \"past_sequence_length\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"kv_sequence_length\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"n_reps\",\n                    type: \"u32\"\n                }\n            ];\n            return \"\\n  const TILE_SIZE = \".concat(v, \"u;\\n\\n  var<workgroup> tileQ: array<\").concat(G.type.storage, \", \").concat(v * v, \">;\\n  var<workgroup> tileK: array<\").concat(G.type.storage, \", \").concat(v * v, \">;\\n  \").concat(R.registerUniforms(J).declareVariables(...j, ...Y), \"\\n  \").concat(R.mainStart([\n                v,\n                v,\n                1\n            ]), \"\\n    // x holds the N and y holds the M\\n    let headIdx = workgroup_id.z % uniforms.num_heads;\\n    let kvHeadIdx = \").concat(y === 1 ? \"headIdx\" : \"headIdx / uniforms.n_reps\", \";\\n    let kv_num_heads = \").concat(y === 1 ? \"uniforms.num_heads\" : \"uniforms.num_heads / uniforms.n_reps\", \";\\n    let batchIdx = workgroup_id.z / uniforms.num_heads;\\n    let m = workgroup_id.y * TILE_SIZE;\\n    let n = workgroup_id.x * TILE_SIZE;\\n    let sequence_length = uniforms.M;\\n    var total_sequence_length = uniforms.N;\\n    \").concat(po(V, Q, !0), \"\\n    let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx;\\n    let qOffset = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;\\n    \").concat(A && u ? \"let pastKeyOffset = absKvHeadIdx * uniforms.past_sequence_length * uniforms.K;\" : \"\", \";\\n    let kOffset = absKvHeadIdx * uniforms.kv_sequence_length * uniforms.K;\\n    \").concat(u ? \"let presentKeyOffset = absKvHeadIdx * uniforms.N * uniforms.K;\" : \"\", \"\\n    var value = \").concat(ee, \"(0);\\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\\n      if (global_id.y < uniforms.M && w + local_id.x < uniforms.K) {\\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = q[qOffset + local_id.y * uniforms.K + w + local_id.x];\\n      }\\n      if (n + local_id.y < uniforms.N && w + local_id.x < uniforms.K) {\\n        var idx = TILE_SIZE * local_id.y + local_id.x;\\n      \").concat((()=>A && u ? \"\\n              if (n + local_id.y < past_sequence_length) {\\n                tileK[idx] = past_key[pastKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x];\\n              } else if (n + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {\\n                tileK[idx] = key[kOffset + (n + local_id.y - past_sequence_length) * uniforms.K + w + local_id.x];\\n              }\" : \"\\n          if (n + local_id.y < uniforms.kv_sequence_length) {\\n            tileK[idx] = key[kOffset + (n + local_id.y) * uniforms.K + w + local_id.x];\\n          }\")(), \"\\n      \").concat(u ? \"if (n + local_id.y < present_sequence_length) {\\n        present_key[presentKeyOffset + (n + local_id.y) * uniforms.K + w + local_id.x] = tileK[idx];\\n      }\" : \"\", \"\\n      }\\n      workgroupBarrier();\\n\\n      for (var k: u32 = 0u; k < TILE_SIZE && w+k < uniforms.K; k++) {\\n          value += \").concat(ee, \"(tileQ[TILE_SIZE * local_id.y + k] * tileK[TILE_SIZE * local_id.x + k]);\\n      }\\n\\n      workgroupBarrier();\\n    }\\n\\n    if (global_id.y < uniforms.M && global_id.x < total_sequence_length) {\\n      let headOffset = workgroup_id.z * uniforms.M * uniforms.N;\\n      let outputIdx = headOffset + global_id.y * uniforms.N + global_id.x;\\n      var sum: f32 = \").concat((()=>{\n                switch(x){\n                    case 1:\n                        return \"value\";\n                    case 2:\n                        return \"value.x + value.y\";\n                    case 4:\n                        return \"value.x + value.y + value.z + value.w\";\n                    default:\n                        throw new Error(\"Unsupported components: \".concat(x));\n                }\n            })(), \";\\n        output[outputIdx] = \").concat(se.type.value, \" (sum * uniforms.alpha) + \").concat(o ? \"attention_bias[outputIdx]\" : \"0.0\", \";\\n    }\\n  }\");\n        };\n        return {\n            name: \"AttentionProbs\",\n            shaderCache: {\n                hint: \"\".concat(x, \";\").concat(o !== void 0, \";\").concat(n !== void 0, \";\").concat(e1),\n                inputDependencies: k\n            },\n            getRunData: ()=>({\n                    outputs: P,\n                    dispatchGroup: S,\n                    programUniforms: T\n                }),\n            getShaderSource: D\n        };\n    }, Um = function(e1, t, r, n, o, i) {\n        let a = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : void 0, d = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : void 0;\n        let l = i + o.kvSequenceLength, p = o.nReps ? o.nReps : 1, m = o.vHiddenSize * p, u = e1 > 1 && n, h = o.kvNumHeads ? o.kvNumHeads : o.numHeads, _ = u ? [\n            o.batchSize,\n            h,\n            l,\n            o.headSize\n        ] : void 0, y = [\n            o.batchSize,\n            o.sequenceLength,\n            m\n        ], g = 12, x = {\n            x: Math.ceil(o.vHeadSize / g),\n            y: Math.ceil(o.sequenceLength / g),\n            z: o.batchSize * o.numHeads\n        }, $ = [\n            {\n                type: 12,\n                data: o.sequenceLength\n            },\n            {\n                type: 12,\n                data: l\n            },\n            {\n                type: 12,\n                data: o.vHeadSize\n            },\n            {\n                type: 12,\n                data: o.numHeads\n            },\n            {\n                type: 12,\n                data: o.headSize\n            },\n            {\n                type: 12,\n                data: m\n            },\n            {\n                type: 12,\n                data: i\n            },\n            {\n                type: 12,\n                data: o.kvSequenceLength\n            },\n            {\n                type: 12,\n                data: p\n            }\n        ], v = u && n && C.size(n.dims) > 0, S = [\n            \"type\",\n            \"type\"\n        ];\n        v && S.push(\"type\"), a && S.push(\"type\"), d && S.push(\"type\");\n        let T = [\n            {\n                dims: y,\n                dataType: t.dataType,\n                gpuDataType: 0\n            }\n        ];\n        u && T.push({\n            dims: _,\n            dataType: t.dataType,\n            gpuDataType: 0\n        });\n        let A = (k)=>{\n            let P = E(\"probs\", t.dataType, t.dims), D = E(\"v\", r.dataType, r.dims), R = [\n                P,\n                D\n            ];\n            v && R.push(E(\"past_value\", n.dataType, n.dims));\n            let G = a ? E(\"seq_lens\", a.dataType, a.dims) : void 0;\n            a && R.push(G);\n            let K = d ? E(\"total_sequence_length_input\", d.dataType, d.dims) : void 0;\n            d && R.push(K);\n            let V = [\n                M(\"output\", t.dataType, y)\n            ];\n            u && V.push(M(\"present_value\", t.dataType, _));\n            let Q = [\n                {\n                    name: \"M\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"K\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"N\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"num_heads\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"head_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"v_hidden_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"past_sequence_length\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"kv_sequence_length\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"n_reps\",\n                    type: \"u32\"\n                }\n            ];\n            return \"\\n  const TILE_SIZE = \".concat(g, \"u;\\n  var<workgroup> tileQ: array<\").concat(P.type.value, \", \").concat(g * g, \">;\\n  var<workgroup> tileV: array<\").concat(P.type.value, \", \").concat(g * g, \">;\\n  \").concat(k.registerUniforms(Q).declareVariables(...R, ...V), \"\\n  \").concat(k.mainStart([\n                g,\n                g,\n                1\n            ]), \"\\n   let headIdx = workgroup_id.z % uniforms.num_heads;\\n   let batchIdx = workgroup_id.z / uniforms.num_heads;\\n   let kvHeadIdx = \").concat(p === 1 ? \"headIdx\" : \"headIdx / uniforms.n_reps\", \";\\n   let kv_num_heads = \").concat(p === 1 ? \"uniforms.num_heads\" : \"uniforms.num_heads / uniforms.n_reps\", \";\\n   let m = global_id.y;\\n   let n = global_id.x;\\n   let sequence_length = uniforms.M;\\n   var total_sequence_length = uniforms.K;\\n   \").concat(po(G, K, !0), \"\\n   let offsetA = workgroup_id.z * uniforms.M * uniforms.K + m * uniforms.K;\\n   let absKvHeadIdx = batchIdx * kv_num_heads + kvHeadIdx; // kvHeadIdx is relative to the batch\\n   \").concat(v && u ? \"let pastValueOffset = absKvHeadIdx * uniforms.N * uniforms.past_sequence_length + n;\" : \"\", \";\\n   let vOffset = absKvHeadIdx * uniforms.N * uniforms.kv_sequence_length + n;\\n   \").concat(u ? \"let presentValueOffset = absKvHeadIdx * uniforms.N * uniforms.K + n;\" : \"\", \"\\n   var value = \").concat(P.type.storage, \"(0);\\n   for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\\n      if (m < uniforms.M && w + local_id.x < uniforms.K) {\\n        tileQ[TILE_SIZE * local_id.y + local_id.x] = probs[offsetA + w + local_id.x];\\n      }\\n      if (n < uniforms.N && w + local_id.y < uniforms.K) {\\n        var idx = TILE_SIZE * local_id.y + local_id.x;\\n        \").concat((()=>v && u ? \"\\n        if (w + local_id.y < past_sequence_length) {\\n          tileV[idx] = past_value[pastValueOffset + (w + local_id.y) * uniforms.N];\\n        } else if (w + local_id.y - past_sequence_length < uniforms.kv_sequence_length) {\\n          tileV[idx] = v[vOffset + (w + local_id.y - past_sequence_length) * uniforms.N];\\n        }\\n      \" : \"\\n            if (w + local_id.y < uniforms.kv_sequence_length) {\\n              tileV[idx] = v[vOffset + (w + local_id.y) * uniforms.N];\\n            }\")(), \"\\n        \").concat(u ? \"\\n            if (w + local_id.y < present_sequence_length) {\\n          present_value[presentValueOffset + (w + local_id.y) * uniforms.N] = tileV[idx];\\n        }\" : \"\", \"\\n      }\\n     workgroupBarrier();\\n     for (var k: u32 = 0u; k < TILE_SIZE && w+k < total_sequence_length; k++) {\\n       value += tileQ[TILE_SIZE * local_id.y + k] * tileV[TILE_SIZE * k + local_id.x];\\n     }\\n     workgroupBarrier();\\n   }\\n\\n   // we need to transpose output from BNSH_v to BSND_v\\n   if (m < uniforms.M && n < uniforms.N) {\\n     let outputIdx = batchIdx * uniforms.M * uniforms.v_hidden_size + m * uniforms.v_hidden_size\\n       + headIdx * uniforms.N + n;\\n     output[outputIdx] = value;\\n   }\\n  }\");\n        };\n        return {\n            name: \"AttentionScore\",\n            shaderCache: {\n                hint: \"\".concat(n !== void 0, \";\").concat(e1),\n                inputDependencies: S\n            },\n            getRunData: ()=>({\n                    outputs: T,\n                    dispatchGroup: x,\n                    programUniforms: $\n                }),\n            getShaderSource: A\n        };\n    }, Rt = function(e1, t, r, n, o, i, a, d, l, p) {\n        let m = arguments.length > 10 && arguments[10] !== void 0 ? arguments[10] : void 0, u = arguments.length > 11 && arguments[11] !== void 0 ? arguments[11] : void 0;\n        let h = Math.min(e1.outputCount, 1 + (a ? 1 : 0) + (d ? 1 : 0)), _ = h > 1 ? p.pastSequenceLength : 0, y = _ + p.kvSequenceLength, g = l && C.size(l.dims) > 0 ? l : void 0, x = [\n            t,\n            r\n        ];\n        h > 1 && a && C.size(a.dims) > 0 && x.push(a), g && x.push(g), m && x.push(m), u && x.push(u);\n        let $ = e1.compute(Rm(h, t, r, a, g, p, _, m, u), {\n            inputs: x,\n            outputs: h > 1 ? [\n                -1,\n                1\n            ] : [\n                -1\n            ]\n        })[0];\n        e1.compute(Mm($, p.batchSize, p.numHeads, _, p.sequenceLength, y, m, u), {\n            inputs: m && u ? [\n                $,\n                m,\n                u\n            ] : [\n                $\n            ],\n            outputs: []\n        });\n        let v = [\n            $,\n            n\n        ];\n        h > 1 && d && C.size(d.dims) > 0 && v.push(d), m && v.push(m), u && v.push(u), e1.compute(Um(h, $, n, d, p, _, m, u), {\n            inputs: v,\n            outputs: h > 1 ? [\n                0,\n                2\n            ] : [\n                0\n            ]\n        });\n    }, Nm = (e1, t)=>{\n        let r = [\n            t.batchSize,\n            t.numHeads,\n            t.sequenceLength,\n            t.headSize\n        ], n = t.sequenceLength, o = t.inputHiddenSize, i = t.headSize, a = 12, d = {\n            x: Math.ceil(t.headSize / a),\n            y: Math.ceil(t.sequenceLength / a),\n            z: t.batchSize * t.numHeads\n        }, l = [\n            e1.inputs[0],\n            e1.inputs[1],\n            e1.inputs[2]\n        ], p = [\n            {\n                type: 12,\n                data: n\n            },\n            {\n                type: 12,\n                data: o\n            },\n            {\n                type: 12,\n                data: i\n            },\n            {\n                type: 12,\n                data: t.numHeads\n            },\n            {\n                type: 12,\n                data: t.headSize\n            },\n            {\n                type: 12,\n                data: t.hiddenSize\n            },\n            {\n                type: 12,\n                data: t.hiddenSize + t.hiddenSize + t.vHiddenSize\n            }\n        ], m = (u)=>{\n            let h = M(\"output_q\", l[0].dataType, r), _ = M(\"output_k\", l[0].dataType, r), y = M(\"output_v\", l[0].dataType, r), g = E(\"input\", l[0].dataType, l[0].dims), x = E(\"weight\", l[1].dataType, l[1].dims), $ = E(\"bias\", l[2].dataType, l[2].dims), v = g.type.storage, S = [\n                {\n                    name: \"M\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"K\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"N\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"num_heads\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"head_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"hidden_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"ldb\",\n                    type: \"u32\"\n                }\n            ];\n            return \"\\n  const TILE_SIZE = \".concat(a, \"u;\\n  var<workgroup> tileInput: array<\").concat(v, \", \").concat(a * a, \">;\\n  var<workgroup> tileWeightQ: array<\").concat(v, \", \").concat(a * a, \">;\\n  var<workgroup> tileWeightK: array<\").concat(v, \", \").concat(a * a, \">;\\n  var<workgroup> tileWeightV: array<\").concat(v, \", \").concat(a * a, \">;\\n  \").concat(u.registerUniforms(S).declareVariables(g, x, $, h, _, y), \"\\n  \").concat(u.mainStart([\n                a,\n                a,\n                1\n            ]), \"\\n    let batchIndex = workgroup_id.z / uniforms.num_heads;\\n    let headNumber = workgroup_id.z % uniforms.num_heads;\\n    let m = global_id.y;\\n    let n = global_id.x;\\n\\n    let inputOffset = batchIndex * (uniforms.M * uniforms.K) + m * uniforms.K;\\n    let biasOffsetQ = headNumber * uniforms.head_size;\\n    let biasOffsetK = uniforms.hidden_size + biasOffsetQ;\\n    let biasOffsetV = uniforms.hidden_size + biasOffsetK;\\n\\n    var valueQ = \").concat(v, \"(0);\\n    var valueK = \").concat(v, \"(0);\\n    var valueV = \").concat(v, \"(0);\\n    for (var w: u32 = 0u; w < uniforms.K; w += TILE_SIZE) {\\n      if (m < uniforms.M && w + local_id.x < uniforms.K) {\\n        tileInput[TILE_SIZE * local_id.y + local_id.x] = input[inputOffset + w + local_id.x];\\n      }\\n      if (n < uniforms.N && w + local_id.y < uniforms.K) {\\n        let offset = n + (w + local_id.y) * uniforms.ldb;\\n        tileWeightQ[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetQ + offset];\\n        tileWeightK[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetK + offset];\\n        tileWeightV[TILE_SIZE * local_id.y + local_id.x] = weight[biasOffsetV + offset];\\n      }\\n      workgroupBarrier();\\n      for (var k: u32 = 0u; k<TILE_SIZE && w+k < uniforms.K; k++) {\\n        let inputTileOffset = TILE_SIZE * local_id.y + k;\\n        let weightTileOffset = TILE_SIZE * k + local_id.x;\\n        valueQ += tileInput[inputTileOffset] * tileWeightQ[weightTileOffset];\\n        valueK += tileInput[inputTileOffset] * tileWeightK[weightTileOffset];\\n        valueV += tileInput[inputTileOffset] * tileWeightV[weightTileOffset];\\n      }\\n\\n      workgroupBarrier();\\n    }\\n\\n    let headOffset = (m * uniforms.N + n) % uniforms.head_size;\\n    valueQ += bias[headOffset + biasOffsetQ];\\n    valueK += bias[headOffset + biasOffsetK];\\n    valueV += bias[headOffset + biasOffsetV];\\n\\n    let offset = workgroup_id.z * uniforms.M * uniforms.N;\\n    if (m < uniforms.M && n < uniforms.N) {\\n      let outputIdx = offset + m * uniforms.N + n;\\n      output_q[outputIdx] = valueQ;\\n      output_k[outputIdx] = valueK;\\n      output_v[outputIdx] = valueV;\\n    }\\n  }\");\n        };\n        return e1.compute({\n            name: \"AttentionPrepare\",\n            shaderCache: {\n                inputDependencies: [\n                    \"type\",\n                    \"type\",\n                    \"type\"\n                ]\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: r,\n                            dataType: e1.inputs[0].dataType,\n                            gpuDataType: 0\n                        },\n                        {\n                            dims: r,\n                            dataType: e1.inputs[0].dataType,\n                            gpuDataType: 0\n                        },\n                        {\n                            dims: r,\n                            dataType: e1.inputs[0].dataType,\n                            gpuDataType: 0\n                        }\n                    ],\n                    dispatchGroup: d,\n                    programUniforms: p\n                }),\n            getShaderSource: m\n        }, {\n            inputs: l,\n            outputs: [\n                -1,\n                -1,\n                -1\n            ]\n        });\n    }, zs = (e1, t)=>{\n        let r = Bm(e1.inputs, t), [n, o, i] = Nm(e1, r);\n        return Rt(e1, n, o, i, e1.inputs[4], void 0, void 0, void 0, e1.inputs[5], r);\n    };\n});\nvar Vm, Wm, Lm, Os, Ds = U(()=>{\n    \"use strict\";\n    We();\n    te();\n    oe();\n    Se();\n    ae();\n    Vm = (e1, t)=>{\n        if (!e1 || e1.length !== 5) throw new Error(\"BatchNormalization requires 5 inputs\");\n        let r = (n, o, i)=>{\n            let a = o.length;\n            if (a !== n.length) throw new Error(\"\".concat(i, \": num dimensions != \").concat(a));\n            o.forEach((d, l)=>{\n                if (d !== n[l]) throw new Error(\"\".concat(i, \": dim[\").concat(l, \"] do not match\"));\n            });\n        };\n        if (e1[0].dims.length > 1) {\n            let n = t.format === \"NHWC\" ? t.spatial ? e1[0].dims.slice(-1) : e1[0].dims.slice(-1).concat(e1[0].dims.slice(1, e1[0].dims.length - 1)) : e1[0].dims.slice(1, t.spatial ? 2 : void 0);\n            r(e1[1].dims, n, \"Invalid input scale\"), r(e1[2].dims, n, \"Invalid input B\"), r(e1[3].dims, n, \"Invalid input mean\"), r(e1[4].dims, n, \"Invalid input var\");\n        } else r(e1[1].dims, [\n            1\n        ], \"Invalid input scale\"), r(e1[2].dims, [\n            1\n        ], \"Invalid input B\"), r(e1[3].dims, [\n            1\n        ], \"Invalid input mean\"), r(e1[4].dims, [\n            1\n        ], \"Invalid input var\");\n    }, Wm = (e1, t)=>{\n        let { epsilon: r, spatial: n, format: o } = t, i = e1[0].dims, a = n ? me(i[i.length - 1]) : 1, d = o === \"NHWC\" && i.length > 1 ? a : 1, l = C.size(i) / a, p = n, m = p ? i.length : i, u = E(\"x\", e1[0].dataType, e1[0].dims, a), h = E(\"scale\", e1[1].dataType, e1[1].dims, d), _ = E(\"bias\", e1[2].dataType, e1[2].dims, d), y = E(\"inputMean\", e1[3].dataType, e1[3].dims, d), g = E(\"inputVar\", e1[4].dataType, e1[4].dims, d), x = M(\"y\", e1[0].dataType, m, a), $ = ()=>{\n            let S = \"\";\n            if (n) S = \"let cOffset = \".concat(i.length === 1 ? \"0u\" : o === \"NHWC\" ? \"outputIndices[\".concat(i.length - 1, \"] / \").concat(a) : \"outputIndices[1]\", \";\");\n            else if (o === \"NCHW\") S = \"\\n            \".concat(x.indicesSet(\"outputIndices\", \"0\", \"0\"), \"\\n            let cOffset = \").concat(x.indicesToOffset(\"outputIndices\"), \";\");\n            else {\n                S = \"var cIndices = \".concat(h.type.indices, \"(0);\\n                       cIndices[0] = outputIndices[\").concat(i.length - 1, \"];\");\n                for(let T = 1; T < h.rank; T++)S += \"cIndices[\".concat(T, \"] = outputIndices[\").concat(T, \"];\");\n                S += \"let cOffset = \".concat(h.indicesToOffset(\"cIndices\"), \";\");\n            }\n            return S;\n        }, v = (S)=>\"\\n  const epsilon = \".concat(r, \";\\n  \").concat(S.registerUniform(\"outputSize\", \"u32\").declareVariables(u, h, _, y, g, x), \"\\n  \").concat(S.mainStart(), \"\\n  \").concat(S.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\"), \"\\n    var outputIndices = \").concat(x.offsetToIndices(\"global_idx * \".concat(a)), \";\\n    \").concat($(), \"\\n    let scale = \").concat(h.getByOffset(\"cOffset\"), \";\\n    let bias = \").concat(_.getByOffset(\"cOffset\"), \";\\n    let inputMean = \").concat(y.getByOffset(\"cOffset\"), \";\\n    let inputVar = \").concat(g.getByOffset(\"cOffset\"), \";\\n    let x = \").concat(u.getByOffset(\"global_idx\"), \";\\n    let value = (x - inputMean) * inverseSqrt(inputVar + epsilon) * scale + bias;\\n    \").concat(x.setByOffset(\"global_idx\", \"value\"), \"\\n  }\");\n        return {\n            name: \"BatchNormalization\",\n            shaderCache: {\n                hint: \"\".concat(t.epsilon, \"_\").concat(t.format, \"_\").concat(n, \"_\").concat(a),\n                inputDependencies: p ? [\n                    \"rank\",\n                    \"type\",\n                    \"type\",\n                    \"type\",\n                    \"type\"\n                ] : void 0\n            },\n            getShaderSource: v,\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: e1[0].dims,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(l / 64)\n                    },\n                    programUniforms: p ? [\n                        {\n                            type: 12,\n                            data: l\n                        },\n                        ...N(i)\n                    ] : [\n                        {\n                            type: 12,\n                            data: l\n                        }\n                    ]\n                })\n        };\n    }, Lm = (e1)=>re(e1), Os = (e1, t)=>{\n        let { inputs: r, outputCount: n } = e1, o = Lm({\n            ...t,\n            outputCount: n\n        });\n        if (ve.webgpu.validateInputContent && Vm(r, o), t.trainingMode) throw new Error(\"BatchNormalization trainingMode is not supported yet.\");\n        e1.compute(Wm(r, o));\n    };\n});\nvar Gm, Hm, Bs, Ms = U(()=>{\n    \"use strict\";\n    oe();\n    ae();\n    Gm = (e1)=>{\n        if (e1[0].dims.length !== 3) throw new Error(\"input should have 3 dimensions\");\n        if (![\n            320,\n            640,\n            1280\n        ].includes(e1[0].dims[2])) throw new Error(\"number of channels should be 320, 640 or 1280\");\n        if (e1[1].dims.length !== 1) throw new Error(\"bias is expected to have 1 dimensions\");\n        if (e1[0].dims[2] !== e1[1].dims[0]) throw new Error(\"last dimension of input and bias are not the same\");\n    }, Hm = (e1)=>{\n        let t = e1[0].dims, r = e1[0].dims[2], n = C.size(t) / 4, o = e1[0].dataType, i = E(\"input\", o, t, 4), a = E(\"bias\", o, [\n            r\n        ], 4), d = E(\"residual\", o, t, 4), l = M(\"output\", o, t, 4);\n        return {\n            name: \"BiasAdd\",\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: t,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(n / 64)\n                    }\n                }),\n            getShaderSource: (m)=>\"\\n  const channels = \".concat(r, \"u / 4;\\n  \").concat(m.declareVariables(i, a, d, l), \"\\n\\n  \").concat(m.mainStart(), \"\\n    \").concat(m.guardAgainstOutOfBoundsWorkgroupSizes(n), \"\\n    let value = \").concat(i.getByOffset(\"global_idx\"), \"\\n      + \").concat(a.getByOffset(\"global_idx % channels\"), \" + \").concat(d.getByOffset(\"global_idx\"), \";\\n    \").concat(l.setByOffset(\"global_idx\", \"value\"), \"\\n  }\")\n        };\n    }, Bs = (e1)=>{\n        Gm(e1.inputs), e1.compute(Hm(e1.inputs));\n    };\n});\nvar Fm, fe, Rs, Us, Ns, Vs, Ws, Ls, Gs, Hs, Fs, qm, qs, Ks, js, Ys, Xt, Zs, qr, Qs, Xs, Js, eu, tu, ru, nu, ou, iu, au, su, uu, du, lu, cu, pu, mu, fu, mo, fo, hu, gu, bu, Km, jm, yu, Kr = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    Fm = (e1, t, r, n, o, i, a)=>{\n        let d = Math.ceil(t / 4), l = \"\";\n        typeof o == \"string\" ? l = \"\".concat(o, \"(a)\") : l = o(\"a\");\n        let p = E(\"inputData\", r, [\n            d\n        ], 4), m = M(\"outputData\", n, [\n            d\n        ], 4), u = [\n            {\n                name: \"vec_size\",\n                type: \"u32\"\n            }\n        ];\n        return a && u.push(...a), \"\\n      \".concat(e1.registerUniforms(u).declareVariables(p, m), \"\\n\\n  \").concat(i !== null && i !== void 0 ? i : \"\", \"\\n\\n  \").concat(e1.mainStart(), \"\\n    \").concat(e1.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.vec_size\"), \"\\n\\n    let a = \").concat(p.getByOffset(\"global_idx\"), \";\\n    \").concat(m.setByOffset(\"global_idx\", l), \"\\n  }\");\n    }, fe = function(e1, t, r, n, o) {\n        let i = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : e1.dataType, a = arguments.length > 6 ? arguments[6] : void 0, d = arguments.length > 7 ? arguments[7] : void 0;\n        let l = [\n            {\n                type: 12,\n                data: Math.ceil(C.size(e1.dims) / 4)\n            }\n        ];\n        return a && l.push(...a), {\n            name: t,\n            shaderCache: {\n                hint: o,\n                inputDependencies: [\n                    \"type\"\n                ]\n            },\n            getShaderSource: (p)=>Fm(p, C.size(e1.dims), e1.dataType, i, r, n, d),\n            getRunData: (p)=>({\n                    outputs: [\n                        {\n                            dims: e1.dims,\n                            dataType: i\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(C.size(p[0].dims) / 64 / 4)\n                    },\n                    programUniforms: l\n                })\n        };\n    }, Rs = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Abs\", \"abs\"));\n    }, Us = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Acos\", \"acos\"));\n    }, Ns = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Acosh\", \"acosh\"));\n    }, Vs = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Asin\", \"asin\"));\n    }, Ws = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Asinh\", \"asinh\"));\n    }, Ls = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Atan\", \"atan\"));\n    }, Gs = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Atanh\", \"atanh\"));\n    }, Hs = (e1)=>re(e1), Fs = (e1, t)=>{\n        let r;\n        switch(t.to){\n            case 10:\n                r = \"vec4<f16>\";\n                break;\n            case 1:\n                r = \"vec4<f32>\";\n                break;\n            case 12:\n                r = \"vec4<u32>\";\n                break;\n            case 6:\n                r = \"vec4<i32>\";\n                break;\n            case 9:\n                r = \"vec4<bool>\";\n                break;\n            default:\n                throw new RangeError(\"not supported type (specified in attribute 'to' from 'Cast' operator): \".concat(t.to));\n        }\n        e1.compute(fe(e1.inputs[0], \"Cast\", r, void 0, t.cacheKey, t.to));\n    }, qm = (e1)=>{\n        let t, r, n = e1.length >= 2 && e1[1].data !== 0, o = e1.length >= 3 && e1[2].data !== 0;\n        switch(e1[0].dataType){\n            case 1:\n                t = n ? e1[1].getFloat32Array()[0] : -34028234663852886e22, r = o ? e1[2].getFloat32Array()[0] : 34028234663852886e22;\n                break;\n            case 10:\n                t = n ? e1[1].getUint16Array()[0] : 64511, r = o ? e1[2].getUint16Array()[0] : 31743;\n                break;\n            default:\n                throw new Error(\"Unsupport data type\");\n        }\n        return re({\n            min: t,\n            max: r\n        });\n    }, qs = (e1, t)=>{\n        let r = t || qm(e1.inputs), n = Ee(e1.inputs[0].dataType);\n        e1.compute(fe(e1.inputs[0], \"Clip\", (o)=>\"clamp(\".concat(o, \", vec4<\").concat(n, \">(uniforms.min), vec4<\").concat(n, \">(uniforms.max))\"), void 0, r.cacheKey, void 0, [\n            {\n                type: e1.inputs[0].dataType,\n                data: r.min\n            },\n            {\n                type: e1.inputs[0].dataType,\n                data: r.max\n            }\n        ], [\n            {\n                name: \"min\",\n                type: n\n            },\n            {\n                name: \"max\",\n                type: n\n            }\n        ]), {\n            inputs: [\n                0\n            ]\n        });\n    }, Ks = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Ceil\", \"ceil\"));\n    }, js = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Cos\", \"cos\"));\n    }, Ys = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Cosh\", \"cosh\"));\n    }, Xt = (e1)=>re(e1), Zs = (e1, t)=>{\n        let r = Ee(e1.inputs[0].dataType);\n        e1.compute(fe(e1.inputs[0], \"Elu\", (n)=>\"elu_vf32(\".concat(n, \")\"), \"\\n  const elu_alpha_ = \".concat(r, \"(\").concat(t.alpha, \");\\n\\n  fn elu_f32(a: \").concat(r, \") -> \").concat(r, \" {\\n  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);\\n  }\\n\\n  fn elu_vf32(v: vec4<\").concat(r, \">) -> vec4<\").concat(r, \"> {\\n  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));\\n  }\"), t.cacheKey));\n    }, qr = function() {\n        let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"f32\";\n        return \"\\nconst r0: \".concat(e1, \" = 0.3275911;\\nconst r1: \").concat(e1, \" = 0.254829592;\\nconst r2: \").concat(e1, \" = -0.284496736;\\nconst r3: \").concat(e1, \" = 1.421413741;\\nconst r4: \").concat(e1, \" = -1.453152027;\\nconst r5: \").concat(e1, \" = 1.061405429;\\n\\nfn erf_vf32(v: vec4<\").concat(e1, \">) -> vec4<\").concat(e1, \"> {\\n  let absv = abs(v);\\n  let x = 1.0 / (1.0 + r0 * absv);\\n  return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));\\n}\");\n    }, Qs = (e1)=>{\n        let t = Ee(e1.inputs[0].dataType);\n        e1.compute(fe(e1.inputs[0], \"Erf\", (r)=>\"erf_vf32(\".concat(r, \")\"), qr(t)));\n    }, Xs = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Exp\", \"exp\"));\n    }, Js = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Floor\", \"floor\"));\n    }, eu = (e1)=>{\n        let t = Ee(e1.inputs[0].dataType);\n        e1.compute(fe(e1.inputs[0], \"Gelu\", (r)=>\"0.5 * \".concat(r, \" * (1.0 + erf_vf32(\").concat(r, \" * 0.7071067811865475))\"), qr(t)));\n    }, tu = (e1, t)=>{\n        let r = Ee(e1.inputs[0].dataType);\n        e1.compute(fe(e1.inputs[0], \"LeakyRelu\", (n)=>\"select(leaky_relu_alpha_ * \".concat(n, \", \").concat(n, \", \").concat(n, \" >= vec4<\").concat(r, \">(0.0))\"), \"const leaky_relu_alpha_ = \".concat(r, \"(\").concat(t.alpha, \");\"), t.cacheKey));\n    }, ru = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Not\", (t)=>\"!\".concat(t)));\n    }, nu = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Neg\", (t)=>\"-\".concat(t)));\n    }, ou = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Reciprocal\", (t)=>\"1.0/\".concat(t)));\n    }, iu = (e1)=>{\n        let t = Ee(e1.inputs[0].dataType);\n        e1.compute(fe(e1.inputs[0], \"Relu\", (r)=>\"select(vec4<\".concat(t, \">(0.0), \").concat(r, \", \").concat(r, \" > vec4<\").concat(t, \">(0.0))\")));\n    }, au = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Sigmoid\", (t)=>\"(1.0 / (1.0 + exp(-\".concat(t, \")))\")));\n    }, su = (e1)=>re(e1), uu = (e1, t)=>{\n        let r = Ee(e1.inputs[0].dataType);\n        e1.compute(fe(e1.inputs[0], \"HardSigmoid\", (n)=>\"max(vec4<\".concat(r, \">(0.0), min(vec4<\").concat(r, \">(1.0), \").concat(t.alpha, \" * \").concat(n, \" + vec4<\").concat(r, \">(\").concat(t.beta, \")))\"), void 0, t.cacheKey));\n    }, du = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Sin\", \"sin\"));\n    }, lu = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Sinh\", \"sinh\"));\n    }, cu = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Sqrt\", \"sqrt\"));\n    }, pu = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Tan\", \"tan\"));\n    }, mu = (e1)=>\"sign(\".concat(e1, \") * (1 - exp(-2 * abs(\").concat(e1, \"))) / (1 + exp(-2 * abs(\").concat(e1, \")))\"), fu = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Tanh\", mu));\n    }, mo = function() {\n        let e1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"f32\";\n        return \"\\nconst fast_gelu_a: \".concat(e1, \" = 0.5;\\nconst fast_gelu_b: \").concat(e1, \" = 0.7978845608028654;\\nconst fast_gelu_c: \").concat(e1, \" = 0.035677408136300125;\\n\\nfn tanh_v(v: vec4<\").concat(e1, \">) -> vec4<\").concat(e1, \"> {\\n  return \").concat(mu(\"v\"), \";\\n}\\n\");\n    }, fo = (e1)=>\"(fast_gelu_a + fast_gelu_a * tanh_v(\".concat(e1, \" * (fast_gelu_c * \").concat(e1, \" * \").concat(e1, \" + fast_gelu_b))) * \").concat(e1), hu = (e1)=>{\n        let t = Ee(e1.inputs[0].dataType);\n        e1.compute(fe(e1.inputs[0], \"FastGelu\", fo, mo(t), void 0, e1.inputs[0].dataType));\n    }, gu = (e1, t)=>{\n        let r = Ee(e1.inputs[0].dataType);\n        return e1.compute(fe(e1.inputs[0], \"ThresholdedRelu\", (n)=>\"select(vec4<\".concat(r, \">(0.0), \").concat(n, \", \").concat(n, \" > thresholded_relu_alpha_)\"), \"const thresholded_relu_alpha_ = vec4<\".concat(r, \">(\").concat(t.alpha, \");\"), t.cacheKey)), 0;\n    }, bu = (e1)=>{\n        e1.compute(fe(e1.inputs[0], \"Log\", \"log\"));\n    }, Km = (e1, t)=>\"\\nconst alpha = vec4<\".concat(e1, \">(\").concat(t, \");\\nconst one = \").concat(e1, \"(1.0);\\nconst zero = \").concat(e1, \"(0.0);\\n\\nfn quick_gelu_impl(x: vec4<\").concat(e1, \">) -> vec4<\").concat(e1, \"> {\\n  let v = x *alpha;\\n  var x1 : vec4<\").concat(e1, \">;\\n  for (var i = 0; i < 4; i = i + 1) {\\n    if (v[i] >= zero) {\\n      x1[i] = one / (one + exp(-v[i]));\\n    } else {\\n      x1[i] = one - one / (one + exp(v[i]));\\n    }\\n  }\\n  return x * x1;\\n}\\n\"), jm = (e1)=>\"quick_gelu_impl(\".concat(e1, \")\"), yu = (e1, t)=>{\n        let r = Ee(e1.inputs[0].dataType);\n        e1.compute(fe(e1.inputs[0], \"QuickGelu\", jm, Km(r, t.alpha), t.cacheKey, e1.inputs[0].dataType));\n    };\n});\nvar Ym, Zm, wu, vu = U(()=>{\n    \"use strict\";\n    oe();\n    ae();\n    Kr();\n    Ym = (e1)=>{\n        if (e1[0].dims.length !== 3) throw new Error(\"input should have 3 dimensions\");\n        if (![\n            2560,\n            5120,\n            10240\n        ].includes(e1[0].dims[2])) throw new Error(\"hidden state should be 2560, 5120 or 10240\");\n        if (e1[1].dims.length !== 1) throw new Error(\"bias is expected to have 1 dimensions\");\n        if (e1[0].dims[2] !== e1[1].dims[0]) throw new Error(\"last dimension of input and bias are not the same\");\n    }, Zm = (e1)=>{\n        let t = e1[0].dims.slice();\n        t[2] = t[2] / 2;\n        let r = E(\"input\", e1[0].dataType, e1[0].dims, 4), n = E(\"bias\", e1[0].dataType, [\n            e1[0].dims[2]\n        ], 4), o = M(\"output\", e1[0].dataType, t, 4), i = C.size(t) / 4, a = _e(e1[0].dataType);\n        return {\n            name: \"BiasSplitGelu\",\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: t,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(i / 64)\n                    }\n                }),\n            getShaderSource: (l)=>\"\\n  const M_SQRT2 = sqrt(2.0);\\n  const halfChannels = \".concat(e1[0].dims[2] / 4 / 2, \"u;\\n\\n  \").concat(l.declareVariables(r, n, o), \"\\n\\n  \").concat(qr(a), \"\\n\\n  \").concat(l.mainStart(), \"\\n    \").concat(l.guardAgainstOutOfBoundsWorkgroupSizes(i), \"\\n    let biasIdx = global_idx % halfChannels;\\n    let batchIndex = global_idx / halfChannels;\\n    let inputOffset = biasIdx + batchIndex * halfChannels * 2;\\n    let valueLeft = input[inputOffset] + bias[biasIdx];\\n    let valueRight = input[inputOffset + halfChannels] + bias[biasIdx + halfChannels];\\n    let geluRight = valueRight * 0.5 * (erf_vf32(valueRight / M_SQRT2) + 1);\\n\\n    \").concat(o.setByOffset(\"global_idx\", \"valueLeft * geluRight\"), \"\\n  }\")\n        };\n    }, wu = (e1)=>{\n        Ym(e1.inputs), e1.compute(Zm(e1.inputs));\n    };\n});\nvar Qm, Xm, at, $u, xu, Su, Tu, Iu, Cu, Au, ku, Eu, Pu, zu = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    ae();\n    Qm = (e1, t, r, n, o, i, a, d, l, p, m, u)=>{\n        let h, _;\n        typeof d == \"string\" ? h = _ = (v, S)=>\"\".concat(d, \"((\").concat(v, \"),(\").concat(S, \"))\") : typeof d == \"function\" ? h = _ = d : (h = d.scalar, _ = d.vector);\n        let y = M(\"outputData\", m, n.length, 4), g = E(\"aData\", l, t.length, 4), x = E(\"bData\", p, r.length, 4), $;\n        if (o) if (i) {\n            let v = C.size(t) === 1, S = C.size(r) === 1, T = t.length > 0 && t[t.length - 1] % 4 === 0, A = r.length > 0 && r[r.length - 1] % 4 === 0;\n            v || S ? $ = y.setByOffset(\"global_idx\", _(v ? \"\".concat(g.type.value, \"(\").concat(g.getByOffset(\"0\"), \".x)\") : g.getByOffset(\"global_idx\"), S ? \"\".concat(x.type.value, \"(\").concat(x.getByOffset(\"0\"), \".x)\") : x.getByOffset(\"global_idx\"))) : $ = \"\\n            let outputIndices = \".concat(y.offsetToIndices(\"global_idx * 4u\"), \";\\n            let offsetA = \").concat(g.broadcastedIndicesToOffset(\"outputIndices\", y), \";\\n            let offsetB = \").concat(x.broadcastedIndicesToOffset(\"outputIndices\", y), \";\\n            \").concat(y.setByOffset(\"global_idx\", _(a || T ? g.getByOffset(\"offsetA / 4u\") : \"\".concat(g.type.value, \"(\").concat(g.getByOffset(\"offsetA / 4u\"), \"[offsetA % 4u])\"), a || A ? x.getByOffset(\"offsetB / 4u\") : \"\".concat(x.type.value, \"(\").concat(x.getByOffset(\"offsetB / 4u\"), \"[offsetB % 4u])\"))), \"\\n          \");\n        } else $ = y.setByOffset(\"global_idx\", _(g.getByOffset(\"global_idx\"), x.getByOffset(\"global_idx\")));\n        else {\n            if (!i) throw new Error(\"no necessary to use scalar implementation for element-wise binary op implementation.\");\n            let v = function(S, T) {\n                let A = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"\";\n                let k = \"aData[indexA\".concat(T, \"][componentA\").concat(T, \"]\"), P = \"bData[indexB\".concat(T, \"][componentB\").concat(T, \"]\");\n                return \"\\n            let outputIndices\".concat(T, \" = \").concat(y.offsetToIndices(\"global_idx * 4u + \".concat(T, \"u\")), \";\\n            let offsetA\").concat(T, \" = \").concat(g.broadcastedIndicesToOffset(\"outputIndices\".concat(T), y), \";\\n            let offsetB\").concat(T, \" = \").concat(x.broadcastedIndicesToOffset(\"outputIndices\".concat(T), y), \";\\n            let indexA\").concat(T, \" = offsetA\").concat(T, \" / 4u;\\n            let indexB\").concat(T, \" = offsetB\").concat(T, \" / 4u;\\n            let componentA\").concat(T, \" = offsetA\").concat(T, \" % 4u;\\n            let componentB\").concat(T, \" = offsetB\").concat(T, \" % 4u;\\n            \").concat(S, \"[\").concat(T, \"] = \").concat(A, \"(\").concat(h(k, P), \");\\n          \");\n            };\n            m === 9 ? $ = \"\\n            var data = vec4<u32>(0);\\n            \".concat(v(\"data\", 0, \"u32\"), \"\\n            \").concat(v(\"data\", 1, \"u32\"), \"\\n            \").concat(v(\"data\", 2, \"u32\"), \"\\n            \").concat(v(\"data\", 3, \"u32\"), \"\\n            outputData[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));\") : $ = \"\\n            \".concat(v(\"outputData[global_idx]\", 0), \"\\n            \").concat(v(\"outputData[global_idx]\", 1), \"\\n            \").concat(v(\"outputData[global_idx]\", 2), \"\\n            \").concat(v(\"outputData[global_idx]\", 3), \"\\n          \");\n        }\n        return \"\\n        \".concat(e1.registerUniform(\"vec_size\", \"u32\").declareVariables(g, x, y), \"\\n\\n        \").concat(u !== null && u !== void 0 ? u : \"\", \"\\n\\n        \").concat(e1.mainStart(), \"\\n        \").concat(e1.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.vec_size\"), \"\\n        \").concat($, \"\\n      }\");\n    }, Xm = function(e1, t, r, n, o, i) {\n        let a = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : r.dataType;\n        let d = r.dims.map((g)=>{\n            var _Number;\n            return (_Number = Number(g)) !== null && _Number !== void 0 ? _Number : 1;\n        }), l = n.dims.map((g)=>{\n            var _Number;\n            return (_Number = Number(g)) !== null && _Number !== void 0 ? _Number : 1;\n        }), p = !C.areEqual(d, l), m = d, u = C.size(d), h = !1, _ = !1, y = [\n            p\n        ];\n        if (p) {\n            let g = tt.calcShape(d, l, !1);\n            if (!g) throw new Error(\"Can't perform binary op on the given tensors\");\n            m = g.slice(), u = C.size(m);\n            let x = C.size(d) === 1, $ = C.size(l) === 1, v = d.length > 0 && d[d.length - 1] % 4 === 0, S = l.length > 0 && l[l.length - 1] % 4 === 0;\n            y.push(x), y.push($), y.push(v), y.push(S);\n            let T = 1;\n            for(let A = 1; A < m.length; A++){\n                let k = d[d.length - A], P = l[l.length - A];\n                if (k === P) T *= k;\n                else break;\n            }\n            T % 4 === 0 ? (_ = !0, h = !0) : (x || $ || v || S) && (h = !0);\n        } else h = !0;\n        return y.push(h), {\n            name: e1,\n            shaderCache: {\n                hint: t + y.map((g)=>g.toString()).join(\"_\"),\n                inputDependencies: [\n                    \"rank\",\n                    \"rank\"\n                ]\n            },\n            getShaderSource: (g)=>Qm(g, d, l, m, h, p, _, o, r.dataType, n.dataType, a, i),\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: m,\n                            dataType: a\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(u / 64 / 4)\n                    },\n                    programUniforms: [\n                        {\n                            type: 12,\n                            data: Math.ceil(C.size(m) / 4)\n                        },\n                        ...N(d, l, m)\n                    ]\n                })\n        };\n    }, at = (e1, t, r, n, o, i)=>{\n        e1.compute(Xm(t, o !== null && o !== void 0 ? o : \"\", e1.inputs[0], e1.inputs[1], r, n, i));\n    }, $u = (e1)=>{\n        at(e1, \"Add\", (t, r)=>\"\".concat(t, \"+\").concat(r));\n    }, xu = (e1)=>{\n        at(e1, \"Div\", (t, r)=>\"\".concat(t, \"/\").concat(r));\n    }, Su = (e1)=>{\n        at(e1, \"Equal\", {\n            scalar: (t, r)=>\"u32(\".concat(t, \"==\").concat(r, \")\"),\n            vector: (t, r)=>\"vec4<u32>(\".concat(t, \"==\").concat(r, \")\")\n        }, void 0, void 0, 9);\n    }, Tu = (e1)=>{\n        at(e1, \"Mul\", (t, r)=>\"\".concat(t, \"*\").concat(r));\n    }, Iu = (e1)=>{\n        let t = E(\"input\", e1.inputs[0].dataType, e1.inputs[0].dims).type.value;\n        at(e1, \"Pow\", {\n            scalar: (n, o)=>\"pow_custom(\".concat(n, \",\").concat(o, \")\"),\n            vector: (n, o)=>\"pow_vector_custom(\".concat(n, \",\").concat(o, \")\")\n        }, \"\\n    fn pow_custom(a : \".concat(t, \", b : \").concat(t, \") -> \").concat(t, \" {\\n      if (b == \").concat(t, \"(0.0)) {\\n        return \").concat(t, \"(1.0);\\n      } else if (a < \").concat(t, \"(0.0) && f32(b) != floor(f32(b))) {\\n        return \").concat(t, \"(pow(f32(a), f32(b))); // NaN\\n      }\\n      return select(sign(a), \").concat(t, \"(1.0), round(f32(abs(b) % \").concat(t, \"(2.0))) != 1.0) * \").concat(t, \"(\").concat(t === \"i32\" ? \"round\" : \"\", \"(pow(f32(abs(a)), f32(b))));\\n    }\\n    fn pow_vector_custom(a : vec4<\").concat(t, \">, b : vec4<\").concat(t, \">) -> vec4<\").concat(t, \"> {\\n      // TODO: implement vectorized pow\\n      return vec4<\").concat(t, \">(pow_custom(a.x, b.x), pow_custom(a.y, b.y), pow_custom(a.z, b.z), pow_custom(a.w, b.w));\\n    }\\n      \"));\n    }, Cu = (e1)=>{\n        at(e1, \"Sub\", (t, r)=>\"\".concat(t, \"-\").concat(r));\n    }, Au = (e1)=>{\n        at(e1, \"Greater\", {\n            scalar: (t, r)=>\"u32(\".concat(t, \">\").concat(r, \")\"),\n            vector: (t, r)=>\"vec4<u32>(\".concat(t, \">\").concat(r, \")\")\n        }, void 0, void 0, 9);\n    }, ku = (e1)=>{\n        at(e1, \"Less\", {\n            scalar: (t, r)=>\"u32(\".concat(t, \"<\").concat(r, \")\"),\n            vector: (t, r)=>\"vec4<u32>(\".concat(t, \"<\").concat(r, \")\")\n        }, void 0, void 0, 9);\n    }, Eu = (e1)=>{\n        at(e1, \"GreaterOrEqual\", {\n            scalar: (t, r)=>\"u32(\".concat(t, \">=\").concat(r, \")\"),\n            vector: (t, r)=>\"vec4<u32>(\".concat(t, \">=\").concat(r, \")\")\n        }, void 0, void 0, 9);\n    }, Pu = (e1)=>{\n        at(e1, \"LessOrEqual\", {\n            scalar: (t, r)=>\"u32(\".concat(t, \"<=\").concat(r, \")\"),\n            vector: (t, r)=>\"vec4<u32>(\".concat(t, \"<=\").concat(r, \")\")\n        }, void 0, void 0, 9);\n    };\n});\nvar ef, tf, rf, nf, Ou, Du, Bu = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    ef = (e1, t)=>{\n        if (!e1 || e1.length < 1) throw new Error(\"too few inputs\");\n        let r = 0, n = e1[r], o = n.dataType, i = n.dims.length;\n        e1.forEach((a, d)=>{\n            if (d !== r) {\n                if (a.dataType !== o) throw new Error(\"input tensors should be one type\");\n                if (a.dims.length !== i) throw new Error(\"input tensors should have the same shape\");\n                a.dims.forEach((l, p)=>{\n                    if (p !== t && l !== n.dims[p]) throw new Error(\"non concat dimensions must match\");\n                });\n            }\n        });\n    }, tf = (e1, t)=>\"\\n  fn calculateInputIndex(index: u32) -> u32 {\\n    let sizeInConcatAxis = array<u32, \".concat(e1, \"u>(\").concat(t, \");\\n    for (var i: u32 = 0u; i < \").concat(e1, \"; i += 1u ) {\\n      if (index < sizeInConcatAxis[i]) {\\n        return i;\\n      }\\n    }\\n    return \").concat(e1, \"u;\\n  }\"), rf = (e1, t)=>{\n        let r = e1.length, n = [];\n        for(let o = 0; o < r; ++o){\n            let i = t.setByOffset(\"global_idx\", e1[o].getByIndices(\"indices\"));\n            r === 1 ? n.push(i) : o === 0 ? n.push(\"if (inputIndex == \".concat(o, \"u) { \").concat(i, \" }\")) : o === r - 1 ? n.push(\"else { \".concat(i, \" }\")) : n.push(\"else if (inputIndex == \".concat(o, \") { \").concat(i, \" }\"));\n        }\n        return n.join(\"\\n\");\n    }, nf = (e1, t, r, n)=>{\n        let o = C.size(r), i = new Array(e1.length), a = new Array(e1.length), d = 0, l = [], p = [], m = [\n            {\n                type: 12,\n                data: o\n            }\n        ];\n        for(let g = 0; g < e1.length; ++g)d += e1[g].dims[t], i[g] = d, p.push(e1[g].dims.length), a[g] = E(\"input\".concat(g), n, p[g]), l.push(\"rank\"), m.push({\n            type: 12,\n            data: i[g]\n        });\n        for(let g = 0; g < e1.length; ++g)m.push(...N(e1[g].dims));\n        m.push(...N(r));\n        let u = M(\"output\", n, r.length), h = u.indicesGet(\"indices\", t), _ = Array.from(Array(i.length).keys()).map((g)=>\"uniforms.sizeInConcatAxis\".concat(g)).join(\",\"), y = (g)=>\"\\n\\n  \".concat((()=>{\n                g.registerUniform(\"outputSize\", \"u32\");\n                for(let x = 0; x < e1.length; x++)g.registerUniform(\"sizeInConcatAxis\".concat(x), \"u32\");\n                return g.declareVariables(...a, u);\n            })(), \"\\n\\n  \").concat(tf(i.length, _), \"\\n\\n  \").concat(g.mainStart(), \"\\n    \").concat(g.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\"), \"\\n\\n    var indices = \").concat(u.offsetToIndices(\"global_idx\"), \";\\n\\n    let inputIndex = calculateInputIndex(\").concat(h, \");\\n    if (inputIndex != 0u) {\\n      let sizeInConcatAxis = array<u32, \").concat(i.length, \"u>(\").concat(_, \");\\n      \").concat(h, \" -= sizeInConcatAxis[inputIndex - 1u];\\n    }\\n\\n    \").concat(rf(a, u), \"\\n  }\");\n        return {\n            name: \"Concat\",\n            shaderCache: {\n                hint: \"\".concat(t),\n                inputDependencies: l\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: r,\n                            dataType: n\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(o / 64)\n                    },\n                    programUniforms: m\n                }),\n            getShaderSource: y\n        };\n    }, Ou = (e1, t)=>{\n        let r = e1.inputs, n = r[0].dims, o = C.normalizeAxis(t.axis, n.length);\n        ef(r, o);\n        let i = n.slice();\n        i[o] = r.reduce((d, l)=>d + (l.dims.length > o ? l.dims[o] : 0), 0);\n        let a = r.filter((d)=>C.size(d.dims) > 0);\n        e1.compute(nf(a, o, i, r[0].dataType), {\n            inputs: a\n        });\n    }, Du = (e1)=>re({\n            axis: e1.axis\n        });\n});\nvar qe, Ke, je, jr, yt = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    qe = function(e1, t) {\n        let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"f32\";\n        switch(e1.activation){\n            case \"Relu\":\n                return \"value = max(value, \".concat(t, \"(0.0));\");\n            case \"Sigmoid\":\n                return \"value = (\".concat(t, \"(1.0) / (\").concat(t, \"(1.0) + exp(-value)));\");\n            case \"Clip\":\n                return \"value = clamp(value, \".concat(t, \"(\").concat(r, \"(uniforms.clip_min)), \").concat(t, \"(\").concat(r, \"(uniforms.clip_max)));\");\n            case \"HardSigmoid\":\n                return \"value = max(\".concat(t, \"(0.0), min(\").concat(t, \"(1.0), \").concat(r, \"(uniforms.alpha) * value + \").concat(r, \"(uniforms.beta)));\");\n            case \"LeakyRelu\":\n                return \"value = select(\".concat(r, \"(uniforms.alpha) * value, value, value >= \").concat(t, \"(0.0));\");\n            case \"Tanh\":\n                return \"let e2x = exp(-2.0 * abs(value));\\n              value = sign(value) * (1.0 - e2x) / (1.0 + e2x);\\n        \";\n            case \"\":\n                return \"\";\n            default:\n                throw new Error(\"Unsupported activation \".concat(e1.activation));\n        }\n    }, Ke = (e1, t)=>{\n        e1.activation === \"Clip\" ? t.push({\n            type: 1,\n            data: e1.clipMax\n        }, {\n            type: 1,\n            data: e1.clipMin\n        }) : e1.activation === \"HardSigmoid\" ? t.push({\n            type: 1,\n            data: e1.alpha\n        }, {\n            type: 1,\n            data: e1.beta\n        }) : e1.activation === \"LeakyRelu\" && t.push({\n            type: 1,\n            data: e1.alpha\n        });\n    }, je = (e1, t)=>{\n        e1.activation === \"Clip\" ? t.push({\n            name: \"clip_max\",\n            type: \"f32\"\n        }, {\n            name: \"clip_min\",\n            type: \"f32\"\n        }) : e1.activation === \"HardSigmoid\" ? t.push({\n            name: \"alpha\",\n            type: \"f32\"\n        }, {\n            name: \"beta\",\n            type: \"f32\"\n        }) : e1.activation === \"LeakyRelu\" && t.push({\n            name: \"alpha\",\n            type: \"f32\"\n        });\n    }, jr = (e1)=>{\n        let t = (e1 === null || e1 === void 0 ? void 0 : e1.activation) || \"\";\n        if (t === \"HardSigmoid\") {\n            let [r, n] = (e1 === null || e1 === void 0 ? void 0 : e1.activation_params) || [\n                .2,\n                .5\n            ];\n            return {\n                activation: t,\n                alpha: r,\n                beta: n\n            };\n        } else if (t === \"Clip\") {\n            let [r, n] = (e1 === null || e1 === void 0 ? void 0 : e1.activation_params) || [\n                es,\n                ts\n            ];\n            return {\n                activation: t,\n                clipMax: n,\n                clipMin: r\n            };\n        } else if (t === \"LeakyRelu\") {\n            let [r] = (e1 === null || e1 === void 0 ? void 0 : e1.activation_params) || [\n                .01\n            ];\n            return {\n                activation: t,\n                alpha: r\n            };\n        }\n        return {\n            activation: t\n        };\n    };\n});\nvar Ae, Mu, Yr = U(()=>{\n    \"use strict\";\n    Ae = (e1, t)=>{\n        switch(e1){\n            case 1:\n                return t;\n            case 2:\n                return \"vec2<\".concat(t, \">\");\n            case 3:\n                return \"vec3<\".concat(t, \">\");\n            case 4:\n                return \"vec4<\".concat(t, \">\");\n            default:\n                throw new Error(\"\".concat(e1, \"-component is not supported.\"));\n        }\n    }, Mu = (e1)=>\"\\n      \".concat(e1 ? \"value = value + getBiasByOutputCoords(coords);\" : \"\", \"\\n      \");\n});\nvar Ru, Uu = U(()=>{\n    \"use strict\";\n    Ru = (e1)=>\"\\nfn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\\n  return dot(coords, vec4<i32>(\\n      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\\n}\\nfn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\\n  return dot(coords, vec4<i32>(\\n    i32(\".concat(e1, \".x), i32(\").concat(e1, \".y), i32(\").concat(e1, \".z), 1));\\n}\\n\");\n});\nvar Jt, Zr, Qr = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    ae();\n    yt();\n    Jt = (e1, t, r, n, o)=>{\n        let i = n - r;\n        return \"\\n      \".concat(Array.from({\n            length: r\n        }).map((a, d)=>\"\\n      if (\".concat(F(t.shape, d, t.rank), \" != 1) {\\n        \").concat(t.indicesSet(e1, d, F(o, d + i, n)), \"\\n      } else {\\n        \").concat(t.indicesSet(e1, d, 0), \"\\n      }\")).join(\"\"), \"\\n\");\n    }, Zr = function(e1, t, r, n) {\n        let o = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1, i = arguments.length > 5 ? arguments[5] : void 0;\n        let a = e1[0].dims, d = e1[1].dims, l = a[a.length - 2], p = d[d.length - 1], m = a[a.length - 1], u = me(p), h = me(m), _ = me(l), y = C.size(r) / u / _, g = e1.length > 2, x = n ? n.slice(0, -2) : r.slice(0, -2), v = [\n            C.size(x),\n            l,\n            p\n        ], S = [\n            {\n                type: 12,\n                data: y\n            },\n            {\n                type: 12,\n                data: l\n            },\n            {\n                type: 12,\n                data: p\n            },\n            {\n                type: 12,\n                data: m\n            }\n        ];\n        Ke(t, S), S.push(...N(x, a, d)), g && S.push(...N(e1[2].dims)), S.push(...N(v));\n        let T = (A)=>{\n            let k = Lr(\"batch_dims\", e1[0].dataType, x.length), P = E(\"a\", e1[0].dataType, a.length, h), D = E(\"b\", e1[1].dataType, d.length, u), R = M(\"output\", e1[0].dataType, v.length, u), G = _e(R.type.tensor), K = qe(t, R.type.value, G), j = [\n                P,\n                D\n            ], V = \"\";\n            if (g) {\n                let Y = o ? u : 1;\n                j.push(E(\"bias\", e1[2].dataType, e1[2].dims.length, Y)), V = \"\".concat(o ? \"value += bias[col / \".concat(Y, \"];\") : \"value += \".concat(R.type.value, \"(bias[row + i]);\"));\n            }\n            let Q = [\n                {\n                    name: \"output_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"M\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"N\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"K\",\n                    type: \"u32\"\n                }\n            ];\n            je(t, Q);\n            let se = ()=>{\n                let Y = \"var a_data: \".concat(P.type.value, \";\");\n                for(let ee = 0; ee < h; ee++)Y += \"\\n              let b_data\".concat(ee, \" = b[(b_offset + (k + \").concat(ee, \") * uniforms.N + col) / \").concat(u, \"];\");\n                for(let ee = 0; ee < _; ee++){\n                    Y += \"a_data = a[(a_offset + (row + \".concat(ee, \") * uniforms.K + k) / \").concat(h, \"];\");\n                    for(let J = 0; J < h; J++)Y += \"\\n            values[\".concat(ee, \"] = fma(\").concat(D.type.value, \"(a_data\").concat(h === 1 ? \"\" : \"[\".concat(J, \"]\"), \"), b_data\").concat(J, \", values[\").concat(ee, \"]);\\n\");\n                }\n                return Y;\n            };\n            return \"\\n  \".concat(A.registerUniforms(Q).registerInternalVariables(k).declareVariables(...j, R), \"\\n  \").concat(A.mainStart(), \"\\n    \").concat(A.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\"), \"\\n    let col = (global_idx % (uniforms.N / \").concat(u, \")) * \").concat(u, \";\\n    var index1 = global_idx / (uniforms.N / \").concat(u, \");\\n    let stride1 = uniforms.M / \").concat(_, \";\\n    let row = (index1 % stride1) * \").concat(_, \";\\n    let batch = index1 / stride1;\\n\\n    \").concat(r.length === 2 ? \"\" : \"let batch_indices = \".concat(k.offsetToIndices(\"batch\"), \";\"), \"\\n\\n    var a_indices: \").concat(P.type.indices, \";\\n    \").concat(Jt(\"a_indices\", P, P.rank - 2, k.rank, \"batch_indices\"), \"\\n    \").concat(P.indicesSet(\"a_indices\", P.rank - 2, 0), \"\\n    \").concat(P.indicesSet(\"a_indices\", P.rank - 1, 0), \"\\n    let a_offset = \").concat(P.indicesToOffset(\"a_indices\"), \";\\n\\n    var b_indices: \").concat(D.type.indices, \";\\n    \").concat(Jt(\"b_indices\", D, D.rank - 2, k.rank, \"batch_indices\"), \"\\n    \").concat(D.indicesSet(\"b_indices\", D.rank - 2, 0), \"\\n    \").concat(D.indicesSet(\"b_indices\", D.rank - 1, 0), \"\\n    let b_offset = \").concat(D.indicesToOffset(\"b_indices\"), \";\\n    var values: array<\").concat(R.type.value, \", \").concat(_, \">;\\n    for (var k: u32 = 0u; k < uniforms.K; k = k + \").concat(h, \") {\\n      \").concat(se(), \"\\n    }\\n    for (var i = 0u; i < \").concat(_, \"u; i++) {\\n      var value = values[i];\\n      \").concat(V, \"\\n      \").concat(K, \"\\n      let cur_indices = \").concat(R.type.indices, \"(batch, row + i, col);\\n      let offset = \").concat(R.indicesToOffset(\"cur_indices\"), \";\\n      \").concat(R.setByOffset(\"offset / \".concat(u), \"value\"), \";\\n    }\\n  }\\n  \");\n        };\n        return {\n            name: \"MatMulNaive\",\n            shaderCache: {\n                hint: \"\".concat(t.activation, \";\").concat(u, \";\").concat(h, \";\").concat(_, \";\").concat(o),\n                inputDependencies: g ? [\n                    \"rank\",\n                    \"rank\",\n                    \"rank\"\n                ] : [\n                    \"rank\",\n                    \"rank\"\n                ]\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: i ? i(r) : r,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(y / 64)\n                    },\n                    programUniforms: S\n                }),\n            getShaderSource: T\n        };\n    };\n});\nvar of, af, ho, Nu, sf, go, uf, er, Xr = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    ae();\n    yt();\n    Qr();\n    Yr();\n    of = (e1, t)=>e1 ? \"\\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\\n          kStart + inputRow,\\n          globalRowStart / innerElementSize + inputCol\".concat(t ? \", batchIndices\" : \"\", \");\\n        \") : \"\\n        mm_Asub[inputRow][inputCol] = mm_readA(batch,\\n          globalRow + innerRow,\\n          kStart / innerElementSize + inputCol\".concat(t ? \", batchIndices\" : \"\", \");\\n        \"), af = (e1, t)=>e1 ? \"\\n        let ACached0 = mm_Asub[k * innerElementSize][localRow];\\n        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];\\n        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];\\n        \".concat(t === 3 ? \"\" : \"let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];\", \"\\n        for (var i = 0; i < rowPerThread; i = i + 1) {\\n          acc[i] = BCached0 * ACached0[i] + acc[i];\\n          acc[i] = BCached1 * ACached1[i] + acc[i];\\n          acc[i] = BCached2 * ACached2[i] + acc[i];\\n          \").concat(t === 3 ? \"\" : \"acc[i] = BCached3 * ACached3[i] + acc[i];\", \"\\n        }\") : \"\\n        for (var i = 0; i < rowPerThread; i = i + 1) {\\n          let ACached = mm_Asub[tileRow + i][k];\\n          acc[i] = BCached0 * ACached.x + acc[i];\\n          acc[i] = BCached1 * ACached.y + acc[i];\\n          acc[i] = BCached2 * ACached.z + acc[i];\\n          \".concat(t === 3 ? \"\" : \"acc[i] = BCached3 * ACached.w + acc[i];\", \"\\n        }\"), ho = function(e1, t) {\n        let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"f32\", n = arguments.length > 3 ? arguments[3] : void 0, o = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1, i = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 32, a = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : !1, d = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : 32;\n        let l = t[1] * e1[1], p = t[0] * e1[0], m = o ? l : i, u = o ? i : l, h = m / t[0], _ = i / t[1];\n        if (!((o && h === 4 && e1[1] === 4 || !o && (h === 3 || h === 4)) && m % t[0] === 0 && i % t[1] === 0 && e1[0] === 4)) throw new Error(\"If transposeA \".concat(o, \" is true, innerElementSize \").concat(h, \" and workPerThread[1] \").concat(e1[1], \" must be 4.\\n      Otherwise, innerElementSize \").concat(h, \" must be 3 or 4.\\n  tileAWidth \").concat(m, \" must be divisible by workgroupSize[0]\").concat(t[0], \". tileInner \").concat(i, \" must be divisible by workgroupSize[1] \").concat(t[1], \". colPerThread \").concat(e1[0], \" must be 4.\"));\n        return \"\\nvar<workgroup> mm_Asub: array<array<vec\".concat(h, \"<\").concat(r, \">, \").concat(m / h, \">, \").concat(u, \">;\\nvar<workgroup> mm_Bsub: array<array<vec4<\").concat(r, \">, \").concat(p / e1[0], \">, \").concat(i, \">;\\n\\nconst rowPerThread = \").concat(e1[1], \";\\nconst colPerThread = \").concat(e1[0], \";\\nconst innerElementSize = \").concat(h, \";\\nconst tileInner = \").concat(i, \";\\n\\n@compute @workgroup_size(\").concat(t[0], \", \").concat(t[1], \", \").concat(t[2], \")\\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\\n        @builtin(global_invocation_id) globalId : vec3<u32>,\\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\\n  let localRow = i32(localId.y);\\n  let tileRow = localRow * rowPerThread;\\n  let tileCol = i32(localId.x);\\n\\n  let globalRow =i32(globalId.y) * rowPerThread;\\n  let globalCol = i32(globalId.x);\\n  let batch = \").concat(a ? \"0\" : \"i32(globalId.z)\", \";\\n  \").concat(n ? \"let batchIndices = \".concat(n.offsetToIndices(\"u32(batch)\"), \";\") : \"\", \"\\n  let globalRowStart = i32(workgroupId.y) * \").concat(l, \";\\n\\n  let num_tiles = \").concat(a ? \"\".concat(Math.ceil(d / i)) : \"(uniforms.dim_inner - 1) / tileInner + 1\", \";\\n  var kStart = \").concat(a ? \"i32(globalId.z) * \".concat(d) : \"0\", \";\\n\\n  var acc: array<vec4<\").concat(r, \">, rowPerThread>;\\n\\n  // Loop over shared dimension.\\n  let tileRowB = localRow * \").concat(_, \";\\n  for (var t = 0; t < num_tiles; t = t + 1) {\\n      // Load one tile of A into local memory.\\n      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\\n          let inputRow = tileRow + innerRow;\\n          let inputCol = tileCol;\\n          \").concat(of(o, n), \"\\n      }\\n\\n      // Load one tile of B into local memory.\\n      for (var innerRow = 0; innerRow < \").concat(_, \"; innerRow = innerRow + 1) {\\n          let inputRow = tileRowB + innerRow;\\n          let inputCol = tileCol;\\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol\").concat(n ? \", batchIndices\" : \"\", \");\\n      }\\n      kStart = kStart + tileInner;\\n      workgroupBarrier();\\n\\n      // Compute acc values for a single thread.\\n      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {\\n          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];\\n          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];\\n          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];\\n          \").concat(h === 3 ? \"\" : \"let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];\", \"\\n\\n          \").concat(af(o, h), \"\\n      }\\n\\n      workgroupBarrier();\\n  }\\n\\n  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\\n      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\\n  }\\n}\");\n    }, Nu = (e1, t)=>e1 ? \"\\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\\n              kStart + inputRow,\\n              globalRowStart + inputCol\".concat(t ? \", batchIndices\" : \"\", \");\\n            \") : \"\\n            mm_Asub[inputRow][inputCol] = mm_readA(batch,\\n              globalRowStart + inputRow,\\n              kStart + inputCol\".concat(t ? \", batchIndices\" : \"\", \");\\n            \"), sf = (e1)=>e1 ? \"let ACached = mm_Asub[k][tileRow + innerRow];\" : \"let ACached = mm_Asub[tileRow + innerRow][k];\", go = function(e1, t) {\n        let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"f32\", n = arguments.length > 3 ? arguments[3] : void 0, o = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1, i = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 32, a = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : !1, d = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : 32, l = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : !1;\n        let p = e1[1] * t[1], m = e1[0] * t[0], u = o ? p : i, h = o ? i : p;\n        if (!(h % t[1] === 0 && u % t[0] === 0 && i % t[1] === 0)) throw new Error(\"tileAHight \".concat(h, \" must be divisible by workgroupSize[1]\").concat(t[1], \", tileAWidth \").concat(u, \" must be divisible by workgroupSize[0]\").concat(t[0], \", tileInner \").concat(i, \" must be divisible by workgroupSize[1]\").concat(t[1]));\n        let _ = h / t[1], y = u / t[0], g = i / t[1], x = l ? \"\\n    let localRow = i32(localId.y);\\n    let localCol = i32(localId.x);\\n    let globalRowStart = i32(workgroupId.y) * \".concat(p, \";\\n    let globalColStart = i32(workgroupId.x) * \").concat(m, \";\\n\\n    // Loop over shared dimension.\\n    for (var t = 0; t < num_tiles; t = t + 1) {\\n      // Load one tile of A into local memory.\\n      for (var inputRow = localRow; inputRow < \").concat(h, \"; inputRow = inputRow + \").concat(t[1], \") {\\n        for (var inputCol = localCol; inputCol < \").concat(u, \"; inputCol = inputCol + \").concat(t[0], \") {\\n          \").concat(Nu(o, n), \"\\n        }\\n      }\\n      // Load one tile of B into local memory.\\n      for (var inputRow = localRow; inputRow < \").concat(i, \"; inputRow = inputRow + \").concat(t[1], \") {\\n            for (var inputCol = localCol; inputCol < \").concat(m, \"; inputCol = inputCol + \").concat(t[0], \") {\\n          mm_Bsub[inputRow][inputCol] = mm_readB(batch,\\n            kStart + inputRow,\\n            globalColStart + inputCol\").concat(n ? \", batchIndices\" : \"\", \");\\n        }\\n      }\\n      kStart = kStart + tileInner;\\n      workgroupBarrier();\\n\\n      // Compute acc values for a single thread.\\n      var BCached : array<\").concat(r, \", colPerThread>;\\n      for (var k = 0; k < tileInner; k = k + 1) {\\n        for (var inner = 0; inner < colPerThread; inner = inner + 1) {\\n          BCached[inner] = mm_Bsub[k][localCol + inner * \").concat(t[0], \"];\\n        }\\n        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\\n          let ACached = \").concat(o ? \"mm_Asub[k][localRow + innerRow * \".concat(t[1], \"];\") : \"mm_Asub[localRow + innerRow * \".concat(t[1], \"][k];\"), \"\\n          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\\n            acc[innerRow][innerCol] = acc[innerRow][innerCol] +\\n                ACached * BCached[innerCol];\\n          }\\n        }\\n      }\\n      workgroupBarrier();\\n    }\\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\\n      let gRow = globalRowStart + localRow + innerRow * \").concat(t[1], \";\\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\\n        let gCol = globalColStart + localCol + innerCol * \").concat(t[0], \";\\n        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\\n      }\\n    }\\n    \") : \"\\nlet tileRow = i32(localId.y) * rowPerThread;\\nlet tileCol = i32(localId.x) * colPerThread;\\n\\nlet globalRow = i32(globalId.y) * rowPerThread;\\nlet globalCol = i32(globalId.x) * colPerThread;\\nlet globalRowStart = i32(workgroupId.y) * \".concat(p, \";\\n\\nlet tileRowA = i32(localId.y) * \").concat(_, \";\\nlet tileColA = i32(localId.x) * \").concat(y, \";\\nlet tileRowB = i32(localId.y) * \").concat(g, \";\\n// Loop over shared dimension.\\nfor (var t = 0; t < num_tiles; t = t + 1) {\\n  // Load one tile of A into local memory.\\n  for (var innerRow = 0; innerRow < \").concat(_, \"; innerRow = innerRow + 1) {\\n    for (var innerCol = 0; innerCol < \").concat(y, \"; innerCol = innerCol + 1) {\\n      let inputRow = tileRowA + innerRow;\\n      let inputCol = tileColA + innerCol;\\n      \").concat(Nu(o, n), \"\\n    }\\n  }\\n\\n  // Load one tile of B into local memory.\\n  for (var innerRow = 0; innerRow < \").concat(g, \"; innerRow = innerRow + 1) {\\n    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\\n      let inputRow = tileRowB + innerRow;\\n      let inputCol = tileCol + innerCol;\\n      mm_Bsub[inputRow][inputCol] = mm_readB(batch,\\n        kStart + inputRow,\\n        globalCol + innerCol\").concat(n ? \", batchIndices\" : \"\", \");\\n    }\\n  }\\n  kStart = kStart + tileInner;\\n  workgroupBarrier();\\n\\n  // Compute acc values for a single thread.\\n  var BCached : array<\").concat(r, \", colPerThread>;\\n  for (var k = 0; k < tileInner; k = k + 1) {\\n    for (var inner = 0; inner < colPerThread; inner = inner + 1) {\\n      BCached[inner] = mm_Bsub[k][tileCol + inner];\\n    }\\n\\n    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\\n      \").concat(sf(o), \"\\n      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\\n        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\\n      }\\n    }\\n  }\\n\\n  workgroupBarrier();\\n}\\n\\nfor (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {\\n  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {\\n    mm_write(batch, globalRow + innerRow, globalCol + innerCol,\\n        acc[innerRow][innerCol]);\\n  }\\n}\\n\");\n        return \"\\n  var<workgroup> mm_Asub : array<array<\".concat(r, \", \").concat(u, \">, \").concat(h, \">;\\n  var<workgroup> mm_Bsub : array<array<\").concat(r, \", \").concat(m, \">, \").concat(i, \">;\\n  const rowPerThread = \").concat(e1[1], \";\\n  const colPerThread = \").concat(e1[0], \";\\n  const tileInner = \").concat(i, \";\\n\\n@compute @workgroup_size(\").concat(t[0], \", \").concat(t[1], \", \").concat(t[2], \")\\nfn main(@builtin(local_invocation_id) localId : vec3<u32>,\\n        @builtin(global_invocation_id) globalId : vec3<u32>,\\n        @builtin(workgroup_id) workgroupId : vec3<u32>) {\\n    let batch = \").concat(a ? \"0\" : \"i32(globalId.z)\", \";\\n    \").concat(n ? \"let batchIndices = \".concat(n.offsetToIndices(\"u32(batch)\"), \";\") : \"\", \"\\n    let num_tiles = \").concat(a ? \"\".concat(Math.ceil(d / i)) : \"(uniforms.dim_inner - 1) / tileInner + 1\", \";\\n    var kStart = \").concat(a ? \"i32(globalId.z) * \".concat(d) : \"0\", \";\\n\\n    var acc : array<array<\").concat(r, \", colPerThread>, rowPerThread>;\\n    \").concat(x, \"\\n  }\\n\");\n    }, uf = function(e1, t, r, n) {\n        let o = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1;\n        let [i, a, d, l] = n, p = _e(n[0].type.tensor);\n        return \"\\n    fn mm_readA(batch: i32, row: i32, colIn: i32, batchIndices: \".concat(i.type.indices, \") -> \").concat(Ae(e1, p), \" {\\n      var value = \").concat(Ae(e1, p), \"(0.0);\\n      let col = colIn * \").concat(e1, \";\\n      if(row < uniforms.dim_a_outer && col < uniforms.dim_inner)\\n      {\\n        var aIndices: \").concat(a.type.indices, \";\\n        \").concat(Jt(\"aIndices\", a, a.rank - 2, i.rank, \"batchIndices\"), \"\\n        \").concat(a.indicesSet(\"aIndices\", a.rank - 2, \"u32(row)\"), \"\\n        \").concat(a.indicesSet(\"aIndices\", a.rank - 1, \"u32(colIn)\"), \"\\n        value = \").concat(a.getByIndices(\"aIndices\"), \";\\n      }\\n      return value;\\n    }\\n\\n    fn mm_readB(batch: i32, row: i32, colIn: i32, batchIndices: \").concat(i.type.indices, \") -> \").concat(Ae(e1, p), \" {\\n      var value = \").concat(Ae(e1, p), \"(0.0);\\n      let col = colIn * \").concat(e1, \";\\n      if(row < uniforms.dim_inner && col < uniforms.dim_b_outer)\\n      {\\n        var bIndices: \").concat(d.type.indices, \";\\n        \").concat(Jt(\"bIndices\", d, d.rank - 2, i.rank, \"batchIndices\"), \"\\n        \").concat(d.indicesSet(\"bIndices\", d.rank - 2, \"u32(row)\"), \"\\n        \").concat(d.indicesSet(\"bIndices\", d.rank - 1, \"u32(colIn)\"), \"\\n        value = \").concat(d.getByIndices(\"bIndices\"), \";\\n      }\\n      return value;\\n    }\\n\\n    fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: \").concat(Ae(e1, p), \") {\\n      let col = colIn * \").concat(e1, \";\\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer) {\\n        var value = valueIn;\\n        let coords = vec3<i32>(batch, row, colIn);\\n        \").concat(t ? \"value = value + \".concat(o ? \"bias[colIn]\" : \"\".concat(Ae(e1, p), \"(bias[row])\"), \";\") : \"\", \"\\n        \").concat(r, \"\\n        \").concat(l.setByIndices(\"vec3<u32>(coords)\", \"value\"), \"\\n      }\\n    }\\n    \");\n    }, er = function(e1, t, r, n) {\n        let o = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1, i = arguments.length > 5 ? arguments[5] : void 0;\n        let a = e1[0].dims, d = e1[1].dims, l = a.slice(0, -2), p = d.slice(0, -2), m = n ? n.slice(0, -2) : r.slice(0, -2), u = C.size(m), h = a[a.length - 2], _ = a[a.length - 1], y = d[d.length - 1], g = _ % 4 === 0 && y % 4 === 0, x = h <= 8 ? [\n            4,\n            1,\n            1\n        ] : [\n            4,\n            4,\n            1\n        ], $ = [\n            8,\n            8,\n            1\n        ], v = [\n            Math.ceil(y / $[0] / x[0]),\n            Math.ceil(h / $[1] / x[1]),\n            Math.ceil(u / $[2] / x[2])\n        ], S = g ? 4 : 1, T = [\n            ...l,\n            h,\n            _ / S\n        ], A = T.length, k = [\n            ...p,\n            _,\n            y / S\n        ], P = k.length, D = [\n            u,\n            h,\n            y / S\n        ], R = [\n            {\n                type: 6,\n                data: h\n            },\n            {\n                type: 6,\n                data: y\n            },\n            {\n                type: 6,\n                data: _\n            }\n        ];\n        Ke(t, R), R.push(...N(m, T, k));\n        let G = [\n            \"rank\",\n            \"rank\"\n        ], K = e1.length > 2;\n        K && (R.push(...N(e1[2].dims)), G.push(\"rank\")), R.push(...N(D));\n        let j = (V)=>{\n            let Q = m.length, se = Lr(\"batchDims\", e1[0].dataType, Q, 1), Y = _e(e1[0].dataType), ee = E(\"a\", e1[0].dataType, A, S), J = E(\"b\", e1[1].dataType, P, S), ne = M(\"result\", e1[0].dataType, D.length, S), be = [\n                ee,\n                J\n            ];\n            if (K) {\n                let q = o ? S : 1;\n                be.push(E(\"bias\", e1[2].dataType, e1[2].dims.length, q));\n            }\n            let Oe = [\n                {\n                    name: \"dim_a_outer\",\n                    type: \"i32\"\n                },\n                {\n                    name: \"dim_b_outer\",\n                    type: \"i32\"\n                },\n                {\n                    name: \"dim_inner\",\n                    type: \"i32\"\n                }\n            ];\n            je(t, Oe);\n            let $e = _e(ne.type.tensor), le = qe(t, ne.type.value, $e), W = uf(S, K, le, [\n                se,\n                ee,\n                J,\n                ne\n            ], o);\n            return \"\\n  \".concat(V.registerUniforms(Oe).registerInternalVariables(se).declareVariables(...be, ne), \"\\n  \").concat(W, \"\\n  \").concat(g ? ho(x, $, Y, se) : go(x, $, Y, se), \"\\n                   \");\n        };\n        return {\n            name: \"MatMul\",\n            shaderCache: {\n                hint: \"\".concat(x, \";\").concat(t.activation, \";\").concat(g, \";\").concat(o),\n                inputDependencies: G\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: i ? i(r) : r,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: v[0],\n                        y: v[1],\n                        z: v[2]\n                    },\n                    programUniforms: R\n                }),\n            getShaderSource: j\n        };\n    };\n});\nvar df, Vu, Wu = U(()=>{\n    \"use strict\";\n    te();\n    et();\n    ae();\n    yt();\n    Yr();\n    Uu();\n    Xr();\n    df = function(e1, t, r, n) {\n        let o = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1, i = arguments.length > 5 ? arguments[5] : void 0, a = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : 4, d = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : 4, l = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : 4, p = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : \"f32\";\n        let m = (G)=>{\n            switch(G){\n                case 1:\n                    return \"resData = x[xIndex];\";\n                case 3:\n                    return \"resData = vec3<\".concat(p, \">(x[xIndex], x[xIndex + 1], x[xIndex + 2]);\");\n                case 4:\n                    return \"resData = x[xIndex / 4];\";\n                default:\n                    throw new Error(\"innerElementSize \".concat(G, \" is not supported.\"));\n            }\n        }, u = (G)=>{\n            switch(G){\n                case 1:\n                    return \"return w[row * i32(uniforms.w_shape[3]) + colIn];\";\n                case 4:\n                    return \"return w[row * i32(uniforms.w_shape[3]) / 4 + colIn];\";\n                default:\n                    throw new Error(\"innerElementSize \".concat(G, \" is not supported.\"));\n            }\n        }, h = e1 ? \"\\n    let coord = vec4<i32>(batch, xRow, xCol, xCh);\\n    \" : \"\\n    let coord = vec4<i32>(batch, xCh, xRow, xCol);\\n    \", _ = e1 ? \"\\n    let coords = vec4<i32>(\\n      batch,\\n      row / outWidth,\\n      row % outWidth,\\n      col);\\n    \" : \"\\n    let coords = vec4<i32>(\\n      batch,\\n      row,\\n      col / outWidth,\\n      col % outWidth);\\n    \", y = e1 ? \"i32(uniforms.x_shape[1])\" : \"i32(uniforms.x_shape[2])\", g = e1 ? \"i32(uniforms.x_shape[2])\" : \"i32(uniforms.x_shape[3])\", x = e1 ? \"row\" : \"col\", $ = e1 ? \"col\" : \"row\", v = \"\\n    let inChannels = i32(uniforms.w_shape[2]);\\n    let outWidth = \".concat(e1 ? \"i32(uniforms.result_shape[2])\" : \"i32(uniforms.result_shape[3])\", \";\\n    let outRow = \").concat(x, \" / outWidth;\\n    let outCol = \").concat(x, \" % outWidth;\\n\\n    let WRow = \").concat($, \" / (i32(uniforms.w_shape[1]) * inChannels);\\n    let WCol = \").concat($, \" / inChannels % i32(uniforms.w_shape[1]);\\n    let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];\\n    let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];\\n    let xCh = \").concat($, \" % inChannels;\\n    var resData = \").concat(Ae(a, p), \"(0.0);\\n    // The bounds checking is always needed since we use it to pad zero for\\n    // the 'same' padding type.\\n    if (xRow >= 0 && xRow < \").concat(y, \" && xCol >= 0 && xCol < \").concat(g, \") {\\n      \").concat(h, \"\\n      let xIndex = getIndexFromCoords4D(coord, vec4<i32>(uniforms.x_shape));\\n      \").concat(m(a), \"\\n    }\\n    return resData;\"), S = e1 ? t && n ? \"\\n    let col = colIn * \".concat(a, \";\\n    \").concat(v) : \"\\n    let col = colIn * \".concat(a, \";\\n    if (row < uniforms.dim_a_outer && col < uniforms.dim_inner) {\\n      \").concat(v, \"\\n    }\\n    return \").concat(Ae(a, p), \"(0.0);\") : n && r ? \"\\n    let col = colIn * \".concat(a, \";\\n    \").concat(v) : \"\\n    let col = colIn * \".concat(a, \";\\n    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {\\n      \").concat(v, \"\\n    }\\n    return \").concat(Ae(a, p), \"(0.0);\"), T = e1 ? n && r ? u(d) : \"\\n    let col = colIn * \".concat(d, \";\\n    if (row < uniforms.dim_inner && col < uniforms.dim_b_outer) {\\n      \").concat(u(d), \"\\n    }\\n    return \").concat(Ae(d, p), \"(0.0);\") : \"\\n    let col = colIn * \".concat(d, \";\\n    if (row < uniforms.dim_inner && col < uniforms.dim_a_outer) {\\n      \").concat(u(d), \"\\n    }\\n    return \").concat(Ae(d, p), \"(0.0);\"), A = Ae(l, p), k = e1 ? Ae(a, p) : Ae(d, p), P = e1 ? Ae(d, p) : Ae(a, p), D = qe(i, A, p);\n        return \"\\n    fn mm_readA(batch: i32, row : i32, colIn : i32) -> \".concat(k, \" {\\n      \").concat(e1 ? S : T, \"\\n    }\\n\\n    fn mm_readB(batch: i32, row : i32, colIn : i32) -> \").concat(P, \" {\\n      \").concat(e1 ? T : S, \"\\n    }\\n\\n    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : \").concat(A, \") {\\n      let col = colIn * \").concat(l, \";\\n      if (row < uniforms.dim_a_outer && col < uniforms.dim_b_outer)\\n      {\\n      var value = valueIn;\\n      let outWidth = \").concat(e1 ? \"i32(uniforms.result_shape[2])\" : \"i32(uniforms.result_shape[3])\", \";\\n      \").concat(_, \"\\n      \").concat(Mu(o), \"\\n      \").concat(D, \"\\n      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\\n      }\\n    }\");\n    }, Vu = (e1, t, r, n, o, i, a, d, l)=>{\n        let p = t.format === \"NHWC\", m = p ? e1[0].dims[3] : e1[0].dims[1], u = r[0], h = p ? r[2] : r[3], _ = p ? r[1] : r[2], y = p ? r[3] : r[1], g = p && (m % 4 === 0 || m % 3 === 0) && y % 4 === 0, x = p ? y : h * _, $ = p ? h * _ : y, v = [\n            8,\n            8,\n            1\n        ], S = n <= 8 ? [\n            4,\n            1,\n            1\n        ] : [\n            4,\n            4,\n            1\n        ], T = [\n            Math.ceil(x / v[0] / S[0]),\n            Math.ceil($ / v[1] / S[1]),\n            Math.ceil(u / v[2] / S[2])\n        ];\n        ue(\"verbose\", ()=>\"[conv2d_mm_webgpu] dispatch = \".concat(T));\n        let A = g ? p && m % 4 !== 0 ? 3 : 4 : 1, k = v[1] * S[1], P = v[0] * S[0], D = Math.max(v[0] * A, v[1]), R = n % k === 0, G = o % P === 0, K = i % D === 0, j = g ? [\n            A,\n            4,\n            4\n        ] : [\n            1,\n            1,\n            1\n        ], V = [\n            {\n                type: 6,\n                data: n\n            },\n            {\n                type: 6,\n                data: o\n            },\n            {\n                type: 6,\n                data: i\n            },\n            {\n                type: 6,\n                data: [\n                    t.pads[0],\n                    t.pads[1]\n                ]\n            },\n            {\n                type: 6,\n                data: t.strides\n            },\n            {\n                type: 6,\n                data: t.dilations\n            }\n        ];\n        Ke(t, V), V.push(...N(e1[0].dims, e1[1].dims));\n        let Q = [\n            \"rank\",\n            \"rank\"\n        ];\n        a && (V.push(...N(e1[2].dims)), Q.push(\"rank\")), V.push(...N(r));\n        let se = (Y)=>{\n            let ee = [\n                {\n                    name: \"dim_a_outer\",\n                    type: \"i32\"\n                },\n                {\n                    name: \"dim_b_outer\",\n                    type: \"i32\"\n                },\n                {\n                    name: \"dim_inner\",\n                    type: \"i32\"\n                },\n                {\n                    name: \"pad\",\n                    type: \"i32\",\n                    length: 2\n                },\n                {\n                    name: \"stride\",\n                    type: \"i32\",\n                    length: 2\n                },\n                {\n                    name: \"dilation\",\n                    type: \"i32\",\n                    length: 2\n                }\n            ];\n            je(t, ee);\n            let J = g ? 4 : 1, ne = _e(e1[0].dataType), be = \"\\n      fn setOutputAtIndex(flatIndex : i32, value : \".concat(g ? \"vec4<\".concat(ne, \">\") : ne, \") {\\n        result[flatIndex] = \").concat(g ? \"vec4<\".concat(ne, \">\") : ne, \"(value);\\n      }\\n      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : \").concat(g ? \"vec4<\".concat(ne, \">\") : ne, \") {\\n        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));\\n        setOutputAtIndex(flatIndex \").concat(g ? \"/ 4\" : \"\", \", value);\\n      }\"), Oe = E(\"x\", e1[0].dataType, e1[0].dims.length, A === 3 ? 1 : A), $e = E(\"w\", e1[1].dataType, e1[1].dims.length, J), le = [\n                Oe,\n                $e\n            ], W = M(\"result\", e1[0].dataType, r.length, J);\n            if (a) {\n                let q = E(\"bias\", e1[2].dataType, e1[2].dims.length, J);\n                le.push(q), be += \"\\n        fn getBiasByOutputCoords(coords : vec4<i32>) -> \".concat(g ? \"vec4<\".concat(ne, \">\") : ne, \" {\\n          return bias[coords.\").concat(p ? \"w\" : \"y\").concat(g ? \"/ 4\" : \"\", \"];\\n        }\");\n            }\n            return \"\\n        \".concat(Ru(\"uniforms.result_strides\"), \"\\n        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,\\n        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,\\n        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };\\n        \").concat(Y.registerUniforms(ee).declareVariables(...le, W), \"\\n        \").concat(be, \"\\n        \").concat(df(p, R, G, K, a, t, j[0], j[1], j[2], ne), \"\\n        \").concat(g ? ho(S, v, ne, void 0, !p, D) : go(S, v, ne, void 0, !p, D, !1, void 0, d));\n        };\n        return {\n            name: \"Conv2DMatMul\",\n            shaderCache: {\n                hint: \"\".concat(t.cacheKey, \";\").concat(A, \";\").concat(g, \";\").concat(R, \";\").concat(G, \";\").concat(K, \";\").concat(k, \";\").concat(P, \";\").concat(D),\n                inputDependencies: Q\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: l ? l(r) : r,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: T[0],\n                        y: T[1],\n                        z: T[2]\n                    },\n                    programUniforms: V\n                }),\n            getShaderSource: se\n        };\n    };\n});\nvar lf, Lu, Jr, cf, Gu, pf, Hu, Fu, qu = U(()=>{\n    \"use strict\";\n    te();\n    et();\n    oe();\n    ae();\n    yt();\n    Yr();\n    lf = (e1)=>{\n        let t = 1;\n        for(let r = 0; r < e1.length; r++)t *= e1[r];\n        return t;\n    }, Lu = (e1)=>typeof e1 == \"number\" ? [\n            e1,\n            e1,\n            e1\n        ] : e1, Jr = (e1, t)=>t <= 1 ? e1 : e1 + (e1 - 1) * (t - 1), cf = function(e1, t, r) {\n        let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;\n        let o = Jr(t, n);\n        return Math.floor((e1[0] * (r - 1) - r + o) / 2);\n    }, Gu = (e1, t, r, n, o)=>{\n        o == null && (o = cf(e1, t[0], n[0]));\n        let i = [\n            0,\n            0,\n            0,\n            r\n        ];\n        for(let a = 0; a < 3; a++)e1[a] + 2 * o >= t[a] && (i[a] = Math.trunc((e1[a] - t[a] + 2 * o) / n[a] + 1));\n        return i;\n    }, pf = (e1, t, r, n, o, i, a, d, l, p)=>{\n        let m, u, h, _;\n        if (e1 === \"VALID\" && (e1 = 0), typeof e1 == \"number\") {\n            m = {\n                top: e1,\n                bottom: e1,\n                left: e1,\n                right: e1,\n                front: e1,\n                back: e1\n            };\n            let y = Gu([\n                t,\n                r,\n                n,\n                1\n            ], [\n                d,\n                l,\n                p\n            ], 1, [\n                o,\n                i,\n                a\n            ], e1);\n            u = y[0], h = y[1], _ = y[2];\n        } else if (Array.isArray(e1)) {\n            if (!e1.every((g, x, $)=>g === $[0])) throw Error(\"Unsupported padding parameter: \".concat(e1));\n            m = {\n                top: e1[0],\n                bottom: e1[1],\n                left: e1[2],\n                right: e1[3],\n                front: e1[4],\n                back: e1[5]\n            };\n            let y = Gu([\n                t,\n                r,\n                n,\n                1\n            ], [\n                d,\n                l,\n                p\n            ], 1, [\n                o,\n                i,\n                a\n            ], e1[0]);\n            u = y[0], h = y[1], _ = y[2];\n        } else if (e1 === \"SAME_UPPER\") {\n            u = Math.ceil(t / o), h = Math.ceil(r / i), _ = Math.ceil(n / a);\n            let y = (u - 1) * o + d - t, g = (h - 1) * i + l - r, x = (_ - 1) * a + p - n, $ = Math.floor(y / 2), v = y - $, S = Math.floor(g / 2), T = g - S, A = Math.floor(x / 2), k = x - A;\n            m = {\n                top: S,\n                bottom: T,\n                left: A,\n                right: k,\n                front: $,\n                back: v\n            };\n        } else throw Error(\"Unknown padding parameter: \".concat(e1));\n        return {\n            padInfo: m,\n            outDepth: u,\n            outHeight: h,\n            outWidth: _\n        };\n    }, Hu = function(e1, t, r, n, o) {\n        let i = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : !1, a = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : \"channelsLast\";\n        let d, l, p, m, u;\n        if (a === \"channelsLast\") [d, l, p, m, u] = e1;\n        else if (a === \"channelsFirst\") [d, u, l, p, m] = e1;\n        else throw new Error(\"Unknown dataFormat \".concat(a));\n        let [h, , _, y, g] = t, [x, $, v] = Lu(r), [S, T, A] = Lu(n), k = Jr(_, S), P = Jr(y, T), D = Jr(g, A), { padInfo: R, outDepth: G, outHeight: K, outWidth: j } = pf(o, l, p, m, x, $, v, k, P, D), V = i ? h * u : h, Q = [\n            0,\n            0,\n            0,\n            0,\n            0\n        ];\n        return a === \"channelsFirst\" ? Q = [\n            d,\n            V,\n            G,\n            K,\n            j\n        ] : a === \"channelsLast\" && (Q = [\n            d,\n            G,\n            K,\n            j,\n            V\n        ]), {\n            batchSize: d,\n            dataFormat: a,\n            inDepth: l,\n            inHeight: p,\n            inWidth: m,\n            inChannels: u,\n            outDepth: G,\n            outHeight: K,\n            outWidth: j,\n            outChannels: V,\n            padInfo: R,\n            strideDepth: x,\n            strideHeight: $,\n            strideWidth: v,\n            filterDepth: _,\n            filterHeight: y,\n            filterWidth: g,\n            effectiveFilterDepth: k,\n            effectiveFilterHeight: P,\n            effectiveFilterWidth: D,\n            dilationDepth: S,\n            dilationHeight: T,\n            dilationWidth: A,\n            inShape: e1,\n            outShape: Q,\n            filterShape: t\n        };\n    }, Fu = (e1, t, r, n, o, i)=>{\n        let a = i === \"channelsLast\", d = a ? e1[0].dims[3] : e1[0].dims[1], l = !1, p = [\n            64,\n            1,\n            1\n        ], m = {\n            x: r.map((v, S)=>S)\n        }, u = [\n            Math.ceil(lf(m.x.map((v)=>r[v])) / p[0]),\n            1,\n            1\n        ];\n        ue(\"verbose\", ()=>\"[conv3d_naive_webgpu] dispatch = \".concat(u));\n        let h = l ? a && d % 4 !== 0 ? 3 : 4 : 1, _ = C.size(r), y = [\n            {\n                type: 12,\n                data: _\n            },\n            {\n                type: 12,\n                data: n\n            },\n            {\n                type: 12,\n                data: o\n            },\n            {\n                type: 12,\n                data: t.strides\n            },\n            {\n                type: 12,\n                data: t.dilations\n            }\n        ];\n        Ke(t, y), y.push(...N(e1[0].dims, e1[1].dims));\n        let g = [\n            \"rank\",\n            \"rank\"\n        ], x = e1.length === 3;\n        x && (y.push(...N(e1[2].dims)), g.push(\"rank\")), y.push(...N(r));\n        let $ = (v)=>{\n            let S = [\n                {\n                    name: \"output_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"filter_dims\",\n                    type: \"u32\",\n                    length: n.length\n                },\n                {\n                    name: \"pads\",\n                    type: \"u32\",\n                    length: o.length\n                },\n                {\n                    name: \"strides\",\n                    type: \"u32\",\n                    length: t.strides.length\n                },\n                {\n                    name: \"dilations\",\n                    type: \"u32\",\n                    length: t.dilations.length\n                }\n            ];\n            je(t, S);\n            let T = l ? 4 : 1, A = _e(e1[0].dataType), k = E(\"x\", e1[0].dataType, e1[0].dims.length, h === 3 ? 1 : h), P = E(\"W\", e1[1].dataType, e1[1].dims.length, T), D = [\n                k,\n                P\n            ], R = M(\"result\", e1[0].dataType, r.length, T), G = \"\";\n            if (x) {\n                let V = E(\"bias\", e1[2].dataType, e1[2].dims.length, T);\n                D.push(V), G += \"\\n        fn getBiasByOutputCoords(coords : array<u32, 5>) -> \".concat(l ? \"vec4<\".concat(A, \">\") : A, \" {\\n          return bias[\").concat(a ? F(\"coords\", 4, 5) : F(\"coords\", 1, 5)).concat(l ? \"/ 4\" : \"\", \"];\\n        }\");\n            }\n            let K = Ae(h, A), j = qe(t, K, A);\n            return \"\\n            \".concat(G, \"\\n            fn getX(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {\\n              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);\\n              return \").concat(k.getByIndices(\"aIndices\"), \";\\n            }\\n            fn getW(d0 : u32, d1 : u32, d2 : u32, d3 : u32, d4 : u32) -> f32 {\\n              let aIndices = array<u32, 5>(d0, d1, d2, d3, d4);\\n              return \").concat(P.getByIndices(\"aIndices\"), \";\\n            }\\n          \").concat(v.registerUniforms(S).declareVariables(...D, R), \"\\n          \").concat(v.mainStart(), \"\\n          \").concat(v.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\"), \"\\n              let coords = \").concat(R.offsetToIndices(\"global_idx\"), \";\\n              let batch = \").concat(F(\"coords\", 0, k.rank), \";\\n              let d2 = \").concat(a ? F(\"coords\", k.rank - 1, k.rank) : F(\"coords\", 1, k.rank), \";\\n              let xFRCCorner = vec3<u32>(\").concat(a ? F(\"coords\", 1, k.rank) : F(\"coords\", 2, k.rank), \",\\n              \").concat(a ? F(\"coords\", 2, k.rank) : F(\"coords\", 3, k.rank), \",\\n              \").concat(a ? F(\"coords\", 3, k.rank) : F(\"coords\", 4, k.rank), \") * uniforms.strides - uniforms.pads;\\n              let xFCorner = xFRCCorner.x;\\n              let xRCorner = xFRCCorner.y;\\n              let xCCorner = xFRCCorner.z;\\n              let xShapeY = \").concat(a ? F(\"uniforms.x_shape\", 1, k.rank) : F(\"uniforms.x_shape\", 2, k.rank), \";\\n              let xShapeZ = \").concat(a ? F(\"uniforms.x_shape\", 2, k.rank) : F(\"uniforms.x_shape\", 3, k.rank), \";\\n              let xShapeW = \").concat(a ? F(\"uniforms.x_shape\", 3, k.rank) : F(\"uniforms.x_shape\", 4, k.rank), \";\\n              let xShapeU = \").concat(a ? F(\"uniforms.x_shape\", 4, k.rank) : F(\"uniforms.x_shape\", 1, k.rank), \";\\n              let inputDepthNearestVec4 = (xShapeU / 4) * 4;\\n              let inputDepthVec4Remainder = xShapeU % 4;\\n\\n              var value = 0.0;\\n              for (var wF = 0u; wF < uniforms.filter_dims[0]; wF++) {\\n                let xF = xFCorner + wF * uniforms.dilations[0];\\n                if (xF < 0 || xF >= xShapeY) {\\n                  continue;\\n                }\\n\\n                for (var wR = 0u; wR < uniforms.filter_dims[1]; wR++) {\\n                  let xR = xRCorner + wR * uniforms.dilations[1];\\n                  if (xR < 0 || xR >= xShapeZ) {\\n                    continue;\\n                  }\\n\\n                  for (var wC = 0u; wC < uniforms.filter_dims[2]; wC++) {\\n                    let xC = xCCorner + wC * uniforms.dilations[2];\\n                    if (xC < 0 || xC >= xShapeW) {\\n                      continue;\\n                    }\\n\\n                    for (var d1 = 0u; d1 < inputDepthNearestVec4; d1 += 4) {\\n                      \").concat(a ? \"let xValues = vec4<f32>(\\n                               getX(batch, xF, xR, xC, d1),\\n                               getX(batch, xF, xR, xC, d1 + 1),\\n                               getX(batch, xF, xR, xC, d1 + 2),\\n                               getX(batch, xF, xR, xC, d1 + 3));\\n                            \" : \"let xValues = vec4<f32>(\\n                               getX(batch, d1, xF, xR, xC),\\n                               getX(batch, d1 + 1, xF, xR, xC),\\n                               getX(batch, d1 + 2, xF, xR, xC),\\n                               getX(batch, d1 + 3, xF, xR, xC));\\n                            \", \"\\n                            let wValues = vec4<f32>(\\n                              getW(d2, d1, wF, wR, wC),\\n                              getW(d2, d1 + 1, wF, wR, wC),\\n                              getW(d2, d1 + 2, wF, wR, wC),\\n                              getW(d2, d1 + 3, wF, wR, wC));\\n                      value += dot(xValues, wValues);\\n                    }\\n                    if (inputDepthVec4Remainder == 1) {\\n                        \").concat(a ? \"value += getX(batch, xF, xR, xC, inputDepthNearestVec4)\\n                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);\" : \"value += getX(batch, inputDepthNearestVec4, xF, xR, xC)\\n                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);\", \"\\n                    } else if (inputDepthVec4Remainder == 2) {\\n                      \").concat(a ? \"let xValues = vec2<f32>(\\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4),\\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));\\n                      \" : \"let xValues = vec2<f32>(\\n                        getX(batch, inputDepthNearestVec4, xF, xR, xC),\\n                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));\\n                    \", \"\\n                    let wValues = vec2<f32>(\\n                      getW(d2, inputDepthNearestVec4, wF, wR, wC),\\n                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));\\n                      value += dot(xValues, wValues);\\n                    } else if (inputDepthVec4Remainder == 3) {\\n                      \").concat(a ? \"let xValues = vec3<f32>(\\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4),\\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),\\n                        getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));\\n                      \" : \"let xValues = vec3<f32>(\\n                        getX(batch, inputDepthNearestVec4, xF, xR, xC),\\n                        getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),\\n                        getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));\\n                    \", \"\\n                    let wValues = vec3<f32>(\\n                      getW(d2, inputDepthNearestVec4, wF, wR, wC),\\n                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),\\n                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));\\n                      value += dot(xValues, wValues);\\n                    }\\n                  }\\n                }\\n              }\\n              \").concat(x ? \"value = value + getBiasByOutputCoords(coords)\" : \"\", \";\\n              \").concat(j, \"\\n              result[global_idx] = f32(value);\\n          }\");\n        };\n        return {\n            name: \"Conv3DNaive\",\n            shaderCache: {\n                hint: \"\".concat(t.cacheKey, \";\").concat(a, \";\").concat(h, \";\").concat(x),\n                inputDependencies: g\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: r,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: u[0],\n                        y: u[1],\n                        z: u[2]\n                    },\n                    programUniforms: y\n                }),\n            getShaderSource: $\n        };\n    };\n});\nvar Ku, ju, Yu = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    ae();\n    yt();\n    Ku = (e1, t, r, n)=>{\n        let o = e1.length > 2, i = o ? \"value += b[output_channel];\" : \"\", a = e1[0].dims, d = e1[1].dims, l = t.format === \"NHWC\", p = l ? r[3] : r[1], m = p / t.group, u = l && m >= 4 ? me(p) : 1, h = C.size(r) / u, _ = [\n            {\n                type: 12,\n                data: h\n            },\n            {\n                type: 12,\n                data: t.dilations\n            },\n            {\n                type: 12,\n                data: [\n                    t.strides[0],\n                    t.strides[1]\n                ]\n            },\n            {\n                type: 12,\n                data: [\n                    t.pads[0],\n                    t.pads[1]\n                ]\n            },\n            {\n                type: 12,\n                data: m\n            }\n        ];\n        Ke(t, _), _.push(...N(a, [\n            d[0],\n            d[1],\n            d[2],\n            d[3] / u\n        ]));\n        let y = o ? [\n            \"rank\",\n            \"rank\",\n            \"rank\"\n        ] : [\n            \"rank\",\n            \"rank\"\n        ];\n        _.push(...N([\n            r[0],\n            r[1],\n            r[2],\n            r[3] / u\n        ]));\n        let g = (x)=>{\n            let $ = M(\"output\", e1[0].dataType, r.length, u), v = _e($.type.tensor), S = qe(t, $.type.value, v), T = E(\"x\", e1[0].dataType, a.length), A = E(\"w\", e1[1].dataType, d.length, u), k = [\n                T,\n                A\n            ];\n            o && k.push(E(\"b\", e1[2].dataType, e1[2].dims, u));\n            let P = [\n                {\n                    name: \"output_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"dilations\",\n                    type: \"u32\",\n                    length: t.dilations.length\n                },\n                {\n                    name: \"strides\",\n                    type: \"u32\",\n                    length: 2\n                },\n                {\n                    name: \"pads\",\n                    type: \"u32\",\n                    length: 2\n                },\n                {\n                    name: \"output_channels_per_group\",\n                    type: \"u32\"\n                }\n            ];\n            je(t, P);\n            let D = l ? \"\\n      for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[0]; wHeight++) {\\n        let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];\\n\\n        if (xHeight < 0u || xHeight >= uniforms.x_shape[1]) {\\n          continue;\\n        }\\n\\n        for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[1]; wWidth++) {\\n          let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];\\n          if (xWidth < 0u || xWidth >= uniforms.x_shape[2]) {\\n            continue;\\n          }\\n\\n          for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[2]; wInChannel++) {\\n            let input_channel = in_channel_offset + wInChannel;\\n            let xVal = \".concat(T.get(\"batch\", \"xHeight\", \"xWidth\", \"input_channel\"), \";\\n            let wVal = \").concat(A.get(\"wHeight\", \"wWidth\", \"wInChannel\", \"output_channel\"), \";\\n            value += xVal * wVal;\\n          }\\n        }\\n      }\\n      \") : \"\\n      for (var wInChannel: u32 = 0u; wInChannel < uniforms.w_shape[1]; wInChannel++) {\\n        let input_channel = in_channel_offset + wInChannel;\\n        for (var wHeight: u32 = 0u; wHeight < uniforms.w_shape[2]; wHeight++) {\\n          let xHeight = xRCCorner.x + wHeight * uniforms.dilations[0];\\n\\n          if (xHeight < 0u || xHeight >= uniforms.x_shape[2]) {\\n            continue;\\n          }\\n\\n          for (var wWidth: u32 = 0u; wWidth < uniforms.w_shape[3]; wWidth++) {\\n            let xWidth = xRCCorner.y + wWidth * uniforms.dilations[1];\\n            if (xWidth < 0u || xWidth >= uniforms.x_shape[3]) {\\n              continue;\\n            }\\n\\n            let xVal = \".concat(T.get(\"batch\", \"input_channel\", \"xHeight\", \"xWidth\"), \";\\n            let wVal = \").concat(A.get(\"output_channel\", \"wInChannel\", \"wHeight\", \"wWidth\"), \";\\n            value += xVal * wVal;\\n          }\\n        }\\n      }\\n      \");\n            return \"\\n  \".concat(x.registerUniforms(P).declareVariables(...k, $), \"\\n\\n  \").concat(x.mainStart(), \"\\n    \").concat(x.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\"), \"\\n\\n    let outputIndices = \").concat($.offsetToIndices(\"global_idx\"), \";\\n    let batch: u32 = outputIndices[0];\\n    let output_channel: u32 = outputIndices[\").concat(l ? 3 : 1, \"];\\n    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[\").concat(l ? 1 : 2, \"], outputIndices[\").concat(l ? 2 : 3, \"]) * uniforms.strides - uniforms.pads;\\n    let group_id: u32 = output_channel * \").concat(u, \" / uniforms.output_channels_per_group;\\n    var in_channel_offset = group_id * uniforms.w_shape[\").concat(l ? 2 : 1, \"];\\n\\n    var value: \").concat($.type.value, \" = \").concat($.type.value, \"(0);\\n    \").concat(D, \"\\n    \").concat(i, \"\\n    \").concat(S, \"\\n    \").concat($.setByOffset(\"global_idx\", \"value\"), \"\\n  }\");\n        };\n        return {\n            name: \"GroupedConv\",\n            shaderCache: {\n                hint: \"\".concat(t.cacheKey, \"_\").concat(u),\n                inputDependencies: y\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: n ? n(r) : r,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(h / 64)\n                    },\n                    programUniforms: _\n                }),\n            getShaderSource: g\n        };\n    }, ju = (e1, t, r, n)=>{\n        let o = e1.length > 2, i = me(r[3]), a = me(r[2]), d = C.size(r) / i / a, l = [\n            e1[0].dims[0],\n            e1[0].dims[1],\n            e1[0].dims[2],\n            e1[0].dims[3] / i\n        ], p = [\n            e1[1].dims[0],\n            e1[1].dims[1],\n            e1[1].dims[2],\n            e1[1].dims[3] / i\n        ], m = [\n            r[0],\n            r[1],\n            r[2],\n            r[3] / i\n        ], u = [\n            {\n                type: 12,\n                data: d\n            },\n            {\n                type: 6,\n                data: [\n                    t.strides[0],\n                    t.strides[1]\n                ]\n            },\n            {\n                type: 6,\n                data: [\n                    t.pads[0],\n                    t.pads[1]\n                ]\n            }\n        ];\n        Ke(t, u), u.push(...N(l, p, m));\n        let h = (a - 1) * t.strides[1] + p[1], _ = (y)=>{\n            let g = M(\"output\", e1[0].dataType, m.length, i), x = _e(g.type.tensor), $ = qe(t, g.type.value, x), v = E(\"x\", e1[0].dataType, l.length, i), S = E(\"w\", e1[1].dataType, p.length, i), T = [\n                v,\n                S\n            ];\n            o && T.push(E(\"b\", e1[2].dataType, e1[2].dims, i));\n            let A = o ? \"value += b[output_channel];\" : \"\", k = [\n                {\n                    name: \"output_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"strides\",\n                    type: \"i32\",\n                    length: 2\n                },\n                {\n                    name: \"pads\",\n                    type: \"i32\",\n                    length: 2\n                }\n            ];\n            return je(t, k), \"\\n  \".concat(y.registerUniforms(k).declareVariables(...T, g), \"\\n  \").concat(y.mainStart(), \"\\n    \").concat(y.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\"), \"\\n    let width0 = uniforms.output_shape[3];\\n    let output_channel = global_idx % width0;\\n    var index1 = global_idx / width0;\\n    let width1 = uniforms.output_shape[2] / \").concat(a, \"u;\\n    let col = (index1 % width1) * \").concat(a, \"u;\\n    index1 = index1 / width1;\\n    let row = index1 % uniforms.output_shape[1];\\n    let batch = index1 / uniforms.output_shape[1];\\n\\n    let x_corner = vec2<i32>(i32(row), i32(col)) * uniforms.strides - uniforms.pads;\\n\\n    var x_vals: array<\").concat(v.type.value, \", \").concat(h, \">;\\n    var values: array<\").concat(g.type.value, \", \").concat(a, \">;\\n    let input_channel = output_channel;\\n    // Use constant instead of uniform can give better performance for w's height/width.\\n    for (var w_height: u32 = 0u; w_height < \").concat(p[0], \"; w_height++) {\\n      let x_height = x_corner.x + i32(w_height);\\n      if (x_height >= 0 && u32(x_height) < uniforms.x_shape[1]) {\\n        for (var i = 0; i < \").concat(h, \"; i++) {\\n          let x_width = x_corner.y + i;\\n          if (x_width >= 0 && u32(x_width) < uniforms.x_shape[2]) {\\n            x_vals[i] = \").concat(v.get(\"batch\", \"u32(x_height)\", \"u32(x_width)\", \"input_channel\"), \";\\n          } else {\\n            x_vals[i] = \").concat(v.type.value, \"(0);\\n          }\\n        }\\n        for (var w_width: u32 = 0u; w_width < \").concat(p[1], \"; w_width++) {\\n          let w_val = \").concat(S.get(\"w_height\", \"w_width\", \"0\", \"output_channel\"), \";\\n          for (var i = 0u; i < \").concat(a, \"u; i++) {\\n            values[i] = fma(x_vals[i * u32(uniforms.strides[1]) + w_width], w_val, values[i]);\\n          }\\n        }\\n      }\\n    }\\n\\n    for (var i = 0u; i < \").concat(a, \"u; i++) {\\n      var value = values[i];\\n      \").concat(A, \"\\n      \").concat($, \"\\n      \").concat(g.set(\"batch\", \"row\", \"col + i\", \"output_channel\", \"value\"), \";\\n    }\\n  }\");\n        };\n        return {\n            name: \"GroupedConv-Vectorize\",\n            shaderCache: {\n                hint: \"\".concat(t.cacheKey, \";\").concat(i, \";\").concat(a, \";\").concat(h, \";\").concat(p[0], \";\").concat(p[1]),\n                inputDependencies: o ? [\n                    \"rank\",\n                    \"rank\",\n                    \"type\"\n                ] : [\n                    \"rank\",\n                    \"rank\"\n                ]\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: n ? n(r) : r,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(d / 64)\n                    },\n                    programUniforms: u\n                }),\n            getShaderSource: _\n        };\n    };\n});\nvar mf, bo, ff, yo, _o, Zu, hf, gf, wo, Qu = U(()=>{\n    \"use strict\";\n    oe();\n    Wu();\n    qu();\n    Xr();\n    Yu();\n    yt();\n    Qr();\n    dt();\n    mf = (e1, t, r, n, o, i)=>{\n        let a = e1[0], d = e1.slice(i ? 1 : 2, i ? 3 : 4), l = d.length, p = t[0], u = t.slice(2).map((y, g)=>y + (y - 1) * (r[g] - 1)), _ = d.map((y, g)=>y + n[g] + n[g + l]).map((y, g)=>Math.floor((y - u[g] + o[g]) / o[g]));\n        return _.splice(0, 0, a), _.splice(i ? 3 : 1, 0, p), _;\n    }, bo = [\n        2,\n        3,\n        1,\n        0\n    ], ff = (e1, t)=>{\n        if (!e1 || e1.length !== 2 && e1.length !== 3) throw new Error(\"Conv requires 2 or 3 inputs\");\n        if (e1[0].dims.length > 5) throw new Error(\"greater than 5D is not supported\");\n        if (e1[0].dims.length !== e1[1].dims.length) throw new Error(\"filter does not have same dimension as input\");\n        let r = e1[0].dims[t.format === \"NHWC\" ? e1[0].dims.length - 1 : 1], n = e1[1].dims[1] * t.group;\n        if (r !== n) throw new Error(\"FILTER_IN_CHANNEL should be equal to DATA_CHANNEL\");\n        if (e1.length === 3 && (e1[2].dims.length !== 1 || e1[1].dims[0] !== e1[2].dims[0])) throw new Error(\"invalid bias\");\n        let o = e1[0].dims.length - 2;\n        if (t.dilations.length !== o) throw new Error(\"dilations should be \".concat(o, \"D\"));\n        if (t.strides.length !== o) throw new Error(\"strides should be \".concat(o, \"D\"));\n        if (t.pads.length !== o * 2) throw new Error(\"pads should be \".concat(o * 2, \"D\"));\n        if (t.kernelShape.length !== 0 && t.kernelShape.length !== e1[1].dims.length - 2) throw new Error(\"invalid kernel shape\");\n    }, yo = (e1, t)=>{\n        let r = e1.kernelShape.slice();\n        r.length < t[1].dims.length - 2 && r.push(...Array(t[1].dims.length - 2 - r.length).fill(0));\n        for(let i = 2; i < t[1].dims.length; ++i)r[i - 2] === 0 && (r[i - 2] = t[1].dims[i]);\n        let n = e1.pads.slice();\n        At.adjustPadsBasedOnAutoPad(t[0].dims, e1.strides, e1.dilations, r, n, e1.format === \"NHWC\", e1.autoPad);\n        let o = Object.assign({}, e1);\n        return Object.assign(o, {\n            kernelShape: r,\n            pads: n\n        }), o;\n    }, _o = (e1)=>{\n        let t = jr(e1), r = e1.format, n = [\n            \"NOTSET\",\n            \"VALID\",\n            \"SAME_UPPER\",\n            \"SAME_LOWER\"\n        ][e1.auto_pad], o = e1.dilations, i = e1.group, a = e1.kernel_shape, d = e1.pads, l = e1.strides, p = e1.w_is_const();\n        return {\n            autoPad: n,\n            format: r,\n            dilations: o,\n            group: i,\n            kernelShape: a,\n            pads: d,\n            strides: l,\n            wIsConst: p,\n            ...t,\n            cacheKey: \"\".concat(e1.format, \";\").concat(t.activation, \";\")\n        };\n    }, Zu = (e1, t, r, n)=>{\n        let o = r.format === \"NHWC\", i = mf(t[0].dims, t[1].dims, r.dilations, r.pads, r.strides, o);\n        if (r.group !== 1) {\n            let k = [\n                t[0]\n            ];\n            if (o) {\n                var _e_kernelCustomData_wT;\n                let D = (_e_kernelCustomData_wT = e1.kernelCustomData.wT) !== null && _e_kernelCustomData_wT !== void 0 ? _e_kernelCustomData_wT : e1.compute(Pe(t[1], bo), {\n                    inputs: [\n                        1\n                    ],\n                    outputs: [\n                        r.wIsConst ? -2 : -1\n                    ]\n                })[0];\n                r.wIsConst && !e1.kernelCustomData.wT && (e1.kernelCustomData.wT = D), k.push(D);\n            } else k.push(t[1]);\n            t.length === 3 && k.push(t[2]), !e1.adapterInfo.isArchitecture(\"ampere\") && o && t[1].dims[0] === r.group && t[1].dims[1] === 1 && r.dilations[0] === 1 && r.dilations[1] === 1 ? e1.compute(ju(k, r, i, n), {\n                inputs: k\n            }) : e1.compute(Ku(k, r, i, n), {\n                inputs: k\n            });\n            return;\n        }\n        let a = t.length === 3, d = t[0].dims[o ? 1 : 2], l = t[0].dims[o ? 2 : 3], p = t[0].dims[o ? 3 : 1], m = t[1].dims[2], u = t[1].dims[3], h = i[o ? 1 : 2], _ = i[o ? 2 : 3], y = i[o ? 3 : 1], g = o && m === d && u === l && r.pads[0] === 0 && r.pads[1] === 0;\n        if (g || m === 1 && u === 1 && r.dilations[0] === 1 && r.dilations[1] === 1 && r.strides[0] === 1 && r.strides[1] === 1 && r.pads[0] === 0 && r.pads[1] === 0) {\n            let k = i[0], P, D, R, G = [];\n            if (o) {\n                var _e_kernelCustomData_wT1;\n                let V = (_e_kernelCustomData_wT1 = e1.kernelCustomData.wT) !== null && _e_kernelCustomData_wT1 !== void 0 ? _e_kernelCustomData_wT1 : e1.compute(Pe(t[1], bo), {\n                    inputs: [\n                        1\n                    ],\n                    outputs: [\n                        r.wIsConst ? -2 : -1\n                    ]\n                })[0];\n                if (r.wIsConst && !e1.kernelCustomData.wT && (e1.kernelCustomData.wT = V), g) {\n                    let Q = d * l * p;\n                    P = t[0].reshape([\n                        1,\n                        k,\n                        Q\n                    ]), D = V.reshape([\n                        1,\n                        Q,\n                        y\n                    ]), R = [\n                        1,\n                        k,\n                        y\n                    ];\n                } else P = t[0].reshape([\n                    k,\n                    d * l,\n                    p\n                ]), D = V.reshape([\n                    1,\n                    p,\n                    y\n                ]), R = [\n                    k,\n                    h * _,\n                    y\n                ];\n                G.push(P), G.push(D);\n            } else P = t[0].reshape([\n                k,\n                p,\n                d * l\n            ]), D = t[1].reshape([\n                1,\n                y,\n                p\n            ]), R = [\n                k,\n                y,\n                h * _\n            ], G.push(D), G.push(P);\n            a && G.push(t[2]);\n            let K = R[2], j = G[0].dims[G[0].dims.length - 1];\n            K < 8 && j < 8 ? e1.compute(Zr(G, r, i, R, o, n), {\n                inputs: G\n            }) : e1.compute(er(G, r, i, R, o, n), {\n                inputs: G\n            });\n            return;\n        }\n        var _e_kernelCustomData_wT2;\n        let x = !0, $ = (_e_kernelCustomData_wT2 = e1.kernelCustomData.wT) !== null && _e_kernelCustomData_wT2 !== void 0 ? _e_kernelCustomData_wT2 : e1.compute(Pe(t[1], bo), {\n            inputs: [\n                1\n            ],\n            outputs: [\n                r.wIsConst ? -2 : -1\n            ]\n        })[0];\n        r.wIsConst && !e1.kernelCustomData.wT && (e1.kernelCustomData.wT = $);\n        let v = [\n            t[0],\n            $\n        ];\n        a && v.push(t[2]);\n        let S = o ? h * _ : y, T = o ? y : h * _, A = m * u * p;\n        e1.compute(Vu(v, r, i, S, T, A, a, x, n), {\n            inputs: v\n        });\n    }, hf = (e1, t)=>{\n        let r = t.format === \"NHWC\", n = [\n            e1.inputs[0].reshape(r ? [\n                e1.inputs[0].dims[0],\n                1,\n                e1.inputs[0].dims[1],\n                e1.inputs[0].dims[2]\n            ] : [\n                e1.inputs[0].dims[0],\n                e1.inputs[0].dims[1],\n                1,\n                e1.inputs[0].dims[2]\n            ]),\n            e1.inputs[1].reshape([\n                e1.inputs[1].dims[0],\n                e1.inputs[1].dims[1],\n                1,\n                e1.inputs[1].dims[2]\n            ])\n        ];\n        e1.inputs.length === 3 && n.push(e1.inputs[2]);\n        let o = [\n            0,\n            t.pads[0],\n            0,\n            t.pads[1]\n        ], i = [\n            1\n        ].concat(t.strides), a = [\n            1\n        ].concat(t.dilations), d = [\n            1\n        ].concat(t.kernelShape), l = yo({\n            ...t,\n            pads: o,\n            strides: i,\n            dilations: a,\n            kernelShape: d\n        }, n);\n        Zu(e1, n, l, (p)=>r ? [\n                p[0],\n                p[2],\n                p[3]\n            ] : [\n                p[0],\n                p[1],\n                p[3]\n            ]);\n    }, gf = (e1, t, r)=>{\n        let n = r.format === \"NHWC\" ? \"channelsLast\" : \"channelsFirst\", o = yo(r, t), i = r.autoPad === \"NOTSET\" ? r.pads : r.autoPad, a = Hu(t[0].dims, t[1].dims, r.strides, r.dilations, i, !1, n);\n        e1.compute(Fu(t, o, a.outShape, [\n            a.filterDepth,\n            a.filterHeight,\n            a.filterWidth\n        ], [\n            a.padInfo.front,\n            a.padInfo.top,\n            a.padInfo.left\n        ], n));\n    }, wo = (e1, t)=>{\n        if (ff(e1.inputs, t), e1.inputs[0].dims.length === 3) hf(e1, t);\n        else if (e1.inputs[0].dims.length === 5) gf(e1, e1.inputs, t);\n        else {\n            let r = yo(t, e1.inputs);\n            Zu(e1, e1.inputs, r);\n        }\n    };\n});\nvar Xu, Ju = U(()=>{\n    \"use strict\";\n    te();\n    et();\n    oe();\n    ae();\n    Xu = (e1, t, r)=>{\n        let n = e1.length > 2, o = t.outputShape, i = t.format === \"NHWC\", a = t.group, d = e1[1].dims, l = d[2] / a, p = d[3], m = i ? me(l) : 1, u = i ? me(p) : 1, h = i ? p === 1 ? m : u : 1, _ = C.size(o) / u, y = [\n            Math.ceil(_ / 64),\n            1,\n            1\n        ];\n        ue(\"verbose\", ()=>\"[conv2d_backprop_webgpu] dispatch = \".concat(y));\n        let g = [\n            \"rank\",\n            \"rank\"\n        ], x = [\n            t.strides[0],\n            t.strides[1]\n        ], $ = [\n            t.kernelShape[i ? 1 : 2],\n            t.kernelShape[i ? 2 : 3]\n        ], v = [\n            t.dilations[0],\n            t.dilations[1]\n        ], S = [\n            $[0] + (t.dilations[0] <= 1 ? 0 : (t.kernelShape[i ? 1 : 2] - 1) * (t.dilations[0] - 1)),\n            $[1] + (t.dilations[1] <= 1 ? 0 : (t.kernelShape[i ? 2 : 3] - 1) * (t.dilations[1] - 1))\n        ], T = [\n            S[0] - 1 - Math.floor((t.pads[0] + t.pads[2]) / 2),\n            S[1] - 1 - Math.floor((t.pads[1] + t.pads[3]) / 2)\n        ], A = [\n            {\n                type: 12,\n                data: _\n            },\n            {\n                type: 12,\n                data: x\n            },\n            {\n                type: 12,\n                data: $\n            },\n            {\n                type: 12,\n                data: v\n            },\n            {\n                type: 12,\n                data: S\n            },\n            {\n                type: 6,\n                data: T\n            },\n            {\n                type: 12,\n                data: l\n            },\n            {\n                type: 12,\n                data: p\n            },\n            ...N(e1[0].dims, e1[1].dims)\n        ];\n        n && (A.push(...N(e1[2].dims)), g.push(\"rank\")), A.push(...N(o));\n        let k = (P)=>{\n            let D = [\n                {\n                    name: \"output_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"strides\",\n                    type: \"u32\",\n                    length: x.length\n                },\n                {\n                    name: \"filter_dims\",\n                    type: \"u32\",\n                    length: $.length\n                },\n                {\n                    name: \"dilations\",\n                    type: \"u32\",\n                    length: $.length\n                },\n                {\n                    name: \"effective_filter_dims\",\n                    type: \"u32\",\n                    length: S.length\n                },\n                {\n                    name: \"pads\",\n                    type: \"i32\",\n                    length: T.length\n                },\n                {\n                    name: \"input_channels_per_group\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"output_channels_per_group\",\n                    type: \"u32\"\n                }\n            ], R = _e(e1[0].dataType), G = i ? 1 : 2, K = i ? 2 : 3, j = i ? 3 : 1, V = E(\"W\", e1[1].dataType, e1[1].dims.length, h), Q = E(\"Dy\", e1[0].dataType, e1[0].dims.length, m), se = [\n                Q,\n                V\n            ];\n            n && se.push(E(\"bias\", e1[2].dataType, [\n                o[j]\n            ].length, u));\n            let Y = M(\"result\", e1[0].dataType, o.length, u), ee = ()=>{\n                let ne = \"\";\n                if (m === 1) ne += \"\\n        let w_offset = \".concat(V.indicesToOffset(\"\".concat(V.type.indices, \"(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)\")), \";\\n        let wValue = \").concat(V.getByOffset(\"w_offset / \".concat(h)), \";\\n        dotProd = dotProd + xValue * wValue;\");\n                else if (p === 1) ne += \"\\n          let wValue = \".concat(V.getByOffset(\"\".concat(V.indicesToOffset(\"\".concat(V.type.indices, \"(u32(wRPerm), u32(wCPerm), inputChannel, wOutChannel)\")), \" / \").concat(h)), \";\\n          dotProd = dotProd + dot(xValue, wValue);\");\n                else for(let be = 0; be < m; be++)ne += \"\\n            let wValue\".concat(be, \" = \").concat(V.getByOffset(\"\".concat(V.indicesToOffset(\"\".concat(V.type.indices, \"(u32(wRPerm), u32(wCPerm), inputChannel + \").concat(be, \", wOutChannel)\")), \" / \").concat(h)), \";\\n            dotProd = dotProd + xValue[\").concat(be, \"] * wValue\").concat(be, \";\");\n                return ne;\n            }, J = \"\\n            let outputIndices = \".concat(Y.offsetToIndices(\"global_idx * \".concat(u)), \";\\n            let batch = \").concat(Y.indicesGet(\"outputIndices\", 0), \";\\n            let d1 = \").concat(Y.indicesGet(\"outputIndices\", j), \";\\n            let r = \").concat(Y.indicesGet(\"outputIndices\", G), \";\\n            let c = \").concat(Y.indicesGet(\"outputIndices\", K), \";\\n            let dyCorner = vec2<i32>(i32(r), i32(c)) - uniforms.pads;\\n            let dyRCorner = dyCorner.x;\\n            let dyCCorner = dyCorner.y;\\n            let groupId = d1 / uniforms.output_channels_per_group;\\n            let wOutChannel = d1 - groupId * uniforms.output_channels_per_group;\\n            // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\\n            // ? = to be determined. : = across all values in that axis.\\n            var dotProd = \").concat(Y.type.value, \"(0.0);\\n            for (var wR: u32 = 0; wR < uniforms.effective_filter_dims.x; wR = wR + 1) {\\n              if (wR % uniforms.dilations.x != 0) {\\n                continue;\\n              }\\n              let dyR = (\").concat(R, \"(dyRCorner) + \").concat(R, \"(wR)) / \").concat(R, \"(uniforms.strides[0]);\\n              let wRPerm = uniforms.filter_dims.x - 1 - wR / uniforms.dilations.x;\\n              if (dyR < 0.0 || dyR >= \").concat(R, \"(uniforms.Dy_shape[\").concat(G, \"]) || fract(dyR) > 0.0 ||\\n                  wRPerm < 0) {\\n                continue;\\n              }\\n              wR = wR + uniforms.strides[0] - 1;\\n              let idyR: u32 = u32(dyR);\\n\\n              for (var wC: u32 = 0; wC < uniforms.effective_filter_dims.y; wC = wC + 1) {\\n                if (wC % uniforms.dilations.y != 0) {\\n                  continue;\\n                }\\n                let dyC = (\").concat(R, \"(dyCCorner) + \").concat(R, \"(wC)) / \").concat(R, \"(uniforms.strides.y);\\n                let wCPerm = uniforms.filter_dims.y - 1 - wC / uniforms.dilations.y;\\n                if (dyC < 0.0 || dyC >= \").concat(R, \"(uniforms.Dy_shape[\").concat(K, \"]) ||\\n                    fract(dyC) > 0.0 || wCPerm < 0) {\\n                  continue;\\n                }\\n                wC = wC + uniforms.strides.y - 1;\\n                let idyC: u32 = u32(dyC);\\n                var inputChannel = groupId * uniforms.input_channels_per_group;\\n                for (var d2: u32 = 0; d2 < uniforms.input_channels_per_group; d2 = d2 + \").concat(m, \") {\\n                  let xValue = \").concat(i ? Q.getByOffset(\"\".concat(Q.indicesToOffset(\"\".concat(Q.type.indices, \"(batch, idyR, idyC, inputChannel)\")), \" / \").concat(m)) : Q.get(\"batch\", \"inputChannel\", \"idyR\", \"idyC\"), \";\\n                  \").concat(ee(), \"\\n                  inputChannel = inputChannel + \").concat(m, \";\\n                }\\n              }\\n            }\\n            let value = dotProd\").concat(n ? \" + bias[d1 / \".concat(u, \"]\") : \"\", \";\\n            \").concat(Y.setByOffset(\"global_idx\", \"value\"), \";\\n          \");\n            return \"\\n    \".concat(P.registerUniforms(D).declareVariables(...se, Y), \"\\n      \").concat(P.mainStart(), \"\\n      \").concat(P.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\"), \";\\n    \").concat(J, \"}\");\n        };\n        return {\n            name: \"ConvTranspose2D\",\n            shaderCache: {\n                hint: \"\".concat(t.cacheKey, \";\").concat(m).concat(h).concat(u).concat(p === 1),\n                inputDependencies: g\n            },\n            getRunData: ()=>({\n                    dispatchGroup: {\n                        x: y[0],\n                        y: y[1],\n                        z: y[2]\n                    },\n                    outputs: [\n                        {\n                            dims: r ? r(o) : o,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    programUniforms: A\n                }),\n            getShaderSource: k\n        };\n    };\n});\nvar bf, yf, _f, ed, td, wf, rd, vf, nd, od = U(()=>{\n    \"use strict\";\n    Ju();\n    yt();\n    dt();\n    bf = (e1, t, r, n, o, i)=>(e1 - 1) * t + r + (n - 1) * o + 1 - i, yf = (e1, t, r, n, o)=>{\n        let i = Math.floor(e1 / 2);\n        t === \"SAME_UPPER\" ? (r[n] = i, r[o] = e1 - i) : t === \"SAME_LOWER\" && (r[n] = e1 - i, r[o] = i);\n    }, _f = (e1, t, r, n, o, i, a, d, l, p)=>{\n        let m = e1.length - 2, u = p.length === 0;\n        l.length < m && l.push(...Array(m - l.length).fill(0));\n        let h = e1[0], _ = t[d ? 3 : 1] * o;\n        for(let y = 0, g = e1.length - m - (d ? 1 : 0); y < m; ++y, ++g){\n            let x = e1[g], $ = u ? x * a[y] : p[y], v = bf(x, a[y], i[y], t[g], r[y], $);\n            yf(v, n, i, y, y + m), u && p.push(a[y] * (x - 1) + l[y] + (t[g] - 1) * r[y] + 1 - i[y] - i[y + m]);\n        }\n        p.splice(0, 0, h), p.splice(d ? 3 : 1, 0, _);\n    }, ed = (e1, t)=>{\n        let r = e1.kernelShape.slice();\n        if (e1.kernelShape.length === 0 || e1.kernelShape.reduce((u, h)=>u * h, 1) === 0) {\n            r.length = 0;\n            for(let u = 2; u < t[1].dims.length; ++u)r.push(t[1].dims[u]);\n        }\n        let n = e1.format === \"NHWC\";\n        r.splice(0, 0, t[1].dims[0]), r.splice(n ? 3 : 1, 0, t[1].dims[1]);\n        let o = e1.pads.slice(), i = e1.outputShape.slice(), a = e1.outputPadding.slice(), d = t[0].dims, l = e1.dilations.slice();\n        if (l.reduce((u, h)=>u + h, 0) === 0) {\n            let u = t[0].dims.length - 2;\n            l = new Array(u).fill(1);\n        }\n        let p = e1.strides.slice();\n        if (p.reduce((u, h)=>u + h, 0) === 0) {\n            let u = t[0].dims.length - 2;\n            p = new Array(u).fill(1);\n        }\n        _f(d, r, l, e1.autoPad, e1.group, o, p, n, a, i);\n        let m = Object.assign({}, e1);\n        return Object.assign(m, {\n            kernelShape: r,\n            pads: o,\n            outputPadding: a,\n            outputShape: i,\n            dilations: l,\n            strides: p\n        }), m;\n    }, td = (e1)=>{\n        let t = jr(e1), r = e1.format, n = [\n            \"NOTSET\",\n            \"VALID\",\n            \"SAME_UPPER\",\n            \"SAME_LOWER\"\n        ][typeof e1.autoPad > \"u\" ? 0 : e1.autoPad], o = e1.dilations, i = e1.group, a = e1.kernelShape, d = e1.pads, l = e1.strides, p = e1.wIsConst(), m = e1.outputPadding, u = e1.outputShape;\n        return {\n            autoPad: n,\n            format: r,\n            dilations: o,\n            group: i,\n            kernelShape: a,\n            outputPadding: m,\n            outputShape: u,\n            pads: d,\n            strides: l,\n            wIsConst: p,\n            ...t,\n            cacheKey: \"\".concat(e1.format, \";\").concat(t.activation, \";\")\n        };\n    }, wf = (e1, t)=>{\n        if (!e1 || e1.length !== 2 && e1.length !== 3) throw new Error(\"Conv requires 2 or 3 inputs\");\n        if (e1[0].dims.length !== 4 && e1[0].dims.length !== 3) throw new Error(\"currently only support 2-dimensional conv\");\n        if (e1[0].dims.length !== e1[1].dims.length) throw new Error(\"filter does not have same dimension as input\");\n        let r = e1[0].dims[t.format === \"NHWC\" ? e1[0].dims.length - 1 : 1], n = e1[1].dims[0];\n        if (r !== n) throw new Error(\"FILTER_IN_CHANNEL should be equal to DATA_CHANNEL\");\n        let o = e1[1].dims[1] * t.group;\n        if (e1.length === 3 && (e1[2].dims.length !== 1 || e1[2].dims[0] !== o)) throw new Error(\"invalid bias\");\n        let i = e1[0].dims.length - 2;\n        if (t.dilations.reduce((m, u)=>m + u, 0) > 0 && t.dilations.length !== i) throw new Error(\"dilations should be \".concat(i, \"D\"));\n        if (t.strides.reduce((m, u)=>m + u, 0) > 0 && t.strides.length !== i) throw new Error(\"strides should be \".concat(i, \"D\"));\n        if (t.pads.reduce((m, u)=>m + u, 0) > 0 && t.pads.length !== i * 2) throw new Error(\"pads should be \".concat(i * 2, \"D\"));\n        if (t.outputPadding.length !== i && t.outputPadding.length !== 0) throw new Error(\"output_padding should be \".concat(i, \"D\"));\n        if (t.kernelShape.reduce((m, u)=>m + u, 0) > 0 && t.kernelShape.length !== 0 && t.kernelShape.length !== e1[1].dims.length - 2) throw new Error(\"invalid kernel shape\");\n        if (t.outputShape.length !== 0 && t.outputShape.length !== e1[0].dims.length - 2) throw new Error(\"invalid output shape\");\n    }, rd = (e1, t, r, n)=>{\n        var _e_kernelCustomData_wT;\n        let o = (_e_kernelCustomData_wT = e1.kernelCustomData.wT) !== null && _e_kernelCustomData_wT !== void 0 ? _e_kernelCustomData_wT : e1.compute(Pe(t[1], [\n            2,\n            3,\n            0,\n            1\n        ]), {\n            inputs: [\n                1\n            ],\n            outputs: [\n                r.wIsConst ? -2 : -1\n            ]\n        })[0];\n        r.wIsConst && !e1.kernelCustomData.wT && (e1.kernelCustomData.wT = o);\n        let i = [\n            t[0],\n            o\n        ];\n        t.length === 3 && i.push(t[2]), e1.compute(Xu(i, r, n), {\n            inputs: i\n        });\n    }, vf = (e1, t)=>{\n        let r = t.format === \"NHWC\", n = [\n            e1.inputs[0].reshape(r ? [\n                e1.inputs[0].dims[0],\n                1,\n                e1.inputs[0].dims[1],\n                e1.inputs[0].dims[2]\n            ] : [\n                e1.inputs[0].dims[0],\n                e1.inputs[0].dims[1],\n                1,\n                e1.inputs[0].dims[2]\n            ]),\n            e1.inputs[1].reshape([\n                e1.inputs[1].dims[0],\n                e1.inputs[1].dims[1],\n                1,\n                e1.inputs[1].dims[2]\n            ])\n        ];\n        e1.inputs.length === 3 && n.push(e1.inputs[2]);\n        let o = t.kernelShape;\n        (o.length === 0 || o[0] === 0) && (o = [\n            e1.inputs[1].dims[2]\n        ]);\n        let i = t.dilations;\n        (i.length === 0 || i[0] === 0) && (i = [\n            1\n        ]);\n        let a = t.strides;\n        (a.length === 0 || a[0] === 0) && (a = [\n            1\n        ]);\n        let d = t.pads;\n        d.length === 0 && (d = [\n            0,\n            0\n        ]), d = [\n            0,\n            d[0],\n            0,\n            d[1]\n        ], a = [\n            1\n        ].concat(a), i = [\n            1\n        ].concat(i), o = [\n            1\n        ].concat(o);\n        let l = ed({\n            ...t,\n            pads: d,\n            strides: a,\n            dilations: i,\n            kernelShape: o\n        }, n);\n        rd(e1, n, l, (p)=>r ? [\n                p[0],\n                p[2],\n                p[3]\n            ] : [\n                p[0],\n                p[1],\n                p[3]\n            ]);\n    }, nd = (e1, t)=>{\n        if (wf(e1.inputs, t), e1.inputs[0].dims.length === 3) vf(e1, t);\n        else {\n            let r = ed(t, e1.inputs);\n            rd(e1, e1.inputs, r);\n        }\n    };\n});\nvar $f, id, ad, sd = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    $f = (e1, t, r, n)=>{\n        let o = C.size(t), i = t.length, a = E(\"input\", e1, i), d = M(\"output\", e1, i), l = r.dataType === 6 ? r.getInt32Array()[0] : Number(r.getBigInt64Array()[0]), p = C.normalizeAxis(l, i), m = (u)=>{\n            let h = \" i32(\".concat(a.indicesGet(\"inputIndices\", \"uniforms.axis\"), \") \"), _ = F(\"uniforms.input_shape\", \"uniforms.axis\", i), y = n.reverse ? h + (n.exclusive ? \" + 1\" : \"\") : \"0\", g = n.reverse ? _ : h + (n.exclusive ? \"\" : \" + 1\");\n            return \"\\n                \".concat(u.registerUniform(\"outputSize\", \"u32\").registerUniform(\"axis\", \"u32\").declareVariables(a, d), \"\\n                \").concat(u.mainStart(), \"\\n                  \").concat(u.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\"), \"\\n                  var inputIndices = \").concat(d.offsetToIndices(\"global_idx\"), \";\\n                  var sum = \").concat(d.type.value, \"(0);\\n                  let first : i32 = \").concat(y, \";\\n                  let last : i32 = \").concat(g, \";\\n                  for (var i : i32 = first; i < last; i++) {\\n                    \").concat(a.indicesSet(\"inputIndices\", \"uniforms.axis\", \"u32(i)\"), \";\\n                    sum = sum + \").concat(a.getByIndices(\"inputIndices\"), \";\\n                  }\\n                  \").concat(d.setByOffset(\"global_idx\", \"sum\"), \";\\n                }\");\n        };\n        return {\n            name: \"CumSum\",\n            shaderCache: {\n                hint: n.cacheKey,\n                inputDependencies: [\n                    \"rank\"\n                ]\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: t,\n                            dataType: e1\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(o / 64)\n                    },\n                    programUniforms: [\n                        {\n                            type: 12,\n                            data: o\n                        },\n                        {\n                            type: 12,\n                            data: p\n                        },\n                        ...N(t, t)\n                    ]\n                }),\n            getShaderSource: m\n        };\n    }, id = (e1, t)=>{\n        let r = e1.inputs[0].dims, n = e1.inputs[0].dataType, o = e1.inputs[1];\n        e1.compute($f(n, r, o, t), {\n            inputs: [\n                0\n            ]\n        });\n    }, ad = (e1)=>{\n        let t = e1.exclusive === 1, r = e1.reverse === 1;\n        return re({\n            exclusive: t,\n            reverse: r\n        });\n    };\n});\nvar xf, Sf, Tf, ud, dd, ld = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    xf = (e1)=>{\n        if (!e1 || e1.length !== 1) throw new Error(\"DepthToSpace requires 1 input.\");\n        if (e1[0].dims.length !== 4) throw new Error(\"DepthToSpace requires 4D input.\");\n    }, Sf = (e1, t, r, n)=>{\n        let o = [];\n        o.push(\"fn perm(i: \".concat(n.type.indices, \") -> \").concat(r.type.indices, \" {\\n    var a: \").concat(r.type.indices, \";\"));\n        for(let i = 0; i < t; ++i)o.push(r.indicesSet(\"a\", e1[i], \"i[\".concat(i, \"]\")));\n        return o.push(\"return a;}\"), o.join(\"\\n\");\n    }, Tf = (e1, t)=>{\n        let r, n, o, i, a, d, l = t.format === \"NHWC\", p = t.blocksize, m = t.mode === \"DCR\";\n        l ? ([r, n, o, i] = e1.dims, a = m ? [\n            r,\n            n,\n            o,\n            p,\n            p,\n            i / p ** 2\n        ] : [\n            r,\n            n,\n            o,\n            i / p ** 2,\n            p,\n            p\n        ], d = m ? [\n            0,\n            1,\n            3,\n            2,\n            4,\n            5\n        ] : [\n            0,\n            1,\n            4,\n            2,\n            5,\n            3\n        ]) : ([r, n, o, i] = [\n            e1.dims[0],\n            e1.dims[2],\n            e1.dims[3],\n            e1.dims[1]\n        ], a = m ? [\n            r,\n            p,\n            p,\n            i / p ** 2,\n            n,\n            o\n        ] : [\n            r,\n            i / p ** 2,\n            p,\n            p,\n            n,\n            o\n        ], d = m ? [\n            0,\n            3,\n            4,\n            1,\n            5,\n            2\n        ] : [\n            0,\n            1,\n            4,\n            2,\n            5,\n            3\n        ]);\n        let u = e1.reshape(a), h = u.dims.length, _ = e1.dataType, y = E(\"a\", _, h), g = M(\"output\", _, h), x = ($)=>\"\\n  \".concat($.registerUniform(\"output_size\", \"u32\").declareVariables(y, g), \"\\n\\n  \").concat(Sf(d, h, y, g), \"\\n\\n  \").concat($.mainStart(), \"\\n    \").concat($.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\"), \"\\n\\n    let indices = \").concat(g.offsetToIndices(\"global_idx\"), \";\\n    let aIndices = perm(indices);\\n\\n    \").concat(g.setByOffset(\"global_idx\", y.getByIndices(\"aIndices\")), \"\\n  }\");\n        return {\n            name: \"DepthToSpace\",\n            shaderCache: {\n                hint: \"\".concat(e1.dims, \";\").concat(t.blocksize, \";\").concat(t.mode),\n                inputDependencies: [\n                    \"rank\"\n                ]\n            },\n            getRunData: ($)=>{\n                let v = l ? [\n                    r,\n                    n * p,\n                    o * p,\n                    i / p ** 2\n                ] : [\n                    r,\n                    i / p ** 2,\n                    n * p,\n                    o * p\n                ], S = C.size(v), T = u.dims, A = C.sortBasedOnPerm(T, d);\n                return {\n                    outputs: [\n                        {\n                            dims: v,\n                            dataType: $[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(S / 64)\n                    },\n                    programUniforms: [\n                        {\n                            type: 12,\n                            data: S\n                        },\n                        ...N(T, A)\n                    ]\n                };\n            },\n            getShaderSource: x\n        };\n    }, ud = (e1, t)=>{\n        xf(e1.inputs), e1.compute(Tf(e1.inputs[0], t));\n    }, dd = (e1)=>re({\n            blocksize: e1.blocksize,\n            mode: e1.mode,\n            format: e1.format\n        });\n});\nvar vo, en, cd, If, Cf, $o, xo, pd, Af, md, fd, hd = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    vo = \"[a-zA-Z]|\\\\.\\\\.\\\\.\", en = \"(\" + vo + \")+\", cd = \"^\" + en + \"$\", If = \"(\" + en + \",)*\" + en, Cf = \"^\" + If + \"$\", $o = class {\n        addSymbol(t, r) {\n            let n = this.symbolToIndices.get(t);\n            n === void 0 ? n = [\n                r\n            ] : n.push(r), this.symbolToIndices.set(t, n);\n        }\n        constructor(t = -1){\n            this.symbolToIndices = new Map, this.inputIndex = t;\n        }\n    }, xo = class {\n        addSymbol(t, r, n) {\n            let o = this.symbolToInfo.get(t);\n            if (o !== void 0) {\n                if (o.dimValue !== r && o.count !== 1) throw new Error(\"Dimension mismatch\");\n                o.count++, o.inputIndices.push(n);\n            } else o = {\n                count: 1,\n                dimValue: r,\n                inputIndices: [\n                    n\n                ]\n            };\n            this.symbolToInfo.set(t, o);\n        }\n        processTerm(t, r, n) {\n            let o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : -1;\n            let i = n.length, a = !1, d = [], l = 0;\n            if (!t.match(RegExp(cd)) && !r && t !== \"\") throw new Error(\"Invalid LHS term\");\n            let p = t.match(RegExp(vo, \"g\")), m = new $o(o);\n            return p === null || p === void 0 ? void 0 : p.forEach((u, h)=>{\n                if (u === \"...\") {\n                    if (a) throw new Error(\"Only one ellipsis is allowed per input term\");\n                    a = !0;\n                    let _ = i - p.length + 1;\n                    if (_ < 0) throw new Error(\"Ellipsis out of bounds\");\n                    if (d = n.slice(l, l + _), this.hasEllipsis) {\n                        if (this.ellipsisDims.length !== d.length || this.ellipsisDims.toString() !== d.toString()) throw new Error(\"Ellipsis dimensions mismatch\");\n                    } else if (r) this.hasEllipsis = !0, this.ellipsisDims = d;\n                    else throw new Error(\"Ellipsis must be specified in the LHS\");\n                    for(let y = 0; y < d.length; y++){\n                        let g = String.fromCharCode(\"0\".charCodeAt(0) + y);\n                        m.addSymbol(g, h + y), this.addSymbol(g, n[l++], o);\n                    }\n                } else m.addSymbol(u, h + (this.hasEllipsis ? this.ellipsisDims.length - 1 : 0)), this.addSymbol(u, n[l++], o);\n            }), m;\n        }\n        constructor(t, r){\n            var _o_match;\n            this.equation = r;\n            this.hasEllipsis = !1, this.symbolToInfo = new Map, this.lhs = new Array, this.outputDims = [];\n            let [n, o] = r.includes(\"->\") ? r.split(\"->\", 2) : [\n                r,\n                \"\"\n            ];\n            if (!n.match(RegExp(Cf))) throw new Error(\"Invalid LHS term\");\n            if (n.split(\",\").forEach((d, l)=>{\n                let p = t[l].dims.slice();\n                if (!d.match(RegExp(cd))) throw new Error(\"Invalid LHS term\");\n                let m = this.processTerm(d, !0, p, l);\n                this.lhs.push(m);\n            }), o === \"\") o += [\n                ...this.symbolToInfo.entries()\n            ].filter((param)=>{\n                let [d, l] = param;\n                return l.count === 1 || d === \"...\";\n            }).map((param)=>{\n                let [d] = param;\n                return d;\n            }).join(\"\");\n            else if (!o.match(RegExp(en))) throw new Error(\"Invalid RHS\");\n            (_o_match = o.match(RegExp(vo, \"g\"))) === null || _o_match === void 0 ? void 0 : _o_match.forEach((d)=>{\n                if (d === \"...\") this.outputDims = this.outputDims.concat(this.ellipsisDims);\n                else {\n                    let l = this.symbolToInfo.get(d);\n                    if (l === void 0) throw new Error(\"Invalid RHS symbol\");\n                    this.outputDims.push(l.dimValue);\n                }\n            }), this.rhs = this.processTerm(o, !1, this.outputDims);\n        }\n    }, pd = (e1)=>e1 + \"_max\", Af = (e1, t, r, n)=>{\n        let i = e1.map((m)=>m.length).map((m, u)=>E(\"input\".concat(u), t, m)), a = C.size(n), d = M(\"output\", t, n.length), l = [\n            ...r.symbolToInfo.keys()\n        ].filter((m)=>!r.rhs.symbolToIndices.has(m)), p = (m)=>{\n            let u = [], h = \"var prod = 1.0;\", _ = \"var sum = 0.0;\", y = \"sum += prod;\", g = [], x = [], $ = [], v = [], S = r.symbolToInfo.size === r.rhs.symbolToIndices.size;\n            r.symbolToInfo.forEach((A, k)=>{\n                if (r.rhs.symbolToIndices.has(k)) {\n                    var _r_rhs_symbolToIndices_get;\n                    let P = (_r_rhs_symbolToIndices_get = r.rhs.symbolToIndices.get(k)) === null || _r_rhs_symbolToIndices_get === void 0 ? void 0 : _r_rhs_symbolToIndices_get[0];\n                    P !== void 0 && r.lhs.forEach((D, R)=>{\n                        if (A.inputIndices.includes(R)) {\n                            let G = D.symbolToIndices.get(k);\n                            if (G === void 0) throw new Error(\"Invalid symbol error\");\n                            G.forEach((K)=>{\n                                u.push(\"\".concat(i[R].indicesSet(\"input\".concat(R, \"Indices\"), K, d.indicesGet(\"outputIndices\", P))));\n                            });\n                        }\n                    });\n                } else r.lhs.forEach((P, D)=>{\n                    if (A.inputIndices.includes(D)) {\n                        let R = P.symbolToIndices.get(k);\n                        if (R === void 0) throw new Error(\"Invalid symbol error\");\n                        R.forEach((G)=>{\n                            g.push(\"\".concat(i[D].indicesSet(\"input\".concat(D, \"Indices\"), G, \"\".concat(k))));\n                        }), v.push(\"prod *= \".concat(i[D].getByIndices(\"input\".concat(D, \"Indices\")), \";\"));\n                    }\n                }), x.push(\"for(var \".concat(k, \": u32 = 0; \").concat(k, \" < uniforms.\").concat(pd(k), \"; \").concat(k, \"++) {\")), $.push(\"}\");\n            });\n            let T = S ? [\n                ...u,\n                \"let sum = \".concat(i.map((A, k)=>A.getByIndices(\"input\".concat(k, \"Indices\"))).join(\" * \"), \";\")\n            ] : [\n                ...u,\n                _,\n                ...x,\n                ...g,\n                h,\n                ...v,\n                y,\n                ...$\n            ];\n            return \"\\n            \".concat(m.registerUniforms(l.map((A)=>({\n                    name: \"\".concat(pd(A)),\n                    type: \"u32\"\n                }))).registerUniform(\"outputSize\", \"u32\").declareVariables(...i, d), \"\\n\\n            \").concat(m.mainStart(), \"\\n            \").concat(m.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\"), \"\\n            var outputIndices = \").concat(d.offsetToIndices(\"global_idx\"), \";\\n            \").concat(i.map((A, k)=>\"var input\".concat(k, \"Indices: \").concat(i[k].type.indices, \";\")).join(\"\\n\"), \"\\n            \").concat(T.join(\"\\n\"), \";\\n            \").concat(d.setByOffset(\"global_idx\", \"sum\"), \";\\n          }\");\n        };\n        return {\n            name: \"Einsum\",\n            shaderCache: {\n                hint: r.equation,\n                inputDependencies: e1.map(()=>\"rank\")\n            },\n            getRunData: ()=>{\n                let m = l.filter((h)=>r.symbolToInfo.has(h)).map((h)=>{\n                    var _r_symbolToInfo_get;\n                    return {\n                        type: 12,\n                        data: ((_r_symbolToInfo_get = r.symbolToInfo.get(h)) === null || _r_symbolToInfo_get === void 0 ? void 0 : _r_symbolToInfo_get.dimValue) || 0\n                    };\n                });\n                m.push({\n                    type: 12,\n                    data: a\n                });\n                let u = e1.map((h, _)=>[\n                        ...N(h)\n                    ]).reduce((h, _)=>h.concat(_), m);\n                return u.push(...N(n)), {\n                    outputs: [\n                        {\n                            dims: n,\n                            dataType: t\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(a / 64)\n                    },\n                    programUniforms: u\n                };\n            },\n            getShaderSource: p\n        };\n    }, md = (e1, t)=>{\n        let r = new xo(e1.inputs, t.equation), n = r.outputDims, o = e1.inputs.map((i, a)=>i.dims);\n        e1.compute(Af(o, e1.inputs[0].dataType, r, n));\n    }, fd = (e1)=>{\n        let t = e1.equation.replace(/\\s+/g, \"\");\n        return re({\n            equation: t\n        });\n    };\n});\nvar kf, gd, Ef, Pf, bd, yd = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    ae();\n    kf = (e1)=>{\n        if (!e1 || e1.length !== 2) throw new Error(\"Expand requires 2 input.\");\n        let t = e1[0].dims, r = Array.from(e1[1].getBigInt64Array(), Number), n = r.length < t.length ? 0 : r.length - t.length, o = t.length < r.length ? 0 : t.length - r.length;\n        for(; n < r.length && o < t.length; ++n, ++o)if (r[n] !== t[o] && r[n] !== 1 && t[o] !== 1) throw new Error(\"Expand requires shape to be broadcastable to input\");\n    }, gd = (e1, t)=>{\n        let r = e1.length - t.length, n = [];\n        for(let o = 0; o < r; ++o)n.push(e1[o]);\n        for(let o = 0; o < t.length; ++o)n.push(t[o] === 1 ? e1[o + r] : t[o]);\n        return n;\n    }, Ef = (e1, t)=>e1.length > t.length ? gd(e1, t) : gd(t, e1), Pf = (e1)=>{\n        let t = e1[0].dims, r = Array.from(e1[1].getBigInt64Array(), Number), n = Ef(t, r), o = e1[0].dataType, i = o === 9 || C.size(t) === 1, a = o === 9 || t.length > 0 && t[t.length - 1] % 4 === 0 ? 4 : 1, d = i || n.length > 0 && n[n.length - 1] % 4 === 0 ? 4 : 1, l = Math.ceil(C.size(n) / d), p = (u)=>{\n            let h = E(\"input\", o, t.length, a), _ = M(\"output\", o, n.length, d), y;\n            if (o === 9) {\n                let g = function(x, $) {\n                    let v = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"\";\n                    return \"\\n          let outputIndices\".concat($, \" = \").concat(_.offsetToIndices(\"outputOffset + \".concat($, \"u\")), \";\\n          let offset\").concat($, \" = \").concat(h.broadcastedIndicesToOffset(\"outputIndices\".concat($), _), \";\\n          let index\").concat($, \" = offset\").concat($, \" / 4u;\\n          let component\").concat($, \" = offset\").concat($, \" % 4u;\\n          \").concat(x, \"[\").concat($, \"] = \").concat(v, \"(\").concat(h.getByOffset(\"index\".concat($)), \"[component\").concat($, \"]);\\n        \");\n                };\n                y = \"\\n        let outputOffset = global_idx * \".concat(d, \";\\n        var data = vec4<u32>(0);\\n        \").concat(g(\"data\", 0, \"u32\"), \"\\n        \").concat(g(\"data\", 1, \"u32\"), \"\\n        \").concat(g(\"data\", 2, \"u32\"), \"\\n        \").concat(g(\"data\", 3, \"u32\"), \"\\n        \").concat(_.setByOffset(\"global_idx\", \"data\"), \"\\n      }\");\n            } else y = \"\\n        let outputIndices = \".concat(_.offsetToIndices(\"global_idx * \".concat(d)), \";\\n        let inputOffset = \").concat(h.broadcastedIndicesToOffset(\"outputIndices\", _), \";\\n        let data = \").concat(_.type.value, \"(\").concat(h.getByOffset(\"inputOffset / \".concat(a)), \");\\n        \").concat(_.setByOffset(\"global_idx\", \"data\"), \"\\n      }\");\n            return \"\\n    \".concat(u.registerUniform(\"vec_size\", \"u32\").declareVariables(h, _), \"\\n    \").concat(u.mainStart(), \"\\n    \").concat(u.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.vec_size\"), \"\\n    \").concat(y);\n        }, m = [\n            {\n                type: 12,\n                data: l\n            },\n            ...N(t, n)\n        ];\n        return {\n            name: \"Expand\",\n            shaderCache: {\n                hint: \"\".concat(n.length, \";\").concat(a).concat(d),\n                inputDependencies: [\n                    \"rank\"\n                ]\n            },\n            getShaderSource: p,\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: n,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(l / 64)\n                    },\n                    programUniforms: m\n                })\n        };\n    }, bd = (e1)=>{\n        kf(e1.inputs), e1.compute(Pf(e1.inputs), {\n            inputs: [\n                0\n            ]\n        });\n    };\n});\nvar zf, _d, wd = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    ae();\n    Kr();\n    zf = (e1)=>{\n        let t = e1[0].dataType, r = C.size(e1[0].dims), n = C.size(e1[1].dims), o = n % 4 === 0, i = (a)=>{\n            let d = E(\"x\", t, [\n                1\n            ], 4), l = E(\"bias\", t, [\n                1\n            ], 4), p = M(\"y\", t, [\n                1\n            ], 4), m = [\n                {\n                    name: \"output_vec_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"bias_size\",\n                    type: \"u32\"\n                }\n            ], u = (_)=>\"\\n      let bias\".concat(_, \"_offset: u32 = (global_idx * 4 + \").concat(_, \") % uniforms.bias_size;\\n      let bias\").concat(_, \" = \").concat(l.getByOffset(\"bias\".concat(_, \"_offset / 4\")), \"[bias\").concat(_, \"_offset % 4];\"), h = o ? \"\\n      let bias = \".concat(l.getByOffset(\"global_idx % (uniforms.bias_size / 4)\"), \";\") : \"\".concat(u(0)).concat(u(1)).concat(u(2)).concat(u(3), \"\\n      let bias = \").concat(d.type.value, \"(bias0, bias1, bias2, bias3);\");\n            return \"\".concat(a.registerUniforms(m).declareVariables(d, l, p), \"\\n\\n    \").concat(mo(Ee(t)), \"\\n\\n    \").concat(a.mainStart(kt), \"\\n      \").concat(a.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_vec_size\"), \"\\n\\n      let x = \").concat(d.getByOffset(\"global_idx\"), \";\\n      \").concat(h, \"\\n      let x_in = x + bias;\\n      \").concat(p.setByOffset(\"global_idx\", fo(\"x_in\")), \"\\n    }\");\n        };\n        return {\n            name: \"FastGeluWithBias\",\n            shaderCache: {\n                hint: \"\".concat(o),\n                inputDependencies: [\n                    \"type\",\n                    \"type\"\n                ]\n            },\n            getShaderSource: i,\n            getRunData: (a)=>({\n                    outputs: [\n                        {\n                            dims: a[0].dims,\n                            dataType: a[0].dataType\n                        }\n                    ],\n                    programUniforms: [\n                        {\n                            type: 12,\n                            data: Math.ceil(r / 4)\n                        },\n                        {\n                            type: 12,\n                            data: n\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(r / kt / 4)\n                    }\n                })\n        };\n    }, _d = (e1)=>{\n        e1.inputs.length < 2 || C.size(e1.inputs[1].dims) === 0 ? hu(e1) : e1.compute(zf(e1.inputs));\n    };\n});\nvar Of, Df, vd, $d, xd = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    Of = (e1)=>{\n        if (!e1 || e1.length !== 2) throw new Error(\"Gather requires 2 inputs.\");\n    }, Df = (e1, t)=>{\n        let r = e1[0].dims, n = e1[1].dims, o = r.length, i = C.normalizeAxis(t.axis, o), a = r.slice(0);\n        a.splice(i, 1, ...n);\n        let d = r[i], l = e1[0].dataType === 9 ? 4 : 1, p = Math.ceil(C.size(a) / l), m = [\n            {\n                type: 12,\n                data: p\n            },\n            {\n                type: 6,\n                data: d\n            },\n            {\n                type: 12,\n                data: i\n            },\n            ...N(e1[0].dims, e1[1].dims, a)\n        ], u = (h)=>{\n            let _ = E(\"data\", e1[0].dataType, e1[0].dims.length, l), y = E(\"inputIndices\", e1[1].dataType, e1[1].dims.length), g = M(\"output\", e1[0].dataType, a.length, l), x = (v)=>{\n                let S = n.length, T = \"var indicesIndices\".concat(v, \"  = \").concat(y.type.indices, \"(0);\");\n                for(let A = 0; A < S; A++)T += \"\".concat(S > 1 ? \"indicesIndices\".concat(v, \"[\").concat(A, \"]\") : \"indicesIndices\".concat(v), \" = \").concat(a.length > 1 ? \"outputIndices\".concat(v, \"[uniforms.axis + \").concat(A, \"]\") : \"outputIndices\".concat(v), \";\");\n                T += \"\\n          var idx\".concat(v, \" = \").concat(y.getByIndices(\"indicesIndices\".concat(v)), \";\\n          if (idx\").concat(v, \" < 0) {\\n            idx\").concat(v, \" = idx\").concat(v, \" + uniforms.axisDimLimit;\\n          }\\n          var dataIndices\").concat(v, \" : \").concat(_.type.indices, \";\\n        \");\n                for(let A = 0, k = 0; A < o; A++)A === i ? (T += \"\".concat(o > 1 ? \"dataIndices\".concat(v, \"[\").concat(A, \"]\") : \"dataIndices\".concat(v), \" = u32(idx\").concat(v, \");\"), k += S) : (T += \"\".concat(o > 1 ? \"dataIndices\".concat(v, \"[\").concat(A, \"]\") : \"dataIndices\".concat(v), \" = \").concat(a.length > 1 ? \"outputIndices\".concat(v, \"[\").concat(k, \"]\") : \"outputIndices\".concat(v), \";\"), k++);\n                return T;\n            }, $;\n            if (e1[0].dataType === 9) {\n                let v = function(S, T) {\n                    let A = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"\";\n                    return \"\\n          let outputIndices\".concat(T, \" = \").concat(g.offsetToIndices(\"outputOffset + \".concat(T, \"u\")), \";\\n          \").concat(x(T), \";\\n          let offset\").concat(T, \" = \").concat(_.indicesToOffset(\"dataIndices\".concat(T)), \";\\n          let index\").concat(T, \" = offset\").concat(T, \" / 4u;\\n          let component\").concat(T, \" = offset\").concat(T, \" % 4u;\\n          \").concat(S, \"[\").concat(T, \"] = \").concat(A, \"(\").concat(_.getByOffset(\"index\".concat(T)), \"[component\").concat(T, \"]);\\n        \");\n                };\n                $ = \"\\n        let outputOffset = global_idx * \".concat(l, \";\\n        var value = vec4<u32>(0);\\n        \").concat(v(\"value\", 0, \"u32\"), \"\\n        \").concat(v(\"value\", 1, \"u32\"), \"\\n        \").concat(v(\"value\", 2, \"u32\"), \"\\n        \").concat(v(\"value\", 3, \"u32\"), \"\\n        \").concat(g.setByOffset(\"global_idx\", \"value\"), \"\\n      \");\n            } else $ = \"\\n      let outputIndices = \".concat(g.offsetToIndices(\"global_idx\"), \";\\n      \").concat(x(\"\"), \";\\n      let value = \").concat(_.getByIndices(\"dataIndices\"), \";\\n      \").concat(g.setByOffset(\"global_idx\", \"value\"), \";\\n      \");\n            return \"\\n      \".concat(h.registerUniform(\"outputSize\", \"u32\").registerUniform(\"axisDimLimit\", \"i32\").registerUniform(\"axis\", \"u32\").declareVariables(_, y, g), \"\\n      \").concat(h.mainStart(), \"\\n        \").concat(h.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\"), \"\\n        \").concat($, \"\\n      }\");\n        };\n        return {\n            name: \"Gather\",\n            shaderCache: {\n                hint: t.cacheKey,\n                inputDependencies: [\n                    \"rank\",\n                    \"rank\"\n                ]\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: a,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(p / 64)\n                    },\n                    programUniforms: m\n                }),\n            getShaderSource: u\n        };\n    }, vd = (e1)=>re({\n            axis: e1.axis\n        }), $d = (e1, t)=>{\n        let r = e1.inputs;\n        Of(r), e1.compute(Df(e1.inputs, t));\n    };\n});\nvar Bf, Sd, Td, Id = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    ae();\n    Bf = (e1, t, r, n, o, i, a, d, l)=>{\n        let p = [\n            {\n                type: 12,\n                data: i\n            },\n            {\n                type: 12,\n                data: n\n            },\n            {\n                type: 12,\n                data: o\n            },\n            {\n                type: 12,\n                data: r\n            },\n            {\n                type: 12,\n                data: a\n            },\n            {\n                type: 12,\n                data: d\n            },\n            {\n                type: 12,\n                data: l\n            }\n        ], m = [\n            i\n        ];\n        p.push(...N(t.dims, m));\n        let u = (h)=>{\n            let _ = E(\"indices_data\", t.dataType, t.dims.length), y = M(\"input_slice_offsets_data\", 12, 1, 1), g = [\n                _,\n                y\n            ], x = [\n                {\n                    name: \"output_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"batch_dims\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"input_dims\",\n                    type: \"u32\",\n                    length: o.length\n                },\n                {\n                    name: \"sizes_from_slice_dims_data\",\n                    type: \"u32\",\n                    length: r.length\n                },\n                {\n                    name: \"num_slices_per_batch\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"input_batch_stride\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"num_slice_dims\",\n                    type: \"u32\"\n                }\n            ];\n            return \"\\n  \".concat(h.registerUniforms(x).declareVariables(...g), \"\\n  \").concat(h.mainStart(), \"\\n    \").concat(h.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\"), \"\\n    let batch_idx = global_idx / uniforms.num_slices_per_batch;\\n    let base_offset = batch_idx * uniforms.input_batch_stride;\\n\\n    let slice_indices_base_offset = global_idx * uniforms.num_slice_dims;\\n    var relative_slice_offset = 0;\\n    for (var dim_idx = 0u; dim_idx < uniforms.num_slice_dims; dim_idx ++) {\\n      var index = i32(indices_data[dim_idx + slice_indices_base_offset].x);\\n      let input_dim_idx = uniforms.batch_dims + dim_idx;\\n      if (index < 0) {\\n        \").concat(o.length === 1 ? \"index += i32(uniforms.input_dims);\" : \"index += i32(uniforms.input_dims[input_dim_idx]);\", \"\\n      }\\n      \").concat(r.length === 1 ? \"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data);\" : \"relative_slice_offset += index * i32(uniforms.sizes_from_slice_dims_data[dim_idx]);\", \"\\n    }\\n\\n    input_slice_offsets_data[global_idx] =  base_offset + u32(relative_slice_offset);\\n  }\");\n        };\n        return e1.compute({\n            name: \"computeSliceOffsets\",\n            shaderCache: {\n                hint: \"\".concat(o.length, \"_\").concat(r.length),\n                inputDependencies: [\n                    \"rank\"\n                ]\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: m,\n                            dataType: e1.inputs[1].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(i / 64)\n                    },\n                    programUniforms: p\n                }),\n            getShaderSource: u\n        }, {\n            inputs: [\n                t\n            ],\n            outputs: [\n                -1\n            ]\n        })[0];\n    }, Sd = (e1, t)=>{\n        let r = e1.inputs, n = r[0].dims, o = r[0].dataType, i = r[1].dims, a = i[i.length - 1], d = C.sizeToDimension(i, i.length - 1), l = C.sizeFromDimension(n, t.batchDims + a), p = C.sizeToDimension(n, t.batchDims), m = C.sizeFromDimension(n, t.batchDims), u = d / p, h = new Array(a), _ = l;\n        for(let T = 0; T < a; ++T)h[a - 1 - T] = _, _ *= n[t.batchDims + a - 1 - T];\n        let y = Bf(e1, r[1], h, t.batchDims, n, d, u, m, a), g = t.batchDims + a;\n        if (g > n.length) throw new Error(\"last dimension of indices must not be larger than rank of input tensor\");\n        let x = i.slice(0, -1).concat(n.slice(g)), $ = C.size(x), v = [\n            {\n                type: 12,\n                data: $\n            },\n            {\n                type: 12,\n                data: l\n            },\n            ...N(r[0].dims, y.dims, x)\n        ], S = (T)=>{\n            let A = E(\"data\", r[0].dataType, r[0].dims.length), k = E(\"slice_offsets\", 12, y.dims.length), P = M(\"output\", r[0].dataType, x.length);\n            return \"\\n          \".concat(T.registerUniform(\"output_size\", \"u32\").registerUniform(\"slice_size\", \"u32\").declareVariables(A, k, P), \"\\n            \").concat(T.mainStart(), \"\\n            \").concat(T.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\"), \"\\n          let slice_offset = slice_offsets[global_idx / uniforms.slice_size];\\n          output[global_idx] = data[u32(slice_offset) + global_idx % uniforms.slice_size];\\n        }\");\n        };\n        e1.compute({\n            name: \"GatherND\",\n            shaderCache: {\n                hint: t.cacheKey,\n                inputDependencies: [\n                    \"rank\",\n                    \"rank\"\n                ]\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: x,\n                            dataType: o\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil($ / 64)\n                    },\n                    programUniforms: v\n                }),\n            getShaderSource: S\n        }, {\n            inputs: [\n                r[0],\n                y\n            ]\n        });\n    }, Td = (e1)=>({\n            batchDims: e1.batch_dims,\n            cacheKey: \"\"\n        });\n});\nvar Mf, Rf, Cd, Ad, kd = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    Mf = (e1, t)=>{\n        if (e1.length < 3 || e1.length > 4) throw new Error(\"GatherBlockQuantized requires 3 or 4 inputs.\");\n        let r = C.normalizeAxis(t.quantizeAxis, e1[0].dims.length), n = t.blockSize, o = e1[0], i = e1[2], a = e1.length === 4 ? e1[3] : void 0;\n        if (i.dims.length !== o.dims.length || !o.dims.map((d, l)=>l === r ? Math.ceil(d / n) === i.dims[l] : d === i.dims[l]).reduce((d, l)=>d && l, !0)) throw new Error(\"Scales must have the same rank as the input tensor and the dims should match except on gatherAxis.\");\n        if (a) {\n            if (a.dataType !== o.dataType) throw new Error(\"Zero point must have the same data type as the input tensor.\");\n            if (a.dims.length !== i.dims.length || !a.dims.map((d, l)=>d === i.dims[l]).reduce((d, l)=>d && l, !0)) throw new Error(\"Zero point must have the same rank as the input tensor and the dims should match except on quantizeAxis.\");\n        }\n    }, Rf = (e1, t)=>{\n        let r = e1[0].dims, n = e1[1].dims, o = r.length, i = C.normalizeAxis(t.gatherAxis, o), a = C.normalizeAxis(t.quantizeAxis, o), d = r.slice(0);\n        d.splice(i, 1, ...n);\n        let l = C.size(d), p = e1[2].dataType, u = e1[0].dataType === 22, h = [\n            {\n                type: 12,\n                data: l\n            },\n            {\n                type: 12,\n                data: a\n            },\n            {\n                type: 12,\n                data: i\n            },\n            {\n                type: 12,\n                data: t.blockSize\n            },\n            ...N(...e1.map((y, g)=>y.dims), d)\n        ], _ = (y)=>{\n            let g = E(\"data\", e1[0].dataType, e1[0].dims.length), x = E(\"inputIndices\", e1[1].dataType, e1[1].dims.length), $ = E(\"scales\", e1[2].dataType, e1[2].dims.length), v = e1.length > 3 ? E(\"zeroPoint\", e1[3].dataType, e1[3].dims.length) : void 0, S = M(\"output\", p, d.length), T = [\n                g,\n                x,\n                $\n            ];\n            v && T.push(v);\n            let A = [\n                {\n                    name: \"output_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"quantize_axis\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"gather_axis\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"block_size\",\n                    type: \"u32\"\n                }\n            ];\n            return \"\\n        \".concat(y.registerUniforms(A).declareVariables(...T, S), \"\\n        \").concat(y.mainStart(), \"\\n        let output_indices = \").concat(S.offsetToIndices(\"global_idx\"), \";\\n        var indices_indices = \").concat(x.type.indices, \"(0);\\n        \").concat((()=>n.length > 1 ? \"\\n          for (var i: u32 = 0; i < \".concat(n.length, \"; i++) {\\n            let index = \").concat(S.indicesGet(\"output_indices\", \"uniforms.gather_axis + i\"), \";\\n            \").concat(x.indicesSet(\"indices_indices\", \"i\", \"index\"), \";\\n          }\") : \"indices_indices = \".concat(S.indicesGet(\"output_indices\", \"uniforms.gather_axis\"), \";\"))(), \";\\n        var data_indices = \").concat(g.type.indices, \"(0);\\n        for (var i: u32 = 0; i < uniforms.gather_axis; i++) {\\n          let index = \").concat(S.indicesGet(\"output_indices\", \"i\"), \";\\n          \").concat(g.indicesSet(\"data_indices\", \"i\", \"index\"), \";\\n        }\\n        var index_from_indices = \").concat(x.getByIndices(\"indices_indices\"), \";\\n        if (index_from_indices < 0) {\\n          index_from_indices += \").concat(r[i], \";\\n        }\\n        \").concat(g.indicesSet(\"data_indices\", \"uniforms.gather_axis\", \"u32(index_from_indices)\"), \";\\n        for (var i = uniforms.gather_axis + 1; i < \").concat(d.length, \"; i++) {\\n          let index = \").concat(S.indicesGet(\"output_indices\", \"i + \".concat(n.length, \" - 1\")), \";\\n          \").concat(g.indicesSet(\"data_indices\", \"i\", \"index\"), \";\\n        }\\n        let data_offset = \").concat(g.indicesToOffset(\"data_indices\"), \";\\n        let data_index = data_offset % 8;\\n        // Convert 4-bit packed data to 8-bit packed data.\\n        let packed_4bit_quantized_data = \").concat(g.getByOffset(\"data_offset / 8\"), \";\\n        let packed_8bit_quantized_data = (packed_4bit_quantized_data >> (4 * (data_index % 2))) & 0x0f0f0f0f;\\n        let quantized_data_vec = \").concat(u ? \"unpack4xI8\" : \"unpack4xU8\", \"(u32(packed_8bit_quantized_data));\\n        let quantized_data = quantized_data_vec[data_index / 2];\\n        var scale_indices = data_indices;\\n        let quantize_axis_index = \").concat($.indicesGet(\"data_indices\", \"uniforms.quantize_axis\"), \" / uniforms.block_size;\\n        \").concat($.indicesSet(\"scale_indices\", \"uniforms.quantize_axis\", \"quantize_axis_index\"), \";\\n        var scale = \").concat($.getByIndices(\"scale_indices\"), \";\\n        \").concat((()=>v ? \"\\n              let zero_point_indices = scale_indices;\\n              let zero_point_offset = \".concat(v.indicesToOffset(\"zero_point_indices\"), \";\\n              let zero_point_index = zero_point_offset % 8;\\n              let packed_4bit_zero_points = \").concat(v.getByOffset(\"zero_point_offset / 8\"), \";\\n              let packed_8bit_zero_points = (packed_4bit_zero_points >> (4 * (zero_point_index % 2))) & 0x0f0f0f0f;\\n              let zero_point_vec = \").concat(u ? \"unpack4xI8\" : \"unpack4xU8\", \"(u32(packed_8bit_zero_points));\\n              let zero_point = zero_point_vec[zero_point_index / 2];\") : \"var zero_point = 0\")(), \";\\n        let dequantized_data = \").concat(Ee(p), \"(quantized_data - zero_point) * scale;\\n        \").concat(S.setByOffset(\"global_idx\", \"dequantized_data\"), \";\\n    }\");\n        };\n        return {\n            name: \"GatherBlockQuantized\",\n            shaderCache: {\n                hint: \"\".concat(t.cacheKey, \";\").concat(e1.filter((y, g)=>g !== 1).map((y)=>y.dims.join(\"_\")).join(\";\")),\n                inputDependencies: Array.from({\n                    length: e1.length\n                }, (y, g)=>\"rank\")\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: d,\n                            dataType: p\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(l / 64)\n                    },\n                    programUniforms: h\n                }),\n            getShaderSource: _\n        };\n    }, Cd = (e1, t)=>{\n        let r = e1.inputs;\n        Mf(r, t), e1.compute(Rf(e1.inputs, t));\n    }, Ad = (e1)=>re({\n            blockSize: e1.blockSize,\n            gatherAxis: e1.gatherAxis,\n            quantizeAxis: e1.quantizeAxis\n        });\n});\nvar Uf, Nf, Ed, Pd, zd = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    Uf = (e1)=>{\n        if (!e1 || e1.length !== 2) throw new Error(\"GatherElements requires 2 inputs.\");\n        if (e1[0].dims.length < 1) throw new Error(\"GatherElements requires that the data input be rank >= 1.\");\n        if (e1[0].dims.length !== e1[1].dims.length) throw new Error(\"GatherElements requires that the data input and\\n                     indices input tensors be of same rank.\");\n    }, Nf = (e1, t)=>{\n        let r = e1[0].dims, n = e1[0].dataType, o = r.length, i = e1[1].dims, a = e1[1].dataType, d = C.normalizeAxis(t.axis, o), l = r[d], p = i.slice(0), m = C.size(p), u = E(\"input\", n, o), h = E(\"indicesInput\", a, i.length), _ = M(\"output\", n, p.length), y = [\n            {\n                type: 12,\n                data: m\n            },\n            {\n                type: 6,\n                data: l\n            },\n            {\n                type: 12,\n                data: d\n            }\n        ];\n        return y.push(...N(r, i, p)), {\n            name: \"GatherElements\",\n            shaderCache: {\n                inputDependencies: [\n                    \"rank\",\n                    \"rank\"\n                ]\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: p,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(m / 64)\n                    },\n                    programUniforms: y\n                }),\n            getShaderSource: ($)=>\"\\n      \".concat($.registerUniform(\"outputSize\", \"u32\").registerUniform(\"axisDimLimit\", \"i32\").registerUniform(\"axis\", \"u32\").declareVariables(u, h, _), \"\\n      \").concat($.mainStart(), \"\\n      \").concat($.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\"), \"\\n\\n      let outputIndices = \").concat(_.offsetToIndices(\"global_idx\"), \";\\n\\n      var idx = \").concat(h.getByOffset(\"global_idx\"), \";\\n      if (idx < 0) {\\n        idx = idx + uniforms.axisDimLimit;\\n      }\\n      var inputIndices = \").concat(u.type.indices, \"(outputIndices);\\n      \").concat(u.indicesSet(\"inputIndices\", \"uniforms.axis\", \"u32(idx)\"), \";\\n      let value = \").concat(u.getByIndices(\"inputIndices\"), \";\\n\\n      \").concat(_.setByOffset(\"global_idx\", \"value\"), \";\\n  }\")\n        };\n    }, Ed = (e1)=>re({\n            axis: e1.axis\n        }), Pd = (e1, t)=>{\n        let r = e1.inputs;\n        Uf(r), e1.compute(Nf(e1.inputs, t));\n    };\n});\nvar Vf, Wf, Od, Dd, Bd = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    ae();\n    Vf = (e1)=>{\n        if (!e1) throw new Error(\"Input is missing\");\n        if (e1.length < 2 || e1.length > 3) throw new Error(\"Invaid input number.\");\n        if (e1.length === 3 && e1[2].dims.length > 2) throw new Error(\"Invalid input shape of C\");\n        if (e1[0].dataType !== e1[1].dataType || e1.length === 3 && e1[0].dataType !== e1[2].dataType) throw new Error(\"Input types are mismatched\");\n    }, Wf = (e1, t)=>{\n        let r = e1[0].dims.slice(), n = e1[1].dims.slice(), [o, i, a] = Vr.getShapeOfGemmResult(r, t.transA, n, t.transB, e1.length === 3 ? e1[2].dims : void 0), d = [\n            o,\n            i\n        ];\n        if (!d) throw new Error(\"Can't use gemm on the given tensors\");\n        let l = 16, p = Math.ceil(i / l), m = Math.ceil(o / l), u = !0, h = C.size(d), _ = [\n            {\n                type: 12,\n                data: u ? p : h\n            },\n            {\n                type: 12,\n                data: o\n            },\n            {\n                type: 12,\n                data: i\n            },\n            {\n                type: 12,\n                data: a\n            },\n            {\n                type: 1,\n                data: t.alpha\n            },\n            {\n                type: 1,\n                data: t.beta\n            }\n        ], y = [\n            \"type\",\n            \"type\"\n        ];\n        e1.length === 3 && (_.push(...N(e1[2].dims)), y.push(\"rank\")), _.push(...N(d));\n        let g = ($)=>{\n            let v = \"\";\n            t.transA && t.transB ? v = \"value += a[k * uniforms.M + m] * b[n * uniforms.K + k];\" : t.transA && !t.transB ? v = \"value += a[k * uniforms.M + m] * b[k * uniforms.N + n];\" : !t.transA && t.transB ? v = \"value += a[m * uniforms.K + k] * b[n * uniforms.K + k];\" : !t.transA && !t.transB && (v = \"value += a[m * uniforms.K + k] * b[k * uniforms.N + n];\");\n            let S = t.alpha === 1 ? \"\" : \"value *= uniforms.alpha;\", T = E(\"a\", e1[0].dataType, e1[0].dims), A = E(\"b\", e1[1].dataType, e1[1].dims), k = T.type.value, P = null, D = [\n                T,\n                A\n            ];\n            e1.length === 3 && (P = E(\"c\", e1[2].dataType, e1[2].dims.length), D.push(P));\n            let R = M(\"output\", e1[0].dataType, d.length);\n            D.push(R);\n            let G = [\n                {\n                    name: \"output_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"M\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"N\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"K\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"alpha\",\n                    type: \"f32\"\n                },\n                {\n                    name: \"beta\",\n                    type: \"f32\"\n                }\n            ];\n            return \"\\n  \".concat($.registerUniforms(G).declareVariables(...D), \"\\n\\n  \").concat($.mainStart(), \"\\n    \").concat($.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\"), \"\\n\\n    let m = global_idx / uniforms.N;\\n    let n = global_idx % uniforms.N;\\n\\n    var value = \").concat(k, \"(0);\\n    for (var k: u32 = 0u; k < uniforms.K; k++) {\\n      \").concat(v, \"\\n    }\\n\\n    \").concat(S, \"\\n    \").concat((()=>P != null ? \"let cOffset = \".concat(P.broadcastedIndicesToOffset(\"vec2(m, n)\", R), \"; value += \").concat(k, \"(uniforms.beta) * \").concat(P.getByOffset(\"cOffset\"), \";\") : \"\")(), \"\\n    output[global_idx] = value;\\n  }\");\n        }, x = ($)=>{\n            let v = E(\"a\", e1[0].dataType, e1[0].dims), S = E(\"b\", e1[1].dataType, e1[1].dims), T = null, A = [\n                v,\n                S\n            ];\n            e1.length === 3 && (T = E(\"c\", e1[2].dataType, e1[2].dims.length), A.push(T));\n            let k = M(\"output\", e1[0].dataType, d.length);\n            A.push(k);\n            let P = [\n                {\n                    name: \"num_tile_n\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"M\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"N\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"K\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"alpha\",\n                    type: \"f32\"\n                },\n                {\n                    name: \"beta\",\n                    type: \"f32\"\n                }\n            ], D = \"\", R = \"\";\n            t.transA && t.transB ? (R = \"\\n      var col = tile_row_start + local_id.x;\\n      var row = k_start + local_id.y;\\n      if (col < uniforms.M && row < uniforms.K) {\\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];\\n      } else {\\n        tile_a[local_id.y][local_id.x] = \".concat(v.type.value, \"(0);\\n      }\\n\\n      col = k_start + local_id.x;\\n      row = tile_col_start + local_id.y;\\n      if (col < uniforms.K && row < uniforms.N) {\\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];\\n      } else {\\n        tile_b[local_id.y][local_id.x] = \").concat(S.type.value, \"(0);\\n      }\\n      \"), D = \"value += tile_a[k][local_id.y] * tile_b[local_id.x][k];\") : t.transA && !t.transB ? (R = \"\\n      var col = tile_row_start + local_id.x;\\n      var row = k_start + local_id.y;\\n      if (col < uniforms.M && row < uniforms.K) {\\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.M + col];\\n      } else {\\n        tile_a[local_id.y][local_id.x] = \".concat(v.type.value, \"(0);\\n      }\\n\\n      col = tile_col_start + local_id.x;\\n      row = k_start + local_id.y;\\n      if (col < uniforms.N && row < uniforms.K) {\\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];\\n      } else {\\n        tile_b[local_id.y][local_id.x] = \").concat(S.type.value, \"(0);\\n      }\\n      \"), D = \"value += tile_a[k][local_id.y] * tile_b[k][local_id.x];\") : !t.transA && t.transB ? (R = \"\\n      var col = k_start + local_id.x;\\n      var row = tile_row_start + local_id.y;\\n      if (col < uniforms.K && row < uniforms.M) {\\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];\\n      } else {\\n        tile_a[local_id.y][local_id.x] = \".concat(v.type.value, \"(0);\\n      }\\n\\n      col = k_start + local_id.x;\\n      row = tile_col_start + local_id.y;\\n      if (col < uniforms.K && row < uniforms.N) {\\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.K + col];\\n      } else {\\n        tile_b[local_id.y][local_id.x] = \").concat(S.type.value, \"(0);\\n      }\\n      \"), D = \"value += tile_a[local_id.y][k] * tile_b[local_id.x][k];\") : !t.transA && !t.transB && (R = \"\\n      var col = k_start + local_id.x;\\n      var row = tile_row_start + local_id.y;\\n      if (col < uniforms.K && row < uniforms.M) {\\n        tile_a[local_id.y][local_id.x] = a[row * uniforms.K + col];\\n      } else {\\n        tile_a[local_id.y][local_id.x] = \".concat(v.type.value, \"(0);\\n      }\\n\\n      col = tile_col_start + local_id.x;\\n      row = k_start + local_id.y;\\n      if (col < uniforms.N && row < uniforms.K) {\\n        tile_b[local_id.y][local_id.x] = b[row * uniforms.N + col];\\n      } else {\\n        tile_b[local_id.y][local_id.x] = \").concat(S.type.value, \"(0);\\n      }\\n      \"), D = \"value += tile_a[local_id.y][k] * tile_b[k][local_id.x];\");\n            let G = t.alpha === 1 ? \"\" : \"value *= uniforms.alpha;\";\n            return \"\\n  \".concat($.registerUniforms(P).declareVariables(...A), \"\\n  var<workgroup> tile_a: array<array<\").concat(v.type.storage, \", \").concat(l, \">, \").concat(l, \">;\\n  var<workgroup> tile_b: array<array<\").concat(S.type.storage, \", \").concat(l, \">, \").concat(l, \">;\\n  \").concat($.mainStart([\n                l,\n                l,\n                1\n            ]), \"\\n    let tile_col_start = (workgroup_index % uniforms.num_tile_n) * \").concat(l, \";\\n    let tile_row_start = (workgroup_index / uniforms.num_tile_n) * \").concat(l, \";\\n    let num_tiles = (uniforms.K - 1) / \").concat(l, \" + 1;\\n    var k_start = 0u;\\n    var value = \").concat(k.type.value, \"(0);\\n    for (var t: u32 = 0u; t < num_tiles; t++) {\\n      \").concat(R, \"\\n      k_start = k_start + \").concat(l, \";\\n      workgroupBarrier();\\n\\n      for (var k: u32 = 0u; k < \").concat(l, \"; k++) {\\n        \").concat(D, \"\\n      }\\n      workgroupBarrier();\\n    }\\n\\n    \").concat(G, \"\\n    let m = tile_row_start + local_id.y;\\n    let n = tile_col_start + local_id.x;\\n    \").concat((()=>T != null ? \"let cOffset = \".concat(T.broadcastedIndicesToOffset(\"vec2(m, n)\", k), \"; value += \").concat(k.type.value, \"(uniforms.beta) * \").concat(T.getByOffset(\"cOffset\"), \";\") : \"\")(), \"\\n    if (m < uniforms.M && n < uniforms.N) {\\n      output[m * uniforms.N + n] = value;\\n    }\\n  }\");\n        };\n        return u ? {\n            name: \"GemmShared\",\n            shaderCache: {\n                hint: \"\".concat(t.cacheKey),\n                inputDependencies: y\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: d,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: p * m\n                    },\n                    programUniforms: _\n                }),\n            getShaderSource: x\n        } : {\n            name: \"Gemm\",\n            shaderCache: {\n                hint: \"\".concat(t.cacheKey),\n                inputDependencies: y\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: d,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(h / 64)\n                    },\n                    programUniforms: _\n                }),\n            getShaderSource: g\n        };\n    }, Od = (e1)=>{\n        let t = e1.transA, r = e1.transB, n = e1.alpha, o = e1.beta;\n        return {\n            transA: t,\n            transB: r,\n            alpha: n,\n            beta: o,\n            cacheKey: \"\".concat(e1.transA, \";\").concat(e1.transB, \";\").concat(e1.alpha === 1)\n        };\n    }, Dd = (e1, t)=>{\n        Vf(e1.inputs), e1.compute(Wf(e1.inputs, t));\n    };\n});\nvar lt, _t, Ut, Nt, Lf, Gf, Hf, Ff, qf, Kf, jf, Yf, Md, Rd, Ud = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    [lt, _t, Ut, Nt] = [\n        0,\n        1,\n        2,\n        3\n    ], Lf = (e1)=>{\n        if (e1[0].dims.length !== 4) throw new Error(\"only 4-D tensor is supported.\");\n        if (e1[0].dims.length !== e1[1].dims.length) throw new Error(\"input dimensions must be equal to grid dimensions\");\n        if (e1[0].dims.length - 2 !== e1[1].dims[e1[1].dims.length - 1]) throw new Error(\"last dimension of grid must be equal to \".concat(e1[0].dims.length - 2));\n        if (e1[0].dims[0] !== e1[1].dims[0]) throw new Error(\"grid batch size must match input batch size\");\n    }, Gf = \"\\n  fn gs_get_cubic_coeffs(x: f32) -> vec4<f32> {\\n    let cubic_alpha = -0.75f;\\n    let x_abs = abs(x);\\n    var coeffs: vec4<f32>;\\n    coeffs[0] = (((cubic_alpha * (x_abs + 1) - 5 * cubic_alpha) * (x_abs + 1) + 8 * cubic_alpha) * (x_abs + 1) - 4 * cubic_alpha);\\n    coeffs[1] = (((cubic_alpha + 2) * x_abs - (cubic_alpha + 3)) * x_abs * x_abs + 1);\\n    coeffs[2] = (((cubic_alpha + 2) * (1 - x_abs) - (cubic_alpha + 3)) * (1 - x_abs) * (1 - x_abs) + 1);\\n    coeffs[3] = (((cubic_alpha * (2 - x_abs) - 5 * cubic_alpha) * (2 - x_abs) + 8 * cubic_alpha) * (2 - x_abs) - 4 * cubic_alpha);\\n    return coeffs;\\n  }\\n\", Hf = (e1)=>\"\\n  fn gs_bicubic_interpolate(p: mat4x4<\".concat(e1, \">, x: f32, y: f32) -> \").concat(e1, \" {\\n    var v: vec4<f32>;\\n    var coeffs = gs_get_cubic_coeffs(x);\\n    for (var i = 0; i < 4; i++) {\\n      v[i] = coeffs[0] * p[i][0] + coeffs[1] * p[i][1] + coeffs[2] * p[i][2] + coeffs[3] * p[i][3];\\n    }\\n    coeffs = gs_get_cubic_coeffs(y);\\n    let pixel = \").concat(e1, \"(coeffs[0] * v[0] + coeffs[1] * v[1] + coeffs[2] * v[2] + coeffs[3] * v[3]);\\n    return pixel;\\n  }\\n\"), Ff = (e1)=>\"\\n  fn gs_denormalize(n: f32, length: i32) -> f32 {\\n    \".concat(e1.alignCorners === 0 ? \"\\n    // alignCorners: false => [-1, 1] to [-0.5, length - 0.5]\\n    return ((n + 1.0) * f32(length) - 1.0) / 2.0;\\n    \" : \"\\n    // alignCorners: true => [-1, 1] to [0, length - 1]\\n    return (n + 1.0) / 2.0 * (f32(length - 1));\\n    \", \"\\n  }\\n\"), qf = (e1)=>\"\\n  \".concat(e1.paddingMode === \"reflection\" ? \"\\n      fn gs_reflect(x: i32, x_min: f32, x_max: f32) -> u32 {\\n        var dx = 0.0;\\n        var fx = f32(x);\\n        let range = x_max - x_min;\\n        if (fx < x_min) {\\n          dx = x_min - fx;\\n          let n = u32(dx / range);\\n          let r = dx - f32(n) * range;\\n          if (n % 2 == 0) {\\n            fx = x_min + r;\\n          } else {\\n            fx = x_max - r;\\n          }\\n        } else if (fx > x_max) {\\n          dx = fx - x_max;\\n          let n = u32(dx / range);\\n          let r = dx - f32(n) * range;\\n          if (n % 2 == 0) {\\n            fx = x_max - r;\\n          } else {\\n            fx = x_min + r;\\n          }\\n        }\\n        return u32(fx);\\n      }\" : \"\", \"\\n\"), Kf = (e1, t, r)=>\"\\n  fn pixel_at_grid(r: i32, c: i32, H: i32, W: i32, batch: u32, channel: u32, border: vec4<f32>) -> \".concat(t, \" {\\n     var pixel = \").concat(t, \"(0);\\n     var indices = vec4<u32>(0);\\n     indices[\").concat(lt, \"] = batch;\\n     indices[\").concat(_t, \"] = channel;\") + (()=>{\n            switch(r.paddingMode){\n                case \"zeros\":\n                    return \"\\n          if (r >= 0 && r < H && c >=0 && c < W) {\\n            indices[\".concat(Ut, \"] = u32(r);\\n            indices[\").concat(Nt, \"] = u32(c);\\n          }\\n        \");\n                case \"border\":\n                    return \"\\n          indices[\".concat(Ut, \"] = u32(clamp(r, 0, H - 1));\\n          indices[\").concat(Nt, \"] = u32(clamp(c, 0, W - 1));\\n        \");\n                case \"reflection\":\n                    return \"\\n          indices[\".concat(Ut, \"] = gs_reflect(r, border[1], border[3]);\\n          indices[\").concat(Nt, \"] = gs_reflect(c, border[0], border[2]);\\n        \");\n                default:\n                    throw new Error(\"padding mode \".concat(r.paddingMode, \" is not supported\"));\n            }\n        })() + \"\\n    return \".concat(e1.getByIndices(\"indices\"), \";\\n  }\\n\"), jf = (e1, t, r)=>(()=>{\n            switch(r.mode){\n                case \"nearest\":\n                    return \"\\n          let result = pixel_at_grid(i32(round(y)), i32(round(x)), H_in, W_in, indices[\".concat(lt, \"], indices[\").concat(_t, \"], border);\\n        \");\n                case \"bilinear\":\n                    return \"\\n          let x1 = i32(floor(x));\\n          let y1 = i32(floor(y));\\n          let x2 = x1 + 1;\\n          let y2 = y1 + 1;\\n\\n          let p11 = pixel_at_grid(y1, x1, H_in, W_in, indices[\".concat(lt, \"], indices[\").concat(_t, \"], border);\\n          let p12 = pixel_at_grid(y1, x2, H_in, W_in, indices[\").concat(lt, \"], indices[\").concat(_t, \"], border);\\n          let p21 = pixel_at_grid(y2, x1, H_in, W_in, indices[\").concat(lt, \"], indices[\").concat(_t, \"], border);\\n          let p22 = pixel_at_grid(y2, x2, H_in, W_in, indices[\").concat(lt, \"], indices[\").concat(_t, \"], border);\\n\\n          let dx2 = \").concat(t, \"(f32(x2) - x);\\n          let dx1 = \").concat(t, \"(x - f32(x1));\\n          let dy2 = \").concat(t, \"(f32(y2) - y);\\n          let dy1 = \").concat(t, \"(y - f32(y1));\\n          let result = dy2 * (dx2 * p11 + dx1 * p12) + dy1 * (dx2 * p21 + dx1 * p22);\\n        \");\n                case \"bicubic\":\n                    return \"\\n          let x0 = i32(floor(x)) - 1;\\n          let y0 = i32(floor(y)) - 1;\\n          var p: mat4x4<\".concat(t, \">;\\n          for (var h = 0; h < 4; h++) {\\n            for (var w = 0; w < 4; w++) {\\n              p[h][w] = pixel_at_grid(h + y0, w + x0, H_in, W_in, indices[\").concat(lt, \"], indices[\").concat(_t, \"], border);\\n            }\\n          }\\n\\n          let dx = x - f32(x0 + 1);\\n          let dy = y - f32(y0 + 1);\\n          let result = gs_bicubic_interpolate(p, dx, dy);\\n        \");\n                default:\n                    throw new Error(\"mode \".concat(r.mode, \" is not supported\"));\n            }\n        })() + \"\".concat(e1.setByOffset(\"global_idx\", \"result\")), Yf = (e1, t)=>{\n        let r = E(\"x\", e1[0].dataType, e1[0].dims.length), n = [\n            e1[1].dims[0],\n            e1[1].dims[1],\n            e1[1].dims[2]\n        ], o = E(\"grid\", e1[1].dataType, n.length, 2), i = [\n            e1[0].dims[0],\n            e1[0].dims[1],\n            e1[1].dims[1],\n            e1[1].dims[2]\n        ];\n        t.format === \"NHWC\" && (i = [\n            e1[0].dims[0],\n            e1[1].dims[1],\n            e1[1].dims[2],\n            e1[0].dims[3]\n        ], [lt, _t, Ut, Nt] = [\n            0,\n            3,\n            1,\n            2\n        ]);\n        let a = M(\"output\", e1[0].dataType, i.length), d = r.type.value, l = C.size(i), p = [\n            {\n                type: 12,\n                data: l\n            },\n            ...N(e1[0].dims, n, i)\n        ], m = (u)=>\"\\n  \".concat(u.registerUniform(\"output_size\", \"u32\").declareVariables(r, o, a), \"\\n  \").concat(Gf, \"\\n  \").concat(Hf(d), \"\\n  \").concat(Ff(t), \"\\n  \").concat(qf(t), \"\\n  \").concat(Kf(r, d, t), \"\\n\\n  \").concat(u.mainStart(), \"\\n    \").concat(u.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\"), \"\\n      let H_in = i32(uniforms.x_shape[\").concat(Ut, \"]);\\n      let W_in = i32(uniforms.x_shape[\").concat(Nt, \"]);\\n\\n      \").concat(t.alignCorners === 0 ? \"\\n      let x_min = -0.5;\\n      let x_max = f32(W_in) - 0.5;\\n      let y_min = -0.5;\\n      let y_max = f32(H_in) - 0.5;\\n      \" : \"\\n      let x_min = 0.0;\\n      let x_max = f32(W_in) - 1.0;\\n      let y_min = 0.0;\\n      let y_max = f32(H_in) - 1.0;\\n      \", \";\\n      let border = vec4<f32>(x_min, y_min, x_max, y_max);\\n\\n      let indices = \").concat(a.offsetToIndices(\"global_idx\"), \";\\n      var grid_indices = vec3<u32>(indices[\").concat(lt, \"], indices[\").concat(Ut, \"], indices[\").concat(Nt, \"]);\\n      let nxy = \").concat(o.getByIndices(\"grid_indices\"), \";\\n      var x = gs_denormalize(f32(nxy[0]), W_in);\\n      var y = gs_denormalize(f32(nxy[1]), H_in);\\n\\n      \").concat(jf(a, d, t), \"\\n  }\");\n        return {\n            name: \"GridSample\",\n            shaderCache: {\n                hint: \"\".concat(t.cacheKey),\n                inputDependencies: [\n                    \"type\",\n                    \"type\"\n                ]\n            },\n            getRunData: (u)=>{\n                let h = C.size(i);\n                return {\n                    outputs: [\n                        {\n                            dims: i,\n                            dataType: u[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(h / 64)\n                    },\n                    programUniforms: p\n                };\n            },\n            getShaderSource: m\n        };\n    }, Md = (e1, t)=>{\n        Lf(e1.inputs), e1.compute(Yf(e1.inputs, t));\n    }, Rd = (e1)=>re({\n            alignCorners: e1.align_corners,\n            mode: e1.mode,\n            paddingMode: e1.padding_mode,\n            format: e1.format\n        });\n});\nvar Be, Xf, Vd, Nd, Jf, tr, Wd, So = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    Nr();\n    Fr();\n    ae();\n    dt();\n    Be = (e1, t)=>e1.length > t && e1[t].dims.length > 0 ? e1[t] : void 0, Xf = (e1, t)=>{\n        let r = e1[0], n = Be(e1, 1), o = Be(e1, 2), i = Be(e1, 3), a = Be(e1, 4), d = Be(e1, 5), l = Be(e1, 6), p = Be(e1, 7);\n        if (r.dims.length !== 3 && r.dims.length !== 5) throw new Error(\"Input query is expected to have 3 or 5 dimensions\");\n        let m = r.dims[0], u = r.dims[1], h = r.dims.length === 3 ? r.dims[2] : t.numHeads * r.dims[4], _ = u, y = 0, g = 0, x = Math.floor(h / t.numHeads);\n        if (l && p && C.size(l.dims) && C.size(p.dims)) {\n            if (l.dims.length !== 4) throw new Error('Input \"past_key\" is expected to have 4 dimensions');\n            if (l.dims[0] !== m || l.dims[1] !== t.numHeads || l.dims[3] !== x) throw new Error('Input \"past_key\" shape (batch_size, num_heads, past_sequence_length, head_size)');\n            if (p.dims[0] !== m || p.dims[1] !== t.numHeads || p.dims[3] !== x) throw new Error('Input \"past_value\" shape (batch_size, num_heads, past_sequence_length, head_size)');\n            if (l.dims[2] !== p.dims[2]) throw new Error('Input \"past_key\" and \"past_value\" shall have same dim 2 (past_sequence_length)');\n            if (p.dims.length !== 4) throw new Error('Input \"past_value\" is expected to have 4 dimensions');\n            y = l.dims[2], g = l.dims[2];\n        } else if (l && C.size(l.dims) || p && C.size(p.dims)) throw new Error('Input \"past_key\" and \"past_value\" shall be both present or both absent');\n        let $;\n        if (n && C.size(n.dims) > 0) {\n            if (r.dims.length !== 3) throw new Error('Input \"query\" is expected to have 3 dimensions when key is given');\n            if (n.dims.length < 3 || n.dims.length > 5) throw new Error('Input \"key\" is expected to have 3, 4, or 5 dimensions');\n            if (r.dims[0] !== n.dims[0]) throw new Error('Input \"query\" and \"key\" shall have same dim 0 (batch size)');\n            if (n.dims.length === 3) {\n                if (n.dims[2] !== r.dims[2]) throw new Error('Input \"query\" and \"key\" shall have same dim 2 (hidden_size)');\n                $ = 2, _ = n.dims[1];\n            } else if (n.dims.length === 5) {\n                if (n.dims[2] !== t.numHeads || n.dims[3] !== 2 || n.dims[4] !== x) throw new Error('Expect \"key\" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');\n                if (o) throw new Error('Expect \"value\" be none when \"key\" has packed kv format.');\n                $ = 5, _ = n.dims[1];\n            } else {\n                if (n.dims[1] !== t.numHeads || n.dims[3] !== x) throw new Error('Expect \"key\" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');\n                $ = 0, _ = n.dims[2];\n            }\n        } else {\n            if (r.dims.length !== 5) throw new Error('Input \"query\" is expected to have 5 dimensions when key is empty');\n            if (r.dims[2] !== t.numHeads || r.dims[3] !== 3) throw new Error('Expect \"query\" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');\n            $ = 3;\n        }\n        if (i && C.size(i.dims) > 0) {\n            if (i.dims.length !== 1) throw new Error('Input \"bias\" is expected to have 1 dimension');\n            if (n && n.dims.length === 5 && n.dims[3] === 2) throw new Error(\"bias is not allowed for packed kv.\");\n        }\n        let v = y + _, S = 0;\n        if (a && C.size(a.dims) > 0) {\n            S = 8;\n            let P = a.dims;\n            throw P.length === 1 ? P[0] === m ? S = 1 : P[0] === 3 * m + 2 && (S = 3) : P.length === 2 && P[0] === m && P[1] === v && (S = 5), S === 8 ? new Error('Input \"key_padding_mask\" shape shall be (batch_size) or (batch_size, total_sequence_length)') : new Error(\"Mask not supported\");\n        }\n        let T = !1, A = h;\n        if (o && C.size(o.dims) > 0) {\n            if (o.dims.length !== 3 && o.dims.length !== 4) throw new Error('Input \"value\" is expected to have 3 or 4 dimensions');\n            if (r.dims[0] !== o.dims[0]) throw new Error('Input \"query\" and \"value\" shall have same dim 0 (batch_size)');\n            if (o.dims.length === 3) {\n                if (_ !== o.dims[1]) throw new Error('Input \"key\" and \"value\" shall have the same dim 1 (kv_sequence_length)');\n                A = o.dims[2];\n            } else {\n                if (_ !== o.dims[2]) throw new Error('Input \"key\" and \"value\" shall have the same dim 2 (kv_sequence_length)');\n                A = o.dims[1] * o.dims[3], T = !0;\n            }\n        }\n        let k = !1;\n        if (a && C.size(a.dims) > 0) throw new Error(\"Key padding mask is not supported\");\n        if (d && C.size(d.dims) > 0) {\n            if (d.dims.length !== 4) throw new Error('Input \"attention_bias\" is expected to have 4 dimensions');\n            if (d.dims[0] !== m || d.dims[1] !== t.numHeads || d.dims[2] !== u || d.dims[3] !== v) throw new Error('Expect \"attention_bias\" shape (batch_size, num_heads, sequence_length, total_sequence_length)');\n        }\n        return {\n            batchSize: m,\n            sequenceLength: u,\n            pastSequenceLength: y,\n            kvSequenceLength: _,\n            totalSequenceLength: v,\n            maxSequenceLength: g,\n            inputHiddenSize: 0,\n            hiddenSize: h,\n            vHiddenSize: A,\n            headSize: x,\n            vHeadSize: Math.floor(A / t.numHeads),\n            numHeads: t.numHeads,\n            isUnidirectional: !1,\n            pastPresentShareBuffer: !1,\n            maskFilterValue: t.maskFilterValue,\n            maskType: S,\n            scale: t.scale,\n            broadcastResPosBias: k,\n            passPastInKv: T,\n            qkvFormat: $\n        };\n    }, Vd = (e1)=>re({\n            ...e1\n        }), Nd = re({\n        perm: [\n            0,\n            2,\n            1,\n            3\n        ]\n    }), Jf = (e1, t, r, n, o, i, a)=>{\n        let d = [\n            n,\n            o,\n            i\n        ], l = C.size(d), p = [\n            {\n                type: 12,\n                data: l\n            },\n            {\n                type: 12,\n                data: a\n            },\n            {\n                type: 12,\n                data: i\n            }\n        ], m = (u)=>{\n            let h = M(\"qkv_with_bias\", t.dataType, d), _ = E(\"qkv\", t.dataType, d), y = E(\"bias\", r.dataType, d), g = [\n                {\n                    name: \"output_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"bias_offset\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"hidden_size\",\n                    type: \"u32\"\n                }\n            ];\n            return \"\\n  \".concat(u.registerUniforms(g).declareVariables(_, y, h), \"\\n  \").concat(u.mainStart(), \"\\n    \").concat(u.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\"), \"\\n    let bias_offset_idx = (global_idx % uniforms.hidden_size) + uniforms.bias_offset;\\n\\n    qkv_with_bias[global_idx] = qkv[global_idx] + bias[bias_offset_idx];\\n  }\");\n        };\n        return e1.compute({\n            name: \"MultiHeadAttentionAddBias\",\n            shaderCache: {\n                inputDependencies: [\n                    \"type\",\n                    \"type\"\n                ]\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: d,\n                            dataType: t.dataType,\n                            gpuDataType: 0\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(l / 64)\n                    },\n                    programUniforms: p\n                }),\n            getShaderSource: m\n        }, {\n            inputs: [\n                t,\n                r\n            ],\n            outputs: [\n                -1\n            ]\n        })[0];\n    }, tr = (e1, t, r, n, o, i, a, d)=>{\n        let l = i;\n        if (a && C.size(a.dims) > 0) {\n            if (n === 1) throw new Error(\"AddBiasReshape is not implemented. Please export your model with packed QKV or KV\");\n            return l = Jf(e1, i, a, t, n, r * o, d), l = l.reshape([\n                t,\n                n,\n                r,\n                o\n            ]), r === 1 || n === 1 ? l : e1.compute(Pe(l, Nd.perm), {\n                inputs: [\n                    l\n                ],\n                outputs: [\n                    -1\n                ]\n            })[0];\n        } else return i.dims.length === 3 && (l = i.reshape([\n            t,\n            n,\n            r,\n            o\n        ])), r === 1 || n === 1 ? l : e1.compute(Pe(l, Nd.perm), {\n            inputs: [\n                l\n            ],\n            outputs: [\n                -1\n            ]\n        })[0];\n    }, Wd = (e1, t)=>{\n        let r = Xf(e1.inputs, t), n = e1.inputs[0], o = Be(e1.inputs, 1), i = Be(e1.inputs, 2), a = Be(e1.inputs, 3), d = Be(e1.inputs, 4), l = Be(e1.inputs, 5), p = Be(e1.inputs, 6), m = Be(e1.inputs, 7);\n        if (n.dims.length === 5) throw new Error(\"Packed QKV is not implemented\");\n        if ((o === null || o === void 0 ? void 0 : o.dims.length) === 5) throw new Error(\"Packed KV is not implemented\");\n        let u = o && i && o.dims.length === 4 && i.dims.length === 4, h = tr(e1, r.batchSize, r.numHeads, r.sequenceLength, r.headSize, n, a, 0);\n        if (u) return Rt(e1, h, o, i, d, void 0, p, m, l, r);\n        if (!o || !i) throw new Error(\"key and value must be provided\");\n        let _ = tr(e1, r.batchSize, r.numHeads, r.kvSequenceLength, r.headSize, o, a, r.hiddenSize), y = tr(e1, r.batchSize, r.numHeads, r.kvSequenceLength, r.vHeadSize, i, a, 2 * r.hiddenSize);\n        Rt(e1, h, _, y, d, void 0, p, m, l, r);\n    };\n});\nvar eh, th, rh, nh, To, Ld, Gd, Io = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    eh = (e1)=>{\n        if (!e1 || e1.length < 1) throw new Error(\"too few inputs\");\n    }, th = (e1, t)=>{\n        let r = [], n = t.numOutputs;\n        return e1[1].dims[0] > 0 && (e1[1].getBigInt64Array().forEach((o)=>r.push(Number(o))), n = r.length), re({\n            numOutputs: n,\n            axis: t.axis,\n            splitSizes: r\n        });\n    }, rh = (e1)=>\"\\nfn calculateOutputIndex(index: u32) -> u32 {\\n    for (var i: u32 = 0u; i < \".concat(e1, \"u; i += 1u ) {\\n    if (index < \").concat(F(\"uniforms.size_in_split_axis\", \"i\", e1), \") {\\n        return i;\\n    }\\n    }\\n    return \").concat(e1, \"u;\\n}\"), nh = (e1)=>{\n        let t = e1.length, r = [];\n        for(let n = 0; n < t; ++n){\n            let o = e1[n].setByIndices(\"indices\", \"input[global_idx]\");\n            t === 1 ? r.push(o) : n === 0 ? r.push(\"if (output_number == \".concat(n, \"u) { \").concat(o, \" }\")) : n === t - 1 ? r.push(\"else { \".concat(o, \" }\")) : r.push(\"else if (output_number == \".concat(n, \") { \").concat(o, \" }\"));\n        }\n        return \"\\n      fn writeBufferData(output_number: u32, indices: \".concat(e1[0].type.indices, \", global_idx: u32) {\\n        \").concat(r.join(\"\\n\"), \"\\n      }\");\n    }, To = (e1, t)=>{\n        let r = e1[0].dims, n = C.size(r), o = e1[0].dataType, i = C.normalizeAxis(t.axis, r.length), a = new Array(t.numOutputs), d = E(\"input\", o, r.length), l = new Array(t.numOutputs), p = [], m = [], u = 0, h = [\n            {\n                type: 12,\n                data: n\n            }\n        ];\n        for(let y = 0; y < t.numOutputs; y++){\n            u += t.splitSizes[y], l[y] = u;\n            let g = r.slice();\n            g[i] = t.splitSizes[y], m.push(g), a[y] = M(\"output\".concat(y), o, g.length), p.push({\n                dims: m[y],\n                dataType: e1[0].dataType\n            });\n        }\n        h.push({\n            type: 12,\n            data: l\n        }, ...N(r, ...m));\n        let _ = (y)=>\"\\n  \".concat(y.registerUniform(\"input_size\", \"u32\").registerUniform(\"size_in_split_axis\", \"u32\", l.length).declareVariables(d, ...a), \"\\n  \").concat(rh(l.length), \"\\n  \").concat(nh(a), \"\\n\\n  \").concat(y.mainStart(), \"\\n    \").concat(y.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.input_size\"), \"\\n\\n    var indices = \").concat(d.offsetToIndices(\"global_idx\"), \";\\n    var index = \").concat(d.indicesGet(\"indices\", i), \";\\n    let output_number = calculateOutputIndex(index);\\n    if (output_number != 0) {\\n      index -= \").concat(F(\"uniforms.size_in_split_axis\", \"output_number - 1u\", l.length), \";\\n      \").concat(d.indicesSet(\"indices\", i, \"index\"), \";\\n    }\\n    writeBufferData(output_number, indices, global_idx);\\n  }\");\n        return {\n            name: \"Split\",\n            shaderCache: {\n                hint: t.cacheKey,\n                inputDependencies: [\n                    \"rank\"\n                ]\n            },\n            getShaderSource: _,\n            getRunData: ()=>({\n                    outputs: p,\n                    dispatchGroup: {\n                        x: Math.ceil(n / 64)\n                    },\n                    programUniforms: h\n                })\n        };\n    }, Ld = (e1, t)=>{\n        eh(e1.inputs);\n        let r = e1.inputs.length === 1 ? t : th(e1.inputs, t);\n        e1.compute(To(e1.inputs, r), {\n            inputs: [\n                0\n            ]\n        });\n    }, Gd = (e1)=>{\n        let t = e1.axis, r = e1.splitSizes, n = e1.numOutputs < 0 ? r.length : e1.numOutputs;\n        if (n !== r.length) throw new Error(\"numOutputs and splitSizes lengh must be equal\");\n        return re({\n            axis: t,\n            numOutputs: n,\n            splitSizes: r\n        });\n    };\n});\nvar oh, ih, Hd, Fd, qd = U(()=>{\n    \"use strict\";\n    Se();\n    Fr();\n    So();\n    Io();\n    dt();\n    oh = (e1, t)=>{\n        if (t.doRotary) throw new Error(\"GroupQuerryAttention do_rotary attribute is not supported\");\n        if (t.doRotary && e1.length <= 7) throw new Error(\"cos_cache and sin_cache inputs are required if do_rotary is specified\");\n        let r = e1[0], n = e1[1], o = e1[2], i = e1[3], a = e1[4];\n        if (t.localWindowSize !== -1) throw new Error(\"Local attention is not supported\");\n        if (t.softcap !== 0) throw new Error(\"Softcap is not supported\");\n        if (t.rotaryInterleaved !== 0) throw new Error(\"Rotary interleaved is not supported\");\n        if (t.smoothSoftmax) throw new Error(\"Smooth softmax is not supported\");\n        if (r.dims.length !== 3 && r.dims.length !== 5) throw new Error(\"Input query is expected to have 3 or 5 dimensions\");\n        let d = !1, l = r.dims[0], p = r.dims[1], m = r.dims.length === 3 ? d ? r.dims[2] / 3 : r.dims[2] : t.numHeads * r.dims[4], u = p, h = 0, _ = !n || n.dims.length === 0, y = Math.floor(_ ? m / (t.numHeads + 2 * t.kvNumHeads) : m / t.numHeads);\n        _ && (m = y * t.numHeads);\n        let g = i && i.dims.length !== 0, x = a && a.dims.length !== 0;\n        if (g && i.dims.length === 4 && i.dims[0] === l && i.dims[1] !== t.kvNumHeads && i.dims[2] === t.kvNumHeads && i.dims[3] === y) throw new Error(\"BSNH pastKey/pastValue is not supported\");\n        if (g && x) {\n            if (i.dims.length !== 4) throw new Error('Input \"past_key\" is expected to have 4 dimensions');\n            if (a.dims.length !== 4) throw new Error('Input \"past_value\" is expected to have 4 dimensions');\n            h = i.dims[2];\n        } else if (g || x) throw new Error('Input \"past_key\" and \"past_value\" shall be both present or both absent');\n        let v = 1;\n        if (n && n.dims.length > 0) {\n            if (r.dims.length !== 3) throw new Error('Input \"query\" is expected to have 3 dimensions when key is given');\n            if (n.dims.length < 3 || n.dims.length > 5) throw new Error('Input \"key\" is expected to have 3, 4, or 5 dimensions');\n            if (r.dims[0] !== n.dims[0]) throw new Error('Input \"query\" and \"key\" shall have same dim 0 (batch size)');\n            if (n.dims.length === 3) {\n                if (r.dims[2] % n.dims[2] !== 0) throw new Error('Dimension 2 of \"query\" should be a multiple of \"key\"');\n                u = n.dims[1];\n            } else if (n.dims.length === 5) {\n                if (n.dims[2] !== t.numHeads || n.dims[3] !== 2 || n.dims[4] !== y) throw new Error('Expect \"key\" shape (batch_size, kv_sequence_length, num_heads, 2, head_size) for packed kv');\n                if (o) throw new Error('Expect \"value\" be none when \"key\" has packed kv format.');\n                u = n.dims[1];\n            } else {\n                if (n.dims[1] !== t.numHeads || n.dims[3] !== y) throw new Error('Expect \"key\" shape (batch_size, num_heads, kv_sequence_length, head_size) for past_key');\n                u = n.dims[2];\n            }\n        } else {\n            if (r.dims.length !== 3 && r.dims.length !== 5) throw new Error('Input \"query\" is expected to have 3 or 5 dimensions when key is empty');\n            if (r.dims.length === 5 && (r.dims[2] !== t.numHeads || r.dims[3] !== 3)) throw new Error('Expect \"query\" shape (batch_size, kv_sequence_length, num_heads, 3, head_size) for packed kv');\n            v = 3;\n        }\n        let S = 0, T = !1, A = t.kvNumHeads ? y * t.kvNumHeads : m;\n        if (o && o.dims.length > 0) {\n            if (o.dims.length !== 3 && o.dims.length !== 4) throw new Error('Input \"value\" is expected to have 3 or 4 dimensions');\n            if (r.dims[0] !== o.dims[0]) throw new Error('Input \"query\" and \"value\" shall have same dim 0 (batch_size)');\n            if (o.dims.length === 3) {\n                if (u !== o.dims[1]) throw new Error('Input \"key\" and \"value\" shall have the same dim 1 (kv_sequence_length)');\n                A = o.dims[2];\n            } else {\n                if (u !== o.dims[2]) throw new Error('Input \"past_key\" and \"past_value\" shall have the same dim 2 (kv_sequence_length)');\n                A = o.dims[1] * o.dims[3], T = !0;\n            }\n        }\n        let k = e1.length > 4 ? e1[5] : void 0;\n        if (k && k.dims.length !== 1 && k.dims[0] !== l) throw new Error('Input \"seqlens\" is expected to have 1 dimension and the same dim 0 as batch_size');\n        let P = -1, D = -1, R = !1;\n        return {\n            batchSize: l,\n            sequenceLength: p,\n            pastSequenceLength: h,\n            kvSequenceLength: u,\n            totalSequenceLength: P,\n            maxSequenceLength: D,\n            inputHiddenSize: 0,\n            hiddenSize: m,\n            vHiddenSize: A,\n            headSize: y,\n            vHeadSize: Math.floor(A / t.kvNumHeads),\n            numHeads: t.numHeads,\n            kvNumHeads: t.kvNumHeads,\n            nReps: t.numHeads / t.kvNumHeads,\n            pastPresentShareBuffer: !1,\n            maskType: S,\n            scale: t.scale,\n            broadcastResPosBias: R,\n            passPastInKv: T,\n            qkvFormat: v\n        };\n    }, ih = re({\n        perm: [\n            0,\n            2,\n            1,\n            3\n        ]\n    }), Hd = (e1, t, r)=>{\n        let n = t, o = r.kvNumHeads;\n        return t.dims.length === 3 && r.kvSequenceLength !== 0 && (n = t.reshape([\n            r.batchSize,\n            r.kvSequenceLength,\n            o,\n            r.headSize\n        ]), n = e1.compute(Pe(n, ih.perm), {\n            inputs: [\n                n\n            ],\n            outputs: [\n                -1\n            ]\n        })[0]), n;\n    }, Fd = (e1, t)=>{\n        var _e_inputs_;\n        let r = oh(e1.inputs, t);\n        if (e1.inputs[0].dims.length === 5) throw new Error(\"Packed QKV is not implemented\");\n        if (((_e_inputs_ = e1.inputs[1]) === null || _e_inputs_ === void 0 ? void 0 : _e_inputs_.dims.length) === 5) throw new Error(\"Packed KV is not implemented\");\n        let n = e1.inputs[0], o = e1.inputs[1] && e1.inputs[1].dims.length > 0 ? e1.inputs[1] : void 0, i = e1.inputs[2] && e1.inputs[2].dims.length > 0 ? e1.inputs[2] : void 0, a = e1.inputs[3] && e1.inputs[3].dims.length !== 0 ? e1.inputs[3] : void 0, d = e1.inputs[4] && e1.inputs[4].dims.length !== 0 ? e1.inputs[4] : void 0, l = e1.inputs.length > 4 ? e1.inputs[5] : void 0, p = e1.inputs.length > 5 ? e1.inputs[6] : void 0, m = r.kvNumHeads ? r.kvNumHeads : r.numHeads, u = re({\n            axis: 2,\n            numOutputs: 3,\n            splitSizes: [\n                r.numHeads * r.headSize,\n                m * r.headSize,\n                m * r.headSize\n            ]\n        }), [h, _, y] = !o && !i ? e1.compute(To([\n            n\n        ], u), {\n            inputs: [\n                n\n            ],\n            outputs: [\n                -1,\n                -1,\n                -1\n            ]\n        }) : [\n            n,\n            o,\n            i\n        ], g = tr(e1, r.batchSize, r.numHeads, r.sequenceLength, r.headSize, h, void 0, 0);\n        Rt(e1, g, Hd(e1, _, r), Hd(e1, y, r), void 0, void 0, a, d, void 0, r, l, p);\n    };\n});\nvar Kd, ah, sh, jd, Yd = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    dt();\n    ae();\n    Kd = (e1, t, r, n, o, i, a, d)=>{\n        let l = me(i), p = l === 1 ? \"f32\" : \"vec\".concat(l, \"f\"), m = l === 1 ? \"vec2f\" : \"mat2x\".concat(l, \"f\"), u = o * a, h = 64;\n        u === 1 && (h = 256);\n        let _ = [\n            o,\n            a,\n            i / l\n        ], y = [\n            o,\n            a,\n            2\n        ], g = [\n            \"rank\",\n            \"type\",\n            \"type\"\n        ], x = [];\n        x.push(...N(_, y));\n        let $ = (v)=>{\n            let S = E(\"x\", t.dataType, 3, l), T = E(\"scale\", r.dataType, r.dims), A = E(\"bias\", n.dataType, n.dims), k = M(\"output\", 1, 3, 2), P = [\n                S,\n                T,\n                A,\n                k\n            ];\n            return \"\\n  var<workgroup> workgroup_shared : array<\".concat(m, \", \").concat(h, \">;\\n  const workgroup_size = \").concat(h, \"u;\\n  \").concat(v.declareVariables(...P), \"\\n  \").concat(v.mainStart(h), \"\\n    let batch = workgroup_index / uniforms.x_shape[1];\\n    let channel = workgroup_index % uniforms.x_shape[1];\\n    let hight = uniforms.x_shape[2];\\n    // initialize workgroup memory\\n    var sum = \").concat(p, \"(0);\\n    var squared_sum = \").concat(p, \"(0);\\n    for (var h = local_idx; h < hight; h += workgroup_size) {\\n      let value = \").concat(p, \"(\").concat(S.get(\"batch\", \"channel\", \"h\"), \");\\n      sum += value;\\n      squared_sum += value * value;\\n    }\\n    workgroup_shared[local_idx] = \").concat(m, \"(sum, squared_sum);\\n    workgroupBarrier();\\n\\n    for (var currSize = workgroup_size >> 1;  currSize > 0; currSize = currSize >> 1) {\\n      if (local_idx < currSize) {\\n        workgroup_shared[local_idx] = workgroup_shared[local_idx] + workgroup_shared[local_idx + currSize];\\n      }\\n      workgroupBarrier();\\n    }\\n    if (local_idx == 0) {\\n      let sum_final = \").concat(Fe(\"workgroup_shared[0][0]\", l), \" / f32(hight * \").concat(l, \");\\n      let squared_sum_final = \").concat(Fe(\"workgroup_shared[0][1]\", l), \" / f32(hight * \").concat(l, \");\\n\\n      let inv_std_dev = inverseSqrt(squared_sum_final - sum_final * sum_final + f32(\").concat(d, \"));\\n      let channel_scale = inv_std_dev * f32(scale[channel]);\\n      let channel_shift = f32(bias[channel]) - sum_final * channel_scale;\\n      output[workgroup_index] = vec2f(channel_scale, channel_shift);\\n    }\\n  }\");\n        };\n        return e1.compute({\n            name: \"InstanceNormComputeChannelScaleShift\",\n            shaderCache: {\n                hint: \"\".concat(l, \";\").concat(d, \";\").concat(h),\n                inputDependencies: g\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: y,\n                            dataType: 1\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: u\n                    },\n                    programUniforms: x\n                }),\n            getShaderSource: $\n        }, {\n            inputs: [\n                t,\n                r,\n                n\n            ],\n            outputs: [\n                -1\n            ]\n        })[0];\n    }, ah = (e1, t, r)=>{\n        let n = t[0].dims, o = n, i = 2, a = n[0], d = n[1], l = C.sizeFromDimension(n, i), p = me(l), m = C.size(o) / p, u = Kd(e1, t[0], t[1], t[2], a, l, d, r.epsilon), h = [\n            a,\n            d,\n            l / p\n        ], _ = [\n            a,\n            d\n        ], y = [\n            \"type\",\n            \"none\"\n        ], g = (x)=>{\n            let $ = E(\"x\", t[0].dataType, h.length, p), v = E(\"scale_shift\", 1, _.length, 2), S = M(\"output\", t[0].dataType, h.length, p), T = [\n                $,\n                v,\n                S\n            ];\n            return \"\\n  \".concat(x.registerUniform(\"output_size\", \"u32\").declareVariables(...T), \"\\n  \").concat(x.mainStart(), \"\\n  \").concat(x.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\"), \"\\n      let outputIndices = \").concat(S.offsetToIndices(\"global_idx\"), \";\\n      let batch = outputIndices[0];\\n      let channel = outputIndices[1];\\n      let scale_shift = \").concat(v.getByIndices(\"vec2<u32>(batch, channel)\"), \";\\n      let value = \").concat($.getByOffset(\"global_idx\"), \" * \").concat(S.type.value, \"(scale_shift.x) + \").concat(S.type.value, \"(scale_shift.y);\\n      \").concat(S.setByOffset(\"global_idx\", \"value\"), \";\\n  }\");\n        };\n        e1.compute({\n            name: \"InstanceNormalization\",\n            shaderCache: {\n                hint: \"\".concat(p),\n                inputDependencies: y\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: o,\n                            dataType: t[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(m / 64)\n                    },\n                    programUniforms: [\n                        {\n                            type: 12,\n                            data: m\n                        },\n                        ...N(h, _, h)\n                    ]\n                }),\n            getShaderSource: g\n        }, {\n            inputs: [\n                t[0],\n                u\n            ]\n        });\n    }, sh = (e1, t, r)=>{\n        let n = t[0].dims, o = n, i = n[0], a = n[n.length - 1], d = C.sizeFromDimension(n, 1) / a, l = me(a), p = C.size(o) / l, m = [\n            {\n                type: 12,\n                data: d\n            },\n            {\n                type: 12,\n                data: Math.floor(a / l)\n            }\n        ], u = [\n            \"type\",\n            \"type\"\n        ], h = !1, _ = [\n            0,\n            n.length - 1\n        ];\n        for(let $ = 0; $ < n.length - 2; $++)h = h || n[$ + 1] !== 1, _.push($ + 1);\n        h = h && n[n.length - 1] !== 1;\n        let y = h ? e1.compute(Pe(e1.inputs[0], _), {\n            inputs: [\n                e1.inputs[0]\n            ],\n            outputs: [\n                -1\n            ]\n        })[0] : e1.inputs[0].reshape(Array.from({\n            length: n.length\n        }, ($, v)=>n[_[v]])), g = Kd(e1, y, t[1], t[2], i, d, a, r.epsilon), x = ($)=>{\n            let v = _e(t[0].dataType), S = l === 1 ? \"vec2f\" : \"mat\".concat(l, \"x2f\"), T = (P)=>{\n                let D = P === 0 ? \"x\" : \"y\", R = l === 1 ? \"f32\" : \"vec\".concat(l, \"f\");\n                switch(l){\n                    case 1:\n                        return \"\".concat(v, \"(\").concat(R, \"(scale.\").concat(D, \"))\");\n                    case 2:\n                        return \"vec2<\".concat(v, \">(\").concat(R, \"(scale[0].\").concat(D, \", scale[1].\").concat(D, \"))\");\n                    case 4:\n                        return \"vec4<\".concat(v, \">(\").concat(R, \"(scale[0].\").concat(D, \", scale[1].\").concat(D, \", scale[2].\").concat(D, \", scale[3].\").concat(D, \"))\");\n                    default:\n                        throw new Error(\"Not supported compoents \".concat(l));\n                }\n            }, A = E(\"input\", t[0].dataType, t[0].dims, l), k = M(\"output\", t[0].dataType, o, l);\n            return \"\\n  @group(0) @binding(0) var<storage, read> input : array<\".concat(A.type.storage, \">;\\n  @group(0) @binding(1) var<storage, read> scale_input : array<\").concat(S, \">;\\n  @group(0) @binding(2) var<storage, read_write> output : array<\").concat(k.type.storage, \">;\\n  struct Uniforms {H: u32, C : u32};\\n  @group(0) @binding(3) var<uniform> uniforms: Uniforms;\\n\\n  \").concat($.mainStart(), \"\\n    let current_image_number = global_idx / (uniforms.C * uniforms.H);\\n    let current_channel_number = global_idx % uniforms.C;\\n\\n    let scale_offset = current_image_number * uniforms.C + current_channel_number;\\n    let scale = scale_input[scale_offset];\\n    output[global_idx] = fma(input[global_idx], \").concat(T(0), \", \").concat(T(1), \");\\n  }\");\n        };\n        e1.compute({\n            name: \"InstanceNormalizationNHWC\",\n            shaderCache: {\n                hint: \"\".concat(l),\n                inputDependencies: u\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: o,\n                            dataType: t[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(p / 64)\n                    },\n                    programUniforms: m\n                }),\n            getShaderSource: x\n        }, {\n            inputs: [\n                t[0],\n                g\n            ]\n        });\n    }, jd = (e1, t)=>{\n        t.format === \"NHWC\" ? sh(e1, e1.inputs, t) : ah(e1, e1.inputs, t);\n    };\n});\nvar uh, dh, Zd, Qd = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    ae();\n    uh = (e1)=>{\n        if (!e1 || e1.length < 2) throw new Error(\"layerNorm requires at least 2 inputs.\");\n    }, dh = (e1, t, r)=>{\n        let n = t.simplified, o = e1[0].dims, i = e1[1], a = !n && e1[2], d = o, l = C.normalizeAxis(t.axis, o.length), p = C.sizeToDimension(o, l), m = C.sizeFromDimension(o, l), u = C.size(i.dims), h = a ? C.size(a.dims) : 0;\n        if (u !== m || a && h !== m) throw new Error(\"Size of X.shape()[axis:] == \".concat(m, \".\\n       Size of scale and bias (if provided) must match this.\\n       Got scale size of \").concat(u, \" and bias size of \").concat(h));\n        let _ = [];\n        for(let A = 0; A < o.length; ++A)A < l ? _.push(o[A]) : _.push(1);\n        let y = me(m), g = [\n            \"type\",\n            \"type\"\n        ], x = [\n            {\n                type: 12,\n                data: p\n            },\n            {\n                type: 1,\n                data: m\n            },\n            {\n                type: 12,\n                data: Math.floor(m / y)\n            },\n            {\n                type: 1,\n                data: t.epsilon\n            }\n        ];\n        a && g.push(\"type\");\n        let $ = r > 1, v = r > 2, S = (A)=>{\n            let k = _e(e1[0].dataType), P = [\n                E(\"x\", e1[0].dataType, e1[0].dims, y),\n                E(\"scale\", i.dataType, i.dims, y)\n            ];\n            a && P.push(E(\"bias\", a.dataType, a.dims, y)), P.push(M(\"output\", e1[0].dataType, d, y)), $ && P.push(M(\"mean_data_output\", 1, _)), v && P.push(M(\"inv_std_output\", 1, _));\n            let D = [\n                {\n                    name: \"norm_count\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"norm_size\",\n                    type: \"f32\"\n                },\n                {\n                    name: \"norm_size_vectorized\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"epsilon\",\n                    type: \"f32\"\n                }\n            ];\n            return \"\\n  \".concat(A.registerUniforms(D).declareVariables(...P), \"\\n  \").concat(A.mainStart(), \"\\n    \").concat(A.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.norm_count\"), \"\\n    let offset = global_idx * uniforms.norm_size_vectorized;\\n    var mean_vector = \").concat(uo(\"f32\", y), \";\\n    var mean_square_vector = \").concat(uo(\"f32\", y), \";\\n\\n    for (var h: u32 = 0u; h < uniforms.norm_size_vectorized; h++) {\\n      let value = \").concat(Et(k, y, \"x[h + offset]\"), \";\\n      mean_vector += value;\\n      mean_square_vector += value * value;\\n    }\\n    let mean = \").concat(Fe(\"mean_vector\", y), \" / uniforms.norm_size;\\n    let inv_std_dev = inverseSqrt(\").concat(Fe(\"mean_square_vector\", y), \" / uniforms.norm_size \").concat(n ? \"\" : \"- mean * mean\", \" + uniforms.epsilon);\\n\\n    for (var j: u32 = 0; j < uniforms.norm_size_vectorized; j++) {\\n      let f32input = \").concat(Et(k, y, \"x[j + offset]\"), \";\\n      let f32scale = \").concat(Et(k, y, \"scale[j]\"), \";\\n      output[j + offset] = \").concat(P[0].type.value, \"((f32input \").concat(n ? \"\" : \"- mean\", \") * inv_std_dev * f32scale\\n        \").concat(a ? \"+ \".concat(Et(k, y, \"bias[j]\")) : \"\", \"\\n      );\\n    }\\n\\n    \").concat($ ? \"mean_data_output[global_idx] = mean\" : \"\", \";\\n    \").concat(v ? \"inv_std_output[global_idx] = inv_std_dev\" : \"\", \";\\n  }\");\n        }, T = [\n            {\n                dims: d,\n                dataType: e1[0].dataType\n            }\n        ];\n        return $ && T.push({\n            dims: _,\n            dataType: 1\n        }), v && T.push({\n            dims: _,\n            dataType: 1\n        }), {\n            name: \"LayerNormalization\",\n            shaderCache: {\n                hint: \"\".concat(y, \";\").concat(r, \";\").concat(n),\n                inputDependencies: g\n            },\n            getRunData: ()=>({\n                    outputs: T,\n                    dispatchGroup: {\n                        x: Math.ceil(p / 64)\n                    },\n                    programUniforms: x\n                }),\n            getShaderSource: S\n        };\n    }, Zd = (e1, t)=>{\n        uh(e1.inputs), e1.compute(dh(e1.inputs, t, e1.outputCount));\n    };\n});\nvar lh, Xd, Jd = U(()=>{\n    \"use strict\";\n    oe();\n    Qr();\n    Xr();\n    lh = (e1)=>{\n        if (!e1 || e1.length !== 2) throw new Error(\"MatMul requires 2 inputs.\");\n        if (e1[0].dims[e1[0].dims.length - 1] !== e1[1].dims[e1[1].dims.length - 2]) throw new Error(\"shared dimension does not match.\");\n    }, Xd = (e1)=>{\n        lh(e1.inputs);\n        let t = tt.calcShape(e1.inputs[0].dims, e1.inputs[1].dims, !0);\n        if (!t) throw new Error(\"Can't use matmul on the given tensors\");\n        let r = t[t.length - 1], n = e1.inputs[0].dims[e1.inputs[0].dims.length - 1];\n        if (r < 8 && n < 8) e1.compute(Zr(e1.inputs, {\n            activation: \"\"\n        }, t));\n        else {\n            let o = t[t.length - 2], i = C.size(e1.inputs[0].dims.slice(0, -2)), a = C.size(e1.inputs[1].dims.slice(0, -2));\n            if (i !== 1 && o === 1 && a === 1) {\n                let d = e1.inputs[0].reshape([\n                    1,\n                    i,\n                    n\n                ]), l = e1.inputs[1].reshape([\n                    1,\n                    n,\n                    r\n                ]), p = [\n                    1,\n                    i,\n                    r\n                ], m = [\n                    d,\n                    l\n                ];\n                e1.compute(er(m, {\n                    activation: \"\"\n                }, t, p), {\n                    inputs: m\n                });\n            } else e1.compute(er(e1.inputs, {\n                activation: \"\"\n            }, t));\n        }\n    };\n});\nvar ch, ph, mh, el, tl, rl = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    ch = (e1, t)=>{\n        if (e1.length < 3 || e1.length > 4) throw new Error(\"MatMulNBits requires 3 or 4 inputs\");\n        let r = e1[0], n = r.dims.length;\n        if (r.dims[n - 1] !== t.k) throw new Error(\"The last dim of input shape does not match the k value\");\n        let o = Math.floor((t.k + t.blockSize - 1) / t.blockSize), i = t.blockSize / 8 * t.bits, a = e1[1];\n        if (!C.areEqual(a.dims, [\n            t.n,\n            o,\n            i\n        ])) throw new Error(\"The second inputs must be 3D tensor with shape N X nBlocksPerCol X blobSize\");\n        let l = e1[2].dims;\n        if (C.size(l) !== t.n * o) throw new Error(\"scales input size error.\");\n        if (e1.length === 4) {\n            let m = e1[3].dims, u = t.bits > 4 ? t.n * o : t.n * Math.floor((o + 1) / 2);\n            if (C.size(m) !== u) throw new Error(\"zeroPoints input size error.\");\n        }\n    }, ph = (e1, t)=>{\n        let r = e1[0].dims, n = r.length, o = r[n - 2], i = t.k, a = t.n, d = r.slice(0, n - 2), l = C.size(d), m = e1[1].dims[2] / 4, u = e1[0].dataType, h = me(t.k), _ = me(m), y = me(a), g = d.concat([\n            o,\n            a\n        ]), x = o > 1 && a / y % 2 === 0 ? 2 : 1, $ = C.size(g) / y / x, v = 64, S = [], T = [\n            l,\n            o,\n            i / h\n        ], A = C.convertShape(e1[1].dims).slice();\n        A.splice(-1, 1, m / _), S.push(...N(T)), S.push(...N(A)), S.push(...N(e1[2].dims)), e1.length === 4 && S.push(...N(C.convertShape(e1[3].dims)));\n        let k = [\n            l,\n            o,\n            a / y\n        ];\n        S.push(...N(k));\n        let P = (D)=>{\n            let R = T.length, G = E(\"a\", e1[0].dataType, R, h), K = E(\"b\", 12, A.length, _), j = E(\"scales\", e1[2].dataType, e1[2].dims.length), V = [\n                G,\n                K,\n                j\n            ], Q = e1.length === 4 ? E(\"zero_points\", 12, e1[3].dims.length) : void 0;\n            Q && V.push(Q);\n            let se = k.length, Y = M(\"output\", e1[0].dataType, se, y), ee = _e(e1[0].dataType), J = (()=>{\n                switch(h){\n                    case 1:\n                        return \"array<\".concat(ee, \", 8>\");\n                    case 2:\n                        return \"mat4x2<\".concat(ee, \">\");\n                    case 4:\n                        return \"mat2x4<\".concat(ee, \">\");\n                    default:\n                        throw new Error(\"\".concat(h, \"-component is not supported.\"));\n                }\n            })(), ne = ()=>{\n                let $e = \"\\n          // reuse a data\\n            var input_offset = \".concat(G.indicesToOffset(\"\".concat(G.type.indices, \"(batch, row, word_offset)\")), \";\\n            var a_data: \").concat(J, \";\\n            for (var j: u32 = 0; j < \").concat(8 / h, \"; j++) {\\n              a_data[j] = \").concat(G.getByOffset(\"input_offset\"), \";\\n              input_offset++;\\n            }\\n          \");\n                for(let le = 0; le < y * x; le++)$e += \"\\n            b_value = \".concat(_ === 1 ? \"b\".concat(le, \"_data\") : \"b\".concat(le, \"_data[i]\"), \";\\n            b_value_lower = unpack4xU8(b_value & b_mask);\\n            b_value_upper = unpack4xU8((b_value >> 4) & b_mask);\\n            b_quantized_values = \").concat(J, \"(\").concat(Array.from({\n                    length: 4\n                }, (W, q)=>\"\".concat(ee, \"(b_value_lower[\").concat(q, \"]), \").concat(ee, \"(b_value_upper[\").concat(q, \"])\")).join(\", \"), \");\\n            b_dequantized_values = \").concat((()=>h === 1 ? \"\".concat(J, \"(\").concat(Array.from({\n                        length: 8\n                    }, (W, q)=>\"(b_quantized_values[\".concat(q, \"] - \").concat(Q ? \"zero_point\".concat(le) : \"zero_point\", \") * scale\").concat(le)).join(\", \"), \");\") : \"(b_quantized_values - \".concat(J, \"(\").concat(Array(8).fill(\"\".concat(Q ? \"zero_point\".concat(le) : \"zero_point\")).join(\",\"), \")) * scale\").concat(le, \";\"))(), \";\\n            workgroup_shared[local_id.x * \").concat(x, \" + \").concat(Math.floor(le / y), \"]\").concat(y > 1 ? \"[\".concat(le % y, \"]\") : \"\", \" += \").concat(Array.from({\n                    length: 8 / h\n                }, (W, q)=>\"\".concat(h === 1 ? \"a_data[\".concat(q, \"] * b_dequantized_values[\").concat(q, \"]\") : \"dot(a_data[\".concat(q, \"], b_dequantized_values[\").concat(q, \"])\"))).join(\" + \"), \";\\n          \");\n                return $e;\n            }, be = ()=>{\n                let $e = \"\\n            var col_index = col * \".concat(y, \";\\n            \").concat(Q ? \"\\n            let zero_point_bytes_per_col = (nBlocksPerCol + 1) / 2;\\n            var zero_point_byte_count: u32;\\n            var zero_point_word_index: u32;\\n            var zero_point_byte_offset: u32;\\n            let zero_point_nibble_offset: u32 = block & 0x1u;\\n            var zero_point_bits_offset: u32;\\n            var zero_point_word: u32;\" : \"\\n            // The default zero point is 8 for unsigned 4-bit quantization.\\n            let zero_point = \".concat(ee, \"(8);\"), \"\\n            \");\n                for(let le = 0; le < y * x; le++)$e += \"\\n            let scale\".concat(le, \" = \").concat(j.getByOffset(\"col_index * nBlocksPerCol + block\"), \";\\n            \").concat(Q ? \"\\n            zero_point_byte_count = col_index * zero_point_bytes_per_col + (block >> 0x1u);\\n            zero_point_word_index = zero_point_byte_count >> 0x2u;\\n            zero_point_byte_offset = zero_point_byte_count & 0x3u;\\n            zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);\\n            zero_point_word = \".concat(Q.getByOffset(\"zero_point_word_index\"), \" >> zero_point_bits_offset;\\n            let zero_point\").concat(le, \" = \").concat(ee, \"((zero_point_word) & 0xFu);\") : \"\", \"\\n            col_index += 1;\");\n                return $e;\n            }, Oe = ()=>{\n                let $e = \"col_index = col * \".concat(y, \";\");\n                for(let le = 0; le < y * x; le++)$e += \"\\n            let b\".concat(le, \"_data = \").concat(K.getByIndices(\"\".concat(K.type.indices, \"(col_index, block, word)\")), \";\\n            col_index += 1;\");\n                return $e += \"\\n            var b_value: u32;\\n            let b_mask: u32 = 0x0F0F0F0Fu;\\n            var b_value_lower: vec4<u32>;\\n            var b_value_upper: vec4<u32>;\\n            var b_quantized_values: \".concat(J, \";\\n            var b_dequantized_values: \").concat(J, \";\"), $e;\n            };\n            return \"\\n        var<workgroup> workgroup_shared: array<\".concat(Y.type.value, \", \").concat(x * v, \">;\\n        \").concat(D.declareVariables(...V, Y), \"\\n        \").concat(D.mainStart([\n                v,\n                1,\n                1\n            ]), \"\\n          let output_indices = \").concat(Y.offsetToIndices(\"(global_idx / \".concat(v, \") * \").concat(x)), \";\\n          let col = output_indices[2];\\n          let row = output_indices[1];\\n          let batch = output_indices[0];\\n          let nBlocksPerCol = uniforms.b_shape[1];\\n\\n          for (var block = local_id.x; block < nBlocksPerCol; block += \").concat(v, \") {\\n            //process one block\\n            var word_offset: u32 = block * \").concat(t.blockSize / h, \";\\n            \").concat(be(), \"\\n            for (var word: u32 = 0; word < \").concat(m, \"; word += \").concat(_, \") {\\n              \").concat(Oe(), \"\\n              for (var i: u32 = 0; i < \").concat(_, \"; i++) {\\n                \").concat(ne(), \"\\n                word_offset += \").concat(8 / h, \";\\n              }\\n            }\\n          }\\n          workgroupBarrier();\\n\\n          if (local_id.x < \").concat(x, \") {\\n            var output_value: \").concat(Y.type.value, \" = \").concat(Y.type.value, \"(0);\\n            var workgroup_shared_offset: u32 = local_id.x;\\n            for (var b: u32 = 0u; b < \").concat(v, \"u; b++) {\\n              output_value += workgroup_shared[workgroup_shared_offset];\\n              workgroup_shared_offset += \").concat(x, \";\\n            }\\n            \").concat(Y.setByIndices(\"\".concat(Y.type.indices, \"(batch, row, col + local_id.x)\"), \"output_value\"), \";\\n          }\\n        }\");\n        };\n        return {\n            name: \"MatMulNBits\",\n            shaderCache: {\n                hint: \"\".concat(t.blockSize, \";\").concat(t.bits, \";\").concat(h, \";\").concat(_, \";\").concat(y, \";\").concat(x, \";\").concat(v),\n                inputDependencies: Array(e1.length).fill(\"rank\")\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: g,\n                            dataType: u\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: $\n                    },\n                    programUniforms: S\n                }),\n            getShaderSource: P\n        };\n    }, mh = (e1, t)=>{\n        let r = e1[0].dims, n = r.length, o = r[n - 2], i = t.k, a = t.n, d = r.slice(0, n - 2), l = C.size(d), m = e1[1].dims[2] / 4, u = e1[0].dataType, h = me(t.k), _ = me(m), y = d.concat([\n            o,\n            a\n        ]), g = 128, x = a % 8 === 0 ? 8 : a % 4 === 0 ? 4 : 1, $ = g / x, v = $ * _ * 8, S = v / h, T = v / t.blockSize, A = C.size(y) / x, k = [], P = [\n            l,\n            o,\n            i / h\n        ], D = C.convertShape(e1[1].dims).slice();\n        D.splice(-1, 1, m / _), k.push(...N(P)), k.push(...N(D)), k.push(...N(e1[2].dims)), e1.length === 4 && k.push(...N(C.convertShape(e1[3].dims)));\n        let R = [\n            l,\n            o,\n            a\n        ];\n        k.push(...N(R));\n        let G = (K)=>{\n            let j = P.length, V = E(\"a\", e1[0].dataType, j, h), Q = E(\"b\", 12, D.length, _), se = E(\"scales\", e1[2].dataType, e1[2].dims.length), Y = [\n                V,\n                Q,\n                se\n            ], ee = e1.length === 4 ? E(\"zero_points\", 12, e1[3].dims.length) : void 0;\n            ee && Y.push(ee);\n            let J = R.length, ne = M(\"output\", e1[0].dataType, J), be = _e(e1[0].dataType), Oe = ()=>{\n                switch(h){\n                    case 1:\n                        return \"\\n          let a_data0 = vec4<\".concat(be, \">(sub_a[word_offset], sub_a[word_offset + 1], sub_a[word_offset + 2], sub_a[word_offset + 3]);\\n          let a_data1 = vec4<\").concat(be, \">(sub_a[word_offset + 4], sub_a[word_offset + 5], sub_a[word_offset + 6], sub_a[word_offset + 7]);\");\n                    case 2:\n                        return \"\\n          let a_data0 = vec4<\".concat(be, \">(sub_a[word_offset], sub_a[word_offset + 1]);\\n          let a_data1 = vec4<\").concat(be, \">(sub_a[word_offset + 2], sub_a[word_offset + 3]);\");\n                    case 4:\n                        return \"\\n          let a_data0 = sub_a[word_offset];\\n          let a_data1 = sub_a[word_offset + 1];\";\n                    default:\n                        throw new Error(\"\".concat(h, \"-component is not supported.\"));\n                }\n            };\n            return \"\\n        var<workgroup> sub_a: array<\".concat(V.type.value, \", \").concat(S, \">;\\n        var<workgroup> inter_results: array<array<\").concat(ne.type.value, \", \").concat($, \">, \").concat(x, \">;\\n        \").concat(K.declareVariables(...Y, ne), \"\\n        \").concat(K.mainStart([\n                $,\n                x,\n                1\n            ]), \"\\n          let output_indices = \").concat(ne.offsetToIndices(\"workgroup_index * \".concat(x)), \";\\n          let col = output_indices[2];\\n          let row = output_indices[1];\\n          let batch = output_indices[0];\\n          let n_blocks_per_col = uniforms.b_shape[1];\\n          let num_tiles =  (n_blocks_per_col - 1) / \").concat(T, \" + 1;\\n\\n          // Loop over shared dimension.\\n          for (var tile: u32 = 0; tile < num_tiles; tile += 1) {\\n            let a_col_start = tile * \").concat(S, \";\\n            // load one tile A data into shared memory.\\n            for (var a_offset = local_idx; a_offset < \").concat(S, \"; a_offset += \").concat(g, \")\\n            {\\n              let a_col = a_col_start + a_offset;\\n              if (a_col < uniforms.a_shape[2])\\n              {\\n                sub_a[a_offset] = \").concat(V.getByIndices(\"\".concat(V.type.indices, \"(batch, row, a_col)\")), \";\\n              } else {\\n                sub_a[a_offset] = \").concat(V.type.value, \"(0);\\n              }\\n            }\\n            workgroupBarrier();\\n\\n            // each thread process one block\\n            let b_row = col + local_id.y;\\n            let block = tile * \").concat(T, \" + local_id.x;\\n            \").concat(ee ? \"\\n            let zero_point_bytes_per_col = (n_blocks_per_col + 1) / 2;\\n            let zero_point_byte_count = b_row * zero_point_bytes_per_col + (block >> 0x1u);\\n            let zero_point_word_index = zero_point_byte_count >> 0x2u;\\n            let zero_point_byte_offset = zero_point_byte_count & 0x3u;\\n            let zero_point_nibble_offset: u32 = block & 0x1u;\\n            let zero_point_bits_offset = (zero_point_byte_offset << 3) + (zero_point_nibble_offset << 2);\\n            let zero_point_word = \".concat(ee.getByOffset(\"zero_point_word_index\"), \" >> zero_point_bits_offset;\\n            let zero_point = \").concat(be, \"((zero_point_word) & 0xFu);\") : \"\\n            // The default zero point is 8 for unsigned 4-bit quantization.\\n            let zero_point = \".concat(be, \"(8);\"), \"\\n            let scale = \").concat(se.getByOffset(\"b_row * n_blocks_per_col + block\"), \";\\n            let b_data = \").concat(Q.getByIndices(\"\".concat(Q.type.indices, \"(b_row, block, 0)\")), \";\\n            var word_offset = local_id.x * \").concat(t.blockSize / h, \";\\n            for (var i: u32 = 0; i < \").concat(_, \"; i++) {\\n              \").concat(Oe(), \"\\n              let b_value = \").concat(_ === 1 ? \"b_data\" : \"b_data[i]\", \";\\n              let b_value_lower = unpack4xU8(b_value & 0x0F0F0F0Fu);\\n              let b_value_upper = unpack4xU8((b_value >> 4) & 0x0F0F0F0Fu);\\n              let b_quantized_values = mat2x4<\").concat(be, \">(\").concat(Array.from({\n                length: 4\n            }, ($e, le)=>\"\".concat(be, \"(b_value_lower[\").concat(le, \"]), \").concat(be, \"(b_value_upper[\").concat(le, \"])\")).join(\", \"), \");\\n              let b_dequantized_values = (b_quantized_values - mat2x4<\").concat(be, \">(\").concat(Array(8).fill(\"zero_point\").join(\",\"), \")) * scale;\\n              inter_results[local_id.y][local_id.x] += \").concat(Array.from({\n                length: 2\n            }, ($e, le)=>\"\".concat(\"dot(a_data\".concat(le, \", b_dequantized_values[\").concat(le, \"])\"))).join(\" + \"), \";\\n              word_offset += \").concat(8 / h, \";\\n            }\\n            workgroupBarrier();\\n          }\\n\\n          if (local_idx < \").concat(x, \") {\\n            var output_value: \").concat(ne.type.value, \" = \").concat(ne.type.value, \"(0);\\n            for (var b = 0u; b < \").concat($, \"; b++) {\\n              output_value += inter_results[local_idx][b];\\n            }\\n            if (col + local_idx < uniforms.output_shape[2])\\n            {\\n              \").concat(ne.setByIndices(\"\".concat(ne.type.indices, \"(batch, row, col + local_idx)\"), \"output_value\"), \"\\n            }\\n          }\\n        }\");\n        };\n        return {\n            name: \"BlockwiseMatMulNBits32\",\n            shaderCache: {\n                hint: \"\".concat(t.blockSize, \";\").concat(h, \";\").concat(_, \";\").concat($, \";\").concat(x),\n                inputDependencies: Array(e1.length).fill(\"rank\")\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: y,\n                            dataType: u\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: A\n                    },\n                    programUniforms: k\n                }),\n            getShaderSource: G\n        };\n    }, el = (e1, t)=>{\n        ch(e1.inputs, t), t.blockSize === 32 && e1.adapterInfo.isVendor(\"intel\") && e1.adapterInfo.isArchitecture(\"gen-12lp\") ? e1.compute(mh(e1.inputs, t)) : e1.compute(ph(e1.inputs, t));\n    }, tl = (e1)=>re(e1);\n});\nvar fh, hh, gh, bh, yh, _h, wh, vh, nl, ol = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    ae();\n    fh = (e1)=>{\n        if (!e1 || e1.length < 1) throw new Error(\"Too few inputs\");\n        if (e1[0].dataType !== 1 && e1[0].dataType !== 10) throw new Error(\"Input type must be float or float16.\");\n        if (e1.length >= 2) {\n            let t = e1[0].dims.length * 2 === e1[1].dims[0];\n            if (e1.length === 4 && (t = e1[3].dims[0] * 2 === e1[1].dims[0]), !t) throw new Error(\"The pads should be a 1D tensor of shape [2 * input_rank] or [2 * num_axes].\");\n        }\n    }, hh = (e1, t, r)=>{\n        let n = \"\";\n        for(let o = t - 1; o >= 0; --o)n += \"\\n            k = i32(\".concat(e1.indicesGet(\"indices\", o), \") - \").concat(F(\"uniforms.pads\", o, r), \";\\n            if (k < 0) {\\n              break;\\n            }\\n            if (k >= i32(\").concat(F(\"uniforms.x_shape\", o, t), \")) {\\n              break;\\n            }\\n            offset += k * i32(\").concat(F(\"uniforms.x_strides\", o, t), \");\\n        \");\n        return \"\\n          value = \".concat(e1.type.value, \"(uniforms.constant_value);\\n          for (var i = 0; i < 1; i++) {\\n            var offset = 0;\\n            var k = 0;\\n            \").concat(n, \"\\n            value = x[offset];\\n          }\\n      \");\n    }, gh = (e1, t, r)=>{\n        let n = \"\";\n        for(let o = t - 1; o >= 0; --o)n += \"\\n                k = i32(\".concat(e1.indicesGet(\"indices\", o), \") - \").concat(F(\"uniforms.pads\", o, r), \";\\n                if (k < 0) {\\n                  k = -k;\\n                }\\n                {\\n                  let _2n_1 = 2 * (i32(\").concat(F(\"uniforms.x_shape\", o, t), \") - 1);\\n                  k = k % _2n_1;\\n                  if(k >= i32(\").concat(F(\"uniforms.x_shape\", o, t), \")) {\\n                    k = _2n_1 - k;\\n                  }\\n                }\\n                offset += k * i32(\").concat(F(\"uniforms.x_strides\", o, t), \");\\n            \");\n        return \"\\n              var offset = 0;\\n              var k = 0;\\n              \".concat(n, \"\\n              value = x[offset];\\n          \");\n    }, bh = (e1, t, r)=>{\n        let n = \"\";\n        for(let o = t - 1; o >= 0; --o)n += \"\\n                k = i32(\".concat(e1.indicesGet(\"indices\", o), \") - \").concat(F(\"uniforms.pads\", o, r), \";\\n                if (k < 0) {\\n                  k = 0;\\n                }\\n                if (k >= i32(\").concat(F(\"uniforms.x_shape\", o, t), \")) {\\n                  k = i32(\").concat(F(\"uniforms.x_shape\", o, t), \") - 1;\\n                }\\n                offset += k * i32(\").concat(F(\"uniforms.x_strides\", o, t), \");\\n            \");\n        return \"\\n              var offset = 0;\\n              var k = 0;\\n              \".concat(n, \"\\n              value = x[offset];\\n          \");\n    }, yh = (e1, t, r)=>{\n        let n = \"\";\n        for(let o = t - 1; o >= 0; --o)n += \"\\n                k = i32(\".concat(e1.indicesGet(\"indices\", o), \") - \").concat(F(\"uniforms.pads\", o, r), \";\\n                if (k < 0)  {\\n                  k += i32(\").concat(F(\"uniforms.x_shape\", o, t), \"]);\\n                }\\n                if (k >= i32(\").concat(F(\"uniforms.x_shape\", o, t), \")) {\\n                  k -= i32(\").concat(F(\"uniforms.x_shape\", o, t), \");\\n                }\\n                offset += k * i32(\").concat(F(\"uniforms.x_strides\", o, t), \");\\n            \");\n        return \"\\n              var offset = 0;\\n              var k = 0;\\n              \".concat(n, \"\\n              value = x[offset];\\n          \");\n    }, _h = (e1, t, r)=>{\n        switch(r.mode){\n            case 0:\n                return hh(e1, t, r.pads.length);\n            case 1:\n                return gh(e1, t, r.pads.length);\n            case 2:\n                return bh(e1, t, r.pads.length);\n            case 3:\n                return yh(e1, t, r.pads.length);\n            default:\n                throw new Error(\"Invalid mode\");\n        }\n    }, wh = (e1, t)=>{\n        let r = C.padShape(e1[0].dims.slice(), t.pads), n = e1[0].dims, o = C.size(r), i = [\n            {\n                type: 12,\n                data: o\n            },\n            {\n                type: 6,\n                data: t.pads\n            }\n        ], a = e1.length >= 3 && e1[2].data;\n        t.mode === 0 && i.push({\n            type: a ? e1[2].dataType : 1,\n            data: t.value\n        }), i.push(...N(e1[0].dims, r));\n        let d = [\n            \"rank\"\n        ], l = (p)=>{\n            let m = M(\"output\", e1[0].dataType, r.length), u = E(\"x\", e1[0].dataType, n.length), h = u.type.value, _ = _h(m, n.length, t), y = [\n                {\n                    name: \"output_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"pads\",\n                    type: \"i32\",\n                    length: t.pads.length\n                }\n            ];\n            return t.mode === 0 && y.push({\n                name: \"constant_value\",\n                type: a ? h : \"f32\"\n            }), \"\\n            \".concat(p.registerUniforms(y).declareVariables(u, m), \"\\n            \").concat(p.mainStart(), \"\\n            \").concat(p.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\"), \"\\n\\n            let indices = \").concat(m.offsetToIndices(\"global_idx\"), \";\\n\\n            var value = \").concat(h, \"(0);\\n            \").concat(_, \"\\n            output[global_idx] = value;\\n        }\");\n        };\n        return {\n            name: \"Pad\",\n            shaderCache: {\n                hint: \"\".concat(t.mode).concat(a),\n                inputDependencies: d\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: r,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(C.size(r) / 64)\n                    },\n                    programUniforms: i\n                }),\n            getShaderSource: l\n        };\n    }, vh = (e1, t)=>{\n        if (e1.length > 1) {\n            let r = e1[1].getBigInt64Array(), n = e1.length >= 3 && e1[2].data ? e1[2].dataType === 10 ? e1[2].getUint16Array()[0] : e1[2].getFloat32Array()[0] : 0, o = e1[0].dims.length, i = new Int32Array(2 * o).fill(0);\n            if (e1.length >= 4) {\n                let d = e1[3].getBigInt64Array();\n                for(let l = 0; l < d.length; l++)i[Number(d[l])] = Number(r[l]), i[Number(d[l]) + o] = Number(r[l + d.length]);\n            } else r.forEach((d, l)=>i[Number(l)] = Number(d));\n            let a = [];\n            return i.forEach((d)=>a.push(d)), {\n                mode: t.mode,\n                value: n,\n                pads: a\n            };\n        } else return t;\n    }, nl = (e1, t)=>{\n        fh(e1.inputs);\n        let r = vh(e1.inputs, t);\n        e1.compute(wh(e1.inputs, r), {\n            inputs: [\n                0\n            ]\n        });\n    };\n});\nvar tn, il, al, sl, ul, $h, xh, dl, ll, cl, pl, ml, fl, hl, gl, bl, yl, _l, wl, vl = U(()=>{\n    \"use strict\";\n    We();\n    te();\n    oe();\n    ae();\n    tn = (e1)=>{\n        if (ve.webgpu.validateInputContent && (!e1 || e1.length !== 1)) throw new Error(\"Pool ops requires 1 input.\");\n    }, il = (e1, t, r)=>{\n        let n = t.format === \"NHWC\", o = e1.dims.slice();\n        n && o.splice(1, 0, o.pop());\n        let i = Object.hasOwnProperty.call(t, \"dilations\"), a = t.kernelShape.slice(), d = t.strides.slice(), l = i ? t.dilations.slice() : [], p = t.pads.slice();\n        At.adjustPoolAttributes(r, o, a, d, l, p);\n        let m = At.computePoolOutputShape(r, o, d, l, a, p, t.autoPad), u = Object.assign({}, t);\n        i ? Object.assign(u, {\n            kernelShape: a,\n            strides: d,\n            pads: p,\n            dilations: l,\n            cacheKey: t.cacheKey\n        }) : Object.assign(u, {\n            kernelShape: a,\n            strides: d,\n            pads: p,\n            cacheKey: t.cacheKey\n        });\n        let h = m.slice();\n        return h.push(h.splice(1, 1)[0]), [\n            u,\n            n ? h : m\n        ];\n    }, al = (e1, t)=>{\n        let r = t.format === \"NHWC\", n = C.size(e1), o = C.size(t.kernelShape), i = [\n            {\n                type: 12,\n                data: n\n            },\n            {\n                type: 12,\n                data: o\n            }\n        ], a = [\n            {\n                name: \"outputSize\",\n                type: \"u32\"\n            },\n            {\n                name: \"kernelSize\",\n                type: \"u32\"\n            }\n        ];\n        if (t.kernelShape.length <= 2) {\n            let d = t.kernelShape[t.kernelShape.length - 1], l = t.strides[t.strides.length - 1], p = t.pads[t.pads.length / 2 - 1], m = t.pads[t.pads.length - 1], u = !!(p + m);\n            i.push({\n                type: 12,\n                data: d\n            }, {\n                type: 12,\n                data: l\n            }, {\n                type: 12,\n                data: p\n            }, {\n                type: 12,\n                data: m\n            }), a.push({\n                name: \"kw\",\n                type: \"u32\"\n            }, {\n                name: \"sw\",\n                type: \"u32\"\n            }, {\n                name: \"pwStart\",\n                type: \"u32\"\n            }, {\n                name: \"pwEnd\",\n                type: \"u32\"\n            });\n            let h = !1;\n            if (t.kernelShape.length === 2) {\n                let _ = t.kernelShape[t.kernelShape.length - 2], y = t.strides[t.strides.length - 2], g = t.pads[t.pads.length / 2 - 2], x = t.pads[t.pads.length - 2];\n                h = !!(g + x), i.push({\n                    type: 12,\n                    data: _\n                }, {\n                    type: 12,\n                    data: y\n                }, {\n                    type: 12,\n                    data: g\n                }, {\n                    type: 12,\n                    data: x\n                }), a.push({\n                    name: \"kh\",\n                    type: \"u32\"\n                }, {\n                    name: \"sh\",\n                    type: \"u32\"\n                }, {\n                    name: \"phStart\",\n                    type: \"u32\"\n                }, {\n                    name: \"phEnd\",\n                    type: \"u32\"\n                });\n            }\n            return [\n                i,\n                a,\n                !0,\n                u,\n                h\n            ];\n        } else {\n            if (r) throw new Error(\"Pooling with kernelShape.length > 2 is not supported for NHWC format.\");\n            let d = C.computeStrides(t.kernelShape);\n            i.push({\n                type: 12,\n                data: d\n            }, {\n                type: 12,\n                data: t.pads\n            }, {\n                type: 12,\n                data: t.strides\n            }), a.push({\n                name: \"kernelStrides\",\n                type: \"u32\",\n                length: d.length\n            }, {\n                name: \"pads\",\n                type: \"u32\",\n                length: t.pads.length\n            }, {\n                name: \"strides\",\n                type: \"u32\",\n                length: t.strides.length\n            });\n            let l = t.pads.reduce((p, m)=>p + m);\n            return [\n                i,\n                a,\n                !!l,\n                !1,\n                !1\n            ];\n        }\n    }, sl = (e1, t, r, n, o, i, a, d, l, p, m, u)=>{\n        let h = o.format === \"NHWC\", _ = t.type.value, y = M(\"output\", t.type.tensor, n);\n        if (o.kernelShape.length <= 2) {\n            let g = \"\", x = \"\", $ = \"\", v = r - (h ? 2 : 1);\n            if (m ? g = \"\\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\\n                  xIndices[\".concat(v, \"] = indices[\").concat(v, \"] * uniforms.sw - uniforms.pwStart + i;\\n                  if (xIndices[\").concat(v, \"] < 0 || xIndices[\").concat(v, \"]\\n                      >= uniforms.x_shape[\").concat(v, \"]) {\\n                    pad++;\\n                    continue;\\n                  }\\n                  let x_val = x[\").concat(t.indicesToOffset(\"xIndices\"), \"];\\n                  \").concat(i, \"\\n                }\") : g = \"\\n                for (var i: u32 = 0u; i < uniforms.kw; i++) {\\n                  xIndices[\".concat(v, \"] = indices[\").concat(v, \"] * uniforms.sw - uniforms.pwStart + i;\\n                  let x_val = x[\").concat(t.indicesToOffset(\"xIndices\"), \"];\\n                  \").concat(i, \"\\n                }\"), o.kernelShape.length === 2) {\n                let T = r - (h ? 3 : 2);\n                u ? x = \"\\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\\n                  xIndices[\".concat(T, \"] = indices[\").concat(T, \"] * uniforms.sh - uniforms.phStart + j;\\n                  if (xIndices[\").concat(T, \"] < 0 || xIndices[\").concat(T, \"] >= uniforms.x_shape[\").concat(T, \"]) {\\n                    pad += i32(uniforms.kw);\\n                    continue;\\n                  }\\n              \") : x = \"\\n                for (var j: u32 = 0u; j < uniforms.kh; j++) {\\n                  xIndices[\".concat(T, \"] = indices[\").concat(T, \"] * uniforms.sh - uniforms.phStart + j;\\n                \"), $ = \"\\n              }\\n            \";\n            }\n            return \"\\n            \".concat(e1.registerUniforms(l).declareVariables(t, y), \"\\n\\n            \").concat(e1.mainStart(), \"\\n              \").concat(e1.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\"), \"\\n\\n              let indices = \").concat(y.offsetToIndices(\"global_idx\"), \";\\n              var xIndices = \").concat(y.offsetToIndices(\"global_idx\"), \";\\n\\n              var value = \").concat(_, \"(\").concat(d, \");\\n              var pad = 0;\\n              \").concat(x, \"\\n              \").concat(g, \"\\n              \").concat($, \"\\n              \").concat(a, \"\\n\\n              output[global_idx] = value;\\n            }\");\n        } else {\n            if (h) throw new Error(\"Pooling with kernelShape.length > 2 is not supported for NHWC format.\");\n            let g = o.kernelShape.length, x = o.pads.length, $ = \"\";\n            return p ? $ = \"\\n                if (xIndices[j] >= uniforms.x_shape[j]) {\\n                  pad++;\\n                  isPad = true;\\n                  break;\\n                }\\n              }\\n              if (!isPad) {\\n                let x_val = x[\".concat(t.indicesToOffset(\"xIndices\"), \"];\\n                \").concat(i, \"\\n              }\") : $ = \"\\n              }\\n              let x_val = x[\".concat(t.indicesToOffset(\"xIndices\"), \"];\\n              \").concat(i, \"\\n            \"), \"\\n            \".concat(e1.registerUniforms(l).declareVariables(t, y), \"\\n\\n            \").concat(e1.mainStart(), \"\\n              \").concat(e1.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\"), \"\\n              let indices = \").concat(y.offsetToIndices(\"global_idx\"), \";\\n              var xIndices = \").concat(y.offsetToIndices(\"global_idx\"), \";\\n\\n              var offsets: array<u32, \").concat(g, \">;\\n\\n              var value = \").concat(_, \"(\").concat(d, \");\\n              var pad = 0;\\n              var isPad = false;\\n\\n              for (var i: u32 = 0u; i < uniforms.kernelSize; i++) {\\n                var offset = i;\\n                for (var j = 0u; j < \").concat(g - 1, \"u; j++) {\\n                  offsets[j] = offset / \").concat(F(\"uniforms.kernelStrides\", \"j\", g), \";\\n                  offset -= offsets[j] * \").concat(F(\"uniforms.kernelStrides\", \"j\", g), \";\\n                }\\n                offsets[\").concat(g - 1, \"] = offset;\\n\\n                isPad = false;\\n                for (var j = \").concat(r - g, \"u; j < \").concat(r, \"u; j++) {\\n                  xIndices[j] = indices[j] * \").concat(F(\"uniforms.strides\", \"j - \".concat(r - g, \"u\"), g), \"\\n                    + offsets[j - \").concat(r - g, \"u] - \").concat(F(\"uniforms.pads\", \"j - 2u\", x), \";\\n                  \").concat($, \"\\n              }\\n              \").concat(a, \"\\n\\n              output[global_idx] = value;\\n            }\");\n        }\n    }, ul = (e1)=>\"\".concat(e1.format, \";\").concat(e1.ceilMode, \";\").concat(e1.autoPad, \";\").concat(e1.kernelShape.length), $h = (e1)=>\"\".concat(ul(e1), \";\").concat(e1.countIncludePad), xh = (e1)=>\"\".concat(ul(e1), \";\").concat(e1.storageOrder, \";\").concat(e1.dilations), dl = (e1)=>({\n            format: e1.format,\n            autoPad: [\n                \"NOTSET\",\n                \"VALID\",\n                \"SAME_UPPER\",\n                \"SAME_LOWER\"\n            ][e1.auto_pad],\n            ceilMode: e1.ceil_mode,\n            kernelShape: e1.kernel_shape,\n            strides: e1.strides,\n            pads: e1.pads\n        }), ll = (e1, t, r, n)=>{\n        let [o, i] = il(t, n, r), a = E(\"x\", t.dataType, t.dims.length), d = a.type.value, l = \"value += x_val;\", p = \"\";\n        o.countIncludePad ? p += \"value /= \".concat(d, \"(uniforms.kernelSize);\") : p += \"value /= \".concat(d, \"(i32(uniforms.kernelSize) - pad);\");\n        let [m, u, h, _, y] = al(i, o);\n        m.push(...N(t.dims, i));\n        let g = [\n            \"rank\"\n        ];\n        return {\n            name: e1,\n            shaderCache: {\n                hint: \"\".concat(n.cacheKey, \";\").concat(h, \";\").concat(_, \";\").concat(y),\n                inputDependencies: g\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: i,\n                            dataType: t.dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(C.size(i) / 64)\n                    },\n                    programUniforms: m\n                }),\n            getShaderSource: (x)=>sl(x, a, t.dims.length, i.length, o, l, p, 0, u, h, _, y)\n        };\n    }, cl = (e1)=>{\n        let t = e1.count_include_pad !== 0, r = dl(e1);\n        if (r.ceilMode !== 0) throw new Error(\"using ceil() in shape computation is not yet supported for AveragePool\");\n        let n = {\n            countIncludePad: t,\n            ...r,\n            cacheKey: \"\"\n        };\n        return {\n            ...n,\n            cacheKey: $h(n)\n        };\n    }, pl = (e1, t)=>{\n        tn(e1.inputs), e1.compute(ll(\"AveragePool\", e1.inputs[0], !1, t));\n    }, ml = {\n        autoPad: \"\",\n        ceilMode: 0,\n        countIncludePad: !1,\n        kernelShape: [],\n        strides: [],\n        pads: [],\n        storageOrder: 0,\n        dilations: []\n    }, fl = (e1)=>{\n        let t = e1.format;\n        return {\n            format: t,\n            ...ml,\n            cacheKey: t\n        };\n    }, hl = (e1, t)=>{\n        tn(e1.inputs), e1.compute(ll(\"GlobalAveragePool\", e1.inputs[0], !0, t));\n    }, gl = (e1, t, r, n)=>{\n        let [o, i] = il(t, n, r), a = \"\\n      value = max(x_val, value);\\n    \", d = \"\", l = E(\"x\", t.dataType, t.dims.length), p = [\n            \"rank\"\n        ], [m, u, h, _, y] = al(i, o);\n        return m.push(...N(t.dims, i)), {\n            name: e1,\n            shaderCache: {\n                hint: \"\".concat(n.cacheKey, \";\").concat(h, \";\").concat(_, \";\").concat(y),\n                inputDependencies: p\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: i,\n                            dataType: t.dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(C.size(i) / 64)\n                    },\n                    programUniforms: m\n                }),\n            getShaderSource: (g)=>sl(g, l, t.dims.length, i.length, o, a, d, t.dataType === 10 ? -65504 : -1e5, u, h, _, y)\n        };\n    }, bl = (e1, t)=>{\n        tn(e1.inputs), e1.compute(gl(\"MaxPool\", e1.inputs[0], !1, t));\n    }, yl = (e1)=>{\n        let t = e1.storage_order, r = e1.dilations, n = dl(e1);\n        if (t !== 0) throw new Error(\"column major storage order is not yet supported for MaxPool\");\n        if (n.ceilMode !== 0) throw new Error(\"using ceil() in shape computation is not yet supported for MaxPool\");\n        let o = {\n            storageOrder: t,\n            dilations: r,\n            ...n,\n            cacheKey: \"\"\n        };\n        return {\n            ...o,\n            cacheKey: xh(o)\n        };\n    }, _l = (e1)=>{\n        let t = e1.format;\n        return {\n            format: t,\n            ...ml,\n            cacheKey: t\n        };\n    }, wl = (e1, t)=>{\n        tn(e1.inputs), e1.compute(gl(\"GlobalMaxPool\", e1.inputs[0], !0, t));\n    };\n});\nvar Th, Ih, $l, xl, Sl = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    Th = (e1, t)=>{\n        if (e1.length < 2 || e1.length > 3) throw new Error(\"DequantizeLinear requires 2 or 3 inputs.\");\n        if (e1.length === 3 && e1[1].dims === e1[2].dims) throw new Error(\"x-scale and x-zero-point must have the same shape.\");\n        if (e1.length === 3 && e1[0].dataType !== e1[2].dataType) throw new Error(\"x and x-zero-point must have the same data type.\");\n        if (e1[0].dataType === 6 && e1.length > 2) throw new Error(\"In the case of dequantizing int32 there is no zero point.\");\n        if (e1[1].dims.length !== 0 && e1[1].dims.length !== 1 && e1[1].dims.length !== e1[0].dims.length) throw new Error(\"scale input must be a scalar, a 1D tensor, or have the same rank as the input tensor.\");\n        if (e1.length > 2) {\n            if (e1[0].dataType !== e1[2].dataType) throw new Error(\"x and x-zero-point must have the same data type.\");\n            if (e1[1].dims.length !== e1[2].dims.length) throw new Error(\"scale and zero-point inputs must have the same rank.\");\n            if (!e1[1].dims.map((r, n)=>r === e1[2].dims[n]).reduce((r, n)=>r && n, !0)) throw new Error(\"scale and zero-point inputs must have the same shape.\");\n        }\n        if (t.blockSize > 0) {\n            if (e1[1].dims.length === 0 || e1[1].dims.length === 1 && e1[1].dims[0] === 1) throw new Error(\"blockSize must be set only for block quantization.\");\n            if (!e1[1].dims.map((o, i)=>i === t.axis || o === e1[0].dims[i]).reduce((o, i)=>o && i, !0)) throw new Error(\"For block qunatization, scale input shape to match the input shape except for the axis\");\n            if (e1[1].dims.length !== e1[0].dims.length) throw new Error(\"For block qunatization the scale input rank must be the same as the x rank.\");\n            let r = e1[0].dims[t.axis], n = e1[1].dims[t.axis];\n            if (t.blockSize < Math.ceil(r / n) || t.blockSize > Math.ceil(r / (n - 1) - 1)) throw new Error(\"blockSize must be with in the range [ceil(dI / Si), ceil(dI / (Si - 1) - 1)].\");\n        }\n    }, Ih = (e1, t)=>{\n        let r = C.normalizeAxis(t.axis, e1[0].dims.length), n = e1[0].dataType, o = n === 3, i = e1[0].dims, a = e1[1].dataType, d = C.size(i), l = n === 3 || n === 2, p = l ? [\n            Math.ceil(C.size(e1[0].dims) / 4)\n        ] : e1[0].dims, m = e1[1].dims, u = e1.length > 2 ? e1[2] : void 0, h = u ? l ? [\n            Math.ceil(C.size(u.dims) / 4)\n        ] : u.dims : void 0, _ = m.length === 0 || m.length === 1 && m[0] === 1, y = _ === !1 && m.length === 1, g = me(d), x = _ && (!l || g === 4), $ = x ? g : 1, v = x && !l ? g : 1, S = E(\"input\", l ? 12 : n, p.length, v), T = E(\"scale\", a, m.length), A = u ? E(\"zero_point\", l ? 12 : n, h.length) : void 0, k = M(\"output\", a, i.length, $), P = [\n            S,\n            T\n        ];\n        A && P.push(A);\n        let D = [\n            p,\n            m\n        ];\n        u && D.push(h);\n        let R = [\n            {\n                type: 12,\n                data: d / $\n            },\n            {\n                type: 12,\n                data: r\n            },\n            {\n                type: 12,\n                data: t.blockSize\n            },\n            ...N(...D, i)\n        ], G = (K)=>{\n            let j = [\n                {\n                    name: \"output_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"axis\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"block_size\",\n                    type: \"u32\"\n                }\n            ];\n            return \"\\n      \".concat(K.registerUniforms(j).declareVariables(...P, k), \"\\n      \").concat(K.mainStart(), \"\\n          \").concat(K.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\"), \"\\n          let output_indices = \").concat(k.offsetToIndices(\"global_idx\"), \";\\n\\n          // Set input x\\n          \").concat((()=>l ? \"\\n            let input = \".concat(S.getByOffset(\"global_idx / 4\"), \";\\n            let x_vec = \").concat(o ? \"unpack4xI8(input)\" : \"unpack4xU8(input)\", \";\\n            let x_value = \").concat($ === 1 ? \"x_vec[global_idx % 4]\" : \"x_vec\", \";\") : \"let x_value = \".concat(S.getByOffset(\"global_idx\"), \";\"))(), \";\\n\\n          // Set scale input\\n          \").concat((()=>_ ? \"let scale_value= \".concat(T.getByOffset(\"0\")) : y ? \"\\n            let scale_index = \".concat(k.indicesGet(\"output_indices\", \"uniforms.axis\"), \";\\n            let scale_value= \").concat(T.getByOffset(\"scale_index\"), \";\") : \"\\n            var scale_indices: \".concat(T.type.indices, \" = output_indices;\\n            let index = \").concat(T.indicesGet(\"scale_indices\", \"uniforms.axis\"), \" / uniforms.block_size;\\n            \").concat(T.indicesSet(\"scale_indices\", \"uniforms.axis\", \"index\"), \";\\n            let scale_value= \").concat(T.getByIndices(\"scale_indices\"), \";\"))(), \";\\n\\n          // Set zero-point input\\n          \").concat((()=>A ? _ ? l ? \"\\n                let zero_point_input = \".concat(A.getByOffset(\"0\"), \";\\n                let zero_point_vec =  \").concat(o ? \"unpack4xI8(zero_point_input)\" : \"unpack4xU8(zero_point_input)\", \";\\n                let zero_point_value= zero_point_vec[0]\") : \"let zero_point_value = \".concat(A.getByOffset(\"0\")) : y ? l ? \"\\n                let zero_point_index = \".concat(k.indicesGet(\"output_indices\", \"uniforms.axis\"), \";\\n                let zero_point_input = \").concat(A.getByOffset(\"zero_point_index / 4\"), \";\\n                let zero_point_vec =  \").concat(o ? \"unpack4xI8(zero_point_input)\" : \"unpack4xU8(zero_point_input)\", \";\\n                let zero_point_value = zero_point_vec[zero_point_index % 4]\") : \"\\n                let zero_point_index = \".concat(k.indicesGet(\"output_indices\", \"uniforms.axis\"), \";\\n                let zero_point_value = \").concat(A.getByOffset(\"zero_point_index\"), \";\") : l ? \"\\n                let zero_point_offset = \".concat(T.indicesToOffset(\"scale_indices\"), \";\\n                let zero_point_input = \").concat(A.getByOffset(\"zero_point_offset / 4\"), \";\\n                let zero_point_vec = \").concat(o ? \"unpack4xI8(zero_point_input)\" : \"unpack4xU8(zero_point_input)\", \";\\n                let zero_point_value = zero_point_vec[zero_point_offset % 4];\") : \"let zero_point_value = \".concat(A.getByIndices(\"scale_indices\"), \";\") : \"let zero_point_value = \".concat(l ? o ? \"i32\" : \"u32\" : S.type.value, \"(0);\"))(), \";\\n      // Compute and write output\\n      \").concat(k.setByOffset(\"global_idx\", \"\".concat(k.type.value, \"(x_value - zero_point_value) * scale_value\")), \";\\n      }\");\n        };\n        return {\n            name: \"DequantizeLinear\",\n            shaderCache: {\n                hint: t.cacheKey,\n                inputDependencies: A ? [\n                    \"rank\",\n                    \"rank\",\n                    \"rank\"\n                ] : [\n                    \"rank\",\n                    \"rank\"\n                ]\n            },\n            getShaderSource: G,\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: i,\n                            dataType: a\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(d / $ / 64),\n                        y: 1,\n                        z: 1\n                    },\n                    programUniforms: R\n                })\n        };\n    }, $l = (e1, t)=>{\n        Th(e1.inputs, t), e1.compute(Ih(e1.inputs, t));\n    }, xl = (e1)=>re({\n            axis: e1.axis,\n            blockSize: e1.blockSize\n        });\n});\nvar Ch, Ah, Tl, Il = U(()=>{\n    \"use strict\";\n    We();\n    te();\n    ae();\n    Ch = (e1, t, r)=>{\n        let n = e1 === t, o = e1 < t && r < 0, i = e1 > t && r > 0;\n        if (n || o || i) throw new Error(\"Range these inputs' contents are invalid.\");\n    }, Ah = (e1, t, r, n)=>{\n        let o = Math.abs(Math.ceil((t - e1) / r)), i = [\n            o\n        ], a = o, d = [\n            {\n                type: 12,\n                data: a\n            },\n            {\n                type: n,\n                data: e1\n            },\n            {\n                type: n,\n                data: r\n            },\n            ...N(i)\n        ], l = (p)=>{\n            let m = M(\"output\", n, i.length), u = m.type.value, h = [\n                {\n                    name: \"outputSize\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"start\",\n                    type: u\n                },\n                {\n                    name: \"delta\",\n                    type: u\n                }\n            ];\n            return \"\\n        \".concat(p.registerUniforms(h).declareVariables(m), \"\\n        \").concat(p.mainStart(), \"\\n        \").concat(p.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\"), \"\\n        output[global_idx] = uniforms.start + \").concat(u, \"(global_idx) * uniforms.delta;\\n      }\");\n        };\n        return {\n            name: \"Range\",\n            shaderCache: {\n                hint: \"\".concat(n)\n            },\n            getShaderSource: l,\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: i,\n                            dataType: n\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(a / 64)\n                    },\n                    programUniforms: d\n                })\n        };\n    }, Tl = (e1)=>{\n        let t = 0, r = 0, n = 0;\n        e1.inputs[0].dataType === 6 ? (t = e1.inputs[0].getInt32Array()[0], r = e1.inputs[1].getInt32Array()[0], n = e1.inputs[2].getInt32Array()[0]) : e1.inputs[0].dataType === 1 && (t = e1.inputs[0].getFloat32Array()[0], r = e1.inputs[1].getFloat32Array()[0], n = e1.inputs[2].getFloat32Array()[0]), ve.webgpu.validateInputContent && Ch(t, r, n), e1.compute(Ah(t, r, n, e1.inputs[0].dataType), {\n            inputs: []\n        });\n    };\n});\nvar kh, Eh, Cl, Al, kl = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    kh = (e1, t, r, n)=>{\n        if (e1 !== \"none\" && n !== \"i32\" && n !== \"u32\" && n !== \"f32\") throw new Error(\"Input \".concat(n, \" is not supported with reduction \").concat(e1, \".\"));\n        let o = \"{\\n                var oldValue = 0;\\n                loop {\\n                  let newValueF32 =\", i = \";\\n                  let newValue = bitcast<i32>(newValueF32);\\n                  let res = atomicCompareExchangeWeak(&\".concat(t, \", oldValue, newValue);\\n                  if res.exchanged {\\n                    break;\\n                  }\\n                  oldValue = res.old_value;\\n                }\\n              }\");\n        switch(e1){\n            case \"none\":\n                return \"\".concat(t, \"=\").concat(r, \";\");\n            case \"add\":\n                return n === \"i32\" || n === \"u32\" ? \"atomicAdd(&\".concat(t, \", bitcast<\").concat(n, \">(\").concat(r, \"));\") : \"\\n              \".concat(o, \"bitcast<\").concat(n, \">(oldValue) + (\").concat(r, \")\").concat(i);\n            case \"max\":\n                return n === \"i32\" || n === \"u32\" ? \"atomicMax(&\".concat(t, \", bitcast<\").concat(n, \">(\").concat(r, \"));\") : \"\\n                \".concat(o, \"max(bitcast<f32>(oldValue), (\").concat(r, \"))\").concat(i);\n            case \"min\":\n                return n === \"i32\" || n === \"u32\" ? \"atomicMin(&\".concat(t, \", bitcast<\").concat(n, \">(\").concat(r, \"));\") : \"\".concat(o, \"min(bitcast<\").concat(n, \">(oldValue), (\").concat(r, \"))\").concat(i);\n            case \"mul\":\n                return \"\".concat(o, \"(bitcast<\").concat(n, \">(oldValue) * (\").concat(r, \"))\").concat(i);\n            default:\n                throw new Error(\"Reduction \".concat(e1, \" is not supported.\"));\n        }\n    }, Eh = (e1, t)=>{\n        let r = e1[0].dims, n = e1[1].dims, o = r, i = 1, a = Math.ceil(C.size(n) / i), d = n[n.length - 1], l = C.sizeFromDimension(r, d), p = [\n            {\n                type: 12,\n                data: a\n            },\n            {\n                type: 12,\n                data: d\n            },\n            {\n                type: 12,\n                data: l\n            },\n            ...N(e1[1].dims, e1[2].dims, o)\n        ], m = (u)=>{\n            let h = E(\"indices\", e1[1].dataType, e1[1].dims.length), _ = E(\"updates\", e1[2].dataType, e1[2].dims.length, i), y = t.reduction !== \"none\" && t.reduction !== \"\" ? rs(\"output\", e1[0].dataType, o.length) : M(\"output\", e1[0].dataType, o.length, i);\n            return \"\\n      \".concat(u.registerUniform(\"output_size\", \"u32\").registerUniform(\"last_index_dimension\", \"u32\").registerUniform(\"num_updates_elements\", \"u32\").declareVariables(h, _, y), \"\\n      \").concat(u.mainStart(), \"\\n        \").concat(u.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\"), \"\\n  var data_offset = 0u;\\n  let indices_start = uniforms.last_index_dimension * global_idx;\\n  let indices_end = indices_start + uniforms.last_index_dimension;\\n  for (var i = indices_start; i < indices_end; i++) {\\n    var index = i32(indices[i].x);\\n    \").concat(e1[0].dims.length === 1 ? \"\\n    let element_count_dim = uniforms.output_strides;\\n    let dim_value = uniforms.output_shape;\" : \"\\n    let element_count_dim = uniforms.output_strides[i - indices_start];\\n    let dim_value = uniforms.output_shape[i - indices_start + uniforms.last_index_dimension];\", \"\\n    if (index >= 0) {\\n      if (index >= i32(dim_value)) {\\n        index = i32(dim_value - 1);\\n      }\\n    } else {\\n      if (index < -i32(dim_value)) {\\n        index = 0;\\n      } else {\\n        index += i32(dim_value);\\n      }\\n    }\\n    data_offset += u32((u32(index) * element_count_dim));\\n  }\\n\\n  for (var i = 0u; i < uniforms.num_updates_elements; i++) {\\n    let value = updates[uniforms.num_updates_elements * global_idx + i];\\n    \").concat(kh(t.reduction, \"output[data_offset + i]\", \"value\", y.type.value), \"\\n  }\\n\\n      }\");\n        };\n        return {\n            name: \"ScatterND\",\n            shaderCache: {\n                hint: \"\".concat(t.cacheKey, \"_\").concat(t.reduction),\n                inputDependencies: [\n                    \"rank\",\n                    \"rank\"\n                ]\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: o,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(a / 64)\n                    },\n                    programUniforms: p\n                }),\n            getShaderSource: m\n        };\n    }, Cl = (e1)=>re({\n            reduction: e1.reduction\n        }), Al = (e1, t)=>{\n        e1.compute(Eh(e1.inputs, t), {\n            inputs: [\n                e1.inputs[1],\n                e1.inputs[2]\n            ],\n            outputs: []\n        });\n    };\n});\nvar Ph, zh, Oh, Dh, Bh, Mh, Rh, Uh, Nh, Vh, Wh, El, Lh, Gh, Hh, Fh, qh, Pl, zl, Ol = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    Ph = (e1, t)=>{\n        if (e1.every((r)=>r > 0 || (()=>{\n                throw new Error(\"Resize requires scales input values to be positive\");\n            })), e1.length > 0) {\n            if (t.mode === \"linear\") {\n                if (!(e1.length === 2 || e1.length === 3 || e1.length === 4 && e1[0] === 1 && e1[1] === 1 || e1.length === 4 && e1[0] === 1 && e1[3] === 1 || e1.length === 5 && e1[0] === 1 && e1[1] === 1)) throw new Error(\"For linear mode, Resize requires scales to be 2D, 3D, 4D with either two outermost or one innermost and\\n            one outermost scale values equal to 1, or 5D with two outermost scale values equal to 1\");\n            } else if (t.mode === \"cubic\" && !(e1.length === 2 || e1.length === 4 && e1[0] === 1 && e1[1] === 1 || e1.length === 4 && e1[0] === 1 && e1[3] === 1)) throw new Error(\"Resize requires scales input size to be 2 or 4 for cubic mode\");\n        }\n    }, zh = (e1, t, r)=>{\n        t.every((o)=>o >= 0 && o < r || (()=>{\n                throw new Error(\"Resize requires axes input values to be positive and less than rank\");\n            }));\n        let n = new Array(r).fill(1);\n        return t.forEach((o, i)=>n[o] = e1[i]), n;\n    }, Oh = (e1, t, r, n, o, i)=>{\n        let [a, d, l] = r > 10 ? [\n            1,\n            2,\n            3\n        ] : [\n            -1,\n            e1.length > 1 ? 1 : -1,\n            -1\n        ], p = e1[0].dims.length;\n        if (a > 0 && e1.length > a && e1[a].dims.length > 0) e1[a].getFloat32Array().forEach((m)=>i.push(m));\n        else if (t.coordinateTransformMode === \"tf_crop_and_resize\") throw new Error(\"Resize requires RoI input to be specified when coordinateTransformMode is tfCropAndResize\");\n        if (d > 0 && e1.length > d && e1[d].dims.length === 1 && e1[d].dims[0] > 0) {\n            if (e1[d].getFloat32Array().forEach((m)=>n.push(m)), n.length !== 0 && n.length !== p && r >= 18 && n.length !== t.axes.length) throw new Error(\"Resize requires scales input size to be same as input rank or axes size for opset 18 and up\");\n            Ph(n, t), t.axes.length > 0 && zh(n, t.axes, p).forEach((m, u)=>n[u] = m);\n        }\n        if (l > 0 && e1.length > l && e1[l].dims.length === 1 && e1[l].dims[0] > 0 && (e1[l].getBigInt64Array().forEach((m)=>o.push(Number(m))), o.length !== 0 && o.length !== p && r >= 18 && o.length !== t.axes.length)) throw new Error(\"Resize requires sizes input size to be same as input rank or axes size for opset 18 and up\");\n        if (t.axes.length > 0) {\n            if (n.length !== 0 && n.length !== t.axes.length) throw new Error('Resize requires \"scales\" input size to be of axes rank when axes attributes is specified');\n            if (o.length !== 0 && o.length !== t.axes.length) throw new Error('Resize requires \"sizes\" input size to be of rank axes rank when axes attributes is specified');\n        }\n        if (typeof n < \"u\" && typeof o < \"u\" && n.length > 0 && o.length > p) throw new Error(\"Resize requires only of scales or sizes to be specified\");\n    }, Dh = (e1, t)=>\"fn getOriginalCoordinateFromResizedCoordinate(xResized: u32, xScale: f32, lengthResized: u32,\\n     lengthOriginal: u32, roiStart: f32, roiEnd: f32) -> \".concat(t, \" { \") + (()=>{\n            switch(e1){\n                case \"asymmetric\":\n                    return \"return \".concat(t, \"(xResized) / \").concat(t, \"(xScale);\");\n                case \"pytorch_half_pixel\":\n                    return \"if (lengthResized > 1) {\\n                    return (\".concat(t, \"(xResized) + 0.5) / \").concat(t, \"(xScale) - 0.5;\\n                  } else {\\n                    return 0.0;\\n                  }\");\n                case \"tf_half_pixel_for_nn\":\n                    return \"return (\".concat(t, \"(xResized) + 0.5) / \").concat(t, \"(xScale);\");\n                case \"align_corners\":\n                    return \"if (lengthResized == 1) {\\n                    return 0.0;\\n                  } else {\\n                    // The whole part and the fractional part are calculated separately due to inaccuracy of floating\\n                    // point division. As an example, f32(21) / f32(7) may evaluate to 2.99... instead of 3, causing an\\n                    // offset-by-one error later in floor().\\n                    let whole = \".concat(t, \"(xResized * (lengthOriginal - 1) / (lengthResized - 1));\\n                    let fract =\\n                        \").concat(t, \"(xResized * (lengthOriginal - 1) % (lengthResized - 1)) / \").concat(t, \"(lengthResized - 1);\\n                    return whole + fract;\\n                  }\");\n                case \"tf_crop_and_resize\":\n                    return \"if (lengthResized > 1) {\\n                    return \".concat(t, \"(roiStart) * \").concat(t, \"(lengthOriginal - 1) +\\n                        (\").concat(t, \"(xResized) * \").concat(t, \"(roiEnd - roiStart) * \").concat(t, \"(lengthOriginal - 1)) /\\n                        \").concat(t, \"(lengthResized - 1);\\n                  } else {\\n                    return 0.5 * \").concat(t, \"(roiStart + roiEnd) * \").concat(t, \"(lengthOriginal - 1);\\n                  }\");\n                case \"half_pixel_symmetric\":\n                    return \"const outputWidth = \".concat(t, \"xScale * \").concat(t, \"(lengthResized);\\n                  const adjustment = \").concat(t, \"(lengthResized) / outputWidth;\\n                  const center = \").concat(t, \"(lengthOriginal) / 2;\\n                  const offset = center * (1 - adjustment);\\n                  return offset + ((\").concat(t, \"(xResized) + 0.5) / \").concat(t, \"(xScale)) - 0.5;\");\n                case \"half_pixel\":\n                    return \"return ((\".concat(t, \"(xResized) + 0.5) / \").concat(t, \"(xScale)) - 0.5;\");\n                default:\n                    throw new Error(\"Coordinate transform mode \".concat(e1, \" is not supported\"));\n            }\n        })() + \"}\", Bh = (e1, t, r)=>\"fn getNearestPixelFromOriginal(xOriginal: \".concat(r, \", isDownSample: bool) -> \").concat(r, \" {\") + (()=>{\n            switch(e1){\n                case \"round_prefer_ceil\":\n                    return \"if (fract(xOriginal) == 0.5) {             return ceil(xOriginal);           } else {             return round(xOriginal);           }\";\n                case \"floor\":\n                    return \"return floor(xOriginal);\";\n                case \"ceil\":\n                    return \"return ceil(xOriginal);\";\n                case \"round_prefer_floor\":\n                    return \"if (fract(xOriginal) == 0.5) {                     return floor(xOriginal);                   } else {                     return round(xOriginal);                   }\";\n                case \"simple\":\n                default:\n                    if (t < 11) return \"if (isDownSample)                     {                       return ceil(xOriginal);                     } else {                       return xOriginal;                     }\";\n                    throw new Error(\"Nearest mode \".concat(e1, \" is not supported\"));\n            }\n        })() + \"}\", Mh = (e1, t, r)=>{\n        let n = new Array(r).fill(0).concat(new Array(r).fill(1)), o = e1.length === 0 ? n : e1.slice();\n        return t.length > 0 ? (t.forEach((i, a)=>{\n            n[i] = o[a], n[a + r] = o[t.length + a];\n        }), n) : o;\n    }, Rh = (e1, t, r, n)=>{\n        let o = [];\n        if (r.length > 0) if (n.length > 0) {\n            if (e1.forEach((i)=>o.push(i)), Math.max(...n) > e1.length) throw new Error(\"axes is out of bound\");\n            n.forEach((i, a)=>o[i] = r[a]);\n        } else r.forEach((i)=>o.push(i));\n        else {\n            if (t.length === 0) throw new Error(\"Resize requires either scales or sizes.\");\n            o = e1.map((i, a)=>Math.round(i * t[a]));\n        }\n        return o;\n    }, Uh = (e1, t, r)=>{\n        let n = (()=>{\n            switch(r.keepAspectRatioPolicy){\n                case \"not_larger\":\n                    return r.axes.length > 0 ? Math.min(...r.axes.map((i)=>t[i]), Number.MAX_VALUE) : Math.min(...t, Number.MAX_VALUE);\n                case \"not_smaller\":\n                    return r.axes.length > 0 ? Math.max(...r.axes.map((i)=>t[i]), Number.MIN_VALUE) : Math.max(...t, Number.MIN_VALUE);\n                default:\n                    throw new Error(\"Keep aspect ratio policy \".concat(r.keepAspectRatioPolicy, \" is not supported\"));\n            }\n        })();\n        t.fill(1, 0, t.length);\n        let o = e1.slice();\n        return r.axes.length > 0 ? (r.axes.forEach((i)=>t[i] = n), r.axes.forEach((i)=>o[i] = Math.round(e1[i] * t[i]))) : (t.fill(n, 0, t.length), o.forEach((i, a)=>o[a] = Math.round(i * t[a]))), o;\n    }, Nh = (e1, t, r, n, o)=>\"\\n    fn calculateOriginalIndicesFromOutputIndices(output_indices: \".concat(e1.type.indices, \") -> array<\").concat(e1.type.value, \", \").concat(r.length, \"> {\\n      var original_indices: array<\").concat(e1.type.value, \", \").concat(r.length, \">;\\n      for (var i:u32 = 0; i < \").concat(r.length, \"; i++) {\\n        var output_index = \").concat(e1.indicesGet(\"output_indices\", \"i\"), \";\\n        var scale = \").concat(F(\"uniforms.scales\", \"i\", n), \";\\n        var roi_low = \").concat(F(\"uniforms.roi\", \"i\", o), \";\\n        var roi_hi = \").concat(F(\"uniforms.roi\", \"i + \".concat(t.length), o), \";\\n        if (scale == 1.0) {\\n          original_indices[i] = \").concat(e1.type.value, \"(output_index);\\n        } else {\\n          var input_shape_i = \").concat(F(\"uniforms.input_shape\", \"i\", t.length), \";\\n          var output_shape_i = \").concat(F(\"uniforms.output_shape\", \"i\", r.length), \";\\n          original_indices[i] = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\\n                                                                           input_shape_i, roi_low, roi_hi);\\n        }\\n      }\\n      return original_indices;\\n    }\"), Vh = (e1, t, r, n, o, i, a)=>\"\\n    fn calculateInputIndicesFromOutputIndices(output_indices: \".concat(t.type.indices, \") -> \").concat(e1.type.indices, \" {\\n      var input_indices: \").concat(e1.type.indices, \";\\n      for (var i:u32 = 0; i < \").concat(n.length, \"; i++) {\\n        var output_index = \").concat(t.indicesGet(\"output_indices\", \"i\"), \";\\n        var input_index: u32;\\n        var scale = \").concat(F(\"uniforms.scales\", \"i\", o), \";\\n        if (scale == 1.0) {\\n          input_index = output_index;\\n        } else {\\n          var roi_low = \").concat(F(\"uniforms.roi\", \"i\", i), \";\\n          var roi_hi = \").concat(F(\"uniforms.roi\", \"i + \".concat(r.length), i), \";\\n          var input_shape_i = \").concat(F(\"uniforms.input_shape\", \"i\", r.length), \";\\n          var output_shape_i = \").concat(F(\"uniforms.output_shape\", \"i\", n.length), \";\\n          var original_idx = getOriginalCoordinateFromResizedCoordinate(output_index, scale, output_shape_i,\\n                                                                        input_shape_i, roi_low, roi_hi);\\n          if (!\").concat(a, \" || (original_idx >= 0 && original_idx < \").concat(t.type.value, \"(input_shape_i))) {\\n            if (original_idx < 0) {\\n              input_index = 0;\\n            } else if (original_idx > \").concat(t.type.value, \"(input_shape_i - 1)) {\\n              input_index = input_shape_i - 1;\\n            } else {\\n              input_index = u32(getNearestPixelFromOriginal(original_idx, scale < 1));\\n            }\\n          } else {\\n            input_index = u32(original_idx);\\n          }\\n        }\\n        \").concat(e1.indicesSet(\"input_indices\", \"i\", \" input_index\"), \"\\n      }\\n      return input_indices;\\n    }\"), Wh = (e1, t)=>\"\\n    fn checkInputIndices(input_indices: \".concat(e1.type.indices, \") -> bool {\\n      for (var i:u32 = 0; i < \").concat(t.length, \"; i++) {\\n        var input_index = \").concat(e1.indicesGet(\"input_indices\", \"i\"), \";\\n        if (input_index < 0 || input_index >= \").concat(F(\"uniforms.input_shape\", \"i\", t.length), \") {\\n          return false;\\n        }\\n      }\\n      return true;\\n    }\"), El = (e1, t, r, n)=>e1.rank > n ? \"\\n    \".concat(e1.indicesSet(\"input_indices\", t, \"channel\"), \";\\n    \").concat(e1.indicesSet(\"input_indices\", r, \"batch\"), \";\\n\") : \"\", Lh = (e1, t, r, n, o)=>{\n        let [a, d, l, p] = r.length === 2 ? [\n            -1,\n            0,\n            1,\n            -1\n        ] : [\n            0,\n            2,\n            3,\n            1\n        ], m = e1.type.value;\n        return \"\\n    fn getInputValue(batch: u32, channel: u32, row: u32, col: u32) -> \".concat(m, \" {\\n      var input_indices: \").concat(e1.type.indices, \";\\n      \").concat(e1.indicesSet(\"input_indices\", d, \"max(0, min(row, \".concat(r[d], \" - 1))\")), \";\\n      \").concat(e1.indicesSet(\"input_indices\", l, \"max(0, min(col, \".concat(r[l], \" - 1))\")), \";\\n      \").concat(El(e1, p, a, 2), \"\\n      return \").concat(e1.getByIndices(\"input_indices\"), \";\\n    }\\n\\n    fn bilinearInterpolation(output_indices: \").concat(t.type.indices, \") -> \").concat(m, \" {\\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\\n      var row:\").concat(m, \" = originalIndices[\").concat(d, \"];\\n      var col:\").concat(m, \" = originalIndices[\").concat(l, \"];\\n      \").concat(n ? \"if (row < 0 || row > (\".concat(r[d], \" - 1) || col < 0 || col > (\").concat(r[l], \" - 1)) {\\n        return \").concat(o, \";\\n      }\") : \"\", \";\\n      row = max(0, min(row, \").concat(r[d], \" - 1));\\n      col = max(0, min(col, \").concat(r[l], \" - 1));\\n      var row1: u32 = u32(row);\\n      var col1: u32 = u32(col);\\n      var row2: u32 = u32(row + 1);\\n      var col2: u32 = u32(col + 1);\\n      var channel: u32 = \").concat(r.length > 2 ? \"u32(originalIndices[\".concat(p, \"])\") : \"0\", \";\\n      var batch: u32 =  \").concat(r.length > 2 ? \"u32(originalIndices[\".concat(a, \"])\") : \"0\", \";\\n      var x11: \").concat(m, \" = getInputValue(batch, channel, row1, col1);\\n      var x12: \").concat(m, \" = getInputValue(batch, channel, row1, col2);\\n      var x21: \").concat(m, \" = getInputValue(batch, channel, row2, col1);\\n      var x22: \").concat(m, \" = getInputValue(batch, channel, row2, col2);\\n      var dx1: \").concat(m, \" = abs(row - \").concat(m, \"(row1));\\n      var dx2: \").concat(m, \" = abs(\").concat(m, \"(row2) - row);\\n      var dy1: \").concat(m, \" = abs(col - \").concat(m, \"(col1));\\n      var dy2: \").concat(m, \" = abs(\").concat(m, \"(col2) - col);\\n      if (row1 == row2) {\\n        dx1 = 0.5;\\n        dx2 = 0.5;\\n      }\\n      if (col1 == col2) {\\n        dy1 = 0.5;\\n        dy2 = 0.5;\\n      }\\n      return (x11 * dx2 * dy2 + x12 * dx2 * dy1 + x21 * dx1 * dy2 + x22 * dx1 * dy1);\\n    }\");\n    }, Gh = (e1, t, r, n, o, i, a, d, l, p)=>{\n        let m = r.length === 2, u = !0, [h, _] = m ? [\n            0,\n            1\n        ] : u ? [\n            2,\n            3\n        ] : [\n            1,\n            2\n        ], y = e1.type.value, g = (x)=>{\n            let $ = x === h ? \"row\" : \"col\";\n            return \"\\n      fn \".concat($, \"CubicInterpolation(input_indices: \").concat(e1.type.indices, \", output_indices: \").concat(t.type.indices, \") -> \").concat(y, \" {\\n        var output_index = \").concat(t.indicesGet(\"output_indices\", x), \";\\n        var originalIdx: \").concat(y, \" = getOriginalCoordinateFromResizedCoordinate(output_index, \").concat(o[x], \",\\n        \").concat(n[x], \", \").concat(r[x], \", \").concat(i[x], \", \").concat(i[x], \" + \").concat(r.length, \");\\n        var fractOriginalIdx: \").concat(y, \" = originalIdx - floor(originalIdx);\\n        var coefs = getCubicInterpolationCoefs(fractOriginalIdx);\\n\\n        if (\").concat(d, \" && (originalIdx < 0 || originalIdx > (\").concat(r[x], \" - 1))) {\\n          return \").concat(l, \";\\n        }\\n        var data: array<\").concat(y, \", 4> = array<\").concat(y, \", 4>(0.0, 0.0, 0.0, 0.0);\\n        for (var i: i32 = -1; i < 3; i++) {\\n          var \").concat($, \": \").concat(y, \" = originalIdx + \").concat(y, \"(i);\\n          if (\").concat($, \" < 0 || \").concat($, \" >= \").concat(r[x], \") {\\n            \").concat((()=>p ? \"coefs[i + 1] = 0.0;\\n                        continue;\" : d ? \"return \".concat(l, \";\") : \"\".concat($, \" = max(0, min(\").concat($, \", \").concat(r[x], \" - 1));\"))(), \";\\n          }\\n        var input_indices_copy: \").concat(e1.type.indices, \" = input_indices;\\n          \").concat(e1.indicesSet(\"input_indices_copy\", x, \"u32(\".concat($, \")\")), \";\\n          data[i + 1] = \").concat(x === h ? e1.getByIndices(\"input_indices_copy\") : \"rowCubicInterpolation(input_indices_copy, output_indices)\", \";\\n        }\\n        return cubicInterpolation1D(data, coefs);\\n      }\");\n        };\n        return \"\\n    \".concat(g(h), \";\\n    \").concat(g(_), \";\\n  fn getCubicInterpolationCoefs(s: \").concat(y, \") -> array<\").concat(y, \", 4> {\\n    var absS = abs(s);\\n    var coeffs: array<\").concat(y, \", 4> = array<\").concat(y, \", 4>(0.0, 0.0, 0.0, 0.0);\\n    var oneMinusAbsS: \").concat(y, \" = 1.0 - absS;\\n    var twoMinusAbsS: \").concat(y, \" = 2.0 - absS;\\n    var onePlusAbsS: \").concat(y, \" = 1.0 + absS;\\n    coeffs[0] = ((\").concat(a, \" * onePlusAbsS - 5 * \").concat(a, \") * onePlusAbsS + 8 * \").concat(a, \") * onePlusAbsS - 4 * \").concat(a, \";\\n    coeffs[1] = ((\").concat(a, \" + 2) * absS - (\").concat(a, \" + 3)) * absS * absS + 1;\\n    coeffs[2] = ((\").concat(a, \" + 2) * oneMinusAbsS - (\").concat(a, \" + 3)) * oneMinusAbsS * oneMinusAbsS + 1;\\n    coeffs[3] = ((\").concat(a, \" * twoMinusAbsS - 5 * \").concat(a, \") * twoMinusAbsS + 8 * \").concat(a, \") * twoMinusAbsS - 4 * \").concat(a, \";\\n    return coeffs;\\n  }\\n\\n  fn cubicInterpolation1D(x: array<\").concat(y, \", 4>, coefs: array<\").concat(y, \", 4>) -> \").concat(y, \" {\\n    var coefsSum: \").concat(y, \" = coefs[0] + coefs[1] + coefs[2] + coefs[3];\\n    return (x[0] * coefs[0] + x[1] * coefs[1]+ x[2] * coefs[2]+ x[3] * coefs[3]) / coefsSum;\\n  }\\n\\n  fn bicubicInterpolation(output_indices: \").concat(t.type.indices, \") -> \").concat(y, \" {\\n    var input_indices: \").concat(e1.type.indices, \" = output_indices;\\n    return colCubicInterpolation(input_indices, output_indices);\\n  }\\n    \");\n    }, Hh = (e1, t, r, n, o)=>{\n        let [a, d, l, p, m] = r.length === 3 ? [\n            -1,\n            0,\n            1,\n            2,\n            -1\n        ] : [\n            0,\n            2,\n            3,\n            4,\n            1\n        ], u = e1.type.value;\n        return \"\\n    fn getInputValue(batch: u32, channel: u32, depth:u32, height: u32, width: u32) -> \".concat(u, \" {\\n      var input_indices: \").concat(e1.type.indices, \";\\n      \").concat(e1.indicesSet(\"input_indices\", d, \"max(0, min(depth, \".concat(r[d], \" - 1))\")), \";\\n      \").concat(e1.indicesSet(\"input_indices\", l, \"max(0, min(height, \".concat(r[l], \" - 1))\")), \";\\n      \").concat(e1.indicesSet(\"input_indices\", p, \"max(0, min(width, \".concat(r[p], \" - 1))\")), \";\\n      \").concat(El(e1, m, a, 3), \"\\n      return \").concat(e1.getByIndices(\"input_indices\"), \";\\n    }\\n\\n    fn trilinearInterpolation(output_indices: \").concat(t.type.indices, \") -> \").concat(u, \" {\\n      var originalIndices = calculateOriginalIndicesFromOutputIndices(output_indices);\\n      var depth:\").concat(u, \" = originalIndices[\").concat(d, \"];\\n      var height:\").concat(u, \" = originalIndices[\").concat(l, \"];\\n      var width:\").concat(u, \" = originalIndices[\").concat(p, \"];\\n      \").concat(n ? \"if (depth < 0 || depth > (\".concat(r[d], \" - 1) || height < 0 || height > (\").concat(r[l], \" - 1) || width < 0 || (width > \").concat(r[p], \" - 1)) {\\n      return \").concat(o, \";\\n        }\") : \"\", \";\\n\\n    depth = max(0, min(depth, \").concat(r[d], \" - 1));\\n      height = max(0, min(height, \").concat(r[l], \" - 1));\\n      width = max(0, min(width, \").concat(r[p], \" - 1));\\n      var depth1: u32 = u32(depth);\\n      var height1: u32 = u32(height);\\n      var width1: u32 = u32(width);\\n      var depth2: u32 = u32(depth + 1);\\n      var height2: u32 = u32(height + 1);\\n      var width2: u32 = u32(width + 1);\\n      var channel: u32 = \").concat(r.length > 3 ? \"u32(originalIndices[\".concat(m, \"])\") : \"0\", \";\\n      var batch: u32 =  \").concat(r.length > 3 ? \"u32(originalIndices[\".concat(a, \"])\") : \"0\", \";\\n\\n      var x111: \").concat(u, \" = getInputValue(batch, channel, depth1, height1, width1);\\n      var x112: \").concat(u, \" = getInputValue(batch, channel, depth1, height1, width2);\\n      var x121: \").concat(u, \" = getInputValue(batch, channel, depth1, height2, width1);\\n      var x122: \").concat(u, \" = getInputValue(batch, channel, depth1, height2, width2);\\n      var x211: \").concat(u, \" = getInputValue(batch, channel, depth2, height1, width1);\\n      var x212: \").concat(u, \" = getInputValue(batch, channel, depth2, height1, width2);\\n      var x221: \").concat(u, \" = getInputValue(batch, channel, depth2, height2, width1);\\n      var x222: \").concat(u, \" = getInputValue(batch, channel, depth2, height2, width2);\\n      var dx1: \").concat(u, \" = abs(depth - \").concat(u, \"(depth1));\\n      var dx2: \").concat(u, \" = abs(\").concat(u, \"(depth2) - depth);\\n      var dy1: \").concat(u, \" = abs(height - \").concat(u, \"(height1));\\n      var dy2: \").concat(u, \" = abs(\").concat(u, \"(height2) - height);\\n      var dz1: \").concat(u, \" = abs(width - \").concat(u, \"(width1));\\n      var dz2: \").concat(u, \" = abs(\").concat(u, \"(width2) - width);\\n      if (depth1 == depth2) {\\n        dx1 = 0.5;\\n        dx2 = 0.5;\\n      }\\n      if (height1 == height2) {\\n        dy1 = 0.5;\\n        dy2 = 0.5;\\n      }\\n      if (width1 == width2) {\\n        dz1 = 0.5;\\n        dz2 = 0.5;\\n      }\\n      return (x111 * dx2 * dy2 * dz2 + x112 * dx2 * dy2 * dz1 + x121 * dx2 * dy1 *dz2 + x122 * dx2 * dy1 * dz1 +\\n              x211 * dx1 * dy2 * dz2 + x212 * dx1 * dy2 * dz1 + x221 * dx1 * dy1 *dz2 + x222 * dx1 * dy1 * dz1);\\n    }\");\n    }, Fh = (e1, t, r, n, o, i)=>{\n        let a = e1.dims, d = Mh(i, t.axes, a.length), l = Rh(a, n, o, t.axes), p = n.slice();\n        n.length === 0 && (p = a.map((v, S)=>v === 0 ? 1 : l[S] / v), t.keepAspectRatioPolicy !== \"stretch\" && (l = Uh(a, p, t)));\n        let m = M(\"output\", e1.dataType, l.length), u = E(\"input\", e1.dataType, a.length), h = C.size(l), _ = a.length === l.length && a.every((v, S)=>v === l[S]), y = t.coordinateTransformMode === \"tf_crop_and_resize\", g = t.extrapolationValue, x = u.type.value, $ = (v)=>\"\\n      \".concat(_ ? \"\" : \"\\n      \".concat(Dh(t.coordinateTransformMode, x), \";\\n      \").concat((()=>{\n                switch(t.mode){\n                    case \"nearest\":\n                        return \"\\n              \".concat(Wh(u, a), \";\\n              \").concat(Bh(t.nearestMode, r, x), \";\\n              \").concat(Vh(u, m, a, l, p.length, d.length, y), \";\\n              \");\n                    case \"linear\":\n                        return \"\\n              \".concat(Nh(m, a, l, p.length, d.length), \";\\n              \").concat((()=>{\n                            if (a.length === 2 || a.length === 4) return \"\".concat(Lh(u, m, a, y, g));\n                            if (a.length === 3 || a.length === 5) return \"\".concat(Hh(u, m, a, y, g));\n                            throw Error(\"Linear mode only supports input dims 2, 3, 4 and 5 are supported in linear mode.\");\n                        })(), \";\\n            \");\n                    case \"cubic\":\n                        return \"\\n            \".concat((()=>{\n                            if (a.length === 2 || a.length === 4) return \"\".concat(Gh(u, m, a, l, p, d, t.cubicCoeffA, y, t.extrapolationValue, t.excludeOutside));\n                            throw Error(\"Cubic mode only supports input dims 2 and 4 are supported in linear mode.\");\n                        })(), \";\\n            \");\n                    default:\n                        throw Error(\"Invalid resize mode\");\n                }\n            })(), \";\\n      \"), \"\\n      \").concat(v.registerUniform(\"output_size\", \"u32\").registerUniform(\"scales\", \"f32\", p.length).registerUniform(\"roi\", \"f32\", d.length).declareVariables(u, m), \"\\n      \").concat(v.mainStart(), \"\\n        \").concat(v.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\"), \"\\n        \").concat(_ ? \"output[global_idx] = input[global_idx];\" : \"\\n        let output_indices = \".concat(m.offsetToIndices(\"global_idx\"), \";\\n        var input_indices: \").concat(u.type.indices, \";\\n        \").concat((()=>{\n                switch(t.mode){\n                    case \"nearest\":\n                        return \"input_indices = calculateInputIndicesFromOutputIndices(output_indices);\\n                if (checkInputIndices(input_indices)) {\\n                  output[global_idx] = \".concat(u.getByIndices(\"input_indices\"), \";\\n                } else {\\n                  output[global_idx] = \").concat(t.extrapolationValue, \";\\n                }\");\n                    case \"linear\":\n                        return \"output[global_idx] = \".concat(a.length === 2 || a.length === 4 ? \"bilinearInterpolation\" : \"trilinearInterpolation\", \"(output_indices);\");\n                    case \"cubic\":\n                        return \"output[global_idx] = bicubicInterpolation(output_indices);\";\n                    default:\n                        throw Error(\"Unsupported resize mode: \".concat(t.mode));\n                }\n            })(), \";\\n\"), \"\\n      }\");\n        return {\n            name: \"Resize\",\n            shaderCache: {\n                hint: \"\".concat(t.cacheKey, \"|\").concat(r, \"|\").concat(p.length > 0 ? p : \"\", \"|\").concat(o.length > 0 ? o : \"\", \"|\").concat(d.length > 0 ? d : \"\", \"|\").concat(_, \"|\").concat(a),\n                inputDependencies: [\n                    \"rank\"\n                ]\n            },\n            getShaderSource: $,\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: l,\n                            dataType: e1.dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(h / 64)\n                    },\n                    programUniforms: [\n                        {\n                            type: 12,\n                            data: h\n                        },\n                        {\n                            type: 1,\n                            data: p\n                        },\n                        {\n                            type: 1,\n                            data: d\n                        },\n                        ...N(a, l)\n                    ]\n                })\n        };\n    }, qh = (e1)=>{\n        let t = e1.customDataBuffer;\n        return new Uint32Array(t, t.byteOffset, 1)[0];\n    }, Pl = (e1, t)=>{\n        let r = [], n = [], o = [], i = qh(e1);\n        if (t.antialias !== 0) throw Error(\"Only default value (0) for Antialias attribute is supported\");\n        Oh(e1.inputs, t, i, r, n, o), e1.compute(Fh(e1.inputs[0], t, i, r, n, o), {\n            inputs: [\n                0\n            ]\n        });\n    }, zl = (e1)=>{\n        let t = e1.antialias, r = e1.axes, n = e1.coordinateTransformMode, o = e1.cubicCoeffA, i = e1.excludeOutside !== 0, a = e1.extrapolationValue, d = e1.keepAspectRatioPolicy, l = e1.mode, p = e1.nearestMode === \"\" ? \"simple\" : e1.nearestMode;\n        return re({\n            antialias: t,\n            axes: r,\n            coordinateTransformMode: n,\n            cubicCoeffA: o,\n            excludeOutside: i,\n            extrapolationValue: a,\n            keepAspectRatioPolicy: d,\n            mode: l,\n            nearestMode: p\n        });\n    };\n});\nvar Kh, jh, Dl, Bl = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    Kh = (e1, t)=>{\n        let [r, n, o, i] = e1, { numHeads: a, rotaryEmbeddingDim: d } = t;\n        if (r.dims.length !== 3 && r.dims.length !== 4) throw new Error(\"Input 'x' is expected to have 3 or 4 dimensions, got \".concat(r.dims.length));\n        if (!C.areEqual(n.dims, []) && !C.areEqual(n.dims, [\n            1\n        ]) && n.dims.length !== 2) throw new Error(\"Input 'position_ids' is expected to have 0, 1, or 2 dimensions, got \".concat(n.dims.length));\n        if (o.dims.length !== 2) throw new Error(\"Input 'cos_cache' is expected to have 2 dimensions, got \".concat(o.dims.length));\n        if (i.dims.length !== 2) throw new Error(\"Input 'sin_cache' is expected to have 2 dimensions, got \".concat(i.dims.length));\n        if (!C.areEqual(o.dims, i.dims)) throw new Error(\"Inputs 'cos_cache' and 'sin_cache' are expected to have the same shape\");\n        if (d > 0 && a === 0) throw new Error(\"num_heads must be provided if rotary_embedding_dim is specified\");\n        let l = r.dims[0], p = r.dims[r.dims.length - 2], m = o.dims[0], u = C.sizeFromDimension(r.dims, 1) / p, h = d === 0 ? o.dims[1] * 2 : u / a;\n        if (d > h) throw new Error(\"rotary_embedding_dim must be less than or equal to head_size\");\n        if (n.dims.length === 2) {\n            if (l !== n.dims[0]) throw new Error(\"Input 'position_ids' dimension 0 should be of size batch_size, got \".concat(n.dims[0]));\n            if (p !== n.dims[1]) throw new Error(\"Input 'position_ids' dimension 1 should be of size sequence_length, got \".concat(n.dims[1]));\n        }\n        if (h / 2 !== o.dims[1] && d / 2 !== o.dims[1]) throw new Error(\"Input 'cos_cache' dimension 1 should be same as head_size / 2 or rotary_embedding_dim / 2, got \".concat(o.dims[1]));\n        if (p > m) throw new Error(\"Updating cos_cache and sin_cache in RotaryEmbedding is not currently supported\");\n    }, jh = (e1, t)=>{\n        let { interleaved: r, numHeads: n, rotaryEmbeddingDim: o, scale: i } = t, a = e1[0].dims[0], d = C.sizeFromDimension(e1[0].dims, 1), l = e1[0].dims[e1[0].dims.length - 2], p = d / l, m = e1[2].dims[1], u = o === 0 ? m * 2 : p / n, h = new Array(a, l, p / u, u - m), _ = C.computeStrides(h), y = [\n            {\n                type: 1,\n                data: i\n            },\n            {\n                type: 12,\n                data: h\n            },\n            {\n                type: 12,\n                data: _\n            },\n            ...e1[0].dims.length === 3 ? new Array({\n                type: 12,\n                data: [\n                    d,\n                    p,\n                    u,\n                    1\n                ]\n            }) : [],\n            ...e1[0].dims.length === 4 ? new Array({\n                type: 12,\n                data: [\n                    d,\n                    u,\n                    l * u,\n                    1\n                ]\n            }) : [],\n            ...N(e1[0].dims, e1[1].dims, e1[2].dims, e1[3].dims, e1[0].dims)\n        ], g = (x)=>{\n            let $ = E(\"input\", e1[0].dataType, e1[0].dims.length), v = E(\"position_ids\", e1[1].dataType, e1[1].dims.length), S = E(\"cos_cache\", e1[2].dataType, e1[2].dims.length), T = E(\"sin_cache\", e1[3].dataType, e1[3].dims.length), A = M(\"output\", e1[0].dataType, e1[0].dims.length);\n            return x.registerUniforms([\n                {\n                    name: \"scale\",\n                    type: \"f32\"\n                },\n                {\n                    name: \"global_shape\",\n                    type: \"u32\",\n                    length: h.length\n                },\n                {\n                    name: \"global_strides\",\n                    type: \"u32\",\n                    length: _.length\n                },\n                {\n                    name: \"input_output_strides\",\n                    type: \"u32\",\n                    length: _.length\n                }\n            ]), \"\\n        \".concat(x.declareVariables($, v, S, T, A), \"\\n\\n        \").concat(x.mainStart(kt), \"\\n          let half_rotary_emb_dim = uniforms.\").concat(S.name, \"_shape[1];\\n          let bsnh = global_idx / uniforms.global_strides % uniforms.global_shape;\\n          let size = uniforms.global_shape[0] * uniforms.global_strides[0];\\n          \").concat(x.guardAgainstOutOfBoundsWorkgroupSizes(\"size\"), \"\\n\\n          if (bsnh[3] < half_rotary_emb_dim) {\\n            let position_ids_idx =\\n                \").concat(v.broadcastedIndicesToOffset(\"bsnh.xy\", M(\"\", v.type.tensor, 2)), \";\\n            let position_id =\\n                u32(\").concat(v.getByOffset(\"position_ids_idx\"), \") + select(0, bsnh[1], position_ids_idx == 0);\\n            let i = dot(bsnh, uniforms.input_output_strides) + select(0, bsnh[3], \").concat(r, \");\\n            let j = i + select(half_rotary_emb_dim, 1, \").concat(r, \");\\n            let re = \").concat($.getByOffset(\"i\"), \" * \").concat(S.get(\"position_id\", \"bsnh[3]\"), \" -\\n                \").concat($.getByOffset(\"j\"), \" * \").concat(T.get(\"position_id\", \"bsnh[3]\"), \";\\n            \").concat(A.setByOffset(\"i\", \"re\"), \"\\n            let im = \").concat($.getByOffset(\"i\"), \" * \").concat(T.get(\"position_id\", \"bsnh[3]\"), \" +\\n                \").concat($.getByOffset(\"j\"), \" * \").concat(S.get(\"position_id\", \"bsnh[3]\"), \";\\n            \").concat(A.setByOffset(\"j\", \"im\"), \"\\n          } else {\\n            let k = dot(bsnh, uniforms.input_output_strides) + half_rotary_emb_dim;\\n            \").concat(A.setByOffset(\"k\", $.getByOffset(\"k\")), \"\\n          }\\n        }\");\n        };\n        return {\n            name: \"RotaryEmbedding\",\n            shaderCache: {\n                hint: re({\n                    interleaved: r\n                }).cacheKey,\n                inputDependencies: [\n                    \"rank\",\n                    \"rank\",\n                    \"rank\",\n                    \"rank\"\n                ]\n            },\n            getShaderSource: g,\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: e1[0].dims,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(C.size(h) / kt)\n                    },\n                    programUniforms: y\n                })\n        };\n    }, Dl = (e1, t)=>{\n        Kh(e1.inputs, t), e1.compute(jh(e1.inputs, t));\n    };\n});\nvar Yh, Zh, Ml, Rl = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    ae();\n    Yh = (e1)=>{\n        if (!e1 || e1.length < 3) throw new Error(\"layerNorm requires at least 3 inputs.\");\n        let t = e1[0], r = e1[1], n = e1[2];\n        if (t.dataType !== r.dataType || t.dataType !== n.dataType) throw new Error(\"All inputs must have the same data type\");\n        if (t.dims.length !== 3 && t.dims.length !== 2) throw new Error(\"Input must be 2D or 3D\");\n        if (r.dims.length !== 3 && r.dims.length !== 2) throw new Error(\"Skip must be 2D or 3D\");\n        let o = t.dims[t.dims.length - 1], i = t.dims[t.dims.length - 2];\n        if (r.dims[r.dims.length - 1] !== o) throw new Error(\"Skip must have the same hidden size as input\");\n        if (r.dims[r.dims.length - 2] !== i) throw new Error(\"Skip must have the same sequence length as input\");\n        if (n.dims.length !== 1) throw new Error(\"Gamma must be 1D\");\n        if (n.dims[n.dims.length - 1] !== o) throw new Error(\"Gamma must have the same hidden size as input\");\n        if (e1.length > 3) {\n            let a = e1[3];\n            if (a.dims.length !== 1) throw new Error(\"Beta must be 1D\");\n            if (a.dims[a.dims.length - 1] !== o) throw new Error(\"Beta must have the same hidden size as input\");\n        }\n        if (e1.length > 4) {\n            let a = e1[4];\n            if (a.dims.length !== 1) throw new Error(\"Bias must be 1D\");\n            if (a.dims[a.dims.length - 1] !== o) throw new Error(\"Bias must have the same hidden size as input\");\n        }\n    }, Zh = (e1, t, r, n)=>{\n        let o = t.simplified, i = e1[0].dims, a = C.size(i), d = i, l = a, p = i.slice(-1)[0], m = n ? i.slice(0, -1).concat(1) : [], u = !o && e1.length > 3, h = e1.length > 4, _ = n && r > 1, y = n && r > 2, g = r > 3, x = 64, $ = me(p), v = [\n            {\n                type: 12,\n                data: l\n            },\n            {\n                type: 12,\n                data: $\n            },\n            {\n                type: 12,\n                data: p\n            },\n            {\n                type: 1,\n                data: t.epsilon\n            }\n        ], S = (A)=>{\n            let k = [\n                {\n                    name: \"output_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"components\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"hidden_size\",\n                    type: \"u32\"\n                },\n                {\n                    name: \"epsilon\",\n                    type: \"f32\"\n                }\n            ], P = [\n                E(\"x\", e1[0].dataType, e1[0].dims, $),\n                E(\"skip\", e1[1].dataType, e1[1].dims, $),\n                E(\"gamma\", e1[2].dataType, e1[2].dims, $)\n            ];\n            u && P.push(E(\"beta\", e1[3].dataType, e1[3].dims, $)), h && P.push(E(\"bias\", e1[4].dataType, e1[4].dims, $)), P.push(M(\"output\", e1[0].dataType, d, $)), _ && P.push(M(\"mean_output\", 1, m)), y && P.push(M(\"inv_std_output\", 1, m)), g && P.push(M(\"input_skip_bias_sum\", e1[0].dataType, d, $));\n            let D = _e(e1[0].dataType), R = _e(1, $);\n            return \"\\n\\n      \".concat(A.registerUniforms(k).declareVariables(...P), \"\\n      var<workgroup> sum_shared : array<\").concat(R, \", \").concat(x, \">;\\n      var<workgroup> sum_squared_shared : array<\").concat(R, \", \").concat(x, \">;\\n\\n      \").concat(A.mainStart([\n                x,\n                1,\n                1\n            ]), \"\\n        let ix = local_id.x;\\n        let iy = global_id.x / \").concat(x, \";\\n\\n        let hidden_size_vectorized: u32 = uniforms.hidden_size / uniforms.components;\\n        var stride = hidden_size_vectorized / \").concat(x, \";\\n        let offset = ix * stride + iy * hidden_size_vectorized;\\n        let offset1d = stride * ix;\\n        if (ix == \").concat(x - 1, \") {\\n          stride = hidden_size_vectorized - stride * ix;\\n        }\\n        for (var i: u32 = 0; i < stride; i++) {\\n          let skip_value = skip[offset + i];\\n          let bias_value = \").concat(h ? \"bias[offset1d + i]\" : D + \"(0.0)\", \";\\n          let input_value = x[offset + i];\\n          let value = input_value + skip_value + bias_value;\\n          \").concat(g ? \"input_skip_bias_sum[offset + i] = value;\" : \"\", \"\\n          output[offset + i] = value;\\n          let f32_value = \").concat(Et(D, $, \"value\"), \";\\n          sum_shared[ix] += f32_value;\\n          sum_squared_shared[ix] += f32_value * f32_value;\\n        }\\n        workgroupBarrier();\\n\\n        var reduce_size : u32 = \").concat(x, \";\\n        for (var curr_size = reduce_size >> 1;  curr_size > 0; curr_size = reduce_size >> 1) {\\n          reduce_size = curr_size + (reduce_size & 1);\\n          if (ix < curr_size) {\\n            sum_shared[ix] += sum_shared[ix + reduce_size];\\n            sum_squared_shared[ix] += sum_squared_shared[ix + reduce_size];\\n          }\\n          workgroupBarrier();\\n        }\\n\\n        let sum = sum_shared[0];\\n        let square_sum = sum_squared_shared[0];\\n        let mean = \").concat(Fe(\"sum\", $), \" / f32(uniforms.hidden_size);\\n        let inv_std_dev = inverseSqrt(\").concat(Fe(\"square_sum\", $), \" / f32(uniforms.hidden_size) \").concat(o ? \"\" : \"- mean * mean\", \" + uniforms.epsilon);\\n        \").concat(_ ? \"mean_output[global_idx] = mean;\" : \"\", \"\\n        \").concat(y ? \"inv_std_output[global_idx] = inv_std_dev;\" : \"\", \"\\n\\n        for (var i: u32 = 0; i < stride; i++) {\\n          output[offset + i] = (output[offset + i] \").concat(o ? \"\" : \"- \".concat(D, \"(mean)\"), \") *\\n            \").concat(D, \"(inv_std_dev) * gamma[offset1d + i]\\n            \").concat(u ? \"+ beta[offset1d + i]\" : \"\", \";\\n        }\\n      }\");\n        }, T = [\n            {\n                dims: d,\n                dataType: e1[0].dataType\n            }\n        ];\n        return r > 1 && T.push({\n            dims: m,\n            dataType: 1\n        }), r > 2 && T.push({\n            dims: m,\n            dataType: 1\n        }), r > 3 && T.push({\n            dims: i,\n            dataType: e1[0].dataType\n        }), {\n            name: \"SkipLayerNormalization\",\n            shaderCache: {\n                hint: \"\".concat($, \";\").concat(_, \";\").concat(y, \";\").concat(g),\n                inputDependencies: e1.map((A, k)=>\"type\")\n            },\n            getShaderSource: S,\n            getRunData: ()=>({\n                    outputs: T,\n                    dispatchGroup: {\n                        x: Math.ceil(l / p)\n                    },\n                    programUniforms: v\n                })\n        };\n    }, Ml = (e1, t)=>{\n        Yh(e1.inputs);\n        let n = [\n            0\n        ];\n        e1.outputCount > 1 && n.push(-3), e1.outputCount > 2 && n.push(-3), e1.outputCount > 3 && n.push(3), e1.compute(Zh(e1.inputs, t, e1.outputCount, !1), {\n            outputs: n\n        });\n    };\n});\nvar Qh, rn, Xh, Ul, Jh, eg, Nl, Vl, Wl = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    ae();\n    Qh = (e1, t)=>{\n        if (!e1 || e1.length < 1) throw new Error(\"too few inputs\");\n        if (t.axes.length !== 0) {\n            if (t.axes.length !== t.starts.length || t.axes.length !== t.ends.length) throw new Error(\"axes, starts and ends must have the same length\");\n        } else if (t.starts.length !== t.ends.length) throw new Error(\"starts and ends must have the same length\");\n        e1.slice(1).forEach((r, n)=>{\n            if (e1[n + 1].dataType !== 6 && e1[n + 1].dataType !== 7) throw new Error(\"Input \".concat(n, \" must be an array of int32 or int64\"));\n        });\n    }, rn = (e1, t)=>{\n        let r = [];\n        if (e1.length > t) if (e1[t].dataType === 7) e1[t].getBigInt64Array().forEach((n)=>r.push(Number(n)));\n        else if (e1[t].dataType === 6) e1[t].getInt32Array().forEach((n)=>r.push(Number(n)));\n        else throw new Error(\"Input \".concat(t, \" must be an array of int32 or int64\"));\n        return r;\n    }, Xh = (e1, t)=>{\n        if (e1.length > 1) {\n            let r = rn(e1, 1), n = rn(e1, 2), o = rn(e1, 3);\n            return o.length === 0 && (o = [\n                ...Array(e1[0].dims.length).keys()\n            ]), re({\n                starts: r,\n                ends: n,\n                axes: o\n            });\n        } else return t;\n    }, Ul = (e1, t, r, n, o)=>{\n        let i = e1;\n        return e1 < 0 && (i += r[n[t]]), o[t] < 0 ? Math.max(0, Math.min(i, r[n[t]] - 1)) : Math.max(0, Math.min(i, r[n[t]]));\n    }, Jh = (e1, t, r)=>\"fn calculateInputIndices(output_indices: \".concat(t.type.indices, \") -> \").concat(e1.type.indices, \" {\\n          var input_indices: \").concat(e1.type.indices, \";\\n          var carry = 0u;\\n          for (var i = \").concat(r.length, \"; i >= 0; i--) {\\n            let input_shape_i = \").concat(F(\"uniforms.input_shape\", \"i\", r.length), \";\\n            let steps_i = \").concat(F(\"uniforms.steps\", \"i\", r.length), \";\\n            let signs_i = \").concat(F(\"uniforms.signs\", \"i\", r.length), \";\\n            let starts_i = \").concat(F(\"uniforms.starts\", \"i\", r.length), \";\\n            var output_index = \").concat(t.indicesGet(\"output_indices\", \"i\"), \";\\n            var input_index = output_index * steps_i + starts_i + carry;\\n            carry = input_index / input_shape_i;\\n            input_index = input_index % input_shape_i;\\n            if (signs_i < 0) {\\n              input_index = input_shape_i - input_index - 1u + starts_i;\\n            }\\n            \").concat(e1.indicesSet(\"input_indices\", \"i\", \"input_index\"), \";\\n          }\\n          return input_indices;\\n      }\"), eg = (e1, t)=>{\n        let r = e1[0].dims, n = C.size(r), o = t.axes.length > 0 ? C.normalizeAxes(t.axes, r.length) : [\n            ...Array(r.length).keys()\n        ], i = rn(e1, 4);\n        i.forEach(($)=>$ !== 0 || (()=>{\n                throw new Error(\"step cannot be 0\");\n            })), i.length === 0 && (i = Array(o.length).fill(1));\n        let a = t.starts.map(($, v)=>Ul($, v, r, o, i)), d = t.ends.map(($, v)=>Ul($, v, r, o, i));\n        if (o.length !== a.length || o.length !== d.length) throw new Error(\"start, ends and axes should have the same number of elements\");\n        if (o.length !== r.length) for(let $ = 0; $ < r.length; ++$)o.includes($) || (a.splice($, 0, 0), d.splice($, 0, r[$]), i.splice($, 0, 1));\n        let l = i.map(($)=>Math.sign($));\n        i.forEach(($, v, S)=>{\n            if ($ < 0) {\n                let T = (d[v] - a[v]) / $, A = a[v], k = A + T * i[v];\n                a[v] = k, d[v] = A, S[v] = -$;\n            }\n        });\n        let p = r.slice(0);\n        o.forEach(($, v)=>{\n            p[$] = Math.ceil((d[$] - a[$]) / i[$]);\n        });\n        let m = {\n            dims: p,\n            dataType: e1[0].dataType\n        }, u = M(\"output\", e1[0].dataType, p.length), h = E(\"input\", e1[0].dataType, e1[0].dims.length), _ = C.size(p), y = [\n            {\n                name: \"outputSize\",\n                type: \"u32\"\n            },\n            {\n                name: \"starts\",\n                type: \"u32\",\n                length: a.length\n            },\n            {\n                name: \"signs\",\n                type: \"i32\",\n                length: l.length\n            },\n            {\n                name: \"steps\",\n                type: \"u32\",\n                length: i.length\n            }\n        ], g = [\n            {\n                type: 12,\n                data: _\n            },\n            {\n                type: 12,\n                data: a\n            },\n            {\n                type: 6,\n                data: l\n            },\n            {\n                type: 12,\n                data: i\n            },\n            ...N(e1[0].dims, p)\n        ], x = ($)=>\"\\n      \".concat($.registerUniforms(y).declareVariables(h, u), \"\\n        \").concat(Jh(h, u, r), \"\\n        \").concat($.mainStart(), \"\\n          \").concat($.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.outputSize\"), \"\\n          let output_indices = \").concat(u.offsetToIndices(\"global_idx\"), \";\\n          let input_indices = calculateInputIndices(output_indices);\\n          \").concat(u.setByOffset(\"global_idx\", h.getByIndices(\"input_indices\")), \"\\n      }\");\n        return {\n            name: \"Slice\",\n            shaderCache: {\n                hint: \"\".concat(l.length, \"_\").concat(a.length, \"_\").concat(i.length),\n                inputDependencies: [\n                    \"rank\"\n                ]\n            },\n            getShaderSource: x,\n            getRunData: ()=>({\n                    outputs: [\n                        m\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(n / 64)\n                    },\n                    programUniforms: g\n                })\n        };\n    }, Nl = (e1, t)=>{\n        Qh(e1.inputs, t);\n        let r = Xh(e1.inputs, t);\n        e1.compute(eg(e1.inputs, r), {\n            inputs: [\n                0\n            ]\n        });\n    }, Vl = (e1)=>{\n        let t = e1.starts, r = e1.ends, n = e1.axes;\n        return re({\n            starts: t,\n            ends: r,\n            axes: n\n        });\n    };\n});\nvar tg, rg, Ll, Gl, Hl = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    Se();\n    dt();\n    ae();\n    tg = (e1)=>{\n        if (!e1 || e1.length !== 1) throw new Error(\"Softmax op requires 1 input.\");\n    }, rg = (e1, t)=>{\n        let r = e1.inputs[0], n = r.dims, o = C.size(n), i = n.length, a = C.normalizeAxis(t.axis, i), d = a < n.length - 1, l, p = [];\n        d ? (p = Array.from({\n            length: i\n        }, (P, D)=>D), p[a] = i - 1, p[i - 1] = a, l = e1.compute(Pe(r, p), {\n            inputs: [\n                r\n            ],\n            outputs: [\n                -1\n            ]\n        })[0]) : l = r;\n        let m = l.dims, u = m[i - 1], h = o / u, _ = me(u), y = u / _, g = 64;\n        h === 1 && (g = 256);\n        let x = (P, D)=>D === 4 ? \"max(max(\".concat(P, \".x, \").concat(P, \".y), max(\").concat(P, \".z, \").concat(P, \".w))\") : D === 2 ? \"max(\".concat(P, \".x, \").concat(P, \".y)\") : D === 3 ? \"max(max(\".concat(P, \".x, \").concat(P, \".y), \").concat(P, \".z)\") : P, $ = E(\"x\", l.dataType, l.dims, _), v = M(\"result\", l.dataType, l.dims, _), S = $.type.value, T = _e(l.dataType) === \"f32\" ? \"var threadMax = \".concat(S, \"(-3.402823e+38f);\") : \"var threadMax = \".concat(S, \"(-65504.0h);\"), A = (P)=>\"\\n      var<workgroup> rowMaxShared : \".concat(S, \";\\n      var<workgroup> rowSumShared : \").concat(S, \";\\n      var<workgroup> threadShared : array<\").concat(S, \", \").concat(g, \">;\\n\\n      fn getValue(row: i32, col: i32, row_stride: i32) -> \").concat(S, \" {\\n        let index = row * row_stride + col;\\n        return x[index];\\n      }\\n\\n      fn setValue(row: i32, col: i32, row_stride: i32, value: \").concat(S, \") {\\n        let index = row * row_stride + col;\\n        result[index] = value;\\n      }\\n      \").concat(P.registerUniform(\"packedCols\", \"i32\").declareVariables($, v), \"\\n      \").concat(P.mainStart(g), \"\\n        let gindex = i32(global_idx);\\n        let lindex = i32(local_idx);\\n        const wg = \").concat(g, \";\\n        let row = gindex / wg;\\n        let cols = uniforms.packedCols;\\n        let row_stride : i32 = uniforms.packedCols;\\n\\n        // find the rows max\\n        \").concat(T, \"\\n        for (var col = lindex; col < cols; col += wg) {\\n          let value = getValue(row, col, row_stride);\\n          threadMax = max(threadMax, value);\\n        }\\n        if (lindex < cols) {\\n          threadShared[lindex] = threadMax;\\n        }\\n        workgroupBarrier();\\n\\n        var reduceSize = min(cols, wg);\\n        for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {\\n          reduceSize = currSize + (reduceSize & 1);\\n          if (lindex < currSize) {\\n            threadShared[lindex] = max(threadShared[lindex], threadShared[lindex + reduceSize]);\\n          }\\n          workgroupBarrier();\\n        }\\n        if (lindex == 0) {\\n          rowMaxShared = \").concat(S, \"(\").concat(x(\"threadShared[0]\", _), \");\\n        }\\n        workgroupBarrier();\\n\\n        // find the rows sum\\n        var threadSum = \").concat(S, \"(0.0);\\n        for (var col = lindex; col < cols; col += wg) {\\n          let subExp = exp(getValue(row, col, row_stride) - rowMaxShared);\\n          threadSum += subExp;\\n        }\\n        threadShared[lindex] = threadSum;\\n        workgroupBarrier();\\n\\n        for (var currSize = wg >> 1;  currSize > 0; currSize = currSize >> 1) {\\n          if (lindex < currSize) {\\n            threadShared[lindex] = threadShared[lindex] + threadShared[lindex + currSize];\\n          }\\n          workgroupBarrier();\\n        }\\n        if (lindex == 0) {\\n          rowSumShared = \").concat(S, \"(\").concat(Fe(\"threadShared[0]\", _), \");\\n        }\\n        workgroupBarrier();\\n\\n        // calculate final value for each element in the row\\n        for (var col = lindex; col < cols; col += wg) {\\n          let value = exp(getValue(row, col, row_stride) - rowMaxShared) / rowSumShared;\\n          setValue(row, col, row_stride, value);\\n        }\\n      }\"), k = e1.compute({\n            name: \"Softmax\",\n            shaderCache: {\n                hint: \"\".concat(_, \";\").concat(g),\n                inputDependencies: [\n                    \"type\"\n                ]\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: m,\n                            dataType: l.dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: h\n                    },\n                    programUniforms: [\n                        {\n                            type: 6,\n                            data: y\n                        }\n                    ]\n                }),\n            getShaderSource: A\n        }, {\n            inputs: [\n                l\n            ],\n            outputs: [\n                d ? -1 : 0\n            ]\n        })[0];\n        d && e1.compute(Pe(k, p), {\n            inputs: [\n                k\n            ]\n        });\n    }, Ll = (e1, t)=>{\n        tg(e1.inputs), rg(e1, t);\n    }, Gl = (e1)=>re({\n            axis: e1.axis\n        });\n});\nvar Fl, ng, og, ig, ql, Kl = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    ae();\n    Fl = (e1)=>Array.from(e1.getBigInt64Array(), Number), ng = (e1)=>{\n        if (!e1 || e1.length !== 2) throw new Error(\"Tile requires 2 inputs.\");\n        if (e1[0].dataType !== 1 && e1[0].dataType !== 10 && e1[0].dataType !== 6 && e1[0].dataType !== 12) throw new Error(\"Tile only support float, float16, int32, and uint32 data types\");\n        if (e1[1].dataType !== 7) throw new Error(\"Tile `repeats` input should be of int64 data type\");\n        if (e1[1].dims.length !== 1) throw new Error(\"Tile `repeats` input should be 1-D\");\n        if (Fl(e1[1]).length !== e1[0].dims.length) throw new Error(\"Tile `repeats` input should have same number of elements as rank of input data tensor\");\n    }, og = (e1, t)=>{\n        let r = [];\n        for(let n = 0; n < e1.length; ++n)r.push(e1[n] * t[n]);\n        return r;\n    }, ig = (e1, t)=>{\n        let r = e1[0].dims, n = t !== null && t !== void 0 ? t : Fl(e1[1]), o = og(r, n), i = C.size(o), a = e1[0].dataType, d = E(\"input\", a, r.length), l = M(\"output\", a, o.length), p = (m)=>\"\\n      const inputShape = \".concat(d.indices(...r), \";\\n      \").concat(m.registerUniform(\"output_size\", \"u32\").declareVariables(d, l), \"\\n      \").concat(m.mainStart(), \"\\n      \").concat(m.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.output_size\"), \"\\n      let output_indices = \").concat(l.offsetToIndices(\"global_idx\"), \";\\n      var input_indices: \").concat(d.type.indices, \";\\n      for (var i = 0; i < \").concat(r.length, \"; i++) {\\n        let input_dim_i = \").concat(d.indicesGet(\"uniforms.input_shape\", \"i\"), \";\\n        let input_dim_value = \").concat(l.indicesGet(\"output_indices\", \"i\"), \"  % input_dim_i;\\n\\n        \").concat(d.indicesSet(\"input_indices\", \"i\", \"input_dim_value\"), \"\\n      }\\n      \").concat(l.setByOffset(\"global_idx\", d.getByIndices(\"input_indices\")), \"\\n    }\");\n        return {\n            name: \"Tile\",\n            shaderCache: {\n                hint: \"\".concat(n),\n                inputDependencies: [\n                    \"rank\"\n                ]\n            },\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: o,\n                            dataType: e1[0].dataType\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(i / 64)\n                    },\n                    programUniforms: [\n                        {\n                            type: 12,\n                            data: i\n                        },\n                        ...N(e1[0].dims, o)\n                    ]\n                }),\n            getShaderSource: p\n        };\n    }, ql = (e1)=>{\n        ng(e1.inputs), e1.compute(ig(e1.inputs), {\n            inputs: [\n                0\n            ]\n        });\n    };\n});\nvar ag, sg, jl, Yl = U(()=>{\n    \"use strict\";\n    te();\n    oe();\n    ae();\n    ag = (e1, t, r, n, o)=>{\n        let i = M(\"output_data\", o, r.length, 4), a = E(\"a_data\", t[1].dataType, t[1].dims.length, 4), d = E(\"b_data\", t[2].dataType, t[2].dims.length, 4), l = E(\"c_data\", t[0].dataType, t[0].dims.length, 4), p, m = (u, h, _)=>\"select(\".concat(h, \", \").concat(u, \", \").concat(_, \")\");\n        if (!n) p = i.setByOffset(\"global_idx\", m(a.getByOffset(\"global_idx\"), d.getByOffset(\"global_idx\"), l.getByOffset(\"global_idx\")));\n        else {\n            let u = function(h, _) {\n                let y = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"\";\n                let g = \"a_data[index_a\".concat(_, \"][component_a\").concat(_, \"]\"), x = \"b_data[index_b\".concat(_, \"][component_b\").concat(_, \"]\"), $ = \"bool(c_data[index_c\".concat(_, \"] & (0xffu << (component_c\").concat(_, \" * 8)))\");\n                return \"\\n            let output_indices\".concat(_, \" = \").concat(i.offsetToIndices(\"global_idx * 4u + \".concat(_, \"u\")), \";\\n            let offset_a\").concat(_, \" = \").concat(a.broadcastedIndicesToOffset(\"output_indices\".concat(_), i), \";\\n            let offset_b\").concat(_, \" = \").concat(d.broadcastedIndicesToOffset(\"output_indices\".concat(_), i), \";\\n            let offset_c\").concat(_, \" = \").concat(l.broadcastedIndicesToOffset(\"output_indices\".concat(_), i), \";\\n            let index_a\").concat(_, \" = offset_a\").concat(_, \" / 4u;\\n            let index_b\").concat(_, \" = offset_b\").concat(_, \" / 4u;\\n            let index_c\").concat(_, \" = offset_c\").concat(_, \" / 4u;\\n            let component_a\").concat(_, \" = offset_a\").concat(_, \" % 4u;\\n            let component_b\").concat(_, \" = offset_b\").concat(_, \" % 4u;\\n            let component_c\").concat(_, \" = offset_c\").concat(_, \" % 4u;\\n            \").concat(h, \"[\").concat(_, \"] = \").concat(y, \"(\").concat(m(g, x, $), \");\\n          \");\n            };\n            o === 9 ? p = \"\\n            var data = vec4<u32>(0);\\n            \".concat(u(\"data\", 0, \"u32\"), \"\\n            \").concat(u(\"data\", 1, \"u32\"), \"\\n            \").concat(u(\"data\", 2, \"u32\"), \"\\n            \").concat(u(\"data\", 3, \"u32\"), \"\\n            output_data[global_idx] = dot(vec4<u32>(0x1, 0x100, 0x10000, 0x1000000), vec4<u32>(data));\") : p = \"\\n            \".concat(u(\"output_data[global_idx]\", 0), \"\\n            \").concat(u(\"output_data[global_idx]\", 1), \"\\n            \").concat(u(\"output_data[global_idx]\", 2), \"\\n            \").concat(u(\"output_data[global_idx]\", 3), \"\\n          \");\n        }\n        return \"\\n        \".concat(e1.registerUniform(\"vec_size\", \"u32\").declareVariables(l, a, d, i), \"\\n        \").concat(e1.mainStart(), \"\\n        \").concat(e1.guardAgainstOutOfBoundsWorkgroupSizes(\"uniforms.vec_size\"), \"\\n        \").concat(p, \"\\n      }\");\n    }, sg = (e1)=>{\n        let t = e1[1].dims, r = e1[2].dims, n = e1[0].dims, o = e1[1].dataType, i = !(C.areEqual(t, r) && C.areEqual(r, n)), a = t, d = C.size(t);\n        if (i) {\n            let p = tt.calcShape(tt.calcShape(t, r, !1), n, !1);\n            if (!p) throw new Error(\"Can't perform where op on the given tensors\");\n            a = p, d = C.size(a);\n        }\n        let l = Math.ceil(d / 4);\n        return {\n            name: \"Where\",\n            shaderCache: {\n                inputDependencies: [\n                    \"rank\",\n                    \"rank\",\n                    \"rank\"\n                ]\n            },\n            getShaderSource: (p)=>ag(p, e1, a, i, o),\n            getRunData: ()=>({\n                    outputs: [\n                        {\n                            dims: a,\n                            dataType: o\n                        }\n                    ],\n                    dispatchGroup: {\n                        x: Math.ceil(d / 64 / 4)\n                    },\n                    programUniforms: [\n                        {\n                            type: 12,\n                            data: l\n                        },\n                        ...N(n, t, r, a)\n                    ]\n                })\n        };\n    }, jl = (e1)=>{\n        e1.compute(sg(e1.inputs));\n    };\n});\nvar Zl, Ql = U(()=>{\n    \"use strict\";\n    Ps();\n    Fr();\n    Ds();\n    Ms();\n    vu();\n    zu();\n    Bu();\n    Qu();\n    od();\n    sd();\n    ld();\n    hd();\n    yd();\n    wd();\n    xd();\n    Id();\n    kd();\n    zd();\n    Bd();\n    Ud();\n    qd();\n    Yd();\n    Qd();\n    Jd();\n    rl();\n    So();\n    ol();\n    vl();\n    Sl();\n    Il();\n    kl();\n    Gr();\n    Ol();\n    Bl();\n    Rl();\n    Wl();\n    Hl();\n    Io();\n    Kl();\n    dt();\n    Kr();\n    Yl();\n    Zl = new Map([\n        [\n            \"Abs\",\n            [\n                Rs\n            ]\n        ],\n        [\n            \"Acos\",\n            [\n                Us\n            ]\n        ],\n        [\n            \"Acosh\",\n            [\n                Ns\n            ]\n        ],\n        [\n            \"Add\",\n            [\n                $u\n            ]\n        ],\n        [\n            \"ArgMax\",\n            [\n                Es,\n                co\n            ]\n        ],\n        [\n            \"ArgMin\",\n            [\n                ks,\n                co\n            ]\n        ],\n        [\n            \"Asin\",\n            [\n                Vs\n            ]\n        ],\n        [\n            \"Asinh\",\n            [\n                Ws\n            ]\n        ],\n        [\n            \"Atan\",\n            [\n                Ls\n            ]\n        ],\n        [\n            \"Atanh\",\n            [\n                Gs\n            ]\n        ],\n        [\n            \"Attention\",\n            [\n                zs\n            ]\n        ],\n        [\n            \"AveragePool\",\n            [\n                pl,\n                cl\n            ]\n        ],\n        [\n            \"BatchNormalization\",\n            [\n                Os\n            ]\n        ],\n        [\n            \"BiasAdd\",\n            [\n                Bs\n            ]\n        ],\n        [\n            \"BiasSplitGelu\",\n            [\n                wu\n            ]\n        ],\n        [\n            \"Cast\",\n            [\n                Fs,\n                Hs\n            ]\n        ],\n        [\n            \"Ceil\",\n            [\n                Ks\n            ]\n        ],\n        [\n            \"Clip\",\n            [\n                qs\n            ]\n        ],\n        [\n            \"Concat\",\n            [\n                Ou,\n                Du\n            ]\n        ],\n        [\n            \"Conv\",\n            [\n                wo,\n                _o\n            ]\n        ],\n        [\n            \"ConvTranspose\",\n            [\n                nd,\n                td\n            ]\n        ],\n        [\n            \"Cos\",\n            [\n                js\n            ]\n        ],\n        [\n            \"Cosh\",\n            [\n                Ys\n            ]\n        ],\n        [\n            \"CumSum\",\n            [\n                id,\n                ad\n            ]\n        ],\n        [\n            \"DepthToSpace\",\n            [\n                ud,\n                dd\n            ]\n        ],\n        [\n            \"DequantizeLinear\",\n            [\n                $l,\n                xl\n            ]\n        ],\n        [\n            \"Div\",\n            [\n                xu\n            ]\n        ],\n        [\n            \"Einsum\",\n            [\n                md,\n                fd\n            ]\n        ],\n        [\n            \"Elu\",\n            [\n                Zs,\n                Xt\n            ]\n        ],\n        [\n            \"Equal\",\n            [\n                Su\n            ]\n        ],\n        [\n            \"Erf\",\n            [\n                Qs\n            ]\n        ],\n        [\n            \"Exp\",\n            [\n                Xs\n            ]\n        ],\n        [\n            \"Expand\",\n            [\n                bd\n            ]\n        ],\n        [\n            \"FastGelu\",\n            [\n                _d\n            ]\n        ],\n        [\n            \"Floor\",\n            [\n                Js\n            ]\n        ],\n        [\n            \"FusedConv\",\n            [\n                wo,\n                _o\n            ]\n        ],\n        [\n            \"Gather\",\n            [\n                $d,\n                vd\n            ]\n        ],\n        [\n            \"GatherElements\",\n            [\n                Pd,\n                Ed\n            ]\n        ],\n        [\n            \"GatherBlockQuantized\",\n            [\n                Cd,\n                Ad\n            ]\n        ],\n        [\n            \"GatherND\",\n            [\n                Sd,\n                Td\n            ]\n        ],\n        [\n            \"Gelu\",\n            [\n                eu\n            ]\n        ],\n        [\n            \"Gemm\",\n            [\n                Dd,\n                Od\n            ]\n        ],\n        [\n            \"GlobalAveragePool\",\n            [\n                hl,\n                fl\n            ]\n        ],\n        [\n            \"GlobalMaxPool\",\n            [\n                wl,\n                _l\n            ]\n        ],\n        [\n            \"Greater\",\n            [\n                Au\n            ]\n        ],\n        [\n            \"GreaterOrEqual\",\n            [\n                Eu\n            ]\n        ],\n        [\n            \"GridSample\",\n            [\n                Md,\n                Rd\n            ]\n        ],\n        [\n            \"GroupQueryAttention\",\n            [\n                Fd\n            ]\n        ],\n        [\n            \"HardSigmoid\",\n            [\n                uu,\n                su\n            ]\n        ],\n        [\n            \"InstanceNormalization\",\n            [\n                jd\n            ]\n        ],\n        [\n            \"LayerNormalization\",\n            [\n                Zd\n            ]\n        ],\n        [\n            \"LeakyRelu\",\n            [\n                tu,\n                Xt\n            ]\n        ],\n        [\n            \"Less\",\n            [\n                ku\n            ]\n        ],\n        [\n            \"LessOrEqual\",\n            [\n                Pu\n            ]\n        ],\n        [\n            \"Log\",\n            [\n                bu\n            ]\n        ],\n        [\n            \"MatMul\",\n            [\n                Xd\n            ]\n        ],\n        [\n            \"MatMulNBits\",\n            [\n                el,\n                tl\n            ]\n        ],\n        [\n            \"MaxPool\",\n            [\n                bl,\n                yl\n            ]\n        ],\n        [\n            \"Mul\",\n            [\n                Tu\n            ]\n        ],\n        [\n            \"MultiHeadAttention\",\n            [\n                Wd,\n                Vd\n            ]\n        ],\n        [\n            \"Neg\",\n            [\n                nu\n            ]\n        ],\n        [\n            \"Not\",\n            [\n                ru\n            ]\n        ],\n        [\n            \"Pad\",\n            [\n                nl\n            ]\n        ],\n        [\n            \"Pow\",\n            [\n                Iu\n            ]\n        ],\n        [\n            \"QuickGelu\",\n            [\n                yu,\n                Xt\n            ]\n        ],\n        [\n            \"Range\",\n            [\n                Tl\n            ]\n        ],\n        [\n            \"Reciprocal\",\n            [\n                ou\n            ]\n        ],\n        [\n            \"ReduceMin\",\n            [\n                xs\n            ]\n        ],\n        [\n            \"ReduceMean\",\n            [\n                ys\n            ]\n        ],\n        [\n            \"ReduceMax\",\n            [\n                $s\n            ]\n        ],\n        [\n            \"ReduceSum\",\n            [\n                Ts\n            ]\n        ],\n        [\n            \"ReduceProd\",\n            [\n                Ss\n            ]\n        ],\n        [\n            \"ReduceL1\",\n            [\n                _s\n            ]\n        ],\n        [\n            \"ReduceL2\",\n            [\n                ws\n            ]\n        ],\n        [\n            \"ReduceLogSum\",\n            [\n                Cs\n            ]\n        ],\n        [\n            \"ReduceLogSumExp\",\n            [\n                vs\n            ]\n        ],\n        [\n            \"ReduceSumSquare\",\n            [\n                Is\n            ]\n        ],\n        [\n            \"Relu\",\n            [\n                iu\n            ]\n        ],\n        [\n            \"Resize\",\n            [\n                Pl,\n                zl\n            ]\n        ],\n        [\n            \"RotaryEmbedding\",\n            [\n                Dl\n            ]\n        ],\n        [\n            \"ScatterND\",\n            [\n                Al,\n                Cl\n            ]\n        ],\n        [\n            \"Sigmoid\",\n            [\n                au\n            ]\n        ],\n        [\n            \"Sin\",\n            [\n                du\n            ]\n        ],\n        [\n            \"Sinh\",\n            [\n                lu\n            ]\n        ],\n        [\n            \"Slice\",\n            [\n                Nl,\n                Vl\n            ]\n        ],\n        [\n            \"SkipLayerNormalization\",\n            [\n                Ml\n            ]\n        ],\n        [\n            \"Split\",\n            [\n                Ld,\n                Gd\n            ]\n        ],\n        [\n            \"Sqrt\",\n            [\n                cu\n            ]\n        ],\n        [\n            \"Softmax\",\n            [\n                Ll,\n                Gl\n            ]\n        ],\n        [\n            \"Sub\",\n            [\n                Cu\n            ]\n        ],\n        [\n            \"Tan\",\n            [\n                pu\n            ]\n        ],\n        [\n            \"Tanh\",\n            [\n                fu\n            ]\n        ],\n        [\n            \"ThresholdedRelu\",\n            [\n                gu,\n                Xt\n            ]\n        ],\n        [\n            \"Tile\",\n            [\n                ql\n            ]\n        ],\n        [\n            \"Transpose\",\n            [\n                is,\n                as\n            ]\n        ],\n        [\n            \"Where\",\n            [\n                jl\n            ]\n        ]\n    ]);\n});\nvar nn, Xl = U(()=>{\n    \"use strict\";\n    We();\n    et();\n    ae();\n    nn = class {\n        getArtifact(t) {\n            return this.repo.get(t);\n        }\n        setArtifact(t, r) {\n            this.repo.set(t, r);\n        }\n        run(t, r, n, o, i) {\n            Ue(t.programInfo.name);\n            let a = this.backend.device, d = this.backend.getComputePassEncoder();\n            this.backend.writeTimestamp(this.backend.pendingDispatchNumber * 2);\n            let l = [];\n            for (let m of r)l.push({\n                binding: l.length,\n                resource: {\n                    buffer: m.buffer\n                }\n            });\n            for (let m of n)l.push({\n                binding: l.length,\n                resource: {\n                    buffer: m.buffer\n                }\n            });\n            i && l.push({\n                binding: l.length,\n                resource: i\n            });\n            let p = a.createBindGroup({\n                layout: t.computePipeline.getBindGroupLayout(0),\n                entries: l,\n                label: t.programInfo.name\n            });\n            if (this.backend.sessionStatus === \"capturing\") {\n                let m = {\n                    kernelId: this.backend.currentKernelId,\n                    computePipeline: t.computePipeline,\n                    bindGroup: p,\n                    dispatchGroup: o\n                };\n                this.backend.capturedCommandList.get(this.backend.currentSessionId).push(m);\n            }\n            d.setPipeline(t.computePipeline), d.setBindGroup(0, p), d.dispatchWorkgroups(...o), this.backend.writeTimestamp(this.backend.pendingDispatchNumber * 2 + 1), this.backend.pendingDispatchNumber++, (this.backend.pendingDispatchNumber >= this.backend.maxDispatchNumber || this.backend.queryType === \"at-passes\") && this.backend.endComputePass(), this.backend.pendingDispatchNumber >= this.backend.maxDispatchNumber && this.backend.flush(), De(t.programInfo.name);\n        }\n        dispose() {}\n        build(t, r) {\n            Ue(t.name);\n            let n = this.backend.device, o = [];\n            [\n                {\n                    feature: \"shader-f16\",\n                    extension: \"f16\"\n                },\n                {\n                    feature: \"subgroups\",\n                    extension: \"subgroups\"\n                },\n                {\n                    feature: \"subgroups-f16\",\n                    extension: \"subgroups_f16\"\n                }\n            ].forEach((u)=>{\n                n.features.has(u.feature) && o.push(\"enable \".concat(u.extension, \";\"));\n            });\n            let a = ns(r, this.backend.device.limits), d = t.getShaderSource(a), l = \"\".concat(o.join(\"\\n\"), \"\\n\").concat(a.additionalImplementations, \"\\n\").concat(d), p = n.createShaderModule({\n                code: l,\n                label: t.name\n            });\n            ue(\"verbose\", ()=>\"[WebGPU] \".concat(t.name, \" shader code: \").concat(l));\n            let m = n.createComputePipeline({\n                compute: {\n                    module: p,\n                    entryPoint: \"main\"\n                },\n                layout: \"auto\",\n                label: t.name\n            });\n            return De(t.name), {\n                programInfo: t,\n                computePipeline: m,\n                uniformVariablesInfo: a.variablesInfo\n            };\n        }\n        normalizeDispatchGroupSize(t) {\n            let r = typeof t == \"number\" ? t : t.x, n = typeof t == \"number\" ? 1 : t.y || 1, o = typeof t == \"number\" ? 1 : t.z || 1, i = this.backend.device.limits.maxComputeWorkgroupsPerDimension;\n            if (r <= i && n <= i && o <= i) return [\n                r,\n                n,\n                o\n            ];\n            let a = r * n * o, d = Math.ceil(Math.sqrt(a));\n            if (d > i) {\n                if (d = Math.ceil(Math.cbrt(a)), d > i) throw new Error(\"Total dispatch size exceeds WebGPU maximum.\");\n                return [\n                    d,\n                    d,\n                    d\n                ];\n            } else return [\n                d,\n                d,\n                1\n            ];\n        }\n        constructor(t){\n            this.backend = t;\n            this.repo = new Map, this.attributesBound = !1;\n        }\n    };\n});\nvar ug, dg, Co, Ao, on, Jl = U(()=>{\n    \"use strict\";\n    We();\n    te();\n    et();\n    Jn();\n    Ja();\n    Ql();\n    Xl();\n    ug = (e1, t)=>{\n        if (t.length !== e1.length) throw new Error(\"inputDependencies length \".concat(t.length, \" is not equal to inputTensors length \").concat(e1.length, \".\"));\n        let r = [];\n        for(let n = 0; n < e1.length; ++n){\n            let o = e1[n].dataType;\n            switch(t[n]){\n                case \"none\":\n                    {\n                        r.push(\"\");\n                        break;\n                    }\n                case \"type\":\n                    {\n                        r.push(\"\".concat(o));\n                        break;\n                    }\n                case \"rank\":\n                    {\n                        let i = e1[n].dims.length;\n                        r.push(\"\".concat(o, \";\").concat(i));\n                        break;\n                    }\n                case \"dims\":\n                    {\n                        let i = e1[n].dims.join(\",\");\n                        r.push(\"\".concat(o, \";\").concat(i));\n                        break;\n                    }\n                default:\n                    throw new Error(\"unsupported input dependency: \".concat(t[n]));\n            }\n        }\n        return r.join(\"|\");\n    }, dg = (e1, t, r)=>{\n        var _e_shaderCache, _e_shaderCache1;\n        let n = e1.name;\n        var _e_shaderCache_inputDependencies;\n        return ((_e_shaderCache = e1.shaderCache) === null || _e_shaderCache === void 0 ? void 0 : _e_shaderCache.hint) && (n += \"[\" + e1.shaderCache.hint + \"]\"), n += \":\" + r + \":\".concat(ug(t, (_e_shaderCache_inputDependencies = (_e_shaderCache1 = e1.shaderCache) === null || _e_shaderCache1 === void 0 ? void 0 : _e_shaderCache1.inputDependencies) !== null && _e_shaderCache_inputDependencies !== void 0 ? _e_shaderCache_inputDependencies : new Array(t.length).fill(\"dims\"))), n;\n    }, Co = class {\n        isArchitecture(t) {\n            return this.architecture === t;\n        }\n        isVendor(t) {\n            return this.vendor === t;\n        }\n        constructor(t){\n            t && (this.architecture = t.architecture, this.vendor = t.vendor);\n        }\n    }, Ao = class {\n        constructor(t){\n            this.subgroupsSupported = t.features.has(\"subgroups\"), this.subgroupsF16Supported = t.features.has(\"subgroups\");\n            let r = t.limits;\n            !this.subgroupsSupported || !r.minSubgroupSize || !r.maxSubgroupSize ? this.subgroupSizeRange = void 0 : this.subgroupSizeRange = [\n                r.minSubgroupSize,\n                r.maxSubgroupSize\n            ];\n        }\n    }, on = class {\n        get currentKernelCustomData() {\n            if (this.currentKernelId === null) throw new Error(\"currentKernelCustomData(): currentKernelId is null. (should not happen)\");\n            let t = this.kernelCustomData.get(this.currentKernelId);\n            return t || (t = {}, this.kernelCustomData.set(this.currentKernelId, t)), t;\n        }\n        async initialize(t, r) {\n            this.env = t;\n            let n = [], o = {\n                requiredLimits: {\n                    maxComputeWorkgroupStorageSize: r.limits.maxComputeWorkgroupStorageSize,\n                    maxComputeWorkgroupsPerDimension: r.limits.maxComputeWorkgroupsPerDimension,\n                    maxStorageBufferBindingSize: r.limits.maxStorageBufferBindingSize,\n                    maxBufferSize: r.limits.maxBufferSize,\n                    maxComputeInvocationsPerWorkgroup: r.limits.maxComputeInvocationsPerWorkgroup,\n                    maxComputeWorkgroupSizeX: r.limits.maxComputeWorkgroupSizeX,\n                    maxComputeWorkgroupSizeY: r.limits.maxComputeWorkgroupSizeY,\n                    maxComputeWorkgroupSizeZ: r.limits.maxComputeWorkgroupSizeZ\n                },\n                requiredFeatures: n\n            }, i = (a)=>r.features.has(a) && n.push(a) && !0;\n            i(\"chromium-experimental-timestamp-query-inside-passes\") || i(\"timestamp-query\"), i(\"shader-f16\"), i(\"subgroups\") && i(\"subgroups-f16\"), this.device = await r.requestDevice(o), this.deviceInfo = new Ao(this.device), this.adapterInfo = new Co(r.info || await r.requestAdapterInfo()), this.gpuDataManager = Xa(this), this.programManager = new nn(this), this.kernels = new Map, this.kernelPersistentData = new Map, this.kernelCustomData = new Map, Rr(t.logLevel, !!t.debug), this.device.onuncapturederror = (a)=>{\n                a.error instanceof GPUValidationError && console.error(\"An uncaught WebGPU validation error was raised: \".concat(a.error.message));\n            }, Object.defineProperty(this.env.webgpu, \"device\", {\n                value: this.device,\n                writable: !1,\n                enumerable: !0,\n                configurable: !1\n            }), Object.defineProperty(this.env.webgpu, \"adapter\", {\n                value: r,\n                writable: !1,\n                enumerable: !0,\n                configurable: !1\n            }), this.setQueryType();\n        }\n        dispose() {\n            typeof this.querySet < \"u\" && this.querySet.destroy(), this.gpuDataManager.dispose();\n        }\n        getCommandEncoder() {\n            return this.commandEncoder || (this.commandEncoder = this.device.createCommandEncoder()), this.commandEncoder;\n        }\n        getComputePassEncoder() {\n            if (!this.computePassEncoder) {\n                let t = this.getCommandEncoder(), r = {};\n                this.queryType === \"at-passes\" && (r.timestampWrites = {\n                    querySet: this.querySet,\n                    beginningOfPassWriteIndex: this.pendingDispatchNumber * 2,\n                    endOfPassWriteIndex: this.pendingDispatchNumber * 2 + 1\n                }), this.computePassEncoder = t.beginComputePass(r);\n            }\n            return this.computePassEncoder;\n        }\n        endComputePass() {\n            this.computePassEncoder && (this.computePassEncoder.end(), this.computePassEncoder = null);\n        }\n        flush() {\n            if (!this.commandEncoder) return;\n            Ue(), this.endComputePass();\n            let t;\n            this.queryType !== \"none\" && (this.commandEncoder.resolveQuerySet(this.querySet, 0, this.pendingDispatchNumber * 2, this.queryResolveBuffer, 0), t = this.device.createBuffer({\n                size: this.pendingDispatchNumber * 2 * 8,\n                usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST\n            }), this.pendingQueries.set(t, this.pendingKernels), this.pendingKernels = [], this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer, 0, t, 0, this.pendingDispatchNumber * 2 * 8)), this.device.queue.submit([\n                this.commandEncoder.finish()\n            ]), this.gpuDataManager.refreshPendingBuffers(), this.commandEncoder = null, this.pendingDispatchNumber = 0, this.queryType !== \"none\" && t.mapAsync(GPUMapMode.READ).then(()=>{\n                let r = new BigUint64Array(t.getMappedRange()), n = this.pendingQueries.get(t);\n                for(let o = 0; o < r.length / 2; o++){\n                    var _this_env_webgpu_profiling;\n                    let i = n[o], a = i.kernelId, d = this.kernels.get(a), l = d.kernelType, p = d.kernelName, m = i.programName, u = i.inputTensorViews, h = i.outputTensorViews, _ = r[o * 2], y = r[o * 2 + 1];\n                    typeof this.queryTimeBase > \"u\" && (this.queryTimeBase = _);\n                    let g = Number(_ - this.queryTimeBase), x = Number(y - this.queryTimeBase);\n                    if (!Number.isSafeInteger(g) || !Number.isSafeInteger(x)) throw new RangeError(\"incorrect timestamp range\");\n                    if ((_this_env_webgpu_profiling = this.env.webgpu.profiling) === null || _this_env_webgpu_profiling === void 0 ? void 0 : _this_env_webgpu_profiling.ondata) this.env.webgpu.profiling.ondata({\n                        version: 1,\n                        inputsMetadata: u.map(($)=>({\n                                dims: $.dims,\n                                dataType: bt($.dataType)\n                            })),\n                        outputsMetadata: h.map(($)=>({\n                                dims: $.dims,\n                                dataType: bt($.dataType)\n                            })),\n                        kernelId: a,\n                        kernelType: l,\n                        kernelName: p,\n                        programName: m,\n                        startTime: g,\n                        endTime: x\n                    });\n                    else {\n                        let $ = \"\";\n                        u.forEach((S, T)=>{\n                            $ += \"input[\".concat(T, \"]: [\").concat(S.dims, \"] | \").concat(bt(S.dataType), \", \");\n                        });\n                        let v = \"\";\n                        h.forEach((S, T)=>{\n                            v += \"output[\".concat(T, \"]: [\").concat(S.dims, \"] | \").concat(bt(S.dataType), \", \");\n                        }), console.log('[profiling] kernel \"'.concat(a, \"|\").concat(l, \"|\").concat(p, \"|\").concat(m, '\" ').concat($).concat(v, \"execution time: \").concat(x - g, \" ns\"));\n                    }\n                    wr(\"GPU\", \"\".concat(m, \"::\").concat(_, \"::\").concat(y));\n                }\n                t.unmap(), this.pendingQueries.delete(t);\n            }), De();\n        }\n        run(t, r, n, o, i, a) {\n            Ue(t.name);\n            let d = [];\n            for(let S = 0; S < r.length; ++S){\n                let T = r[S].data;\n                if (T === 0) continue;\n                let A = this.gpuDataManager.get(T);\n                if (!A) throw new Error(\"no GPU data for input: \".concat(T));\n                d.push(A);\n            }\n            let { outputs: l, dispatchGroup: p, programUniforms: m } = t.getRunData(r), u = n.length === 0 ? l.map((S, T)=>T) : n;\n            if (u.length !== l.length) throw new Error(\"Output size \".concat(u.length, \" must be equal to \").concat(l.length, \".\"));\n            let h = [], _ = [];\n            for(let S = 0; S < l.length; ++S){\n                if (!Number.isInteger(u[S]) || u[S] < -3 || u[S] >= a) throw new Error(\"Invalid output index: \".concat(u[S]));\n                if (u[S] === -3) continue;\n                let T = u[S] === -1, A = u[S] === -2, k = T || A ? i(l[S].dataType, l[S].dims) : o(u[S], l[S].dataType, l[S].dims);\n                if (h.push(k), k.data === 0) continue;\n                let P = this.gpuDataManager.get(k.data);\n                if (!P) throw new Error(\"no GPU data for output: \".concat(k.data));\n                if (T && this.temporaryData.push(P), A) {\n                    let D = this.kernelPersistentData.get(this.currentKernelId);\n                    D || (D = [], this.kernelPersistentData.set(this.currentKernelId, D)), D.push(P);\n                }\n                _.push(P);\n            }\n            if (d.length !== r.length || _.length !== h.length) {\n                if (_.length === 0) return De(t.name), h;\n                throw new Error(\"Program \".concat(t.name, \" has zero-sized tensor(s) in inputs or outputs. This is not supported now.\"));\n            }\n            let y;\n            if (m) {\n                let S = 0, T = [];\n                m.forEach((D)=>{\n                    let R = typeof D.data == \"number\" ? [\n                        D.data\n                    ] : D.data;\n                    if (R.length === 0) return;\n                    let G = D.type === 10 ? 2 : 4, K, j;\n                    D.type === 10 ? (j = R.length > 4 ? 16 : R.length > 2 ? 8 : R.length * G, K = R.length > 4 ? 16 : G * R.length) : (j = R.length <= 2 ? R.length * G : 16, K = 16), S = Math.ceil(S / j) * j, T.push(S);\n                    let V = D.type === 10 ? 8 : 4;\n                    S += R.length > 4 ? Math.ceil(R.length / V) * K : R.length * G;\n                });\n                let A = 16;\n                S = Math.ceil(S / A) * A;\n                let k = new ArrayBuffer(S);\n                m.forEach((D, R)=>{\n                    let G = T[R], K = typeof D.data == \"number\" ? [\n                        D.data\n                    ] : D.data;\n                    if (D.type === 6) new Int32Array(k, G, K.length).set(K);\n                    else if (D.type === 12) new Uint32Array(k, G, K.length).set(K);\n                    else if (D.type === 10) new Uint16Array(k, G, K.length).set(K);\n                    else if (D.type === 1) new Float32Array(k, G, K.length).set(K);\n                    else throw new Error(\"Unsupported uniform type: \".concat(bt(D.type)));\n                });\n                let P = this.gpuDataManager.create(S, GPUBufferUsage.COPY_DST | GPUBufferUsage.UNIFORM);\n                this.device.queue.writeBuffer(P.buffer, 0, k, 0, S), this.gpuDataManager.release(P.id), y = {\n                    offset: 0,\n                    size: S,\n                    buffer: P.buffer\n                };\n            }\n            let g = this.programManager.normalizeDispatchGroupSize(p), x = g[1] === 1 && g[2] === 1, $ = dg(t, r, x), v = this.programManager.getArtifact($);\n            if (v || (v = this.programManager.build(t, g), this.programManager.setArtifact($, v), ue(\"info\", ()=>\"[artifact] key: \".concat($, \", programName: \").concat(t.name))), m && v.uniformVariablesInfo) {\n                if (m.length !== v.uniformVariablesInfo.length) throw new Error(\"Uniform variables count mismatch: expect \".concat(v.uniformVariablesInfo.length, \", got \").concat(m.length, ' in program \"').concat(v.programInfo.name, '\".'));\n                for(let S = 0; S < m.length; S++){\n                    let T = m[S], A = T.type, k = typeof T.data == \"number\" ? 1 : T.data.length, [P, D] = v.uniformVariablesInfo[S];\n                    if (A !== P || k !== D) throw new Error(\"Uniform variable \".concat(S, \" mismatch: expect type \").concat(P, \" with size \").concat(D, \", got type \").concat(A, \" with size \").concat(k, ' in program \"').concat(v.programInfo.name, '\".'));\n                }\n            }\n            if (ue(\"info\", ()=>'[ProgramManager] run \"'.concat(t.name, '\" (key=').concat($, \") with \").concat(g[0], \"x\").concat(g[1], \"x\").concat(g[2])), this.queryType !== \"none\" || this.sessionStatus === \"capturing\") {\n                let S = {\n                    kernelId: this.currentKernelId,\n                    programName: v.programInfo.name,\n                    inputTensorViews: r,\n                    outputTensorViews: h\n                };\n                this.pendingKernels.push(S), this.sessionStatus === \"capturing\" && this.capturedPendingKernels.get(this.currentSessionId).push(S);\n            }\n            return this.programManager.run(v, d, _, g, y), De(t.name), h;\n        }\n        upload(t, r) {\n            this.gpuDataManager.upload(t, r);\n        }\n        memcpy(t, r) {\n            this.gpuDataManager.memcpy(t, r);\n        }\n        async download(t, r) {\n            await this.gpuDataManager.download(t, r);\n        }\n        alloc(t) {\n            return this.gpuDataManager.create(t).id;\n        }\n        free(t) {\n            return this.gpuDataManager.release(t);\n        }\n        createKernel(t, r, n, o) {\n            let i = Zl.get(t);\n            if (!i) throw new Error(\"kernel not implemented: \".concat(t));\n            let a = {\n                kernelType: t,\n                kernelName: o,\n                kernelEntry: i[0],\n                attributes: [\n                    i[1],\n                    n\n                ]\n            };\n            this.kernels.set(r, a);\n        }\n        releaseKernel(t) {\n            let r = this.kernelPersistentData.get(t);\n            if (r) {\n                for (let n of r)this.gpuDataManager.release(n.id);\n                this.kernelPersistentData.delete(t);\n            }\n            this.kernelCustomData.delete(t), this.kernels.delete(t);\n        }\n        computeKernel(t, r, n) {\n            let o = this.kernels.get(t);\n            if (!o) throw new Error(\"kernel not created: \".concat(t));\n            let i = o.kernelType, a = o.kernelName, d = o.kernelEntry, l = o.attributes;\n            if (this.currentKernelId !== null) throw new Error('kernel \"['.concat(i, \"] \").concat(a, '\" is not allowed to be called recursively'));\n            this.currentKernelId = t, l[0] && (l[1] = l[0](l[1]), l[0] = void 0), ue(\"info\", ()=>'[WebGPU] Start to run kernel \"['.concat(i, \"] \").concat(a, '\"...'));\n            let p = this.env.debug;\n            this.temporaryData = [];\n            try {\n                return p && this.device.pushErrorScope(\"validation\"), d(r, l[1]), 0;\n            } catch (m) {\n                return n.push(Promise.resolve('[WebGPU] Kernel \"['.concat(i, \"] \").concat(a, '\" failed. ').concat(m))), 1;\n            } finally{\n                p && n.push(this.device.popErrorScope().then((m)=>m ? 'GPU validation error for kernel \"['.concat(i, \"] \").concat(a, '\": ').concat(m.message) : null));\n                for (let m of this.temporaryData)this.gpuDataManager.release(m.id);\n                this.temporaryData = [], this.currentKernelId = null;\n            }\n        }\n        registerBuffer(t, r, n, o) {\n            let i = this.sessionExternalDataMapping.get(t);\n            i || (i = new Map, this.sessionExternalDataMapping.set(t, i));\n            let a = i.get(r), d = this.gpuDataManager.registerExternalBuffer(n, o, a);\n            return i.set(r, [\n                d,\n                n\n            ]), d;\n        }\n        unregisterBuffers(t) {\n            let r = this.sessionExternalDataMapping.get(t);\n            r && (r.forEach((n)=>this.gpuDataManager.unregisterExternalBuffer(n[0])), this.sessionExternalDataMapping.delete(t));\n        }\n        getBuffer(t) {\n            let r = this.gpuDataManager.get(t);\n            if (!r) throw new Error(\"no GPU data for buffer: \".concat(t));\n            return r.buffer;\n        }\n        createDownloader(t, r, n) {\n            return async ()=>{\n                let o = await no(this, t, r);\n                return Ur(o.buffer, n);\n            };\n        }\n        writeTimestamp(t) {\n            this.queryType === \"inside-passes\" && this.computePassEncoder.writeTimestamp(this.querySet, t);\n        }\n        setQueryType() {\n            var _this_env_webgpu_profiling;\n            this.queryType = \"none\", (((_this_env_webgpu_profiling = this.env.webgpu.profiling) === null || _this_env_webgpu_profiling === void 0 ? void 0 : _this_env_webgpu_profiling.mode) === \"default\" || (typeof this.env.trace > \"u\" ? this.env.wasm.trace : this.env.trace)) && (this.device.features.has(\"chromium-experimental-timestamp-query-inside-passes\") ? this.queryType = \"inside-passes\" : this.device.features.has(\"timestamp-query\") && (this.queryType = \"at-passes\"), this.queryType !== \"none\" && typeof this.querySet > \"u\" && (this.querySet = this.device.createQuerySet({\n                type: \"timestamp\",\n                count: this.maxDispatchNumber * 2\n            }), this.queryResolveBuffer = this.device.createBuffer({\n                size: this.maxDispatchNumber * 2 * 8,\n                usage: GPUBufferUsage.COPY_SRC | GPUBufferUsage.QUERY_RESOLVE\n            })));\n        }\n        captureBegin() {\n            ue(\"info\", \"captureBegin\"), this.capturedCommandList.get(this.currentSessionId) || this.capturedCommandList.set(this.currentSessionId, []), this.capturedPendingKernels.get(this.currentSessionId) || this.capturedPendingKernels.set(this.currentSessionId, []), this.flush(), this.sessionStatus = \"capturing\";\n        }\n        captureEnd() {\n            ue(\"info\", \"captureEnd\"), this.flush(), this.sessionStatus = \"default\";\n        }\n        replay() {\n            ue(\"info\", \"replay\"), this.sessionStatus = \"replaying\";\n            let t = this.capturedCommandList.get(this.currentSessionId), r = this.capturedPendingKernels.get(this.currentSessionId), n = t.length;\n            this.pendingKernels = [];\n            for(let o = 0; o < n; o++){\n                let i = this.getComputePassEncoder(), a = t[o];\n                this.writeTimestamp(this.pendingDispatchNumber * 2), i.setPipeline(a.computePipeline), i.setBindGroup(0, a.bindGroup), i.dispatchWorkgroups(...a.dispatchGroup), this.writeTimestamp(this.pendingDispatchNumber * 2 + 1), this.pendingDispatchNumber++, this.queryType !== \"none\" && this.pendingKernels.push(r[o]), (this.pendingDispatchNumber >= this.maxDispatchNumber || this.queryType === \"at-passes\") && this.endComputePass(), this.pendingDispatchNumber >= this.maxDispatchNumber && this.flush();\n            }\n            this.flush(), this.sessionStatus = \"default\";\n        }\n        onCreateSession() {\n            this.gpuDataManager.onCreateSession();\n        }\n        onReleaseSession(t) {\n            this.unregisterBuffers(t), this.capturedCommandList.has(t) && this.capturedCommandList.delete(t), this.capturedPendingKernels.has(t) && this.capturedPendingKernels.delete(t), this.gpuDataManager.onReleaseSession(t);\n        }\n        onRunStart(t) {\n            this.currentSessionId = t, this.setQueryType();\n        }\n        constructor(){\n            this.currentSessionId = null;\n            this.currentKernelId = null;\n            this.commandEncoder = null;\n            this.computePassEncoder = null;\n            this.maxDispatchNumber = 16;\n            this.pendingDispatchNumber = 0;\n            this.pendingKernels = [];\n            this.pendingQueries = new Map;\n            this.sessionStatus = \"default\";\n            this.capturedCommandList = new Map;\n            this.capturedPendingKernels = new Map;\n            this.sessionExternalDataMapping = new Map;\n        }\n    };\n});\nvar lg, ec, cg, tc, an, sn, ko, rc, nc = U(()=>{\n    \"use strict\";\n    et();\n    lg = 1, ec = ()=>lg++, cg = new Map([\n        [\n            \"float32\",\n            32\n        ],\n        [\n            \"float16\",\n            16\n        ],\n        [\n            \"int32\",\n            32\n        ],\n        [\n            \"uint32\",\n            32\n        ],\n        [\n            \"int64\",\n            64\n        ],\n        [\n            \"uint64\",\n            64\n        ],\n        [\n            \"int8\",\n            8\n        ],\n        [\n            \"uint8\",\n            8\n        ],\n        [\n            \"int4\",\n            4\n        ],\n        [\n            \"uint4\",\n            4\n        ]\n    ]), tc = (e1, t)=>{\n        let r = cg.get(e1);\n        if (!r) throw new Error(\"Unsupported data type.\");\n        return t.length > 0 ? Math.ceil(t.reduce((n, o)=>n * o) * r / 8) : 0;\n    }, an = class {\n        get tensor() {\n            return this.mlTensor;\n        }\n        get type() {\n            return this.dataType;\n        }\n        get shape() {\n            return this.tensorShape;\n        }\n        get byteLength() {\n            return tc(this.dataType, this.tensorShape);\n        }\n        destroy() {\n            ue(\"verbose\", ()=>\"[WebNN] TensorWrapper.destroy\"), this.mlTensor.destroy();\n        }\n        write(t) {\n            this.mlContext.writeTensor(this.mlTensor, t);\n        }\n        async read(t) {\n            return t ? this.mlContext.readTensor(this.mlTensor, t) : this.mlContext.readTensor(this.mlTensor);\n        }\n        canReuseTensor(t, r, n) {\n            return this.mlContext === t && this.dataType === r && this.tensorShape.length === n.length && this.tensorShape.every((o, i)=>o === n[i]);\n        }\n        constructor(t){\n            this.sessionId = t.sessionId, this.mlContext = t.context, this.mlTensor = t.tensor, this.dataType = t.dataType, this.tensorShape = t.shape;\n        }\n    }, sn = class {\n        get tensorWrapper() {\n            return this.wrapper;\n        }\n        releaseTensor() {\n            this.tensorWrapper && (this.tensorManager.releaseTensor(this.tensorWrapper), this.wrapper = void 0);\n        }\n        async ensureTensor(t, r, n, o) {\n            if (this.wrapper) {\n                if (this.wrapper.canReuseTensor(t, r, n)) return this.wrapper.tensor;\n                if (o) {\n                    if (this.wrapper.byteLength !== tc(r, n)) throw new Error(\"Unable to copy data to tensor with different size.\");\n                    this.activeUpload = new Uint8Array(await this.wrapper.read());\n                }\n                this.tensorManager.releaseTensor(this.wrapper);\n            }\n            let i = typeof MLTensorUsage > \"u\" ? void 0 : MLTensorUsage.READ | MLTensorUsage.WRITE;\n            return this.wrapper = await this.tensorManager.getCachedTensor(r, n, i, !0, !0), o && this.activeUpload && (this.wrapper.write(this.activeUpload), this.activeUpload = void 0), this.wrapper.tensor;\n        }\n        upload(t) {\n            if (this.wrapper) if (t.byteLength === this.wrapper.byteLength) {\n                this.wrapper.write(t);\n                return;\n            } else ue(\"verbose\", ()=>\"Data size does not match tensor size. Releasing tensor.\"), this.releaseTensor();\n            this.activeUpload ? this.activeUpload.set(t) : this.activeUpload = new Uint8Array(t);\n        }\n        async download(t) {\n            if (this.activeUpload) if (t) {\n                t instanceof ArrayBuffer ? new Uint8Array(t).set(this.activeUpload) : new Uint8Array(t.buffer, t.byteOffset, t.byteLength).set(this.activeUpload);\n                return;\n            } else return this.activeUpload.buffer;\n            if (!this.wrapper) throw new Error(\"Tensor has not been created.\");\n            return t ? this.wrapper.read(t) : this.wrapper.read();\n        }\n        constructor(t, r){\n            this.tensorManager = t;\n            this.wrapper = r;\n        }\n    }, ko = class {\n        reserveTensorId() {\n            let t = ec();\n            return this.tensorTrackersById.set(t, new sn(this)), t;\n        }\n        releaseTensorId(t) {\n            let r = this.tensorTrackersById.get(t);\n            r && (this.tensorTrackersById.delete(t), r.tensorWrapper && this.releaseTensor(r.tensorWrapper));\n        }\n        async ensureTensor(t, r, n, o) {\n            ue(\"verbose\", ()=>\"[WebNN] TensorManager.ensureTensor {tensorId: \".concat(t, \", dataType: \").concat(r, \", shape: \").concat(n, \", copyOld: \").concat(o, \"}\"));\n            let i = this.tensorTrackersById.get(t);\n            if (!i) throw new Error(\"Tensor not found.\");\n            return i.ensureTensor(this.backend.currentContext, r, n, o);\n        }\n        upload(t, r) {\n            let n = this.tensorTrackersById.get(t);\n            if (!n) throw new Error(\"Tensor not found.\");\n            n.upload(r);\n        }\n        async download(t, r) {\n            ue(\"verbose\", ()=>\"[WebNN] TensorManager.download {tensorId: \".concat(t, \", dstBuffer: \").concat(r === null || r === void 0 ? void 0 : r.byteLength, \"}\"));\n            let n = this.tensorTrackersById.get(t);\n            if (!n) throw new Error(\"Tensor not found.\");\n            return n.download(r);\n        }\n        releaseTensorsForSession(t) {\n            for (let r of this.freeTensors)r.sessionId === t && r.destroy();\n            this.freeTensors = this.freeTensors.filter((r)=>r.sessionId !== t);\n        }\n        registerTensor(t, r, n, o) {\n            let i = ec(), a = new an({\n                sessionId: this.backend.currentSessionId,\n                context: t,\n                tensor: r,\n                dataType: n,\n                shape: o\n            });\n            return this.tensorTrackersById.set(i, new sn(this, a)), this.externalTensors.add(a), i;\n        }\n        async getCachedTensor(t, r, n, o, i) {\n            let a = this.backend.currentSessionId, d = this.backend.currentContext;\n            for (let [p, m] of this.freeTensors.entries())if (m.canReuseTensor(d, t, r)) {\n                ue(\"verbose\", ()=>\"[WebNN] Reusing tensor {dataType: \".concat(t, \", shape: \").concat(r, \"}\"));\n                let u = this.freeTensors.splice(p, 1)[0];\n                return u.sessionId = a, u;\n            }\n            ue(\"verbose\", ()=>\"[WebNN] MLContext.createTensor {dataType: \".concat(t, \", shape: \").concat(r, \"}\"));\n            let l = await d.createTensor({\n                dataType: t,\n                shape: r,\n                dimensions: r,\n                usage: n,\n                writable: o,\n                readable: i\n            });\n            return new an({\n                sessionId: a,\n                context: d,\n                tensor: l,\n                dataType: t,\n                shape: r\n            });\n        }\n        releaseTensor(t) {\n            this.externalTensors.has(t) && this.externalTensors.delete(t), this.freeTensors.push(t);\n        }\n        constructor(t){\n            this.backend = t;\n            this.tensorTrackersById = new Map;\n            this.freeTensors = [];\n            this.externalTensors = new Set;\n        }\n    }, rc = function() {\n        for(var _len = arguments.length, e1 = new Array(_len), _key = 0; _key < _len; _key++){\n            e1[_key] = arguments[_key];\n        }\n        return new ko(...e1);\n    };\n});\nvar oc, pg, un, ic = U(()=>{\n    \"use strict\";\n    te();\n    gt();\n    Jn();\n    nc();\n    et();\n    oc = new Map([\n        [\n            1,\n            \"float32\"\n        ],\n        [\n            10,\n            \"float16\"\n        ],\n        [\n            6,\n            \"int32\"\n        ],\n        [\n            12,\n            \"uint32\"\n        ],\n        [\n            7,\n            \"int64\"\n        ],\n        [\n            13,\n            \"uint64\"\n        ],\n        [\n            22,\n            \"int4\"\n        ],\n        [\n            21,\n            \"uint4\"\n        ],\n        [\n            3,\n            \"int8\"\n        ],\n        [\n            2,\n            \"uint8\"\n        ],\n        [\n            9,\n            \"uint8\"\n        ]\n    ]), pg = (e1, t)=>{\n        if (e1 === t) return !0;\n        if (e1 === void 0 || t === void 0) return !1;\n        let r = Object.keys(e1).sort(), n = Object.keys(t).sort();\n        return r.length === n.length && r.every((o, i)=>o === n[i] && e1[o] === t[o]);\n    }, un = class {\n        get currentSessionId() {\n            if (this.activeSessionId === void 0) throw new Error(\"No active session\");\n            return this.activeSessionId;\n        }\n        onRunStart(t) {\n            this.activeSessionId = t;\n        }\n        async createMLContext(t) {\n            if (t instanceof GPUDevice) {\n                let n = this.mlContextCache.findIndex((o)=>o.gpuDevice === t);\n                if (n !== -1) return this.mlContextCache[n].mlContext;\n                {\n                    let o = await navigator.ml.createContext(t);\n                    return this.mlContextCache.push({\n                        gpuDevice: t,\n                        mlContext: o\n                    }), o;\n                }\n            } else if (t === void 0) {\n                let n = this.mlContextCache.findIndex((o)=>o.options === void 0 && o.gpuDevice === void 0);\n                if (n !== -1) return this.mlContextCache[n].mlContext;\n                {\n                    let o = await navigator.ml.createContext();\n                    return this.mlContextCache.push({\n                        mlContext: o\n                    }), o;\n                }\n            }\n            let r = this.mlContextCache.findIndex((n)=>pg(n.options, t));\n            if (r !== -1) return this.mlContextCache[r].mlContext;\n            {\n                let n = await navigator.ml.createContext(t);\n                return this.mlContextCache.push({\n                    options: t,\n                    mlContext: n\n                }), n;\n            }\n        }\n        get currentContext() {\n            let t = this.getMLContext(this.currentSessionId);\n            if (!t) throw new Error(\"No MLContext found for session \".concat(this.currentSessionId));\n            return t;\n        }\n        registerMLContext(t, r) {\n            this.mlContextBySessionId.set(t, r);\n            let n = this.sessionIdsByMLContext.get(r);\n            n || (n = new Set, this.sessionIdsByMLContext.set(r, n)), n.add(t);\n        }\n        onReleaseSession(t) {\n            let r = this.mlContextBySessionId.get(t);\n            if (!r) return;\n            this.tensorManager.releaseTensorsForSession(t), this.mlContextBySessionId.delete(t);\n            let n = this.sessionIdsByMLContext.get(r);\n            if (n.delete(t), n.size === 0) {\n                this.sessionIdsByMLContext.delete(r);\n                let o = this.mlContextCache.findIndex((i)=>i.mlContext === r);\n                o !== -1 && this.mlContextCache.splice(o, 1);\n            }\n        }\n        getMLContext(t) {\n            return this.mlContextBySessionId.get(t);\n        }\n        reserveTensorId() {\n            return this.tensorManager.reserveTensorId();\n        }\n        releaseTensorId(t) {\n            ue(\"verbose\", ()=>\"[WebNN] releaseTensorId {tensorId: \".concat(t, \"}\")), this.tensorManager.releaseTensorId(t);\n        }\n        async ensureTensor(t, r, n, o) {\n            let i = oc.get(r);\n            if (!i) throw new Error(\"Unsupported ONNX data type: \".concat(r));\n            return this.tensorManager.ensureTensor(t, i, n, o);\n        }\n        uploadTensor(t, r) {\n            if (!Ie().shouldTransferToMLTensor) throw new Error(\"Trying to upload to a MLTensor while shouldTransferToMLTensor is false\");\n            ue(\"verbose\", ()=>\"[WebNN] uploadTensor {tensorId: \".concat(t, \", data: \").concat(r.byteLength, \"}\")), this.tensorManager.upload(t, r);\n        }\n        async downloadTensor(t, r) {\n            return this.tensorManager.download(t, r);\n        }\n        createMLTensorDownloader(t, r) {\n            return async ()=>{\n                let n = await this.tensorManager.download(t);\n                return Ur(n, r);\n            };\n        }\n        registerMLTensor(t, r, n) {\n            let o = oc.get(r);\n            if (!o) throw new Error(\"Unsupported ONNX data type: \".concat(r));\n            let i = this.tensorManager.registerTensor(this.currentContext, t, o, n);\n            return ue(\"verbose\", ()=>\"[WebNN] registerMLTensor {tensor: \".concat(t, \", dataType: \").concat(o, \", dimensions: \").concat(n, \"} -> {tensorId: \").concat(i, \"}\")), i;\n        }\n        registerMLConstant(t, r, n, o, i, a) {\n            if (!a) throw new Error(\"External mounted files are not available.\");\n            let d = t;\n            t.startsWith(\"./\") && (d = t.substring(2));\n            let l = a.get(d);\n            if (!l) throw new Error(\"File with name \".concat(d, \" not found in preloaded files.\"));\n            if (r + n > l.byteLength) throw new Error(\"Out of bounds: data offset and length exceed the external file data size.\");\n            let p = l.slice(r, r + n).buffer, m;\n            switch(i.dataType){\n                case \"float32\":\n                    m = new Float32Array(p);\n                    break;\n                case \"float16\":\n                    m = new Uint16Array(p);\n                    break;\n                case \"int32\":\n                    m = new Int32Array(p);\n                    break;\n                case \"uint32\":\n                    m = new Uint32Array(p);\n                    break;\n                case \"int64\":\n                    m = new BigInt64Array(p);\n                    break;\n                case \"uint64\":\n                    m = new BigUint64Array(p);\n                    break;\n                case \"int8\":\n                    m = new Int8Array(p);\n                    break;\n                case \"int4\":\n                case \"uint4\":\n                case \"uint8\":\n                    m = new Uint8Array(p);\n                    break;\n                default:\n                    throw new Error(\"Unsupported data type: \".concat(i.dataType, \" in creating WebNN Constant from external data.\"));\n            }\n            return ue(\"verbose\", ()=>\"[WebNN] registerMLConstant {dataType: \".concat(i.dataType, \", shape: \").concat(i.shape, \"}}\")), o.constant(i, m);\n        }\n        flush() {}\n        constructor(t){\n            this.tensorManager = rc(this);\n            this.mlContextBySessionId = new Map;\n            this.sessionIdsByMLContext = new Map;\n            this.mlContextCache = [];\n            Rr(t.logLevel, !!t.debug);\n        }\n    };\n});\nvar ac = {};\nFt(ac, {\n    init: ()=>mg\n});\nvar rr, Eo, mg, sc = U(()=>{\n    \"use strict\";\n    te();\n    Jl();\n    et();\n    oe();\n    ic();\n    rr = class e1 {\n        getFloat32Array() {\n            if (this.dataType !== 1) throw new Error(\"Invalid data type\");\n            let t = C.size(this.dims);\n            return t === 0 ? new Float32Array : new Float32Array(this.module.HEAP8.buffer, this.data, t);\n        }\n        getBigInt64Array() {\n            if (this.dataType !== 7) throw new Error(\"Invalid data type\");\n            let t = C.size(this.dims);\n            return t === 0 ? new BigInt64Array : new BigInt64Array(this.module.HEAP8.buffer, this.data, t);\n        }\n        getInt32Array() {\n            if (this.dataType !== 6) throw new Error(\"Invalid data type\");\n            let t = C.size(this.dims);\n            return t === 0 ? new Int32Array : new Int32Array(this.module.HEAP8.buffer, this.data, t);\n        }\n        getUint16Array() {\n            if (this.dataType !== 10 && this.dataType !== 4) throw new Error(\"Invalid data type\");\n            let t = C.size(this.dims);\n            return t === 0 ? new Uint16Array : new Uint16Array(this.module.HEAP8.buffer, this.data, t);\n        }\n        reshape(t) {\n            if (C.size(t) !== C.size(this.dims)) throw new Error(\"Invalid new shape\");\n            return new e1(this.module, this.dataType, this.data, t);\n        }\n        constructor(t, r, n, o){\n            this.module = t;\n            this.dataType = r;\n            this.data = n;\n            this.dims = o;\n        }\n    }, Eo = class {\n        get kernelCustomData() {\n            return this.backend.currentKernelCustomData;\n        }\n        get customDataBuffer() {\n            return this.module.HEAPU8.subarray(this.customDataOffset, this.customDataOffset + this.customDataSize);\n        }\n        compute(t, r) {\n            var _r_inputs;\n            var _r_inputs_map, _r_outputs;\n            let n = (_r_inputs_map = r === null || r === void 0 ? void 0 : (_r_inputs = r.inputs) === null || _r_inputs === void 0 ? void 0 : _r_inputs.map((d)=>typeof d == \"number\" ? this.inputs[d] : d)) !== null && _r_inputs_map !== void 0 ? _r_inputs_map : this.inputs, o = (_r_outputs = r === null || r === void 0 ? void 0 : r.outputs) !== null && _r_outputs !== void 0 ? _r_outputs : [], i = (d, l, p)=>new rr(this.module, l, this.output(d, p), p), a = (d, l)=>{\n                let p = Ct(d, l);\n                if (!p) throw new Error(\"Unsupported data type: \".concat(d));\n                let m = p > 0 ? this.backend.gpuDataManager.create(p).id : 0;\n                return new rr(this.module, d, m, l);\n            };\n            return this.backend.run(t, n, o, i, a, this.outputCount);\n        }\n        output(t, r) {\n            let n = this.module.stackSave();\n            try {\n                let o = this.module.PTR_SIZE, i = o === 4 ? \"i32\" : \"i64\", a = this.module.stackAlloc((1 + r.length) * o);\n                this.module.setValue(a, r.length, i);\n                for(let d = 0; d < r.length; d++)this.module.setValue(a + o * (d + 1), r[d], i);\n                return this.module._JsepOutput(this.opKernelContext, t, a);\n            } catch (o) {\n                throw new Error(\"Failed to generate kernel's output[\".concat(t, \"] with dims [\").concat(r, \"]. If you are running with pre-allocated output, please make sure the output type/dims are correct. Error: \").concat(o));\n            } finally{\n                this.module.stackRestore(n);\n            }\n        }\n        constructor(t, r, n){\n            this.module = t;\n            this.backend = r;\n            this.customDataOffset = 0;\n            this.customDataSize = 0;\n            this.adapterInfo = r.adapterInfo, this.deviceInfo = r.deviceInfo;\n            let o = t.PTR_SIZE, i = n / t.PTR_SIZE, a = o === 4 ? \"i32\" : \"i64\";\n            this.opKernelContext = Number(t.getValue(o * i++, a));\n            let d = Number(t.getValue(o * i++, a));\n            this.outputCount = Number(t.getValue(o * i++, a)), this.customDataOffset = Number(t.getValue(o * i++, \"*\")), this.customDataSize = Number(t.getValue(o * i++, a));\n            let l = [];\n            for(let p = 0; p < d; p++){\n                let m = Number(t.getValue(o * i++, a)), u = Number(t.getValue(o * i++, \"*\")), h = Number(t.getValue(o * i++, a)), _ = [];\n                for(let y = 0; y < h; y++)_.push(Number(t.getValue(o * i++, a)));\n                l.push(new rr(t, m, u, _));\n            }\n            this.inputs = l;\n        }\n    }, mg = async (e1, t, r, n)=>{\n        let o = t.jsepInit;\n        if (!o) throw new Error(\"Failed to initialize JSEP. The WebAssembly module is not built with JSEP support.\");\n        if (e1 === \"webgpu\") {\n            let i = new on;\n            await i.initialize(r, n), o(\"webgpu\", [\n                i,\n                (a)=>i.alloc(Number(a)),\n                (a)=>i.free(a),\n                function(a, d, l) {\n                    let p = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;\n                    if (p) ue(\"verbose\", ()=>\"[WebGPU] jsepCopyGpuToGpu: src=\".concat(Number(a), \", dst=\").concat(Number(d), \", size=\").concat(Number(l))), i.memcpy(Number(a), Number(d));\n                    else {\n                        ue(\"verbose\", ()=>\"[WebGPU] jsepCopyCpuToGpu: dataOffset=\".concat(Number(a), \", gpuDataId=\").concat(Number(d), \", size=\").concat(Number(l)));\n                        let m = t.HEAPU8.subarray(Number(a >>> 0), Number(a >>> 0) + Number(l));\n                        i.upload(Number(d), m);\n                    }\n                },\n                async (a, d, l)=>{\n                    ue(\"verbose\", ()=>\"[WebGPU] jsepCopyGpuToCpu: gpuDataId=\".concat(a, \", dataOffset=\").concat(d, \", size=\").concat(l)), await i.download(Number(a), ()=>t.HEAPU8.subarray(Number(d) >>> 0, Number(d + l) >>> 0));\n                },\n                (a, d, l)=>i.createKernel(a, Number(d), l, t.UTF8ToString(t._JsepGetNodeName(Number(d)))),\n                (a)=>i.releaseKernel(a),\n                (a, d, l, p)=>{\n                    ue(\"verbose\", ()=>\"[WebGPU] jsepRun: sessionHandle=\".concat(l, \", kernel=\").concat(a, \", contextDataOffset=\").concat(d));\n                    let m = new Eo(t, i, Number(d));\n                    return i.computeKernel(Number(a), m, p);\n                },\n                ()=>i.captureBegin(),\n                ()=>i.captureEnd(),\n                ()=>i.replay()\n            ]);\n        } else {\n            let i = new un(r);\n            o(\"webnn\", [\n                i,\n                ()=>i.reserveTensorId(),\n                (a)=>i.releaseTensorId(a),\n                async (a, d, l, p)=>i.ensureTensor(a, d, l, p),\n                (a, d)=>{\n                    i.uploadTensor(a, d);\n                },\n                async (a, d)=>i.downloadTensor(a, d)\n            ]);\n        }\n    };\n});\nvar fg, Tr, Ir, Pt, hg, Kt, Cr, Ar, uc, kr, Er, Pr, qn = U(()=>{\n    \"use strict\";\n    Ha();\n    qa();\n    te();\n    gt();\n    Or();\n    Xn();\n    fg = (e1, t)=>{\n        Ie()._OrtInit(e1, t) !== 0 && pe(\"Can't initialize onnxruntime.\");\n    }, Tr = async (e1)=>{\n        fg(e1.wasm.numThreads, Zt(e1.logLevel));\n    }, Ir = async (e1, t)=>{\n        {\n            let r = (sc(), br(ac)).init;\n            if (t === \"webgpu\") {\n                if (typeof navigator > \"u\" || !navigator.gpu) throw new Error(\"WebGPU is not supported in current environment\");\n                let n = e1.webgpu.adapter;\n                if (n) {\n                    if (typeof n.limits != \"object\" || typeof n.features != \"object\" || typeof n.requestDevice != \"function\") throw new Error(\"Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.\");\n                } else {\n                    let o = e1.webgpu.powerPreference;\n                    if (o !== void 0 && o !== \"low-power\" && o !== \"high-performance\") throw new Error('Invalid powerPreference setting: \"'.concat(o, '\"'));\n                    let i = e1.webgpu.forceFallbackAdapter;\n                    if (i !== void 0 && typeof i != \"boolean\") throw new Error('Invalid forceFallbackAdapter setting: \"'.concat(i, '\"'));\n                    if (n = await navigator.gpu.requestAdapter({\n                        powerPreference: o,\n                        forceFallbackAdapter: i\n                    }), !n) throw new Error('Failed to get GPU adapter. You may need to enable flag \"--enable-unsafe-webgpu\" if you are using Chrome.');\n                }\n                await r(\"webgpu\", Ie(), e1, n);\n            }\n            if (t === \"webnn\") {\n                if (typeof navigator > \"u\" || !navigator.ml) throw new Error(\"WebNN is not supported in current environment\");\n                await r(\"webnn\", Ie(), e1);\n            }\n        }\n    }, Pt = new Map, hg = (e1)=>{\n        let t = Ie(), r = t.stackSave();\n        try {\n            let n = t.PTR_SIZE, o = t.stackAlloc(2 * n);\n            t._OrtGetInputOutputCount(e1, o, o + n) !== 0 && pe(\"Can't get session input/output count.\");\n            let a = n === 4 ? \"i32\" : \"i64\";\n            return [\n                Number(t.getValue(o, a)),\n                Number(t.getValue(o + n, a))\n            ];\n        } finally{\n            t.stackRestore(r);\n        }\n    }, Kt = (e1)=>{\n        let t = Ie(), r = t._malloc(e1.byteLength);\n        if (r === 0) throw new Error(\"Can't create a session. failed to allocate a buffer of size \".concat(e1.byteLength, \".\"));\n        return t.HEAPU8.set(e1, r), [\n            r,\n            e1.byteLength\n        ];\n    }, Cr = async (e1, t)=>{\n        let r, n, o = Ie();\n        Array.isArray(e1) ? [r, n] = e1 : e1.buffer === o.HEAPU8.buffer ? [r, n] = [\n            e1.byteOffset,\n            e1.byteLength\n        ] : [r, n] = Kt(e1);\n        let i = 0, a = 0, d = 0, l = [], p = [], m = [];\n        try {\n            var _o_jsepOnCreateSession;\n            if ([a, l] = Fa(t), (t === null || t === void 0 ? void 0 : t.externalData) && o.mountExternalData) {\n                let v = [];\n                for (let S of t.externalData){\n                    let T = typeof S == \"string\" ? S : S.path;\n                    v.push(Qt(typeof S == \"string\" ? S : S.data).then((A)=>{\n                        o.mountExternalData(T, A);\n                    }));\n                }\n                await Promise.all(v);\n            }\n            var _t_executionProviders;\n            for (let v of (_t_executionProviders = t === null || t === void 0 ? void 0 : t.executionProviders) !== null && _t_executionProviders !== void 0 ? _t_executionProviders : [])if ((typeof v == \"string\" ? v : v.name) === \"webnn\") {\n                if (o.shouldTransferToMLTensor = !1, typeof v != \"string\") {\n                    let T = v, A = T === null || T === void 0 ? void 0 : T.context, k = T === null || T === void 0 ? void 0 : T.gpuDevice, P = T === null || T === void 0 ? void 0 : T.deviceType, D = T === null || T === void 0 ? void 0 : T.powerPreference;\n                    A ? o.currentContext = A : k ? o.currentContext = await o.jsepCreateMLContext(k) : o.currentContext = await o.jsepCreateMLContext({\n                        deviceType: P,\n                        powerPreference: D\n                    });\n                } else o.currentContext = await o.jsepCreateMLContext();\n                break;\n            }\n            i = await o._OrtCreateSession(r, n, a), i === 0 && pe(\"Can't create a session.\"), (_o_jsepOnCreateSession = o.jsepOnCreateSession) === null || _o_jsepOnCreateSession === void 0 ? void 0 : _o_jsepOnCreateSession.call(o), o.currentContext && (o.jsepRegisterMLContext(i, o.currentContext), o.currentContext = void 0, o.shouldTransferToMLTensor = !0);\n            let [u, h] = hg(i), _ = !!(t === null || t === void 0 ? void 0 : t.enableGraphCapture), y = [], g = [], x = [];\n            for(let v = 0; v < u; v++){\n                let S = o._OrtGetInputName(i, v);\n                S === 0 && pe(\"Can't get an input name.\"), p.push(S), y.push(o.UTF8ToString(S));\n            }\n            for(let v = 0; v < h; v++){\n                let S = o._OrtGetOutputName(i, v);\n                S === 0 && pe(\"Can't get an output name.\"), m.push(S);\n                let T = o.UTF8ToString(S);\n                g.push(T);\n                {\n                    var _t_preferredOutputLocation;\n                    if (_ && (t === null || t === void 0 ? void 0 : t.preferredOutputLocation) === void 0) {\n                        x.push(\"gpu-buffer\");\n                        continue;\n                    }\n                    var _t_preferredOutputLocation_T;\n                    let A = typeof (t === null || t === void 0 ? void 0 : t.preferredOutputLocation) == \"string\" ? t.preferredOutputLocation : (_t_preferredOutputLocation_T = t === null || t === void 0 ? void 0 : (_t_preferredOutputLocation = t.preferredOutputLocation) === null || _t_preferredOutputLocation === void 0 ? void 0 : _t_preferredOutputLocation[T]) !== null && _t_preferredOutputLocation_T !== void 0 ? _t_preferredOutputLocation_T : \"cpu\";\n                    if (A !== \"cpu\" && A !== \"cpu-pinned\" && A !== \"gpu-buffer\" && A !== \"ml-tensor\") throw new Error(\"Not supported preferred output location: \".concat(A, \".\"));\n                    if (_ && A !== \"gpu-buffer\") throw new Error(\"Not supported preferred output location: \".concat(A, \". Only 'gpu-buffer' location is supported when enableGraphCapture is true.\"));\n                    x.push(A);\n                }\n            }\n            let $ = null;\n            return x.some((v)=>v === \"gpu-buffer\" || v === \"ml-tensor\") && (d = o._OrtCreateBinding(i), d === 0 && pe(\"Can't create IO binding.\"), $ = {\n                handle: d,\n                outputPreferredLocations: x,\n                outputPreferredLocationsEncoded: x.map((v)=>Qn(v))\n            }), Pt.set(i, [\n                i,\n                p,\n                m,\n                $,\n                _,\n                !1\n            ]), [\n                i,\n                y,\n                g\n            ];\n        } catch (u) {\n            throw p.forEach((h)=>o._OrtFree(h)), m.forEach((h)=>o._OrtFree(h)), d !== 0 && o._OrtReleaseBinding(d) !== 0 && pe(\"Can't release IO binding.\"), i !== 0 && o._OrtReleaseSession(i) !== 0 && pe(\"Can't release session.\"), u;\n        } finally{\n            var _o_unmountExternalData;\n            o._free(r), a !== 0 && o._OrtReleaseSessionOptions(a) !== 0 && pe(\"Can't release session options.\"), l.forEach((u)=>o._free(u)), (_o_unmountExternalData = o.unmountExternalData) === null || _o_unmountExternalData === void 0 ? void 0 : _o_unmountExternalData.call(o);\n        }\n    }, Ar = (e1)=>{\n        var _t_jsepOnReleaseSession;\n        let t = Ie(), r = Pt.get(e1);\n        if (!r) throw new Error(\"cannot release session. invalid session id: \".concat(e1));\n        let [n, o, i, a, d] = r;\n        a && (d && t._OrtClearBoundOutputs(a.handle) !== 0 && pe(\"Can't clear bound outputs.\"), t._OrtReleaseBinding(a.handle) !== 0 && pe(\"Can't release IO binding.\")), (_t_jsepOnReleaseSession = t.jsepOnReleaseSession) === null || _t_jsepOnReleaseSession === void 0 ? void 0 : _t_jsepOnReleaseSession.call(t, e1), o.forEach((l)=>t._OrtFree(l)), i.forEach((l)=>t._OrtFree(l)), t._OrtReleaseSession(n) !== 0 && pe(\"Can't release session.\"), Pt.delete(e1);\n    }, uc = function(e1, t, r, n, o) {\n        let i = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : !1;\n        if (!e1) {\n            t.push(0);\n            return;\n        }\n        let a = Ie(), d = a.PTR_SIZE, l = e1[0], p = e1[1], m = e1[3], u, h;\n        if (l === \"string\" && (m === \"gpu-buffer\" || m === \"ml-tensor\")) throw new Error(\"String tensor is not supported on GPU.\");\n        if (i && m !== \"gpu-buffer\") throw new Error(\"External buffer must be provided for input/output index \".concat(o, \" when enableGraphCapture is true.\"));\n        if (m === \"gpu-buffer\") {\n            let g = e1[2].gpuBuffer;\n            h = Ct(Yt(l), p);\n            let x = a.jsepRegisterBuffer;\n            if (!x) throw new Error('Tensor location \"gpu-buffer\" is not supported without using WebGPU.');\n            u = x(n, o, g, h);\n        } else if (m === \"ml-tensor\") {\n            let g = e1[2].mlTensor;\n            h = Ct(Yt(l), p);\n            let x = a.jsepRegisterMLTensor;\n            if (!x) throw new Error('Tensor location \"ml-tensor\" is not supported without using WebNN.');\n            u = x(g, Yt(l), p);\n        } else {\n            let g = e1[2];\n            if (Array.isArray(g)) {\n                h = d * g.length, u = a._malloc(h), r.push(u);\n                for(let x = 0; x < g.length; x++){\n                    if (typeof g[x] != \"string\") throw new TypeError(\"tensor data at index \".concat(x, \" is not a string\"));\n                    a.setValue(u + x * d, ke(g[x], r), \"*\");\n                }\n            } else h = g.byteLength, u = a._malloc(h), r.push(u), a.HEAPU8.set(new Uint8Array(g.buffer, g.byteOffset, h), u);\n        }\n        let _ = a.stackSave(), y = a.stackAlloc(4 * p.length);\n        try {\n            p.forEach((x, $)=>a.setValue(y + $ * d, x, d === 4 ? \"i32\" : \"i64\"));\n            let g = a._OrtCreateTensor(Yt(l), u, h, y, p.length, Qn(m));\n            g === 0 && pe(\"Can't create tensor for input/output. session=\".concat(n, \", index=\").concat(o, \".\")), t.push(g);\n        } finally{\n            a.stackRestore(_);\n        }\n    }, kr = async (e1, t, r, n, o, i)=>{\n        let a = Ie(), d = a.PTR_SIZE, l = Pt.get(e1);\n        if (!l) throw new Error(\"cannot run inference. invalid session id: \".concat(e1));\n        let p = l[0], m = l[1], u = l[2], h = l[3], _ = l[4], y = l[5], g = t.length, x = n.length, $ = 0, v = [], S = [], T = [], A = [], k = a.stackSave(), P = a.stackAlloc(g * d), D = a.stackAlloc(g * d), R = a.stackAlloc(x * d), G = a.stackAlloc(x * d);\n        try {\n            var _a_jsepOnRunStart;\n            (_a_jsepOnRunStart = a.jsepOnRunStart) === null || _a_jsepOnRunStart === void 0 ? void 0 : _a_jsepOnRunStart.call(a, p), [$, v] = Ga(i);\n            for(let V = 0; V < g; V++)uc(r[V], S, A, e1, t[V], _);\n            for(let V = 0; V < x; V++)uc(o[V], T, A, e1, g + n[V], _);\n            for(let V = 0; V < g; V++)a.setValue(P + V * d, S[V], \"*\"), a.setValue(D + V * d, m[t[V]], \"*\");\n            for(let V = 0; V < x; V++)a.setValue(R + V * d, T[V], \"*\"), a.setValue(G + V * d, u[n[V]], \"*\");\n            if (h && !y) {\n                let { handle: V, outputPreferredLocations: Q, outputPreferredLocationsEncoded: se } = h;\n                if (m.length !== g) throw new Error(\"input count from feeds (\".concat(g, \") is expected to be always equal to model's input count (\").concat(m.length, \").\"));\n                for(let Y = 0; Y < g; Y++){\n                    let ee = t[Y];\n                    await a._OrtBindInput(V, m[ee], S[Y]) !== 0 && pe(\"Can't bind input[\".concat(Y, \"] for session=\").concat(e1, \".\"));\n                }\n                for(let Y = 0; Y < x; Y++){\n                    var _o_Y;\n                    let ee = n[Y];\n                    ((_o_Y = o[Y]) === null || _o_Y === void 0 ? void 0 : _o_Y[3]) ? a._OrtBindOutput(V, u[ee], T[Y], 0) !== 0 && pe(\"Can't bind pre-allocated output[\".concat(Y, \"] for session=\").concat(e1, \".\")) : a._OrtBindOutput(V, u[ee], 0, se[ee]) !== 0 && pe(\"Can't bind output[\".concat(Y, \"] to \").concat(Q[Y], \" for session=\").concat(e1, \".\"));\n                }\n                Pt.set(e1, [\n                    p,\n                    m,\n                    u,\n                    h,\n                    _,\n                    !0\n                ]);\n            }\n            let K;\n            h ? K = await a._OrtRunWithBinding(p, h.handle, x, R, $) : K = await a._OrtRun(p, D, P, g, G, x, R, $), K !== 0 && pe(\"failed to call OrtRun().\");\n            let j = [];\n            for(let V = 0; V < x; V++){\n                let Q = Number(a.getValue(R + V * d, \"*\"));\n                if (Q === T[V]) {\n                    j.push(o[V]);\n                    continue;\n                }\n                let se = a.stackSave(), Y = a.stackAlloc(4 * d), ee = !1, J, ne = 0;\n                try {\n                    a._OrtGetTensorData(Q, Y, Y + d, Y + 2 * d, Y + 3 * d) !== 0 && pe(\"Can't access output tensor data on index \".concat(V, \".\"));\n                    let Oe = d === 4 ? \"i32\" : \"i64\", $e = Number(a.getValue(Y, Oe));\n                    ne = a.getValue(Y + d, \"*\");\n                    let le = a.getValue(Y + d * 2, \"*\"), W = Number(a.getValue(Y + d * 3, Oe)), q = [];\n                    for(let we = 0; we < W; we++)q.push(Number(a.getValue(le + we * d, Oe)));\n                    a._OrtFree(le) !== 0 && pe(\"Can't free memory for tensor dims.\");\n                    let he = q.reduce((we, ye)=>we * ye, 1);\n                    J = bt($e);\n                    let Ge = h === null || h === void 0 ? void 0 : h.outputPreferredLocations[n[V]];\n                    if (J === \"string\") {\n                        if (Ge === \"gpu-buffer\" || Ge === \"ml-tensor\") throw new Error(\"String tensor is not supported on GPU.\");\n                        let we = [];\n                        for(let ye = 0; ye < he; ye++){\n                            let Ye = a.getValue(ne + ye * d, \"*\"), Lt = a.getValue(ne + (ye + 1) * d, \"*\"), fn = ye === he - 1 ? void 0 : Lt - Ye;\n                            we.push(a.UTF8ToString(Ye, fn));\n                        }\n                        j.push([\n                            J,\n                            q,\n                            we,\n                            \"cpu\"\n                        ]);\n                    } else if (Ge === \"gpu-buffer\" && he > 0) {\n                        let we = a.jsepGetBuffer;\n                        if (!we) throw new Error('preferredLocation \"gpu-buffer\" is not supported without using WebGPU.');\n                        let ye = we(ne), Ye = Ct($e, he);\n                        if (Ye === void 0 || !Br(J)) throw new Error(\"Unsupported data type: \".concat(J));\n                        ee = !0, j.push([\n                            J,\n                            q,\n                            {\n                                gpuBuffer: ye,\n                                download: a.jsepCreateDownloader(ye, Ye, J),\n                                dispose: ()=>{\n                                    a._OrtReleaseTensor(Q) !== 0 && pe(\"Can't release tensor.\");\n                                }\n                            },\n                            \"gpu-buffer\"\n                        ]);\n                    } else if (Ge === \"ml-tensor\" && he > 0) {\n                        let we = a.jsepEnsureTensor;\n                        if (!we) throw new Error('preferredLocation \"ml-tensor\" is not supported without using WebNN.');\n                        if (Ct($e, he) === void 0 || !Mr(J)) throw new Error(\"Unsupported data type: \".concat(J));\n                        let Ye = await we(ne, $e, q, !1);\n                        ee = !0, j.push([\n                            J,\n                            q,\n                            {\n                                mlTensor: Ye,\n                                download: a.jsepCreateMLTensorDownloader(ne, J),\n                                dispose: ()=>{\n                                    a.jsepReleaseTensorId(ne), a._OrtReleaseTensor(Q);\n                                }\n                            },\n                            \"ml-tensor\"\n                        ]);\n                    } else {\n                        let we = Dr(J), ye = new we(he);\n                        new Uint8Array(ye.buffer, ye.byteOffset, ye.byteLength).set(a.HEAPU8.subarray(ne, ne + ye.byteLength)), j.push([\n                            J,\n                            q,\n                            ye,\n                            \"cpu\"\n                        ]);\n                    }\n                } finally{\n                    a.stackRestore(se), J === \"string\" && ne && a._free(ne), ee || a._OrtReleaseTensor(Q);\n                }\n            }\n            return h && !_ && (a._OrtClearBoundOutputs(h.handle) !== 0 && pe(\"Can't clear bound outputs.\"), Pt.set(e1, [\n                p,\n                m,\n                u,\n                h,\n                _,\n                !1\n            ])), j;\n        } finally{\n            a.stackRestore(k), S.forEach((K)=>a._OrtReleaseTensor(K)), T.forEach((K)=>a._OrtReleaseTensor(K)), A.forEach((K)=>a._free(K)), $ !== 0 && a._OrtReleaseRunOptions($), v.forEach((K)=>a._free(K));\n        }\n    }, Er = (e1)=>{\n        let t = Ie(), r = Pt.get(e1);\n        if (!r) throw new Error(\"invalid session id\");\n        let n = r[0], o = t._OrtEndProfiling(n);\n        o === 0 && pe(\"Can't get an profile file name.\"), t._OrtFree(o);\n    }, Pr = (e1)=>{\n        let t = [];\n        for (let r of e1){\n            let n = r[2];\n            !Array.isArray(n) && \"buffer\" in n && t.push(n.buffer);\n        }\n        return t;\n    };\n});\nvar zt, Le, nr, ln, cn, dn, Po, zo, Vt, Wt, bg, dc, lc, cc, pc, mc, fc, hc, Oo = U(()=>{\n    \"use strict\";\n    We();\n    qn();\n    gt();\n    xr();\n    zt = ()=>!!ve.wasm.proxy && typeof document < \"u\", nr = !1, ln = !1, cn = !1, zo = new Map, Vt = (e1, t)=>{\n        let r = zo.get(e1);\n        r ? r.push(t) : zo.set(e1, [\n            t\n        ]);\n    }, Wt = ()=>{\n        if (nr || !ln || cn || !Le) throw new Error(\"worker not ready\");\n    }, bg = (e1)=>{\n        switch(e1.data.type){\n            case \"init-wasm\":\n                nr = !1, e1.data.err ? (cn = !0, Po[1](e1.data.err)) : (ln = !0, Po[0]()), dn && (URL.revokeObjectURL(dn), dn = void 0);\n                break;\n            case \"init-ep\":\n            case \"copy-from\":\n            case \"create\":\n            case \"release\":\n            case \"run\":\n            case \"end-profiling\":\n                {\n                    let t = zo.get(e1.data.type);\n                    e1.data.err ? t.shift()[1](e1.data.err) : t.shift()[0](e1.data.out);\n                    break;\n                }\n            default:\n        }\n    }, dc = async ()=>{\n        if (!ln) {\n            if (nr) throw new Error(\"multiple calls to 'initWasm()' detected.\");\n            if (cn) throw new Error(\"previous call to 'initWasm()' failed.\");\n            if (nr = !0, zt()) return new Promise((e1, t)=>{\n                Le === null || Le === void 0 ? void 0 : Le.terminate(), Va().then((param)=>{\n                    let [r, n] = param;\n                    try {\n                        var _url;\n                        Le = n, Le.onerror = (i)=>t(i), Le.onmessage = bg, Po = [\n                            e1,\n                            t\n                        ];\n                        let o = {\n                            type: \"init-wasm\",\n                            in: ve\n                        };\n                        !o.in.wasm.wasmPaths && (r || ((_url = \"file:///Users/amityadav/Desktop/Text-Behind%20Image/node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs\") === null || _url === void 0 ? void 0 : _url.startsWith(\"file:\"))) && (o.in.wasm.wasmPaths = {\n                            wasm: /* asset import */ new __webpack_require__.U(__webpack_require__(/*! ort-wasm-simd-threaded.jsep.wasm */ \"(app-pages-browser)/./node_modules/onnxruntime-web/dist/ort-wasm-simd-threaded.jsep.wasm\")).href\n                        }), Le.postMessage(o), dn = r;\n                    } catch (o) {\n                        t(o);\n                    }\n                }, t);\n            });\n            try {\n                await Sr(ve.wasm), await Tr(ve), ln = !0;\n            } catch (e1) {\n                throw cn = !0, e1;\n            } finally{\n                nr = !1;\n            }\n        }\n    }, lc = async (e1)=>{\n        if (zt()) return Wt(), new Promise((t, r)=>{\n            Vt(\"init-ep\", [\n                t,\n                r\n            ]);\n            let n = {\n                type: \"init-ep\",\n                in: {\n                    epName: e1,\n                    env: ve\n                }\n            };\n            Le.postMessage(n);\n        });\n        await Ir(ve, e1);\n    }, cc = async (e1)=>zt() ? (Wt(), new Promise((t, r)=>{\n            Vt(\"copy-from\", [\n                t,\n                r\n            ]);\n            let n = {\n                type: \"copy-from\",\n                in: {\n                    buffer: e1\n                }\n            };\n            Le.postMessage(n, [\n                e1.buffer\n            ]);\n        })) : Kt(e1), pc = async (e1, t)=>{\n        if (zt()) {\n            if (t === null || t === void 0 ? void 0 : t.preferredOutputLocation) throw new Error('session option \"preferredOutputLocation\" is not supported for proxy.');\n            return Wt(), new Promise((r, n)=>{\n                Vt(\"create\", [\n                    r,\n                    n\n                ]);\n                let o = {\n                    type: \"create\",\n                    in: {\n                        model: e1,\n                        options: {\n                            ...t\n                        }\n                    }\n                }, i = [];\n                e1 instanceof Uint8Array && i.push(e1.buffer), Le.postMessage(o, i);\n            });\n        } else return Cr(e1, t);\n    }, mc = async (e1)=>{\n        if (zt()) return Wt(), new Promise((t, r)=>{\n            Vt(\"release\", [\n                t,\n                r\n            ]);\n            let n = {\n                type: \"release\",\n                in: e1\n            };\n            Le.postMessage(n);\n        });\n        Ar(e1);\n    }, fc = async (e1, t, r, n, o, i)=>{\n        if (zt()) {\n            if (r.some((a)=>a[3] !== \"cpu\")) throw new Error(\"input tensor on GPU is not supported for proxy.\");\n            if (o.some((a)=>a)) throw new Error(\"pre-allocated output tensor is not supported for proxy.\");\n            return Wt(), new Promise((a, d)=>{\n                Vt(\"run\", [\n                    a,\n                    d\n                ]);\n                let l = r, p = {\n                    type: \"run\",\n                    in: {\n                        sessionId: e1,\n                        inputIndices: t,\n                        inputs: l,\n                        outputIndices: n,\n                        options: i\n                    }\n                };\n                Le.postMessage(p, Pr(l));\n            });\n        } else return kr(e1, t, r, n, o, i);\n    }, hc = async (e1)=>{\n        if (zt()) return Wt(), new Promise((t, r)=>{\n            Vt(\"end-profiling\", [\n                t,\n                r\n            ]);\n            let n = {\n                type: \"end-profiling\",\n                in: e1\n            };\n            Le.postMessage(n);\n        });\n        Er(e1);\n    };\n});\nvar gc, yg, pn, bc = U(()=>{\n    \"use strict\";\n    We();\n    Oo();\n    te();\n    $r();\n    Xn();\n    gc = (e1, t)=>{\n        switch(e1.location){\n            case \"cpu\":\n                return [\n                    e1.type,\n                    e1.dims,\n                    e1.data,\n                    \"cpu\"\n                ];\n            case \"gpu-buffer\":\n                return [\n                    e1.type,\n                    e1.dims,\n                    {\n                        gpuBuffer: e1.gpuBuffer\n                    },\n                    \"gpu-buffer\"\n                ];\n            case \"ml-tensor\":\n                return [\n                    e1.type,\n                    e1.dims,\n                    {\n                        mlTensor: e1.mlTensor\n                    },\n                    \"ml-tensor\"\n                ];\n            default:\n                throw new Error(\"invalid data location: \".concat(e1.location, \" for \").concat(t()));\n        }\n    }, yg = (e1)=>{\n        switch(e1[3]){\n            case \"cpu\":\n                return new He(e1[0], e1[2], e1[1]);\n            case \"gpu-buffer\":\n                {\n                    let t = e1[0];\n                    if (!Br(t)) throw new Error(\"not supported data type: \".concat(t, \" for deserializing GPU tensor\"));\n                    let { gpuBuffer: r, download: n, dispose: o } = e1[2];\n                    return He.fromGpuBuffer(r, {\n                        dataType: t,\n                        dims: e1[1],\n                        download: n,\n                        dispose: o\n                    });\n                }\n            case \"ml-tensor\":\n                {\n                    let t = e1[0];\n                    if (!Mr(t)) throw new Error(\"not supported data type: \".concat(t, \" for deserializing MLTensor tensor\"));\n                    let { mlTensor: r, download: n, dispose: o } = e1[2];\n                    return He.fromMLTensor(r, {\n                        dataType: t,\n                        dims: e1[1],\n                        download: n,\n                        dispose: o\n                    });\n                }\n            default:\n                throw new Error(\"invalid data location: \".concat(e1[3]));\n        }\n    }, pn = class {\n        async fetchModelAndCopyToWasmMemory(t) {\n            return cc(await Qt(t));\n        }\n        async loadModel(t, r) {\n            Ue();\n            let n;\n            typeof t == \"string\" ?  false ? 0 : n = await this.fetchModelAndCopyToWasmMemory(t) : n = t, [this.sessionId, this.inputNames, this.outputNames] = await pc(n, r), De();\n        }\n        async dispose() {\n            return mc(this.sessionId);\n        }\n        async run(t, r, n) {\n            Ue();\n            let o = [], i = [];\n            Object.entries(t).forEach((h)=>{\n                let _ = h[0], y = h[1], g = this.inputNames.indexOf(_);\n                if (g === -1) throw new Error(\"invalid input '\".concat(_, \"'\"));\n                o.push(y), i.push(g);\n            });\n            let a = [], d = [];\n            Object.entries(r).forEach((h)=>{\n                let _ = h[0], y = h[1], g = this.outputNames.indexOf(_);\n                if (g === -1) throw new Error(\"invalid output '\".concat(_, \"'\"));\n                a.push(y), d.push(g);\n            });\n            let l = o.map((h, _)=>gc(h, ()=>'input \"'.concat(this.inputNames[i[_]], '\"'))), p = a.map((h, _)=>h ? gc(h, ()=>'output \"'.concat(this.outputNames[d[_]], '\"')) : null), m = await fc(this.sessionId, i, l, d, p, n), u = {};\n            var _a_h;\n            for(let h = 0; h < m.length; h++)u[this.outputNames[d[h]]] = (_a_h = a[h]) !== null && _a_h !== void 0 ? _a_h : yg(m[h]);\n            return De(), u;\n        }\n        startProfiling() {}\n        endProfiling() {\n            hc(this.sessionId);\n        }\n    };\n});\nvar _c = {};\nFt(_c, {\n    OnnxruntimeWebAssemblyBackend: ()=>mn,\n    initializeFlags: ()=>yc,\n    wasmBackend: ()=>_g\n});\nvar yc, mn, _g, wc = U(()=>{\n    \"use strict\";\n    We();\n    Oo();\n    bc();\n    yc = ()=>{\n        if ((typeof ve.wasm.initTimeout != \"number\" || ve.wasm.initTimeout < 0) && (ve.wasm.initTimeout = 0), ve.wasm.simd === !1 && console.warn('Deprecated property \"env.wasm.simd\" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'), typeof ve.wasm.proxy != \"boolean\" && (ve.wasm.proxy = !1), typeof ve.wasm.trace != \"boolean\" && (ve.wasm.trace = !1), typeof ve.wasm.numThreads != \"number\" || !Number.isInteger(ve.wasm.numThreads) || ve.wasm.numThreads <= 0) if (typeof self < \"u\" && !self.crossOriginIsolated) ve.wasm.numThreads = 1;\n        else {\n            let e1 = typeof navigator > \"u\" ? Nn(\"node:os\").cpus().length : navigator.hardwareConcurrency;\n            ve.wasm.numThreads = Math.min(4, Math.ceil((e1 || 1) / 2));\n        }\n    }, mn = class {\n        async init(t) {\n            yc(), await dc(), await lc(t);\n        }\n        async createInferenceSessionHandler(t, r) {\n            let n = new pn;\n            return await n.loadModel(t, r), Promise.resolve(n);\n        }\n    }, _g = new mn;\n});\nWe();\nWe();\nWe();\nvar Ca = \"1.21.0-dev.20250114-228dd16893\";\nvar $1 = Fn;\n{\n    let e1 = (wc(), br(_c)).wasmBackend;\n    St(\"webgpu\", e1, 5), St(\"webnn\", e1, 5), St(\"cpu\", e1, 10), St(\"wasm\", e1, 10);\n}Object.defineProperty(ve.versions, \"web\", {\n    value: Ca,\n    enumerable: !0\n});\n /**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */  /**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */  /**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */  //# sourceMappingURL=ort.webgpu.bundle.min.mjs.map\nvar _c1, _c2, _c3, _c4, _c5, _c6, _c7, _c8, _c9, _c10;\n$RefreshReg$(_c1, \"Sa$U\");\n$RefreshReg$(_c2, \"Sa\");\n$RefreshReg$(_c3, \"Ta$U\");\n$RefreshReg$(_c4, \"Ta\");\n$RefreshReg$(_c5, \"Ia$U\");\n$RefreshReg$(_c6, \"Ia\");\n$RefreshReg$(_c7, \"We$U\");\n$RefreshReg$(_c8, \"We\");\n$RefreshReg$(_c9, \"Nr$U\");\n$RefreshReg$(_c10, \"Nr\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vbm54cnVudGltZS13ZWIvZGlzdC9vcnQud2ViZ3B1LmJ1bmRsZS5taW4ubWpzPzQ3MDkiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTs7OztDQUlDLEdBQ0QsSUFBSUEsS0FBR0MsT0FBT0MsY0FBYztBQUFDLElBQUlDLEtBQUdGLE9BQU9HLHdCQUF3QjtBQUFDLElBQUlDLEtBQUdKLE9BQU9LLG1CQUFtQjtBQUFDLElBQUlDLEtBQUdOLE9BQU9PLFNBQVMsQ0FBQ0MsY0FBYztBQUFDLElBQUlDLEtBQUcsQ0FBQ0MsQ0FBQUEsS0FBRyxPQUFPQyxVQUFRLE1BQUlBLFVBQVEsT0FBT0MsUUFBTSxNQUFJLElBQUlBLE1BQU1GLElBQUU7UUFBQ0csS0FBSSxDQUFDQyxHQUFFQyxJQUFJLENBQUMsT0FBT0osVUFBUSxNQUFJQSxVQUFRRyxDQUFBQSxDQUFFLENBQUNDLEVBQUU7SUFBQSxLQUFHTCxFQUFBQSxFQUFHLFNBQVNBLEVBQUM7SUFBRSxJQUFHLE9BQU9DLFVBQVEsS0FBSSxPQUFPQSxRQUFRSyxLQUFLLENBQUMsSUFBSSxFQUFDQztJQUFXLE1BQU1DLE1BQU0seUJBQXVCUixLQUFFO0FBQXFCO0FBQUcsSUFBSVMsSUFBRSxDQUFDVCxJQUFFSSxJQUFJLElBQUtKLENBQUFBLE1BQUlJLENBQUFBLElBQUVKLEdBQUVBLEtBQUUsRUFBQyxHQUFHSSxDQUFBQTtBQUFHLElBQUlNLEtBQUcsQ0FBQ1YsSUFBRUk7SUFBSyxJQUFJLElBQUlDLEtBQUtELEVBQUVmLEdBQUdXLElBQUVLLEdBQUU7UUFBQ0YsS0FBSUMsQ0FBQyxDQUFDQyxFQUFFO1FBQUNNLFlBQVcsQ0FBQztJQUFDO0FBQUUsR0FBRUMsS0FBRyxDQUFDWixJQUFFSSxHQUFFQyxHQUFFUTtJQUFLLElBQUdULEtBQUcsT0FBT0EsS0FBRyxZQUFVLE9BQU9BLEtBQUcsWUFBVyxLQUFJLElBQUlVLEtBQUtwQixHQUFHVSxHQUFHLENBQUNS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bnpELEVBQUVxekQsU0FBUyxDQUFDOXpELEdBQUVDLElBQUdzSCxRQUFRbUwsT0FBTyxDQUFDalM7UUFBRTtJQUFDLEdBQUU0ekQsS0FBRyxJQUFJSjtBQUFFO0FBQUd2bUQ7QUFBS0E7QUFBS0E7QUFBSyxJQUFJZ21CLEtBQUc7QUFBaUMsSUFBSStnQyxLQUFHdm5EO0FBQUc7SUFBQyxJQUFJdE4sS0FBRSxDQUFDMDBELE1BQUsxekQsR0FBR216RCxHQUFFLEVBQUdLLFdBQVc7SUFBQ3B6RCxHQUFHLFVBQVNwQixJQUFFLElBQUdvQixHQUFHLFNBQVFwQixJQUFFLElBQUdvQixHQUFHLE9BQU1wQixJQUFFLEtBQUlvQixHQUFHLFFBQU9wQixJQUFFO0FBQUcsQ0FBQ1YsT0FBT0MsY0FBYyxDQUFDOEUsR0FBR0gsUUFBUSxFQUFDLE9BQU07SUFBQ2pELE9BQU02eUI7SUFBR256QixZQUFXLENBQUM7QUFBQztBQUFxSixDQUN0Z3pDOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxJQUNEOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxJQUNEOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxJQUNELGtEQUFrRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvb25ueHJ1bnRpbWUtd2ViL2Rpc3Qvb3J0LndlYmdwdS5idW5kbGUubWluLm1qcz9kMGYyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogT05OWCBSdW50aW1lIFdlYiB2MS4yMS4wLWRldi4yMDI1MDExNC0yMjhkZDE2ODkzXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xudmFyIFVuPU9iamVjdC5kZWZpbmVQcm9wZXJ0eTt2YXIgVnA9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjt2YXIgV3A9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7dmFyIExwPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7dmFyIE5uPShlPT50eXBlb2YgcmVxdWlyZTxcInVcIj9yZXF1aXJlOnR5cGVvZiBQcm94eTxcInVcIj9uZXcgUHJveHkoZSx7Z2V0Oih0LHIpPT4odHlwZW9mIHJlcXVpcmU8XCJ1XCI/cmVxdWlyZTp0KVtyXX0pOmUpKGZ1bmN0aW9uKGUpe2lmKHR5cGVvZiByZXF1aXJlPFwidVwiKXJldHVybiByZXF1aXJlLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt0aHJvdyBFcnJvcignRHluYW1pYyByZXF1aXJlIG9mIFwiJytlKydcIiBpcyBub3Qgc3VwcG9ydGVkJyl9KTt2YXIgVT0oZSx0KT0+KCk9PihlJiYodD1lKGU9MCkpLHQpO3ZhciBGdD0oZSx0KT0+e2Zvcih2YXIgciBpbiB0KVVuKGUscix7Z2V0OnRbcl0sZW51bWVyYWJsZTohMH0pfSxHcD0oZSx0LHIsbik9PntpZih0JiZ0eXBlb2YgdD09XCJvYmplY3RcInx8dHlwZW9mIHQ9PVwiZnVuY3Rpb25cIilmb3IobGV0IG8gb2YgV3AodCkpIUxwLmNhbGwoZSxvKSYmbyE9PXImJlVuKGUsbyx7Z2V0OigpPT50W29dLGVudW1lcmFibGU6IShuPVZwKHQsbykpfHxuLmVudW1lcmFibGV9KTtyZXR1cm4gZX07dmFyIGJyPWU9PkdwKFVuKHt9LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUpO3ZhciB5cix4dCxTdCxIcCxKaSxWbj1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7eXI9bmV3IE1hcCx4dD1bXSxTdD0oZSx0LHIpPT57aWYodCYmdHlwZW9mIHQuaW5pdD09XCJmdW5jdGlvblwiJiZ0eXBlb2YgdC5jcmVhdGVJbmZlcmVuY2VTZXNzaW9uSGFuZGxlcj09XCJmdW5jdGlvblwiKXtsZXQgbj15ci5nZXQoZSk7aWYobj09PXZvaWQgMCl5ci5zZXQoZSx7YmFja2VuZDp0LHByaW9yaXR5OnJ9KTtlbHNle2lmKG4ucHJpb3JpdHk+cilyZXR1cm47aWYobi5wcmlvcml0eT09PXImJm4uYmFja2VuZCE9PXQpdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgcmVnaXN0ZXIgYmFja2VuZCBcIiR7ZX1cIiB1c2luZyBwcmlvcml0eSAke3J9YCl9aWYocj49MCl7bGV0IG89eHQuaW5kZXhPZihlKTtvIT09LTEmJnh0LnNwbGljZShvLDEpO2ZvcihsZXQgaT0wO2k8eHQubGVuZ3RoO2krKylpZih5ci5nZXQoeHRbaV0pLnByaW9yaXR5PD1yKXt4dC5zcGxpY2UoaSwwLGUpO3JldHVybn14dC5wdXNoKGUpfXJldHVybn10aHJvdyBuZXcgVHlwZUVycm9yKFwibm90IGEgdmFsaWQgYmFja2VuZFwiKX0sSHA9YXN5bmMgZT0+e2xldCB0PXlyLmdldChlKTtpZighdClyZXR1cm5cImJhY2tlbmQgbm90IGZvdW5kLlwiO2lmKHQuaW5pdGlhbGl6ZWQpcmV0dXJuIHQuYmFja2VuZDtpZih0LmFib3J0ZWQpcmV0dXJuIHQuZXJyb3I7e2xldCByPSEhdC5pbml0UHJvbWlzZTt0cnl7cmV0dXJuIHJ8fCh0LmluaXRQcm9taXNlPXQuYmFja2VuZC5pbml0KGUpKSxhd2FpdCB0LmluaXRQcm9taXNlLHQuaW5pdGlhbGl6ZWQ9ITAsdC5iYWNrZW5kfWNhdGNoKG4pe3JldHVybiByfHwodC5lcnJvcj1gJHtufWAsdC5hYm9ydGVkPSEwKSx0LmVycm9yfWZpbmFsbHl7ZGVsZXRlIHQuaW5pdFByb21pc2V9fX0sSmk9YXN5bmMgZT0+e2xldCB0PWUuZXhlY3V0aW9uUHJvdmlkZXJzfHxbXSxyPXQubWFwKGw9PnR5cGVvZiBsPT1cInN0cmluZ1wiP2w6bC5uYW1lKSxuPXIubGVuZ3RoPT09MD94dDpyLG8saT1bXSxhPW5ldyBTZXQ7Zm9yKGxldCBsIG9mIG4pe2xldCBwPWF3YWl0IEhwKGwpO3R5cGVvZiBwPT1cInN0cmluZ1wiP2kucHVzaCh7bmFtZTpsLGVycjpwfSk6KG98fChvPXApLG89PT1wJiZhLmFkZChsKSl9aWYoIW8pdGhyb3cgbmV3IEVycm9yKGBubyBhdmFpbGFibGUgYmFja2VuZCBmb3VuZC4gRVJSOiAke2kubWFwKGw9PmBbJHtsLm5hbWV9XSAke2wuZXJyfWApLmpvaW4oXCIsIFwiKX1gKTtmb3IobGV0e25hbWU6bCxlcnI6cH1vZiBpKXIuaW5jbHVkZXMobCkmJmNvbnNvbGUud2FybihgcmVtb3ZpbmcgcmVxdWVzdGVkIGV4ZWN1dGlvbiBwcm92aWRlciBcIiR7bH1cIiBmcm9tIHNlc3Npb24gb3B0aW9ucyBiZWNhdXNlIGl0IGlzIG5vdCBhdmFpbGFibGU6ICR7cH1gKTtsZXQgZD10LmZpbHRlcihsPT5hLmhhcyh0eXBlb2YgbD09XCJzdHJpbmdcIj9sOmwubmFtZSkpO3JldHVybltvLG5ldyBQcm94eShlLHtnZXQ6KGwscCk9PnA9PT1cImV4ZWN1dGlvblByb3ZpZGVyc1wiP2Q6UmVmbGVjdC5nZXQobCxwKX0pXX19KTt2YXIgZWE9VSgoKT0+e1widXNlIHN0cmljdFwiO1ZuKCl9KTt2YXIgdGEscmE9VSgoKT0+e1widXNlIHN0cmljdFwiO3RhPVwiMS4yMS4wLWRldi4yMDI0MTIxMi0xZjg4Mjg0Zjk2XCJ9KTt2YXIgbmEsUmUsV249VSgoKT0+e1widXNlIHN0cmljdFwiO3JhKCk7bmE9XCJ3YXJuaW5nXCIsUmU9e3dhc206e30sd2ViZ2w6e30sd2ViZ3B1Ont9LHZlcnNpb25zOntjb21tb246dGF9LHNldCBsb2dMZXZlbChlKXtpZihlIT09dm9pZCAwKXtpZih0eXBlb2YgZSE9XCJzdHJpbmdcInx8W1widmVyYm9zZVwiLFwiaW5mb1wiLFwid2FybmluZ1wiLFwiZXJyb3JcIixcImZhdGFsXCJdLmluZGV4T2YoZSk9PT0tMSl0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGxvZ2dpbmcgbGV2ZWw6ICR7ZX1gKTtuYT1lfX0sZ2V0IGxvZ0xldmVsKCl7cmV0dXJuIG5hfX07T2JqZWN0LmRlZmluZVByb3BlcnR5KFJlLFwibG9nTGV2ZWxcIix7ZW51bWVyYWJsZTohMH0pfSk7dmFyIHZlLG9hPVUoKCk9PntcInVzZSBzdHJpY3RcIjtXbigpO3ZlPVJlfSk7dmFyIGlhLGFhLHNhPVUoKCk9PntcInVzZSBzdHJpY3RcIjtpYT0oZSx0KT0+e2xldCByPXR5cGVvZiBkb2N1bWVudDxcInVcIj9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpOm5ldyBPZmZzY3JlZW5DYW52YXMoMSwxKTtyLndpZHRoPWUuZGltc1szXSxyLmhlaWdodD1lLmRpbXNbMl07bGV0IG49ci5nZXRDb250ZXh0KFwiMmRcIik7aWYobiE9bnVsbCl7bGV0IG8saTt0Py50ZW5zb3JMYXlvdXQhPT12b2lkIDAmJnQudGVuc29yTGF5b3V0PT09XCJOSFdDXCI/KG89ZS5kaW1zWzJdLGk9ZS5kaW1zWzNdKToobz1lLmRpbXNbM10saT1lLmRpbXNbMl0pO2xldCBhPXQ/LmZvcm1hdCE9PXZvaWQgMD90LmZvcm1hdDpcIlJHQlwiLGQ9dD8ubm9ybSxsLHA7ZD09PXZvaWQgMHx8ZC5tZWFuPT09dm9pZCAwP2w9WzI1NSwyNTUsMjU1LDI1NV06dHlwZW9mIGQubWVhbj09XCJudW1iZXJcIj9sPVtkLm1lYW4sZC5tZWFuLGQubWVhbixkLm1lYW5dOihsPVtkLm1lYW5bMF0sZC5tZWFuWzFdLGQubWVhblsyXSwwXSxkLm1lYW5bM10hPT12b2lkIDAmJihsWzNdPWQubWVhblszXSkpLGQ9PT12b2lkIDB8fGQuYmlhcz09PXZvaWQgMD9wPVswLDAsMCwwXTp0eXBlb2YgZC5iaWFzPT1cIm51bWJlclwiP3A9W2QuYmlhcyxkLmJpYXMsZC5iaWFzLGQuYmlhc106KHA9W2QuYmlhc1swXSxkLmJpYXNbMV0sZC5iaWFzWzJdLDBdLGQuYmlhc1szXSE9PXZvaWQgMCYmKHBbM109ZC5iaWFzWzNdKSk7bGV0IG09aSpvLHU9MCxoPW0sXz1tKjIseT0tMTthPT09XCJSR0JBXCI/KHU9MCxoPW0sXz1tKjIseT1tKjMpOmE9PT1cIlJHQlwiPyh1PTAsaD1tLF89bSoyKTphPT09XCJSQkdcIiYmKHU9MCxfPW0saD1tKjIpO2ZvcihsZXQgZz0wO2c8aTtnKyspZm9yKGxldCB4PTA7eDxvO3grKyl7bGV0ICQ9KGUuZGF0YVt1KytdLXBbMF0pKmxbMF0sdj0oZS5kYXRhW2grK10tcFsxXSkqbFsxXSxTPShlLmRhdGFbXysrXS1wWzJdKSpsWzJdLFQ9eT09PS0xPzI1NTooZS5kYXRhW3krK10tcFszXSkqbFszXTtuLmZpbGxTdHlsZT1cInJnYmEoXCIrJCtcIixcIit2K1wiLFwiK1MrXCIsXCIrVCtcIilcIixuLmZpbGxSZWN0KHgsZywxLDEpfWlmKFwidG9EYXRhVVJMXCJpbiByKXJldHVybiByLnRvRGF0YVVSTCgpO3Rocm93IG5ldyBFcnJvcihcInRvRGF0YVVSTCBpcyBub3Qgc3VwcG9ydGVkXCIpfWVsc2UgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YVwiKX0sYWE9KGUsdCk9PntsZXQgcj10eXBlb2YgZG9jdW1lbnQ8XCJ1XCI/ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKS5nZXRDb250ZXh0KFwiMmRcIik6bmV3IE9mZnNjcmVlbkNhbnZhcygxLDEpLmdldENvbnRleHQoXCIyZFwiKSxuO2lmKHIhPW51bGwpe2xldCBvLGksYTt0Py50ZW5zb3JMYXlvdXQhPT12b2lkIDAmJnQudGVuc29yTGF5b3V0PT09XCJOSFdDXCI/KG89ZS5kaW1zWzJdLGk9ZS5kaW1zWzFdLGE9ZS5kaW1zWzNdKToobz1lLmRpbXNbM10saT1lLmRpbXNbMl0sYT1lLmRpbXNbMV0pO2xldCBkPXQhPT12b2lkIDAmJnQuZm9ybWF0IT09dm9pZCAwP3QuZm9ybWF0OlwiUkdCXCIsbD10Py5ub3JtLHAsbTtsPT09dm9pZCAwfHxsLm1lYW49PT12b2lkIDA/cD1bMjU1LDI1NSwyNTUsMjU1XTp0eXBlb2YgbC5tZWFuPT1cIm51bWJlclwiP3A9W2wubWVhbixsLm1lYW4sbC5tZWFuLGwubWVhbl06KHA9W2wubWVhblswXSxsLm1lYW5bMV0sbC5tZWFuWzJdLDI1NV0sbC5tZWFuWzNdIT09dm9pZCAwJiYocFszXT1sLm1lYW5bM10pKSxsPT09dm9pZCAwfHxsLmJpYXM9PT12b2lkIDA/bT1bMCwwLDAsMF06dHlwZW9mIGwuYmlhcz09XCJudW1iZXJcIj9tPVtsLmJpYXMsbC5iaWFzLGwuYmlhcyxsLmJpYXNdOihtPVtsLmJpYXNbMF0sbC5iaWFzWzFdLGwuYmlhc1syXSwwXSxsLmJpYXNbM10hPT12b2lkIDAmJihtWzNdPWwuYmlhc1szXSkpO2xldCB1PWkqbztpZih0IT09dm9pZCAwJiYodC5mb3JtYXQhPT12b2lkIDAmJmE9PT00JiZ0LmZvcm1hdCE9PVwiUkdCQVwifHxhPT09MyYmdC5mb3JtYXQhPT1cIlJHQlwiJiZ0LmZvcm1hdCE9PVwiQkdSXCIpKXRocm93IG5ldyBFcnJvcihcIlRlbnNvciBmb3JtYXQgZG9lc24ndCBtYXRjaCBpbnB1dCB0ZW5zb3IgZGltc1wiKTtsZXQgaD00LF89MCx5PTEsZz0yLHg9MywkPTAsdj11LFM9dSoyLFQ9LTE7ZD09PVwiUkdCQVwiPygkPTAsdj11LFM9dSoyLFQ9dSozKTpkPT09XCJSR0JcIj8oJD0wLHY9dSxTPXUqMik6ZD09PVwiUkJHXCImJigkPTAsUz11LHY9dSoyKSxuPXIuY3JlYXRlSW1hZ2VEYXRhKG8saSk7Zm9yKGxldCBBPTA7QTxpKm87Xys9aCx5Kz1oLGcrPWgseCs9aCxBKyspbi5kYXRhW19dPShlLmRhdGFbJCsrXS1tWzBdKSpwWzBdLG4uZGF0YVt5XT0oZS5kYXRhW3YrK10tbVsxXSkqcFsxXSxuLmRhdGFbZ109KGUuZGF0YVtTKytdLW1bMl0pKnBbMl0sbi5kYXRhW3hdPVQ9PT0tMT8yNTU6KGUuZGF0YVtUKytdLW1bM10pKnBbM119ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhXCIpO3JldHVybiBufX0pO3ZhciBMbix1YSxkYSxsYSxjYSxwYSxtYT1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7X3IoKTtMbj0oZSx0KT0+e2lmKGU9PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiSW1hZ2UgYnVmZmVyIG11c3QgYmUgZGVmaW5lZFwiKTtpZih0LmhlaWdodD09PXZvaWQgMHx8dC53aWR0aD09PXZvaWQgMCl0aHJvdyBuZXcgRXJyb3IoXCJJbWFnZSBoZWlnaHQgYW5kIHdpZHRoIG11c3QgYmUgZGVmaW5lZFwiKTtpZih0LnRlbnNvckxheW91dD09PVwiTkhXQ1wiKXRocm93IG5ldyBFcnJvcihcIk5IV0MgVGVuc29yIGxheW91dCBpcyBub3Qgc3VwcG9ydGVkIHlldFwiKTtsZXR7aGVpZ2h0OnIsd2lkdGg6bn09dCxvPXQubm9ybT8/e21lYW46MjU1LGJpYXM6MH0saSxhO3R5cGVvZiBvLm1lYW49PVwibnVtYmVyXCI/aT1bby5tZWFuLG8ubWVhbixvLm1lYW4sby5tZWFuXTppPVtvLm1lYW5bMF0sby5tZWFuWzFdLG8ubWVhblsyXSxvLm1lYW5bM10/PzI1NV0sdHlwZW9mIG8uYmlhcz09XCJudW1iZXJcIj9hPVtvLmJpYXMsby5iaWFzLG8uYmlhcyxvLmJpYXNdOmE9W28uYmlhc1swXSxvLmJpYXNbMV0sby5iaWFzWzJdLG8uYmlhc1szXT8/MF07bGV0IGQ9dC5mb3JtYXQhPT12b2lkIDA/dC5mb3JtYXQ6XCJSR0JBXCIsbD10LnRlbnNvckZvcm1hdCE9PXZvaWQgMCYmdC50ZW5zb3JGb3JtYXQhPT12b2lkIDA/dC50ZW5zb3JGb3JtYXQ6XCJSR0JcIixwPXIqbixtPWw9PT1cIlJHQkFcIj9uZXcgRmxvYXQzMkFycmF5KHAqNCk6bmV3IEZsb2F0MzJBcnJheShwKjMpLHU9NCxoPTAsXz0xLHk9MixnPTMseD0wLCQ9cCx2PXAqMixTPS0xO2Q9PT1cIlJHQlwiJiYodT0zLGg9MCxfPTEseT0yLGc9LTEpLGw9PT1cIlJHQkFcIj9TPXAqMzpsPT09XCJSQkdcIj8oeD0wLHY9cCwkPXAqMik6bD09PVwiQkdSXCImJih2PTAsJD1wLHg9cCoyKTtmb3IobGV0IEE9MDtBPHA7QSsrLGgrPXUseSs9dSxfKz11LGcrPXUpbVt4KytdPShlW2hdK2FbMF0pL2lbMF0sbVskKytdPShlW19dK2FbMV0pL2lbMV0sbVt2KytdPShlW3ldK2FbMl0pL2lbMl0sUyE9PS0xJiZnIT09LTEmJihtW1MrK109KGVbZ10rYVszXSkvaVszXSk7cmV0dXJuIGw9PT1cIlJHQkFcIj9uZXcgemUoXCJmbG9hdDMyXCIsbSxbMSw0LHIsbl0pOm5ldyB6ZShcImZsb2F0MzJcIixtLFsxLDMscixuXSl9LHVhPWFzeW5jKGUsdCk9PntsZXQgcj10eXBlb2YgSFRNTEltYWdlRWxlbWVudDxcInVcIiYmZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQsbj10eXBlb2YgSW1hZ2VEYXRhPFwidVwiJiZlIGluc3RhbmNlb2YgSW1hZ2VEYXRhLG89dHlwZW9mIEltYWdlQml0bWFwPFwidVwiJiZlIGluc3RhbmNlb2YgSW1hZ2VCaXRtYXAsaT10eXBlb2YgZT09XCJzdHJpbmdcIixhLGQ9dD8/e30sbD0oKT0+e2lmKHR5cGVvZiBkb2N1bWVudDxcInVcIilyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtpZih0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzPFwidVwiKXJldHVybiBuZXcgT2Zmc2NyZWVuQ2FudmFzKDEsMSk7dGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIGlzIG5vdCBzdXBwb3J0ZWRcIil9LHA9bT0+dHlwZW9mIEhUTUxDYW52YXNFbGVtZW50PFwidVwiJiZtIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnR8fG0gaW5zdGFuY2VvZiBPZmZzY3JlZW5DYW52YXM/bS5nZXRDb250ZXh0KFwiMmRcIik6bnVsbDtpZihyKXtsZXQgbT1sKCk7bS53aWR0aD1lLndpZHRoLG0uaGVpZ2h0PWUuaGVpZ2h0O2xldCB1PXAobSk7aWYodSE9bnVsbCl7bGV0IGg9ZS5oZWlnaHQsXz1lLndpZHRoO2lmKHQhPT12b2lkIDAmJnQucmVzaXplZEhlaWdodCE9PXZvaWQgMCYmdC5yZXNpemVkV2lkdGghPT12b2lkIDAmJihoPXQucmVzaXplZEhlaWdodCxfPXQucmVzaXplZFdpZHRoKSx0IT09dm9pZCAwKXtpZihkPXQsdC50ZW5zb3JGb3JtYXQhPT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiSW1hZ2UgaW5wdXQgY29uZmlnIGZvcm1hdCBtdXN0IGJlIFJHQkEgZm9yIEhUTUxJbWFnZUVsZW1lbnRcIik7ZC50ZW5zb3JGb3JtYXQ9XCJSR0JBXCIsZC5oZWlnaHQ9aCxkLndpZHRoPV99ZWxzZSBkLnRlbnNvckZvcm1hdD1cIlJHQkFcIixkLmhlaWdodD1oLGQud2lkdGg9Xzt1LmRyYXdJbWFnZShlLDAsMCksYT11LmdldEltYWdlRGF0YSgwLDAsXyxoKS5kYXRhfWVsc2UgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBhY2Nlc3MgaW1hZ2UgZGF0YVwiKX1lbHNlIGlmKG4pe2xldCBtLHU7aWYodCE9PXZvaWQgMCYmdC5yZXNpemVkV2lkdGghPT12b2lkIDAmJnQucmVzaXplZEhlaWdodCE9PXZvaWQgMD8obT10LnJlc2l6ZWRIZWlnaHQsdT10LnJlc2l6ZWRXaWR0aCk6KG09ZS5oZWlnaHQsdT1lLndpZHRoKSx0IT09dm9pZCAwJiYoZD10KSxkLmZvcm1hdD1cIlJHQkFcIixkLmhlaWdodD1tLGQud2lkdGg9dSx0IT09dm9pZCAwKXtsZXQgaD1sKCk7aC53aWR0aD11LGguaGVpZ2h0PW07bGV0IF89cChoKTtpZihfIT1udWxsKV8ucHV0SW1hZ2VEYXRhKGUsMCwwKSxhPV8uZ2V0SW1hZ2VEYXRhKDAsMCx1LG0pLmRhdGE7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGFjY2VzcyBpbWFnZSBkYXRhXCIpfWVsc2UgYT1lLmRhdGF9ZWxzZSBpZihvKXtpZih0PT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIlBsZWFzZSBwcm92aWRlIGltYWdlIGNvbmZpZyB3aXRoIGZvcm1hdCBmb3IgSW1hZ2ViaXRtYXBcIik7bGV0IG09bCgpO20ud2lkdGg9ZS53aWR0aCxtLmhlaWdodD1lLmhlaWdodDtsZXQgdT1wKG0pO2lmKHUhPW51bGwpe2xldCBoPWUuaGVpZ2h0LF89ZS53aWR0aDtyZXR1cm4gdS5kcmF3SW1hZ2UoZSwwLDAsXyxoKSxhPXUuZ2V0SW1hZ2VEYXRhKDAsMCxfLGgpLmRhdGEsZC5oZWlnaHQ9aCxkLndpZHRoPV8sTG4oYSxkKX1lbHNlIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgYWNjZXNzIGltYWdlIGRhdGFcIil9ZWxzZXtpZihpKXJldHVybiBuZXcgUHJvbWlzZSgobSx1KT0+e2xldCBoPWwoKSxfPXAoaCk7aWYoIWV8fCFfKXJldHVybiB1KCk7bGV0IHk9bmV3IEltYWdlO3kuY3Jvc3NPcmlnaW49XCJBbm9ueW1vdXNcIix5LnNyYz1lLHkub25sb2FkPSgpPT57aC53aWR0aD15LndpZHRoLGguaGVpZ2h0PXkuaGVpZ2h0LF8uZHJhd0ltYWdlKHksMCwwLGgud2lkdGgsaC5oZWlnaHQpO2xldCBnPV8uZ2V0SW1hZ2VEYXRhKDAsMCxoLndpZHRoLGguaGVpZ2h0KTtkLmhlaWdodD1oLmhlaWdodCxkLndpZHRoPWgud2lkdGgsbShMbihnLmRhdGEsZCkpfX0pO3Rocm93IG5ldyBFcnJvcihcIklucHV0IGRhdGEgcHJvdmlkZWQgaXMgbm90IHN1cHBvcnRlZCAtIGFib3J0ZWQgdGVuc29yIGNyZWF0aW9uXCIpfWlmKGEhPT12b2lkIDApcmV0dXJuIExuKGEsZCk7dGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgZGF0YSBwcm92aWRlZCBpcyBub3Qgc3VwcG9ydGVkIC0gYWJvcnRlZCB0ZW5zb3IgY3JlYXRpb25cIil9LGRhPShlLHQpPT57bGV0e3dpZHRoOnIsaGVpZ2h0Om4sZG93bmxvYWQ6byxkaXNwb3NlOml9PXQsYT1bMSxuLHIsNF07cmV0dXJuIG5ldyB6ZSh7bG9jYXRpb246XCJ0ZXh0dXJlXCIsdHlwZTpcImZsb2F0MzJcIix0ZXh0dXJlOmUsZGltczphLGRvd25sb2FkOm8sZGlzcG9zZTppfSl9LGxhPShlLHQpPT57bGV0e2RhdGFUeXBlOnIsZGltczpuLGRvd25sb2FkOm8sZGlzcG9zZTppfT10O3JldHVybiBuZXcgemUoe2xvY2F0aW9uOlwiZ3B1LWJ1ZmZlclwiLHR5cGU6cj8/XCJmbG9hdDMyXCIsZ3B1QnVmZmVyOmUsZGltczpuLGRvd25sb2FkOm8sZGlzcG9zZTppfSl9LGNhPShlLHQpPT57bGV0e2RhdGFUeXBlOnIsZGltczpuLGRvd25sb2FkOm8sZGlzcG9zZTppfT10O3JldHVybiBuZXcgemUoe2xvY2F0aW9uOlwibWwtdGVuc29yXCIsdHlwZTpyPz9cImZsb2F0MzJcIixtbFRlbnNvcjplLGRpbXM6bixkb3dubG9hZDpvLGRpc3Bvc2U6aX0pfSxwYT0oZSx0LHIpPT5uZXcgemUoe2xvY2F0aW9uOlwiY3B1LXBpbm5lZFwiLHR5cGU6ZSxkYXRhOnQsZGltczpyPz9bdC5sZW5ndGhdfSl9KTt2YXIgVHQscXQsZmEsaGEsZ2E9VSgoKT0+e1widXNlIHN0cmljdFwiO1R0PW5ldyBNYXAoW1tcImZsb2F0MzJcIixGbG9hdDMyQXJyYXldLFtcInVpbnQ4XCIsVWludDhBcnJheV0sW1wiaW50OFwiLEludDhBcnJheV0sW1widWludDE2XCIsVWludDE2QXJyYXldLFtcImludDE2XCIsSW50MTZBcnJheV0sW1wiaW50MzJcIixJbnQzMkFycmF5XSxbXCJib29sXCIsVWludDhBcnJheV0sW1wiZmxvYXQ2NFwiLEZsb2F0NjRBcnJheV0sW1widWludDMyXCIsVWludDMyQXJyYXldLFtcImludDRcIixVaW50OEFycmF5XSxbXCJ1aW50NFwiLFVpbnQ4QXJyYXldXSkscXQ9bmV3IE1hcChbW0Zsb2F0MzJBcnJheSxcImZsb2F0MzJcIl0sW1VpbnQ4QXJyYXksXCJ1aW50OFwiXSxbSW50OEFycmF5LFwiaW50OFwiXSxbVWludDE2QXJyYXksXCJ1aW50MTZcIl0sW0ludDE2QXJyYXksXCJpbnQxNlwiXSxbSW50MzJBcnJheSxcImludDMyXCJdLFtGbG9hdDY0QXJyYXksXCJmbG9hdDY0XCJdLFtVaW50MzJBcnJheSxcInVpbnQzMlwiXV0pLGZhPSExLGhhPSgpPT57aWYoIWZhKXtmYT0hMDtsZXQgZT10eXBlb2YgQmlnSW50NjRBcnJheTxcInVcIiYmQmlnSW50NjRBcnJheS5mcm9tLHQ9dHlwZW9mIEJpZ1VpbnQ2NEFycmF5PFwidVwiJiZCaWdVaW50NjRBcnJheS5mcm9tLHI9dHlwZW9mIEZsb2F0MTZBcnJheTxcInVcIiYmRmxvYXQxNkFycmF5LmZyb207ZSYmKFR0LnNldChcImludDY0XCIsQmlnSW50NjRBcnJheSkscXQuc2V0KEJpZ0ludDY0QXJyYXksXCJpbnQ2NFwiKSksdCYmKFR0LnNldChcInVpbnQ2NFwiLEJpZ1VpbnQ2NEFycmF5KSxxdC5zZXQoQmlnVWludDY0QXJyYXksXCJ1aW50NjRcIikpLHI/KFR0LnNldChcImZsb2F0MTZcIixGbG9hdDE2QXJyYXkpLHF0LnNldChGbG9hdDE2QXJyYXksXCJmbG9hdDE2XCIpKTpUdC5zZXQoXCJmbG9hdDE2XCIsVWludDE2QXJyYXkpfX19KTt2YXIgYmEseWEsX2E9VSgoKT0+e1widXNlIHN0cmljdFwiO19yKCk7YmE9ZT0+e2xldCB0PTE7Zm9yKGxldCByPTA7cjxlLmxlbmd0aDtyKyspe2xldCBuPWVbcl07aWYodHlwZW9mIG4hPVwibnVtYmVyXCJ8fCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSl0aHJvdyBuZXcgVHlwZUVycm9yKGBkaW1zWyR7cn1dIG11c3QgYmUgYW4gaW50ZWdlciwgZ290OiAke259YCk7aWYobjwwKXRocm93IG5ldyBSYW5nZUVycm9yKGBkaW1zWyR7cn1dIG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlciwgZ290OiAke259YCk7dCo9bn1yZXR1cm4gdH0seWE9KGUsdCk9Pntzd2l0Y2goZS5sb2NhdGlvbil7Y2FzZVwiY3B1XCI6cmV0dXJuIG5ldyB6ZShlLnR5cGUsZS5kYXRhLHQpO2Nhc2VcImNwdS1waW5uZWRcIjpyZXR1cm4gbmV3IHplKHtsb2NhdGlvbjpcImNwdS1waW5uZWRcIixkYXRhOmUuZGF0YSx0eXBlOmUudHlwZSxkaW1zOnR9KTtjYXNlXCJ0ZXh0dXJlXCI6cmV0dXJuIG5ldyB6ZSh7bG9jYXRpb246XCJ0ZXh0dXJlXCIsdGV4dHVyZTplLnRleHR1cmUsdHlwZTplLnR5cGUsZGltczp0fSk7Y2FzZVwiZ3B1LWJ1ZmZlclwiOnJldHVybiBuZXcgemUoe2xvY2F0aW9uOlwiZ3B1LWJ1ZmZlclwiLGdwdUJ1ZmZlcjplLmdwdUJ1ZmZlcix0eXBlOmUudHlwZSxkaW1zOnR9KTtjYXNlXCJtbC10ZW5zb3JcIjpyZXR1cm4gbmV3IHplKHtsb2NhdGlvbjpcIm1sLXRlbnNvclwiLG1sVGVuc29yOmUubWxUZW5zb3IsdHlwZTplLnR5cGUsZGltczp0fSk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHRlbnNvclJlc2hhcGU6IHRlbnNvciBsb2NhdGlvbiAke2UubG9jYXRpb259IGlzIG5vdCBzdXBwb3J0ZWRgKX19fSk7dmFyIHplLF9yPVUoKCk9PntcInVzZSBzdHJpY3RcIjtzYSgpO21hKCk7Z2EoKTtfYSgpO3plPWNsYXNze2NvbnN0cnVjdG9yKHQscixuKXtoYSgpO2xldCBvLGk7aWYodHlwZW9mIHQ9PVwib2JqZWN0XCImJlwibG9jYXRpb25cImluIHQpc3dpdGNoKHRoaXMuZGF0YUxvY2F0aW9uPXQubG9jYXRpb24sbz10LnR5cGUsaT10LmRpbXMsdC5sb2NhdGlvbil7Y2FzZVwiY3B1LXBpbm5lZFwiOntsZXQgZD1UdC5nZXQobyk7aWYoIWQpdGhyb3cgbmV3IFR5cGVFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZSBcIiR7b31cIiB0byBjcmVhdGUgdGVuc29yIGZyb20gcGlubmVkIGJ1ZmZlcmApO2lmKCEodC5kYXRhIGluc3RhbmNlb2YgZCkpdGhyb3cgbmV3IFR5cGVFcnJvcihgYnVmZmVyIHNob3VsZCBiZSBvZiB0eXBlICR7ZC5uYW1lfWApO3RoaXMuY3B1RGF0YT10LmRhdGE7YnJlYWt9Y2FzZVwidGV4dHVyZVwiOntpZihvIT09XCJmbG9hdDMyXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihgdW5zdXBwb3J0ZWQgdHlwZSBcIiR7b31cIiB0byBjcmVhdGUgdGVuc29yIGZyb20gdGV4dHVyZWApO3RoaXMuZ3B1VGV4dHVyZURhdGE9dC50ZXh0dXJlLHRoaXMuZG93bmxvYWRlcj10LmRvd25sb2FkLHRoaXMuZGlzcG9zZXI9dC5kaXNwb3NlO2JyZWFrfWNhc2VcImdwdS1idWZmZXJcIjp7aWYobyE9PVwiZmxvYXQzMlwiJiZvIT09XCJmbG9hdDE2XCImJm8hPT1cImludDMyXCImJm8hPT1cImludDY0XCImJm8hPT1cInVpbnQzMlwiJiZvIT09XCJ1aW50OFwiJiZvIT09XCJib29sXCImJm8hPT1cInVpbnQ0XCImJm8hPT1cImludDRcIil0aHJvdyBuZXcgVHlwZUVycm9yKGB1bnN1cHBvcnRlZCB0eXBlIFwiJHtvfVwiIHRvIGNyZWF0ZSB0ZW5zb3IgZnJvbSBncHUgYnVmZmVyYCk7dGhpcy5ncHVCdWZmZXJEYXRhPXQuZ3B1QnVmZmVyLHRoaXMuZG93bmxvYWRlcj10LmRvd25sb2FkLHRoaXMuZGlzcG9zZXI9dC5kaXNwb3NlO2JyZWFrfWNhc2VcIm1sLXRlbnNvclwiOntpZihvIT09XCJmbG9hdDMyXCImJm8hPT1cImZsb2F0MTZcIiYmbyE9PVwiaW50MzJcIiYmbyE9PVwiaW50NjRcIiYmbyE9PVwidWludDMyXCImJm8hPT1cInVpbnQ2NFwiJiZvIT09XCJpbnQ4XCImJm8hPT1cInVpbnQ4XCImJm8hPT1cImJvb2xcIiYmbyE9PVwidWludDRcIiYmbyE9PVwiaW50NFwiKXRocm93IG5ldyBUeXBlRXJyb3IoYHVuc3VwcG9ydGVkIHR5cGUgXCIke299XCIgdG8gY3JlYXRlIHRlbnNvciBmcm9tIE1MVGVuc29yYCk7dGhpcy5tbFRlbnNvckRhdGE9dC5tbFRlbnNvcix0aGlzLmRvd25sb2FkZXI9dC5kb3dubG9hZCx0aGlzLmRpc3Bvc2VyPXQuZGlzcG9zZTticmVha31kZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVGVuc29yIGNvbnN0cnVjdG9yOiB1bnN1cHBvcnRlZCBsb2NhdGlvbiAnJHt0aGlzLmRhdGFMb2NhdGlvbn0nYCl9ZWxzZXtsZXQgZCxsO2lmKHR5cGVvZiB0PT1cInN0cmluZ1wiKWlmKG89dCxsPW4sdD09PVwic3RyaW5nXCIpe2lmKCFBcnJheS5pc0FycmF5KHIpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJBIHN0cmluZyB0ZW5zb3IncyBkYXRhIG11c3QgYmUgYSBzdHJpbmcgYXJyYXkuXCIpO2Q9cn1lbHNle2xldCBwPVR0LmdldCh0KTtpZihwPT09dm9pZCAwKXRocm93IG5ldyBUeXBlRXJyb3IoYFVuc3VwcG9ydGVkIHRlbnNvciB0eXBlOiAke3R9LmApO2lmKEFycmF5LmlzQXJyYXkocikpe2lmKHQ9PT1cImZsb2F0MTZcIiYmcD09PVVpbnQxNkFycmF5fHx0PT09XCJ1aW50NFwifHx0PT09XCJpbnQ0XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihgQ3JlYXRpbmcgYSAke3R9IHRlbnNvciBmcm9tIG51bWJlciBhcnJheSBpcyBub3Qgc3VwcG9ydGVkLiBQbGVhc2UgdXNlICR7cC5uYW1lfSBhcyBkYXRhLmApO3Q9PT1cInVpbnQ2NFwifHx0PT09XCJpbnQ2NFwiP2Q9cC5mcm9tKHIsQmlnSW50KTpkPXAuZnJvbShyKX1lbHNlIGlmKHIgaW5zdGFuY2VvZiBwKWQ9cjtlbHNlIGlmKHIgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSlpZih0PT09XCJ1aW50OFwiKWQ9VWludDhBcnJheS5mcm9tKHIpO2Vsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkEgVWludDhDbGFtcGVkQXJyYXkgdGVuc29yJ3MgZGF0YSBtdXN0IGJlIHR5cGUgb2YgdWludDhcIik7ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKGBBICR7b30gdGVuc29yJ3MgZGF0YSBtdXN0IGJlIHR5cGUgb2YgJHtwfWApfWVsc2UgaWYobD1yLEFycmF5LmlzQXJyYXkodCkpe2lmKHQubGVuZ3RoPT09MCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGVuc29yIHR5cGUgY2Fubm90IGJlIGluZmVycmVkIGZyb20gYW4gZW1wdHkgYXJyYXkuXCIpO2xldCBwPXR5cGVvZiB0WzBdO2lmKHA9PT1cInN0cmluZ1wiKW89XCJzdHJpbmdcIixkPXQ7ZWxzZSBpZihwPT09XCJib29sZWFuXCIpbz1cImJvb2xcIixkPVVpbnQ4QXJyYXkuZnJvbSh0KTtlbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgZWxlbWVudCB0eXBlIG9mIGRhdGEgYXJyYXk6ICR7cH0uYCl9ZWxzZSBpZih0IGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkpbz1cInVpbnQ4XCIsZD1VaW50OEFycmF5LmZyb20odCk7ZWxzZXtsZXQgcD1xdC5nZXQodC5jb25zdHJ1Y3Rvcik7aWYocD09PXZvaWQgMCl0aHJvdyBuZXcgVHlwZUVycm9yKGBVbnN1cHBvcnRlZCB0eXBlIGZvciB0ZW5zb3IgZGF0YTogJHt0LmNvbnN0cnVjdG9yfS5gKTtvPXAsZD10fWlmKGw9PT12b2lkIDApbD1bZC5sZW5ndGhdO2Vsc2UgaWYoIUFycmF5LmlzQXJyYXkobCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkEgdGVuc29yJ3MgZGltcyBtdXN0IGJlIGEgbnVtYmVyIGFycmF5XCIpO2k9bCx0aGlzLmNwdURhdGE9ZCx0aGlzLmRhdGFMb2NhdGlvbj1cImNwdVwifWxldCBhPWJhKGkpO2lmKHRoaXMuY3B1RGF0YSYmYSE9PXRoaXMuY3B1RGF0YS5sZW5ndGgmJiEoKG89PT1cInVpbnQ0XCJ8fG89PT1cImludDRcIikmJk1hdGguY2VpbChhLzIpPT09dGhpcy5jcHVEYXRhLmxlbmd0aCkpdGhyb3cgbmV3IEVycm9yKGBUZW5zb3IncyBzaXplKCR7YX0pIGRvZXMgbm90IG1hdGNoIGRhdGEgbGVuZ3RoKCR7dGhpcy5jcHVEYXRhLmxlbmd0aH0pLmApO3RoaXMudHlwZT1vLHRoaXMuZGltcz1pLHRoaXMuc2l6ZT1hfXN0YXRpYyBhc3luYyBmcm9tSW1hZ2UodCxyKXtyZXR1cm4gdWEodCxyKX1zdGF0aWMgZnJvbVRleHR1cmUodCxyKXtyZXR1cm4gZGEodCxyKX1zdGF0aWMgZnJvbUdwdUJ1ZmZlcih0LHIpe3JldHVybiBsYSh0LHIpfXN0YXRpYyBmcm9tTUxUZW5zb3IodCxyKXtyZXR1cm4gY2EodCxyKX1zdGF0aWMgZnJvbVBpbm5lZEJ1ZmZlcih0LHIsbil7cmV0dXJuIHBhKHQscixuKX10b0RhdGFVUkwodCl7cmV0dXJuIGlhKHRoaXMsdCl9dG9JbWFnZURhdGEodCl7cmV0dXJuIGFhKHRoaXMsdCl9Z2V0IGRhdGEoKXtpZih0aGlzLmVuc3VyZVZhbGlkKCksIXRoaXMuY3B1RGF0YSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZGF0YSBpcyBub3Qgb24gQ1BVLiBVc2UgYGdldERhdGEoKWAgdG8gZG93bmxvYWQgR1BVIGRhdGEgdG8gQ1BVLCBvciB1c2UgYHRleHR1cmVgIG9yIGBncHVCdWZmZXJgIHByb3BlcnR5IHRvIGFjY2VzcyB0aGUgR1BVIGRhdGEgZGlyZWN0bHkuXCIpO3JldHVybiB0aGlzLmNwdURhdGF9Z2V0IGxvY2F0aW9uKCl7cmV0dXJuIHRoaXMuZGF0YUxvY2F0aW9ufWdldCB0ZXh0dXJlKCl7aWYodGhpcy5lbnN1cmVWYWxpZCgpLCF0aGlzLmdwdVRleHR1cmVEYXRhKXRocm93IG5ldyBFcnJvcihcIlRoZSBkYXRhIGlzIG5vdCBzdG9yZWQgYXMgYSBXZWJHTCB0ZXh0dXJlLlwiKTtyZXR1cm4gdGhpcy5ncHVUZXh0dXJlRGF0YX1nZXQgZ3B1QnVmZmVyKCl7aWYodGhpcy5lbnN1cmVWYWxpZCgpLCF0aGlzLmdwdUJ1ZmZlckRhdGEpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGRhdGEgaXMgbm90IHN0b3JlZCBhcyBhIFdlYkdQVSBidWZmZXIuXCIpO3JldHVybiB0aGlzLmdwdUJ1ZmZlckRhdGF9Z2V0IG1sVGVuc29yKCl7aWYodGhpcy5lbnN1cmVWYWxpZCgpLCF0aGlzLm1sVGVuc29yRGF0YSl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgZGF0YSBpcyBub3Qgc3RvcmVkIGFzIGEgV2ViTk4gTUxUZW5zb3IuXCIpO3JldHVybiB0aGlzLm1sVGVuc29yRGF0YX1hc3luYyBnZXREYXRhKHQpe3N3aXRjaCh0aGlzLmVuc3VyZVZhbGlkKCksdGhpcy5kYXRhTG9jYXRpb24pe2Nhc2VcImNwdVwiOmNhc2VcImNwdS1waW5uZWRcIjpyZXR1cm4gdGhpcy5kYXRhO2Nhc2VcInRleHR1cmVcIjpjYXNlXCJncHUtYnVmZmVyXCI6Y2FzZVwibWwtdGVuc29yXCI6e2lmKCF0aGlzLmRvd25sb2FkZXIpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGN1cnJlbnQgdGVuc29yIGlzIG5vdCBjcmVhdGVkIHdpdGggYSBzcGVjaWZpZWQgZGF0YSBkb3dubG9hZGVyLlwiKTtpZih0aGlzLmlzRG93bmxvYWRpbmcpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGN1cnJlbnQgdGVuc29yIGlzIGJlaW5nIGRvd25sb2FkZWQuXCIpO3RyeXt0aGlzLmlzRG93bmxvYWRpbmc9ITA7bGV0IHI9YXdhaXQgdGhpcy5kb3dubG9hZGVyKCk7cmV0dXJuIHRoaXMuZG93bmxvYWRlcj12b2lkIDAsdGhpcy5kYXRhTG9jYXRpb249XCJjcHVcIix0aGlzLmNwdURhdGE9cix0JiZ0aGlzLmRpc3Bvc2VyJiYodGhpcy5kaXNwb3NlcigpLHRoaXMuZGlzcG9zZXI9dm9pZCAwKSxyfWZpbmFsbHl7dGhpcy5pc0Rvd25sb2FkaW5nPSExfX1kZWZhdWx0OnRocm93IG5ldyBFcnJvcihgY2Fubm90IGdldCBkYXRhIGZyb20gbG9jYXRpb246ICR7dGhpcy5kYXRhTG9jYXRpb259YCl9fWRpc3Bvc2UoKXtpZih0aGlzLmlzRG93bmxvYWRpbmcpdGhyb3cgbmV3IEVycm9yKFwiVGhlIGN1cnJlbnQgdGVuc29yIGlzIGJlaW5nIGRvd25sb2FkZWQuXCIpO3RoaXMuZGlzcG9zZXImJih0aGlzLmRpc3Bvc2VyKCksdGhpcy5kaXNwb3Nlcj12b2lkIDApLHRoaXMuY3B1RGF0YT12b2lkIDAsdGhpcy5ncHVUZXh0dXJlRGF0YT12b2lkIDAsdGhpcy5ncHVCdWZmZXJEYXRhPXZvaWQgMCx0aGlzLm1sVGVuc29yRGF0YT12b2lkIDAsdGhpcy5kb3dubG9hZGVyPXZvaWQgMCx0aGlzLmlzRG93bmxvYWRpbmc9dm9pZCAwLHRoaXMuZGF0YUxvY2F0aW9uPVwibm9uZVwifWVuc3VyZVZhbGlkKCl7aWYodGhpcy5kYXRhTG9jYXRpb249PT1cIm5vbmVcIil0aHJvdyBuZXcgRXJyb3IoXCJUaGUgdGVuc29yIGlzIGRpc3Bvc2VkLlwiKX1yZXNoYXBlKHQpe2lmKHRoaXMuZW5zdXJlVmFsaWQoKSx0aGlzLmRvd25sb2FkZXJ8fHRoaXMuZGlzcG9zZXIpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHJlc2hhcGUgYSB0ZW5zb3IgdGhhdCBvd25zIEdQVSByZXNvdXJjZS5cIik7cmV0dXJuIHlhKHRoaXMsdCl9fX0pO3ZhciBIZSxHbj1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7X3IoKTtIZT16ZX0pO3ZhciB3cix3YSxVZSxEZSxIbj1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7V24oKTt3cj0oZSx0KT0+eyh0eXBlb2YgUmUudHJhY2U+XCJ1XCI/IVJlLndhc20udHJhY2U6IVJlLnRyYWNlKXx8Y29uc29sZS50aW1lU3RhbXAoYCR7ZX06Ok9SVDo6JHt0fWApfSx3YT0oZSx0KT0+e2xldCByPW5ldyBFcnJvcigpLnN0YWNrPy5zcGxpdCgvXFxyXFxufFxccnxcXG4vZyl8fFtdLG49ITE7Zm9yKGxldCBvPTA7bzxyLmxlbmd0aDtvKyspe2lmKG4mJiFyW29dLmluY2x1ZGVzKFwiVFJBQ0VfRlVOQ1wiKSl7bGV0IGk9YEZVTkNfJHtlfTo6JHtyW29dLnRyaW0oKS5zcGxpdChcIiBcIilbMV19YDt0JiYoaSs9YDo6JHt0fWApLHdyKFwiQ1BVXCIsaSk7cmV0dXJufXJbb10uaW5jbHVkZXMoXCJUUkFDRV9GVU5DXCIpJiYobj0hMCl9fSxVZT1lPT57KHR5cGVvZiBSZS50cmFjZT5cInVcIj8hUmUud2FzbS50cmFjZTohUmUudHJhY2UpfHx3YShcIkJFR0lOXCIsZSl9LERlPWU9PnsodHlwZW9mIFJlLnRyYWNlPlwidVwiPyFSZS53YXNtLnRyYWNlOiFSZS50cmFjZSl8fHdhKFwiRU5EXCIsZSl9fSk7dmFyIHZyLHZhPVUoKCk9PntcInVzZSBzdHJpY3RcIjtWbigpO0duKCk7SG4oKTt2cj1jbGFzcyBle2NvbnN0cnVjdG9yKHQpe3RoaXMuaGFuZGxlcj10fWFzeW5jIHJ1bih0LHIsbil7VWUoKTtsZXQgbz17fSxpPXt9O2lmKHR5cGVvZiB0IT1cIm9iamVjdFwifHx0PT09bnVsbHx8dCBpbnN0YW5jZW9mIEhlfHxBcnJheS5pc0FycmF5KHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCInZmVlZHMnIG11c3QgYmUgYW4gb2JqZWN0IHRoYXQgdXNlIGlucHV0IG5hbWVzIGFzIGtleXMgYW5kIE9ubnhWYWx1ZSBhcyBjb3JyZXNwb25kaW5nIHZhbHVlcy5cIik7bGV0IGE9ITA7aWYodHlwZW9mIHI9PVwib2JqZWN0XCIpe2lmKHI9PT1udWxsKXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmV4cGVjdGVkIGFyZ3VtZW50WzFdOiBjYW5ub3QgYmUgbnVsbC5cIik7aWYociBpbnN0YW5jZW9mIEhlKXRocm93IG5ldyBUeXBlRXJyb3IoXCInZmV0Y2hlcycgY2Fubm90IGJlIGEgVGVuc29yXCIpO2lmKEFycmF5LmlzQXJyYXkocikpe2lmKHIubGVuZ3RoPT09MCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ2ZldGNoZXMnIGNhbm5vdCBiZSBhbiBlbXB0eSBhcnJheS5cIik7YT0hMTtmb3IobGV0IHAgb2Ygcil7aWYodHlwZW9mIHAhPVwic3RyaW5nXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidmZXRjaGVzJyBtdXN0IGJlIGEgc3RyaW5nIGFycmF5IG9yIGFuIG9iamVjdC5cIik7aWYodGhpcy5vdXRwdXROYW1lcy5pbmRleE9mKHApPT09LTEpdGhyb3cgbmV3IFJhbmdlRXJyb3IoYCdmZXRjaGVzJyBjb250YWlucyBpbnZhbGlkIG91dHB1dCBuYW1lOiAke3B9LmApO29bcF09bnVsbH1pZih0eXBlb2Ygbj09XCJvYmplY3RcIiYmbiE9PW51bGwpaT1uO2Vsc2UgaWYodHlwZW9mIG48XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIil9ZWxzZXtsZXQgcD0hMSxtPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHIpO2ZvcihsZXQgdSBvZiB0aGlzLm91dHB1dE5hbWVzKWlmKG0uaW5kZXhPZih1KSE9PS0xKXtsZXQgaD1yW3VdOyhoPT09bnVsbHx8aCBpbnN0YW5jZW9mIEhlKSYmKHA9ITAsYT0hMSxvW3VdPWgpfWlmKHApe2lmKHR5cGVvZiBuPT1cIm9iamVjdFwiJiZuIT09bnVsbClpPW47ZWxzZSBpZih0eXBlb2YgbjxcInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKX1lbHNlIGk9cn19ZWxzZSBpZih0eXBlb2YgcjxcInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5leHBlY3RlZCBhcmd1bWVudFsxXTogbXVzdCBiZSAnZmV0Y2hlcycgb3IgJ29wdGlvbnMnLlwiKTtmb3IobGV0IHAgb2YgdGhpcy5pbnB1dE5hbWVzKWlmKHR5cGVvZiB0W3BdPlwidVwiKXRocm93IG5ldyBFcnJvcihgaW5wdXQgJyR7cH0nIGlzIG1pc3NpbmcgaW4gJ2ZlZWRzJy5gKTtpZihhKWZvcihsZXQgcCBvZiB0aGlzLm91dHB1dE5hbWVzKW9bcF09bnVsbDtsZXQgZD1hd2FpdCB0aGlzLmhhbmRsZXIucnVuKHQsbyxpKSxsPXt9O2ZvcihsZXQgcCBpbiBkKWlmKE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGQscCkpe2xldCBtPWRbcF07bSBpbnN0YW5jZW9mIEhlP2xbcF09bTpsW3BdPW5ldyBIZShtLnR5cGUsbS5kYXRhLG0uZGltcyl9cmV0dXJuIERlKCksbH1hc3luYyByZWxlYXNlKCl7cmV0dXJuIHRoaXMuaGFuZGxlci5kaXNwb3NlKCl9c3RhdGljIGFzeW5jIGNyZWF0ZSh0LHIsbixvKXtVZSgpO2xldCBpLGE9e307aWYodHlwZW9mIHQ9PVwic3RyaW5nXCIpe2lmKGk9dCx0eXBlb2Ygcj09XCJvYmplY3RcIiYmciE9PW51bGwpYT1yO2Vsc2UgaWYodHlwZW9mIHI8XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidvcHRpb25zJyBtdXN0IGJlIGFuIG9iamVjdC5cIil9ZWxzZSBpZih0IGluc3RhbmNlb2YgVWludDhBcnJheSl7aWYoaT10LHR5cGVvZiByPT1cIm9iamVjdFwiJiZyIT09bnVsbClhPXI7ZWxzZSBpZih0eXBlb2YgcjxcInVcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiJ29wdGlvbnMnIG11c3QgYmUgYW4gb2JqZWN0LlwiKX1lbHNlIGlmKHQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcnx8dHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyPFwidVwiJiZ0IGluc3RhbmNlb2YgU2hhcmVkQXJyYXlCdWZmZXIpe2xldCBtPXQsdT0wLGg9dC5ieXRlTGVuZ3RoO2lmKHR5cGVvZiByPT1cIm9iamVjdFwiJiZyIT09bnVsbClhPXI7ZWxzZSBpZih0eXBlb2Ygcj09XCJudW1iZXJcIil7aWYodT1yLCFOdW1iZXIuaXNTYWZlSW50ZWdlcih1KSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIidieXRlT2Zmc2V0JyBtdXN0IGJlIGFuIGludGVnZXIuXCIpO2lmKHU8MHx8dT49bS5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKGAnYnl0ZU9mZnNldCcgaXMgb3V0IG9mIHJhbmdlIFswLCAke20uYnl0ZUxlbmd0aH0pLmApO2lmKGg9dC5ieXRlTGVuZ3RoLXUsdHlwZW9mIG49PVwibnVtYmVyXCIpe2lmKGg9biwhTnVtYmVyLmlzU2FmZUludGVnZXIoaCkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCInYnl0ZUxlbmd0aCcgbXVzdCBiZSBhbiBpbnRlZ2VyLlwiKTtpZihoPD0wfHx1K2g+bS5ieXRlTGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKGAnYnl0ZUxlbmd0aCcgaXMgb3V0IG9mIHJhbmdlICgwLCAke20uYnl0ZUxlbmd0aC11fV0uYCk7aWYodHlwZW9mIG89PVwib2JqZWN0XCImJm8hPT1udWxsKWE9bztlbHNlIGlmKHR5cGVvZiBvPFwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpfWVsc2UgaWYodHlwZW9mIG48XCJ1XCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIidieXRlTGVuZ3RoJyBtdXN0IGJlIGEgbnVtYmVyLlwiKX1lbHNlIGlmKHR5cGVvZiByPFwidVwiKXRocm93IG5ldyBUeXBlRXJyb3IoXCInb3B0aW9ucycgbXVzdCBiZSBhbiBvYmplY3QuXCIpO2k9bmV3IFVpbnQ4QXJyYXkobSx1LGgpfWVsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVuZXhwZWN0ZWQgYXJndW1lbnRbMF06IG11c3QgYmUgJ3BhdGgnIG9yICdidWZmZXInLlwiKTtsZXRbZCxsXT1hd2FpdCBKaShhKSxwPWF3YWl0IGQuY3JlYXRlSW5mZXJlbmNlU2Vzc2lvbkhhbmRsZXIoaSxsKTtyZXR1cm4gRGUoKSxuZXcgZShwKX1zdGFydFByb2ZpbGluZygpe3RoaXMuaGFuZGxlci5zdGFydFByb2ZpbGluZygpfWVuZFByb2ZpbGluZygpe3RoaXMuaGFuZGxlci5lbmRQcm9maWxpbmcoKX1nZXQgaW5wdXROYW1lcygpe3JldHVybiB0aGlzLmhhbmRsZXIuaW5wdXROYW1lc31nZXQgb3V0cHV0TmFtZXMoKXtyZXR1cm4gdGhpcy5oYW5kbGVyLm91dHB1dE5hbWVzfX19KTt2YXIgRnAsJGE9VSgoKT0+e1widXNlIHN0cmljdFwiO3ZhKCk7RnA9dnJ9KTt2YXIgeGE9VSgoKT0+e1widXNlIHN0cmljdFwifSk7dmFyIFNhPVUoKCk9PntcInVzZSBzdHJpY3RcIn0pO3ZhciBUYT1VKCgpPT57XCJ1c2Ugc3RyaWN0XCJ9KTt2YXIgSWE9VSgoKT0+e1widXNlIHN0cmljdFwifSk7dmFyIEZuPXt9O0Z0KEZuLHtJbmZlcmVuY2VTZXNzaW9uOigpPT5GcCxUUkFDRTooKT0+d3IsVFJBQ0VfRlVOQ19CRUdJTjooKT0+VWUsVFJBQ0VfRlVOQ19FTkQ6KCk9PkRlLFRlbnNvcjooKT0+SGUsZW52OigpPT52ZSxyZWdpc3RlckJhY2tlbmQ6KCk9PlN0fSk7dmFyIFdlPVUoKCk9PntcInVzZSBzdHJpY3RcIjtlYSgpO29hKCk7JGEoKTtHbigpO3hhKCk7U2EoKTtIbigpO1RhKCk7SWEoKX0pO3ZhciAkcj1VKCgpPT57XCJ1c2Ugc3RyaWN0XCJ9KTt2YXIgRWE9e307RnQoRWEse2RlZmF1bHQ6KCk9PnFwfSk7dmFyIEFhLGthLHFwLFBhPVUoKCk9PntcInVzZSBzdHJpY3RcIjtxbigpO2d0KCk7eHIoKTtBYT1cIm9ydC13YXNtLXByb3h5LXdvcmtlclwiLGthPWdsb2JhbFRoaXMuc2VsZj8ubmFtZT09PUFhO2thJiYoc2VsZi5vbm1lc3NhZ2U9ZT0+e2xldHt0eXBlOnQsaW46cn09ZS5kYXRhO3RyeXtzd2l0Y2godCl7Y2FzZVwiaW5pdC13YXNtXCI6U3Ioci53YXNtKS50aGVuKCgpPT57VHIocikudGhlbigoKT0+e3Bvc3RNZXNzYWdlKHt0eXBlOnR9KX0sbj0+e3Bvc3RNZXNzYWdlKHt0eXBlOnQsZXJyOm59KX0pfSxuPT57cG9zdE1lc3NhZ2Uoe3R5cGU6dCxlcnI6bn0pfSk7YnJlYWs7Y2FzZVwiaW5pdC1lcFwiOntsZXR7ZXBOYW1lOm4sZW52Om99PXI7SXIobyxuKS50aGVuKCgpPT57cG9zdE1lc3NhZ2Uoe3R5cGU6dH0pfSxpPT57cG9zdE1lc3NhZ2Uoe3R5cGU6dCxlcnI6aX0pfSk7YnJlYWt9Y2FzZVwiY29weS1mcm9tXCI6e2xldHtidWZmZXI6bn09cixvPUt0KG4pO3Bvc3RNZXNzYWdlKHt0eXBlOnQsb3V0Om99KTticmVha31jYXNlXCJjcmVhdGVcIjp7bGV0e21vZGVsOm4sb3B0aW9uczpvfT1yO0NyKG4sbykudGhlbihpPT57cG9zdE1lc3NhZ2Uoe3R5cGU6dCxvdXQ6aX0pfSxpPT57cG9zdE1lc3NhZ2Uoe3R5cGU6dCxlcnI6aX0pfSk7YnJlYWt9Y2FzZVwicmVsZWFzZVwiOkFyKHIpLHBvc3RNZXNzYWdlKHt0eXBlOnR9KTticmVhaztjYXNlXCJydW5cIjp7bGV0e3Nlc3Npb25JZDpuLGlucHV0SW5kaWNlczpvLGlucHV0czppLG91dHB1dEluZGljZXM6YSxvcHRpb25zOmR9PXI7a3IobixvLGksYSxuZXcgQXJyYXkoYS5sZW5ndGgpLmZpbGwobnVsbCksZCkudGhlbihsPT57bC5zb21lKHA9PnBbM10hPT1cImNwdVwiKT9wb3N0TWVzc2FnZSh7dHlwZTp0LGVycjpcIlByb3h5IGRvZXMgbm90IHN1cHBvcnQgbm9uLWNwdSB0ZW5zb3IgbG9jYXRpb24uXCJ9KTpwb3N0TWVzc2FnZSh7dHlwZTp0LG91dDpsfSxQcihbLi4uaSwuLi5sXSkpfSxsPT57cG9zdE1lc3NhZ2Uoe3R5cGU6dCxlcnI6bH0pfSk7YnJlYWt9Y2FzZVwiZW5kLXByb2ZpbGluZ1wiOkVyKHIpLHBvc3RNZXNzYWdlKHt0eXBlOnR9KTticmVhaztkZWZhdWx0On19Y2F0Y2gobil7cG9zdE1lc3NhZ2Uoe3R5cGU6dCxlcnI6bn0pfX0pO3FwPWthP251bGw6ZT0+bmV3IFdvcmtlcihlPz9OZSx7dHlwZTpcIm1vZHVsZVwiLG5hbWU6QWF9KX0pO3ZhciBPYT17fTtGdChPYSx7ZGVmYXVsdDooKT0+S3B9KTt2YXIgS24semEsS3AsRGE9VSgoKT0+e1widXNlIHN0cmljdFwiO3phPShLbj1pbXBvcnQubWV0YS51cmwsYXN5bmMgZnVuY3Rpb24oZT17fSl7ZnVuY3Rpb24gdCgpe3JldHVybiBzZS5idWZmZXIhPUouYnVmZmVyJiZ5ZSgpLEp9ZnVuY3Rpb24gcigpe3JldHVybiBzZS5idWZmZXIhPUouYnVmZmVyJiZ5ZSgpLG5lfWZ1bmN0aW9uIG4oKXtyZXR1cm4gc2UuYnVmZmVyIT1KLmJ1ZmZlciYmeWUoKSxiZX1mdW5jdGlvbiBvKCl7cmV0dXJuIHNlLmJ1ZmZlciE9Si5idWZmZXImJnllKCksT2V9ZnVuY3Rpb24gaSgpe3JldHVybiBzZS5idWZmZXIhPUouYnVmZmVyJiZ5ZSgpLCRlfWZ1bmN0aW9uIGEoKXtyZXR1cm4gc2UuYnVmZmVyIT1KLmJ1ZmZlciYmeWUoKSxsZX1mdW5jdGlvbiBkKCl7cmV0dXJuIHNlLmJ1ZmZlciE9Si5idWZmZXImJnllKCksV31mdW5jdGlvbiBsKCl7cmV0dXJuIHNlLmJ1ZmZlciE9Si5idWZmZXImJnllKCksR2V9dmFyIHAsbSx1PU9iamVjdC5hc3NpZ24oe30sZSksaD1uZXcgUHJvbWlzZSgocyxjKT0+e3A9cyxtPWN9KSxfPXR5cGVvZiB3aW5kb3c9PVwib2JqZWN0XCIseT10eXBlb2YgaW1wb3J0U2NyaXB0cz09XCJmdW5jdGlvblwiLGc9eSYmc2VsZi5uYW1lPT1cImVtLXB0aHJlYWRcIjt1Lm1vdW50RXh0ZXJuYWxEYXRhPShzLGMpPT57cy5zdGFydHNXaXRoKFwiLi9cIikmJihzPXMuc3Vic3RyaW5nKDIpKSwodS5GYnx8KHUuRmI9bmV3IE1hcCkpLnNldChzLGMpfSx1LnVubW91bnRFeHRlcm5hbERhdGE9KCk9PntkZWxldGUgdS5GYn07dmFyIHg9Z2xvYmFsVGhpcy5TaGFyZWRBcnJheUJ1ZmZlcj8/bmV3IFdlYkFzc2VtYmx5Lk1lbW9yeSh7aW5pdGlhbDowLG1heGltdW06MCxzaGFyZWQ6ITB9KS5idWZmZXIuY29uc3RydWN0b3I7bGV0ICQ9KCk9PntsZXQgcz0oZixiLHcpPT4oLi4uSSk9PntsZXQgTz1YZSxCPWI/LigpO0k9ZiguLi5JKTtsZXQgTD1iPy4oKTtyZXR1cm4gQiE9PUwmJihmPUwsdyhCKSxiPXc9bnVsbCksWGUhPU8/bmV3IFByb21pc2UoKEgsWCk9PntFbj17cmVzb2x2ZTpILHJlamVjdDpYfX0pOkl9LGM9Zj0+YXN5bmMoLi4uYik9Pnt0cnl7aWYodS5HYil0aHJvdyBFcnJvcihcIlNlc3Npb24gYWxyZWFkeSBzdGFydGVkXCIpO2xldCB3PXUuR2I9e2hjOmJbMF0sZXJyb3JzOltdfSxJPWF3YWl0IGYoLi4uYik7aWYodS5HYiE9PXcpdGhyb3cgRXJyb3IoXCJTZXNzaW9uIG1pc21hdGNoXCIpO3UuSGI/LmZsdXNoKCk7bGV0IE89dy5lcnJvcnM7aWYoMDxPLmxlbmd0aCl7bGV0IEI9YXdhaXQgUHJvbWlzZS5hbGwoTyk7aWYoQj1CLmZpbHRlcihMPT5MKSwwPEIubGVuZ3RoKXRocm93IEVycm9yKEIuam9pbihgXG5gKSl9cmV0dXJuIEl9ZmluYWxseXt1LkdiPW51bGx9fTt1Ll9PcnRDcmVhdGVTZXNzaW9uPXModS5fT3J0Q3JlYXRlU2Vzc2lvbiwoKT0+dS5fT3J0Q3JlYXRlU2Vzc2lvbixmPT51Ll9PcnRDcmVhdGVTZXNzaW9uPWYpLHUuX09ydFJ1bj1jKHModS5fT3J0UnVuLCgpPT51Ll9PcnRSdW4sZj0+dS5fT3J0UnVuPWYpKSx1Ll9PcnRSdW5XaXRoQmluZGluZz1jKHModS5fT3J0UnVuV2l0aEJpbmRpbmcsKCk9PnUuX09ydFJ1bldpdGhCaW5kaW5nLGY9PnUuX09ydFJ1bldpdGhCaW5kaW5nPWYpKSx1Ll9PcnRCaW5kSW5wdXQ9cyh1Ll9PcnRCaW5kSW5wdXQsKCk9PnUuX09ydEJpbmRJbnB1dCxmPT51Ll9PcnRCaW5kSW5wdXQ9ZiksJD12b2lkIDB9O3UuanNlcEluaXQ9KHMsYyk9PntpZigkPy4oKSxzPT09XCJ3ZWJncHVcIil7W3UuSGIsdS5WYix1LlpiLHUuT2IsdS5ZYix1LmtiLHUuJGIsdS5jYyx1LldiLHUuWGIsdS5hY109YztsZXQgZj11LkhiO3UuanNlcFJlZ2lzdGVyQnVmZmVyPShiLHcsSSxPKT0+Zi5yZWdpc3RlckJ1ZmZlcihiLHcsSSxPKSx1LmpzZXBHZXRCdWZmZXI9Yj0+Zi5nZXRCdWZmZXIoYiksdS5qc2VwQ3JlYXRlRG93bmxvYWRlcj0oYix3LEkpPT5mLmNyZWF0ZURvd25sb2FkZXIoYix3LEkpLHUuanNlcE9uQ3JlYXRlU2Vzc2lvbj1iPT57Zi5vbkNyZWF0ZVNlc3Npb24oYil9LHUuanNlcE9uUmVsZWFzZVNlc3Npb249Yj0+e2Yub25SZWxlYXNlU2Vzc2lvbihiKX0sdS5qc2VwT25SdW5TdGFydD1iPT5mLm9uUnVuU3RhcnQoYiksdS5kYz0oYix3KT0+e2YudXBsb2FkKGIsdyl9fWVsc2UgaWYocz09PVwid2Vibm5cIil7W3UuSGIsdS5iYyx1LlBiLHUuanNlcEVuc3VyZVRlbnNvcix1LmVjLHUuanNlcERvd25sb2FkVGVuc29yXT1jLHUuanNlcFJlbGVhc2VUZW5zb3JJZD11LlBiO2xldCBmPXUuSGI7dS5qc2VwT25SdW5TdGFydD1iPT5mLm9uUnVuU3RhcnQoYiksdS5qc2VwUmVnaXN0ZXJNTENvbnRleHQ9KGIsdyk9PntmLnJlZ2lzdGVyTUxDb250ZXh0KGIsdyl9LHUuanNlcE9uUmVsZWFzZVNlc3Npb249Yj0+e2Yub25SZWxlYXNlU2Vzc2lvbihiKX0sdS5qc2VwQ3JlYXRlTUxUZW5zb3JEb3dubG9hZGVyPShiLHcpPT5mLmNyZWF0ZU1MVGVuc29yRG93bmxvYWRlcihiLHcpLHUuanNlcFJlZ2lzdGVyTUxUZW5zb3I9KGIsdyxJKT0+Zi5yZWdpc3Rlck1MVGVuc29yKGIsdyxJKSx1LmpzZXBDcmVhdGVNTENvbnRleHQ9Yj0+Zi5jcmVhdGVNTENvbnRleHQoYiksdS5qc2VwUmVnaXN0ZXJNTENvbnN0YW50PShiLHcsSSxPLEIpPT5mLnJlZ2lzdGVyTUxDb25zdGFudChiLHcsSSxPLEIsdS5GYil9fTt2YXIgdixTLFQ9T2JqZWN0LmFzc2lnbih7fSx1KSxBPVwiLi90aGlzLnByb2dyYW1cIixrPShzLGMpPT57dGhyb3cgY30sUD1cIlwiOyhffHx5KSYmKHk/UD1zZWxmLmxvY2F0aW9uLmhyZWY6dHlwZW9mIGRvY3VtZW50PFwidVwiJiZkb2N1bWVudC5jdXJyZW50U2NyaXB0JiYoUD1kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYyksS24mJihQPUtuKSxQPVAuc3RhcnRzV2l0aChcImJsb2I6XCIpP1wiXCI6UC5zdWJzdHIoMCxQLnJlcGxhY2UoL1s/I10uKi8sXCJcIikubGFzdEluZGV4T2YoXCIvXCIpKzEpLHkmJihTPXM9Pnt2YXIgYz1uZXcgWE1MSHR0cFJlcXVlc3Q7cmV0dXJuIGMub3BlbihcIkdFVFwiLHMsITEpLGMucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIixjLnNlbmQobnVsbCksbmV3IFVpbnQ4QXJyYXkoYy5yZXNwb25zZSl9KSx2PShzLGMsZik9Pnt2YXIgYj1uZXcgWE1MSHR0cFJlcXVlc3Q7Yi5vcGVuKFwiR0VUXCIscywhMCksYi5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiLGIub25sb2FkPSgpPT57Yi5zdGF0dXM9PTIwMHx8Yi5zdGF0dXM9PTAmJmIucmVzcG9uc2U/YyhiLnJlc3BvbnNlKTpmKCl9LGIub25lcnJvcj1mLGIuc2VuZChudWxsKX0pO3ZhciBELFI9Y29uc29sZS5sb2cuYmluZChjb25zb2xlKSxHPWNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKSxLPVIsaj1HO2lmKE9iamVjdC5hc3NpZ24odSxUKSxUPW51bGwsZyl7bGV0IHM9ZnVuY3Rpb24oYyl7dHJ5e3ZhciBmPWMuZGF0YSxiPWYuY21kO2lmKGI9PT1cImxvYWRcIil7bGV0IHc9W107c2VsZi5vbm1lc3NhZ2U9ST0+dy5wdXNoKEkpLHNlbGYuc3RhcnRXb3JrZXI9KCk9Pntwb3N0TWVzc2FnZSh7Y21kOlwibG9hZGVkXCJ9KTtmb3IobGV0IEkgb2YgdylzKEkpO3NlbGYub25tZXNzYWdlPXN9O2ZvcihsZXQgSSBvZiBmLmhhbmRsZXJzKXVbSV0mJiF1W0ldLnByb3h5fHwodVtJXT0oLi4uTyk9Pntwb3N0TWVzc2FnZSh7TmI6XCJjYWxsSGFuZGxlclwiLHBjOkksYXJnczpPfSl9LEk9PVwicHJpbnRcIiYmKEs9dVtJXSksST09XCJwcmludEVyclwiJiYoaj11W0ldKSk7c2U9Zi53YXNtTWVtb3J5LHllKCksVihmLndhc21Nb2R1bGUpfWVsc2UgaWYoYj09PVwicnVuXCIpe0RuKGYucHRocmVhZF9wdHIsMCwwLDEsMCwwKSxBbihmLnB0aHJlYWRfcHRyKSx4YygpLEhvKCksUXx8KFdpKCksUT0hMCk7dHJ5e1NjKGYuc3RhcnRfcm91dGluZSxmLmFyZyl9Y2F0Y2godyl7aWYodyE9XCJ1bndpbmRcIil0aHJvdyB3fX1lbHNlIGI9PT1cImNhbmNlbFwiP010KCkmJmhyKC0xKTpmLnRhcmdldCE9PVwic2V0aW1tZWRpYXRlXCImJihiPT09XCJjaGVja01haWxib3hcIj9RJiZpcigpOmImJihqKGB3b3JrZXI6IHJlY2VpdmVkIHVua25vd24gY29tbWFuZCAke2J9YCksaihmKSkpfWNhdGNoKHcpe3Rocm93IExpKCksd319O3ZhciB3Zz1zLFYsUT0hMTtqPWZ1bmN0aW9uKC4uLmMpe2M9Yy5qb2luKFwiIFwiKSxjb25zb2xlLmVycm9yKGMpfSxzZWxmLmFsZXJ0PWZ1bmN0aW9uKC4uLmMpe3Bvc3RNZXNzYWdlKHtOYjpcImFsZXJ0XCIsdGV4dDpjLmpvaW4oXCIgXCIpLHJjOk10KCl9KX0sdS5pbnN0YW50aWF0ZVdhc209KGMsZik9Pm5ldyBQcm9taXNlKGI9PntWPXc9Pnt3PW5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZSh3LE5vKCkpLGYodyksYigpfX0pLHNlbGYub251bmhhbmRsZWRyZWplY3Rpb249Yz0+e3Rocm93IGMucmVhc29ufHxjfSxzZWxmLm9ubWVzc2FnZT1zfXUud2FzbUJpbmFyeSYmKEQ9dS53YXNtQmluYXJ5KTt2YXIgc2UsWSxlZSxKLG5lLGJlLE9lLCRlLGxlLFcscSxoZSxHZSx3ZT0hMTtmdW5jdGlvbiB5ZSgpe3ZhciBzPXNlLmJ1ZmZlcjt1LkhFQVA4PUo9bmV3IEludDhBcnJheShzKSx1LkhFQVAxNj1iZT1uZXcgSW50MTZBcnJheShzKSx1LkhFQVBVOD1uZT1uZXcgVWludDhBcnJheShzKSx1LkhFQVBVMTY9T2U9bmV3IFVpbnQxNkFycmF5KHMpLHUuSEVBUDMyPSRlPW5ldyBJbnQzMkFycmF5KHMpLHUuSEVBUFUzMj1sZT1uZXcgVWludDMyQXJyYXkocyksdS5IRUFQRjMyPVc9bmV3IEZsb2F0MzJBcnJheShzKSx1LkhFQVBGNjQ9R2U9bmV3IEZsb2F0NjRBcnJheShzKSx1LkhFQVA2ND1xPW5ldyBCaWdJbnQ2NEFycmF5KHMpLHUuSEVBUFU2ND1oZT1uZXcgQmlnVWludDY0QXJyYXkocyl9aWYoIWcpe2lmKCEoKHNlPW5ldyBXZWJBc3NlbWJseS5NZW1vcnkoe2luaXRpYWw6MjU2LG1heGltdW06NjU1MzYsc2hhcmVkOiEwfSkpLmJ1ZmZlciBpbnN0YW5jZW9mIHgpKXRocm93IGooXCJyZXF1ZXN0ZWQgYSBzaGFyZWQgV2ViQXNzZW1ibHkuTWVtb3J5IGJ1dCB0aGUgcmV0dXJuZWQgYnVmZmVyIGlzIG5vdCBhIFNoYXJlZEFycmF5QnVmZmVyLCBpbmRpY2F0aW5nIHRoYXQgd2hpbGUgdGhlIGJyb3dzZXIgaGFzIFNoYXJlZEFycmF5QnVmZmVyIGl0IGRvZXMgbm90IGhhdmUgV2ViQXNzZW1ibHkgdGhyZWFkcyBzdXBwb3J0IC0geW91IG1heSBuZWVkIHRvIHNldCBhIGZsYWdcIiksRXJyb3IoXCJiYWQgbWVtb3J5XCIpO3llKCl9dmFyIFllPVtdLEx0PVtdLGZuPVtdLEd0PTAsaG49bnVsbCxIdD1udWxsO2Z1bmN0aW9uIERvKCl7aWYoLS1HdD09MCYmKGhuIT09bnVsbCYmKGNsZWFySW50ZXJ2YWwoaG4pLGhuPW51bGwpLEh0KSl7dmFyIHM9SHQ7SHQ9bnVsbCxzKCl9fWZ1bmN0aW9uIGN0KHMpe3Rocm93IGoocz1cIkFib3J0ZWQoXCIrcytcIilcIiksd2U9ITAsZWU9MSxzPW5ldyBXZWJBc3NlbWJseS5SdW50aW1lRXJyb3IocytcIi4gQnVpbGQgd2l0aCAtc0FTU0VSVElPTlMgZm9yIG1vcmUgaW5mby5cIiksbShzKSxzfXZhciBnbixCbz1zPT5zLnN0YXJ0c1dpdGgoXCJkYXRhOmFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbTtiYXNlNjQsXCIpLE1vPXM9PnMuc3RhcnRzV2l0aChcImZpbGU6Ly9cIik7ZnVuY3Rpb24gUm8ocyl7aWYocz09Z24mJkQpcmV0dXJuIG5ldyBVaW50OEFycmF5KEQpO2lmKFMpcmV0dXJuIFMocyk7dGhyb3dcImJvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkXCJ9ZnVuY3Rpb24gVW8ocyxjLGYpe3JldHVybiBmdW5jdGlvbihiKXtpZighRCYmKF98fHkpKXtpZih0eXBlb2YgZmV0Y2g9PVwiZnVuY3Rpb25cIiYmIU1vKGIpKXJldHVybiBmZXRjaChiLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKHc9PntpZighdy5vayl0aHJvd2BmYWlsZWQgdG8gbG9hZCB3YXNtIGJpbmFyeSBmaWxlIGF0ICcke2J9J2A7cmV0dXJuIHcuYXJyYXlCdWZmZXIoKX0pLmNhdGNoKCgpPT5SbyhiKSk7aWYodilyZXR1cm4gbmV3IFByb21pc2UoKHcsSSk9Pnt2KGIsTz0+dyhuZXcgVWludDhBcnJheShPKSksSSl9KX1yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKT0+Um8oYikpfShzKS50aGVuKGI9PldlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGIsYykpLnRoZW4oZixiPT57aihgZmFpbGVkIHRvIGFzeW5jaHJvbm91c2x5IHByZXBhcmUgd2FzbTogJHtifWApLGN0KGIpfSl9ZnVuY3Rpb24gTm8oKXtyZXR1cm57YTp7TzokYyxBYTp2YyxiOkljLGFhOmpvLEI6UW8scWE6WG8sWTplaSxfOnRpLHJhOnJpLG9hOm5pLGhhOm9pLG5hOmlpLEw6YWksWjpzaSxXOnVpLHBhOmRpLFg6bGksdmE6Q2MsRjprYyxROkVjLFA6emMsRTpEYyx1OkJjLHE6TWMsRzpSYyxBOkhjLFI6RmMsdWE6cWMsa2E6S2MsVTpqYyxiYTpZYyxIOlpjLGphOkFuLHRhOlFjLHQ6WGMsQmE6SmMseDpycCxuOm5wLGw6aXAsYzpJbixvOmFwLGo6ZHAsdzpscCxwOmNwLGY6cHAsczptcCxtOmZwLGU6aHAsazpncCxpOmJwLGg6eXAsZDpfcCxlYTp3cCxmYTp2cCxnYTokcCxjYTpTaSxkYTpUaSxUOnhwLGc6U3AsRDpUcCxJOklwLE06Q3AseTpBcCxzYTprcCxWOkVwLHY6Q2ksejpQcCxOOnpwLFM6T3AsemE6RHAseWE6QnAsbGE6RWksbWE6UGksJDp2bixDOnppLEs6T2ksaWE6RGksSjpCaSxhOnNlLHhhOnduLHdhOlVpLHI6VXB9fX12YXIgYm49ezkxMzcwMDoocyxjLGYsYix3KT0+e2lmKHU9PT12b2lkIDB8fCF1LkZiKXJldHVybiAxO2lmKChzPUNlKE51bWJlcihzPj4+MCkpKS5zdGFydHNXaXRoKFwiLi9cIikmJihzPXMuc3Vic3RyaW5nKDIpKSwhKHM9dS5GYi5nZXQocykpKXJldHVybiAyO2lmKGM9TnVtYmVyKGM+Pj4wKSxmPU51bWJlcihmPj4+MCksYj1OdW1iZXIoYj4+PjApLGMrZj5zLmJ5dGVMZW5ndGgpcmV0dXJuIDM7dHJ5e2xldCBJPXMuc3ViYXJyYXkoYyxjK2YpO3N3aXRjaCh3KXtjYXNlIDA6cigpLnNldChJLGI+Pj4wKTticmVhaztjYXNlIDE6dS5kYyhiLEkpO2JyZWFrO2RlZmF1bHQ6cmV0dXJuIDR9cmV0dXJuIDB9Y2F0Y2h7cmV0dXJuIDR9fSw5MTQ0MTU6KHMsYyxmKT0+e3UuZWMocyxyKCkuc3ViYXJyYXkoYz4+PjAsYytmPj4+MCkpfSw5MTQ0Nzg6KCk9PnUuYmMoKSw5MTQ1MTk6cz0+e3UuUGIocyl9LDkxNDU1NTooKT0+e3UuV2IoKX0sOTE0NTg2OigpPT57dS5YYigpfSw5MTQ2MTU6KCk9Pnt1LmFjKCl9LDkxNDY0MDpzPT51LlZiKHMpLDkxNDY3MzpzPT51LlpiKHMpLDkxNDcwNToocyxjLGYpPT57dS5PYihOdW1iZXIocyksTnVtYmVyKGMpLE51bWJlcihmKSwhMCl9LDkxNDc2ODoocyxjLGYpPT57dS5PYihOdW1iZXIocyksTnVtYmVyKGMpLE51bWJlcihmKSl9LDkxNDgyNTooKT0+dHlwZW9mIHdhc21PZmZzZXRDb252ZXJ0ZXI8XCJ1XCIsOTE0ODgyOnM9Pnt1LmtiKFwiQWJzXCIscyx2b2lkIDApfSw5MTQ5MzM6cz0+e3Uua2IoXCJOZWdcIixzLHZvaWQgMCl9LDkxNDk4NDpzPT57dS5rYihcIkZsb29yXCIscyx2b2lkIDApfSw5MTUwMzc6cz0+e3Uua2IoXCJDZWlsXCIscyx2b2lkIDApfSw5MTUwODk6cz0+e3Uua2IoXCJSZWNpcHJvY2FsXCIscyx2b2lkIDApfSw5MTUxNDc6cz0+e3Uua2IoXCJTcXJ0XCIscyx2b2lkIDApfSw5MTUxOTk6cz0+e3Uua2IoXCJFeHBcIixzLHZvaWQgMCl9LDkxNTI1MDpzPT57dS5rYihcIkVyZlwiLHMsdm9pZCAwKX0sOTE1MzAxOnM9Pnt1LmtiKFwiU2lnbW9pZFwiLHMsdm9pZCAwKX0sOTE1MzU2OihzLGMsZik9Pnt1LmtiKFwiSGFyZFNpZ21vaWRcIixzLHthbHBoYTpjLGJldGE6Zn0pfSw5MTU0MzU6cz0+e3Uua2IoXCJMb2dcIixzLHZvaWQgMCl9LDkxNTQ4NjpzPT57dS5rYihcIlNpblwiLHMsdm9pZCAwKX0sOTE1NTM3OnM9Pnt1LmtiKFwiQ29zXCIscyx2b2lkIDApfSw5MTU1ODg6cz0+e3Uua2IoXCJUYW5cIixzLHZvaWQgMCl9LDkxNTYzOTpzPT57dS5rYihcIkFzaW5cIixzLHZvaWQgMCl9LDkxNTY5MTpzPT57dS5rYihcIkFjb3NcIixzLHZvaWQgMCl9LDkxNTc0MzpzPT57dS5rYihcIkF0YW5cIixzLHZvaWQgMCl9LDkxNTc5NTpzPT57dS5rYihcIlNpbmhcIixzLHZvaWQgMCl9LDkxNTg0NzpzPT57dS5rYihcIkNvc2hcIixzLHZvaWQgMCl9LDkxNTg5OTpzPT57dS5rYihcIkFzaW5oXCIscyx2b2lkIDApfSw5MTU5NTI6cz0+e3Uua2IoXCJBY29zaFwiLHMsdm9pZCAwKX0sOTE2MDA1OnM9Pnt1LmtiKFwiQXRhbmhcIixzLHZvaWQgMCl9LDkxNjA1ODpzPT57dS5rYihcIlRhbmhcIixzLHZvaWQgMCl9LDkxNjExMDpzPT57dS5rYihcIk5vdFwiLHMsdm9pZCAwKX0sOTE2MTYxOihzLGMsZik9Pnt1LmtiKFwiQ2xpcFwiLHMse21pbjpjLG1heDpmfSl9LDkxNjIzMDpzPT57dS5rYihcIkNsaXBcIixzLHZvaWQgMCl9LDkxNjI4MjoocyxjKT0+e3Uua2IoXCJFbHVcIixzLHthbHBoYTpjfSl9LDkxNjM0MDpzPT57dS5rYihcIkdlbHVcIixzLHZvaWQgMCl9LDkxNjM5MjpzPT57dS5rYihcIlJlbHVcIixzLHZvaWQgMCl9LDkxNjQ0NDoocyxjKT0+e3Uua2IoXCJMZWFreVJlbHVcIixzLHthbHBoYTpjfSl9LDkxNjUwODoocyxjKT0+e3Uua2IoXCJUaHJlc2hvbGRlZFJlbHVcIixzLHthbHBoYTpjfSl9LDkxNjU3ODoocyxjKT0+e3Uua2IoXCJDYXN0XCIscyx7dG86Y30pfSw5MTY2MzY6cz0+e3Uua2IoXCJBZGRcIixzLHZvaWQgMCl9LDkxNjY4NzpzPT57dS5rYihcIlN1YlwiLHMsdm9pZCAwKX0sOTE2NzM4OnM9Pnt1LmtiKFwiTXVsXCIscyx2b2lkIDApfSw5MTY3ODk6cz0+e3Uua2IoXCJEaXZcIixzLHZvaWQgMCl9LDkxNjg0MDpzPT57dS5rYihcIlBvd1wiLHMsdm9pZCAwKX0sOTE2ODkxOnM9Pnt1LmtiKFwiRXF1YWxcIixzLHZvaWQgMCl9LDkxNjk0NDpzPT57dS5rYihcIkdyZWF0ZXJcIixzLHZvaWQgMCl9LDkxNjk5OTpzPT57dS5rYihcIkdyZWF0ZXJPckVxdWFsXCIscyx2b2lkIDApfSw5MTcwNjE6cz0+e3Uua2IoXCJMZXNzXCIscyx2b2lkIDApfSw5MTcxMTM6cz0+e3Uua2IoXCJMZXNzT3JFcXVhbFwiLHMsdm9pZCAwKX0sOTE3MTcyOihzLGMsZixiLHcpPT57dS5rYihcIlJlZHVjZU1lYW5cIixzLHtrZWVwRGltczohIWMsbm9vcFdpdGhFbXB0eUF4ZXM6ISFmLGF4ZXM6Yj9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoYik+Pj4wLE51bWJlcih3KT4+PjApKTpbXX0pfSw5MTczNDc6KHMsYyxmLGIsdyk9Pnt1LmtiKFwiUmVkdWNlTWF4XCIscyx7a2VlcERpbXM6ISFjLG5vb3BXaXRoRW1wdHlBeGVzOiEhZixheGVzOmI/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGIpPj4+MCxOdW1iZXIodyk+Pj4wKSk6W119KX0sOTE3NTIxOihzLGMsZixiLHcpPT57dS5rYihcIlJlZHVjZU1pblwiLHMse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWYsYXhlczpiP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihiKT4+PjAsTnVtYmVyKHcpPj4+MCkpOltdfSl9LDkxNzY5NToocyxjLGYsYix3KT0+e3Uua2IoXCJSZWR1Y2VQcm9kXCIscyx7a2VlcERpbXM6ISFjLG5vb3BXaXRoRW1wdHlBeGVzOiEhZixheGVzOmI/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGIpPj4+MCxOdW1iZXIodyk+Pj4wKSk6W119KX0sOTE3ODcwOihzLGMsZixiLHcpPT57dS5rYihcIlJlZHVjZVN1bVwiLHMse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWYsYXhlczpiP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihiKT4+PjAsTnVtYmVyKHcpPj4+MCkpOltdfSl9LDkxODA0NDoocyxjLGYsYix3KT0+e3Uua2IoXCJSZWR1Y2VMMVwiLHMse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWYsYXhlczpiP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihiKT4+PjAsTnVtYmVyKHcpPj4+MCkpOltdfSl9LDkxODIxNzoocyxjLGYsYix3KT0+e3Uua2IoXCJSZWR1Y2VMMlwiLHMse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWYsYXhlczpiP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihiKT4+PjAsTnVtYmVyKHcpPj4+MCkpOltdfSl9LDkxODM5MDoocyxjLGYsYix3KT0+e3Uua2IoXCJSZWR1Y2VMb2dTdW1cIixzLHtrZWVwRGltczohIWMsbm9vcFdpdGhFbXB0eUF4ZXM6ISFmLGF4ZXM6Yj9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoYik+Pj4wLE51bWJlcih3KT4+PjApKTpbXX0pfSw5MTg1Njc6KHMsYyxmLGIsdyk9Pnt1LmtiKFwiUmVkdWNlU3VtU3F1YXJlXCIscyx7a2VlcERpbXM6ISFjLG5vb3BXaXRoRW1wdHlBeGVzOiEhZixheGVzOmI/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGIpPj4+MCxOdW1iZXIodyk+Pj4wKSk6W119KX0sOTE4NzQ3OihzLGMsZixiLHcpPT57dS5rYihcIlJlZHVjZUxvZ1N1bUV4cFwiLHMse2tlZXBEaW1zOiEhYyxub29wV2l0aEVtcHR5QXhlczohIWYsYXhlczpiP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihiKT4+PjAsTnVtYmVyKHcpPj4+MCkpOltdfSl9LDkxODkyNzpzPT57dS5rYihcIldoZXJlXCIscyx2b2lkIDApfSw5MTg5ODA6KHMsYyxmKT0+e3Uua2IoXCJUcmFuc3Bvc2VcIixzLHtwZXJtOmM/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGMpPj4+MCxOdW1iZXIoZik+Pj4wKSk6W119KX0sOTE5MTA0OihzLGMsZixiKT0+e3Uua2IoXCJEZXB0aFRvU3BhY2VcIixzLHtibG9ja3NpemU6Yyxtb2RlOkNlKGYpLGZvcm1hdDpiP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkxOTIzNzoocyxjLGYsYik9Pnt1LmtiKFwiRGVwdGhUb1NwYWNlXCIscyx7YmxvY2tzaXplOmMsbW9kZTpDZShmKSxmb3JtYXQ6Yj9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5MTkzNzA6KHMsYyxmLGIsdyxJLE8sQixMLEgsWCxjZSxnZSx6LGRlKT0+e3Uua2IoXCJDb252VHJhbnNwb3NlXCIscyx7Zm9ybWF0Okw/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b1BhZDpjLGRpbGF0aW9uczpbZl0sZ3JvdXA6YixrZXJuZWxTaGFwZTpbd10scGFkczpbSSxPXSxzdHJpZGVzOltCXSx3SXNDb25zdDooKT0+ISF0KClbSD4+PjBdLG91dHB1dFBhZGRpbmc6WD9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoWCk+Pj4wLE51bWJlcihjZSk+Pj4wKSk6W10sb3V0cHV0U2hhcGU6Z2U/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGdlKT4+PjAsTnVtYmVyKHopPj4+MCkpOltdLGFjdGl2YXRpb246Q2UoZGUpfSl9LDkxOTgwMzoocyxjLGYsYix3LEksTyxCLEwsSCxYLGNlLGdlLHopPT57dS5rYihcIkNvbnZUcmFuc3Bvc2VcIixzLHtmb3JtYXQ6Qj9cIk5IV0NcIjpcIk5DSFdcIixhdXRvUGFkOmMsZGlsYXRpb25zOkFycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihmKT4+PjAsMisoTnVtYmVyKGYpPj4+MCk+Pj4wKSksZ3JvdXA6YixrZXJuZWxTaGFwZTpBcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIodyk+Pj4wLDIrKE51bWJlcih3KT4+PjApPj4+MCkpLHBhZHM6QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKEkpPj4+MCw0KyhOdW1iZXIoSSk+Pj4wKT4+PjApKSxzdHJpZGVzOkFycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihPKT4+PjAsMisoTnVtYmVyKE8pPj4+MCk+Pj4wKSksd0lzQ29uc3Q6KCk9PiEhdCgpW0w+Pj4wXSxvdXRwdXRQYWRkaW5nOkg/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKEgpPj4+MCxOdW1iZXIoWCk+Pj4wKSk6W10sb3V0cHV0U2hhcGU6Y2U/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGNlKT4+PjAsTnVtYmVyKGdlKT4+PjApKTpbXSxhY3RpdmF0aW9uOkNlKHopfSl9LDkyMDQ2NDoocyxjLGYsYix3LEksTyxCLEwsSCxYLGNlLGdlLHosZGUpPT57dS5rYihcIkNvbnZUcmFuc3Bvc2VcIixzLHtmb3JtYXQ6TD9cIk5IV0NcIjpcIk5DSFdcIixhdXRvUGFkOmMsZGlsYXRpb25zOltmXSxncm91cDpiLGtlcm5lbFNoYXBlOlt3XSxwYWRzOltJLE9dLHN0cmlkZXM6W0JdLHdJc0NvbnN0OigpPT4hIXQoKVtIPj4+MF0sb3V0cHV0UGFkZGluZzpYP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihYKT4+PjAsTnVtYmVyKGNlKT4+PjApKTpbXSxvdXRwdXRTaGFwZTpnZT9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoZ2UpPj4+MCxOdW1iZXIoeik+Pj4wKSk6W10sYWN0aXZhdGlvbjpDZShkZSl9KX0sOTIwODk3OihzLGMsZixiLHcsSSxPLEIsTCxILFgsY2UsZ2Useik9Pnt1LmtiKFwiQ29udlRyYW5zcG9zZVwiLHMse2Zvcm1hdDpCP1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9QYWQ6YyxkaWxhdGlvbnM6QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGYpPj4+MCwyKyhOdW1iZXIoZik+Pj4wKT4+PjApKSxncm91cDpiLGtlcm5lbFNoYXBlOkFycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcih3KT4+PjAsMisoTnVtYmVyKHcpPj4+MCk+Pj4wKSkscGFkczpBcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoSSk+Pj4wLDQrKE51bWJlcihJKT4+PjApPj4+MCkpLHN0cmlkZXM6QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKE8pPj4+MCwyKyhOdW1iZXIoTyk+Pj4wKT4+PjApKSx3SXNDb25zdDooKT0+ISF0KClbTD4+PjBdLG91dHB1dFBhZGRpbmc6SD9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoSCk+Pj4wLE51bWJlcihYKT4+PjApKTpbXSxvdXRwdXRTaGFwZTpjZT9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoY2UpPj4+MCxOdW1iZXIoZ2UpPj4+MCkpOltdLGFjdGl2YXRpb246Q2Uoeil9KX0sOTIxNTU4OihzLGMpPT57dS5rYihcIkdsb2JhbEF2ZXJhZ2VQb29sXCIscyx7Zm9ybWF0OmM/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTIxNjQ5OihzLGMsZixiLHcsSSxPLEIsTCxILFgsY2UsZ2Useik9Pnt1LmtiKFwiQXZlcmFnZVBvb2xcIixzLHtmb3JtYXQ6ej9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDpjLGNlaWxfbW9kZTpmLGNvdW50X2luY2x1ZGVfcGFkOmIsc3RvcmFnZV9vcmRlcjp3LGRpbGF0aW9uczpJP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihJKT4+PjAsTnVtYmVyKE8pPj4+MCkpOltdLGtlcm5lbF9zaGFwZTpCP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihCKT4+PjAsTnVtYmVyKEwpPj4+MCkpOltdLHBhZHM6SD9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoSCk+Pj4wLE51bWJlcihYKT4+PjApKTpbXSxzdHJpZGVzOmNlP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihjZSk+Pj4wLE51bWJlcihnZSk+Pj4wKSk6W119KX0sOTIyMTI4OihzLGMpPT57dS5rYihcIkdsb2JhbEF2ZXJhZ2VQb29sXCIscyx7Zm9ybWF0OmM/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTIyMjE5OihzLGMsZixiLHcsSSxPLEIsTCxILFgsY2UsZ2Useik9Pnt1LmtiKFwiQXZlcmFnZVBvb2xcIixzLHtmb3JtYXQ6ej9cIk5IV0NcIjpcIk5DSFdcIixhdXRvX3BhZDpjLGNlaWxfbW9kZTpmLGNvdW50X2luY2x1ZGVfcGFkOmIsc3RvcmFnZV9vcmRlcjp3LGRpbGF0aW9uczpJP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihJKT4+PjAsTnVtYmVyKE8pPj4+MCkpOltdLGtlcm5lbF9zaGFwZTpCP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihCKT4+PjAsTnVtYmVyKEwpPj4+MCkpOltdLHBhZHM6SD9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoSCk+Pj4wLE51bWJlcihYKT4+PjApKTpbXSxzdHJpZGVzOmNlP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihjZSk+Pj4wLE51bWJlcihnZSk+Pj4wKSk6W119KX0sOTIyNjk4OihzLGMpPT57dS5rYihcIkdsb2JhbE1heFBvb2xcIixzLHtmb3JtYXQ6Yz9cIk5IV0NcIjpcIk5DSFdcIn0pfSw5MjI3ODU6KHMsYyxmLGIsdyxJLE8sQixMLEgsWCxjZSxnZSx6KT0+e3Uua2IoXCJNYXhQb29sXCIscyx7Zm9ybWF0Ono/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6YyxjZWlsX21vZGU6Zixjb3VudF9pbmNsdWRlX3BhZDpiLHN0b3JhZ2Vfb3JkZXI6dyxkaWxhdGlvbnM6ST9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoSSk+Pj4wLE51bWJlcihPKT4+PjApKTpbXSxrZXJuZWxfc2hhcGU6Qj9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoQik+Pj4wLE51bWJlcihMKT4+PjApKTpbXSxwYWRzOkg/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKEgpPj4+MCxOdW1iZXIoWCk+Pj4wKSk6W10sc3RyaWRlczpjZT9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoY2UpPj4+MCxOdW1iZXIoZ2UpPj4+MCkpOltdfSl9LDkyMzI2MDoocyxjKT0+e3Uua2IoXCJHbG9iYWxNYXhQb29sXCIscyx7Zm9ybWF0OmM/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTIzMzQ3OihzLGMsZixiLHcsSSxPLEIsTCxILFgsY2UsZ2Useik9Pnt1LmtiKFwiTWF4UG9vbFwiLHMse2Zvcm1hdDp6P1wiTkhXQ1wiOlwiTkNIV1wiLGF1dG9fcGFkOmMsY2VpbF9tb2RlOmYsY291bnRfaW5jbHVkZV9wYWQ6YixzdG9yYWdlX29yZGVyOncsZGlsYXRpb25zOkk/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKEkpPj4+MCxOdW1iZXIoTyk+Pj4wKSk6W10sa2VybmVsX3NoYXBlOkI/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKEIpPj4+MCxOdW1iZXIoTCk+Pj4wKSk6W10scGFkczpIP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihIKT4+PjAsTnVtYmVyKFgpPj4+MCkpOltdLHN0cmlkZXM6Y2U/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGNlKT4+PjAsTnVtYmVyKGdlKT4+PjApKTpbXX0pfSw5MjM4MjI6KHMsYyxmLGIsdyk9Pnt1LmtiKFwiR2VtbVwiLHMse2FscGhhOmMsYmV0YTpmLHRyYW5zQTpiLHRyYW5zQjp3fSl9LDkyMzkyNjpzPT57dS5rYihcIk1hdE11bFwiLHMsdm9pZCAwKX0sOTIzOTgwOihzLGMsZixiKT0+e3Uua2IoXCJBcmdNYXhcIixzLHtrZWVwRGltczohIWMsc2VsZWN0TGFzdEluZGV4OiEhZixheGlzOmJ9KX0sOTI0MDg4OihzLGMsZixiKT0+e3Uua2IoXCJBcmdNaW5cIixzLHtrZWVwRGltczohIWMsc2VsZWN0TGFzdEluZGV4OiEhZixheGlzOmJ9KX0sOTI0MTk2OihzLGMpPT57dS5rYihcIlNvZnRtYXhcIixzLHtheGlzOmN9KX0sOTI0MjU5OihzLGMpPT57dS5rYihcIkNvbmNhdFwiLHMse2F4aXM6Y30pfSw5MjQzMTk6KHMsYyxmLGIsdyk9Pnt1LmtiKFwiU3BsaXRcIixzLHtheGlzOmMsbnVtT3V0cHV0czpmLHNwbGl0U2l6ZXM6Yj9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoYik+Pj4wLE51bWJlcih3KT4+PjApKTpbXX0pfSw5MjQ0NzU6cz0+e3Uua2IoXCJFeHBhbmRcIixzLHZvaWQgMCl9LDkyNDUyOToocyxjKT0+e3Uua2IoXCJHYXRoZXJcIixzLHtheGlzOk51bWJlcihjKX0pfSw5MjQ2MDA6KHMsYyk9Pnt1LmtiKFwiR2F0aGVyRWxlbWVudHNcIixzLHtheGlzOk51bWJlcihjKX0pfSw5MjQ2Nzk6KHMsYyk9Pnt1LmtiKFwiR2F0aGVyTkRcIixzLHtiYXRjaF9kaW1zOk51bWJlcihjKX0pfSw5MjQ3NTg6KHMsYyxmLGIsdyxJLE8sQixMLEgsWCk9Pnt1LmtiKFwiUmVzaXplXCIscyx7YW50aWFsaWFzOmMsYXhlczpmP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihmKT4+PjAsTnVtYmVyKGIpPj4+MCkpOltdLGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlOkNlKHcpLGN1YmljQ29lZmZBOkksZXhjbHVkZU91dHNpZGU6TyxleHRyYXBvbGF0aW9uVmFsdWU6QixrZWVwQXNwZWN0UmF0aW9Qb2xpY3k6Q2UoTCksbW9kZTpDZShIKSxuZWFyZXN0TW9kZTpDZShYKX0pfSw5MjUxMjA6KHMsYyxmLGIsdyxJLE8pPT57dS5rYihcIlNsaWNlXCIscyx7c3RhcnRzOmM/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKGMpPj4+MCxOdW1iZXIoZik+Pj4wKSk6W10sZW5kczpiP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihiKT4+PjAsTnVtYmVyKHcpPj4+MCkpOltdLGF4ZXM6ST9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoSSk+Pj4wLE51bWJlcihPKT4+PjApKTpbXX0pfSw5MjUzODQ6cz0+e3Uua2IoXCJUaWxlXCIscyx2b2lkIDApfSw5MjU0MzY6KHMsYyxmKT0+e3Uua2IoXCJJbnN0YW5jZU5vcm1hbGl6YXRpb25cIixzLHtlcHNpbG9uOmMsZm9ybWF0OmY/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTI1NTUwOihzLGMsZik9Pnt1LmtiKFwiSW5zdGFuY2VOb3JtYWxpemF0aW9uXCIscyx7ZXBzaWxvbjpjLGZvcm1hdDpmP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkyNTY2NDpzPT57dS5rYihcIlJhbmdlXCIscyx2b2lkIDApfSw5MjU3MTc6KHMsYyk9Pnt1LmtiKFwiRWluc3VtXCIscyx7ZXF1YXRpb246Q2UoYyl9KX0sOTI1Nzk4OihzLGMsZixiLHcpPT57dS5rYihcIlBhZFwiLHMse21vZGU6Yyx2YWx1ZTpmLHBhZHM6Yj9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoYik+Pj4wLE51bWJlcih3KT4+PjApKTpbXX0pfSw5MjU5NDE6KHMsYyxmLGIsdyxJKT0+e3Uua2IoXCJCYXRjaE5vcm1hbGl6YXRpb25cIixzLHtlcHNpbG9uOmMsbW9tZW50dW06ZixzcGF0aWFsOiEhdyx0cmFpbmluZ01vZGU6ISFiLGZvcm1hdDpJP1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkyNjExMDoocyxjLGYsYix3LEkpPT57dS5rYihcIkJhdGNoTm9ybWFsaXphdGlvblwiLHMse2Vwc2lsb246Yyxtb21lbnR1bTpmLHNwYXRpYWw6ISF3LHRyYWluaW5nTW9kZTohIWIsZm9ybWF0Okk/XCJOSFdDXCI6XCJOQ0hXXCJ9KX0sOTI2Mjc5OihzLGMsZik9Pnt1LmtiKFwiQ3VtU3VtXCIscyx7ZXhjbHVzaXZlOk51bWJlcihjKSxyZXZlcnNlOk51bWJlcihmKX0pfSw5MjYzNzY6KHMsYyxmKT0+e3Uua2IoXCJEZXF1YW50aXplTGluZWFyXCIscyx7YXhpczpjLGJsb2NrU2l6ZTpmfSl9LDkyNjQ2NjoocyxjLGYsYix3KT0+e3Uua2IoXCJHcmlkU2FtcGxlXCIscyx7YWxpZ25fY29ybmVyczpjLG1vZGU6Q2UoZikscGFkZGluZ19tb2RlOkNlKGIpLGZvcm1hdDp3P1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkyNjYzNjoocyxjLGYsYix3KT0+e3Uua2IoXCJHcmlkU2FtcGxlXCIscyx7YWxpZ25fY29ybmVyczpjLG1vZGU6Q2UoZikscGFkZGluZ19tb2RlOkNlKGIpLGZvcm1hdDp3P1wiTkhXQ1wiOlwiTkNIV1wifSl9LDkyNjgwNjoocyxjLGYsYix3LEksTyxCLEwpPT57dS5rYihcIkF0dGVudGlvblwiLHMse251bUhlYWRzOmMsaXNVbmlkaXJlY3Rpb25hbDpmLG1hc2tGaWx0ZXJWYWx1ZTpiLHNjYWxlOncsZG9Sb3Rhcnk6SSxxa3ZIaWRkZW5TaXplczpPP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihCKT4+PjAsTnVtYmVyKEIpK08+Pj4wKSk6W10scGFzdFByZXNlbnRTaGFyZUJ1ZmZlcjohIUx9KX0sOTI3MDc4OnM9Pnt1LmtiKFwiQmlhc0FkZFwiLHMsdm9pZCAwKX0sOTI3MTMzOnM9Pnt1LmtiKFwiQmlhc1NwbGl0R2VsdVwiLHMsdm9pZCAwKX0sOTI3MTk0OnM9Pnt1LmtiKFwiRmFzdEdlbHVcIixzLHZvaWQgMCl9LDkyNzI1MDoocyxjLGYsYix3LEksTyxCLEwsSCxYLGNlLGdlLHosZGUsVGUpPT57dS5rYihcIkNvbnZcIixzLHtmb3JtYXQ6Y2U/XCJOSFdDXCI6XCJOQ0hXXCIsYXV0b19wYWQ6YyxkaWxhdGlvbnM6Zj9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoZik+Pj4wLE51bWJlcihiKT4+PjApKTpbXSxncm91cDp3LGtlcm5lbF9zaGFwZTpJP0FycmF5LmZyb20oaSgpLnN1YmFycmF5KE51bWJlcihJKT4+PjAsTnVtYmVyKE8pPj4+MCkpOltdLHBhZHM6Qj9BcnJheS5mcm9tKGkoKS5zdWJhcnJheShOdW1iZXIoQik+Pj4wLE51bWJlcihMKT4+PjApKTpbXSxzdHJpZGVzOkg/QXJyYXkuZnJvbShpKCkuc3ViYXJyYXkoTnVtYmVyKEgpPj4+MCxOdW1iZXIoWCk+Pj4wKSk6W10sd19pc19jb25zdDooKT0+ISF0KClbTnVtYmVyKGdlKT4+PjBdLGFjdGl2YXRpb246Q2UoeiksYWN0aXZhdGlvbl9wYXJhbXM6ZGU/QXJyYXkuZnJvbShkKCkuc3ViYXJyYXkoTnVtYmVyKGRlKT4+PjAsTnVtYmVyKFRlKT4+PjApKTpbXX0pfSw5Mjc4MzQ6cz0+e3Uua2IoXCJHZWx1XCIscyx2b2lkIDApfSw5Mjc4ODY6KHMsYyxmLGIsdyxJLE8sQixMKT0+e3Uua2IoXCJHcm91cFF1ZXJ5QXR0ZW50aW9uXCIscyx7bnVtSGVhZHM6Yyxrdk51bUhlYWRzOmYsc2NhbGU6Yixzb2Z0Y2FwOncsZG9Sb3Rhcnk6SSxyb3RhcnlJbnRlcmxlYXZlZDpPLHNtb290aFNvZnRtYXg6Qixsb2NhbFdpbmRvd1NpemU6TH0pfSw5MjgxMDM6KHMsYyxmLGIpPT57dS5rYihcIkxheWVyTm9ybWFsaXphdGlvblwiLHMse2F4aXM6YyxlcHNpbG9uOmYsc2ltcGxpZmllZDohIWJ9KX0sOTI4MjE0OihzLGMsZixiKT0+e3Uua2IoXCJMYXllck5vcm1hbGl6YXRpb25cIixzLHtheGlzOmMsZXBzaWxvbjpmLHNpbXBsaWZpZWQ6ISFifSl9LDkyODMyNToocyxjLGYsYix3LEkpPT57dS5rYihcIk1hdE11bE5CaXRzXCIscyx7azpjLG46ZixhY2N1cmFjeUxldmVsOmIsYml0czp3LGJsb2NrU2l6ZTpJfSl9LDkyODQ1MjoocyxjLGYsYix3LEkpPT57dS5rYihcIk11bHRpSGVhZEF0dGVudGlvblwiLHMse251bUhlYWRzOmMsaXNVbmlkaXJlY3Rpb25hbDpmLG1hc2tGaWx0ZXJWYWx1ZTpiLHNjYWxlOncsZG9Sb3Rhcnk6SX0pfSw5Mjg2MTE6KHMsYyk9Pnt1LmtiKFwiUXVpY2tHZWx1XCIscyx7YWxwaGE6Y30pfSw5Mjg2NzU6KHMsYyxmLGIsdyk9Pnt1LmtiKFwiUm90YXJ5RW1iZWRkaW5nXCIscyx7aW50ZXJsZWF2ZWQ6ISFjLG51bUhlYWRzOmYscm90YXJ5RW1iZWRkaW5nRGltOmIsc2NhbGU6d30pfSw5Mjg4MTQ6KHMsYyxmKT0+e3Uua2IoXCJTa2lwTGF5ZXJOb3JtYWxpemF0aW9uXCIscyx7ZXBzaWxvbjpjLHNpbXBsaWZpZWQ6ISFmfSl9LDkyODkxNjoocyxjLGYpPT57dS5rYihcIlNraXBMYXllck5vcm1hbGl6YXRpb25cIixzLHtlcHNpbG9uOmMsc2ltcGxpZmllZDohIWZ9KX0sOTI5MDE4OihzLGMsZixiKT0+e3Uua2IoXCJHYXRoZXJCbG9ja1F1YW50aXplZFwiLHMse2dhdGhlckF4aXM6YyxxdWFudGl6ZUF4aXM6ZixibG9ja1NpemU6Yn0pfSw5MjkxMzk6cz0+e3UuJGIocyl9LDkyOTE3MzoocyxjKT0+dS5jYyhOdW1iZXIocyksTnVtYmVyKGMpLHUuR2IuaGMsdS5HYi5lcnJvcnMpfTtmdW5jdGlvbiB2YyhzLGMsZil7cmV0dXJuIF9pKGFzeW5jKCk9Pnthd2FpdCB1LlliKE51bWJlcihzKSxOdW1iZXIoYyksTnVtYmVyKGYpKX0pfWZ1bmN0aW9uICRjKCl7cmV0dXJuIHR5cGVvZiB3YXNtT2Zmc2V0Q29udmVydGVyPFwidVwifWZ1bmN0aW9uIHluKHMpe3RoaXMubmFtZT1cIkV4aXRTdGF0dXNcIix0aGlzLm1lc3NhZ2U9YFByb2dyYW0gdGVybWluYXRlZCB3aXRoIGV4aXQoJHtzfSlgLHRoaXMuc3RhdHVzPXN9dmFyIF9uPXM9PntzLnRlcm1pbmF0ZSgpLHMub25tZXNzYWdlPSgpPT57fX0sVm89cz0+e3B0Lmxlbmd0aD09MCYmKHFvKCksRm8ocHRbMF0pKTt2YXIgYz1wdC5wb3AoKTtpZighYylyZXR1cm4gNjt2dC5wdXNoKGMpLFplW3MuQmJdPWMsYy5CYj1zLkJiO3ZhciBmPXtjbWQ6XCJydW5cIixzdGFydF9yb3V0aW5lOnMuaWMsYXJnOnMuUmIscHRocmVhZF9wdHI6cy5CYn07cmV0dXJuIGMucG9zdE1lc3NhZ2UoZixzLm5jKSwwfSx3dD0wLHhlPShzLGMsLi4uZik9Pntmb3IodmFyIGI9MipmLmxlbmd0aCx3PVJuKCksST1Nbig4KmIpLE89ST4+PjMsQj0wO0I8Zi5sZW5ndGg7QisrKXt2YXIgTD1mW0JdO3R5cGVvZiBMPT1cImJpZ2ludFwiPyhxW08rMipCXT0xbixxW08rMipCKzFdPUwpOihxW08rMipCXT0wbixsKClbTysyKkIrMT4+PjBdPUwpfXJldHVybiBzPUdpKHMsMCxiLEksYyksZ3Iodyksc307ZnVuY3Rpb24gd24ocyl7aWYoZylyZXR1cm4geGUoMCwxLHMpO2lmKGVlPXMsISgwPHd0KSl7Zm9yKHZhciBjIG9mIHZ0KV9uKGMpO2ZvcihjIG9mIHB0KV9uKGMpO3B0PVtdLHZ0PVtdLFplPVtdLHdlPSEwfWsocyxuZXcgeW4ocykpfWZ1bmN0aW9uIFdvKHMpe2lmKGcpcmV0dXJuIHhlKDEsMCxzKTt2bihzKX12YXIgdm49cz0+e2lmKGVlPXMsZyl0aHJvdyBXbyhzKSxcInVud2luZFwiO3duKHMpfSxwdD1bXSx2dD1bXSxMbz1bXSxaZT17fSxHbz1zPT57dmFyIGM9cy5CYjtkZWxldGUgWmVbY10scHQucHVzaChzKSx2dC5zcGxpY2UodnQuaW5kZXhPZihzKSwxKSxzLkJiPTAsQm4oYyl9O2Z1bmN0aW9uIEhvKCl7TG8uZm9yRWFjaChzPT5zKCkpfXZhciBGbz1zPT5uZXcgUHJvbWlzZShjPT57cy5vbm1lc3NhZ2U9dz0+e3ZhciBJPSh3PXcuZGF0YSkuY21kO2lmKHcudGFyZ2V0VGhyZWFkJiZ3LnRhcmdldFRocmVhZCE9TXQoKSl7dmFyIE89WmVbdy50YXJnZXRUaHJlYWRdO08/Ty5wb3N0TWVzc2FnZSh3LHcudHJhbnNmZXJMaXN0KTpqKGBJbnRlcm5hbCBlcnJvciEgV29ya2VyIHNlbnQgYSBtZXNzYWdlIFwiJHtJfVwiIHRvIHRhcmdldCBwdGhyZWFkICR7dy50YXJnZXRUaHJlYWR9LCBidXQgdGhhdCB0aHJlYWQgbm8gbG9uZ2VyIGV4aXN0cyFgKX1lbHNlIEk9PT1cImNoZWNrTWFpbGJveFwiP2lyKCk6ST09PVwic3Bhd25UaHJlYWRcIj9Wbyh3KTpJPT09XCJjbGVhbnVwVGhyZWFkXCI/R28oWmVbdy50aHJlYWRdKTpJPT09XCJraWxsVGhyZWFkXCI/KHc9dy50aHJlYWQsST1aZVt3XSxkZWxldGUgWmVbd10sX24oSSksQm4odyksdnQuc3BsaWNlKHZ0LmluZGV4T2YoSSksMSksSS5CYj0wKTpJPT09XCJjYW5jZWxUaHJlYWRcIj9aZVt3LnRocmVhZF0ucG9zdE1lc3NhZ2Uoe2NtZDpcImNhbmNlbFwifSk6ST09PVwibG9hZGVkXCI/KHMubG9hZGVkPSEwLGMocykpOkk9PT1cImFsZXJ0XCI/YWxlcnQoYFRocmVhZCAke3cudGhyZWFkSWR9OiAke3cudGV4dH1gKTp3LnRhcmdldD09PVwic2V0aW1tZWRpYXRlXCI/cy5wb3N0TWVzc2FnZSh3KTpJPT09XCJjYWxsSGFuZGxlclwiP3Vbdy5oYW5kbGVyXSguLi53LmFyZ3MpOkkmJmooYHdvcmtlciBzZW50IGFuIHVua25vd24gY29tbWFuZCAke0l9YCl9LHMub25lcnJvcj13PT57dGhyb3cgaihgd29ya2VyIHNlbnQgYW4gZXJyb3IhICR7dy5maWxlbmFtZX06JHt3LmxpbmVub306ICR7dy5tZXNzYWdlfWApLHd9O3ZhciBmLGI9W107Zm9yKGYgb2ZbXSl1Lmhhc093blByb3BlcnR5KGYpJiZiLnB1c2goZik7cy5wb3N0TWVzc2FnZSh7Y21kOlwibG9hZFwiLGhhbmRsZXJzOmIsd2FzbU1lbW9yeTpzZSx3YXNtTW9kdWxlOll9KX0pO2Z1bmN0aW9uIHFvKCl7dmFyIHM9bmV3IFdvcmtlcihpbXBvcnQubWV0YS51cmwuc3RhcnRzV2l0aChcImZpbGU6XCIpP25ldyBVUkwoXCJvcnQud2ViZ3B1LmJ1bmRsZS5taW4ubWpzXCIsaW1wb3J0Lm1ldGEudXJsKTpuZXcgVVJMKGltcG9ydC5tZXRhLnVybCkse3R5cGU6XCJtb2R1bGVcIix3b3JrZXJEYXRhOlwiZW0tcHRocmVhZFwiLG5hbWU6XCJlbS1wdGhyZWFkXCJ9KTtwdC5wdXNoKHMpfXZhciBvcj1zPT57Zm9yKDswPHMubGVuZ3RoOylzLnNoaWZ0KCkodSl9LHhjPSgpPT57dmFyIHM9TXQoKSxjPWEoKVtzKzUyPj4+Mj4+PjBdO3M9YSgpW3MrNTY+Pj4yPj4+MF0sRmkoYyxjLXMpLGdyKGMpfSxTYz0ocyxjKT0+e3d0PTAscz1xaShzLGMpLDA8d3Q/ZWU9czpocihzKX07Y2xhc3MgVGN7Y29uc3RydWN0b3IoYyl7dGhpcy5LYj1jLTI0fX1mdW5jdGlvbiBJYyhzLGMsZil7dmFyIGI9bmV3IFRjKHM+Pj49MCk7dGhyb3cgYz4+Pj0wLGY+Pj49MCxhKClbYi5LYisxNj4+PjI+Pj4wXT0wLGEoKVtiLktiKzQ+Pj4yPj4+MF09YyxhKClbYi5LYis4Pj4+Mj4+PjBdPWYsc31mdW5jdGlvbiBLbyhzLGMsZixiKXtyZXR1cm4gZz94ZSgyLDEscyxjLGYsYik6am8ocyxjLGYsYil9ZnVuY3Rpb24gam8ocyxjLGYsYil7aWYocz4+Pj0wLGM+Pj49MCxmPj4+PTAsYj4+Pj0wLHg9PT12b2lkIDApcmV0dXJuIGooXCJDdXJyZW50IGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgU2hhcmVkQXJyYXlCdWZmZXIsIHB0aHJlYWRzIGFyZSBub3QgYXZhaWxhYmxlIVwiKSw2O3ZhciB3PVtdO3JldHVybiBnJiZ3Lmxlbmd0aD09PTA/S28ocyxjLGYsYik6KHM9e2ljOmYsQmI6cyxSYjpiLG5jOnd9LGc/KHMuTmI9XCJzcGF3blRocmVhZFwiLHBvc3RNZXNzYWdlKHMsdyksMCk6Vm8ocykpfXZhciBZbz10eXBlb2YgVGV4dERlY29kZXI8XCJ1XCI/bmV3IFRleHREZWNvZGVyKFwidXRmOFwiKTp2b2lkIDAsWm89KHMsYyxmKT0+e3ZhciBiPShjPj4+PTApK2Y7Zm9yKGY9YztzW2ZdJiYhKGY+PWIpOykrK2Y7aWYoMTY8Zi1jJiZzLmJ1ZmZlciYmWW8pcmV0dXJuIFlvLmRlY29kZShzLmJ1ZmZlciBpbnN0YW5jZW9mIHg/cy5zbGljZShjLGYpOnMuc3ViYXJyYXkoYyxmKSk7Zm9yKGI9XCJcIjtjPGY7KXt2YXIgdz1zW2MrK107aWYoMTI4Jncpe3ZhciBJPTYzJnNbYysrXTtpZigoMjI0JncpPT0xOTIpYis9U3RyaW5nLmZyb21DaGFyQ29kZSgoMzEmdyk8PDZ8SSk7ZWxzZXt2YXIgTz02MyZzW2MrK107NjU1MzY+KHc9KDI0MCZ3KT09MjI0PygxNSZ3KTw8MTJ8STw8NnxPOig3JncpPDwxOHxJPDwxMnxPPDw2fDYzJnNbYysrXSk/Yis9U3RyaW5nLmZyb21DaGFyQ29kZSh3KToody09NjU1MzYsYis9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5Nnx3Pj4xMCw1NjMyMHwxMDIzJncpKX19ZWxzZSBiKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHcpfXJldHVybiBifSxDZT0ocyxjKT0+KHM+Pj49MCk/Wm8ocigpLHMsYyk6XCJcIjtmdW5jdGlvbiBRbyhzLGMsZil7cmV0dXJuIGc/eGUoMywxLHMsYyxmKTowfWZ1bmN0aW9uIFhvKHMsYyl7aWYoZylyZXR1cm4geGUoNCwxLHMsYyl9dmFyICRuPXM9Pntmb3IodmFyIGM9MCxmPTA7ZjxzLmxlbmd0aDsrK2Ype3ZhciBiPXMuY2hhckNvZGVBdChmKTsxMjc+PWI/YysrOjIwNDc+PWI/Yys9Mjo1NTI5Njw9YiYmNTczNDM+PWI/KGMrPTQsKytmKTpjKz0zfXJldHVybiBjfSxKbz0ocyxjLGYsYik9PntpZighKDA8YikpcmV0dXJuIDA7dmFyIHc9Zj4+Pj0wO2I9ZitiLTE7Zm9yKHZhciBJPTA7STxzLmxlbmd0aDsrK0kpe3ZhciBPPXMuY2hhckNvZGVBdChJKTtpZig1NTI5Njw9TyYmNTczNDM+PU8mJihPPTY1NTM2KygoMTAyMyZPKTw8MTApfDEwMjMmcy5jaGFyQ29kZUF0KCsrSSkpLDEyNz49Tyl7aWYoZj49YilicmVhaztjW2YrKz4+PjBdPU99ZWxzZXtpZigyMDQ3Pj1PKXtpZihmKzE+PWIpYnJlYWs7Y1tmKys+Pj4wXT0xOTJ8Tz4+Nn1lbHNle2lmKDY1NTM1Pj1PKXtpZihmKzI+PWIpYnJlYWs7Y1tmKys+Pj4wXT0yMjR8Tz4+MTJ9ZWxzZXtpZihmKzM+PWIpYnJlYWs7Y1tmKys+Pj4wXT0yNDB8Tz4+MTgsY1tmKys+Pj4wXT0xMjh8Tz4+MTImNjN9Y1tmKys+Pj4wXT0xMjh8Tz4+NiY2M31jW2YrKz4+PjBdPTEyOHw2MyZPfX1yZXR1cm4gY1tmPj4+MF09MCxmLXd9LE90PShzLGMsZik9PkpvKHMscigpLGMsZik7ZnVuY3Rpb24gZWkocyxjKXtpZihnKXJldHVybiB4ZSg1LDEscyxjKX1mdW5jdGlvbiB0aShzLGMsZil7aWYoZylyZXR1cm4geGUoNiwxLHMsYyxmKX1mdW5jdGlvbiByaShzLGMsZil7cmV0dXJuIGc/eGUoNywxLHMsYyxmKTowfWZ1bmN0aW9uIG5pKHMsYyl7aWYoZylyZXR1cm4geGUoOCwxLHMsYyl9ZnVuY3Rpb24gb2kocyxjLGYpe2lmKGcpcmV0dXJuIHhlKDksMSxzLGMsZil9ZnVuY3Rpb24gaWkocyxjLGYsYil7aWYoZylyZXR1cm4geGUoMTAsMSxzLGMsZixiKX1mdW5jdGlvbiBhaShzLGMsZixiKXtpZihnKXJldHVybiB4ZSgxMSwxLHMsYyxmLGIpfWZ1bmN0aW9uIHNpKHMsYyxmLGIpe2lmKGcpcmV0dXJuIHhlKDEyLDEscyxjLGYsYil9ZnVuY3Rpb24gdWkocyl7aWYoZylyZXR1cm4geGUoMTMsMSxzKX1mdW5jdGlvbiBkaShzLGMpe2lmKGcpcmV0dXJuIHhlKDE0LDEscyxjKX1mdW5jdGlvbiBsaShzLGMsZil7aWYoZylyZXR1cm4geGUoMTUsMSxzLGMsZil9dmFyIGNpLG10LENjPSgpPT57Y3QoXCJcIil9LFFlPXM9Pntmb3IodmFyIGM9XCJcIjtyKClbcz4+PjBdOyljKz1jaVtyKClbcysrPj4+MF1dO3JldHVybiBjfSx4bj17fSxTbj17fSxBYz17fTtmdW5jdGlvbiBzdChzLGMsZj17fSl7aWYoIShcImFyZ1BhY2tBZHZhbmNlXCJpbiBjKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwicmVnaXN0ZXJUeXBlIHJlZ2lzdGVyZWRJbnN0YW5jZSByZXF1aXJlcyBhcmdQYWNrQWR2YW5jZVwiKTtyZXR1cm4gZnVuY3Rpb24oYix3LEk9e30pe3ZhciBPPXcubmFtZTtpZighYil0aHJvdyBuZXcgbXQoYHR5cGUgXCIke099XCIgbXVzdCBoYXZlIGEgcG9zaXRpdmUgaW50ZWdlciB0eXBlaWQgcG9pbnRlcmApO2lmKFNuLmhhc093blByb3BlcnR5KGIpKXtpZihJLlRiKXJldHVybjt0aHJvdyBuZXcgbXQoYENhbm5vdCByZWdpc3RlciB0eXBlICcke099JyB0d2ljZWApfVNuW2JdPXcsZGVsZXRlIEFjW2JdLHhuLmhhc093blByb3BlcnR5KGIpJiYodz14bltiXSxkZWxldGUgeG5bYl0sdy5mb3JFYWNoKEI9PkIoKSkpfShzLGMsZil9dmFyIHBpPShzLGMsZik9Pntzd2l0Y2goYyl7Y2FzZSAxOnJldHVybiBmP2I9PnQoKVtiPj4+MF06Yj0+cigpW2I+Pj4wXTtjYXNlIDI6cmV0dXJuIGY/Yj0+bigpW2I+Pj4xPj4+MF06Yj0+bygpW2I+Pj4xPj4+MF07Y2FzZSA0OnJldHVybiBmP2I9PmkoKVtiPj4+Mj4+PjBdOmI9PmEoKVtiPj4+Mj4+PjBdO2Nhc2UgODpyZXR1cm4gZj9iPT5xW2I+Pj4zXTpiPT5oZVtiPj4+M107ZGVmYXVsdDp0aHJvdyBuZXcgVHlwZUVycm9yKGBpbnZhbGlkIGludGVnZXIgd2lkdGggKCR7Y30pOiAke3N9YCl9fTtmdW5jdGlvbiBrYyhzLGMsZil7Zj4+Pj0wLHN0KHM+Pj49MCx7bmFtZTpjPVFlKGM+Pj4wKSxmcm9tV2lyZVR5cGU6Yj0+Yix0b1dpcmVUeXBlOmZ1bmN0aW9uKGIsdyl7aWYodHlwZW9mIHchPVwiYmlnaW50XCImJnR5cGVvZiB3IT1cIm51bWJlclwiKXRocm93IHc9dz09PW51bGw/XCJudWxsXCI6KGI9dHlwZW9mIHcpPT1cIm9iamVjdFwifHxiPT09XCJhcnJheVwifHxiPT09XCJmdW5jdGlvblwiP3cudG9TdHJpbmcoKTpcIlwiK3csbmV3IFR5cGVFcnJvcihgQ2Fubm90IGNvbnZlcnQgXCIke3d9XCIgdG8gJHt0aGlzLm5hbWV9YCk7cmV0dXJuIHR5cGVvZiB3PT1cIm51bWJlclwiJiYodz1CaWdJbnQodykpLHd9LGFyZ1BhY2tBZHZhbmNlOmZ0LHJlYWRWYWx1ZUZyb21Qb2ludGVyOnBpKGMsZixjLmluZGV4T2YoXCJ1XCIpPT0tMSksRWI6bnVsbH0pfXZhciBmdD04O2Z1bmN0aW9uIEVjKHMsYyxmLGIpe3N0KHM+Pj49MCx7bmFtZTpjPVFlKGM+Pj4wKSxmcm9tV2lyZVR5cGU6ZnVuY3Rpb24odyl7cmV0dXJuISF3fSx0b1dpcmVUeXBlOmZ1bmN0aW9uKHcsSSl7cmV0dXJuIEk/ZjpifSxhcmdQYWNrQWR2YW5jZTpmdCxyZWFkVmFsdWVGcm9tUG9pbnRlcjpmdW5jdGlvbih3KXtyZXR1cm4gdGhpcy5mcm9tV2lyZVR5cGUocigpW3c+Pj4wXSl9LEViOm51bGx9KX12YXIgVG49W10sdXQ9W107ZnVuY3Rpb24gSW4ocyl7OTwocz4+Pj0wKSYmLS11dFtzKzFdPT0wJiYodXRbc109dm9pZCAwLFRuLnB1c2gocykpfXZhciBNZT1zPT57aWYoIXMpdGhyb3cgbmV3IG10KFwiQ2Fubm90IHVzZSBkZWxldGVkIHZhbC4gaGFuZGxlID0gXCIrcyk7cmV0dXJuIHV0W3NdfSxWZT1zPT57c3dpdGNoKHMpe2Nhc2Ugdm9pZCAwOnJldHVybiAyO2Nhc2UgbnVsbDpyZXR1cm4gNDtjYXNlITA6cmV0dXJuIDY7Y2FzZSExOnJldHVybiA4O2RlZmF1bHQ6bGV0IGM9VG4ucG9wKCl8fHV0Lmxlbmd0aDtyZXR1cm4gdXRbY109cyx1dFtjKzFdPTEsY319O2Z1bmN0aW9uIENuKHMpe3JldHVybiB0aGlzLmZyb21XaXJlVHlwZShhKClbcz4+PjI+Pj4wXSl9dmFyIFBjPXtuYW1lOlwiZW1zY3JpcHRlbjo6dmFsXCIsZnJvbVdpcmVUeXBlOnM9Pnt2YXIgYz1NZShzKTtyZXR1cm4gSW4ocyksY30sdG9XaXJlVHlwZToocyxjKT0+VmUoYyksYXJnUGFja0FkdmFuY2U6ZnQscmVhZFZhbHVlRnJvbVBvaW50ZXI6Q24sRWI6bnVsbH07ZnVuY3Rpb24gemMocyl7cmV0dXJuIHN0KHM+Pj4wLFBjKX12YXIgT2M9KHMsYyk9Pntzd2l0Y2goYyl7Y2FzZSA0OnJldHVybiBmdW5jdGlvbihmKXtyZXR1cm4gdGhpcy5mcm9tV2lyZVR5cGUoZCgpW2Y+Pj4yPj4+MF0pfTtjYXNlIDg6cmV0dXJuIGZ1bmN0aW9uKGYpe3JldHVybiB0aGlzLmZyb21XaXJlVHlwZShsKClbZj4+PjM+Pj4wXSl9O2RlZmF1bHQ6dGhyb3cgbmV3IFR5cGVFcnJvcihgaW52YWxpZCBmbG9hdCB3aWR0aCAoJHtjfSk6ICR7c31gKX19O2Z1bmN0aW9uIERjKHMsYyxmKXtmPj4+PTAsc3Qocz4+Pj0wLHtuYW1lOmM9UWUoYz4+PjApLGZyb21XaXJlVHlwZTpiPT5iLHRvV2lyZVR5cGU6KGIsdyk9PncsYXJnUGFja0FkdmFuY2U6ZnQscmVhZFZhbHVlRnJvbVBvaW50ZXI6T2MoYyxmKSxFYjpudWxsfSl9ZnVuY3Rpb24gQmMocyxjLGYsYix3KXtpZihzPj4+PTAsZj4+Pj0wLGM9UWUoYz4+PjApLHc9PT0tMSYmKHc9NDI5NDk2NzI5NSksdz1CPT5CLGI9PT0wKXt2YXIgST0zMi04KmY7dz1CPT5CPDxJPj4+SX12YXIgTz1jLmluY2x1ZGVzKFwidW5zaWduZWRcIik/ZnVuY3Rpb24oQixMKXtyZXR1cm4gTD4+PjB9OmZ1bmN0aW9uKEIsTCl7cmV0dXJuIEx9O3N0KHMse25hbWU6Yyxmcm9tV2lyZVR5cGU6dyx0b1dpcmVUeXBlOk8sYXJnUGFja0FkdmFuY2U6ZnQscmVhZFZhbHVlRnJvbVBvaW50ZXI6cGkoYyxmLGIhPT0wKSxFYjpudWxsfSl9ZnVuY3Rpb24gTWMocyxjLGYpe2Z1bmN0aW9uIGIoSSl7dmFyIE89YSgpW0k+Pj4yPj4+MF07cmV0dXJuIEk9YSgpW0krND4+PjI+Pj4wXSxuZXcgdyh0KCkuYnVmZmVyLEksTyl9dmFyIHc9W0ludDhBcnJheSxVaW50OEFycmF5LEludDE2QXJyYXksVWludDE2QXJyYXksSW50MzJBcnJheSxVaW50MzJBcnJheSxGbG9hdDMyQXJyYXksRmxvYXQ2NEFycmF5LEJpZ0ludDY0QXJyYXksQmlnVWludDY0QXJyYXldW2NdO3N0KHM+Pj49MCx7bmFtZTpmPVFlKGY+Pj4wKSxmcm9tV2lyZVR5cGU6YixhcmdQYWNrQWR2YW5jZTpmdCxyZWFkVmFsdWVGcm9tUG9pbnRlcjpifSx7VGI6ITB9KX1mdW5jdGlvbiBSYyhzLGMpe3M+Pj49MDt2YXIgZj0oYz1RZShjPj4+MCkpPT09XCJzdGQ6OnN0cmluZ1wiO3N0KHMse25hbWU6Yyxmcm9tV2lyZVR5cGU6ZnVuY3Rpb24oYil7dmFyIHc9YSgpW2I+Pj4yPj4+MF0sST1iKzQ7aWYoZilmb3IodmFyIE89SSxCPTA7Qjw9dzsrK0Ipe3ZhciBMPUkrQjtpZihCPT13fHxyKClbTD4+PjBdPT0wKXtpZihPPUNlKE8sTC1PKSxIPT09dm9pZCAwKXZhciBIPU87ZWxzZSBIKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDApLEgrPU87Tz1MKzF9fWVsc2V7Zm9yKEg9QXJyYXkodyksQj0wO0I8dzsrK0IpSFtCXT1TdHJpbmcuZnJvbUNoYXJDb2RlKHIoKVtJK0I+Pj4wXSk7SD1ILmpvaW4oXCJcIil9cmV0dXJuIEplKGIpLEh9LHRvV2lyZVR5cGU6ZnVuY3Rpb24oYix3KXt3IGluc3RhbmNlb2YgQXJyYXlCdWZmZXImJih3PW5ldyBVaW50OEFycmF5KHcpKTt2YXIgST10eXBlb2Ygdz09XCJzdHJpbmdcIjtpZighKEl8fHcgaW5zdGFuY2VvZiBVaW50OEFycmF5fHx3IGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXl8fHcgaW5zdGFuY2VvZiBJbnQ4QXJyYXkpKXRocm93IG5ldyBtdChcIkNhbm5vdCBwYXNzIG5vbi1zdHJpbmcgdG8gc3RkOjpzdHJpbmdcIik7dmFyIE89ZiYmST8kbih3KTp3Lmxlbmd0aCxCPWZyKDQrTysxKSxMPUIrNDtpZihhKClbQj4+PjI+Pj4wXT1PLGYmJkkpT3QodyxMLE8rMSk7ZWxzZSBpZihJKWZvcihJPTA7STxPOysrSSl7dmFyIEg9dy5jaGFyQ29kZUF0KEkpO2lmKDI1NTxIKXRocm93IEplKEwpLG5ldyBtdChcIlN0cmluZyBoYXMgVVRGLTE2IGNvZGUgdW5pdHMgdGhhdCBkbyBub3QgZml0IGluIDggYml0c1wiKTtyKClbTCtJPj4+MF09SH1lbHNlIGZvcihJPTA7STxPOysrSSlyKClbTCtJPj4+MF09d1tJXTtyZXR1cm4gYiE9PW51bGwmJmIucHVzaChKZSxCKSxCfSxhcmdQYWNrQWR2YW5jZTpmdCxyZWFkVmFsdWVGcm9tUG9pbnRlcjpDbixFYihiKXtKZShiKX19KX12YXIgbWk9dHlwZW9mIFRleHREZWNvZGVyPFwidVwiP25ldyBUZXh0RGVjb2RlcihcInV0Zi0xNmxlXCIpOnZvaWQgMCxVYz0ocyxjKT0+e2Zvcih2YXIgZj1zPj4xLGI9ZitjLzI7IShmPj1iKSYmbygpW2Y+Pj4wXTspKytmO2lmKDMyPChmPDw9MSktcyYmbWkpcmV0dXJuIG1pLmRlY29kZShyKCkuc2xpY2UocyxmKSk7Zm9yKGY9XCJcIixiPTA7IShiPj1jLzIpOysrYil7dmFyIHc9bigpW3MrMipiPj4+MT4+PjBdO2lmKHc9PTApYnJlYWs7Zis9U3RyaW5nLmZyb21DaGFyQ29kZSh3KX1yZXR1cm4gZn0sTmM9KHMsYyxmKT0+e2lmKGY/Pz0yMTQ3NDgzNjQ3LDI+ZilyZXR1cm4gMDt2YXIgYj1jO2Y9KGYtPTIpPDIqcy5sZW5ndGg/Zi8yOnMubGVuZ3RoO2Zvcih2YXIgdz0wO3c8ZjsrK3cpe3ZhciBJPXMuY2hhckNvZGVBdCh3KTtuKClbYz4+PjE+Pj4wXT1JLGMrPTJ9cmV0dXJuIG4oKVtjPj4+MT4+PjBdPTAsYy1ifSxWYz1zPT4yKnMubGVuZ3RoLFdjPShzLGMpPT57Zm9yKHZhciBmPTAsYj1cIlwiOyEoZj49Yy80KTspe3ZhciB3PWkoKVtzKzQqZj4+PjI+Pj4wXTtpZih3PT0wKWJyZWFrOysrZiw2NTUzNjw9dz8ody09NjU1MzYsYis9U3RyaW5nLmZyb21DaGFyQ29kZSg1NTI5Nnx3Pj4xMCw1NjMyMHwxMDIzJncpKTpiKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHcpfXJldHVybiBifSxMYz0ocyxjLGYpPT57aWYoYz4+Pj0wLGY/Pz0yMTQ3NDgzNjQ3LDQ+ZilyZXR1cm4gMDt2YXIgYj1jO2Y9YitmLTQ7Zm9yKHZhciB3PTA7dzxzLmxlbmd0aDsrK3cpe3ZhciBJPXMuY2hhckNvZGVBdCh3KTtpZig1NTI5Njw9SSYmNTczNDM+PUkmJihJPTY1NTM2KygoMTAyMyZJKTw8MTApfDEwMjMmcy5jaGFyQ29kZUF0KCsrdykpLGkoKVtjPj4+Mj4+PjBdPUksKGMrPTQpKzQ+ZilicmVha31yZXR1cm4gaSgpW2M+Pj4yPj4+MF09MCxjLWJ9LEdjPXM9Pntmb3IodmFyIGM9MCxmPTA7ZjxzLmxlbmd0aDsrK2Ype3ZhciBiPXMuY2hhckNvZGVBdChmKTs1NTI5Njw9YiYmNTczNDM+PWImJisrZixjKz00fXJldHVybiBjfTtmdW5jdGlvbiBIYyhzLGMsZil7aWYocz4+Pj0wLGM+Pj49MCxmPVFlKGY+Pj49MCksYz09PTIpdmFyIGI9VWMsdz1OYyxJPVZjLE89Qj0+bygpW0I+Pj4xPj4+MF07ZWxzZSBjPT09NCYmKGI9V2Msdz1MYyxJPUdjLE89Qj0+YSgpW0I+Pj4yPj4+MF0pO3N0KHMse25hbWU6Zixmcm9tV2lyZVR5cGU6Qj0+e2Zvcih2YXIgTCxIPWEoKVtCPj4+Mj4+PjBdLFg9Qis0LGNlPTA7Y2U8PUg7KytjZSl7dmFyIGdlPUIrNCtjZSpjO2NlIT1IJiZPKGdlKSE9MHx8KFg9YihYLGdlLVgpLEw9PT12b2lkIDA/TD1YOihMKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDApLEwrPVgpLFg9Z2UrYyl9cmV0dXJuIEplKEIpLEx9LHRvV2lyZVR5cGU6KEIsTCk9PntpZih0eXBlb2YgTCE9XCJzdHJpbmdcIil0aHJvdyBuZXcgbXQoYENhbm5vdCBwYXNzIG5vbi1zdHJpbmcgdG8gQysrIHN0cmluZyB0eXBlICR7Zn1gKTt2YXIgSD1JKEwpLFg9ZnIoNCtIK2MpO3JldHVybiBhKClbWD4+PjI+Pj4wXT1IL2MsdyhMLFgrNCxIK2MpLEIhPT1udWxsJiZCLnB1c2goSmUsWCksWH0sYXJnUGFja0FkdmFuY2U6ZnQscmVhZFZhbHVlRnJvbVBvaW50ZXI6Q24sRWIoQil7SmUoQil9fSl9ZnVuY3Rpb24gRmMocyxjKXtzdChzPj4+PTAse1ViOiEwLG5hbWU6Yz1RZShjPj4+MCksYXJnUGFja0FkdmFuY2U6MCxmcm9tV2lyZVR5cGU6KCk9Pnt9LHRvV2lyZVR5cGU6KCk9Pnt9fSl9dmFyIHFjPSgpPT4xO2Z1bmN0aW9uIEtjKHMpe0RuKHM+Pj4wLCF5LDEsIV8sMTMxMDcyLCExKSxIbygpfXZhciBmaT1zPT57aWYoIXdlKXRyeXtpZihzKCksISgwPHd0KSl0cnl7Zz9ocihlZSk6dm4oZWUpfWNhdGNoKGMpe2MgaW5zdGFuY2VvZiB5bnx8Yz09XCJ1bndpbmRcInx8aygxLGMpfX1jYXRjaChjKXtjIGluc3RhbmNlb2YgeW58fGM9PVwidW53aW5kXCJ8fGsoMSxjKX19O2Z1bmN0aW9uIEFuKHMpe3M+Pj49MCx0eXBlb2YgQXRvbWljcy5vYz09XCJmdW5jdGlvblwiJiYoQXRvbWljcy5vYyhpKCkscz4+PjIscykudmFsdWUudGhlbihpcikscys9MTI4LEF0b21pY3Muc3RvcmUoaSgpLHM+Pj4yLDEpKX12YXIgaXI9KCk9Pnt2YXIgcz1NdCgpO3MmJihBbihzKSxmaShIaSkpfTtmdW5jdGlvbiBqYyhzLGMpeyhzPj4+PTApPT1jPj4+MD9zZXRUaW1lb3V0KGlyKTpnP3Bvc3RNZXNzYWdlKHt0YXJnZXRUaHJlYWQ6cyxjbWQ6XCJjaGVja01haWxib3hcIn0pOihzPVplW3NdKSYmcy5wb3N0TWVzc2FnZSh7Y21kOlwiY2hlY2tNYWlsYm94XCJ9KX12YXIga249W107ZnVuY3Rpb24gWWMocyxjLGYsYix3KXtmb3IoYz4+Pj0wLGIvPTIsa24ubGVuZ3RoPWIsZj13Pj4+MD4+PjMsdz0wO3c8Yjt3Kyspa25bd109cVtmKzIqd10/cVtmKzIqdysxXTpsKClbZisyKncrMT4+PjBdO3JldHVybihjP2JuW2NdOk5wW3NdKSguLi5rbil9ZnVuY3Rpb24gWmMocyl7cz4+Pj0wLGc/cG9zdE1lc3NhZ2Uoe2NtZDpcImNsZWFudXBUaHJlYWRcIix0aHJlYWQ6c30pOkdvKFplW3NdKX1mdW5jdGlvbiBRYyhzKXt9dmFyIGFyPShzLGMpPT57dmFyIGY9U25bc107aWYoZj09PXZvaWQgMCl0aHJvdyBzPVZpKHMpLGY9UWUocyksSmUocyksbmV3IG10KGAke2N9IGhhcyB1bmtub3duIHR5cGUgJHtmfWApO3JldHVybiBmfSxoaT0ocyxjLGYpPT57dmFyIGI9W107cmV0dXJuIHM9cy50b1dpcmVUeXBlKGIsZiksYi5sZW5ndGgmJihhKClbYz4+PjI+Pj4wXT1WZShiKSksc307ZnVuY3Rpb24gWGMocyxjLGYpe3JldHVybiBjPj4+PTAsZj4+Pj0wLHM9TWUocz4+PjApLGM9YXIoYyxcImVtdmFsOjphc1wiKSxoaShjLGYscyl9ZnVuY3Rpb24gSmMocyxjKXtyZXR1cm4gYz4+Pj0wLHM9TWUocz4+PjApLChjPWFyKGMsXCJlbXZhbDo6YXNcIikpLnRvV2lyZVR5cGUobnVsbCxzKX12YXIgc3I9cz0+e3RyeXtzKCl9Y2F0Y2goYyl7Y3QoYyl9fSxodD0wLFhlPW51bGwsZ2k9MCx1cj1bXSxiaT17fSx5aT17fSxlcD0wLEVuPW51bGwsdHA9W107ZnVuY3Rpb24gX2kocyl7cmV0dXJuIGZ1bmN0aW9uKGMpe2lmKCF3ZSl7aWYoaHQ9PT0wKXt2YXIgZj0hMSxiPSExO2MoKHc9MCk9PntpZighd2UmJihnaT13LGY9ITAsYikpe2h0PTIsc3IoKCk9PllpKFhlKSksdHlwZW9mIEJyb3dzZXI8XCJ1XCImJkJyb3dzZXIuTGIuU2ImJkJyb3dzZXIuTGIucmVzdW1lKCksdz0hMTt0cnl7dmFyIEk9ZnVuY3Rpb24oKXt2YXIgTD1pKClbWGUrOD4+PjI+Pj4wXTtyZXR1cm4gTD1aW3lpW0xdXSwtLXd0LEwoKX0oKX1jYXRjaChMKXtJPUwsdz0hMH12YXIgTz0hMTtpZighWGUpe3ZhciBCPUVuO0ImJihFbj1udWxsLCh3P0IucmVqZWN0OkIucmVzb2x2ZSkoSSksTz0hMCl9aWYodyYmIU8pdGhyb3cgSX19KSxiPSEwLGZ8fChodD0xLFhlPWZ1bmN0aW9uKCl7dmFyIHc9ZnIoNjU1NDgpLEk9dysxMjthKClbdz4+PjI+Pj4wXT1JLGEoKVt3KzQ+Pj4yPj4+MF09SSs2NTUzNixJPXVyWzBdO3ZhciBPPWJpW0ldO3JldHVybiBPPT09dm9pZCAwJiYoTz1lcCsrLGJpW0ldPU8seWlbT109SSksST1PLGkoKVt3Kzg+Pj4yPj4+MF09SSx3fSgpLHR5cGVvZiBCcm93c2VyPFwidVwiJiZCcm93c2VyLkxiLlNiJiZCcm93c2VyLkxiLnBhdXNlKCksc3IoKCk9PktpKFhlKSkpfWVsc2UgaHQ9PT0yPyhodD0wLHNyKFppKSxKZShYZSksWGU9bnVsbCx0cC5mb3JFYWNoKGZpKSk6Y3QoYGludmFsaWQgc3RhdGU6ICR7aHR9YCk7cmV0dXJuIGdpfX0oYz0+e3MoKS50aGVuKGMpfSl9ZnVuY3Rpb24gcnAocyl7cmV0dXJuIHM+Pj49MCxfaSgoKT0+KHM9TWUocykpLnRoZW4oVmUpKX12YXIgZHI9W107ZnVuY3Rpb24gbnAocyxjLGYsYil7cmV0dXJuIGY+Pj49MCxiPj4+PTAsKHM9ZHJbcz4+PjBdKShudWxsLGM9TWUoYz4+PjApLGYsYil9dmFyIG9wPXt9LGxyPXM9Pnt2YXIgYz1vcFtzXTtyZXR1cm4gYz09PXZvaWQgMD9RZShzKTpjfTtmdW5jdGlvbiBpcChzLGMsZixiLHcpe3JldHVybiBmPj4+PTAsYj4+Pj0wLHc+Pj49MCwocz1kcltzPj4+MF0pKGM9TWUoYz4+PjApLGNbZj1scihmKV0sYix3KX12YXIgd2k9KCk9PnR5cGVvZiBnbG9iYWxUaGlzPT1cIm9iamVjdFwiP2dsb2JhbFRoaXM6RnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO2Z1bmN0aW9uIGFwKHMpe3JldHVybihzPj4+PTApPT0wP1ZlKHdpKCkpOihzPWxyKHMpLFZlKHdpKClbc10pKX12YXIgc3A9cz0+e3ZhciBjPWRyLmxlbmd0aDtyZXR1cm4gZHIucHVzaChzKSxjfSx1cD0ocyxjKT0+e2Zvcih2YXIgZj1BcnJheShzKSxiPTA7YjxzOysrYilmW2JdPWFyKGEoKVtjKzQqYj4+PjI+Pj4wXSxcInBhcmFtZXRlciBcIitiKTtyZXR1cm4gZn0sdmk9KHMsYyk9Pk9iamVjdC5kZWZpbmVQcm9wZXJ0eShjLFwibmFtZVwiLHt2YWx1ZTpzfSk7ZnVuY3Rpb24gZHAocyxjLGYpe3ZhciBiPShjPXVwKHMsYz4+PjApKS5zaGlmdCgpO3MtLTt2YXIgdz1gcmV0dXJuIGZ1bmN0aW9uIChvYmosIGZ1bmMsIGRlc3RydWN0b3JzUmVmLCBhcmdzKSB7XG5gLEk9MCxPPVtdO2Y9PT0wJiZPLnB1c2goXCJvYmpcIik7Zm9yKHZhciBCPVtcInJldFR5cGVcIl0sTD1bYl0sSD0wO0g8czsrK0gpTy5wdXNoKFwiYXJnXCIrSCksQi5wdXNoKFwiYXJnVHlwZVwiK0gpLEwucHVzaChjW0hdKSx3Kz1gICB2YXIgYXJnJHtIfSA9IGFyZ1R5cGUke0h9LnJlYWRWYWx1ZUZyb21Qb2ludGVyKGFyZ3Mke0k/XCIrXCIrSTpcIlwifSk7XG5gLEkrPWNbSF0uYXJnUGFja0FkdmFuY2U7cmV0dXJuIHcrPWAgIHZhciBydiA9ICR7Zj09PTE/XCJuZXcgZnVuY1wiOlwiZnVuYy5jYWxsXCJ9KCR7Ty5qb2luKFwiLCBcIil9KTtcbmAsYi5VYnx8KEIucHVzaChcImVtdmFsX3JldHVyblZhbHVlXCIpLEwucHVzaChoaSksdys9YCAgcmV0dXJuIGVtdmFsX3JldHVyblZhbHVlKHJldFR5cGUsIGRlc3RydWN0b3JzUmVmLCBydik7XG5gKSxCLnB1c2godytgfTtcbmApLHM9ZnVuY3Rpb24oWCl7dmFyIGNlPUZ1bmN0aW9uO2lmKCEoY2UgaW5zdGFuY2VvZiBGdW5jdGlvbikpdGhyb3cgbmV3IFR5cGVFcnJvcihgbmV3XyBjYWxsZWQgd2l0aCBjb25zdHJ1Y3RvciB0eXBlICR7dHlwZW9mIGNlfSB3aGljaCBpcyBub3QgYSBmdW5jdGlvbmApO3ZhciBnZT12aShjZS5uYW1lfHxcInVua25vd25GdW5jdGlvbk5hbWVcIixmdW5jdGlvbigpe30pO3JldHVybiBnZS5wcm90b3R5cGU9Y2UucHJvdG90eXBlLGdlPW5ldyBnZSwoWD1jZS5hcHBseShnZSxYKSlpbnN0YW5jZW9mIE9iamVjdD9YOmdlfShCKSguLi5MKSxmPWBtZXRob2RDYWxsZXI8KCR7Yy5tYXAoWD0+WC5uYW1lKS5qb2luKFwiLCBcIil9KSA9PiAke2IubmFtZX0+YCxzcCh2aShmLHMpKX1mdW5jdGlvbiBscChzKXtyZXR1cm4gcz1scihzPj4+MCksVmUodVtzXSl9ZnVuY3Rpb24gY3AocyxjKXtyZXR1cm4gYz4+Pj0wLHM9TWUocz4+PjApLGM9TWUoYyksVmUoc1tjXSl9ZnVuY3Rpb24gcHAocyl7OTwocz4+Pj0wKSYmKHV0W3MrMV0rPTEpfWZ1bmN0aW9uIG1wKCl7cmV0dXJuIFZlKFtdKX1mdW5jdGlvbiBmcChzKXtzPU1lKHM+Pj4wKTtmb3IodmFyIGM9QXJyYXkocy5sZW5ndGgpLGY9MDtmPHMubGVuZ3RoO2YrKyljW2ZdPXNbZl07cmV0dXJuIFZlKGMpfWZ1bmN0aW9uIGhwKHMpe3JldHVybiBWZShscihzPj4+MCkpfWZ1bmN0aW9uIGdwKCl7cmV0dXJuIFZlKHt9KX1mdW5jdGlvbiBicChzKXtmb3IodmFyIGM9TWUocz4+Pj0wKTtjLmxlbmd0aDspe3ZhciBmPWMucG9wKCk7Yy5wb3AoKShmKX1JbihzKX1mdW5jdGlvbiB5cChzLGMsZil7Yz4+Pj0wLGY+Pj49MCxzPU1lKHM+Pj4wKSxjPU1lKGMpLGY9TWUoZiksc1tjXT1mfWZ1bmN0aW9uIF9wKHMsYyl7cmV0dXJuIGM+Pj49MCxzPShzPWFyKHM+Pj4wLFwiX2VtdmFsX3Rha2VfdmFsdWVcIikpLnJlYWRWYWx1ZUZyb21Qb2ludGVyKGMpLFZlKHMpfWZ1bmN0aW9uIHdwKHMsYyl7cz0tOTAwNzE5OTI1NDc0MDk5Mj5zfHw5MDA3MTk5MjU0NzQwOTkyPHM/TmFOOk51bWJlcihzKSxjPj4+PTAscz1uZXcgRGF0ZSgxZTMqcyksaSgpW2M+Pj4yPj4+MF09cy5nZXRVVENTZWNvbmRzKCksaSgpW2MrND4+PjI+Pj4wXT1zLmdldFVUQ01pbnV0ZXMoKSxpKClbYys4Pj4+Mj4+PjBdPXMuZ2V0VVRDSG91cnMoKSxpKClbYysxMj4+PjI+Pj4wXT1zLmdldFVUQ0RhdGUoKSxpKClbYysxNj4+PjI+Pj4wXT1zLmdldFVUQ01vbnRoKCksaSgpW2MrMjA+Pj4yPj4+MF09cy5nZXRVVENGdWxsWWVhcigpLTE5MDAsaSgpW2MrMjQ+Pj4yPj4+MF09cy5nZXRVVENEYXkoKSxzPShzLmdldFRpbWUoKS1EYXRlLlVUQyhzLmdldFVUQ0Z1bGxZZWFyKCksMCwxLDAsMCwwLDApKS84NjRlNXwwLGkoKVtjKzI4Pj4+Mj4+PjBdPXN9dmFyIER0PXM9PnMlND09MCYmKHMlMTAwIT0wfHxzJTQwMD09MCksJGk9WzAsMzEsNjAsOTEsMTIxLDE1MiwxODIsMjEzLDI0NCwyNzQsMzA1LDMzNV0seGk9WzAsMzEsNTksOTAsMTIwLDE1MSwxODEsMjEyLDI0MywyNzMsMzA0LDMzNF07ZnVuY3Rpb24gdnAocyxjKXtzPS05MDA3MTk5MjU0NzQwOTkyPnN8fDkwMDcxOTkyNTQ3NDA5OTI8cz9OYU46TnVtYmVyKHMpLGM+Pj49MCxzPW5ldyBEYXRlKDFlMypzKSxpKClbYz4+PjI+Pj4wXT1zLmdldFNlY29uZHMoKSxpKClbYys0Pj4+Mj4+PjBdPXMuZ2V0TWludXRlcygpLGkoKVtjKzg+Pj4yPj4+MF09cy5nZXRIb3VycygpLGkoKVtjKzEyPj4+Mj4+PjBdPXMuZ2V0RGF0ZSgpLGkoKVtjKzE2Pj4+Mj4+PjBdPXMuZ2V0TW9udGgoKSxpKClbYysyMD4+PjI+Pj4wXT1zLmdldEZ1bGxZZWFyKCktMTkwMCxpKClbYysyND4+PjI+Pj4wXT1zLmdldERheSgpO3ZhciBmPShEdChzLmdldEZ1bGxZZWFyKCkpPyRpOnhpKVtzLmdldE1vbnRoKCldK3MuZ2V0RGF0ZSgpLTF8MDtpKClbYysyOD4+PjI+Pj4wXT1mLGkoKVtjKzM2Pj4+Mj4+PjBdPS02MCpzLmdldFRpbWV6b25lT2Zmc2V0KCksZj1uZXcgRGF0ZShzLmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpO3ZhciBiPW5ldyBEYXRlKHMuZ2V0RnVsbFllYXIoKSwwLDEpLmdldFRpbWV6b25lT2Zmc2V0KCk7cz0wfChmIT1iJiZzLmdldFRpbWV6b25lT2Zmc2V0KCk9PU1hdGgubWluKGIsZikpLGkoKVtjKzMyPj4+Mj4+PjBdPXN9ZnVuY3Rpb24gJHAocyl7cz4+Pj0wO3ZhciBjPW5ldyBEYXRlKGkoKVtzKzIwPj4+Mj4+PjBdKzE5MDAsaSgpW3MrMTY+Pj4yPj4+MF0saSgpW3MrMTI+Pj4yPj4+MF0saSgpW3MrOD4+PjI+Pj4wXSxpKClbcys0Pj4+Mj4+PjBdLGkoKVtzPj4+Mj4+PjBdLDApLGY9aSgpW3MrMzI+Pj4yPj4+MF0sYj1jLmdldFRpbWV6b25lT2Zmc2V0KCksdz1uZXcgRGF0ZShjLmdldEZ1bGxZZWFyKCksNiwxKS5nZXRUaW1lem9uZU9mZnNldCgpLEk9bmV3IERhdGUoYy5nZXRGdWxsWWVhcigpLDAsMSkuZ2V0VGltZXpvbmVPZmZzZXQoKSxPPU1hdGgubWluKEksdyk7cmV0dXJuIDA+Zj9pKClbcyszMj4+PjI+Pj4wXT0rKHchPUkmJk89PWIpOjA8ZiE9KE89PWIpJiYodz1NYXRoLm1heChJLHcpLGMuc2V0VGltZShjLmdldFRpbWUoKSs2ZTQqKCgwPGY/Tzp3KS1iKSkpLGkoKVtzKzI0Pj4+Mj4+PjBdPWMuZ2V0RGF5KCksZj0oRHQoYy5nZXRGdWxsWWVhcigpKT8kaTp4aSlbYy5nZXRNb250aCgpXStjLmdldERhdGUoKS0xfDAsaSgpW3MrMjg+Pj4yPj4+MF09ZixpKClbcz4+PjI+Pj4wXT1jLmdldFNlY29uZHMoKSxpKClbcys0Pj4+Mj4+PjBdPWMuZ2V0TWludXRlcygpLGkoKVtzKzg+Pj4yPj4+MF09Yy5nZXRIb3VycygpLGkoKVtzKzEyPj4+Mj4+PjBdPWMuZ2V0RGF0ZSgpLGkoKVtzKzE2Pj4+Mj4+PjBdPWMuZ2V0TW9udGgoKSxpKClbcysyMD4+PjI+Pj4wXT1jLmdldFllYXIoKSxzPWMuZ2V0VGltZSgpLEJpZ0ludChpc05hTihzKT8tMTpzLzFlMyl9ZnVuY3Rpb24gU2kocyxjLGYsYix3LEksTyl7cmV0dXJuIGc/eGUoMTYsMSxzLGMsZixiLHcsSSxPKTotNTJ9ZnVuY3Rpb24gVGkocyxjLGYsYix3LEkpe2lmKGcpcmV0dXJuIHhlKDE3LDEscyxjLGYsYix3LEkpfWZ1bmN0aW9uIHhwKHMsYyxmLGIpe3M+Pj49MCxjPj4+PTAsZj4+Pj0wLGI+Pj49MDt2YXIgdz1uZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCksST1uZXcgRGF0ZSh3LDAsMSksTz1uZXcgRGF0ZSh3LDYsMSk7dz1JLmdldFRpbWV6b25lT2Zmc2V0KCk7dmFyIEI9Ty5nZXRUaW1lem9uZU9mZnNldCgpLEw9TWF0aC5tYXgodyxCKTthKClbcz4+PjI+Pj4wXT02MCpMLGkoKVtjPj4+Mj4+PjBdPSsodyE9QiksST0ocz1IPT5ILnRvTG9jYWxlVGltZVN0cmluZyh2b2lkIDAse2hvdXIxMjohMSx0aW1lWm9uZU5hbWU6XCJzaG9ydFwifSkuc3BsaXQoXCIgXCIpWzFdKShJKSxPPXMoTyksQjx3PyhPdChJLGYsMTcpLE90KE8sYiwxNykpOihPdChJLGIsMTcpLE90KE8sZiwxNykpfXZhciBQbj1bXSxJaT0ocyxjKT0+e1BuLmxlbmd0aD0wO2Zvcih2YXIgZjtmPXIoKVtzKys+Pj4wXTspe3ZhciBiPWYhPTEwNTtjKz0oYiY9ZiE9MTEyKSYmYyU4PzQ6MCxQbi5wdXNoKGY9PTExMj9hKClbYz4+PjI+Pj4wXTpmPT0xMDY/cVtjPj4+M106Zj09MTA1P2koKVtjPj4+Mj4+PjBdOmwoKVtjPj4+Mz4+PjBdKSxjKz1iPzg6NH1yZXR1cm4gUG59O2Z1bmN0aW9uIFNwKHMsYyxmKXtyZXR1cm4gcz4+Pj0wLGM9SWkoYz4+PjAsZj4+PjApLGJuW3NdKC4uLmMpfWZ1bmN0aW9uIFRwKHMsYyxmKXtyZXR1cm4gcz4+Pj0wLGM9SWkoYz4+PjAsZj4+PjApLGJuW3NdKC4uLmMpfXZhciBJcD0oKT0+e30sQ3A9KCk9PkRhdGUubm93KCk7ZnVuY3Rpb24gQXAocyxjKXtyZXR1cm4gaihDZShzPj4+MCxjPj4+MCkpfXZhciBDaSxrcD0oKT0+e3Rocm93IHd0Kz0xLFwidW53aW5kXCJ9O2Z1bmN0aW9uIEVwKCl7cmV0dXJuIDQyOTQ5MDE3NjB9Q2k9KCk9PnBlcmZvcm1hbmNlLnRpbWVPcmlnaW4rcGVyZm9ybWFuY2Uubm93KCk7dmFyIFBwPSgpPT5uYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeTtmdW5jdGlvbiB6cCgpe3JldHVybiBjdChcIkNhbm5vdCB1c2UgZW1zY3JpcHRlbl9wY19nZXRfZnVuY3Rpb24gd2l0aG91dCAtc1VTRV9PRkZTRVRfQ09OVkVSVEVSXCIpLDB9ZnVuY3Rpb24gT3Aocyl7cz4+Pj0wO3ZhciBjPXIoKS5sZW5ndGg7aWYoczw9Y3x8NDI5NDkwMTc2MDxzKXJldHVybiExO2Zvcih2YXIgZj0xOzQ+PWY7Zio9Mil7dmFyIGI9YyooMSsuMi9mKTtiPU1hdGgubWluKGIscysxMDA2NjMyOTYpO3ZhciB3PU1hdGg7Yj1NYXRoLm1heChzLGIpO2U6e3c9KHcubWluLmNhbGwodyw0Mjk0OTAxNzYwLGIrKDY1NTM2LWIlNjU1MzYpJTY1NTM2KS1zZS5idWZmZXIuYnl0ZUxlbmd0aCs2NTUzNSkvNjU1MzY7dHJ5e3NlLmdyb3codykseWUoKTt2YXIgST0xO2JyZWFrIGV9Y2F0Y2h7fUk9dm9pZCAwfWlmKEkpcmV0dXJuITB9cmV0dXJuITF9dmFyIGNyPSgpPT4oY3QoXCJDYW5ub3QgdXNlIGNvbnZlcnRGcmFtZVRvUEMgKG5lZWRlZCBieSBfX2J1aWx0aW5fcmV0dXJuX2FkZHJlc3MpIHdpdGhvdXQgLXNVU0VfT0ZGU0VUX0NPTlZFUlRFUlwiKSwwKSxCdD17fSxBaT1zPT57cy5mb3JFYWNoKGM9Pnt2YXIgZj1jcigpO2YmJihCdFtmXT1jKX0pfTtmdW5jdGlvbiBEcCgpe3ZhciBzPUVycm9yKCkuc3RhY2sudG9TdHJpbmcoKS5zcGxpdChgXG5gKTtyZXR1cm4gc1swXT09XCJFcnJvclwiJiZzLnNoaWZ0KCksQWkocyksQnQuUWI9Y3IoKSxCdC5mYz1zLEJ0LlFifWZ1bmN0aW9uIEJwKHMsYyxmKXtpZihzPj4+PTAsYz4+Pj0wLEJ0LlFiPT1zKXZhciBiPUJ0LmZjO2Vsc2UoYj1FcnJvcigpLnN0YWNrLnRvU3RyaW5nKCkuc3BsaXQoYFxuYCkpWzBdPT1cIkVycm9yXCImJmIuc2hpZnQoKSxBaShiKTtmb3IodmFyIHc9MztiW3ddJiZjcigpIT1zOykrK3c7Zm9yKHM9MDtzPGYmJmJbcyt3XTsrK3MpaSgpW2MrNCpzPj4+Mj4+PjBdPWNyKCk7cmV0dXJuIHN9dmFyIHpuLE9uPXt9LGtpPSgpPT57aWYoIXpuKXt2YXIgcyxjPXtVU0VSOlwid2ViX3VzZXJcIixMT0dOQU1FOlwid2ViX3VzZXJcIixQQVRIOlwiL1wiLFBXRDpcIi9cIixIT01FOlwiL2hvbWUvd2ViX3VzZXJcIixMQU5HOih0eXBlb2YgbmF2aWdhdG9yPT1cIm9iamVjdFwiJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdfHxcIkNcIikucmVwbGFjZShcIi1cIixcIl9cIikrXCIuVVRGLThcIixfOkF8fFwiLi90aGlzLnByb2dyYW1cIn07Zm9yKHMgaW4gT24pT25bc109PT12b2lkIDA/ZGVsZXRlIGNbc106Y1tzXT1PbltzXTt2YXIgZj1bXTtmb3IocyBpbiBjKWYucHVzaChgJHtzfT0ke2Nbc119YCk7em49Zn1yZXR1cm4gem59O2Z1bmN0aW9uIEVpKHMsYyl7aWYoZylyZXR1cm4geGUoMTgsMSxzLGMpO3M+Pj49MCxjPj4+PTA7dmFyIGY9MDtyZXR1cm4ga2koKS5mb3JFYWNoKChiLHcpPT57dmFyIEk9YytmO2Zvcih3PWEoKVtzKzQqdz4+PjI+Pj4wXT1JLEk9MDtJPGIubGVuZ3RoOysrSSl0KClbdysrPj4+MF09Yi5jaGFyQ29kZUF0KEkpO3QoKVt3Pj4+MF09MCxmKz1iLmxlbmd0aCsxfSksMH1mdW5jdGlvbiBQaShzLGMpe2lmKGcpcmV0dXJuIHhlKDE5LDEscyxjKTtzPj4+PTAsYz4+Pj0wO3ZhciBmPWtpKCk7YSgpW3M+Pj4yPj4+MF09Zi5sZW5ndGg7dmFyIGI9MDtyZXR1cm4gZi5mb3JFYWNoKHc9PmIrPXcubGVuZ3RoKzEpLGEoKVtjPj4+Mj4+PjBdPWIsMH1mdW5jdGlvbiB6aShzKXtyZXR1cm4gZz94ZSgyMCwxLHMpOjUyfWZ1bmN0aW9uIE9pKHMsYyxmLGIpe3JldHVybiBnP3hlKDIxLDEscyxjLGYsYik6NTJ9ZnVuY3Rpb24gRGkocyxjLGYsYil7cmV0dXJuIGc/eGUoMjIsMSxzLGMsZixiKTo3MH12YXIgTXA9W251bGwsW10sW11dO2Z1bmN0aW9uIEJpKHMsYyxmLGIpe2lmKGcpcmV0dXJuIHhlKDIzLDEscyxjLGYsYik7Yz4+Pj0wLGY+Pj49MCxiPj4+PTA7Zm9yKHZhciB3PTAsST0wO0k8ZjtJKyspe3ZhciBPPWEoKVtjPj4+Mj4+PjBdLEI9YSgpW2MrND4+PjI+Pj4wXTtjKz04O2Zvcih2YXIgTD0wO0w8QjtMKyspe3ZhciBIPXIoKVtPK0w+Pj4wXSxYPU1wW3NdO0g9PT0wfHxIPT09MTA/KChzPT09MT9LOmopKFpvKFgsMCkpLFgubGVuZ3RoPTApOlgucHVzaChIKX13Kz1CfXJldHVybiBhKClbYj4+PjI+Pj4wXT13LDB9dmFyIE1pPVszMSwyOSwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV0sUmk9WzMxLDI4LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXSxScD0ocyxjKT0+e3QoKS5zZXQocyxjPj4+MCl9O2Z1bmN0aW9uIFVpKHMsYyxmLGIpe2Z1bmN0aW9uIHcoeixkZSxUZSl7Zm9yKHo9dHlwZW9mIHo9PVwibnVtYmVyXCI/ei50b1N0cmluZygpOnp8fFwiXCI7ei5sZW5ndGg8ZGU7KXo9VGVbMF0rejtyZXR1cm4gen1mdW5jdGlvbiBJKHosZGUpe3JldHVybiB3KHosZGUsXCIwXCIpfWZ1bmN0aW9uIE8oeixkZSl7ZnVuY3Rpb24gVGUoWGkpe3JldHVybiAwPlhpPy0xOjA8WGk/MTowfXZhciAkdDtyZXR1cm4oJHQ9VGUoei5nZXRGdWxsWWVhcigpLWRlLmdldEZ1bGxZZWFyKCkpKT09PTAmJigkdD1UZSh6LmdldE1vbnRoKCktZGUuZ2V0TW9udGgoKSkpPT09MCYmKCR0PVRlKHouZ2V0RGF0ZSgpLWRlLmdldERhdGUoKSkpLCR0fWZ1bmN0aW9uIEIoeil7c3dpdGNoKHouZ2V0RGF5KCkpe2Nhc2UgMDpyZXR1cm4gbmV3IERhdGUoei5nZXRGdWxsWWVhcigpLTEsMTEsMjkpO2Nhc2UgMTpyZXR1cm4gejtjYXNlIDI6cmV0dXJuIG5ldyBEYXRlKHouZ2V0RnVsbFllYXIoKSwwLDMpO2Nhc2UgMzpyZXR1cm4gbmV3IERhdGUoei5nZXRGdWxsWWVhcigpLDAsMik7Y2FzZSA0OnJldHVybiBuZXcgRGF0ZSh6LmdldEZ1bGxZZWFyKCksMCwxKTtjYXNlIDU6cmV0dXJuIG5ldyBEYXRlKHouZ2V0RnVsbFllYXIoKS0xLDExLDMxKTtjYXNlIDY6cmV0dXJuIG5ldyBEYXRlKHouZ2V0RnVsbFllYXIoKS0xLDExLDMwKX19ZnVuY3Rpb24gTCh6KXt2YXIgZGU9ei5DYjtmb3Ioej1uZXcgRGF0ZShuZXcgRGF0ZSh6LkRiKzE5MDAsMCwxKS5nZXRUaW1lKCkpOzA8ZGU7KXt2YXIgVGU9ei5nZXRNb250aCgpLCR0PShEdCh6LmdldEZ1bGxZZWFyKCkpP01pOlJpKVtUZV07aWYoIShkZT4kdC16LmdldERhdGUoKSkpe3ouc2V0RGF0ZSh6LmdldERhdGUoKStkZSk7YnJlYWt9ZGUtPSR0LXouZ2V0RGF0ZSgpKzEsei5zZXREYXRlKDEpLDExPlRlP3ouc2V0TW9udGgoVGUrMSk6KHouc2V0TW9udGgoMCksei5zZXRGdWxsWWVhcih6LmdldEZ1bGxZZWFyKCkrMSkpfXJldHVybiBUZT1uZXcgRGF0ZSh6LmdldEZ1bGxZZWFyKCkrMSwwLDQpLGRlPUIobmV3IERhdGUoei5nZXRGdWxsWWVhcigpLDAsNCkpLFRlPUIoVGUpLDA+PU8oZGUseik/MD49TyhUZSx6KT96LmdldEZ1bGxZZWFyKCkrMTp6LmdldEZ1bGxZZWFyKCk6ei5nZXRGdWxsWWVhcigpLTF9cz4+Pj0wLGM+Pj49MCxmPj4+PTAsYj4+Pj0wO3ZhciBIPWEoKVtiKzQwPj4+Mj4+PjBdO2Zvcih2YXIgWCBpbiBiPXtsYzppKClbYj4+PjI+Pj4wXSxrYzppKClbYis0Pj4+Mj4+PjBdLEliOmkoKVtiKzg+Pj4yPj4+MF0sTWI6aSgpW2IrMTI+Pj4yPj4+MF0sSmI6aSgpW2IrMTY+Pj4yPj4+MF0sRGI6aSgpW2IrMjA+Pj4yPj4+MF0sdmI6aSgpW2IrMjQ+Pj4yPj4+MF0sQ2I6aSgpW2IrMjg+Pj4yPj4+MF0sc2M6aSgpW2IrMzI+Pj4yPj4+MF0samM6aSgpW2IrMzY+Pj4yPj4+MF0sbWM6SD9DZShIKTpcIlwifSxmPUNlKGYpLEg9e1wiJWNcIjpcIiVhICViICVkICVIOiVNOiVTICVZXCIsXCIlRFwiOlwiJW0vJWQvJXlcIixcIiVGXCI6XCIlWS0lbS0lZFwiLFwiJWhcIjpcIiViXCIsXCIlclwiOlwiJUk6JU06JVMgJXBcIixcIiVSXCI6XCIlSDolTVwiLFwiJVRcIjpcIiVIOiVNOiVTXCIsXCIleFwiOlwiJW0vJWQvJXlcIixcIiVYXCI6XCIlSDolTTolU1wiLFwiJUVjXCI6XCIlY1wiLFwiJUVDXCI6XCIlQ1wiLFwiJUV4XCI6XCIlbS8lZC8leVwiLFwiJUVYXCI6XCIlSDolTTolU1wiLFwiJUV5XCI6XCIleVwiLFwiJUVZXCI6XCIlWVwiLFwiJU9kXCI6XCIlZFwiLFwiJU9lXCI6XCIlZVwiLFwiJU9IXCI6XCIlSFwiLFwiJU9JXCI6XCIlSVwiLFwiJU9tXCI6XCIlbVwiLFwiJU9NXCI6XCIlTVwiLFwiJU9TXCI6XCIlU1wiLFwiJU91XCI6XCIldVwiLFwiJU9VXCI6XCIlVVwiLFwiJU9WXCI6XCIlVlwiLFwiJU93XCI6XCIld1wiLFwiJU9XXCI6XCIlV1wiLFwiJU95XCI6XCIleVwifSlmPWYucmVwbGFjZShuZXcgUmVnRXhwKFgsXCJnXCIpLEhbWF0pO3ZhciBjZT1cIlN1bmRheSBNb25kYXkgVHVlc2RheSBXZWRuZXNkYXkgVGh1cnNkYXkgRnJpZGF5IFNhdHVyZGF5XCIuc3BsaXQoXCIgXCIpLGdlPVwiSmFudWFyeSBGZWJydWFyeSBNYXJjaCBBcHJpbCBNYXkgSnVuZSBKdWx5IEF1Z3VzdCBTZXB0ZW1iZXIgT2N0b2JlciBOb3ZlbWJlciBEZWNlbWJlclwiLnNwbGl0KFwiIFwiKTtmb3IoWCBpbiBIPXtcIiVhXCI6ej0+Y2Vbei52Yl0uc3Vic3RyaW5nKDAsMyksXCIlQVwiOno9PmNlW3oudmJdLFwiJWJcIjp6PT5nZVt6LkpiXS5zdWJzdHJpbmcoMCwzKSxcIiVCXCI6ej0+Z2Vbei5KYl0sXCIlQ1wiOno9PkkoKHouRGIrMTkwMCkvMTAwfDAsMiksXCIlZFwiOno9Pkkoei5NYiwyKSxcIiVlXCI6ej0+dyh6Lk1iLDIsXCIgXCIpLFwiJWdcIjp6PT5MKHopLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpLFwiJUdcIjpMLFwiJUhcIjp6PT5JKHouSWIsMiksXCIlSVwiOno9Pigoej16LkliKT09MD96PTEyOjEyPHomJih6LT0xMiksSSh6LDIpKSxcIiVqXCI6ej0+e2Zvcih2YXIgZGU9MCxUZT0wO1RlPD16LkpiLTE7ZGUrPShEdCh6LkRiKzE5MDApP01pOlJpKVtUZSsrXSk7cmV0dXJuIEkoei5NYitkZSwzKX0sXCIlbVwiOno9Pkkoei5KYisxLDIpLFwiJU1cIjp6PT5JKHoua2MsMiksXCIlblwiOigpPT5gXG5gLFwiJXBcIjp6PT4wPD16LkliJiYxMj56LkliP1wiQU1cIjpcIlBNXCIsXCIlU1wiOno9Pkkoei5sYywyKSxcIiV0XCI6KCk9PlwiXHRcIixcIiV1XCI6ej0+ei52Ynx8NyxcIiVVXCI6ej0+SShNYXRoLmZsb29yKCh6LkNiKzctei52YikvNyksMiksXCIlVlwiOno9Pnt2YXIgZGU9TWF0aC5mbG9vcigoei5DYis3LSh6LnZiKzYpJTcpLzcpO2lmKDI+PSh6LnZiKzM3MS16LkNiLTIpJTcmJmRlKyssZGUpZGU9PTUzJiYoKFRlPSh6LnZiKzM3MS16LkNiKSU3KT09NHx8VGU9PTMmJkR0KHouRGIpfHwoZGU9MSkpO2Vsc2V7ZGU9NTI7dmFyIFRlPSh6LnZiKzctei5DYi0xKSU3OyhUZT09NHx8VGU9PTUmJkR0KHouRGIlNDAwLTEpKSYmZGUrK31yZXR1cm4gSShkZSwyKX0sXCIld1wiOno9PnoudmIsXCIlV1wiOno9PkkoTWF0aC5mbG9vcigoei5DYis3LSh6LnZiKzYpJTcpLzcpLDIpLFwiJXlcIjp6PT4oei5EYisxOTAwKS50b1N0cmluZygpLnN1YnN0cmluZygyKSxcIiVZXCI6ej0+ei5EYisxOTAwLFwiJXpcIjp6PT57dmFyIGRlPTA8PSh6PXouamMpO3JldHVybiB6PU1hdGguYWJzKHopLzYwLChkZT9cIitcIjpcIi1cIikrKFwiMDAwMFwiKyh6LzYwKjEwMCt6JTYwKSkuc2xpY2UoLTQpfSxcIiVaXCI6ej0+ei5tYyxcIiUlXCI6KCk9PlwiJVwifSxmPWYucmVwbGFjZSgvJSUvZyxcIlxcMFxcMFwiKSxIKWYuaW5jbHVkZXMoWCkmJihmPWYucmVwbGFjZShuZXcgUmVnRXhwKFgsXCJnXCIpLEhbWF0oYikpKTtyZXR1cm4gWD1mdW5jdGlvbih6KXt2YXIgZGU9QXJyYXkoJG4oeikrMSk7cmV0dXJuIEpvKHosZGUsMCxkZS5sZW5ndGgpLGRlfShmPWYucmVwbGFjZSgvXFwwXFwwL2csXCIlXCIpKSxYLmxlbmd0aD5jPzA6KFJwKFgscyksWC5sZW5ndGgtMSl9ZnVuY3Rpb24gVXAocyxjLGYsYil7cmV0dXJuIFVpKHM+Pj4wLGM+Pj4wLGY+Pj4wLGI+Pj4wKX1nfHxmdW5jdGlvbigpe2Zvcih2YXIgcz11Lm51bVRocmVhZHMtMTtzLS07KXFvKCk7WWUudW5zaGlmdCgoKT0+e0d0KyssZnVuY3Rpb24oYyl7Zz9jKCk6UHJvbWlzZS5hbGwocHQubWFwKEZvKSkudGhlbihjKX0oKCk9PkRvKCkpfSl9KCk7Zm9yKHZhciBOaT1BcnJheSgyNTYpLHByPTA7MjU2PnByOysrcHIpTmlbcHJdPVN0cmluZy5mcm9tQ2hhckNvZGUocHIpO2NpPU5pLG10PXUuQmluZGluZ0Vycm9yPWNsYXNzIGV4dGVuZHMgRXJyb3J7Y29uc3RydWN0b3Iocyl7c3VwZXIocyksdGhpcy5uYW1lPVwiQmluZGluZ0Vycm9yXCJ9fSx1LkludGVybmFsRXJyb3I9Y2xhc3MgZXh0ZW5kcyBFcnJvcntjb25zdHJ1Y3RvcihzKXtzdXBlcihzKSx0aGlzLm5hbWU9XCJJbnRlcm5hbEVycm9yXCJ9fSx1dC5wdXNoKDAsMSx2b2lkIDAsMSxudWxsLDEsITAsMSwhMSwxKSx1LmNvdW50X2VtdmFsX2hhbmRsZXM9KCk9PnV0Lmxlbmd0aC8yLTUtVG4ubGVuZ3RoO3ZhciBOcD1bd24sV28sS28sUW8sWG8sZWksdGkscmksbmksb2ksaWksYWksc2ksdWksZGksbGksU2ksVGksRWksUGksemksT2ksRGksQmldLFo9ZnVuY3Rpb24oKXtmdW5jdGlvbiBzKGYsYil7cmV0dXJuIFo9Zi5leHBvcnRzLFo9ZnVuY3Rpb24oKXt2YXIgdz1aLEk9e307Zm9yKGxldFtPLEJdb2YgT2JqZWN0LmVudHJpZXModykpSVtPXT10eXBlb2YgQj09XCJmdW5jdGlvblwiPyguLi5MKT0+e3VyLnB1c2goTyk7dHJ5e3JldHVybiBCKC4uLkwpfWZpbmFsbHl7d2V8fCh1ci5wb3AoKSxYZSYmaHQ9PT0xJiZ1ci5sZW5ndGg9PT0wJiYoaHQ9MCx3dCs9MSxzcihqaSksdHlwZW9mIEZpYmVyczxcInVcIiYmRmliZXJzLnRjKCkpKX19OkI7cmV0dXJuIEl9KCksWj1mdW5jdGlvbigpe3ZhciB3PVosST1CPT5MPT5CKEwpPj4+MCxPPUI9PigpPT5CKCk+Pj4wO3JldHVybih3PU9iamVjdC5hc3NpZ24oe30sdykpLkRhPUkody5EYSksdy5nYj1PKHcuZ2IpLHcuaWI9SSh3LmliKSx3LmVtc2NyaXB0ZW5fbWFpbl9ydW50aW1lX3RocmVhZF9pZD1PKHcuZW1zY3JpcHRlbl9tYWluX3J1bnRpbWVfdGhyZWFkX2lkKSx3LnRiPUkody50Yiksdy51Yj1PKHcudWIpLHd9KCksTG8ucHVzaChaLmpiKSxMdC51bnNoaWZ0KFouQ2EpLFk9YixEbygpLFp9dmFyIGM9Tm8oKTtpZihHdCsrLHUuaW5zdGFudGlhdGVXYXNtKXRyeXtyZXR1cm4gdS5pbnN0YW50aWF0ZVdhc20oYyxzKX1jYXRjaChmKXtqKGBNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiAke2Z9YCksbShmKX1yZXR1cm4gZ258fD11LmxvY2F0ZUZpbGU/Qm8oXCJvcnQtd2FzbS1zaW1kLXRocmVhZGVkLmpzZXAud2FzbVwiKT9cIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC53YXNtXCI6dS5sb2NhdGVGaWxlP3UubG9jYXRlRmlsZShcIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC53YXNtXCIsUCk6UCtcIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC53YXNtXCI6bmV3IFVSTChcIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC53YXNtXCIsaW1wb3J0Lm1ldGEudXJsKS5ocmVmLGZ1bmN0aW9uKGYsYil7dmFyIHc9Z247cmV0dXJuIER8fHR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyE9XCJmdW5jdGlvblwifHxCbyh3KXx8TW8odyl8fHR5cGVvZiBmZXRjaCE9XCJmdW5jdGlvblwiP1VvKHcsZixiKTpmZXRjaCh3LHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKEk9PldlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKEksZikudGhlbihiLGZ1bmN0aW9uKE8pe3JldHVybiBqKGB3YXNtIHN0cmVhbWluZyBjb21waWxlIGZhaWxlZDogJHtPfWApLGooXCJmYWxsaW5nIGJhY2sgdG8gQXJyYXlCdWZmZXIgaW5zdGFudGlhdGlvblwiKSxVbyh3LGYsYil9KSl9KGMsZnVuY3Rpb24oZil7cyhmLmluc3RhbmNlLGYubW9kdWxlKX0pLmNhdGNoKG0pLHt9fSgpLFZpPXM9PihWaT1aLkRhKShzKSxXaT0oKT0+KFdpPVouRWEpKCk7dS5fT3J0SW5pdD0ocyxjKT0+KHUuX09ydEluaXQ9Wi5GYSkocyxjKSx1Ll9PcnRHZXRMYXN0RXJyb3I9KHMsYyk9Pih1Ll9PcnRHZXRMYXN0RXJyb3I9Wi5HYSkocyxjKSx1Ll9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucz0ocyxjLGYsYix3LEksTyxCLEwsSCk9Pih1Ll9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucz1aLkhhKShzLGMsZixiLHcsSSxPLEIsTCxIKSx1Ll9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlcj0ocyxjKT0+KHUuX09ydEFwcGVuZEV4ZWN1dGlvblByb3ZpZGVyPVouSWEpKHMsYyksdS5fT3J0QWRkRnJlZURpbWVuc2lvbk92ZXJyaWRlPShzLGMsZik9Pih1Ll9PcnRBZGRGcmVlRGltZW5zaW9uT3ZlcnJpZGU9Wi5KYSkocyxjLGYpLHUuX09ydEFkZFNlc3Npb25Db25maWdFbnRyeT0ocyxjLGYpPT4odS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5PVouS2EpKHMsYyxmKSx1Ll9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnM9cz0+KHUuX09ydFJlbGVhc2VTZXNzaW9uT3B0aW9ucz1aLkxhKShzKSx1Ll9PcnRDcmVhdGVTZXNzaW9uPShzLGMsZik9Pih1Ll9PcnRDcmVhdGVTZXNzaW9uPVouTWEpKHMsYyxmKSx1Ll9PcnRSZWxlYXNlU2Vzc2lvbj1zPT4odS5fT3J0UmVsZWFzZVNlc3Npb249Wi5OYSkocyksdS5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudD0ocyxjLGYpPT4odS5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudD1aLk9hKShzLGMsZiksdS5fT3J0R2V0SW5wdXROYW1lPShzLGMpPT4odS5fT3J0R2V0SW5wdXROYW1lPVouUGEpKHMsYyksdS5fT3J0R2V0T3V0cHV0TmFtZT0ocyxjKT0+KHUuX09ydEdldE91dHB1dE5hbWU9Wi5RYSkocyxjKSx1Ll9PcnRGcmVlPXM9Pih1Ll9PcnRGcmVlPVouUmEpKHMpLHUuX09ydENyZWF0ZVRlbnNvcj0ocyxjLGYsYix3LEkpPT4odS5fT3J0Q3JlYXRlVGVuc29yPVouU2EpKHMsYyxmLGIsdyxJKSx1Ll9PcnRHZXRUZW5zb3JEYXRhPShzLGMsZixiLHcpPT4odS5fT3J0R2V0VGVuc29yRGF0YT1aLlRhKShzLGMsZixiLHcpLHUuX09ydFJlbGVhc2VUZW5zb3I9cz0+KHUuX09ydFJlbGVhc2VUZW5zb3I9Wi5VYSkocyksdS5fT3J0Q3JlYXRlUnVuT3B0aW9ucz0ocyxjLGYsYik9Pih1Ll9PcnRDcmVhdGVSdW5PcHRpb25zPVouVmEpKHMsYyxmLGIpLHUuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5PShzLGMsZik9Pih1Ll9PcnRBZGRSdW5Db25maWdFbnRyeT1aLldhKShzLGMsZiksdS5fT3J0UmVsZWFzZVJ1bk9wdGlvbnM9cz0+KHUuX09ydFJlbGVhc2VSdW5PcHRpb25zPVouWGEpKHMpLHUuX09ydENyZWF0ZUJpbmRpbmc9cz0+KHUuX09ydENyZWF0ZUJpbmRpbmc9Wi5ZYSkocyksdS5fT3J0QmluZElucHV0PShzLGMsZik9Pih1Ll9PcnRCaW5kSW5wdXQ9Wi5aYSkocyxjLGYpLHUuX09ydEJpbmRPdXRwdXQ9KHMsYyxmLGIpPT4odS5fT3J0QmluZE91dHB1dD1aLl9hKShzLGMsZixiKSx1Ll9PcnRDbGVhckJvdW5kT3V0cHV0cz1zPT4odS5fT3J0Q2xlYXJCb3VuZE91dHB1dHM9Wi4kYSkocyksdS5fT3J0UmVsZWFzZUJpbmRpbmc9cz0+KHUuX09ydFJlbGVhc2VCaW5kaW5nPVouYWIpKHMpLHUuX09ydFJ1bldpdGhCaW5kaW5nPShzLGMsZixiLHcpPT4odS5fT3J0UnVuV2l0aEJpbmRpbmc9Wi5iYikocyxjLGYsYix3KSx1Ll9PcnRSdW49KHMsYyxmLGIsdyxJLE8sQik9Pih1Ll9PcnRSdW49Wi5jYikocyxjLGYsYix3LEksTyxCKSx1Ll9PcnRFbmRQcm9maWxpbmc9cz0+KHUuX09ydEVuZFByb2ZpbGluZz1aLmRiKShzKSx1Ll9Kc2VwT3V0cHV0PShzLGMsZik9Pih1Ll9Kc2VwT3V0cHV0PVouZWIpKHMsYyxmKSx1Ll9Kc2VwR2V0Tm9kZU5hbWU9cz0+KHUuX0pzZXBHZXROb2RlTmFtZT1aLmZiKShzKTt2YXIgbXIsTXQ9KCk9PihNdD1aLmdiKSgpLEplPXUuX2ZyZWU9cz0+KEplPXUuX2ZyZWU9Wi5oYikocyksZnI9dS5fbWFsbG9jPXM9Pihmcj11Ll9tYWxsb2M9Wi5pYikocyksRG49KHMsYyxmLGIsdyxJKT0+KERuPVoubGIpKHMsYyxmLGIsdyxJKSxMaT0oKT0+KExpPVoubWIpKCksR2k9KHMsYyxmLGIsdyk9PihHaT1aLm5iKShzLGMsZixiLHcpLEJuPXM9PihCbj1aLm9iKShzKSxocj1zPT4oaHI9Wi5wYikocyksSGk9KCk9PihIaT1aLnFiKSgpLEZpPShzLGMpPT4oRmk9Wi5yYikocyxjKSxncj1zPT4oZ3I9Wi5zYikocyksTW49cz0+KE1uPVoudGIpKHMpLFJuPSgpPT4oUm49Wi51YikoKSxxaT11LmR5bkNhbGxfaWk9KHMsYyk9PihxaT11LmR5bkNhbGxfaWk9Wi53YikocyxjKSxLaT1zPT4oS2k9Wi54Yikocyksamk9KCk9PihqaT1aLnliKSgpLFlpPXM9PihZaT1aLnpiKShzKSxaaT0oKT0+KFppPVouQWIpKCk7ZnVuY3Rpb24gUWkoKXswPEd0fHwoZz8ocCh1KSxnfHxvcihMdCksc3RhcnRXb3JrZXIodSkpOihvcihZZSksMDxHdHx8bXJ8fChtcj0hMCx1LmNhbGxlZFJ1bj0hMCx3ZXx8KGd8fG9yKEx0KSxwKHUpLGd8fG9yKGZuKSkpKSl9cmV0dXJuIHUuX19fc3RhcnRfZW1fanM9OTI5MzAxLHUuX19fc3RvcF9lbV9qcz05Mjk1NDcsdS5zdGFja1NhdmU9KCk9PlJuKCksdS5zdGFja1Jlc3RvcmU9cz0+Z3IocyksdS5zdGFja0FsbG9jPXM9Pk1uKHMpLHUuc2V0VmFsdWU9ZnVuY3Rpb24ocyxjLGY9XCJpOFwiKXtzd2l0Y2goZi5lbmRzV2l0aChcIipcIikmJihmPVwiKlwiKSxmKXtjYXNlXCJpMVwiOmNhc2VcImk4XCI6dCgpW3M+Pj4wXT1jO2JyZWFrO2Nhc2VcImkxNlwiOm4oKVtzPj4+MT4+PjBdPWM7YnJlYWs7Y2FzZVwiaTMyXCI6aSgpW3M+Pj4yPj4+MF09YzticmVhaztjYXNlXCJpNjRcIjpxW3M+Pj4zXT1CaWdJbnQoYyk7YnJlYWs7Y2FzZVwiZmxvYXRcIjpkKClbcz4+PjI+Pj4wXT1jO2JyZWFrO2Nhc2VcImRvdWJsZVwiOmwoKVtzPj4+Mz4+PjBdPWM7YnJlYWs7Y2FzZVwiKlwiOmEoKVtzPj4+Mj4+PjBdPWM7YnJlYWs7ZGVmYXVsdDpjdChgaW52YWxpZCB0eXBlIGZvciBzZXRWYWx1ZTogJHtmfWApfX0sdS5nZXRWYWx1ZT1mdW5jdGlvbihzLGM9XCJpOFwiKXtzd2l0Y2goYy5lbmRzV2l0aChcIipcIikmJihjPVwiKlwiKSxjKXtjYXNlXCJpMVwiOmNhc2VcImk4XCI6cmV0dXJuIHQoKVtzPj4+MF07Y2FzZVwiaTE2XCI6cmV0dXJuIG4oKVtzPj4+MT4+PjBdO2Nhc2VcImkzMlwiOnJldHVybiBpKClbcz4+PjI+Pj4wXTtjYXNlXCJpNjRcIjpyZXR1cm4gcVtzPj4+M107Y2FzZVwiZmxvYXRcIjpyZXR1cm4gZCgpW3M+Pj4yPj4+MF07Y2FzZVwiZG91YmxlXCI6cmV0dXJuIGwoKVtzPj4+Mz4+PjBdO2Nhc2VcIipcIjpyZXR1cm4gYSgpW3M+Pj4yPj4+MF07ZGVmYXVsdDpjdChgaW52YWxpZCB0eXBlIGZvciBnZXRWYWx1ZTogJHtjfWApfX0sdS5VVEY4VG9TdHJpbmc9Q2UsdS5zdHJpbmdUb1VURjg9T3QsdS5sZW5ndGhCeXRlc1VURjg9JG4sSHQ9ZnVuY3Rpb24gcygpe21yfHxRaSgpLG1yfHwoSHQ9cyl9LFFpKCksdS5QVFJfU0laRT00LGh9KSxLcD16YTtnbG9iYWxUaGlzLnNlbGY/Lm5hbWU9PT1cImVtLXB0aHJlYWRcIiYmemEoKX0pO3ZhciBSYSxqcCxOZSxVYSxqbixZcCxacCxOYSxRcCxCYSxWYSxNYSxXYSx4cj1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7JHIoKTtSYT0hMXx8dHlwZW9mIGxvY2F0aW9uPlwidVwiP3ZvaWQgMDpsb2NhdGlvbi5vcmlnaW4sanA9KCk9PntpZighITEpcmV0dXJuIGltcG9ydC5tZXRhLnVybD8uc3RhcnRzV2l0aChcImZpbGU6XCIpP25ldyBVUkwobmV3IFVSTChcIm9ydC53ZWJncHUuYnVuZGxlLm1pbi5tanNcIixpbXBvcnQubWV0YS51cmwpLmhyZWYsUmEpLmhyZWY6aW1wb3J0Lm1ldGEudXJsfSxOZT1qcCgpLFVhPSgpPT57aWYoTmUmJiFOZS5zdGFydHNXaXRoKFwiYmxvYjpcIikpcmV0dXJuIE5lLnN1YnN0cmluZygwLE5lLmxhc3RJbmRleE9mKFwiL1wiKSsxKX0sam49KGUsdCk9Pnt0cnl7bGV0IHI9dD8/TmU7cmV0dXJuKHI/bmV3IFVSTChlLHIpOm5ldyBVUkwoZSkpLm9yaWdpbj09PVJhfWNhdGNoe3JldHVybiExfX0sWXA9KGUsdCk9PntsZXQgcj10Pz9OZTt0cnl7cmV0dXJuKHI/bmV3IFVSTChlLHIpOm5ldyBVUkwoZSkpLmhyZWZ9Y2F0Y2h7cmV0dXJufX0sWnA9KGUsdCk9PmAke3Q/P1wiLi9cIn0ke2V9YCxOYT1hc3luYyBlPT57bGV0IHI9YXdhaXQoYXdhaXQgZmV0Y2goZSx7Y3JlZGVudGlhbHM6XCJzYW1lLW9yaWdpblwifSkpLmJsb2IoKTtyZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChyKX0sUXA9YXN5bmMgZT0+KGF3YWl0IGltcG9ydCgvKndlYnBhY2tJZ25vcmU6dHJ1ZSovZSkpLmRlZmF1bHQsQmE9KFBhKCksYnIoRWEpKS5kZWZhdWx0LFZhPWFzeW5jKCk9PntpZighTmUpdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGxvYWQgcHJveHkgd29ya2VyOiBjYW5ub3QgZGV0ZXJtaW5lIHRoZSBzY3JpcHQgc291cmNlIFVSTC5cIik7aWYoam4oTmUpKXJldHVyblt2b2lkIDAsQmEoKV07bGV0IGU9YXdhaXQgTmEoTmUpO3JldHVybltlLEJhKGUpXX0sTWE9KERhKCksYnIoT2EpKS5kZWZhdWx0LFdhPWFzeW5jKGUsdCxyKT0+e2lmKCFlJiYhdCYmTWEmJk5lJiZqbihOZSkpcmV0dXJuW3ZvaWQgMCxNYV07e2xldCBuPVwib3J0LXdhc20tc2ltZC10aHJlYWRlZC5qc2VwLm1qc1wiLG89ZT8/WXAobix0KSxpPSEhMSYmciYmbyYmIWpuKG8sdCksYT1pP2F3YWl0IE5hKG8pOm8/P1pwKG4sdCk7cmV0dXJuW2k/YTp2b2lkIDAsYXdhaXQgUXAoYSldfX19KTt2YXIgWW4sWm4senIsTGEsWHAsSnAsU3IsSWUsZ3Q9VSgoKT0+e1widXNlIHN0cmljdFwiO3hyKCk7Wm49ITEsenI9ITEsTGE9ITEsWHA9KCk9PntpZih0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXI+XCJ1XCIpcmV0dXJuITE7dHJ5e3JldHVybiB0eXBlb2YgTWVzc2FnZUNoYW5uZWw8XCJ1XCImJm5ldyBNZXNzYWdlQ2hhbm5lbCgpLnBvcnQxLnBvc3RNZXNzYWdlKG5ldyBTaGFyZWRBcnJheUJ1ZmZlcigxKSksV2ViQXNzZW1ibHkudmFsaWRhdGUobmV3IFVpbnQ4QXJyYXkoWzAsOTcsMTE1LDEwOSwxLDAsMCwwLDEsNCwxLDk2LDAsMCwzLDIsMSwwLDUsNCwxLDMsMSwxLDEwLDExLDEsOSwwLDY1LDAsMjU0LDE2LDIsMCwyNiwxMV0pKX1jYXRjaHtyZXR1cm4hMX19LEpwPSgpPT57dHJ5e3JldHVybiBXZWJBc3NlbWJseS52YWxpZGF0ZShuZXcgVWludDhBcnJheShbMCw5NywxMTUsMTA5LDEsMCwwLDAsMSw0LDEsOTYsMCwwLDMsMiwxLDAsMTAsMzAsMSwyOCwwLDY1LDAsMjUzLDE1LDI1MywxMiwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDI1MywxODYsMSwyNiwxMV0pKX1jYXRjaHtyZXR1cm4hMX19LFNyPWFzeW5jIGU9PntpZihabilyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7aWYoenIpdGhyb3cgbmV3IEVycm9yKFwibXVsdGlwbGUgY2FsbHMgdG8gJ2luaXRpYWxpemVXZWJBc3NlbWJseSgpJyBkZXRlY3RlZC5cIik7aWYoTGEpdGhyb3cgbmV3IEVycm9yKFwicHJldmlvdXMgY2FsbCB0byAnaW5pdGlhbGl6ZVdlYkFzc2VtYmx5KCknIGZhaWxlZC5cIik7enI9ITA7bGV0IHQ9ZS5pbml0VGltZW91dCxyPWUubnVtVGhyZWFkcztpZighSnAoKSl0aHJvdyBuZXcgRXJyb3IoXCJXZWJBc3NlbWJseSBTSU1EIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQuXCIpO2xldCBuPVhwKCk7cj4xJiYhbiYmKHR5cGVvZiBzZWxmPFwidVwiJiYhc2VsZi5jcm9zc09yaWdpbklzb2xhdGVkJiZjb25zb2xlLndhcm4oXCJlbnYud2FzbS5udW1UaHJlYWRzIGlzIHNldCB0byBcIityK1wiLCBidXQgdGhpcyB3aWxsIG5vdCB3b3JrIHVubGVzcyB5b3UgZW5hYmxlIGNyb3NzT3JpZ2luSXNvbGF0ZWQgbW9kZS4gU2VlIGh0dHBzOi8vd2ViLmRldi9jcm9zcy1vcmlnaW4taXNvbGF0aW9uLWd1aWRlLyBmb3IgbW9yZSBpbmZvLlwiKSxjb25zb2xlLndhcm4oXCJXZWJBc3NlbWJseSBtdWx0aS10aHJlYWRpbmcgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudC4gRmFsbGluZyBiYWNrIHRvIHNpbmdsZS10aHJlYWRpbmcuXCIpLGUubnVtVGhyZWFkcz1yPTEpO2xldCBvPWUud2FzbVBhdGhzLGk9dHlwZW9mIG89PVwic3RyaW5nXCI/bzp2b2lkIDAsYT1vPy5tanMsZD1hPy5ocmVmPz9hLGw9bz8ud2FzbSxwPWw/LmhyZWY/P2wsbT1lLndhc21CaW5hcnksW3UsaF09YXdhaXQgV2EoZCxpLHI+MSksXz0hMSx5PVtdO2lmKHQ+MCYmeS5wdXNoKG5ldyBQcm9taXNlKGc9PntzZXRUaW1lb3V0KCgpPT57Xz0hMCxnKCl9LHQpfSkpLHkucHVzaChuZXcgUHJvbWlzZSgoZyx4KT0+e2xldCAkPXtudW1UaHJlYWRzOnJ9O2lmKG0pJC53YXNtQmluYXJ5PW07ZWxzZSBpZihwfHxpKSQubG9jYXRlRmlsZT12PT5wPz9pK3Y7ZWxzZSBpZihkJiZkLmluZGV4T2YoXCJibG9iOlwiKSE9PTApJC5sb2NhdGVGaWxlPXY9Pm5ldyBVUkwodixkKS5ocmVmO2Vsc2UgaWYodSl7bGV0IHY9VWEoKTt2JiYoJC5sb2NhdGVGaWxlPVM9PnYrUyl9aCgkKS50aGVuKHY9Pnt6cj0hMSxabj0hMCxZbj12LGcoKSx1JiZVUkwucmV2b2tlT2JqZWN0VVJMKHUpfSx2PT57enI9ITEsTGE9ITAseCh2KX0pfSkpLGF3YWl0IFByb21pc2UucmFjZSh5KSxfKXRocm93IG5ldyBFcnJvcihgV2ViQXNzZW1ibHkgYmFja2VuZCBpbml0aWFsaXppbmcgZmFpbGVkIGR1ZSB0byB0aW1lb3V0OiAke3R9bXNgKX0sSWU9KCk9PntpZihabiYmWW4pcmV0dXJuIFluO3Rocm93IG5ldyBFcnJvcihcIldlYkFzc2VtYmx5IGlzIG5vdCBpbml0aWFsaXplZCB5ZXQuXCIpfX0pO3ZhciBrZSxqdCxwZSxPcj1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7Z3QoKTtrZT0oZSx0KT0+e2xldCByPUllKCksbj1yLmxlbmd0aEJ5dGVzVVRGOChlKSsxLG89ci5fbWFsbG9jKG4pO3JldHVybiByLnN0cmluZ1RvVVRGOChlLG8sbiksdC5wdXNoKG8pLG99LGp0PShlLHQscixuKT0+e2lmKHR5cGVvZiBlPT1cIm9iamVjdFwiJiZlIT09bnVsbCl7aWYoci5oYXMoZSkpdGhyb3cgbmV3IEVycm9yKFwiQ2lyY3VsYXIgcmVmZXJlbmNlIGluIG9wdGlvbnNcIik7ci5hZGQoZSl9T2JqZWN0LmVudHJpZXMoZSkuZm9yRWFjaCgoW28saV0pPT57bGV0IGE9dD90K286bztpZih0eXBlb2YgaT09XCJvYmplY3RcIilqdChpLGErXCIuXCIscixuKTtlbHNlIGlmKHR5cGVvZiBpPT1cInN0cmluZ1wifHx0eXBlb2YgaT09XCJudW1iZXJcIiluKGEsaS50b1N0cmluZygpKTtlbHNlIGlmKHR5cGVvZiBpPT1cImJvb2xlYW5cIiluKGEsaT9cIjFcIjpcIjBcIik7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoYENhbid0IGhhbmRsZSBleHRyYSBjb25maWcgdHlwZTogJHt0eXBlb2YgaX1gKX0pfSxwZT1lPT57bGV0IHQ9SWUoKSxyPXQuc3RhY2tTYXZlKCk7dHJ5e2xldCBuPXQuUFRSX1NJWkUsbz10LnN0YWNrQWxsb2MoMipuKTt0Ll9PcnRHZXRMYXN0RXJyb3IobyxvK24pO2xldCBpPU51bWJlcih0LmdldFZhbHVlKG8sbj09PTQ/XCJpMzJcIjpcImk2NFwiKSksYT10LmdldFZhbHVlKG8rbixcIipcIiksZD1hP3QuVVRGOFRvU3RyaW5nKGEpOlwiXCI7dGhyb3cgbmV3IEVycm9yKGAke2V9IEVSUk9SX0NPREU6ICR7aX0sIEVSUk9SX01FU1NBR0U6ICR7ZH1gKX1maW5hbGx5e3Quc3RhY2tSZXN0b3JlKHIpfX19KTt2YXIgR2EsSGE9VSgoKT0+e1widXNlIHN0cmljdFwiO2d0KCk7T3IoKTtHYT1lPT57bGV0IHQ9SWUoKSxyPTAsbj1bXSxvPWV8fHt9O3RyeXtpZihlPy5sb2dTZXZlcml0eUxldmVsPT09dm9pZCAwKW8ubG9nU2V2ZXJpdHlMZXZlbD0yO2Vsc2UgaWYodHlwZW9mIGUubG9nU2V2ZXJpdHlMZXZlbCE9XCJudW1iZXJcInx8IU51bWJlci5pc0ludGVnZXIoZS5sb2dTZXZlcml0eUxldmVsKXx8ZS5sb2dTZXZlcml0eUxldmVsPDB8fGUubG9nU2V2ZXJpdHlMZXZlbD40KXRocm93IG5ldyBFcnJvcihgbG9nIHNlcnZlcml0eSBsZXZlbCBpcyBub3QgdmFsaWQ6ICR7ZS5sb2dTZXZlcml0eUxldmVsfWApO2lmKGU/LmxvZ1ZlcmJvc2l0eUxldmVsPT09dm9pZCAwKW8ubG9nVmVyYm9zaXR5TGV2ZWw9MDtlbHNlIGlmKHR5cGVvZiBlLmxvZ1ZlcmJvc2l0eUxldmVsIT1cIm51bWJlclwifHwhTnVtYmVyLmlzSW50ZWdlcihlLmxvZ1ZlcmJvc2l0eUxldmVsKSl0aHJvdyBuZXcgRXJyb3IoYGxvZyB2ZXJib3NpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke2UubG9nVmVyYm9zaXR5TGV2ZWx9YCk7ZT8udGVybWluYXRlPT09dm9pZCAwJiYoby50ZXJtaW5hdGU9ITEpO2xldCBpPTA7cmV0dXJuIGU/LnRhZyE9PXZvaWQgMCYmKGk9a2UoZS50YWcsbikpLHI9dC5fT3J0Q3JlYXRlUnVuT3B0aW9ucyhvLmxvZ1NldmVyaXR5TGV2ZWwsby5sb2dWZXJib3NpdHlMZXZlbCwhIW8udGVybWluYXRlLGkpLHI9PT0wJiZwZShcIkNhbid0IGNyZWF0ZSBydW4gb3B0aW9ucy5cIiksZT8uZXh0cmEhPT12b2lkIDAmJmp0KGUuZXh0cmEsXCJcIixuZXcgV2Vha1NldCwoYSxkKT0+e2xldCBsPWtlKGEsbikscD1rZShkLG4pO3QuX09ydEFkZFJ1bkNvbmZpZ0VudHJ5KHIsbCxwKSE9PTAmJnBlKGBDYW4ndCBzZXQgYSBydW4gY29uZmlnIGVudHJ5OiAke2F9IC0gJHtkfS5gKX0pLFtyLG5dfWNhdGNoKGkpe3Rocm93IHIhPT0wJiZ0Ll9PcnRSZWxlYXNlUnVuT3B0aW9ucyhyKSxuLmZvckVhY2goYT0+dC5fZnJlZShhKSksaX19fSk7dmFyIGVtLHRtLHJtLG5tLEZhLHFhPVUoKCk9PntcInVzZSBzdHJpY3RcIjtndCgpO09yKCk7ZW09ZT0+e3N3aXRjaChlKXtjYXNlXCJkaXNhYmxlZFwiOnJldHVybiAwO2Nhc2VcImJhc2ljXCI6cmV0dXJuIDE7Y2FzZVwiZXh0ZW5kZWRcIjpyZXR1cm4gMjtjYXNlXCJhbGxcIjpyZXR1cm4gOTk7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGdyYXBoIG9wdGltaXphdGlvbiBsZXZlbDogJHtlfWApfX0sdG09ZT0+e3N3aXRjaChlKXtjYXNlXCJzZXF1ZW50aWFsXCI6cmV0dXJuIDA7Y2FzZVwicGFyYWxsZWxcIjpyZXR1cm4gMTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgZXhlY3V0aW9uIG1vZGU6ICR7ZX1gKX19LHJtPWU9PntlLmV4dHJhfHwoZS5leHRyYT17fSksZS5leHRyYS5zZXNzaW9ufHwoZS5leHRyYS5zZXNzaW9uPXt9KTtsZXQgdD1lLmV4dHJhLnNlc3Npb247dC51c2Vfb3J0X21vZGVsX2J5dGVzX2RpcmVjdGx5fHwodC51c2Vfb3J0X21vZGVsX2J5dGVzX2RpcmVjdGx5PVwiMVwiKSxlLmV4ZWN1dGlvblByb3ZpZGVycyYmZS5leGVjdXRpb25Qcm92aWRlcnMuc29tZShyPT4odHlwZW9mIHI9PVwic3RyaW5nXCI/cjpyLm5hbWUpPT09XCJ3ZWJncHVcIikmJihlLmVuYWJsZU1lbVBhdHRlcm49ITEpfSxubT0oZSx0LHIpPT57Zm9yKGxldCBuIG9mIHQpe2xldCBvPXR5cGVvZiBuPT1cInN0cmluZ1wiP246bi5uYW1lO3N3aXRjaChvKXtjYXNlXCJ3ZWJublwiOmlmKG89XCJXRUJOTlwiLHR5cGVvZiBuIT1cInN0cmluZ1wiKXtsZXQgZD1uPy5kZXZpY2VUeXBlO2lmKGQpe2xldCBsPWtlKFwiZGV2aWNlVHlwZVwiLHIpLHA9a2UoZCxyKTtJZSgpLl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkoZSxsLHApIT09MCYmcGUoYENhbid0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAnZGV2aWNlVHlwZScgLSAke2R9LmApfX1icmVhaztjYXNlXCJ3ZWJncHVcIjppZihvPVwiSlNcIix0eXBlb2YgbiE9XCJzdHJpbmdcIil7bGV0IGE9bjtpZihhPy5wcmVmZXJyZWRMYXlvdXQpe2lmKGEucHJlZmVycmVkTGF5b3V0IT09XCJOQ0hXXCImJmEucHJlZmVycmVkTGF5b3V0IT09XCJOSFdDXCIpdGhyb3cgbmV3IEVycm9yKGBwcmVmZXJyZWRMYXlvdXQgbXVzdCBiZSBlaXRoZXIgJ05DSFcnIG9yICdOSFdDJzogJHthLnByZWZlcnJlZExheW91dH1gKTtsZXQgZD1rZShcInByZWZlcnJlZExheW91dFwiLHIpLGw9a2UoYS5wcmVmZXJyZWRMYXlvdXQscik7SWUoKS5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KGUsZCxsKSE9PTAmJnBlKGBDYW4ndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogJ3ByZWZlcnJlZExheW91dCcgLSAke2EucHJlZmVycmVkTGF5b3V0fS5gKX19YnJlYWs7Y2FzZVwid2FzbVwiOmNhc2VcImNwdVwiOmNvbnRpbnVlO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBub3Qgc3VwcG9ydGVkIGV4ZWN1dGlvbiBwcm92aWRlcjogJHtvfWApfWxldCBpPWtlKG8scik7SWUoKS5fT3J0QXBwZW5kRXhlY3V0aW9uUHJvdmlkZXIoZSxpKSE9PTAmJnBlKGBDYW4ndCBhcHBlbmQgZXhlY3V0aW9uIHByb3ZpZGVyOiAke299LmApfX0sRmE9ZT0+e2xldCB0PUllKCkscj0wLG49W10sbz1lfHx7fTtybShvKTt0cnl7bGV0IGk9ZW0oby5ncmFwaE9wdGltaXphdGlvbkxldmVsPz9cImFsbFwiKSxhPXRtKG8uZXhlY3V0aW9uTW9kZT8/XCJzZXF1ZW50aWFsXCIpLGQ9dHlwZW9mIG8ubG9nSWQ9PVwic3RyaW5nXCI/a2Uoby5sb2dJZCxuKTowLGw9by5sb2dTZXZlcml0eUxldmVsPz8yO2lmKCFOdW1iZXIuaXNJbnRlZ2VyKGwpfHxsPDB8fGw+NCl0aHJvdyBuZXcgRXJyb3IoYGxvZyBzZXJ2ZXJpdHkgbGV2ZWwgaXMgbm90IHZhbGlkOiAke2x9YCk7bGV0IHA9by5sb2dWZXJib3NpdHlMZXZlbD8/MDtpZighTnVtYmVyLmlzSW50ZWdlcihwKXx8cDwwfHxwPjQpdGhyb3cgbmV3IEVycm9yKGBsb2cgdmVyYm9zaXR5IGxldmVsIGlzIG5vdCB2YWxpZDogJHtwfWApO2xldCBtPXR5cGVvZiBvLm9wdGltaXplZE1vZGVsRmlsZVBhdGg9PVwic3RyaW5nXCI/a2Uoby5vcHRpbWl6ZWRNb2RlbEZpbGVQYXRoLG4pOjA7aWYocj10Ll9PcnRDcmVhdGVTZXNzaW9uT3B0aW9ucyhpLCEhby5lbmFibGVDcHVNZW1BcmVuYSwhIW8uZW5hYmxlTWVtUGF0dGVybixhLCEhby5lbmFibGVQcm9maWxpbmcsMCxkLGwscCxtKSxyPT09MCYmcGUoXCJDYW4ndCBjcmVhdGUgc2Vzc2lvbiBvcHRpb25zLlwiKSxvLmV4ZWN1dGlvblByb3ZpZGVycyYmbm0ocixvLmV4ZWN1dGlvblByb3ZpZGVycyxuKSxvLmVuYWJsZUdyYXBoQ2FwdHVyZSE9PXZvaWQgMCl7aWYodHlwZW9mIG8uZW5hYmxlR3JhcGhDYXB0dXJlIT1cImJvb2xlYW5cIil0aHJvdyBuZXcgRXJyb3IoYGVuYWJsZUdyYXBoQ2FwdHVyZSBtdXN0IGJlIGEgYm9vbGVhbiB2YWx1ZTogJHtvLmVuYWJsZUdyYXBoQ2FwdHVyZX1gKTtsZXQgdT1rZShcImVuYWJsZUdyYXBoQ2FwdHVyZVwiLG4pLGg9a2Uoby5lbmFibGVHcmFwaENhcHR1cmUudG9TdHJpbmcoKSxuKTt0Ll9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkocix1LGgpIT09MCYmcGUoYENhbid0IHNldCBhIHNlc3Npb24gY29uZmlnIGVudHJ5OiAnZW5hYmxlR3JhcGhDYXB0dXJlJyAtICR7by5lbmFibGVHcmFwaENhcHR1cmV9LmApfWlmKG8uZnJlZURpbWVuc2lvbk92ZXJyaWRlcylmb3IobGV0W3UsaF1vZiBPYmplY3QuZW50cmllcyhvLmZyZWVEaW1lbnNpb25PdmVycmlkZXMpKXtpZih0eXBlb2YgdSE9XCJzdHJpbmdcIil0aHJvdyBuZXcgRXJyb3IoYGZyZWUgZGltZW5zaW9uIG92ZXJyaWRlIG5hbWUgbXVzdCBiZSBhIHN0cmluZzogJHt1fWApO2lmKHR5cGVvZiBoIT1cIm51bWJlclwifHwhTnVtYmVyLmlzSW50ZWdlcihoKXx8aDwwKXRocm93IG5ldyBFcnJvcihgZnJlZSBkaW1lbnNpb24gb3ZlcnJpZGUgdmFsdWUgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyOiAke2h9YCk7bGV0IF89a2UodSxuKTt0Ll9PcnRBZGRGcmVlRGltZW5zaW9uT3ZlcnJpZGUocixfLGgpIT09MCYmcGUoYENhbid0IHNldCBhIGZyZWUgZGltZW5zaW9uIG92ZXJyaWRlOiAke3V9IC0gJHtofS5gKX1yZXR1cm4gby5leHRyYSE9PXZvaWQgMCYmanQoby5leHRyYSxcIlwiLG5ldyBXZWFrU2V0LCh1LGgpPT57bGV0IF89a2UodSxuKSx5PWtlKGgsbik7dC5fT3J0QWRkU2Vzc2lvbkNvbmZpZ0VudHJ5KHIsXyx5KSE9PTAmJnBlKGBDYW4ndCBzZXQgYSBzZXNzaW9uIGNvbmZpZyBlbnRyeTogJHt1fSAtICR7aH0uYCl9KSxbcixuXX1jYXRjaChpKXt0aHJvdyByIT09MCYmdC5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zKHIpIT09MCYmcGUoXCJDYW4ndCByZWxlYXNlIHNlc3Npb24gb3B0aW9ucy5cIiksbi5mb3JFYWNoKGE9PnQuX2ZyZWUoYSkpLGl9fX0pO3ZhciBZdCxidCxDdCxEcixadCxCcixNcixRbix0ZT1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7WXQ9ZT0+e3N3aXRjaChlKXtjYXNlXCJpbnQ4XCI6cmV0dXJuIDM7Y2FzZVwidWludDhcIjpyZXR1cm4gMjtjYXNlXCJib29sXCI6cmV0dXJuIDk7Y2FzZVwiaW50MTZcIjpyZXR1cm4gNTtjYXNlXCJ1aW50MTZcIjpyZXR1cm4gNDtjYXNlXCJpbnQzMlwiOnJldHVybiA2O2Nhc2VcInVpbnQzMlwiOnJldHVybiAxMjtjYXNlXCJmbG9hdDE2XCI6cmV0dXJuIDEwO2Nhc2VcImZsb2F0MzJcIjpyZXR1cm4gMTtjYXNlXCJmbG9hdDY0XCI6cmV0dXJuIDExO2Nhc2VcInN0cmluZ1wiOnJldHVybiA4O2Nhc2VcImludDY0XCI6cmV0dXJuIDc7Y2FzZVwidWludDY0XCI6cmV0dXJuIDEzO2Nhc2VcImludDRcIjpyZXR1cm4gMjI7Y2FzZVwidWludDRcIjpyZXR1cm4gMjE7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtlfWApfX0sYnQ9ZT0+e3N3aXRjaChlKXtjYXNlIDM6cmV0dXJuXCJpbnQ4XCI7Y2FzZSAyOnJldHVyblwidWludDhcIjtjYXNlIDk6cmV0dXJuXCJib29sXCI7Y2FzZSA1OnJldHVyblwiaW50MTZcIjtjYXNlIDQ6cmV0dXJuXCJ1aW50MTZcIjtjYXNlIDY6cmV0dXJuXCJpbnQzMlwiO2Nhc2UgMTI6cmV0dXJuXCJ1aW50MzJcIjtjYXNlIDEwOnJldHVyblwiZmxvYXQxNlwiO2Nhc2UgMTpyZXR1cm5cImZsb2F0MzJcIjtjYXNlIDExOnJldHVyblwiZmxvYXQ2NFwiO2Nhc2UgODpyZXR1cm5cInN0cmluZ1wiO2Nhc2UgNzpyZXR1cm5cImludDY0XCI7Y2FzZSAxMzpyZXR1cm5cInVpbnQ2NFwiO2Nhc2UgMjI6cmV0dXJuXCJpbnQ0XCI7Y2FzZSAyMTpyZXR1cm5cInVpbnQ0XCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtlfWApfX0sQ3Q9KGUsdCk9PntsZXQgcj1bLTEsNCwxLDEsMiwyLDQsOCwtMSwxLDIsOCw0LDgsLTEsLTEsLTEsLTEsLTEsLTEsLTEsLjUsLjVdW2VdLG49dHlwZW9mIHQ9PVwibnVtYmVyXCI/dDp0LnJlZHVjZSgobyxpKT0+byppLDEpO3JldHVybiByPjA/TWF0aC5jZWlsKG4qcik6dm9pZCAwfSxEcj1lPT57c3dpdGNoKGUpe2Nhc2VcImZsb2F0MTZcIjpyZXR1cm4gdHlwZW9mIEZsb2F0MTZBcnJheTxcInVcIiYmRmxvYXQxNkFycmF5LmZyb20/RmxvYXQxNkFycmF5OlVpbnQxNkFycmF5O2Nhc2VcImZsb2F0MzJcIjpyZXR1cm4gRmxvYXQzMkFycmF5O2Nhc2VcInVpbnQ4XCI6cmV0dXJuIFVpbnQ4QXJyYXk7Y2FzZVwiaW50OFwiOnJldHVybiBJbnQ4QXJyYXk7Y2FzZVwidWludDE2XCI6cmV0dXJuIFVpbnQxNkFycmF5O2Nhc2VcImludDE2XCI6cmV0dXJuIEludDE2QXJyYXk7Y2FzZVwiaW50MzJcIjpyZXR1cm4gSW50MzJBcnJheTtjYXNlXCJib29sXCI6cmV0dXJuIFVpbnQ4QXJyYXk7Y2FzZVwiZmxvYXQ2NFwiOnJldHVybiBGbG9hdDY0QXJyYXk7Y2FzZVwidWludDMyXCI6cmV0dXJuIFVpbnQzMkFycmF5O2Nhc2VcImludDY0XCI6cmV0dXJuIEJpZ0ludDY0QXJyYXk7Y2FzZVwidWludDY0XCI6cmV0dXJuIEJpZ1VpbnQ2NEFycmF5O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCB0eXBlOiAke2V9YCl9fSxadD1lPT57c3dpdGNoKGUpe2Nhc2VcInZlcmJvc2VcIjpyZXR1cm4gMDtjYXNlXCJpbmZvXCI6cmV0dXJuIDE7Y2FzZVwid2FybmluZ1wiOnJldHVybiAyO2Nhc2VcImVycm9yXCI6cmV0dXJuIDM7Y2FzZVwiZmF0YWxcIjpyZXR1cm4gNDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgdW5zdXBwb3J0ZWQgbG9nZ2luZyBsZXZlbDogJHtlfWApfX0sQnI9ZT0+ZT09PVwiZmxvYXQzMlwifHxlPT09XCJmbG9hdDE2XCJ8fGU9PT1cImludDMyXCJ8fGU9PT1cImludDY0XCJ8fGU9PT1cInVpbnQzMlwifHxlPT09XCJ1aW50OFwifHxlPT09XCJib29sXCJ8fGU9PT1cInVpbnQ0XCJ8fGU9PT1cImludDRcIixNcj1lPT5lPT09XCJmbG9hdDMyXCJ8fGU9PT1cImZsb2F0MTZcInx8ZT09PVwiaW50MzJcInx8ZT09PVwiaW50NjRcInx8ZT09PVwidWludDMyXCJ8fGU9PT1cInVpbnQ2NFwifHxlPT09XCJpbnQ4XCJ8fGU9PT1cInVpbnQ4XCJ8fGU9PT1cImJvb2xcInx8ZT09PVwidWludDRcInx8ZT09PVwiaW50NFwiLFFuPWU9Pntzd2l0Y2goZSl7Y2FzZVwibm9uZVwiOnJldHVybiAwO2Nhc2VcImNwdVwiOnJldHVybiAxO2Nhc2VcImNwdS1waW5uZWRcIjpyZXR1cm4gMjtjYXNlXCJ0ZXh0dXJlXCI6cmV0dXJuIDM7Y2FzZVwiZ3B1LWJ1ZmZlclwiOnJldHVybiA0O2Nhc2VcIm1sLXRlbnNvclwiOnJldHVybiA1O2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGB1bnN1cHBvcnRlZCBkYXRhIGxvY2F0aW9uOiAke2V9YCl9fX0pO3ZhciBRdCxYbj1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7JHIoKTtRdD1hc3luYyBlPT57aWYodHlwZW9mIGU9PVwic3RyaW5nXCIpaWYoITEpdHJ5e2xldHtyZWFkRmlsZTp0fT1ObihcIm5vZGU6ZnMvcHJvbWlzZXNcIik7cmV0dXJuIG5ldyBVaW50OEFycmF5KGF3YWl0IHQoZSkpfWNhdGNoKHQpe2lmKHQuY29kZT09PVwiRVJSX0ZTX0ZJTEVfVE9PX0xBUkdFXCIpe2xldHtjcmVhdGVSZWFkU3RyZWFtOnJ9PU5uKFwibm9kZTpmc1wiKSxuPXIoZSksbz1bXTtmb3IgYXdhaXQobGV0IGkgb2YgbilvLnB1c2goaSk7cmV0dXJuIG5ldyBVaW50OEFycmF5KEJ1ZmZlci5jb25jYXQobykpfXRocm93IHR9ZWxzZXtsZXQgdD1hd2FpdCBmZXRjaChlKTtpZighdC5vayl0aHJvdyBuZXcgRXJyb3IoYGZhaWxlZCB0byBsb2FkIGV4dGVybmFsIGRhdGEgZmlsZTogJHtlfWApO2xldCByPXQuaGVhZGVycy5nZXQoXCJDb250ZW50LUxlbmd0aFwiKSxuPXI/cGFyc2VJbnQociwxMCk6MDtpZihuPDEwNzM3NDE4MjQpcmV0dXJuIG5ldyBVaW50OEFycmF5KGF3YWl0IHQuYXJyYXlCdWZmZXIoKSk7e2lmKCF0LmJvZHkpdGhyb3cgbmV3IEVycm9yKGBmYWlsZWQgdG8gbG9hZCBleHRlcm5hbCBkYXRhIGZpbGU6ICR7ZX0sIG5vIHJlc3BvbnNlIGJvZHkuYCk7bGV0IG89dC5ib2R5LmdldFJlYWRlcigpLGk7dHJ5e2k9bmV3IEFycmF5QnVmZmVyKG4pfWNhdGNoKGQpe2lmKGQgaW5zdGFuY2VvZiBSYW5nZUVycm9yKXtsZXQgbD1NYXRoLmNlaWwobi82NTUzNik7aT1uZXcgV2ViQXNzZW1ibHkuTWVtb3J5KHtpbml0aWFsOmwsbWF4aW11bTpsfSkuYnVmZmVyfWVsc2UgdGhyb3cgZH1sZXQgYT0wO2Zvcig7Oyl7bGV0e2RvbmU6ZCx2YWx1ZTpsfT1hd2FpdCBvLnJlYWQoKTtpZihkKWJyZWFrO2xldCBwPWwuYnl0ZUxlbmd0aDtuZXcgVWludDhBcnJheShpLGEscCkuc2V0KGwpLGErPXB9cmV0dXJuIG5ldyBVaW50OEFycmF5KGksMCxuKX19ZWxzZSByZXR1cm4gZSBpbnN0YW5jZW9mIEJsb2I/bmV3IFVpbnQ4QXJyYXkoYXdhaXQgZS5hcnJheUJ1ZmZlcigpKTplIGluc3RhbmNlb2YgVWludDhBcnJheT9lOm5ldyBVaW50OEFycmF5KGUpfX0pO3ZhciBvbSxpbSxLYSxqYSxScixhbSx1ZSxldD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtvbT1bXCJWXCIsXCJJXCIsXCJXXCIsXCJFXCIsXCJGXCJdLGltPShlLHQpPT57Y29uc29sZS5sb2coYFske29tW2VdfSwke25ldyBEYXRlKCkudG9JU09TdHJpbmcoKX1dJHt0fWApfSxScj0oZSx0KT0+e0thPWUsamE9dH0sYW09KGUsdCk9PntsZXQgcj1adChlKSxuPVp0KEthKTtyPj1uJiZpbShyLHR5cGVvZiB0PT1cImZ1bmN0aW9uXCI/dCgpOnQpfSx1ZT0oLi4uZSk9PntqYSYmYW0oLi4uZSl9fSk7dmFyIFVyLEpuPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO1VyPShlLHQpPT5uZXcoRHIodCkpKGUpfSk7dmFyIE5yPVUoKCk9PntcInVzZSBzdHJpY3RcIn0pO3ZhciBZYSxlbyx0byxzbSx1bSxaYSxubyxybyxYYSxKYT1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7ZXQoKTtOcigpO1lhPW5ldyBNYXAoW1s2NCwyNTBdLFsxMjgsMjAwXSxbMjU2LDIwMF0sWzUxMiwyMDBdLFsyMDQ4LDIzMF0sWzQwOTYsMjAwXSxbODE5Miw1MF0sWzE2Mzg0LDUwXSxbMzI3NjgsNTBdLFs2NTUzNiw1MF0sWzEzMTA3Miw1MF0sWzI2MjE0NCw1MF0sWzUyNDI4OCw1MF0sWzEwNDg1NzYsNTBdLFsyMDk3MTUyLDMwXSxbNDE5NDMwNCwyMF0sWzgzODg2MDgsMTBdLFsxMjU4MjkxMiwxMF0sWzE2Nzc3MjE2LDEwXSxbMjYyMTQ0MDAsMTVdLFszMzU1NDQzMiwyMl0sWzQ0MjM2ODAwLDJdLFs1ODk4MjQwMCw2XSxbNjcxMDg4NjQsNl0sWzEzNDIxNzcyOCw2XSxbMTY3NzcyMTYwLDZdXSksZW89W10sdG89ZT0+TWF0aC5jZWlsKE51bWJlcihlKS8xNikqMTYsc209ZT0+e2ZvcihsZXQgdD0wO3Q8ZW8ubGVuZ3RoO3QrKyl7bGV0IHI9ZW9bdF07aWYoZTw9cilyZXR1cm4gcn1yZXR1cm4gTWF0aC5jZWlsKGUvMTYpKjE2fSx1bT0xLFphPSgpPT51bSsrLG5vPWFzeW5jKGUsdCxyLG4pPT57bGV0IG89dG8ociksaT1lLmRldmljZS5jcmVhdGVCdWZmZXIoe3NpemU6byx1c2FnZTpHUFVCdWZmZXJVc2FnZS5DT1BZX0RTVHxHUFVCdWZmZXJVc2FnZS5NQVBfUkVBRH0pO3RyeXtsZXQgYT1lLmdldENvbW1hbmRFbmNvZGVyKCk7ZS5lbmRDb21wdXRlUGFzcygpLGEuY29weUJ1ZmZlclRvQnVmZmVyKHQsMCxpLDAsbyksZS5mbHVzaCgpLGF3YWl0IGkubWFwQXN5bmMoR1BVTWFwTW9kZS5SRUFEKTtsZXQgZD1pLmdldE1hcHBlZFJhbmdlKCk7aWYobil7bGV0IGw9bigpO3JldHVybiBsLnNldChuZXcgVWludDhBcnJheShkLDAscikpLGx9ZWxzZSByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZC5zbGljZSgwLHIpKX1maW5hbGx5e2kuZGVzdHJveSgpfX0scm89Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5iYWNrZW5kPXQ7dGhpcy5zdG9yYWdlQ2FjaGU9bmV3IE1hcCx0aGlzLmZyZWVCdWZmZXJzPW5ldyBNYXAsdGhpcy5mcmVlVW5pZm9ybUJ1ZmZlcnM9bmV3IE1hcCx0aGlzLmJ1ZmZlcnNQZW5kaW5nPVtdLHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycz1uZXcgTWFwO2ZvcihsZXRbcl1vZiBZYSllby5wdXNoKHIpLHRoaXMuZnJlZUJ1ZmZlcnMuc2V0KHIsW10pLHRoaXMuZnJlZVVuaWZvcm1CdWZmZXJzLnNldChyLFtdKTt0aGlzLnNlc3Npb25Db3VudD0wfXVwbG9hZCh0LHIpe2xldCBuPXIuYnVmZmVyLG89ci5ieXRlT2Zmc2V0LGk9ci5ieXRlTGVuZ3RoLGE9dG8oaSksZD10aGlzLnN0b3JhZ2VDYWNoZS5nZXQodCk7aWYoIWQpdGhyb3cgbmV3IEVycm9yKFwiZ3B1IGRhdGEgZm9yIHVwbG9hZGluZyBkb2VzIG5vdCBleGlzdFwiKTtpZihOdW1iZXIoZC5vcmlnaW5hbFNpemUpIT09aSl0aHJvdyBuZXcgRXJyb3IoYGluY29uc2lzdGVudCBkYXRhIHNpemUuIGdwdSBkYXRhIHNpemU9JHtkLm9yaWdpbmFsU2l6ZX0sIGRhdGEgc2l6ZT0ke2l9YCk7bGV0IGw9dGhpcy5iYWNrZW5kLmRldmljZS5jcmVhdGVCdWZmZXIoe21hcHBlZEF0Q3JlYXRpb246ITAsc2l6ZTphLHVzYWdlOkdQVUJ1ZmZlclVzYWdlLk1BUF9XUklURXxHUFVCdWZmZXJVc2FnZS5DT1BZX1NSQ30pLHA9bC5nZXRNYXBwZWRSYW5nZSgpO25ldyBVaW50OEFycmF5KHApLnNldChuZXcgVWludDhBcnJheShuLG8saSkpLGwudW5tYXAoKTtsZXQgbT10aGlzLmJhY2tlbmQuZGV2aWNlLmNyZWF0ZUNvbW1hbmRFbmNvZGVyKCk7bS5jb3B5QnVmZmVyVG9CdWZmZXIobCwwLGQuZ3B1RGF0YS5idWZmZXIsMCxhKSx0aGlzLmJhY2tlbmQuZGV2aWNlLnF1ZXVlLnN1Ym1pdChbbS5maW5pc2goKV0pLGwuZGVzdHJveSgpLHVlKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIudXBsb2FkKGlkPSR7dH0pYCl9bWVtY3B5KHQscil7bGV0IG49dGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KHQpO2lmKCFuKXRocm93IG5ldyBFcnJvcihcInNvdXJjZSBncHUgZGF0YSBmb3IgbWVtY3B5IGRvZXMgbm90IGV4aXN0XCIpO2xldCBvPXRoaXMuc3RvcmFnZUNhY2hlLmdldChyKTtpZighbyl0aHJvdyBuZXcgRXJyb3IoXCJkZXN0aW5hdGlvbiBncHUgZGF0YSBmb3IgbWVtY3B5IGRvZXMgbm90IGV4aXN0XCIpO2lmKG4ub3JpZ2luYWxTaXplIT09by5vcmlnaW5hbFNpemUpdGhyb3cgbmV3IEVycm9yKFwiaW5jb25zaXN0ZW50IHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZ3B1IGRhdGEgc2l6ZVwiKTtsZXQgaT10byhuLm9yaWdpbmFsU2l6ZSksYT10aGlzLmJhY2tlbmQuZ2V0Q29tbWFuZEVuY29kZXIoKTt0aGlzLmJhY2tlbmQuZW5kQ29tcHV0ZVBhc3MoKSxhLmNvcHlCdWZmZXJUb0J1ZmZlcihuLmdwdURhdGEuYnVmZmVyLDAsby5ncHVEYXRhLmJ1ZmZlciwwLGkpfXJlZ2lzdGVyRXh0ZXJuYWxCdWZmZXIodCxyLG4pe2xldCBvO2lmKG4pe2lmKG89blswXSx0PT09blsxXSlyZXR1cm4gdWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci5yZWdpc3RlckV4dGVybmFsQnVmZmVyKHNpemU9JHtyfSkgPT4gaWQ9JHtvfSwgYnVmZmVyIGlzIHRoZSBzYW1lLCBza2lwLmApLG87aWYodGhpcy5iYWNrZW5kLmNhcHR1cmVkQ29tbWFuZExpc3QuaGFzKHRoaXMuYmFja2VuZC5jdXJyZW50U2Vzc2lvbklkKSl0aHJvdyBuZXcgRXJyb3IoYFJlZ2lzdGVyaW5nIGEgZGlmZmVyZW50IGV4dGVybmFsIGJ1ZmZlciB1bmRlciBncmFwaCBjYXB0dXJlIG1vZGUgaXMgbm90IHN1cHBvcnRlZCB5ZXQuXG4gICAgICAgICAgICAgUGxlYXNlIHVzZSB0aGUgcHJldmlvdXMgZXh0ZXJuYWwgYnVmZmVyIWApfWVsc2Ugbz1aYSgpO3JldHVybiB0aGlzLnN0b3JhZ2VDYWNoZS5zZXQobyx7Z3B1RGF0YTp7aWQ6byx0eXBlOjAsYnVmZmVyOnR9LG9yaWdpbmFsU2l6ZTpyfSksdWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBHcHVEYXRhTWFuYWdlci5yZWdpc3RlckV4dGVybmFsQnVmZmVyKHNpemU9JHtyfSkgPT4gaWQ9JHtvfSwgcmVnaXN0ZXJlZC5gKSxvfXVucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlcih0KXt0IT09dm9pZCAwJiYodGhpcy5zdG9yYWdlQ2FjaGUuZGVsZXRlKHQpLHVlKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0gR3B1RGF0YU1hbmFnZXIudW5yZWdpc3RlckV4dGVybmFsQnVmZmVyKCkgPT4gaWQ9JHt0fWApKX1jcmVhdGUodCxyPUdQVUJ1ZmZlclVzYWdlLlNUT1JBR0V8R1BVQnVmZmVyVXNhZ2UuQ09QWV9TUkN8R1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1Qpe2xldCBuPXNtKHQpLG8saT0ociZHUFVCdWZmZXJVc2FnZS5TVE9SQUdFKT09PUdQVUJ1ZmZlclVzYWdlLlNUT1JBR0UsYT0ociZHUFVCdWZmZXJVc2FnZS5VTklGT1JNKT09PUdQVUJ1ZmZlclVzYWdlLlVOSUZPUk07aWYoaXx8YSl7bGV0IHA9KGk/dGhpcy5mcmVlQnVmZmVyczp0aGlzLmZyZWVVbmlmb3JtQnVmZmVycykuZ2V0KG4pO3A/cC5sZW5ndGg+MD9vPXAucG9wKCk6bz10aGlzLmJhY2tlbmQuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7c2l6ZTpuLHVzYWdlOnJ9KTpvPXRoaXMuYmFja2VuZC5kZXZpY2UuY3JlYXRlQnVmZmVyKHtzaXplOm4sdXNhZ2U6cn0pfWVsc2Ugbz10aGlzLmJhY2tlbmQuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7c2l6ZTpuLHVzYWdlOnJ9KTtsZXQgZD17aWQ6WmEoKSx0eXBlOjAsYnVmZmVyOm99O3JldHVybiB0aGlzLnN0b3JhZ2VDYWNoZS5zZXQoZC5pZCx7Z3B1RGF0YTpkLG9yaWdpbmFsU2l6ZTpOdW1iZXIodCl9KSx1ZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLmNyZWF0ZShzaXplPSR7dH0pID0+IGlkPSR7ZC5pZH1gKSxkfWdldCh0KXtyZXR1cm4gdGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KHQpPy5ncHVEYXRhfXJlbGVhc2UodCl7bGV0IHI9dHlwZW9mIHQ9PVwiYmlnaW50XCI/TnVtYmVyKHQpOnQsbj10aGlzLnN0b3JhZ2VDYWNoZS5nZXQocik7aWYoIW4pe2lmKHRoaXMuc3RvcmFnZUNhY2hlLnNpemU9PT0wKXJldHVybiAwO3Rocm93IG5ldyBFcnJvcihcInJlbGVhc2luZyBkYXRhIGRvZXMgbm90IGV4aXN0XCIpfXJldHVybiB1ZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIEdwdURhdGFNYW5hZ2VyLnJlbGVhc2UoaWQ9JHtyfSksIGdwdURhdGFJZD0ke24uZ3B1RGF0YS5pZH1gKSx0aGlzLnN0b3JhZ2VDYWNoZS5kZWxldGUociksdGhpcy5idWZmZXJzUGVuZGluZy5wdXNoKG4uZ3B1RGF0YS5idWZmZXIpLG4ub3JpZ2luYWxTaXplfWFzeW5jIGRvd25sb2FkKHQscil7bGV0IG49dGhpcy5zdG9yYWdlQ2FjaGUuZ2V0KE51bWJlcih0KSk7aWYoIW4pdGhyb3cgbmV3IEVycm9yKFwiZGF0YSBkb2VzIG5vdCBleGlzdFwiKTthd2FpdCBubyh0aGlzLmJhY2tlbmQsbi5ncHVEYXRhLmJ1ZmZlcixuLm9yaWdpbmFsU2l6ZSxyKX1yZWZyZXNoUGVuZGluZ0J1ZmZlcnMoKXtpZih0aGlzLmJ1ZmZlcnNQZW5kaW5nLmxlbmd0aCE9PTApaWYodGhpcy5iYWNrZW5kLnNlc3Npb25TdGF0dXM9PT1cImRlZmF1bHRcIil7Zm9yKGxldCB0IG9mIHRoaXMuYnVmZmVyc1BlbmRpbmcpe2xldCByPVlhLmdldCh0LnNpemUpO2lmKCh0LnVzYWdlJkdQVUJ1ZmZlclVzYWdlLlNUT1JBR0UpPT09R1BVQnVmZmVyVXNhZ2UuU1RPUkFHRSl7bGV0IG49dGhpcy5mcmVlQnVmZmVycy5nZXQodC5zaXplKXx8W107cj09PXZvaWQgMHx8bi5sZW5ndGg+PXI/dC5kZXN0cm95KCk6bi5wdXNoKHQpfWVsc2UgaWYoKHQudXNhZ2UmR1BVQnVmZmVyVXNhZ2UuVU5JRk9STSk9PT1HUFVCdWZmZXJVc2FnZS5VTklGT1JNKXtsZXQgbj10aGlzLmZyZWVVbmlmb3JtQnVmZmVycy5nZXQodC5zaXplKXx8W107cj09PXZvaWQgMHx8bi5sZW5ndGg+PXI/dC5kZXN0cm95KCk6bi5wdXNoKHQpfWVsc2UgdC5kZXN0cm95KCl9dGhpcy5idWZmZXJzUGVuZGluZz1bXX1lbHNle2xldCB0PXRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycy5nZXQodGhpcy5iYWNrZW5kLmN1cnJlbnRTZXNzaW9uSWQpO3R8fCh0PVtdLHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycy5zZXQodGhpcy5iYWNrZW5kLmN1cnJlbnRTZXNzaW9uSWQsdCkpO2ZvcihsZXQgciBvZiB0aGlzLmJ1ZmZlcnNQZW5kaW5nKXQucHVzaChyKTt0aGlzLmJ1ZmZlcnNQZW5kaW5nPVtdfX1kaXNwb3NlKCl7dGhpcy5mcmVlQnVmZmVycy5mb3JFYWNoKHQ9Pnt0LmZvckVhY2gocj0+e3IuZGVzdHJveSgpfSl9KSx0aGlzLmZyZWVVbmlmb3JtQnVmZmVycy5mb3JFYWNoKHQ9Pnt0LmZvckVhY2gocj0+e3IuZGVzdHJveSgpfSl9KSx0aGlzLnN0b3JhZ2VDYWNoZS5mb3JFYWNoKHQ9Pnt0LmdwdURhdGEuYnVmZmVyLmRlc3Ryb3koKX0pLHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycy5mb3JFYWNoKHQ9Pnt0LmZvckVhY2gocj0+e3IuZGVzdHJveSgpfSl9KSx0aGlzLnN0b3JhZ2VDYWNoZT1uZXcgTWFwLHRoaXMuZnJlZUJ1ZmZlcnM9bmV3IE1hcCx0aGlzLmZyZWVVbmlmb3JtQnVmZmVycz1uZXcgTWFwLHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycz1uZXcgTWFwfW9uQ3JlYXRlU2Vzc2lvbigpe3RoaXMuc2Vzc2lvbkNvdW50Kz0xfW9uUmVsZWFzZVNlc3Npb24odCl7bGV0IHI9dGhpcy5jYXB0dXJlZFBlbmRpbmdCdWZmZXJzLmdldCh0KTtyJiYoci5mb3JFYWNoKG49PntuLmRlc3Ryb3koKX0pLHRoaXMuY2FwdHVyZWRQZW5kaW5nQnVmZmVycy5kZWxldGUodCkpLHRoaXMuc2Vzc2lvbkNvdW50LT0xLHRoaXMuc2Vzc2lvbkNvdW50PT09MCYmKHVlKFwid2FybmluZ1wiLCgpPT5cIltXZWJHUFVdIENsZWFyaW5nIHdlYmdwdSBidWZmZXIgY2FjaGVcIiksdGhpcy5zdG9yYWdlQ2FjaGUuZm9yRWFjaChuPT57bi5ncHVEYXRhLmJ1ZmZlci5kZXN0cm95KCl9KSx0aGlzLnN0b3JhZ2VDYWNoZT1uZXcgTWFwKX19LFhhPSguLi5lKT0+bmV3IHJvKC4uLmUpfSk7dmFyIG9vLHJlLFNlPVUoKCk9PntcInVzZSBzdHJpY3RcIjtvbz1jbGFzc3tjb25zdHJ1Y3Rvcih0KXtPYmplY3QuYXNzaWduKHRoaXMsdCl9Z2V0IGNhY2hlS2V5KCl7cmV0dXJuIHRoaXMua2V5fHwodGhpcy5rZXk9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykuc29ydCgpLm1hcCh0PT5gJHt0aGlzW3RdfWApLmpvaW4oXCI7XCIpKSx0aGlzLmtleX19LHJlPWU9Pm5ldyBvbyhlKX0pO3ZhciBpbyx0dCxDLEF0LFZyLGVzLHRzLG9lPVUoKCk9PntcInVzZSBzdHJpY3RcIjtpbz1jbGFzc3tzdGF0aWMgY2FsY01hdE11bFNoYXBlKHQscil7cmV0dXJuIHRbMV0hPT1yWzBdP3ZvaWQgMDpbdFswXSxyWzFdXX19LHR0PWNsYXNze3N0YXRpYyBjYWxjU2hhcGUodCxyLG49ITEpe2xldCBvPXQubGVuZ3RoLGk9ci5sZW5ndGg7aWYobz09PTApcmV0dXJuIHI7aWYoaT09PTApcmV0dXJuIHQ7bGV0IGE9TWF0aC5tYXgodC5sZW5ndGgsci5sZW5ndGgpLGQ9bmV3IEFycmF5KGEpO2lmKG4pe2lmKG88Mnx8aTwyKXJldHVybjtsZXQgbD1pby5jYWxjTWF0TXVsU2hhcGUoW3Rbby0yXSx0W28tMV1dLFtyW2ktMl0scltpLTFdXSk7aWYobD09PXZvaWQgMClyZXR1cm47W2RbYS0yXSxkW2EtMV1dPWx9Zm9yKGxldCBsPW4/MzoxO2w8PWE7bCsrKXtsZXQgcD1vLWw8MD8xOnRbby1sXSxtPWktbDwwPzE6cltpLWxdO2lmKHAhPT1tJiZwPjEmJm0+MSlyZXR1cm47bGV0IHU9TWF0aC5tYXgocCxtKTtpZihwJiZtKWRbYS1sXT1NYXRoLm1heChwLG0pO2Vsc2V7aWYodT4xKXJldHVybjtkW2EtbF09MH19cmV0dXJuIGR9c3RhdGljIGlzVmFsaWRCcm9hZGNhc3QodCxyKXtsZXQgbj10Lmxlbmd0aCxvPXIubGVuZ3RoO2lmKG4+bylyZXR1cm4hMTtmb3IobGV0IGk9MTtpPD1uO2krKylpZih0W24taV0hPT0xJiZ0W24taV0hPT1yW28taV0pcmV0dXJuITE7cmV0dXJuITB9fSxDPWNsYXNzIGV7c3RhdGljIHNpemUodCl7cmV0dXJuIGUuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZSh0LDAsdC5sZW5ndGgpfXN0YXRpYyBjb252ZXJ0U2hhcGUodCxyPTQpe2xldCBuPXQubGVuZ3RoO2lmKG49PT0wKXJldHVybltdO2xldCBvPW5ldyBBcnJheShuKSxpPW4tMTtmb3IoO2k+PTA7KXtpZih0W2ldJXI9PT0wKXtvW2ldPXRbaV0vcjticmVha31pZihyJXRbaV0hPT0wKXRocm93IG5ldyBFcnJvcihcImNhbm5vdCBjb252ZXJ0IHNoYXBlXCIpO29baV09MSxyLz10W2ldLGktLX1mb3IoaS0tO2k+PTA7aS0tKW9baV09dFtpXTtyZXR1cm4gb31zdGF0aWMgc2l6ZUZyb21EaW1lbnNpb24odCxyKXtpZihyPDB8fHI+dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRpbWVuc2lvbiBvZiAke3J9IGZvciBzaXplRnJvbURpbWVuc2lvbiBhcyBUZW5zb3IgaGFzICR7dC5sZW5ndGh9IGRpbWVuc2lvbnMuYCk7cmV0dXJuIGUuZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZSh0LHIsdC5sZW5ndGgpfXN0YXRpYyBzaXplVG9EaW1lbnNpb24odCxyKXtpZihyPDB8fHI+dC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRpbWVuc2lvbiBvZiAke3J9IGZvciBzaXplVG9EaW1lbnNpb24gYXMgVGVuc29yIGhhcyAke3QubGVuZ3RofSBkaW1lbnNpb25zLmApO3JldHVybiBlLmdldFNpemVGcm9tRGltZW5zaW9uUmFuZ2UodCwwLHIpfXN0YXRpYyBnZXRTaXplRnJvbURpbWVuc2lvblJhbmdlKHQscixuKXtsZXQgbz0xO2ZvcihsZXQgaT1yO2k8bjtpKyspe2lmKHRbaV08MCl0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZ2V0IHZhbGlkIHNpemUgZnJvbSBzcGVjaWZpZWQgZGltZW5zaW9uIHJhbmdlLiBNb3N0IGxpa2VseSB0aGUgcmFuZ2UgY29udGFpbnMgbmVnYXRpdmUgdmFsdWVzIGluIHRoZW0uXCIpO28qPU51bWJlcih0W2ldKX1yZXR1cm4gb31zdGF0aWMgY29tcHV0ZVN0cmlkZXModCl7bGV0IHI9dC5sZW5ndGg7aWYocj09PTApcmV0dXJuW107aWYocj09PTEpcmV0dXJuWzFdO2xldCBuPW5ldyBBcnJheShyKTtuW3ItMV09MSxuW3ItMl09dFtyLTFdO2ZvcihsZXQgbz1yLTM7bz49MDstLW8pbltvXT1uW28rMV0qdFtvKzFdO3JldHVybiBufXN0YXRpYyBub3JtYWxpemVBeGlzKHQscil7aWYodDwtciYmdD49cil0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBheGlzIGZvciB0aGlzIG9wZXJhdGlvbi5cIik7cmV0dXJuIHQ8MD90K3I6dH1zdGF0aWMgbm9ybWFsaXplQXhlcyh0LHIpe3JldHVybiB0Lm1hcChuPT50aGlzLm5vcm1hbGl6ZUF4aXMobixyPz90Lmxlbmd0aCkpfXN0YXRpYyBzb3J0QmFzZWRPblBlcm0odCxyKXtyZXR1cm4gcj9yLm1hcChuPT50W25dKTp0LnNsaWNlKCkucmV2ZXJzZSgpfXN0YXRpYyBwYWRTaGFwZSh0LHIpe2xldCBuPXQubGVuZ3RoO3JldHVybiB0Lm1hcCgobyxpKT0+bytyW2ldK3JbaStuXSl9c3RhdGljIGFyZUVxdWFsKHQscil7cmV0dXJuIHQubGVuZ3RoIT09ci5sZW5ndGg/ITE6dC5ldmVyeSgobixvKT0+bj09PXJbb10pfX0sQXQ9Y2xhc3MgZXtzdGF0aWMgYWRqdXN0UG9vbEF0dHJpYnV0ZXModCxyLG4sbyxpLGEpe2lmKCF0JiZuLmxlbmd0aCE9PXIubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG9mIHNwZWNpZmllZCBrZXJuZWwgc2hhcGVzIHNob3VsZCBiZSAyIGxlc3MgdGhhbiBsZW5ndGggb2YgaW5wdXQgZGltZW5zaW9uc1wiKTtpZih0KWZvcihsZXQgZD0wO2Q8ci5sZW5ndGgtMjtkKyspZD49bi5sZW5ndGg/bi5wdXNoKHJbZCsyXSk6bltkXT1yW2QrMl07Zm9yKGxldCBkPTA7ZDxuLmxlbmd0aDtkKyspaWYoZDxvLmxlbmd0aCl7aWYob1tkXTwwKXRocm93IG5ldyBFcnJvcihcInN0cmlkZXMgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxXCIpfWVsc2Ugby5wdXNoKDEpO2ZvcihsZXQgZD0wO2Q8bi5sZW5ndGg7ZCsrKWlmKGQ8aS5sZW5ndGgpe2lmKGlbZF08MCl0aHJvdyBuZXcgRXJyb3IoXCJkaWxhdGlvbnMgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAxXCIpfWVsc2UgaS5wdXNoKDEpO2ZvcihsZXQgZD0wO2Q8bi5sZW5ndGgqMjtkKyspaWYoZDxhLmxlbmd0aCl7aWYoYVtkXTwwKXRocm93IG5ldyBFcnJvcihcInBhZCBzaG91bGQgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDFcIil9ZWxzZSBhLnB1c2goMCk7Zm9yKGxldCBkPTA7ZDxuLmxlbmd0aDtkKyspe2lmKG5bZF08PTApdGhyb3cgbmV3IEVycm9yKFwia2VybmVsIHNoYXBlcyBuZWVkIHRvIGJlIGdyZWF0ZXIgdGhhbiAwXCIpO2lmKGFbZF0+PW5bZF18fGFbZCtuLmxlbmd0aF0+PW5bZF0pdGhyb3cgbmV3IEVycm9yKFwicGFkcyBzaG91bGQgYmUgc21hbGxlciB0aGFuIGtlcm5lbFwiKX19c3RhdGljIGFkanVzdFBhZHNCYXNlZE9uQXV0b1BhZCh0LHIsbixvLGksYSxkKXtpZihkKXtpZihpLmxlbmd0aCE9PTIqKHQubGVuZ3RoLTIpKXRocm93IG5ldyBFcnJvcihcImxlbmd0aCBvZiBwYWRzIHNob3VsZCBiZSB0d2ljZSB0aGUgbGVuZ3RoIG9mIGRhdGEgZGltZW5zaW9uc1wiKTtpZihyLmxlbmd0aCE9PXQubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwibGVuZ3RoIG9mIHN0cmlkZXMgc2hvdWxkIGJlIHRoZSBsZW5ndGggb2YgZGF0YSBkaW1lbnNpb25zXCIpO2lmKG8ubGVuZ3RoIT09dC5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggb2Yga2VybmVsIHNoYXBlcyBzaG91bGQgYmUgdGhlIGxlbmd0aCBvZiBkYXRhIGRpbWVuc2lvbnNcIik7Zm9yKGxldCBsPTA7bDx0Lmxlbmd0aC0yO2wrKyllLmFkanVzdFBhZEFuZFJldHVyblNoYXBlKHRbbCsoYT8xOjIpXSxyW2xdLG5bbF0sb1tsXSxpLGwsbCt0Lmxlbmd0aC0yLGQpfX1zdGF0aWMgY29tcHV0ZVBvb2xPdXRwdXRTaGFwZSh0LHIsbixvLGksYSxkKXtpZihyLmxlbmd0aDw9MCl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCBzaGFwZSBtdXN0IGJlIG9mIHNpemUgZ3JlYXRlciB0aGFuIDBcIik7bGV0IGw9W3JbMF0sclsxXV07cmV0dXJuIGUuY29tcHV0ZVNoYXBlSGVscGVyKHQscixsLG4sbyxpLGEsZCksbH1zdGF0aWMgY29tcHV0ZUNvbnZPdXRwdXRTaGFwZSh0LHIsbixvLGksYSxkKXtpZih0Lmxlbmd0aDw9MHx8ci5sZW5ndGg8PTApdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnB1dCB0ZW5zb3IgZGltcyBvciBpbnZhbGlkIGZpbHRlciB0ZW5zb3IgZGltc1wiKTtsZXQgbD1bdFswXSxyWzBdXTtyZXR1cm4gZS5jb21wdXRlU2hhcGVIZWxwZXIoITEsdCxsLG4sbyxpLGEsZCksbH1zdGF0aWMgY29tcHV0ZVNoYXBlSGVscGVyKHQscixuLG8saSxhLGQsbCl7aWYodClmb3IobGV0IHA9MDtwPHIubGVuZ3RoLTI7cCsrKW4ucHVzaCgxKTtlbHNlIGZvcihsZXQgcD0wO3A8ci5sZW5ndGgtMjtwKyspbi5wdXNoKGUuYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUocltwKzJdLG9bcF0saVtwXSxhW3BdLGQscCxwK3IubGVuZ3RoLTIsbCkpfXN0YXRpYyBhZGp1c3RQYWRBbmRSZXR1cm5TaGFwZSh0LHIsbixvLGksYSxkLGwpe2xldCBwPW4qKG8tMSkrMTtpZihsJiZsIT09XCJOT1RTRVRcIilzd2l0Y2gobCl7Y2FzZVwiVkFMSURcIjpyZXR1cm4gaVthXT0wLGlbZF09MCxNYXRoLmZsb29yKCh0LXApL3IrMSk7Y2FzZVwiU0FNRV9MT1dFUlwiOmNhc2VcIlNBTUVfVVBQRVJcIjppZihuIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJEaWxhdGlvbiBub3Qgc3VwcG9ydGVkIGZvciBTQU1FX1VQUEVSIG9yIFNBTUVfTE9XRVJcIik7e2xldCB1PSgodCtyLTEpL3ItMSkqcitvLXQ7cmV0dXJuIGlbYV09TWF0aC5mbG9vcihsPT09XCJTQU1FX0xPV0VSXCI/KHUrMSkvMjp1LzIpLGlbZF09dS1pW2FdLE1hdGguZmxvb3IoKHQrdS1vKS9yKzEpfWRlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgQXV0b1BhZCB0eXBlXCIpfWVsc2UgcmV0dXJuIE1hdGguZmxvb3IoKHQraVthXStpW2RdLXApL3IrMSl9fSxWcj1jbGFzc3tzdGF0aWMgZ2V0U2hhcGVPZkdlbW1SZXN1bHQodCxyLG4sbyxpKXtpZih0Lmxlbmd0aCE9PTJ8fG4ubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJzaGFwZSBuZWVkIHRvIGJlIG9mIHNpemUgMlwiKTtsZXQgYSxkLGw7cj8oYT10WzFdLGQ9dFswXSk6KGE9dFswXSxkPXRbMV0pO2xldCBwPS0xO2lmKG8/KGw9blswXSxwPTEpOihsPW5bMV0scD0wKSxuW3BdIT09ZCl0aHJvdyBuZXcgRXJyb3IoXCJkaW1lbnNpb24gbWlzbWF0Y2hcIik7aWYoYTw9MHx8bDw9MHx8ZDw9MCl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNoYXBlIHNwZWNpZmllZFwiKTtpZihpJiYhdHQuaXNWYWxpZEJyb2FkY2FzdChpLFthLGxdKSl0aHJvdyBuZXcgRXJyb3IoXCJnZW1tOiBpbnZhbGlkIGJpYXMgc2hhcGUgZm9yIGJyb2FkY2FzdFwiKTtyZXR1cm5bYSxsLGRdfX0sZXM9LTM0MDI4MjM0NjYzODUyODg2ZTIyLHRzPTM0MDI4MjM0NjYzODUyODg2ZTIyfSk7dmFyIGt0LHNvLF9lLEVlLE4sbWUsdW8sRXQsRmUsRixXcixFLE0scnMsTHIsYW8sbnMsYWU9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTtrdD02NCxzbz0oZSx0KT0+e2lmKHQ9PT0zKXRocm93IG5ldyBFcnJvcihcInZlYzMgaGFzIHNhbWUgYWxpZ25tZW50IGFzIHZlYzQsIHVzZSB2ZWM0IGluc3RlYWRcIik7c3dpdGNoKE51bWJlcihlKSl7Y2FzZSAxMDpyZXR1cm4gdD4xP2B2ZWMke3R9PGYxNj5gOlwiZjE2XCI7Y2FzZSAxOnJldHVybiB0PjE/YHZlYyR7dH08ZjMyPmA6XCJmMzJcIjtjYXNlIDY6cmV0dXJuIHQ+MT9gdmVjJHt0fTxpMzI+YDpcImkzMlwiO2Nhc2UgMTI6cmV0dXJuIHQ+MT9gdmVjJHt0fTx1MzI+YDpcInUzMlwiO2Nhc2UgNzppZih0PjEpdGhyb3cgbmV3IEVycm9yKFwiY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQgdmVjWCBvZiB1aW50NjQgeWV0XCIpO3JldHVybltcInZlYzI8dTMyPlwiLFwiaTMyXCJdO2Nhc2UgMTM6aWYodD4xKXRocm93IG5ldyBFcnJvcihcImN1cnJlbnRseSBub3Qgc3VwcG9ydGVkIHZlY1ggb2YgdWludDY0IHlldFwiKTtyZXR1cm5bXCJ2ZWMyPHUzMj5cIixcInUzMlwiXTtjYXNlIDk6aWYodCE9PTQpdGhyb3cgbmV3IEVycm9yKFwiYm9vbCBtdXN0IGJlIHZlYzRcIik7cmV0dXJuW1widTMyXCIsXCJ2ZWM0PGJvb2w+XCJdO2Nhc2UgMjI6cmV0dXJuXCJpMzJcIjtjYXNlIDIxOnJldHVyblwidTMyXCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZGF0YSB0eXBlOiAke2V9YCl9fSxfZT0oZSx0PTEpPT57bGV0IHI9c28oZSx0KTtyZXR1cm4gdHlwZW9mIHI9PVwic3RyaW5nXCI/cjpyWzBdfSxFZT0oZSx0PTEpPT57bGV0IHI9c28oZSx0KTtyZXR1cm4gdHlwZW9mIHI9PVwic3RyaW5nXCI/cjpyWzFdfSxOPSguLi5lKT0+e2xldCB0PVtdO3JldHVybiBlLmZvckVhY2gocj0+e3IubGVuZ3RoIT09MCYmdC5wdXNoKHt0eXBlOjEyLGRhdGE6cn0se3R5cGU6MTIsZGF0YTpDLmNvbXB1dGVTdHJpZGVzKHIpfSl9KSx0fSxtZT1lPT5lJTQ9PT0wPzQ6ZSUyPT09MD8yOjEsdW89KGU9XCJmMzJcIix0LHI9XCIwXCIpPT4hdHx8dD09PTE/YCR7ZX0oJHtyfSlgOmB2ZWMke3R9PCR7ZX0+KCR7cn0pYCxFdD0oZSx0LHIpPT5lPT09XCJmMzJcIj9yOnQ9PT0xP2BmMzIoJHtyfSlgOmB2ZWMke3R9PGYzMj4oJHtyfSlgLEZlPShlLHQpPT50PT09ND9gKCR7ZX0ueCArICR7ZX0ueSArICR7ZX0ueiArICR7ZX0udylgOnQ9PT0yP2AoJHtlfS54ICsgJHtlfS55KWA6dD09PTM/YCgke2V9LnggKyAke2V9LnkgKyAke2V9LnopYDplLEY9KGUsdCxyLG4pPT5lLnN0YXJ0c1dpdGgoXCJ1bmlmb3Jtcy5cIikmJnI+ND90eXBlb2YgdD09XCJzdHJpbmdcIj9uPT09XCJmMTZcIj9gJHtlfVsoJHt0fSkgLyA4XVsoJHt0fSkgJSA4IC8gNF1bKCR7dH0pICUgOCAlIDRdYDpgJHtlfVsoJHt0fSkgLyA0XVsoJHt0fSkgJSA0XWA6bj09PVwiZjE2XCI/YCR7ZX1bJHtNYXRoLmZsb29yKHQvOCl9XVske01hdGguZmxvb3IodCU4LzQpfV1bJHt0JTglNH1dYDpgJHtlfVske01hdGguZmxvb3IodC80KX1dWyR7dCU0fV1gOnI+MT9gJHtlfVske3R9XWA6ZSxXcj0oZSx0LHIsbixvKT0+e2xldCBpPXR5cGVvZiByPT1cIm51bWJlclwiLGE9aT9yOnIubGVuZ3RoLGQ9Wy4uLm5ldyBBcnJheShhKS5rZXlzKCldLGw9YTwyP1widTMyXCI6YTw9ND9gdmVjJHthfTx1MzI+YDpgYXJyYXk8dTMyLCAke2F9PmAscD1zbyh0LG8pLG09dHlwZW9mIHA9PVwic3RyaW5nXCI/cDpwWzFdLHU9dHlwZW9mIHA9PVwic3RyaW5nXCI/cDpwWzBdLGg9e2luZGljZXM6bCx2YWx1ZTptLHN0b3JhZ2U6dSx0ZW5zb3I6dH0sXz1XPT50eXBlb2YgVz09XCJzdHJpbmdcIj9XOmAke1d9dWAseT17b2Zmc2V0VG9JbmRpY2VzOiExLGluZGljZXNUb09mZnNldDohMSxicm9hZGNhc3RlZEluZGljZXNUb09mZnNldDohMSxzZXQ6ITEsc2V0QnlJbmRpY2VzOiExLGdldDohMSxnZXRCeUluZGljZXM6ITF9LGc9aT9cInVuaWZvcm1zLlwiOlwiXCIseD1gJHtnfSR7ZX1fc2hhcGVgLCQ9YCR7Z30ke2V9X3N0cmlkZXNgLHY9XCJcIjtmb3IobGV0IFc9MDtXPGEtMTtXKyspdis9YFxuICAgIGxldCBkaW0ke1d9ID0gY3VycmVudCAvICR7RigkLFcsYSl9O1xuICAgIGxldCByZXN0JHtXfSA9IGN1cnJlbnQgJSAke0YoJCxXLGEpfTtcbiAgICBpbmRpY2VzWyR7V31dID0gZGltJHtXfTtcbiAgICBjdXJyZW50ID0gcmVzdCR7V307XG4gICAgYDt2Kz1gaW5kaWNlc1ske2EtMX1dID0gY3VycmVudDtgO2xldCBTPWE8Mj9cIlwiOmBcbiAgZm4gbzJpXyR7ZX0ob2Zmc2V0OiB1MzIpIC0+ICR7aC5pbmRpY2VzfSB7XG4gICAgdmFyIGluZGljZXM6ICR7aC5pbmRpY2VzfTtcbiAgICB2YXIgY3VycmVudCA9IG9mZnNldDtcbiAgICAke3Z9XG4gICAgcmV0dXJuIGluZGljZXM7XG4gIH1gLFQ9Vz0+KHkub2Zmc2V0VG9JbmRpY2VzPSEwLGE8Mj9XOmBvMmlfJHtlfSgke1d9KWApLEE9W107aWYoYT49Milmb3IobGV0IFc9YS0xO1c+PTA7Vy0tKUEucHVzaChgJHtGKCQsVyxhKX0gKiAoaW5kaWNlc1ske1d9XSlgKTtsZXQgaz1hPDI/XCJcIjpgXG4gIGZuIGkyb18ke2V9KGluZGljZXM6ICR7aC5pbmRpY2VzfSkgLT4gdTMyIHtcbiAgICByZXR1cm4gJHtBLmpvaW4oXCIrXCIpfTtcbiAgfWAsUD1XPT4oeS5pbmRpY2VzVG9PZmZzZXQ9ITAsYTwyP1c6YGkyb18ke2V9KCR7V30pYCksRD0oLi4uVyk9PmE9PT0wP1wiMHVcIjpgJHtoLmluZGljZXN9KCR7Vy5tYXAoXykuam9pbihcIixcIil9KWAsUj0oVyxxKT0+YTwyP2Ake1d9YDpgJHtGKFcscSxhKX1gLEc9KFcscSxoZSk9PmE8Mj9gJHtXfT0ke2hlfTtgOmAke0YoVyxxLGEpfT0ke2hlfTtgLEs9e30saj0oVyxxKT0+e3kuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQ9ITA7bGV0IGhlPWAke3EubmFtZX1icm9hZGNhc3RlZEluZGljZXNUbyR7ZX1PZmZzZXRgO2lmKGhlIGluIEspcmV0dXJuYCR7aGV9KCR7V30pYDtsZXQgR2U9W107Zm9yKGxldCB3ZT1hLTE7d2U+PTA7d2UtLSl7bGV0IHllPXEuaW5kaWNlc0dldChcIm91dHB1dEluZGljZXNcIix3ZStxLnJhbmstYSk7R2UucHVzaChgJHtSKCQsd2UpfSAqICgke3llfSAlICR7Uih4LHdlKX0pYCl9cmV0dXJuIEtbaGVdPWBmbiAke2hlfShvdXRwdXRJbmRpY2VzOiAke3EudHlwZS5pbmRpY2VzfSkgLT4gdTMyIHtcbiAgICAgICAgICAgICByZXR1cm4gJHtHZS5sZW5ndGg+MD9HZS5qb2luKFwiK1wiKTpcIjB1XCJ9O1xuICAgICAgICAgICB9YCxgJHtoZX0oJHtXfSlgfSxWPShXLHEpPT4oKCk9PntpZihoLnN0b3JhZ2U9PT1oLnZhbHVlKXJldHVybmAke2V9WyR7V31dPSR7cX07YDtpZihoLnN0b3JhZ2U9PT1cInZlYzI8dTMyPlwiJiZoLnZhbHVlPT09XCJpMzJcIilyZXR1cm5gJHtlfVske1d9XT12ZWMyPHUzMj4odTMyKCR7cX0pLCBzZWxlY3QoMHUsIDB4RkZGRkZGRkZ1LCAke3F9IDwgMCkpO2A7aWYoaC5zdG9yYWdlPT09XCJ2ZWMyPHUzMj5cIiYmaC52YWx1ZT09PVwidTMyXCIpcmV0dXJuYCR7ZX1bJHtXfV09dmVjMjx1MzI+KHUzMigke3F9KSwgMHUpO2A7aWYoaC5zdG9yYWdlPT09XCJ1MzJcIiYmaC52YWx1ZT09PVwidmVjNDxib29sPlwiKXJldHVybmAke2V9WyR7V31dPWRvdCh2ZWM0PHUzMj4oMHgxLCAweDEwMCwgMHgxMDAwMCwgMHgxMDAwMDAwKSwgdmVjNDx1MzI+KCR7cX0pKTtgO3Rocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBjb21iaW5hdGlvbiBvZiBzdG9yYWdlIHR5cGUgJHtoLnN0b3JhZ2V9IGFuZCB2YWx1ZSB0eXBlICR7aC52YWx1ZX0geWV0YCl9KSgpLFE9Vz0+KCgpPT57aWYoaC5zdG9yYWdlPT09aC52YWx1ZSlyZXR1cm5gJHtlfVske1d9XWA7aWYoaC5zdG9yYWdlPT09XCJ2ZWMyPHUzMj5cIiYmaC52YWx1ZT09PVwiaTMyXCIpcmV0dXJuYGkzMigke2V9WyR7V31dLngpYDtpZihoLnN0b3JhZ2U9PT1cInZlYzI8dTMyPlwiJiZoLnZhbHVlPT09XCJ1MzJcIilyZXR1cm5gdTMyKCR7ZX1bJHtXfV0ueClgO2lmKGguc3RvcmFnZT09PVwidTMyXCImJmgudmFsdWU9PT1cInZlYzQ8Ym9vbD5cIilyZXR1cm5gdmVjNDxib29sPihib29sKCR7ZX1bJHtXfV0gJiAweEZGdSksIGJvb2woJHtlfVske1d9XSAmIDB4RkYwMHUpLCBib29sKCR7ZX1bJHtXfV0gJiAweEZGMDAwMHUpLCBib29sKCR7ZX1bJHtXfV0gJiAweEZGMDAwMDAwdSkpYDt0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgY29tYmluYXRpb24gb2Ygc3RvcmFnZSB0eXBlICR7aC5zdG9yYWdlfSBhbmQgdmFsdWUgdHlwZSAke2gudmFsdWV9IHlldGApfSkoKSxzZT1hPDI/XCJcIjpgXG4gIGZuIGdldF8ke2V9QnlJbmRpY2VzKGluZGljZXM6ICR7aC5pbmRpY2VzfSkgLT4gJHttfSB7XG4gICAgcmV0dXJuICR7UShgaTJvXyR7ZX0oaW5kaWNlcylgKX07XG4gIH1gLFk9YTwyP1wiXCI6KCgpPT57bGV0IFc9ZC5tYXAoaGU9PmBkJHtoZX06IHUzMmApLmpvaW4oXCIsIFwiKSxxPWQubWFwKGhlPT5gZCR7aGV9YCkuam9pbihcIiwgXCIpO3JldHVybmBcbiAgZm4gZ2V0XyR7ZX0oJHtXfSkgLT4gJHttfSB7XG4gICAgcmV0dXJuIGdldF8ke2V9QnlJbmRpY2VzKCR7RChxKX0pO1xuICB9YH0pKCksZWU9KC4uLlcpPT57aWYoVy5sZW5ndGghPT1hKXRocm93IG5ldyBFcnJvcihgaW5kaWNlcyBsZW5ndGggbXVzdCBiZSAke2F9YCk7bGV0IHE9Vy5tYXAoXykuam9pbihcIixcIik7cmV0dXJuIGE9PT0wP1EoXCIwdVwiKTphPT09MT9RKHFbMF0pOih5LmdldD0hMCx5LmdldEJ5SW5kaWNlcz0hMCx5LmluZGljZXNUb09mZnNldD0hMCxgZ2V0XyR7ZX0oJHtxfSlgKX0sSj1XPT5hPDI/UShXKTooeS5nZXRCeUluZGljZXM9ITAseS5pbmRpY2VzVG9PZmZzZXQ9ITAsYGdldF8ke2V9QnlJbmRpY2VzKCR7V30pYCksbmU9YTwyP1wiXCI6YFxuICBmbiBzZXRfJHtlfUJ5SW5kaWNlcyhpbmRpY2VzOiAke2guaW5kaWNlc30sIHZhbHVlOiAke219KSB7XG4gICAgJHtWKGBpMm9fJHtlfShpbmRpY2VzKWAsXCJ2YWx1ZVwiKX1cbiAgfWAsYmU9YTwyP1wiXCI6KCgpPT57bGV0IFc9ZC5tYXAoaGU9PmBkJHtoZX06IHUzMmApLmpvaW4oXCIsIFwiKSxxPWQubWFwKGhlPT5gZCR7aGV9YCkuam9pbihcIiwgXCIpO3JldHVybmBcbiAgZm4gc2V0XyR7ZX0oJHtXfSwgdmFsdWU6ICR7bX0pIHtcbiAgICBzZXRfJHtlfUJ5SW5kaWNlcygke0QocSl9LCB2YWx1ZSk7XG4gIH1gfSkoKTtyZXR1cm57aW1wbDooKT0+e2xldCBXPVtdLHE9ITE7cmV0dXJuIHkub2Zmc2V0VG9JbmRpY2VzJiYoVy5wdXNoKFMpLHE9ITApLHkuaW5kaWNlc1RvT2Zmc2V0JiYoVy5wdXNoKGspLHE9ITApLHkuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQmJihPYmplY3QudmFsdWVzKEspLmZvckVhY2goaGU9PlcucHVzaChoZSkpLHE9ITApLHkuc2V0JiYoVy5wdXNoKGJlKSxxPSEwKSx5LnNldEJ5SW5kaWNlcyYmKFcucHVzaChuZSkscT0hMCkseS5nZXQmJihXLnB1c2goWSkscT0hMCkseS5nZXRCeUluZGljZXMmJihXLnB1c2goc2UpLHE9ITApLCFpJiZxJiZXLnVuc2hpZnQoYGNvbnN0ICR7eH0gPSAke2guaW5kaWNlc30oJHtyLmpvaW4oXCIsXCIpfSk7YCxgY29uc3QgJHskfSA9ICR7aC5pbmRpY2VzfSgke0MuY29tcHV0ZVN0cmlkZXMocikuam9pbihcIixcIil9KTtgKSxXLmpvaW4oYFxuYCl9LHR5cGU6aCxvZmZzZXRUb0luZGljZXM6VCxpbmRpY2VzVG9PZmZzZXQ6UCxicm9hZGNhc3RlZEluZGljZXNUb09mZnNldDpqLGluZGljZXM6RCxpbmRpY2VzR2V0OlIsaW5kaWNlc1NldDpHLHNldDooLi4uVyk9PntpZihXLmxlbmd0aCE9PWErMSl0aHJvdyBuZXcgRXJyb3IoYGluZGljZXMgbGVuZ3RoIG11c3QgYmUgJHthfWApO2xldCBxPVdbYV07aWYodHlwZW9mIHEhPVwic3RyaW5nXCIpdGhyb3cgbmV3IEVycm9yKFwidmFsdWUgbXVzdCBiZSBzdHJpbmdcIik7bGV0IGhlPVcuc2xpY2UoMCxhKS5tYXAoXykuam9pbihcIixcIik7cmV0dXJuIGE9PT0wP1YoXCIwdVwiLHEpOmE9PT0xP1YoaGVbMF0scSk6KHkuc2V0PSEwLHkuc2V0QnlJbmRpY2VzPSEwLHkuaW5kaWNlc1RvT2Zmc2V0PSEwLGBzZXRfJHtlfSgke2hlfSwgJHtxfSlgKX0sc2V0QnlPZmZzZXQ6VixzZXRCeUluZGljZXM6KFcscSk9PmE8Mj9WKFcscSk6KHkuc2V0QnlJbmRpY2VzPSEwLHkuaW5kaWNlc1RvT2Zmc2V0PSEwLGBzZXRfJHtlfUJ5SW5kaWNlcygke1d9LCAke3F9KTtgKSxnZXQ6ZWUsZ2V0QnlPZmZzZXQ6USxnZXRCeUluZGljZXM6Six1c2FnZTpuLG5hbWU6ZSxzdHJpZGVzOiQsc2hhcGU6eCxyYW5rOmF9fSxFPShlLHQscixuPTEpPT5XcihlLHQscixcImlucHV0XCIsbiksTT0oZSx0LHIsbj0xKT0+V3IoZSx0LHIsXCJvdXRwdXRcIixuKSxycz0oZSx0LHIpPT5XcihlLHQscixcImF0b21pY091dHB1dFwiLDEpLExyPShlLHQscixuPTEpPT5XcihlLHQscixcImludGVybmFsXCIsbiksYW89Y2xhc3N7Y29uc3RydWN0b3IodCxyKXt0aGlzLm5vcm1hbGl6ZWREaXNwYXRjaEdyb3VwPXQ7dGhpcy5saW1pdHM9cjt0aGlzLmludGVybmFsVmFyaWFibGVzPVtdO3RoaXMudmFyaWFibGVzPVtdO3RoaXMudW5pZm9ybXM9W107dGhpcy52YXJpYWJsZUluZGV4PTB9Z3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyh0KXtyZXR1cm5gaWYgKGdsb2JhbF9pZHggPj0gJHt0eXBlb2YgdD09XCJudW1iZXJcIj9gJHt0fXVgOnR9KSB7IHJldHVybjsgfWB9bWFpblN0YXJ0KHQ9a3Qpe2xldCByPXR5cGVvZiB0PT1cIm51bWJlclwiP3Q6dFswXSxuPXR5cGVvZiB0PT1cIm51bWJlclwiPzE6dFsxXSxvPXR5cGVvZiB0PT1cIm51bWJlclwiPzE6dFsyXTtpZihyPnRoaXMubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWHx8bj50aGlzLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVl8fG8+dGhpcy5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVaKXRocm93IG5ldyBFcnJvcihgd29ya2dyb3VwIHNpemUgWyR7cn0sICR7bn0sICR7b31dIGV4Y2VlZHMgdGhlIG1heGltdW0gd29ya2dyb3VwIHNpemUgWyR7dGhpcy5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVYfSwgJHt0aGlzLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVl9LCAke3RoaXMubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWn1dLmApO2lmKHIqbipvPnRoaXMubGltaXRzLm1heENvbXB1dGVJbnZvY2F0aW9uc1Blcldvcmtncm91cCl0aHJvdyBuZXcgRXJyb3IoYHdvcmtncm91cCBzaXplIFske3J9LCAke259LCAke299XSBleGNlZWRzIHRoZSBtYXhpbXVtIHdvcmtncm91cCBpbnZvY2F0aW9ucyAke3RoaXMubGltaXRzLm1heENvbXB1dGVJbnZvY2F0aW9uc1Blcldvcmtncm91cH0uYCk7bGV0IGk9dGhpcy5ub3JtYWxpemVkRGlzcGF0Y2hHcm91cFsxXT09PTEmJnRoaXMubm9ybWFsaXplZERpc3BhdGNoR3JvdXBbMl09PT0xLGE9aT9gQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIGdsb2JhbF9pZCA6IHZlYzM8dTMyPixcbiAgICBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cF9pZCA6IHZlYzM8dTMyPixcbiAgICBAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2luZGV4KSBsb2NhbF9pZHggOiB1MzIsXG4gICAgQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pZCkgbG9jYWxfaWQgOiB2ZWMzPHUzMj5gOmBAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsX2lkIDogdmVjMzx1MzI+LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pZCkgbG9jYWxfaWQgOiB2ZWMzPHUzMj4sXG4gICAgQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pbmRleCkgbG9jYWxfaWR4IDogdTMyLFxuICAgIEBidWlsdGluKHdvcmtncm91cF9pZCkgd29ya2dyb3VwX2lkIDogdmVjMzx1MzI+LFxuICAgIEBidWlsdGluKG51bV93b3JrZ3JvdXBzKSBudW1fd29ya2dyb3VwcyA6IHZlYzM8dTMyPmAsZD1pP2BsZXQgZ2xvYmFsX2lkeCA9IGdsb2JhbF9pZC54O1xuICAgICAgICAgbGV0IHdvcmtncm91cF9pbmRleCA9IHdvcmtncm91cF9pZC54O2A6YGxldCB3b3JrZ3JvdXBfaW5kZXggPSB3b3JrZ3JvdXBfaWQueiAqIG51bV93b3JrZ3JvdXBzWzBdICogbnVtX3dvcmtncm91cHNbMV0gK1xuICAgICAgICAgICAgIHdvcmtncm91cF9pZC55ICogbnVtX3dvcmtncm91cHNbMF0gKyB3b3JrZ3JvdXBfaWQueDtcbiAgICAgICAgIGxldCBnbG9iYWxfaWR4ID0gd29ya2dyb3VwX2luZGV4ICogJHtyKm4qb311ICsgbG9jYWxfaWR4O2A7cmV0dXJuYEBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSgke3J9LCAke259LCAke299KVxuICBmbiBtYWluKCR7YX0pIHtcbiAgICAke2R9XG4gIGB9YXBwZW5kVmFyaWFibGVVbmlmb3Jtcyh0KXt0LnJhbmshPT0wJiYodC5zaGFwZS5zdGFydHNXaXRoKFwidW5pZm9ybXMuXCIpJiZ0aGlzLnVuaWZvcm1zLnB1c2goe25hbWU6dC5zaGFwZS5yZXBsYWNlKFwidW5pZm9ybXMuXCIsXCJcIiksdHlwZTpcInUzMlwiLGxlbmd0aDp0LnJhbmt9KSx0LnN0cmlkZXMuc3RhcnRzV2l0aChcInVuaWZvcm1zLlwiKSYmdGhpcy51bmlmb3Jtcy5wdXNoKHtuYW1lOnQuc3RyaWRlcy5yZXBsYWNlKFwidW5pZm9ybXMuXCIsXCJcIiksdHlwZTpcInUzMlwiLGxlbmd0aDp0LnJhbmt9KSl9ZGVjbGFyZVZhcmlhYmxlKHQscil7aWYodC51c2FnZT09PVwiaW50ZXJuYWxcIil0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgdXNlIGludGVybmFsIHZhcmlhYmxlIHdpdGggZGVjbGFyZVZhcmlhYmxlKCkuIHVzZSByZWdpc3RlckludGVybmFsVmFyaWFibGVzKCkgaW5zdGVhZC5cIik7dGhpcy52YXJpYWJsZXMucHVzaCh0KSx0aGlzLmFwcGVuZFZhcmlhYmxlVW5pZm9ybXModCk7bGV0IG49dC51c2FnZT09PVwiaW5wdXRcIj9cInJlYWRcIjpcInJlYWRfd3JpdGVcIixvPXQudXNhZ2U9PT1cImF0b21pY091dHB1dFwiP1wiYXRvbWljPGkzMj5cIjp0LnR5cGUuc3RvcmFnZTtyZXR1cm5gQGdyb3VwKDApIEBiaW5kaW5nKCR7cn0pIHZhcjxzdG9yYWdlLCAke259PiAke3QubmFtZX06IGFycmF5PCR7b30+O2B9ZGVjbGFyZVZhcmlhYmxlcyguLi50KXtyZXR1cm4gdC5tYXAocj0+dGhpcy5kZWNsYXJlVmFyaWFibGUocix0aGlzLnZhcmlhYmxlSW5kZXgrKykpLmpvaW4oYFxuYCl9cmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlKHQpe2lmKHQudXNhZ2UhPT1cImludGVybmFsXCIpdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IHVzZSBpbnB1dCBvciBvdXRwdXQgdmFyaWFibGUgd2l0aCByZWdpc3RlckludGVybmFsVmFyaWFibGUoKS4gdXNlIGRlY2xhcmVWYXJpYWJsZXMoKSBpbnN0ZWFkLlwiKTt0aGlzLmludGVybmFsVmFyaWFibGVzLnB1c2godCksdGhpcy5hcHBlbmRWYXJpYWJsZVVuaWZvcm1zKHQpfXJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZXMoLi4udCl7cmV0dXJuIHQuZm9yRWFjaChyPT50aGlzLnJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZShyKSksdGhpc31yZWdpc3RlclVuaWZvcm0odCxyLG49MSl7cmV0dXJuIHRoaXMudW5pZm9ybXMucHVzaCh7bmFtZTp0LHR5cGU6cixsZW5ndGg6bn0pLHRoaXN9cmVnaXN0ZXJVbmlmb3Jtcyh0KXtyZXR1cm4gdGhpcy51bmlmb3Jtcz10aGlzLnVuaWZvcm1zLmNvbmNhdCh0KSx0aGlzfXVuaWZvcm1EZWNsYXJhdGlvbigpe2lmKHRoaXMudW5pZm9ybXMubGVuZ3RoPT09MClyZXR1cm5cIlwiO2xldCB0PVtdO2ZvcihsZXR7bmFtZTpyLHR5cGU6bixsZW5ndGg6b31vZiB0aGlzLnVuaWZvcm1zKWlmKG8mJm8+NCluPT09XCJmMTZcIj90LnB1c2goYEBhbGlnbigxNikgJHtyfTphcnJheTxtYXQyeDQ8JHtufT4sICR7TWF0aC5jZWlsKG8vOCl9PmApOnQucHVzaChgJHtyfTphcnJheTx2ZWM0PCR7bn0+LCAke01hdGguY2VpbChvLzQpfT5gKTtlbHNle2xldCBpPW89PW51bGx8fG89PT0xP246YHZlYyR7b308JHtufT5gO3QucHVzaChgJHtyfToke2l9YCl9cmV0dXJuYFxuICAgICAgc3RydWN0IFVuaWZvcm1zIHsgJHt0LmpvaW4oXCIsIFwiKX0gfTtcbiAgICAgIEBncm91cCgwKSBAYmluZGluZygke3RoaXMudmFyaWFibGVJbmRleH0pIHZhcjx1bmlmb3JtPiB1bmlmb3JtczogVW5pZm9ybXM7YH1nZXQgYWRkaXRpb25hbEltcGxlbWVudGF0aW9ucygpe3JldHVybiB0aGlzLnVuaWZvcm1EZWNsYXJhdGlvbigpK3RoaXMudmFyaWFibGVzLm1hcCh0PT50LmltcGwoKSkuam9pbihgXG5gKSt0aGlzLmludGVybmFsVmFyaWFibGVzLm1hcCh0PT50LmltcGwoKSkuam9pbihgXG5gKX1nZXQgdmFyaWFibGVzSW5mbygpe2lmKHRoaXMudW5pZm9ybXMubGVuZ3RoPT09MClyZXR1cm47bGV0IHQ9cj0+WzEyLDEwLDEsNl1bW1widTMyXCIsXCJmMTZcIixcImYzMlwiLFwiaTMyXCJdLmluZGV4T2YocildO3JldHVybiB0aGlzLnVuaWZvcm1zLm1hcChyPT5bdChyLnR5cGUpLHIubGVuZ3RoPz8xXSl9fSxucz0oZSx0KT0+bmV3IGFvKGUsdCl9KTt2YXIgZG0sb3MsbG0sY20scG0sbW0sUGUsaXMsYXMsZHQ9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTtTZSgpO2FlKCk7ZG09KGUsdCk9PntpZighZXx8ZS5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIlRyYW5zcG9zZSByZXF1aXJlcyAxIGlucHV0LlwiKTtpZih0Lmxlbmd0aCE9PTAmJnQubGVuZ3RoIT09ZVswXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYHBlcm0gc2l6ZSAke3QubGVuZ3RofSBkb2VzIG5vdCBtYXRjaCBpbnB1dCByYW5rICR7ZVswXS5kaW1zLmxlbmd0aH1gKX0sb3M9KGUsdCk9PnQubGVuZ3RoIT09MD90OlsuLi5uZXcgQXJyYXkoZSkua2V5cygpXS5yZXZlcnNlKCksbG09KGUsdCk9PkMuc29ydEJhc2VkT25QZXJtKGUsb3MoZS5sZW5ndGgsdCkpLGNtPShlLHQscixuKT0+e2xldCBvPWBmbiBwZXJtKGk6ICR7bi50eXBlLmluZGljZXN9KSAtPiAke3IudHlwZS5pbmRpY2VzfSB7XG4gICAgdmFyIGE6ICR7ci50eXBlLmluZGljZXN9O2A7Zm9yKGxldCBpPTA7aTx0OysraSlvKz1gYVske2VbaV19XT1pWyR7aX1dO2A7cmV0dXJuIG8rPVwicmV0dXJuIGE7fVwifSxwbT0oZSx0KT0+e2xldCByPVtdLG49W107Zm9yKGxldCBvPTA7bzxlLmxlbmd0aDsrK28pZVtvXSE9PTEmJnIucHVzaChlW29dKSxlW3Rbb11dIT09MSYmbi5wdXNoKHRbb10pO3JldHVybntuZXdTaGFwZTpyLG5ld1Blcm06bn19LG1tPShlLHQpPT57bGV0IHI9MDtmb3IobGV0IG49MDtuPGUubGVuZ3RoOysrbilpZih0W2Vbbl1dIT09MSl7aWYoZVtuXTxyKXJldHVybiExO3I9ZVtuXX1yZXR1cm4hMH0sUGU9KGUsdCk9PntsZXQgcj1lLmRhdGFUeXBlLG49ZS5kaW1zLmxlbmd0aCxvPW9zKG4sdCksaT1sbShlLmRpbXMsbyksYT1lLmRpbXMsZD1pLGw9bjwyfHxtbShvLGUuZGltcykscDtpZihsKXJldHVybiBwPWc9PntsZXQgeD1FKFwiaW5wdXRcIixyLGEsNCksJD1NKFwib3V0cHV0XCIscixkLDQpO3JldHVybmBcbiAgJHtnLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dF9zaXplXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyh4LCQpfVxuICAke2cubWFpblN0YXJ0KCl9XG4gICAgJHtnLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSBpbnB1dFtnbG9iYWxfaWR4XTtcbiAgfWB9LHtuYW1lOlwiVHJhbnNwb3NlQ29weVwiLHNoYWRlckNhY2hlOntpbnB1dERlcGVuZGVuY2llczpbXCJ0eXBlXCJdfSxnZXRSdW5EYXRhOigpPT57bGV0IGc9Qy5zaXplKGkpO3JldHVybntvdXRwdXRzOlt7ZGltczppLGRhdGFUeXBlOmUuZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChnLzY0LzQpfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjEyLGRhdGE6TWF0aC5jZWlsKGcvNCl9XX19LGdldFNoYWRlclNvdXJjZTpwfTtsZXR7bmV3U2hhcGU6bSxuZXdQZXJtOnV9PXBtKGUuZGltcyxvKSxoPUMuYXJlRXF1YWwodSxbMiwzLDFdKSxfPUMuYXJlRXF1YWwodSxbMywxLDJdKTtpZihtLmxlbmd0aD09PTJ8fGh8fF8pe2E9aD9bbVswXSxtWzFdKm1bMl1dOl8/W21bMF0qbVsxXSxtWzJdXTptLGQ9W2FbMV0sYVswXV07bGV0IGc9MTY7cmV0dXJuIHA9eD0+e2xldCAkPUUoXCJhXCIscixhLmxlbmd0aCksdj1NKFwib3V0cHV0XCIscixkLmxlbmd0aCk7cmV0dXJuYFxuICAke3gucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0X3NpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKCQsdil9XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGUgOiBhcnJheTxhcnJheTwke3YudHlwZS52YWx1ZX0sICR7ZysxfT4sICR7Z30+O1xuICAke3gubWFpblN0YXJ0KFtnLGcsMV0pfVxuICAgIGxldCBzdHJpZGUgPSAodW5pZm9ybXMub3V0cHV0X3NoYXBlWzFdIC0gMSkgLyAke2d9ICsgMTtcbiAgICBsZXQgd29ya2dyb3VwX2lkX3ggPSB3b3JrZ3JvdXBfaW5kZXggJSBzdHJpZGU7XG4gICAgbGV0IHdvcmtncm91cF9pZF95ID0gd29ya2dyb3VwX2luZGV4IC8gc3RyaWRlO1xuICAgIGxldCBpbnB1dF9jb2wgPSB3b3JrZ3JvdXBfaWRfeSAqICR7Z311ICsgbG9jYWxfaWQueDtcbiAgICBsZXQgaW5wdXRfcm93ID0gd29ya2dyb3VwX2lkX3ggKiAke2d9dSArIGxvY2FsX2lkLnk7XG4gICAgaWYgKGlucHV0X3JvdyA8IHVuaWZvcm1zLmFfc2hhcGVbMF0gJiYgaW5wdXRfY29sIDwgdW5pZm9ybXMuYV9zaGFwZVsxXSkge1xuICAgICAgdGlsZVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9ICR7JC5nZXRCeUluZGljZXMoYCR7JC50eXBlLmluZGljZXN9KGlucHV0X3JvdywgaW5wdXRfY29sKWApfTtcbiAgICB9XG4gICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgbGV0IG91dHB1dF9jb2wgPSB3b3JrZ3JvdXBfaWRfeCAqICR7Z311ICsgbG9jYWxfaWQueDtcbiAgICBsZXQgb3V0cHV0X3JvdyA9IHdvcmtncm91cF9pZF95ICogJHtnfXUgKyBsb2NhbF9pZC55O1xuICAgIGlmIChvdXRwdXRfcm93IDwgdW5pZm9ybXMub3V0cHV0X3NoYXBlWzBdICYmIG91dHB1dF9jb2wgPCB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMV0pIHtcbiAgICAgICR7di5zZXRCeUluZGljZXMoYCR7di50eXBlLmluZGljZXN9KG91dHB1dF9yb3csIG91dHB1dF9jb2wpYCxcInRpbGVbbG9jYWxfaWQueF1bbG9jYWxfaWQueV1cIil9XG4gICAgfVxuICB9YH0se25hbWU6XCJUcmFuc3Bvc2VTaGFyZWRcIixzaGFkZXJDYWNoZTp7aW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiXX0sZ2V0UnVuRGF0YTooKT0+e2xldCB4PUMuc2l6ZShpKTtyZXR1cm57b3V0cHV0czpbe2RpbXM6aSxkYXRhVHlwZTplLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoZFsxXS9nKSx5Ok1hdGguY2VpbChkWzBdL2cpfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjEyLGRhdGE6eH0sLi4uTihhLGQpXX19LGdldFNoYWRlclNvdXJjZTpwfX1yZXR1cm4gcD1nPT57bGV0IHg9RShcImFcIixyLGEubGVuZ3RoKSwkPU0oXCJvdXRwdXRcIixyLGQubGVuZ3RoKTtyZXR1cm5gXG4gICR7Zy5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoeCwkKX1cblxuICAke2NtKG8sbix4LCQpfVxuXG4gICR7Zy5tYWluU3RhcnQoKX1cbiAgICAke2cuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuXG4gICAgbGV0IGluZGljZXMgPSAkeyQub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgbGV0IGFJbmRpY2VzID0gcGVybShpbmRpY2VzKTtcblxuICAgICR7JC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIix4LmdldEJ5SW5kaWNlcyhcImFJbmRpY2VzXCIpKX1cbiAgfWB9LHtuYW1lOlwiVHJhbnNwb3NlXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dH1gLGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LGdldFJ1bkRhdGE6KCk9PntsZXQgZz1DLnNpemUoaSk7cmV0dXJue291dHB1dHM6W3tkaW1zOmksZGF0YVR5cGU6ZS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGcvNjQpfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjEyLGRhdGE6Z30sLi4uTihhLGQpXX19LGdldFNoYWRlclNvdXJjZTpwfX0saXM9KGUsdCk9PntkbShlLmlucHV0cyx0LnBlcm0pLGUuY29tcHV0ZShQZShlLmlucHV0c1swXSx0LnBlcm0pKX0sYXM9ZT0+cmUoe3Blcm06ZS5wZXJtfSl9KTt2YXIgZm0saG0sZ20sYm0seW0sX20sd20sdm0sJG0seG0scnQsc3MsdXMsZHMsbHMsY3MscHMsbXMsZnMsaHMsZ3MsYnM9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTthZSgpO0dyKCk7ZHQoKTtmbT17bWF4Olwic2VsZWN0KGJlc3RWYWx1ZSwgY2FuZGlkYXRlLCBjYW5kaWRhdGUgPiBiZXN0VmFsdWUpXCIsbWluOlwic2VsZWN0KGJlc3RWYWx1ZSwgY2FuZGlkYXRlLCBjYW5kaWRhdGUgPCBiZXN0VmFsdWUpXCIsbWVhbjpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLHN1bTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLHByb2Q6XCJiZXN0VmFsdWUgKiBjYW5kaWRhdGVcIixzdW1TcXVhcmU6XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGUgKiBjYW5kaWRhdGVcIixsb2dTdW1FeHA6XCJiZXN0VmFsdWUgKyBleHAoY2FuZGlkYXRlKVwiLGwxOlwiYmVzdFZhbHVlICsgYWJzKGNhbmRpZGF0ZSlcIixsMjpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZSAqIGNhbmRpZGF0ZVwiLGxvZ1N1bTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwifSxobT17bWF4Olwic2VsZWN0KGJlc3RWYWx1ZSwgY2FuZGlkYXRlLCBjYW5kaWRhdGUgPiBiZXN0VmFsdWUpXCIsbWluOlwic2VsZWN0KGJlc3RWYWx1ZSwgY2FuZGlkYXRlLCBjYW5kaWRhdGUgPCBiZXN0VmFsdWUpXCIsbWVhbjpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLHN1bTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLHByb2Q6XCJiZXN0VmFsdWUgKiBjYW5kaWRhdGVcIixzdW1TcXVhcmU6XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixsb2dTdW1FeHA6XCJiZXN0VmFsdWUgKyBjYW5kaWRhdGVcIixsMTpcImJlc3RWYWx1ZSArIGNhbmRpZGF0ZVwiLGwyOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCIsbG9nU3VtOlwiYmVzdFZhbHVlICsgY2FuZGlkYXRlXCJ9LGdtPXttYXg6XCJfQVtvZmZzZXRdXCIsbWluOlwiX0Fbb2Zmc2V0XVwiLG1lYW46XCIwXCIsc3VtOlwiMFwiLHByb2Q6XCIxXCIsc3VtU3F1YXJlOlwiMFwiLGxvZ1N1bUV4cDpcIjBcIixsMTpcIjBcIixsMjpcIjBcIixsb2dTdW06XCIwXCJ9LGJtPXttYXg6XCJiZXN0VmFsdWVcIixtaW46XCJiZXN0VmFsdWVcIixzdW06XCJiZXN0VmFsdWVcIixwcm9kOlwiYmVzdFZhbHVlXCIsc3VtU3F1YXJlOlwiYmVzdFZhbHVlXCIsbG9nU3VtRXhwOlwibG9nKGJlc3RWYWx1ZSlcIixsMTpcImJlc3RWYWx1ZVwiLGwyOlwic3FydChiZXN0VmFsdWUpXCIsbG9nU3VtOlwibG9nKGJlc3RWYWx1ZSlcIn0seW09KGUsdCk9PntsZXQgcj1bXTtmb3IobGV0IG49dC1lO248dDsrK24pci5wdXNoKG4pO3JldHVybiByfSxfbT0oZSx0KT0+e2xldCByPVtdLG49ZS5sZW5ndGg7Zm9yKGxldCBpPTA7aTxuO2krKyl0LmluZGV4T2YoaSk9PT0tMSYmci5wdXNoKGVbaV0pO2xldCBvPXQubWFwKGk9PmVbaV0pO3JldHVybltyLG9dfSx3bT0oZSx0KT0+e2xldCByPWUubGVuZ3RoK3QubGVuZ3RoLG49W10sbz0wO2ZvcihsZXQgaT0wO2k8cjtpKyspdC5pbmRleE9mKGkpPT09LTE/bi5wdXNoKGVbbysrXSk6bi5wdXNoKDEpO3JldHVybiBufSx2bT0oZSx0KT0+e2ZvcihsZXQgcj0wO3I8ZS5sZW5ndGg7KytyKWlmKGVbZS5sZW5ndGgtci0xXSE9PXQtMS1yKXJldHVybiExO3JldHVybiEwfSwkbT0oZSx0KT0+e2xldCByPVtdO2lmKCF2bShlLHQpKXtmb3IobGV0IG49MDtuPHQ7KytuKWUuaW5kZXhPZihuKT09PS0xJiZyLnB1c2gobik7ZS5mb3JFYWNoKG49PnIucHVzaChuKSl9cmV0dXJuIHJ9LHhtPShlLHQscixuLG8saSxhKT0+e2xldCBkPXJbMF0uZGltcyxsPUMuc2l6ZShpKSxwPUMuc2l6ZShhKSxtPUUoXCJfQVwiLHJbMF0uZGF0YVR5cGUsZCksdT1NKFwib3V0cHV0XCIsbyxpKSxoPTY0O2w9PT0xJiYoaD0yNTYpO2xldCBfPWBcbiAgICAgICAgICB2YXI8d29ya2dyb3VwPiBhQmVzdFZhbHVlcyA6IGFycmF5PGYzMiwgJHtofT47XG4gICAgICAgYCx5PWc9PmBcbiAgICAgICAgJHtnLnJlZ2lzdGVyVW5pZm9ybShcInJlZHVjZVNpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKG0sdSl9XG4gICAgICAgICR7X31cbiAgICAgICAgZm4gRElWX0NFSUwoYSA6IHUzMiwgYiA6IHUzMikgLT4gdTMyIHtcbiAgICAgICAgICByZXR1cm4gKChhIC0gMXUpIC8gYiArIDF1KTtcbiAgICAgICAgIH1cbiAgICAgICAgICR7Zy5tYWluU3RhcnQoaCl9XG5cbiAgICAgICAgICBsZXQgb3V0cHV0SW5kZXggPSBnbG9iYWxfaWR4IC8gJHtofTtcbiAgICAgICAgICBsZXQgb2Zmc2V0ID0gb3V0cHV0SW5kZXggKiB1bmlmb3Jtcy5yZWR1Y2VTaXplO1xuXG4gICAgICAgICAgdmFyIGJlc3RWYWx1ZSA9IGYzMigke2dtW25dfSk7XG4gICAgICAgICAgbGV0IExlbmd0aCA9IHVuaWZvcm1zLnJlZHVjZVNpemU7XG4gICAgICAgICAgZm9yICh2YXIgayA9IGxvY2FsX2lkeDsgayA8IExlbmd0aDsgayA9IGsgKyAke2h9KSB7XG4gICAgICAgICAgIGxldCBjYW5kaWRhdGUgPSBmMzIoJHttLmdldEJ5T2Zmc2V0KFwib2Zmc2V0ICsga1wiKX0pO1xuICAgICAgICAgICBiZXN0VmFsdWUgPSAke2ZtW25dfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYUJlc3RWYWx1ZXNbbG9jYWxfaWR4XSA9IGJlc3RWYWx1ZTtcbiAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgIHZhciByZWR1Y2VTaXplID0gbWluKExlbmd0aCwgJHtofXUpO1xuICAgICAgICAgZm9yICh2YXIgY3VycmVudFNpemUgPSByZWR1Y2VTaXplIC8gMnU7IHJlZHVjZVNpemUgPiAxdTtcbiAgICAgICAgICAgICBjdXJyZW50U2l6ZSA9IHJlZHVjZVNpemUgLyAydSkge1xuICAgICAgICAgICBsZXQgaW50ZXJ2YWwgPSBESVZfQ0VJTChyZWR1Y2VTaXplLCAydSk7XG4gICAgICAgICAgIGlmIChsb2NhbF9pZHggPCBjdXJyZW50U2l6ZSkge1xuICAgICAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IGFCZXN0VmFsdWVzW2xvY2FsX2lkeCArIGludGVydmFsXTtcbiAgICAgICAgICAgIGJlc3RWYWx1ZSA9ICR7aG1bbl19O1xuICAgICAgICAgICAgYUJlc3RWYWx1ZXNbbG9jYWxfaWR4XSA9IGJlc3RWYWx1ZTtcbiAgICAgICAgICAgfVxuICAgICAgICAgICByZWR1Y2VTaXplID0gaW50ZXJ2YWw7XG4gICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICAgICAgIH1cblxuICAgICAgICAgaWYgKGxvY2FsX2lkeCA9PSAwdSkge1xuICAgICAgICAgICR7dS5zZXRCeU9mZnNldChcIm91dHB1dEluZGV4XCIsYCR7bj09PVwibWVhblwiP2Ake3UudHlwZS5zdG9yYWdlfShiZXN0VmFsdWUgLyBmMzIodW5pZm9ybXMucmVkdWNlU2l6ZSkpYDpgJHt1LnR5cGUuc3RvcmFnZX0oJHtibVtuXX0pYH1gKX07XG4gICAgICAgICB9XG4gICAgICAgIH1gO3JldHVybntuYW1lOmUsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dH07JHtofWAsaW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiXX0sZ2V0U2hhZGVyU291cmNlOnksZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczppLGRhdGFUeXBlOm99XSxkaXNwYXRjaEdyb3VwOnt4Omx9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTpwfV19KX19LHJ0PShlLHQscixuKT0+e2xldCBvPWUuaW5wdXRzLmxlbmd0aD09PTE/cjpsbyhlLmlucHV0cyxyKSxpPW8uYXhlcztpLmxlbmd0aD09PTAmJiFvLm5vb3BXaXRoRW1wdHlBeGVzJiYoaT1lLmlucHV0c1swXS5kaW1zLm1hcCgoXyx5KT0+eSkpO2xldCBhPUMubm9ybWFsaXplQXhlcyhpLGUuaW5wdXRzWzBdLmRpbXMubGVuZ3RoKSxkPWEsbD1lLmlucHV0c1swXSxwPSRtKGQsZS5pbnB1dHNbMF0uZGltcy5sZW5ndGgpO3AubGVuZ3RoPjAmJihsPWUuY29tcHV0ZShQZShlLmlucHV0c1swXSxwKSx7aW5wdXRzOlswXSxvdXRwdXRzOlstMV19KVswXSxkPXltKGQubGVuZ3RoLGwuZGltcy5sZW5ndGgpKTtsZXRbbSx1XT1fbShsLmRpbXMsZCksaD1tO28ua2VlcERpbXMmJihoPXdtKG0sYSkpLGUuY29tcHV0ZSh4bSh0LG8uY2FjaGVLZXksW2xdLG4sZS5pbnB1dHNbMF0uZGF0YVR5cGUsaCx1KSx7aW5wdXRzOltsXX0pfSxzcz0oZSx0KT0+e3J0KGUsXCJSZWR1Y2VNZWFuU2hhcmVkXCIsdCxcIm1lYW5cIil9LHVzPShlLHQpPT57cnQoZSxcIlJlZHVjZUwxU2hhcmVkXCIsdCxcImwxXCIpfSxkcz0oZSx0KT0+e3J0KGUsXCJSZWR1Y2VMMlNoYXJlZFwiLHQsXCJsMlwiKX0sbHM9KGUsdCk9PntydChlLFwiUmVkdWNlTG9nU3VtRXhwU2hhcmVkXCIsdCxcImxvZ1N1bUV4cFwiKX0sY3M9KGUsdCk9PntydChlLFwiUmVkdWNlTWF4U2hhcmVkXCIsdCxcIm1heFwiKX0scHM9KGUsdCk9PntydChlLFwiUmVkdWNlTWluU2hhcmVkXCIsdCxcIm1pblwiKX0sbXM9KGUsdCk9PntydChlLFwiUmVkdWNlUHJvZFNoYXJlZFwiLHQsXCJwcm9kXCIpfSxmcz0oZSx0KT0+e3J0KGUsXCJSZWR1Y2VTdW1TaGFyZWRcIix0LFwic3VtXCIpfSxocz0oZSx0KT0+e3J0KGUsXCJSZWR1Y2VTdW1TcXVhcmVTaGFyZWRcIix0LFwic3VtU3F1YXJlXCIpfSxncz0oZSx0KT0+e3J0KGUsXCJSZWR1Y2VMb2dTdW1TaGFyZWRcIix0LFwibG9nU3VtXCIpfX0pO3ZhciBudCxTbSxIcixsbyxvdCxUbSxJbSxDbSxBbSxrbSxFbSxQbSx6bSxPbSxEbSxpdCx5cyxfcyx3cyx2cywkcyx4cyxTcyxUcyxJcyxDcyxHcj1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtvZSgpO1NlKCk7YWUoKTticygpO250PWU9PntpZighZXx8ZS5sZW5ndGg9PT0wfHxlLmxlbmd0aD4yKXRocm93IG5ldyBFcnJvcihcIlJlZHVjZSBvcCByZXF1aXJlcyAxIG9yIDIgaW5wdXRzLlwiKTtpZihlLmxlbmd0aD09PTImJmVbMV0uZGltcy5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXhlcyBpbnB1dCBkaW1zLlwiKX0sU209ZT0+W1wiXCIsXCJcIixgdmFyIHZhbHVlID0gJHtlLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O2AsXCJcIl0sSHI9KGUsdCxyLG4sbyxpLGE9ITEsZD0hMSk9PntsZXQgbD1bXSxwPXJbMF0uZGltcyxtPXAubGVuZ3RoLHU9Qy5ub3JtYWxpemVBeGVzKG8sbSksaD0hZCYmdS5sZW5ndGg9PT0wO3AuZm9yRWFjaCgoeCwkKT0+e2h8fHUuaW5kZXhPZigkKT49MD9hJiZsLnB1c2goMSk6bC5wdXNoKHgpfSk7bGV0IF89bC5sZW5ndGgseT1DLnNpemUobCk7cmV0dXJue25hbWU6ZSxzaGFkZXJDYWNoZTp0LGdldFNoYWRlclNvdXJjZTp4PT57bGV0ICQ9W10sdj1FKFwiX0FcIixyWzBdLmRhdGFUeXBlLG0pLFM9TShcIm91dHB1dFwiLGksXyksVD1uKHYsUyx1KSxBPVRbMl07Zm9yKGxldCBrPTAsUD0wO2s8bTtrKyspaHx8dS5pbmRleE9mKGspPj0wPyhhJiZQKyssQT1gZm9yKHZhciBqJHtrfTogdTMyID0gMDsgaiR7a30gPCAke3Bba119OyBqJHtrfSsrKSB7XG4gICAgICAgICAgICAgICAgICAke1RbMl0uaW5jbHVkZXMoXCJsYXN0X2luZGV4XCIpP2BsZXQgbGFzdF9pbmRleCA9IGoke2t9O2A6XCJcIn1cbiAgICAgICAgICAgICAgICAgICR7di5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLGssYGoke2t9YCl9XG4gICAgICAgICAgICAgICAgICAke0F9XG4gICAgICAgICAgICAgICAgfWApOigkLnB1c2goYCR7di5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLGssUy5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixQKSl9O2ApLFArKyk7cmV0dXJuYFxuXG4gICAgICAgICR7eC5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXModixTKX1cblxuICAgICAgICAke3gubWFpblN0YXJ0KCl9XG4gICAgICAgICAgJHt4Lmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICAgICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHt2LnR5cGUuaW5kaWNlc307XG4gICAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHtTLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuXG4gICAgICAgICAgJHskLmpvaW4oYFxuYCl9XG4gICAgICAgICAgJHtUWzBdfSAgICAgICAvLyBpbml0IG9wcyBmb3IgcmVkdWNlIG1heC9taW5cbiAgICAgICAgICAke1RbMV19XG4gICAgICAgICAgJHtBfVxuICAgICAgICAgICR7VFszXX1cbiAgICAgICAgICAke1QubGVuZ3RoPT09ND9TLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIik6VC5zbGljZSg0KS5qb2luKGBcbmApfVxuICAgICAgICB9YH0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpsLGRhdGFUeXBlOml9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbCh5LzY0KX0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZToxMixkYXRhOnl9LC4uLk4ocCxsKV19KX19LGxvPShlLHQpPT57bGV0IHI9W107cmV0dXJuIGVbMV0uZGltc1swXT4wJiZlWzFdLmdldEJpZ0ludDY0QXJyYXkoKS5mb3JFYWNoKG49PnIucHVzaChOdW1iZXIobikpKSxyZSh7YXhlczpyLGtlZXBEaW1zOnQua2VlcERpbXMsbm9vcFdpdGhFbXB0eUF4ZXM6dC5ub29wV2l0aEVtcHR5QXhlc30pfSxvdD0oZSx0LHIsbik9PntsZXQgbz1lLmlucHV0cyxpPW8ubGVuZ3RoPT09MT9yOmxvKG8scik7ZS5jb21wdXRlKEhyKHQse2hpbnQ6aS5jYWNoZUtleSxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxbb1swXV0saS5ub29wV2l0aEVtcHR5QXhlcyYmaS5heGVzLmxlbmd0aD09PTA/U206bixpLmF4ZXMsb1swXS5kYXRhVHlwZSxpLmtlZXBEaW1zLGkubm9vcFdpdGhFbXB0eUF4ZXMpLHtpbnB1dHM6WzBdfSl9LFRtPShlLHQpPT57bnQoZS5pbnB1dHMpLG90KGUsXCJSZWR1Y2VMb2dTdW1cIix0LChuLG8pPT5bYHZhciB2YWx1ZSA9ICR7by50eXBlLnN0b3JhZ2V9KDApO2AsXCJcIixgdmFsdWUgKz0gJHtuLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O2AsXCJ2YWx1ZSA9IGxvZyh2YWx1ZSk7XCJdKX0sSW09KGUsdCk9PntudChlLmlucHV0cyksb3QoZSxcIlJlZHVjZUwxXCIsdCwobixvKT0+W2B2YXIgdmFsdWUgPSAke28udHlwZS5zdG9yYWdlfSgwKTtgLFwiXCIsYHZhbHVlICs9IGFicygke24uZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX0pO2AsXCJcIl0pfSxDbT0oZSx0KT0+e250KGUuaW5wdXRzKSxvdChlLFwiUmVkdWNlTDJcIix0LChuLG8pPT5bYHZhciB0ID0gJHtvLnR5cGUudmFsdWV9KDApOyB2YXIgdmFsdWUgPSAke28udHlwZS52YWx1ZX0oMCk7YCxcIlwiLGB0ID0gJHtuLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9OyB2YWx1ZSArPSAodCAqIHQpO2AsXCJ2YWx1ZSA9IHNxcnQodmFsdWUpO1wiXSl9LEFtPShlLHQpPT57bnQoZS5pbnB1dHMpLG90KGUsXCJSZWR1Y2VMb2dTdW1FeHBcIix0LChuLG8pPT5bYHZhciB2YWx1ZSA9ICR7by50eXBlLnN0b3JhZ2V9KDApO2AsXCJcIixgdmFsdWUgKz0gZXhwKCR7bi5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfSk7YCxcInZhbHVlID0gbG9nKHZhbHVlKTtcIl0pfSxrbT0oZSx0KT0+e250KGUuaW5wdXRzKSxvdChlLFwiUmVkdWNlTWF4XCIsdCwobixvLGkpPT57bGV0IGE9W107Zm9yKGxldCBkPTA7ZDxuLnJhbms7ZCsrKShpLmluZGV4T2YoZCk+PTB8fGkubGVuZ3RoPT09MCkmJmEucHVzaChuLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsZCwwKSk7cmV0dXJuW2Ake2Euam9pbihgXG5gKX1gLGB2YXIgdmFsdWUgPSAke24uZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07YCxgdmFsdWUgPSBtYXgodmFsdWUsICR7bi5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfSk7YCxcIlwiXX0pfSxFbT0oZSx0KT0+e250KGUuaW5wdXRzKSxvdChlLFwiUmVkdWNlTWVhblwiLHQsKG4sbyxpKT0+e2xldCBhPTE7Zm9yKGxldCBkPTA7ZDxuLnJhbms7ZCsrKShpLmluZGV4T2YoZCk+PTB8fGkubGVuZ3RoPT09MCkmJihhKj1lLmlucHV0c1swXS5kaW1zW2RdKTtyZXR1cm5bXCJ2YXIgc3VtID0gZjMyKDApO1wiLFwiXCIsYHN1bSArPSBmMzIoJHtuLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9KTtgLGBsZXQgdmFsdWUgPSAke28udHlwZS52YWx1ZX0oc3VtIC8gJHthfSk7YF19KX0sUG09KGUsdCk9PntudChlLmlucHV0cyksb3QoZSxcIlJlZHVjZU1pblwiLHQsKG4sbyxpKT0+e2xldCBhPVtdO2ZvcihsZXQgZD0wO2Q8bi5yYW5rO2QrKykoaS5pbmRleE9mKGQpPj0wfHxpLmxlbmd0aD09PTApJiZhLnB1c2goYGlucHV0X2luZGljZXNbJHtkfV0gPSAwO2ApO3JldHVybltgJHthLmpvaW4oYFxuYCl9YCxgdmFyIHZhbHVlID0gJHtuLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O2AsYHZhbHVlID0gbWluKHZhbHVlLCAke24uZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX0pO2AsXCJcIl19KX0sem09KGUsdCk9PntudChlLmlucHV0cyksb3QoZSxcIlJlZHVjZVByb2RcIix0LChuLG8pPT5bYHZhciB2YWx1ZSA9ICR7by50eXBlLnN0b3JhZ2V9KDEpO2AsXCJcIixgdmFsdWUgKj0gJHtuLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O2AsXCJcIl0pfSxPbT0oZSx0KT0+e250KGUuaW5wdXRzKSxvdChlLFwiUmVkdWNlU3VtXCIsdCwobixvKT0+W2B2YXIgdmFsdWUgPSAke28udHlwZS5zdG9yYWdlfSgwKTtgLFwiXCIsYHZhbHVlICs9ICR7bi5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtgLFwiXCJdKX0sRG09KGUsdCk9PntudChlLmlucHV0cyksb3QoZSxcIlJlZHVjZVN1bVNxdWFyZVwiLHQsKG4sbyk9PltgdmFyIHQgPSAke28udHlwZS52YWx1ZX0oMCk7IHZhciB2YWx1ZSA9ICR7by50eXBlLnZhbHVlfSgwKTtgLFwiXCIsYHQgPSAke24uZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07IHZhbHVlICs9IHQgKiB0O2AsXCJcIl0pfSxpdD0oZSx0LHIpPT57aWYodC5sZW5ndGg9PT0wKXJldHVybiByO2xldCBuPTEsbz0xO2ZvcihsZXQgaT0wO2k8dC5sZW5ndGg7aSsrKXQuaW5kZXhPZihpKT09PS0xP24qPWVbaV06byo9ZVtpXTtyZXR1cm4gbzwzMiYmbj4xMDI0fSx5cz0oZSx0KT0+e2l0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP0VtKGUsdCk6c3MoZSx0KX0sX3M9KGUsdCk9PntpdChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT9JbShlLHQpOnVzKGUsdCl9LHdzPShlLHQpPT57aXQoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/Q20oZSx0KTpkcyhlLHQpfSx2cz0oZSx0KT0+e2l0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP0FtKGUsdCk6bHMoZSx0KX0sJHM9KGUsdCk9PntpdChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT9rbShlLHQpOmNzKGUsdCl9LHhzPShlLHQpPT57aXQoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/UG0oZSx0KTpwcyhlLHQpfSxTcz0oZSx0KT0+e2l0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP3ptKGUsdCk6bXMoZSx0KX0sVHM9KGUsdCk9PntpdChlLmlucHV0c1swXS5kaW1zLHQuYXhlcyx0Lm5vb3BXaXRoRW1wdHlBeGVzKT9PbShlLHQpOmZzKGUsdCl9LElzPShlLHQpPT57aXQoZS5pbnB1dHNbMF0uZGltcyx0LmF4ZXMsdC5ub29wV2l0aEVtcHR5QXhlcyk/RG0oZSx0KTpocyhlLHQpfSxDcz0oZSx0KT0+e2l0KGUuaW5wdXRzWzBdLmRpbXMsdC5heGVzLHQubm9vcFdpdGhFbXB0eUF4ZXMpP1RtKGUsdCk6Z3MoZSx0KX19KTt2YXIgQXMsa3MsRXMsY28sUHM9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7U2UoKTtHcigpO0FzPWU9PntpZighZXx8ZS5sZW5ndGg9PT0wfHxlLmxlbmd0aD4yKXRocm93IG5ldyBFcnJvcihcIkFyZ01pbk1heE9wIG9wIHJlcXVpcmVzIDEgb3IgMiBpbnB1dHMuXCIpO2lmKGVbMF0uZGF0YVR5cGUhPT0xKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZS5cIil9LGtzPShlLHQpPT57QXMoZS5pbnB1dHMpO2xldCByPShuLG8saSk9PntsZXQgYT1bXTtmb3IobGV0IGQ9MDtkPG4ucmFuaztkKyspKGkuaW5kZXhPZihkKT49MHx8aS5sZW5ndGg9PT0wKSYmYS5wdXNoKGBpbnB1dF9pbmRpY2VzWyR7ZH1dID0gMDtgKTtyZXR1cm5bYCR7YS5qb2luKGBcbmApfWAsYHZhciB2YWx1ZSA9ICR7bi5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtcbnZhciBiZXN0X2luZGV4IDogaTMyID0gMDtgLGBpZiAoJHtuLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9ICR7dC5zZWxlY3RMYXN0SW5kZXg+MD9cIjw9XCI6XCI8XCJ9IHZhbHVlKSB7XG4gICAgICAgICB2YWx1ZSA9ICR7bi5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzXCIpfTtcbiAgICAgICAgIGJlc3RfaW5kZXggPSBpMzIobGFzdF9pbmRleCk7XG4gICAgICAgfWAsXCJcIixvLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwiYmVzdF9pbmRleFwiKV19O2UuY29tcHV0ZShIcihcIkFyZ01pblwiLHtoaW50OnQuY2FjaGVLZXksaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiXX0sW2UuaW5wdXRzWzBdXSxyLFt0LmF4aXNdLDcsdC5rZWVwRGltcykse2lucHV0czpbMF19KX0sRXM9KGUsdCk9PntBcyhlLmlucHV0cyk7bGV0IHI9KG4sbyxpKT0+e2xldCBhPVtdO2ZvcihsZXQgZD0wO2Q8bi5yYW5rO2QrKykoaS5pbmRleE9mKGQpPj0wfHxpLmxlbmd0aD09PTApJiZhLnB1c2goYGlucHV0X2luZGljZXNbJHtkfV0gPSAwO2ApO3JldHVybltgJHthLmpvaW4oYFxuYCl9YCxgdmFyIHZhbHVlID0gJHtuLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O1xudmFyIGJlc3RfaW5kZXggOiBpMzIgPSAwO2AsYGlmICgke24uZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX0gJHt0LnNlbGVjdExhc3RJbmRleD4wP1wiPj1cIjpcIj5cIn0gdmFsdWUpIHtcbiAgICAgICAgIHZhbHVlID0gJHtuLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O1xuICAgICAgICAgYmVzdF9pbmRleCA9IGkzMihsYXN0X2luZGV4KTtcbiAgICAgICB9YCxcIlwiLG8uc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJiZXN0X2luZGV4XCIpXX07ZS5jb21wdXRlKEhyKFwiYXJnTWF4XCIse2hpbnQ6dC5jYWNoZUtleSxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxbZS5pbnB1dHNbMF1dLHIsW3QuYXhpc10sNyx0LmtlZXBEaW1zKSx7aW5wdXRzOlswXX0pfSxjbz1lPT5yZShlKX0pO3ZhciBCbSxwbyxNbSxSbSxVbSxSdCxObSx6cyxGcj1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtvZSgpO05yKCk7YWUoKTtCbT0oZSx0KT0+e2xldCByPWVbMF0sbj1lWzFdLG89ZVsyXSxpPWVbM10sYT1lWzRdLGQ9ZVs1XTtpZihhJiZkKXRocm93IG5ldyBFcnJvcihcIkF0dGVudGlvbiBjYW5ub3QgaGF2ZSBib3RoIHBhc3QgYW5kIGF0dGVudGlvbl9iaWFzXCIpO2lmKHIuZGltcy5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJpbnB1dFwiIG11c3QgaGF2ZSAzIGRpbWVuc2lvbnMnKTtsZXQgbD1yLmRpbXNbMF0scD1yLmRpbXNbMV0sbT1yLmRpbXNbMl07aWYoby5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImJpYXNcIiBpcyBleHBlY3RlZCB0byBoYXZlIDEgZGltZW5zaW9ucycpO2lmKG4uZGltcy5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJ3ZWlnaHRzXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAyIGRpbWVuc2lvbnMnKTtpZihuLmRpbXNbMF0hPT1tKXRocm93IG5ldyBFcnJvcihcIklucHV0IDEgZGltZW5zaW9uIDAgc2hvdWxkIGhhdmUgc2FtZSBsZW5ndGggYXMgZGltZW5zaW9uIDIgb2YgaW5wdXQgMFwiKTtpZihvLmRpbXNbMF0hPT1uLmRpbXNbMV0pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImJpYXNcIiBkaW1lbnNpb24gMCBzaG91bGQgaGF2ZSBzYW1lIGxlbmd0aCBhcyBkaW1lbnNpb24gMSBvZiBpbnB1dCBcIndlaWdodHNcIicpO2xldCB1PW8uZGltc1swXS8zLGg9dSxfPWg7aWYodC5xa3ZIaWRkZW5TaXplcy5sZW5ndGg+MCl7aWYodC5xa3ZIaWRkZW5TaXplcy5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcihcInFrdl9oaWRkZW5fc2l6ZXMgYXR0cmlidXRlIHNob3VsZCBoYXZlIDMgZWxlbWVudHNcIik7Zm9yKGxldCBTIG9mIHQucWt2SGlkZGVuU2l6ZXMpaWYoUyV0Lm51bUhlYWRzIT09MCl0aHJvdyBuZXcgRXJyb3IoXCJxa3ZfaGlkZGVuX3NpemVzIHNob3VsZCBiZSBkaXZpc2libGUgYnkgbnVtX2hlYWRzXCIpO3U9dC5xa3ZIaWRkZW5TaXplc1swXSxoPXQucWt2SGlkZGVuU2l6ZXNbMV0sXz10LnFrdkhpZGRlblNpemVzWzJdfWxldCB5PXA7aWYodSE9PWgpdGhyb3cgbmV3IEVycm9yKFwicWt2X2hpZGRlbl9zaXplcyBmaXJzdCBlbGVtZW50IHNob3VsZCBiZSBzYW1lIGFzIHRoZSBzZWNvbmRcIik7aWYoby5kaW1zWzBdIT09dStoK18pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImJpYXNcIiBkaW1lbnNpb24gMCBzaG91bGQgaGF2ZSBzYW1lIGxlbmd0aCBhcyBzdW0gb2YgUS9LL1YgaGlkZGVuIHNpemVzJyk7bGV0IGc9MDtpZihhKXtpZihoIT09Xyl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdFwiIGV4cGVjdCBrX2hpZGRlbl9zaXplID09IHZfaGlkZGVuX3NpemUnKTtpZihhLmRpbXMubGVuZ3RoIT09NSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdFwiIG11c3QgaGF2ZSA1IGRpbWVuc2lvbnMnKTtpZihhLmRpbXNbMF0hPT0yKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0XCIgZmlyc3QgZGltZW5zaW9uIG11c3QgYmUgMicpO2lmKGEuZGltc1sxXSE9PWwpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RcIiBzZWNvbmQgZGltZW5zaW9uIG11c3QgYmUgYmF0Y2hfc2l6ZScpO2lmKGEuZGltc1syXSE9PXQubnVtSGVhZHMpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RcIiB0aGlyZCBkaW1lbnNpb24gbXVzdCBiZSBudW1faGVhZHMnKTtpZihhLmRpbXNbNF0hPT1oL3QubnVtSGVhZHMpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RcIiBmaWZ0aCBkaW1lbnNpb24gbXVzdCBiZSBrX2hpZGRlbl9zaXplIC8gbnVtX2hlYWRzJyk7dC5wYXN0UHJlc2VudFNoYXJlQnVmZmVyfHwoZz1hLmRpbXNbM10pfWxldCB4PXkrZywkPS0xLHY9MDtpZihpKXRocm93IG5ldyBFcnJvcihcIk1hc2sgbm90IHN1cHBvcnRlZFwiKTtpZihhKXRocm93IG5ldyBFcnJvcihcInBhc3QgaXMgbm90IHN1cHBvcnRlZFwiKTtpZihkKXtpZihkLmRpbXMubGVuZ3RoIT09NCl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwiYXR0ZW50aW9uX2JpYXNcIiBtdXN0IGhhdmUgNCBkaW1lbnNpb25zJyk7aWYoZC5kaW1zWzBdIT09bHx8ZC5kaW1zWzFdIT09dC5udW1IZWFkc3x8ZC5kaW1zWzJdIT09cHx8ZC5kaW1zWzNdIT09eCl0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcImF0dGVudGlvbl9iaWFzXCIgc2hhcGUgKGJhdGNoX3NpemUsIG51bV9oZWFkcywgc2VxdWVuY2VfbGVuZ3RoLCB0b3RhbF9zZXF1ZW5jZV9sZW5ndGgpJyl9cmV0dXJue2JhdGNoU2l6ZTpsLHNlcXVlbmNlTGVuZ3RoOnAscGFzdFNlcXVlbmNlTGVuZ3RoOmcsa3ZTZXF1ZW5jZUxlbmd0aDp5LHRvdGFsU2VxdWVuY2VMZW5ndGg6eCxtYXhTZXF1ZW5jZUxlbmd0aDokLGlucHV0SGlkZGVuU2l6ZTptLGhpZGRlblNpemU6dSx2SGlkZGVuU2l6ZTpfLGhlYWRTaXplOk1hdGguZmxvb3IodS90Lm51bUhlYWRzKSx2SGVhZFNpemU6TWF0aC5mbG9vcihfL3QubnVtSGVhZHMpLG51bUhlYWRzOnQubnVtSGVhZHMsaXNVbmlkaXJlY3Rpb25hbDohMSxwYXN0UHJlc2VudFNoYXJlQnVmZmVyOiExLG1hc2tGaWx0ZXJWYWx1ZTp0Lm1hc2tGaWx0ZXJWYWx1ZSxtYXNrVHlwZTp2LHNjYWxlOnQuc2NhbGUsYnJvYWRjYXN0UmVzUG9zQmlhczohMSxwYXNzUGFzdEluS3Y6ITEscWt2Rm9ybWF0OjF9fSxwbz0oZSx0LHIpPT50JiZlP2BcbiAgICAgIGxldCB0b3RhbF9zZXF1ZW5jZV9sZW5ndGhfaW5wdXQgPSB1MzIoJHt0LmdldEJ5T2Zmc2V0KFwiMFwiKX0pO1xuICAgICAgbGV0IHByZXNlbnRfc2VxdWVuY2VfbGVuZ3RoID0gbWF4KHRvdGFsX3NlcXVlbmNlX2xlbmd0aF9pbnB1dCwgdW5pZm9ybXMucGFzdF9zZXF1ZW5jZV9sZW5ndGgpO1xuICAgICAgbGV0IGlzX3N1YnNlcXVlbnRfcHJvbXB0OiBib29sID0gc2VxdWVuY2VfbGVuZ3RoID4gMSAmJiBzZXF1ZW5jZV9sZW5ndGggIT0gdG90YWxfc2VxdWVuY2VfbGVuZ3RoX2lucHV0O1xuICAgICAgbGV0IGlzX2ZpcnN0X3Byb21wdDogYm9vbCA9IGlzX3N1YnNlcXVlbnRfcHJvbXB0ID09IGZhbHNlICYmIHNlcXVlbmNlX2xlbmd0aCA9PSB0b3RhbF9zZXF1ZW5jZV9sZW5ndGhfaW5wdXQ7XG4gICAgICB0b3RhbF9zZXF1ZW5jZV9sZW5ndGggPSB1MzIoJHtlPy5nZXRCeU9mZnNldChcImJhdGNoSWR4XCIpfSkgKyAxO1xuICAgICAgdmFyIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoOiB1MzIgPSAwO1xuICAgICAgaWYgKGlzX2ZpcnN0X3Byb21wdCA9PSBmYWxzZSkge1xuICAgICAgICBwYXN0X3NlcXVlbmNlX2xlbmd0aCA9IHRvdGFsX3NlcXVlbmNlX2xlbmd0aCAtIHNlcXVlbmNlX2xlbmd0aDtcbiAgICAgIH1cbiAgICAgICBgOmBcbiAgICAke3I/XCJsZXQgcGFzdF9zZXF1ZW5jZV9sZW5ndGggPSB1bmlmb3Jtcy5wYXN0X3NlcXVlbmNlX2xlbmd0aFwiOlwiXCJ9O1xuICAgIGxldCBwcmVzZW50X3NlcXVlbmNlX2xlbmd0aCA9IHRvdGFsX3NlcXVlbmNlX2xlbmd0aDtcbiAgICBgLE1tPShlLHQscixuLG8saSxhLGQpPT57bGV0IGw9bWUoYT8xOmkpLHA9NjQsbT1pL2w7bTxwJiYocD0zMik7bGV0IHU9TWF0aC5jZWlsKGkvbC9wKSxoPVt7dHlwZToxMixkYXRhOnR9LHt0eXBlOjEyLGRhdGE6cn0se3R5cGU6MTIsZGF0YTpufSx7dHlwZToxMixkYXRhOm99LHt0eXBlOjEyLGRhdGE6bX0se3R5cGU6MTIsZGF0YTp1fV0sXz1fZShlLmRhdGFUeXBlLGwpLHk9RWUoMSxsKSxnPVtcInR5cGVcIl07YSYmZy5wdXNoKFwidHlwZVwiKSxkJiZnLnB1c2goXCJ0eXBlXCIpO2xldCB4PSQ9PntsZXQgdj1NKFwieFwiLGUuZGF0YVR5cGUsZS5kaW1zLGwpLFM9W3ZdLFQ9YT9FKFwic2VxX2xlbnNcIixhLmRhdGFUeXBlLGEuZGltcyk6dm9pZCAwO1QmJlMucHVzaChUKTtsZXQgQT1kP0UoXCJ0b3RhbF9zZXF1ZW5jZV9sZW5ndGhfaW5wdXRcIixkLmRhdGFUeXBlLGQuZGltcyk6dm9pZCAwO0EmJlMucHVzaChBKTtsZXQgaz1FZShlLmRhdGFUeXBlKSxQPVt7bmFtZTpcImJhdGNoX3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibnVtX2hlYWRzXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInBhc3Rfc2VxdWVuY2VfbGVuZ3RoXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInNlcXVlbmNlX2xlbmd0aFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJ0b3RhbF9zZXF1ZW5jZV9sZW5ndGhcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiZWxlbWVudHNfcGVyX3RocmVhZFwiLHR5cGU6XCJ1MzJcIn1dO3JldHVybmBcbiAgdmFyPHdvcmtncm91cD4gdGhyZWFkX21heDogYXJyYXk8ZjMyLCAke3B9PjtcbiAgdmFyPHdvcmtncm91cD4gdGhyZWFkX3N1bTogYXJyYXk8ZjMyLCAke3B9PjtcbiAgJHskLnJlZ2lzdGVyVW5pZm9ybXMoUCkuZGVjbGFyZVZhcmlhYmxlcyguLi5TKX1cbiAgJHskLm1haW5TdGFydChbcCwxLDFdKX1cbiAgICBsZXQgYmF0Y2hJZHggPSB3b3JrZ3JvdXBfaWQueiAvIHVuaWZvcm1zLm51bV9oZWFkcztcbiAgICBsZXQgaGVhZElkeCA9IHdvcmtncm91cF9pZC56ICUgdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgIGxldCBzZXF1ZW5jZV9sZW5ndGggPSB1bmlmb3Jtcy5zZXF1ZW5jZV9sZW5ndGg7XG4gICAgdmFyIHRvdGFsX3NlcXVlbmNlX2xlbmd0aCA9IHVuaWZvcm1zLnRvdGFsX3NlcXVlbmNlX2xlbmd0aDtcbiAgICAke3BvKFQsQSwhMSl9XG4gICAgbGV0IGxvY2FsX29mZnNldCA9IGxvY2FsX2lkeCAqIHVuaWZvcm1zLmVsZW1lbnRzX3Blcl90aHJlYWQ7XG4gICAgbGV0IG9mZnNldCA9IChnbG9iYWxfaWR4IC8gJHtwfSkgKiB1bmlmb3Jtcy50b3RhbF9zZXF1ZW5jZV9sZW5ndGggKyBsb2NhbF9vZmZzZXQ7XG4gICAgbGV0IHNlcV9jYXVzYWxfbGVuZ3RoID0gJHthP1widTMyKHBhc3Rfc2VxdWVuY2VfbGVuZ3RoICsgd29ya2dyb3VwX2lkLnkgKyAxKVwiOlwidG90YWxfc2VxdWVuY2VfbGVuZ3RoXCJ9O1xuICAgIHZhciB0aHJlYWRfbWF4X3ZlY3RvciA9ICR7eX0oLTMuNDAyODIzZSszOGYpO1xuICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCB1bmlmb3Jtcy5lbGVtZW50c19wZXJfdGhyZWFkICYmIGkgKyBsb2NhbF9vZmZzZXQgPCBzZXFfY2F1c2FsX2xlbmd0aDsgaSsrKSB7XG4gICAgICB0aHJlYWRfbWF4X3ZlY3RvciA9IG1heCgke3l9KHhbb2Zmc2V0ICsgaV0pLCB0aHJlYWRfbWF4X3ZlY3Rvcik7XG4gICAgfVxuICAgIHRocmVhZF9tYXhbbG9jYWxfaWR4XSA9ICR7KCgpPT57c3dpdGNoKGwpe2Nhc2UgMTpyZXR1cm5cInRocmVhZF9tYXhfdmVjdG9yXCI7Y2FzZSAyOnJldHVyblwibWF4KHRocmVhZF9tYXhfdmVjdG9yLngsIHRocmVhZF9tYXhfdmVjdG9yLnkpXCI7Y2FzZSA0OnJldHVyblwibWF4KG1heCh0aHJlYWRfbWF4X3ZlY3Rvci54LCB0aHJlYWRfbWF4X3ZlY3Rvci55KSwgbWF4KHRocmVhZF9tYXhfdmVjdG9yLnosIHRocmVhZF9tYXhfdmVjdG9yLncpKVwiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjb21wb25lbnRzOiAke2x9YCl9fSkoKX07XG4gICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgdmFyIG1heF92YWx1ZSA9ICBmMzIoLTMuNDAyODIzZSszOGYpO1xuICAgIGZvciAodmFyIGkgPSAwdTsgaSA8ICR7cH07IGkrKykge1xuICAgICAgbWF4X3ZhbHVlID0gbWF4KHRocmVhZF9tYXhbaV0sIG1heF92YWx1ZSk7XG4gICAgfVxuXG4gICAgdmFyIHN1bV92ZWN0b3IgPSAke3l9KDApO1xuICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCB1bmlmb3Jtcy5lbGVtZW50c19wZXJfdGhyZWFkICYmIGkgKyBsb2NhbF9vZmZzZXQgPCBzZXFfY2F1c2FsX2xlbmd0aDsgaSsrKSB7XG4gICAgICBzdW1fdmVjdG9yICs9IGV4cCgke3l9KHhbb2Zmc2V0ICsgaV0pIC0gbWF4X3ZhbHVlKTtcbiAgICB9XG4gICAgdGhyZWFkX3N1bVtsb2NhbF9pZHhdID0gJHsoKCk9Pntzd2l0Y2gobCl7Y2FzZSAxOnJldHVyblwic3VtX3ZlY3RvclwiO2Nhc2UgMjpyZXR1cm5cInN1bV92ZWN0b3IueCArIHN1bV92ZWN0b3IueVwiO2Nhc2UgNDpyZXR1cm5cInN1bV92ZWN0b3IueCArIHN1bV92ZWN0b3IueSArIHN1bV92ZWN0b3IueiArIHN1bV92ZWN0b3Iud1wiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjb21wb25lbnRzOiAke2x9YCl9fSkoKX07XG4gICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgdmFyIHN1bTogZjMyID0gMDtcbiAgICBmb3IgKHZhciBpID0gMHU7IGkgPCAke3B9OyBpKyspIHtcbiAgICAgIHN1bSArPSB0aHJlYWRfc3VtW2ldO1xuICAgIH1cblxuICAgIGlmIChzdW0gPT0gMCkge1xuICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8IHVuaWZvcm1zLmVsZW1lbnRzX3Blcl90aHJlYWQgJiYgaSArIGxvY2FsX29mZnNldCA8IHNlcV9jYXVzYWxfbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgeFtvZmZzZXQgKyBpXSA9ICR7di50eXBlLnZhbHVlfSgke2t9KDEuMCkgLyAke2t9KHNlcV9jYXVzYWxfbGVuZ3RoKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCB1bmlmb3Jtcy5lbGVtZW50c19wZXJfdGhyZWFkICYmIGkgKyBsb2NhbF9vZmZzZXQgPCBzZXFfY2F1c2FsX2xlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBmMzJpbnB1dCA9ICR7eX0oeFtvZmZzZXQgKyBpXSk7XG4gICAgICAgIHhbb2Zmc2V0ICsgaV0gPSAke3YudHlwZS52YWx1ZX0oZXhwKGYzMmlucHV0IC0gbWF4X3ZhbHVlKSAvIHN1bSk7XG4gICAgICB9XG4gICAgfVxuICAgICAgJHthP2BcbiAgICAgICAgZm9yICh2YXIgdG90YWxfc2VxX2lkOiB1MzIgPSBzZXFfY2F1c2FsX2xlbmd0aDsgdG90YWxfc2VxX2lkICsgbG9jYWxfb2Zmc2V0IDwgdW5pZm9ybXMudG90YWxfc2VxdWVuY2VfbGVuZ3RoOyB0b3RhbF9zZXFfaWQrKykge1xuICAgICAgICAgIHhbb2Zmc2V0ICsgdG90YWxfc2VxX2lkXSA9ICR7di50eXBlLnZhbHVlfSgke2t9KDApKTtcbiAgICAgICAgfWA6XCJcIn07XG4gIH1gfTtyZXR1cm57bmFtZTpcIkF0dGVudGlvblByb2JzU29mdG1heFwiLHNoYWRlckNhY2hlOntoaW50OmAke3B9OyR7X307JHtsfWAsaW5wdXREZXBlbmRlbmNpZXM6Z30sZ2V0U2hhZGVyU291cmNlOngsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOltdLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGkvcCkseTpvLHo6dCpyfSxwcm9ncmFtVW5pZm9ybXM6aH0pfX0sUm09KGUsdCxyLG4sbyxpLGEsZCxsKT0+e2xldCBwPWEraS5rdlNlcXVlbmNlTGVuZ3RoLG09W2kuYmF0Y2hTaXplLGkubnVtSGVhZHMsaS5zZXF1ZW5jZUxlbmd0aCxwXSx1PWU+MSYmbixoPWkua3ZOdW1IZWFkcz9pLmt2TnVtSGVhZHM6aS5udW1IZWFkcyxfPXU/W2kuYmF0Y2hTaXplLGgscCxpLmhlYWRTaXplXTp2b2lkIDAseT1pLm5SZXBzP2kublJlcHM6MSxnPWkuc2NhbGU9PT0wPzEvTWF0aC5zcXJ0KGkuaGVhZFNpemUpOmkuc2NhbGUseD1tZShpLmhlYWRTaXplKSwkPWkuaGVhZFNpemUveCx2PTEyLFM9e3g6TWF0aC5jZWlsKHAvdikseTpNYXRoLmNlaWwoaS5zZXF1ZW5jZUxlbmd0aC92KSx6OmkuYmF0Y2hTaXplKmkubnVtSGVhZHN9LFQ9W3t0eXBlOjEyLGRhdGE6aS5zZXF1ZW5jZUxlbmd0aH0se3R5cGU6MTIsZGF0YTokfSx7dHlwZToxMixkYXRhOnB9LHt0eXBlOjEyLGRhdGE6aS5udW1IZWFkc30se3R5cGU6MTIsZGF0YTppLmhlYWRTaXplfSx7dHlwZToxLGRhdGE6Z30se3R5cGU6MTIsZGF0YTphfSx7dHlwZToxMixkYXRhOmkua3ZTZXF1ZW5jZUxlbmd0aH0se3R5cGU6MTIsZGF0YTp5fV0sQT11JiZuJiZDLnNpemUobi5kaW1zKT4wLGs9W1widHlwZVwiLFwidHlwZVwiXTtBJiZrLnB1c2goXCJ0eXBlXCIpLG8mJmsucHVzaChcInR5cGVcIiksZCYmay5wdXNoKFwidHlwZVwiKSxsJiZrLnB1c2goXCJ0eXBlXCIpO2xldCBQPVt7ZGltczptLGRhdGFUeXBlOnQuZGF0YVR5cGUsZ3B1RGF0YVR5cGU6MH1dO3UmJlAucHVzaCh7ZGltczpfLGRhdGFUeXBlOnQuZGF0YVR5cGUsZ3B1RGF0YVR5cGU6MH0pO2xldCBEPVI9PntsZXQgRz1FKFwicVwiLHQuZGF0YVR5cGUsdC5kaW1zLHgpLEs9RShcImtleVwiLHIuZGF0YVR5cGUsci5kaW1zLHgpLGo9W0csS107aWYoQSl7bGV0IG5lPUUoXCJwYXN0X2tleVwiLG4uZGF0YVR5cGUsbi5kaW1zLHgpO2oucHVzaChuZSl9byYmai5wdXNoKEUoXCJhdHRlbnRpb25fYmlhc1wiLG8uZGF0YVR5cGUsby5kaW1zKSk7bGV0IFY9ZD9FKFwic2VxX2xlbnNcIixkLmRhdGFUeXBlLGQuZGltcyk6dm9pZCAwO1YmJmoucHVzaChWKTtsZXQgUT1sP0UoXCJ0b3RhbF9zZXF1ZW5jZV9sZW5ndGhfaW5wdXRcIixsLmRhdGFUeXBlLGwuZGltcyk6dm9pZCAwO1EmJmoucHVzaChRKTtsZXQgc2U9TShcIm91dHB1dFwiLHQuZGF0YVR5cGUsbSksWT1bc2VdO3UmJlkucHVzaChNKFwicHJlc2VudF9rZXlcIix0LmRhdGFUeXBlLF8seCkpO2xldCBlZT1FZSgxLHgpLEo9W3tuYW1lOlwiTVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJLXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIk5cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibnVtX2hlYWRzXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImhlYWRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJhbHBoYVwiLHR5cGU6XCJmMzJcIn0se25hbWU6XCJwYXN0X3NlcXVlbmNlX2xlbmd0aFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJrdl9zZXF1ZW5jZV9sZW5ndGhcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibl9yZXBzXCIsdHlwZTpcInUzMlwifV07cmV0dXJuYFxuICBjb25zdCBUSUxFX1NJWkUgPSAke3Z9dTtcblxuICB2YXI8d29ya2dyb3VwPiB0aWxlUTogYXJyYXk8JHtHLnR5cGUuc3RvcmFnZX0sICR7dip2fT47XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVLOiBhcnJheTwke0cudHlwZS5zdG9yYWdlfSwgJHt2KnZ9PjtcbiAgJHtSLnJlZ2lzdGVyVW5pZm9ybXMoSikuZGVjbGFyZVZhcmlhYmxlcyguLi5qLC4uLlkpfVxuICAke1IubWFpblN0YXJ0KFt2LHYsMV0pfVxuICAgIC8vIHggaG9sZHMgdGhlIE4gYW5kIHkgaG9sZHMgdGhlIE1cbiAgICBsZXQgaGVhZElkeCA9IHdvcmtncm91cF9pZC56ICUgdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgIGxldCBrdkhlYWRJZHggPSAke3k9PT0xP1wiaGVhZElkeFwiOlwiaGVhZElkeCAvIHVuaWZvcm1zLm5fcmVwc1wifTtcbiAgICBsZXQga3ZfbnVtX2hlYWRzID0gJHt5PT09MT9cInVuaWZvcm1zLm51bV9oZWFkc1wiOlwidW5pZm9ybXMubnVtX2hlYWRzIC8gdW5pZm9ybXMubl9yZXBzXCJ9O1xuICAgIGxldCBiYXRjaElkeCA9IHdvcmtncm91cF9pZC56IC8gdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgIGxldCBtID0gd29ya2dyb3VwX2lkLnkgKiBUSUxFX1NJWkU7XG4gICAgbGV0IG4gPSB3b3JrZ3JvdXBfaWQueCAqIFRJTEVfU0laRTtcbiAgICBsZXQgc2VxdWVuY2VfbGVuZ3RoID0gdW5pZm9ybXMuTTtcbiAgICB2YXIgdG90YWxfc2VxdWVuY2VfbGVuZ3RoID0gdW5pZm9ybXMuTjtcbiAgICAke3BvKFYsUSwhMCl9XG4gICAgbGV0IGFic0t2SGVhZElkeCA9IGJhdGNoSWR4ICoga3ZfbnVtX2hlYWRzICsga3ZIZWFkSWR4O1xuICAgIGxldCBxT2Zmc2V0ID0gd29ya2dyb3VwX2lkLnogKiB1bmlmb3Jtcy5NICogdW5pZm9ybXMuSyArIG0gKiB1bmlmb3Jtcy5LO1xuICAgICR7QSYmdT9cImxldCBwYXN0S2V5T2Zmc2V0ID0gYWJzS3ZIZWFkSWR4ICogdW5pZm9ybXMucGFzdF9zZXF1ZW5jZV9sZW5ndGggKiB1bmlmb3Jtcy5LO1wiOlwiXCJ9O1xuICAgIGxldCBrT2Zmc2V0ID0gYWJzS3ZIZWFkSWR4ICogdW5pZm9ybXMua3Zfc2VxdWVuY2VfbGVuZ3RoICogdW5pZm9ybXMuSztcbiAgICAke3U/XCJsZXQgcHJlc2VudEtleU9mZnNldCA9IGFic0t2SGVhZElkeCAqIHVuaWZvcm1zLk4gKiB1bmlmb3Jtcy5LO1wiOlwiXCJ9XG4gICAgdmFyIHZhbHVlID0gJHtlZX0oMCk7XG4gICAgZm9yICh2YXIgdzogdTMyID0gMHU7IHcgPCB1bmlmb3Jtcy5LOyB3ICs9IFRJTEVfU0laRSkge1xuICAgICAgaWYgKGdsb2JhbF9pZC55IDwgdW5pZm9ybXMuTSAmJiB3ICsgbG9jYWxfaWQueCA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdGlsZVFbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLnhdID0gcVtxT2Zmc2V0ICsgbG9jYWxfaWQueSAqIHVuaWZvcm1zLksgKyB3ICsgbG9jYWxfaWQueF07XG4gICAgICB9XG4gICAgICBpZiAobiArIGxvY2FsX2lkLnkgPCB1bmlmb3Jtcy5OICYmIHcgKyBsb2NhbF9pZC54IDwgdW5pZm9ybXMuSykge1xuICAgICAgICB2YXIgaWR4ID0gVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLng7XG4gICAgICAkeygoKT0+QSYmdT9gXG4gICAgICAgICAgICAgIGlmIChuICsgbG9jYWxfaWQueSA8IHBhc3Rfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGlsZUtbaWR4XSA9IHBhc3Rfa2V5W3Bhc3RLZXlPZmZzZXQgKyAobiArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMuSyArIHcgKyBsb2NhbF9pZC54XTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChuICsgbG9jYWxfaWQueSAtIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoIDwgdW5pZm9ybXMua3Zfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGlsZUtbaWR4XSA9IGtleVtrT2Zmc2V0ICsgKG4gKyBsb2NhbF9pZC55IC0gcGFzdF9zZXF1ZW5jZV9sZW5ndGgpICogdW5pZm9ybXMuSyArIHcgKyBsb2NhbF9pZC54XTtcbiAgICAgICAgICAgICAgfWA6YFxuICAgICAgICAgIGlmIChuICsgbG9jYWxfaWQueSA8IHVuaWZvcm1zLmt2X3NlcXVlbmNlX2xlbmd0aCkge1xuICAgICAgICAgICAgdGlsZUtbaWR4XSA9IGtleVtrT2Zmc2V0ICsgKG4gKyBsb2NhbF9pZC55KSAqIHVuaWZvcm1zLksgKyB3ICsgbG9jYWxfaWQueF07XG4gICAgICAgICAgfWApKCl9XG4gICAgICAke3U/YGlmIChuICsgbG9jYWxfaWQueSA8IHByZXNlbnRfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgIHByZXNlbnRfa2V5W3ByZXNlbnRLZXlPZmZzZXQgKyAobiArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMuSyArIHcgKyBsb2NhbF9pZC54XSA9IHRpbGVLW2lkeF07XG4gICAgICB9YDpcIlwifVxuICAgICAgfVxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICBmb3IgKHZhciBrOiB1MzIgPSAwdTsgayA8IFRJTEVfU0laRSAmJiB3K2sgPCB1bmlmb3Jtcy5LOyBrKyspIHtcbiAgICAgICAgICB2YWx1ZSArPSAke2VlfSh0aWxlUVtUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsga10gKiB0aWxlS1tUSUxFX1NJWkUgKiBsb2NhbF9pZC54ICsga10pO1xuICAgICAgfVxuXG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgfVxuXG4gICAgaWYgKGdsb2JhbF9pZC55IDwgdW5pZm9ybXMuTSAmJiBnbG9iYWxfaWQueCA8IHRvdGFsX3NlcXVlbmNlX2xlbmd0aCkge1xuICAgICAgbGV0IGhlYWRPZmZzZXQgPSB3b3JrZ3JvdXBfaWQueiAqIHVuaWZvcm1zLk0gKiB1bmlmb3Jtcy5OO1xuICAgICAgbGV0IG91dHB1dElkeCA9IGhlYWRPZmZzZXQgKyBnbG9iYWxfaWQueSAqIHVuaWZvcm1zLk4gKyBnbG9iYWxfaWQueDtcbiAgICAgIHZhciBzdW06IGYzMiA9ICR7KCgpPT57c3dpdGNoKHgpe2Nhc2UgMTpyZXR1cm5cInZhbHVlXCI7Y2FzZSAyOnJldHVyblwidmFsdWUueCArIHZhbHVlLnlcIjtjYXNlIDQ6cmV0dXJuXCJ2YWx1ZS54ICsgdmFsdWUueSArIHZhbHVlLnogKyB2YWx1ZS53XCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNvbXBvbmVudHM6ICR7eH1gKX19KSgpfTtcbiAgICAgICAgb3V0cHV0W291dHB1dElkeF0gPSAke3NlLnR5cGUudmFsdWV9IChzdW0gKiB1bmlmb3Jtcy5hbHBoYSkgKyAke28/XCJhdHRlbnRpb25fYmlhc1tvdXRwdXRJZHhdXCI6XCIwLjBcIn07XG4gICAgfVxuICB9YH07cmV0dXJue25hbWU6XCJBdHRlbnRpb25Qcm9ic1wiLHNoYWRlckNhY2hlOntoaW50OmAke3h9OyR7byE9PXZvaWQgMH07JHtuIT09dm9pZCAwfTske2V9YCxpbnB1dERlcGVuZGVuY2llczprfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6UCxkaXNwYXRjaEdyb3VwOlMscHJvZ3JhbVVuaWZvcm1zOlR9KSxnZXRTaGFkZXJTb3VyY2U6RH19LFVtPShlLHQscixuLG8saSxhPXZvaWQgMCxkPXZvaWQgMCk9PntsZXQgbD1pK28ua3ZTZXF1ZW5jZUxlbmd0aCxwPW8ublJlcHM/by5uUmVwczoxLG09by52SGlkZGVuU2l6ZSpwLHU9ZT4xJiZuLGg9by5rdk51bUhlYWRzP28ua3ZOdW1IZWFkczpvLm51bUhlYWRzLF89dT9bby5iYXRjaFNpemUsaCxsLG8uaGVhZFNpemVdOnZvaWQgMCx5PVtvLmJhdGNoU2l6ZSxvLnNlcXVlbmNlTGVuZ3RoLG1dLGc9MTIseD17eDpNYXRoLmNlaWwoby52SGVhZFNpemUvZykseTpNYXRoLmNlaWwoby5zZXF1ZW5jZUxlbmd0aC9nKSx6Om8uYmF0Y2hTaXplKm8ubnVtSGVhZHN9LCQ9W3t0eXBlOjEyLGRhdGE6by5zZXF1ZW5jZUxlbmd0aH0se3R5cGU6MTIsZGF0YTpsfSx7dHlwZToxMixkYXRhOm8udkhlYWRTaXplfSx7dHlwZToxMixkYXRhOm8ubnVtSGVhZHN9LHt0eXBlOjEyLGRhdGE6by5oZWFkU2l6ZX0se3R5cGU6MTIsZGF0YTptfSx7dHlwZToxMixkYXRhOml9LHt0eXBlOjEyLGRhdGE6by5rdlNlcXVlbmNlTGVuZ3RofSx7dHlwZToxMixkYXRhOnB9XSx2PXUmJm4mJkMuc2l6ZShuLmRpbXMpPjAsUz1bXCJ0eXBlXCIsXCJ0eXBlXCJdO3YmJlMucHVzaChcInR5cGVcIiksYSYmUy5wdXNoKFwidHlwZVwiKSxkJiZTLnB1c2goXCJ0eXBlXCIpO2xldCBUPVt7ZGltczp5LGRhdGFUeXBlOnQuZGF0YVR5cGUsZ3B1RGF0YVR5cGU6MH1dO3UmJlQucHVzaCh7ZGltczpfLGRhdGFUeXBlOnQuZGF0YVR5cGUsZ3B1RGF0YVR5cGU6MH0pO2xldCBBPWs9PntsZXQgUD1FKFwicHJvYnNcIix0LmRhdGFUeXBlLHQuZGltcyksRD1FKFwidlwiLHIuZGF0YVR5cGUsci5kaW1zKSxSPVtQLERdO3YmJlIucHVzaChFKFwicGFzdF92YWx1ZVwiLG4uZGF0YVR5cGUsbi5kaW1zKSk7bGV0IEc9YT9FKFwic2VxX2xlbnNcIixhLmRhdGFUeXBlLGEuZGltcyk6dm9pZCAwO2EmJlIucHVzaChHKTtsZXQgSz1kP0UoXCJ0b3RhbF9zZXF1ZW5jZV9sZW5ndGhfaW5wdXRcIixkLmRhdGFUeXBlLGQuZGltcyk6dm9pZCAwO2QmJlIucHVzaChLKTtsZXQgVj1bTShcIm91dHB1dFwiLHQuZGF0YVR5cGUseSldO3UmJlYucHVzaChNKFwicHJlc2VudF92YWx1ZVwiLHQuZGF0YVR5cGUsXykpO2xldCBRPVt7bmFtZTpcIk1cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiS1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJOXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIm51bV9oZWFkc1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJoZWFkX3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwidl9oaWRkZW5fc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJwYXN0X3NlcXVlbmNlX2xlbmd0aFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJrdl9zZXF1ZW5jZV9sZW5ndGhcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibl9yZXBzXCIsdHlwZTpcInUzMlwifV07cmV0dXJuYFxuICBjb25zdCBUSUxFX1NJWkUgPSAke2d9dTtcbiAgdmFyPHdvcmtncm91cD4gdGlsZVE6IGFycmF5PCR7UC50eXBlLnZhbHVlfSwgJHtnKmd9PjtcbiAgdmFyPHdvcmtncm91cD4gdGlsZVY6IGFycmF5PCR7UC50eXBlLnZhbHVlfSwgJHtnKmd9PjtcbiAgJHtrLnJlZ2lzdGVyVW5pZm9ybXMoUSkuZGVjbGFyZVZhcmlhYmxlcyguLi5SLC4uLlYpfVxuICAke2subWFpblN0YXJ0KFtnLGcsMV0pfVxuICAgbGV0IGhlYWRJZHggPSB3b3JrZ3JvdXBfaWQueiAlIHVuaWZvcm1zLm51bV9oZWFkcztcbiAgIGxldCBiYXRjaElkeCA9IHdvcmtncm91cF9pZC56IC8gdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgbGV0IGt2SGVhZElkeCA9ICR7cD09PTE/XCJoZWFkSWR4XCI6XCJoZWFkSWR4IC8gdW5pZm9ybXMubl9yZXBzXCJ9O1xuICAgbGV0IGt2X251bV9oZWFkcyA9ICR7cD09PTE/XCJ1bmlmb3Jtcy5udW1faGVhZHNcIjpcInVuaWZvcm1zLm51bV9oZWFkcyAvIHVuaWZvcm1zLm5fcmVwc1wifTtcbiAgIGxldCBtID0gZ2xvYmFsX2lkLnk7XG4gICBsZXQgbiA9IGdsb2JhbF9pZC54O1xuICAgbGV0IHNlcXVlbmNlX2xlbmd0aCA9IHVuaWZvcm1zLk07XG4gICB2YXIgdG90YWxfc2VxdWVuY2VfbGVuZ3RoID0gdW5pZm9ybXMuSztcbiAgICR7cG8oRyxLLCEwKX1cbiAgIGxldCBvZmZzZXRBID0gd29ya2dyb3VwX2lkLnogKiB1bmlmb3Jtcy5NICogdW5pZm9ybXMuSyArIG0gKiB1bmlmb3Jtcy5LO1xuICAgbGV0IGFic0t2SGVhZElkeCA9IGJhdGNoSWR4ICoga3ZfbnVtX2hlYWRzICsga3ZIZWFkSWR4OyAvLyBrdkhlYWRJZHggaXMgcmVsYXRpdmUgdG8gdGhlIGJhdGNoXG4gICAke3YmJnU/XCJsZXQgcGFzdFZhbHVlT2Zmc2V0ID0gYWJzS3ZIZWFkSWR4ICogdW5pZm9ybXMuTiAqIHVuaWZvcm1zLnBhc3Rfc2VxdWVuY2VfbGVuZ3RoICsgbjtcIjpcIlwifTtcbiAgIGxldCB2T2Zmc2V0ID0gYWJzS3ZIZWFkSWR4ICogdW5pZm9ybXMuTiAqIHVuaWZvcm1zLmt2X3NlcXVlbmNlX2xlbmd0aCArIG47XG4gICAke3U/XCJsZXQgcHJlc2VudFZhbHVlT2Zmc2V0ID0gYWJzS3ZIZWFkSWR4ICogdW5pZm9ybXMuTiAqIHVuaWZvcm1zLksgKyBuO1wiOlwiXCJ9XG4gICB2YXIgdmFsdWUgPSAke1AudHlwZS5zdG9yYWdlfSgwKTtcbiAgIGZvciAodmFyIHc6IHUzMiA9IDB1OyB3IDwgdW5pZm9ybXMuSzsgdyArPSBUSUxFX1NJWkUpIHtcbiAgICAgIGlmIChtIDwgdW5pZm9ybXMuTSAmJiB3ICsgbG9jYWxfaWQueCA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdGlsZVFbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGxvY2FsX2lkLnhdID0gcHJvYnNbb2Zmc2V0QSArIHcgKyBsb2NhbF9pZC54XTtcbiAgICAgIH1cbiAgICAgIGlmIChuIDwgdW5pZm9ybXMuTiAmJiB3ICsgbG9jYWxfaWQueSA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdmFyIGlkeCA9IFRJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54O1xuICAgICAgICAkeygoKT0+diYmdT9gXG4gICAgICAgIGlmICh3ICsgbG9jYWxfaWQueSA8IHBhc3Rfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgICAgdGlsZVZbaWR4XSA9IHBhc3RfdmFsdWVbcGFzdFZhbHVlT2Zmc2V0ICsgKHcgKyBsb2NhbF9pZC55KSAqIHVuaWZvcm1zLk5dO1xuICAgICAgICB9IGVsc2UgaWYgKHcgKyBsb2NhbF9pZC55IC0gcGFzdF9zZXF1ZW5jZV9sZW5ndGggPCB1bmlmb3Jtcy5rdl9zZXF1ZW5jZV9sZW5ndGgpIHtcbiAgICAgICAgICB0aWxlVltpZHhdID0gdlt2T2Zmc2V0ICsgKHcgKyBsb2NhbF9pZC55IC0gcGFzdF9zZXF1ZW5jZV9sZW5ndGgpICogdW5pZm9ybXMuTl07XG4gICAgICAgIH1cbiAgICAgIGA6YFxuICAgICAgICAgICAgaWYgKHcgKyBsb2NhbF9pZC55IDwgdW5pZm9ybXMua3Zfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHRpbGVWW2lkeF0gPSB2W3ZPZmZzZXQgKyAodyArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMuTl07XG4gICAgICAgICAgICB9YCkoKX1cbiAgICAgICAgJHt1P2BcbiAgICAgICAgICAgIGlmICh3ICsgbG9jYWxfaWQueSA8IHByZXNlbnRfc2VxdWVuY2VfbGVuZ3RoKSB7XG4gICAgICAgICAgcHJlc2VudF92YWx1ZVtwcmVzZW50VmFsdWVPZmZzZXQgKyAodyArIGxvY2FsX2lkLnkpICogdW5pZm9ybXMuTl0gPSB0aWxlVltpZHhdO1xuICAgICAgICB9YDpcIlwifVxuICAgICAgfVxuICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgIGZvciAodmFyIGs6IHUzMiA9IDB1OyBrIDwgVElMRV9TSVpFICYmIHcrayA8IHRvdGFsX3NlcXVlbmNlX2xlbmd0aDsgaysrKSB7XG4gICAgICAgdmFsdWUgKz0gdGlsZVFbVElMRV9TSVpFICogbG9jYWxfaWQueSArIGtdICogdGlsZVZbVElMRV9TSVpFICogayArIGxvY2FsX2lkLnhdO1xuICAgICB9XG4gICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgIH1cblxuICAgLy8gd2UgbmVlZCB0byB0cmFuc3Bvc2Ugb3V0cHV0IGZyb20gQk5TSF92IHRvIEJTTkRfdlxuICAgaWYgKG0gPCB1bmlmb3Jtcy5NICYmIG4gPCB1bmlmb3Jtcy5OKSB7XG4gICAgIGxldCBvdXRwdXRJZHggPSBiYXRjaElkeCAqIHVuaWZvcm1zLk0gKiB1bmlmb3Jtcy52X2hpZGRlbl9zaXplICsgbSAqIHVuaWZvcm1zLnZfaGlkZGVuX3NpemVcbiAgICAgICArIGhlYWRJZHggKiB1bmlmb3Jtcy5OICsgbjtcbiAgICAgb3V0cHV0W291dHB1dElkeF0gPSB2YWx1ZTtcbiAgIH1cbiAgfWB9O3JldHVybntuYW1lOlwiQXR0ZW50aW9uU2NvcmVcIixzaGFkZXJDYWNoZTp7aGludDpgJHtuIT09dm9pZCAwfTske2V9YCxpbnB1dERlcGVuZGVuY2llczpTfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6VCxkaXNwYXRjaEdyb3VwOngscHJvZ3JhbVVuaWZvcm1zOiR9KSxnZXRTaGFkZXJTb3VyY2U6QX19LFJ0PShlLHQscixuLG8saSxhLGQsbCxwLG09dm9pZCAwLHU9dm9pZCAwKT0+e2xldCBoPU1hdGgubWluKGUub3V0cHV0Q291bnQsMSsoYT8xOjApKyhkPzE6MCkpLF89aD4xP3AucGFzdFNlcXVlbmNlTGVuZ3RoOjAseT1fK3Aua3ZTZXF1ZW5jZUxlbmd0aCxnPWwmJkMuc2l6ZShsLmRpbXMpPjA/bDp2b2lkIDAseD1bdCxyXTtoPjEmJmEmJkMuc2l6ZShhLmRpbXMpPjAmJngucHVzaChhKSxnJiZ4LnB1c2goZyksbSYmeC5wdXNoKG0pLHUmJngucHVzaCh1KTtsZXQgJD1lLmNvbXB1dGUoUm0oaCx0LHIsYSxnLHAsXyxtLHUpLHtpbnB1dHM6eCxvdXRwdXRzOmg+MT9bLTEsMV06Wy0xXX0pWzBdO2UuY29tcHV0ZShNbSgkLHAuYmF0Y2hTaXplLHAubnVtSGVhZHMsXyxwLnNlcXVlbmNlTGVuZ3RoLHksbSx1KSx7aW5wdXRzOm0mJnU/WyQsbSx1XTpbJF0sb3V0cHV0czpbXX0pO2xldCB2PVskLG5dO2g+MSYmZCYmQy5zaXplKGQuZGltcyk+MCYmdi5wdXNoKGQpLG0mJnYucHVzaChtKSx1JiZ2LnB1c2godSksZS5jb21wdXRlKFVtKGgsJCxuLGQscCxfLG0sdSkse2lucHV0czp2LG91dHB1dHM6aD4xP1swLDJdOlswXX0pfSxObT0oZSx0KT0+e2xldCByPVt0LmJhdGNoU2l6ZSx0Lm51bUhlYWRzLHQuc2VxdWVuY2VMZW5ndGgsdC5oZWFkU2l6ZV0sbj10LnNlcXVlbmNlTGVuZ3RoLG89dC5pbnB1dEhpZGRlblNpemUsaT10LmhlYWRTaXplLGE9MTIsZD17eDpNYXRoLmNlaWwodC5oZWFkU2l6ZS9hKSx5Ok1hdGguY2VpbCh0LnNlcXVlbmNlTGVuZ3RoL2EpLHo6dC5iYXRjaFNpemUqdC5udW1IZWFkc30sbD1bZS5pbnB1dHNbMF0sZS5pbnB1dHNbMV0sZS5pbnB1dHNbMl1dLHA9W3t0eXBlOjEyLGRhdGE6bn0se3R5cGU6MTIsZGF0YTpvfSx7dHlwZToxMixkYXRhOml9LHt0eXBlOjEyLGRhdGE6dC5udW1IZWFkc30se3R5cGU6MTIsZGF0YTp0LmhlYWRTaXplfSx7dHlwZToxMixkYXRhOnQuaGlkZGVuU2l6ZX0se3R5cGU6MTIsZGF0YTp0LmhpZGRlblNpemUrdC5oaWRkZW5TaXplK3QudkhpZGRlblNpemV9XSxtPXU9PntsZXQgaD1NKFwib3V0cHV0X3FcIixsWzBdLmRhdGFUeXBlLHIpLF89TShcIm91dHB1dF9rXCIsbFswXS5kYXRhVHlwZSxyKSx5PU0oXCJvdXRwdXRfdlwiLGxbMF0uZGF0YVR5cGUsciksZz1FKFwiaW5wdXRcIixsWzBdLmRhdGFUeXBlLGxbMF0uZGltcykseD1FKFwid2VpZ2h0XCIsbFsxXS5kYXRhVHlwZSxsWzFdLmRpbXMpLCQ9RShcImJpYXNcIixsWzJdLmRhdGFUeXBlLGxbMl0uZGltcyksdj1nLnR5cGUuc3RvcmFnZSxTPVt7bmFtZTpcIk1cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiS1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJOXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIm51bV9oZWFkc1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJoZWFkX3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiaGlkZGVuX3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwibGRiXCIsdHlwZTpcInUzMlwifV07cmV0dXJuYFxuICBjb25zdCBUSUxFX1NJWkUgPSAke2F9dTtcbiAgdmFyPHdvcmtncm91cD4gdGlsZUlucHV0OiBhcnJheTwke3Z9LCAke2EqYX0+O1xuICB2YXI8d29ya2dyb3VwPiB0aWxlV2VpZ2h0UTogYXJyYXk8JHt2fSwgJHthKmF9PjtcbiAgdmFyPHdvcmtncm91cD4gdGlsZVdlaWdodEs6IGFycmF5PCR7dn0sICR7YSphfT47XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVXZWlnaHRWOiBhcnJheTwke3Z9LCAke2EqYX0+O1xuICAke3UucmVnaXN0ZXJVbmlmb3JtcyhTKS5kZWNsYXJlVmFyaWFibGVzKGcseCwkLGgsXyx5KX1cbiAgJHt1Lm1haW5TdGFydChbYSxhLDFdKX1cbiAgICBsZXQgYmF0Y2hJbmRleCA9IHdvcmtncm91cF9pZC56IC8gdW5pZm9ybXMubnVtX2hlYWRzO1xuICAgIGxldCBoZWFkTnVtYmVyID0gd29ya2dyb3VwX2lkLnogJSB1bmlmb3Jtcy5udW1faGVhZHM7XG4gICAgbGV0IG0gPSBnbG9iYWxfaWQueTtcbiAgICBsZXQgbiA9IGdsb2JhbF9pZC54O1xuXG4gICAgbGV0IGlucHV0T2Zmc2V0ID0gYmF0Y2hJbmRleCAqICh1bmlmb3Jtcy5NICogdW5pZm9ybXMuSykgKyBtICogdW5pZm9ybXMuSztcbiAgICBsZXQgYmlhc09mZnNldFEgPSBoZWFkTnVtYmVyICogdW5pZm9ybXMuaGVhZF9zaXplO1xuICAgIGxldCBiaWFzT2Zmc2V0SyA9IHVuaWZvcm1zLmhpZGRlbl9zaXplICsgYmlhc09mZnNldFE7XG4gICAgbGV0IGJpYXNPZmZzZXRWID0gdW5pZm9ybXMuaGlkZGVuX3NpemUgKyBiaWFzT2Zmc2V0SztcblxuICAgIHZhciB2YWx1ZVEgPSAke3Z9KDApO1xuICAgIHZhciB2YWx1ZUsgPSAke3Z9KDApO1xuICAgIHZhciB2YWx1ZVYgPSAke3Z9KDApO1xuICAgIGZvciAodmFyIHc6IHUzMiA9IDB1OyB3IDwgdW5pZm9ybXMuSzsgdyArPSBUSUxFX1NJWkUpIHtcbiAgICAgIGlmIChtIDwgdW5pZm9ybXMuTSAmJiB3ICsgbG9jYWxfaWQueCA8IHVuaWZvcm1zLkspIHtcbiAgICAgICAgdGlsZUlucHV0W1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IGlucHV0W2lucHV0T2Zmc2V0ICsgdyArIGxvY2FsX2lkLnhdO1xuICAgICAgfVxuICAgICAgaWYgKG4gPCB1bmlmb3Jtcy5OICYmIHcgKyBsb2NhbF9pZC55IDwgdW5pZm9ybXMuSykge1xuICAgICAgICBsZXQgb2Zmc2V0ID0gbiArICh3ICsgbG9jYWxfaWQueSkgKiB1bmlmb3Jtcy5sZGI7XG4gICAgICAgIHRpbGVXZWlnaHRRW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IHdlaWdodFtiaWFzT2Zmc2V0USArIG9mZnNldF07XG4gICAgICAgIHRpbGVXZWlnaHRLW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IHdlaWdodFtiaWFzT2Zmc2V0SyArIG9mZnNldF07XG4gICAgICAgIHRpbGVXZWlnaHRWW1RJTEVfU0laRSAqIGxvY2FsX2lkLnkgKyBsb2NhbF9pZC54XSA9IHdlaWdodFtiaWFzT2Zmc2V0ViArIG9mZnNldF07XG4gICAgICB9XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgICBmb3IgKHZhciBrOiB1MzIgPSAwdTsgazxUSUxFX1NJWkUgJiYgdytrIDwgdW5pZm9ybXMuSzsgaysrKSB7XG4gICAgICAgIGxldCBpbnB1dFRpbGVPZmZzZXQgPSBUSUxFX1NJWkUgKiBsb2NhbF9pZC55ICsgaztcbiAgICAgICAgbGV0IHdlaWdodFRpbGVPZmZzZXQgPSBUSUxFX1NJWkUgKiBrICsgbG9jYWxfaWQueDtcbiAgICAgICAgdmFsdWVRICs9IHRpbGVJbnB1dFtpbnB1dFRpbGVPZmZzZXRdICogdGlsZVdlaWdodFFbd2VpZ2h0VGlsZU9mZnNldF07XG4gICAgICAgIHZhbHVlSyArPSB0aWxlSW5wdXRbaW5wdXRUaWxlT2Zmc2V0XSAqIHRpbGVXZWlnaHRLW3dlaWdodFRpbGVPZmZzZXRdO1xuICAgICAgICB2YWx1ZVYgKz0gdGlsZUlucHV0W2lucHV0VGlsZU9mZnNldF0gKiB0aWxlV2VpZ2h0Vlt3ZWlnaHRUaWxlT2Zmc2V0XTtcbiAgICAgIH1cblxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgIH1cblxuICAgIGxldCBoZWFkT2Zmc2V0ID0gKG0gKiB1bmlmb3Jtcy5OICsgbikgJSB1bmlmb3Jtcy5oZWFkX3NpemU7XG4gICAgdmFsdWVRICs9IGJpYXNbaGVhZE9mZnNldCArIGJpYXNPZmZzZXRRXTtcbiAgICB2YWx1ZUsgKz0gYmlhc1toZWFkT2Zmc2V0ICsgYmlhc09mZnNldEtdO1xuICAgIHZhbHVlViArPSBiaWFzW2hlYWRPZmZzZXQgKyBiaWFzT2Zmc2V0Vl07XG5cbiAgICBsZXQgb2Zmc2V0ID0gd29ya2dyb3VwX2lkLnogKiB1bmlmb3Jtcy5NICogdW5pZm9ybXMuTjtcbiAgICBpZiAobSA8IHVuaWZvcm1zLk0gJiYgbiA8IHVuaWZvcm1zLk4pIHtcbiAgICAgIGxldCBvdXRwdXRJZHggPSBvZmZzZXQgKyBtICogdW5pZm9ybXMuTiArIG47XG4gICAgICBvdXRwdXRfcVtvdXRwdXRJZHhdID0gdmFsdWVRO1xuICAgICAgb3V0cHV0X2tbb3V0cHV0SWR4XSA9IHZhbHVlSztcbiAgICAgIG91dHB1dF92W291dHB1dElkeF0gPSB2YWx1ZVY7XG4gICAgfVxuICB9YH07cmV0dXJuIGUuY29tcHV0ZSh7bmFtZTpcIkF0dGVudGlvblByZXBhcmVcIixzaGFkZXJDYWNoZTp7aW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiLFwidHlwZVwiLFwidHlwZVwiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpyLGRhdGFUeXBlOmUuaW5wdXRzWzBdLmRhdGFUeXBlLGdwdURhdGFUeXBlOjB9LHtkaW1zOnIsZGF0YVR5cGU6ZS5pbnB1dHNbMF0uZGF0YVR5cGUsZ3B1RGF0YVR5cGU6MH0se2RpbXM6cixkYXRhVHlwZTplLmlucHV0c1swXS5kYXRhVHlwZSxncHVEYXRhVHlwZTowfV0sZGlzcGF0Y2hHcm91cDpkLHByb2dyYW1Vbmlmb3JtczpwfSksZ2V0U2hhZGVyU291cmNlOm19LHtpbnB1dHM6bCxvdXRwdXRzOlstMSwtMSwtMV19KX0senM9KGUsdCk9PntsZXQgcj1CbShlLmlucHV0cyx0KSxbbixvLGldPU5tKGUscik7cmV0dXJuIFJ0KGUsbixvLGksZS5pbnB1dHNbNF0sdm9pZCAwLHZvaWQgMCx2b2lkIDAsZS5pbnB1dHNbNV0scil9fSk7dmFyIFZtLFdtLExtLE9zLERzPVUoKCk9PntcInVzZSBzdHJpY3RcIjtXZSgpO3RlKCk7b2UoKTtTZSgpO2FlKCk7Vm09KGUsdCk9PntpZighZXx8ZS5sZW5ndGghPT01KXRocm93IG5ldyBFcnJvcihcIkJhdGNoTm9ybWFsaXphdGlvbiByZXF1aXJlcyA1IGlucHV0c1wiKTtsZXQgcj0obixvLGkpPT57bGV0IGE9by5sZW5ndGg7aWYoYSE9PW4ubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgJHtpfTogbnVtIGRpbWVuc2lvbnMgIT0gJHthfWApO28uZm9yRWFjaCgoZCxsKT0+e2lmKGQhPT1uW2xdKXRocm93IG5ldyBFcnJvcihgJHtpfTogZGltWyR7bH1dIGRvIG5vdCBtYXRjaGApfSl9O2lmKGVbMF0uZGltcy5sZW5ndGg+MSl7bGV0IG49dC5mb3JtYXQ9PT1cIk5IV0NcIj90LnNwYXRpYWw/ZVswXS5kaW1zLnNsaWNlKC0xKTplWzBdLmRpbXMuc2xpY2UoLTEpLmNvbmNhdChlWzBdLmRpbXMuc2xpY2UoMSxlWzBdLmRpbXMubGVuZ3RoLTEpKTplWzBdLmRpbXMuc2xpY2UoMSx0LnNwYXRpYWw/Mjp2b2lkIDApO3IoZVsxXS5kaW1zLG4sXCJJbnZhbGlkIGlucHV0IHNjYWxlXCIpLHIoZVsyXS5kaW1zLG4sXCJJbnZhbGlkIGlucHV0IEJcIikscihlWzNdLmRpbXMsbixcIkludmFsaWQgaW5wdXQgbWVhblwiKSxyKGVbNF0uZGltcyxuLFwiSW52YWxpZCBpbnB1dCB2YXJcIil9ZWxzZSByKGVbMV0uZGltcyxbMV0sXCJJbnZhbGlkIGlucHV0IHNjYWxlXCIpLHIoZVsyXS5kaW1zLFsxXSxcIkludmFsaWQgaW5wdXQgQlwiKSxyKGVbM10uZGltcyxbMV0sXCJJbnZhbGlkIGlucHV0IG1lYW5cIikscihlWzRdLmRpbXMsWzFdLFwiSW52YWxpZCBpbnB1dCB2YXJcIil9LFdtPShlLHQpPT57bGV0e2Vwc2lsb246cixzcGF0aWFsOm4sZm9ybWF0Om99PXQsaT1lWzBdLmRpbXMsYT1uP21lKGlbaS5sZW5ndGgtMV0pOjEsZD1vPT09XCJOSFdDXCImJmkubGVuZ3RoPjE/YToxLGw9Qy5zaXplKGkpL2EscD1uLG09cD9pLmxlbmd0aDppLHU9RShcInhcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcyxhKSxoPUUoXCJzY2FsZVwiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zLGQpLF89RShcImJpYXNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcyxkKSx5PUUoXCJpbnB1dE1lYW5cIixlWzNdLmRhdGFUeXBlLGVbM10uZGltcyxkKSxnPUUoXCJpbnB1dFZhclwiLGVbNF0uZGF0YVR5cGUsZVs0XS5kaW1zLGQpLHg9TShcInlcIixlWzBdLmRhdGFUeXBlLG0sYSksJD0oKT0+e2xldCBTPVwiXCI7aWYobilTPWBsZXQgY09mZnNldCA9ICR7aS5sZW5ndGg9PT0xP1wiMHVcIjpvPT09XCJOSFdDXCI/YG91dHB1dEluZGljZXNbJHtpLmxlbmd0aC0xfV0gLyAke2F9YDpcIm91dHB1dEluZGljZXNbMV1cIn07YDtlbHNlIGlmKG89PT1cIk5DSFdcIilTPWBcbiAgICAgICAgICAgICR7eC5pbmRpY2VzU2V0KFwib3V0cHV0SW5kaWNlc1wiLFwiMFwiLFwiMFwiKX1cbiAgICAgICAgICAgIGxldCBjT2Zmc2V0ID0gJHt4LmluZGljZXNUb09mZnNldChcIm91dHB1dEluZGljZXNcIil9O2A7ZWxzZXtTPWB2YXIgY0luZGljZXMgPSAke2gudHlwZS5pbmRpY2VzfSgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgY0luZGljZXNbMF0gPSBvdXRwdXRJbmRpY2VzWyR7aS5sZW5ndGgtMX1dO2A7Zm9yKGxldCBUPTE7VDxoLnJhbms7VCsrKVMrPWBjSW5kaWNlc1ske1R9XSA9IG91dHB1dEluZGljZXNbJHtUfV07YDtTKz1gbGV0IGNPZmZzZXQgPSAke2guaW5kaWNlc1RvT2Zmc2V0KFwiY0luZGljZXNcIil9O2B9cmV0dXJuIFN9LHY9Uz0+YFxuICBjb25zdCBlcHNpbG9uID0gJHtyfTtcbiAgJHtTLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dFNpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKHUsaCxfLHksZyx4KX1cbiAgJHtTLm1haW5TdGFydCgpfVxuICAke1MuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG4gICAgdmFyIG91dHB1dEluZGljZXMgPSAke3gub2Zmc2V0VG9JbmRpY2VzKGBnbG9iYWxfaWR4ICogJHthfWApfTtcbiAgICAkeyQoKX1cbiAgICBsZXQgc2NhbGUgPSAke2guZ2V0QnlPZmZzZXQoXCJjT2Zmc2V0XCIpfTtcbiAgICBsZXQgYmlhcyA9ICR7Xy5nZXRCeU9mZnNldChcImNPZmZzZXRcIil9O1xuICAgIGxldCBpbnB1dE1lYW4gPSAke3kuZ2V0QnlPZmZzZXQoXCJjT2Zmc2V0XCIpfTtcbiAgICBsZXQgaW5wdXRWYXIgPSAke2cuZ2V0QnlPZmZzZXQoXCJjT2Zmc2V0XCIpfTtcbiAgICBsZXQgeCA9ICR7dS5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIil9O1xuICAgIGxldCB2YWx1ZSA9ICh4IC0gaW5wdXRNZWFuKSAqIGludmVyc2VTcXJ0KGlucHV0VmFyICsgZXBzaWxvbikgKiBzY2FsZSArIGJpYXM7XG4gICAgJHt4LnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIil9XG4gIH1gO3JldHVybntuYW1lOlwiQmF0Y2hOb3JtYWxpemF0aW9uXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5lcHNpbG9ufV8ke3QuZm9ybWF0fV8ke259XyR7YX1gLGlucHV0RGVwZW5kZW5jaWVzOnA/W1wicmFua1wiLFwidHlwZVwiLFwidHlwZVwiLFwidHlwZVwiLFwidHlwZVwiXTp2b2lkIDB9LGdldFNoYWRlclNvdXJjZTp2LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6ZVswXS5kaW1zLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChsLzY0KX0scHJvZ3JhbVVuaWZvcm1zOnA/W3t0eXBlOjEyLGRhdGE6bH0sLi4uTihpKV06W3t0eXBlOjEyLGRhdGE6bH1dfSl9fSxMbT1lPT5yZShlKSxPcz0oZSx0KT0+e2xldHtpbnB1dHM6cixvdXRwdXRDb3VudDpufT1lLG89TG0oey4uLnQsb3V0cHV0Q291bnQ6bn0pO2lmKHZlLndlYmdwdS52YWxpZGF0ZUlucHV0Q29udGVudCYmVm0ocixvKSx0LnRyYWluaW5nTW9kZSl0aHJvdyBuZXcgRXJyb3IoXCJCYXRjaE5vcm1hbGl6YXRpb24gdHJhaW5pbmdNb2RlIGlzIG5vdCBzdXBwb3J0ZWQgeWV0LlwiKTtlLmNvbXB1dGUoV20ocixvKSl9fSk7dmFyIEdtLEhtLEJzLE1zPVUoKCk9PntcInVzZSBzdHJpY3RcIjtvZSgpO2FlKCk7R209ZT0+e2lmKGVbMF0uZGltcy5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcihcImlucHV0IHNob3VsZCBoYXZlIDMgZGltZW5zaW9uc1wiKTtpZighWzMyMCw2NDAsMTI4MF0uaW5jbHVkZXMoZVswXS5kaW1zWzJdKSl0aHJvdyBuZXcgRXJyb3IoXCJudW1iZXIgb2YgY2hhbm5lbHMgc2hvdWxkIGJlIDMyMCwgNjQwIG9yIDEyODBcIik7aWYoZVsxXS5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiYmlhcyBpcyBleHBlY3RlZCB0byBoYXZlIDEgZGltZW5zaW9uc1wiKTtpZihlWzBdLmRpbXNbMl0hPT1lWzFdLmRpbXNbMF0pdGhyb3cgbmV3IEVycm9yKFwibGFzdCBkaW1lbnNpb24gb2YgaW5wdXQgYW5kIGJpYXMgYXJlIG5vdCB0aGUgc2FtZVwiKX0sSG09ZT0+e2xldCB0PWVbMF0uZGltcyxyPWVbMF0uZGltc1syXSxuPUMuc2l6ZSh0KS80LG89ZVswXS5kYXRhVHlwZSxpPUUoXCJpbnB1dFwiLG8sdCw0KSxhPUUoXCJiaWFzXCIsbyxbcl0sNCksZD1FKFwicmVzaWR1YWxcIixvLHQsNCksbD1NKFwib3V0cHV0XCIsbyx0LDQpO3JldHVybntuYW1lOlwiQmlhc0FkZFwiLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6dCxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwobi82NCl9fSksZ2V0U2hhZGVyU291cmNlOm09PmBcbiAgY29uc3QgY2hhbm5lbHMgPSAke3J9dSAvIDQ7XG4gICR7bS5kZWNsYXJlVmFyaWFibGVzKGksYSxkLGwpfVxuXG4gICR7bS5tYWluU3RhcnQoKX1cbiAgICAke20uZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhuKX1cbiAgICBsZXQgdmFsdWUgPSAke2kuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpfVxuICAgICAgKyAke2EuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4ICUgY2hhbm5lbHNcIil9ICsgJHtkLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgJHtsLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwidmFsdWVcIil9XG4gIH1gfX0sQnM9ZT0+e0dtKGUuaW5wdXRzKSxlLmNvbXB1dGUoSG0oZS5pbnB1dHMpKX19KTt2YXIgRm0sZmUsUnMsVXMsTnMsVnMsV3MsTHMsR3MsSHMsRnMscW0scXMsS3MsanMsWXMsWHQsWnMscXIsUXMsWHMsSnMsZXUsdHUscnUsbnUsb3UsaXUsYXUsc3UsdXUsZHUsbHUsY3UscHUsbXUsZnUsbW8sZm8saHUsZ3UsYnUsS20sam0seXUsS3I9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTtTZSgpO2FlKCk7Rm09KGUsdCxyLG4sbyxpLGEpPT57bGV0IGQ9TWF0aC5jZWlsKHQvNCksbD1cIlwiO3R5cGVvZiBvPT1cInN0cmluZ1wiP2w9YCR7b30oYSlgOmw9byhcImFcIik7bGV0IHA9RShcImlucHV0RGF0YVwiLHIsW2RdLDQpLG09TShcIm91dHB1dERhdGFcIixuLFtkXSw0KSx1PVt7bmFtZTpcInZlY19zaXplXCIsdHlwZTpcInUzMlwifV07cmV0dXJuIGEmJnUucHVzaCguLi5hKSxgXG4gICAgICAke2UucmVnaXN0ZXJVbmlmb3Jtcyh1KS5kZWNsYXJlVmFyaWFibGVzKHAsbSl9XG5cbiAgJHtpPz9cIlwifVxuXG4gICR7ZS5tYWluU3RhcnQoKX1cbiAgICAke2UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLnZlY19zaXplXCIpfVxuXG4gICAgbGV0IGEgPSAke3AuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAke20uc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsbCl9XG4gIH1gfSxmZT0oZSx0LHIsbixvLGk9ZS5kYXRhVHlwZSxhLGQpPT57bGV0IGw9W3t0eXBlOjEyLGRhdGE6TWF0aC5jZWlsKEMuc2l6ZShlLmRpbXMpLzQpfV07cmV0dXJuIGEmJmwucHVzaCguLi5hKSx7bmFtZTp0LHNoYWRlckNhY2hlOntoaW50Om8saW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiXX0sZ2V0U2hhZGVyU291cmNlOnA9PkZtKHAsQy5zaXplKGUuZGltcyksZS5kYXRhVHlwZSxpLHIsbixkKSxnZXRSdW5EYXRhOnA9Pih7b3V0cHV0czpbe2RpbXM6ZS5kaW1zLGRhdGFUeXBlOml9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChDLnNpemUocFswXS5kaW1zKS82NC80KX0scHJvZ3JhbVVuaWZvcm1zOmx9KX19LFJzPWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJBYnNcIixcImFic1wiKSl9LFVzPWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJBY29zXCIsXCJhY29zXCIpKX0sTnM9ZT0+e2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIkFjb3NoXCIsXCJhY29zaFwiKSl9LFZzPWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJBc2luXCIsXCJhc2luXCIpKX0sV3M9ZT0+e2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIkFzaW5oXCIsXCJhc2luaFwiKSl9LExzPWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJBdGFuXCIsXCJhdGFuXCIpKX0sR3M9ZT0+e2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIkF0YW5oXCIsXCJhdGFuaFwiKSl9LEhzPWU9PnJlKGUpLEZzPShlLHQpPT57bGV0IHI7c3dpdGNoKHQudG8pe2Nhc2UgMTA6cj1cInZlYzQ8ZjE2PlwiO2JyZWFrO2Nhc2UgMTpyPVwidmVjNDxmMzI+XCI7YnJlYWs7Y2FzZSAxMjpyPVwidmVjNDx1MzI+XCI7YnJlYWs7Y2FzZSA2OnI9XCJ2ZWM0PGkzMj5cIjticmVhaztjYXNlIDk6cj1cInZlYzQ8Ym9vbD5cIjticmVhaztkZWZhdWx0OnRocm93IG5ldyBSYW5nZUVycm9yKGBub3Qgc3VwcG9ydGVkIHR5cGUgKHNwZWNpZmllZCBpbiBhdHRyaWJ1dGUgJ3RvJyBmcm9tICdDYXN0JyBvcGVyYXRvcik6ICR7dC50b31gKX1lLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJDYXN0XCIscix2b2lkIDAsdC5jYWNoZUtleSx0LnRvKSl9LHFtPWU9PntsZXQgdCxyLG49ZS5sZW5ndGg+PTImJmVbMV0uZGF0YSE9PTAsbz1lLmxlbmd0aD49MyYmZVsyXS5kYXRhIT09MDtzd2l0Y2goZVswXS5kYXRhVHlwZSl7Y2FzZSAxOnQ9bj9lWzFdLmdldEZsb2F0MzJBcnJheSgpWzBdOi0zNDAyODIzNDY2Mzg1Mjg4NmUyMixyPW8/ZVsyXS5nZXRGbG9hdDMyQXJyYXkoKVswXTozNDAyODIzNDY2Mzg1Mjg4NmUyMjticmVhaztjYXNlIDEwOnQ9bj9lWzFdLmdldFVpbnQxNkFycmF5KClbMF06NjQ1MTEscj1vP2VbMl0uZ2V0VWludDE2QXJyYXkoKVswXTozMTc0MzticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydCBkYXRhIHR5cGVcIil9cmV0dXJuIHJlKHttaW46dCxtYXg6cn0pfSxxcz0oZSx0KT0+e2xldCByPXR8fHFtKGUuaW5wdXRzKSxuPUVlKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJDbGlwXCIsbz0+YGNsYW1wKCR7b30sIHZlYzQ8JHtufT4odW5pZm9ybXMubWluKSwgdmVjNDwke259Pih1bmlmb3Jtcy5tYXgpKWAsdm9pZCAwLHIuY2FjaGVLZXksdm9pZCAwLFt7dHlwZTplLmlucHV0c1swXS5kYXRhVHlwZSxkYXRhOnIubWlufSx7dHlwZTplLmlucHV0c1swXS5kYXRhVHlwZSxkYXRhOnIubWF4fV0sW3tuYW1lOlwibWluXCIsdHlwZTpufSx7bmFtZTpcIm1heFwiLHR5cGU6bn1dKSx7aW5wdXRzOlswXX0pfSxLcz1lPT57ZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiQ2VpbFwiLFwiY2VpbFwiKSl9LGpzPWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJDb3NcIixcImNvc1wiKSl9LFlzPWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJDb3NoXCIsXCJjb3NoXCIpKX0sWHQ9ZT0+cmUoZSksWnM9KGUsdCk9PntsZXQgcj1FZShlLmlucHV0c1swXS5kYXRhVHlwZSk7ZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiRWx1XCIsbj0+YGVsdV92ZjMyKCR7bn0pYCxgXG4gIGNvbnN0IGVsdV9hbHBoYV8gPSAke3J9KCR7dC5hbHBoYX0pO1xuXG4gIGZuIGVsdV9mMzIoYTogJHtyfSkgLT4gJHtyfSB7XG4gIHJldHVybiBzZWxlY3QoKGV4cChhKSAtIDEuMCkgKiBlbHVfYWxwaGFfLCBhLCBhID49IDAuMCk7XG4gIH1cblxuICBmbiBlbHVfdmYzMih2OiB2ZWM0PCR7cn0+KSAtPiB2ZWM0PCR7cn0+IHtcbiAgcmV0dXJuIHZlYzQoZWx1X2YzMih2LngpLCBlbHVfZjMyKHYueSksIGVsdV9mMzIodi56KSwgZWx1X2YzMih2LncpKTtcbiAgfWAsdC5jYWNoZUtleSkpfSxxcj0oZT1cImYzMlwiKT0+YFxuY29uc3QgcjA6ICR7ZX0gPSAwLjMyNzU5MTE7XG5jb25zdCByMTogJHtlfSA9IDAuMjU0ODI5NTkyO1xuY29uc3QgcjI6ICR7ZX0gPSAtMC4yODQ0OTY3MzY7XG5jb25zdCByMzogJHtlfSA9IDEuNDIxNDEzNzQxO1xuY29uc3QgcjQ6ICR7ZX0gPSAtMS40NTMxNTIwMjc7XG5jb25zdCByNTogJHtlfSA9IDEuMDYxNDA1NDI5O1xuXG5mbiBlcmZfdmYzMih2OiB2ZWM0PCR7ZX0+KSAtPiB2ZWM0PCR7ZX0+IHtcbiAgbGV0IGFic3YgPSBhYnModik7XG4gIGxldCB4ID0gMS4wIC8gKDEuMCArIHIwICogYWJzdik7XG4gIHJldHVybiBzaWduKHYpICogKDEuMCAtICgoKChyNSAqIHggKyByNCkgKiB4ICsgcjMpICogeCArIHIyKSAqIHggKyByMSkgKiB4ICogZXhwKC1hYnN2ICogYWJzdikpO1xufWAsUXM9ZT0+e2xldCB0PUVlKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJFcmZcIixyPT5gZXJmX3ZmMzIoJHtyfSlgLHFyKHQpKSl9LFhzPWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJFeHBcIixcImV4cFwiKSl9LEpzPWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJGbG9vclwiLFwiZmxvb3JcIikpfSxldT1lPT57bGV0IHQ9RWUoZS5pbnB1dHNbMF0uZGF0YVR5cGUpO2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIkdlbHVcIixyPT5gMC41ICogJHtyfSAqICgxLjAgKyBlcmZfdmYzMigke3J9ICogMC43MDcxMDY3ODExODY1NDc1KSlgLHFyKHQpKSl9LHR1PShlLHQpPT57bGV0IHI9RWUoZS5pbnB1dHNbMF0uZGF0YVR5cGUpO2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIkxlYWt5UmVsdVwiLG49PmBzZWxlY3QobGVha3lfcmVsdV9hbHBoYV8gKiAke259LCAke259LCAke259ID49IHZlYzQ8JHtyfT4oMC4wKSlgLGBjb25zdCBsZWFreV9yZWx1X2FscGhhXyA9ICR7cn0oJHt0LmFscGhhfSk7YCx0LmNhY2hlS2V5KSl9LHJ1PWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJOb3RcIix0PT5gISR7dH1gKSl9LG51PWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJOZWdcIix0PT5gLSR7dH1gKSl9LG91PWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJSZWNpcHJvY2FsXCIsdD0+YDEuMC8ke3R9YCkpfSxpdT1lPT57bGV0IHQ9RWUoZS5pbnB1dHNbMF0uZGF0YVR5cGUpO2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIlJlbHVcIixyPT5gc2VsZWN0KHZlYzQ8JHt0fT4oMC4wKSwgJHtyfSwgJHtyfSA+IHZlYzQ8JHt0fT4oMC4wKSlgKSl9LGF1PWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJTaWdtb2lkXCIsdD0+YCgxLjAgLyAoMS4wICsgZXhwKC0ke3R9KSkpYCkpfSxzdT1lPT5yZShlKSx1dT0oZSx0KT0+e2xldCByPUVlKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJIYXJkU2lnbW9pZFwiLG49PmBtYXgodmVjNDwke3J9PigwLjApLCBtaW4odmVjNDwke3J9PigxLjApLCAke3QuYWxwaGF9ICogJHtufSArIHZlYzQ8JHtyfT4oJHt0LmJldGF9KSkpYCx2b2lkIDAsdC5jYWNoZUtleSkpfSxkdT1lPT57ZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiU2luXCIsXCJzaW5cIikpfSxsdT1lPT57ZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiU2luaFwiLFwic2luaFwiKSl9LGN1PWU9PntlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJTcXJ0XCIsXCJzcXJ0XCIpKX0scHU9ZT0+e2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIlRhblwiLFwidGFuXCIpKX0sbXU9ZT0+YHNpZ24oJHtlfSkgKiAoMSAtIGV4cCgtMiAqIGFicygke2V9KSkpIC8gKDEgKyBleHAoLTIgKiBhYnMoJHtlfSkpKWAsZnU9ZT0+e2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIlRhbmhcIixtdSkpfSxtbz0oZT1cImYzMlwiKT0+YFxuY29uc3QgZmFzdF9nZWx1X2E6ICR7ZX0gPSAwLjU7XG5jb25zdCBmYXN0X2dlbHVfYjogJHtlfSA9IDAuNzk3ODg0NTYwODAyODY1NDtcbmNvbnN0IGZhc3RfZ2VsdV9jOiAke2V9ID0gMC4wMzU2Nzc0MDgxMzYzMDAxMjU7XG5cbmZuIHRhbmhfdih2OiB2ZWM0PCR7ZX0+KSAtPiB2ZWM0PCR7ZX0+IHtcbiAgcmV0dXJuICR7bXUoXCJ2XCIpfTtcbn1cbmAsZm89ZT0+YChmYXN0X2dlbHVfYSArIGZhc3RfZ2VsdV9hICogdGFuaF92KCR7ZX0gKiAoZmFzdF9nZWx1X2MgKiAke2V9ICogJHtlfSArIGZhc3RfZ2VsdV9iKSkpICogJHtlfWAsaHU9ZT0+e2xldCB0PUVlKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtlLmNvbXB1dGUoZmUoZS5pbnB1dHNbMF0sXCJGYXN0R2VsdVwiLGZvLG1vKHQpLHZvaWQgMCxlLmlucHV0c1swXS5kYXRhVHlwZSkpfSxndT0oZSx0KT0+e2xldCByPUVlKGUuaW5wdXRzWzBdLmRhdGFUeXBlKTtyZXR1cm4gZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiVGhyZXNob2xkZWRSZWx1XCIsbj0+YHNlbGVjdCh2ZWM0PCR7cn0+KDAuMCksICR7bn0sICR7bn0gPiB0aHJlc2hvbGRlZF9yZWx1X2FscGhhXylgLGBjb25zdCB0aHJlc2hvbGRlZF9yZWx1X2FscGhhXyA9IHZlYzQ8JHtyfT4oJHt0LmFscGhhfSk7YCx0LmNhY2hlS2V5KSksMH0sYnU9ZT0+e2UuY29tcHV0ZShmZShlLmlucHV0c1swXSxcIkxvZ1wiLFwibG9nXCIpKX0sS209KGUsdCk9PmBcbmNvbnN0IGFscGhhID0gdmVjNDwke2V9Pigke3R9KTtcbmNvbnN0IG9uZSA9ICR7ZX0oMS4wKTtcbmNvbnN0IHplcm8gPSAke2V9KDAuMCk7XG5cbmZuIHF1aWNrX2dlbHVfaW1wbCh4OiB2ZWM0PCR7ZX0+KSAtPiB2ZWM0PCR7ZX0+IHtcbiAgbGV0IHYgPSB4ICphbHBoYTtcbiAgdmFyIHgxIDogdmVjNDwke2V9PjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpID0gaSArIDEpIHtcbiAgICBpZiAodltpXSA+PSB6ZXJvKSB7XG4gICAgICB4MVtpXSA9IG9uZSAvIChvbmUgKyBleHAoLXZbaV0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeDFbaV0gPSBvbmUgLSBvbmUgLyAob25lICsgZXhwKHZbaV0pKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHggKiB4MTtcbn1cbmAsam09ZT0+YHF1aWNrX2dlbHVfaW1wbCgke2V9KWAseXU9KGUsdCk9PntsZXQgcj1FZShlLmlucHV0c1swXS5kYXRhVHlwZSk7ZS5jb21wdXRlKGZlKGUuaW5wdXRzWzBdLFwiUXVpY2tHZWx1XCIsam0sS20ocix0LmFscGhhKSx0LmNhY2hlS2V5LGUuaW5wdXRzWzBdLmRhdGFUeXBlKSl9fSk7dmFyIFltLFptLHd1LHZ1PVUoKCk9PntcInVzZSBzdHJpY3RcIjtvZSgpO2FlKCk7S3IoKTtZbT1lPT57aWYoZVswXS5kaW1zLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgc2hvdWxkIGhhdmUgMyBkaW1lbnNpb25zXCIpO2lmKCFbMjU2MCw1MTIwLDEwMjQwXS5pbmNsdWRlcyhlWzBdLmRpbXNbMl0pKXRocm93IG5ldyBFcnJvcihcImhpZGRlbiBzdGF0ZSBzaG91bGQgYmUgMjU2MCwgNTEyMCBvciAxMDI0MFwiKTtpZihlWzFdLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJiaWFzIGlzIGV4cGVjdGVkIHRvIGhhdmUgMSBkaW1lbnNpb25zXCIpO2lmKGVbMF0uZGltc1syXSE9PWVbMV0uZGltc1swXSl0aHJvdyBuZXcgRXJyb3IoXCJsYXN0IGRpbWVuc2lvbiBvZiBpbnB1dCBhbmQgYmlhcyBhcmUgbm90IHRoZSBzYW1lXCIpfSxabT1lPT57bGV0IHQ9ZVswXS5kaW1zLnNsaWNlKCk7dFsyXT10WzJdLzI7bGV0IHI9RShcImlucHV0XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMsNCksbj1FKFwiYmlhc1wiLGVbMF0uZGF0YVR5cGUsW2VbMF0uZGltc1syXV0sNCksbz1NKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSx0LDQpLGk9Qy5zaXplKHQpLzQsYT1fZShlWzBdLmRhdGFUeXBlKTtyZXR1cm57bmFtZTpcIkJpYXNTcGxpdEdlbHVcIixnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnQsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGkvNjQpfX0pLGdldFNoYWRlclNvdXJjZTpsPT5gXG4gIGNvbnN0IE1fU1FSVDIgPSBzcXJ0KDIuMCk7XG4gIGNvbnN0IGhhbGZDaGFubmVscyA9ICR7ZVswXS5kaW1zWzJdLzQvMn11O1xuXG4gICR7bC5kZWNsYXJlVmFyaWFibGVzKHIsbixvKX1cblxuICAke3FyKGEpfVxuXG4gICR7bC5tYWluU3RhcnQoKX1cbiAgICAke2wuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhpKX1cbiAgICBsZXQgYmlhc0lkeCA9IGdsb2JhbF9pZHggJSBoYWxmQ2hhbm5lbHM7XG4gICAgbGV0IGJhdGNoSW5kZXggPSBnbG9iYWxfaWR4IC8gaGFsZkNoYW5uZWxzO1xuICAgIGxldCBpbnB1dE9mZnNldCA9IGJpYXNJZHggKyBiYXRjaEluZGV4ICogaGFsZkNoYW5uZWxzICogMjtcbiAgICBsZXQgdmFsdWVMZWZ0ID0gaW5wdXRbaW5wdXRPZmZzZXRdICsgYmlhc1tiaWFzSWR4XTtcbiAgICBsZXQgdmFsdWVSaWdodCA9IGlucHV0W2lucHV0T2Zmc2V0ICsgaGFsZkNoYW5uZWxzXSArIGJpYXNbYmlhc0lkeCArIGhhbGZDaGFubmVsc107XG4gICAgbGV0IGdlbHVSaWdodCA9IHZhbHVlUmlnaHQgKiAwLjUgKiAoZXJmX3ZmMzIodmFsdWVSaWdodCAvIE1fU1FSVDIpICsgMSk7XG5cbiAgICAke28uc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZUxlZnQgKiBnZWx1UmlnaHRcIil9XG4gIH1gfX0sd3U9ZT0+e1ltKGUuaW5wdXRzKSxlLmNvbXB1dGUoWm0oZS5pbnB1dHMpKX19KTt2YXIgUW0sWG0sYXQsJHUseHUsU3UsVHUsSXUsQ3UsQXUsa3UsRXUsUHUsenU9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTthZSgpO1FtPShlLHQscixuLG8saSxhLGQsbCxwLG0sdSk9PntsZXQgaCxfO3R5cGVvZiBkPT1cInN0cmluZ1wiP2g9Xz0odixTKT0+YCR7ZH0oKCR7dn0pLCgke1N9KSlgOnR5cGVvZiBkPT1cImZ1bmN0aW9uXCI/aD1fPWQ6KGg9ZC5zY2FsYXIsXz1kLnZlY3Rvcik7bGV0IHk9TShcIm91dHB1dERhdGFcIixtLG4ubGVuZ3RoLDQpLGc9RShcImFEYXRhXCIsbCx0Lmxlbmd0aCw0KSx4PUUoXCJiRGF0YVwiLHAsci5sZW5ndGgsNCksJDtpZihvKWlmKGkpe2xldCB2PUMuc2l6ZSh0KT09PTEsUz1DLnNpemUocik9PT0xLFQ9dC5sZW5ndGg+MCYmdFt0Lmxlbmd0aC0xXSU0PT09MCxBPXIubGVuZ3RoPjAmJnJbci5sZW5ndGgtMV0lND09PTA7dnx8Uz8kPXkuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXyh2P2Ake2cudHlwZS52YWx1ZX0oJHtnLmdldEJ5T2Zmc2V0KFwiMFwiKX0ueClgOmcuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpLFM/YCR7eC50eXBlLnZhbHVlfSgke3guZ2V0QnlPZmZzZXQoXCIwXCIpfS54KWA6eC5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIikpKTokPWBcbiAgICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHt5Lm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHggKiA0dVwiKX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0QSA9ICR7Zy5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChcIm91dHB1dEluZGljZXNcIix5KX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0QiA9ICR7eC5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChcIm91dHB1dEluZGljZXNcIix5KX07XG4gICAgICAgICAgICAke3kuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXyhhfHxUP2cuZ2V0QnlPZmZzZXQoXCJvZmZzZXRBIC8gNHVcIik6YCR7Zy50eXBlLnZhbHVlfSgke2cuZ2V0QnlPZmZzZXQoXCJvZmZzZXRBIC8gNHVcIil9W29mZnNldEEgJSA0dV0pYCxhfHxBP3guZ2V0QnlPZmZzZXQoXCJvZmZzZXRCIC8gNHVcIik6YCR7eC50eXBlLnZhbHVlfSgke3guZ2V0QnlPZmZzZXQoXCJvZmZzZXRCIC8gNHVcIil9W29mZnNldEIgJSA0dV0pYCkpfVxuICAgICAgICAgIGB9ZWxzZSAkPXkuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXyhnLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSx4LmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKSkpO2Vsc2V7aWYoIWkpdGhyb3cgbmV3IEVycm9yKFwibm8gbmVjZXNzYXJ5IHRvIHVzZSBzY2FsYXIgaW1wbGVtZW50YXRpb24gZm9yIGVsZW1lbnQtd2lzZSBiaW5hcnkgb3AgaW1wbGVtZW50YXRpb24uXCIpO2xldCB2PShTLFQsQT1cIlwiKT0+e2xldCBrPWBhRGF0YVtpbmRleEEke1R9XVtjb21wb25lbnRBJHtUfV1gLFA9YGJEYXRhW2luZGV4QiR7VH1dW2NvbXBvbmVudEIke1R9XWA7cmV0dXJuYFxuICAgICAgICAgICAgbGV0IG91dHB1dEluZGljZXMke1R9ID0gJHt5Lm9mZnNldFRvSW5kaWNlcyhgZ2xvYmFsX2lkeCAqIDR1ICsgJHtUfXVgKX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0QSR7VH0gPSAke2cuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dEluZGljZXMke1R9YCx5KX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0QiR7VH0gPSAke3guYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dEluZGljZXMke1R9YCx5KX07XG4gICAgICAgICAgICBsZXQgaW5kZXhBJHtUfSA9IG9mZnNldEEke1R9IC8gNHU7XG4gICAgICAgICAgICBsZXQgaW5kZXhCJHtUfSA9IG9mZnNldEIke1R9IC8gNHU7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50QSR7VH0gPSBvZmZzZXRBJHtUfSAlIDR1O1xuICAgICAgICAgICAgbGV0IGNvbXBvbmVudEIke1R9ID0gb2Zmc2V0QiR7VH0gJSA0dTtcbiAgICAgICAgICAgICR7U31bJHtUfV0gPSAke0F9KCR7aChrLFApfSk7XG4gICAgICAgICAgYH07bT09PTk/JD1gXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHZlYzQ8dTMyPigwKTtcbiAgICAgICAgICAgICR7dihcImRhdGFcIiwwLFwidTMyXCIpfVxuICAgICAgICAgICAgJHt2KFwiZGF0YVwiLDEsXCJ1MzJcIil9XG4gICAgICAgICAgICAke3YoXCJkYXRhXCIsMixcInUzMlwiKX1cbiAgICAgICAgICAgICR7dihcImRhdGFcIiwzLFwidTMyXCIpfVxuICAgICAgICAgICAgb3V0cHV0RGF0YVtnbG9iYWxfaWR4XSA9IGRvdCh2ZWM0PHUzMj4oMHgxLCAweDEwMCwgMHgxMDAwMCwgMHgxMDAwMDAwKSwgdmVjNDx1MzI+KGRhdGEpKTtgOiQ9YFxuICAgICAgICAgICAgJHt2KFwib3V0cHV0RGF0YVtnbG9iYWxfaWR4XVwiLDApfVxuICAgICAgICAgICAgJHt2KFwib3V0cHV0RGF0YVtnbG9iYWxfaWR4XVwiLDEpfVxuICAgICAgICAgICAgJHt2KFwib3V0cHV0RGF0YVtnbG9iYWxfaWR4XVwiLDIpfVxuICAgICAgICAgICAgJHt2KFwib3V0cHV0RGF0YVtnbG9iYWxfaWR4XVwiLDMpfVxuICAgICAgICAgIGB9cmV0dXJuYFxuICAgICAgICAke2UucmVnaXN0ZXJVbmlmb3JtKFwidmVjX3NpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKGcseCx5KX1cblxuICAgICAgICAke3U/P1wiXCJ9XG5cbiAgICAgICAgJHtlLm1haW5TdGFydCgpfVxuICAgICAgICAke2UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLnZlY19zaXplXCIpfVxuICAgICAgICAkeyR9XG4gICAgICB9YH0sWG09KGUsdCxyLG4sbyxpLGE9ci5kYXRhVHlwZSk9PntsZXQgZD1yLmRpbXMubWFwKGc9Pk51bWJlcihnKT8/MSksbD1uLmRpbXMubWFwKGc9Pk51bWJlcihnKT8/MSkscD0hQy5hcmVFcXVhbChkLGwpLG09ZCx1PUMuc2l6ZShkKSxoPSExLF89ITEseT1bcF07aWYocCl7bGV0IGc9dHQuY2FsY1NoYXBlKGQsbCwhMSk7aWYoIWcpdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgcGVyZm9ybSBiaW5hcnkgb3Agb24gdGhlIGdpdmVuIHRlbnNvcnNcIik7bT1nLnNsaWNlKCksdT1DLnNpemUobSk7bGV0IHg9Qy5zaXplKGQpPT09MSwkPUMuc2l6ZShsKT09PTEsdj1kLmxlbmd0aD4wJiZkW2QubGVuZ3RoLTFdJTQ9PT0wLFM9bC5sZW5ndGg+MCYmbFtsLmxlbmd0aC0xXSU0PT09MDt5LnB1c2goeCkseS5wdXNoKCQpLHkucHVzaCh2KSx5LnB1c2goUyk7bGV0IFQ9MTtmb3IobGV0IEE9MTtBPG0ubGVuZ3RoO0ErKyl7bGV0IGs9ZFtkLmxlbmd0aC1BXSxQPWxbbC5sZW5ndGgtQV07aWYoaz09PVApVCo9aztlbHNlIGJyZWFrfVQlND09PTA/KF89ITAsaD0hMCk6KHh8fCR8fHZ8fFMpJiYoaD0hMCl9ZWxzZSBoPSEwO3JldHVybiB5LnB1c2goaCkse25hbWU6ZSxzaGFkZXJDYWNoZTp7aGludDp0K3kubWFwKGc9PmcudG9TdHJpbmcoKSkuam9pbihcIl9cIiksaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiLFwicmFua1wiXX0sZ2V0U2hhZGVyU291cmNlOmc9PlFtKGcsZCxsLG0saCxwLF8sbyxyLmRhdGFUeXBlLG4uZGF0YVR5cGUsYSxpKSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm0sZGF0YVR5cGU6YX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHUvNjQvNCl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTpNYXRoLmNlaWwoQy5zaXplKG0pLzQpfSwuLi5OKGQsbCxtKV19KX19LGF0PShlLHQscixuLG8saSk9PntlLmNvbXB1dGUoWG0odCxvPz9cIlwiLGUuaW5wdXRzWzBdLGUuaW5wdXRzWzFdLHIsbixpKSl9LCR1PWU9PnthdChlLFwiQWRkXCIsKHQscik9PmAke3R9KyR7cn1gKX0seHU9ZT0+e2F0KGUsXCJEaXZcIiwodCxyKT0+YCR7dH0vJHtyfWApfSxTdT1lPT57YXQoZSxcIkVxdWFsXCIse3NjYWxhcjoodCxyKT0+YHUzMigke3R9PT0ke3J9KWAsdmVjdG9yOih0LHIpPT5gdmVjNDx1MzI+KCR7dH09PSR7cn0pYH0sdm9pZCAwLHZvaWQgMCw5KX0sVHU9ZT0+e2F0KGUsXCJNdWxcIiwodCxyKT0+YCR7dH0qJHtyfWApfSxJdT1lPT57bGV0IHQ9RShcImlucHV0XCIsZS5pbnB1dHNbMF0uZGF0YVR5cGUsZS5pbnB1dHNbMF0uZGltcykudHlwZS52YWx1ZTthdChlLFwiUG93XCIse3NjYWxhcjoobixvKT0+YHBvd19jdXN0b20oJHtufSwke299KWAsdmVjdG9yOihuLG8pPT5gcG93X3ZlY3Rvcl9jdXN0b20oJHtufSwke299KWB9LGBcbiAgICBmbiBwb3dfY3VzdG9tKGEgOiAke3R9LCBiIDogJHt0fSkgLT4gJHt0fSB7XG4gICAgICBpZiAoYiA9PSAke3R9KDAuMCkpIHtcbiAgICAgICAgcmV0dXJuICR7dH0oMS4wKTtcbiAgICAgIH0gZWxzZSBpZiAoYSA8ICR7dH0oMC4wKSAmJiBmMzIoYikgIT0gZmxvb3IoZjMyKGIpKSkge1xuICAgICAgICByZXR1cm4gJHt0fShwb3coZjMyKGEpLCBmMzIoYikpKTsgLy8gTmFOXG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZWN0KHNpZ24oYSksICR7dH0oMS4wKSwgcm91bmQoZjMyKGFicyhiKSAlICR7dH0oMi4wKSkpICE9IDEuMCkgKiAke3R9KCR7dD09PVwiaTMyXCI/XCJyb3VuZFwiOlwiXCJ9KHBvdyhmMzIoYWJzKGEpKSwgZjMyKGIpKSkpO1xuICAgIH1cbiAgICBmbiBwb3dfdmVjdG9yX2N1c3RvbShhIDogdmVjNDwke3R9PiwgYiA6IHZlYzQ8JHt0fT4pIC0+IHZlYzQ8JHt0fT4ge1xuICAgICAgLy8gVE9ETzogaW1wbGVtZW50IHZlY3Rvcml6ZWQgcG93XG4gICAgICByZXR1cm4gdmVjNDwke3R9Pihwb3dfY3VzdG9tKGEueCwgYi54KSwgcG93X2N1c3RvbShhLnksIGIueSksIHBvd19jdXN0b20oYS56LCBiLnopLCBwb3dfY3VzdG9tKGEudywgYi53KSk7XG4gICAgfVxuICAgICAgYCl9LEN1PWU9PnthdChlLFwiU3ViXCIsKHQscik9PmAke3R9LSR7cn1gKX0sQXU9ZT0+e2F0KGUsXCJHcmVhdGVyXCIse3NjYWxhcjoodCxyKT0+YHUzMigke3R9PiR7cn0pYCx2ZWN0b3I6KHQscik9PmB2ZWM0PHUzMj4oJHt0fT4ke3J9KWB9LHZvaWQgMCx2b2lkIDAsOSl9LGt1PWU9PnthdChlLFwiTGVzc1wiLHtzY2FsYXI6KHQscik9PmB1MzIoJHt0fTwke3J9KWAsdmVjdG9yOih0LHIpPT5gdmVjNDx1MzI+KCR7dH08JHtyfSlgfSx2b2lkIDAsdm9pZCAwLDkpfSxFdT1lPT57YXQoZSxcIkdyZWF0ZXJPckVxdWFsXCIse3NjYWxhcjoodCxyKT0+YHUzMigke3R9Pj0ke3J9KWAsdmVjdG9yOih0LHIpPT5gdmVjNDx1MzI+KCR7dH0+PSR7cn0pYH0sdm9pZCAwLHZvaWQgMCw5KX0sUHU9ZT0+e2F0KGUsXCJMZXNzT3JFcXVhbFwiLHtzY2FsYXI6KHQscik9PmB1MzIoJHt0fTw9JHtyfSlgLHZlY3RvcjoodCxyKT0+YHZlYzQ8dTMyPigke3R9PD0ke3J9KWB9LHZvaWQgMCx2b2lkIDAsOSl9fSk7dmFyIGVmLHRmLHJmLG5mLE91LER1LEJ1PVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7U2UoKTthZSgpO2VmPShlLHQpPT57aWYoIWV8fGUubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKFwidG9vIGZldyBpbnB1dHNcIik7bGV0IHI9MCxuPWVbcl0sbz1uLmRhdGFUeXBlLGk9bi5kaW1zLmxlbmd0aDtlLmZvckVhY2goKGEsZCk9PntpZihkIT09cil7aWYoYS5kYXRhVHlwZSE9PW8pdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgdGVuc29ycyBzaG91bGQgYmUgb25lIHR5cGVcIik7aWYoYS5kaW1zLmxlbmd0aCE9PWkpdGhyb3cgbmV3IEVycm9yKFwiaW5wdXQgdGVuc29ycyBzaG91bGQgaGF2ZSB0aGUgc2FtZSBzaGFwZVwiKTthLmRpbXMuZm9yRWFjaCgobCxwKT0+e2lmKHAhPT10JiZsIT09bi5kaW1zW3BdKXRocm93IG5ldyBFcnJvcihcIm5vbiBjb25jYXQgZGltZW5zaW9ucyBtdXN0IG1hdGNoXCIpfSl9fSl9LHRmPShlLHQpPT5gXG4gIGZuIGNhbGN1bGF0ZUlucHV0SW5kZXgoaW5kZXg6IHUzMikgLT4gdTMyIHtcbiAgICBsZXQgc2l6ZUluQ29uY2F0QXhpcyA9IGFycmF5PHUzMiwgJHtlfXU+KCR7dH0pO1xuICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgJHtlfTsgaSArPSAxdSApIHtcbiAgICAgIGlmIChpbmRleCA8IHNpemVJbkNvbmNhdEF4aXNbaV0pIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAke2V9dTtcbiAgfWAscmY9KGUsdCk9PntsZXQgcj1lLmxlbmd0aCxuPVtdO2ZvcihsZXQgbz0wO288cjsrK28pe2xldCBpPXQuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsZVtvXS5nZXRCeUluZGljZXMoXCJpbmRpY2VzXCIpKTtyPT09MT9uLnB1c2goaSk6bz09PTA/bi5wdXNoKGBpZiAoaW5wdXRJbmRleCA9PSAke299dSkgeyAke2l9IH1gKTpvPT09ci0xP24ucHVzaChgZWxzZSB7ICR7aX0gfWApOm4ucHVzaChgZWxzZSBpZiAoaW5wdXRJbmRleCA9PSAke299KSB7ICR7aX0gfWApfXJldHVybiBuLmpvaW4oYFxuYCl9LG5mPShlLHQscixuKT0+e2xldCBvPUMuc2l6ZShyKSxpPW5ldyBBcnJheShlLmxlbmd0aCksYT1uZXcgQXJyYXkoZS5sZW5ndGgpLGQ9MCxsPVtdLHA9W10sbT1be3R5cGU6MTIsZGF0YTpvfV07Zm9yKGxldCBnPTA7ZzxlLmxlbmd0aDsrK2cpZCs9ZVtnXS5kaW1zW3RdLGlbZ109ZCxwLnB1c2goZVtnXS5kaW1zLmxlbmd0aCksYVtnXT1FKGBpbnB1dCR7Z31gLG4scFtnXSksbC5wdXNoKFwicmFua1wiKSxtLnB1c2goe3R5cGU6MTIsZGF0YTppW2ddfSk7Zm9yKGxldCBnPTA7ZzxlLmxlbmd0aDsrK2cpbS5wdXNoKC4uLk4oZVtnXS5kaW1zKSk7bS5wdXNoKC4uLk4ocikpO2xldCB1PU0oXCJvdXRwdXRcIixuLHIubGVuZ3RoKSxoPXUuaW5kaWNlc0dldChcImluZGljZXNcIix0KSxfPUFycmF5LmZyb20oQXJyYXkoaS5sZW5ndGgpLmtleXMoKSkubWFwKGc9PmB1bmlmb3Jtcy5zaXplSW5Db25jYXRBeGlzJHtnfWApLmpvaW4oXCIsXCIpLHk9Zz0+YFxuXG4gICR7KCgpPT57Zy5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRTaXplXCIsXCJ1MzJcIik7Zm9yKGxldCB4PTA7eDxlLmxlbmd0aDt4KyspZy5yZWdpc3RlclVuaWZvcm0oYHNpemVJbkNvbmNhdEF4aXMke3h9YCxcInUzMlwiKTtyZXR1cm4gZy5kZWNsYXJlVmFyaWFibGVzKC4uLmEsdSl9KSgpfVxuXG4gICR7dGYoaS5sZW5ndGgsXyl9XG5cbiAgJHtnLm1haW5TdGFydCgpfVxuICAgICR7Zy5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0U2l6ZVwiKX1cblxuICAgIHZhciBpbmRpY2VzID0gJHt1Lm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuXG4gICAgbGV0IGlucHV0SW5kZXggPSBjYWxjdWxhdGVJbnB1dEluZGV4KCR7aH0pO1xuICAgIGlmIChpbnB1dEluZGV4ICE9IDB1KSB7XG4gICAgICBsZXQgc2l6ZUluQ29uY2F0QXhpcyA9IGFycmF5PHUzMiwgJHtpLmxlbmd0aH11Pigke199KTtcbiAgICAgICR7aH0gLT0gc2l6ZUluQ29uY2F0QXhpc1tpbnB1dEluZGV4IC0gMXVdO1xuICAgIH1cblxuICAgICR7cmYoYSx1KX1cbiAgfWA7cmV0dXJue25hbWU6XCJDb25jYXRcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0fWAsaW5wdXREZXBlbmRlbmNpZXM6bH0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpyLGRhdGFUeXBlOm59XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChvLzY0KX0scHJvZ3JhbVVuaWZvcm1zOm19KSxnZXRTaGFkZXJTb3VyY2U6eX19LE91PShlLHQpPT57bGV0IHI9ZS5pbnB1dHMsbj1yWzBdLmRpbXMsbz1DLm5vcm1hbGl6ZUF4aXModC5heGlzLG4ubGVuZ3RoKTtlZihyLG8pO2xldCBpPW4uc2xpY2UoKTtpW29dPXIucmVkdWNlKChkLGwpPT5kKyhsLmRpbXMubGVuZ3RoPm8/bC5kaW1zW29dOjApLDApO2xldCBhPXIuZmlsdGVyKGQ9PkMuc2l6ZShkLmRpbXMpPjApO2UuY29tcHV0ZShuZihhLG8saSxyWzBdLmRhdGFUeXBlKSx7aW5wdXRzOmF9KX0sRHU9ZT0+cmUoe2F4aXM6ZS5heGlzfSl9KTt2YXIgcWUsS2UsamUsanIseXQ9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTtxZT0oZSx0LHI9XCJmMzJcIik9Pntzd2l0Y2goZS5hY3RpdmF0aW9uKXtjYXNlXCJSZWx1XCI6cmV0dXJuYHZhbHVlID0gbWF4KHZhbHVlLCAke3R9KDAuMCkpO2A7Y2FzZVwiU2lnbW9pZFwiOnJldHVybmB2YWx1ZSA9ICgke3R9KDEuMCkgLyAoJHt0fSgxLjApICsgZXhwKC12YWx1ZSkpKTtgO2Nhc2VcIkNsaXBcIjpyZXR1cm5gdmFsdWUgPSBjbGFtcCh2YWx1ZSwgJHt0fSgke3J9KHVuaWZvcm1zLmNsaXBfbWluKSksICR7dH0oJHtyfSh1bmlmb3Jtcy5jbGlwX21heCkpKTtgO2Nhc2VcIkhhcmRTaWdtb2lkXCI6cmV0dXJuYHZhbHVlID0gbWF4KCR7dH0oMC4wKSwgbWluKCR7dH0oMS4wKSwgJHtyfSh1bmlmb3Jtcy5hbHBoYSkgKiB2YWx1ZSArICR7cn0odW5pZm9ybXMuYmV0YSkpKTtgO2Nhc2VcIkxlYWt5UmVsdVwiOnJldHVybmB2YWx1ZSA9IHNlbGVjdCgke3J9KHVuaWZvcm1zLmFscGhhKSAqIHZhbHVlLCB2YWx1ZSwgdmFsdWUgPj0gJHt0fSgwLjApKTtgO2Nhc2VcIlRhbmhcIjpyZXR1cm5gbGV0IGUyeCA9IGV4cCgtMi4wICogYWJzKHZhbHVlKSk7XG4gICAgICAgICAgICAgIHZhbHVlID0gc2lnbih2YWx1ZSkgKiAoMS4wIC0gZTJ4KSAvICgxLjAgKyBlMngpO1xuICAgICAgICBgO2Nhc2VcIlwiOnJldHVyblwiXCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGFjdGl2YXRpb24gJHtlLmFjdGl2YXRpb259YCl9fSxLZT0oZSx0KT0+e2UuYWN0aXZhdGlvbj09PVwiQ2xpcFwiP3QucHVzaCh7dHlwZToxLGRhdGE6ZS5jbGlwTWF4fSx7dHlwZToxLGRhdGE6ZS5jbGlwTWlufSk6ZS5hY3RpdmF0aW9uPT09XCJIYXJkU2lnbW9pZFwiP3QucHVzaCh7dHlwZToxLGRhdGE6ZS5hbHBoYX0se3R5cGU6MSxkYXRhOmUuYmV0YX0pOmUuYWN0aXZhdGlvbj09PVwiTGVha3lSZWx1XCImJnQucHVzaCh7dHlwZToxLGRhdGE6ZS5hbHBoYX0pfSxqZT0oZSx0KT0+e2UuYWN0aXZhdGlvbj09PVwiQ2xpcFwiP3QucHVzaCh7bmFtZTpcImNsaXBfbWF4XCIsdHlwZTpcImYzMlwifSx7bmFtZTpcImNsaXBfbWluXCIsdHlwZTpcImYzMlwifSk6ZS5hY3RpdmF0aW9uPT09XCJIYXJkU2lnbW9pZFwiP3QucHVzaCh7bmFtZTpcImFscGhhXCIsdHlwZTpcImYzMlwifSx7bmFtZTpcImJldGFcIix0eXBlOlwiZjMyXCJ9KTplLmFjdGl2YXRpb249PT1cIkxlYWt5UmVsdVwiJiZ0LnB1c2goe25hbWU6XCJhbHBoYVwiLHR5cGU6XCJmMzJcIn0pfSxqcj1lPT57bGV0IHQ9ZT8uYWN0aXZhdGlvbnx8XCJcIjtpZih0PT09XCJIYXJkU2lnbW9pZFwiKXtsZXRbcixuXT1lPy5hY3RpdmF0aW9uX3BhcmFtc3x8Wy4yLC41XTtyZXR1cm57YWN0aXZhdGlvbjp0LGFscGhhOnIsYmV0YTpufX1lbHNlIGlmKHQ9PT1cIkNsaXBcIil7bGV0W3Isbl09ZT8uYWN0aXZhdGlvbl9wYXJhbXN8fFtlcyx0c107cmV0dXJue2FjdGl2YXRpb246dCxjbGlwTWF4Om4sY2xpcE1pbjpyfX1lbHNlIGlmKHQ9PT1cIkxlYWt5UmVsdVwiKXtsZXRbcl09ZT8uYWN0aXZhdGlvbl9wYXJhbXN8fFsuMDFdO3JldHVybnthY3RpdmF0aW9uOnQsYWxwaGE6cn19cmV0dXJue2FjdGl2YXRpb246dH19fSk7dmFyIEFlLE11LFlyPVUoKCk9PntcInVzZSBzdHJpY3RcIjtBZT0oZSx0KT0+e3N3aXRjaChlKXtjYXNlIDE6cmV0dXJuIHQ7Y2FzZSAyOnJldHVybmB2ZWMyPCR7dH0+YDtjYXNlIDM6cmV0dXJuYHZlYzM8JHt0fT5gO2Nhc2UgNDpyZXR1cm5gdmVjNDwke3R9PmA7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYCR7ZX0tY29tcG9uZW50IGlzIG5vdCBzdXBwb3J0ZWQuYCl9fSxNdT1lPT5gXG4gICAgICAke2U/XCJ2YWx1ZSA9IHZhbHVlICsgZ2V0Qmlhc0J5T3V0cHV0Q29vcmRzKGNvb3Jkcyk7XCI6XCJcIn1cbiAgICAgIGB9KTt2YXIgUnUsVXU9VSgoKT0+e1widXNlIHN0cmljdFwiO1J1PWU9PmBcbmZuIGdldEluZGV4RnJvbUNvb3JkczREKGNvb3JkcyA6IHZlYzQ8aTMyPiwgc2hhcGUgOiB2ZWM0PGkzMj4pIC0+IGkzMiB7XG4gIHJldHVybiBkb3QoY29vcmRzLCB2ZWM0PGkzMj4oXG4gICAgICBzaGFwZS55ICogc2hhcGUueiAqIHNoYXBlLncsIHNoYXBlLnogKiBzaGFwZS53LCBzaGFwZS53LCAxKSk7XG59XG5mbiBnZXRPdXRwdXRJbmRleEZyb21Db29yZHMoY29vcmRzIDogdmVjNDxpMzI+KSAtPiBpMzIge1xuICByZXR1cm4gZG90KGNvb3JkcywgdmVjNDxpMzI+KFxuICAgIGkzMigke2V9LngpLCBpMzIoJHtlfS55KSwgaTMyKCR7ZX0ueiksIDEpKTtcbn1cbmB9KTt2YXIgSnQsWnIsUXI9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTthZSgpO3l0KCk7SnQ9KGUsdCxyLG4sbyk9PntsZXQgaT1uLXI7cmV0dXJuYFxuICAgICAgJHtBcnJheS5mcm9tKHtsZW5ndGg6cn0pLm1hcCgoYSxkKT0+YFxuICAgICAgaWYgKCR7Rih0LnNoYXBlLGQsdC5yYW5rKX0gIT0gMSkge1xuICAgICAgICAke3QuaW5kaWNlc1NldChlLGQsRihvLGQraSxuKSl9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAke3QuaW5kaWNlc1NldChlLGQsMCl9XG4gICAgICB9YCkuam9pbihcIlwiKX1cbmB9LFpyPShlLHQscixuLG89ITEsaSk9PntsZXQgYT1lWzBdLmRpbXMsZD1lWzFdLmRpbXMsbD1hW2EubGVuZ3RoLTJdLHA9ZFtkLmxlbmd0aC0xXSxtPWFbYS5sZW5ndGgtMV0sdT1tZShwKSxoPW1lKG0pLF89bWUobCkseT1DLnNpemUocikvdS9fLGc9ZS5sZW5ndGg+Mix4PW4/bi5zbGljZSgwLC0yKTpyLnNsaWNlKDAsLTIpLHY9W0Muc2l6ZSh4KSxsLHBdLFM9W3t0eXBlOjEyLGRhdGE6eX0se3R5cGU6MTIsZGF0YTpsfSx7dHlwZToxMixkYXRhOnB9LHt0eXBlOjEyLGRhdGE6bX1dO0tlKHQsUyksUy5wdXNoKC4uLk4oeCxhLGQpKSxnJiZTLnB1c2goLi4uTihlWzJdLmRpbXMpKSxTLnB1c2goLi4uTih2KSk7bGV0IFQ9QT0+e2xldCBrPUxyKFwiYmF0Y2hfZGltc1wiLGVbMF0uZGF0YVR5cGUseC5sZW5ndGgpLFA9RShcImFcIixlWzBdLmRhdGFUeXBlLGEubGVuZ3RoLGgpLEQ9RShcImJcIixlWzFdLmRhdGFUeXBlLGQubGVuZ3RoLHUpLFI9TShcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsdi5sZW5ndGgsdSksRz1fZShSLnR5cGUudGVuc29yKSxLPXFlKHQsUi50eXBlLnZhbHVlLEcpLGo9W1AsRF0sVj1cIlwiO2lmKGcpe2xldCBZPW8/dToxO2oucHVzaChFKFwiYmlhc1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLmxlbmd0aCxZKSksVj1gJHtvP2B2YWx1ZSArPSBiaWFzW2NvbCAvICR7WX1dO2A6YHZhbHVlICs9ICR7Ui50eXBlLnZhbHVlfShiaWFzW3JvdyArIGldKTtgfWB9bGV0IFE9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiTVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJOXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIktcIix0eXBlOlwidTMyXCJ9XTtqZSh0LFEpO2xldCBzZT0oKT0+e2xldCBZPWB2YXIgYV9kYXRhOiAke1AudHlwZS52YWx1ZX07YDtmb3IobGV0IGVlPTA7ZWU8aDtlZSsrKVkrPWBcbiAgICAgICAgICAgICAgbGV0IGJfZGF0YSR7ZWV9ID0gYlsoYl9vZmZzZXQgKyAoayArICR7ZWV9KSAqIHVuaWZvcm1zLk4gKyBjb2wpIC8gJHt1fV07YDtmb3IobGV0IGVlPTA7ZWU8XztlZSsrKXtZKz1gYV9kYXRhID0gYVsoYV9vZmZzZXQgKyAocm93ICsgJHtlZX0pICogdW5pZm9ybXMuSyArIGspIC8gJHtofV07YDtmb3IobGV0IEo9MDtKPGg7SisrKVkrPWBcbiAgICAgICAgICAgIHZhbHVlc1ske2VlfV0gPSBmbWEoJHtELnR5cGUudmFsdWV9KGFfZGF0YSR7aD09PTE/XCJcIjpgWyR7Sn1dYH0pLCBiX2RhdGEke0p9LCB2YWx1ZXNbJHtlZX1dKTtcbmB9cmV0dXJuIFl9O3JldHVybmBcbiAgJHtBLnJlZ2lzdGVyVW5pZm9ybXMoUSkucmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlcyhrKS5kZWNsYXJlVmFyaWFibGVzKC4uLmosUil9XG4gICR7QS5tYWluU3RhcnQoKX1cbiAgICAke0EuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgIGxldCBjb2wgPSAoZ2xvYmFsX2lkeCAlICh1bmlmb3Jtcy5OIC8gJHt1fSkpICogJHt1fTtcbiAgICB2YXIgaW5kZXgxID0gZ2xvYmFsX2lkeCAvICh1bmlmb3Jtcy5OIC8gJHt1fSk7XG4gICAgbGV0IHN0cmlkZTEgPSB1bmlmb3Jtcy5NIC8gJHtffTtcbiAgICBsZXQgcm93ID0gKGluZGV4MSAlIHN0cmlkZTEpICogJHtffTtcbiAgICBsZXQgYmF0Y2ggPSBpbmRleDEgLyBzdHJpZGUxO1xuXG4gICAgJHtyLmxlbmd0aD09PTI/XCJcIjpgbGV0IGJhdGNoX2luZGljZXMgPSAke2sub2Zmc2V0VG9JbmRpY2VzKFwiYmF0Y2hcIil9O2B9XG5cbiAgICB2YXIgYV9pbmRpY2VzOiAke1AudHlwZS5pbmRpY2VzfTtcbiAgICAke0p0KFwiYV9pbmRpY2VzXCIsUCxQLnJhbmstMixrLnJhbmssXCJiYXRjaF9pbmRpY2VzXCIpfVxuICAgICR7UC5pbmRpY2VzU2V0KFwiYV9pbmRpY2VzXCIsUC5yYW5rLTIsMCl9XG4gICAgJHtQLmluZGljZXNTZXQoXCJhX2luZGljZXNcIixQLnJhbmstMSwwKX1cbiAgICBsZXQgYV9vZmZzZXQgPSAke1AuaW5kaWNlc1RvT2Zmc2V0KFwiYV9pbmRpY2VzXCIpfTtcblxuICAgIHZhciBiX2luZGljZXM6ICR7RC50eXBlLmluZGljZXN9O1xuICAgICR7SnQoXCJiX2luZGljZXNcIixELEQucmFuay0yLGsucmFuayxcImJhdGNoX2luZGljZXNcIil9XG4gICAgJHtELmluZGljZXNTZXQoXCJiX2luZGljZXNcIixELnJhbmstMiwwKX1cbiAgICAke0QuaW5kaWNlc1NldChcImJfaW5kaWNlc1wiLEQucmFuay0xLDApfVxuICAgIGxldCBiX29mZnNldCA9ICR7RC5pbmRpY2VzVG9PZmZzZXQoXCJiX2luZGljZXNcIil9O1xuICAgIHZhciB2YWx1ZXM6IGFycmF5PCR7Ui50eXBlLnZhbHVlfSwgJHtffT47XG4gICAgZm9yICh2YXIgazogdTMyID0gMHU7IGsgPCB1bmlmb3Jtcy5LOyBrID0gayArICR7aH0pIHtcbiAgICAgICR7c2UoKX1cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDB1OyBpIDwgJHtffXU7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgJHtWfVxuICAgICAgJHtLfVxuICAgICAgbGV0IGN1cl9pbmRpY2VzID0gJHtSLnR5cGUuaW5kaWNlc30oYmF0Y2gsIHJvdyArIGksIGNvbCk7XG4gICAgICBsZXQgb2Zmc2V0ID0gJHtSLmluZGljZXNUb09mZnNldChcImN1cl9pbmRpY2VzXCIpfTtcbiAgICAgICR7Ui5zZXRCeU9mZnNldChgb2Zmc2V0IC8gJHt1fWAsXCJ2YWx1ZVwiKX07XG4gICAgfVxuICB9XG4gIGB9O3JldHVybntuYW1lOlwiTWF0TXVsTmFpdmVcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmFjdGl2YXRpb259OyR7dX07JHtofTske199OyR7b31gLGlucHV0RGVwZW5kZW5jaWVzOmc/W1wicmFua1wiLFwicmFua1wiLFwicmFua1wiXTpbXCJyYW5rXCIsXCJyYW5rXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmk/aShyKTpyLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbCh5LzY0KX0scHJvZ3JhbVVuaWZvcm1zOlN9KSxnZXRTaGFkZXJTb3VyY2U6VH19fSk7dmFyIG9mLGFmLGhvLE51LHNmLGdvLHVmLGVyLFhyPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7YWUoKTt5dCgpO1FyKCk7WXIoKTtvZj0oZSx0KT0+ZT9gXG4gICAgICAgIG1tX0FzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRBKGJhdGNoLFxuICAgICAgICAgIGtTdGFydCArIGlucHV0Um93LFxuICAgICAgICAgIGdsb2JhbFJvd1N0YXJ0IC8gaW5uZXJFbGVtZW50U2l6ZSArIGlucHV0Q29sJHt0P1wiLCBiYXRjaEluZGljZXNcIjpcIlwifSk7XG4gICAgICAgIGA6YFxuICAgICAgICBtbV9Bc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQShiYXRjaCxcbiAgICAgICAgICBnbG9iYWxSb3cgKyBpbm5lclJvdyxcbiAgICAgICAgICBrU3RhcnQgLyBpbm5lckVsZW1lbnRTaXplICsgaW5wdXRDb2wke3Q/XCIsIGJhdGNoSW5kaWNlc1wiOlwiXCJ9KTtcbiAgICAgICAgYCxhZj0oZSx0KT0+ZT9gXG4gICAgICAgIGxldCBBQ2FjaGVkMCA9IG1tX0FzdWJbayAqIGlubmVyRWxlbWVudFNpemVdW2xvY2FsUm93XTtcbiAgICAgICAgbGV0IEFDYWNoZWQxID0gbW1fQXN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDFdW2xvY2FsUm93XTtcbiAgICAgICAgbGV0IEFDYWNoZWQyID0gbW1fQXN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDJdW2xvY2FsUm93XTtcbiAgICAgICAgJHt0PT09Mz9cIlwiOlwibGV0IEFDYWNoZWQzID0gbW1fQXN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDNdW2xvY2FsUm93XTtcIn1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dQZXJUaHJlYWQ7IGkgPSBpICsgMSkge1xuICAgICAgICAgIGFjY1tpXSA9IEJDYWNoZWQwICogQUNhY2hlZDBbaV0gKyBhY2NbaV07XG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDEgKiBBQ2FjaGVkMVtpXSArIGFjY1tpXTtcbiAgICAgICAgICBhY2NbaV0gPSBCQ2FjaGVkMiAqIEFDYWNoZWQyW2ldICsgYWNjW2ldO1xuICAgICAgICAgICR7dD09PTM/XCJcIjpcImFjY1tpXSA9IEJDYWNoZWQzICogQUNhY2hlZDNbaV0gKyBhY2NbaV07XCJ9XG4gICAgICAgIH1gOmBcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dQZXJUaHJlYWQ7IGkgPSBpICsgMSkge1xuICAgICAgICAgIGxldCBBQ2FjaGVkID0gbW1fQXN1Ylt0aWxlUm93ICsgaV1ba107XG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDAgKiBBQ2FjaGVkLnggKyBhY2NbaV07XG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDEgKiBBQ2FjaGVkLnkgKyBhY2NbaV07XG4gICAgICAgICAgYWNjW2ldID0gQkNhY2hlZDIgKiBBQ2FjaGVkLnogKyBhY2NbaV07XG4gICAgICAgICAgJHt0PT09Mz9cIlwiOlwiYWNjW2ldID0gQkNhY2hlZDMgKiBBQ2FjaGVkLncgKyBhY2NbaV07XCJ9XG4gICAgICAgIH1gLGhvPShlLHQscj1cImYzMlwiLG4sbz0hMSxpPTMyLGE9ITEsZD0zMik9PntsZXQgbD10WzFdKmVbMV0scD10WzBdKmVbMF0sbT1vP2w6aSx1PW8/aTpsLGg9bS90WzBdLF89aS90WzFdO2lmKCEoKG8mJmg9PT00JiZlWzFdPT09NHx8IW8mJihoPT09M3x8aD09PTQpKSYmbSV0WzBdPT09MCYmaSV0WzFdPT09MCYmZVswXT09PTQpKXRocm93IG5ldyBFcnJvcihgSWYgdHJhbnNwb3NlQSAke299IGlzIHRydWUsIGlubmVyRWxlbWVudFNpemUgJHtofSBhbmQgd29ya1BlclRocmVhZFsxXSAke2VbMV19IG11c3QgYmUgNC5cbiAgICAgIE90aGVyd2lzZSwgaW5uZXJFbGVtZW50U2l6ZSAke2h9IG11c3QgYmUgMyBvciA0LlxuICB0aWxlQVdpZHRoICR7bX0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVswXSR7dFswXX0uIHRpbGVJbm5lciAke2l9IG11c3QgYmUgZGl2aXNpYmxlIGJ5IHdvcmtncm91cFNpemVbMV0gJHt0WzFdfS4gY29sUGVyVGhyZWFkICR7ZVswXX0gbXVzdCBiZSA0LmApO3JldHVybmBcbnZhcjx3b3JrZ3JvdXA+IG1tX0FzdWI6IGFycmF5PGFycmF5PHZlYyR7aH08JHtyfT4sICR7bS9ofT4sICR7dX0+O1xudmFyPHdvcmtncm91cD4gbW1fQnN1YjogYXJyYXk8YXJyYXk8dmVjNDwke3J9PiwgJHtwL2VbMF19PiwgJHtpfT47XG5cbmNvbnN0IHJvd1BlclRocmVhZCA9ICR7ZVsxXX07XG5jb25zdCBjb2xQZXJUaHJlYWQgPSAke2VbMF19O1xuY29uc3QgaW5uZXJFbGVtZW50U2l6ZSA9ICR7aH07XG5jb25zdCB0aWxlSW5uZXIgPSAke2l9O1xuXG5AY29tcHV0ZSBAd29ya2dyb3VwX3NpemUoJHt0WzBdfSwgJHt0WzFdfSwgJHt0WzJdfSlcbmZuIG1haW4oQGJ1aWx0aW4obG9jYWxfaW52b2NhdGlvbl9pZCkgbG9jYWxJZCA6IHZlYzM8dTMyPixcbiAgICAgICAgQGJ1aWx0aW4oZ2xvYmFsX2ludm9jYXRpb25faWQpIGdsb2JhbElkIDogdmVjMzx1MzI+LFxuICAgICAgICBAYnVpbHRpbih3b3JrZ3JvdXBfaWQpIHdvcmtncm91cElkIDogdmVjMzx1MzI+KSB7XG4gIGxldCBsb2NhbFJvdyA9IGkzMihsb2NhbElkLnkpO1xuICBsZXQgdGlsZVJvdyA9IGxvY2FsUm93ICogcm93UGVyVGhyZWFkO1xuICBsZXQgdGlsZUNvbCA9IGkzMihsb2NhbElkLngpO1xuXG4gIGxldCBnbG9iYWxSb3cgPWkzMihnbG9iYWxJZC55KSAqIHJvd1BlclRocmVhZDtcbiAgbGV0IGdsb2JhbENvbCA9IGkzMihnbG9iYWxJZC54KTtcbiAgbGV0IGJhdGNoID0gJHthP1wiMFwiOlwiaTMyKGdsb2JhbElkLnopXCJ9O1xuICAke24/YGxldCBiYXRjaEluZGljZXMgPSAke24ub2Zmc2V0VG9JbmRpY2VzKFwidTMyKGJhdGNoKVwiKX07YDpcIlwifVxuICBsZXQgZ2xvYmFsUm93U3RhcnQgPSBpMzIod29ya2dyb3VwSWQueSkgKiAke2x9O1xuXG4gIGxldCBudW1fdGlsZXMgPSAke2E/YCR7TWF0aC5jZWlsKGQvaSl9YDpcIih1bmlmb3Jtcy5kaW1faW5uZXIgLSAxKSAvIHRpbGVJbm5lciArIDFcIn07XG4gIHZhciBrU3RhcnQgPSAke2E/YGkzMihnbG9iYWxJZC56KSAqICR7ZH1gOlwiMFwifTtcblxuICB2YXIgYWNjOiBhcnJheTx2ZWM0PCR7cn0+LCByb3dQZXJUaHJlYWQ+O1xuXG4gIC8vIExvb3Agb3ZlciBzaGFyZWQgZGltZW5zaW9uLlxuICBsZXQgdGlsZVJvd0IgPSBsb2NhbFJvdyAqICR7X307XG4gIGZvciAodmFyIHQgPSAwOyB0IDwgbnVtX3RpbGVzOyB0ID0gdCArIDEpIHtcbiAgICAgIC8vIExvYWQgb25lIHRpbGUgb2YgQSBpbnRvIGxvY2FsIG1lbW9yeS5cbiAgICAgIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCByb3dQZXJUaHJlYWQ7IGlubmVyUm93ID0gaW5uZXJSb3cgKyAxKSB7XG4gICAgICAgICAgbGV0IGlucHV0Um93ID0gdGlsZVJvdyArIGlubmVyUm93O1xuICAgICAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2w7XG4gICAgICAgICAgJHtvZihvLG4pfVxuICAgICAgfVxuXG4gICAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIEIgaW50byBsb2NhbCBtZW1vcnkuXG4gICAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgJHtffTsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgICAgICBsZXQgaW5wdXRSb3cgPSB0aWxlUm93QiArIGlubmVyUm93O1xuICAgICAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2w7XG4gICAgICAgICAgbW1fQnN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEIoYmF0Y2gsIGtTdGFydCArIGlucHV0Um93LCBnbG9iYWxDb2wke24/XCIsIGJhdGNoSW5kaWNlc1wiOlwiXCJ9KTtcbiAgICAgIH1cbiAgICAgIGtTdGFydCA9IGtTdGFydCArIHRpbGVJbm5lcjtcbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgLy8gQ29tcHV0ZSBhY2MgdmFsdWVzIGZvciBhIHNpbmdsZSB0aHJlYWQuXG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRpbGVJbm5lciAvIGlubmVyRWxlbWVudFNpemU7IGsgPSBrICsgMSkge1xuICAgICAgICAgIGxldCBCQ2FjaGVkMCA9IG1tX0JzdWJbayAqIGlubmVyRWxlbWVudFNpemVdW3RpbGVDb2xdO1xuICAgICAgICAgIGxldCBCQ2FjaGVkMSA9IG1tX0JzdWJbayAqIGlubmVyRWxlbWVudFNpemUgKyAxXVt0aWxlQ29sXTtcbiAgICAgICAgICBsZXQgQkNhY2hlZDIgPSBtbV9Cc3ViW2sgKiBpbm5lckVsZW1lbnRTaXplICsgMl1bdGlsZUNvbF07XG4gICAgICAgICAgJHtoPT09Mz9cIlwiOlwibGV0IEJDYWNoZWQzID0gbW1fQnN1YltrICogaW5uZXJFbGVtZW50U2l6ZSArIDNdW3RpbGVDb2xdO1wifVxuXG4gICAgICAgICAgJHthZihvLGgpfVxuICAgICAgfVxuXG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gIH1cblxuICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgICAgbW1fd3JpdGUoYmF0Y2gsIGdsb2JhbFJvdyArIGlubmVyUm93LCBnbG9iYWxDb2wsIGFjY1tpbm5lclJvd10pO1xuICB9XG59YH0sTnU9KGUsdCk9PmU/YFxuICAgICAgICAgICAgbW1fQXN1YltpbnB1dFJvd11baW5wdXRDb2xdID0gbW1fcmVhZEEoYmF0Y2gsXG4gICAgICAgICAgICAgIGtTdGFydCArIGlucHV0Um93LFxuICAgICAgICAgICAgICBnbG9iYWxSb3dTdGFydCArIGlucHV0Q29sJHt0P1wiLCBiYXRjaEluZGljZXNcIjpcIlwifSk7XG4gICAgICAgICAgICBgOmBcbiAgICAgICAgICAgIG1tX0FzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRBKGJhdGNoLFxuICAgICAgICAgICAgICBnbG9iYWxSb3dTdGFydCArIGlucHV0Um93LFxuICAgICAgICAgICAgICBrU3RhcnQgKyBpbnB1dENvbCR7dD9cIiwgYmF0Y2hJbmRpY2VzXCI6XCJcIn0pO1xuICAgICAgICAgICAgYCxzZj1lPT5lP1wibGV0IEFDYWNoZWQgPSBtbV9Bc3ViW2tdW3RpbGVSb3cgKyBpbm5lclJvd107XCI6XCJsZXQgQUNhY2hlZCA9IG1tX0FzdWJbdGlsZVJvdyArIGlubmVyUm93XVtrXTtcIixnbz0oZSx0LHI9XCJmMzJcIixuLG89ITEsaT0zMixhPSExLGQ9MzIsbD0hMSk9PntsZXQgcD1lWzFdKnRbMV0sbT1lWzBdKnRbMF0sdT1vP3A6aSxoPW8/aTpwO2lmKCEoaCV0WzFdPT09MCYmdSV0WzBdPT09MCYmaSV0WzFdPT09MCkpdGhyb3cgbmV3IEVycm9yKGB0aWxlQUhpZ2h0ICR7aH0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVsxXSR7dFsxXX0sIHRpbGVBV2lkdGggJHt1fSBtdXN0IGJlIGRpdmlzaWJsZSBieSB3b3JrZ3JvdXBTaXplWzBdJHt0WzBdfSwgdGlsZUlubmVyICR7aX0gbXVzdCBiZSBkaXZpc2libGUgYnkgd29ya2dyb3VwU2l6ZVsxXSR7dFsxXX1gKTtsZXQgXz1oL3RbMV0seT11L3RbMF0sZz1pL3RbMV0seD1sP2BcbiAgICBsZXQgbG9jYWxSb3cgPSBpMzIobG9jYWxJZC55KTtcbiAgICBsZXQgbG9jYWxDb2wgPSBpMzIobG9jYWxJZC54KTtcbiAgICBsZXQgZ2xvYmFsUm93U3RhcnQgPSBpMzIod29ya2dyb3VwSWQueSkgKiAke3B9O1xuICAgIGxldCBnbG9iYWxDb2xTdGFydCA9IGkzMih3b3JrZ3JvdXBJZC54KSAqICR7bX07XG5cbiAgICAvLyBMb29wIG92ZXIgc2hhcmVkIGRpbWVuc2lvbi5cbiAgICBmb3IgKHZhciB0ID0gMDsgdCA8IG51bV90aWxlczsgdCA9IHQgKyAxKSB7XG4gICAgICAvLyBMb2FkIG9uZSB0aWxlIG9mIEEgaW50byBsb2NhbCBtZW1vcnkuXG4gICAgICBmb3IgKHZhciBpbnB1dFJvdyA9IGxvY2FsUm93OyBpbnB1dFJvdyA8ICR7aH07IGlucHV0Um93ID0gaW5wdXRSb3cgKyAke3RbMV19KSB7XG4gICAgICAgIGZvciAodmFyIGlucHV0Q29sID0gbG9jYWxDb2w7IGlucHV0Q29sIDwgJHt1fTsgaW5wdXRDb2wgPSBpbnB1dENvbCArICR7dFswXX0pIHtcbiAgICAgICAgICAke051KG8sbil9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIExvYWQgb25lIHRpbGUgb2YgQiBpbnRvIGxvY2FsIG1lbW9yeS5cbiAgICAgIGZvciAodmFyIGlucHV0Um93ID0gbG9jYWxSb3c7IGlucHV0Um93IDwgJHtpfTsgaW5wdXRSb3cgPSBpbnB1dFJvdyArICR7dFsxXX0pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGlucHV0Q29sID0gbG9jYWxDb2w7IGlucHV0Q29sIDwgJHttfTsgaW5wdXRDb2wgPSBpbnB1dENvbCArICR7dFswXX0pIHtcbiAgICAgICAgICBtbV9Cc3ViW2lucHV0Um93XVtpbnB1dENvbF0gPSBtbV9yZWFkQihiYXRjaCxcbiAgICAgICAgICAgIGtTdGFydCArIGlucHV0Um93LFxuICAgICAgICAgICAgZ2xvYmFsQ29sU3RhcnQgKyBpbnB1dENvbCR7bj9cIiwgYmF0Y2hJbmRpY2VzXCI6XCJcIn0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBrU3RhcnQgPSBrU3RhcnQgKyB0aWxlSW5uZXI7XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgIC8vIENvbXB1dGUgYWNjIHZhbHVlcyBmb3IgYSBzaW5nbGUgdGhyZWFkLlxuICAgICAgdmFyIEJDYWNoZWQgOiBhcnJheTwke3J9LCBjb2xQZXJUaHJlYWQ+O1xuICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aWxlSW5uZXI7IGsgPSBrICsgMSkge1xuICAgICAgICBmb3IgKHZhciBpbm5lciA9IDA7IGlubmVyIDwgY29sUGVyVGhyZWFkOyBpbm5lciA9IGlubmVyICsgMSkge1xuICAgICAgICAgIEJDYWNoZWRbaW5uZXJdID0gbW1fQnN1YltrXVtsb2NhbENvbCArIGlubmVyICogJHt0WzBdfV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaW5uZXJSb3cgPSAwOyBpbm5lclJvdyA8IHJvd1BlclRocmVhZDsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICAgICAgICBsZXQgQUNhY2hlZCA9ICR7bz9gbW1fQXN1YltrXVtsb2NhbFJvdyArIGlubmVyUm93ICogJHt0WzFdfV07YDpgbW1fQXN1Yltsb2NhbFJvdyArIGlubmVyUm93ICogJHt0WzFdfV1ba107YH1cbiAgICAgICAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgICAgICAgICAgYWNjW2lubmVyUm93XVtpbm5lckNvbF0gPSBhY2NbaW5uZXJSb3ddW2lubmVyQ29sXSArXG4gICAgICAgICAgICAgICAgQUNhY2hlZCAqIEJDYWNoZWRbaW5uZXJDb2xdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgICAgbGV0IGdSb3cgPSBnbG9iYWxSb3dTdGFydCArIGxvY2FsUm93ICsgaW5uZXJSb3cgKiAke3RbMV19O1xuICAgICAgZm9yICh2YXIgaW5uZXJDb2wgPSAwOyBpbm5lckNvbCA8IGNvbFBlclRocmVhZDsgaW5uZXJDb2wgPSBpbm5lckNvbCArIDEpIHtcbiAgICAgICAgbGV0IGdDb2wgPSBnbG9iYWxDb2xTdGFydCArIGxvY2FsQ29sICsgaW5uZXJDb2wgKiAke3RbMF19O1xuICAgICAgICBtbV93cml0ZShiYXRjaCwgZ1JvdywgZ0NvbCwgYWNjW2lubmVyUm93XVtpbm5lckNvbF0pO1xuICAgICAgfVxuICAgIH1cbiAgICBgOmBcbmxldCB0aWxlUm93ID0gaTMyKGxvY2FsSWQueSkgKiByb3dQZXJUaHJlYWQ7XG5sZXQgdGlsZUNvbCA9IGkzMihsb2NhbElkLngpICogY29sUGVyVGhyZWFkO1xuXG5sZXQgZ2xvYmFsUm93ID0gaTMyKGdsb2JhbElkLnkpICogcm93UGVyVGhyZWFkO1xubGV0IGdsb2JhbENvbCA9IGkzMihnbG9iYWxJZC54KSAqIGNvbFBlclRocmVhZDtcbmxldCBnbG9iYWxSb3dTdGFydCA9IGkzMih3b3JrZ3JvdXBJZC55KSAqICR7cH07XG5cbmxldCB0aWxlUm93QSA9IGkzMihsb2NhbElkLnkpICogJHtffTtcbmxldCB0aWxlQ29sQSA9IGkzMihsb2NhbElkLngpICogJHt5fTtcbmxldCB0aWxlUm93QiA9IGkzMihsb2NhbElkLnkpICogJHtnfTtcbi8vIExvb3Agb3ZlciBzaGFyZWQgZGltZW5zaW9uLlxuZm9yICh2YXIgdCA9IDA7IHQgPCBudW1fdGlsZXM7IHQgPSB0ICsgMSkge1xuICAvLyBMb2FkIG9uZSB0aWxlIG9mIEEgaW50byBsb2NhbCBtZW1vcnkuXG4gIGZvciAodmFyIGlubmVyUm93ID0gMDsgaW5uZXJSb3cgPCAke199OyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCAke3l9OyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgICAgbGV0IGlucHV0Um93ID0gdGlsZVJvd0EgKyBpbm5lclJvdztcbiAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2xBICsgaW5uZXJDb2w7XG4gICAgICAke051KG8sbil9XG4gICAgfVxuICB9XG5cbiAgLy8gTG9hZCBvbmUgdGlsZSBvZiBCIGludG8gbG9jYWwgbWVtb3J5LlxuICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgJHtnfTsgaW5uZXJSb3cgPSBpbm5lclJvdyArIDEpIHtcbiAgICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgICAgbGV0IGlucHV0Um93ID0gdGlsZVJvd0IgKyBpbm5lclJvdztcbiAgICAgIGxldCBpbnB1dENvbCA9IHRpbGVDb2wgKyBpbm5lckNvbDtcbiAgICAgIG1tX0JzdWJbaW5wdXRSb3ddW2lucHV0Q29sXSA9IG1tX3JlYWRCKGJhdGNoLFxuICAgICAgICBrU3RhcnQgKyBpbnB1dFJvdyxcbiAgICAgICAgZ2xvYmFsQ29sICsgaW5uZXJDb2wke24/XCIsIGJhdGNoSW5kaWNlc1wiOlwiXCJ9KTtcbiAgICB9XG4gIH1cbiAga1N0YXJ0ID0ga1N0YXJ0ICsgdGlsZUlubmVyO1xuICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgLy8gQ29tcHV0ZSBhY2MgdmFsdWVzIGZvciBhIHNpbmdsZSB0aHJlYWQuXG4gIHZhciBCQ2FjaGVkIDogYXJyYXk8JHtyfSwgY29sUGVyVGhyZWFkPjtcbiAgZm9yICh2YXIgayA9IDA7IGsgPCB0aWxlSW5uZXI7IGsgPSBrICsgMSkge1xuICAgIGZvciAodmFyIGlubmVyID0gMDsgaW5uZXIgPCBjb2xQZXJUaHJlYWQ7IGlubmVyID0gaW5uZXIgKyAxKSB7XG4gICAgICBCQ2FjaGVkW2lubmVyXSA9IG1tX0JzdWJba11bdGlsZUNvbCArIGlubmVyXTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICAgICAgJHtzZihvKX1cbiAgICAgIGZvciAodmFyIGlubmVyQ29sID0gMDsgaW5uZXJDb2wgPCBjb2xQZXJUaHJlYWQ7IGlubmVyQ29sID0gaW5uZXJDb2wgKyAxKSB7XG4gICAgICAgIGFjY1tpbm5lclJvd11baW5uZXJDb2xdID0gYWNjW2lubmVyUm93XVtpbm5lckNvbF0gKyBBQ2FjaGVkICogQkNhY2hlZFtpbm5lckNvbF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgd29ya2dyb3VwQmFycmllcigpO1xufVxuXG5mb3IgKHZhciBpbm5lclJvdyA9IDA7IGlubmVyUm93IDwgcm93UGVyVGhyZWFkOyBpbm5lclJvdyA9IGlubmVyUm93ICsgMSkge1xuICBmb3IgKHZhciBpbm5lckNvbCA9IDA7IGlubmVyQ29sIDwgY29sUGVyVGhyZWFkOyBpbm5lckNvbCA9IGlubmVyQ29sICsgMSkge1xuICAgIG1tX3dyaXRlKGJhdGNoLCBnbG9iYWxSb3cgKyBpbm5lclJvdywgZ2xvYmFsQ29sICsgaW5uZXJDb2wsXG4gICAgICAgIGFjY1tpbm5lclJvd11baW5uZXJDb2xdKTtcbiAgfVxufVxuYDtyZXR1cm5gXG4gIHZhcjx3b3JrZ3JvdXA+IG1tX0FzdWIgOiBhcnJheTxhcnJheTwke3J9LCAke3V9PiwgJHtofT47XG4gIHZhcjx3b3JrZ3JvdXA+IG1tX0JzdWIgOiBhcnJheTxhcnJheTwke3J9LCAke219PiwgJHtpfT47XG4gIGNvbnN0IHJvd1BlclRocmVhZCA9ICR7ZVsxXX07XG4gIGNvbnN0IGNvbFBlclRocmVhZCA9ICR7ZVswXX07XG4gIGNvbnN0IHRpbGVJbm5lciA9ICR7aX07XG5cbkBjb21wdXRlIEB3b3JrZ3JvdXBfc2l6ZSgke3RbMF19LCAke3RbMV19LCAke3RbMl19KVxuZm4gbWFpbihAYnVpbHRpbihsb2NhbF9pbnZvY2F0aW9uX2lkKSBsb2NhbElkIDogdmVjMzx1MzI+LFxuICAgICAgICBAYnVpbHRpbihnbG9iYWxfaW52b2NhdGlvbl9pZCkgZ2xvYmFsSWQgOiB2ZWMzPHUzMj4sXG4gICAgICAgIEBidWlsdGluKHdvcmtncm91cF9pZCkgd29ya2dyb3VwSWQgOiB2ZWMzPHUzMj4pIHtcbiAgICBsZXQgYmF0Y2ggPSAke2E/XCIwXCI6XCJpMzIoZ2xvYmFsSWQueilcIn07XG4gICAgJHtuP2BsZXQgYmF0Y2hJbmRpY2VzID0gJHtuLm9mZnNldFRvSW5kaWNlcyhcInUzMihiYXRjaClcIil9O2A6XCJcIn1cbiAgICBsZXQgbnVtX3RpbGVzID0gJHthP2Ake01hdGguY2VpbChkL2kpfWA6XCIodW5pZm9ybXMuZGltX2lubmVyIC0gMSkgLyB0aWxlSW5uZXIgKyAxXCJ9O1xuICAgIHZhciBrU3RhcnQgPSAke2E/YGkzMihnbG9iYWxJZC56KSAqICR7ZH1gOlwiMFwifTtcblxuICAgIHZhciBhY2MgOiBhcnJheTxhcnJheTwke3J9LCBjb2xQZXJUaHJlYWQ+LCByb3dQZXJUaHJlYWQ+O1xuICAgICR7eH1cbiAgfVxuYH0sdWY9KGUsdCxyLG4sbz0hMSk9PntsZXRbaSxhLGQsbF09bixwPV9lKG5bMF0udHlwZS50ZW5zb3IpO3JldHVybmBcbiAgICBmbiBtbV9yZWFkQShiYXRjaDogaTMyLCByb3c6IGkzMiwgY29sSW46IGkzMiwgYmF0Y2hJbmRpY2VzOiAke2kudHlwZS5pbmRpY2VzfSkgLT4gJHtBZShlLHApfSB7XG4gICAgICB2YXIgdmFsdWUgPSAke0FlKGUscCl9KDAuMCk7XG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke2V9O1xuICAgICAgaWYocm93IDwgdW5pZm9ybXMuZGltX2Ffb3V0ZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2lubmVyKVxuICAgICAge1xuICAgICAgICB2YXIgYUluZGljZXM6ICR7YS50eXBlLmluZGljZXN9O1xuICAgICAgICAke0p0KFwiYUluZGljZXNcIixhLGEucmFuay0yLGkucmFuayxcImJhdGNoSW5kaWNlc1wiKX1cbiAgICAgICAgJHthLmluZGljZXNTZXQoXCJhSW5kaWNlc1wiLGEucmFuay0yLFwidTMyKHJvdylcIil9XG4gICAgICAgICR7YS5pbmRpY2VzU2V0KFwiYUluZGljZXNcIixhLnJhbmstMSxcInUzMihjb2xJbilcIil9XG4gICAgICAgIHZhbHVlID0gJHthLmdldEJ5SW5kaWNlcyhcImFJbmRpY2VzXCIpfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmbiBtbV9yZWFkQihiYXRjaDogaTMyLCByb3c6IGkzMiwgY29sSW46IGkzMiwgYmF0Y2hJbmRpY2VzOiAke2kudHlwZS5pbmRpY2VzfSkgLT4gJHtBZShlLHApfSB7XG4gICAgICB2YXIgdmFsdWUgPSAke0FlKGUscCl9KDAuMCk7XG4gICAgICBsZXQgY29sID0gY29sSW4gKiAke2V9O1xuICAgICAgaWYocm93IDwgdW5pZm9ybXMuZGltX2lubmVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9iX291dGVyKVxuICAgICAge1xuICAgICAgICB2YXIgYkluZGljZXM6ICR7ZC50eXBlLmluZGljZXN9O1xuICAgICAgICAke0p0KFwiYkluZGljZXNcIixkLGQucmFuay0yLGkucmFuayxcImJhdGNoSW5kaWNlc1wiKX1cbiAgICAgICAgJHtkLmluZGljZXNTZXQoXCJiSW5kaWNlc1wiLGQucmFuay0yLFwidTMyKHJvdylcIil9XG4gICAgICAgICR7ZC5pbmRpY2VzU2V0KFwiYkluZGljZXNcIixkLnJhbmstMSxcInUzMihjb2xJbilcIil9XG4gICAgICAgIHZhbHVlID0gJHtkLmdldEJ5SW5kaWNlcyhcImJJbmRpY2VzXCIpfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBmbiBtbV93cml0ZShiYXRjaDogaTMyLCByb3c6IGkzMiwgY29sSW46IGkzMiwgdmFsdWVJbjogJHtBZShlLHApfSkge1xuICAgICAgbGV0IGNvbCA9IGNvbEluICogJHtlfTtcbiAgICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1fYV9vdXRlciAmJiBjb2wgPCB1bmlmb3Jtcy5kaW1fYl9vdXRlcikge1xuICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZUluO1xuICAgICAgICBsZXQgY29vcmRzID0gdmVjMzxpMzI+KGJhdGNoLCByb3csIGNvbEluKTtcbiAgICAgICAgJHt0P2B2YWx1ZSA9IHZhbHVlICsgJHtvP1wiYmlhc1tjb2xJbl1cIjpgJHtBZShlLHApfShiaWFzW3Jvd10pYH07YDpcIlwifVxuICAgICAgICAke3J9XG4gICAgICAgICR7bC5zZXRCeUluZGljZXMoXCJ2ZWMzPHUzMj4oY29vcmRzKVwiLFwidmFsdWVcIil9XG4gICAgICB9XG4gICAgfVxuICAgIGB9LGVyPShlLHQscixuLG89ITEsaSk9PntsZXQgYT1lWzBdLmRpbXMsZD1lWzFdLmRpbXMsbD1hLnNsaWNlKDAsLTIpLHA9ZC5zbGljZSgwLC0yKSxtPW4/bi5zbGljZSgwLC0yKTpyLnNsaWNlKDAsLTIpLHU9Qy5zaXplKG0pLGg9YVthLmxlbmd0aC0yXSxfPWFbYS5sZW5ndGgtMV0seT1kW2QubGVuZ3RoLTFdLGc9XyU0PT09MCYmeSU0PT09MCx4PWg8PTg/WzQsMSwxXTpbNCw0LDFdLCQ9WzgsOCwxXSx2PVtNYXRoLmNlaWwoeS8kWzBdL3hbMF0pLE1hdGguY2VpbChoLyRbMV0veFsxXSksTWF0aC5jZWlsKHUvJFsyXS94WzJdKV0sUz1nPzQ6MSxUPVsuLi5sLGgsXy9TXSxBPVQubGVuZ3RoLGs9Wy4uLnAsXyx5L1NdLFA9ay5sZW5ndGgsRD1bdSxoLHkvU10sUj1be3R5cGU6NixkYXRhOmh9LHt0eXBlOjYsZGF0YTp5fSx7dHlwZTo2LGRhdGE6X31dO0tlKHQsUiksUi5wdXNoKC4uLk4obSxULGspKTtsZXQgRz1bXCJyYW5rXCIsXCJyYW5rXCJdLEs9ZS5sZW5ndGg+MjtLJiYoUi5wdXNoKC4uLk4oZVsyXS5kaW1zKSksRy5wdXNoKFwicmFua1wiKSksUi5wdXNoKC4uLk4oRCkpO2xldCBqPVY9PntsZXQgUT1tLmxlbmd0aCxzZT1McihcImJhdGNoRGltc1wiLGVbMF0uZGF0YVR5cGUsUSwxKSxZPV9lKGVbMF0uZGF0YVR5cGUpLGVlPUUoXCJhXCIsZVswXS5kYXRhVHlwZSxBLFMpLEo9RShcImJcIixlWzFdLmRhdGFUeXBlLFAsUyksbmU9TShcInJlc3VsdFwiLGVbMF0uZGF0YVR5cGUsRC5sZW5ndGgsUyksYmU9W2VlLEpdO2lmKEspe2xldCBxPW8/UzoxO2JlLnB1c2goRShcImJpYXNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcy5sZW5ndGgscSkpfWxldCBPZT1be25hbWU6XCJkaW1fYV9vdXRlclwiLHR5cGU6XCJpMzJcIn0se25hbWU6XCJkaW1fYl9vdXRlclwiLHR5cGU6XCJpMzJcIn0se25hbWU6XCJkaW1faW5uZXJcIix0eXBlOlwiaTMyXCJ9XTtqZSh0LE9lKTtsZXQgJGU9X2UobmUudHlwZS50ZW5zb3IpLGxlPXFlKHQsbmUudHlwZS52YWx1ZSwkZSksVz11ZihTLEssbGUsW3NlLGVlLEosbmVdLG8pO3JldHVybmBcbiAgJHtWLnJlZ2lzdGVyVW5pZm9ybXMoT2UpLnJlZ2lzdGVySW50ZXJuYWxWYXJpYWJsZXMoc2UpLmRlY2xhcmVWYXJpYWJsZXMoLi4uYmUsbmUpfVxuICAke1d9XG4gICR7Zz9obyh4LCQsWSxzZSk6Z28oeCwkLFksc2UpfVxuICAgICAgICAgICAgICAgICAgIGB9O3JldHVybntuYW1lOlwiTWF0TXVsXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7eH07JHt0LmFjdGl2YXRpb259OyR7Z307JHtvfWAsaW5wdXREZXBlbmRlbmNpZXM6R30sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczppP2kocik6cixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDp2WzBdLHk6dlsxXSx6OnZbMl19LHByb2dyYW1Vbmlmb3JtczpSfSksZ2V0U2hhZGVyU291cmNlOmp9fX0pO3ZhciBkZixWdSxXdT1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtldCgpO2FlKCk7eXQoKTtZcigpO1V1KCk7WHIoKTtkZj0oZSx0LHIsbixvPSExLGksYT00LGQ9NCxsPTQscD1cImYzMlwiKT0+e2xldCBtPUc9Pntzd2l0Y2goRyl7Y2FzZSAxOnJldHVyblwicmVzRGF0YSA9IHhbeEluZGV4XTtcIjtjYXNlIDM6cmV0dXJuYHJlc0RhdGEgPSB2ZWMzPCR7cH0+KHhbeEluZGV4XSwgeFt4SW5kZXggKyAxXSwgeFt4SW5kZXggKyAyXSk7YDtjYXNlIDQ6cmV0dXJuXCJyZXNEYXRhID0geFt4SW5kZXggLyA0XTtcIjtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW5uZXJFbGVtZW50U2l6ZSAke0d9IGlzIG5vdCBzdXBwb3J0ZWQuYCl9fSx1PUc9Pntzd2l0Y2goRyl7Y2FzZSAxOnJldHVyblwicmV0dXJuIHdbcm93ICogaTMyKHVuaWZvcm1zLndfc2hhcGVbM10pICsgY29sSW5dO1wiO2Nhc2UgNDpyZXR1cm5cInJldHVybiB3W3JvdyAqIGkzMih1bmlmb3Jtcy53X3NoYXBlWzNdKSAvIDQgKyBjb2xJbl07XCI7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGlubmVyRWxlbWVudFNpemUgJHtHfSBpcyBub3Qgc3VwcG9ydGVkLmApfX0saD1lP2BcbiAgICBsZXQgY29vcmQgPSB2ZWM0PGkzMj4oYmF0Y2gsIHhSb3csIHhDb2wsIHhDaCk7XG4gICAgYDpgXG4gICAgbGV0IGNvb3JkID0gdmVjNDxpMzI+KGJhdGNoLCB4Q2gsIHhSb3csIHhDb2wpO1xuICAgIGAsXz1lP2BcbiAgICBsZXQgY29vcmRzID0gdmVjNDxpMzI+KFxuICAgICAgYmF0Y2gsXG4gICAgICByb3cgLyBvdXRXaWR0aCxcbiAgICAgIHJvdyAlIG91dFdpZHRoLFxuICAgICAgY29sKTtcbiAgICBgOmBcbiAgICBsZXQgY29vcmRzID0gdmVjNDxpMzI+KFxuICAgICAgYmF0Y2gsXG4gICAgICByb3csXG4gICAgICBjb2wgLyBvdXRXaWR0aCxcbiAgICAgIGNvbCAlIG91dFdpZHRoKTtcbiAgICBgLHk9ZT9cImkzMih1bmlmb3Jtcy54X3NoYXBlWzFdKVwiOlwiaTMyKHVuaWZvcm1zLnhfc2hhcGVbMl0pXCIsZz1lP1wiaTMyKHVuaWZvcm1zLnhfc2hhcGVbMl0pXCI6XCJpMzIodW5pZm9ybXMueF9zaGFwZVszXSlcIix4PWU/XCJyb3dcIjpcImNvbFwiLCQ9ZT9cImNvbFwiOlwicm93XCIsdj1gXG4gICAgbGV0IGluQ2hhbm5lbHMgPSBpMzIodW5pZm9ybXMud19zaGFwZVsyXSk7XG4gICAgbGV0IG91dFdpZHRoID0gJHtlP1wiaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVsyXSlcIjpcImkzMih1bmlmb3Jtcy5yZXN1bHRfc2hhcGVbM10pXCJ9O1xuICAgIGxldCBvdXRSb3cgPSAke3h9IC8gb3V0V2lkdGg7XG4gICAgbGV0IG91dENvbCA9ICR7eH0gJSBvdXRXaWR0aDtcblxuICAgIGxldCBXUm93ID0gJHskfSAvIChpMzIodW5pZm9ybXMud19zaGFwZVsxXSkgKiBpbkNoYW5uZWxzKTtcbiAgICBsZXQgV0NvbCA9ICR7JH0gLyBpbkNoYW5uZWxzICUgaTMyKHVuaWZvcm1zLndfc2hhcGVbMV0pO1xuICAgIGxldCB4Um93ID0gb3V0Um93ICogdW5pZm9ybXMuc3RyaWRlWzBdICsgdW5pZm9ybXMuZGlsYXRpb25bMF0gKiBXUm93IC0gdW5pZm9ybXMucGFkWzBdO1xuICAgIGxldCB4Q29sID0gb3V0Q29sICogdW5pZm9ybXMuc3RyaWRlWzFdICsgdW5pZm9ybXMuZGlsYXRpb25bMV0gKiBXQ29sIC0gdW5pZm9ybXMucGFkWzFdO1xuICAgIGxldCB4Q2ggPSAkeyR9ICUgaW5DaGFubmVscztcbiAgICB2YXIgcmVzRGF0YSA9ICR7QWUoYSxwKX0oMC4wKTtcbiAgICAvLyBUaGUgYm91bmRzIGNoZWNraW5nIGlzIGFsd2F5cyBuZWVkZWQgc2luY2Ugd2UgdXNlIGl0IHRvIHBhZCB6ZXJvIGZvclxuICAgIC8vIHRoZSAnc2FtZScgcGFkZGluZyB0eXBlLlxuICAgIGlmICh4Um93ID49IDAgJiYgeFJvdyA8ICR7eX0gJiYgeENvbCA+PSAwICYmIHhDb2wgPCAke2d9KSB7XG4gICAgICAke2h9XG4gICAgICBsZXQgeEluZGV4ID0gZ2V0SW5kZXhGcm9tQ29vcmRzNEQoY29vcmQsIHZlYzQ8aTMyPih1bmlmb3Jtcy54X3NoYXBlKSk7XG4gICAgICAke20oYSl9XG4gICAgfVxuICAgIHJldHVybiByZXNEYXRhO2AsUz1lP3QmJm4/YFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7YX07XG4gICAgJHt2fWA6YFxuICAgIGxldCBjb2wgPSBjb2xJbiAqICR7YX07XG4gICAgaWYgKHJvdyA8IHVuaWZvcm1zLmRpbV9hX291dGVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9pbm5lcikge1xuICAgICAgJHt2fVxuICAgIH1cbiAgICByZXR1cm4gJHtBZShhLHApfSgwLjApO2A6biYmcj9gXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHthfTtcbiAgICAke3Z9YDpgXG4gICAgbGV0IGNvbCA9IGNvbEluICogJHthfTtcbiAgICBpZiAocm93IDwgdW5pZm9ybXMuZGltX2lubmVyICYmIGNvbCA8IHVuaWZvcm1zLmRpbV9iX291dGVyKSB7XG4gICAgICAke3Z9XG4gICAgfVxuICAgIHJldHVybiAke0FlKGEscCl9KDAuMCk7YCxUPWU/biYmcj91KGQpOmBcbiAgICBsZXQgY29sID0gY29sSW4gKiAke2R9O1xuICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1faW5uZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXIpIHtcbiAgICAgICR7dShkKX1cbiAgICB9XG4gICAgcmV0dXJuICR7QWUoZCxwKX0oMC4wKTtgOmBcbiAgICBsZXQgY29sID0gY29sSW4gKiAke2R9O1xuICAgIGlmIChyb3cgPCB1bmlmb3Jtcy5kaW1faW5uZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Ffb3V0ZXIpIHtcbiAgICAgICR7dShkKX1cbiAgICB9XG4gICAgcmV0dXJuICR7QWUoZCxwKX0oMC4wKTtgLEE9QWUobCxwKSxrPWU/QWUoYSxwKTpBZShkLHApLFA9ZT9BZShkLHApOkFlKGEscCksRD1xZShpLEEscCk7cmV0dXJuYFxuICAgIGZuIG1tX3JlYWRBKGJhdGNoOiBpMzIsIHJvdyA6IGkzMiwgY29sSW4gOiBpMzIpIC0+ICR7a30ge1xuICAgICAgJHtlP1M6VH1cbiAgICB9XG5cbiAgICBmbiBtbV9yZWFkQihiYXRjaDogaTMyLCByb3cgOiBpMzIsIGNvbEluIDogaTMyKSAtPiAke1B9IHtcbiAgICAgICR7ZT9UOlN9XG4gICAgfVxuXG4gICAgZm4gbW1fd3JpdGUoYmF0Y2g6IGkzMiwgcm93IDogaTMyLCBjb2xJbiA6IGkzMiwgdmFsdWVJbiA6ICR7QX0pIHtcbiAgICAgIGxldCBjb2wgPSBjb2xJbiAqICR7bH07XG4gICAgICBpZiAocm93IDwgdW5pZm9ybXMuZGltX2Ffb3V0ZXIgJiYgY29sIDwgdW5pZm9ybXMuZGltX2Jfb3V0ZXIpXG4gICAgICB7XG4gICAgICB2YXIgdmFsdWUgPSB2YWx1ZUluO1xuICAgICAgbGV0IG91dFdpZHRoID0gJHtlP1wiaTMyKHVuaWZvcm1zLnJlc3VsdF9zaGFwZVsyXSlcIjpcImkzMih1bmlmb3Jtcy5yZXN1bHRfc2hhcGVbM10pXCJ9O1xuICAgICAgJHtffVxuICAgICAgJHtNdShvKX1cbiAgICAgICR7RH1cbiAgICAgIHNldE91dHB1dEF0Q29vcmRzKGNvb3Jkc1swXSwgY29vcmRzWzFdLCBjb29yZHNbMl0sIGNvb3Jkc1szXSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1gfSxWdT0oZSx0LHIsbixvLGksYSxkLGwpPT57bGV0IHA9dC5mb3JtYXQ9PT1cIk5IV0NcIixtPXA/ZVswXS5kaW1zWzNdOmVbMF0uZGltc1sxXSx1PXJbMF0saD1wP3JbMl06clszXSxfPXA/clsxXTpyWzJdLHk9cD9yWzNdOnJbMV0sZz1wJiYobSU0PT09MHx8bSUzPT09MCkmJnklND09PTAseD1wP3k6aCpfLCQ9cD9oKl86eSx2PVs4LDgsMV0sUz1uPD04P1s0LDEsMV06WzQsNCwxXSxUPVtNYXRoLmNlaWwoeC92WzBdL1NbMF0pLE1hdGguY2VpbCgkL3ZbMV0vU1sxXSksTWF0aC5jZWlsKHUvdlsyXS9TWzJdKV07dWUoXCJ2ZXJib3NlXCIsKCk9PmBbY29udjJkX21tX3dlYmdwdV0gZGlzcGF0Y2ggPSAke1R9YCk7bGV0IEE9Zz9wJiZtJTQhPT0wPzM6NDoxLGs9dlsxXSpTWzFdLFA9dlswXSpTWzBdLEQ9TWF0aC5tYXgodlswXSpBLHZbMV0pLFI9biVrPT09MCxHPW8lUD09PTAsSz1pJUQ9PT0wLGo9Zz9bQSw0LDRdOlsxLDEsMV0sVj1be3R5cGU6NixkYXRhOm59LHt0eXBlOjYsZGF0YTpvfSx7dHlwZTo2LGRhdGE6aX0se3R5cGU6NixkYXRhOlt0LnBhZHNbMF0sdC5wYWRzWzFdXX0se3R5cGU6NixkYXRhOnQuc3RyaWRlc30se3R5cGU6NixkYXRhOnQuZGlsYXRpb25zfV07S2UodCxWKSxWLnB1c2goLi4uTihlWzBdLmRpbXMsZVsxXS5kaW1zKSk7bGV0IFE9W1wicmFua1wiLFwicmFua1wiXTthJiYoVi5wdXNoKC4uLk4oZVsyXS5kaW1zKSksUS5wdXNoKFwicmFua1wiKSksVi5wdXNoKC4uLk4ocikpO2xldCBzZT1ZPT57bGV0IGVlPVt7bmFtZTpcImRpbV9hX291dGVyXCIsdHlwZTpcImkzMlwifSx7bmFtZTpcImRpbV9iX291dGVyXCIsdHlwZTpcImkzMlwifSx7bmFtZTpcImRpbV9pbm5lclwiLHR5cGU6XCJpMzJcIn0se25hbWU6XCJwYWRcIix0eXBlOlwiaTMyXCIsbGVuZ3RoOjJ9LHtuYW1lOlwic3RyaWRlXCIsdHlwZTpcImkzMlwiLGxlbmd0aDoyfSx7bmFtZTpcImRpbGF0aW9uXCIsdHlwZTpcImkzMlwiLGxlbmd0aDoyfV07amUodCxlZSk7bGV0IEo9Zz80OjEsbmU9X2UoZVswXS5kYXRhVHlwZSksYmU9YFxuICAgICAgZm4gc2V0T3V0cHV0QXRJbmRleChmbGF0SW5kZXggOiBpMzIsIHZhbHVlIDogJHtnP2B2ZWM0PCR7bmV9PmA6bmV9KSB7XG4gICAgICAgIHJlc3VsdFtmbGF0SW5kZXhdID0gJHtnP2B2ZWM0PCR7bmV9PmA6bmV9KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGZuIHNldE91dHB1dEF0Q29vcmRzKGQwIDogaTMyLCBkMSA6IGkzMiwgZDIgOiBpMzIsIGQzIDogaTMyLCB2YWx1ZSA6ICR7Zz9gdmVjNDwke25lfT5gOm5lfSkge1xuICAgICAgICBsZXQgZmxhdEluZGV4ID0gZ2V0T3V0cHV0SW5kZXhGcm9tQ29vcmRzKHZlYzQ8aTMyPihkMCwgZDEsIGQyLCBkMykpO1xuICAgICAgICBzZXRPdXRwdXRBdEluZGV4KGZsYXRJbmRleCAke2c/XCIvIDRcIjpcIlwifSwgdmFsdWUpO1xuICAgICAgfWAsT2U9RShcInhcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcy5sZW5ndGgsQT09PTM/MTpBKSwkZT1FKFwid1wiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zLmxlbmd0aCxKKSxsZT1bT2UsJGVdLFc9TShcInJlc3VsdFwiLGVbMF0uZGF0YVR5cGUsci5sZW5ndGgsSik7aWYoYSl7bGV0IHE9RShcImJpYXNcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcy5sZW5ndGgsSik7bGUucHVzaChxKSxiZSs9YFxuICAgICAgICBmbiBnZXRCaWFzQnlPdXRwdXRDb29yZHMoY29vcmRzIDogdmVjNDxpMzI+KSAtPiAke2c/YHZlYzQ8JHtuZX0+YDpuZX0ge1xuICAgICAgICAgIHJldHVybiBiaWFzW2Nvb3Jkcy4ke3A/XCJ3XCI6XCJ5XCJ9JHtnP1wiLyA0XCI6XCJcIn1dO1xuICAgICAgICB9YH1yZXR1cm5gXG4gICAgICAgICR7UnUoXCJ1bmlmb3Jtcy5yZXN1bHRfc3RyaWRlc1wiKX1cbiAgICAgICAgLy9zdHJ1Y3QgVW5pZm9ybXMgeyB4U2hhcGUgOiB2ZWM0PGkzMj4sIHdTaGFwZSA6IHZlYzQ8aTMyPiwgb3V0U2hhcGUgOiB2ZWM0PGkzMj4sXG4gICAgICAgIC8vICBvdXRTaGFwZVN0cmlkZXM6IHZlYzM8aTMyPiwgZmlsdGVyRGltcyA6IHZlYzI8aTMyPiwgcGFkIDogdmVjMjxpMzI+LCBzdHJpZGUgOiB2ZWMyPGkzMj4sXG4gICAgICAgIC8vICBkaWxhdGlvbiA6IHZlYzI8aTMyPiwgZGltQU91dGVyIDogaTMyLCBkaW1CT3V0ZXIgOiBpMzIsIGRpbUlubmVyIDogaTMyIH07XG4gICAgICAgICR7WS5yZWdpc3RlclVuaWZvcm1zKGVlKS5kZWNsYXJlVmFyaWFibGVzKC4uLmxlLFcpfVxuICAgICAgICAke2JlfVxuICAgICAgICAke2RmKHAsUixHLEssYSx0LGpbMF0salsxXSxqWzJdLG5lKX1cbiAgICAgICAgJHtnP2hvKFMsdixuZSx2b2lkIDAsIXAsRCk6Z28oUyx2LG5lLHZvaWQgMCwhcCxELCExLHZvaWQgMCxkKX1gfTtyZXR1cm57bmFtZTpcIkNvbnYyRE1hdE11bFwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9OyR7QX07JHtnfTske1J9OyR7R307JHtLfTske2t9OyR7UH07JHtEfWAsaW5wdXREZXBlbmRlbmNpZXM6UX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpsP2wocik6cixkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpUWzBdLHk6VFsxXSx6OlRbMl19LHByb2dyYW1Vbmlmb3JtczpWfSksZ2V0U2hhZGVyU291cmNlOnNlfX19KTt2YXIgbGYsTHUsSnIsY2YsR3UscGYsSHUsRnUscXU9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7ZXQoKTtvZSgpO2FlKCk7eXQoKTtZcigpO2xmPWU9PntsZXQgdD0xO2ZvcihsZXQgcj0wO3I8ZS5sZW5ndGg7cisrKXQqPWVbcl07cmV0dXJuIHR9LEx1PWU9PnR5cGVvZiBlPT1cIm51bWJlclwiP1tlLGUsZV06ZSxKcj0oZSx0KT0+dDw9MT9lOmUrKGUtMSkqKHQtMSksY2Y9KGUsdCxyLG49MSk9PntsZXQgbz1Kcih0LG4pO3JldHVybiBNYXRoLmZsb29yKChlWzBdKihyLTEpLXIrbykvMil9LEd1PShlLHQscixuLG8pPT57bz09bnVsbCYmKG89Y2YoZSx0WzBdLG5bMF0pKTtsZXQgaT1bMCwwLDAscl07Zm9yKGxldCBhPTA7YTwzO2ErKyllW2FdKzIqbz49dFthXSYmKGlbYV09TWF0aC50cnVuYygoZVthXS10W2FdKzIqbykvblthXSsxKSk7cmV0dXJuIGl9LHBmPShlLHQscixuLG8saSxhLGQsbCxwKT0+e2xldCBtLHUsaCxfO2lmKGU9PT1cIlZBTElEXCImJihlPTApLHR5cGVvZiBlPT1cIm51bWJlclwiKXttPXt0b3A6ZSxib3R0b206ZSxsZWZ0OmUscmlnaHQ6ZSxmcm9udDplLGJhY2s6ZX07bGV0IHk9R3UoW3QscixuLDFdLFtkLGwscF0sMSxbbyxpLGFdLGUpO3U9eVswXSxoPXlbMV0sXz15WzJdfWVsc2UgaWYoQXJyYXkuaXNBcnJheShlKSl7aWYoIWUuZXZlcnkoKGcseCwkKT0+Zz09PSRbMF0pKXRocm93IEVycm9yKGBVbnN1cHBvcnRlZCBwYWRkaW5nIHBhcmFtZXRlcjogJHtlfWApO209e3RvcDplWzBdLGJvdHRvbTplWzFdLGxlZnQ6ZVsyXSxyaWdodDplWzNdLGZyb250OmVbNF0sYmFjazplWzVdfTtsZXQgeT1HdShbdCxyLG4sMV0sW2QsbCxwXSwxLFtvLGksYV0sZVswXSk7dT15WzBdLGg9eVsxXSxfPXlbMl19ZWxzZSBpZihlPT09XCJTQU1FX1VQUEVSXCIpe3U9TWF0aC5jZWlsKHQvbyksaD1NYXRoLmNlaWwoci9pKSxfPU1hdGguY2VpbChuL2EpO2xldCB5PSh1LTEpKm8rZC10LGc9KGgtMSkqaStsLXIseD0oXy0xKSphK3AtbiwkPU1hdGguZmxvb3IoeS8yKSx2PXktJCxTPU1hdGguZmxvb3IoZy8yKSxUPWctUyxBPU1hdGguZmxvb3IoeC8yKSxrPXgtQTttPXt0b3A6Uyxib3R0b206VCxsZWZ0OkEscmlnaHQ6ayxmcm9udDokLGJhY2s6dn19ZWxzZSB0aHJvdyBFcnJvcihgVW5rbm93biBwYWRkaW5nIHBhcmFtZXRlcjogJHtlfWApO3JldHVybntwYWRJbmZvOm0sb3V0RGVwdGg6dSxvdXRIZWlnaHQ6aCxvdXRXaWR0aDpffX0sSHU9KGUsdCxyLG4sbyxpPSExLGE9XCJjaGFubmVsc0xhc3RcIik9PntsZXQgZCxsLHAsbSx1O2lmKGE9PT1cImNoYW5uZWxzTGFzdFwiKVtkLGwscCxtLHVdPWU7ZWxzZSBpZihhPT09XCJjaGFubmVsc0ZpcnN0XCIpW2QsdSxsLHAsbV09ZTtlbHNlIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBkYXRhRm9ybWF0ICR7YX1gKTtsZXRbaCwsXyx5LGddPXQsW3gsJCx2XT1MdShyKSxbUyxULEFdPUx1KG4pLGs9SnIoXyxTKSxQPUpyKHksVCksRD1KcihnLEEpLHtwYWRJbmZvOlIsb3V0RGVwdGg6RyxvdXRIZWlnaHQ6SyxvdXRXaWR0aDpqfT1wZihvLGwscCxtLHgsJCx2LGssUCxEKSxWPWk/aCp1OmgsUT1bMCwwLDAsMCwwXTtyZXR1cm4gYT09PVwiY2hhbm5lbHNGaXJzdFwiP1E9W2QsVixHLEssal06YT09PVwiY2hhbm5lbHNMYXN0XCImJihRPVtkLEcsSyxqLFZdKSx7YmF0Y2hTaXplOmQsZGF0YUZvcm1hdDphLGluRGVwdGg6bCxpbkhlaWdodDpwLGluV2lkdGg6bSxpbkNoYW5uZWxzOnUsb3V0RGVwdGg6RyxvdXRIZWlnaHQ6SyxvdXRXaWR0aDpqLG91dENoYW5uZWxzOlYscGFkSW5mbzpSLHN0cmlkZURlcHRoOngsc3RyaWRlSGVpZ2h0OiQsc3RyaWRlV2lkdGg6dixmaWx0ZXJEZXB0aDpfLGZpbHRlckhlaWdodDp5LGZpbHRlcldpZHRoOmcsZWZmZWN0aXZlRmlsdGVyRGVwdGg6ayxlZmZlY3RpdmVGaWx0ZXJIZWlnaHQ6UCxlZmZlY3RpdmVGaWx0ZXJXaWR0aDpELGRpbGF0aW9uRGVwdGg6UyxkaWxhdGlvbkhlaWdodDpULGRpbGF0aW9uV2lkdGg6QSxpblNoYXBlOmUsb3V0U2hhcGU6USxmaWx0ZXJTaGFwZTp0fX0sRnU9KGUsdCxyLG4sbyxpKT0+e2xldCBhPWk9PT1cImNoYW5uZWxzTGFzdFwiLGQ9YT9lWzBdLmRpbXNbM106ZVswXS5kaW1zWzFdLGw9ITEscD1bNjQsMSwxXSxtPXt4OnIubWFwKCh2LFMpPT5TKX0sdT1bTWF0aC5jZWlsKGxmKG0ueC5tYXAodj0+clt2XSkpL3BbMF0pLDEsMV07dWUoXCJ2ZXJib3NlXCIsKCk9PmBbY29udjNkX25haXZlX3dlYmdwdV0gZGlzcGF0Y2ggPSAke3V9YCk7bGV0IGg9bD9hJiZkJTQhPT0wPzM6NDoxLF89Qy5zaXplKHIpLHk9W3t0eXBlOjEyLGRhdGE6X30se3R5cGU6MTIsZGF0YTpufSx7dHlwZToxMixkYXRhOm99LHt0eXBlOjEyLGRhdGE6dC5zdHJpZGVzfSx7dHlwZToxMixkYXRhOnQuZGlsYXRpb25zfV07S2UodCx5KSx5LnB1c2goLi4uTihlWzBdLmRpbXMsZVsxXS5kaW1zKSk7bGV0IGc9W1wicmFua1wiLFwicmFua1wiXSx4PWUubGVuZ3RoPT09Mzt4JiYoeS5wdXNoKC4uLk4oZVsyXS5kaW1zKSksZy5wdXNoKFwicmFua1wiKSkseS5wdXNoKC4uLk4ocikpO2xldCAkPXY9PntsZXQgUz1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJmaWx0ZXJfZGltc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6bi5sZW5ndGh9LHtuYW1lOlwicGFkc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6by5sZW5ndGh9LHtuYW1lOlwic3RyaWRlc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6dC5zdHJpZGVzLmxlbmd0aH0se25hbWU6XCJkaWxhdGlvbnNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOnQuZGlsYXRpb25zLmxlbmd0aH1dO2plKHQsUyk7bGV0IFQ9bD80OjEsQT1fZShlWzBdLmRhdGFUeXBlKSxrPUUoXCJ4XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMubGVuZ3RoLGg9PT0zPzE6aCksUD1FKFwiV1wiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zLmxlbmd0aCxUKSxEPVtrLFBdLFI9TShcInJlc3VsdFwiLGVbMF0uZGF0YVR5cGUsci5sZW5ndGgsVCksRz1cIlwiO2lmKHgpe2xldCBWPUUoXCJiaWFzXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMubGVuZ3RoLFQpO0QucHVzaChWKSxHKz1gXG4gICAgICAgIGZuIGdldEJpYXNCeU91dHB1dENvb3Jkcyhjb29yZHMgOiBhcnJheTx1MzIsIDU+KSAtPiAke2w/YHZlYzQ8JHtBfT5gOkF9IHtcbiAgICAgICAgICByZXR1cm4gYmlhc1ske2E/RihcImNvb3Jkc1wiLDQsNSk6RihcImNvb3Jkc1wiLDEsNSl9JHtsP1wiLyA0XCI6XCJcIn1dO1xuICAgICAgICB9YH1sZXQgSz1BZShoLEEpLGo9cWUodCxLLEEpO3JldHVybmBcbiAgICAgICAgICAgICR7R31cbiAgICAgICAgICAgIGZuIGdldFgoZDAgOiB1MzIsIGQxIDogdTMyLCBkMiA6IHUzMiwgZDMgOiB1MzIsIGQ0IDogdTMyKSAtPiBmMzIge1xuICAgICAgICAgICAgICBsZXQgYUluZGljZXMgPSBhcnJheTx1MzIsIDU+KGQwLCBkMSwgZDIsIGQzLCBkNCk7XG4gICAgICAgICAgICAgIHJldHVybiAke2suZ2V0QnlJbmRpY2VzKFwiYUluZGljZXNcIil9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm4gZ2V0VyhkMCA6IHUzMiwgZDEgOiB1MzIsIGQyIDogdTMyLCBkMyA6IHUzMiwgZDQgOiB1MzIpIC0+IGYzMiB7XG4gICAgICAgICAgICAgIGxldCBhSW5kaWNlcyA9IGFycmF5PHUzMiwgNT4oZDAsIGQxLCBkMiwgZDMsIGQ0KTtcbiAgICAgICAgICAgICAgcmV0dXJuICR7UC5nZXRCeUluZGljZXMoXCJhSW5kaWNlc1wiKX07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgJHt2LnJlZ2lzdGVyVW5pZm9ybXMoUykuZGVjbGFyZVZhcmlhYmxlcyguLi5ELFIpfVxuICAgICAgICAgICR7di5tYWluU3RhcnQoKX1cbiAgICAgICAgICAke3YuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgICAgICAgICAgICBsZXQgY29vcmRzID0gJHtSLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgICAgICAgICBsZXQgYmF0Y2ggPSAke0YoXCJjb29yZHNcIiwwLGsucmFuayl9O1xuICAgICAgICAgICAgICBsZXQgZDIgPSAke2E/RihcImNvb3Jkc1wiLGsucmFuay0xLGsucmFuayk6RihcImNvb3Jkc1wiLDEsay5yYW5rKX07XG4gICAgICAgICAgICAgIGxldCB4RlJDQ29ybmVyID0gdmVjMzx1MzI+KCR7YT9GKFwiY29vcmRzXCIsMSxrLnJhbmspOkYoXCJjb29yZHNcIiwyLGsucmFuayl9LFxuICAgICAgICAgICAgICAke2E/RihcImNvb3Jkc1wiLDIsay5yYW5rKTpGKFwiY29vcmRzXCIsMyxrLnJhbmspfSxcbiAgICAgICAgICAgICAgJHthP0YoXCJjb29yZHNcIiwzLGsucmFuayk6RihcImNvb3Jkc1wiLDQsay5yYW5rKX0pICogdW5pZm9ybXMuc3RyaWRlcyAtIHVuaWZvcm1zLnBhZHM7XG4gICAgICAgICAgICAgIGxldCB4RkNvcm5lciA9IHhGUkNDb3JuZXIueDtcbiAgICAgICAgICAgICAgbGV0IHhSQ29ybmVyID0geEZSQ0Nvcm5lci55O1xuICAgICAgICAgICAgICBsZXQgeENDb3JuZXIgPSB4RlJDQ29ybmVyLno7XG4gICAgICAgICAgICAgIGxldCB4U2hhcGVZID0gJHthP0YoXCJ1bmlmb3Jtcy54X3NoYXBlXCIsMSxrLnJhbmspOkYoXCJ1bmlmb3Jtcy54X3NoYXBlXCIsMixrLnJhbmspfTtcbiAgICAgICAgICAgICAgbGV0IHhTaGFwZVogPSAke2E/RihcInVuaWZvcm1zLnhfc2hhcGVcIiwyLGsucmFuayk6RihcInVuaWZvcm1zLnhfc2hhcGVcIiwzLGsucmFuayl9O1xuICAgICAgICAgICAgICBsZXQgeFNoYXBlVyA9ICR7YT9GKFwidW5pZm9ybXMueF9zaGFwZVwiLDMsay5yYW5rKTpGKFwidW5pZm9ybXMueF9zaGFwZVwiLDQsay5yYW5rKX07XG4gICAgICAgICAgICAgIGxldCB4U2hhcGVVID0gJHthP0YoXCJ1bmlmb3Jtcy54X3NoYXBlXCIsNCxrLnJhbmspOkYoXCJ1bmlmb3Jtcy54X3NoYXBlXCIsMSxrLnJhbmspfTtcbiAgICAgICAgICAgICAgbGV0IGlucHV0RGVwdGhOZWFyZXN0VmVjNCA9ICh4U2hhcGVVIC8gNCkgKiA0O1xuICAgICAgICAgICAgICBsZXQgaW5wdXREZXB0aFZlYzRSZW1haW5kZXIgPSB4U2hhcGVVICUgNDtcblxuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSAwLjA7XG4gICAgICAgICAgICAgIGZvciAodmFyIHdGID0gMHU7IHdGIDwgdW5pZm9ybXMuZmlsdGVyX2RpbXNbMF07IHdGKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgeEYgPSB4RkNvcm5lciArIHdGICogdW5pZm9ybXMuZGlsYXRpb25zWzBdO1xuICAgICAgICAgICAgICAgIGlmICh4RiA8IDAgfHwgeEYgPj0geFNoYXBlWSkge1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgd1IgPSAwdTsgd1IgPCB1bmlmb3Jtcy5maWx0ZXJfZGltc1sxXTsgd1IrKykge1xuICAgICAgICAgICAgICAgICAgbGV0IHhSID0geFJDb3JuZXIgKyB3UiAqIHVuaWZvcm1zLmRpbGF0aW9uc1sxXTtcbiAgICAgICAgICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0geFNoYXBlWikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgd0MgPSAwdTsgd0MgPCB1bmlmb3Jtcy5maWx0ZXJfZGltc1syXTsgd0MrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeEMgPSB4Q0Nvcm5lciArIHdDICogdW5pZm9ybXMuZGlsYXRpb25zWzJdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoeEMgPCAwIHx8IHhDID49IHhTaGFwZVcpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGQxID0gMHU7IGQxIDwgaW5wdXREZXB0aE5lYXJlc3RWZWM0OyBkMSArPSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgJHthP2BsZXQgeFZhbHVlcyA9IHZlYzQ8ZjMyPihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBkMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgZDEgKyAxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBkMSArIDIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGQxICsgMykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGA6YGxldCB4VmFsdWVzID0gdmVjNDxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGQxLCB4RiwgeFIsIHhDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCBkMSArIDEsIHhGLCB4UiwgeEMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGQxICsgMiwgeEYsIHhSLCB4QyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgZDEgKyAzLCB4RiwgeFIsIHhDKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlcyA9IHZlYzQ8ZjMyPihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGQxLCB3Riwgd1IsIHdDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGQxICsgMSwgd0YsIHdSLCB3QyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBkMSArIDIsIHdGLCB3Uiwgd0MpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgZDEgKyAzLCB3Riwgd1IsIHdDKSk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAke2E/YHZhbHVlICs9IGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGlucHV0RGVwdGhOZWFyZXN0VmVjNClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKiBnZXRXKGQyLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQsIHdGLCB3Uiwgd0MpO2A6YHZhbHVlICs9IGdldFgoYmF0Y2gsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCwgeEYsIHhSLCB4QylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgKiBnZXRXKGQyLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQsIHdGLCB3Uiwgd0MpO2B9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXREZXB0aFZlYzRSZW1haW5kZXIgPT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICR7YT9gbGV0IHhWYWx1ZXMgPSB2ZWMyPGYzMj4oXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4RiwgeFIsIHhDLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICAgIGA6YGxldCB4VmFsdWVzID0gdmVjMjxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgaW5wdXREZXB0aE5lYXJlc3RWZWM0LCB4RiwgeFIsIHhDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDEsIHhGLCB4UiwgeEMpKTtcbiAgICAgICAgICAgICAgICAgICAgYH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IHdWYWx1ZXMgPSB2ZWMyPGYzMj4oXG4gICAgICAgICAgICAgICAgICAgICAgZ2V0VyhkMiwgaW5wdXREZXB0aE5lYXJlc3RWZWM0LCB3Riwgd1IsIHdDKSxcbiAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyAxLCB3Riwgd1IsIHdDKSk7XG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gZG90KHhWYWx1ZXMsIHdWYWx1ZXMpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0RGVwdGhWZWM0UmVtYWluZGVyID09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAke2E/YGxldCB4VmFsdWVzID0gdmVjMzxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgaW5wdXREZXB0aE5lYXJlc3RWZWM0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhGLCB4UiwgeEMsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeEYsIHhSLCB4QywgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMikpO1xuICAgICAgICAgICAgICAgICAgICAgIGA6YGxldCB4VmFsdWVzID0gdmVjMzxmMzI+KFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgaW5wdXREZXB0aE5lYXJlc3RWZWM0LCB4RiwgeFIsIHhDKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDEsIHhGLCB4UiwgeEMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgMiwgeEYsIHhSLCB4QykpO1xuICAgICAgICAgICAgICAgICAgICBgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgd1ZhbHVlcyA9IHZlYzM8ZjMyPihcbiAgICAgICAgICAgICAgICAgICAgICBnZXRXKGQyLCBpbnB1dERlcHRoTmVhcmVzdFZlYzQsIHdGLCB3Uiwgd0MpLFxuICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDEsIHdGLCB3Uiwgd0MpLFxuICAgICAgICAgICAgICAgICAgICAgIGdldFcoZDIsIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIDIsIHdGLCB3Uiwgd0MpKTtcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgJHt4P1widmFsdWUgPSB2YWx1ZSArIGdldEJpYXNCeU91dHB1dENvb3Jkcyhjb29yZHMpXCI6XCJcIn07XG4gICAgICAgICAgICAgICR7an1cbiAgICAgICAgICAgICAgcmVzdWx0W2dsb2JhbF9pZHhdID0gZjMyKHZhbHVlKTtcbiAgICAgICAgICB9YH07cmV0dXJue25hbWU6XCJDb252M0ROYWl2ZVwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9OyR7YX07JHtofTske3h9YCxpbnB1dERlcGVuZGVuY2llczpnfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOnIsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6dVswXSx5OnVbMV0sejp1WzJdfSxwcm9ncmFtVW5pZm9ybXM6eX0pLGdldFNoYWRlclNvdXJjZTokfX19KTt2YXIgS3UsanUsWXU9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTthZSgpO3l0KCk7S3U9KGUsdCxyLG4pPT57bGV0IG89ZS5sZW5ndGg+MixpPW8/XCJ2YWx1ZSArPSBiW291dHB1dF9jaGFubmVsXTtcIjpcIlwiLGE9ZVswXS5kaW1zLGQ9ZVsxXS5kaW1zLGw9dC5mb3JtYXQ9PT1cIk5IV0NcIixwPWw/clszXTpyWzFdLG09cC90Lmdyb3VwLHU9bCYmbT49ND9tZShwKToxLGg9Qy5zaXplKHIpL3UsXz1be3R5cGU6MTIsZGF0YTpofSx7dHlwZToxMixkYXRhOnQuZGlsYXRpb25zfSx7dHlwZToxMixkYXRhOlt0LnN0cmlkZXNbMF0sdC5zdHJpZGVzWzFdXX0se3R5cGU6MTIsZGF0YTpbdC5wYWRzWzBdLHQucGFkc1sxXV19LHt0eXBlOjEyLGRhdGE6bX1dO0tlKHQsXyksXy5wdXNoKC4uLk4oYSxbZFswXSxkWzFdLGRbMl0sZFszXS91XSkpO2xldCB5PW8/W1wicmFua1wiLFwicmFua1wiLFwicmFua1wiXTpbXCJyYW5rXCIsXCJyYW5rXCJdO18ucHVzaCguLi5OKFtyWzBdLHJbMV0sclsyXSxyWzNdL3VdKSk7bGV0IGc9eD0+e2xldCAkPU0oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLHIubGVuZ3RoLHUpLHY9X2UoJC50eXBlLnRlbnNvciksUz1xZSh0LCQudHlwZS52YWx1ZSx2KSxUPUUoXCJ4XCIsZVswXS5kYXRhVHlwZSxhLmxlbmd0aCksQT1FKFwid1wiLGVbMV0uZGF0YVR5cGUsZC5sZW5ndGgsdSksaz1bVCxBXTtvJiZrLnB1c2goRShcImJcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcyx1KSk7bGV0IFA9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiZGlsYXRpb25zXCIsdHlwZTpcInUzMlwiLGxlbmd0aDp0LmRpbGF0aW9ucy5sZW5ndGh9LHtuYW1lOlwic3RyaWRlc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6Mn0se25hbWU6XCJwYWRzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDoyfSx7bmFtZTpcIm91dHB1dF9jaGFubmVsc19wZXJfZ3JvdXBcIix0eXBlOlwidTMyXCJ9XTtqZSh0LFApO2xldCBEPWw/YFxuICAgICAgZm9yICh2YXIgd0hlaWdodDogdTMyID0gMHU7IHdIZWlnaHQgPCB1bmlmb3Jtcy53X3NoYXBlWzBdOyB3SGVpZ2h0KyspIHtcbiAgICAgICAgbGV0IHhIZWlnaHQgPSB4UkNDb3JuZXIueCArIHdIZWlnaHQgKiB1bmlmb3Jtcy5kaWxhdGlvbnNbMF07XG5cbiAgICAgICAgaWYgKHhIZWlnaHQgPCAwdSB8fCB4SGVpZ2h0ID49IHVuaWZvcm1zLnhfc2hhcGVbMV0pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIHdXaWR0aDogdTMyID0gMHU7IHdXaWR0aCA8IHVuaWZvcm1zLndfc2hhcGVbMV07IHdXaWR0aCsrKSB7XG4gICAgICAgICAgbGV0IHhXaWR0aCA9IHhSQ0Nvcm5lci55ICsgd1dpZHRoICogdW5pZm9ybXMuZGlsYXRpb25zWzFdO1xuICAgICAgICAgIGlmICh4V2lkdGggPCAwdSB8fCB4V2lkdGggPj0gdW5pZm9ybXMueF9zaGFwZVsyXSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICh2YXIgd0luQ2hhbm5lbDogdTMyID0gMHU7IHdJbkNoYW5uZWwgPCB1bmlmb3Jtcy53X3NoYXBlWzJdOyB3SW5DaGFubmVsKyspIHtcbiAgICAgICAgICAgIGxldCBpbnB1dF9jaGFubmVsID0gaW5fY2hhbm5lbF9vZmZzZXQgKyB3SW5DaGFubmVsO1xuICAgICAgICAgICAgbGV0IHhWYWwgPSAke1QuZ2V0KFwiYmF0Y2hcIixcInhIZWlnaHRcIixcInhXaWR0aFwiLFwiaW5wdXRfY2hhbm5lbFwiKX07XG4gICAgICAgICAgICBsZXQgd1ZhbCA9ICR7QS5nZXQoXCJ3SGVpZ2h0XCIsXCJ3V2lkdGhcIixcIndJbkNoYW5uZWxcIixcIm91dHB1dF9jaGFubmVsXCIpfTtcbiAgICAgICAgICAgIHZhbHVlICs9IHhWYWwgKiB3VmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYDpgXG4gICAgICBmb3IgKHZhciB3SW5DaGFubmVsOiB1MzIgPSAwdTsgd0luQ2hhbm5lbCA8IHVuaWZvcm1zLndfc2hhcGVbMV07IHdJbkNoYW5uZWwrKykge1xuICAgICAgICBsZXQgaW5wdXRfY2hhbm5lbCA9IGluX2NoYW5uZWxfb2Zmc2V0ICsgd0luQ2hhbm5lbDtcbiAgICAgICAgZm9yICh2YXIgd0hlaWdodDogdTMyID0gMHU7IHdIZWlnaHQgPCB1bmlmb3Jtcy53X3NoYXBlWzJdOyB3SGVpZ2h0KyspIHtcbiAgICAgICAgICBsZXQgeEhlaWdodCA9IHhSQ0Nvcm5lci54ICsgd0hlaWdodCAqIHVuaWZvcm1zLmRpbGF0aW9uc1swXTtcblxuICAgICAgICAgIGlmICh4SGVpZ2h0IDwgMHUgfHwgeEhlaWdodCA+PSB1bmlmb3Jtcy54X3NoYXBlWzJdKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciB3V2lkdGg6IHUzMiA9IDB1OyB3V2lkdGggPCB1bmlmb3Jtcy53X3NoYXBlWzNdOyB3V2lkdGgrKykge1xuICAgICAgICAgICAgbGV0IHhXaWR0aCA9IHhSQ0Nvcm5lci55ICsgd1dpZHRoICogdW5pZm9ybXMuZGlsYXRpb25zWzFdO1xuICAgICAgICAgICAgaWYgKHhXaWR0aCA8IDB1IHx8IHhXaWR0aCA+PSB1bmlmb3Jtcy54X3NoYXBlWzNdKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgeFZhbCA9ICR7VC5nZXQoXCJiYXRjaFwiLFwiaW5wdXRfY2hhbm5lbFwiLFwieEhlaWdodFwiLFwieFdpZHRoXCIpfTtcbiAgICAgICAgICAgIGxldCB3VmFsID0gJHtBLmdldChcIm91dHB1dF9jaGFubmVsXCIsXCJ3SW5DaGFubmVsXCIsXCJ3SGVpZ2h0XCIsXCJ3V2lkdGhcIil9O1xuICAgICAgICAgICAgdmFsdWUgKz0geFZhbCAqIHdWYWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBgO3JldHVybmBcbiAgJHt4LnJlZ2lzdGVyVW5pZm9ybXMoUCkuZGVjbGFyZVZhcmlhYmxlcyguLi5rLCQpfVxuXG4gICR7eC5tYWluU3RhcnQoKX1cbiAgICAke3guZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuXG4gICAgbGV0IG91dHB1dEluZGljZXMgPSAkeyQub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgbGV0IGJhdGNoOiB1MzIgPSBvdXRwdXRJbmRpY2VzWzBdO1xuICAgIGxldCBvdXRwdXRfY2hhbm5lbDogdTMyID0gb3V0cHV0SW5kaWNlc1ske2w/MzoxfV07XG4gICAgbGV0IHhSQ0Nvcm5lcjogdmVjMjx1MzI+ID0gdmVjMjx1MzI+KG91dHB1dEluZGljZXNbJHtsPzE6Mn1dLCBvdXRwdXRJbmRpY2VzWyR7bD8yOjN9XSkgKiB1bmlmb3Jtcy5zdHJpZGVzIC0gdW5pZm9ybXMucGFkcztcbiAgICBsZXQgZ3JvdXBfaWQ6IHUzMiA9IG91dHB1dF9jaGFubmVsICogJHt1fSAvIHVuaWZvcm1zLm91dHB1dF9jaGFubmVsc19wZXJfZ3JvdXA7XG4gICAgdmFyIGluX2NoYW5uZWxfb2Zmc2V0ID0gZ3JvdXBfaWQgKiB1bmlmb3Jtcy53X3NoYXBlWyR7bD8yOjF9XTtcblxuICAgIHZhciB2YWx1ZTogJHskLnR5cGUudmFsdWV9ID0gJHskLnR5cGUudmFsdWV9KDApO1xuICAgICR7RH1cbiAgICAke2l9XG4gICAgJHtTfVxuICAgICR7JC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlXCIpfVxuICB9YH07cmV0dXJue25hbWU6XCJHcm91cGVkQ29udlwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9XyR7dX1gLGlucHV0RGVwZW5kZW5jaWVzOnl9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6bj9uKHIpOnIsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGgvNjQpfSxwcm9ncmFtVW5pZm9ybXM6X30pLGdldFNoYWRlclNvdXJjZTpnfX0sanU9KGUsdCxyLG4pPT57bGV0IG89ZS5sZW5ndGg+MixpPW1lKHJbM10pLGE9bWUoclsyXSksZD1DLnNpemUocikvaS9hLGw9W2VbMF0uZGltc1swXSxlWzBdLmRpbXNbMV0sZVswXS5kaW1zWzJdLGVbMF0uZGltc1szXS9pXSxwPVtlWzFdLmRpbXNbMF0sZVsxXS5kaW1zWzFdLGVbMV0uZGltc1syXSxlWzFdLmRpbXNbM10vaV0sbT1bclswXSxyWzFdLHJbMl0sclszXS9pXSx1PVt7dHlwZToxMixkYXRhOmR9LHt0eXBlOjYsZGF0YTpbdC5zdHJpZGVzWzBdLHQuc3RyaWRlc1sxXV19LHt0eXBlOjYsZGF0YTpbdC5wYWRzWzBdLHQucGFkc1sxXV19XTtLZSh0LHUpLHUucHVzaCguLi5OKGwscCxtKSk7bGV0IGg9KGEtMSkqdC5zdHJpZGVzWzFdK3BbMV0sXz15PT57bGV0IGc9TShcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsbS5sZW5ndGgsaSkseD1fZShnLnR5cGUudGVuc29yKSwkPXFlKHQsZy50eXBlLnZhbHVlLHgpLHY9RShcInhcIixlWzBdLmRhdGFUeXBlLGwubGVuZ3RoLGkpLFM9RShcIndcIixlWzFdLmRhdGFUeXBlLHAubGVuZ3RoLGkpLFQ9W3YsU107byYmVC5wdXNoKEUoXCJiXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMsaSkpO2xldCBBPW8/XCJ2YWx1ZSArPSBiW291dHB1dF9jaGFubmVsXTtcIjpcIlwiLGs9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwic3RyaWRlc1wiLHR5cGU6XCJpMzJcIixsZW5ndGg6Mn0se25hbWU6XCJwYWRzXCIsdHlwZTpcImkzMlwiLGxlbmd0aDoyfV07cmV0dXJuIGplKHQsayksYFxuICAke3kucmVnaXN0ZXJVbmlmb3JtcyhrKS5kZWNsYXJlVmFyaWFibGVzKC4uLlQsZyl9XG4gICR7eS5tYWluU3RhcnQoKX1cbiAgICAke3kuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgIGxldCB3aWR0aDAgPSB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbM107XG4gICAgbGV0IG91dHB1dF9jaGFubmVsID0gZ2xvYmFsX2lkeCAlIHdpZHRoMDtcbiAgICB2YXIgaW5kZXgxID0gZ2xvYmFsX2lkeCAvIHdpZHRoMDtcbiAgICBsZXQgd2lkdGgxID0gdW5pZm9ybXMub3V0cHV0X3NoYXBlWzJdIC8gJHthfXU7XG4gICAgbGV0IGNvbCA9IChpbmRleDEgJSB3aWR0aDEpICogJHthfXU7XG4gICAgaW5kZXgxID0gaW5kZXgxIC8gd2lkdGgxO1xuICAgIGxldCByb3cgPSBpbmRleDEgJSB1bmlmb3Jtcy5vdXRwdXRfc2hhcGVbMV07XG4gICAgbGV0IGJhdGNoID0gaW5kZXgxIC8gdW5pZm9ybXMub3V0cHV0X3NoYXBlWzFdO1xuXG4gICAgbGV0IHhfY29ybmVyID0gdmVjMjxpMzI+KGkzMihyb3cpLCBpMzIoY29sKSkgKiB1bmlmb3Jtcy5zdHJpZGVzIC0gdW5pZm9ybXMucGFkcztcblxuICAgIHZhciB4X3ZhbHM6IGFycmF5PCR7di50eXBlLnZhbHVlfSwgJHtofT47XG4gICAgdmFyIHZhbHVlczogYXJyYXk8JHtnLnR5cGUudmFsdWV9LCAke2F9PjtcbiAgICBsZXQgaW5wdXRfY2hhbm5lbCA9IG91dHB1dF9jaGFubmVsO1xuICAgIC8vIFVzZSBjb25zdGFudCBpbnN0ZWFkIG9mIHVuaWZvcm0gY2FuIGdpdmUgYmV0dGVyIHBlcmZvcm1hbmNlIGZvciB3J3MgaGVpZ2h0L3dpZHRoLlxuICAgIGZvciAodmFyIHdfaGVpZ2h0OiB1MzIgPSAwdTsgd19oZWlnaHQgPCAke3BbMF19OyB3X2hlaWdodCsrKSB7XG4gICAgICBsZXQgeF9oZWlnaHQgPSB4X2Nvcm5lci54ICsgaTMyKHdfaGVpZ2h0KTtcbiAgICAgIGlmICh4X2hlaWdodCA+PSAwICYmIHUzMih4X2hlaWdodCkgPCB1bmlmb3Jtcy54X3NoYXBlWzFdKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgJHtofTsgaSsrKSB7XG4gICAgICAgICAgbGV0IHhfd2lkdGggPSB4X2Nvcm5lci55ICsgaTtcbiAgICAgICAgICBpZiAoeF93aWR0aCA+PSAwICYmIHUzMih4X3dpZHRoKSA8IHVuaWZvcm1zLnhfc2hhcGVbMl0pIHtcbiAgICAgICAgICAgIHhfdmFsc1tpXSA9ICR7di5nZXQoXCJiYXRjaFwiLFwidTMyKHhfaGVpZ2h0KVwiLFwidTMyKHhfd2lkdGgpXCIsXCJpbnB1dF9jaGFubmVsXCIpfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeF92YWxzW2ldID0gJHt2LnR5cGUudmFsdWV9KDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciB3X3dpZHRoOiB1MzIgPSAwdTsgd193aWR0aCA8ICR7cFsxXX07IHdfd2lkdGgrKykge1xuICAgICAgICAgIGxldCB3X3ZhbCA9ICR7Uy5nZXQoXCJ3X2hlaWdodFwiLFwid193aWR0aFwiLFwiMFwiLFwib3V0cHV0X2NoYW5uZWxcIil9O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwdTsgaSA8ICR7YX11OyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlc1tpXSA9IGZtYSh4X3ZhbHNbaSAqIHUzMih1bmlmb3Jtcy5zdHJpZGVzWzFdKSArIHdfd2lkdGhdLCB3X3ZhbCwgdmFsdWVzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMHU7IGkgPCAke2F9dTsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAke0F9XG4gICAgICAkeyR9XG4gICAgICAke2cuc2V0KFwiYmF0Y2hcIixcInJvd1wiLFwiY29sICsgaVwiLFwib3V0cHV0X2NoYW5uZWxcIixcInZhbHVlXCIpfTtcbiAgICB9XG4gIH1gfTtyZXR1cm57bmFtZTpcIkdyb3VwZWRDb252LVZlY3Rvcml6ZVwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9OyR7aX07JHthfTske2h9OyR7cFswXX07JHtwWzFdfWAsaW5wdXREZXBlbmRlbmNpZXM6bz9bXCJyYW5rXCIsXCJyYW5rXCIsXCJ0eXBlXCJdOltcInJhbmtcIixcInJhbmtcIl19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6bj9uKHIpOnIsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGQvNjQpfSxwcm9ncmFtVW5pZm9ybXM6dX0pLGdldFNoYWRlclNvdXJjZTpffX19KTt2YXIgbWYsYm8sZmYseW8sX28sWnUsaGYsZ2Ysd28sUXU9VSgoKT0+e1widXNlIHN0cmljdFwiO29lKCk7V3UoKTtxdSgpO1hyKCk7WXUoKTt5dCgpO1FyKCk7ZHQoKTttZj0oZSx0LHIsbixvLGkpPT57bGV0IGE9ZVswXSxkPWUuc2xpY2UoaT8xOjIsaT8zOjQpLGw9ZC5sZW5ndGgscD10WzBdLHU9dC5zbGljZSgyKS5tYXAoKHksZyk9PnkrKHktMSkqKHJbZ10tMSkpLF89ZC5tYXAoKHksZyk9PnkrbltnXStuW2crbF0pLm1hcCgoeSxnKT0+TWF0aC5mbG9vcigoeS11W2ddK29bZ10pL29bZ10pKTtyZXR1cm4gXy5zcGxpY2UoMCwwLGEpLF8uc3BsaWNlKGk/MzoxLDAscCksX30sYm89WzIsMywxLDBdLGZmPShlLHQpPT57aWYoIWV8fGUubGVuZ3RoIT09MiYmZS5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcihcIkNvbnYgcmVxdWlyZXMgMiBvciAzIGlucHV0c1wiKTtpZihlWzBdLmRpbXMubGVuZ3RoPjUpdGhyb3cgbmV3IEVycm9yKFwiZ3JlYXRlciB0aGFuIDVEIGlzIG5vdCBzdXBwb3J0ZWRcIik7aWYoZVswXS5kaW1zLmxlbmd0aCE9PWVbMV0uZGltcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiZmlsdGVyIGRvZXMgbm90IGhhdmUgc2FtZSBkaW1lbnNpb24gYXMgaW5wdXRcIik7bGV0IHI9ZVswXS5kaW1zW3QuZm9ybWF0PT09XCJOSFdDXCI/ZVswXS5kaW1zLmxlbmd0aC0xOjFdLG49ZVsxXS5kaW1zWzFdKnQuZ3JvdXA7aWYociE9PW4pdGhyb3cgbmV3IEVycm9yKFwiRklMVEVSX0lOX0NIQU5ORUwgc2hvdWxkIGJlIGVxdWFsIHRvIERBVEFfQ0hBTk5FTFwiKTtpZihlLmxlbmd0aD09PTMmJihlWzJdLmRpbXMubGVuZ3RoIT09MXx8ZVsxXS5kaW1zWzBdIT09ZVsyXS5kaW1zWzBdKSl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJpYXNcIik7bGV0IG89ZVswXS5kaW1zLmxlbmd0aC0yO2lmKHQuZGlsYXRpb25zLmxlbmd0aCE9PW8pdGhyb3cgbmV3IEVycm9yKGBkaWxhdGlvbnMgc2hvdWxkIGJlICR7b31EYCk7aWYodC5zdHJpZGVzLmxlbmd0aCE9PW8pdGhyb3cgbmV3IEVycm9yKGBzdHJpZGVzIHNob3VsZCBiZSAke299RGApO2lmKHQucGFkcy5sZW5ndGghPT1vKjIpdGhyb3cgbmV3IEVycm9yKGBwYWRzIHNob3VsZCBiZSAke28qMn1EYCk7aWYodC5rZXJuZWxTaGFwZS5sZW5ndGghPT0wJiZ0Lmtlcm5lbFNoYXBlLmxlbmd0aCE9PWVbMV0uZGltcy5sZW5ndGgtMil0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGtlcm5lbCBzaGFwZVwiKX0seW89KGUsdCk9PntsZXQgcj1lLmtlcm5lbFNoYXBlLnNsaWNlKCk7ci5sZW5ndGg8dFsxXS5kaW1zLmxlbmd0aC0yJiZyLnB1c2goLi4uQXJyYXkodFsxXS5kaW1zLmxlbmd0aC0yLXIubGVuZ3RoKS5maWxsKDApKTtmb3IobGV0IGk9MjtpPHRbMV0uZGltcy5sZW5ndGg7KytpKXJbaS0yXT09PTAmJihyW2ktMl09dFsxXS5kaW1zW2ldKTtsZXQgbj1lLnBhZHMuc2xpY2UoKTtBdC5hZGp1c3RQYWRzQmFzZWRPbkF1dG9QYWQodFswXS5kaW1zLGUuc3RyaWRlcyxlLmRpbGF0aW9ucyxyLG4sZS5mb3JtYXQ9PT1cIk5IV0NcIixlLmF1dG9QYWQpO2xldCBvPU9iamVjdC5hc3NpZ24oe30sZSk7cmV0dXJuIE9iamVjdC5hc3NpZ24obyx7a2VybmVsU2hhcGU6cixwYWRzOm59KSxvfSxfbz1lPT57bGV0IHQ9anIoZSkscj1lLmZvcm1hdCxuPVtcIk5PVFNFVFwiLFwiVkFMSURcIixcIlNBTUVfVVBQRVJcIixcIlNBTUVfTE9XRVJcIl1bZS5hdXRvX3BhZF0sbz1lLmRpbGF0aW9ucyxpPWUuZ3JvdXAsYT1lLmtlcm5lbF9zaGFwZSxkPWUucGFkcyxsPWUuc3RyaWRlcyxwPWUud19pc19jb25zdCgpO3JldHVybnthdXRvUGFkOm4sZm9ybWF0OnIsZGlsYXRpb25zOm8sZ3JvdXA6aSxrZXJuZWxTaGFwZTphLHBhZHM6ZCxzdHJpZGVzOmwsd0lzQ29uc3Q6cCwuLi50LGNhY2hlS2V5OmAke2UuZm9ybWF0fTske3QuYWN0aXZhdGlvbn07YH19LFp1PShlLHQscixuKT0+e2xldCBvPXIuZm9ybWF0PT09XCJOSFdDXCIsaT1tZih0WzBdLmRpbXMsdFsxXS5kaW1zLHIuZGlsYXRpb25zLHIucGFkcyxyLnN0cmlkZXMsbyk7aWYoci5ncm91cCE9PTEpe2xldCBrPVt0WzBdXTtpZihvKXtsZXQgRD1lLmtlcm5lbEN1c3RvbURhdGEud1Q/P2UuY29tcHV0ZShQZSh0WzFdLGJvKSx7aW5wdXRzOlsxXSxvdXRwdXRzOltyLndJc0NvbnN0Py0yOi0xXX0pWzBdO3Iud0lzQ29uc3QmJiFlLmtlcm5lbEN1c3RvbURhdGEud1QmJihlLmtlcm5lbEN1c3RvbURhdGEud1Q9RCksay5wdXNoKEQpfWVsc2Ugay5wdXNoKHRbMV0pO3QubGVuZ3RoPT09MyYmay5wdXNoKHRbMl0pLCFlLmFkYXB0ZXJJbmZvLmlzQXJjaGl0ZWN0dXJlKFwiYW1wZXJlXCIpJiZvJiZ0WzFdLmRpbXNbMF09PT1yLmdyb3VwJiZ0WzFdLmRpbXNbMV09PT0xJiZyLmRpbGF0aW9uc1swXT09PTEmJnIuZGlsYXRpb25zWzFdPT09MT9lLmNvbXB1dGUoanUoayxyLGksbikse2lucHV0czprfSk6ZS5jb21wdXRlKEt1KGsscixpLG4pLHtpbnB1dHM6a30pO3JldHVybn1sZXQgYT10Lmxlbmd0aD09PTMsZD10WzBdLmRpbXNbbz8xOjJdLGw9dFswXS5kaW1zW28/MjozXSxwPXRbMF0uZGltc1tvPzM6MV0sbT10WzFdLmRpbXNbMl0sdT10WzFdLmRpbXNbM10saD1pW28/MToyXSxfPWlbbz8yOjNdLHk9aVtvPzM6MV0sZz1vJiZtPT09ZCYmdT09PWwmJnIucGFkc1swXT09PTAmJnIucGFkc1sxXT09PTA7aWYoZ3x8bT09PTEmJnU9PT0xJiZyLmRpbGF0aW9uc1swXT09PTEmJnIuZGlsYXRpb25zWzFdPT09MSYmci5zdHJpZGVzWzBdPT09MSYmci5zdHJpZGVzWzFdPT09MSYmci5wYWRzWzBdPT09MCYmci5wYWRzWzFdPT09MCl7bGV0IGs9aVswXSxQLEQsUixHPVtdO2lmKG8pe2xldCBWPWUua2VybmVsQ3VzdG9tRGF0YS53VD8/ZS5jb21wdXRlKFBlKHRbMV0sYm8pLHtpbnB1dHM6WzFdLG91dHB1dHM6W3Iud0lzQ29uc3Q/LTI6LTFdfSlbMF07aWYoci53SXNDb25zdCYmIWUua2VybmVsQ3VzdG9tRGF0YS53VCYmKGUua2VybmVsQ3VzdG9tRGF0YS53VD1WKSxnKXtsZXQgUT1kKmwqcDtQPXRbMF0ucmVzaGFwZShbMSxrLFFdKSxEPVYucmVzaGFwZShbMSxRLHldKSxSPVsxLGsseV19ZWxzZSBQPXRbMF0ucmVzaGFwZShbayxkKmwscF0pLEQ9Vi5yZXNoYXBlKFsxLHAseV0pLFI9W2ssaCpfLHldO0cucHVzaChQKSxHLnB1c2goRCl9ZWxzZSBQPXRbMF0ucmVzaGFwZShbayxwLGQqbF0pLEQ9dFsxXS5yZXNoYXBlKFsxLHkscF0pLFI9W2sseSxoKl9dLEcucHVzaChEKSxHLnB1c2goUCk7YSYmRy5wdXNoKHRbMl0pO2xldCBLPVJbMl0saj1HWzBdLmRpbXNbR1swXS5kaW1zLmxlbmd0aC0xXTtLPDgmJmo8OD9lLmNvbXB1dGUoWnIoRyxyLGksUixvLG4pLHtpbnB1dHM6R30pOmUuY29tcHV0ZShlcihHLHIsaSxSLG8sbikse2lucHV0czpHfSk7cmV0dXJufWxldCB4PSEwLCQ9ZS5rZXJuZWxDdXN0b21EYXRhLndUPz9lLmNvbXB1dGUoUGUodFsxXSxibykse2lucHV0czpbMV0sb3V0cHV0czpbci53SXNDb25zdD8tMjotMV19KVswXTtyLndJc0NvbnN0JiYhZS5rZXJuZWxDdXN0b21EYXRhLndUJiYoZS5rZXJuZWxDdXN0b21EYXRhLndUPSQpO2xldCB2PVt0WzBdLCRdO2EmJnYucHVzaCh0WzJdKTtsZXQgUz1vP2gqXzp5LFQ9bz95OmgqXyxBPW0qdSpwO2UuY29tcHV0ZShWdSh2LHIsaSxTLFQsQSxhLHgsbikse2lucHV0czp2fSl9LGhmPShlLHQpPT57bGV0IHI9dC5mb3JtYXQ9PT1cIk5IV0NcIixuPVtlLmlucHV0c1swXS5yZXNoYXBlKHI/W2UuaW5wdXRzWzBdLmRpbXNbMF0sMSxlLmlucHV0c1swXS5kaW1zWzFdLGUuaW5wdXRzWzBdLmRpbXNbMl1dOltlLmlucHV0c1swXS5kaW1zWzBdLGUuaW5wdXRzWzBdLmRpbXNbMV0sMSxlLmlucHV0c1swXS5kaW1zWzJdXSksZS5pbnB1dHNbMV0ucmVzaGFwZShbZS5pbnB1dHNbMV0uZGltc1swXSxlLmlucHV0c1sxXS5kaW1zWzFdLDEsZS5pbnB1dHNbMV0uZGltc1syXV0pXTtlLmlucHV0cy5sZW5ndGg9PT0zJiZuLnB1c2goZS5pbnB1dHNbMl0pO2xldCBvPVswLHQucGFkc1swXSwwLHQucGFkc1sxXV0saT1bMV0uY29uY2F0KHQuc3RyaWRlcyksYT1bMV0uY29uY2F0KHQuZGlsYXRpb25zKSxkPVsxXS5jb25jYXQodC5rZXJuZWxTaGFwZSksbD15byh7Li4udCxwYWRzOm8sc3RyaWRlczppLGRpbGF0aW9uczphLGtlcm5lbFNoYXBlOmR9LG4pO1p1KGUsbixsLHA9PnI/W3BbMF0scFsyXSxwWzNdXTpbcFswXSxwWzFdLHBbM11dKX0sZ2Y9KGUsdCxyKT0+e2xldCBuPXIuZm9ybWF0PT09XCJOSFdDXCI/XCJjaGFubmVsc0xhc3RcIjpcImNoYW5uZWxzRmlyc3RcIixvPXlvKHIsdCksaT1yLmF1dG9QYWQ9PT1cIk5PVFNFVFwiP3IucGFkczpyLmF1dG9QYWQsYT1IdSh0WzBdLmRpbXMsdFsxXS5kaW1zLHIuc3RyaWRlcyxyLmRpbGF0aW9ucyxpLCExLG4pO2UuY29tcHV0ZShGdSh0LG8sYS5vdXRTaGFwZSxbYS5maWx0ZXJEZXB0aCxhLmZpbHRlckhlaWdodCxhLmZpbHRlcldpZHRoXSxbYS5wYWRJbmZvLmZyb250LGEucGFkSW5mby50b3AsYS5wYWRJbmZvLmxlZnRdLG4pKX0sd289KGUsdCk9PntpZihmZihlLmlucHV0cyx0KSxlLmlucHV0c1swXS5kaW1zLmxlbmd0aD09PTMpaGYoZSx0KTtlbHNlIGlmKGUuaW5wdXRzWzBdLmRpbXMubGVuZ3RoPT09NSlnZihlLGUuaW5wdXRzLHQpO2Vsc2V7bGV0IHI9eW8odCxlLmlucHV0cyk7WnUoZSxlLmlucHV0cyxyKX19fSk7dmFyIFh1LEp1PVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO2V0KCk7b2UoKTthZSgpO1h1PShlLHQscik9PntsZXQgbj1lLmxlbmd0aD4yLG89dC5vdXRwdXRTaGFwZSxpPXQuZm9ybWF0PT09XCJOSFdDXCIsYT10Lmdyb3VwLGQ9ZVsxXS5kaW1zLGw9ZFsyXS9hLHA9ZFszXSxtPWk/bWUobCk6MSx1PWk/bWUocCk6MSxoPWk/cD09PTE/bTp1OjEsXz1DLnNpemUobykvdSx5PVtNYXRoLmNlaWwoXy82NCksMSwxXTt1ZShcInZlcmJvc2VcIiwoKT0+YFtjb252MmRfYmFja3Byb3Bfd2ViZ3B1XSBkaXNwYXRjaCA9ICR7eX1gKTtsZXQgZz1bXCJyYW5rXCIsXCJyYW5rXCJdLHg9W3Quc3RyaWRlc1swXSx0LnN0cmlkZXNbMV1dLCQ9W3Qua2VybmVsU2hhcGVbaT8xOjJdLHQua2VybmVsU2hhcGVbaT8yOjNdXSx2PVt0LmRpbGF0aW9uc1swXSx0LmRpbGF0aW9uc1sxXV0sUz1bJFswXSsodC5kaWxhdGlvbnNbMF08PTE/MDoodC5rZXJuZWxTaGFwZVtpPzE6Ml0tMSkqKHQuZGlsYXRpb25zWzBdLTEpKSwkWzFdKyh0LmRpbGF0aW9uc1sxXTw9MT8wOih0Lmtlcm5lbFNoYXBlW2k/MjozXS0xKSoodC5kaWxhdGlvbnNbMV0tMSkpXSxUPVtTWzBdLTEtTWF0aC5mbG9vcigodC5wYWRzWzBdK3QucGFkc1syXSkvMiksU1sxXS0xLU1hdGguZmxvb3IoKHQucGFkc1sxXSt0LnBhZHNbM10pLzIpXSxBPVt7dHlwZToxMixkYXRhOl99LHt0eXBlOjEyLGRhdGE6eH0se3R5cGU6MTIsZGF0YTokfSx7dHlwZToxMixkYXRhOnZ9LHt0eXBlOjEyLGRhdGE6U30se3R5cGU6NixkYXRhOlR9LHt0eXBlOjEyLGRhdGE6bH0se3R5cGU6MTIsZGF0YTpwfSwuLi5OKGVbMF0uZGltcyxlWzFdLmRpbXMpXTtuJiYoQS5wdXNoKC4uLk4oZVsyXS5kaW1zKSksZy5wdXNoKFwicmFua1wiKSksQS5wdXNoKC4uLk4obykpO2xldCBrPVA9PntsZXQgRD1be25hbWU6XCJvdXRwdXRfc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJzdHJpZGVzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDp4Lmxlbmd0aH0se25hbWU6XCJmaWx0ZXJfZGltc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6JC5sZW5ndGh9LHtuYW1lOlwiZGlsYXRpb25zXCIsdHlwZTpcInUzMlwiLGxlbmd0aDokLmxlbmd0aH0se25hbWU6XCJlZmZlY3RpdmVfZmlsdGVyX2RpbXNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOlMubGVuZ3RofSx7bmFtZTpcInBhZHNcIix0eXBlOlwiaTMyXCIsbGVuZ3RoOlQubGVuZ3RofSx7bmFtZTpcImlucHV0X2NoYW5uZWxzX3Blcl9ncm91cFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJvdXRwdXRfY2hhbm5lbHNfcGVyX2dyb3VwXCIsdHlwZTpcInUzMlwifV0sUj1fZShlWzBdLmRhdGFUeXBlKSxHPWk/MToyLEs9aT8yOjMsaj1pPzM6MSxWPUUoXCJXXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMubGVuZ3RoLGgpLFE9RShcIkR5XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMubGVuZ3RoLG0pLHNlPVtRLFZdO24mJnNlLnB1c2goRShcImJpYXNcIixlWzJdLmRhdGFUeXBlLFtvW2pdXS5sZW5ndGgsdSkpO2xldCBZPU0oXCJyZXN1bHRcIixlWzBdLmRhdGFUeXBlLG8ubGVuZ3RoLHUpLGVlPSgpPT57bGV0IG5lPVwiXCI7aWYobT09PTEpbmUrPWBcbiAgICAgICAgbGV0IHdfb2Zmc2V0ID0gJHtWLmluZGljZXNUb09mZnNldChgJHtWLnR5cGUuaW5kaWNlc30odTMyKHdSUGVybSksIHUzMih3Q1Blcm0pLCBpbnB1dENoYW5uZWwsIHdPdXRDaGFubmVsKWApfTtcbiAgICAgICAgbGV0IHdWYWx1ZSA9ICR7Vi5nZXRCeU9mZnNldChgd19vZmZzZXQgLyAke2h9YCl9O1xuICAgICAgICBkb3RQcm9kID0gZG90UHJvZCArIHhWYWx1ZSAqIHdWYWx1ZTtgO2Vsc2UgaWYocD09PTEpbmUrPWBcbiAgICAgICAgICBsZXQgd1ZhbHVlID0gJHtWLmdldEJ5T2Zmc2V0KGAke1YuaW5kaWNlc1RvT2Zmc2V0KGAke1YudHlwZS5pbmRpY2VzfSh1MzIod1JQZXJtKSwgdTMyKHdDUGVybSksIGlucHV0Q2hhbm5lbCwgd091dENoYW5uZWwpYCl9IC8gJHtofWApfTtcbiAgICAgICAgICBkb3RQcm9kID0gZG90UHJvZCArIGRvdCh4VmFsdWUsIHdWYWx1ZSk7YDtlbHNlIGZvcihsZXQgYmU9MDtiZTxtO2JlKyspbmUrPWBcbiAgICAgICAgICAgIGxldCB3VmFsdWUke2JlfSA9ICR7Vi5nZXRCeU9mZnNldChgJHtWLmluZGljZXNUb09mZnNldChgJHtWLnR5cGUuaW5kaWNlc30odTMyKHdSUGVybSksIHUzMih3Q1Blcm0pLCBpbnB1dENoYW5uZWwgKyAke2JlfSwgd091dENoYW5uZWwpYCl9IC8gJHtofWApfTtcbiAgICAgICAgICAgIGRvdFByb2QgPSBkb3RQcm9kICsgeFZhbHVlWyR7YmV9XSAqIHdWYWx1ZSR7YmV9O2A7cmV0dXJuIG5lfSxKPWBcbiAgICAgICAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtZLm9mZnNldFRvSW5kaWNlcyhgZ2xvYmFsX2lkeCAqICR7dX1gKX07XG4gICAgICAgICAgICBsZXQgYmF0Y2ggPSAke1kuaW5kaWNlc0dldChcIm91dHB1dEluZGljZXNcIiwwKX07XG4gICAgICAgICAgICBsZXQgZDEgPSAke1kuaW5kaWNlc0dldChcIm91dHB1dEluZGljZXNcIixqKX07XG4gICAgICAgICAgICBsZXQgciA9ICR7WS5pbmRpY2VzR2V0KFwib3V0cHV0SW5kaWNlc1wiLEcpfTtcbiAgICAgICAgICAgIGxldCBjID0gJHtZLmluZGljZXNHZXQoXCJvdXRwdXRJbmRpY2VzXCIsSyl9O1xuICAgICAgICAgICAgbGV0IGR5Q29ybmVyID0gdmVjMjxpMzI+KGkzMihyKSwgaTMyKGMpKSAtIHVuaWZvcm1zLnBhZHM7XG4gICAgICAgICAgICBsZXQgZHlSQ29ybmVyID0gZHlDb3JuZXIueDtcbiAgICAgICAgICAgIGxldCBkeUNDb3JuZXIgPSBkeUNvcm5lci55O1xuICAgICAgICAgICAgbGV0IGdyb3VwSWQgPSBkMSAvIHVuaWZvcm1zLm91dHB1dF9jaGFubmVsc19wZXJfZ3JvdXA7XG4gICAgICAgICAgICBsZXQgd091dENoYW5uZWwgPSBkMSAtIGdyb3VwSWQgKiB1bmlmb3Jtcy5vdXRwdXRfY2hhbm5lbHNfcGVyX2dyb3VwO1xuICAgICAgICAgICAgLy8gQ29udm9sdmUgZHkoPywgPywgZDIpIHdpdGggdyg6LCA6LCBkMSwgZDIpIHRvIGNvbXB1dGUgZHgoeFIsIHhDLCBkMSkuXG4gICAgICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cbiAgICAgICAgICAgIHZhciBkb3RQcm9kID0gJHtZLnR5cGUudmFsdWV9KDAuMCk7XG4gICAgICAgICAgICBmb3IgKHZhciB3UjogdTMyID0gMDsgd1IgPCB1bmlmb3Jtcy5lZmZlY3RpdmVfZmlsdGVyX2RpbXMueDsgd1IgPSB3UiArIDEpIHtcbiAgICAgICAgICAgICAgaWYgKHdSICUgdW5pZm9ybXMuZGlsYXRpb25zLnggIT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldCBkeVIgPSAoJHtSfShkeVJDb3JuZXIpICsgJHtSfSh3UikpIC8gJHtSfSh1bmlmb3Jtcy5zdHJpZGVzWzBdKTtcbiAgICAgICAgICAgICAgbGV0IHdSUGVybSA9IHVuaWZvcm1zLmZpbHRlcl9kaW1zLnggLSAxIC0gd1IgLyB1bmlmb3Jtcy5kaWxhdGlvbnMueDtcbiAgICAgICAgICAgICAgaWYgKGR5UiA8IDAuMCB8fCBkeVIgPj0gJHtSfSh1bmlmb3Jtcy5EeV9zaGFwZVske0d9XSkgfHwgZnJhY3QoZHlSKSA+IDAuMCB8fFxuICAgICAgICAgICAgICAgICAgd1JQZXJtIDwgMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdSID0gd1IgKyB1bmlmb3Jtcy5zdHJpZGVzWzBdIC0gMTtcbiAgICAgICAgICAgICAgbGV0IGlkeVI6IHUzMiA9IHUzMihkeVIpO1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIHdDOiB1MzIgPSAwOyB3QyA8IHVuaWZvcm1zLmVmZmVjdGl2ZV9maWx0ZXJfZGltcy55OyB3QyA9IHdDICsgMSkge1xuICAgICAgICAgICAgICAgIGlmICh3QyAlIHVuaWZvcm1zLmRpbGF0aW9ucy55ICE9IDApIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgZHlDID0gKCR7Un0oZHlDQ29ybmVyKSArICR7Un0od0MpKSAvICR7Un0odW5pZm9ybXMuc3RyaWRlcy55KTtcbiAgICAgICAgICAgICAgICBsZXQgd0NQZXJtID0gdW5pZm9ybXMuZmlsdGVyX2RpbXMueSAtIDEgLSB3QyAvIHVuaWZvcm1zLmRpbGF0aW9ucy55O1xuICAgICAgICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49ICR7Un0odW5pZm9ybXMuRHlfc2hhcGVbJHtLfV0pIHx8XG4gICAgICAgICAgICAgICAgICAgIGZyYWN0KGR5QykgPiAwLjAgfHwgd0NQZXJtIDwgMCkge1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdDID0gd0MgKyB1bmlmb3Jtcy5zdHJpZGVzLnkgLSAxO1xuICAgICAgICAgICAgICAgIGxldCBpZHlDOiB1MzIgPSB1MzIoZHlDKTtcbiAgICAgICAgICAgICAgICB2YXIgaW5wdXRDaGFubmVsID0gZ3JvdXBJZCAqIHVuaWZvcm1zLmlucHV0X2NoYW5uZWxzX3Blcl9ncm91cDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBkMjogdTMyID0gMDsgZDIgPCB1bmlmb3Jtcy5pbnB1dF9jaGFubmVsc19wZXJfZ3JvdXA7IGQyID0gZDIgKyAke219KSB7XG4gICAgICAgICAgICAgICAgICBsZXQgeFZhbHVlID0gJHtpP1EuZ2V0QnlPZmZzZXQoYCR7US5pbmRpY2VzVG9PZmZzZXQoYCR7US50eXBlLmluZGljZXN9KGJhdGNoLCBpZHlSLCBpZHlDLCBpbnB1dENoYW5uZWwpYCl9IC8gJHttfWApOlEuZ2V0KFwiYmF0Y2hcIixcImlucHV0Q2hhbm5lbFwiLFwiaWR5UlwiLFwiaWR5Q1wiKX07XG4gICAgICAgICAgICAgICAgICAke2VlKCl9XG4gICAgICAgICAgICAgICAgICBpbnB1dENoYW5uZWwgPSBpbnB1dENoYW5uZWwgKyAke219O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHZhbHVlID0gZG90UHJvZCR7bj9gICsgYmlhc1tkMSAvICR7dX1dYDpcIlwifTtcbiAgICAgICAgICAgICR7WS5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlXCIpfTtcbiAgICAgICAgICBgO3JldHVybmBcbiAgICAke1AucmVnaXN0ZXJVbmlmb3JtcyhEKS5kZWNsYXJlVmFyaWFibGVzKC4uLnNlLFkpfVxuICAgICAgJHtQLm1haW5TdGFydCgpfVxuICAgICAgJHtQLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX07XG4gICAgJHtKfX1gfTtyZXR1cm57bmFtZTpcIkNvbnZUcmFuc3Bvc2UyRFwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9OyR7bX0ke2h9JHt1fSR7cD09PTF9YCxpbnB1dERlcGVuZGVuY2llczpnfSxnZXRSdW5EYXRhOigpPT4oe2Rpc3BhdGNoR3JvdXA6e3g6eVswXSx5OnlbMV0sejp5WzJdfSxvdXRwdXRzOlt7ZGltczpyP3Iobyk6byxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0scHJvZ3JhbVVuaWZvcm1zOkF9KSxnZXRTaGFkZXJTb3VyY2U6a319fSk7dmFyIGJmLHlmLF9mLGVkLHRkLHdmLHJkLHZmLG5kLG9kPVUoKCk9PntcInVzZSBzdHJpY3RcIjtKdSgpO3l0KCk7ZHQoKTtiZj0oZSx0LHIsbixvLGkpPT4oZS0xKSp0K3IrKG4tMSkqbysxLWkseWY9KGUsdCxyLG4sbyk9PntsZXQgaT1NYXRoLmZsb29yKGUvMik7dD09PVwiU0FNRV9VUFBFUlwiPyhyW25dPWkscltvXT1lLWkpOnQ9PT1cIlNBTUVfTE9XRVJcIiYmKHJbbl09ZS1pLHJbb109aSl9LF9mPShlLHQscixuLG8saSxhLGQsbCxwKT0+e2xldCBtPWUubGVuZ3RoLTIsdT1wLmxlbmd0aD09PTA7bC5sZW5ndGg8bSYmbC5wdXNoKC4uLkFycmF5KG0tbC5sZW5ndGgpLmZpbGwoMCkpO2xldCBoPWVbMF0sXz10W2Q/MzoxXSpvO2ZvcihsZXQgeT0wLGc9ZS5sZW5ndGgtbS0oZD8xOjApO3k8bTsrK3ksKytnKXtsZXQgeD1lW2ddLCQ9dT94KmFbeV06cFt5XSx2PWJmKHgsYVt5XSxpW3ldLHRbZ10sclt5XSwkKTt5Zih2LG4saSx5LHkrbSksdSYmcC5wdXNoKGFbeV0qKHgtMSkrbFt5XSsodFtnXS0xKSpyW3ldKzEtaVt5XS1pW3krbV0pfXAuc3BsaWNlKDAsMCxoKSxwLnNwbGljZShkPzM6MSwwLF8pfSxlZD0oZSx0KT0+e2xldCByPWUua2VybmVsU2hhcGUuc2xpY2UoKTtpZihlLmtlcm5lbFNoYXBlLmxlbmd0aD09PTB8fGUua2VybmVsU2hhcGUucmVkdWNlKCh1LGgpPT51KmgsMSk9PT0wKXtyLmxlbmd0aD0wO2ZvcihsZXQgdT0yO3U8dFsxXS5kaW1zLmxlbmd0aDsrK3Upci5wdXNoKHRbMV0uZGltc1t1XSl9bGV0IG49ZS5mb3JtYXQ9PT1cIk5IV0NcIjtyLnNwbGljZSgwLDAsdFsxXS5kaW1zWzBdKSxyLnNwbGljZShuPzM6MSwwLHRbMV0uZGltc1sxXSk7bGV0IG89ZS5wYWRzLnNsaWNlKCksaT1lLm91dHB1dFNoYXBlLnNsaWNlKCksYT1lLm91dHB1dFBhZGRpbmcuc2xpY2UoKSxkPXRbMF0uZGltcyxsPWUuZGlsYXRpb25zLnNsaWNlKCk7aWYobC5yZWR1Y2UoKHUsaCk9PnUraCwwKT09PTApe2xldCB1PXRbMF0uZGltcy5sZW5ndGgtMjtsPW5ldyBBcnJheSh1KS5maWxsKDEpfWxldCBwPWUuc3RyaWRlcy5zbGljZSgpO2lmKHAucmVkdWNlKCh1LGgpPT51K2gsMCk9PT0wKXtsZXQgdT10WzBdLmRpbXMubGVuZ3RoLTI7cD1uZXcgQXJyYXkodSkuZmlsbCgxKX1fZihkLHIsbCxlLmF1dG9QYWQsZS5ncm91cCxvLHAsbixhLGkpO2xldCBtPU9iamVjdC5hc3NpZ24oe30sZSk7cmV0dXJuIE9iamVjdC5hc3NpZ24obSx7a2VybmVsU2hhcGU6cixwYWRzOm8sb3V0cHV0UGFkZGluZzphLG91dHB1dFNoYXBlOmksZGlsYXRpb25zOmwsc3RyaWRlczpwfSksbX0sdGQ9ZT0+e2xldCB0PWpyKGUpLHI9ZS5mb3JtYXQsbj1bXCJOT1RTRVRcIixcIlZBTElEXCIsXCJTQU1FX1VQUEVSXCIsXCJTQU1FX0xPV0VSXCJdW3R5cGVvZiBlLmF1dG9QYWQ+XCJ1XCI/MDplLmF1dG9QYWRdLG89ZS5kaWxhdGlvbnMsaT1lLmdyb3VwLGE9ZS5rZXJuZWxTaGFwZSxkPWUucGFkcyxsPWUuc3RyaWRlcyxwPWUud0lzQ29uc3QoKSxtPWUub3V0cHV0UGFkZGluZyx1PWUub3V0cHV0U2hhcGU7cmV0dXJue2F1dG9QYWQ6bixmb3JtYXQ6cixkaWxhdGlvbnM6byxncm91cDppLGtlcm5lbFNoYXBlOmEsb3V0cHV0UGFkZGluZzptLG91dHB1dFNoYXBlOnUscGFkczpkLHN0cmlkZXM6bCx3SXNDb25zdDpwLC4uLnQsY2FjaGVLZXk6YCR7ZS5mb3JtYXR9OyR7dC5hY3RpdmF0aW9ufTtgfX0sd2Y9KGUsdCk9PntpZighZXx8ZS5sZW5ndGghPT0yJiZlLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKFwiQ29udiByZXF1aXJlcyAyIG9yIDMgaW5wdXRzXCIpO2lmKGVbMF0uZGltcy5sZW5ndGghPT00JiZlWzBdLmRpbXMubGVuZ3RoIT09Myl0aHJvdyBuZXcgRXJyb3IoXCJjdXJyZW50bHkgb25seSBzdXBwb3J0IDItZGltZW5zaW9uYWwgY29udlwiKTtpZihlWzBdLmRpbXMubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJmaWx0ZXIgZG9lcyBub3QgaGF2ZSBzYW1lIGRpbWVuc2lvbiBhcyBpbnB1dFwiKTtsZXQgcj1lWzBdLmRpbXNbdC5mb3JtYXQ9PT1cIk5IV0NcIj9lWzBdLmRpbXMubGVuZ3RoLTE6MV0sbj1lWzFdLmRpbXNbMF07aWYociE9PW4pdGhyb3cgbmV3IEVycm9yKFwiRklMVEVSX0lOX0NIQU5ORUwgc2hvdWxkIGJlIGVxdWFsIHRvIERBVEFfQ0hBTk5FTFwiKTtsZXQgbz1lWzFdLmRpbXNbMV0qdC5ncm91cDtpZihlLmxlbmd0aD09PTMmJihlWzJdLmRpbXMubGVuZ3RoIT09MXx8ZVsyXS5kaW1zWzBdIT09bykpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBiaWFzXCIpO2xldCBpPWVbMF0uZGltcy5sZW5ndGgtMjtpZih0LmRpbGF0aW9ucy5yZWR1Y2UoKG0sdSk9Pm0rdSwwKT4wJiZ0LmRpbGF0aW9ucy5sZW5ndGghPT1pKXRocm93IG5ldyBFcnJvcihgZGlsYXRpb25zIHNob3VsZCBiZSAke2l9RGApO2lmKHQuc3RyaWRlcy5yZWR1Y2UoKG0sdSk9Pm0rdSwwKT4wJiZ0LnN0cmlkZXMubGVuZ3RoIT09aSl0aHJvdyBuZXcgRXJyb3IoYHN0cmlkZXMgc2hvdWxkIGJlICR7aX1EYCk7aWYodC5wYWRzLnJlZHVjZSgobSx1KT0+bSt1LDApPjAmJnQucGFkcy5sZW5ndGghPT1pKjIpdGhyb3cgbmV3IEVycm9yKGBwYWRzIHNob3VsZCBiZSAke2kqMn1EYCk7aWYodC5vdXRwdXRQYWRkaW5nLmxlbmd0aCE9PWkmJnQub3V0cHV0UGFkZGluZy5sZW5ndGghPT0wKXRocm93IG5ldyBFcnJvcihgb3V0cHV0X3BhZGRpbmcgc2hvdWxkIGJlICR7aX1EYCk7aWYodC5rZXJuZWxTaGFwZS5yZWR1Y2UoKG0sdSk9Pm0rdSwwKT4wJiZ0Lmtlcm5lbFNoYXBlLmxlbmd0aCE9PTAmJnQua2VybmVsU2hhcGUubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aC0yKXRocm93IG5ldyBFcnJvcihcImludmFsaWQga2VybmVsIHNoYXBlXCIpO2lmKHQub3V0cHV0U2hhcGUubGVuZ3RoIT09MCYmdC5vdXRwdXRTaGFwZS5sZW5ndGghPT1lWzBdLmRpbXMubGVuZ3RoLTIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBvdXRwdXQgc2hhcGVcIil9LHJkPShlLHQscixuKT0+e2xldCBvPWUua2VybmVsQ3VzdG9tRGF0YS53VD8/ZS5jb21wdXRlKFBlKHRbMV0sWzIsMywwLDFdKSx7aW5wdXRzOlsxXSxvdXRwdXRzOltyLndJc0NvbnN0Py0yOi0xXX0pWzBdO3Iud0lzQ29uc3QmJiFlLmtlcm5lbEN1c3RvbURhdGEud1QmJihlLmtlcm5lbEN1c3RvbURhdGEud1Q9byk7bGV0IGk9W3RbMF0sb107dC5sZW5ndGg9PT0zJiZpLnB1c2godFsyXSksZS5jb21wdXRlKFh1KGkscixuKSx7aW5wdXRzOml9KX0sdmY9KGUsdCk9PntsZXQgcj10LmZvcm1hdD09PVwiTkhXQ1wiLG49W2UuaW5wdXRzWzBdLnJlc2hhcGUocj9bZS5pbnB1dHNbMF0uZGltc1swXSwxLGUuaW5wdXRzWzBdLmRpbXNbMV0sZS5pbnB1dHNbMF0uZGltc1syXV06W2UuaW5wdXRzWzBdLmRpbXNbMF0sZS5pbnB1dHNbMF0uZGltc1sxXSwxLGUuaW5wdXRzWzBdLmRpbXNbMl1dKSxlLmlucHV0c1sxXS5yZXNoYXBlKFtlLmlucHV0c1sxXS5kaW1zWzBdLGUuaW5wdXRzWzFdLmRpbXNbMV0sMSxlLmlucHV0c1sxXS5kaW1zWzJdXSldO2UuaW5wdXRzLmxlbmd0aD09PTMmJm4ucHVzaChlLmlucHV0c1syXSk7bGV0IG89dC5rZXJuZWxTaGFwZTsoby5sZW5ndGg9PT0wfHxvWzBdPT09MCkmJihvPVtlLmlucHV0c1sxXS5kaW1zWzJdXSk7bGV0IGk9dC5kaWxhdGlvbnM7KGkubGVuZ3RoPT09MHx8aVswXT09PTApJiYoaT1bMV0pO2xldCBhPXQuc3RyaWRlczsoYS5sZW5ndGg9PT0wfHxhWzBdPT09MCkmJihhPVsxXSk7bGV0IGQ9dC5wYWRzO2QubGVuZ3RoPT09MCYmKGQ9WzAsMF0pLGQ9WzAsZFswXSwwLGRbMV1dLGE9WzFdLmNvbmNhdChhKSxpPVsxXS5jb25jYXQoaSksbz1bMV0uY29uY2F0KG8pO2xldCBsPWVkKHsuLi50LHBhZHM6ZCxzdHJpZGVzOmEsZGlsYXRpb25zOmksa2VybmVsU2hhcGU6b30sbik7cmQoZSxuLGwscD0+cj9bcFswXSxwWzJdLHBbM11dOltwWzBdLHBbMV0scFszXV0pfSxuZD0oZSx0KT0+e2lmKHdmKGUuaW5wdXRzLHQpLGUuaW5wdXRzWzBdLmRpbXMubGVuZ3RoPT09Myl2ZihlLHQpO2Vsc2V7bGV0IHI9ZWQodCxlLmlucHV0cyk7cmQoZSxlLmlucHV0cyxyKX19fSk7dmFyICRmLGlkLGFkLHNkPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7U2UoKTthZSgpOyRmPShlLHQscixuKT0+e2xldCBvPUMuc2l6ZSh0KSxpPXQubGVuZ3RoLGE9RShcImlucHV0XCIsZSxpKSxkPU0oXCJvdXRwdXRcIixlLGkpLGw9ci5kYXRhVHlwZT09PTY/ci5nZXRJbnQzMkFycmF5KClbMF06TnVtYmVyKHIuZ2V0QmlnSW50NjRBcnJheSgpWzBdKSxwPUMubm9ybWFsaXplQXhpcyhsLGkpLG09dT0+e2xldCBoPWAgaTMyKCR7YS5pbmRpY2VzR2V0KFwiaW5wdXRJbmRpY2VzXCIsXCJ1bmlmb3Jtcy5heGlzXCIpfSkgYCxfPUYoXCJ1bmlmb3Jtcy5pbnB1dF9zaGFwZVwiLFwidW5pZm9ybXMuYXhpc1wiLGkpLHk9bi5yZXZlcnNlP2grKG4uZXhjbHVzaXZlP1wiICsgMVwiOlwiXCIpOlwiMFwiLGc9bi5yZXZlcnNlP186aCsobi5leGNsdXNpdmU/XCJcIjpcIiArIDFcIik7cmV0dXJuYFxuICAgICAgICAgICAgICAgICR7dS5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRTaXplXCIsXCJ1MzJcIikucmVnaXN0ZXJVbmlmb3JtKFwiYXhpc1wiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoYSxkKX1cbiAgICAgICAgICAgICAgICAke3UubWFpblN0YXJ0KCl9XG4gICAgICAgICAgICAgICAgICAke3UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG4gICAgICAgICAgICAgICAgICB2YXIgaW5wdXRJbmRpY2VzID0gJHtkLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgICAgICAgICAgICAgdmFyIHN1bSA9ICR7ZC50eXBlLnZhbHVlfSgwKTtcbiAgICAgICAgICAgICAgICAgIGxldCBmaXJzdCA6IGkzMiA9ICR7eX07XG4gICAgICAgICAgICAgICAgICBsZXQgbGFzdCA6IGkzMiA9ICR7Z307XG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBpIDogaTMyID0gZmlyc3Q7IGkgPCBsYXN0OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgJHthLmluZGljZXNTZXQoXCJpbnB1dEluZGljZXNcIixcInVuaWZvcm1zLmF4aXNcIixcInUzMihpKVwiKX07XG4gICAgICAgICAgICAgICAgICAgIHN1bSA9IHN1bSArICR7YS5nZXRCeUluZGljZXMoXCJpbnB1dEluZGljZXNcIil9O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgJHtkLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwic3VtXCIpfTtcbiAgICAgICAgICAgICAgICB9YH07cmV0dXJue25hbWU6XCJDdW1TdW1cIixzaGFkZXJDYWNoZTp7aGludDpuLmNhY2hlS2V5LGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6dCxkYXRhVHlwZTplfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoby82NCl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTpvfSx7dHlwZToxMixkYXRhOnB9LC4uLk4odCx0KV19KSxnZXRTaGFkZXJTb3VyY2U6bX19LGlkPShlLHQpPT57bGV0IHI9ZS5pbnB1dHNbMF0uZGltcyxuPWUuaW5wdXRzWzBdLmRhdGFUeXBlLG89ZS5pbnB1dHNbMV07ZS5jb21wdXRlKCRmKG4scixvLHQpLHtpbnB1dHM6WzBdfSl9LGFkPWU9PntsZXQgdD1lLmV4Y2x1c2l2ZT09PTEscj1lLnJldmVyc2U9PT0xO3JldHVybiByZSh7ZXhjbHVzaXZlOnQscmV2ZXJzZTpyfSl9fSk7dmFyIHhmLFNmLFRmLHVkLGRkLGxkPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7U2UoKTthZSgpO3hmPWU9PntpZighZXx8ZS5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIkRlcHRoVG9TcGFjZSByZXF1aXJlcyAxIGlucHV0LlwiKTtpZihlWzBdLmRpbXMubGVuZ3RoIT09NCl0aHJvdyBuZXcgRXJyb3IoXCJEZXB0aFRvU3BhY2UgcmVxdWlyZXMgNEQgaW5wdXQuXCIpfSxTZj0oZSx0LHIsbik9PntsZXQgbz1bXTtvLnB1c2goYGZuIHBlcm0oaTogJHtuLnR5cGUuaW5kaWNlc30pIC0+ICR7ci50eXBlLmluZGljZXN9IHtcbiAgICB2YXIgYTogJHtyLnR5cGUuaW5kaWNlc307YCk7Zm9yKGxldCBpPTA7aTx0OysraSlvLnB1c2goci5pbmRpY2VzU2V0KFwiYVwiLGVbaV0sYGlbJHtpfV1gKSk7cmV0dXJuIG8ucHVzaChcInJldHVybiBhO31cIiksby5qb2luKGBcbmApfSxUZj0oZSx0KT0+e2xldCByLG4sbyxpLGEsZCxsPXQuZm9ybWF0PT09XCJOSFdDXCIscD10LmJsb2Nrc2l6ZSxtPXQubW9kZT09PVwiRENSXCI7bD8oW3IsbixvLGldPWUuZGltcyxhPW0/W3IsbixvLHAscCxpL3AqKjJdOltyLG4sbyxpL3AqKjIscCxwXSxkPW0/WzAsMSwzLDIsNCw1XTpbMCwxLDQsMiw1LDNdKTooW3IsbixvLGldPVtlLmRpbXNbMF0sZS5kaW1zWzJdLGUuZGltc1szXSxlLmRpbXNbMV1dLGE9bT9bcixwLHAsaS9wKioyLG4sb106W3IsaS9wKioyLHAscCxuLG9dLGQ9bT9bMCwzLDQsMSw1LDJdOlswLDEsNCwyLDUsM10pO2xldCB1PWUucmVzaGFwZShhKSxoPXUuZGltcy5sZW5ndGgsXz1lLmRhdGFUeXBlLHk9RShcImFcIixfLGgpLGc9TShcIm91dHB1dFwiLF8saCkseD0kPT5gXG4gICR7JC5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoeSxnKX1cblxuICAke1NmKGQsaCx5LGcpfVxuXG4gICR7JC5tYWluU3RhcnQoKX1cbiAgICAkeyQuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuXG4gICAgbGV0IGluZGljZXMgPSAke2cub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgbGV0IGFJbmRpY2VzID0gcGVybShpbmRpY2VzKTtcblxuICAgICR7Zy5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIix5LmdldEJ5SW5kaWNlcyhcImFJbmRpY2VzXCIpKX1cbiAgfWA7cmV0dXJue25hbWU6XCJEZXB0aFRvU3BhY2VcIixzaGFkZXJDYWNoZTp7aGludDpgJHtlLmRpbXN9OyR7dC5ibG9ja3NpemV9OyR7dC5tb2RlfWAsaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiXX0sZ2V0UnVuRGF0YTokPT57bGV0IHY9bD9bcixuKnAsbypwLGkvcCoqMl06W3IsaS9wKioyLG4qcCxvKnBdLFM9Qy5zaXplKHYpLFQ9dS5kaW1zLEE9Qy5zb3J0QmFzZWRPblBlcm0oVCxkKTtyZXR1cm57b3V0cHV0czpbe2RpbXM6dixkYXRhVHlwZTokWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoUy82NCl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTpTfSwuLi5OKFQsQSldfX0sZ2V0U2hhZGVyU291cmNlOnh9fSx1ZD0oZSx0KT0+e3hmKGUuaW5wdXRzKSxlLmNvbXB1dGUoVGYoZS5pbnB1dHNbMF0sdCkpfSxkZD1lPT5yZSh7YmxvY2tzaXplOmUuYmxvY2tzaXplLG1vZGU6ZS5tb2RlLGZvcm1hdDplLmZvcm1hdH0pfSk7dmFyIHZvLGVuLGNkLElmLENmLCRvLHhvLHBkLEFmLG1kLGZkLGhkPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7U2UoKTthZSgpO3ZvPVwiW2EtekEtWl18XFxcXC5cXFxcLlxcXFwuXCIsZW49XCIoXCIrdm8rXCIpK1wiLGNkPVwiXlwiK2VuK1wiJFwiLElmPVwiKFwiK2VuK1wiLCkqXCIrZW4sQ2Y9XCJeXCIrSWYrXCIkXCIsJG89Y2xhc3N7Y29uc3RydWN0b3IodD0tMSl7dGhpcy5zeW1ib2xUb0luZGljZXM9bmV3IE1hcCx0aGlzLmlucHV0SW5kZXg9dH1hZGRTeW1ib2wodCxyKXtsZXQgbj10aGlzLnN5bWJvbFRvSW5kaWNlcy5nZXQodCk7bj09PXZvaWQgMD9uPVtyXTpuLnB1c2gociksdGhpcy5zeW1ib2xUb0luZGljZXMuc2V0KHQsbil9fSx4bz1jbGFzc3tjb25zdHJ1Y3Rvcih0LHIpe3RoaXMuZXF1YXRpb249cjt0aGlzLmhhc0VsbGlwc2lzPSExLHRoaXMuc3ltYm9sVG9JbmZvPW5ldyBNYXAsdGhpcy5saHM9bmV3IEFycmF5LHRoaXMub3V0cHV0RGltcz1bXTtsZXRbbixvXT1yLmluY2x1ZGVzKFwiLT5cIik/ci5zcGxpdChcIi0+XCIsMik6W3IsXCJcIl07aWYoIW4ubWF0Y2goUmVnRXhwKENmKSkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBMSFMgdGVybVwiKTtpZihuLnNwbGl0KFwiLFwiKS5mb3JFYWNoKChkLGwpPT57bGV0IHA9dFtsXS5kaW1zLnNsaWNlKCk7aWYoIWQubWF0Y2goUmVnRXhwKGNkKSkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBMSFMgdGVybVwiKTtsZXQgbT10aGlzLnByb2Nlc3NUZXJtKGQsITAscCxsKTt0aGlzLmxocy5wdXNoKG0pfSksbz09PVwiXCIpbys9Wy4uLnRoaXMuc3ltYm9sVG9JbmZvLmVudHJpZXMoKV0uZmlsdGVyKChbZCxsXSk9PmwuY291bnQ9PT0xfHxkPT09XCIuLi5cIikubWFwKChbZF0pPT5kKS5qb2luKFwiXCIpO2Vsc2UgaWYoIW8ubWF0Y2goUmVnRXhwKGVuKSkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBSSFNcIik7by5tYXRjaChSZWdFeHAodm8sXCJnXCIpKT8uZm9yRWFjaChkPT57aWYoZD09PVwiLi4uXCIpdGhpcy5vdXRwdXREaW1zPXRoaXMub3V0cHV0RGltcy5jb25jYXQodGhpcy5lbGxpcHNpc0RpbXMpO2Vsc2V7bGV0IGw9dGhpcy5zeW1ib2xUb0luZm8uZ2V0KGQpO2lmKGw9PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBSSFMgc3ltYm9sXCIpO3RoaXMub3V0cHV0RGltcy5wdXNoKGwuZGltVmFsdWUpfX0pLHRoaXMucmhzPXRoaXMucHJvY2Vzc1Rlcm0obywhMSx0aGlzLm91dHB1dERpbXMpfWFkZFN5bWJvbCh0LHIsbil7bGV0IG89dGhpcy5zeW1ib2xUb0luZm8uZ2V0KHQpO2lmKG8hPT12b2lkIDApe2lmKG8uZGltVmFsdWUhPT1yJiZvLmNvdW50IT09MSl0aHJvdyBuZXcgRXJyb3IoXCJEaW1lbnNpb24gbWlzbWF0Y2hcIik7by5jb3VudCsrLG8uaW5wdXRJbmRpY2VzLnB1c2gobil9ZWxzZSBvPXtjb3VudDoxLGRpbVZhbHVlOnIsaW5wdXRJbmRpY2VzOltuXX07dGhpcy5zeW1ib2xUb0luZm8uc2V0KHQsbyl9cHJvY2Vzc1Rlcm0odCxyLG4sbz0tMSl7bGV0IGk9bi5sZW5ndGgsYT0hMSxkPVtdLGw9MDtpZighdC5tYXRjaChSZWdFeHAoY2QpKSYmIXImJnQhPT1cIlwiKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgTEhTIHRlcm1cIik7bGV0IHA9dC5tYXRjaChSZWdFeHAodm8sXCJnXCIpKSxtPW5ldyAkbyhvKTtyZXR1cm4gcD8uZm9yRWFjaCgodSxoKT0+e2lmKHU9PT1cIi4uLlwiKXtpZihhKXRocm93IG5ldyBFcnJvcihcIk9ubHkgb25lIGVsbGlwc2lzIGlzIGFsbG93ZWQgcGVyIGlucHV0IHRlcm1cIik7YT0hMDtsZXQgXz1pLXAubGVuZ3RoKzE7aWYoXzwwKXRocm93IG5ldyBFcnJvcihcIkVsbGlwc2lzIG91dCBvZiBib3VuZHNcIik7aWYoZD1uLnNsaWNlKGwsbCtfKSx0aGlzLmhhc0VsbGlwc2lzKXtpZih0aGlzLmVsbGlwc2lzRGltcy5sZW5ndGghPT1kLmxlbmd0aHx8dGhpcy5lbGxpcHNpc0RpbXMudG9TdHJpbmcoKSE9PWQudG9TdHJpbmcoKSl0aHJvdyBuZXcgRXJyb3IoXCJFbGxpcHNpcyBkaW1lbnNpb25zIG1pc21hdGNoXCIpfWVsc2UgaWYocil0aGlzLmhhc0VsbGlwc2lzPSEwLHRoaXMuZWxsaXBzaXNEaW1zPWQ7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJFbGxpcHNpcyBtdXN0IGJlIHNwZWNpZmllZCBpbiB0aGUgTEhTXCIpO2ZvcihsZXQgeT0wO3k8ZC5sZW5ndGg7eSsrKXtsZXQgZz1TdHJpbmcuZnJvbUNoYXJDb2RlKFwiMFwiLmNoYXJDb2RlQXQoMCkreSk7bS5hZGRTeW1ib2woZyxoK3kpLHRoaXMuYWRkU3ltYm9sKGcsbltsKytdLG8pfX1lbHNlIG0uYWRkU3ltYm9sKHUsaCsodGhpcy5oYXNFbGxpcHNpcz90aGlzLmVsbGlwc2lzRGltcy5sZW5ndGgtMTowKSksdGhpcy5hZGRTeW1ib2wodSxuW2wrK10sbyl9KSxtfX0scGQ9ZT0+ZStcIl9tYXhcIixBZj0oZSx0LHIsbik9PntsZXQgaT1lLm1hcChtPT5tLmxlbmd0aCkubWFwKChtLHUpPT5FKGBpbnB1dCR7dX1gLHQsbSkpLGE9Qy5zaXplKG4pLGQ9TShcIm91dHB1dFwiLHQsbi5sZW5ndGgpLGw9Wy4uLnIuc3ltYm9sVG9JbmZvLmtleXMoKV0uZmlsdGVyKG09PiFyLnJocy5zeW1ib2xUb0luZGljZXMuaGFzKG0pKSxwPW09PntsZXQgdT1bXSxoPVwidmFyIHByb2QgPSAxLjA7XCIsXz1cInZhciBzdW0gPSAwLjA7XCIseT1cInN1bSArPSBwcm9kO1wiLGc9W10seD1bXSwkPVtdLHY9W10sUz1yLnN5bWJvbFRvSW5mby5zaXplPT09ci5yaHMuc3ltYm9sVG9JbmRpY2VzLnNpemU7ci5zeW1ib2xUb0luZm8uZm9yRWFjaCgoQSxrKT0+e2lmKHIucmhzLnN5bWJvbFRvSW5kaWNlcy5oYXMoaykpe2xldCBQPXIucmhzLnN5bWJvbFRvSW5kaWNlcy5nZXQoayk/LlswXTtQIT09dm9pZCAwJiZyLmxocy5mb3JFYWNoKChELFIpPT57aWYoQS5pbnB1dEluZGljZXMuaW5jbHVkZXMoUikpe2xldCBHPUQuc3ltYm9sVG9JbmRpY2VzLmdldChrKTtpZihHPT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3ltYm9sIGVycm9yXCIpO0cuZm9yRWFjaChLPT57dS5wdXNoKGAke2lbUl0uaW5kaWNlc1NldChgaW5wdXQke1J9SW5kaWNlc2AsSyxkLmluZGljZXNHZXQoXCJvdXRwdXRJbmRpY2VzXCIsUCkpfWApfSl9fSl9ZWxzZSByLmxocy5mb3JFYWNoKChQLEQpPT57aWYoQS5pbnB1dEluZGljZXMuaW5jbHVkZXMoRCkpe2xldCBSPVAuc3ltYm9sVG9JbmRpY2VzLmdldChrKTtpZihSPT09dm9pZCAwKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3ltYm9sIGVycm9yXCIpO1IuZm9yRWFjaChHPT57Zy5wdXNoKGAke2lbRF0uaW5kaWNlc1NldChgaW5wdXQke0R9SW5kaWNlc2AsRyxgJHtrfWApfWApfSksdi5wdXNoKGBwcm9kICo9ICR7aVtEXS5nZXRCeUluZGljZXMoYGlucHV0JHtEfUluZGljZXNgKX07YCl9fSkseC5wdXNoKGBmb3IodmFyICR7a306IHUzMiA9IDA7ICR7a30gPCB1bmlmb3Jtcy4ke3BkKGspfTsgJHtrfSsrKSB7YCksJC5wdXNoKFwifVwiKX0pO2xldCBUPVM/Wy4uLnUsYGxldCBzdW0gPSAke2kubWFwKChBLGspPT5BLmdldEJ5SW5kaWNlcyhgaW5wdXQke2t9SW5kaWNlc2ApKS5qb2luKFwiICogXCIpfTtgXTpbLi4udSxfLC4uLngsLi4uZyxoLC4uLnYseSwuLi4kXTtyZXR1cm5gXG4gICAgICAgICAgICAke20ucmVnaXN0ZXJVbmlmb3JtcyhsLm1hcChBPT4oe25hbWU6YCR7cGQoQSl9YCx0eXBlOlwidTMyXCJ9KSkpLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dFNpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKC4uLmksZCl9XG5cbiAgICAgICAgICAgICR7bS5tYWluU3RhcnQoKX1cbiAgICAgICAgICAgICR7bS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0U2l6ZVwiKX1cbiAgICAgICAgICAgIHZhciBvdXRwdXRJbmRpY2VzID0gJHtkLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgICAgICAgJHtpLm1hcCgoQSxrKT0+YHZhciBpbnB1dCR7a31JbmRpY2VzOiAke2lba10udHlwZS5pbmRpY2VzfTtgKS5qb2luKGBcbmApfVxuICAgICAgICAgICAgJHtULmpvaW4oYFxuYCl9O1xuICAgICAgICAgICAgJHtkLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwic3VtXCIpfTtcbiAgICAgICAgICB9YH07cmV0dXJue25hbWU6XCJFaW5zdW1cIixzaGFkZXJDYWNoZTp7aGludDpyLmVxdWF0aW9uLGlucHV0RGVwZW5kZW5jaWVzOmUubWFwKCgpPT5cInJhbmtcIil9LGdldFJ1bkRhdGE6KCk9PntsZXQgbT1sLmZpbHRlcihoPT5yLnN5bWJvbFRvSW5mby5oYXMoaCkpLm1hcChoPT4oe3R5cGU6MTIsZGF0YTpyLnN5bWJvbFRvSW5mby5nZXQoaCk/LmRpbVZhbHVlfHwwfSkpO20ucHVzaCh7dHlwZToxMixkYXRhOmF9KTtsZXQgdT1lLm1hcCgoaCxfKT0+Wy4uLk4oaCldKS5yZWR1Y2UoKGgsXyk9PmguY29uY2F0KF8pLG0pO3JldHVybiB1LnB1c2goLi4uTihuKSkse291dHB1dHM6W3tkaW1zOm4sZGF0YVR5cGU6dH1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGEvNjQpfSxwcm9ncmFtVW5pZm9ybXM6dX19LGdldFNoYWRlclNvdXJjZTpwfX0sbWQ9KGUsdCk9PntsZXQgcj1uZXcgeG8oZS5pbnB1dHMsdC5lcXVhdGlvbiksbj1yLm91dHB1dERpbXMsbz1lLmlucHV0cy5tYXAoKGksYSk9PmkuZGltcyk7ZS5jb21wdXRlKEFmKG8sZS5pbnB1dHNbMF0uZGF0YVR5cGUscixuKSl9LGZkPWU9PntsZXQgdD1lLmVxdWF0aW9uLnJlcGxhY2UoL1xccysvZyxcIlwiKTtyZXR1cm4gcmUoe2VxdWF0aW9uOnR9KX19KTt2YXIga2YsZ2QsRWYsUGYsYmQseWQ9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTthZSgpO2tmPWU9PntpZighZXx8ZS5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIkV4cGFuZCByZXF1aXJlcyAyIGlucHV0LlwiKTtsZXQgdD1lWzBdLmRpbXMscj1BcnJheS5mcm9tKGVbMV0uZ2V0QmlnSW50NjRBcnJheSgpLE51bWJlciksbj1yLmxlbmd0aDx0Lmxlbmd0aD8wOnIubGVuZ3RoLXQubGVuZ3RoLG89dC5sZW5ndGg8ci5sZW5ndGg/MDp0Lmxlbmd0aC1yLmxlbmd0aDtmb3IoO248ci5sZW5ndGgmJm88dC5sZW5ndGg7KytuLCsrbylpZihyW25dIT09dFtvXSYmcltuXSE9PTEmJnRbb10hPT0xKXRocm93IG5ldyBFcnJvcihcIkV4cGFuZCByZXF1aXJlcyBzaGFwZSB0byBiZSBicm9hZGNhc3RhYmxlIHRvIGlucHV0XCIpfSxnZD0oZSx0KT0+e2xldCByPWUubGVuZ3RoLXQubGVuZ3RoLG49W107Zm9yKGxldCBvPTA7bzxyOysrbyluLnB1c2goZVtvXSk7Zm9yKGxldCBvPTA7bzx0Lmxlbmd0aDsrK28pbi5wdXNoKHRbb109PT0xP2VbbytyXTp0W29dKTtyZXR1cm4gbn0sRWY9KGUsdCk9PmUubGVuZ3RoPnQubGVuZ3RoP2dkKGUsdCk6Z2QodCxlKSxQZj1lPT57bGV0IHQ9ZVswXS5kaW1zLHI9QXJyYXkuZnJvbShlWzFdLmdldEJpZ0ludDY0QXJyYXkoKSxOdW1iZXIpLG49RWYodCxyKSxvPWVbMF0uZGF0YVR5cGUsaT1vPT09OXx8Qy5zaXplKHQpPT09MSxhPW89PT05fHx0Lmxlbmd0aD4wJiZ0W3QubGVuZ3RoLTFdJTQ9PT0wPzQ6MSxkPWl8fG4ubGVuZ3RoPjAmJm5bbi5sZW5ndGgtMV0lND09PTA/NDoxLGw9TWF0aC5jZWlsKEMuc2l6ZShuKS9kKSxwPXU9PntsZXQgaD1FKFwiaW5wdXRcIixvLHQubGVuZ3RoLGEpLF89TShcIm91dHB1dFwiLG8sbi5sZW5ndGgsZCkseTtpZihvPT09OSl7bGV0IGc9KHgsJCx2PVwiXCIpPT5gXG4gICAgICAgICAgbGV0IG91dHB1dEluZGljZXMkeyR9ID0gJHtfLm9mZnNldFRvSW5kaWNlcyhgb3V0cHV0T2Zmc2V0ICsgJHskfXVgKX07XG4gICAgICAgICAgbGV0IG9mZnNldCR7JH0gPSAke2guYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dEluZGljZXMkeyR9YCxfKX07XG4gICAgICAgICAgbGV0IGluZGV4JHskfSA9IG9mZnNldCR7JH0gLyA0dTtcbiAgICAgICAgICBsZXQgY29tcG9uZW50JHskfSA9IG9mZnNldCR7JH0gJSA0dTtcbiAgICAgICAgICAke3h9WyR7JH1dID0gJHt2fSgke2guZ2V0QnlPZmZzZXQoYGluZGV4JHskfWApfVtjb21wb25lbnQkeyR9XSk7XG4gICAgICAgIGA7eT1gXG4gICAgICAgIGxldCBvdXRwdXRPZmZzZXQgPSBnbG9iYWxfaWR4ICogJHtkfTtcbiAgICAgICAgdmFyIGRhdGEgPSB2ZWM0PHUzMj4oMCk7XG4gICAgICAgICR7ZyhcImRhdGFcIiwwLFwidTMyXCIpfVxuICAgICAgICAke2coXCJkYXRhXCIsMSxcInUzMlwiKX1cbiAgICAgICAgJHtnKFwiZGF0YVwiLDIsXCJ1MzJcIil9XG4gICAgICAgICR7ZyhcImRhdGFcIiwzLFwidTMyXCIpfVxuICAgICAgICAke18uc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJkYXRhXCIpfVxuICAgICAgfWB9ZWxzZSB5PWBcbiAgICAgICAgbGV0IG91dHB1dEluZGljZXMgPSAke18ub2Zmc2V0VG9JbmRpY2VzKGBnbG9iYWxfaWR4ICogJHtkfWApfTtcbiAgICAgICAgbGV0IGlucHV0T2Zmc2V0ID0gJHtoLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KFwib3V0cHV0SW5kaWNlc1wiLF8pfTtcbiAgICAgICAgbGV0IGRhdGEgPSAke18udHlwZS52YWx1ZX0oJHtoLmdldEJ5T2Zmc2V0KGBpbnB1dE9mZnNldCAvICR7YX1gKX0pO1xuICAgICAgICAke18uc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJkYXRhXCIpfVxuICAgICAgfWA7cmV0dXJuYFxuICAgICR7dS5yZWdpc3RlclVuaWZvcm0oXCJ2ZWNfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoaCxfKX1cbiAgICAke3UubWFpblN0YXJ0KCl9XG4gICAgJHt1Lmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy52ZWNfc2l6ZVwiKX1cbiAgICAke3l9YH0sbT1be3R5cGU6MTIsZGF0YTpsfSwuLi5OKHQsbildO3JldHVybntuYW1lOlwiRXhwYW5kXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7bi5sZW5ndGh9OyR7YX0ke2R9YCxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxnZXRTaGFkZXJTb3VyY2U6cCxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm4sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGwvNjQpfSxwcm9ncmFtVW5pZm9ybXM6bX0pfX0sYmQ9ZT0+e2tmKGUuaW5wdXRzKSxlLmNvbXB1dGUoUGYoZS5pbnB1dHMpLHtpbnB1dHM6WzBdfSl9fSk7dmFyIHpmLF9kLHdkPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7YWUoKTtLcigpO3pmPWU9PntsZXQgdD1lWzBdLmRhdGFUeXBlLHI9Qy5zaXplKGVbMF0uZGltcyksbj1DLnNpemUoZVsxXS5kaW1zKSxvPW4lND09PTAsaT1hPT57bGV0IGQ9RShcInhcIix0LFsxXSw0KSxsPUUoXCJiaWFzXCIsdCxbMV0sNCkscD1NKFwieVwiLHQsWzFdLDQpLG09W3tuYW1lOlwib3V0cHV0X3ZlY19zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImJpYXNfc2l6ZVwiLHR5cGU6XCJ1MzJcIn1dLHU9Xz0+YFxuICAgICAgbGV0IGJpYXMke199X29mZnNldDogdTMyID0gKGdsb2JhbF9pZHggKiA0ICsgJHtffSkgJSB1bmlmb3Jtcy5iaWFzX3NpemU7XG4gICAgICBsZXQgYmlhcyR7X30gPSAke2wuZ2V0QnlPZmZzZXQoYGJpYXMke199X29mZnNldCAvIDRgKX1bYmlhcyR7X31fb2Zmc2V0ICUgNF07YCxoPW8/YFxuICAgICAgbGV0IGJpYXMgPSAke2wuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4ICUgKHVuaWZvcm1zLmJpYXNfc2l6ZSAvIDQpXCIpfTtgOmAke3UoMCl9JHt1KDEpfSR7dSgyKX0ke3UoMyl9XG4gICAgICBsZXQgYmlhcyA9ICR7ZC50eXBlLnZhbHVlfShiaWFzMCwgYmlhczEsIGJpYXMyLCBiaWFzMyk7YDtyZXR1cm5gJHthLnJlZ2lzdGVyVW5pZm9ybXMobSkuZGVjbGFyZVZhcmlhYmxlcyhkLGwscCl9XG5cbiAgICAke21vKEVlKHQpKX1cblxuICAgICR7YS5tYWluU3RhcnQoa3QpfVxuICAgICAgJHthLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfdmVjX3NpemVcIil9XG5cbiAgICAgIGxldCB4ID0gJHtkLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAke2h9XG4gICAgICBsZXQgeF9pbiA9IHggKyBiaWFzO1xuICAgICAgJHtwLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLGZvKFwieF9pblwiKSl9XG4gICAgfWB9O3JldHVybntuYW1lOlwiRmFzdEdlbHVXaXRoQmlhc1wiLHNoYWRlckNhY2hlOntoaW50OmAke299YCxpbnB1dERlcGVuZGVuY2llczpbXCJ0eXBlXCIsXCJ0eXBlXCJdfSxnZXRTaGFkZXJTb3VyY2U6aSxnZXRSdW5EYXRhOmE9Pih7b3V0cHV0czpbe2RpbXM6YVswXS5kaW1zLGRhdGFUeXBlOmFbMF0uZGF0YVR5cGV9XSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjEyLGRhdGE6TWF0aC5jZWlsKHIvNCl9LHt0eXBlOjEyLGRhdGE6bn1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKHIva3QvNCl9fSl9fSxfZD1lPT57ZS5pbnB1dHMubGVuZ3RoPDJ8fEMuc2l6ZShlLmlucHV0c1sxXS5kaW1zKT09PTA/aHUoZSk6ZS5jb21wdXRlKHpmKGUuaW5wdXRzKSl9fSk7dmFyIE9mLERmLHZkLCRkLHhkPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7U2UoKTthZSgpO09mPWU9PntpZighZXx8ZS5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIkdhdGhlciByZXF1aXJlcyAyIGlucHV0cy5cIil9LERmPShlLHQpPT57bGV0IHI9ZVswXS5kaW1zLG49ZVsxXS5kaW1zLG89ci5sZW5ndGgsaT1DLm5vcm1hbGl6ZUF4aXModC5heGlzLG8pLGE9ci5zbGljZSgwKTthLnNwbGljZShpLDEsLi4ubik7bGV0IGQ9cltpXSxsPWVbMF0uZGF0YVR5cGU9PT05PzQ6MSxwPU1hdGguY2VpbChDLnNpemUoYSkvbCksbT1be3R5cGU6MTIsZGF0YTpwfSx7dHlwZTo2LGRhdGE6ZH0se3R5cGU6MTIsZGF0YTppfSwuLi5OKGVbMF0uZGltcyxlWzFdLmRpbXMsYSldLHU9aD0+e2xldCBfPUUoXCJkYXRhXCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMubGVuZ3RoLGwpLHk9RShcImlucHV0SW5kaWNlc1wiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zLmxlbmd0aCksZz1NKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxhLmxlbmd0aCxsKSx4PXY9PntsZXQgUz1uLmxlbmd0aCxUPWB2YXIgaW5kaWNlc0luZGljZXMke3Z9ICA9ICR7eS50eXBlLmluZGljZXN9KDApO2A7Zm9yKGxldCBBPTA7QTxTO0ErKylUKz1gJHtTPjE/YGluZGljZXNJbmRpY2VzJHt2fVske0F9XWA6YGluZGljZXNJbmRpY2VzJHt2fWB9ID0gJHthLmxlbmd0aD4xP2BvdXRwdXRJbmRpY2VzJHt2fVt1bmlmb3Jtcy5heGlzICsgJHtBfV1gOmBvdXRwdXRJbmRpY2VzJHt2fWB9O2A7VCs9YFxuICAgICAgICAgIHZhciBpZHgke3Z9ID0gJHt5LmdldEJ5SW5kaWNlcyhgaW5kaWNlc0luZGljZXMke3Z9YCl9O1xuICAgICAgICAgIGlmIChpZHgke3Z9IDwgMCkge1xuICAgICAgICAgICAgaWR4JHt2fSA9IGlkeCR7dn0gKyB1bmlmb3Jtcy5heGlzRGltTGltaXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBkYXRhSW5kaWNlcyR7dn0gOiAke18udHlwZS5pbmRpY2VzfTtcbiAgICAgICAgYDtmb3IobGV0IEE9MCxrPTA7QTxvO0ErKylBPT09aT8oVCs9YCR7bz4xP2BkYXRhSW5kaWNlcyR7dn1bJHtBfV1gOmBkYXRhSW5kaWNlcyR7dn1gfSA9IHUzMihpZHgke3Z9KTtgLGsrPVMpOihUKz1gJHtvPjE/YGRhdGFJbmRpY2VzJHt2fVske0F9XWA6YGRhdGFJbmRpY2VzJHt2fWB9ID0gJHthLmxlbmd0aD4xP2BvdXRwdXRJbmRpY2VzJHt2fVske2t9XWA6YG91dHB1dEluZGljZXMke3Z9YH07YCxrKyspO3JldHVybiBUfSwkO2lmKGVbMF0uZGF0YVR5cGU9PT05KXtsZXQgdj0oUyxULEE9XCJcIik9PmBcbiAgICAgICAgICBsZXQgb3V0cHV0SW5kaWNlcyR7VH0gPSAke2cub2Zmc2V0VG9JbmRpY2VzKGBvdXRwdXRPZmZzZXQgKyAke1R9dWApfTtcbiAgICAgICAgICAke3goVCl9O1xuICAgICAgICAgIGxldCBvZmZzZXQke1R9ID0gJHtfLmluZGljZXNUb09mZnNldChgZGF0YUluZGljZXMke1R9YCl9O1xuICAgICAgICAgIGxldCBpbmRleCR7VH0gPSBvZmZzZXQke1R9IC8gNHU7XG4gICAgICAgICAgbGV0IGNvbXBvbmVudCR7VH0gPSBvZmZzZXQke1R9ICUgNHU7XG4gICAgICAgICAgJHtTfVske1R9XSA9ICR7QX0oJHtfLmdldEJ5T2Zmc2V0KGBpbmRleCR7VH1gKX1bY29tcG9uZW50JHtUfV0pO1xuICAgICAgICBgOyQ9YFxuICAgICAgICBsZXQgb3V0cHV0T2Zmc2V0ID0gZ2xvYmFsX2lkeCAqICR7bH07XG4gICAgICAgIHZhciB2YWx1ZSA9IHZlYzQ8dTMyPigwKTtcbiAgICAgICAgJHt2KFwidmFsdWVcIiwwLFwidTMyXCIpfVxuICAgICAgICAke3YoXCJ2YWx1ZVwiLDEsXCJ1MzJcIil9XG4gICAgICAgICR7dihcInZhbHVlXCIsMixcInUzMlwiKX1cbiAgICAgICAgJHt2KFwidmFsdWVcIiwzLFwidTMyXCIpfVxuICAgICAgICAke2cuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKX1cbiAgICAgIGB9ZWxzZSAkPWBcbiAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtnLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgJHt4KFwiXCIpfTtcbiAgICAgIGxldCB2YWx1ZSA9ICR7Xy5nZXRCeUluZGljZXMoXCJkYXRhSW5kaWNlc1wiKX07XG4gICAgICAke2cuc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsXCJ2YWx1ZVwiKX07XG4gICAgICBgO3JldHVybmBcbiAgICAgICR7aC5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRTaXplXCIsXCJ1MzJcIikucmVnaXN0ZXJVbmlmb3JtKFwiYXhpc0RpbUxpbWl0XCIsXCJpMzJcIikucmVnaXN0ZXJVbmlmb3JtKFwiYXhpc1wiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoXyx5LGcpfVxuICAgICAgJHtoLm1haW5TdGFydCgpfVxuICAgICAgICAke2guZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG4gICAgICAgICR7JH1cbiAgICAgIH1gfTtyZXR1cm57bmFtZTpcIkdhdGhlclwiLHNoYWRlckNhY2hlOntoaW50OnQuY2FjaGVLZXksaW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiLFwicmFua1wiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczphLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChwLzY0KX0scHJvZ3JhbVVuaWZvcm1zOm19KSxnZXRTaGFkZXJTb3VyY2U6dX19LHZkPWU9PnJlKHtheGlzOmUuYXhpc30pLCRkPShlLHQpPT57bGV0IHI9ZS5pbnB1dHM7T2YociksZS5jb21wdXRlKERmKGUuaW5wdXRzLHQpKX19KTt2YXIgQmYsU2QsVGQsSWQ9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTthZSgpO0JmPShlLHQscixuLG8saSxhLGQsbCk9PntsZXQgcD1be3R5cGU6MTIsZGF0YTppfSx7dHlwZToxMixkYXRhOm59LHt0eXBlOjEyLGRhdGE6b30se3R5cGU6MTIsZGF0YTpyfSx7dHlwZToxMixkYXRhOmF9LHt0eXBlOjEyLGRhdGE6ZH0se3R5cGU6MTIsZGF0YTpsfV0sbT1baV07cC5wdXNoKC4uLk4odC5kaW1zLG0pKTtsZXQgdT1oPT57bGV0IF89RShcImluZGljZXNfZGF0YVwiLHQuZGF0YVR5cGUsdC5kaW1zLmxlbmd0aCkseT1NKFwiaW5wdXRfc2xpY2Vfb2Zmc2V0c19kYXRhXCIsMTIsMSwxKSxnPVtfLHldLHg9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiYmF0Y2hfZGltc1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJpbnB1dF9kaW1zXCIsdHlwZTpcInUzMlwiLGxlbmd0aDpvLmxlbmd0aH0se25hbWU6XCJzaXplc19mcm9tX3NsaWNlX2RpbXNfZGF0YVwiLHR5cGU6XCJ1MzJcIixsZW5ndGg6ci5sZW5ndGh9LHtuYW1lOlwibnVtX3NsaWNlc19wZXJfYmF0Y2hcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiaW5wdXRfYmF0Y2hfc3RyaWRlXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIm51bV9zbGljZV9kaW1zXCIsdHlwZTpcInUzMlwifV07cmV0dXJuYFxuICAke2gucmVnaXN0ZXJVbmlmb3Jtcyh4KS5kZWNsYXJlVmFyaWFibGVzKC4uLmcpfVxuICAke2gubWFpblN0YXJ0KCl9XG4gICAgJHtoLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICBsZXQgYmF0Y2hfaWR4ID0gZ2xvYmFsX2lkeCAvIHVuaWZvcm1zLm51bV9zbGljZXNfcGVyX2JhdGNoO1xuICAgIGxldCBiYXNlX29mZnNldCA9IGJhdGNoX2lkeCAqIHVuaWZvcm1zLmlucHV0X2JhdGNoX3N0cmlkZTtcblxuICAgIGxldCBzbGljZV9pbmRpY2VzX2Jhc2Vfb2Zmc2V0ID0gZ2xvYmFsX2lkeCAqIHVuaWZvcm1zLm51bV9zbGljZV9kaW1zO1xuICAgIHZhciByZWxhdGl2ZV9zbGljZV9vZmZzZXQgPSAwO1xuICAgIGZvciAodmFyIGRpbV9pZHggPSAwdTsgZGltX2lkeCA8IHVuaWZvcm1zLm51bV9zbGljZV9kaW1zOyBkaW1faWR4ICsrKSB7XG4gICAgICB2YXIgaW5kZXggPSBpMzIoaW5kaWNlc19kYXRhW2RpbV9pZHggKyBzbGljZV9pbmRpY2VzX2Jhc2Vfb2Zmc2V0XS54KTtcbiAgICAgIGxldCBpbnB1dF9kaW1faWR4ID0gdW5pZm9ybXMuYmF0Y2hfZGltcyArIGRpbV9pZHg7XG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICR7by5sZW5ndGg9PT0xP1wiaW5kZXggKz0gaTMyKHVuaWZvcm1zLmlucHV0X2RpbXMpO1wiOlwiaW5kZXggKz0gaTMyKHVuaWZvcm1zLmlucHV0X2RpbXNbaW5wdXRfZGltX2lkeF0pO1wifVxuICAgICAgfVxuICAgICAgJHtyLmxlbmd0aD09PTE/XCJyZWxhdGl2ZV9zbGljZV9vZmZzZXQgKz0gaW5kZXggKiBpMzIodW5pZm9ybXMuc2l6ZXNfZnJvbV9zbGljZV9kaW1zX2RhdGEpO1wiOlwicmVsYXRpdmVfc2xpY2Vfb2Zmc2V0ICs9IGluZGV4ICogaTMyKHVuaWZvcm1zLnNpemVzX2Zyb21fc2xpY2VfZGltc19kYXRhW2RpbV9pZHhdKTtcIn1cbiAgICB9XG5cbiAgICBpbnB1dF9zbGljZV9vZmZzZXRzX2RhdGFbZ2xvYmFsX2lkeF0gPSAgYmFzZV9vZmZzZXQgKyB1MzIocmVsYXRpdmVfc2xpY2Vfb2Zmc2V0KTtcbiAgfWB9O3JldHVybiBlLmNvbXB1dGUoe25hbWU6XCJjb21wdXRlU2xpY2VPZmZzZXRzXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7by5sZW5ndGh9XyR7ci5sZW5ndGh9YCxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm0sZGF0YVR5cGU6ZS5pbnB1dHNbMV0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChpLzY0KX0scHJvZ3JhbVVuaWZvcm1zOnB9KSxnZXRTaGFkZXJTb3VyY2U6dX0se2lucHV0czpbdF0sb3V0cHV0czpbLTFdfSlbMF19LFNkPShlLHQpPT57bGV0IHI9ZS5pbnB1dHMsbj1yWzBdLmRpbXMsbz1yWzBdLmRhdGFUeXBlLGk9clsxXS5kaW1zLGE9aVtpLmxlbmd0aC0xXSxkPUMuc2l6ZVRvRGltZW5zaW9uKGksaS5sZW5ndGgtMSksbD1DLnNpemVGcm9tRGltZW5zaW9uKG4sdC5iYXRjaERpbXMrYSkscD1DLnNpemVUb0RpbWVuc2lvbihuLHQuYmF0Y2hEaW1zKSxtPUMuc2l6ZUZyb21EaW1lbnNpb24obix0LmJhdGNoRGltcyksdT1kL3AsaD1uZXcgQXJyYXkoYSksXz1sO2ZvcihsZXQgVD0wO1Q8YTsrK1QpaFthLTEtVF09XyxfKj1uW3QuYmF0Y2hEaW1zK2EtMS1UXTtsZXQgeT1CZihlLHJbMV0saCx0LmJhdGNoRGltcyxuLGQsdSxtLGEpLGc9dC5iYXRjaERpbXMrYTtpZihnPm4ubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcImxhc3QgZGltZW5zaW9uIG9mIGluZGljZXMgbXVzdCBub3QgYmUgbGFyZ2VyIHRoYW4gcmFuayBvZiBpbnB1dCB0ZW5zb3JcIik7bGV0IHg9aS5zbGljZSgwLC0xKS5jb25jYXQobi5zbGljZShnKSksJD1DLnNpemUoeCksdj1be3R5cGU6MTIsZGF0YTokfSx7dHlwZToxMixkYXRhOmx9LC4uLk4oclswXS5kaW1zLHkuZGltcyx4KV0sUz1UPT57bGV0IEE9RShcImRhdGFcIixyWzBdLmRhdGFUeXBlLHJbMF0uZGltcy5sZW5ndGgpLGs9RShcInNsaWNlX29mZnNldHNcIiwxMix5LmRpbXMubGVuZ3RoKSxQPU0oXCJvdXRwdXRcIixyWzBdLmRhdGFUeXBlLHgubGVuZ3RoKTtyZXR1cm5gXG4gICAgICAgICAgJHtULnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dF9zaXplXCIsXCJ1MzJcIikucmVnaXN0ZXJVbmlmb3JtKFwic2xpY2Vfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoQSxrLFApfVxuICAgICAgICAgICAgJHtULm1haW5TdGFydCgpfVxuICAgICAgICAgICAgJHtULmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICAgICAgICBsZXQgc2xpY2Vfb2Zmc2V0ID0gc2xpY2Vfb2Zmc2V0c1tnbG9iYWxfaWR4IC8gdW5pZm9ybXMuc2xpY2Vfc2l6ZV07XG4gICAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gZGF0YVt1MzIoc2xpY2Vfb2Zmc2V0KSArIGdsb2JhbF9pZHggJSB1bmlmb3Jtcy5zbGljZV9zaXplXTtcbiAgICAgICAgfWB9O2UuY29tcHV0ZSh7bmFtZTpcIkdhdGhlck5EXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6dC5jYWNoZUtleSxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCIsXCJyYW5rXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOngsZGF0YVR5cGU6b31dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKCQvNjQpfSxwcm9ncmFtVW5pZm9ybXM6dn0pLGdldFNoYWRlclNvdXJjZTpTfSx7aW5wdXRzOltyWzBdLHldfSl9LFRkPWU9Pih7YmF0Y2hEaW1zOmUuYmF0Y2hfZGltcyxjYWNoZUtleTpcIlwifSl9KTt2YXIgTWYsUmYsQ2QsQWQsa2Q9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTtTZSgpO2FlKCk7TWY9KGUsdCk9PntpZihlLmxlbmd0aDwzfHxlLmxlbmd0aD40KXRocm93IG5ldyBFcnJvcihcIkdhdGhlckJsb2NrUXVhbnRpemVkIHJlcXVpcmVzIDMgb3IgNCBpbnB1dHMuXCIpO2xldCByPUMubm9ybWFsaXplQXhpcyh0LnF1YW50aXplQXhpcyxlWzBdLmRpbXMubGVuZ3RoKSxuPXQuYmxvY2tTaXplLG89ZVswXSxpPWVbMl0sYT1lLmxlbmd0aD09PTQ/ZVszXTp2b2lkIDA7aWYoaS5kaW1zLmxlbmd0aCE9PW8uZGltcy5sZW5ndGh8fCFvLmRpbXMubWFwKChkLGwpPT5sPT09cj9NYXRoLmNlaWwoZC9uKT09PWkuZGltc1tsXTpkPT09aS5kaW1zW2xdKS5yZWR1Y2UoKGQsbCk9PmQmJmwsITApKXRocm93IG5ldyBFcnJvcihcIlNjYWxlcyBtdXN0IGhhdmUgdGhlIHNhbWUgcmFuayBhcyB0aGUgaW5wdXQgdGVuc29yIGFuZCB0aGUgZGltcyBzaG91bGQgbWF0Y2ggZXhjZXB0IG9uIGdhdGhlckF4aXMuXCIpO2lmKGEpe2lmKGEuZGF0YVR5cGUhPT1vLmRhdGFUeXBlKXRocm93IG5ldyBFcnJvcihcIlplcm8gcG9pbnQgbXVzdCBoYXZlIHRoZSBzYW1lIGRhdGEgdHlwZSBhcyB0aGUgaW5wdXQgdGVuc29yLlwiKTtpZihhLmRpbXMubGVuZ3RoIT09aS5kaW1zLmxlbmd0aHx8IWEuZGltcy5tYXAoKGQsbCk9PmQ9PT1pLmRpbXNbbF0pLnJlZHVjZSgoZCxsKT0+ZCYmbCwhMCkpdGhyb3cgbmV3IEVycm9yKFwiWmVybyBwb2ludCBtdXN0IGhhdmUgdGhlIHNhbWUgcmFuayBhcyB0aGUgaW5wdXQgdGVuc29yIGFuZCB0aGUgZGltcyBzaG91bGQgbWF0Y2ggZXhjZXB0IG9uIHF1YW50aXplQXhpcy5cIil9fSxSZj0oZSx0KT0+e2xldCByPWVbMF0uZGltcyxuPWVbMV0uZGltcyxvPXIubGVuZ3RoLGk9Qy5ub3JtYWxpemVBeGlzKHQuZ2F0aGVyQXhpcyxvKSxhPUMubm9ybWFsaXplQXhpcyh0LnF1YW50aXplQXhpcyxvKSxkPXIuc2xpY2UoMCk7ZC5zcGxpY2UoaSwxLC4uLm4pO2xldCBsPUMuc2l6ZShkKSxwPWVbMl0uZGF0YVR5cGUsdT1lWzBdLmRhdGFUeXBlPT09MjIsaD1be3R5cGU6MTIsZGF0YTpsfSx7dHlwZToxMixkYXRhOmF9LHt0eXBlOjEyLGRhdGE6aX0se3R5cGU6MTIsZGF0YTp0LmJsb2NrU2l6ZX0sLi4uTiguLi5lLm1hcCgoeSxnKT0+eS5kaW1zKSxkKV0sXz15PT57bGV0IGc9RShcImRhdGFcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcy5sZW5ndGgpLHg9RShcImlucHV0SW5kaWNlc1wiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zLmxlbmd0aCksJD1FKFwic2NhbGVzXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMubGVuZ3RoKSx2PWUubGVuZ3RoPjM/RShcInplcm9Qb2ludFwiLGVbM10uZGF0YVR5cGUsZVszXS5kaW1zLmxlbmd0aCk6dm9pZCAwLFM9TShcIm91dHB1dFwiLHAsZC5sZW5ndGgpLFQ9W2cseCwkXTt2JiZULnB1c2godik7bGV0IEE9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwicXVhbnRpemVfYXhpc1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJnYXRoZXJfYXhpc1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJibG9ja19zaXplXCIsdHlwZTpcInUzMlwifV07cmV0dXJuYFxuICAgICAgICAke3kucmVnaXN0ZXJVbmlmb3JtcyhBKS5kZWNsYXJlVmFyaWFibGVzKC4uLlQsUyl9XG4gICAgICAgICR7eS5tYWluU3RhcnQoKX1cbiAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHtTLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuICAgICAgICB2YXIgaW5kaWNlc19pbmRpY2VzID0gJHt4LnR5cGUuaW5kaWNlc30oMCk7XG4gICAgICAgICR7KCgpPT5uLmxlbmd0aD4xP2BcbiAgICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgJHtuLmxlbmd0aH07IGkrKykge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gJHtTLmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLFwidW5pZm9ybXMuZ2F0aGVyX2F4aXMgKyBpXCIpfTtcbiAgICAgICAgICAgICR7eC5pbmRpY2VzU2V0KFwiaW5kaWNlc19pbmRpY2VzXCIsXCJpXCIsXCJpbmRleFwiKX07XG4gICAgICAgICAgfWA6YGluZGljZXNfaW5kaWNlcyA9ICR7Uy5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixcInVuaWZvcm1zLmdhdGhlcl9heGlzXCIpfTtgKSgpfTtcbiAgICAgICAgdmFyIGRhdGFfaW5kaWNlcyA9ICR7Zy50eXBlLmluZGljZXN9KDApO1xuICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgdW5pZm9ybXMuZ2F0aGVyX2F4aXM7IGkrKykge1xuICAgICAgICAgIGxldCBpbmRleCA9ICR7Uy5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixcImlcIil9O1xuICAgICAgICAgICR7Zy5pbmRpY2VzU2V0KFwiZGF0YV9pbmRpY2VzXCIsXCJpXCIsXCJpbmRleFwiKX07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4X2Zyb21faW5kaWNlcyA9ICR7eC5nZXRCeUluZGljZXMoXCJpbmRpY2VzX2luZGljZXNcIil9O1xuICAgICAgICBpZiAoaW5kZXhfZnJvbV9pbmRpY2VzIDwgMCkge1xuICAgICAgICAgIGluZGV4X2Zyb21faW5kaWNlcyArPSAke3JbaV19O1xuICAgICAgICB9XG4gICAgICAgICR7Zy5pbmRpY2VzU2V0KFwiZGF0YV9pbmRpY2VzXCIsXCJ1bmlmb3Jtcy5nYXRoZXJfYXhpc1wiLFwidTMyKGluZGV4X2Zyb21faW5kaWNlcylcIil9O1xuICAgICAgICBmb3IgKHZhciBpID0gdW5pZm9ybXMuZ2F0aGVyX2F4aXMgKyAxOyBpIDwgJHtkLmxlbmd0aH07IGkrKykge1xuICAgICAgICAgIGxldCBpbmRleCA9ICR7Uy5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixgaSArICR7bi5sZW5ndGh9IC0gMWApfTtcbiAgICAgICAgICAke2cuaW5kaWNlc1NldChcImRhdGFfaW5kaWNlc1wiLFwiaVwiLFwiaW5kZXhcIil9O1xuICAgICAgICB9XG4gICAgICAgIGxldCBkYXRhX29mZnNldCA9ICR7Zy5pbmRpY2VzVG9PZmZzZXQoXCJkYXRhX2luZGljZXNcIil9O1xuICAgICAgICBsZXQgZGF0YV9pbmRleCA9IGRhdGFfb2Zmc2V0ICUgODtcbiAgICAgICAgLy8gQ29udmVydCA0LWJpdCBwYWNrZWQgZGF0YSB0byA4LWJpdCBwYWNrZWQgZGF0YS5cbiAgICAgICAgbGV0IHBhY2tlZF80Yml0X3F1YW50aXplZF9kYXRhID0gJHtnLmdldEJ5T2Zmc2V0KFwiZGF0YV9vZmZzZXQgLyA4XCIpfTtcbiAgICAgICAgbGV0IHBhY2tlZF84Yml0X3F1YW50aXplZF9kYXRhID0gKHBhY2tlZF80Yml0X3F1YW50aXplZF9kYXRhID4+ICg0ICogKGRhdGFfaW5kZXggJSAyKSkpICYgMHgwZjBmMGYwZjtcbiAgICAgICAgbGV0IHF1YW50aXplZF9kYXRhX3ZlYyA9ICR7dT9cInVucGFjazR4SThcIjpcInVucGFjazR4VThcIn0odTMyKHBhY2tlZF84Yml0X3F1YW50aXplZF9kYXRhKSk7XG4gICAgICAgIGxldCBxdWFudGl6ZWRfZGF0YSA9IHF1YW50aXplZF9kYXRhX3ZlY1tkYXRhX2luZGV4IC8gMl07XG4gICAgICAgIHZhciBzY2FsZV9pbmRpY2VzID0gZGF0YV9pbmRpY2VzO1xuICAgICAgICBsZXQgcXVhbnRpemVfYXhpc19pbmRleCA9ICR7JC5pbmRpY2VzR2V0KFwiZGF0YV9pbmRpY2VzXCIsXCJ1bmlmb3Jtcy5xdWFudGl6ZV9heGlzXCIpfSAvIHVuaWZvcm1zLmJsb2NrX3NpemU7XG4gICAgICAgICR7JC5pbmRpY2VzU2V0KFwic2NhbGVfaW5kaWNlc1wiLFwidW5pZm9ybXMucXVhbnRpemVfYXhpc1wiLFwicXVhbnRpemVfYXhpc19pbmRleFwiKX07XG4gICAgICAgIHZhciBzY2FsZSA9ICR7JC5nZXRCeUluZGljZXMoXCJzY2FsZV9pbmRpY2VzXCIpfTtcbiAgICAgICAgJHsoKCk9PnY/YFxuICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9pbmRpY2VzID0gc2NhbGVfaW5kaWNlcztcbiAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfb2Zmc2V0ID0gJHt2LmluZGljZXNUb09mZnNldChcInplcm9fcG9pbnRfaW5kaWNlc1wiKX07XG4gICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2luZGV4ID0gemVyb19wb2ludF9vZmZzZXQgJSA4O1xuICAgICAgICAgICAgICBsZXQgcGFja2VkXzRiaXRfemVyb19wb2ludHMgPSAke3YuZ2V0QnlPZmZzZXQoXCJ6ZXJvX3BvaW50X29mZnNldCAvIDhcIil9O1xuICAgICAgICAgICAgICBsZXQgcGFja2VkXzhiaXRfemVyb19wb2ludHMgPSAocGFja2VkXzRiaXRfemVyb19wb2ludHMgPj4gKDQgKiAoemVyb19wb2ludF9pbmRleCAlIDIpKSkgJiAweDBmMGYwZjBmO1xuICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF92ZWMgPSAke3U/XCJ1bnBhY2s0eEk4XCI6XCJ1bnBhY2s0eFU4XCJ9KHUzMihwYWNrZWRfOGJpdF96ZXJvX3BvaW50cykpO1xuICAgICAgICAgICAgICBsZXQgemVyb19wb2ludCA9IHplcm9fcG9pbnRfdmVjW3plcm9fcG9pbnRfaW5kZXggLyAyXTtgOlwidmFyIHplcm9fcG9pbnQgPSAwXCIpKCl9O1xuICAgICAgICBsZXQgZGVxdWFudGl6ZWRfZGF0YSA9ICR7RWUocCl9KHF1YW50aXplZF9kYXRhIC0gemVyb19wb2ludCkgKiBzY2FsZTtcbiAgICAgICAgJHtTLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwiZGVxdWFudGl6ZWRfZGF0YVwiKX07XG4gICAgfWB9O3JldHVybntuYW1lOlwiR2F0aGVyQmxvY2tRdWFudGl6ZWRcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmNhY2hlS2V5fTske2UuZmlsdGVyKCh5LGcpPT5nIT09MSkubWFwKHk9PnkuZGltcy5qb2luKFwiX1wiKSkuam9pbihcIjtcIil9YCxpbnB1dERlcGVuZGVuY2llczpBcnJheS5mcm9tKHtsZW5ndGg6ZS5sZW5ndGh9LCh5LGcpPT5cInJhbmtcIil9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6ZCxkYXRhVHlwZTpwfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwobC82NCl9LHByb2dyYW1Vbmlmb3JtczpofSksZ2V0U2hhZGVyU291cmNlOl99fSxDZD0oZSx0KT0+e2xldCByPWUuaW5wdXRzO01mKHIsdCksZS5jb21wdXRlKFJmKGUuaW5wdXRzLHQpKX0sQWQ9ZT0+cmUoe2Jsb2NrU2l6ZTplLmJsb2NrU2l6ZSxnYXRoZXJBeGlzOmUuZ2F0aGVyQXhpcyxxdWFudGl6ZUF4aXM6ZS5xdWFudGl6ZUF4aXN9KX0pO3ZhciBVZixOZixFZCxQZCx6ZD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtvZSgpO1NlKCk7YWUoKTtVZj1lPT57aWYoIWV8fGUubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJHYXRoZXJFbGVtZW50cyByZXF1aXJlcyAyIGlucHV0cy5cIik7aWYoZVswXS5kaW1zLmxlbmd0aDwxKXRocm93IG5ldyBFcnJvcihcIkdhdGhlckVsZW1lbnRzIHJlcXVpcmVzIHRoYXQgdGhlIGRhdGEgaW5wdXQgYmUgcmFuayA+PSAxLlwiKTtpZihlWzBdLmRpbXMubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYEdhdGhlckVsZW1lbnRzIHJlcXVpcmVzIHRoYXQgdGhlIGRhdGEgaW5wdXQgYW5kXG4gICAgICAgICAgICAgICAgICAgICBpbmRpY2VzIGlucHV0IHRlbnNvcnMgYmUgb2Ygc2FtZSByYW5rLmApfSxOZj0oZSx0KT0+e2xldCByPWVbMF0uZGltcyxuPWVbMF0uZGF0YVR5cGUsbz1yLmxlbmd0aCxpPWVbMV0uZGltcyxhPWVbMV0uZGF0YVR5cGUsZD1DLm5vcm1hbGl6ZUF4aXModC5heGlzLG8pLGw9cltkXSxwPWkuc2xpY2UoMCksbT1DLnNpemUocCksdT1FKFwiaW5wdXRcIixuLG8pLGg9RShcImluZGljZXNJbnB1dFwiLGEsaS5sZW5ndGgpLF89TShcIm91dHB1dFwiLG4scC5sZW5ndGgpLHk9W3t0eXBlOjEyLGRhdGE6bX0se3R5cGU6NixkYXRhOmx9LHt0eXBlOjEyLGRhdGE6ZH1dO3JldHVybiB5LnB1c2goLi4uTihyLGkscCkpLHtuYW1lOlwiR2F0aGVyRWxlbWVudHNcIixzaGFkZXJDYWNoZTp7aW5wdXREZXBlbmRlbmNpZXM6W1wicmFua1wiLFwicmFua1wiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpwLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChtLzY0KX0scHJvZ3JhbVVuaWZvcm1zOnl9KSxnZXRTaGFkZXJTb3VyY2U6JD0+YFxuICAgICAgJHskLnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dFNpemVcIixcInUzMlwiKS5yZWdpc3RlclVuaWZvcm0oXCJheGlzRGltTGltaXRcIixcImkzMlwiKS5yZWdpc3RlclVuaWZvcm0oXCJheGlzXCIsXCJ1MzJcIikuZGVjbGFyZVZhcmlhYmxlcyh1LGgsXyl9XG4gICAgICAkeyQubWFpblN0YXJ0KCl9XG4gICAgICAkeyQuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG5cbiAgICAgIGxldCBvdXRwdXRJbmRpY2VzID0gJHtfLm9mZnNldFRvSW5kaWNlcyhcImdsb2JhbF9pZHhcIil9O1xuXG4gICAgICB2YXIgaWR4ID0gJHtoLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgICBpZHggPSBpZHggKyB1bmlmb3Jtcy5heGlzRGltTGltaXQ7XG4gICAgICB9XG4gICAgICB2YXIgaW5wdXRJbmRpY2VzID0gJHt1LnR5cGUuaW5kaWNlc30ob3V0cHV0SW5kaWNlcyk7XG4gICAgICAke3UuaW5kaWNlc1NldChcImlucHV0SW5kaWNlc1wiLFwidW5pZm9ybXMuYXhpc1wiLFwidTMyKGlkeClcIil9O1xuICAgICAgbGV0IHZhbHVlID0gJHt1LmdldEJ5SW5kaWNlcyhcImlucHV0SW5kaWNlc1wiKX07XG5cbiAgICAgICR7Xy5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlXCIpfTtcbiAgfWB9fSxFZD1lPT5yZSh7YXhpczplLmF4aXN9KSxQZD0oZSx0KT0+e2xldCByPWUuaW5wdXRzO1VmKHIpLGUuY29tcHV0ZShOZihlLmlucHV0cyx0KSl9fSk7dmFyIFZmLFdmLE9kLERkLEJkPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7YWUoKTtWZj1lPT57aWYoIWUpdGhyb3cgbmV3IEVycm9yKFwiSW5wdXQgaXMgbWlzc2luZ1wiKTtpZihlLmxlbmd0aDwyfHxlLmxlbmd0aD4zKXRocm93IG5ldyBFcnJvcihcIkludmFpZCBpbnB1dCBudW1iZXIuXCIpO2lmKGUubGVuZ3RoPT09MyYmZVsyXS5kaW1zLmxlbmd0aD4yKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgc2hhcGUgb2YgQ1wiKTtpZihlWzBdLmRhdGFUeXBlIT09ZVsxXS5kYXRhVHlwZXx8ZS5sZW5ndGg9PT0zJiZlWzBdLmRhdGFUeXBlIT09ZVsyXS5kYXRhVHlwZSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCB0eXBlcyBhcmUgbWlzbWF0Y2hlZFwiKX0sV2Y9KGUsdCk9PntsZXQgcj1lWzBdLmRpbXMuc2xpY2UoKSxuPWVbMV0uZGltcy5zbGljZSgpLFtvLGksYV09VnIuZ2V0U2hhcGVPZkdlbW1SZXN1bHQocix0LnRyYW5zQSxuLHQudHJhbnNCLGUubGVuZ3RoPT09Mz9lWzJdLmRpbXM6dm9pZCAwKSxkPVtvLGldO2lmKCFkKXRocm93IG5ldyBFcnJvcihcIkNhbid0IHVzZSBnZW1tIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO2xldCBsPTE2LHA9TWF0aC5jZWlsKGkvbCksbT1NYXRoLmNlaWwoby9sKSx1PSEwLGg9Qy5zaXplKGQpLF89W3t0eXBlOjEyLGRhdGE6dT9wOmh9LHt0eXBlOjEyLGRhdGE6b30se3R5cGU6MTIsZGF0YTppfSx7dHlwZToxMixkYXRhOmF9LHt0eXBlOjEsZGF0YTp0LmFscGhhfSx7dHlwZToxLGRhdGE6dC5iZXRhfV0seT1bXCJ0eXBlXCIsXCJ0eXBlXCJdO2UubGVuZ3RoPT09MyYmKF8ucHVzaCguLi5OKGVbMl0uZGltcykpLHkucHVzaChcInJhbmtcIikpLF8ucHVzaCguLi5OKGQpKTtsZXQgZz0kPT57bGV0IHY9XCJcIjt0LnRyYW5zQSYmdC50cmFuc0I/dj1cInZhbHVlICs9IGFbayAqIHVuaWZvcm1zLk0gKyBtXSAqIGJbbiAqIHVuaWZvcm1zLksgKyBrXTtcIjp0LnRyYW5zQSYmIXQudHJhbnNCP3Y9XCJ2YWx1ZSArPSBhW2sgKiB1bmlmb3Jtcy5NICsgbV0gKiBiW2sgKiB1bmlmb3Jtcy5OICsgbl07XCI6IXQudHJhbnNBJiZ0LnRyYW5zQj92PVwidmFsdWUgKz0gYVttICogdW5pZm9ybXMuSyArIGtdICogYltuICogdW5pZm9ybXMuSyArIGtdO1wiOiF0LnRyYW5zQSYmIXQudHJhbnNCJiYodj1cInZhbHVlICs9IGFbbSAqIHVuaWZvcm1zLksgKyBrXSAqIGJbayAqIHVuaWZvcm1zLk4gKyBuXTtcIik7bGV0IFM9dC5hbHBoYT09PTE/XCJcIjpcInZhbHVlICo9IHVuaWZvcm1zLmFscGhhO1wiLFQ9RShcImFcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcyksQT1FKFwiYlwiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zKSxrPVQudHlwZS52YWx1ZSxQPW51bGwsRD1bVCxBXTtlLmxlbmd0aD09PTMmJihQPUUoXCJjXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMubGVuZ3RoKSxELnB1c2goUCkpO2xldCBSPU0oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLGQubGVuZ3RoKTtELnB1c2goUik7bGV0IEc9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiTVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJOXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIktcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiYWxwaGFcIix0eXBlOlwiZjMyXCJ9LHtuYW1lOlwiYmV0YVwiLHR5cGU6XCJmMzJcIn1dO3JldHVybmBcbiAgJHskLnJlZ2lzdGVyVW5pZm9ybXMoRykuZGVjbGFyZVZhcmlhYmxlcyguLi5EKX1cblxuICAkeyQubWFpblN0YXJ0KCl9XG4gICAgJHskLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cblxuICAgIGxldCBtID0gZ2xvYmFsX2lkeCAvIHVuaWZvcm1zLk47XG4gICAgbGV0IG4gPSBnbG9iYWxfaWR4ICUgdW5pZm9ybXMuTjtcblxuICAgIHZhciB2YWx1ZSA9ICR7a30oMCk7XG4gICAgZm9yICh2YXIgazogdTMyID0gMHU7IGsgPCB1bmlmb3Jtcy5LOyBrKyspIHtcbiAgICAgICR7dn1cbiAgICB9XG5cbiAgICAke1N9XG4gICAgJHsoKCk9PlAhPW51bGw/YGxldCBjT2Zmc2V0ID0gJHtQLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KFwidmVjMihtLCBuKVwiLFIpfTsgdmFsdWUgKz0gJHtrfSh1bmlmb3Jtcy5iZXRhKSAqICR7UC5nZXRCeU9mZnNldChcImNPZmZzZXRcIil9O2A6XCJcIikoKX1cbiAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSB2YWx1ZTtcbiAgfWB9LHg9JD0+e2xldCB2PUUoXCJhXCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMpLFM9RShcImJcIixlWzFdLmRhdGFUeXBlLGVbMV0uZGltcyksVD1udWxsLEE9W3YsU107ZS5sZW5ndGg9PT0zJiYoVD1FKFwiY1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLmxlbmd0aCksQS5wdXNoKFQpKTtsZXQgaz1NKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxkLmxlbmd0aCk7QS5wdXNoKGspO2xldCBQPVt7bmFtZTpcIm51bV90aWxlX25cIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiTVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJOXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIktcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiYWxwaGFcIix0eXBlOlwiZjMyXCJ9LHtuYW1lOlwiYmV0YVwiLHR5cGU6XCJmMzJcIn1dLEQ9XCJcIixSPVwiXCI7dC50cmFuc0EmJnQudHJhbnNCPyhSPWBcbiAgICAgIHZhciBjb2wgPSB0aWxlX3Jvd19zdGFydCArIGxvY2FsX2lkLng7XG4gICAgICB2YXIgcm93ID0ga19zdGFydCArIGxvY2FsX2lkLnk7XG4gICAgICBpZiAoY29sIDwgdW5pZm9ybXMuTSAmJiByb3cgPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIHRpbGVfYVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9IGFbcm93ICogdW5pZm9ybXMuTSArIGNvbF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWxlX2FbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke3YudHlwZS52YWx1ZX0oMCk7XG4gICAgICB9XG5cbiAgICAgIGNvbCA9IGtfc3RhcnQgKyBsb2NhbF9pZC54O1xuICAgICAgcm93ID0gdGlsZV9jb2xfc3RhcnQgKyBsb2NhbF9pZC55O1xuICAgICAgaWYgKGNvbCA8IHVuaWZvcm1zLksgJiYgcm93IDwgdW5pZm9ybXMuTikge1xuICAgICAgICB0aWxlX2JbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSBiW3JvdyAqIHVuaWZvcm1zLksgKyBjb2xdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGlsZV9iW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gJHtTLnR5cGUudmFsdWV9KDApO1xuICAgICAgfVxuICAgICAgYCxEPVwidmFsdWUgKz0gdGlsZV9hW2tdW2xvY2FsX2lkLnldICogdGlsZV9iW2xvY2FsX2lkLnhdW2tdO1wiKTp0LnRyYW5zQSYmIXQudHJhbnNCPyhSPWBcbiAgICAgIHZhciBjb2wgPSB0aWxlX3Jvd19zdGFydCArIGxvY2FsX2lkLng7XG4gICAgICB2YXIgcm93ID0ga19zdGFydCArIGxvY2FsX2lkLnk7XG4gICAgICBpZiAoY29sIDwgdW5pZm9ybXMuTSAmJiByb3cgPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIHRpbGVfYVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9IGFbcm93ICogdW5pZm9ybXMuTSArIGNvbF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWxlX2FbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke3YudHlwZS52YWx1ZX0oMCk7XG4gICAgICB9XG5cbiAgICAgIGNvbCA9IHRpbGVfY29sX3N0YXJ0ICsgbG9jYWxfaWQueDtcbiAgICAgIHJvdyA9IGtfc3RhcnQgKyBsb2NhbF9pZC55O1xuICAgICAgaWYgKGNvbCA8IHVuaWZvcm1zLk4gJiYgcm93IDwgdW5pZm9ybXMuSykge1xuICAgICAgICB0aWxlX2JbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSBiW3JvdyAqIHVuaWZvcm1zLk4gKyBjb2xdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGlsZV9iW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gJHtTLnR5cGUudmFsdWV9KDApO1xuICAgICAgfVxuICAgICAgYCxEPVwidmFsdWUgKz0gdGlsZV9hW2tdW2xvY2FsX2lkLnldICogdGlsZV9iW2tdW2xvY2FsX2lkLnhdO1wiKTohdC50cmFuc0EmJnQudHJhbnNCPyhSPWBcbiAgICAgIHZhciBjb2wgPSBrX3N0YXJ0ICsgbG9jYWxfaWQueDtcbiAgICAgIHZhciByb3cgPSB0aWxlX3Jvd19zdGFydCArIGxvY2FsX2lkLnk7XG4gICAgICBpZiAoY29sIDwgdW5pZm9ybXMuSyAmJiByb3cgPCB1bmlmb3Jtcy5NKSB7XG4gICAgICAgIHRpbGVfYVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9IGFbcm93ICogdW5pZm9ybXMuSyArIGNvbF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWxlX2FbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke3YudHlwZS52YWx1ZX0oMCk7XG4gICAgICB9XG5cbiAgICAgIGNvbCA9IGtfc3RhcnQgKyBsb2NhbF9pZC54O1xuICAgICAgcm93ID0gdGlsZV9jb2xfc3RhcnQgKyBsb2NhbF9pZC55O1xuICAgICAgaWYgKGNvbCA8IHVuaWZvcm1zLksgJiYgcm93IDwgdW5pZm9ybXMuTikge1xuICAgICAgICB0aWxlX2JbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSBiW3JvdyAqIHVuaWZvcm1zLksgKyBjb2xdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGlsZV9iW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gJHtTLnR5cGUudmFsdWV9KDApO1xuICAgICAgfVxuICAgICAgYCxEPVwidmFsdWUgKz0gdGlsZV9hW2xvY2FsX2lkLnldW2tdICogdGlsZV9iW2xvY2FsX2lkLnhdW2tdO1wiKTohdC50cmFuc0EmJiF0LnRyYW5zQiYmKFI9YFxuICAgICAgdmFyIGNvbCA9IGtfc3RhcnQgKyBsb2NhbF9pZC54O1xuICAgICAgdmFyIHJvdyA9IHRpbGVfcm93X3N0YXJ0ICsgbG9jYWxfaWQueTtcbiAgICAgIGlmIChjb2wgPCB1bmlmb3Jtcy5LICYmIHJvdyA8IHVuaWZvcm1zLk0pIHtcbiAgICAgICAgdGlsZV9hW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdID0gYVtyb3cgKiB1bmlmb3Jtcy5LICsgY29sXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbGVfYVtsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9ICR7di50eXBlLnZhbHVlfSgwKTtcbiAgICAgIH1cblxuICAgICAgY29sID0gdGlsZV9jb2xfc3RhcnQgKyBsb2NhbF9pZC54O1xuICAgICAgcm93ID0ga19zdGFydCArIGxvY2FsX2lkLnk7XG4gICAgICBpZiAoY29sIDwgdW5pZm9ybXMuTiAmJiByb3cgPCB1bmlmb3Jtcy5LKSB7XG4gICAgICAgIHRpbGVfYltsb2NhbF9pZC55XVtsb2NhbF9pZC54XSA9IGJbcm93ICogdW5pZm9ybXMuTiArIGNvbF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aWxlX2JbbG9jYWxfaWQueV1bbG9jYWxfaWQueF0gPSAke1MudHlwZS52YWx1ZX0oMCk7XG4gICAgICB9XG4gICAgICBgLEQ9XCJ2YWx1ZSArPSB0aWxlX2FbbG9jYWxfaWQueV1ba10gKiB0aWxlX2Jba11bbG9jYWxfaWQueF07XCIpO2xldCBHPXQuYWxwaGE9PT0xP1wiXCI6XCJ2YWx1ZSAqPSB1bmlmb3Jtcy5hbHBoYTtcIjtyZXR1cm5gXG4gICR7JC5yZWdpc3RlclVuaWZvcm1zKFApLmRlY2xhcmVWYXJpYWJsZXMoLi4uQSl9XG4gIHZhcjx3b3JrZ3JvdXA+IHRpbGVfYTogYXJyYXk8YXJyYXk8JHt2LnR5cGUuc3RvcmFnZX0sICR7bH0+LCAke2x9PjtcbiAgdmFyPHdvcmtncm91cD4gdGlsZV9iOiBhcnJheTxhcnJheTwke1MudHlwZS5zdG9yYWdlfSwgJHtsfT4sICR7bH0+O1xuICAkeyQubWFpblN0YXJ0KFtsLGwsMV0pfVxuICAgIGxldCB0aWxlX2NvbF9zdGFydCA9ICh3b3JrZ3JvdXBfaW5kZXggJSB1bmlmb3Jtcy5udW1fdGlsZV9uKSAqICR7bH07XG4gICAgbGV0IHRpbGVfcm93X3N0YXJ0ID0gKHdvcmtncm91cF9pbmRleCAvIHVuaWZvcm1zLm51bV90aWxlX24pICogJHtsfTtcbiAgICBsZXQgbnVtX3RpbGVzID0gKHVuaWZvcm1zLksgLSAxKSAvICR7bH0gKyAxO1xuICAgIHZhciBrX3N0YXJ0ID0gMHU7XG4gICAgdmFyIHZhbHVlID0gJHtrLnR5cGUudmFsdWV9KDApO1xuICAgIGZvciAodmFyIHQ6IHUzMiA9IDB1OyB0IDwgbnVtX3RpbGVzOyB0KyspIHtcbiAgICAgICR7Un1cbiAgICAgIGtfc3RhcnQgPSBrX3N0YXJ0ICsgJHtsfTtcbiAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgZm9yICh2YXIgazogdTMyID0gMHU7IGsgPCAke2x9OyBrKyspIHtcbiAgICAgICAgJHtEfVxuICAgICAgfVxuICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuICAgIH1cblxuICAgICR7R31cbiAgICBsZXQgbSA9IHRpbGVfcm93X3N0YXJ0ICsgbG9jYWxfaWQueTtcbiAgICBsZXQgbiA9IHRpbGVfY29sX3N0YXJ0ICsgbG9jYWxfaWQueDtcbiAgICAkeygoKT0+VCE9bnVsbD9gbGV0IGNPZmZzZXQgPSAke1QuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoXCJ2ZWMyKG0sIG4pXCIsayl9OyB2YWx1ZSArPSAke2sudHlwZS52YWx1ZX0odW5pZm9ybXMuYmV0YSkgKiAke1QuZ2V0QnlPZmZzZXQoXCJjT2Zmc2V0XCIpfTtgOlwiXCIpKCl9XG4gICAgaWYgKG0gPCB1bmlmb3Jtcy5NICYmIG4gPCB1bmlmb3Jtcy5OKSB7XG4gICAgICBvdXRwdXRbbSAqIHVuaWZvcm1zLk4gKyBuXSA9IHZhbHVlO1xuICAgIH1cbiAgfWB9O3JldHVybiB1P3tuYW1lOlwiR2VtbVNoYXJlZFwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9YCxpbnB1dERlcGVuZGVuY2llczp5fSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmQsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6cCptfSxwcm9ncmFtVW5pZm9ybXM6X30pLGdldFNoYWRlclNvdXJjZTp4fTp7bmFtZTpcIkdlbW1cIixzaGFkZXJDYWNoZTp7aGludDpgJHt0LmNhY2hlS2V5fWAsaW5wdXREZXBlbmRlbmNpZXM6eX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpkLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChoLzY0KX0scHJvZ3JhbVVuaWZvcm1zOl99KSxnZXRTaGFkZXJTb3VyY2U6Z319LE9kPWU9PntsZXQgdD1lLnRyYW5zQSxyPWUudHJhbnNCLG49ZS5hbHBoYSxvPWUuYmV0YTtyZXR1cm57dHJhbnNBOnQsdHJhbnNCOnIsYWxwaGE6bixiZXRhOm8sY2FjaGVLZXk6YCR7ZS50cmFuc0F9OyR7ZS50cmFuc0J9OyR7ZS5hbHBoYT09PTF9YH19LERkPShlLHQpPT57VmYoZS5pbnB1dHMpLGUuY29tcHV0ZShXZihlLmlucHV0cyx0KSl9fSk7dmFyIGx0LF90LFV0LE50LExmLEdmLEhmLEZmLHFmLEtmLGpmLFlmLE1kLFJkLFVkPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7U2UoKTthZSgpO1tsdCxfdCxVdCxOdF09WzAsMSwyLDNdLExmPWU9PntpZihlWzBdLmRpbXMubGVuZ3RoIT09NCl0aHJvdyBuZXcgRXJyb3IoXCJvbmx5IDQtRCB0ZW5zb3IgaXMgc3VwcG9ydGVkLlwiKTtpZihlWzBdLmRpbXMubGVuZ3RoIT09ZVsxXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCBkaW1lbnNpb25zIG11c3QgYmUgZXF1YWwgdG8gZ3JpZCBkaW1lbnNpb25zXCIpO2lmKGVbMF0uZGltcy5sZW5ndGgtMiE9PWVbMV0uZGltc1tlWzFdLmRpbXMubGVuZ3RoLTFdKXRocm93IG5ldyBFcnJvcihgbGFzdCBkaW1lbnNpb24gb2YgZ3JpZCBtdXN0IGJlIGVxdWFsIHRvICR7ZVswXS5kaW1zLmxlbmd0aC0yfWApO2lmKGVbMF0uZGltc1swXSE9PWVbMV0uZGltc1swXSl0aHJvdyBuZXcgRXJyb3IoXCJncmlkIGJhdGNoIHNpemUgbXVzdCBtYXRjaCBpbnB1dCBiYXRjaCBzaXplXCIpfSxHZj1gXG4gIGZuIGdzX2dldF9jdWJpY19jb2VmZnMoeDogZjMyKSAtPiB2ZWM0PGYzMj4ge1xuICAgIGxldCBjdWJpY19hbHBoYSA9IC0wLjc1ZjtcbiAgICBsZXQgeF9hYnMgPSBhYnMoeCk7XG4gICAgdmFyIGNvZWZmczogdmVjNDxmMzI+O1xuICAgIGNvZWZmc1swXSA9ICgoKGN1YmljX2FscGhhICogKHhfYWJzICsgMSkgLSA1ICogY3ViaWNfYWxwaGEpICogKHhfYWJzICsgMSkgKyA4ICogY3ViaWNfYWxwaGEpICogKHhfYWJzICsgMSkgLSA0ICogY3ViaWNfYWxwaGEpO1xuICAgIGNvZWZmc1sxXSA9ICgoKGN1YmljX2FscGhhICsgMikgKiB4X2FicyAtIChjdWJpY19hbHBoYSArIDMpKSAqIHhfYWJzICogeF9hYnMgKyAxKTtcbiAgICBjb2VmZnNbMl0gPSAoKChjdWJpY19hbHBoYSArIDIpICogKDEgLSB4X2FicykgLSAoY3ViaWNfYWxwaGEgKyAzKSkgKiAoMSAtIHhfYWJzKSAqICgxIC0geF9hYnMpICsgMSk7XG4gICAgY29lZmZzWzNdID0gKCgoY3ViaWNfYWxwaGEgKiAoMiAtIHhfYWJzKSAtIDUgKiBjdWJpY19hbHBoYSkgKiAoMiAtIHhfYWJzKSArIDggKiBjdWJpY19hbHBoYSkgKiAoMiAtIHhfYWJzKSAtIDQgKiBjdWJpY19hbHBoYSk7XG4gICAgcmV0dXJuIGNvZWZmcztcbiAgfVxuYCxIZj1lPT5gXG4gIGZuIGdzX2JpY3ViaWNfaW50ZXJwb2xhdGUocDogbWF0NHg0PCR7ZX0+LCB4OiBmMzIsIHk6IGYzMikgLT4gJHtlfSB7XG4gICAgdmFyIHY6IHZlYzQ8ZjMyPjtcbiAgICB2YXIgY29lZmZzID0gZ3NfZ2V0X2N1YmljX2NvZWZmcyh4KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgdltpXSA9IGNvZWZmc1swXSAqIHBbaV1bMF0gKyBjb2VmZnNbMV0gKiBwW2ldWzFdICsgY29lZmZzWzJdICogcFtpXVsyXSArIGNvZWZmc1szXSAqIHBbaV1bM107XG4gICAgfVxuICAgIGNvZWZmcyA9IGdzX2dldF9jdWJpY19jb2VmZnMoeSk7XG4gICAgbGV0IHBpeGVsID0gJHtlfShjb2VmZnNbMF0gKiB2WzBdICsgY29lZmZzWzFdICogdlsxXSArIGNvZWZmc1syXSAqIHZbMl0gKyBjb2VmZnNbM10gKiB2WzNdKTtcbiAgICByZXR1cm4gcGl4ZWw7XG4gIH1cbmAsRmY9ZT0+YFxuICBmbiBnc19kZW5vcm1hbGl6ZShuOiBmMzIsIGxlbmd0aDogaTMyKSAtPiBmMzIge1xuICAgICR7ZS5hbGlnbkNvcm5lcnM9PT0wP2BcbiAgICAvLyBhbGlnbkNvcm5lcnM6IGZhbHNlID0+IFstMSwgMV0gdG8gWy0wLjUsIGxlbmd0aCAtIDAuNV1cbiAgICByZXR1cm4gKChuICsgMS4wKSAqIGYzMihsZW5ndGgpIC0gMS4wKSAvIDIuMDtcbiAgICBgOmBcbiAgICAvLyBhbGlnbkNvcm5lcnM6IHRydWUgPT4gWy0xLCAxXSB0byBbMCwgbGVuZ3RoIC0gMV1cbiAgICByZXR1cm4gKG4gKyAxLjApIC8gMi4wICogKGYzMihsZW5ndGggLSAxKSk7XG4gICAgYH1cbiAgfVxuYCxxZj1lPT5gXG4gICR7ZS5wYWRkaW5nTW9kZT09PVwicmVmbGVjdGlvblwiP2BcbiAgICAgIGZuIGdzX3JlZmxlY3QoeDogaTMyLCB4X21pbjogZjMyLCB4X21heDogZjMyKSAtPiB1MzIge1xuICAgICAgICB2YXIgZHggPSAwLjA7XG4gICAgICAgIHZhciBmeCA9IGYzMih4KTtcbiAgICAgICAgbGV0IHJhbmdlID0geF9tYXggLSB4X21pbjtcbiAgICAgICAgaWYgKGZ4IDwgeF9taW4pIHtcbiAgICAgICAgICBkeCA9IHhfbWluIC0gZng7XG4gICAgICAgICAgbGV0IG4gPSB1MzIoZHggLyByYW5nZSk7XG4gICAgICAgICAgbGV0IHIgPSBkeCAtIGYzMihuKSAqIHJhbmdlO1xuICAgICAgICAgIGlmIChuICUgMiA9PSAwKSB7XG4gICAgICAgICAgICBmeCA9IHhfbWluICsgcjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnggPSB4X21heCAtIHI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGZ4ID4geF9tYXgpIHtcbiAgICAgICAgICBkeCA9IGZ4IC0geF9tYXg7XG4gICAgICAgICAgbGV0IG4gPSB1MzIoZHggLyByYW5nZSk7XG4gICAgICAgICAgbGV0IHIgPSBkeCAtIGYzMihuKSAqIHJhbmdlO1xuICAgICAgICAgIGlmIChuICUgMiA9PSAwKSB7XG4gICAgICAgICAgICBmeCA9IHhfbWF4IC0gcjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZnggPSB4X21pbiArIHI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1MzIoZngpO1xuICAgICAgfWA6XCJcIn1cbmAsS2Y9KGUsdCxyKT0+YFxuICBmbiBwaXhlbF9hdF9ncmlkKHI6IGkzMiwgYzogaTMyLCBIOiBpMzIsIFc6IGkzMiwgYmF0Y2g6IHUzMiwgY2hhbm5lbDogdTMyLCBib3JkZXI6IHZlYzQ8ZjMyPikgLT4gJHt0fSB7XG4gICAgIHZhciBwaXhlbCA9ICR7dH0oMCk7XG4gICAgIHZhciBpbmRpY2VzID0gdmVjNDx1MzI+KDApO1xuICAgICBpbmRpY2VzWyR7bHR9XSA9IGJhdGNoO1xuICAgICBpbmRpY2VzWyR7X3R9XSA9IGNoYW5uZWw7YCsoKCk9Pntzd2l0Y2goci5wYWRkaW5nTW9kZSl7Y2FzZVwiemVyb3NcIjpyZXR1cm5gXG4gICAgICAgICAgaWYgKHIgPj0gMCAmJiByIDwgSCAmJiBjID49MCAmJiBjIDwgVykge1xuICAgICAgICAgICAgaW5kaWNlc1ske1V0fV0gPSB1MzIocik7XG4gICAgICAgICAgICBpbmRpY2VzWyR7TnR9XSA9IHUzMihjKTtcbiAgICAgICAgICB9XG4gICAgICAgIGA7Y2FzZVwiYm9yZGVyXCI6cmV0dXJuYFxuICAgICAgICAgIGluZGljZXNbJHtVdH1dID0gdTMyKGNsYW1wKHIsIDAsIEggLSAxKSk7XG4gICAgICAgICAgaW5kaWNlc1ske050fV0gPSB1MzIoY2xhbXAoYywgMCwgVyAtIDEpKTtcbiAgICAgICAgYDtjYXNlXCJyZWZsZWN0aW9uXCI6cmV0dXJuYFxuICAgICAgICAgIGluZGljZXNbJHtVdH1dID0gZ3NfcmVmbGVjdChyLCBib3JkZXJbMV0sIGJvcmRlclszXSk7XG4gICAgICAgICAgaW5kaWNlc1ske050fV0gPSBnc19yZWZsZWN0KGMsIGJvcmRlclswXSwgYm9yZGVyWzJdKTtcbiAgICAgICAgYDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgcGFkZGluZyBtb2RlICR7ci5wYWRkaW5nTW9kZX0gaXMgbm90IHN1cHBvcnRlZGApfX0pKCkrYFxuICAgIHJldHVybiAke2UuZ2V0QnlJbmRpY2VzKFwiaW5kaWNlc1wiKX07XG4gIH1cbmAsamY9KGUsdCxyKT0+KCgpPT57c3dpdGNoKHIubW9kZSl7Y2FzZVwibmVhcmVzdFwiOnJldHVybmBcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gcGl4ZWxfYXRfZ3JpZChpMzIocm91bmQoeSkpLCBpMzIocm91bmQoeCkpLCBIX2luLCBXX2luLCBpbmRpY2VzWyR7bHR9XSwgaW5kaWNlc1ske190fV0sIGJvcmRlcik7XG4gICAgICAgIGA7Y2FzZVwiYmlsaW5lYXJcIjpyZXR1cm5gXG4gICAgICAgICAgbGV0IHgxID0gaTMyKGZsb29yKHgpKTtcbiAgICAgICAgICBsZXQgeTEgPSBpMzIoZmxvb3IoeSkpO1xuICAgICAgICAgIGxldCB4MiA9IHgxICsgMTtcbiAgICAgICAgICBsZXQgeTIgPSB5MSArIDE7XG5cbiAgICAgICAgICBsZXQgcDExID0gcGl4ZWxfYXRfZ3JpZCh5MSwgeDEsIEhfaW4sIFdfaW4sIGluZGljZXNbJHtsdH1dLCBpbmRpY2VzWyR7X3R9XSwgYm9yZGVyKTtcbiAgICAgICAgICBsZXQgcDEyID0gcGl4ZWxfYXRfZ3JpZCh5MSwgeDIsIEhfaW4sIFdfaW4sIGluZGljZXNbJHtsdH1dLCBpbmRpY2VzWyR7X3R9XSwgYm9yZGVyKTtcbiAgICAgICAgICBsZXQgcDIxID0gcGl4ZWxfYXRfZ3JpZCh5MiwgeDEsIEhfaW4sIFdfaW4sIGluZGljZXNbJHtsdH1dLCBpbmRpY2VzWyR7X3R9XSwgYm9yZGVyKTtcbiAgICAgICAgICBsZXQgcDIyID0gcGl4ZWxfYXRfZ3JpZCh5MiwgeDIsIEhfaW4sIFdfaW4sIGluZGljZXNbJHtsdH1dLCBpbmRpY2VzWyR7X3R9XSwgYm9yZGVyKTtcblxuICAgICAgICAgIGxldCBkeDIgPSAke3R9KGYzMih4MikgLSB4KTtcbiAgICAgICAgICBsZXQgZHgxID0gJHt0fSh4IC0gZjMyKHgxKSk7XG4gICAgICAgICAgbGV0IGR5MiA9ICR7dH0oZjMyKHkyKSAtIHkpO1xuICAgICAgICAgIGxldCBkeTEgPSAke3R9KHkgLSBmMzIoeTEpKTtcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gZHkyICogKGR4MiAqIHAxMSArIGR4MSAqIHAxMikgKyBkeTEgKiAoZHgyICogcDIxICsgZHgxICogcDIyKTtcbiAgICAgICAgYDtjYXNlXCJiaWN1YmljXCI6cmV0dXJuYFxuICAgICAgICAgIGxldCB4MCA9IGkzMihmbG9vcih4KSkgLSAxO1xuICAgICAgICAgIGxldCB5MCA9IGkzMihmbG9vcih5KSkgLSAxO1xuICAgICAgICAgIHZhciBwOiBtYXQ0eDQ8JHt0fT47XG4gICAgICAgICAgZm9yICh2YXIgaCA9IDA7IGggPCA0OyBoKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIHcgPSAwOyB3IDwgNDsgdysrKSB7XG4gICAgICAgICAgICAgIHBbaF1bd10gPSBwaXhlbF9hdF9ncmlkKGggKyB5MCwgdyArIHgwLCBIX2luLCBXX2luLCBpbmRpY2VzWyR7bHR9XSwgaW5kaWNlc1ske190fV0sIGJvcmRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IGR4ID0geCAtIGYzMih4MCArIDEpO1xuICAgICAgICAgIGxldCBkeSA9IHkgLSBmMzIoeTAgKyAxKTtcbiAgICAgICAgICBsZXQgcmVzdWx0ID0gZ3NfYmljdWJpY19pbnRlcnBvbGF0ZShwLCBkeCwgZHkpO1xuICAgICAgICBgO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBtb2RlICR7ci5tb2RlfSBpcyBub3Qgc3VwcG9ydGVkYCl9fSkoKStgJHtlLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLFwicmVzdWx0XCIpfWAsWWY9KGUsdCk9PntsZXQgcj1FKFwieFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLmxlbmd0aCksbj1bZVsxXS5kaW1zWzBdLGVbMV0uZGltc1sxXSxlWzFdLmRpbXNbMl1dLG89RShcImdyaWRcIixlWzFdLmRhdGFUeXBlLG4ubGVuZ3RoLDIpLGk9W2VbMF0uZGltc1swXSxlWzBdLmRpbXNbMV0sZVsxXS5kaW1zWzFdLGVbMV0uZGltc1syXV07dC5mb3JtYXQ9PT1cIk5IV0NcIiYmKGk9W2VbMF0uZGltc1swXSxlWzFdLmRpbXNbMV0sZVsxXS5kaW1zWzJdLGVbMF0uZGltc1szXV0sW2x0LF90LFV0LE50XT1bMCwzLDEsMl0pO2xldCBhPU0oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLGkubGVuZ3RoKSxkPXIudHlwZS52YWx1ZSxsPUMuc2l6ZShpKSxwPVt7dHlwZToxMixkYXRhOmx9LC4uLk4oZVswXS5kaW1zLG4saSldLG09dT0+YFxuICAke3UucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0X3NpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKHIsbyxhKX1cbiAgJHtHZn1cbiAgJHtIZihkKX1cbiAgJHtGZih0KX1cbiAgJHtxZih0KX1cbiAgJHtLZihyLGQsdCl9XG5cbiAgJHt1Lm1haW5TdGFydCgpfVxuICAgICR7dS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgICBsZXQgSF9pbiA9IGkzMih1bmlmb3Jtcy54X3NoYXBlWyR7VXR9XSk7XG4gICAgICBsZXQgV19pbiA9IGkzMih1bmlmb3Jtcy54X3NoYXBlWyR7TnR9XSk7XG5cbiAgICAgICR7dC5hbGlnbkNvcm5lcnM9PT0wP2BcbiAgICAgIGxldCB4X21pbiA9IC0wLjU7XG4gICAgICBsZXQgeF9tYXggPSBmMzIoV19pbikgLSAwLjU7XG4gICAgICBsZXQgeV9taW4gPSAtMC41O1xuICAgICAgbGV0IHlfbWF4ID0gZjMyKEhfaW4pIC0gMC41O1xuICAgICAgYDpgXG4gICAgICBsZXQgeF9taW4gPSAwLjA7XG4gICAgICBsZXQgeF9tYXggPSBmMzIoV19pbikgLSAxLjA7XG4gICAgICBsZXQgeV9taW4gPSAwLjA7XG4gICAgICBsZXQgeV9tYXggPSBmMzIoSF9pbikgLSAxLjA7XG4gICAgICBgfTtcbiAgICAgIGxldCBib3JkZXIgPSB2ZWM0PGYzMj4oeF9taW4sIHlfbWluLCB4X21heCwgeV9tYXgpO1xuXG4gICAgICBsZXQgaW5kaWNlcyA9ICR7YS5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgIHZhciBncmlkX2luZGljZXMgPSB2ZWMzPHUzMj4oaW5kaWNlc1ske2x0fV0sIGluZGljZXNbJHtVdH1dLCBpbmRpY2VzWyR7TnR9XSk7XG4gICAgICBsZXQgbnh5ID0gJHtvLmdldEJ5SW5kaWNlcyhcImdyaWRfaW5kaWNlc1wiKX07XG4gICAgICB2YXIgeCA9IGdzX2Rlbm9ybWFsaXplKGYzMihueHlbMF0pLCBXX2luKTtcbiAgICAgIHZhciB5ID0gZ3NfZGVub3JtYWxpemUoZjMyKG54eVsxXSksIEhfaW4pO1xuXG4gICAgICAke2pmKGEsZCx0KX1cbiAgfWA7cmV0dXJue25hbWU6XCJHcmlkU2FtcGxlXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5jYWNoZUtleX1gLGlucHV0RGVwZW5kZW5jaWVzOltcInR5cGVcIixcInR5cGVcIl19LGdldFJ1bkRhdGE6dT0+e2xldCBoPUMuc2l6ZShpKTtyZXR1cm57b3V0cHV0czpbe2RpbXM6aSxkYXRhVHlwZTp1WzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoaC82NCl9LHByb2dyYW1Vbmlmb3JtczpwfX0sZ2V0U2hhZGVyU291cmNlOm19fSxNZD0oZSx0KT0+e0xmKGUuaW5wdXRzKSxlLmNvbXB1dGUoWWYoZS5pbnB1dHMsdCkpfSxSZD1lPT5yZSh7YWxpZ25Db3JuZXJzOmUuYWxpZ25fY29ybmVycyxtb2RlOmUubW9kZSxwYWRkaW5nTW9kZTplLnBhZGRpbmdfbW9kZSxmb3JtYXQ6ZS5mb3JtYXR9KX0pO3ZhciBCZSxYZixWZCxOZCxKZix0cixXZCxTbz1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtvZSgpO1NlKCk7TnIoKTtGcigpO2FlKCk7ZHQoKTtCZT0oZSx0KT0+ZS5sZW5ndGg+dCYmZVt0XS5kaW1zLmxlbmd0aD4wP2VbdF06dm9pZCAwLFhmPShlLHQpPT57bGV0IHI9ZVswXSxuPUJlKGUsMSksbz1CZShlLDIpLGk9QmUoZSwzKSxhPUJlKGUsNCksZD1CZShlLDUpLGw9QmUoZSw2KSxwPUJlKGUsNyk7aWYoci5kaW1zLmxlbmd0aCE9PTMmJnIuZGltcy5sZW5ndGghPT01KXRocm93IG5ldyBFcnJvcihcIklucHV0IHF1ZXJ5IGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBvciA1IGRpbWVuc2lvbnNcIik7bGV0IG09ci5kaW1zWzBdLHU9ci5kaW1zWzFdLGg9ci5kaW1zLmxlbmd0aD09PTM/ci5kaW1zWzJdOnQubnVtSGVhZHMqci5kaW1zWzRdLF89dSx5PTAsZz0wLHg9TWF0aC5mbG9vcihoL3QubnVtSGVhZHMpO2lmKGwmJnAmJkMuc2l6ZShsLmRpbXMpJiZDLnNpemUocC5kaW1zKSl7aWYobC5kaW1zLmxlbmd0aCE9PTQpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3Rfa2V5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSA0IGRpbWVuc2lvbnMnKTtpZihsLmRpbXNbMF0hPT1tfHxsLmRpbXNbMV0hPT10Lm51bUhlYWRzfHxsLmRpbXNbM10hPT14KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIHNoYXBlIChiYXRjaF9zaXplLCBudW1faGVhZHMsIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoLCBoZWFkX3NpemUpJyk7aWYocC5kaW1zWzBdIT09bXx8cC5kaW1zWzFdIT09dC5udW1IZWFkc3x8cC5kaW1zWzNdIT09eCl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF92YWx1ZVwiIHNoYXBlIChiYXRjaF9zaXplLCBudW1faGVhZHMsIHBhc3Rfc2VxdWVuY2VfbGVuZ3RoLCBoZWFkX3NpemUpJyk7aWYobC5kaW1zWzJdIT09cC5kaW1zWzJdKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIGFuZCBcInBhc3RfdmFsdWVcIiBzaGFsbCBoYXZlIHNhbWUgZGltIDIgKHBhc3Rfc2VxdWVuY2VfbGVuZ3RoKScpO2lmKHAuZGltcy5sZW5ndGghPT00KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X3ZhbHVlXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSA0IGRpbWVuc2lvbnMnKTt5PWwuZGltc1syXSxnPWwuZGltc1syXX1lbHNlIGlmKGwmJkMuc2l6ZShsLmRpbXMpfHxwJiZDLnNpemUocC5kaW1zKSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBhbmQgXCJwYXN0X3ZhbHVlXCIgc2hhbGwgYmUgYm90aCBwcmVzZW50IG9yIGJvdGggYWJzZW50Jyk7bGV0ICQ7aWYobiYmQy5zaXplKG4uZGltcyk+MCl7aWYoci5kaW1zLmxlbmd0aCE9PTMpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIGRpbWVuc2lvbnMgd2hlbiBrZXkgaXMgZ2l2ZW4nKTtpZihuLmRpbXMubGVuZ3RoPDN8fG4uZGltcy5sZW5ndGg+NSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwia2V5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzLCA0LCBvciA1IGRpbWVuc2lvbnMnKTtpZihyLmRpbXNbMF0hPT1uLmRpbXNbMF0pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgYW5kIFwia2V5XCIgc2hhbGwgaGF2ZSBzYW1lIGRpbSAwIChiYXRjaCBzaXplKScpO2lmKG4uZGltcy5sZW5ndGg9PT0zKXtpZihuLmRpbXNbMl0hPT1yLmRpbXNbMl0pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgYW5kIFwia2V5XCIgc2hhbGwgaGF2ZSBzYW1lIGRpbSAyIChoaWRkZW5fc2l6ZSknKTskPTIsXz1uLmRpbXNbMV19ZWxzZSBpZihuLmRpbXMubGVuZ3RoPT09NSl7aWYobi5kaW1zWzJdIT09dC5udW1IZWFkc3x8bi5kaW1zWzNdIT09Mnx8bi5kaW1zWzRdIT09eCl0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcImtleVwiIHNoYXBlIChiYXRjaF9zaXplLCBrdl9zZXF1ZW5jZV9sZW5ndGgsIG51bV9oZWFkcywgMiwgaGVhZF9zaXplKSBmb3IgcGFja2VkIGt2Jyk7aWYobyl0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcInZhbHVlXCIgYmUgbm9uZSB3aGVuIFwia2V5XCIgaGFzIHBhY2tlZCBrdiBmb3JtYXQuJyk7JD01LF89bi5kaW1zWzFdfWVsc2V7aWYobi5kaW1zWzFdIT09dC5udW1IZWFkc3x8bi5kaW1zWzNdIT09eCl0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcImtleVwiIHNoYXBlIChiYXRjaF9zaXplLCBudW1faGVhZHMsIGt2X3NlcXVlbmNlX2xlbmd0aCwgaGVhZF9zaXplKSBmb3IgcGFzdF9rZXknKTskPTAsXz1uLmRpbXNbMl19fWVsc2V7aWYoci5kaW1zLmxlbmd0aCE9PTUpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSA1IGRpbWVuc2lvbnMgd2hlbiBrZXkgaXMgZW1wdHknKTtpZihyLmRpbXNbMl0hPT10Lm51bUhlYWRzfHxyLmRpbXNbM10hPT0zKXRocm93IG5ldyBFcnJvcignRXhwZWN0IFwicXVlcnlcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwga3Zfc2VxdWVuY2VfbGVuZ3RoLCBudW1faGVhZHMsIDMsIGhlYWRfc2l6ZSkgZm9yIHBhY2tlZCBrdicpOyQ9M31pZihpJiZDLnNpemUoaS5kaW1zKT4wKXtpZihpLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwiYmlhc1wiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMSBkaW1lbnNpb24nKTtpZihuJiZuLmRpbXMubGVuZ3RoPT09NSYmbi5kaW1zWzNdPT09Mil0aHJvdyBuZXcgRXJyb3IoXCJiaWFzIGlzIG5vdCBhbGxvd2VkIGZvciBwYWNrZWQga3YuXCIpfWxldCB2PXkrXyxTPTA7aWYoYSYmQy5zaXplKGEuZGltcyk+MCl7Uz04O2xldCBQPWEuZGltczt0aHJvdyBQLmxlbmd0aD09PTE/UFswXT09PW0/Uz0xOlBbMF09PT0zKm0rMiYmKFM9Myk6UC5sZW5ndGg9PT0yJiZQWzBdPT09bSYmUFsxXT09PXYmJihTPTUpLFM9PT04P25ldyBFcnJvcignSW5wdXQgXCJrZXlfcGFkZGluZ19tYXNrXCIgc2hhcGUgc2hhbGwgYmUgKGJhdGNoX3NpemUpIG9yIChiYXRjaF9zaXplLCB0b3RhbF9zZXF1ZW5jZV9sZW5ndGgpJyk6bmV3IEVycm9yKFwiTWFzayBub3Qgc3VwcG9ydGVkXCIpfWxldCBUPSExLEE9aDtpZihvJiZDLnNpemUoby5kaW1zKT4wKXtpZihvLmRpbXMubGVuZ3RoIT09MyYmby5kaW1zLmxlbmd0aCE9PTQpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInZhbHVlXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIG9yIDQgZGltZW5zaW9ucycpO2lmKHIuZGltc1swXSE9PW8uZGltc1swXSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicXVlcnlcIiBhbmQgXCJ2YWx1ZVwiIHNoYWxsIGhhdmUgc2FtZSBkaW0gMCAoYmF0Y2hfc2l6ZSknKTtpZihvLmRpbXMubGVuZ3RoPT09Myl7aWYoXyE9PW8uZGltc1sxXSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwia2V5XCIgYW5kIFwidmFsdWVcIiBzaGFsbCBoYXZlIHRoZSBzYW1lIGRpbSAxIChrdl9zZXF1ZW5jZV9sZW5ndGgpJyk7QT1vLmRpbXNbMl19ZWxzZXtpZihfIT09by5kaW1zWzJdKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJrZXlcIiBhbmQgXCJ2YWx1ZVwiIHNoYWxsIGhhdmUgdGhlIHNhbWUgZGltIDIgKGt2X3NlcXVlbmNlX2xlbmd0aCknKTtBPW8uZGltc1sxXSpvLmRpbXNbM10sVD0hMH19bGV0IGs9ITE7aWYoYSYmQy5zaXplKGEuZGltcyk+MCl0aHJvdyBuZXcgRXJyb3IoXCJLZXkgcGFkZGluZyBtYXNrIGlzIG5vdCBzdXBwb3J0ZWRcIik7aWYoZCYmQy5zaXplKGQuZGltcyk+MCl7aWYoZC5kaW1zLmxlbmd0aCE9PTQpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImF0dGVudGlvbl9iaWFzXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSA0IGRpbWVuc2lvbnMnKTtpZihkLmRpbXNbMF0hPT1tfHxkLmRpbXNbMV0hPT10Lm51bUhlYWRzfHxkLmRpbXNbMl0hPT11fHxkLmRpbXNbM10hPT12KXRocm93IG5ldyBFcnJvcignRXhwZWN0IFwiYXR0ZW50aW9uX2JpYXNcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwgbnVtX2hlYWRzLCBzZXF1ZW5jZV9sZW5ndGgsIHRvdGFsX3NlcXVlbmNlX2xlbmd0aCknKX1yZXR1cm57YmF0Y2hTaXplOm0sc2VxdWVuY2VMZW5ndGg6dSxwYXN0U2VxdWVuY2VMZW5ndGg6eSxrdlNlcXVlbmNlTGVuZ3RoOl8sdG90YWxTZXF1ZW5jZUxlbmd0aDp2LG1heFNlcXVlbmNlTGVuZ3RoOmcsaW5wdXRIaWRkZW5TaXplOjAsaGlkZGVuU2l6ZTpoLHZIaWRkZW5TaXplOkEsaGVhZFNpemU6eCx2SGVhZFNpemU6TWF0aC5mbG9vcihBL3QubnVtSGVhZHMpLG51bUhlYWRzOnQubnVtSGVhZHMsaXNVbmlkaXJlY3Rpb25hbDohMSxwYXN0UHJlc2VudFNoYXJlQnVmZmVyOiExLG1hc2tGaWx0ZXJWYWx1ZTp0Lm1hc2tGaWx0ZXJWYWx1ZSxtYXNrVHlwZTpTLHNjYWxlOnQuc2NhbGUsYnJvYWRjYXN0UmVzUG9zQmlhczprLHBhc3NQYXN0SW5LdjpULHFrdkZvcm1hdDokfX0sVmQ9ZT0+cmUoey4uLmV9KSxOZD1yZSh7cGVybTpbMCwyLDEsM119KSxKZj0oZSx0LHIsbixvLGksYSk9PntsZXQgZD1bbixvLGldLGw9Qy5zaXplKGQpLHA9W3t0eXBlOjEyLGRhdGE6bH0se3R5cGU6MTIsZGF0YTphfSx7dHlwZToxMixkYXRhOml9XSxtPXU9PntsZXQgaD1NKFwicWt2X3dpdGhfYmlhc1wiLHQuZGF0YVR5cGUsZCksXz1FKFwicWt2XCIsdC5kYXRhVHlwZSxkKSx5PUUoXCJiaWFzXCIsci5kYXRhVHlwZSxkKSxnPVt7bmFtZTpcIm91dHB1dF9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImJpYXNfb2Zmc2V0XCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImhpZGRlbl9zaXplXCIsdHlwZTpcInUzMlwifV07cmV0dXJuYFxuICAke3UucmVnaXN0ZXJVbmlmb3JtcyhnKS5kZWNsYXJlVmFyaWFibGVzKF8seSxoKX1cbiAgJHt1Lm1haW5TdGFydCgpfVxuICAgICR7dS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgbGV0IGJpYXNfb2Zmc2V0X2lkeCA9IChnbG9iYWxfaWR4ICUgdW5pZm9ybXMuaGlkZGVuX3NpemUpICsgdW5pZm9ybXMuYmlhc19vZmZzZXQ7XG5cbiAgICBxa3Zfd2l0aF9iaWFzW2dsb2JhbF9pZHhdID0gcWt2W2dsb2JhbF9pZHhdICsgYmlhc1tiaWFzX29mZnNldF9pZHhdO1xuICB9YH07cmV0dXJuIGUuY29tcHV0ZSh7bmFtZTpcIk11bHRpSGVhZEF0dGVudGlvbkFkZEJpYXNcIixzaGFkZXJDYWNoZTp7aW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiLFwidHlwZVwiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpkLGRhdGFUeXBlOnQuZGF0YVR5cGUsZ3B1RGF0YVR5cGU6MH1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGwvNjQpfSxwcm9ncmFtVW5pZm9ybXM6cH0pLGdldFNoYWRlclNvdXJjZTptfSx7aW5wdXRzOlt0LHJdLG91dHB1dHM6Wy0xXX0pWzBdfSx0cj0oZSx0LHIsbixvLGksYSxkKT0+e2xldCBsPWk7aWYoYSYmQy5zaXplKGEuZGltcyk+MCl7aWYobj09PTEpdGhyb3cgbmV3IEVycm9yKFwiQWRkQmlhc1Jlc2hhcGUgaXMgbm90IGltcGxlbWVudGVkLiBQbGVhc2UgZXhwb3J0IHlvdXIgbW9kZWwgd2l0aCBwYWNrZWQgUUtWIG9yIEtWXCIpO3JldHVybiBsPUpmKGUsaSxhLHQsbixyKm8sZCksbD1sLnJlc2hhcGUoW3QsbixyLG9dKSxyPT09MXx8bj09PTE/bDplLmNvbXB1dGUoUGUobCxOZC5wZXJtKSx7aW5wdXRzOltsXSxvdXRwdXRzOlstMV19KVswXX1lbHNlIHJldHVybiBpLmRpbXMubGVuZ3RoPT09MyYmKGw9aS5yZXNoYXBlKFt0LG4scixvXSkpLHI9PT0xfHxuPT09MT9sOmUuY29tcHV0ZShQZShsLE5kLnBlcm0pLHtpbnB1dHM6W2xdLG91dHB1dHM6Wy0xXX0pWzBdfSxXZD0oZSx0KT0+e2xldCByPVhmKGUuaW5wdXRzLHQpLG49ZS5pbnB1dHNbMF0sbz1CZShlLmlucHV0cywxKSxpPUJlKGUuaW5wdXRzLDIpLGE9QmUoZS5pbnB1dHMsMyksZD1CZShlLmlucHV0cyw0KSxsPUJlKGUuaW5wdXRzLDUpLHA9QmUoZS5pbnB1dHMsNiksbT1CZShlLmlucHV0cyw3KTtpZihuLmRpbXMubGVuZ3RoPT09NSl0aHJvdyBuZXcgRXJyb3IoXCJQYWNrZWQgUUtWIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtpZihvPy5kaW1zLmxlbmd0aD09PTUpdGhyb3cgbmV3IEVycm9yKFwiUGFja2VkIEtWIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtsZXQgdT1vJiZpJiZvLmRpbXMubGVuZ3RoPT09NCYmaS5kaW1zLmxlbmd0aD09PTQsaD10cihlLHIuYmF0Y2hTaXplLHIubnVtSGVhZHMsci5zZXF1ZW5jZUxlbmd0aCxyLmhlYWRTaXplLG4sYSwwKTtpZih1KXJldHVybiBSdChlLGgsbyxpLGQsdm9pZCAwLHAsbSxsLHIpO2lmKCFvfHwhaSl0aHJvdyBuZXcgRXJyb3IoXCJrZXkgYW5kIHZhbHVlIG11c3QgYmUgcHJvdmlkZWRcIik7bGV0IF89dHIoZSxyLmJhdGNoU2l6ZSxyLm51bUhlYWRzLHIua3ZTZXF1ZW5jZUxlbmd0aCxyLmhlYWRTaXplLG8sYSxyLmhpZGRlblNpemUpLHk9dHIoZSxyLmJhdGNoU2l6ZSxyLm51bUhlYWRzLHIua3ZTZXF1ZW5jZUxlbmd0aCxyLnZIZWFkU2l6ZSxpLGEsMipyLmhpZGRlblNpemUpO1J0KGUsaCxfLHksZCx2b2lkIDAscCxtLGwscil9fSk7dmFyIGVoLHRoLHJoLG5oLFRvLExkLEdkLElvPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7U2UoKTthZSgpO2VoPWU9PntpZighZXx8ZS5sZW5ndGg8MSl0aHJvdyBuZXcgRXJyb3IoXCJ0b28gZmV3IGlucHV0c1wiKX0sdGg9KGUsdCk9PntsZXQgcj1bXSxuPXQubnVtT3V0cHV0cztyZXR1cm4gZVsxXS5kaW1zWzBdPjAmJihlWzFdLmdldEJpZ0ludDY0QXJyYXkoKS5mb3JFYWNoKG89PnIucHVzaChOdW1iZXIobykpKSxuPXIubGVuZ3RoKSxyZSh7bnVtT3V0cHV0czpuLGF4aXM6dC5heGlzLHNwbGl0U2l6ZXM6cn0pfSxyaD1lPT5gXG5mbiBjYWxjdWxhdGVPdXRwdXRJbmRleChpbmRleDogdTMyKSAtPiB1MzIge1xuICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgJHtlfXU7IGkgKz0gMXUgKSB7XG4gICAgaWYgKGluZGV4IDwgJHtGKFwidW5pZm9ybXMuc2l6ZV9pbl9zcGxpdF9heGlzXCIsXCJpXCIsZSl9KSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICR7ZX11O1xufWAsbmg9ZT0+e2xldCB0PWUubGVuZ3RoLHI9W107Zm9yKGxldCBuPTA7bjx0Oysrbil7bGV0IG89ZVtuXS5zZXRCeUluZGljZXMoXCJpbmRpY2VzXCIsXCJpbnB1dFtnbG9iYWxfaWR4XVwiKTt0PT09MT9yLnB1c2gobyk6bj09PTA/ci5wdXNoKGBpZiAob3V0cHV0X251bWJlciA9PSAke259dSkgeyAke299IH1gKTpuPT09dC0xP3IucHVzaChgZWxzZSB7ICR7b30gfWApOnIucHVzaChgZWxzZSBpZiAob3V0cHV0X251bWJlciA9PSAke259KSB7ICR7b30gfWApfXJldHVybmBcbiAgICAgIGZuIHdyaXRlQnVmZmVyRGF0YShvdXRwdXRfbnVtYmVyOiB1MzIsIGluZGljZXM6ICR7ZVswXS50eXBlLmluZGljZXN9LCBnbG9iYWxfaWR4OiB1MzIpIHtcbiAgICAgICAgJHtyLmpvaW4oYFxuYCl9XG4gICAgICB9YH0sVG89KGUsdCk9PntsZXQgcj1lWzBdLmRpbXMsbj1DLnNpemUociksbz1lWzBdLmRhdGFUeXBlLGk9Qy5ub3JtYWxpemVBeGlzKHQuYXhpcyxyLmxlbmd0aCksYT1uZXcgQXJyYXkodC5udW1PdXRwdXRzKSxkPUUoXCJpbnB1dFwiLG8sci5sZW5ndGgpLGw9bmV3IEFycmF5KHQubnVtT3V0cHV0cykscD1bXSxtPVtdLHU9MCxoPVt7dHlwZToxMixkYXRhOm59XTtmb3IobGV0IHk9MDt5PHQubnVtT3V0cHV0czt5Kyspe3UrPXQuc3BsaXRTaXplc1t5XSxsW3ldPXU7bGV0IGc9ci5zbGljZSgpO2dbaV09dC5zcGxpdFNpemVzW3ldLG0ucHVzaChnKSxhW3ldPU0oYG91dHB1dCR7eX1gLG8sZy5sZW5ndGgpLHAucHVzaCh7ZGltczptW3ldLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9KX1oLnB1c2goe3R5cGU6MTIsZGF0YTpsfSwuLi5OKHIsLi4ubSkpO2xldCBfPXk9PmBcbiAgJHt5LnJlZ2lzdGVyVW5pZm9ybShcImlucHV0X3NpemVcIixcInUzMlwiKS5yZWdpc3RlclVuaWZvcm0oXCJzaXplX2luX3NwbGl0X2F4aXNcIixcInUzMlwiLGwubGVuZ3RoKS5kZWNsYXJlVmFyaWFibGVzKGQsLi4uYSl9XG4gICR7cmgobC5sZW5ndGgpfVxuICAke25oKGEpfVxuXG4gICR7eS5tYWluU3RhcnQoKX1cbiAgICAke3kuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLmlucHV0X3NpemVcIil9XG5cbiAgICB2YXIgaW5kaWNlcyA9ICR7ZC5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICB2YXIgaW5kZXggPSAke2QuaW5kaWNlc0dldChcImluZGljZXNcIixpKX07XG4gICAgbGV0IG91dHB1dF9udW1iZXIgPSBjYWxjdWxhdGVPdXRwdXRJbmRleChpbmRleCk7XG4gICAgaWYgKG91dHB1dF9udW1iZXIgIT0gMCkge1xuICAgICAgaW5kZXggLT0gJHtGKFwidW5pZm9ybXMuc2l6ZV9pbl9zcGxpdF9heGlzXCIsXCJvdXRwdXRfbnVtYmVyIC0gMXVcIixsLmxlbmd0aCl9O1xuICAgICAgJHtkLmluZGljZXNTZXQoXCJpbmRpY2VzXCIsaSxcImluZGV4XCIpfTtcbiAgICB9XG4gICAgd3JpdGVCdWZmZXJEYXRhKG91dHB1dF9udW1iZXIsIGluZGljZXMsIGdsb2JhbF9pZHgpO1xuICB9YDtyZXR1cm57bmFtZTpcIlNwbGl0XCIsc2hhZGVyQ2FjaGU6e2hpbnQ6dC5jYWNoZUtleSxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxnZXRTaGFkZXJTb3VyY2U6XyxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6cCxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChuLzY0KX0scHJvZ3JhbVVuaWZvcm1zOmh9KX19LExkPShlLHQpPT57ZWgoZS5pbnB1dHMpO2xldCByPWUuaW5wdXRzLmxlbmd0aD09PTE/dDp0aChlLmlucHV0cyx0KTtlLmNvbXB1dGUoVG8oZS5pbnB1dHMscikse2lucHV0czpbMF19KX0sR2Q9ZT0+e2xldCB0PWUuYXhpcyxyPWUuc3BsaXRTaXplcyxuPWUubnVtT3V0cHV0czwwP3IubGVuZ3RoOmUubnVtT3V0cHV0cztpZihuIT09ci5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwibnVtT3V0cHV0cyBhbmQgc3BsaXRTaXplcyBsZW5naCBtdXN0IGJlIGVxdWFsXCIpO3JldHVybiByZSh7YXhpczp0LG51bU91dHB1dHM6bixzcGxpdFNpemVzOnJ9KX19KTt2YXIgb2gsaWgsSGQsRmQscWQ9VSgoKT0+e1widXNlIHN0cmljdFwiO1NlKCk7RnIoKTtTbygpO0lvKCk7ZHQoKTtvaD0oZSx0KT0+e2lmKHQuZG9Sb3RhcnkpdGhyb3cgbmV3IEVycm9yKFwiR3JvdXBRdWVycnlBdHRlbnRpb24gZG9fcm90YXJ5IGF0dHJpYnV0ZSBpcyBub3Qgc3VwcG9ydGVkXCIpO2lmKHQuZG9Sb3RhcnkmJmUubGVuZ3RoPD03KXRocm93IG5ldyBFcnJvcihcImNvc19jYWNoZSBhbmQgc2luX2NhY2hlIGlucHV0cyBhcmUgcmVxdWlyZWQgaWYgZG9fcm90YXJ5IGlzIHNwZWNpZmllZFwiKTtsZXQgcj1lWzBdLG49ZVsxXSxvPWVbMl0saT1lWzNdLGE9ZVs0XTtpZih0LmxvY2FsV2luZG93U2l6ZSE9PS0xKXRocm93IG5ldyBFcnJvcihcIkxvY2FsIGF0dGVudGlvbiBpcyBub3Qgc3VwcG9ydGVkXCIpO2lmKHQuc29mdGNhcCE9PTApdGhyb3cgbmV3IEVycm9yKFwiU29mdGNhcCBpcyBub3Qgc3VwcG9ydGVkXCIpO2lmKHQucm90YXJ5SW50ZXJsZWF2ZWQhPT0wKXRocm93IG5ldyBFcnJvcihcIlJvdGFyeSBpbnRlcmxlYXZlZCBpcyBub3Qgc3VwcG9ydGVkXCIpO2lmKHQuc21vb3RoU29mdG1heCl0aHJvdyBuZXcgRXJyb3IoXCJTbW9vdGggc29mdG1heCBpcyBub3Qgc3VwcG9ydGVkXCIpO2lmKHIuZGltcy5sZW5ndGghPT0zJiZyLmRpbXMubGVuZ3RoIT09NSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBxdWVyeSBpcyBleHBlY3RlZCB0byBoYXZlIDMgb3IgNSBkaW1lbnNpb25zXCIpO2xldCBkPSExLGw9ci5kaW1zWzBdLHA9ci5kaW1zWzFdLG09ci5kaW1zLmxlbmd0aD09PTM/ZD9yLmRpbXNbMl0vMzpyLmRpbXNbMl06dC5udW1IZWFkcypyLmRpbXNbNF0sdT1wLGg9MCxfPSFufHxuLmRpbXMubGVuZ3RoPT09MCx5PU1hdGguZmxvb3IoXz9tLyh0Lm51bUhlYWRzKzIqdC5rdk51bUhlYWRzKTptL3QubnVtSGVhZHMpO18mJihtPXkqdC5udW1IZWFkcyk7bGV0IGc9aSYmaS5kaW1zLmxlbmd0aCE9PTAseD1hJiZhLmRpbXMubGVuZ3RoIT09MDtpZihnJiZpLmRpbXMubGVuZ3RoPT09NCYmaS5kaW1zWzBdPT09bCYmaS5kaW1zWzFdIT09dC5rdk51bUhlYWRzJiZpLmRpbXNbMl09PT10Lmt2TnVtSGVhZHMmJmkuZGltc1szXT09PXkpdGhyb3cgbmV3IEVycm9yKFwiQlNOSCBwYXN0S2V5L3Bhc3RWYWx1ZSBpcyBub3Qgc3VwcG9ydGVkXCIpO2lmKGcmJngpe2lmKGkuZGltcy5sZW5ndGghPT00KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJwYXN0X2tleVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgNCBkaW1lbnNpb25zJyk7aWYoYS5kaW1zLmxlbmd0aCE9PTQpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInBhc3RfdmFsdWVcIiBpcyBleHBlY3RlZCB0byBoYXZlIDQgZGltZW5zaW9ucycpO2g9aS5kaW1zWzJdfWVsc2UgaWYoZ3x8eCl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBhbmQgXCJwYXN0X3ZhbHVlXCIgc2hhbGwgYmUgYm90aCBwcmVzZW50IG9yIGJvdGggYWJzZW50Jyk7bGV0IHY9MTtpZihuJiZuLmRpbXMubGVuZ3RoPjApe2lmKHIuZGltcy5sZW5ndGghPT0zKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBkaW1lbnNpb25zIHdoZW4ga2V5IGlzIGdpdmVuJyk7aWYobi5kaW1zLmxlbmd0aDwzfHxuLmRpbXMubGVuZ3RoPjUpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImtleVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMywgNCwgb3IgNSBkaW1lbnNpb25zJyk7aWYoci5kaW1zWzBdIT09bi5kaW1zWzBdKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJxdWVyeVwiIGFuZCBcImtleVwiIHNoYWxsIGhhdmUgc2FtZSBkaW0gMCAoYmF0Y2ggc2l6ZSknKTtpZihuLmRpbXMubGVuZ3RoPT09Myl7aWYoci5kaW1zWzJdJW4uZGltc1syXSE9PTApdGhyb3cgbmV3IEVycm9yKCdEaW1lbnNpb24gMiBvZiBcInF1ZXJ5XCIgc2hvdWxkIGJlIGEgbXVsdGlwbGUgb2YgXCJrZXlcIicpO3U9bi5kaW1zWzFdfWVsc2UgaWYobi5kaW1zLmxlbmd0aD09PTUpe2lmKG4uZGltc1syXSE9PXQubnVtSGVhZHN8fG4uZGltc1szXSE9PTJ8fG4uZGltc1s0XSE9PXkpdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJrZXlcIiBzaGFwZSAoYmF0Y2hfc2l6ZSwga3Zfc2VxdWVuY2VfbGVuZ3RoLCBudW1faGVhZHMsIDIsIGhlYWRfc2l6ZSkgZm9yIHBhY2tlZCBrdicpO2lmKG8pdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJ2YWx1ZVwiIGJlIG5vbmUgd2hlbiBcImtleVwiIGhhcyBwYWNrZWQga3YgZm9ybWF0LicpO3U9bi5kaW1zWzFdfWVsc2V7aWYobi5kaW1zWzFdIT09dC5udW1IZWFkc3x8bi5kaW1zWzNdIT09eSl0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdCBcImtleVwiIHNoYXBlIChiYXRjaF9zaXplLCBudW1faGVhZHMsIGt2X3NlcXVlbmNlX2xlbmd0aCwgaGVhZF9zaXplKSBmb3IgcGFzdF9rZXknKTt1PW4uZGltc1syXX19ZWxzZXtpZihyLmRpbXMubGVuZ3RoIT09MyYmci5kaW1zLmxlbmd0aCE9PTUpdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAzIG9yIDUgZGltZW5zaW9ucyB3aGVuIGtleSBpcyBlbXB0eScpO2lmKHIuZGltcy5sZW5ndGg9PT01JiYoci5kaW1zWzJdIT09dC5udW1IZWFkc3x8ci5kaW1zWzNdIT09MykpdGhyb3cgbmV3IEVycm9yKCdFeHBlY3QgXCJxdWVyeVwiIHNoYXBlIChiYXRjaF9zaXplLCBrdl9zZXF1ZW5jZV9sZW5ndGgsIG51bV9oZWFkcywgMywgaGVhZF9zaXplKSBmb3IgcGFja2VkIGt2Jyk7dj0zfWxldCBTPTAsVD0hMSxBPXQua3ZOdW1IZWFkcz95KnQua3ZOdW1IZWFkczptO2lmKG8mJm8uZGltcy5sZW5ndGg+MCl7aWYoby5kaW1zLmxlbmd0aCE9PTMmJm8uZGltcy5sZW5ndGghPT00KXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJ2YWx1ZVwiIGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBvciA0IGRpbWVuc2lvbnMnKTtpZihyLmRpbXNbMF0hPT1vLmRpbXNbMF0pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcInF1ZXJ5XCIgYW5kIFwidmFsdWVcIiBzaGFsbCBoYXZlIHNhbWUgZGltIDAgKGJhdGNoX3NpemUpJyk7aWYoby5kaW1zLmxlbmd0aD09PTMpe2lmKHUhPT1vLmRpbXNbMV0pdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBcImtleVwiIGFuZCBcInZhbHVlXCIgc2hhbGwgaGF2ZSB0aGUgc2FtZSBkaW0gMSAoa3Zfc2VxdWVuY2VfbGVuZ3RoKScpO0E9by5kaW1zWzJdfWVsc2V7aWYodSE9PW8uZGltc1syXSl0aHJvdyBuZXcgRXJyb3IoJ0lucHV0IFwicGFzdF9rZXlcIiBhbmQgXCJwYXN0X3ZhbHVlXCIgc2hhbGwgaGF2ZSB0aGUgc2FtZSBkaW0gMiAoa3Zfc2VxdWVuY2VfbGVuZ3RoKScpO0E9by5kaW1zWzFdKm8uZGltc1szXSxUPSEwfX1sZXQgaz1lLmxlbmd0aD40P2VbNV06dm9pZCAwO2lmKGsmJmsuZGltcy5sZW5ndGghPT0xJiZrLmRpbXNbMF0hPT1sKXRocm93IG5ldyBFcnJvcignSW5wdXQgXCJzZXFsZW5zXCIgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAxIGRpbWVuc2lvbiBhbmQgdGhlIHNhbWUgZGltIDAgYXMgYmF0Y2hfc2l6ZScpO2xldCBQPS0xLEQ9LTEsUj0hMTtyZXR1cm57YmF0Y2hTaXplOmwsc2VxdWVuY2VMZW5ndGg6cCxwYXN0U2VxdWVuY2VMZW5ndGg6aCxrdlNlcXVlbmNlTGVuZ3RoOnUsdG90YWxTZXF1ZW5jZUxlbmd0aDpQLG1heFNlcXVlbmNlTGVuZ3RoOkQsaW5wdXRIaWRkZW5TaXplOjAsaGlkZGVuU2l6ZTptLHZIaWRkZW5TaXplOkEsaGVhZFNpemU6eSx2SGVhZFNpemU6TWF0aC5mbG9vcihBL3Qua3ZOdW1IZWFkcyksbnVtSGVhZHM6dC5udW1IZWFkcyxrdk51bUhlYWRzOnQua3ZOdW1IZWFkcyxuUmVwczp0Lm51bUhlYWRzL3Qua3ZOdW1IZWFkcyxwYXN0UHJlc2VudFNoYXJlQnVmZmVyOiExLG1hc2tUeXBlOlMsc2NhbGU6dC5zY2FsZSxicm9hZGNhc3RSZXNQb3NCaWFzOlIscGFzc1Bhc3RJbkt2OlQscWt2Rm9ybWF0OnZ9fSxpaD1yZSh7cGVybTpbMCwyLDEsM119KSxIZD0oZSx0LHIpPT57bGV0IG49dCxvPXIua3ZOdW1IZWFkcztyZXR1cm4gdC5kaW1zLmxlbmd0aD09PTMmJnIua3ZTZXF1ZW5jZUxlbmd0aCE9PTAmJihuPXQucmVzaGFwZShbci5iYXRjaFNpemUsci5rdlNlcXVlbmNlTGVuZ3RoLG8sci5oZWFkU2l6ZV0pLG49ZS5jb21wdXRlKFBlKG4saWgucGVybSkse2lucHV0czpbbl0sb3V0cHV0czpbLTFdfSlbMF0pLG59LEZkPShlLHQpPT57bGV0IHI9b2goZS5pbnB1dHMsdCk7aWYoZS5pbnB1dHNbMF0uZGltcy5sZW5ndGg9PT01KXRocm93IG5ldyBFcnJvcihcIlBhY2tlZCBRS1YgaXMgbm90IGltcGxlbWVudGVkXCIpO2lmKGUuaW5wdXRzWzFdPy5kaW1zLmxlbmd0aD09PTUpdGhyb3cgbmV3IEVycm9yKFwiUGFja2VkIEtWIGlzIG5vdCBpbXBsZW1lbnRlZFwiKTtsZXQgbj1lLmlucHV0c1swXSxvPWUuaW5wdXRzWzFdJiZlLmlucHV0c1sxXS5kaW1zLmxlbmd0aD4wP2UuaW5wdXRzWzFdOnZvaWQgMCxpPWUuaW5wdXRzWzJdJiZlLmlucHV0c1syXS5kaW1zLmxlbmd0aD4wP2UuaW5wdXRzWzJdOnZvaWQgMCxhPWUuaW5wdXRzWzNdJiZlLmlucHV0c1szXS5kaW1zLmxlbmd0aCE9PTA/ZS5pbnB1dHNbM106dm9pZCAwLGQ9ZS5pbnB1dHNbNF0mJmUuaW5wdXRzWzRdLmRpbXMubGVuZ3RoIT09MD9lLmlucHV0c1s0XTp2b2lkIDAsbD1lLmlucHV0cy5sZW5ndGg+ND9lLmlucHV0c1s1XTp2b2lkIDAscD1lLmlucHV0cy5sZW5ndGg+NT9lLmlucHV0c1s2XTp2b2lkIDAsbT1yLmt2TnVtSGVhZHM/ci5rdk51bUhlYWRzOnIubnVtSGVhZHMsdT1yZSh7YXhpczoyLG51bU91dHB1dHM6MyxzcGxpdFNpemVzOltyLm51bUhlYWRzKnIuaGVhZFNpemUsbSpyLmhlYWRTaXplLG0qci5oZWFkU2l6ZV19KSxbaCxfLHldPSFvJiYhaT9lLmNvbXB1dGUoVG8oW25dLHUpLHtpbnB1dHM6W25dLG91dHB1dHM6Wy0xLC0xLC0xXX0pOltuLG8saV0sZz10cihlLHIuYmF0Y2hTaXplLHIubnVtSGVhZHMsci5zZXF1ZW5jZUxlbmd0aCxyLmhlYWRTaXplLGgsdm9pZCAwLDApO1J0KGUsZyxIZChlLF8sciksSGQoZSx5LHIpLHZvaWQgMCx2b2lkIDAsYSxkLHZvaWQgMCxyLGwscCl9fSk7dmFyIEtkLGFoLHNoLGpkLFlkPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7ZHQoKTthZSgpO0tkPShlLHQscixuLG8saSxhLGQpPT57bGV0IGw9bWUoaSkscD1sPT09MT9cImYzMlwiOmB2ZWMke2x9ZmAsbT1sPT09MT9cInZlYzJmXCI6YG1hdDJ4JHtsfWZgLHU9byphLGg9NjQ7dT09PTEmJihoPTI1Nik7bGV0IF89W28sYSxpL2xdLHk9W28sYSwyXSxnPVtcInJhbmtcIixcInR5cGVcIixcInR5cGVcIl0seD1bXTt4LnB1c2goLi4uTihfLHkpKTtsZXQgJD12PT57bGV0IFM9RShcInhcIix0LmRhdGFUeXBlLDMsbCksVD1FKFwic2NhbGVcIixyLmRhdGFUeXBlLHIuZGltcyksQT1FKFwiYmlhc1wiLG4uZGF0YVR5cGUsbi5kaW1zKSxrPU0oXCJvdXRwdXRcIiwxLDMsMiksUD1bUyxULEEsa107cmV0dXJuYFxuICB2YXI8d29ya2dyb3VwPiB3b3JrZ3JvdXBfc2hhcmVkIDogYXJyYXk8JHttfSwgJHtofT47XG4gIGNvbnN0IHdvcmtncm91cF9zaXplID0gJHtofXU7XG4gICR7di5kZWNsYXJlVmFyaWFibGVzKC4uLlApfVxuICAke3YubWFpblN0YXJ0KGgpfVxuICAgIGxldCBiYXRjaCA9IHdvcmtncm91cF9pbmRleCAvIHVuaWZvcm1zLnhfc2hhcGVbMV07XG4gICAgbGV0IGNoYW5uZWwgPSB3b3JrZ3JvdXBfaW5kZXggJSB1bmlmb3Jtcy54X3NoYXBlWzFdO1xuICAgIGxldCBoaWdodCA9IHVuaWZvcm1zLnhfc2hhcGVbMl07XG4gICAgLy8gaW5pdGlhbGl6ZSB3b3JrZ3JvdXAgbWVtb3J5XG4gICAgdmFyIHN1bSA9ICR7cH0oMCk7XG4gICAgdmFyIHNxdWFyZWRfc3VtID0gJHtwfSgwKTtcbiAgICBmb3IgKHZhciBoID0gbG9jYWxfaWR4OyBoIDwgaGlnaHQ7IGggKz0gd29ya2dyb3VwX3NpemUpIHtcbiAgICAgIGxldCB2YWx1ZSA9ICR7cH0oJHtTLmdldChcImJhdGNoXCIsXCJjaGFubmVsXCIsXCJoXCIpfSk7XG4gICAgICBzdW0gKz0gdmFsdWU7XG4gICAgICBzcXVhcmVkX3N1bSArPSB2YWx1ZSAqIHZhbHVlO1xuICAgIH1cbiAgICB3b3JrZ3JvdXBfc2hhcmVkW2xvY2FsX2lkeF0gPSAke219KHN1bSwgc3F1YXJlZF9zdW0pO1xuICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgIGZvciAodmFyIGN1cnJTaXplID0gd29ya2dyb3VwX3NpemUgPj4gMTsgIGN1cnJTaXplID4gMDsgY3VyclNpemUgPSBjdXJyU2l6ZSA+PiAxKSB7XG4gICAgICBpZiAobG9jYWxfaWR4IDwgY3VyclNpemUpIHtcbiAgICAgICAgd29ya2dyb3VwX3NoYXJlZFtsb2NhbF9pZHhdID0gd29ya2dyb3VwX3NoYXJlZFtsb2NhbF9pZHhdICsgd29ya2dyb3VwX3NoYXJlZFtsb2NhbF9pZHggKyBjdXJyU2l6ZV07XG4gICAgICB9XG4gICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgfVxuICAgIGlmIChsb2NhbF9pZHggPT0gMCkge1xuICAgICAgbGV0IHN1bV9maW5hbCA9ICR7RmUoXCJ3b3JrZ3JvdXBfc2hhcmVkWzBdWzBdXCIsbCl9IC8gZjMyKGhpZ2h0ICogJHtsfSk7XG4gICAgICBsZXQgc3F1YXJlZF9zdW1fZmluYWwgPSAke0ZlKFwid29ya2dyb3VwX3NoYXJlZFswXVsxXVwiLGwpfSAvIGYzMihoaWdodCAqICR7bH0pO1xuXG4gICAgICBsZXQgaW52X3N0ZF9kZXYgPSBpbnZlcnNlU3FydChzcXVhcmVkX3N1bV9maW5hbCAtIHN1bV9maW5hbCAqIHN1bV9maW5hbCArIGYzMigke2R9KSk7XG4gICAgICBsZXQgY2hhbm5lbF9zY2FsZSA9IGludl9zdGRfZGV2ICogZjMyKHNjYWxlW2NoYW5uZWxdKTtcbiAgICAgIGxldCBjaGFubmVsX3NoaWZ0ID0gZjMyKGJpYXNbY2hhbm5lbF0pIC0gc3VtX2ZpbmFsICogY2hhbm5lbF9zY2FsZTtcbiAgICAgIG91dHB1dFt3b3JrZ3JvdXBfaW5kZXhdID0gdmVjMmYoY2hhbm5lbF9zY2FsZSwgY2hhbm5lbF9zaGlmdCk7XG4gICAgfVxuICB9YH07cmV0dXJuIGUuY29tcHV0ZSh7bmFtZTpcIkluc3RhbmNlTm9ybUNvbXB1dGVDaGFubmVsU2NhbGVTaGlmdFwiLHNoYWRlckNhY2hlOntoaW50OmAke2x9OyR7ZH07JHtofWAsaW5wdXREZXBlbmRlbmNpZXM6Z30sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczp5LGRhdGFUeXBlOjF9XSxkaXNwYXRjaEdyb3VwOnt4OnV9LHByb2dyYW1Vbmlmb3Jtczp4fSksZ2V0U2hhZGVyU291cmNlOiR9LHtpbnB1dHM6W3QscixuXSxvdXRwdXRzOlstMV19KVswXX0sYWg9KGUsdCxyKT0+e2xldCBuPXRbMF0uZGltcyxvPW4saT0yLGE9blswXSxkPW5bMV0sbD1DLnNpemVGcm9tRGltZW5zaW9uKG4saSkscD1tZShsKSxtPUMuc2l6ZShvKS9wLHU9S2QoZSx0WzBdLHRbMV0sdFsyXSxhLGwsZCxyLmVwc2lsb24pLGg9W2EsZCxsL3BdLF89W2EsZF0seT1bXCJ0eXBlXCIsXCJub25lXCJdLGc9eD0+e2xldCAkPUUoXCJ4XCIsdFswXS5kYXRhVHlwZSxoLmxlbmd0aCxwKSx2PUUoXCJzY2FsZV9zaGlmdFwiLDEsXy5sZW5ndGgsMiksUz1NKFwib3V0cHV0XCIsdFswXS5kYXRhVHlwZSxoLmxlbmd0aCxwKSxUPVskLHYsU107cmV0dXJuYFxuICAke3gucmVnaXN0ZXJVbmlmb3JtKFwib3V0cHV0X3NpemVcIixcInUzMlwiKS5kZWNsYXJlVmFyaWFibGVzKC4uLlQpfVxuICAke3gubWFpblN0YXJ0KCl9XG4gICR7eC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgICBsZXQgb3V0cHV0SW5kaWNlcyA9ICR7Uy5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgIGxldCBiYXRjaCA9IG91dHB1dEluZGljZXNbMF07XG4gICAgICBsZXQgY2hhbm5lbCA9IG91dHB1dEluZGljZXNbMV07XG4gICAgICBsZXQgc2NhbGVfc2hpZnQgPSAke3YuZ2V0QnlJbmRpY2VzKFwidmVjMjx1MzI+KGJhdGNoLCBjaGFubmVsKVwiKX07XG4gICAgICBsZXQgdmFsdWUgPSAkeyQuZ2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIpfSAqICR7Uy50eXBlLnZhbHVlfShzY2FsZV9zaGlmdC54KSArICR7Uy50eXBlLnZhbHVlfShzY2FsZV9zaGlmdC55KTtcbiAgICAgICR7Uy5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixcInZhbHVlXCIpfTtcbiAgfWB9O2UuY29tcHV0ZSh7bmFtZTpcIkluc3RhbmNlTm9ybWFsaXphdGlvblwiLHNoYWRlckNhY2hlOntoaW50OmAke3B9YCxpbnB1dERlcGVuZGVuY2llczp5fSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm8sZGF0YVR5cGU6dFswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKG0vNjQpfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjEyLGRhdGE6bX0sLi4uTihoLF8saCldfSksZ2V0U2hhZGVyU291cmNlOmd9LHtpbnB1dHM6W3RbMF0sdV19KX0sc2g9KGUsdCxyKT0+e2xldCBuPXRbMF0uZGltcyxvPW4saT1uWzBdLGE9bltuLmxlbmd0aC0xXSxkPUMuc2l6ZUZyb21EaW1lbnNpb24obiwxKS9hLGw9bWUoYSkscD1DLnNpemUobykvbCxtPVt7dHlwZToxMixkYXRhOmR9LHt0eXBlOjEyLGRhdGE6TWF0aC5mbG9vcihhL2wpfV0sdT1bXCJ0eXBlXCIsXCJ0eXBlXCJdLGg9ITEsXz1bMCxuLmxlbmd0aC0xXTtmb3IobGV0ICQ9MDskPG4ubGVuZ3RoLTI7JCsrKWg9aHx8blskKzFdIT09MSxfLnB1c2goJCsxKTtoPWgmJm5bbi5sZW5ndGgtMV0hPT0xO2xldCB5PWg/ZS5jb21wdXRlKFBlKGUuaW5wdXRzWzBdLF8pLHtpbnB1dHM6W2UuaW5wdXRzWzBdXSxvdXRwdXRzOlstMV19KVswXTplLmlucHV0c1swXS5yZXNoYXBlKEFycmF5LmZyb20oe2xlbmd0aDpuLmxlbmd0aH0sKCQsdik9Pm5bX1t2XV0pKSxnPUtkKGUseSx0WzFdLHRbMl0saSxkLGEsci5lcHNpbG9uKSx4PSQ9PntsZXQgdj1fZSh0WzBdLmRhdGFUeXBlKSxTPWw9PT0xP1widmVjMmZcIjpgbWF0JHtsfXgyZmAsVD1QPT57bGV0IEQ9UD09PTA/XCJ4XCI6XCJ5XCIsUj1sPT09MT9cImYzMlwiOmB2ZWMke2x9ZmA7c3dpdGNoKGwpe2Nhc2UgMTpyZXR1cm5gJHt2fSgke1J9KHNjYWxlLiR7RH0pKWA7Y2FzZSAyOnJldHVybmB2ZWMyPCR7dn0+KCR7Un0oc2NhbGVbMF0uJHtEfSwgc2NhbGVbMV0uJHtEfSkpYDtjYXNlIDQ6cmV0dXJuYHZlYzQ8JHt2fT4oJHtSfShzY2FsZVswXS4ke0R9LCBzY2FsZVsxXS4ke0R9LCBzY2FsZVsyXS4ke0R9LCBzY2FsZVszXS4ke0R9KSlgO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBOb3Qgc3VwcG9ydGVkIGNvbXBvZW50cyAke2x9YCl9fSxBPUUoXCJpbnB1dFwiLHRbMF0uZGF0YVR5cGUsdFswXS5kaW1zLGwpLGs9TShcIm91dHB1dFwiLHRbMF0uZGF0YVR5cGUsbyxsKTtyZXR1cm5gXG4gIEBncm91cCgwKSBAYmluZGluZygwKSB2YXI8c3RvcmFnZSwgcmVhZD4gaW5wdXQgOiBhcnJheTwke0EudHlwZS5zdG9yYWdlfT47XG4gIEBncm91cCgwKSBAYmluZGluZygxKSB2YXI8c3RvcmFnZSwgcmVhZD4gc2NhbGVfaW5wdXQgOiBhcnJheTwke1N9PjtcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDIpIHZhcjxzdG9yYWdlLCByZWFkX3dyaXRlPiBvdXRwdXQgOiBhcnJheTwke2sudHlwZS5zdG9yYWdlfT47XG4gIHN0cnVjdCBVbmlmb3JtcyB7SDogdTMyLCBDIDogdTMyfTtcbiAgQGdyb3VwKDApIEBiaW5kaW5nKDMpIHZhcjx1bmlmb3JtPiB1bmlmb3JtczogVW5pZm9ybXM7XG5cbiAgJHskLm1haW5TdGFydCgpfVxuICAgIGxldCBjdXJyZW50X2ltYWdlX251bWJlciA9IGdsb2JhbF9pZHggLyAodW5pZm9ybXMuQyAqIHVuaWZvcm1zLkgpO1xuICAgIGxldCBjdXJyZW50X2NoYW5uZWxfbnVtYmVyID0gZ2xvYmFsX2lkeCAlIHVuaWZvcm1zLkM7XG5cbiAgICBsZXQgc2NhbGVfb2Zmc2V0ID0gY3VycmVudF9pbWFnZV9udW1iZXIgKiB1bmlmb3Jtcy5DICsgY3VycmVudF9jaGFubmVsX251bWJlcjtcbiAgICBsZXQgc2NhbGUgPSBzY2FsZV9pbnB1dFtzY2FsZV9vZmZzZXRdO1xuICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IGZtYShpbnB1dFtnbG9iYWxfaWR4XSwgJHtUKDApfSwgJHtUKDEpfSk7XG4gIH1gfTtlLmNvbXB1dGUoe25hbWU6XCJJbnN0YW5jZU5vcm1hbGl6YXRpb25OSFdDXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7bH1gLGlucHV0RGVwZW5kZW5jaWVzOnV9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6byxkYXRhVHlwZTp0WzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwocC82NCl9LHByb2dyYW1Vbmlmb3JtczptfSksZ2V0U2hhZGVyU291cmNlOnh9LHtpbnB1dHM6W3RbMF0sZ119KX0samQ9KGUsdCk9Pnt0LmZvcm1hdD09PVwiTkhXQ1wiP3NoKGUsZS5pbnB1dHMsdCk6YWgoZSxlLmlucHV0cyx0KX19KTt2YXIgdWgsZGgsWmQsUWQ9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTthZSgpO3VoPWU9PntpZighZXx8ZS5sZW5ndGg8Mil0aHJvdyBuZXcgRXJyb3IoXCJsYXllck5vcm0gcmVxdWlyZXMgYXQgbGVhc3QgMiBpbnB1dHMuXCIpfSxkaD0oZSx0LHIpPT57bGV0IG49dC5zaW1wbGlmaWVkLG89ZVswXS5kaW1zLGk9ZVsxXSxhPSFuJiZlWzJdLGQ9byxsPUMubm9ybWFsaXplQXhpcyh0LmF4aXMsby5sZW5ndGgpLHA9Qy5zaXplVG9EaW1lbnNpb24obyxsKSxtPUMuc2l6ZUZyb21EaW1lbnNpb24obyxsKSx1PUMuc2l6ZShpLmRpbXMpLGg9YT9DLnNpemUoYS5kaW1zKTowO2lmKHUhPT1tfHxhJiZoIT09bSl0aHJvdyBuZXcgRXJyb3IoYFNpemUgb2YgWC5zaGFwZSgpW2F4aXM6XSA9PSAke219LlxuICAgICAgIFNpemUgb2Ygc2NhbGUgYW5kIGJpYXMgKGlmIHByb3ZpZGVkKSBtdXN0IG1hdGNoIHRoaXMuXG4gICAgICAgR290IHNjYWxlIHNpemUgb2YgJHt1fSBhbmQgYmlhcyBzaXplIG9mICR7aH1gKTtsZXQgXz1bXTtmb3IobGV0IEE9MDtBPG8ubGVuZ3RoOysrQSlBPGw/Xy5wdXNoKG9bQV0pOl8ucHVzaCgxKTtsZXQgeT1tZShtKSxnPVtcInR5cGVcIixcInR5cGVcIl0seD1be3R5cGU6MTIsZGF0YTpwfSx7dHlwZToxLGRhdGE6bX0se3R5cGU6MTIsZGF0YTpNYXRoLmZsb29yKG0veSl9LHt0eXBlOjEsZGF0YTp0LmVwc2lsb259XTthJiZnLnB1c2goXCJ0eXBlXCIpO2xldCAkPXI+MSx2PXI+MixTPUE9PntsZXQgaz1fZShlWzBdLmRhdGFUeXBlKSxQPVtFKFwieFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLHkpLEUoXCJzY2FsZVwiLGkuZGF0YVR5cGUsaS5kaW1zLHkpXTthJiZQLnB1c2goRShcImJpYXNcIixhLmRhdGFUeXBlLGEuZGltcyx5KSksUC5wdXNoKE0oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLGQseSkpLCQmJlAucHVzaChNKFwibWVhbl9kYXRhX291dHB1dFwiLDEsXykpLHYmJlAucHVzaChNKFwiaW52X3N0ZF9vdXRwdXRcIiwxLF8pKTtsZXQgRD1be25hbWU6XCJub3JtX2NvdW50XCIsdHlwZTpcInUzMlwifSx7bmFtZTpcIm5vcm1fc2l6ZVwiLHR5cGU6XCJmMzJcIn0se25hbWU6XCJub3JtX3NpemVfdmVjdG9yaXplZFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJlcHNpbG9uXCIsdHlwZTpcImYzMlwifV07cmV0dXJuYFxuICAke0EucmVnaXN0ZXJVbmlmb3JtcyhEKS5kZWNsYXJlVmFyaWFibGVzKC4uLlApfVxuICAke0EubWFpblN0YXJ0KCl9XG4gICAgJHtBLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5ub3JtX2NvdW50XCIpfVxuICAgIGxldCBvZmZzZXQgPSBnbG9iYWxfaWR4ICogdW5pZm9ybXMubm9ybV9zaXplX3ZlY3Rvcml6ZWQ7XG4gICAgdmFyIG1lYW5fdmVjdG9yID0gJHt1byhcImYzMlwiLHkpfTtcbiAgICB2YXIgbWVhbl9zcXVhcmVfdmVjdG9yID0gJHt1byhcImYzMlwiLHkpfTtcblxuICAgIGZvciAodmFyIGg6IHUzMiA9IDB1OyBoIDwgdW5pZm9ybXMubm9ybV9zaXplX3ZlY3Rvcml6ZWQ7IGgrKykge1xuICAgICAgbGV0IHZhbHVlID0gJHtFdChrLHksXCJ4W2ggKyBvZmZzZXRdXCIpfTtcbiAgICAgIG1lYW5fdmVjdG9yICs9IHZhbHVlO1xuICAgICAgbWVhbl9zcXVhcmVfdmVjdG9yICs9IHZhbHVlICogdmFsdWU7XG4gICAgfVxuICAgIGxldCBtZWFuID0gJHtGZShcIm1lYW5fdmVjdG9yXCIseSl9IC8gdW5pZm9ybXMubm9ybV9zaXplO1xuICAgIGxldCBpbnZfc3RkX2RldiA9IGludmVyc2VTcXJ0KCR7RmUoXCJtZWFuX3NxdWFyZV92ZWN0b3JcIix5KX0gLyB1bmlmb3Jtcy5ub3JtX3NpemUgJHtuP1wiXCI6XCItIG1lYW4gKiBtZWFuXCJ9ICsgdW5pZm9ybXMuZXBzaWxvbik7XG5cbiAgICBmb3IgKHZhciBqOiB1MzIgPSAwOyBqIDwgdW5pZm9ybXMubm9ybV9zaXplX3ZlY3Rvcml6ZWQ7IGorKykge1xuICAgICAgbGV0IGYzMmlucHV0ID0gJHtFdChrLHksXCJ4W2ogKyBvZmZzZXRdXCIpfTtcbiAgICAgIGxldCBmMzJzY2FsZSA9ICR7RXQoayx5LFwic2NhbGVbal1cIil9O1xuICAgICAgb3V0cHV0W2ogKyBvZmZzZXRdID0gJHtQWzBdLnR5cGUudmFsdWV9KChmMzJpbnB1dCAke24/XCJcIjpcIi0gbWVhblwifSkgKiBpbnZfc3RkX2RldiAqIGYzMnNjYWxlXG4gICAgICAgICR7YT9gKyAke0V0KGsseSxcImJpYXNbal1cIil9YDpcIlwifVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAkeyQ/XCJtZWFuX2RhdGFfb3V0cHV0W2dsb2JhbF9pZHhdID0gbWVhblwiOlwiXCJ9O1xuICAgICR7dj9cImludl9zdGRfb3V0cHV0W2dsb2JhbF9pZHhdID0gaW52X3N0ZF9kZXZcIjpcIlwifTtcbiAgfWB9LFQ9W3tkaW1zOmQsZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dO3JldHVybiAkJiZULnB1c2goe2RpbXM6XyxkYXRhVHlwZToxfSksdiYmVC5wdXNoKHtkaW1zOl8sZGF0YVR5cGU6MX0pLHtuYW1lOlwiTGF5ZXJOb3JtYWxpemF0aW9uXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7eX07JHtyfTske259YCxpbnB1dERlcGVuZGVuY2llczpnfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6VCxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChwLzY0KX0scHJvZ3JhbVVuaWZvcm1zOnh9KSxnZXRTaGFkZXJTb3VyY2U6U319LFpkPShlLHQpPT57dWgoZS5pbnB1dHMpLGUuY29tcHV0ZShkaChlLmlucHV0cyx0LGUub3V0cHV0Q291bnQpKX19KTt2YXIgbGgsWGQsSmQ9VSgoKT0+e1widXNlIHN0cmljdFwiO29lKCk7UXIoKTtYcigpO2xoPWU9PntpZighZXx8ZS5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihcIk1hdE11bCByZXF1aXJlcyAyIGlucHV0cy5cIik7aWYoZVswXS5kaW1zW2VbMF0uZGltcy5sZW5ndGgtMV0hPT1lWzFdLmRpbXNbZVsxXS5kaW1zLmxlbmd0aC0yXSl0aHJvdyBuZXcgRXJyb3IoXCJzaGFyZWQgZGltZW5zaW9uIGRvZXMgbm90IG1hdGNoLlwiKX0sWGQ9ZT0+e2xoKGUuaW5wdXRzKTtsZXQgdD10dC5jYWxjU2hhcGUoZS5pbnB1dHNbMF0uZGltcyxlLmlucHV0c1sxXS5kaW1zLCEwKTtpZighdCl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCB1c2UgbWF0bXVsIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO2xldCByPXRbdC5sZW5ndGgtMV0sbj1lLmlucHV0c1swXS5kaW1zW2UuaW5wdXRzWzBdLmRpbXMubGVuZ3RoLTFdO2lmKHI8OCYmbjw4KWUuY29tcHV0ZShacihlLmlucHV0cyx7YWN0aXZhdGlvbjpcIlwifSx0KSk7ZWxzZXtsZXQgbz10W3QubGVuZ3RoLTJdLGk9Qy5zaXplKGUuaW5wdXRzWzBdLmRpbXMuc2xpY2UoMCwtMikpLGE9Qy5zaXplKGUuaW5wdXRzWzFdLmRpbXMuc2xpY2UoMCwtMikpO2lmKGkhPT0xJiZvPT09MSYmYT09PTEpe2xldCBkPWUuaW5wdXRzWzBdLnJlc2hhcGUoWzEsaSxuXSksbD1lLmlucHV0c1sxXS5yZXNoYXBlKFsxLG4scl0pLHA9WzEsaSxyXSxtPVtkLGxdO2UuY29tcHV0ZShlcihtLHthY3RpdmF0aW9uOlwiXCJ9LHQscCkse2lucHV0czptfSl9ZWxzZSBlLmNvbXB1dGUoZXIoZS5pbnB1dHMse2FjdGl2YXRpb246XCJcIn0sdCkpfX19KTt2YXIgY2gscGgsbWgsZWwsdGwscmw9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTtTZSgpO2FlKCk7Y2g9KGUsdCk9PntpZihlLmxlbmd0aDwzfHxlLmxlbmd0aD40KXRocm93IG5ldyBFcnJvcihcIk1hdE11bE5CaXRzIHJlcXVpcmVzIDMgb3IgNCBpbnB1dHNcIik7bGV0IHI9ZVswXSxuPXIuZGltcy5sZW5ndGg7aWYoci5kaW1zW24tMV0hPT10LmspdGhyb3cgbmV3IEVycm9yKFwiVGhlIGxhc3QgZGltIG9mIGlucHV0IHNoYXBlIGRvZXMgbm90IG1hdGNoIHRoZSBrIHZhbHVlXCIpO2xldCBvPU1hdGguZmxvb3IoKHQuayt0LmJsb2NrU2l6ZS0xKS90LmJsb2NrU2l6ZSksaT10LmJsb2NrU2l6ZS84KnQuYml0cyxhPWVbMV07aWYoIUMuYXJlRXF1YWwoYS5kaW1zLFt0Lm4sbyxpXSkpdGhyb3cgbmV3IEVycm9yKFwiVGhlIHNlY29uZCBpbnB1dHMgbXVzdCBiZSAzRCB0ZW5zb3Igd2l0aCBzaGFwZSBOIFggbkJsb2Nrc1BlckNvbCBYIGJsb2JTaXplXCIpO2xldCBsPWVbMl0uZGltcztpZihDLnNpemUobCkhPT10Lm4qbyl0aHJvdyBuZXcgRXJyb3IoXCJzY2FsZXMgaW5wdXQgc2l6ZSBlcnJvci5cIik7aWYoZS5sZW5ndGg9PT00KXtsZXQgbT1lWzNdLmRpbXMsdT10LmJpdHM+ND90Lm4qbzp0Lm4qTWF0aC5mbG9vcigobysxKS8yKTtpZihDLnNpemUobSkhPT11KXRocm93IG5ldyBFcnJvcihcInplcm9Qb2ludHMgaW5wdXQgc2l6ZSBlcnJvci5cIil9fSxwaD0oZSx0KT0+e2xldCByPWVbMF0uZGltcyxuPXIubGVuZ3RoLG89cltuLTJdLGk9dC5rLGE9dC5uLGQ9ci5zbGljZSgwLG4tMiksbD1DLnNpemUoZCksbT1lWzFdLmRpbXNbMl0vNCx1PWVbMF0uZGF0YVR5cGUsaD1tZSh0LmspLF89bWUobSkseT1tZShhKSxnPWQuY29uY2F0KFtvLGFdKSx4PW8+MSYmYS95JTI9PT0wPzI6MSwkPUMuc2l6ZShnKS95L3gsdj02NCxTPVtdLFQ9W2wsbyxpL2hdLEE9Qy5jb252ZXJ0U2hhcGUoZVsxXS5kaW1zKS5zbGljZSgpO0Euc3BsaWNlKC0xLDEsbS9fKSxTLnB1c2goLi4uTihUKSksUy5wdXNoKC4uLk4oQSkpLFMucHVzaCguLi5OKGVbMl0uZGltcykpLGUubGVuZ3RoPT09NCYmUy5wdXNoKC4uLk4oQy5jb252ZXJ0U2hhcGUoZVszXS5kaW1zKSkpO2xldCBrPVtsLG8sYS95XTtTLnB1c2goLi4uTihrKSk7bGV0IFA9RD0+e2xldCBSPVQubGVuZ3RoLEc9RShcImFcIixlWzBdLmRhdGFUeXBlLFIsaCksSz1FKFwiYlwiLDEyLEEubGVuZ3RoLF8pLGo9RShcInNjYWxlc1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLmxlbmd0aCksVj1bRyxLLGpdLFE9ZS5sZW5ndGg9PT00P0UoXCJ6ZXJvX3BvaW50c1wiLDEyLGVbM10uZGltcy5sZW5ndGgpOnZvaWQgMDtRJiZWLnB1c2goUSk7bGV0IHNlPWsubGVuZ3RoLFk9TShcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsc2UseSksZWU9X2UoZVswXS5kYXRhVHlwZSksSj0oKCk9Pntzd2l0Y2goaCl7Y2FzZSAxOnJldHVybmBhcnJheTwke2VlfSwgOD5gO2Nhc2UgMjpyZXR1cm5gbWF0NHgyPCR7ZWV9PmA7Y2FzZSA0OnJldHVybmBtYXQyeDQ8JHtlZX0+YDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgJHtofS1jb21wb25lbnQgaXMgbm90IHN1cHBvcnRlZC5gKX19KSgpLG5lPSgpPT57bGV0ICRlPWBcbiAgICAgICAgICAvLyByZXVzZSBhIGRhdGFcbiAgICAgICAgICAgIHZhciBpbnB1dF9vZmZzZXQgPSAke0cuaW5kaWNlc1RvT2Zmc2V0KGAke0cudHlwZS5pbmRpY2VzfShiYXRjaCwgcm93LCB3b3JkX29mZnNldClgKX07XG4gICAgICAgICAgICB2YXIgYV9kYXRhOiAke0p9O1xuICAgICAgICAgICAgZm9yICh2YXIgajogdTMyID0gMDsgaiA8ICR7OC9ofTsgaisrKSB7XG4gICAgICAgICAgICAgIGFfZGF0YVtqXSA9ICR7Ry5nZXRCeU9mZnNldChcImlucHV0X29mZnNldFwiKX07XG4gICAgICAgICAgICAgIGlucHV0X29mZnNldCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGA7Zm9yKGxldCBsZT0wO2xlPHkqeDtsZSsrKSRlKz1gXG4gICAgICAgICAgICBiX3ZhbHVlID0gJHtfPT09MT9gYiR7bGV9X2RhdGFgOmBiJHtsZX1fZGF0YVtpXWB9O1xuICAgICAgICAgICAgYl92YWx1ZV9sb3dlciA9IHVucGFjazR4VTgoYl92YWx1ZSAmIGJfbWFzayk7XG4gICAgICAgICAgICBiX3ZhbHVlX3VwcGVyID0gdW5wYWNrNHhVOCgoYl92YWx1ZSA+PiA0KSAmIGJfbWFzayk7XG4gICAgICAgICAgICBiX3F1YW50aXplZF92YWx1ZXMgPSAke0p9KCR7QXJyYXkuZnJvbSh7bGVuZ3RoOjR9LChXLHEpPT5gJHtlZX0oYl92YWx1ZV9sb3dlclske3F9XSksICR7ZWV9KGJfdmFsdWVfdXBwZXJbJHtxfV0pYCkuam9pbihcIiwgXCIpfSk7XG4gICAgICAgICAgICBiX2RlcXVhbnRpemVkX3ZhbHVlcyA9ICR7KCgpPT5oPT09MT9gJHtKfSgke0FycmF5LmZyb20oe2xlbmd0aDo4fSwoVyxxKT0+YChiX3F1YW50aXplZF92YWx1ZXNbJHtxfV0gLSAke1E/YHplcm9fcG9pbnQke2xlfWA6XCJ6ZXJvX3BvaW50XCJ9KSAqIHNjYWxlJHtsZX1gKS5qb2luKFwiLCBcIil9KTtgOmAoYl9xdWFudGl6ZWRfdmFsdWVzIC0gJHtKfSgke0FycmF5KDgpLmZpbGwoYCR7UT9gemVyb19wb2ludCR7bGV9YDpcInplcm9fcG9pbnRcIn1gKS5qb2luKFwiLFwiKX0pKSAqIHNjYWxlJHtsZX07YCkoKX07XG4gICAgICAgICAgICB3b3JrZ3JvdXBfc2hhcmVkW2xvY2FsX2lkLnggKiAke3h9ICsgJHtNYXRoLmZsb29yKGxlL3kpfV0ke3k+MT9gWyR7bGUleX1dYDpcIlwifSArPSAke0FycmF5LmZyb20oe2xlbmd0aDo4L2h9LChXLHEpPT5gJHtoPT09MT9gYV9kYXRhWyR7cX1dICogYl9kZXF1YW50aXplZF92YWx1ZXNbJHtxfV1gOmBkb3QoYV9kYXRhWyR7cX1dLCBiX2RlcXVhbnRpemVkX3ZhbHVlc1ske3F9XSlgfWApLmpvaW4oXCIgKyBcIil9O1xuICAgICAgICAgIGA7cmV0dXJuICRlfSxiZT0oKT0+e2xldCAkZT1gXG4gICAgICAgICAgICB2YXIgY29sX2luZGV4ID0gY29sICogJHt5fTtcbiAgICAgICAgICAgICR7UT9gXG4gICAgICAgICAgICBsZXQgemVyb19wb2ludF9ieXRlc19wZXJfY29sID0gKG5CbG9ja3NQZXJDb2wgKyAxKSAvIDI7XG4gICAgICAgICAgICB2YXIgemVyb19wb2ludF9ieXRlX2NvdW50OiB1MzI7XG4gICAgICAgICAgICB2YXIgemVyb19wb2ludF93b3JkX2luZGV4OiB1MzI7XG4gICAgICAgICAgICB2YXIgemVyb19wb2ludF9ieXRlX29mZnNldDogdTMyO1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfbmliYmxlX29mZnNldDogdTMyID0gYmxvY2sgJiAweDF1O1xuICAgICAgICAgICAgdmFyIHplcm9fcG9pbnRfYml0c19vZmZzZXQ6IHUzMjtcbiAgICAgICAgICAgIHZhciB6ZXJvX3BvaW50X3dvcmQ6IHUzMjtgOmBcbiAgICAgICAgICAgIC8vIFRoZSBkZWZhdWx0IHplcm8gcG9pbnQgaXMgOCBmb3IgdW5zaWduZWQgNC1iaXQgcXVhbnRpemF0aW9uLlxuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnQgPSAke2VlfSg4KTtgfVxuICAgICAgICAgICAgYDtmb3IobGV0IGxlPTA7bGU8eSp4O2xlKyspJGUrPWBcbiAgICAgICAgICAgIGxldCBzY2FsZSR7bGV9ID0gJHtqLmdldEJ5T2Zmc2V0KFwiY29sX2luZGV4ICogbkJsb2Nrc1BlckNvbCArIGJsb2NrXCIpfTtcbiAgICAgICAgICAgICR7UT9gXG4gICAgICAgICAgICB6ZXJvX3BvaW50X2J5dGVfY291bnQgPSBjb2xfaW5kZXggKiB6ZXJvX3BvaW50X2J5dGVzX3Blcl9jb2wgKyAoYmxvY2sgPj4gMHgxdSk7XG4gICAgICAgICAgICB6ZXJvX3BvaW50X3dvcmRfaW5kZXggPSB6ZXJvX3BvaW50X2J5dGVfY291bnQgPj4gMHgydTtcbiAgICAgICAgICAgIHplcm9fcG9pbnRfYnl0ZV9vZmZzZXQgPSB6ZXJvX3BvaW50X2J5dGVfY291bnQgJiAweDN1O1xuICAgICAgICAgICAgemVyb19wb2ludF9iaXRzX29mZnNldCA9ICh6ZXJvX3BvaW50X2J5dGVfb2Zmc2V0IDw8IDMpICsgKHplcm9fcG9pbnRfbmliYmxlX29mZnNldCA8PCAyKTtcbiAgICAgICAgICAgIHplcm9fcG9pbnRfd29yZCA9ICR7US5nZXRCeU9mZnNldChcInplcm9fcG9pbnRfd29yZF9pbmRleFwiKX0gPj4gemVyb19wb2ludF9iaXRzX29mZnNldDtcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50JHtsZX0gPSAke2VlfSgoemVyb19wb2ludF93b3JkKSAmIDB4RnUpO2A6XCJcIn1cbiAgICAgICAgICAgIGNvbF9pbmRleCArPSAxO2A7cmV0dXJuICRlfSxPZT0oKT0+e2xldCAkZT1gY29sX2luZGV4ID0gY29sICogJHt5fTtgO2ZvcihsZXQgbGU9MDtsZTx5Kng7bGUrKykkZSs9YFxuICAgICAgICAgICAgbGV0IGIke2xlfV9kYXRhID0gJHtLLmdldEJ5SW5kaWNlcyhgJHtLLnR5cGUuaW5kaWNlc30oY29sX2luZGV4LCBibG9jaywgd29yZClgKX07XG4gICAgICAgICAgICBjb2xfaW5kZXggKz0gMTtgO3JldHVybiAkZSs9YFxuICAgICAgICAgICAgdmFyIGJfdmFsdWU6IHUzMjtcbiAgICAgICAgICAgIGxldCBiX21hc2s6IHUzMiA9IDB4MEYwRjBGMEZ1O1xuICAgICAgICAgICAgdmFyIGJfdmFsdWVfbG93ZXI6IHZlYzQ8dTMyPjtcbiAgICAgICAgICAgIHZhciBiX3ZhbHVlX3VwcGVyOiB2ZWM0PHUzMj47XG4gICAgICAgICAgICB2YXIgYl9xdWFudGl6ZWRfdmFsdWVzOiAke0p9O1xuICAgICAgICAgICAgdmFyIGJfZGVxdWFudGl6ZWRfdmFsdWVzOiAke0p9O2AsJGV9O3JldHVybmBcbiAgICAgICAgdmFyPHdvcmtncm91cD4gd29ya2dyb3VwX3NoYXJlZDogYXJyYXk8JHtZLnR5cGUudmFsdWV9LCAke3gqdn0+O1xuICAgICAgICAke0QuZGVjbGFyZVZhcmlhYmxlcyguLi5WLFkpfVxuICAgICAgICAke0QubWFpblN0YXJ0KFt2LDEsMV0pfVxuICAgICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7WS5vZmZzZXRUb0luZGljZXMoYChnbG9iYWxfaWR4IC8gJHt2fSkgKiAke3h9YCl9O1xuICAgICAgICAgIGxldCBjb2wgPSBvdXRwdXRfaW5kaWNlc1syXTtcbiAgICAgICAgICBsZXQgcm93ID0gb3V0cHV0X2luZGljZXNbMV07XG4gICAgICAgICAgbGV0IGJhdGNoID0gb3V0cHV0X2luZGljZXNbMF07XG4gICAgICAgICAgbGV0IG5CbG9ja3NQZXJDb2wgPSB1bmlmb3Jtcy5iX3NoYXBlWzFdO1xuXG4gICAgICAgICAgZm9yICh2YXIgYmxvY2sgPSBsb2NhbF9pZC54OyBibG9jayA8IG5CbG9ja3NQZXJDb2w7IGJsb2NrICs9ICR7dn0pIHtcbiAgICAgICAgICAgIC8vcHJvY2VzcyBvbmUgYmxvY2tcbiAgICAgICAgICAgIHZhciB3b3JkX29mZnNldDogdTMyID0gYmxvY2sgKiAke3QuYmxvY2tTaXplL2h9O1xuICAgICAgICAgICAgJHtiZSgpfVxuICAgICAgICAgICAgZm9yICh2YXIgd29yZDogdTMyID0gMDsgd29yZCA8ICR7bX07IHdvcmQgKz0gJHtffSkge1xuICAgICAgICAgICAgICAke09lKCl9XG4gICAgICAgICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCAke199OyBpKyspIHtcbiAgICAgICAgICAgICAgICAke25lKCl9XG4gICAgICAgICAgICAgICAgd29yZF9vZmZzZXQgKz0gJHs4L2h9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICAgIGlmIChsb2NhbF9pZC54IDwgJHt4fSkge1xuICAgICAgICAgICAgdmFyIG91dHB1dF92YWx1ZTogJHtZLnR5cGUudmFsdWV9ID0gJHtZLnR5cGUudmFsdWV9KDApO1xuICAgICAgICAgICAgdmFyIHdvcmtncm91cF9zaGFyZWRfb2Zmc2V0OiB1MzIgPSBsb2NhbF9pZC54O1xuICAgICAgICAgICAgZm9yICh2YXIgYjogdTMyID0gMHU7IGIgPCAke3Z9dTsgYisrKSB7XG4gICAgICAgICAgICAgIG91dHB1dF92YWx1ZSArPSB3b3JrZ3JvdXBfc2hhcmVkW3dvcmtncm91cF9zaGFyZWRfb2Zmc2V0XTtcbiAgICAgICAgICAgICAgd29ya2dyb3VwX3NoYXJlZF9vZmZzZXQgKz0gJHt4fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICR7WS5zZXRCeUluZGljZXMoYCR7WS50eXBlLmluZGljZXN9KGJhdGNoLCByb3csIGNvbCArIGxvY2FsX2lkLngpYCxcIm91dHB1dF92YWx1ZVwiKX07XG4gICAgICAgICAgfVxuICAgICAgICB9YH07cmV0dXJue25hbWU6XCJNYXRNdWxOQml0c1wiLHNoYWRlckNhY2hlOntoaW50OmAke3QuYmxvY2tTaXplfTske3QuYml0c307JHtofTske199OyR7eX07JHt4fTske3Z9YCxpbnB1dERlcGVuZGVuY2llczpBcnJheShlLmxlbmd0aCkuZmlsbChcInJhbmtcIil9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6ZyxkYXRhVHlwZTp1fV0sZGlzcGF0Y2hHcm91cDp7eDokfSxwcm9ncmFtVW5pZm9ybXM6U30pLGdldFNoYWRlclNvdXJjZTpQfX0sbWg9KGUsdCk9PntsZXQgcj1lWzBdLmRpbXMsbj1yLmxlbmd0aCxvPXJbbi0yXSxpPXQuayxhPXQubixkPXIuc2xpY2UoMCxuLTIpLGw9Qy5zaXplKGQpLG09ZVsxXS5kaW1zWzJdLzQsdT1lWzBdLmRhdGFUeXBlLGg9bWUodC5rKSxfPW1lKG0pLHk9ZC5jb25jYXQoW28sYV0pLGc9MTI4LHg9YSU4PT09MD84OmElND09PTA/NDoxLCQ9Zy94LHY9JCpfKjgsUz12L2gsVD12L3QuYmxvY2tTaXplLEE9Qy5zaXplKHkpL3gsaz1bXSxQPVtsLG8saS9oXSxEPUMuY29udmVydFNoYXBlKGVbMV0uZGltcykuc2xpY2UoKTtELnNwbGljZSgtMSwxLG0vXyksay5wdXNoKC4uLk4oUCkpLGsucHVzaCguLi5OKEQpKSxrLnB1c2goLi4uTihlWzJdLmRpbXMpKSxlLmxlbmd0aD09PTQmJmsucHVzaCguLi5OKEMuY29udmVydFNoYXBlKGVbM10uZGltcykpKTtsZXQgUj1bbCxvLGFdO2sucHVzaCguLi5OKFIpKTtsZXQgRz1LPT57bGV0IGo9UC5sZW5ndGgsVj1FKFwiYVwiLGVbMF0uZGF0YVR5cGUsaixoKSxRPUUoXCJiXCIsMTIsRC5sZW5ndGgsXyksc2U9RShcInNjYWxlc1wiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLmxlbmd0aCksWT1bVixRLHNlXSxlZT1lLmxlbmd0aD09PTQ/RShcInplcm9fcG9pbnRzXCIsMTIsZVszXS5kaW1zLmxlbmd0aCk6dm9pZCAwO2VlJiZZLnB1c2goZWUpO2xldCBKPVIubGVuZ3RoLG5lPU0oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLEopLGJlPV9lKGVbMF0uZGF0YVR5cGUpLE9lPSgpPT57c3dpdGNoKGgpe2Nhc2UgMTpyZXR1cm5gXG4gICAgICAgICAgbGV0IGFfZGF0YTAgPSB2ZWM0PCR7YmV9PihzdWJfYVt3b3JkX29mZnNldF0sIHN1Yl9hW3dvcmRfb2Zmc2V0ICsgMV0sIHN1Yl9hW3dvcmRfb2Zmc2V0ICsgMl0sIHN1Yl9hW3dvcmRfb2Zmc2V0ICsgM10pO1xuICAgICAgICAgIGxldCBhX2RhdGExID0gdmVjNDwke2JlfT4oc3ViX2Fbd29yZF9vZmZzZXQgKyA0XSwgc3ViX2Fbd29yZF9vZmZzZXQgKyA1XSwgc3ViX2Fbd29yZF9vZmZzZXQgKyA2XSwgc3ViX2Fbd29yZF9vZmZzZXQgKyA3XSk7YDtjYXNlIDI6cmV0dXJuYFxuICAgICAgICAgIGxldCBhX2RhdGEwID0gdmVjNDwke2JlfT4oc3ViX2Fbd29yZF9vZmZzZXRdLCBzdWJfYVt3b3JkX29mZnNldCArIDFdKTtcbiAgICAgICAgICBsZXQgYV9kYXRhMSA9IHZlYzQ8JHtiZX0+KHN1Yl9hW3dvcmRfb2Zmc2V0ICsgMl0sIHN1Yl9hW3dvcmRfb2Zmc2V0ICsgM10pO2A7Y2FzZSA0OnJldHVybmBcbiAgICAgICAgICBsZXQgYV9kYXRhMCA9IHN1Yl9hW3dvcmRfb2Zmc2V0XTtcbiAgICAgICAgICBsZXQgYV9kYXRhMSA9IHN1Yl9hW3dvcmRfb2Zmc2V0ICsgMV07YDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgJHtofS1jb21wb25lbnQgaXMgbm90IHN1cHBvcnRlZC5gKX19O3JldHVybmBcbiAgICAgICAgdmFyPHdvcmtncm91cD4gc3ViX2E6IGFycmF5PCR7Vi50eXBlLnZhbHVlfSwgJHtTfT47XG4gICAgICAgIHZhcjx3b3JrZ3JvdXA+IGludGVyX3Jlc3VsdHM6IGFycmF5PGFycmF5PCR7bmUudHlwZS52YWx1ZX0sICR7JH0+LCAke3h9PjtcbiAgICAgICAgJHtLLmRlY2xhcmVWYXJpYWJsZXMoLi4uWSxuZSl9XG4gICAgICAgICR7Sy5tYWluU3RhcnQoWyQseCwxXSl9XG4gICAgICAgICAgbGV0IG91dHB1dF9pbmRpY2VzID0gJHtuZS5vZmZzZXRUb0luZGljZXMoYHdvcmtncm91cF9pbmRleCAqICR7eH1gKX07XG4gICAgICAgICAgbGV0IGNvbCA9IG91dHB1dF9pbmRpY2VzWzJdO1xuICAgICAgICAgIGxldCByb3cgPSBvdXRwdXRfaW5kaWNlc1sxXTtcbiAgICAgICAgICBsZXQgYmF0Y2ggPSBvdXRwdXRfaW5kaWNlc1swXTtcbiAgICAgICAgICBsZXQgbl9ibG9ja3NfcGVyX2NvbCA9IHVuaWZvcm1zLmJfc2hhcGVbMV07XG4gICAgICAgICAgbGV0IG51bV90aWxlcyA9ICAobl9ibG9ja3NfcGVyX2NvbCAtIDEpIC8gJHtUfSArIDE7XG5cbiAgICAgICAgICAvLyBMb29wIG92ZXIgc2hhcmVkIGRpbWVuc2lvbi5cbiAgICAgICAgICBmb3IgKHZhciB0aWxlOiB1MzIgPSAwOyB0aWxlIDwgbnVtX3RpbGVzOyB0aWxlICs9IDEpIHtcbiAgICAgICAgICAgIGxldCBhX2NvbF9zdGFydCA9IHRpbGUgKiAke1N9O1xuICAgICAgICAgICAgLy8gbG9hZCBvbmUgdGlsZSBBIGRhdGEgaW50byBzaGFyZWQgbWVtb3J5LlxuICAgICAgICAgICAgZm9yICh2YXIgYV9vZmZzZXQgPSBsb2NhbF9pZHg7IGFfb2Zmc2V0IDwgJHtTfTsgYV9vZmZzZXQgKz0gJHtnfSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbGV0IGFfY29sID0gYV9jb2xfc3RhcnQgKyBhX29mZnNldDtcbiAgICAgICAgICAgICAgaWYgKGFfY29sIDwgdW5pZm9ybXMuYV9zaGFwZVsyXSlcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN1Yl9hW2Ffb2Zmc2V0XSA9ICR7Vi5nZXRCeUluZGljZXMoYCR7Vi50eXBlLmluZGljZXN9KGJhdGNoLCByb3csIGFfY29sKWApfTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdWJfYVthX29mZnNldF0gPSAke1YudHlwZS52YWx1ZX0oMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICAgICAgLy8gZWFjaCB0aHJlYWQgcHJvY2VzcyBvbmUgYmxvY2tcbiAgICAgICAgICAgIGxldCBiX3JvdyA9IGNvbCArIGxvY2FsX2lkLnk7XG4gICAgICAgICAgICBsZXQgYmxvY2sgPSB0aWxlICogJHtUfSArIGxvY2FsX2lkLng7XG4gICAgICAgICAgICAke2VlP2BcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2J5dGVzX3Blcl9jb2wgPSAobl9ibG9ja3NfcGVyX2NvbCArIDEpIC8gMjtcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2J5dGVfY291bnQgPSBiX3JvdyAqIHplcm9fcG9pbnRfYnl0ZXNfcGVyX2NvbCArIChibG9jayA+PiAweDF1KTtcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3dvcmRfaW5kZXggPSB6ZXJvX3BvaW50X2J5dGVfY291bnQgPj4gMHgydTtcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2J5dGVfb2Zmc2V0ID0gemVyb19wb2ludF9ieXRlX2NvdW50ICYgMHgzdTtcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X25pYmJsZV9vZmZzZXQ6IHUzMiA9IGJsb2NrICYgMHgxdTtcbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2JpdHNfb2Zmc2V0ID0gKHplcm9fcG9pbnRfYnl0ZV9vZmZzZXQgPDwgMykgKyAoemVyb19wb2ludF9uaWJibGVfb2Zmc2V0IDw8IDIpO1xuICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfd29yZCA9ICR7ZWUuZ2V0QnlPZmZzZXQoXCJ6ZXJvX3BvaW50X3dvcmRfaW5kZXhcIil9ID4+IHplcm9fcG9pbnRfYml0c19vZmZzZXQ7XG4gICAgICAgICAgICBsZXQgemVyb19wb2ludCA9ICR7YmV9KCh6ZXJvX3BvaW50X3dvcmQpICYgMHhGdSk7YDpgXG4gICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCB6ZXJvIHBvaW50IGlzIDggZm9yIHVuc2lnbmVkIDQtYml0IHF1YW50aXphdGlvbi5cbiAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50ID0gJHtiZX0oOCk7YH1cbiAgICAgICAgICAgIGxldCBzY2FsZSA9ICR7c2UuZ2V0QnlPZmZzZXQoXCJiX3JvdyAqIG5fYmxvY2tzX3Blcl9jb2wgKyBibG9ja1wiKX07XG4gICAgICAgICAgICBsZXQgYl9kYXRhID0gJHtRLmdldEJ5SW5kaWNlcyhgJHtRLnR5cGUuaW5kaWNlc30oYl9yb3csIGJsb2NrLCAwKWApfTtcbiAgICAgICAgICAgIHZhciB3b3JkX29mZnNldCA9IGxvY2FsX2lkLnggKiAke3QuYmxvY2tTaXplL2h9O1xuICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMDsgaSA8ICR7X307IGkrKykge1xuICAgICAgICAgICAgICAke09lKCl9XG4gICAgICAgICAgICAgIGxldCBiX3ZhbHVlID0gJHtfPT09MT9cImJfZGF0YVwiOlwiYl9kYXRhW2ldXCJ9O1xuICAgICAgICAgICAgICBsZXQgYl92YWx1ZV9sb3dlciA9IHVucGFjazR4VTgoYl92YWx1ZSAmIDB4MEYwRjBGMEZ1KTtcbiAgICAgICAgICAgICAgbGV0IGJfdmFsdWVfdXBwZXIgPSB1bnBhY2s0eFU4KChiX3ZhbHVlID4+IDQpICYgMHgwRjBGMEYwRnUpO1xuICAgICAgICAgICAgICBsZXQgYl9xdWFudGl6ZWRfdmFsdWVzID0gbWF0Mng0PCR7YmV9Pigke0FycmF5LmZyb20oe2xlbmd0aDo0fSwoJGUsbGUpPT5gJHtiZX0oYl92YWx1ZV9sb3dlclske2xlfV0pLCAke2JlfShiX3ZhbHVlX3VwcGVyWyR7bGV9XSlgKS5qb2luKFwiLCBcIil9KTtcbiAgICAgICAgICAgICAgbGV0IGJfZGVxdWFudGl6ZWRfdmFsdWVzID0gKGJfcXVhbnRpemVkX3ZhbHVlcyAtIG1hdDJ4NDwke2JlfT4oJHtBcnJheSg4KS5maWxsKFwiemVyb19wb2ludFwiKS5qb2luKFwiLFwiKX0pKSAqIHNjYWxlO1xuICAgICAgICAgICAgICBpbnRlcl9yZXN1bHRzW2xvY2FsX2lkLnldW2xvY2FsX2lkLnhdICs9ICR7QXJyYXkuZnJvbSh7bGVuZ3RoOjJ9LCgkZSxsZSk9PmAke2Bkb3QoYV9kYXRhJHtsZX0sIGJfZGVxdWFudGl6ZWRfdmFsdWVzWyR7bGV9XSlgfWApLmpvaW4oXCIgKyBcIil9O1xuICAgICAgICAgICAgICB3b3JkX29mZnNldCArPSAkezgvaH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGxvY2FsX2lkeCA8ICR7eH0pIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXRfdmFsdWU6ICR7bmUudHlwZS52YWx1ZX0gPSAke25lLnR5cGUudmFsdWV9KDApO1xuICAgICAgICAgICAgZm9yICh2YXIgYiA9IDB1OyBiIDwgJHskfTsgYisrKSB7XG4gICAgICAgICAgICAgIG91dHB1dF92YWx1ZSArPSBpbnRlcl9yZXN1bHRzW2xvY2FsX2lkeF1bYl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29sICsgbG9jYWxfaWR4IDwgdW5pZm9ybXMub3V0cHV0X3NoYXBlWzJdKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAke25lLnNldEJ5SW5kaWNlcyhgJHtuZS50eXBlLmluZGljZXN9KGJhdGNoLCByb3csIGNvbCArIGxvY2FsX2lkeClgLFwib3V0cHV0X3ZhbHVlXCIpfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfWB9O3JldHVybntuYW1lOlwiQmxvY2t3aXNlTWF0TXVsTkJpdHMzMlwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuYmxvY2tTaXplfTske2h9OyR7X307JHskfTske3h9YCxpbnB1dERlcGVuZGVuY2llczpBcnJheShlLmxlbmd0aCkuZmlsbChcInJhbmtcIil9LGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6eSxkYXRhVHlwZTp1fV0sZGlzcGF0Y2hHcm91cDp7eDpBfSxwcm9ncmFtVW5pZm9ybXM6a30pLGdldFNoYWRlclNvdXJjZTpHfX0sZWw9KGUsdCk9PntjaChlLmlucHV0cyx0KSx0LmJsb2NrU2l6ZT09PTMyJiZlLmFkYXB0ZXJJbmZvLmlzVmVuZG9yKFwiaW50ZWxcIikmJmUuYWRhcHRlckluZm8uaXNBcmNoaXRlY3R1cmUoXCJnZW4tMTJscFwiKT9lLmNvbXB1dGUobWgoZS5pbnB1dHMsdCkpOmUuY29tcHV0ZShwaChlLmlucHV0cyx0KSl9LHRsPWU9PnJlKGUpfSk7dmFyIGZoLGhoLGdoLGJoLHloLF9oLHdoLHZoLG5sLG9sPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7YWUoKTtmaD1lPT57aWYoIWV8fGUubGVuZ3RoPDEpdGhyb3cgbmV3IEVycm9yKFwiVG9vIGZldyBpbnB1dHNcIik7aWYoZVswXS5kYXRhVHlwZSE9PTEmJmVbMF0uZGF0YVR5cGUhPT0xMCl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCB0eXBlIG11c3QgYmUgZmxvYXQgb3IgZmxvYXQxNi5cIik7aWYoZS5sZW5ndGg+PTIpe2xldCB0PWVbMF0uZGltcy5sZW5ndGgqMj09PWVbMV0uZGltc1swXTtpZihlLmxlbmd0aD09PTQmJih0PWVbM10uZGltc1swXSoyPT09ZVsxXS5kaW1zWzBdKSwhdCl0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcGFkcyBzaG91bGQgYmUgYSAxRCB0ZW5zb3Igb2Ygc2hhcGUgWzIgKiBpbnB1dF9yYW5rXSBvciBbMiAqIG51bV9heGVzXS5cIil9fSxoaD0oZSx0LHIpPT57bGV0IG49XCJcIjtmb3IobGV0IG89dC0xO28+PTA7LS1vKW4rPWBcbiAgICAgICAgICAgIGsgPSBpMzIoJHtlLmluZGljZXNHZXQoXCJpbmRpY2VzXCIsbyl9KSAtICR7RihcInVuaWZvcm1zLnBhZHNcIixvLHIpfTtcbiAgICAgICAgICAgIGlmIChrIDwgMCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrID49IGkzMigke0YoXCJ1bmlmb3Jtcy54X3NoYXBlXCIsbyx0KX0pKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ICs9IGsgKiBpMzIoJHtGKFwidW5pZm9ybXMueF9zdHJpZGVzXCIsbyx0KX0pO1xuICAgICAgICBgO3JldHVybmBcbiAgICAgICAgICB2YWx1ZSA9ICR7ZS50eXBlLnZhbHVlfSh1bmlmb3Jtcy5jb25zdGFudF92YWx1ZSk7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgJHtufVxuICAgICAgICAgICAgdmFsdWUgPSB4W29mZnNldF07XG4gICAgICAgICAgfVxuICAgICAgYH0sZ2g9KGUsdCxyKT0+e2xldCBuPVwiXCI7Zm9yKGxldCBvPXQtMTtvPj0wOy0tbyluKz1gXG4gICAgICAgICAgICAgICAgayA9IGkzMigke2UuaW5kaWNlc0dldChcImluZGljZXNcIixvKX0pIC0gJHtGKFwidW5pZm9ybXMucGFkc1wiLG8scil9O1xuICAgICAgICAgICAgICAgIGlmIChrIDwgMCkge1xuICAgICAgICAgICAgICAgICAgayA9IC1rO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBsZXQgXzJuXzEgPSAyICogKGkzMigke0YoXCJ1bmlmb3Jtcy54X3NoYXBlXCIsbyx0KX0pIC0gMSk7XG4gICAgICAgICAgICAgICAgICBrID0gayAlIF8ybl8xO1xuICAgICAgICAgICAgICAgICAgaWYoayA+PSBpMzIoJHtGKFwidW5pZm9ybXMueF9zaGFwZVwiLG8sdCl9KSkge1xuICAgICAgICAgICAgICAgICAgICBrID0gXzJuXzEgLSBrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gayAqIGkzMigke0YoXCJ1bmlmb3Jtcy54X3N0cmlkZXNcIixvLHQpfSk7XG4gICAgICAgICAgICBgO3JldHVybmBcbiAgICAgICAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgICAgICAgIHZhciBrID0gMDtcbiAgICAgICAgICAgICAgJHtufVxuICAgICAgICAgICAgICB2YWx1ZSA9IHhbb2Zmc2V0XTtcbiAgICAgICAgICBgfSxiaD0oZSx0LHIpPT57bGV0IG49XCJcIjtmb3IobGV0IG89dC0xO28+PTA7LS1vKW4rPWBcbiAgICAgICAgICAgICAgICBrID0gaTMyKCR7ZS5pbmRpY2VzR2V0KFwiaW5kaWNlc1wiLG8pfSkgLSAke0YoXCJ1bmlmb3Jtcy5wYWRzXCIsbyxyKX07XG4gICAgICAgICAgICAgICAgaWYgKGsgPCAwKSB7XG4gICAgICAgICAgICAgICAgICBrID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGsgPj0gaTMyKCR7RihcInVuaWZvcm1zLnhfc2hhcGVcIixvLHQpfSkpIHtcbiAgICAgICAgICAgICAgICAgIGsgPSBpMzIoJHtGKFwidW5pZm9ybXMueF9zaGFwZVwiLG8sdCl9KSAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBrICogaTMyKCR7RihcInVuaWZvcm1zLnhfc3RyaWRlc1wiLG8sdCl9KTtcbiAgICAgICAgICAgIGA7cmV0dXJuYFxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgICAke259XG4gICAgICAgICAgICAgIHZhbHVlID0geFtvZmZzZXRdO1xuICAgICAgICAgIGB9LHloPShlLHQscik9PntsZXQgbj1cIlwiO2ZvcihsZXQgbz10LTE7bz49MDstLW8pbis9YFxuICAgICAgICAgICAgICAgIGsgPSBpMzIoJHtlLmluZGljZXNHZXQoXCJpbmRpY2VzXCIsbyl9KSAtICR7RihcInVuaWZvcm1zLnBhZHNcIixvLHIpfTtcbiAgICAgICAgICAgICAgICBpZiAoayA8IDApICB7XG4gICAgICAgICAgICAgICAgICBrICs9IGkzMigke0YoXCJ1bmlmb3Jtcy54X3NoYXBlXCIsbyx0KX1dKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGsgPj0gaTMyKCR7RihcInVuaWZvcm1zLnhfc2hhcGVcIixvLHQpfSkpIHtcbiAgICAgICAgICAgICAgICAgIGsgLT0gaTMyKCR7RihcInVuaWZvcm1zLnhfc2hhcGVcIixvLHQpfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9mZnNldCArPSBrICogaTMyKCR7RihcInVuaWZvcm1zLnhfc3RyaWRlc1wiLG8sdCl9KTtcbiAgICAgICAgICAgIGA7cmV0dXJuYFxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgICAgICAke259XG4gICAgICAgICAgICAgIHZhbHVlID0geFtvZmZzZXRdO1xuICAgICAgICAgIGB9LF9oPShlLHQscik9Pntzd2l0Y2goci5tb2RlKXtjYXNlIDA6cmV0dXJuIGhoKGUsdCxyLnBhZHMubGVuZ3RoKTtjYXNlIDE6cmV0dXJuIGdoKGUsdCxyLnBhZHMubGVuZ3RoKTtjYXNlIDI6cmV0dXJuIGJoKGUsdCxyLnBhZHMubGVuZ3RoKTtjYXNlIDM6cmV0dXJuIHloKGUsdCxyLnBhZHMubGVuZ3RoKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbW9kZVwiKX19LHdoPShlLHQpPT57bGV0IHI9Qy5wYWRTaGFwZShlWzBdLmRpbXMuc2xpY2UoKSx0LnBhZHMpLG49ZVswXS5kaW1zLG89Qy5zaXplKHIpLGk9W3t0eXBlOjEyLGRhdGE6b30se3R5cGU6NixkYXRhOnQucGFkc31dLGE9ZS5sZW5ndGg+PTMmJmVbMl0uZGF0YTt0Lm1vZGU9PT0wJiZpLnB1c2goe3R5cGU6YT9lWzJdLmRhdGFUeXBlOjEsZGF0YTp0LnZhbHVlfSksaS5wdXNoKC4uLk4oZVswXS5kaW1zLHIpKTtsZXQgZD1bXCJyYW5rXCJdLGw9cD0+e2xldCBtPU0oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLHIubGVuZ3RoKSx1PUUoXCJ4XCIsZVswXS5kYXRhVHlwZSxuLmxlbmd0aCksaD11LnR5cGUudmFsdWUsXz1faChtLG4ubGVuZ3RoLHQpLHk9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwicGFkc1wiLHR5cGU6XCJpMzJcIixsZW5ndGg6dC5wYWRzLmxlbmd0aH1dO3JldHVybiB0Lm1vZGU9PT0wJiZ5LnB1c2goe25hbWU6XCJjb25zdGFudF92YWx1ZVwiLHR5cGU6YT9oOlwiZjMyXCJ9KSxgXG4gICAgICAgICAgICAke3AucmVnaXN0ZXJVbmlmb3Jtcyh5KS5kZWNsYXJlVmFyaWFibGVzKHUsbSl9XG4gICAgICAgICAgICAke3AubWFpblN0YXJ0KCl9XG4gICAgICAgICAgICAke3AuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuXG4gICAgICAgICAgICBsZXQgaW5kaWNlcyA9ICR7bS5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcblxuICAgICAgICAgICAgdmFyIHZhbHVlID0gJHtofSgwKTtcbiAgICAgICAgICAgICR7X31cbiAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHZhbHVlO1xuICAgICAgICB9YH07cmV0dXJue25hbWU6XCJQYWRcIixzaGFkZXJDYWNoZTp7aGludDpgJHt0Lm1vZGV9JHthfWAsaW5wdXREZXBlbmRlbmNpZXM6ZH0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczpyLGRhdGFUeXBlOmVbMF0uZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChDLnNpemUocikvNjQpfSxwcm9ncmFtVW5pZm9ybXM6aX0pLGdldFNoYWRlclNvdXJjZTpsfX0sdmg9KGUsdCk9PntpZihlLmxlbmd0aD4xKXtsZXQgcj1lWzFdLmdldEJpZ0ludDY0QXJyYXkoKSxuPWUubGVuZ3RoPj0zJiZlWzJdLmRhdGE/ZVsyXS5kYXRhVHlwZT09PTEwP2VbMl0uZ2V0VWludDE2QXJyYXkoKVswXTplWzJdLmdldEZsb2F0MzJBcnJheSgpWzBdOjAsbz1lWzBdLmRpbXMubGVuZ3RoLGk9bmV3IEludDMyQXJyYXkoMipvKS5maWxsKDApO2lmKGUubGVuZ3RoPj00KXtsZXQgZD1lWzNdLmdldEJpZ0ludDY0QXJyYXkoKTtmb3IobGV0IGw9MDtsPGQubGVuZ3RoO2wrKylpW051bWJlcihkW2xdKV09TnVtYmVyKHJbbF0pLGlbTnVtYmVyKGRbbF0pK29dPU51bWJlcihyW2wrZC5sZW5ndGhdKX1lbHNlIHIuZm9yRWFjaCgoZCxsKT0+aVtOdW1iZXIobCldPU51bWJlcihkKSk7bGV0IGE9W107cmV0dXJuIGkuZm9yRWFjaChkPT5hLnB1c2goZCkpLHttb2RlOnQubW9kZSx2YWx1ZTpuLHBhZHM6YX19ZWxzZSByZXR1cm4gdH0sbmw9KGUsdCk9PntmaChlLmlucHV0cyk7bGV0IHI9dmgoZS5pbnB1dHMsdCk7ZS5jb21wdXRlKHdoKGUuaW5wdXRzLHIpLHtpbnB1dHM6WzBdfSl9fSk7dmFyIHRuLGlsLGFsLHNsLHVsLCRoLHhoLGRsLGxsLGNsLHBsLG1sLGZsLGhsLGdsLGJsLHlsLF9sLHdsLHZsPVUoKCk9PntcInVzZSBzdHJpY3RcIjtXZSgpO3RlKCk7b2UoKTthZSgpO3RuPWU9PntpZih2ZS53ZWJncHUudmFsaWRhdGVJbnB1dENvbnRlbnQmJighZXx8ZS5sZW5ndGghPT0xKSl0aHJvdyBuZXcgRXJyb3IoXCJQb29sIG9wcyByZXF1aXJlcyAxIGlucHV0LlwiKX0saWw9KGUsdCxyKT0+e2xldCBuPXQuZm9ybWF0PT09XCJOSFdDXCIsbz1lLmRpbXMuc2xpY2UoKTtuJiZvLnNwbGljZSgxLDAsby5wb3AoKSk7bGV0IGk9T2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwodCxcImRpbGF0aW9uc1wiKSxhPXQua2VybmVsU2hhcGUuc2xpY2UoKSxkPXQuc3RyaWRlcy5zbGljZSgpLGw9aT90LmRpbGF0aW9ucy5zbGljZSgpOltdLHA9dC5wYWRzLnNsaWNlKCk7QXQuYWRqdXN0UG9vbEF0dHJpYnV0ZXMocixvLGEsZCxsLHApO2xldCBtPUF0LmNvbXB1dGVQb29sT3V0cHV0U2hhcGUocixvLGQsbCxhLHAsdC5hdXRvUGFkKSx1PU9iamVjdC5hc3NpZ24oe30sdCk7aT9PYmplY3QuYXNzaWduKHUse2tlcm5lbFNoYXBlOmEsc3RyaWRlczpkLHBhZHM6cCxkaWxhdGlvbnM6bCxjYWNoZUtleTp0LmNhY2hlS2V5fSk6T2JqZWN0LmFzc2lnbih1LHtrZXJuZWxTaGFwZTphLHN0cmlkZXM6ZCxwYWRzOnAsY2FjaGVLZXk6dC5jYWNoZUtleX0pO2xldCBoPW0uc2xpY2UoKTtyZXR1cm4gaC5wdXNoKGguc3BsaWNlKDEsMSlbMF0pLFt1LG4/aDptXX0sYWw9KGUsdCk9PntsZXQgcj10LmZvcm1hdD09PVwiTkhXQ1wiLG49Qy5zaXplKGUpLG89Qy5zaXplKHQua2VybmVsU2hhcGUpLGk9W3t0eXBlOjEyLGRhdGE6bn0se3R5cGU6MTIsZGF0YTpvfV0sYT1be25hbWU6XCJvdXRwdXRTaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImtlcm5lbFNpemVcIix0eXBlOlwidTMyXCJ9XTtpZih0Lmtlcm5lbFNoYXBlLmxlbmd0aDw9Mil7bGV0IGQ9dC5rZXJuZWxTaGFwZVt0Lmtlcm5lbFNoYXBlLmxlbmd0aC0xXSxsPXQuc3RyaWRlc1t0LnN0cmlkZXMubGVuZ3RoLTFdLHA9dC5wYWRzW3QucGFkcy5sZW5ndGgvMi0xXSxtPXQucGFkc1t0LnBhZHMubGVuZ3RoLTFdLHU9ISEocCttKTtpLnB1c2goe3R5cGU6MTIsZGF0YTpkfSx7dHlwZToxMixkYXRhOmx9LHt0eXBlOjEyLGRhdGE6cH0se3R5cGU6MTIsZGF0YTptfSksYS5wdXNoKHtuYW1lOlwia3dcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwic3dcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwicHdTdGFydFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJwd0VuZFwiLHR5cGU6XCJ1MzJcIn0pO2xldCBoPSExO2lmKHQua2VybmVsU2hhcGUubGVuZ3RoPT09Mil7bGV0IF89dC5rZXJuZWxTaGFwZVt0Lmtlcm5lbFNoYXBlLmxlbmd0aC0yXSx5PXQuc3RyaWRlc1t0LnN0cmlkZXMubGVuZ3RoLTJdLGc9dC5wYWRzW3QucGFkcy5sZW5ndGgvMi0yXSx4PXQucGFkc1t0LnBhZHMubGVuZ3RoLTJdO2g9ISEoZyt4KSxpLnB1c2goe3R5cGU6MTIsZGF0YTpffSx7dHlwZToxMixkYXRhOnl9LHt0eXBlOjEyLGRhdGE6Z30se3R5cGU6MTIsZGF0YTp4fSksYS5wdXNoKHtuYW1lOlwia2hcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwic2hcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwicGhTdGFydFwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJwaEVuZFwiLHR5cGU6XCJ1MzJcIn0pfXJldHVybltpLGEsITAsdSxoXX1lbHNle2lmKHIpdGhyb3cgbmV3IEVycm9yKFwiUG9vbGluZyB3aXRoIGtlcm5lbFNoYXBlLmxlbmd0aCA+IDIgaXMgbm90IHN1cHBvcnRlZCBmb3IgTkhXQyBmb3JtYXQuXCIpO2xldCBkPUMuY29tcHV0ZVN0cmlkZXModC5rZXJuZWxTaGFwZSk7aS5wdXNoKHt0eXBlOjEyLGRhdGE6ZH0se3R5cGU6MTIsZGF0YTp0LnBhZHN9LHt0eXBlOjEyLGRhdGE6dC5zdHJpZGVzfSksYS5wdXNoKHtuYW1lOlwia2VybmVsU3RyaWRlc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6ZC5sZW5ndGh9LHtuYW1lOlwicGFkc1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6dC5wYWRzLmxlbmd0aH0se25hbWU6XCJzdHJpZGVzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDp0LnN0cmlkZXMubGVuZ3RofSk7bGV0IGw9dC5wYWRzLnJlZHVjZSgocCxtKT0+cCttKTtyZXR1cm5baSxhLCEhbCwhMSwhMV19fSxzbD0oZSx0LHIsbixvLGksYSxkLGwscCxtLHUpPT57bGV0IGg9by5mb3JtYXQ9PT1cIk5IV0NcIixfPXQudHlwZS52YWx1ZSx5PU0oXCJvdXRwdXRcIix0LnR5cGUudGVuc29yLG4pO2lmKG8ua2VybmVsU2hhcGUubGVuZ3RoPD0yKXtsZXQgZz1cIlwiLHg9XCJcIiwkPVwiXCIsdj1yLShoPzI6MSk7aWYobT9nPWBcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwdTsgaSA8IHVuaWZvcm1zLmt3OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgIHhJbmRpY2VzWyR7dn1dID0gaW5kaWNlc1ske3Z9XSAqIHVuaWZvcm1zLnN3IC0gdW5pZm9ybXMucHdTdGFydCArIGk7XG4gICAgICAgICAgICAgICAgICBpZiAoeEluZGljZXNbJHt2fV0gPCAwIHx8IHhJbmRpY2VzWyR7dn1dXG4gICAgICAgICAgICAgICAgICAgICAgPj0gdW5pZm9ybXMueF9zaGFwZVske3Z9XSkge1xuICAgICAgICAgICAgICAgICAgICBwYWQrKztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBsZXQgeF92YWwgPSB4WyR7dC5pbmRpY2VzVG9PZmZzZXQoXCJ4SW5kaWNlc1wiKX1dO1xuICAgICAgICAgICAgICAgICAgJHtpfVxuICAgICAgICAgICAgICAgIH1gOmc9YFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDB1OyBpIDwgdW5pZm9ybXMua3c7IGkrKykge1xuICAgICAgICAgICAgICAgICAgeEluZGljZXNbJHt2fV0gPSBpbmRpY2VzWyR7dn1dICogdW5pZm9ybXMuc3cgLSB1bmlmb3Jtcy5wd1N0YXJ0ICsgaTtcbiAgICAgICAgICAgICAgICAgIGxldCB4X3ZhbCA9IHhbJHt0LmluZGljZXNUb09mZnNldChcInhJbmRpY2VzXCIpfV07XG4gICAgICAgICAgICAgICAgICAke2l9XG4gICAgICAgICAgICAgICAgfWAsby5rZXJuZWxTaGFwZS5sZW5ndGg9PT0yKXtsZXQgVD1yLShoPzM6Mik7dT94PWBcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqOiB1MzIgPSAwdTsgaiA8IHVuaWZvcm1zLmtoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIHhJbmRpY2VzWyR7VH1dID0gaW5kaWNlc1ske1R9XSAqIHVuaWZvcm1zLnNoIC0gdW5pZm9ybXMucGhTdGFydCArIGo7XG4gICAgICAgICAgICAgICAgICBpZiAoeEluZGljZXNbJHtUfV0gPCAwIHx8IHhJbmRpY2VzWyR7VH1dID49IHVuaWZvcm1zLnhfc2hhcGVbJHtUfV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcGFkICs9IGkzMih1bmlmb3Jtcy5rdyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBgOng9YFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGo6IHUzMiA9IDB1OyBqIDwgdW5pZm9ybXMua2g7IGorKykge1xuICAgICAgICAgICAgICAgICAgeEluZGljZXNbJHtUfV0gPSBpbmRpY2VzWyR7VH1dICogdW5pZm9ybXMuc2ggLSB1bmlmb3Jtcy5waFN0YXJ0ICsgajtcbiAgICAgICAgICAgICAgICBgLCQ9YFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBgfXJldHVybmBcbiAgICAgICAgICAgICR7ZS5yZWdpc3RlclVuaWZvcm1zKGwpLmRlY2xhcmVWYXJpYWJsZXModCx5KX1cblxuICAgICAgICAgICAgJHtlLm1haW5TdGFydCgpfVxuICAgICAgICAgICAgICAke2UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dFNpemVcIil9XG5cbiAgICAgICAgICAgICAgbGV0IGluZGljZXMgPSAke3kub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAgICAgICAgIHZhciB4SW5kaWNlcyA9ICR7eS5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcblxuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSAke199KCR7ZH0pO1xuICAgICAgICAgICAgICB2YXIgcGFkID0gMDtcbiAgICAgICAgICAgICAgJHt4fVxuICAgICAgICAgICAgICAke2d9XG4gICAgICAgICAgICAgICR7JH1cbiAgICAgICAgICAgICAgJHthfVxuXG4gICAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHZhbHVlO1xuICAgICAgICAgICAgfWB9ZWxzZXtpZihoKXRocm93IG5ldyBFcnJvcihcIlBvb2xpbmcgd2l0aCBrZXJuZWxTaGFwZS5sZW5ndGggPiAyIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIE5IV0MgZm9ybWF0LlwiKTtsZXQgZz1vLmtlcm5lbFNoYXBlLmxlbmd0aCx4PW8ucGFkcy5sZW5ndGgsJD1cIlwiO3JldHVybiBwPyQ9YFxuICAgICAgICAgICAgICAgIGlmICh4SW5kaWNlc1tqXSA+PSB1bmlmb3Jtcy54X3NoYXBlW2pdKSB7XG4gICAgICAgICAgICAgICAgICBwYWQrKztcbiAgICAgICAgICAgICAgICAgIGlzUGFkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWlzUGFkKSB7XG4gICAgICAgICAgICAgICAgbGV0IHhfdmFsID0geFske3QuaW5kaWNlc1RvT2Zmc2V0KFwieEluZGljZXNcIil9XTtcbiAgICAgICAgICAgICAgICAke2l9XG4gICAgICAgICAgICAgIH1gOiQ9YFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGxldCB4X3ZhbCA9IHhbJHt0LmluZGljZXNUb09mZnNldChcInhJbmRpY2VzXCIpfV07XG4gICAgICAgICAgICAgICR7aX1cbiAgICAgICAgICAgIGAsYFxuICAgICAgICAgICAgJHtlLnJlZ2lzdGVyVW5pZm9ybXMobCkuZGVjbGFyZVZhcmlhYmxlcyh0LHkpfVxuXG4gICAgICAgICAgICAke2UubWFpblN0YXJ0KCl9XG4gICAgICAgICAgICAgICR7ZS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0U2l6ZVwiKX1cbiAgICAgICAgICAgICAgbGV0IGluZGljZXMgPSAke3kub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAgICAgICAgIHZhciB4SW5kaWNlcyA9ICR7eS5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcblxuICAgICAgICAgICAgICB2YXIgb2Zmc2V0czogYXJyYXk8dTMyLCAke2d9PjtcblxuICAgICAgICAgICAgICB2YXIgdmFsdWUgPSAke199KCR7ZH0pO1xuICAgICAgICAgICAgICB2YXIgcGFkID0gMDtcbiAgICAgICAgICAgICAgdmFyIGlzUGFkID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgaTogdTMyID0gMHU7IGkgPCB1bmlmb3Jtcy5rZXJuZWxTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gaTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMHU7IGogPCAke2ctMX11OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIG9mZnNldHNbal0gPSBvZmZzZXQgLyAke0YoXCJ1bmlmb3Jtcy5rZXJuZWxTdHJpZGVzXCIsXCJqXCIsZyl9O1xuICAgICAgICAgICAgICAgICAgb2Zmc2V0IC09IG9mZnNldHNbal0gKiAke0YoXCJ1bmlmb3Jtcy5rZXJuZWxTdHJpZGVzXCIsXCJqXCIsZyl9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvZmZzZXRzWyR7Zy0xfV0gPSBvZmZzZXQ7XG5cbiAgICAgICAgICAgICAgICBpc1BhZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAke3ItZ311OyBqIDwgJHtyfXU7IGorKykge1xuICAgICAgICAgICAgICAgICAgeEluZGljZXNbal0gPSBpbmRpY2VzW2pdICogJHtGKFwidW5pZm9ybXMuc3RyaWRlc1wiLGBqIC0gJHtyLWd9dWAsZyl9XG4gICAgICAgICAgICAgICAgICAgICsgb2Zmc2V0c1tqIC0gJHtyLWd9dV0gLSAke0YoXCJ1bmlmb3Jtcy5wYWRzXCIsXCJqIC0gMnVcIix4KX07XG4gICAgICAgICAgICAgICAgICAkeyR9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgJHthfVxuXG4gICAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9IHZhbHVlO1xuICAgICAgICAgICAgfWB9fSx1bD1lPT5gJHtlLmZvcm1hdH07JHtlLmNlaWxNb2RlfTske2UuYXV0b1BhZH07JHtlLmtlcm5lbFNoYXBlLmxlbmd0aH1gLCRoPWU9PmAke3VsKGUpfTske2UuY291bnRJbmNsdWRlUGFkfWAseGg9ZT0+YCR7dWwoZSl9OyR7ZS5zdG9yYWdlT3JkZXJ9OyR7ZS5kaWxhdGlvbnN9YCxkbD1lPT4oe2Zvcm1hdDplLmZvcm1hdCxhdXRvUGFkOltcIk5PVFNFVFwiLFwiVkFMSURcIixcIlNBTUVfVVBQRVJcIixcIlNBTUVfTE9XRVJcIl1bZS5hdXRvX3BhZF0sY2VpbE1vZGU6ZS5jZWlsX21vZGUsa2VybmVsU2hhcGU6ZS5rZXJuZWxfc2hhcGUsc3RyaWRlczplLnN0cmlkZXMscGFkczplLnBhZHN9KSxsbD0oZSx0LHIsbik9PntsZXRbbyxpXT1pbCh0LG4sciksYT1FKFwieFwiLHQuZGF0YVR5cGUsdC5kaW1zLmxlbmd0aCksZD1hLnR5cGUudmFsdWUsbD1cInZhbHVlICs9IHhfdmFsO1wiLHA9XCJcIjtvLmNvdW50SW5jbHVkZVBhZD9wKz1gdmFsdWUgLz0gJHtkfSh1bmlmb3Jtcy5rZXJuZWxTaXplKTtgOnArPWB2YWx1ZSAvPSAke2R9KGkzMih1bmlmb3Jtcy5rZXJuZWxTaXplKSAtIHBhZCk7YDtsZXRbbSx1LGgsXyx5XT1hbChpLG8pO20ucHVzaCguLi5OKHQuZGltcyxpKSk7bGV0IGc9W1wicmFua1wiXTtyZXR1cm57bmFtZTplLHNoYWRlckNhY2hlOntoaW50OmAke24uY2FjaGVLZXl9OyR7aH07JHtffTske3l9YCxpbnB1dERlcGVuZGVuY2llczpnfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmksZGF0YVR5cGU6dC5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKEMuc2l6ZShpKS82NCl9LHByb2dyYW1Vbmlmb3JtczptfSksZ2V0U2hhZGVyU291cmNlOng9PnNsKHgsYSx0LmRpbXMubGVuZ3RoLGkubGVuZ3RoLG8sbCxwLDAsdSxoLF8seSl9fSxjbD1lPT57bGV0IHQ9ZS5jb3VudF9pbmNsdWRlX3BhZCE9PTAscj1kbChlKTtpZihyLmNlaWxNb2RlIT09MCl0aHJvdyBuZXcgRXJyb3IoXCJ1c2luZyBjZWlsKCkgaW4gc2hhcGUgY29tcHV0YXRpb24gaXMgbm90IHlldCBzdXBwb3J0ZWQgZm9yIEF2ZXJhZ2VQb29sXCIpO2xldCBuPXtjb3VudEluY2x1ZGVQYWQ6dCwuLi5yLGNhY2hlS2V5OlwiXCJ9O3JldHVybnsuLi5uLGNhY2hlS2V5OiRoKG4pfX0scGw9KGUsdCk9Pnt0bihlLmlucHV0cyksZS5jb21wdXRlKGxsKFwiQXZlcmFnZVBvb2xcIixlLmlucHV0c1swXSwhMSx0KSl9LG1sPXthdXRvUGFkOlwiXCIsY2VpbE1vZGU6MCxjb3VudEluY2x1ZGVQYWQ6ITEsa2VybmVsU2hhcGU6W10sc3RyaWRlczpbXSxwYWRzOltdLHN0b3JhZ2VPcmRlcjowLGRpbGF0aW9uczpbXX0sZmw9ZT0+e2xldCB0PWUuZm9ybWF0O3JldHVybntmb3JtYXQ6dCwuLi5tbCxjYWNoZUtleTp0fX0saGw9KGUsdCk9Pnt0bihlLmlucHV0cyksZS5jb21wdXRlKGxsKFwiR2xvYmFsQXZlcmFnZVBvb2xcIixlLmlucHV0c1swXSwhMCx0KSl9LGdsPShlLHQscixuKT0+e2xldFtvLGldPWlsKHQsbixyKSxhPWBcbiAgICAgIHZhbHVlID0gbWF4KHhfdmFsLCB2YWx1ZSk7XG4gICAgYCxkPVwiXCIsbD1FKFwieFwiLHQuZGF0YVR5cGUsdC5kaW1zLmxlbmd0aCkscD1bXCJyYW5rXCJdLFttLHUsaCxfLHldPWFsKGksbyk7cmV0dXJuIG0ucHVzaCguLi5OKHQuZGltcyxpKSkse25hbWU6ZSxzaGFkZXJDYWNoZTp7aGludDpgJHtuLmNhY2hlS2V5fTske2h9OyR7X307JHt5fWAsaW5wdXREZXBlbmRlbmNpZXM6cH0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczppLGRhdGFUeXBlOnQuZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChDLnNpemUoaSkvNjQpfSxwcm9ncmFtVW5pZm9ybXM6bX0pLGdldFNoYWRlclNvdXJjZTpnPT5zbChnLGwsdC5kaW1zLmxlbmd0aCxpLmxlbmd0aCxvLGEsZCx0LmRhdGFUeXBlPT09MTA/LTY1NTA0Oi0xZTUsdSxoLF8seSl9fSxibD0oZSx0KT0+e3RuKGUuaW5wdXRzKSxlLmNvbXB1dGUoZ2woXCJNYXhQb29sXCIsZS5pbnB1dHNbMF0sITEsdCkpfSx5bD1lPT57bGV0IHQ9ZS5zdG9yYWdlX29yZGVyLHI9ZS5kaWxhdGlvbnMsbj1kbChlKTtpZih0IT09MCl0aHJvdyBuZXcgRXJyb3IoXCJjb2x1bW4gbWFqb3Igc3RvcmFnZSBvcmRlciBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgTWF4UG9vbFwiKTtpZihuLmNlaWxNb2RlIT09MCl0aHJvdyBuZXcgRXJyb3IoXCJ1c2luZyBjZWlsKCkgaW4gc2hhcGUgY29tcHV0YXRpb24gaXMgbm90IHlldCBzdXBwb3J0ZWQgZm9yIE1heFBvb2xcIik7bGV0IG89e3N0b3JhZ2VPcmRlcjp0LGRpbGF0aW9uczpyLC4uLm4sY2FjaGVLZXk6XCJcIn07cmV0dXJuey4uLm8sY2FjaGVLZXk6eGgobyl9fSxfbD1lPT57bGV0IHQ9ZS5mb3JtYXQ7cmV0dXJue2Zvcm1hdDp0LC4uLm1sLGNhY2hlS2V5OnR9fSx3bD0oZSx0KT0+e3RuKGUuaW5wdXRzKSxlLmNvbXB1dGUoZ2woXCJHbG9iYWxNYXhQb29sXCIsZS5pbnB1dHNbMF0sITAsdCkpfX0pO3ZhciBUaCxJaCwkbCx4bCxTbD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtvZSgpO1NlKCk7YWUoKTtUaD0oZSx0KT0+e2lmKGUubGVuZ3RoPDJ8fGUubGVuZ3RoPjMpdGhyb3cgbmV3IEVycm9yKFwiRGVxdWFudGl6ZUxpbmVhciByZXF1aXJlcyAyIG9yIDMgaW5wdXRzLlwiKTtpZihlLmxlbmd0aD09PTMmJmVbMV0uZGltcz09PWVbMl0uZGltcyl0aHJvdyBuZXcgRXJyb3IoXCJ4LXNjYWxlIGFuZCB4LXplcm8tcG9pbnQgbXVzdCBoYXZlIHRoZSBzYW1lIHNoYXBlLlwiKTtpZihlLmxlbmd0aD09PTMmJmVbMF0uZGF0YVR5cGUhPT1lWzJdLmRhdGFUeXBlKXRocm93IG5ldyBFcnJvcihcInggYW5kIHgtemVyby1wb2ludCBtdXN0IGhhdmUgdGhlIHNhbWUgZGF0YSB0eXBlLlwiKTtpZihlWzBdLmRhdGFUeXBlPT09NiYmZS5sZW5ndGg+Mil0aHJvdyBuZXcgRXJyb3IoXCJJbiB0aGUgY2FzZSBvZiBkZXF1YW50aXppbmcgaW50MzIgdGhlcmUgaXMgbm8gemVybyBwb2ludC5cIik7aWYoZVsxXS5kaW1zLmxlbmd0aCE9PTAmJmVbMV0uZGltcy5sZW5ndGghPT0xJiZlWzFdLmRpbXMubGVuZ3RoIT09ZVswXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzY2FsZSBpbnB1dCBtdXN0IGJlIGEgc2NhbGFyLCBhIDFEIHRlbnNvciwgb3IgaGF2ZSB0aGUgc2FtZSByYW5rIGFzIHRoZSBpbnB1dCB0ZW5zb3IuXCIpO2lmKGUubGVuZ3RoPjIpe2lmKGVbMF0uZGF0YVR5cGUhPT1lWzJdLmRhdGFUeXBlKXRocm93IG5ldyBFcnJvcihcInggYW5kIHgtemVyby1wb2ludCBtdXN0IGhhdmUgdGhlIHNhbWUgZGF0YSB0eXBlLlwiKTtpZihlWzFdLmRpbXMubGVuZ3RoIT09ZVsyXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJzY2FsZSBhbmQgemVyby1wb2ludCBpbnB1dHMgbXVzdCBoYXZlIHRoZSBzYW1lIHJhbmsuXCIpO2lmKCFlWzFdLmRpbXMubWFwKChyLG4pPT5yPT09ZVsyXS5kaW1zW25dKS5yZWR1Y2UoKHIsbik9PnImJm4sITApKXRocm93IG5ldyBFcnJvcihcInNjYWxlIGFuZCB6ZXJvLXBvaW50IGlucHV0cyBtdXN0IGhhdmUgdGhlIHNhbWUgc2hhcGUuXCIpfWlmKHQuYmxvY2tTaXplPjApe2lmKGVbMV0uZGltcy5sZW5ndGg9PT0wfHxlWzFdLmRpbXMubGVuZ3RoPT09MSYmZVsxXS5kaW1zWzBdPT09MSl0aHJvdyBuZXcgRXJyb3IoXCJibG9ja1NpemUgbXVzdCBiZSBzZXQgb25seSBmb3IgYmxvY2sgcXVhbnRpemF0aW9uLlwiKTtpZighZVsxXS5kaW1zLm1hcCgobyxpKT0+aT09PXQuYXhpc3x8bz09PWVbMF0uZGltc1tpXSkucmVkdWNlKChvLGkpPT5vJiZpLCEwKSl0aHJvdyBuZXcgRXJyb3IoXCJGb3IgYmxvY2sgcXVuYXRpemF0aW9uLCBzY2FsZSBpbnB1dCBzaGFwZSB0byBtYXRjaCB0aGUgaW5wdXQgc2hhcGUgZXhjZXB0IGZvciB0aGUgYXhpc1wiKTtpZihlWzFdLmRpbXMubGVuZ3RoIT09ZVswXS5kaW1zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJGb3IgYmxvY2sgcXVuYXRpemF0aW9uIHRoZSBzY2FsZSBpbnB1dCByYW5rIG11c3QgYmUgdGhlIHNhbWUgYXMgdGhlIHggcmFuay5cIik7bGV0IHI9ZVswXS5kaW1zW3QuYXhpc10sbj1lWzFdLmRpbXNbdC5heGlzXTtpZih0LmJsb2NrU2l6ZTxNYXRoLmNlaWwoci9uKXx8dC5ibG9ja1NpemU+TWF0aC5jZWlsKHIvKG4tMSktMSkpdGhyb3cgbmV3IEVycm9yKFwiYmxvY2tTaXplIG11c3QgYmUgd2l0aCBpbiB0aGUgcmFuZ2UgW2NlaWwoZEkgLyBTaSksIGNlaWwoZEkgLyAoU2kgLSAxKSAtIDEpXS5cIil9fSxJaD0oZSx0KT0+e2xldCByPUMubm9ybWFsaXplQXhpcyh0LmF4aXMsZVswXS5kaW1zLmxlbmd0aCksbj1lWzBdLmRhdGFUeXBlLG89bj09PTMsaT1lWzBdLmRpbXMsYT1lWzFdLmRhdGFUeXBlLGQ9Qy5zaXplKGkpLGw9bj09PTN8fG49PT0yLHA9bD9bTWF0aC5jZWlsKEMuc2l6ZShlWzBdLmRpbXMpLzQpXTplWzBdLmRpbXMsbT1lWzFdLmRpbXMsdT1lLmxlbmd0aD4yP2VbMl06dm9pZCAwLGg9dT9sP1tNYXRoLmNlaWwoQy5zaXplKHUuZGltcykvNCldOnUuZGltczp2b2lkIDAsXz1tLmxlbmd0aD09PTB8fG0ubGVuZ3RoPT09MSYmbVswXT09PTEseT1fPT09ITEmJm0ubGVuZ3RoPT09MSxnPW1lKGQpLHg9XyYmKCFsfHxnPT09NCksJD14P2c6MSx2PXgmJiFsP2c6MSxTPUUoXCJpbnB1dFwiLGw/MTI6bixwLmxlbmd0aCx2KSxUPUUoXCJzY2FsZVwiLGEsbS5sZW5ndGgpLEE9dT9FKFwiemVyb19wb2ludFwiLGw/MTI6bixoLmxlbmd0aCk6dm9pZCAwLGs9TShcIm91dHB1dFwiLGEsaS5sZW5ndGgsJCksUD1bUyxUXTtBJiZQLnB1c2goQSk7bGV0IEQ9W3AsbV07dSYmRC5wdXNoKGgpO2xldCBSPVt7dHlwZToxMixkYXRhOmQvJH0se3R5cGU6MTIsZGF0YTpyfSx7dHlwZToxMixkYXRhOnQuYmxvY2tTaXplfSwuLi5OKC4uLkQsaSldLEc9Sz0+e2xldCBqPVt7bmFtZTpcIm91dHB1dF9zaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcImF4aXNcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiYmxvY2tfc2l6ZVwiLHR5cGU6XCJ1MzJcIn1dO3JldHVybmBcbiAgICAgICR7Sy5yZWdpc3RlclVuaWZvcm1zKGopLmRlY2xhcmVWYXJpYWJsZXMoLi4uUCxrKX1cbiAgICAgICR7Sy5tYWluU3RhcnQoKX1cbiAgICAgICAgICAke0suZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICAgICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7ay5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcblxuICAgICAgICAgIC8vIFNldCBpbnB1dCB4XG4gICAgICAgICAgJHsoKCk9Pmw/YFxuICAgICAgICAgICAgbGV0IGlucHV0ID0gJHtTLmdldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeCAvIDRcIil9O1xuICAgICAgICAgICAgbGV0IHhfdmVjID0gJHtvP1widW5wYWNrNHhJOChpbnB1dClcIjpcInVucGFjazR4VTgoaW5wdXQpXCJ9O1xuICAgICAgICAgICAgbGV0IHhfdmFsdWUgPSAkeyQ9PT0xP1wieF92ZWNbZ2xvYmFsX2lkeCAlIDRdXCI6XCJ4X3ZlY1wifTtgOmBsZXQgeF92YWx1ZSA9ICR7Uy5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIil9O2ApKCl9O1xuXG4gICAgICAgICAgLy8gU2V0IHNjYWxlIGlucHV0XG4gICAgICAgICAgJHsoKCk9Pl8/YGxldCBzY2FsZV92YWx1ZT0gJHtULmdldEJ5T2Zmc2V0KFwiMFwiKX1gOnk/YFxuICAgICAgICAgICAgbGV0IHNjYWxlX2luZGV4ID0gJHtrLmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLFwidW5pZm9ybXMuYXhpc1wiKX07XG4gICAgICAgICAgICBsZXQgc2NhbGVfdmFsdWU9ICR7VC5nZXRCeU9mZnNldChcInNjYWxlX2luZGV4XCIpfTtgOmBcbiAgICAgICAgICAgIHZhciBzY2FsZV9pbmRpY2VzOiAke1QudHlwZS5pbmRpY2VzfSA9IG91dHB1dF9pbmRpY2VzO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gJHtULmluZGljZXNHZXQoXCJzY2FsZV9pbmRpY2VzXCIsXCJ1bmlmb3Jtcy5heGlzXCIpfSAvIHVuaWZvcm1zLmJsb2NrX3NpemU7XG4gICAgICAgICAgICAke1QuaW5kaWNlc1NldChcInNjYWxlX2luZGljZXNcIixcInVuaWZvcm1zLmF4aXNcIixcImluZGV4XCIpfTtcbiAgICAgICAgICAgIGxldCBzY2FsZV92YWx1ZT0gJHtULmdldEJ5SW5kaWNlcyhcInNjYWxlX2luZGljZXNcIil9O2ApKCl9O1xuXG4gICAgICAgICAgLy8gU2V0IHplcm8tcG9pbnQgaW5wdXRcbiAgICAgICAgICAkeygoKT0+QT9fP2w/YFxuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2lucHV0ID0gJHtBLmdldEJ5T2Zmc2V0KFwiMFwiKX07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmVjID0gICR7bz9cInVucGFjazR4STgoemVyb19wb2ludF9pbnB1dClcIjpcInVucGFjazR4VTgoemVyb19wb2ludF9pbnB1dClcIn07XG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfdmFsdWU9IHplcm9fcG9pbnRfdmVjWzBdYDpgbGV0IHplcm9fcG9pbnRfdmFsdWUgPSAke0EuZ2V0QnlPZmZzZXQoXCIwXCIpfWA6eT9sP2BcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF9pbmRleCA9ICR7ay5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixcInVuaWZvcm1zLmF4aXNcIil9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2lucHV0ID0gJHtBLmdldEJ5T2Zmc2V0KFwiemVyb19wb2ludF9pbmRleCAvIDRcIil9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3ZlYyA9ICAke28/XCJ1bnBhY2s0eEk4KHplcm9fcG9pbnRfaW5wdXQpXCI6XCJ1bnBhY2s0eFU4KHplcm9fcG9pbnRfaW5wdXQpXCJ9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3ZhbHVlID0gemVyb19wb2ludF92ZWNbemVyb19wb2ludF9pbmRleCAlIDRdYDpgXG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfaW5kZXggPSAke2suaW5kaWNlc0dldChcIm91dHB1dF9pbmRpY2VzXCIsXCJ1bmlmb3Jtcy5heGlzXCIpfTtcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF92YWx1ZSA9ICR7QS5nZXRCeU9mZnNldChcInplcm9fcG9pbnRfaW5kZXhcIil9O2A6bD9gXG4gICAgICAgICAgICAgICAgbGV0IHplcm9fcG9pbnRfb2Zmc2V0ID0gJHtULmluZGljZXNUb09mZnNldChcInNjYWxlX2luZGljZXNcIil9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X2lucHV0ID0gJHtBLmdldEJ5T2Zmc2V0KFwiemVyb19wb2ludF9vZmZzZXQgLyA0XCIpfTtcbiAgICAgICAgICAgICAgICBsZXQgemVyb19wb2ludF92ZWMgPSAke28/XCJ1bnBhY2s0eEk4KHplcm9fcG9pbnRfaW5wdXQpXCI6XCJ1bnBhY2s0eFU4KHplcm9fcG9pbnRfaW5wdXQpXCJ9O1xuICAgICAgICAgICAgICAgIGxldCB6ZXJvX3BvaW50X3ZhbHVlID0gemVyb19wb2ludF92ZWNbemVyb19wb2ludF9vZmZzZXQgJSA0XTtgOmBsZXQgemVyb19wb2ludF92YWx1ZSA9ICR7QS5nZXRCeUluZGljZXMoXCJzY2FsZV9pbmRpY2VzXCIpfTtgOmBsZXQgemVyb19wb2ludF92YWx1ZSA9ICR7bD9vP1wiaTMyXCI6XCJ1MzJcIjpTLnR5cGUudmFsdWV9KDApO2ApKCl9O1xuICAgICAgLy8gQ29tcHV0ZSBhbmQgd3JpdGUgb3V0cHV0XG4gICAgICAke2suc2V0QnlPZmZzZXQoXCJnbG9iYWxfaWR4XCIsYCR7ay50eXBlLnZhbHVlfSh4X3ZhbHVlIC0gemVyb19wb2ludF92YWx1ZSkgKiBzY2FsZV92YWx1ZWApfTtcbiAgICAgIH1gfTtyZXR1cm57bmFtZTpcIkRlcXVhbnRpemVMaW5lYXJcIixzaGFkZXJDYWNoZTp7aGludDp0LmNhY2hlS2V5LGlucHV0RGVwZW5kZW5jaWVzOkE/W1wicmFua1wiLFwicmFua1wiLFwicmFua1wiXTpbXCJyYW5rXCIsXCJyYW5rXCJdfSxnZXRTaGFkZXJTb3VyY2U6RyxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmksZGF0YVR5cGU6YX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGQvJC82NCkseToxLHo6MX0scHJvZ3JhbVVuaWZvcm1zOlJ9KX19LCRsPShlLHQpPT57VGgoZS5pbnB1dHMsdCksZS5jb21wdXRlKEloKGUuaW5wdXRzLHQpKX0seGw9ZT0+cmUoe2F4aXM6ZS5heGlzLGJsb2NrU2l6ZTplLmJsb2NrU2l6ZX0pfSk7dmFyIENoLEFoLFRsLElsPVUoKCk9PntcInVzZSBzdHJpY3RcIjtXZSgpO3RlKCk7YWUoKTtDaD0oZSx0LHIpPT57bGV0IG49ZT09PXQsbz1lPHQmJnI8MCxpPWU+dCYmcj4wO2lmKG58fG98fGkpdGhyb3cgbmV3IEVycm9yKFwiUmFuZ2UgdGhlc2UgaW5wdXRzJyBjb250ZW50cyBhcmUgaW52YWxpZC5cIil9LEFoPShlLHQscixuKT0+e2xldCBvPU1hdGguYWJzKE1hdGguY2VpbCgodC1lKS9yKSksaT1bb10sYT1vLGQ9W3t0eXBlOjEyLGRhdGE6YX0se3R5cGU6bixkYXRhOmV9LHt0eXBlOm4sZGF0YTpyfSwuLi5OKGkpXSxsPXA9PntsZXQgbT1NKFwib3V0cHV0XCIsbixpLmxlbmd0aCksdT1tLnR5cGUudmFsdWUsaD1be25hbWU6XCJvdXRwdXRTaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInN0YXJ0XCIsdHlwZTp1fSx7bmFtZTpcImRlbHRhXCIsdHlwZTp1fV07cmV0dXJuYFxuICAgICAgICAke3AucmVnaXN0ZXJVbmlmb3JtcyhoKS5kZWNsYXJlVmFyaWFibGVzKG0pfVxuICAgICAgICAke3AubWFpblN0YXJ0KCl9XG4gICAgICAgICR7cC5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0U2l6ZVwiKX1cbiAgICAgICAgb3V0cHV0W2dsb2JhbF9pZHhdID0gdW5pZm9ybXMuc3RhcnQgKyAke3V9KGdsb2JhbF9pZHgpICogdW5pZm9ybXMuZGVsdGE7XG4gICAgICB9YH07cmV0dXJue25hbWU6XCJSYW5nZVwiLHNoYWRlckNhY2hlOntoaW50OmAke259YH0sZ2V0U2hhZGVyU291cmNlOmwsZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczppLGRhdGFUeXBlOm59XSxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChhLzY0KX0scHJvZ3JhbVVuaWZvcm1zOmR9KX19LFRsPWU9PntsZXQgdD0wLHI9MCxuPTA7ZS5pbnB1dHNbMF0uZGF0YVR5cGU9PT02Pyh0PWUuaW5wdXRzWzBdLmdldEludDMyQXJyYXkoKVswXSxyPWUuaW5wdXRzWzFdLmdldEludDMyQXJyYXkoKVswXSxuPWUuaW5wdXRzWzJdLmdldEludDMyQXJyYXkoKVswXSk6ZS5pbnB1dHNbMF0uZGF0YVR5cGU9PT0xJiYodD1lLmlucHV0c1swXS5nZXRGbG9hdDMyQXJyYXkoKVswXSxyPWUuaW5wdXRzWzFdLmdldEZsb2F0MzJBcnJheSgpWzBdLG49ZS5pbnB1dHNbMl0uZ2V0RmxvYXQzMkFycmF5KClbMF0pLHZlLndlYmdwdS52YWxpZGF0ZUlucHV0Q29udGVudCYmQ2godCxyLG4pLGUuY29tcHV0ZShBaCh0LHIsbixlLmlucHV0c1swXS5kYXRhVHlwZSkse2lucHV0czpbXX0pfX0pO3ZhciBraCxFaCxDbCxBbCxrbD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtvZSgpO1NlKCk7YWUoKTtraD0oZSx0LHIsbik9PntpZihlIT09XCJub25lXCImJm4hPT1cImkzMlwiJiZuIT09XCJ1MzJcIiYmbiE9PVwiZjMyXCIpdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAke259IGlzIG5vdCBzdXBwb3J0ZWQgd2l0aCByZWR1Y3Rpb24gJHtlfS5gKTtsZXQgbz1ge1xuICAgICAgICAgICAgICAgIHZhciBvbGRWYWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgbG9vcCB7XG4gICAgICAgICAgICAgICAgICBsZXQgbmV3VmFsdWVGMzIgPWAsaT1gO1xuICAgICAgICAgICAgICAgICAgbGV0IG5ld1ZhbHVlID0gYml0Y2FzdDxpMzI+KG5ld1ZhbHVlRjMyKTtcbiAgICAgICAgICAgICAgICAgIGxldCByZXMgPSBhdG9taWNDb21wYXJlRXhjaGFuZ2VXZWFrKCYke3R9LCBvbGRWYWx1ZSwgbmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgaWYgcmVzLmV4Y2hhbmdlZCB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgb2xkVmFsdWUgPSByZXMub2xkX3ZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfWA7c3dpdGNoKGUpe2Nhc2VcIm5vbmVcIjpyZXR1cm5gJHt0fT0ke3J9O2A7Y2FzZVwiYWRkXCI6cmV0dXJuIG49PT1cImkzMlwifHxuPT09XCJ1MzJcIj9gYXRvbWljQWRkKCYke3R9LCBiaXRjYXN0PCR7bn0+KCR7cn0pKTtgOmBcbiAgICAgICAgICAgICAgJHtvfWJpdGNhc3Q8JHtufT4ob2xkVmFsdWUpICsgKCR7cn0pJHtpfWA7Y2FzZVwibWF4XCI6cmV0dXJuIG49PT1cImkzMlwifHxuPT09XCJ1MzJcIj9gYXRvbWljTWF4KCYke3R9LCBiaXRjYXN0PCR7bn0+KCR7cn0pKTtgOmBcbiAgICAgICAgICAgICAgICAke299bWF4KGJpdGNhc3Q8ZjMyPihvbGRWYWx1ZSksICgke3J9KSkke2l9YDtjYXNlXCJtaW5cIjpyZXR1cm4gbj09PVwiaTMyXCJ8fG49PT1cInUzMlwiP2BhdG9taWNNaW4oJiR7dH0sIGJpdGNhc3Q8JHtufT4oJHtyfSkpO2A6YCR7b31taW4oYml0Y2FzdDwke259PihvbGRWYWx1ZSksICgke3J9KSkke2l9YDtjYXNlXCJtdWxcIjpyZXR1cm5gJHtvfShiaXRjYXN0PCR7bn0+KG9sZFZhbHVlKSAqICgke3J9KSkke2l9YDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgUmVkdWN0aW9uICR7ZX0gaXMgbm90IHN1cHBvcnRlZC5gKX19LEVoPShlLHQpPT57bGV0IHI9ZVswXS5kaW1zLG49ZVsxXS5kaW1zLG89cixpPTEsYT1NYXRoLmNlaWwoQy5zaXplKG4pL2kpLGQ9bltuLmxlbmd0aC0xXSxsPUMuc2l6ZUZyb21EaW1lbnNpb24ocixkKSxwPVt7dHlwZToxMixkYXRhOmF9LHt0eXBlOjEyLGRhdGE6ZH0se3R5cGU6MTIsZGF0YTpsfSwuLi5OKGVbMV0uZGltcyxlWzJdLmRpbXMsbyldLG09dT0+e2xldCBoPUUoXCJpbmRpY2VzXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMubGVuZ3RoKSxfPUUoXCJ1cGRhdGVzXCIsZVsyXS5kYXRhVHlwZSxlWzJdLmRpbXMubGVuZ3RoLGkpLHk9dC5yZWR1Y3Rpb24hPT1cIm5vbmVcIiYmdC5yZWR1Y3Rpb24hPT1cIlwiP3JzKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxvLmxlbmd0aCk6TShcIm91dHB1dFwiLGVbMF0uZGF0YVR5cGUsby5sZW5ndGgsaSk7cmV0dXJuYFxuICAgICAgJHt1LnJlZ2lzdGVyVW5pZm9ybShcIm91dHB1dF9zaXplXCIsXCJ1MzJcIikucmVnaXN0ZXJVbmlmb3JtKFwibGFzdF9pbmRleF9kaW1lbnNpb25cIixcInUzMlwiKS5yZWdpc3RlclVuaWZvcm0oXCJudW1fdXBkYXRlc19lbGVtZW50c1wiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoaCxfLHkpfVxuICAgICAgJHt1Lm1haW5TdGFydCgpfVxuICAgICAgICAke3UuZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInVuaWZvcm1zLm91dHB1dF9zaXplXCIpfVxuICB2YXIgZGF0YV9vZmZzZXQgPSAwdTtcbiAgbGV0IGluZGljZXNfc3RhcnQgPSB1bmlmb3Jtcy5sYXN0X2luZGV4X2RpbWVuc2lvbiAqIGdsb2JhbF9pZHg7XG4gIGxldCBpbmRpY2VzX2VuZCA9IGluZGljZXNfc3RhcnQgKyB1bmlmb3Jtcy5sYXN0X2luZGV4X2RpbWVuc2lvbjtcbiAgZm9yICh2YXIgaSA9IGluZGljZXNfc3RhcnQ7IGkgPCBpbmRpY2VzX2VuZDsgaSsrKSB7XG4gICAgdmFyIGluZGV4ID0gaTMyKGluZGljZXNbaV0ueCk7XG4gICAgJHtlWzBdLmRpbXMubGVuZ3RoPT09MT9gXG4gICAgbGV0IGVsZW1lbnRfY291bnRfZGltID0gdW5pZm9ybXMub3V0cHV0X3N0cmlkZXM7XG4gICAgbGV0IGRpbV92YWx1ZSA9IHVuaWZvcm1zLm91dHB1dF9zaGFwZTtgOmBcbiAgICBsZXQgZWxlbWVudF9jb3VudF9kaW0gPSB1bmlmb3Jtcy5vdXRwdXRfc3RyaWRlc1tpIC0gaW5kaWNlc19zdGFydF07XG4gICAgbGV0IGRpbV92YWx1ZSA9IHVuaWZvcm1zLm91dHB1dF9zaGFwZVtpIC0gaW5kaWNlc19zdGFydCArIHVuaWZvcm1zLmxhc3RfaW5kZXhfZGltZW5zaW9uXTtgfVxuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICBpZiAoaW5kZXggPj0gaTMyKGRpbV92YWx1ZSkpIHtcbiAgICAgICAgaW5kZXggPSBpMzIoZGltX3ZhbHVlIC0gMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpbmRleCA8IC1pMzIoZGltX3ZhbHVlKSkge1xuICAgICAgICBpbmRleCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmRleCArPSBpMzIoZGltX3ZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZGF0YV9vZmZzZXQgKz0gdTMyKCh1MzIoaW5kZXgpICogZWxlbWVudF9jb3VudF9kaW0pKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwdTsgaSA8IHVuaWZvcm1zLm51bV91cGRhdGVzX2VsZW1lbnRzOyBpKyspIHtcbiAgICBsZXQgdmFsdWUgPSB1cGRhdGVzW3VuaWZvcm1zLm51bV91cGRhdGVzX2VsZW1lbnRzICogZ2xvYmFsX2lkeCArIGldO1xuICAgICR7a2godC5yZWR1Y3Rpb24sXCJvdXRwdXRbZGF0YV9vZmZzZXQgKyBpXVwiLFwidmFsdWVcIix5LnR5cGUudmFsdWUpfVxuICB9XG5cbiAgICAgIH1gfTtyZXR1cm57bmFtZTpcIlNjYXR0ZXJORFwiLHNoYWRlckNhY2hlOntoaW50OmAke3QuY2FjaGVLZXl9XyR7dC5yZWR1Y3Rpb259YCxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCIsXCJyYW5rXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm8sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGEvNjQpfSxwcm9ncmFtVW5pZm9ybXM6cH0pLGdldFNoYWRlclNvdXJjZTptfX0sQ2w9ZT0+cmUoe3JlZHVjdGlvbjplLnJlZHVjdGlvbn0pLEFsPShlLHQpPT57ZS5jb21wdXRlKEVoKGUuaW5wdXRzLHQpLHtpbnB1dHM6W2UuaW5wdXRzWzFdLGUuaW5wdXRzWzJdXSxvdXRwdXRzOltdfSl9fSk7dmFyIFBoLHpoLE9oLERoLEJoLE1oLFJoLFVoLE5oLFZoLFdoLEVsLExoLEdoLEhoLEZoLHFoLFBsLHpsLE9sPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7U2UoKTthZSgpO1BoPShlLHQpPT57aWYoZS5ldmVyeShyPT5yPjB8fCgoKT0+e3Rocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBzY2FsZXMgaW5wdXQgdmFsdWVzIHRvIGJlIHBvc2l0aXZlXCIpfSkpLGUubGVuZ3RoPjApe2lmKHQubW9kZT09PVwibGluZWFyXCIpe2lmKCEoZS5sZW5ndGg9PT0yfHxlLmxlbmd0aD09PTN8fGUubGVuZ3RoPT09NCYmZVswXT09PTEmJmVbMV09PT0xfHxlLmxlbmd0aD09PTQmJmVbMF09PT0xJiZlWzNdPT09MXx8ZS5sZW5ndGg9PT01JiZlWzBdPT09MSYmZVsxXT09PTEpKXRocm93IG5ldyBFcnJvcihgRm9yIGxpbmVhciBtb2RlLCBSZXNpemUgcmVxdWlyZXMgc2NhbGVzIHRvIGJlIDJELCAzRCwgNEQgd2l0aCBlaXRoZXIgdHdvIG91dGVybW9zdCBvciBvbmUgaW5uZXJtb3N0IGFuZFxuICAgICAgICAgICAgb25lIG91dGVybW9zdCBzY2FsZSB2YWx1ZXMgZXF1YWwgdG8gMSwgb3IgNUQgd2l0aCB0d28gb3V0ZXJtb3N0IHNjYWxlIHZhbHVlcyBlcXVhbCB0byAxYCl9ZWxzZSBpZih0Lm1vZGU9PT1cImN1YmljXCImJiEoZS5sZW5ndGg9PT0yfHxlLmxlbmd0aD09PTQmJmVbMF09PT0xJiZlWzFdPT09MXx8ZS5sZW5ndGg9PT00JiZlWzBdPT09MSYmZVszXT09PTEpKXRocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBzY2FsZXMgaW5wdXQgc2l6ZSB0byBiZSAyIG9yIDQgZm9yIGN1YmljIG1vZGVcIil9fSx6aD0oZSx0LHIpPT57dC5ldmVyeShvPT5vPj0wJiZvPHJ8fCgoKT0+e3Rocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBheGVzIGlucHV0IHZhbHVlcyB0byBiZSBwb3NpdGl2ZSBhbmQgbGVzcyB0aGFuIHJhbmtcIil9KSk7bGV0IG49bmV3IEFycmF5KHIpLmZpbGwoMSk7cmV0dXJuIHQuZm9yRWFjaCgobyxpKT0+bltvXT1lW2ldKSxufSxPaD0oZSx0LHIsbixvLGkpPT57bGV0W2EsZCxsXT1yPjEwP1sxLDIsM106Wy0xLGUubGVuZ3RoPjE/MTotMSwtMV0scD1lWzBdLmRpbXMubGVuZ3RoO2lmKGE+MCYmZS5sZW5ndGg+YSYmZVthXS5kaW1zLmxlbmd0aD4wKWVbYV0uZ2V0RmxvYXQzMkFycmF5KCkuZm9yRWFjaChtPT5pLnB1c2gobSkpO2Vsc2UgaWYodC5jb29yZGluYXRlVHJhbnNmb3JtTW9kZT09PVwidGZfY3JvcF9hbmRfcmVzaXplXCIpdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIFJvSSBpbnB1dCB0byBiZSBzcGVjaWZpZWQgd2hlbiBjb29yZGluYXRlVHJhbnNmb3JtTW9kZSBpcyB0ZkNyb3BBbmRSZXNpemVcIik7aWYoZD4wJiZlLmxlbmd0aD5kJiZlW2RdLmRpbXMubGVuZ3RoPT09MSYmZVtkXS5kaW1zWzBdPjApe2lmKGVbZF0uZ2V0RmxvYXQzMkFycmF5KCkuZm9yRWFjaChtPT5uLnB1c2gobSkpLG4ubGVuZ3RoIT09MCYmbi5sZW5ndGghPT1wJiZyPj0xOCYmbi5sZW5ndGghPT10LmF4ZXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlJlc2l6ZSByZXF1aXJlcyBzY2FsZXMgaW5wdXQgc2l6ZSB0byBiZSBzYW1lIGFzIGlucHV0IHJhbmsgb3IgYXhlcyBzaXplIGZvciBvcHNldCAxOCBhbmQgdXBcIik7UGgobix0KSx0LmF4ZXMubGVuZ3RoPjAmJnpoKG4sdC5heGVzLHApLmZvckVhY2goKG0sdSk9Pm5bdV09bSl9aWYobD4wJiZlLmxlbmd0aD5sJiZlW2xdLmRpbXMubGVuZ3RoPT09MSYmZVtsXS5kaW1zWzBdPjAmJihlW2xdLmdldEJpZ0ludDY0QXJyYXkoKS5mb3JFYWNoKG09Pm8ucHVzaChOdW1iZXIobSkpKSxvLmxlbmd0aCE9PTAmJm8ubGVuZ3RoIT09cCYmcj49MTgmJm8ubGVuZ3RoIT09dC5heGVzLmxlbmd0aCkpdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIHNpemVzIGlucHV0IHNpemUgdG8gYmUgc2FtZSBhcyBpbnB1dCByYW5rIG9yIGF4ZXMgc2l6ZSBmb3Igb3BzZXQgMTggYW5kIHVwXCIpO2lmKHQuYXhlcy5sZW5ndGg+MCl7aWYobi5sZW5ndGghPT0wJiZuLmxlbmd0aCE9PXQuYXhlcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKCdSZXNpemUgcmVxdWlyZXMgXCJzY2FsZXNcIiBpbnB1dCBzaXplIHRvIGJlIG9mIGF4ZXMgcmFuayB3aGVuIGF4ZXMgYXR0cmlidXRlcyBpcyBzcGVjaWZpZWQnKTtpZihvLmxlbmd0aCE9PTAmJm8ubGVuZ3RoIT09dC5heGVzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoJ1Jlc2l6ZSByZXF1aXJlcyBcInNpemVzXCIgaW5wdXQgc2l6ZSB0byBiZSBvZiByYW5rIGF4ZXMgcmFuayB3aGVuIGF4ZXMgYXR0cmlidXRlcyBpcyBzcGVjaWZpZWQnKX1pZih0eXBlb2YgbjxcInVcIiYmdHlwZW9mIG88XCJ1XCImJm4ubGVuZ3RoPjAmJm8ubGVuZ3RoPnApdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIG9ubHkgb2Ygc2NhbGVzIG9yIHNpemVzIHRvIGJlIHNwZWNpZmllZFwiKX0sRGg9KGUsdCk9PmBmbiBnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUoeFJlc2l6ZWQ6IHUzMiwgeFNjYWxlOiBmMzIsIGxlbmd0aFJlc2l6ZWQ6IHUzMixcbiAgICAgbGVuZ3RoT3JpZ2luYWw6IHUzMiwgcm9pU3RhcnQ6IGYzMiwgcm9pRW5kOiBmMzIpIC0+ICR7dH0geyBgKygoKT0+e3N3aXRjaChlKXtjYXNlXCJhc3ltbWV0cmljXCI6cmV0dXJuYHJldHVybiAke3R9KHhSZXNpemVkKSAvICR7dH0oeFNjYWxlKTtgO2Nhc2VcInB5dG9yY2hfaGFsZl9waXhlbFwiOnJldHVybmBpZiAobGVuZ3RoUmVzaXplZCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgke3R9KHhSZXNpemVkKSArIDAuNSkgLyAke3R9KHhTY2FsZSkgLSAwLjU7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMC4wO1xuICAgICAgICAgICAgICAgICAgfWA7Y2FzZVwidGZfaGFsZl9waXhlbF9mb3Jfbm5cIjpyZXR1cm5gcmV0dXJuICgke3R9KHhSZXNpemVkKSArIDAuNSkgLyAke3R9KHhTY2FsZSk7YDtjYXNlXCJhbGlnbl9jb3JuZXJzXCI6cmV0dXJuYGlmIChsZW5ndGhSZXNpemVkID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDAuMDtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSB3aG9sZSBwYXJ0IGFuZCB0aGUgZnJhY3Rpb25hbCBwYXJ0IGFyZSBjYWxjdWxhdGVkIHNlcGFyYXRlbHkgZHVlIHRvIGluYWNjdXJhY3kgb2YgZmxvYXRpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gcG9pbnQgZGl2aXNpb24uIEFzIGFuIGV4YW1wbGUsIGYzMigyMSkgLyBmMzIoNykgbWF5IGV2YWx1YXRlIHRvIDIuOTkuLi4gaW5zdGVhZCBvZiAzLCBjYXVzaW5nIGFuXG4gICAgICAgICAgICAgICAgICAgIC8vIG9mZnNldC1ieS1vbmUgZXJyb3IgbGF0ZXIgaW4gZmxvb3IoKS5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHdob2xlID0gJHt0fSh4UmVzaXplZCAqIChsZW5ndGhPcmlnaW5hbCAtIDEpIC8gKGxlbmd0aFJlc2l6ZWQgLSAxKSk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmcmFjdCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAke3R9KHhSZXNpemVkICogKGxlbmd0aE9yaWdpbmFsIC0gMSkgJSAobGVuZ3RoUmVzaXplZCAtIDEpKSAvICR7dH0obGVuZ3RoUmVzaXplZCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2hvbGUgKyBmcmFjdDtcbiAgICAgICAgICAgICAgICAgIH1gO2Nhc2VcInRmX2Nyb3BfYW5kX3Jlc2l6ZVwiOnJldHVybmBpZiAobGVuZ3RoUmVzaXplZCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR7dH0ocm9pU3RhcnQpICogJHt0fShsZW5ndGhPcmlnaW5hbCAtIDEpICtcbiAgICAgICAgICAgICAgICAgICAgICAgICgke3R9KHhSZXNpemVkKSAqICR7dH0ocm9pRW5kIC0gcm9pU3RhcnQpICogJHt0fShsZW5ndGhPcmlnaW5hbCAtIDEpKSAvXG4gICAgICAgICAgICAgICAgICAgICAgICAke3R9KGxlbmd0aFJlc2l6ZWQgLSAxKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwLjUgKiAke3R9KHJvaVN0YXJ0ICsgcm9pRW5kKSAqICR7dH0obGVuZ3RoT3JpZ2luYWwgLSAxKTtcbiAgICAgICAgICAgICAgICAgIH1gO2Nhc2VcImhhbGZfcGl4ZWxfc3ltbWV0cmljXCI6cmV0dXJuYGNvbnN0IG91dHB1dFdpZHRoID0gJHt0fXhTY2FsZSAqICR7dH0obGVuZ3RoUmVzaXplZCk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBhZGp1c3RtZW50ID0gJHt0fShsZW5ndGhSZXNpemVkKSAvIG91dHB1dFdpZHRoO1xuICAgICAgICAgICAgICAgICAgY29uc3QgY2VudGVyID0gJHt0fShsZW5ndGhPcmlnaW5hbCkgLyAyO1xuICAgICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gY2VudGVyICogKDEgLSBhZGp1c3RtZW50KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBvZmZzZXQgKyAoKCR7dH0oeFJlc2l6ZWQpICsgMC41KSAvICR7dH0oeFNjYWxlKSkgLSAwLjU7YDtjYXNlXCJoYWxmX3BpeGVsXCI6cmV0dXJuYHJldHVybiAoKCR7dH0oeFJlc2l6ZWQpICsgMC41KSAvICR7dH0oeFNjYWxlKSkgLSAwLjU7YDtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgQ29vcmRpbmF0ZSB0cmFuc2Zvcm0gbW9kZSAke2V9IGlzIG5vdCBzdXBwb3J0ZWRgKX19KSgpK1wifVwiLEJoPShlLHQscik9PmBmbiBnZXROZWFyZXN0UGl4ZWxGcm9tT3JpZ2luYWwoeE9yaWdpbmFsOiAke3J9LCBpc0Rvd25TYW1wbGU6IGJvb2wpIC0+ICR7cn0ge2ArKCgpPT57c3dpdGNoKGUpe2Nhc2VcInJvdW5kX3ByZWZlcl9jZWlsXCI6cmV0dXJuXCJpZiAoZnJhY3QoeE9yaWdpbmFsKSA9PSAwLjUpIHsgICAgICAgICAgICAgcmV0dXJuIGNlaWwoeE9yaWdpbmFsKTsgICAgICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgIHJldHVybiByb3VuZCh4T3JpZ2luYWwpOyAgICAgICAgICAgfVwiO2Nhc2VcImZsb29yXCI6cmV0dXJuXCJyZXR1cm4gZmxvb3IoeE9yaWdpbmFsKTtcIjtjYXNlXCJjZWlsXCI6cmV0dXJuXCJyZXR1cm4gY2VpbCh4T3JpZ2luYWwpO1wiO2Nhc2VcInJvdW5kX3ByZWZlcl9mbG9vclwiOnJldHVyblwiaWYgKGZyYWN0KHhPcmlnaW5hbCkgPT0gMC41KSB7ICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZsb29yKHhPcmlnaW5hbCk7ICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJvdW5kKHhPcmlnaW5hbCk7ICAgICAgICAgICAgICAgICAgIH1cIjtjYXNlXCJzaW1wbGVcIjpkZWZhdWx0OmlmKHQ8MTEpcmV0dXJuXCJpZiAoaXNEb3duU2FtcGxlKSAgICAgICAgICAgICAgICAgICAgIHsgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjZWlsKHhPcmlnaW5hbCk7ICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4T3JpZ2luYWw7ICAgICAgICAgICAgICAgICAgICAgfVwiO3Rocm93IG5ldyBFcnJvcihgTmVhcmVzdCBtb2RlICR7ZX0gaXMgbm90IHN1cHBvcnRlZGApfX0pKCkrXCJ9XCIsTWg9KGUsdCxyKT0+e2xldCBuPW5ldyBBcnJheShyKS5maWxsKDApLmNvbmNhdChuZXcgQXJyYXkocikuZmlsbCgxKSksbz1lLmxlbmd0aD09PTA/bjplLnNsaWNlKCk7cmV0dXJuIHQubGVuZ3RoPjA/KHQuZm9yRWFjaCgoaSxhKT0+e25baV09b1thXSxuW2Ercl09b1t0Lmxlbmd0aCthXX0pLG4pOm99LFJoPShlLHQscixuKT0+e2xldCBvPVtdO2lmKHIubGVuZ3RoPjApaWYobi5sZW5ndGg+MCl7aWYoZS5mb3JFYWNoKGk9Pm8ucHVzaChpKSksTWF0aC5tYXgoLi4ubik+ZS5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiYXhlcyBpcyBvdXQgb2YgYm91bmRcIik7bi5mb3JFYWNoKChpLGEpPT5vW2ldPXJbYV0pfWVsc2Ugci5mb3JFYWNoKGk9Pm8ucHVzaChpKSk7ZWxzZXtpZih0Lmxlbmd0aD09PTApdGhyb3cgbmV3IEVycm9yKFwiUmVzaXplIHJlcXVpcmVzIGVpdGhlciBzY2FsZXMgb3Igc2l6ZXMuXCIpO289ZS5tYXAoKGksYSk9Pk1hdGgucm91bmQoaSp0W2FdKSl9cmV0dXJuIG99LFVoPShlLHQscik9PntsZXQgbj0oKCk9Pntzd2l0Y2goci5rZWVwQXNwZWN0UmF0aW9Qb2xpY3kpe2Nhc2VcIm5vdF9sYXJnZXJcIjpyZXR1cm4gci5heGVzLmxlbmd0aD4wP01hdGgubWluKC4uLnIuYXhlcy5tYXAoaT0+dFtpXSksTnVtYmVyLk1BWF9WQUxVRSk6TWF0aC5taW4oLi4udCxOdW1iZXIuTUFYX1ZBTFVFKTtjYXNlXCJub3Rfc21hbGxlclwiOnJldHVybiByLmF4ZXMubGVuZ3RoPjA/TWF0aC5tYXgoLi4uci5heGVzLm1hcChpPT50W2ldKSxOdW1iZXIuTUlOX1ZBTFVFKTpNYXRoLm1heCguLi50LE51bWJlci5NSU5fVkFMVUUpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBLZWVwIGFzcGVjdCByYXRpbyBwb2xpY3kgJHtyLmtlZXBBc3BlY3RSYXRpb1BvbGljeX0gaXMgbm90IHN1cHBvcnRlZGApfX0pKCk7dC5maWxsKDEsMCx0Lmxlbmd0aCk7bGV0IG89ZS5zbGljZSgpO3JldHVybiByLmF4ZXMubGVuZ3RoPjA/KHIuYXhlcy5mb3JFYWNoKGk9PnRbaV09biksci5heGVzLmZvckVhY2goaT0+b1tpXT1NYXRoLnJvdW5kKGVbaV0qdFtpXSkpKToodC5maWxsKG4sMCx0Lmxlbmd0aCksby5mb3JFYWNoKChpLGEpPT5vW2FdPU1hdGgucm91bmQoaSp0W2FdKSkpLG99LE5oPShlLHQscixuLG8pPT5gXG4gICAgZm4gY2FsY3VsYXRlT3JpZ2luYWxJbmRpY2VzRnJvbU91dHB1dEluZGljZXMob3V0cHV0X2luZGljZXM6ICR7ZS50eXBlLmluZGljZXN9KSAtPiBhcnJheTwke2UudHlwZS52YWx1ZX0sICR7ci5sZW5ndGh9PiB7XG4gICAgICB2YXIgb3JpZ2luYWxfaW5kaWNlczogYXJyYXk8JHtlLnR5cGUudmFsdWV9LCAke3IubGVuZ3RofT47XG4gICAgICBmb3IgKHZhciBpOnUzMiA9IDA7IGkgPCAke3IubGVuZ3RofTsgaSsrKSB7XG4gICAgICAgIHZhciBvdXRwdXRfaW5kZXggPSAke2UuaW5kaWNlc0dldChcIm91dHB1dF9pbmRpY2VzXCIsXCJpXCIpfTtcbiAgICAgICAgdmFyIHNjYWxlID0gJHtGKFwidW5pZm9ybXMuc2NhbGVzXCIsXCJpXCIsbil9O1xuICAgICAgICB2YXIgcm9pX2xvdyA9ICR7RihcInVuaWZvcm1zLnJvaVwiLFwiaVwiLG8pfTtcbiAgICAgICAgdmFyIHJvaV9oaSA9ICR7RihcInVuaWZvcm1zLnJvaVwiLGBpICsgJHt0Lmxlbmd0aH1gLG8pfTtcbiAgICAgICAgaWYgKHNjYWxlID09IDEuMCkge1xuICAgICAgICAgIG9yaWdpbmFsX2luZGljZXNbaV0gPSAke2UudHlwZS52YWx1ZX0ob3V0cHV0X2luZGV4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgaW5wdXRfc2hhcGVfaSA9ICR7RihcInVuaWZvcm1zLmlucHV0X3NoYXBlXCIsXCJpXCIsdC5sZW5ndGgpfTtcbiAgICAgICAgICB2YXIgb3V0cHV0X3NoYXBlX2kgPSAke0YoXCJ1bmlmb3Jtcy5vdXRwdXRfc2hhcGVcIixcImlcIixyLmxlbmd0aCl9O1xuICAgICAgICAgIG9yaWdpbmFsX2luZGljZXNbaV0gPSBnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUob3V0cHV0X2luZGV4LCBzY2FsZSwgb3V0cHV0X3NoYXBlX2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dF9zaGFwZV9pLCByb2lfbG93LCByb2lfaGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ2luYWxfaW5kaWNlcztcbiAgICB9YCxWaD0oZSx0LHIsbixvLGksYSk9PmBcbiAgICBmbiBjYWxjdWxhdGVJbnB1dEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlczogJHt0LnR5cGUuaW5kaWNlc30pIC0+ICR7ZS50eXBlLmluZGljZXN9IHtcbiAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke2UudHlwZS5pbmRpY2VzfTtcbiAgICAgIGZvciAodmFyIGk6dTMyID0gMDsgaSA8ICR7bi5sZW5ndGh9OyBpKyspIHtcbiAgICAgICAgdmFyIG91dHB1dF9pbmRleCA9ICR7dC5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIixcImlcIil9O1xuICAgICAgICB2YXIgaW5wdXRfaW5kZXg6IHUzMjtcbiAgICAgICAgdmFyIHNjYWxlID0gJHtGKFwidW5pZm9ybXMuc2NhbGVzXCIsXCJpXCIsbyl9O1xuICAgICAgICBpZiAoc2NhbGUgPT0gMS4wKSB7XG4gICAgICAgICAgaW5wdXRfaW5kZXggPSBvdXRwdXRfaW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHJvaV9sb3cgPSAke0YoXCJ1bmlmb3Jtcy5yb2lcIixcImlcIixpKX07XG4gICAgICAgICAgdmFyIHJvaV9oaSA9ICR7RihcInVuaWZvcm1zLnJvaVwiLGBpICsgJHtyLmxlbmd0aH1gLGkpfTtcbiAgICAgICAgICB2YXIgaW5wdXRfc2hhcGVfaSA9ICR7RihcInVuaWZvcm1zLmlucHV0X3NoYXBlXCIsXCJpXCIsci5sZW5ndGgpfTtcbiAgICAgICAgICB2YXIgb3V0cHV0X3NoYXBlX2kgPSAke0YoXCJ1bmlmb3Jtcy5vdXRwdXRfc2hhcGVcIixcImlcIixuLmxlbmd0aCl9O1xuICAgICAgICAgIHZhciBvcmlnaW5hbF9pZHggPSBnZXRPcmlnaW5hbENvb3JkaW5hdGVGcm9tUmVzaXplZENvb3JkaW5hdGUob3V0cHV0X2luZGV4LCBzY2FsZSwgb3V0cHV0X3NoYXBlX2ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dF9zaGFwZV9pLCByb2lfbG93LCByb2lfaGkpO1xuICAgICAgICAgIGlmICghJHthfSB8fCAob3JpZ2luYWxfaWR4ID49IDAgJiYgb3JpZ2luYWxfaWR4IDwgJHt0LnR5cGUudmFsdWV9KGlucHV0X3NoYXBlX2kpKSkge1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsX2lkeCA8IDApIHtcbiAgICAgICAgICAgICAgaW5wdXRfaW5kZXggPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvcmlnaW5hbF9pZHggPiAke3QudHlwZS52YWx1ZX0oaW5wdXRfc2hhcGVfaSAtIDEpKSB7XG4gICAgICAgICAgICAgIGlucHV0X2luZGV4ID0gaW5wdXRfc2hhcGVfaSAtIDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpbnB1dF9pbmRleCA9IHUzMihnZXROZWFyZXN0UGl4ZWxGcm9tT3JpZ2luYWwob3JpZ2luYWxfaWR4LCBzY2FsZSA8IDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5wdXRfaW5kZXggPSB1MzIob3JpZ2luYWxfaWR4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgJHtlLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsXCJpXCIsXCIgaW5wdXRfaW5kZXhcIil9XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5wdXRfaW5kaWNlcztcbiAgICB9YCxXaD0oZSx0KT0+YFxuICAgIGZuIGNoZWNrSW5wdXRJbmRpY2VzKGlucHV0X2luZGljZXM6ICR7ZS50eXBlLmluZGljZXN9KSAtPiBib29sIHtcbiAgICAgIGZvciAodmFyIGk6dTMyID0gMDsgaSA8ICR7dC5sZW5ndGh9OyBpKyspIHtcbiAgICAgICAgdmFyIGlucHV0X2luZGV4ID0gJHtlLmluZGljZXNHZXQoXCJpbnB1dF9pbmRpY2VzXCIsXCJpXCIpfTtcbiAgICAgICAgaWYgKGlucHV0X2luZGV4IDwgMCB8fCBpbnB1dF9pbmRleCA+PSAke0YoXCJ1bmlmb3Jtcy5pbnB1dF9zaGFwZVwiLFwiaVwiLHQubGVuZ3RoKX0pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1gLEVsPShlLHQscixuKT0+ZS5yYW5rPm4/YFxuICAgICR7ZS5pbmRpY2VzU2V0KFwiaW5wdXRfaW5kaWNlc1wiLHQsXCJjaGFubmVsXCIpfTtcbiAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixyLFwiYmF0Y2hcIil9O1xuYDpcIlwiLExoPShlLHQscixuLG8pPT57bGV0W2EsZCxsLHBdPXIubGVuZ3RoPT09Mj9bLTEsMCwxLC0xXTpbMCwyLDMsMV0sbT1lLnR5cGUudmFsdWU7cmV0dXJuYFxuICAgIGZuIGdldElucHV0VmFsdWUoYmF0Y2g6IHUzMiwgY2hhbm5lbDogdTMyLCByb3c6IHUzMiwgY29sOiB1MzIpIC0+ICR7bX0ge1xuICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7ZS50eXBlLmluZGljZXN9O1xuICAgICAgJHtlLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsZCxgbWF4KDAsIG1pbihyb3csICR7cltkXX0gLSAxKSlgKX07XG4gICAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixsLGBtYXgoMCwgbWluKGNvbCwgJHtyW2xdfSAtIDEpKWApfTtcbiAgICAgICR7RWwoZSxwLGEsMil9XG4gICAgICByZXR1cm4gJHtlLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIil9O1xuICAgIH1cblxuICAgIGZuIGJpbGluZWFySW50ZXJwb2xhdGlvbihvdXRwdXRfaW5kaWNlczogJHt0LnR5cGUuaW5kaWNlc30pIC0+ICR7bX0ge1xuICAgICAgdmFyIG9yaWdpbmFsSW5kaWNlcyA9IGNhbGN1bGF0ZU9yaWdpbmFsSW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzKTtcbiAgICAgIHZhciByb3c6JHttfSA9IG9yaWdpbmFsSW5kaWNlc1ske2R9XTtcbiAgICAgIHZhciBjb2w6JHttfSA9IG9yaWdpbmFsSW5kaWNlc1ske2x9XTtcbiAgICAgICR7bj9gaWYgKHJvdyA8IDAgfHwgcm93ID4gKCR7cltkXX0gLSAxKSB8fCBjb2wgPCAwIHx8IGNvbCA+ICgke3JbbF19IC0gMSkpIHtcbiAgICAgICAgcmV0dXJuICR7b307XG4gICAgICB9YDpcIlwifTtcbiAgICAgIHJvdyA9IG1heCgwLCBtaW4ocm93LCAke3JbZF19IC0gMSkpO1xuICAgICAgY29sID0gbWF4KDAsIG1pbihjb2wsICR7cltsXX0gLSAxKSk7XG4gICAgICB2YXIgcm93MTogdTMyID0gdTMyKHJvdyk7XG4gICAgICB2YXIgY29sMTogdTMyID0gdTMyKGNvbCk7XG4gICAgICB2YXIgcm93MjogdTMyID0gdTMyKHJvdyArIDEpO1xuICAgICAgdmFyIGNvbDI6IHUzMiA9IHUzMihjb2wgKyAxKTtcbiAgICAgIHZhciBjaGFubmVsOiB1MzIgPSAke3IubGVuZ3RoPjI/YHUzMihvcmlnaW5hbEluZGljZXNbJHtwfV0pYDpcIjBcIn07XG4gICAgICB2YXIgYmF0Y2g6IHUzMiA9ICAke3IubGVuZ3RoPjI/YHUzMihvcmlnaW5hbEluZGljZXNbJHthfV0pYDpcIjBcIn07XG4gICAgICB2YXIgeDExOiAke219ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgcm93MSwgY29sMSk7XG4gICAgICB2YXIgeDEyOiAke219ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgcm93MSwgY29sMik7XG4gICAgICB2YXIgeDIxOiAke219ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgcm93MiwgY29sMSk7XG4gICAgICB2YXIgeDIyOiAke219ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgcm93MiwgY29sMik7XG4gICAgICB2YXIgZHgxOiAke219ID0gYWJzKHJvdyAtICR7bX0ocm93MSkpO1xuICAgICAgdmFyIGR4MjogJHttfSA9IGFicygke219KHJvdzIpIC0gcm93KTtcbiAgICAgIHZhciBkeTE6ICR7bX0gPSBhYnMoY29sIC0gJHttfShjb2wxKSk7XG4gICAgICB2YXIgZHkyOiAke219ID0gYWJzKCR7bX0oY29sMikgLSBjb2wpO1xuICAgICAgaWYgKHJvdzEgPT0gcm93Mikge1xuICAgICAgICBkeDEgPSAwLjU7XG4gICAgICAgIGR4MiA9IDAuNTtcbiAgICAgIH1cbiAgICAgIGlmIChjb2wxID09IGNvbDIpIHtcbiAgICAgICAgZHkxID0gMC41O1xuICAgICAgICBkeTIgPSAwLjU7XG4gICAgICB9XG4gICAgICByZXR1cm4gKHgxMSAqIGR4MiAqIGR5MiArIHgxMiAqIGR4MiAqIGR5MSArIHgyMSAqIGR4MSAqIGR5MiArIHgyMiAqIGR4MSAqIGR5MSk7XG4gICAgfWB9LEdoPShlLHQscixuLG8saSxhLGQsbCxwKT0+e2xldCBtPXIubGVuZ3RoPT09Mix1PSEwLFtoLF9dPW0/WzAsMV06dT9bMiwzXTpbMSwyXSx5PWUudHlwZS52YWx1ZSxnPXg9PntsZXQgJD14PT09aD9cInJvd1wiOlwiY29sXCI7cmV0dXJuYFxuICAgICAgZm4gJHskfUN1YmljSW50ZXJwb2xhdGlvbihpbnB1dF9pbmRpY2VzOiAke2UudHlwZS5pbmRpY2VzfSwgb3V0cHV0X2luZGljZXM6ICR7dC50eXBlLmluZGljZXN9KSAtPiAke3l9IHtcbiAgICAgICAgdmFyIG91dHB1dF9pbmRleCA9ICR7dC5pbmRpY2VzR2V0KFwib3V0cHV0X2luZGljZXNcIix4KX07XG4gICAgICAgIHZhciBvcmlnaW5hbElkeDogJHt5fSA9IGdldE9yaWdpbmFsQ29vcmRpbmF0ZUZyb21SZXNpemVkQ29vcmRpbmF0ZShvdXRwdXRfaW5kZXgsICR7b1t4XX0sXG4gICAgICAgICR7blt4XX0sICR7clt4XX0sICR7aVt4XX0sICR7aVt4XX0gKyAke3IubGVuZ3RofSk7XG4gICAgICAgIHZhciBmcmFjdE9yaWdpbmFsSWR4OiAke3l9ID0gb3JpZ2luYWxJZHggLSBmbG9vcihvcmlnaW5hbElkeCk7XG4gICAgICAgIHZhciBjb2VmcyA9IGdldEN1YmljSW50ZXJwb2xhdGlvbkNvZWZzKGZyYWN0T3JpZ2luYWxJZHgpO1xuXG4gICAgICAgIGlmICgke2R9ICYmIChvcmlnaW5hbElkeCA8IDAgfHwgb3JpZ2luYWxJZHggPiAoJHtyW3hdfSAtIDEpKSkge1xuICAgICAgICAgIHJldHVybiAke2x9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXRhOiBhcnJheTwke3l9LCA0PiA9IGFycmF5PCR7eX0sIDQ+KDAuMCwgMC4wLCAwLjAsIDAuMCk7XG4gICAgICAgIGZvciAodmFyIGk6IGkzMiA9IC0xOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgdmFyICR7JH06ICR7eX0gPSBvcmlnaW5hbElkeCArICR7eX0oaSk7XG4gICAgICAgICAgaWYgKCR7JH0gPCAwIHx8ICR7JH0gPj0gJHtyW3hdfSkge1xuICAgICAgICAgICAgJHsoKCk9PnA/YGNvZWZzW2kgKyAxXSA9IDAuMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO2A6ZD9gcmV0dXJuICR7bH07YDpgJHskfSA9IG1heCgwLCBtaW4oJHskfSwgJHtyW3hdfSAtIDEpKTtgKSgpfTtcbiAgICAgICAgICB9XG4gICAgICAgIHZhciBpbnB1dF9pbmRpY2VzX2NvcHk6ICR7ZS50eXBlLmluZGljZXN9ID0gaW5wdXRfaW5kaWNlcztcbiAgICAgICAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNfY29weVwiLHgsYHUzMigkeyR9KWApfTtcbiAgICAgICAgICBkYXRhW2kgKyAxXSA9ICR7eD09PWg/ZS5nZXRCeUluZGljZXMoXCJpbnB1dF9pbmRpY2VzX2NvcHlcIik6XCJyb3dDdWJpY0ludGVycG9sYXRpb24oaW5wdXRfaW5kaWNlc19jb3B5LCBvdXRwdXRfaW5kaWNlcylcIn07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1YmljSW50ZXJwb2xhdGlvbjFEKGRhdGEsIGNvZWZzKTtcbiAgICAgIH1gfTtyZXR1cm5gXG4gICAgJHtnKGgpfTtcbiAgICAke2coXyl9O1xuICBmbiBnZXRDdWJpY0ludGVycG9sYXRpb25Db2VmcyhzOiAke3l9KSAtPiBhcnJheTwke3l9LCA0PiB7XG4gICAgdmFyIGFic1MgPSBhYnMocyk7XG4gICAgdmFyIGNvZWZmczogYXJyYXk8JHt5fSwgND4gPSBhcnJheTwke3l9LCA0PigwLjAsIDAuMCwgMC4wLCAwLjApO1xuICAgIHZhciBvbmVNaW51c0Fic1M6ICR7eX0gPSAxLjAgLSBhYnNTO1xuICAgIHZhciB0d29NaW51c0Fic1M6ICR7eX0gPSAyLjAgLSBhYnNTO1xuICAgIHZhciBvbmVQbHVzQWJzUzogJHt5fSA9IDEuMCArIGFic1M7XG4gICAgY29lZmZzWzBdID0gKCgke2F9ICogb25lUGx1c0Fic1MgLSA1ICogJHthfSkgKiBvbmVQbHVzQWJzUyArIDggKiAke2F9KSAqIG9uZVBsdXNBYnNTIC0gNCAqICR7YX07XG4gICAgY29lZmZzWzFdID0gKCgke2F9ICsgMikgKiBhYnNTIC0gKCR7YX0gKyAzKSkgKiBhYnNTICogYWJzUyArIDE7XG4gICAgY29lZmZzWzJdID0gKCgke2F9ICsgMikgKiBvbmVNaW51c0Fic1MgLSAoJHthfSArIDMpKSAqIG9uZU1pbnVzQWJzUyAqIG9uZU1pbnVzQWJzUyArIDE7XG4gICAgY29lZmZzWzNdID0gKCgke2F9ICogdHdvTWludXNBYnNTIC0gNSAqICR7YX0pICogdHdvTWludXNBYnNTICsgOCAqICR7YX0pICogdHdvTWludXNBYnNTIC0gNCAqICR7YX07XG4gICAgcmV0dXJuIGNvZWZmcztcbiAgfVxuXG4gIGZuIGN1YmljSW50ZXJwb2xhdGlvbjFEKHg6IGFycmF5PCR7eX0sIDQ+LCBjb2VmczogYXJyYXk8JHt5fSwgND4pIC0+ICR7eX0ge1xuICAgIHZhciBjb2Vmc1N1bTogJHt5fSA9IGNvZWZzWzBdICsgY29lZnNbMV0gKyBjb2Vmc1syXSArIGNvZWZzWzNdO1xuICAgIHJldHVybiAoeFswXSAqIGNvZWZzWzBdICsgeFsxXSAqIGNvZWZzWzFdKyB4WzJdICogY29lZnNbMl0rIHhbM10gKiBjb2Vmc1szXSkgLyBjb2Vmc1N1bTtcbiAgfVxuXG4gIGZuIGJpY3ViaWNJbnRlcnBvbGF0aW9uKG91dHB1dF9pbmRpY2VzOiAke3QudHlwZS5pbmRpY2VzfSkgLT4gJHt5fSB7XG4gICAgdmFyIGlucHV0X2luZGljZXM6ICR7ZS50eXBlLmluZGljZXN9ID0gb3V0cHV0X2luZGljZXM7XG4gICAgcmV0dXJuIGNvbEN1YmljSW50ZXJwb2xhdGlvbihpbnB1dF9pbmRpY2VzLCBvdXRwdXRfaW5kaWNlcyk7XG4gIH1cbiAgICBgfSxIaD0oZSx0LHIsbixvKT0+e2xldFthLGQsbCxwLG1dPXIubGVuZ3RoPT09Mz9bLTEsMCwxLDIsLTFdOlswLDIsMyw0LDFdLHU9ZS50eXBlLnZhbHVlO3JldHVybmBcbiAgICBmbiBnZXRJbnB1dFZhbHVlKGJhdGNoOiB1MzIsIGNoYW5uZWw6IHUzMiwgZGVwdGg6dTMyLCBoZWlnaHQ6IHUzMiwgd2lkdGg6IHUzMikgLT4gJHt1fSB7XG4gICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtlLnR5cGUuaW5kaWNlc307XG4gICAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixkLGBtYXgoMCwgbWluKGRlcHRoLCAke3JbZF19IC0gMSkpYCl9O1xuICAgICAgJHtlLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsbCxgbWF4KDAsIG1pbihoZWlnaHQsICR7cltsXX0gLSAxKSlgKX07XG4gICAgICAke2UuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixwLGBtYXgoMCwgbWluKHdpZHRoLCAke3JbcF19IC0gMSkpYCl9O1xuICAgICAgJHtFbChlLG0sYSwzKX1cbiAgICAgIHJldHVybiAke2UuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07XG4gICAgfVxuXG4gICAgZm4gdHJpbGluZWFySW50ZXJwb2xhdGlvbihvdXRwdXRfaW5kaWNlczogJHt0LnR5cGUuaW5kaWNlc30pIC0+ICR7dX0ge1xuICAgICAgdmFyIG9yaWdpbmFsSW5kaWNlcyA9IGNhbGN1bGF0ZU9yaWdpbmFsSW5kaWNlc0Zyb21PdXRwdXRJbmRpY2VzKG91dHB1dF9pbmRpY2VzKTtcbiAgICAgIHZhciBkZXB0aDoke3V9ID0gb3JpZ2luYWxJbmRpY2VzWyR7ZH1dO1xuICAgICAgdmFyIGhlaWdodDoke3V9ID0gb3JpZ2luYWxJbmRpY2VzWyR7bH1dO1xuICAgICAgdmFyIHdpZHRoOiR7dX0gPSBvcmlnaW5hbEluZGljZXNbJHtwfV07XG4gICAgICAke24/YGlmIChkZXB0aCA8IDAgfHwgZGVwdGggPiAoJHtyW2RdfSAtIDEpIHx8IGhlaWdodCA8IDAgfHwgaGVpZ2h0ID4gKCR7cltsXX0gLSAxKSB8fCB3aWR0aCA8IDAgfHwgKHdpZHRoID4gJHtyW3BdfSAtIDEpKSB7XG4gICAgICByZXR1cm4gJHtvfTtcbiAgICAgICAgfWA6XCJcIn07XG5cbiAgICBkZXB0aCA9IG1heCgwLCBtaW4oZGVwdGgsICR7cltkXX0gLSAxKSk7XG4gICAgICBoZWlnaHQgPSBtYXgoMCwgbWluKGhlaWdodCwgJHtyW2xdfSAtIDEpKTtcbiAgICAgIHdpZHRoID0gbWF4KDAsIG1pbih3aWR0aCwgJHtyW3BdfSAtIDEpKTtcbiAgICAgIHZhciBkZXB0aDE6IHUzMiA9IHUzMihkZXB0aCk7XG4gICAgICB2YXIgaGVpZ2h0MTogdTMyID0gdTMyKGhlaWdodCk7XG4gICAgICB2YXIgd2lkdGgxOiB1MzIgPSB1MzIod2lkdGgpO1xuICAgICAgdmFyIGRlcHRoMjogdTMyID0gdTMyKGRlcHRoICsgMSk7XG4gICAgICB2YXIgaGVpZ2h0MjogdTMyID0gdTMyKGhlaWdodCArIDEpO1xuICAgICAgdmFyIHdpZHRoMjogdTMyID0gdTMyKHdpZHRoICsgMSk7XG4gICAgICB2YXIgY2hhbm5lbDogdTMyID0gJHtyLmxlbmd0aD4zP2B1MzIob3JpZ2luYWxJbmRpY2VzWyR7bX1dKWA6XCIwXCJ9O1xuICAgICAgdmFyIGJhdGNoOiB1MzIgPSAgJHtyLmxlbmd0aD4zP2B1MzIob3JpZ2luYWxJbmRpY2VzWyR7YX1dKWA6XCIwXCJ9O1xuXG4gICAgICB2YXIgeDExMTogJHt1fSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMSwgaGVpZ2h0MSwgd2lkdGgxKTtcbiAgICAgIHZhciB4MTEyOiAke3V9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgxLCBoZWlnaHQxLCB3aWR0aDIpO1xuICAgICAgdmFyIHgxMjE6ICR7dX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDEsIGhlaWdodDIsIHdpZHRoMSk7XG4gICAgICB2YXIgeDEyMjogJHt1fSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMSwgaGVpZ2h0Miwgd2lkdGgyKTtcbiAgICAgIHZhciB4MjExOiAke3V9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgyLCBoZWlnaHQxLCB3aWR0aDEpO1xuICAgICAgdmFyIHgyMTI6ICR7dX0gPSBnZXRJbnB1dFZhbHVlKGJhdGNoLCBjaGFubmVsLCBkZXB0aDIsIGhlaWdodDEsIHdpZHRoMik7XG4gICAgICB2YXIgeDIyMTogJHt1fSA9IGdldElucHV0VmFsdWUoYmF0Y2gsIGNoYW5uZWwsIGRlcHRoMiwgaGVpZ2h0Miwgd2lkdGgxKTtcbiAgICAgIHZhciB4MjIyOiAke3V9ID0gZ2V0SW5wdXRWYWx1ZShiYXRjaCwgY2hhbm5lbCwgZGVwdGgyLCBoZWlnaHQyLCB3aWR0aDIpO1xuICAgICAgdmFyIGR4MTogJHt1fSA9IGFicyhkZXB0aCAtICR7dX0oZGVwdGgxKSk7XG4gICAgICB2YXIgZHgyOiAke3V9ID0gYWJzKCR7dX0oZGVwdGgyKSAtIGRlcHRoKTtcbiAgICAgIHZhciBkeTE6ICR7dX0gPSBhYnMoaGVpZ2h0IC0gJHt1fShoZWlnaHQxKSk7XG4gICAgICB2YXIgZHkyOiAke3V9ID0gYWJzKCR7dX0oaGVpZ2h0MikgLSBoZWlnaHQpO1xuICAgICAgdmFyIGR6MTogJHt1fSA9IGFicyh3aWR0aCAtICR7dX0od2lkdGgxKSk7XG4gICAgICB2YXIgZHoyOiAke3V9ID0gYWJzKCR7dX0od2lkdGgyKSAtIHdpZHRoKTtcbiAgICAgIGlmIChkZXB0aDEgPT0gZGVwdGgyKSB7XG4gICAgICAgIGR4MSA9IDAuNTtcbiAgICAgICAgZHgyID0gMC41O1xuICAgICAgfVxuICAgICAgaWYgKGhlaWdodDEgPT0gaGVpZ2h0Mikge1xuICAgICAgICBkeTEgPSAwLjU7XG4gICAgICAgIGR5MiA9IDAuNTtcbiAgICAgIH1cbiAgICAgIGlmICh3aWR0aDEgPT0gd2lkdGgyKSB7XG4gICAgICAgIGR6MSA9IDAuNTtcbiAgICAgICAgZHoyID0gMC41O1xuICAgICAgfVxuICAgICAgcmV0dXJuICh4MTExICogZHgyICogZHkyICogZHoyICsgeDExMiAqIGR4MiAqIGR5MiAqIGR6MSArIHgxMjEgKiBkeDIgKiBkeTEgKmR6MiArIHgxMjIgKiBkeDIgKiBkeTEgKiBkejEgK1xuICAgICAgICAgICAgICB4MjExICogZHgxICogZHkyICogZHoyICsgeDIxMiAqIGR4MSAqIGR5MiAqIGR6MSArIHgyMjEgKiBkeDEgKiBkeTEgKmR6MiArIHgyMjIgKiBkeDEgKiBkeTEgKiBkejEpO1xuICAgIH1gfSxGaD0oZSx0LHIsbixvLGkpPT57bGV0IGE9ZS5kaW1zLGQ9TWgoaSx0LmF4ZXMsYS5sZW5ndGgpLGw9UmgoYSxuLG8sdC5heGVzKSxwPW4uc2xpY2UoKTtuLmxlbmd0aD09PTAmJihwPWEubWFwKCh2LFMpPT52PT09MD8xOmxbU10vdiksdC5rZWVwQXNwZWN0UmF0aW9Qb2xpY3khPT1cInN0cmV0Y2hcIiYmKGw9VWgoYSxwLHQpKSk7bGV0IG09TShcIm91dHB1dFwiLGUuZGF0YVR5cGUsbC5sZW5ndGgpLHU9RShcImlucHV0XCIsZS5kYXRhVHlwZSxhLmxlbmd0aCksaD1DLnNpemUobCksXz1hLmxlbmd0aD09PWwubGVuZ3RoJiZhLmV2ZXJ5KCh2LFMpPT52PT09bFtTXSkseT10LmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlPT09XCJ0Zl9jcm9wX2FuZF9yZXNpemVcIixnPXQuZXh0cmFwb2xhdGlvblZhbHVlLHg9dS50eXBlLnZhbHVlLCQ9dj0+YFxuICAgICAgJHtfP1wiXCI6YFxuICAgICAgJHtEaCh0LmNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlLHgpfTtcbiAgICAgICR7KCgpPT57c3dpdGNoKHQubW9kZSl7Y2FzZVwibmVhcmVzdFwiOnJldHVybmBcbiAgICAgICAgICAgICAgJHtXaCh1LGEpfTtcbiAgICAgICAgICAgICAgJHtCaCh0Lm5lYXJlc3RNb2RlLHIseCl9O1xuICAgICAgICAgICAgICAke1ZoKHUsbSxhLGwscC5sZW5ndGgsZC5sZW5ndGgseSl9O1xuICAgICAgICAgICAgICBgO2Nhc2VcImxpbmVhclwiOnJldHVybmBcbiAgICAgICAgICAgICAgJHtOaChtLGEsbCxwLmxlbmd0aCxkLmxlbmd0aCl9O1xuICAgICAgICAgICAgICAkeygoKT0+e2lmKGEubGVuZ3RoPT09Mnx8YS5sZW5ndGg9PT00KXJldHVybmAke0xoKHUsbSxhLHksZyl9YDtpZihhLmxlbmd0aD09PTN8fGEubGVuZ3RoPT09NSlyZXR1cm5gJHtIaCh1LG0sYSx5LGcpfWA7dGhyb3cgRXJyb3IoXCJMaW5lYXIgbW9kZSBvbmx5IHN1cHBvcnRzIGlucHV0IGRpbXMgMiwgMywgNCBhbmQgNSBhcmUgc3VwcG9ydGVkIGluIGxpbmVhciBtb2RlLlwiKX0pKCl9O1xuICAgICAgICAgICAgYDtjYXNlXCJjdWJpY1wiOnJldHVybmBcbiAgICAgICAgICAgICR7KCgpPT57aWYoYS5sZW5ndGg9PT0yfHxhLmxlbmd0aD09PTQpcmV0dXJuYCR7R2godSxtLGEsbCxwLGQsdC5jdWJpY0NvZWZmQSx5LHQuZXh0cmFwb2xhdGlvblZhbHVlLHQuZXhjbHVkZU91dHNpZGUpfWA7dGhyb3cgRXJyb3IoXCJDdWJpYyBtb2RlIG9ubHkgc3VwcG9ydHMgaW5wdXQgZGltcyAyIGFuZCA0IGFyZSBzdXBwb3J0ZWQgaW4gbGluZWFyIG1vZGUuXCIpfSkoKX07XG4gICAgICAgICAgICBgO2RlZmF1bHQ6dGhyb3cgRXJyb3IoXCJJbnZhbGlkIHJlc2l6ZSBtb2RlXCIpfX0pKCl9O1xuICAgICAgYH1cbiAgICAgICR7di5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLnJlZ2lzdGVyVW5pZm9ybShcInNjYWxlc1wiLFwiZjMyXCIscC5sZW5ndGgpLnJlZ2lzdGVyVW5pZm9ybShcInJvaVwiLFwiZjMyXCIsZC5sZW5ndGgpLmRlY2xhcmVWYXJpYWJsZXModSxtKX1cbiAgICAgICR7di5tYWluU3RhcnQoKX1cbiAgICAgICAgJHt2Lmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRfc2l6ZVwiKX1cbiAgICAgICAgJHtfP1wib3V0cHV0W2dsb2JhbF9pZHhdID0gaW5wdXRbZ2xvYmFsX2lkeF07XCI6YFxuICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke20ub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICAgIHZhciBpbnB1dF9pbmRpY2VzOiAke3UudHlwZS5pbmRpY2VzfTtcbiAgICAgICAgJHsoKCk9Pntzd2l0Y2godC5tb2RlKXtjYXNlXCJuZWFyZXN0XCI6cmV0dXJuYGlucHV0X2luZGljZXMgPSBjYWxjdWxhdGVJbnB1dEluZGljZXNGcm9tT3V0cHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlcyk7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrSW5wdXRJbmRpY2VzKGlucHV0X2luZGljZXMpKSB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXRbZ2xvYmFsX2lkeF0gPSAke3UuZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKX07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG91dHB1dFtnbG9iYWxfaWR4XSA9ICR7dC5leHRyYXBvbGF0aW9uVmFsdWV9O1xuICAgICAgICAgICAgICAgIH1gO2Nhc2VcImxpbmVhclwiOnJldHVybmBvdXRwdXRbZ2xvYmFsX2lkeF0gPSAke2EubGVuZ3RoPT09Mnx8YS5sZW5ndGg9PT00P1wiYmlsaW5lYXJJbnRlcnBvbGF0aW9uXCI6XCJ0cmlsaW5lYXJJbnRlcnBvbGF0aW9uXCJ9KG91dHB1dF9pbmRpY2VzKTtgO2Nhc2VcImN1YmljXCI6cmV0dXJuXCJvdXRwdXRbZ2xvYmFsX2lkeF0gPSBiaWN1YmljSW50ZXJwb2xhdGlvbihvdXRwdXRfaW5kaWNlcyk7XCI7ZGVmYXVsdDp0aHJvdyBFcnJvcihgVW5zdXBwb3J0ZWQgcmVzaXplIG1vZGU6ICR7dC5tb2RlfWApfX0pKCl9O1xuYH1cbiAgICAgIH1gO3JldHVybntuYW1lOlwiUmVzaXplXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7dC5jYWNoZUtleX18JHtyfXwke3AubGVuZ3RoPjA/cDpcIlwifXwke28ubGVuZ3RoPjA/bzpcIlwifXwke2QubGVuZ3RoPjA/ZDpcIlwifXwke199fCR7YX1gLGlucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIl19LGdldFNoYWRlclNvdXJjZTokLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6bCxkYXRhVHlwZTplLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoaC82NCl9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6MTIsZGF0YTpofSx7dHlwZToxLGRhdGE6cH0se3R5cGU6MSxkYXRhOmR9LC4uLk4oYSxsKV19KX19LHFoPWU9PntsZXQgdD1lLmN1c3RvbURhdGFCdWZmZXI7cmV0dXJuIG5ldyBVaW50MzJBcnJheSh0LHQuYnl0ZU9mZnNldCwxKVswXX0sUGw9KGUsdCk9PntsZXQgcj1bXSxuPVtdLG89W10saT1xaChlKTtpZih0LmFudGlhbGlhcyE9PTApdGhyb3cgRXJyb3IoXCJPbmx5IGRlZmF1bHQgdmFsdWUgKDApIGZvciBBbnRpYWxpYXMgYXR0cmlidXRlIGlzIHN1cHBvcnRlZFwiKTtPaChlLmlucHV0cyx0LGkscixuLG8pLGUuY29tcHV0ZShGaChlLmlucHV0c1swXSx0LGkscixuLG8pLHtpbnB1dHM6WzBdfSl9LHpsPWU9PntsZXQgdD1lLmFudGlhbGlhcyxyPWUuYXhlcyxuPWUuY29vcmRpbmF0ZVRyYW5zZm9ybU1vZGUsbz1lLmN1YmljQ29lZmZBLGk9ZS5leGNsdWRlT3V0c2lkZSE9PTAsYT1lLmV4dHJhcG9sYXRpb25WYWx1ZSxkPWUua2VlcEFzcGVjdFJhdGlvUG9saWN5LGw9ZS5tb2RlLHA9ZS5uZWFyZXN0TW9kZT09PVwiXCI/XCJzaW1wbGVcIjplLm5lYXJlc3RNb2RlO3JldHVybiByZSh7YW50aWFsaWFzOnQsYXhlczpyLGNvb3JkaW5hdGVUcmFuc2Zvcm1Nb2RlOm4sY3ViaWNDb2VmZkE6byxleGNsdWRlT3V0c2lkZTppLGV4dHJhcG9sYXRpb25WYWx1ZTphLGtlZXBBc3BlY3RSYXRpb1BvbGljeTpkLG1vZGU6bCxuZWFyZXN0TW9kZTpwfSl9fSk7dmFyIEtoLGpoLERsLEJsPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO29lKCk7U2UoKTthZSgpO0toPShlLHQpPT57bGV0W3IsbixvLGldPWUse251bUhlYWRzOmEscm90YXJ5RW1iZWRkaW5nRGltOmR9PXQ7aWYoci5kaW1zLmxlbmd0aCE9PTMmJnIuZGltcy5sZW5ndGghPT00KXRocm93IG5ldyBFcnJvcihgSW5wdXQgJ3gnIGlzIGV4cGVjdGVkIHRvIGhhdmUgMyBvciA0IGRpbWVuc2lvbnMsIGdvdCAke3IuZGltcy5sZW5ndGh9YCk7aWYoIUMuYXJlRXF1YWwobi5kaW1zLFtdKSYmIUMuYXJlRXF1YWwobi5kaW1zLFsxXSkmJm4uZGltcy5sZW5ndGghPT0yKXRocm93IG5ldyBFcnJvcihgSW5wdXQgJ3Bvc2l0aW9uX2lkcycgaXMgZXhwZWN0ZWQgdG8gaGF2ZSAwLCAxLCBvciAyIGRpbWVuc2lvbnMsIGdvdCAke24uZGltcy5sZW5ndGh9YCk7aWYoby5kaW1zLmxlbmd0aCE9PTIpdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAnY29zX2NhY2hlJyBpcyBleHBlY3RlZCB0byBoYXZlIDIgZGltZW5zaW9ucywgZ290ICR7by5kaW1zLmxlbmd0aH1gKTtpZihpLmRpbXMubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoYElucHV0ICdzaW5fY2FjaGUnIGlzIGV4cGVjdGVkIHRvIGhhdmUgMiBkaW1lbnNpb25zLCBnb3QgJHtpLmRpbXMubGVuZ3RofWApO2lmKCFDLmFyZUVxdWFsKG8uZGltcyxpLmRpbXMpKXRocm93IG5ldyBFcnJvcihcIklucHV0cyAnY29zX2NhY2hlJyBhbmQgJ3Npbl9jYWNoZScgYXJlIGV4cGVjdGVkIHRvIGhhdmUgdGhlIHNhbWUgc2hhcGVcIik7aWYoZD4wJiZhPT09MCl0aHJvdyBuZXcgRXJyb3IoXCJudW1faGVhZHMgbXVzdCBiZSBwcm92aWRlZCBpZiByb3RhcnlfZW1iZWRkaW5nX2RpbSBpcyBzcGVjaWZpZWRcIik7bGV0IGw9ci5kaW1zWzBdLHA9ci5kaW1zW3IuZGltcy5sZW5ndGgtMl0sbT1vLmRpbXNbMF0sdT1DLnNpemVGcm9tRGltZW5zaW9uKHIuZGltcywxKS9wLGg9ZD09PTA/by5kaW1zWzFdKjI6dS9hO2lmKGQ+aCl0aHJvdyBuZXcgRXJyb3IoXCJyb3RhcnlfZW1iZWRkaW5nX2RpbSBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byBoZWFkX3NpemVcIik7aWYobi5kaW1zLmxlbmd0aD09PTIpe2lmKGwhPT1uLmRpbXNbMF0pdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAncG9zaXRpb25faWRzJyBkaW1lbnNpb24gMCBzaG91bGQgYmUgb2Ygc2l6ZSBiYXRjaF9zaXplLCBnb3QgJHtuLmRpbXNbMF19YCk7aWYocCE9PW4uZGltc1sxXSl0aHJvdyBuZXcgRXJyb3IoYElucHV0ICdwb3NpdGlvbl9pZHMnIGRpbWVuc2lvbiAxIHNob3VsZCBiZSBvZiBzaXplIHNlcXVlbmNlX2xlbmd0aCwgZ290ICR7bi5kaW1zWzFdfWApfWlmKGgvMiE9PW8uZGltc1sxXSYmZC8yIT09by5kaW1zWzFdKXRocm93IG5ldyBFcnJvcihgSW5wdXQgJ2Nvc19jYWNoZScgZGltZW5zaW9uIDEgc2hvdWxkIGJlIHNhbWUgYXMgaGVhZF9zaXplIC8gMiBvciByb3RhcnlfZW1iZWRkaW5nX2RpbSAvIDIsIGdvdCAke28uZGltc1sxXX1gKTtpZihwPm0pdGhyb3cgbmV3IEVycm9yKFwiVXBkYXRpbmcgY29zX2NhY2hlIGFuZCBzaW5fY2FjaGUgaW4gUm90YXJ5RW1iZWRkaW5nIGlzIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkXCIpfSxqaD0oZSx0KT0+e2xldHtpbnRlcmxlYXZlZDpyLG51bUhlYWRzOm4scm90YXJ5RW1iZWRkaW5nRGltOm8sc2NhbGU6aX09dCxhPWVbMF0uZGltc1swXSxkPUMuc2l6ZUZyb21EaW1lbnNpb24oZVswXS5kaW1zLDEpLGw9ZVswXS5kaW1zW2VbMF0uZGltcy5sZW5ndGgtMl0scD1kL2wsbT1lWzJdLmRpbXNbMV0sdT1vPT09MD9tKjI6cC9uLGg9bmV3IEFycmF5KGEsbCxwL3UsdS1tKSxfPUMuY29tcHV0ZVN0cmlkZXMoaCkseT1be3R5cGU6MSxkYXRhOml9LHt0eXBlOjEyLGRhdGE6aH0se3R5cGU6MTIsZGF0YTpffSwuLi5lWzBdLmRpbXMubGVuZ3RoPT09Mz9uZXcgQXJyYXkoe3R5cGU6MTIsZGF0YTpbZCxwLHUsMV19KTpbXSwuLi5lWzBdLmRpbXMubGVuZ3RoPT09ND9uZXcgQXJyYXkoe3R5cGU6MTIsZGF0YTpbZCx1LGwqdSwxXX0pOltdLC4uLk4oZVswXS5kaW1zLGVbMV0uZGltcyxlWzJdLmRpbXMsZVszXS5kaW1zLGVbMF0uZGltcyldLGc9eD0+e2xldCAkPUUoXCJpbnB1dFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLmxlbmd0aCksdj1FKFwicG9zaXRpb25faWRzXCIsZVsxXS5kYXRhVHlwZSxlWzFdLmRpbXMubGVuZ3RoKSxTPUUoXCJjb3NfY2FjaGVcIixlWzJdLmRhdGFUeXBlLGVbMl0uZGltcy5sZW5ndGgpLFQ9RShcInNpbl9jYWNoZVwiLGVbM10uZGF0YVR5cGUsZVszXS5kaW1zLmxlbmd0aCksQT1NKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxlWzBdLmRpbXMubGVuZ3RoKTtyZXR1cm4geC5yZWdpc3RlclVuaWZvcm1zKFt7bmFtZTpcInNjYWxlXCIsdHlwZTpcImYzMlwifSx7bmFtZTpcImdsb2JhbF9zaGFwZVwiLHR5cGU6XCJ1MzJcIixsZW5ndGg6aC5sZW5ndGh9LHtuYW1lOlwiZ2xvYmFsX3N0cmlkZXNcIix0eXBlOlwidTMyXCIsbGVuZ3RoOl8ubGVuZ3RofSx7bmFtZTpcImlucHV0X291dHB1dF9zdHJpZGVzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDpfLmxlbmd0aH1dKSxgXG4gICAgICAgICR7eC5kZWNsYXJlVmFyaWFibGVzKCQsdixTLFQsQSl9XG5cbiAgICAgICAgJHt4Lm1haW5TdGFydChrdCl9XG4gICAgICAgICAgbGV0IGhhbGZfcm90YXJ5X2VtYl9kaW0gPSB1bmlmb3Jtcy4ke1MubmFtZX1fc2hhcGVbMV07XG4gICAgICAgICAgbGV0IGJzbmggPSBnbG9iYWxfaWR4IC8gdW5pZm9ybXMuZ2xvYmFsX3N0cmlkZXMgJSB1bmlmb3Jtcy5nbG9iYWxfc2hhcGU7XG4gICAgICAgICAgbGV0IHNpemUgPSB1bmlmb3Jtcy5nbG9iYWxfc2hhcGVbMF0gKiB1bmlmb3Jtcy5nbG9iYWxfc3RyaWRlc1swXTtcbiAgICAgICAgICAke3guZ3VhcmRBZ2FpbnN0T3V0T2ZCb3VuZHNXb3JrZ3JvdXBTaXplcyhcInNpemVcIil9XG5cbiAgICAgICAgICBpZiAoYnNuaFszXSA8IGhhbGZfcm90YXJ5X2VtYl9kaW0pIHtcbiAgICAgICAgICAgIGxldCBwb3NpdGlvbl9pZHNfaWR4ID1cbiAgICAgICAgICAgICAgICAke3YuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoXCJic25oLnh5XCIsTShcIlwiLHYudHlwZS50ZW5zb3IsMikpfTtcbiAgICAgICAgICAgIGxldCBwb3NpdGlvbl9pZCA9XG4gICAgICAgICAgICAgICAgdTMyKCR7di5nZXRCeU9mZnNldChcInBvc2l0aW9uX2lkc19pZHhcIil9KSArIHNlbGVjdCgwLCBic25oWzFdLCBwb3NpdGlvbl9pZHNfaWR4ID09IDApO1xuICAgICAgICAgICAgbGV0IGkgPSBkb3QoYnNuaCwgdW5pZm9ybXMuaW5wdXRfb3V0cHV0X3N0cmlkZXMpICsgc2VsZWN0KDAsIGJzbmhbM10sICR7cn0pO1xuICAgICAgICAgICAgbGV0IGogPSBpICsgc2VsZWN0KGhhbGZfcm90YXJ5X2VtYl9kaW0sIDEsICR7cn0pO1xuICAgICAgICAgICAgbGV0IHJlID0gJHskLmdldEJ5T2Zmc2V0KFwiaVwiKX0gKiAke1MuZ2V0KFwicG9zaXRpb25faWRcIixcImJzbmhbM11cIil9IC1cbiAgICAgICAgICAgICAgICAkeyQuZ2V0QnlPZmZzZXQoXCJqXCIpfSAqICR7VC5nZXQoXCJwb3NpdGlvbl9pZFwiLFwiYnNuaFszXVwiKX07XG4gICAgICAgICAgICAke0Euc2V0QnlPZmZzZXQoXCJpXCIsXCJyZVwiKX1cbiAgICAgICAgICAgIGxldCBpbSA9ICR7JC5nZXRCeU9mZnNldChcImlcIil9ICogJHtULmdldChcInBvc2l0aW9uX2lkXCIsXCJic25oWzNdXCIpfSArXG4gICAgICAgICAgICAgICAgJHskLmdldEJ5T2Zmc2V0KFwialwiKX0gKiAke1MuZ2V0KFwicG9zaXRpb25faWRcIixcImJzbmhbM11cIil9O1xuICAgICAgICAgICAgJHtBLnNldEJ5T2Zmc2V0KFwialwiLFwiaW1cIil9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBrID0gZG90KGJzbmgsIHVuaWZvcm1zLmlucHV0X291dHB1dF9zdHJpZGVzKSArIGhhbGZfcm90YXJ5X2VtYl9kaW07XG4gICAgICAgICAgICAke0Euc2V0QnlPZmZzZXQoXCJrXCIsJC5nZXRCeU9mZnNldChcImtcIikpfVxuICAgICAgICAgIH1cbiAgICAgICAgfWB9O3JldHVybntuYW1lOlwiUm90YXJ5RW1iZWRkaW5nXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6cmUoe2ludGVybGVhdmVkOnJ9KS5jYWNoZUtleSxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCIsXCJyYW5rXCIsXCJyYW5rXCIsXCJyYW5rXCJdfSxnZXRTaGFkZXJTb3VyY2U6ZyxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOmVbMF0uZGltcyxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoQy5zaXplKGgpL2t0KX0scHJvZ3JhbVVuaWZvcm1zOnl9KX19LERsPShlLHQpPT57S2goZS5pbnB1dHMsdCksZS5jb21wdXRlKGpoKGUuaW5wdXRzLHQpKX19KTt2YXIgWWgsWmgsTWwsUmw9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTthZSgpO1loPWU9PntpZighZXx8ZS5sZW5ndGg8Myl0aHJvdyBuZXcgRXJyb3IoXCJsYXllck5vcm0gcmVxdWlyZXMgYXQgbGVhc3QgMyBpbnB1dHMuXCIpO2xldCB0PWVbMF0scj1lWzFdLG49ZVsyXTtpZih0LmRhdGFUeXBlIT09ci5kYXRhVHlwZXx8dC5kYXRhVHlwZSE9PW4uZGF0YVR5cGUpdGhyb3cgbmV3IEVycm9yKFwiQWxsIGlucHV0cyBtdXN0IGhhdmUgdGhlIHNhbWUgZGF0YSB0eXBlXCIpO2lmKHQuZGltcy5sZW5ndGghPT0zJiZ0LmRpbXMubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBtdXN0IGJlIDJEIG9yIDNEXCIpO2lmKHIuZGltcy5sZW5ndGghPT0zJiZyLmRpbXMubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJTa2lwIG11c3QgYmUgMkQgb3IgM0RcIik7bGV0IG89dC5kaW1zW3QuZGltcy5sZW5ndGgtMV0saT10LmRpbXNbdC5kaW1zLmxlbmd0aC0yXTtpZihyLmRpbXNbci5kaW1zLmxlbmd0aC0xXSE9PW8pdGhyb3cgbmV3IEVycm9yKFwiU2tpcCBtdXN0IGhhdmUgdGhlIHNhbWUgaGlkZGVuIHNpemUgYXMgaW5wdXRcIik7aWYoci5kaW1zW3IuZGltcy5sZW5ndGgtMl0hPT1pKXRocm93IG5ldyBFcnJvcihcIlNraXAgbXVzdCBoYXZlIHRoZSBzYW1lIHNlcXVlbmNlIGxlbmd0aCBhcyBpbnB1dFwiKTtpZihuLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJHYW1tYSBtdXN0IGJlIDFEXCIpO2lmKG4uZGltc1tuLmRpbXMubGVuZ3RoLTFdIT09byl0aHJvdyBuZXcgRXJyb3IoXCJHYW1tYSBtdXN0IGhhdmUgdGhlIHNhbWUgaGlkZGVuIHNpemUgYXMgaW5wdXRcIik7aWYoZS5sZW5ndGg+Myl7bGV0IGE9ZVszXTtpZihhLmRpbXMubGVuZ3RoIT09MSl0aHJvdyBuZXcgRXJyb3IoXCJCZXRhIG11c3QgYmUgMURcIik7aWYoYS5kaW1zW2EuZGltcy5sZW5ndGgtMV0hPT1vKXRocm93IG5ldyBFcnJvcihcIkJldGEgbXVzdCBoYXZlIHRoZSBzYW1lIGhpZGRlbiBzaXplIGFzIGlucHV0XCIpfWlmKGUubGVuZ3RoPjQpe2xldCBhPWVbNF07aWYoYS5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiQmlhcyBtdXN0IGJlIDFEXCIpO2lmKGEuZGltc1thLmRpbXMubGVuZ3RoLTFdIT09byl0aHJvdyBuZXcgRXJyb3IoXCJCaWFzIG11c3QgaGF2ZSB0aGUgc2FtZSBoaWRkZW4gc2l6ZSBhcyBpbnB1dFwiKX19LFpoPShlLHQscixuKT0+e2xldCBvPXQuc2ltcGxpZmllZCxpPWVbMF0uZGltcyxhPUMuc2l6ZShpKSxkPWksbD1hLHA9aS5zbGljZSgtMSlbMF0sbT1uP2kuc2xpY2UoMCwtMSkuY29uY2F0KDEpOltdLHU9IW8mJmUubGVuZ3RoPjMsaD1lLmxlbmd0aD40LF89biYmcj4xLHk9biYmcj4yLGc9cj4zLHg9NjQsJD1tZShwKSx2PVt7dHlwZToxMixkYXRhOmx9LHt0eXBlOjEyLGRhdGE6JH0se3R5cGU6MTIsZGF0YTpwfSx7dHlwZToxLGRhdGE6dC5lcHNpbG9ufV0sUz1BPT57bGV0IGs9W3tuYW1lOlwib3V0cHV0X3NpemVcIix0eXBlOlwidTMyXCJ9LHtuYW1lOlwiY29tcG9uZW50c1wiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJoaWRkZW5fc2l6ZVwiLHR5cGU6XCJ1MzJcIn0se25hbWU6XCJlcHNpbG9uXCIsdHlwZTpcImYzMlwifV0sUD1bRShcInhcIixlWzBdLmRhdGFUeXBlLGVbMF0uZGltcywkKSxFKFwic2tpcFwiLGVbMV0uZGF0YVR5cGUsZVsxXS5kaW1zLCQpLEUoXCJnYW1tYVwiLGVbMl0uZGF0YVR5cGUsZVsyXS5kaW1zLCQpXTt1JiZQLnB1c2goRShcImJldGFcIixlWzNdLmRhdGFUeXBlLGVbM10uZGltcywkKSksaCYmUC5wdXNoKEUoXCJiaWFzXCIsZVs0XS5kYXRhVHlwZSxlWzRdLmRpbXMsJCkpLFAucHVzaChNKFwib3V0cHV0XCIsZVswXS5kYXRhVHlwZSxkLCQpKSxfJiZQLnB1c2goTShcIm1lYW5fb3V0cHV0XCIsMSxtKSkseSYmUC5wdXNoKE0oXCJpbnZfc3RkX291dHB1dFwiLDEsbSkpLGcmJlAucHVzaChNKFwiaW5wdXRfc2tpcF9iaWFzX3N1bVwiLGVbMF0uZGF0YVR5cGUsZCwkKSk7bGV0IEQ9X2UoZVswXS5kYXRhVHlwZSksUj1fZSgxLCQpO3JldHVybmBcblxuICAgICAgJHtBLnJlZ2lzdGVyVW5pZm9ybXMoaykuZGVjbGFyZVZhcmlhYmxlcyguLi5QKX1cbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHN1bV9zaGFyZWQgOiBhcnJheTwke1J9LCAke3h9PjtcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHN1bV9zcXVhcmVkX3NoYXJlZCA6IGFycmF5PCR7Un0sICR7eH0+O1xuXG4gICAgICAke0EubWFpblN0YXJ0KFt4LDEsMV0pfVxuICAgICAgICBsZXQgaXggPSBsb2NhbF9pZC54O1xuICAgICAgICBsZXQgaXkgPSBnbG9iYWxfaWQueCAvICR7eH07XG5cbiAgICAgICAgbGV0IGhpZGRlbl9zaXplX3ZlY3Rvcml6ZWQ6IHUzMiA9IHVuaWZvcm1zLmhpZGRlbl9zaXplIC8gdW5pZm9ybXMuY29tcG9uZW50cztcbiAgICAgICAgdmFyIHN0cmlkZSA9IGhpZGRlbl9zaXplX3ZlY3Rvcml6ZWQgLyAke3h9O1xuICAgICAgICBsZXQgb2Zmc2V0ID0gaXggKiBzdHJpZGUgKyBpeSAqIGhpZGRlbl9zaXplX3ZlY3Rvcml6ZWQ7XG4gICAgICAgIGxldCBvZmZzZXQxZCA9IHN0cmlkZSAqIGl4O1xuICAgICAgICBpZiAoaXggPT0gJHt4LTF9KSB7XG4gICAgICAgICAgc3RyaWRlID0gaGlkZGVuX3NpemVfdmVjdG9yaXplZCAtIHN0cmlkZSAqIGl4O1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGk6IHUzMiA9IDA7IGkgPCBzdHJpZGU7IGkrKykge1xuICAgICAgICAgIGxldCBza2lwX3ZhbHVlID0gc2tpcFtvZmZzZXQgKyBpXTtcbiAgICAgICAgICBsZXQgYmlhc192YWx1ZSA9ICR7aD9cImJpYXNbb2Zmc2V0MWQgKyBpXVwiOkQrXCIoMC4wKVwifTtcbiAgICAgICAgICBsZXQgaW5wdXRfdmFsdWUgPSB4W29mZnNldCArIGldO1xuICAgICAgICAgIGxldCB2YWx1ZSA9IGlucHV0X3ZhbHVlICsgc2tpcF92YWx1ZSArIGJpYXNfdmFsdWU7XG4gICAgICAgICAgJHtnP1wiaW5wdXRfc2tpcF9iaWFzX3N1bVtvZmZzZXQgKyBpXSA9IHZhbHVlO1wiOlwiXCJ9XG4gICAgICAgICAgb3V0cHV0W29mZnNldCArIGldID0gdmFsdWU7XG4gICAgICAgICAgbGV0IGYzMl92YWx1ZSA9ICR7RXQoRCwkLFwidmFsdWVcIil9O1xuICAgICAgICAgIHN1bV9zaGFyZWRbaXhdICs9IGYzMl92YWx1ZTtcbiAgICAgICAgICBzdW1fc3F1YXJlZF9zaGFyZWRbaXhdICs9IGYzMl92YWx1ZSAqIGYzMl92YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgdmFyIHJlZHVjZV9zaXplIDogdTMyID0gJHt4fTtcbiAgICAgICAgZm9yICh2YXIgY3Vycl9zaXplID0gcmVkdWNlX3NpemUgPj4gMTsgIGN1cnJfc2l6ZSA+IDA7IGN1cnJfc2l6ZSA9IHJlZHVjZV9zaXplID4+IDEpIHtcbiAgICAgICAgICByZWR1Y2Vfc2l6ZSA9IGN1cnJfc2l6ZSArIChyZWR1Y2Vfc2l6ZSAmIDEpO1xuICAgICAgICAgIGlmIChpeCA8IGN1cnJfc2l6ZSkge1xuICAgICAgICAgICAgc3VtX3NoYXJlZFtpeF0gKz0gc3VtX3NoYXJlZFtpeCArIHJlZHVjZV9zaXplXTtcbiAgICAgICAgICAgIHN1bV9zcXVhcmVkX3NoYXJlZFtpeF0gKz0gc3VtX3NxdWFyZWRfc2hhcmVkW2l4ICsgcmVkdWNlX3NpemVdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc3VtID0gc3VtX3NoYXJlZFswXTtcbiAgICAgICAgbGV0IHNxdWFyZV9zdW0gPSBzdW1fc3F1YXJlZF9zaGFyZWRbMF07XG4gICAgICAgIGxldCBtZWFuID0gJHtGZShcInN1bVwiLCQpfSAvIGYzMih1bmlmb3Jtcy5oaWRkZW5fc2l6ZSk7XG4gICAgICAgIGxldCBpbnZfc3RkX2RldiA9IGludmVyc2VTcXJ0KCR7RmUoXCJzcXVhcmVfc3VtXCIsJCl9IC8gZjMyKHVuaWZvcm1zLmhpZGRlbl9zaXplKSAke28/XCJcIjpcIi0gbWVhbiAqIG1lYW5cIn0gKyB1bmlmb3Jtcy5lcHNpbG9uKTtcbiAgICAgICAgJHtfP1wibWVhbl9vdXRwdXRbZ2xvYmFsX2lkeF0gPSBtZWFuO1wiOlwiXCJ9XG4gICAgICAgICR7eT9cImludl9zdGRfb3V0cHV0W2dsb2JhbF9pZHhdID0gaW52X3N0ZF9kZXY7XCI6XCJcIn1cblxuICAgICAgICBmb3IgKHZhciBpOiB1MzIgPSAwOyBpIDwgc3RyaWRlOyBpKyspIHtcbiAgICAgICAgICBvdXRwdXRbb2Zmc2V0ICsgaV0gPSAob3V0cHV0W29mZnNldCArIGldICR7bz9cIlwiOmAtICR7RH0obWVhbilgfSkgKlxuICAgICAgICAgICAgJHtEfShpbnZfc3RkX2RldikgKiBnYW1tYVtvZmZzZXQxZCArIGldXG4gICAgICAgICAgICAke3U/XCIrIGJldGFbb2Zmc2V0MWQgKyBpXVwiOlwiXCJ9O1xuICAgICAgICB9XG4gICAgICB9YH0sVD1be2RpbXM6ZCxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfV07cmV0dXJuIHI+MSYmVC5wdXNoKHtkaW1zOm0sZGF0YVR5cGU6MX0pLHI+MiYmVC5wdXNoKHtkaW1zOm0sZGF0YVR5cGU6MX0pLHI+MyYmVC5wdXNoKHtkaW1zOmksZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX0pLHtuYW1lOlwiU2tpcExheWVyTm9ybWFsaXphdGlvblwiLHNoYWRlckNhY2hlOntoaW50OmAkeyR9OyR7X307JHt5fTske2d9YCxpbnB1dERlcGVuZGVuY2llczplLm1hcCgoQSxrKT0+XCJ0eXBlXCIpfSxnZXRTaGFkZXJTb3VyY2U6UyxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6VCxkaXNwYXRjaEdyb3VwOnt4Ok1hdGguY2VpbChsL3ApfSxwcm9ncmFtVW5pZm9ybXM6dn0pfX0sTWw9KGUsdCk9PntZaChlLmlucHV0cyk7bGV0IG49WzBdO2Uub3V0cHV0Q291bnQ+MSYmbi5wdXNoKC0zKSxlLm91dHB1dENvdW50PjImJm4ucHVzaCgtMyksZS5vdXRwdXRDb3VudD4zJiZuLnB1c2goMyksZS5jb21wdXRlKFpoKGUuaW5wdXRzLHQsZS5vdXRwdXRDb3VudCwhMSkse291dHB1dHM6bn0pfX0pO3ZhciBRaCxybixYaCxVbCxKaCxlZyxObCxWbCxXbD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtvZSgpO1NlKCk7YWUoKTtRaD0oZSx0KT0+e2lmKCFlfHxlLmxlbmd0aDwxKXRocm93IG5ldyBFcnJvcihcInRvbyBmZXcgaW5wdXRzXCIpO2lmKHQuYXhlcy5sZW5ndGghPT0wKXtpZih0LmF4ZXMubGVuZ3RoIT09dC5zdGFydHMubGVuZ3RofHx0LmF4ZXMubGVuZ3RoIT09dC5lbmRzLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJheGVzLCBzdGFydHMgYW5kIGVuZHMgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aFwiKX1lbHNlIGlmKHQuc3RhcnRzLmxlbmd0aCE9PXQuZW5kcy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic3RhcnRzIGFuZCBlbmRzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIik7ZS5zbGljZSgxKS5mb3JFYWNoKChyLG4pPT57aWYoZVtuKzFdLmRhdGFUeXBlIT09NiYmZVtuKzFdLmRhdGFUeXBlIT09Nyl0aHJvdyBuZXcgRXJyb3IoYElucHV0ICR7bn0gbXVzdCBiZSBhbiBhcnJheSBvZiBpbnQzMiBvciBpbnQ2NGApfSl9LHJuPShlLHQpPT57bGV0IHI9W107aWYoZS5sZW5ndGg+dClpZihlW3RdLmRhdGFUeXBlPT09NyllW3RdLmdldEJpZ0ludDY0QXJyYXkoKS5mb3JFYWNoKG49PnIucHVzaChOdW1iZXIobikpKTtlbHNlIGlmKGVbdF0uZGF0YVR5cGU9PT02KWVbdF0uZ2V0SW50MzJBcnJheSgpLmZvckVhY2gobj0+ci5wdXNoKE51bWJlcihuKSkpO2Vsc2UgdGhyb3cgbmV3IEVycm9yKGBJbnB1dCAke3R9IG11c3QgYmUgYW4gYXJyYXkgb2YgaW50MzIgb3IgaW50NjRgKTtyZXR1cm4gcn0sWGg9KGUsdCk9PntpZihlLmxlbmd0aD4xKXtsZXQgcj1ybihlLDEpLG49cm4oZSwyKSxvPXJuKGUsMyk7cmV0dXJuIG8ubGVuZ3RoPT09MCYmKG89Wy4uLkFycmF5KGVbMF0uZGltcy5sZW5ndGgpLmtleXMoKV0pLHJlKHtzdGFydHM6cixlbmRzOm4sYXhlczpvfSl9ZWxzZSByZXR1cm4gdH0sVWw9KGUsdCxyLG4sbyk9PntsZXQgaT1lO3JldHVybiBlPDAmJihpKz1yW25bdF1dKSxvW3RdPDA/TWF0aC5tYXgoMCxNYXRoLm1pbihpLHJbblt0XV0tMSkpOk1hdGgubWF4KDAsTWF0aC5taW4oaSxyW25bdF1dKSl9LEpoPShlLHQscik9PmBmbiBjYWxjdWxhdGVJbnB1dEluZGljZXMob3V0cHV0X2luZGljZXM6ICR7dC50eXBlLmluZGljZXN9KSAtPiAke2UudHlwZS5pbmRpY2VzfSB7XG4gICAgICAgICAgdmFyIGlucHV0X2luZGljZXM6ICR7ZS50eXBlLmluZGljZXN9O1xuICAgICAgICAgIHZhciBjYXJyeSA9IDB1O1xuICAgICAgICAgIGZvciAodmFyIGkgPSAke3IubGVuZ3RofTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBpbnB1dF9zaGFwZV9pID0gJHtGKFwidW5pZm9ybXMuaW5wdXRfc2hhcGVcIixcImlcIixyLmxlbmd0aCl9O1xuICAgICAgICAgICAgbGV0IHN0ZXBzX2kgPSAke0YoXCJ1bmlmb3Jtcy5zdGVwc1wiLFwiaVwiLHIubGVuZ3RoKX07XG4gICAgICAgICAgICBsZXQgc2lnbnNfaSA9ICR7RihcInVuaWZvcm1zLnNpZ25zXCIsXCJpXCIsci5sZW5ndGgpfTtcbiAgICAgICAgICAgIGxldCBzdGFydHNfaSA9ICR7RihcInVuaWZvcm1zLnN0YXJ0c1wiLFwiaVwiLHIubGVuZ3RoKX07XG4gICAgICAgICAgICB2YXIgb3V0cHV0X2luZGV4ID0gJHt0LmluZGljZXNHZXQoXCJvdXRwdXRfaW5kaWNlc1wiLFwiaVwiKX07XG4gICAgICAgICAgICB2YXIgaW5wdXRfaW5kZXggPSBvdXRwdXRfaW5kZXggKiBzdGVwc19pICsgc3RhcnRzX2kgKyBjYXJyeTtcbiAgICAgICAgICAgIGNhcnJ5ID0gaW5wdXRfaW5kZXggLyBpbnB1dF9zaGFwZV9pO1xuICAgICAgICAgICAgaW5wdXRfaW5kZXggPSBpbnB1dF9pbmRleCAlIGlucHV0X3NoYXBlX2k7XG4gICAgICAgICAgICBpZiAoc2lnbnNfaSA8IDApIHtcbiAgICAgICAgICAgICAgaW5wdXRfaW5kZXggPSBpbnB1dF9zaGFwZV9pIC0gaW5wdXRfaW5kZXggLSAxdSArIHN0YXJ0c19pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgJHtlLmluZGljZXNTZXQoXCJpbnB1dF9pbmRpY2VzXCIsXCJpXCIsXCJpbnB1dF9pbmRleFwiKX07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpbnB1dF9pbmRpY2VzO1xuICAgICAgfWAsZWc9KGUsdCk9PntsZXQgcj1lWzBdLmRpbXMsbj1DLnNpemUociksbz10LmF4ZXMubGVuZ3RoPjA/Qy5ub3JtYWxpemVBeGVzKHQuYXhlcyxyLmxlbmd0aCk6Wy4uLkFycmF5KHIubGVuZ3RoKS5rZXlzKCldLGk9cm4oZSw0KTtpLmZvckVhY2goJD0+JCE9PTB8fCgoKT0+e3Rocm93IG5ldyBFcnJvcihcInN0ZXAgY2Fubm90IGJlIDBcIil9KSksaS5sZW5ndGg9PT0wJiYoaT1BcnJheShvLmxlbmd0aCkuZmlsbCgxKSk7bGV0IGE9dC5zdGFydHMubWFwKCgkLHYpPT5VbCgkLHYscixvLGkpKSxkPXQuZW5kcy5tYXAoKCQsdik9PlVsKCQsdixyLG8saSkpO2lmKG8ubGVuZ3RoIT09YS5sZW5ndGh8fG8ubGVuZ3RoIT09ZC5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwic3RhcnQsIGVuZHMgYW5kIGF4ZXMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzXCIpO2lmKG8ubGVuZ3RoIT09ci5sZW5ndGgpZm9yKGxldCAkPTA7JDxyLmxlbmd0aDsrKyQpby5pbmNsdWRlcygkKXx8KGEuc3BsaWNlKCQsMCwwKSxkLnNwbGljZSgkLDAsclskXSksaS5zcGxpY2UoJCwwLDEpKTtsZXQgbD1pLm1hcCgkPT5NYXRoLnNpZ24oJCkpO2kuZm9yRWFjaCgoJCx2LFMpPT57aWYoJDwwKXtsZXQgVD0oZFt2XS1hW3ZdKS8kLEE9YVt2XSxrPUErVCppW3ZdO2Fbdl09ayxkW3ZdPUEsU1t2XT0tJH19KTtsZXQgcD1yLnNsaWNlKDApO28uZm9yRWFjaCgoJCx2KT0+e3BbJF09TWF0aC5jZWlsKChkWyRdLWFbJF0pL2lbJF0pfSk7bGV0IG09e2RpbXM6cCxkYXRhVHlwZTplWzBdLmRhdGFUeXBlfSx1PU0oXCJvdXRwdXRcIixlWzBdLmRhdGFUeXBlLHAubGVuZ3RoKSxoPUUoXCJpbnB1dFwiLGVbMF0uZGF0YVR5cGUsZVswXS5kaW1zLmxlbmd0aCksXz1DLnNpemUocCkseT1be25hbWU6XCJvdXRwdXRTaXplXCIsdHlwZTpcInUzMlwifSx7bmFtZTpcInN0YXJ0c1wiLHR5cGU6XCJ1MzJcIixsZW5ndGg6YS5sZW5ndGh9LHtuYW1lOlwic2lnbnNcIix0eXBlOlwiaTMyXCIsbGVuZ3RoOmwubGVuZ3RofSx7bmFtZTpcInN0ZXBzXCIsdHlwZTpcInUzMlwiLGxlbmd0aDppLmxlbmd0aH1dLGc9W3t0eXBlOjEyLGRhdGE6X30se3R5cGU6MTIsZGF0YTphfSx7dHlwZTo2LGRhdGE6bH0se3R5cGU6MTIsZGF0YTppfSwuLi5OKGVbMF0uZGltcyxwKV0seD0kPT5gXG4gICAgICAkeyQucmVnaXN0ZXJVbmlmb3Jtcyh5KS5kZWNsYXJlVmFyaWFibGVzKGgsdSl9XG4gICAgICAgICR7SmgoaCx1LHIpfVxuICAgICAgICAkeyQubWFpblN0YXJ0KCl9XG4gICAgICAgICAgJHskLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy5vdXRwdXRTaXplXCIpfVxuICAgICAgICAgIGxldCBvdXRwdXRfaW5kaWNlcyA9ICR7dS5vZmZzZXRUb0luZGljZXMoXCJnbG9iYWxfaWR4XCIpfTtcbiAgICAgICAgICBsZXQgaW5wdXRfaW5kaWNlcyA9IGNhbGN1bGF0ZUlucHV0SW5kaWNlcyhvdXRwdXRfaW5kaWNlcyk7XG4gICAgICAgICAgJHt1LnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLGguZ2V0QnlJbmRpY2VzKFwiaW5wdXRfaW5kaWNlc1wiKSl9XG4gICAgICB9YDtyZXR1cm57bmFtZTpcIlNsaWNlXCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7bC5sZW5ndGh9XyR7YS5sZW5ndGh9XyR7aS5sZW5ndGh9YCxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxnZXRTaGFkZXJTb3VyY2U6eCxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W21dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKG4vNjQpfSxwcm9ncmFtVW5pZm9ybXM6Z30pfX0sTmw9KGUsdCk9PntRaChlLmlucHV0cyx0KTtsZXQgcj1YaChlLmlucHV0cyx0KTtlLmNvbXB1dGUoZWcoZS5pbnB1dHMscikse2lucHV0czpbMF19KX0sVmw9ZT0+e2xldCB0PWUuc3RhcnRzLHI9ZS5lbmRzLG49ZS5heGVzO3JldHVybiByZSh7c3RhcnRzOnQsZW5kczpyLGF4ZXM6bn0pfX0pO3ZhciB0ZyxyZyxMbCxHbCxIbD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dGUoKTtvZSgpO1NlKCk7ZHQoKTthZSgpO3RnPWU9PntpZighZXx8ZS5sZW5ndGghPT0xKXRocm93IG5ldyBFcnJvcihcIlNvZnRtYXggb3AgcmVxdWlyZXMgMSBpbnB1dC5cIil9LHJnPShlLHQpPT57bGV0IHI9ZS5pbnB1dHNbMF0sbj1yLmRpbXMsbz1DLnNpemUobiksaT1uLmxlbmd0aCxhPUMubm9ybWFsaXplQXhpcyh0LmF4aXMsaSksZD1hPG4ubGVuZ3RoLTEsbCxwPVtdO2Q/KHA9QXJyYXkuZnJvbSh7bGVuZ3RoOml9LChQLEQpPT5EKSxwW2FdPWktMSxwW2ktMV09YSxsPWUuY29tcHV0ZShQZShyLHApLHtpbnB1dHM6W3JdLG91dHB1dHM6Wy0xXX0pWzBdKTpsPXI7bGV0IG09bC5kaW1zLHU9bVtpLTFdLGg9by91LF89bWUodSkseT11L18sZz02NDtoPT09MSYmKGc9MjU2KTtsZXQgeD0oUCxEKT0+RD09PTQ/YG1heChtYXgoJHtQfS54LCAke1B9LnkpLCBtYXgoJHtQfS56LCAke1B9LncpKWA6RD09PTI/YG1heCgke1B9LngsICR7UH0ueSlgOkQ9PT0zP2BtYXgobWF4KCR7UH0ueCwgJHtQfS55KSwgJHtQfS56KWA6UCwkPUUoXCJ4XCIsbC5kYXRhVHlwZSxsLmRpbXMsXyksdj1NKFwicmVzdWx0XCIsbC5kYXRhVHlwZSxsLmRpbXMsXyksUz0kLnR5cGUudmFsdWUsVD1fZShsLmRhdGFUeXBlKT09PVwiZjMyXCI/YHZhciB0aHJlYWRNYXggPSAke1N9KC0zLjQwMjgyM2UrMzhmKTtgOmB2YXIgdGhyZWFkTWF4ID0gJHtTfSgtNjU1MDQuMGgpO2AsQT1QPT5gXG4gICAgICB2YXI8d29ya2dyb3VwPiByb3dNYXhTaGFyZWQgOiAke1N9O1xuICAgICAgdmFyPHdvcmtncm91cD4gcm93U3VtU2hhcmVkIDogJHtTfTtcbiAgICAgIHZhcjx3b3JrZ3JvdXA+IHRocmVhZFNoYXJlZCA6IGFycmF5PCR7U30sICR7Z30+O1xuXG4gICAgICBmbiBnZXRWYWx1ZShyb3c6IGkzMiwgY29sOiBpMzIsIHJvd19zdHJpZGU6IGkzMikgLT4gJHtTfSB7XG4gICAgICAgIGxldCBpbmRleCA9IHJvdyAqIHJvd19zdHJpZGUgKyBjb2w7XG4gICAgICAgIHJldHVybiB4W2luZGV4XTtcbiAgICAgIH1cblxuICAgICAgZm4gc2V0VmFsdWUocm93OiBpMzIsIGNvbDogaTMyLCByb3dfc3RyaWRlOiBpMzIsIHZhbHVlOiAke1N9KSB7XG4gICAgICAgIGxldCBpbmRleCA9IHJvdyAqIHJvd19zdHJpZGUgKyBjb2w7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgICR7UC5yZWdpc3RlclVuaWZvcm0oXCJwYWNrZWRDb2xzXCIsXCJpMzJcIikuZGVjbGFyZVZhcmlhYmxlcygkLHYpfVxuICAgICAgJHtQLm1haW5TdGFydChnKX1cbiAgICAgICAgbGV0IGdpbmRleCA9IGkzMihnbG9iYWxfaWR4KTtcbiAgICAgICAgbGV0IGxpbmRleCA9IGkzMihsb2NhbF9pZHgpO1xuICAgICAgICBjb25zdCB3ZyA9ICR7Z307XG4gICAgICAgIGxldCByb3cgPSBnaW5kZXggLyB3ZztcbiAgICAgICAgbGV0IGNvbHMgPSB1bmlmb3Jtcy5wYWNrZWRDb2xzO1xuICAgICAgICBsZXQgcm93X3N0cmlkZSA6IGkzMiA9IHVuaWZvcm1zLnBhY2tlZENvbHM7XG5cbiAgICAgICAgLy8gZmluZCB0aGUgcm93cyBtYXhcbiAgICAgICAgJHtUfVxuICAgICAgICBmb3IgKHZhciBjb2wgPSBsaW5kZXg7IGNvbCA8IGNvbHM7IGNvbCArPSB3Zykge1xuICAgICAgICAgIGxldCB2YWx1ZSA9IGdldFZhbHVlKHJvdywgY29sLCByb3dfc3RyaWRlKTtcbiAgICAgICAgICB0aHJlYWRNYXggPSBtYXgodGhyZWFkTWF4LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbmRleCA8IGNvbHMpIHtcbiAgICAgICAgICB0aHJlYWRTaGFyZWRbbGluZGV4XSA9IHRocmVhZE1heDtcbiAgICAgICAgfVxuICAgICAgICB3b3JrZ3JvdXBCYXJyaWVyKCk7XG5cbiAgICAgICAgdmFyIHJlZHVjZVNpemUgPSBtaW4oY29scywgd2cpO1xuICAgICAgICBmb3IgKHZhciBjdXJyU2l6ZSA9IHJlZHVjZVNpemUgPj4gMTsgIGN1cnJTaXplID4gMDsgY3VyclNpemUgPSByZWR1Y2VTaXplID4+IDEpIHtcbiAgICAgICAgICByZWR1Y2VTaXplID0gY3VyclNpemUgKyAocmVkdWNlU2l6ZSAmIDEpO1xuICAgICAgICAgIGlmIChsaW5kZXggPCBjdXJyU2l6ZSkge1xuICAgICAgICAgICAgdGhyZWFkU2hhcmVkW2xpbmRleF0gPSBtYXgodGhyZWFkU2hhcmVkW2xpbmRleF0sIHRocmVhZFNoYXJlZFtsaW5kZXggKyByZWR1Y2VTaXplXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZGV4ID09IDApIHtcbiAgICAgICAgICByb3dNYXhTaGFyZWQgPSAke1N9KCR7eChcInRocmVhZFNoYXJlZFswXVwiLF8pfSk7XG4gICAgICAgIH1cbiAgICAgICAgd29ya2dyb3VwQmFycmllcigpO1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIHJvd3Mgc3VtXG4gICAgICAgIHZhciB0aHJlYWRTdW0gPSAke1N9KDAuMCk7XG4gICAgICAgIGZvciAodmFyIGNvbCA9IGxpbmRleDsgY29sIDwgY29sczsgY29sICs9IHdnKSB7XG4gICAgICAgICAgbGV0IHN1YkV4cCA9IGV4cChnZXRWYWx1ZShyb3csIGNvbCwgcm93X3N0cmlkZSkgLSByb3dNYXhTaGFyZWQpO1xuICAgICAgICAgIHRocmVhZFN1bSArPSBzdWJFeHA7XG4gICAgICAgIH1cbiAgICAgICAgdGhyZWFkU2hhcmVkW2xpbmRleF0gPSB0aHJlYWRTdW07XG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICBmb3IgKHZhciBjdXJyU2l6ZSA9IHdnID4+IDE7ICBjdXJyU2l6ZSA+IDA7IGN1cnJTaXplID0gY3VyclNpemUgPj4gMSkge1xuICAgICAgICAgIGlmIChsaW5kZXggPCBjdXJyU2l6ZSkge1xuICAgICAgICAgICAgdGhyZWFkU2hhcmVkW2xpbmRleF0gPSB0aHJlYWRTaGFyZWRbbGluZGV4XSArIHRocmVhZFNoYXJlZFtsaW5kZXggKyBjdXJyU2l6ZV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGluZGV4ID09IDApIHtcbiAgICAgICAgICByb3dTdW1TaGFyZWQgPSAke1N9KCR7RmUoXCJ0aHJlYWRTaGFyZWRbMF1cIixfKX0pO1xuICAgICAgICB9XG4gICAgICAgIHdvcmtncm91cEJhcnJpZXIoKTtcblxuICAgICAgICAvLyBjYWxjdWxhdGUgZmluYWwgdmFsdWUgZm9yIGVhY2ggZWxlbWVudCBpbiB0aGUgcm93XG4gICAgICAgIGZvciAodmFyIGNvbCA9IGxpbmRleDsgY29sIDwgY29sczsgY29sICs9IHdnKSB7XG4gICAgICAgICAgbGV0IHZhbHVlID0gZXhwKGdldFZhbHVlKHJvdywgY29sLCByb3dfc3RyaWRlKSAtIHJvd01heFNoYXJlZCkgLyByb3dTdW1TaGFyZWQ7XG4gICAgICAgICAgc2V0VmFsdWUocm93LCBjb2wsIHJvd19zdHJpZGUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfWAsaz1lLmNvbXB1dGUoe25hbWU6XCJTb2Z0bWF4XCIsc2hhZGVyQ2FjaGU6e2hpbnQ6YCR7X307JHtnfWAsaW5wdXREZXBlbmRlbmNpZXM6W1widHlwZVwiXX0sZ2V0UnVuRGF0YTooKT0+KHtvdXRwdXRzOlt7ZGltczptLGRhdGFUeXBlOmwuZGF0YVR5cGV9XSxkaXNwYXRjaEdyb3VwOnt4Omh9LHByb2dyYW1Vbmlmb3Jtczpbe3R5cGU6NixkYXRhOnl9XX0pLGdldFNoYWRlclNvdXJjZTpBfSx7aW5wdXRzOltsXSxvdXRwdXRzOltkPy0xOjBdfSlbMF07ZCYmZS5jb21wdXRlKFBlKGsscCkse2lucHV0czpba119KX0sTGw9KGUsdCk9Pnt0ZyhlLmlucHV0cykscmcoZSx0KX0sR2w9ZT0+cmUoe2F4aXM6ZS5heGlzfSl9KTt2YXIgRmwsbmcsb2csaWcscWwsS2w9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTthZSgpO0ZsPWU9PkFycmF5LmZyb20oZS5nZXRCaWdJbnQ2NEFycmF5KCksTnVtYmVyKSxuZz1lPT57aWYoIWV8fGUubGVuZ3RoIT09Mil0aHJvdyBuZXcgRXJyb3IoXCJUaWxlIHJlcXVpcmVzIDIgaW5wdXRzLlwiKTtpZihlWzBdLmRhdGFUeXBlIT09MSYmZVswXS5kYXRhVHlwZSE9PTEwJiZlWzBdLmRhdGFUeXBlIT09NiYmZVswXS5kYXRhVHlwZSE9PTEyKXRocm93IG5ldyBFcnJvcihcIlRpbGUgb25seSBzdXBwb3J0IGZsb2F0LCBmbG9hdDE2LCBpbnQzMiwgYW5kIHVpbnQzMiBkYXRhIHR5cGVzXCIpO2lmKGVbMV0uZGF0YVR5cGUhPT03KXRocm93IG5ldyBFcnJvcihcIlRpbGUgYHJlcGVhdHNgIGlucHV0IHNob3VsZCBiZSBvZiBpbnQ2NCBkYXRhIHR5cGVcIik7aWYoZVsxXS5kaW1zLmxlbmd0aCE9PTEpdGhyb3cgbmV3IEVycm9yKFwiVGlsZSBgcmVwZWF0c2AgaW5wdXQgc2hvdWxkIGJlIDEtRFwiKTtpZihGbChlWzFdKS5sZW5ndGghPT1lWzBdLmRpbXMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIlRpbGUgYHJlcGVhdHNgIGlucHV0IHNob3VsZCBoYXZlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzIGFzIHJhbmsgb2YgaW5wdXQgZGF0YSB0ZW5zb3JcIil9LG9nPShlLHQpPT57bGV0IHI9W107Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDsrK24pci5wdXNoKGVbbl0qdFtuXSk7cmV0dXJuIHJ9LGlnPShlLHQpPT57bGV0IHI9ZVswXS5kaW1zLG49dD8/RmwoZVsxXSksbz1vZyhyLG4pLGk9Qy5zaXplKG8pLGE9ZVswXS5kYXRhVHlwZSxkPUUoXCJpbnB1dFwiLGEsci5sZW5ndGgpLGw9TShcIm91dHB1dFwiLGEsby5sZW5ndGgpLHA9bT0+YFxuICAgICAgY29uc3QgaW5wdXRTaGFwZSA9ICR7ZC5pbmRpY2VzKC4uLnIpfTtcbiAgICAgICR7bS5yZWdpc3RlclVuaWZvcm0oXCJvdXRwdXRfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMoZCxsKX1cbiAgICAgICR7bS5tYWluU3RhcnQoKX1cbiAgICAgICR7bS5ndWFyZEFnYWluc3RPdXRPZkJvdW5kc1dvcmtncm91cFNpemVzKFwidW5pZm9ybXMub3V0cHV0X3NpemVcIil9XG4gICAgICBsZXQgb3V0cHV0X2luZGljZXMgPSAke2wub2Zmc2V0VG9JbmRpY2VzKFwiZ2xvYmFsX2lkeFwiKX07XG4gICAgICB2YXIgaW5wdXRfaW5kaWNlczogJHtkLnR5cGUuaW5kaWNlc307XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8ICR7ci5sZW5ndGh9OyBpKyspIHtcbiAgICAgICAgbGV0IGlucHV0X2RpbV9pID0gJHtkLmluZGljZXNHZXQoXCJ1bmlmb3Jtcy5pbnB1dF9zaGFwZVwiLFwiaVwiKX07XG4gICAgICAgIGxldCBpbnB1dF9kaW1fdmFsdWUgPSAke2wuaW5kaWNlc0dldChcIm91dHB1dF9pbmRpY2VzXCIsXCJpXCIpfSAgJSBpbnB1dF9kaW1faTtcblxuICAgICAgICAke2QuaW5kaWNlc1NldChcImlucHV0X2luZGljZXNcIixcImlcIixcImlucHV0X2RpbV92YWx1ZVwiKX1cbiAgICAgIH1cbiAgICAgICR7bC5zZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIixkLmdldEJ5SW5kaWNlcyhcImlucHV0X2luZGljZXNcIikpfVxuICAgIH1gO3JldHVybntuYW1lOlwiVGlsZVwiLHNoYWRlckNhY2hlOntoaW50OmAke259YCxpbnB1dERlcGVuZGVuY2llczpbXCJyYW5rXCJdfSxnZXRSdW5EYXRhOigpPT4oe291dHB1dHM6W3tkaW1zOm8sZGF0YVR5cGU6ZVswXS5kYXRhVHlwZX1dLGRpc3BhdGNoR3JvdXA6e3g6TWF0aC5jZWlsKGkvNjQpfSxwcm9ncmFtVW5pZm9ybXM6W3t0eXBlOjEyLGRhdGE6aX0sLi4uTihlWzBdLmRpbXMsbyldfSksZ2V0U2hhZGVyU291cmNlOnB9fSxxbD1lPT57bmcoZS5pbnB1dHMpLGUuY29tcHV0ZShpZyhlLmlucHV0cykse2lucHV0czpbMF19KX19KTt2YXIgYWcsc2csamwsWWw9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7b2UoKTthZSgpO2FnPShlLHQscixuLG8pPT57bGV0IGk9TShcIm91dHB1dF9kYXRhXCIsbyxyLmxlbmd0aCw0KSxhPUUoXCJhX2RhdGFcIix0WzFdLmRhdGFUeXBlLHRbMV0uZGltcy5sZW5ndGgsNCksZD1FKFwiYl9kYXRhXCIsdFsyXS5kYXRhVHlwZSx0WzJdLmRpbXMubGVuZ3RoLDQpLGw9RShcImNfZGF0YVwiLHRbMF0uZGF0YVR5cGUsdFswXS5kaW1zLmxlbmd0aCw0KSxwLG09KHUsaCxfKT0+YHNlbGVjdCgke2h9LCAke3V9LCAke199KWA7aWYoIW4pcD1pLnNldEJ5T2Zmc2V0KFwiZ2xvYmFsX2lkeFwiLG0oYS5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIiksZC5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIiksbC5nZXRCeU9mZnNldChcImdsb2JhbF9pZHhcIikpKTtlbHNle2xldCB1PShoLF8seT1cIlwiKT0+e2xldCBnPWBhX2RhdGFbaW5kZXhfYSR7X31dW2NvbXBvbmVudF9hJHtffV1gLHg9YGJfZGF0YVtpbmRleF9iJHtffV1bY29tcG9uZW50X2Ike199XWAsJD1gYm9vbChjX2RhdGFbaW5kZXhfYyR7X31dICYgKDB4ZmZ1IDw8IChjb21wb25lbnRfYyR7X30gKiA4KSkpYDtyZXR1cm5gXG4gICAgICAgICAgICBsZXQgb3V0cHV0X2luZGljZXMke199ID0gJHtpLm9mZnNldFRvSW5kaWNlcyhgZ2xvYmFsX2lkeCAqIDR1ICsgJHtffXVgKX07XG4gICAgICAgICAgICBsZXQgb2Zmc2V0X2Eke199ID0gJHthLmJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0KGBvdXRwdXRfaW5kaWNlcyR7X31gLGkpfTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRfYiR7X30gPSAke2QuYnJvYWRjYXN0ZWRJbmRpY2VzVG9PZmZzZXQoYG91dHB1dF9pbmRpY2VzJHtffWAsaSl9O1xuICAgICAgICAgICAgbGV0IG9mZnNldF9jJHtffSA9ICR7bC5icm9hZGNhc3RlZEluZGljZXNUb09mZnNldChgb3V0cHV0X2luZGljZXMke199YCxpKX07XG4gICAgICAgICAgICBsZXQgaW5kZXhfYSR7X30gPSBvZmZzZXRfYSR7X30gLyA0dTtcbiAgICAgICAgICAgIGxldCBpbmRleF9iJHtffSA9IG9mZnNldF9iJHtffSAvIDR1O1xuICAgICAgICAgICAgbGV0IGluZGV4X2Mke199ID0gb2Zmc2V0X2Mke199IC8gNHU7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50X2Eke199ID0gb2Zmc2V0X2Eke199ICUgNHU7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50X2Ike199ID0gb2Zmc2V0X2Ike199ICUgNHU7XG4gICAgICAgICAgICBsZXQgY29tcG9uZW50X2Mke199ID0gb2Zmc2V0X2Mke199ICUgNHU7XG4gICAgICAgICAgICAke2h9WyR7X31dID0gJHt5fSgke20oZyx4LCQpfSk7XG4gICAgICAgICAgYH07bz09PTk/cD1gXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHZlYzQ8dTMyPigwKTtcbiAgICAgICAgICAgICR7dShcImRhdGFcIiwwLFwidTMyXCIpfVxuICAgICAgICAgICAgJHt1KFwiZGF0YVwiLDEsXCJ1MzJcIil9XG4gICAgICAgICAgICAke3UoXCJkYXRhXCIsMixcInUzMlwiKX1cbiAgICAgICAgICAgICR7dShcImRhdGFcIiwzLFwidTMyXCIpfVxuICAgICAgICAgICAgb3V0cHV0X2RhdGFbZ2xvYmFsX2lkeF0gPSBkb3QodmVjNDx1MzI+KDB4MSwgMHgxMDAsIDB4MTAwMDAsIDB4MTAwMDAwMCksIHZlYzQ8dTMyPihkYXRhKSk7YDpwPWBcbiAgICAgICAgICAgICR7dShcIm91dHB1dF9kYXRhW2dsb2JhbF9pZHhdXCIsMCl9XG4gICAgICAgICAgICAke3UoXCJvdXRwdXRfZGF0YVtnbG9iYWxfaWR4XVwiLDEpfVxuICAgICAgICAgICAgJHt1KFwib3V0cHV0X2RhdGFbZ2xvYmFsX2lkeF1cIiwyKX1cbiAgICAgICAgICAgICR7dShcIm91dHB1dF9kYXRhW2dsb2JhbF9pZHhdXCIsMyl9XG4gICAgICAgICAgYH1yZXR1cm5gXG4gICAgICAgICR7ZS5yZWdpc3RlclVuaWZvcm0oXCJ2ZWNfc2l6ZVwiLFwidTMyXCIpLmRlY2xhcmVWYXJpYWJsZXMobCxhLGQsaSl9XG4gICAgICAgICR7ZS5tYWluU3RhcnQoKX1cbiAgICAgICAgJHtlLmd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMoXCJ1bmlmb3Jtcy52ZWNfc2l6ZVwiKX1cbiAgICAgICAgJHtwfVxuICAgICAgfWB9LHNnPWU9PntsZXQgdD1lWzFdLmRpbXMscj1lWzJdLmRpbXMsbj1lWzBdLmRpbXMsbz1lWzFdLmRhdGFUeXBlLGk9IShDLmFyZUVxdWFsKHQscikmJkMuYXJlRXF1YWwocixuKSksYT10LGQ9Qy5zaXplKHQpO2lmKGkpe2xldCBwPXR0LmNhbGNTaGFwZSh0dC5jYWxjU2hhcGUodCxyLCExKSxuLCExKTtpZighcCl0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBwZXJmb3JtIHdoZXJlIG9wIG9uIHRoZSBnaXZlbiB0ZW5zb3JzXCIpO2E9cCxkPUMuc2l6ZShhKX1sZXQgbD1NYXRoLmNlaWwoZC80KTtyZXR1cm57bmFtZTpcIldoZXJlXCIsc2hhZGVyQ2FjaGU6e2lucHV0RGVwZW5kZW5jaWVzOltcInJhbmtcIixcInJhbmtcIixcInJhbmtcIl19LGdldFNoYWRlclNvdXJjZTpwPT5hZyhwLGUsYSxpLG8pLGdldFJ1bkRhdGE6KCk9Pih7b3V0cHV0czpbe2RpbXM6YSxkYXRhVHlwZTpvfV0sZGlzcGF0Y2hHcm91cDp7eDpNYXRoLmNlaWwoZC82NC80KX0scHJvZ3JhbVVuaWZvcm1zOlt7dHlwZToxMixkYXRhOmx9LC4uLk4obix0LHIsYSldfSl9fSxqbD1lPT57ZS5jb21wdXRlKHNnKGUuaW5wdXRzKSl9fSk7dmFyIFpsLFFsPVUoKCk9PntcInVzZSBzdHJpY3RcIjtQcygpO0ZyKCk7RHMoKTtNcygpO3Z1KCk7enUoKTtCdSgpO1F1KCk7b2QoKTtzZCgpO2xkKCk7aGQoKTt5ZCgpO3dkKCk7eGQoKTtJZCgpO2tkKCk7emQoKTtCZCgpO1VkKCk7cWQoKTtZZCgpO1FkKCk7SmQoKTtybCgpO1NvKCk7b2woKTt2bCgpO1NsKCk7SWwoKTtrbCgpO0dyKCk7T2woKTtCbCgpO1JsKCk7V2woKTtIbCgpO0lvKCk7S2woKTtkdCgpO0tyKCk7WWwoKTtabD1uZXcgTWFwKFtbXCJBYnNcIixbUnNdXSxbXCJBY29zXCIsW1VzXV0sW1wiQWNvc2hcIixbTnNdXSxbXCJBZGRcIixbJHVdXSxbXCJBcmdNYXhcIixbRXMsY29dXSxbXCJBcmdNaW5cIixba3MsY29dXSxbXCJBc2luXCIsW1ZzXV0sW1wiQXNpbmhcIixbV3NdXSxbXCJBdGFuXCIsW0xzXV0sW1wiQXRhbmhcIixbR3NdXSxbXCJBdHRlbnRpb25cIixbenNdXSxbXCJBdmVyYWdlUG9vbFwiLFtwbCxjbF1dLFtcIkJhdGNoTm9ybWFsaXphdGlvblwiLFtPc11dLFtcIkJpYXNBZGRcIixbQnNdXSxbXCJCaWFzU3BsaXRHZWx1XCIsW3d1XV0sW1wiQ2FzdFwiLFtGcyxIc11dLFtcIkNlaWxcIixbS3NdXSxbXCJDbGlwXCIsW3FzXV0sW1wiQ29uY2F0XCIsW091LER1XV0sW1wiQ29udlwiLFt3byxfb11dLFtcIkNvbnZUcmFuc3Bvc2VcIixbbmQsdGRdXSxbXCJDb3NcIixbanNdXSxbXCJDb3NoXCIsW1lzXV0sW1wiQ3VtU3VtXCIsW2lkLGFkXV0sW1wiRGVwdGhUb1NwYWNlXCIsW3VkLGRkXV0sW1wiRGVxdWFudGl6ZUxpbmVhclwiLFskbCx4bF1dLFtcIkRpdlwiLFt4dV1dLFtcIkVpbnN1bVwiLFttZCxmZF1dLFtcIkVsdVwiLFtacyxYdF1dLFtcIkVxdWFsXCIsW1N1XV0sW1wiRXJmXCIsW1FzXV0sW1wiRXhwXCIsW1hzXV0sW1wiRXhwYW5kXCIsW2JkXV0sW1wiRmFzdEdlbHVcIixbX2RdXSxbXCJGbG9vclwiLFtKc11dLFtcIkZ1c2VkQ29udlwiLFt3byxfb11dLFtcIkdhdGhlclwiLFskZCx2ZF1dLFtcIkdhdGhlckVsZW1lbnRzXCIsW1BkLEVkXV0sW1wiR2F0aGVyQmxvY2tRdWFudGl6ZWRcIixbQ2QsQWRdXSxbXCJHYXRoZXJORFwiLFtTZCxUZF1dLFtcIkdlbHVcIixbZXVdXSxbXCJHZW1tXCIsW0RkLE9kXV0sW1wiR2xvYmFsQXZlcmFnZVBvb2xcIixbaGwsZmxdXSxbXCJHbG9iYWxNYXhQb29sXCIsW3dsLF9sXV0sW1wiR3JlYXRlclwiLFtBdV1dLFtcIkdyZWF0ZXJPckVxdWFsXCIsW0V1XV0sW1wiR3JpZFNhbXBsZVwiLFtNZCxSZF1dLFtcIkdyb3VwUXVlcnlBdHRlbnRpb25cIixbRmRdXSxbXCJIYXJkU2lnbW9pZFwiLFt1dSxzdV1dLFtcIkluc3RhbmNlTm9ybWFsaXphdGlvblwiLFtqZF1dLFtcIkxheWVyTm9ybWFsaXphdGlvblwiLFtaZF1dLFtcIkxlYWt5UmVsdVwiLFt0dSxYdF1dLFtcIkxlc3NcIixba3VdXSxbXCJMZXNzT3JFcXVhbFwiLFtQdV1dLFtcIkxvZ1wiLFtidV1dLFtcIk1hdE11bFwiLFtYZF1dLFtcIk1hdE11bE5CaXRzXCIsW2VsLHRsXV0sW1wiTWF4UG9vbFwiLFtibCx5bF1dLFtcIk11bFwiLFtUdV1dLFtcIk11bHRpSGVhZEF0dGVudGlvblwiLFtXZCxWZF1dLFtcIk5lZ1wiLFtudV1dLFtcIk5vdFwiLFtydV1dLFtcIlBhZFwiLFtubF1dLFtcIlBvd1wiLFtJdV1dLFtcIlF1aWNrR2VsdVwiLFt5dSxYdF1dLFtcIlJhbmdlXCIsW1RsXV0sW1wiUmVjaXByb2NhbFwiLFtvdV1dLFtcIlJlZHVjZU1pblwiLFt4c11dLFtcIlJlZHVjZU1lYW5cIixbeXNdXSxbXCJSZWR1Y2VNYXhcIixbJHNdXSxbXCJSZWR1Y2VTdW1cIixbVHNdXSxbXCJSZWR1Y2VQcm9kXCIsW1NzXV0sW1wiUmVkdWNlTDFcIixbX3NdXSxbXCJSZWR1Y2VMMlwiLFt3c11dLFtcIlJlZHVjZUxvZ1N1bVwiLFtDc11dLFtcIlJlZHVjZUxvZ1N1bUV4cFwiLFt2c11dLFtcIlJlZHVjZVN1bVNxdWFyZVwiLFtJc11dLFtcIlJlbHVcIixbaXVdXSxbXCJSZXNpemVcIixbUGwsemxdXSxbXCJSb3RhcnlFbWJlZGRpbmdcIixbRGxdXSxbXCJTY2F0dGVyTkRcIixbQWwsQ2xdXSxbXCJTaWdtb2lkXCIsW2F1XV0sW1wiU2luXCIsW2R1XV0sW1wiU2luaFwiLFtsdV1dLFtcIlNsaWNlXCIsW05sLFZsXV0sW1wiU2tpcExheWVyTm9ybWFsaXphdGlvblwiLFtNbF1dLFtcIlNwbGl0XCIsW0xkLEdkXV0sW1wiU3FydFwiLFtjdV1dLFtcIlNvZnRtYXhcIixbTGwsR2xdXSxbXCJTdWJcIixbQ3VdXSxbXCJUYW5cIixbcHVdXSxbXCJUYW5oXCIsW2Z1XV0sW1wiVGhyZXNob2xkZWRSZWx1XCIsW2d1LFh0XV0sW1wiVGlsZVwiLFtxbF1dLFtcIlRyYW5zcG9zZVwiLFtpcyxhc11dLFtcIldoZXJlXCIsW2psXV1dKX0pO3ZhciBubixYbD1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7V2UoKTtldCgpO2FlKCk7bm49Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy5iYWNrZW5kPXQ7dGhpcy5yZXBvPW5ldyBNYXAsdGhpcy5hdHRyaWJ1dGVzQm91bmQ9ITF9Z2V0QXJ0aWZhY3QodCl7cmV0dXJuIHRoaXMucmVwby5nZXQodCl9c2V0QXJ0aWZhY3QodCxyKXt0aGlzLnJlcG8uc2V0KHQscil9cnVuKHQscixuLG8saSl7VWUodC5wcm9ncmFtSW5mby5uYW1lKTtsZXQgYT10aGlzLmJhY2tlbmQuZGV2aWNlLGQ9dGhpcy5iYWNrZW5kLmdldENvbXB1dGVQYXNzRW5jb2RlcigpO3RoaXMuYmFja2VuZC53cml0ZVRpbWVzdGFtcCh0aGlzLmJhY2tlbmQucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKjIpO2xldCBsPVtdO2ZvcihsZXQgbSBvZiByKWwucHVzaCh7YmluZGluZzpsLmxlbmd0aCxyZXNvdXJjZTp7YnVmZmVyOm0uYnVmZmVyfX0pO2ZvcihsZXQgbSBvZiBuKWwucHVzaCh7YmluZGluZzpsLmxlbmd0aCxyZXNvdXJjZTp7YnVmZmVyOm0uYnVmZmVyfX0pO2kmJmwucHVzaCh7YmluZGluZzpsLmxlbmd0aCxyZXNvdXJjZTppfSk7bGV0IHA9YS5jcmVhdGVCaW5kR3JvdXAoe2xheW91dDp0LmNvbXB1dGVQaXBlbGluZS5nZXRCaW5kR3JvdXBMYXlvdXQoMCksZW50cmllczpsLGxhYmVsOnQucHJvZ3JhbUluZm8ubmFtZX0pO2lmKHRoaXMuYmFja2VuZC5zZXNzaW9uU3RhdHVzPT09XCJjYXB0dXJpbmdcIil7bGV0IG09e2tlcm5lbElkOnRoaXMuYmFja2VuZC5jdXJyZW50S2VybmVsSWQsY29tcHV0ZVBpcGVsaW5lOnQuY29tcHV0ZVBpcGVsaW5lLGJpbmRHcm91cDpwLGRpc3BhdGNoR3JvdXA6b307dGhpcy5iYWNrZW5kLmNhcHR1cmVkQ29tbWFuZExpc3QuZ2V0KHRoaXMuYmFja2VuZC5jdXJyZW50U2Vzc2lvbklkKS5wdXNoKG0pfWQuc2V0UGlwZWxpbmUodC5jb21wdXRlUGlwZWxpbmUpLGQuc2V0QmluZEdyb3VwKDAscCksZC5kaXNwYXRjaFdvcmtncm91cHMoLi4ubyksdGhpcy5iYWNrZW5kLndyaXRlVGltZXN0YW1wKHRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIqMisxKSx0aGlzLmJhY2tlbmQucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKyssKHRoaXMuYmFja2VuZC5wZW5kaW5nRGlzcGF0Y2hOdW1iZXI+PXRoaXMuYmFja2VuZC5tYXhEaXNwYXRjaE51bWJlcnx8dGhpcy5iYWNrZW5kLnF1ZXJ5VHlwZT09PVwiYXQtcGFzc2VzXCIpJiZ0aGlzLmJhY2tlbmQuZW5kQ29tcHV0ZVBhc3MoKSx0aGlzLmJhY2tlbmQucGVuZGluZ0Rpc3BhdGNoTnVtYmVyPj10aGlzLmJhY2tlbmQubWF4RGlzcGF0Y2hOdW1iZXImJnRoaXMuYmFja2VuZC5mbHVzaCgpLERlKHQucHJvZ3JhbUluZm8ubmFtZSl9ZGlzcG9zZSgpe31idWlsZCh0LHIpe1VlKHQubmFtZSk7bGV0IG49dGhpcy5iYWNrZW5kLmRldmljZSxvPVtdO1t7ZmVhdHVyZTpcInNoYWRlci1mMTZcIixleHRlbnNpb246XCJmMTZcIn0se2ZlYXR1cmU6XCJzdWJncm91cHNcIixleHRlbnNpb246XCJzdWJncm91cHNcIn0se2ZlYXR1cmU6XCJzdWJncm91cHMtZjE2XCIsZXh0ZW5zaW9uOlwic3ViZ3JvdXBzX2YxNlwifV0uZm9yRWFjaCh1PT57bi5mZWF0dXJlcy5oYXModS5mZWF0dXJlKSYmby5wdXNoKGBlbmFibGUgJHt1LmV4dGVuc2lvbn07YCl9KTtsZXQgYT1ucyhyLHRoaXMuYmFja2VuZC5kZXZpY2UubGltaXRzKSxkPXQuZ2V0U2hhZGVyU291cmNlKGEpLGw9YCR7by5qb2luKGBcbmApfVxuJHthLmFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbnN9XG4ke2R9YCxwPW4uY3JlYXRlU2hhZGVyTW9kdWxlKHtjb2RlOmwsbGFiZWw6dC5uYW1lfSk7dWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSAke3QubmFtZX0gc2hhZGVyIGNvZGU6ICR7bH1gKTtsZXQgbT1uLmNyZWF0ZUNvbXB1dGVQaXBlbGluZSh7Y29tcHV0ZTp7bW9kdWxlOnAsZW50cnlQb2ludDpcIm1haW5cIn0sbGF5b3V0OlwiYXV0b1wiLGxhYmVsOnQubmFtZX0pO3JldHVybiBEZSh0Lm5hbWUpLHtwcm9ncmFtSW5mbzp0LGNvbXB1dGVQaXBlbGluZTptLHVuaWZvcm1WYXJpYWJsZXNJbmZvOmEudmFyaWFibGVzSW5mb319bm9ybWFsaXplRGlzcGF0Y2hHcm91cFNpemUodCl7bGV0IHI9dHlwZW9mIHQ9PVwibnVtYmVyXCI/dDp0Lngsbj10eXBlb2YgdD09XCJudW1iZXJcIj8xOnQueXx8MSxvPXR5cGVvZiB0PT1cIm51bWJlclwiPzE6dC56fHwxLGk9dGhpcy5iYWNrZW5kLmRldmljZS5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cHNQZXJEaW1lbnNpb247aWYocjw9aSYmbjw9aSYmbzw9aSlyZXR1cm5bcixuLG9dO2xldCBhPXIqbipvLGQ9TWF0aC5jZWlsKE1hdGguc3FydChhKSk7aWYoZD5pKXtpZihkPU1hdGguY2VpbChNYXRoLmNicnQoYSkpLGQ+aSl0aHJvdyBuZXcgRXJyb3IoXCJUb3RhbCBkaXNwYXRjaCBzaXplIGV4Y2VlZHMgV2ViR1BVIG1heGltdW0uXCIpO3JldHVybltkLGQsZF19ZWxzZSByZXR1cm5bZCxkLDFdfX19KTt2YXIgdWcsZGcsQ28sQW8sb24sSmw9VSgoKT0+e1widXNlIHN0cmljdFwiO1dlKCk7dGUoKTtldCgpO0puKCk7SmEoKTtRbCgpO1hsKCk7dWc9KGUsdCk9PntpZih0Lmxlbmd0aCE9PWUubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgaW5wdXREZXBlbmRlbmNpZXMgbGVuZ3RoICR7dC5sZW5ndGh9IGlzIG5vdCBlcXVhbCB0byBpbnB1dFRlbnNvcnMgbGVuZ3RoICR7ZS5sZW5ndGh9LmApO2xldCByPVtdO2ZvcihsZXQgbj0wO248ZS5sZW5ndGg7KytuKXtsZXQgbz1lW25dLmRhdGFUeXBlO3N3aXRjaCh0W25dKXtjYXNlXCJub25lXCI6e3IucHVzaChcIlwiKTticmVha31jYXNlXCJ0eXBlXCI6e3IucHVzaChgJHtvfWApO2JyZWFrfWNhc2VcInJhbmtcIjp7bGV0IGk9ZVtuXS5kaW1zLmxlbmd0aDtyLnB1c2goYCR7b307JHtpfWApO2JyZWFrfWNhc2VcImRpbXNcIjp7bGV0IGk9ZVtuXS5kaW1zLmpvaW4oXCIsXCIpO3IucHVzaChgJHtvfTske2l9YCk7YnJlYWt9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkIGlucHV0IGRlcGVuZGVuY3k6ICR7dFtuXX1gKX19cmV0dXJuIHIuam9pbihcInxcIil9LGRnPShlLHQscik9PntsZXQgbj1lLm5hbWU7cmV0dXJuIGUuc2hhZGVyQ2FjaGU/LmhpbnQmJihuKz1cIltcIitlLnNoYWRlckNhY2hlLmhpbnQrXCJdXCIpLG4rPVwiOlwiK3IrYDoke3VnKHQsZS5zaGFkZXJDYWNoZT8uaW5wdXREZXBlbmRlbmNpZXM/P25ldyBBcnJheSh0Lmxlbmd0aCkuZmlsbChcImRpbXNcIikpfWAsbn0sQ289Y2xhc3N7Y29uc3RydWN0b3IodCl7dCYmKHRoaXMuYXJjaGl0ZWN0dXJlPXQuYXJjaGl0ZWN0dXJlLHRoaXMudmVuZG9yPXQudmVuZG9yKX1pc0FyY2hpdGVjdHVyZSh0KXtyZXR1cm4gdGhpcy5hcmNoaXRlY3R1cmU9PT10fWlzVmVuZG9yKHQpe3JldHVybiB0aGlzLnZlbmRvcj09PXR9fSxBbz1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLnN1Ymdyb3Vwc1N1cHBvcnRlZD10LmZlYXR1cmVzLmhhcyhcInN1Ymdyb3Vwc1wiKSx0aGlzLnN1Ymdyb3Vwc0YxNlN1cHBvcnRlZD10LmZlYXR1cmVzLmhhcyhcInN1Ymdyb3Vwc1wiKTtsZXQgcj10LmxpbWl0czshdGhpcy5zdWJncm91cHNTdXBwb3J0ZWR8fCFyLm1pblN1Ymdyb3VwU2l6ZXx8IXIubWF4U3ViZ3JvdXBTaXplP3RoaXMuc3ViZ3JvdXBTaXplUmFuZ2U9dm9pZCAwOnRoaXMuc3ViZ3JvdXBTaXplUmFuZ2U9W3IubWluU3ViZ3JvdXBTaXplLHIubWF4U3ViZ3JvdXBTaXplXX19LG9uPWNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5jdXJyZW50U2Vzc2lvbklkPW51bGw7dGhpcy5jdXJyZW50S2VybmVsSWQ9bnVsbDt0aGlzLmNvbW1hbmRFbmNvZGVyPW51bGw7dGhpcy5jb21wdXRlUGFzc0VuY29kZXI9bnVsbDt0aGlzLm1heERpc3BhdGNoTnVtYmVyPTE2O3RoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyPTA7dGhpcy5wZW5kaW5nS2VybmVscz1bXTt0aGlzLnBlbmRpbmdRdWVyaWVzPW5ldyBNYXA7dGhpcy5zZXNzaW9uU3RhdHVzPVwiZGVmYXVsdFwiO3RoaXMuY2FwdHVyZWRDb21tYW5kTGlzdD1uZXcgTWFwO3RoaXMuY2FwdHVyZWRQZW5kaW5nS2VybmVscz1uZXcgTWFwO3RoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmc9bmV3IE1hcH1nZXQgY3VycmVudEtlcm5lbEN1c3RvbURhdGEoKXtpZih0aGlzLmN1cnJlbnRLZXJuZWxJZD09PW51bGwpdGhyb3cgbmV3IEVycm9yKFwiY3VycmVudEtlcm5lbEN1c3RvbURhdGEoKTogY3VycmVudEtlcm5lbElkIGlzIG51bGwuIChzaG91bGQgbm90IGhhcHBlbilcIik7bGV0IHQ9dGhpcy5rZXJuZWxDdXN0b21EYXRhLmdldCh0aGlzLmN1cnJlbnRLZXJuZWxJZCk7cmV0dXJuIHR8fCh0PXt9LHRoaXMua2VybmVsQ3VzdG9tRGF0YS5zZXQodGhpcy5jdXJyZW50S2VybmVsSWQsdCkpLHR9YXN5bmMgaW5pdGlhbGl6ZSh0LHIpe3RoaXMuZW52PXQ7bGV0IG49W10sbz17cmVxdWlyZWRMaW1pdHM6e21heENvbXB1dGVXb3JrZ3JvdXBTdG9yYWdlU2l6ZTpyLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU3RvcmFnZVNpemUsbWF4Q29tcHV0ZVdvcmtncm91cHNQZXJEaW1lbnNpb246ci5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cHNQZXJEaW1lbnNpb24sbWF4U3RvcmFnZUJ1ZmZlckJpbmRpbmdTaXplOnIubGltaXRzLm1heFN0b3JhZ2VCdWZmZXJCaW5kaW5nU2l6ZSxtYXhCdWZmZXJTaXplOnIubGltaXRzLm1heEJ1ZmZlclNpemUsbWF4Q29tcHV0ZUludm9jYXRpb25zUGVyV29ya2dyb3VwOnIubGltaXRzLm1heENvbXB1dGVJbnZvY2F0aW9uc1Blcldvcmtncm91cCxtYXhDb21wdXRlV29ya2dyb3VwU2l6ZVg6ci5saW1pdHMubWF4Q29tcHV0ZVdvcmtncm91cFNpemVYLG1heENvbXB1dGVXb3JrZ3JvdXBTaXplWTpyLmxpbWl0cy5tYXhDb21wdXRlV29ya2dyb3VwU2l6ZVksbWF4Q29tcHV0ZVdvcmtncm91cFNpemVaOnIubGltaXRzLm1heENvbXB1dGVXb3JrZ3JvdXBTaXplWn0scmVxdWlyZWRGZWF0dXJlczpufSxpPWE9PnIuZmVhdHVyZXMuaGFzKGEpJiZuLnB1c2goYSkmJiEwO2koXCJjaHJvbWl1bS1leHBlcmltZW50YWwtdGltZXN0YW1wLXF1ZXJ5LWluc2lkZS1wYXNzZXNcIil8fGkoXCJ0aW1lc3RhbXAtcXVlcnlcIiksaShcInNoYWRlci1mMTZcIiksaShcInN1Ymdyb3Vwc1wiKSYmaShcInN1Ymdyb3Vwcy1mMTZcIiksdGhpcy5kZXZpY2U9YXdhaXQgci5yZXF1ZXN0RGV2aWNlKG8pLHRoaXMuZGV2aWNlSW5mbz1uZXcgQW8odGhpcy5kZXZpY2UpLHRoaXMuYWRhcHRlckluZm89bmV3IENvKHIuaW5mb3x8YXdhaXQgci5yZXF1ZXN0QWRhcHRlckluZm8oKSksdGhpcy5ncHVEYXRhTWFuYWdlcj1YYSh0aGlzKSx0aGlzLnByb2dyYW1NYW5hZ2VyPW5ldyBubih0aGlzKSx0aGlzLmtlcm5lbHM9bmV3IE1hcCx0aGlzLmtlcm5lbFBlcnNpc3RlbnREYXRhPW5ldyBNYXAsdGhpcy5rZXJuZWxDdXN0b21EYXRhPW5ldyBNYXAsUnIodC5sb2dMZXZlbCwhIXQuZGVidWcpLHRoaXMuZGV2aWNlLm9udW5jYXB0dXJlZGVycm9yPWE9PnthLmVycm9yIGluc3RhbmNlb2YgR1BVVmFsaWRhdGlvbkVycm9yJiZjb25zb2xlLmVycm9yKGBBbiB1bmNhdWdodCBXZWJHUFUgdmFsaWRhdGlvbiBlcnJvciB3YXMgcmFpc2VkOiAke2EuZXJyb3IubWVzc2FnZX1gKX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMuZW52LndlYmdwdSxcImRldmljZVwiLHt2YWx1ZTp0aGlzLmRldmljZSx3cml0YWJsZTohMSxlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLmVudi53ZWJncHUsXCJhZGFwdGVyXCIse3ZhbHVlOnIsd3JpdGFibGU6ITEsZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITF9KSx0aGlzLnNldFF1ZXJ5VHlwZSgpfWRpc3Bvc2UoKXt0eXBlb2YgdGhpcy5xdWVyeVNldDxcInVcIiYmdGhpcy5xdWVyeVNldC5kZXN0cm95KCksdGhpcy5ncHVEYXRhTWFuYWdlci5kaXNwb3NlKCl9Z2V0Q29tbWFuZEVuY29kZXIoKXtyZXR1cm4gdGhpcy5jb21tYW5kRW5jb2Rlcnx8KHRoaXMuY29tbWFuZEVuY29kZXI9dGhpcy5kZXZpY2UuY3JlYXRlQ29tbWFuZEVuY29kZXIoKSksdGhpcy5jb21tYW5kRW5jb2Rlcn1nZXRDb21wdXRlUGFzc0VuY29kZXIoKXtpZighdGhpcy5jb21wdXRlUGFzc0VuY29kZXIpe2xldCB0PXRoaXMuZ2V0Q29tbWFuZEVuY29kZXIoKSxyPXt9O3RoaXMucXVlcnlUeXBlPT09XCJhdC1wYXNzZXNcIiYmKHIudGltZXN0YW1wV3JpdGVzPXtxdWVyeVNldDp0aGlzLnF1ZXJ5U2V0LGJlZ2lubmluZ09mUGFzc1dyaXRlSW5kZXg6dGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIqMixlbmRPZlBhc3NXcml0ZUluZGV4OnRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKjIrMX0pLHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyPXQuYmVnaW5Db21wdXRlUGFzcyhyKX1yZXR1cm4gdGhpcy5jb21wdXRlUGFzc0VuY29kZXJ9ZW5kQ29tcHV0ZVBhc3MoKXt0aGlzLmNvbXB1dGVQYXNzRW5jb2RlciYmKHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyLmVuZCgpLHRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyPW51bGwpfWZsdXNoKCl7aWYoIXRoaXMuY29tbWFuZEVuY29kZXIpcmV0dXJuO1VlKCksdGhpcy5lbmRDb21wdXRlUGFzcygpO2xldCB0O3RoaXMucXVlcnlUeXBlIT09XCJub25lXCImJih0aGlzLmNvbW1hbmRFbmNvZGVyLnJlc29sdmVRdWVyeVNldCh0aGlzLnF1ZXJ5U2V0LDAsdGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIqMix0aGlzLnF1ZXJ5UmVzb2x2ZUJ1ZmZlciwwKSx0PXRoaXMuZGV2aWNlLmNyZWF0ZUJ1ZmZlcih7c2l6ZTp0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcioyKjgsdXNhZ2U6R1BVQnVmZmVyVXNhZ2UuTUFQX1JFQUR8R1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1R9KSx0aGlzLnBlbmRpbmdRdWVyaWVzLnNldCh0LHRoaXMucGVuZGluZ0tlcm5lbHMpLHRoaXMucGVuZGluZ0tlcm5lbHM9W10sdGhpcy5jb21tYW5kRW5jb2Rlci5jb3B5QnVmZmVyVG9CdWZmZXIodGhpcy5xdWVyeVJlc29sdmVCdWZmZXIsMCx0LDAsdGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXIqMio4KSksdGhpcy5kZXZpY2UucXVldWUuc3VibWl0KFt0aGlzLmNvbW1hbmRFbmNvZGVyLmZpbmlzaCgpXSksdGhpcy5ncHVEYXRhTWFuYWdlci5yZWZyZXNoUGVuZGluZ0J1ZmZlcnMoKSx0aGlzLmNvbW1hbmRFbmNvZGVyPW51bGwsdGhpcy5wZW5kaW5nRGlzcGF0Y2hOdW1iZXI9MCx0aGlzLnF1ZXJ5VHlwZSE9PVwibm9uZVwiJiZ0Lm1hcEFzeW5jKEdQVU1hcE1vZGUuUkVBRCkudGhlbigoKT0+e2xldCByPW5ldyBCaWdVaW50NjRBcnJheSh0LmdldE1hcHBlZFJhbmdlKCkpLG49dGhpcy5wZW5kaW5nUXVlcmllcy5nZXQodCk7Zm9yKGxldCBvPTA7bzxyLmxlbmd0aC8yO28rKyl7bGV0IGk9bltvXSxhPWkua2VybmVsSWQsZD10aGlzLmtlcm5lbHMuZ2V0KGEpLGw9ZC5rZXJuZWxUeXBlLHA9ZC5rZXJuZWxOYW1lLG09aS5wcm9ncmFtTmFtZSx1PWkuaW5wdXRUZW5zb3JWaWV3cyxoPWkub3V0cHV0VGVuc29yVmlld3MsXz1yW28qMl0seT1yW28qMisxXTt0eXBlb2YgdGhpcy5xdWVyeVRpbWVCYXNlPlwidVwiJiYodGhpcy5xdWVyeVRpbWVCYXNlPV8pO2xldCBnPU51bWJlcihfLXRoaXMucXVlcnlUaW1lQmFzZSkseD1OdW1iZXIoeS10aGlzLnF1ZXJ5VGltZUJhc2UpO2lmKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihnKXx8IU51bWJlci5pc1NhZmVJbnRlZ2VyKHgpKXRocm93IG5ldyBSYW5nZUVycm9yKFwiaW5jb3JyZWN0IHRpbWVzdGFtcCByYW5nZVwiKTtpZih0aGlzLmVudi53ZWJncHUucHJvZmlsaW5nPy5vbmRhdGEpdGhpcy5lbnYud2ViZ3B1LnByb2ZpbGluZy5vbmRhdGEoe3ZlcnNpb246MSxpbnB1dHNNZXRhZGF0YTp1Lm1hcCgkPT4oe2RpbXM6JC5kaW1zLGRhdGFUeXBlOmJ0KCQuZGF0YVR5cGUpfSkpLG91dHB1dHNNZXRhZGF0YTpoLm1hcCgkPT4oe2RpbXM6JC5kaW1zLGRhdGFUeXBlOmJ0KCQuZGF0YVR5cGUpfSkpLGtlcm5lbElkOmEsa2VybmVsVHlwZTpsLGtlcm5lbE5hbWU6cCxwcm9ncmFtTmFtZTptLHN0YXJ0VGltZTpnLGVuZFRpbWU6eH0pO2Vsc2V7bGV0ICQ9XCJcIjt1LmZvckVhY2goKFMsVCk9PnskKz1gaW5wdXRbJHtUfV06IFske1MuZGltc31dIHwgJHtidChTLmRhdGFUeXBlKX0sIGB9KTtsZXQgdj1cIlwiO2guZm9yRWFjaCgoUyxUKT0+e3YrPWBvdXRwdXRbJHtUfV06IFske1MuZGltc31dIHwgJHtidChTLmRhdGFUeXBlKX0sIGB9KSxjb25zb2xlLmxvZyhgW3Byb2ZpbGluZ10ga2VybmVsIFwiJHthfXwke2x9fCR7cH18JHttfVwiICR7JH0ke3Z9ZXhlY3V0aW9uIHRpbWU6ICR7eC1nfSBuc2ApfXdyKFwiR1BVXCIsYCR7bX06OiR7X306OiR7eX1gKX10LnVubWFwKCksdGhpcy5wZW5kaW5nUXVlcmllcy5kZWxldGUodCl9KSxEZSgpfXJ1bih0LHIsbixvLGksYSl7VWUodC5uYW1lKTtsZXQgZD1bXTtmb3IobGV0IFM9MDtTPHIubGVuZ3RoOysrUyl7bGV0IFQ9cltTXS5kYXRhO2lmKFQ9PT0wKWNvbnRpbnVlO2xldCBBPXRoaXMuZ3B1RGF0YU1hbmFnZXIuZ2V0KFQpO2lmKCFBKXRocm93IG5ldyBFcnJvcihgbm8gR1BVIGRhdGEgZm9yIGlucHV0OiAke1R9YCk7ZC5wdXNoKEEpfWxldHtvdXRwdXRzOmwsZGlzcGF0Y2hHcm91cDpwLHByb2dyYW1Vbmlmb3JtczptfT10LmdldFJ1bkRhdGEociksdT1uLmxlbmd0aD09PTA/bC5tYXAoKFMsVCk9PlQpOm47aWYodS5sZW5ndGghPT1sLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoYE91dHB1dCBzaXplICR7dS5sZW5ndGh9IG11c3QgYmUgZXF1YWwgdG8gJHtsLmxlbmd0aH0uYCk7bGV0IGg9W10sXz1bXTtmb3IobGV0IFM9MDtTPGwubGVuZ3RoOysrUyl7aWYoIU51bWJlci5pc0ludGVnZXIodVtTXSl8fHVbU108LTN8fHVbU10+PWEpdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIG91dHB1dCBpbmRleDogJHt1W1NdfWApO2lmKHVbU109PT0tMyljb250aW51ZTtsZXQgVD11W1NdPT09LTEsQT11W1NdPT09LTIsaz1UfHxBP2kobFtTXS5kYXRhVHlwZSxsW1NdLmRpbXMpOm8odVtTXSxsW1NdLmRhdGFUeXBlLGxbU10uZGltcyk7aWYoaC5wdXNoKGspLGsuZGF0YT09PTApY29udGludWU7bGV0IFA9dGhpcy5ncHVEYXRhTWFuYWdlci5nZXQoay5kYXRhKTtpZighUCl0aHJvdyBuZXcgRXJyb3IoYG5vIEdQVSBkYXRhIGZvciBvdXRwdXQ6ICR7ay5kYXRhfWApO2lmKFQmJnRoaXMudGVtcG9yYXJ5RGF0YS5wdXNoKFApLEEpe2xldCBEPXRoaXMua2VybmVsUGVyc2lzdGVudERhdGEuZ2V0KHRoaXMuY3VycmVudEtlcm5lbElkKTtEfHwoRD1bXSx0aGlzLmtlcm5lbFBlcnNpc3RlbnREYXRhLnNldCh0aGlzLmN1cnJlbnRLZXJuZWxJZCxEKSksRC5wdXNoKFApfV8ucHVzaChQKX1pZihkLmxlbmd0aCE9PXIubGVuZ3RofHxfLmxlbmd0aCE9PWgubGVuZ3RoKXtpZihfLmxlbmd0aD09PTApcmV0dXJuIERlKHQubmFtZSksaDt0aHJvdyBuZXcgRXJyb3IoYFByb2dyYW0gJHt0Lm5hbWV9IGhhcyB6ZXJvLXNpemVkIHRlbnNvcihzKSBpbiBpbnB1dHMgb3Igb3V0cHV0cy4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkIG5vdy5gKX1sZXQgeTtpZihtKXtsZXQgUz0wLFQ9W107bS5mb3JFYWNoKEQ9PntsZXQgUj10eXBlb2YgRC5kYXRhPT1cIm51bWJlclwiP1tELmRhdGFdOkQuZGF0YTtpZihSLmxlbmd0aD09PTApcmV0dXJuO2xldCBHPUQudHlwZT09PTEwPzI6NCxLLGo7RC50eXBlPT09MTA/KGo9Ui5sZW5ndGg+ND8xNjpSLmxlbmd0aD4yPzg6Ui5sZW5ndGgqRyxLPVIubGVuZ3RoPjQ/MTY6RypSLmxlbmd0aCk6KGo9Ui5sZW5ndGg8PTI/Ui5sZW5ndGgqRzoxNixLPTE2KSxTPU1hdGguY2VpbChTL2opKmosVC5wdXNoKFMpO2xldCBWPUQudHlwZT09PTEwPzg6NDtTKz1SLmxlbmd0aD40P01hdGguY2VpbChSLmxlbmd0aC9WKSpLOlIubGVuZ3RoKkd9KTtsZXQgQT0xNjtTPU1hdGguY2VpbChTL0EpKkE7bGV0IGs9bmV3IEFycmF5QnVmZmVyKFMpO20uZm9yRWFjaCgoRCxSKT0+e2xldCBHPVRbUl0sSz10eXBlb2YgRC5kYXRhPT1cIm51bWJlclwiP1tELmRhdGFdOkQuZGF0YTtpZihELnR5cGU9PT02KW5ldyBJbnQzMkFycmF5KGssRyxLLmxlbmd0aCkuc2V0KEspO2Vsc2UgaWYoRC50eXBlPT09MTIpbmV3IFVpbnQzMkFycmF5KGssRyxLLmxlbmd0aCkuc2V0KEspO2Vsc2UgaWYoRC50eXBlPT09MTApbmV3IFVpbnQxNkFycmF5KGssRyxLLmxlbmd0aCkuc2V0KEspO2Vsc2UgaWYoRC50eXBlPT09MSluZXcgRmxvYXQzMkFycmF5KGssRyxLLmxlbmd0aCkuc2V0KEspO2Vsc2UgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCB1bmlmb3JtIHR5cGU6ICR7YnQoRC50eXBlKX1gKX0pO2xldCBQPXRoaXMuZ3B1RGF0YU1hbmFnZXIuY3JlYXRlKFMsR1BVQnVmZmVyVXNhZ2UuQ09QWV9EU1R8R1BVQnVmZmVyVXNhZ2UuVU5JRk9STSk7dGhpcy5kZXZpY2UucXVldWUud3JpdGVCdWZmZXIoUC5idWZmZXIsMCxrLDAsUyksdGhpcy5ncHVEYXRhTWFuYWdlci5yZWxlYXNlKFAuaWQpLHk9e29mZnNldDowLHNpemU6UyxidWZmZXI6UC5idWZmZXJ9fWxldCBnPXRoaXMucHJvZ3JhbU1hbmFnZXIubm9ybWFsaXplRGlzcGF0Y2hHcm91cFNpemUocCkseD1nWzFdPT09MSYmZ1syXT09PTEsJD1kZyh0LHIseCksdj10aGlzLnByb2dyYW1NYW5hZ2VyLmdldEFydGlmYWN0KCQpO2lmKHZ8fCh2PXRoaXMucHJvZ3JhbU1hbmFnZXIuYnVpbGQodCxnKSx0aGlzLnByb2dyYW1NYW5hZ2VyLnNldEFydGlmYWN0KCQsdiksdWUoXCJpbmZvXCIsKCk9PmBbYXJ0aWZhY3RdIGtleTogJHskfSwgcHJvZ3JhbU5hbWU6ICR7dC5uYW1lfWApKSxtJiZ2LnVuaWZvcm1WYXJpYWJsZXNJbmZvKXtpZihtLmxlbmd0aCE9PXYudW5pZm9ybVZhcmlhYmxlc0luZm8ubGVuZ3RoKXRocm93IG5ldyBFcnJvcihgVW5pZm9ybSB2YXJpYWJsZXMgY291bnQgbWlzbWF0Y2g6IGV4cGVjdCAke3YudW5pZm9ybVZhcmlhYmxlc0luZm8ubGVuZ3RofSwgZ290ICR7bS5sZW5ndGh9IGluIHByb2dyYW0gXCIke3YucHJvZ3JhbUluZm8ubmFtZX1cIi5gKTtmb3IobGV0IFM9MDtTPG0ubGVuZ3RoO1MrKyl7bGV0IFQ9bVtTXSxBPVQudHlwZSxrPXR5cGVvZiBULmRhdGE9PVwibnVtYmVyXCI/MTpULmRhdGEubGVuZ3RoLFtQLERdPXYudW5pZm9ybVZhcmlhYmxlc0luZm9bU107aWYoQSE9PVB8fGshPT1EKXRocm93IG5ldyBFcnJvcihgVW5pZm9ybSB2YXJpYWJsZSAke1N9IG1pc21hdGNoOiBleHBlY3QgdHlwZSAke1B9IHdpdGggc2l6ZSAke0R9LCBnb3QgdHlwZSAke0F9IHdpdGggc2l6ZSAke2t9IGluIHByb2dyYW0gXCIke3YucHJvZ3JhbUluZm8ubmFtZX1cIi5gKX19aWYodWUoXCJpbmZvXCIsKCk9PmBbUHJvZ3JhbU1hbmFnZXJdIHJ1biBcIiR7dC5uYW1lfVwiIChrZXk9JHskfSkgd2l0aCAke2dbMF19eCR7Z1sxXX14JHtnWzJdfWApLHRoaXMucXVlcnlUeXBlIT09XCJub25lXCJ8fHRoaXMuc2Vzc2lvblN0YXR1cz09PVwiY2FwdHVyaW5nXCIpe2xldCBTPXtrZXJuZWxJZDp0aGlzLmN1cnJlbnRLZXJuZWxJZCxwcm9ncmFtTmFtZTp2LnByb2dyYW1JbmZvLm5hbWUsaW5wdXRUZW5zb3JWaWV3czpyLG91dHB1dFRlbnNvclZpZXdzOmh9O3RoaXMucGVuZGluZ0tlcm5lbHMucHVzaChTKSx0aGlzLnNlc3Npb25TdGF0dXM9PT1cImNhcHR1cmluZ1wiJiZ0aGlzLmNhcHR1cmVkUGVuZGluZ0tlcm5lbHMuZ2V0KHRoaXMuY3VycmVudFNlc3Npb25JZCkucHVzaChTKX1yZXR1cm4gdGhpcy5wcm9ncmFtTWFuYWdlci5ydW4odixkLF8sZyx5KSxEZSh0Lm5hbWUpLGh9dXBsb2FkKHQscil7dGhpcy5ncHVEYXRhTWFuYWdlci51cGxvYWQodCxyKX1tZW1jcHkodCxyKXt0aGlzLmdwdURhdGFNYW5hZ2VyLm1lbWNweSh0LHIpfWFzeW5jIGRvd25sb2FkKHQscil7YXdhaXQgdGhpcy5ncHVEYXRhTWFuYWdlci5kb3dubG9hZCh0LHIpfWFsbG9jKHQpe3JldHVybiB0aGlzLmdwdURhdGFNYW5hZ2VyLmNyZWF0ZSh0KS5pZH1mcmVlKHQpe3JldHVybiB0aGlzLmdwdURhdGFNYW5hZ2VyLnJlbGVhc2UodCl9Y3JlYXRlS2VybmVsKHQscixuLG8pe2xldCBpPVpsLmdldCh0KTtpZighaSl0aHJvdyBuZXcgRXJyb3IoYGtlcm5lbCBub3QgaW1wbGVtZW50ZWQ6ICR7dH1gKTtsZXQgYT17a2VybmVsVHlwZTp0LGtlcm5lbE5hbWU6byxrZXJuZWxFbnRyeTppWzBdLGF0dHJpYnV0ZXM6W2lbMV0sbl19O3RoaXMua2VybmVscy5zZXQocixhKX1yZWxlYXNlS2VybmVsKHQpe2xldCByPXRoaXMua2VybmVsUGVyc2lzdGVudERhdGEuZ2V0KHQpO2lmKHIpe2ZvcihsZXQgbiBvZiByKXRoaXMuZ3B1RGF0YU1hbmFnZXIucmVsZWFzZShuLmlkKTt0aGlzLmtlcm5lbFBlcnNpc3RlbnREYXRhLmRlbGV0ZSh0KX10aGlzLmtlcm5lbEN1c3RvbURhdGEuZGVsZXRlKHQpLHRoaXMua2VybmVscy5kZWxldGUodCl9Y29tcHV0ZUtlcm5lbCh0LHIsbil7bGV0IG89dGhpcy5rZXJuZWxzLmdldCh0KTtpZighbyl0aHJvdyBuZXcgRXJyb3IoYGtlcm5lbCBub3QgY3JlYXRlZDogJHt0fWApO2xldCBpPW8ua2VybmVsVHlwZSxhPW8ua2VybmVsTmFtZSxkPW8ua2VybmVsRW50cnksbD1vLmF0dHJpYnV0ZXM7aWYodGhpcy5jdXJyZW50S2VybmVsSWQhPT1udWxsKXRocm93IG5ldyBFcnJvcihga2VybmVsIFwiWyR7aX1dICR7YX1cIiBpcyBub3QgYWxsb3dlZCB0byBiZSBjYWxsZWQgcmVjdXJzaXZlbHlgKTt0aGlzLmN1cnJlbnRLZXJuZWxJZD10LGxbMF0mJihsWzFdPWxbMF0obFsxXSksbFswXT12b2lkIDApLHVlKFwiaW5mb1wiLCgpPT5gW1dlYkdQVV0gU3RhcnQgdG8gcnVuIGtlcm5lbCBcIlske2l9XSAke2F9XCIuLi5gKTtsZXQgcD10aGlzLmVudi5kZWJ1Zzt0aGlzLnRlbXBvcmFyeURhdGE9W107dHJ5e3JldHVybiBwJiZ0aGlzLmRldmljZS5wdXNoRXJyb3JTY29wZShcInZhbGlkYXRpb25cIiksZChyLGxbMV0pLDB9Y2F0Y2gobSl7cmV0dXJuIG4ucHVzaChQcm9taXNlLnJlc29sdmUoYFtXZWJHUFVdIEtlcm5lbCBcIlske2l9XSAke2F9XCIgZmFpbGVkLiAke219YCkpLDF9ZmluYWxseXtwJiZuLnB1c2godGhpcy5kZXZpY2UucG9wRXJyb3JTY29wZSgpLnRoZW4obT0+bT9gR1BVIHZhbGlkYXRpb24gZXJyb3IgZm9yIGtlcm5lbCBcIlske2l9XSAke2F9XCI6ICR7bS5tZXNzYWdlfWA6bnVsbCkpO2ZvcihsZXQgbSBvZiB0aGlzLnRlbXBvcmFyeURhdGEpdGhpcy5ncHVEYXRhTWFuYWdlci5yZWxlYXNlKG0uaWQpO3RoaXMudGVtcG9yYXJ5RGF0YT1bXSx0aGlzLmN1cnJlbnRLZXJuZWxJZD1udWxsfX1yZWdpc3RlckJ1ZmZlcih0LHIsbixvKXtsZXQgaT10aGlzLnNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nLmdldCh0KTtpfHwoaT1uZXcgTWFwLHRoaXMuc2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmcuc2V0KHQsaSkpO2xldCBhPWkuZ2V0KHIpLGQ9dGhpcy5ncHVEYXRhTWFuYWdlci5yZWdpc3RlckV4dGVybmFsQnVmZmVyKG4sbyxhKTtyZXR1cm4gaS5zZXQocixbZCxuXSksZH11bnJlZ2lzdGVyQnVmZmVycyh0KXtsZXQgcj10aGlzLnNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nLmdldCh0KTtyJiYoci5mb3JFYWNoKG49PnRoaXMuZ3B1RGF0YU1hbmFnZXIudW5yZWdpc3RlckV4dGVybmFsQnVmZmVyKG5bMF0pKSx0aGlzLnNlc3Npb25FeHRlcm5hbERhdGFNYXBwaW5nLmRlbGV0ZSh0KSl9Z2V0QnVmZmVyKHQpe2xldCByPXRoaXMuZ3B1RGF0YU1hbmFnZXIuZ2V0KHQpO2lmKCFyKXRocm93IG5ldyBFcnJvcihgbm8gR1BVIGRhdGEgZm9yIGJ1ZmZlcjogJHt0fWApO3JldHVybiByLmJ1ZmZlcn1jcmVhdGVEb3dubG9hZGVyKHQscixuKXtyZXR1cm4gYXN5bmMoKT0+e2xldCBvPWF3YWl0IG5vKHRoaXMsdCxyKTtyZXR1cm4gVXIoby5idWZmZXIsbil9fXdyaXRlVGltZXN0YW1wKHQpe3RoaXMucXVlcnlUeXBlPT09XCJpbnNpZGUtcGFzc2VzXCImJnRoaXMuY29tcHV0ZVBhc3NFbmNvZGVyLndyaXRlVGltZXN0YW1wKHRoaXMucXVlcnlTZXQsdCl9c2V0UXVlcnlUeXBlKCl7dGhpcy5xdWVyeVR5cGU9XCJub25lXCIsKHRoaXMuZW52LndlYmdwdS5wcm9maWxpbmc/Lm1vZGU9PT1cImRlZmF1bHRcInx8KHR5cGVvZiB0aGlzLmVudi50cmFjZT5cInVcIj90aGlzLmVudi53YXNtLnRyYWNlOnRoaXMuZW52LnRyYWNlKSkmJih0aGlzLmRldmljZS5mZWF0dXJlcy5oYXMoXCJjaHJvbWl1bS1leHBlcmltZW50YWwtdGltZXN0YW1wLXF1ZXJ5LWluc2lkZS1wYXNzZXNcIik/dGhpcy5xdWVyeVR5cGU9XCJpbnNpZGUtcGFzc2VzXCI6dGhpcy5kZXZpY2UuZmVhdHVyZXMuaGFzKFwidGltZXN0YW1wLXF1ZXJ5XCIpJiYodGhpcy5xdWVyeVR5cGU9XCJhdC1wYXNzZXNcIiksdGhpcy5xdWVyeVR5cGUhPT1cIm5vbmVcIiYmdHlwZW9mIHRoaXMucXVlcnlTZXQ+XCJ1XCImJih0aGlzLnF1ZXJ5U2V0PXRoaXMuZGV2aWNlLmNyZWF0ZVF1ZXJ5U2V0KHt0eXBlOlwidGltZXN0YW1wXCIsY291bnQ6dGhpcy5tYXhEaXNwYXRjaE51bWJlcioyfSksdGhpcy5xdWVyeVJlc29sdmVCdWZmZXI9dGhpcy5kZXZpY2UuY3JlYXRlQnVmZmVyKHtzaXplOnRoaXMubWF4RGlzcGF0Y2hOdW1iZXIqMio4LHVzYWdlOkdQVUJ1ZmZlclVzYWdlLkNPUFlfU1JDfEdQVUJ1ZmZlclVzYWdlLlFVRVJZX1JFU09MVkV9KSkpfWNhcHR1cmVCZWdpbigpe3VlKFwiaW5mb1wiLFwiY2FwdHVyZUJlZ2luXCIpLHRoaXMuY2FwdHVyZWRDb21tYW5kTGlzdC5nZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkKXx8dGhpcy5jYXB0dXJlZENvbW1hbmRMaXN0LnNldCh0aGlzLmN1cnJlbnRTZXNzaW9uSWQsW10pLHRoaXMuY2FwdHVyZWRQZW5kaW5nS2VybmVscy5nZXQodGhpcy5jdXJyZW50U2Vzc2lvbklkKXx8dGhpcy5jYXB0dXJlZFBlbmRpbmdLZXJuZWxzLnNldCh0aGlzLmN1cnJlbnRTZXNzaW9uSWQsW10pLHRoaXMuZmx1c2goKSx0aGlzLnNlc3Npb25TdGF0dXM9XCJjYXB0dXJpbmdcIn1jYXB0dXJlRW5kKCl7dWUoXCJpbmZvXCIsXCJjYXB0dXJlRW5kXCIpLHRoaXMuZmx1c2goKSx0aGlzLnNlc3Npb25TdGF0dXM9XCJkZWZhdWx0XCJ9cmVwbGF5KCl7dWUoXCJpbmZvXCIsXCJyZXBsYXlcIiksdGhpcy5zZXNzaW9uU3RhdHVzPVwicmVwbGF5aW5nXCI7bGV0IHQ9dGhpcy5jYXB0dXJlZENvbW1hbmRMaXN0LmdldCh0aGlzLmN1cnJlbnRTZXNzaW9uSWQpLHI9dGhpcy5jYXB0dXJlZFBlbmRpbmdLZXJuZWxzLmdldCh0aGlzLmN1cnJlbnRTZXNzaW9uSWQpLG49dC5sZW5ndGg7dGhpcy5wZW5kaW5nS2VybmVscz1bXTtmb3IobGV0IG89MDtvPG47bysrKXtsZXQgaT10aGlzLmdldENvbXB1dGVQYXNzRW5jb2RlcigpLGE9dFtvXTt0aGlzLndyaXRlVGltZXN0YW1wKHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKjIpLGkuc2V0UGlwZWxpbmUoYS5jb21wdXRlUGlwZWxpbmUpLGkuc2V0QmluZEdyb3VwKDAsYS5iaW5kR3JvdXApLGkuZGlzcGF0Y2hXb3JrZ3JvdXBzKC4uLmEuZGlzcGF0Y2hHcm91cCksdGhpcy53cml0ZVRpbWVzdGFtcCh0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcioyKzEpLHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyKyssdGhpcy5xdWVyeVR5cGUhPT1cIm5vbmVcIiYmdGhpcy5wZW5kaW5nS2VybmVscy5wdXNoKHJbb10pLCh0aGlzLnBlbmRpbmdEaXNwYXRjaE51bWJlcj49dGhpcy5tYXhEaXNwYXRjaE51bWJlcnx8dGhpcy5xdWVyeVR5cGU9PT1cImF0LXBhc3Nlc1wiKSYmdGhpcy5lbmRDb21wdXRlUGFzcygpLHRoaXMucGVuZGluZ0Rpc3BhdGNoTnVtYmVyPj10aGlzLm1heERpc3BhdGNoTnVtYmVyJiZ0aGlzLmZsdXNoKCl9dGhpcy5mbHVzaCgpLHRoaXMuc2Vzc2lvblN0YXR1cz1cImRlZmF1bHRcIn1vbkNyZWF0ZVNlc3Npb24oKXt0aGlzLmdwdURhdGFNYW5hZ2VyLm9uQ3JlYXRlU2Vzc2lvbigpfW9uUmVsZWFzZVNlc3Npb24odCl7dGhpcy51bnJlZ2lzdGVyQnVmZmVycyh0KSx0aGlzLmNhcHR1cmVkQ29tbWFuZExpc3QuaGFzKHQpJiZ0aGlzLmNhcHR1cmVkQ29tbWFuZExpc3QuZGVsZXRlKHQpLHRoaXMuY2FwdHVyZWRQZW5kaW5nS2VybmVscy5oYXModCkmJnRoaXMuY2FwdHVyZWRQZW5kaW5nS2VybmVscy5kZWxldGUodCksdGhpcy5ncHVEYXRhTWFuYWdlci5vblJlbGVhc2VTZXNzaW9uKHQpfW9uUnVuU3RhcnQodCl7dGhpcy5jdXJyZW50U2Vzc2lvbklkPXQsdGhpcy5zZXRRdWVyeVR5cGUoKX19fSk7dmFyIGxnLGVjLGNnLHRjLGFuLHNuLGtvLHJjLG5jPVUoKCk9PntcInVzZSBzdHJpY3RcIjtldCgpO2xnPTEsZWM9KCk9PmxnKyssY2c9bmV3IE1hcChbW1wiZmxvYXQzMlwiLDMyXSxbXCJmbG9hdDE2XCIsMTZdLFtcImludDMyXCIsMzJdLFtcInVpbnQzMlwiLDMyXSxbXCJpbnQ2NFwiLDY0XSxbXCJ1aW50NjRcIiw2NF0sW1wiaW50OFwiLDhdLFtcInVpbnQ4XCIsOF0sW1wiaW50NFwiLDRdLFtcInVpbnQ0XCIsNF1dKSx0Yz0oZSx0KT0+e2xldCByPWNnLmdldChlKTtpZighcil0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBkYXRhIHR5cGUuXCIpO3JldHVybiB0Lmxlbmd0aD4wP01hdGguY2VpbCh0LnJlZHVjZSgobixvKT0+bipvKSpyLzgpOjB9LGFuPWNsYXNze2NvbnN0cnVjdG9yKHQpe3RoaXMuc2Vzc2lvbklkPXQuc2Vzc2lvbklkLHRoaXMubWxDb250ZXh0PXQuY29udGV4dCx0aGlzLm1sVGVuc29yPXQudGVuc29yLHRoaXMuZGF0YVR5cGU9dC5kYXRhVHlwZSx0aGlzLnRlbnNvclNoYXBlPXQuc2hhcGV9Z2V0IHRlbnNvcigpe3JldHVybiB0aGlzLm1sVGVuc29yfWdldCB0eXBlKCl7cmV0dXJuIHRoaXMuZGF0YVR5cGV9Z2V0IHNoYXBlKCl7cmV0dXJuIHRoaXMudGVuc29yU2hhcGV9Z2V0IGJ5dGVMZW5ndGgoKXtyZXR1cm4gdGModGhpcy5kYXRhVHlwZSx0aGlzLnRlbnNvclNoYXBlKX1kZXN0cm95KCl7dWUoXCJ2ZXJib3NlXCIsKCk9PlwiW1dlYk5OXSBUZW5zb3JXcmFwcGVyLmRlc3Ryb3lcIiksdGhpcy5tbFRlbnNvci5kZXN0cm95KCl9d3JpdGUodCl7dGhpcy5tbENvbnRleHQud3JpdGVUZW5zb3IodGhpcy5tbFRlbnNvcix0KX1hc3luYyByZWFkKHQpe3JldHVybiB0P3RoaXMubWxDb250ZXh0LnJlYWRUZW5zb3IodGhpcy5tbFRlbnNvcix0KTp0aGlzLm1sQ29udGV4dC5yZWFkVGVuc29yKHRoaXMubWxUZW5zb3IpfWNhblJldXNlVGVuc29yKHQscixuKXtyZXR1cm4gdGhpcy5tbENvbnRleHQ9PT10JiZ0aGlzLmRhdGFUeXBlPT09ciYmdGhpcy50ZW5zb3JTaGFwZS5sZW5ndGg9PT1uLmxlbmd0aCYmdGhpcy50ZW5zb3JTaGFwZS5ldmVyeSgobyxpKT0+bz09PW5baV0pfX0sc249Y2xhc3N7Y29uc3RydWN0b3IodCxyKXt0aGlzLnRlbnNvck1hbmFnZXI9dDt0aGlzLndyYXBwZXI9cn1nZXQgdGVuc29yV3JhcHBlcigpe3JldHVybiB0aGlzLndyYXBwZXJ9cmVsZWFzZVRlbnNvcigpe3RoaXMudGVuc29yV3JhcHBlciYmKHRoaXMudGVuc29yTWFuYWdlci5yZWxlYXNlVGVuc29yKHRoaXMudGVuc29yV3JhcHBlciksdGhpcy53cmFwcGVyPXZvaWQgMCl9YXN5bmMgZW5zdXJlVGVuc29yKHQscixuLG8pe2lmKHRoaXMud3JhcHBlcil7aWYodGhpcy53cmFwcGVyLmNhblJldXNlVGVuc29yKHQscixuKSlyZXR1cm4gdGhpcy53cmFwcGVyLnRlbnNvcjtpZihvKXtpZih0aGlzLndyYXBwZXIuYnl0ZUxlbmd0aCE9PXRjKHIsbikpdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGNvcHkgZGF0YSB0byB0ZW5zb3Igd2l0aCBkaWZmZXJlbnQgc2l6ZS5cIik7dGhpcy5hY3RpdmVVcGxvYWQ9bmV3IFVpbnQ4QXJyYXkoYXdhaXQgdGhpcy53cmFwcGVyLnJlYWQoKSl9dGhpcy50ZW5zb3JNYW5hZ2VyLnJlbGVhc2VUZW5zb3IodGhpcy53cmFwcGVyKX1sZXQgaT10eXBlb2YgTUxUZW5zb3JVc2FnZT5cInVcIj92b2lkIDA6TUxUZW5zb3JVc2FnZS5SRUFEfE1MVGVuc29yVXNhZ2UuV1JJVEU7cmV0dXJuIHRoaXMud3JhcHBlcj1hd2FpdCB0aGlzLnRlbnNvck1hbmFnZXIuZ2V0Q2FjaGVkVGVuc29yKHIsbixpLCEwLCEwKSxvJiZ0aGlzLmFjdGl2ZVVwbG9hZCYmKHRoaXMud3JhcHBlci53cml0ZSh0aGlzLmFjdGl2ZVVwbG9hZCksdGhpcy5hY3RpdmVVcGxvYWQ9dm9pZCAwKSx0aGlzLndyYXBwZXIudGVuc29yfXVwbG9hZCh0KXtpZih0aGlzLndyYXBwZXIpaWYodC5ieXRlTGVuZ3RoPT09dGhpcy53cmFwcGVyLmJ5dGVMZW5ndGgpe3RoaXMud3JhcHBlci53cml0ZSh0KTtyZXR1cm59ZWxzZSB1ZShcInZlcmJvc2VcIiwoKT0+XCJEYXRhIHNpemUgZG9lcyBub3QgbWF0Y2ggdGVuc29yIHNpemUuIFJlbGVhc2luZyB0ZW5zb3IuXCIpLHRoaXMucmVsZWFzZVRlbnNvcigpO3RoaXMuYWN0aXZlVXBsb2FkP3RoaXMuYWN0aXZlVXBsb2FkLnNldCh0KTp0aGlzLmFjdGl2ZVVwbG9hZD1uZXcgVWludDhBcnJheSh0KX1hc3luYyBkb3dubG9hZCh0KXtpZih0aGlzLmFjdGl2ZVVwbG9hZClpZih0KXt0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXI/bmV3IFVpbnQ4QXJyYXkodCkuc2V0KHRoaXMuYWN0aXZlVXBsb2FkKTpuZXcgVWludDhBcnJheSh0LmJ1ZmZlcix0LmJ5dGVPZmZzZXQsdC5ieXRlTGVuZ3RoKS5zZXQodGhpcy5hY3RpdmVVcGxvYWQpO3JldHVybn1lbHNlIHJldHVybiB0aGlzLmFjdGl2ZVVwbG9hZC5idWZmZXI7aWYoIXRoaXMud3JhcHBlcil0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3IgaGFzIG5vdCBiZWVuIGNyZWF0ZWQuXCIpO3JldHVybiB0P3RoaXMud3JhcHBlci5yZWFkKHQpOnRoaXMud3JhcHBlci5yZWFkKCl9fSxrbz1jbGFzc3tjb25zdHJ1Y3Rvcih0KXt0aGlzLmJhY2tlbmQ9dDt0aGlzLnRlbnNvclRyYWNrZXJzQnlJZD1uZXcgTWFwO3RoaXMuZnJlZVRlbnNvcnM9W107dGhpcy5leHRlcm5hbFRlbnNvcnM9bmV3IFNldH1yZXNlcnZlVGVuc29ySWQoKXtsZXQgdD1lYygpO3JldHVybiB0aGlzLnRlbnNvclRyYWNrZXJzQnlJZC5zZXQodCxuZXcgc24odGhpcykpLHR9cmVsZWFzZVRlbnNvcklkKHQpe2xldCByPXRoaXMudGVuc29yVHJhY2tlcnNCeUlkLmdldCh0KTtyJiYodGhpcy50ZW5zb3JUcmFja2Vyc0J5SWQuZGVsZXRlKHQpLHIudGVuc29yV3JhcHBlciYmdGhpcy5yZWxlYXNlVGVuc29yKHIudGVuc29yV3JhcHBlcikpfWFzeW5jIGVuc3VyZVRlbnNvcih0LHIsbixvKXt1ZShcInZlcmJvc2VcIiwoKT0+YFtXZWJOTl0gVGVuc29yTWFuYWdlci5lbnN1cmVUZW5zb3Ige3RlbnNvcklkOiAke3R9LCBkYXRhVHlwZTogJHtyfSwgc2hhcGU6ICR7bn0sIGNvcHlPbGQ6ICR7b319YCk7bGV0IGk9dGhpcy50ZW5zb3JUcmFja2Vyc0J5SWQuZ2V0KHQpO2lmKCFpKXRocm93IG5ldyBFcnJvcihcIlRlbnNvciBub3QgZm91bmQuXCIpO3JldHVybiBpLmVuc3VyZVRlbnNvcih0aGlzLmJhY2tlbmQuY3VycmVudENvbnRleHQscixuLG8pfXVwbG9hZCh0LHIpe2xldCBuPXRoaXMudGVuc29yVHJhY2tlcnNCeUlkLmdldCh0KTtpZighbil0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3Igbm90IGZvdW5kLlwiKTtuLnVwbG9hZChyKX1hc3luYyBkb3dubG9hZCh0LHIpe3VlKFwidmVyYm9zZVwiLCgpPT5gW1dlYk5OXSBUZW5zb3JNYW5hZ2VyLmRvd25sb2FkIHt0ZW5zb3JJZDogJHt0fSwgZHN0QnVmZmVyOiAke3I/LmJ5dGVMZW5ndGh9fWApO2xldCBuPXRoaXMudGVuc29yVHJhY2tlcnNCeUlkLmdldCh0KTtpZighbil0aHJvdyBuZXcgRXJyb3IoXCJUZW5zb3Igbm90IGZvdW5kLlwiKTtyZXR1cm4gbi5kb3dubG9hZChyKX1yZWxlYXNlVGVuc29yc0ZvclNlc3Npb24odCl7Zm9yKGxldCByIG9mIHRoaXMuZnJlZVRlbnNvcnMpci5zZXNzaW9uSWQ9PT10JiZyLmRlc3Ryb3koKTt0aGlzLmZyZWVUZW5zb3JzPXRoaXMuZnJlZVRlbnNvcnMuZmlsdGVyKHI9PnIuc2Vzc2lvbklkIT09dCl9cmVnaXN0ZXJUZW5zb3IodCxyLG4sbyl7bGV0IGk9ZWMoKSxhPW5ldyBhbih7c2Vzc2lvbklkOnRoaXMuYmFja2VuZC5jdXJyZW50U2Vzc2lvbklkLGNvbnRleHQ6dCx0ZW5zb3I6cixkYXRhVHlwZTpuLHNoYXBlOm99KTtyZXR1cm4gdGhpcy50ZW5zb3JUcmFja2Vyc0J5SWQuc2V0KGksbmV3IHNuKHRoaXMsYSkpLHRoaXMuZXh0ZXJuYWxUZW5zb3JzLmFkZChhKSxpfWFzeW5jIGdldENhY2hlZFRlbnNvcih0LHIsbixvLGkpe2xldCBhPXRoaXMuYmFja2VuZC5jdXJyZW50U2Vzc2lvbklkLGQ9dGhpcy5iYWNrZW5kLmN1cnJlbnRDb250ZXh0O2ZvcihsZXRbcCxtXW9mIHRoaXMuZnJlZVRlbnNvcnMuZW50cmllcygpKWlmKG0uY2FuUmV1c2VUZW5zb3IoZCx0LHIpKXt1ZShcInZlcmJvc2VcIiwoKT0+YFtXZWJOTl0gUmV1c2luZyB0ZW5zb3Ige2RhdGFUeXBlOiAke3R9LCBzaGFwZTogJHtyfX1gKTtsZXQgdT10aGlzLmZyZWVUZW5zb3JzLnNwbGljZShwLDEpWzBdO3JldHVybiB1LnNlc3Npb25JZD1hLHV9dWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViTk5dIE1MQ29udGV4dC5jcmVhdGVUZW5zb3Ige2RhdGFUeXBlOiAke3R9LCBzaGFwZTogJHtyfX1gKTtsZXQgbD1hd2FpdCBkLmNyZWF0ZVRlbnNvcih7ZGF0YVR5cGU6dCxzaGFwZTpyLGRpbWVuc2lvbnM6cix1c2FnZTpuLHdyaXRhYmxlOm8scmVhZGFibGU6aX0pO3JldHVybiBuZXcgYW4oe3Nlc3Npb25JZDphLGNvbnRleHQ6ZCx0ZW5zb3I6bCxkYXRhVHlwZTp0LHNoYXBlOnJ9KX1yZWxlYXNlVGVuc29yKHQpe3RoaXMuZXh0ZXJuYWxUZW5zb3JzLmhhcyh0KSYmdGhpcy5leHRlcm5hbFRlbnNvcnMuZGVsZXRlKHQpLHRoaXMuZnJlZVRlbnNvcnMucHVzaCh0KX19LHJjPSguLi5lKT0+bmV3IGtvKC4uLmUpfSk7dmFyIG9jLHBnLHVuLGljPVUoKCk9PntcInVzZSBzdHJpY3RcIjt0ZSgpO2d0KCk7Sm4oKTtuYygpO2V0KCk7b2M9bmV3IE1hcChbWzEsXCJmbG9hdDMyXCJdLFsxMCxcImZsb2F0MTZcIl0sWzYsXCJpbnQzMlwiXSxbMTIsXCJ1aW50MzJcIl0sWzcsXCJpbnQ2NFwiXSxbMTMsXCJ1aW50NjRcIl0sWzIyLFwiaW50NFwiXSxbMjEsXCJ1aW50NFwiXSxbMyxcImludDhcIl0sWzIsXCJ1aW50OFwiXSxbOSxcInVpbnQ4XCJdXSkscGc9KGUsdCk9PntpZihlPT09dClyZXR1cm4hMDtpZihlPT09dm9pZCAwfHx0PT09dm9pZCAwKXJldHVybiExO2xldCByPU9iamVjdC5rZXlzKGUpLnNvcnQoKSxuPU9iamVjdC5rZXlzKHQpLnNvcnQoKTtyZXR1cm4gci5sZW5ndGg9PT1uLmxlbmd0aCYmci5ldmVyeSgobyxpKT0+bz09PW5baV0mJmVbb109PT10W29dKX0sdW49Y2xhc3N7Y29uc3RydWN0b3IodCl7dGhpcy50ZW5zb3JNYW5hZ2VyPXJjKHRoaXMpO3RoaXMubWxDb250ZXh0QnlTZXNzaW9uSWQ9bmV3IE1hcDt0aGlzLnNlc3Npb25JZHNCeU1MQ29udGV4dD1uZXcgTWFwO3RoaXMubWxDb250ZXh0Q2FjaGU9W107UnIodC5sb2dMZXZlbCwhIXQuZGVidWcpfWdldCBjdXJyZW50U2Vzc2lvbklkKCl7aWYodGhpcy5hY3RpdmVTZXNzaW9uSWQ9PT12b2lkIDApdGhyb3cgbmV3IEVycm9yKFwiTm8gYWN0aXZlIHNlc3Npb25cIik7cmV0dXJuIHRoaXMuYWN0aXZlU2Vzc2lvbklkfW9uUnVuU3RhcnQodCl7dGhpcy5hY3RpdmVTZXNzaW9uSWQ9dH1hc3luYyBjcmVhdGVNTENvbnRleHQodCl7aWYodCBpbnN0YW5jZW9mIEdQVURldmljZSl7bGV0IG49dGhpcy5tbENvbnRleHRDYWNoZS5maW5kSW5kZXgobz0+by5ncHVEZXZpY2U9PT10KTtpZihuIT09LTEpcmV0dXJuIHRoaXMubWxDb250ZXh0Q2FjaGVbbl0ubWxDb250ZXh0O3tsZXQgbz1hd2FpdCBuYXZpZ2F0b3IubWwuY3JlYXRlQ29udGV4dCh0KTtyZXR1cm4gdGhpcy5tbENvbnRleHRDYWNoZS5wdXNoKHtncHVEZXZpY2U6dCxtbENvbnRleHQ6b30pLG99fWVsc2UgaWYodD09PXZvaWQgMCl7bGV0IG49dGhpcy5tbENvbnRleHRDYWNoZS5maW5kSW5kZXgobz0+by5vcHRpb25zPT09dm9pZCAwJiZvLmdwdURldmljZT09PXZvaWQgMCk7aWYobiE9PS0xKXJldHVybiB0aGlzLm1sQ29udGV4dENhY2hlW25dLm1sQ29udGV4dDt7bGV0IG89YXdhaXQgbmF2aWdhdG9yLm1sLmNyZWF0ZUNvbnRleHQoKTtyZXR1cm4gdGhpcy5tbENvbnRleHRDYWNoZS5wdXNoKHttbENvbnRleHQ6b30pLG99fWxldCByPXRoaXMubWxDb250ZXh0Q2FjaGUuZmluZEluZGV4KG49PnBnKG4ub3B0aW9ucyx0KSk7aWYociE9PS0xKXJldHVybiB0aGlzLm1sQ29udGV4dENhY2hlW3JdLm1sQ29udGV4dDt7bGV0IG49YXdhaXQgbmF2aWdhdG9yLm1sLmNyZWF0ZUNvbnRleHQodCk7cmV0dXJuIHRoaXMubWxDb250ZXh0Q2FjaGUucHVzaCh7b3B0aW9uczp0LG1sQ29udGV4dDpufSksbn19Z2V0IGN1cnJlbnRDb250ZXh0KCl7bGV0IHQ9dGhpcy5nZXRNTENvbnRleHQodGhpcy5jdXJyZW50U2Vzc2lvbklkKTtpZighdCl0aHJvdyBuZXcgRXJyb3IoYE5vIE1MQ29udGV4dCBmb3VuZCBmb3Igc2Vzc2lvbiAke3RoaXMuY3VycmVudFNlc3Npb25JZH1gKTtyZXR1cm4gdH1yZWdpc3Rlck1MQ29udGV4dCh0LHIpe3RoaXMubWxDb250ZXh0QnlTZXNzaW9uSWQuc2V0KHQscik7bGV0IG49dGhpcy5zZXNzaW9uSWRzQnlNTENvbnRleHQuZ2V0KHIpO258fChuPW5ldyBTZXQsdGhpcy5zZXNzaW9uSWRzQnlNTENvbnRleHQuc2V0KHIsbikpLG4uYWRkKHQpfW9uUmVsZWFzZVNlc3Npb24odCl7bGV0IHI9dGhpcy5tbENvbnRleHRCeVNlc3Npb25JZC5nZXQodCk7aWYoIXIpcmV0dXJuO3RoaXMudGVuc29yTWFuYWdlci5yZWxlYXNlVGVuc29yc0ZvclNlc3Npb24odCksdGhpcy5tbENvbnRleHRCeVNlc3Npb25JZC5kZWxldGUodCk7bGV0IG49dGhpcy5zZXNzaW9uSWRzQnlNTENvbnRleHQuZ2V0KHIpO2lmKG4uZGVsZXRlKHQpLG4uc2l6ZT09PTApe3RoaXMuc2Vzc2lvbklkc0J5TUxDb250ZXh0LmRlbGV0ZShyKTtsZXQgbz10aGlzLm1sQ29udGV4dENhY2hlLmZpbmRJbmRleChpPT5pLm1sQ29udGV4dD09PXIpO28hPT0tMSYmdGhpcy5tbENvbnRleHRDYWNoZS5zcGxpY2UobywxKX19Z2V0TUxDb250ZXh0KHQpe3JldHVybiB0aGlzLm1sQ29udGV4dEJ5U2Vzc2lvbklkLmdldCh0KX1yZXNlcnZlVGVuc29ySWQoKXtyZXR1cm4gdGhpcy50ZW5zb3JNYW5hZ2VyLnJlc2VydmVUZW5zb3JJZCgpfXJlbGVhc2VUZW5zb3JJZCh0KXt1ZShcInZlcmJvc2VcIiwoKT0+YFtXZWJOTl0gcmVsZWFzZVRlbnNvcklkIHt0ZW5zb3JJZDogJHt0fX1gKSx0aGlzLnRlbnNvck1hbmFnZXIucmVsZWFzZVRlbnNvcklkKHQpfWFzeW5jIGVuc3VyZVRlbnNvcih0LHIsbixvKXtsZXQgaT1vYy5nZXQocik7aWYoIWkpdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBPTk5YIGRhdGEgdHlwZTogJHtyfWApO3JldHVybiB0aGlzLnRlbnNvck1hbmFnZXIuZW5zdXJlVGVuc29yKHQsaSxuLG8pfXVwbG9hZFRlbnNvcih0LHIpe2lmKCFJZSgpLnNob3VsZFRyYW5zZmVyVG9NTFRlbnNvcil0aHJvdyBuZXcgRXJyb3IoXCJUcnlpbmcgdG8gdXBsb2FkIHRvIGEgTUxUZW5zb3Igd2hpbGUgc2hvdWxkVHJhbnNmZXJUb01MVGVuc29yIGlzIGZhbHNlXCIpO3VlKFwidmVyYm9zZVwiLCgpPT5gW1dlYk5OXSB1cGxvYWRUZW5zb3Ige3RlbnNvcklkOiAke3R9LCBkYXRhOiAke3IuYnl0ZUxlbmd0aH19YCksdGhpcy50ZW5zb3JNYW5hZ2VyLnVwbG9hZCh0LHIpfWFzeW5jIGRvd25sb2FkVGVuc29yKHQscil7cmV0dXJuIHRoaXMudGVuc29yTWFuYWdlci5kb3dubG9hZCh0LHIpfWNyZWF0ZU1MVGVuc29yRG93bmxvYWRlcih0LHIpe3JldHVybiBhc3luYygpPT57bGV0IG49YXdhaXQgdGhpcy50ZW5zb3JNYW5hZ2VyLmRvd25sb2FkKHQpO3JldHVybiBVcihuLHIpfX1yZWdpc3Rlck1MVGVuc29yKHQscixuKXtsZXQgbz1vYy5nZXQocik7aWYoIW8pdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBPTk5YIGRhdGEgdHlwZTogJHtyfWApO2xldCBpPXRoaXMudGVuc29yTWFuYWdlci5yZWdpc3RlclRlbnNvcih0aGlzLmN1cnJlbnRDb250ZXh0LHQsbyxuKTtyZXR1cm4gdWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViTk5dIHJlZ2lzdGVyTUxUZW5zb3Ige3RlbnNvcjogJHt0fSwgZGF0YVR5cGU6ICR7b30sIGRpbWVuc2lvbnM6ICR7bn19IC0+IHt0ZW5zb3JJZDogJHtpfX1gKSxpfXJlZ2lzdGVyTUxDb25zdGFudCh0LHIsbixvLGksYSl7aWYoIWEpdGhyb3cgbmV3IEVycm9yKFwiRXh0ZXJuYWwgbW91bnRlZCBmaWxlcyBhcmUgbm90IGF2YWlsYWJsZS5cIik7bGV0IGQ9dDt0LnN0YXJ0c1dpdGgoXCIuL1wiKSYmKGQ9dC5zdWJzdHJpbmcoMikpO2xldCBsPWEuZ2V0KGQpO2lmKCFsKXRocm93IG5ldyBFcnJvcihgRmlsZSB3aXRoIG5hbWUgJHtkfSBub3QgZm91bmQgaW4gcHJlbG9hZGVkIGZpbGVzLmApO2lmKHIrbj5sLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiT3V0IG9mIGJvdW5kczogZGF0YSBvZmZzZXQgYW5kIGxlbmd0aCBleGNlZWQgdGhlIGV4dGVybmFsIGZpbGUgZGF0YSBzaXplLlwiKTtsZXQgcD1sLnNsaWNlKHIscituKS5idWZmZXIsbTtzd2l0Y2goaS5kYXRhVHlwZSl7Y2FzZVwiZmxvYXQzMlwiOm09bmV3IEZsb2F0MzJBcnJheShwKTticmVhaztjYXNlXCJmbG9hdDE2XCI6bT1uZXcgVWludDE2QXJyYXkocCk7YnJlYWs7Y2FzZVwiaW50MzJcIjptPW5ldyBJbnQzMkFycmF5KHApO2JyZWFrO2Nhc2VcInVpbnQzMlwiOm09bmV3IFVpbnQzMkFycmF5KHApO2JyZWFrO2Nhc2VcImludDY0XCI6bT1uZXcgQmlnSW50NjRBcnJheShwKTticmVhaztjYXNlXCJ1aW50NjRcIjptPW5ldyBCaWdVaW50NjRBcnJheShwKTticmVhaztjYXNlXCJpbnQ4XCI6bT1uZXcgSW50OEFycmF5KHApO2JyZWFrO2Nhc2VcImludDRcIjpjYXNlXCJ1aW50NFwiOmNhc2VcInVpbnQ4XCI6bT1uZXcgVWludDhBcnJheShwKTticmVhaztkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2kuZGF0YVR5cGV9IGluIGNyZWF0aW5nIFdlYk5OIENvbnN0YW50IGZyb20gZXh0ZXJuYWwgZGF0YS5gKX1yZXR1cm4gdWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViTk5dIHJlZ2lzdGVyTUxDb25zdGFudCB7ZGF0YVR5cGU6ICR7aS5kYXRhVHlwZX0sIHNoYXBlOiAke2kuc2hhcGV9fX1gKSxvLmNvbnN0YW50KGksbSl9Zmx1c2goKXt9fX0pO3ZhciBhYz17fTtGdChhYyx7aW5pdDooKT0+bWd9KTt2YXIgcnIsRW8sbWcsc2M9VSgoKT0+e1widXNlIHN0cmljdFwiO3RlKCk7SmwoKTtldCgpO29lKCk7aWMoKTtycj1jbGFzcyBle2NvbnN0cnVjdG9yKHQscixuLG8pe3RoaXMubW9kdWxlPXQ7dGhpcy5kYXRhVHlwZT1yO3RoaXMuZGF0YT1uO3RoaXMuZGltcz1vfWdldEZsb2F0MzJBcnJheSgpe2lmKHRoaXMuZGF0YVR5cGUhPT0xKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0YSB0eXBlXCIpO2xldCB0PUMuc2l6ZSh0aGlzLmRpbXMpO3JldHVybiB0PT09MD9uZXcgRmxvYXQzMkFycmF5Om5ldyBGbG9hdDMyQXJyYXkodGhpcy5tb2R1bGUuSEVBUDguYnVmZmVyLHRoaXMuZGF0YSx0KX1nZXRCaWdJbnQ2NEFycmF5KCl7aWYodGhpcy5kYXRhVHlwZSE9PTcpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBkYXRhIHR5cGVcIik7bGV0IHQ9Qy5zaXplKHRoaXMuZGltcyk7cmV0dXJuIHQ9PT0wP25ldyBCaWdJbnQ2NEFycmF5Om5ldyBCaWdJbnQ2NEFycmF5KHRoaXMubW9kdWxlLkhFQVA4LmJ1ZmZlcix0aGlzLmRhdGEsdCl9Z2V0SW50MzJBcnJheSgpe2lmKHRoaXMuZGF0YVR5cGUhPT02KXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0YSB0eXBlXCIpO2xldCB0PUMuc2l6ZSh0aGlzLmRpbXMpO3JldHVybiB0PT09MD9uZXcgSW50MzJBcnJheTpuZXcgSW50MzJBcnJheSh0aGlzLm1vZHVsZS5IRUFQOC5idWZmZXIsdGhpcy5kYXRhLHQpfWdldFVpbnQxNkFycmF5KCl7aWYodGhpcy5kYXRhVHlwZSE9PTEwJiZ0aGlzLmRhdGFUeXBlIT09NCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGEgdHlwZVwiKTtsZXQgdD1DLnNpemUodGhpcy5kaW1zKTtyZXR1cm4gdD09PTA/bmV3IFVpbnQxNkFycmF5Om5ldyBVaW50MTZBcnJheSh0aGlzLm1vZHVsZS5IRUFQOC5idWZmZXIsdGhpcy5kYXRhLHQpfXJlc2hhcGUodCl7aWYoQy5zaXplKHQpIT09Qy5zaXplKHRoaXMuZGltcykpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBuZXcgc2hhcGVcIik7cmV0dXJuIG5ldyBlKHRoaXMubW9kdWxlLHRoaXMuZGF0YVR5cGUsdGhpcy5kYXRhLHQpfX0sRW89Y2xhc3N7Y29uc3RydWN0b3IodCxyLG4pe3RoaXMubW9kdWxlPXQ7dGhpcy5iYWNrZW5kPXI7dGhpcy5jdXN0b21EYXRhT2Zmc2V0PTA7dGhpcy5jdXN0b21EYXRhU2l6ZT0wO3RoaXMuYWRhcHRlckluZm89ci5hZGFwdGVySW5mbyx0aGlzLmRldmljZUluZm89ci5kZXZpY2VJbmZvO2xldCBvPXQuUFRSX1NJWkUsaT1uL3QuUFRSX1NJWkUsYT1vPT09ND9cImkzMlwiOlwiaTY0XCI7dGhpcy5vcEtlcm5lbENvbnRleHQ9TnVtYmVyKHQuZ2V0VmFsdWUobyppKyssYSkpO2xldCBkPU51bWJlcih0LmdldFZhbHVlKG8qaSsrLGEpKTt0aGlzLm91dHB1dENvdW50PU51bWJlcih0LmdldFZhbHVlKG8qaSsrLGEpKSx0aGlzLmN1c3RvbURhdGFPZmZzZXQ9TnVtYmVyKHQuZ2V0VmFsdWUobyppKyssXCIqXCIpKSx0aGlzLmN1c3RvbURhdGFTaXplPU51bWJlcih0LmdldFZhbHVlKG8qaSsrLGEpKTtsZXQgbD1bXTtmb3IobGV0IHA9MDtwPGQ7cCsrKXtsZXQgbT1OdW1iZXIodC5nZXRWYWx1ZShvKmkrKyxhKSksdT1OdW1iZXIodC5nZXRWYWx1ZShvKmkrKyxcIipcIikpLGg9TnVtYmVyKHQuZ2V0VmFsdWUobyppKyssYSkpLF89W107Zm9yKGxldCB5PTA7eTxoO3krKylfLnB1c2goTnVtYmVyKHQuZ2V0VmFsdWUobyppKyssYSkpKTtsLnB1c2gobmV3IHJyKHQsbSx1LF8pKX10aGlzLmlucHV0cz1sfWdldCBrZXJuZWxDdXN0b21EYXRhKCl7cmV0dXJuIHRoaXMuYmFja2VuZC5jdXJyZW50S2VybmVsQ3VzdG9tRGF0YX1nZXQgY3VzdG9tRGF0YUJ1ZmZlcigpe3JldHVybiB0aGlzLm1vZHVsZS5IRUFQVTguc3ViYXJyYXkodGhpcy5jdXN0b21EYXRhT2Zmc2V0LHRoaXMuY3VzdG9tRGF0YU9mZnNldCt0aGlzLmN1c3RvbURhdGFTaXplKX1jb21wdXRlKHQscil7bGV0IG49cj8uaW5wdXRzPy5tYXAoZD0+dHlwZW9mIGQ9PVwibnVtYmVyXCI/dGhpcy5pbnB1dHNbZF06ZCk/P3RoaXMuaW5wdXRzLG89cj8ub3V0cHV0cz8/W10saT0oZCxsLHApPT5uZXcgcnIodGhpcy5tb2R1bGUsbCx0aGlzLm91dHB1dChkLHApLHApLGE9KGQsbCk9PntsZXQgcD1DdChkLGwpO2lmKCFwKXRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGF0YSB0eXBlOiAke2R9YCk7bGV0IG09cD4wP3RoaXMuYmFja2VuZC5ncHVEYXRhTWFuYWdlci5jcmVhdGUocCkuaWQ6MDtyZXR1cm4gbmV3IHJyKHRoaXMubW9kdWxlLGQsbSxsKX07cmV0dXJuIHRoaXMuYmFja2VuZC5ydW4odCxuLG8saSxhLHRoaXMub3V0cHV0Q291bnQpfW91dHB1dCh0LHIpe2xldCBuPXRoaXMubW9kdWxlLnN0YWNrU2F2ZSgpO3RyeXtsZXQgbz10aGlzLm1vZHVsZS5QVFJfU0laRSxpPW89PT00P1wiaTMyXCI6XCJpNjRcIixhPXRoaXMubW9kdWxlLnN0YWNrQWxsb2MoKDErci5sZW5ndGgpKm8pO3RoaXMubW9kdWxlLnNldFZhbHVlKGEsci5sZW5ndGgsaSk7Zm9yKGxldCBkPTA7ZDxyLmxlbmd0aDtkKyspdGhpcy5tb2R1bGUuc2V0VmFsdWUoYStvKihkKzEpLHJbZF0saSk7cmV0dXJuIHRoaXMubW9kdWxlLl9Kc2VwT3V0cHV0KHRoaXMub3BLZXJuZWxDb250ZXh0LHQsYSl9Y2F0Y2gobyl7dGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZ2VuZXJhdGUga2VybmVsJ3Mgb3V0cHV0WyR7dH1dIHdpdGggZGltcyBbJHtyfV0uIElmIHlvdSBhcmUgcnVubmluZyB3aXRoIHByZS1hbGxvY2F0ZWQgb3V0cHV0LCBwbGVhc2UgbWFrZSBzdXJlIHRoZSBvdXRwdXQgdHlwZS9kaW1zIGFyZSBjb3JyZWN0LiBFcnJvcjogJHtvfWApfWZpbmFsbHl7dGhpcy5tb2R1bGUuc3RhY2tSZXN0b3JlKG4pfX19LG1nPWFzeW5jKGUsdCxyLG4pPT57bGV0IG89dC5qc2VwSW5pdDtpZighbyl0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gaW5pdGlhbGl6ZSBKU0VQLiBUaGUgV2ViQXNzZW1ibHkgbW9kdWxlIGlzIG5vdCBidWlsdCB3aXRoIEpTRVAgc3VwcG9ydC5cIik7aWYoZT09PVwid2ViZ3B1XCIpe2xldCBpPW5ldyBvbjthd2FpdCBpLmluaXRpYWxpemUocixuKSxvKFwid2ViZ3B1XCIsW2ksYT0+aS5hbGxvYyhOdW1iZXIoYSkpLGE9PmkuZnJlZShhKSwoYSxkLGwscD0hMSk9PntpZihwKXVlKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0ganNlcENvcHlHcHVUb0dwdTogc3JjPSR7TnVtYmVyKGEpfSwgZHN0PSR7TnVtYmVyKGQpfSwgc2l6ZT0ke051bWJlcihsKX1gKSxpLm1lbWNweShOdW1iZXIoYSksTnVtYmVyKGQpKTtlbHNle3VlKFwidmVyYm9zZVwiLCgpPT5gW1dlYkdQVV0ganNlcENvcHlDcHVUb0dwdTogZGF0YU9mZnNldD0ke051bWJlcihhKX0sIGdwdURhdGFJZD0ke051bWJlcihkKX0sIHNpemU9JHtOdW1iZXIobCl9YCk7bGV0IG09dC5IRUFQVTguc3ViYXJyYXkoTnVtYmVyKGE+Pj4wKSxOdW1iZXIoYT4+PjApK051bWJlcihsKSk7aS51cGxvYWQoTnVtYmVyKGQpLG0pfX0sYXN5bmMoYSxkLGwpPT57dWUoXCJ2ZXJib3NlXCIsKCk9PmBbV2ViR1BVXSBqc2VwQ29weUdwdVRvQ3B1OiBncHVEYXRhSWQ9JHthfSwgZGF0YU9mZnNldD0ke2R9LCBzaXplPSR7bH1gKSxhd2FpdCBpLmRvd25sb2FkKE51bWJlcihhKSwoKT0+dC5IRUFQVTguc3ViYXJyYXkoTnVtYmVyKGQpPj4+MCxOdW1iZXIoZCtsKT4+PjApKX0sKGEsZCxsKT0+aS5jcmVhdGVLZXJuZWwoYSxOdW1iZXIoZCksbCx0LlVURjhUb1N0cmluZyh0Ll9Kc2VwR2V0Tm9kZU5hbWUoTnVtYmVyKGQpKSkpLGE9PmkucmVsZWFzZUtlcm5lbChhKSwoYSxkLGwscCk9Pnt1ZShcInZlcmJvc2VcIiwoKT0+YFtXZWJHUFVdIGpzZXBSdW46IHNlc3Npb25IYW5kbGU9JHtsfSwga2VybmVsPSR7YX0sIGNvbnRleHREYXRhT2Zmc2V0PSR7ZH1gKTtsZXQgbT1uZXcgRW8odCxpLE51bWJlcihkKSk7cmV0dXJuIGkuY29tcHV0ZUtlcm5lbChOdW1iZXIoYSksbSxwKX0sKCk9PmkuY2FwdHVyZUJlZ2luKCksKCk9PmkuY2FwdHVyZUVuZCgpLCgpPT5pLnJlcGxheSgpXSl9ZWxzZXtsZXQgaT1uZXcgdW4ocik7byhcIndlYm5uXCIsW2ksKCk9PmkucmVzZXJ2ZVRlbnNvcklkKCksYT0+aS5yZWxlYXNlVGVuc29ySWQoYSksYXN5bmMoYSxkLGwscCk9PmkuZW5zdXJlVGVuc29yKGEsZCxsLHApLChhLGQpPT57aS51cGxvYWRUZW5zb3IoYSxkKX0sYXN5bmMoYSxkKT0+aS5kb3dubG9hZFRlbnNvcihhLGQpXSl9fX0pO3ZhciBmZyxUcixJcixQdCxoZyxLdCxDcixBcix1YyxrcixFcixQcixxbj1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7SGEoKTtxYSgpO3RlKCk7Z3QoKTtPcigpO1huKCk7Zmc9KGUsdCk9PntJZSgpLl9PcnRJbml0KGUsdCkhPT0wJiZwZShcIkNhbid0IGluaXRpYWxpemUgb25ueHJ1bnRpbWUuXCIpfSxUcj1hc3luYyBlPT57ZmcoZS53YXNtLm51bVRocmVhZHMsWnQoZS5sb2dMZXZlbCkpfSxJcj1hc3luYyhlLHQpPT57e2xldCByPShzYygpLGJyKGFjKSkuaW5pdDtpZih0PT09XCJ3ZWJncHVcIil7aWYodHlwZW9mIG5hdmlnYXRvcj5cInVcInx8IW5hdmlnYXRvci5ncHUpdGhyb3cgbmV3IEVycm9yKFwiV2ViR1BVIGlzIG5vdCBzdXBwb3J0ZWQgaW4gY3VycmVudCBlbnZpcm9ubWVudFwiKTtsZXQgbj1lLndlYmdwdS5hZGFwdGVyO2lmKG4pe2lmKHR5cGVvZiBuLmxpbWl0cyE9XCJvYmplY3RcInx8dHlwZW9mIG4uZmVhdHVyZXMhPVwib2JqZWN0XCJ8fHR5cGVvZiBuLnJlcXVlc3REZXZpY2UhPVwiZnVuY3Rpb25cIil0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIEdQVSBhZGFwdGVyIHNldCBpbiBgZW52LndlYmdwdS5hZGFwdGVyYC4gSXQgbXVzdCBiZSBhIEdQVUFkYXB0ZXIgb2JqZWN0LlwiKX1lbHNle2xldCBvPWUud2ViZ3B1LnBvd2VyUHJlZmVyZW5jZTtpZihvIT09dm9pZCAwJiZvIT09XCJsb3ctcG93ZXJcIiYmbyE9PVwiaGlnaC1wZXJmb3JtYW5jZVwiKXRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwb3dlclByZWZlcmVuY2Ugc2V0dGluZzogXCIke299XCJgKTtsZXQgaT1lLndlYmdwdS5mb3JjZUZhbGxiYWNrQWRhcHRlcjtpZihpIT09dm9pZCAwJiZ0eXBlb2YgaSE9XCJib29sZWFuXCIpdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGZvcmNlRmFsbGJhY2tBZGFwdGVyIHNldHRpbmc6IFwiJHtpfVwiYCk7aWYobj1hd2FpdCBuYXZpZ2F0b3IuZ3B1LnJlcXVlc3RBZGFwdGVyKHtwb3dlclByZWZlcmVuY2U6byxmb3JjZUZhbGxiYWNrQWRhcHRlcjppfSksIW4pdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZ2V0IEdQVSBhZGFwdGVyLiBZb3UgbWF5IG5lZWQgdG8gZW5hYmxlIGZsYWcgXCItLWVuYWJsZS11bnNhZmUtd2ViZ3B1XCIgaWYgeW91IGFyZSB1c2luZyBDaHJvbWUuJyl9YXdhaXQgcihcIndlYmdwdVwiLEllKCksZSxuKX1pZih0PT09XCJ3ZWJublwiKXtpZih0eXBlb2YgbmF2aWdhdG9yPlwidVwifHwhbmF2aWdhdG9yLm1sKXRocm93IG5ldyBFcnJvcihcIldlYk5OIGlzIG5vdCBzdXBwb3J0ZWQgaW4gY3VycmVudCBlbnZpcm9ubWVudFwiKTthd2FpdCByKFwid2Vibm5cIixJZSgpLGUpfX19LFB0PW5ldyBNYXAsaGc9ZT0+e2xldCB0PUllKCkscj10LnN0YWNrU2F2ZSgpO3RyeXtsZXQgbj10LlBUUl9TSVpFLG89dC5zdGFja0FsbG9jKDIqbik7dC5fT3J0R2V0SW5wdXRPdXRwdXRDb3VudChlLG8sbytuKSE9PTAmJnBlKFwiQ2FuJ3QgZ2V0IHNlc3Npb24gaW5wdXQvb3V0cHV0IGNvdW50LlwiKTtsZXQgYT1uPT09ND9cImkzMlwiOlwiaTY0XCI7cmV0dXJuW051bWJlcih0LmdldFZhbHVlKG8sYSkpLE51bWJlcih0LmdldFZhbHVlKG8rbixhKSldfWZpbmFsbHl7dC5zdGFja1Jlc3RvcmUocil9fSxLdD1lPT57bGV0IHQ9SWUoKSxyPXQuX21hbGxvYyhlLmJ5dGVMZW5ndGgpO2lmKHI9PT0wKXRocm93IG5ldyBFcnJvcihgQ2FuJ3QgY3JlYXRlIGEgc2Vzc2lvbi4gZmFpbGVkIHRvIGFsbG9jYXRlIGEgYnVmZmVyIG9mIHNpemUgJHtlLmJ5dGVMZW5ndGh9LmApO3JldHVybiB0LkhFQVBVOC5zZXQoZSxyKSxbcixlLmJ5dGVMZW5ndGhdfSxDcj1hc3luYyhlLHQpPT57bGV0IHIsbixvPUllKCk7QXJyYXkuaXNBcnJheShlKT9bcixuXT1lOmUuYnVmZmVyPT09by5IRUFQVTguYnVmZmVyP1tyLG5dPVtlLmJ5dGVPZmZzZXQsZS5ieXRlTGVuZ3RoXTpbcixuXT1LdChlKTtsZXQgaT0wLGE9MCxkPTAsbD1bXSxwPVtdLG09W107dHJ5e2lmKFthLGxdPUZhKHQpLHQ/LmV4dGVybmFsRGF0YSYmby5tb3VudEV4dGVybmFsRGF0YSl7bGV0IHY9W107Zm9yKGxldCBTIG9mIHQuZXh0ZXJuYWxEYXRhKXtsZXQgVD10eXBlb2YgUz09XCJzdHJpbmdcIj9TOlMucGF0aDt2LnB1c2goUXQodHlwZW9mIFM9PVwic3RyaW5nXCI/UzpTLmRhdGEpLnRoZW4oQT0+e28ubW91bnRFeHRlcm5hbERhdGEoVCxBKX0pKX1hd2FpdCBQcm9taXNlLmFsbCh2KX1mb3IobGV0IHYgb2YgdD8uZXhlY3V0aW9uUHJvdmlkZXJzPz9bXSlpZigodHlwZW9mIHY9PVwic3RyaW5nXCI/djp2Lm5hbWUpPT09XCJ3ZWJublwiKXtpZihvLnNob3VsZFRyYW5zZmVyVG9NTFRlbnNvcj0hMSx0eXBlb2YgdiE9XCJzdHJpbmdcIil7bGV0IFQ9dixBPVQ/LmNvbnRleHQsaz1UPy5ncHVEZXZpY2UsUD1UPy5kZXZpY2VUeXBlLEQ9VD8ucG93ZXJQcmVmZXJlbmNlO0E/by5jdXJyZW50Q29udGV4dD1BOms/by5jdXJyZW50Q29udGV4dD1hd2FpdCBvLmpzZXBDcmVhdGVNTENvbnRleHQoayk6by5jdXJyZW50Q29udGV4dD1hd2FpdCBvLmpzZXBDcmVhdGVNTENvbnRleHQoe2RldmljZVR5cGU6UCxwb3dlclByZWZlcmVuY2U6RH0pfWVsc2Ugby5jdXJyZW50Q29udGV4dD1hd2FpdCBvLmpzZXBDcmVhdGVNTENvbnRleHQoKTticmVha31pPWF3YWl0IG8uX09ydENyZWF0ZVNlc3Npb24ocixuLGEpLGk9PT0wJiZwZShcIkNhbid0IGNyZWF0ZSBhIHNlc3Npb24uXCIpLG8uanNlcE9uQ3JlYXRlU2Vzc2lvbj8uKCksby5jdXJyZW50Q29udGV4dCYmKG8uanNlcFJlZ2lzdGVyTUxDb250ZXh0KGksby5jdXJyZW50Q29udGV4dCksby5jdXJyZW50Q29udGV4dD12b2lkIDAsby5zaG91bGRUcmFuc2ZlclRvTUxUZW5zb3I9ITApO2xldFt1LGhdPWhnKGkpLF89ISF0Py5lbmFibGVHcmFwaENhcHR1cmUseT1bXSxnPVtdLHg9W107Zm9yKGxldCB2PTA7djx1O3YrKyl7bGV0IFM9by5fT3J0R2V0SW5wdXROYW1lKGksdik7Uz09PTAmJnBlKFwiQ2FuJ3QgZ2V0IGFuIGlucHV0IG5hbWUuXCIpLHAucHVzaChTKSx5LnB1c2goby5VVEY4VG9TdHJpbmcoUykpfWZvcihsZXQgdj0wO3Y8aDt2Kyspe2xldCBTPW8uX09ydEdldE91dHB1dE5hbWUoaSx2KTtTPT09MCYmcGUoXCJDYW4ndCBnZXQgYW4gb3V0cHV0IG5hbWUuXCIpLG0ucHVzaChTKTtsZXQgVD1vLlVURjhUb1N0cmluZyhTKTtnLnB1c2goVCk7e2lmKF8mJnQ/LnByZWZlcnJlZE91dHB1dExvY2F0aW9uPT09dm9pZCAwKXt4LnB1c2goXCJncHUtYnVmZmVyXCIpO2NvbnRpbnVlfWxldCBBPXR5cGVvZiB0Py5wcmVmZXJyZWRPdXRwdXRMb2NhdGlvbj09XCJzdHJpbmdcIj90LnByZWZlcnJlZE91dHB1dExvY2F0aW9uOnQ/LnByZWZlcnJlZE91dHB1dExvY2F0aW9uPy5bVF0/P1wiY3B1XCI7aWYoQSE9PVwiY3B1XCImJkEhPT1cImNwdS1waW5uZWRcIiYmQSE9PVwiZ3B1LWJ1ZmZlclwiJiZBIT09XCJtbC10ZW5zb3JcIil0aHJvdyBuZXcgRXJyb3IoYE5vdCBzdXBwb3J0ZWQgcHJlZmVycmVkIG91dHB1dCBsb2NhdGlvbjogJHtBfS5gKTtpZihfJiZBIT09XCJncHUtYnVmZmVyXCIpdGhyb3cgbmV3IEVycm9yKGBOb3Qgc3VwcG9ydGVkIHByZWZlcnJlZCBvdXRwdXQgbG9jYXRpb246ICR7QX0uIE9ubHkgJ2dwdS1idWZmZXInIGxvY2F0aW9uIGlzIHN1cHBvcnRlZCB3aGVuIGVuYWJsZUdyYXBoQ2FwdHVyZSBpcyB0cnVlLmApO3gucHVzaChBKX19bGV0ICQ9bnVsbDtyZXR1cm4geC5zb21lKHY9PnY9PT1cImdwdS1idWZmZXJcInx8dj09PVwibWwtdGVuc29yXCIpJiYoZD1vLl9PcnRDcmVhdGVCaW5kaW5nKGkpLGQ9PT0wJiZwZShcIkNhbid0IGNyZWF0ZSBJTyBiaW5kaW5nLlwiKSwkPXtoYW5kbGU6ZCxvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnM6eCxvdXRwdXRQcmVmZXJyZWRMb2NhdGlvbnNFbmNvZGVkOngubWFwKHY9PlFuKHYpKX0pLFB0LnNldChpLFtpLHAsbSwkLF8sITFdKSxbaSx5LGddfWNhdGNoKHUpe3Rocm93IHAuZm9yRWFjaChoPT5vLl9PcnRGcmVlKGgpKSxtLmZvckVhY2goaD0+by5fT3J0RnJlZShoKSksZCE9PTAmJm8uX09ydFJlbGVhc2VCaW5kaW5nKGQpIT09MCYmcGUoXCJDYW4ndCByZWxlYXNlIElPIGJpbmRpbmcuXCIpLGkhPT0wJiZvLl9PcnRSZWxlYXNlU2Vzc2lvbihpKSE9PTAmJnBlKFwiQ2FuJ3QgcmVsZWFzZSBzZXNzaW9uLlwiKSx1fWZpbmFsbHl7by5fZnJlZShyKSxhIT09MCYmby5fT3J0UmVsZWFzZVNlc3Npb25PcHRpb25zKGEpIT09MCYmcGUoXCJDYW4ndCByZWxlYXNlIHNlc3Npb24gb3B0aW9ucy5cIiksbC5mb3JFYWNoKHU9Pm8uX2ZyZWUodSkpLG8udW5tb3VudEV4dGVybmFsRGF0YT8uKCl9fSxBcj1lPT57bGV0IHQ9SWUoKSxyPVB0LmdldChlKTtpZighcil0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCByZWxlYXNlIHNlc3Npb24uIGludmFsaWQgc2Vzc2lvbiBpZDogJHtlfWApO2xldFtuLG8saSxhLGRdPXI7YSYmKGQmJnQuX09ydENsZWFyQm91bmRPdXRwdXRzKGEuaGFuZGxlKSE9PTAmJnBlKFwiQ2FuJ3QgY2xlYXIgYm91bmQgb3V0cHV0cy5cIiksdC5fT3J0UmVsZWFzZUJpbmRpbmcoYS5oYW5kbGUpIT09MCYmcGUoXCJDYW4ndCByZWxlYXNlIElPIGJpbmRpbmcuXCIpKSx0LmpzZXBPblJlbGVhc2VTZXNzaW9uPy4oZSksby5mb3JFYWNoKGw9PnQuX09ydEZyZWUobCkpLGkuZm9yRWFjaChsPT50Ll9PcnRGcmVlKGwpKSx0Ll9PcnRSZWxlYXNlU2Vzc2lvbihuKSE9PTAmJnBlKFwiQ2FuJ3QgcmVsZWFzZSBzZXNzaW9uLlwiKSxQdC5kZWxldGUoZSl9LHVjPShlLHQscixuLG8saT0hMSk9PntpZighZSl7dC5wdXNoKDApO3JldHVybn1sZXQgYT1JZSgpLGQ9YS5QVFJfU0laRSxsPWVbMF0scD1lWzFdLG09ZVszXSx1LGg7aWYobD09PVwic3RyaW5nXCImJihtPT09XCJncHUtYnVmZmVyXCJ8fG09PT1cIm1sLXRlbnNvclwiKSl0aHJvdyBuZXcgRXJyb3IoXCJTdHJpbmcgdGVuc29yIGlzIG5vdCBzdXBwb3J0ZWQgb24gR1BVLlwiKTtpZihpJiZtIT09XCJncHUtYnVmZmVyXCIpdGhyb3cgbmV3IEVycm9yKGBFeHRlcm5hbCBidWZmZXIgbXVzdCBiZSBwcm92aWRlZCBmb3IgaW5wdXQvb3V0cHV0IGluZGV4ICR7b30gd2hlbiBlbmFibGVHcmFwaENhcHR1cmUgaXMgdHJ1ZS5gKTtpZihtPT09XCJncHUtYnVmZmVyXCIpe2xldCBnPWVbMl0uZ3B1QnVmZmVyO2g9Q3QoWXQobCkscCk7bGV0IHg9YS5qc2VwUmVnaXN0ZXJCdWZmZXI7aWYoIXgpdGhyb3cgbmV3IEVycm9yKCdUZW5zb3IgbG9jYXRpb24gXCJncHUtYnVmZmVyXCIgaXMgbm90IHN1cHBvcnRlZCB3aXRob3V0IHVzaW5nIFdlYkdQVS4nKTt1PXgobixvLGcsaCl9ZWxzZSBpZihtPT09XCJtbC10ZW5zb3JcIil7bGV0IGc9ZVsyXS5tbFRlbnNvcjtoPUN0KFl0KGwpLHApO2xldCB4PWEuanNlcFJlZ2lzdGVyTUxUZW5zb3I7aWYoIXgpdGhyb3cgbmV3IEVycm9yKCdUZW5zb3IgbG9jYXRpb24gXCJtbC10ZW5zb3JcIiBpcyBub3Qgc3VwcG9ydGVkIHdpdGhvdXQgdXNpbmcgV2ViTk4uJyk7dT14KGcsWXQobCkscCl9ZWxzZXtsZXQgZz1lWzJdO2lmKEFycmF5LmlzQXJyYXkoZykpe2g9ZCpnLmxlbmd0aCx1PWEuX21hbGxvYyhoKSxyLnB1c2godSk7Zm9yKGxldCB4PTA7eDxnLmxlbmd0aDt4Kyspe2lmKHR5cGVvZiBnW3hdIT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoYHRlbnNvciBkYXRhIGF0IGluZGV4ICR7eH0gaXMgbm90IGEgc3RyaW5nYCk7YS5zZXRWYWx1ZSh1K3gqZCxrZShnW3hdLHIpLFwiKlwiKX19ZWxzZSBoPWcuYnl0ZUxlbmd0aCx1PWEuX21hbGxvYyhoKSxyLnB1c2godSksYS5IRUFQVTguc2V0KG5ldyBVaW50OEFycmF5KGcuYnVmZmVyLGcuYnl0ZU9mZnNldCxoKSx1KX1sZXQgXz1hLnN0YWNrU2F2ZSgpLHk9YS5zdGFja0FsbG9jKDQqcC5sZW5ndGgpO3RyeXtwLmZvckVhY2goKHgsJCk9PmEuc2V0VmFsdWUoeSskKmQseCxkPT09ND9cImkzMlwiOlwiaTY0XCIpKTtsZXQgZz1hLl9PcnRDcmVhdGVUZW5zb3IoWXQobCksdSxoLHkscC5sZW5ndGgsUW4obSkpO2c9PT0wJiZwZShgQ2FuJ3QgY3JlYXRlIHRlbnNvciBmb3IgaW5wdXQvb3V0cHV0LiBzZXNzaW9uPSR7bn0sIGluZGV4PSR7b30uYCksdC5wdXNoKGcpfWZpbmFsbHl7YS5zdGFja1Jlc3RvcmUoXyl9fSxrcj1hc3luYyhlLHQscixuLG8saSk9PntsZXQgYT1JZSgpLGQ9YS5QVFJfU0laRSxsPVB0LmdldChlKTtpZighbCl0aHJvdyBuZXcgRXJyb3IoYGNhbm5vdCBydW4gaW5mZXJlbmNlLiBpbnZhbGlkIHNlc3Npb24gaWQ6ICR7ZX1gKTtsZXQgcD1sWzBdLG09bFsxXSx1PWxbMl0saD1sWzNdLF89bFs0XSx5PWxbNV0sZz10Lmxlbmd0aCx4PW4ubGVuZ3RoLCQ9MCx2PVtdLFM9W10sVD1bXSxBPVtdLGs9YS5zdGFja1NhdmUoKSxQPWEuc3RhY2tBbGxvYyhnKmQpLEQ9YS5zdGFja0FsbG9jKGcqZCksUj1hLnN0YWNrQWxsb2MoeCpkKSxHPWEuc3RhY2tBbGxvYyh4KmQpO3RyeXthLmpzZXBPblJ1blN0YXJ0Py4ocCksWyQsdl09R2EoaSk7Zm9yKGxldCBWPTA7VjxnO1YrKyl1YyhyW1ZdLFMsQSxlLHRbVl0sXyk7Zm9yKGxldCBWPTA7Vjx4O1YrKyl1YyhvW1ZdLFQsQSxlLGcrbltWXSxfKTtmb3IobGV0IFY9MDtWPGc7VisrKWEuc2V0VmFsdWUoUCtWKmQsU1tWXSxcIipcIiksYS5zZXRWYWx1ZShEK1YqZCxtW3RbVl1dLFwiKlwiKTtmb3IobGV0IFY9MDtWPHg7VisrKWEuc2V0VmFsdWUoUitWKmQsVFtWXSxcIipcIiksYS5zZXRWYWx1ZShHK1YqZCx1W25bVl1dLFwiKlwiKTtpZihoJiYheSl7bGV0e2hhbmRsZTpWLG91dHB1dFByZWZlcnJlZExvY2F0aW9uczpRLG91dHB1dFByZWZlcnJlZExvY2F0aW9uc0VuY29kZWQ6c2V9PWg7aWYobS5sZW5ndGghPT1nKXRocm93IG5ldyBFcnJvcihgaW5wdXQgY291bnQgZnJvbSBmZWVkcyAoJHtnfSkgaXMgZXhwZWN0ZWQgdG8gYmUgYWx3YXlzIGVxdWFsIHRvIG1vZGVsJ3MgaW5wdXQgY291bnQgKCR7bS5sZW5ndGh9KS5gKTtmb3IobGV0IFk9MDtZPGc7WSsrKXtsZXQgZWU9dFtZXTthd2FpdCBhLl9PcnRCaW5kSW5wdXQoVixtW2VlXSxTW1ldKSE9PTAmJnBlKGBDYW4ndCBiaW5kIGlucHV0WyR7WX1dIGZvciBzZXNzaW9uPSR7ZX0uYCl9Zm9yKGxldCBZPTA7WTx4O1krKyl7bGV0IGVlPW5bWV07b1tZXT8uWzNdP2EuX09ydEJpbmRPdXRwdXQoVix1W2VlXSxUW1ldLDApIT09MCYmcGUoYENhbid0IGJpbmQgcHJlLWFsbG9jYXRlZCBvdXRwdXRbJHtZfV0gZm9yIHNlc3Npb249JHtlfS5gKTphLl9PcnRCaW5kT3V0cHV0KFYsdVtlZV0sMCxzZVtlZV0pIT09MCYmcGUoYENhbid0IGJpbmQgb3V0cHV0WyR7WX1dIHRvICR7UVtZXX0gZm9yIHNlc3Npb249JHtlfS5gKX1QdC5zZXQoZSxbcCxtLHUsaCxfLCEwXSl9bGV0IEs7aD9LPWF3YWl0IGEuX09ydFJ1bldpdGhCaW5kaW5nKHAsaC5oYW5kbGUseCxSLCQpOks9YXdhaXQgYS5fT3J0UnVuKHAsRCxQLGcsRyx4LFIsJCksSyE9PTAmJnBlKFwiZmFpbGVkIHRvIGNhbGwgT3J0UnVuKCkuXCIpO2xldCBqPVtdO2ZvcihsZXQgVj0wO1Y8eDtWKyspe2xldCBRPU51bWJlcihhLmdldFZhbHVlKFIrVipkLFwiKlwiKSk7aWYoUT09PVRbVl0pe2oucHVzaChvW1ZdKTtjb250aW51ZX1sZXQgc2U9YS5zdGFja1NhdmUoKSxZPWEuc3RhY2tBbGxvYyg0KmQpLGVlPSExLEosbmU9MDt0cnl7YS5fT3J0R2V0VGVuc29yRGF0YShRLFksWStkLFkrMipkLFkrMypkKSE9PTAmJnBlKGBDYW4ndCBhY2Nlc3Mgb3V0cHV0IHRlbnNvciBkYXRhIG9uIGluZGV4ICR7Vn0uYCk7bGV0IE9lPWQ9PT00P1wiaTMyXCI6XCJpNjRcIiwkZT1OdW1iZXIoYS5nZXRWYWx1ZShZLE9lKSk7bmU9YS5nZXRWYWx1ZShZK2QsXCIqXCIpO2xldCBsZT1hLmdldFZhbHVlKFkrZCoyLFwiKlwiKSxXPU51bWJlcihhLmdldFZhbHVlKFkrZCozLE9lKSkscT1bXTtmb3IobGV0IHdlPTA7d2U8Vzt3ZSsrKXEucHVzaChOdW1iZXIoYS5nZXRWYWx1ZShsZSt3ZSpkLE9lKSkpO2EuX09ydEZyZWUobGUpIT09MCYmcGUoXCJDYW4ndCBmcmVlIG1lbW9yeSBmb3IgdGVuc29yIGRpbXMuXCIpO2xldCBoZT1xLnJlZHVjZSgod2UseWUpPT53ZSp5ZSwxKTtKPWJ0KCRlKTtsZXQgR2U9aD8ub3V0cHV0UHJlZmVycmVkTG9jYXRpb25zW25bVl1dO2lmKEo9PT1cInN0cmluZ1wiKXtpZihHZT09PVwiZ3B1LWJ1ZmZlclwifHxHZT09PVwibWwtdGVuc29yXCIpdGhyb3cgbmV3IEVycm9yKFwiU3RyaW5nIHRlbnNvciBpcyBub3Qgc3VwcG9ydGVkIG9uIEdQVS5cIik7bGV0IHdlPVtdO2ZvcihsZXQgeWU9MDt5ZTxoZTt5ZSsrKXtsZXQgWWU9YS5nZXRWYWx1ZShuZSt5ZSpkLFwiKlwiKSxMdD1hLmdldFZhbHVlKG5lKyh5ZSsxKSpkLFwiKlwiKSxmbj15ZT09PWhlLTE/dm9pZCAwOkx0LVllO3dlLnB1c2goYS5VVEY4VG9TdHJpbmcoWWUsZm4pKX1qLnB1c2goW0oscSx3ZSxcImNwdVwiXSl9ZWxzZSBpZihHZT09PVwiZ3B1LWJ1ZmZlclwiJiZoZT4wKXtsZXQgd2U9YS5qc2VwR2V0QnVmZmVyO2lmKCF3ZSl0aHJvdyBuZXcgRXJyb3IoJ3ByZWZlcnJlZExvY2F0aW9uIFwiZ3B1LWJ1ZmZlclwiIGlzIG5vdCBzdXBwb3J0ZWQgd2l0aG91dCB1c2luZyBXZWJHUFUuJyk7bGV0IHllPXdlKG5lKSxZZT1DdCgkZSxoZSk7aWYoWWU9PT12b2lkIDB8fCFCcihKKSl0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtKfWApO2VlPSEwLGoucHVzaChbSixxLHtncHVCdWZmZXI6eWUsZG93bmxvYWQ6YS5qc2VwQ3JlYXRlRG93bmxvYWRlcih5ZSxZZSxKKSxkaXNwb3NlOigpPT57YS5fT3J0UmVsZWFzZVRlbnNvcihRKSE9PTAmJnBlKFwiQ2FuJ3QgcmVsZWFzZSB0ZW5zb3IuXCIpfX0sXCJncHUtYnVmZmVyXCJdKX1lbHNlIGlmKEdlPT09XCJtbC10ZW5zb3JcIiYmaGU+MCl7bGV0IHdlPWEuanNlcEVuc3VyZVRlbnNvcjtpZighd2UpdGhyb3cgbmV3IEVycm9yKCdwcmVmZXJyZWRMb2NhdGlvbiBcIm1sLXRlbnNvclwiIGlzIG5vdCBzdXBwb3J0ZWQgd2l0aG91dCB1c2luZyBXZWJOTi4nKTtpZihDdCgkZSxoZSk9PT12b2lkIDB8fCFNcihKKSl0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGRhdGEgdHlwZTogJHtKfWApO2xldCBZZT1hd2FpdCB3ZShuZSwkZSxxLCExKTtlZT0hMCxqLnB1c2goW0oscSx7bWxUZW5zb3I6WWUsZG93bmxvYWQ6YS5qc2VwQ3JlYXRlTUxUZW5zb3JEb3dubG9hZGVyKG5lLEopLGRpc3Bvc2U6KCk9PnthLmpzZXBSZWxlYXNlVGVuc29ySWQobmUpLGEuX09ydFJlbGVhc2VUZW5zb3IoUSl9fSxcIm1sLXRlbnNvclwiXSl9ZWxzZXtsZXQgd2U9RHIoSikseWU9bmV3IHdlKGhlKTtuZXcgVWludDhBcnJheSh5ZS5idWZmZXIseWUuYnl0ZU9mZnNldCx5ZS5ieXRlTGVuZ3RoKS5zZXQoYS5IRUFQVTguc3ViYXJyYXkobmUsbmUreWUuYnl0ZUxlbmd0aCkpLGoucHVzaChbSixxLHllLFwiY3B1XCJdKX19ZmluYWxseXthLnN0YWNrUmVzdG9yZShzZSksSj09PVwic3RyaW5nXCImJm5lJiZhLl9mcmVlKG5lKSxlZXx8YS5fT3J0UmVsZWFzZVRlbnNvcihRKX19cmV0dXJuIGgmJiFfJiYoYS5fT3J0Q2xlYXJCb3VuZE91dHB1dHMoaC5oYW5kbGUpIT09MCYmcGUoXCJDYW4ndCBjbGVhciBib3VuZCBvdXRwdXRzLlwiKSxQdC5zZXQoZSxbcCxtLHUsaCxfLCExXSkpLGp9ZmluYWxseXthLnN0YWNrUmVzdG9yZShrKSxTLmZvckVhY2goSz0+YS5fT3J0UmVsZWFzZVRlbnNvcihLKSksVC5mb3JFYWNoKEs9PmEuX09ydFJlbGVhc2VUZW5zb3IoSykpLEEuZm9yRWFjaChLPT5hLl9mcmVlKEspKSwkIT09MCYmYS5fT3J0UmVsZWFzZVJ1bk9wdGlvbnMoJCksdi5mb3JFYWNoKEs9PmEuX2ZyZWUoSykpfX0sRXI9ZT0+e2xldCB0PUllKCkscj1QdC5nZXQoZSk7aWYoIXIpdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzZXNzaW9uIGlkXCIpO2xldCBuPXJbMF0sbz10Ll9PcnRFbmRQcm9maWxpbmcobik7bz09PTAmJnBlKFwiQ2FuJ3QgZ2V0IGFuIHByb2ZpbGUgZmlsZSBuYW1lLlwiKSx0Ll9PcnRGcmVlKG8pfSxQcj1lPT57bGV0IHQ9W107Zm9yKGxldCByIG9mIGUpe2xldCBuPXJbMl07IUFycmF5LmlzQXJyYXkobikmJlwiYnVmZmVyXCJpbiBuJiZ0LnB1c2gobi5idWZmZXIpfXJldHVybiB0fX0pO3ZhciB6dCxMZSxucixsbixjbixkbixQbyx6byxWdCxXdCxiZyxkYyxsYyxjYyxwYyxtYyxmYyxoYyxPbz1VKCgpPT57XCJ1c2Ugc3RyaWN0XCI7V2UoKTtxbigpO2d0KCk7eHIoKTt6dD0oKT0+ISF2ZS53YXNtLnByb3h5JiZ0eXBlb2YgZG9jdW1lbnQ8XCJ1XCIsbnI9ITEsbG49ITEsY249ITEsem89bmV3IE1hcCxWdD0oZSx0KT0+e2xldCByPXpvLmdldChlKTtyP3IucHVzaCh0KTp6by5zZXQoZSxbdF0pfSxXdD0oKT0+e2lmKG5yfHwhbG58fGNufHwhTGUpdGhyb3cgbmV3IEVycm9yKFwid29ya2VyIG5vdCByZWFkeVwiKX0sYmc9ZT0+e3N3aXRjaChlLmRhdGEudHlwZSl7Y2FzZVwiaW5pdC13YXNtXCI6bnI9ITEsZS5kYXRhLmVycj8oY249ITAsUG9bMV0oZS5kYXRhLmVycikpOihsbj0hMCxQb1swXSgpKSxkbiYmKFVSTC5yZXZva2VPYmplY3RVUkwoZG4pLGRuPXZvaWQgMCk7YnJlYWs7Y2FzZVwiaW5pdC1lcFwiOmNhc2VcImNvcHktZnJvbVwiOmNhc2VcImNyZWF0ZVwiOmNhc2VcInJlbGVhc2VcIjpjYXNlXCJydW5cIjpjYXNlXCJlbmQtcHJvZmlsaW5nXCI6e2xldCB0PXpvLmdldChlLmRhdGEudHlwZSk7ZS5kYXRhLmVycj90LnNoaWZ0KClbMV0oZS5kYXRhLmVycik6dC5zaGlmdCgpWzBdKGUuZGF0YS5vdXQpO2JyZWFrfWRlZmF1bHQ6fX0sZGM9YXN5bmMoKT0+e2lmKCFsbil7aWYobnIpdGhyb3cgbmV3IEVycm9yKFwibXVsdGlwbGUgY2FsbHMgdG8gJ2luaXRXYXNtKCknIGRldGVjdGVkLlwiKTtpZihjbil0aHJvdyBuZXcgRXJyb3IoXCJwcmV2aW91cyBjYWxsIHRvICdpbml0V2FzbSgpJyBmYWlsZWQuXCIpO2lmKG5yPSEwLHp0KCkpcmV0dXJuIG5ldyBQcm9taXNlKChlLHQpPT57TGU/LnRlcm1pbmF0ZSgpLFZhKCkudGhlbigoW3Isbl0pPT57dHJ5e0xlPW4sTGUub25lcnJvcj1pPT50KGkpLExlLm9ubWVzc2FnZT1iZyxQbz1bZSx0XTtsZXQgbz17dHlwZTpcImluaXQtd2FzbVwiLGluOnZlfTshby5pbi53YXNtLndhc21QYXRocyYmKHJ8fGltcG9ydC5tZXRhLnVybD8uc3RhcnRzV2l0aChcImZpbGU6XCIpKSYmKG8uaW4ud2FzbS53YXNtUGF0aHM9e3dhc206bmV3IFVSTChcIm9ydC13YXNtLXNpbWQtdGhyZWFkZWQuanNlcC53YXNtXCIsaW1wb3J0Lm1ldGEudXJsKS5ocmVmfSksTGUucG9zdE1lc3NhZ2UobyksZG49cn1jYXRjaChvKXt0KG8pfX0sdCl9KTt0cnl7YXdhaXQgU3IodmUud2FzbSksYXdhaXQgVHIodmUpLGxuPSEwfWNhdGNoKGUpe3Rocm93IGNuPSEwLGV9ZmluYWxseXtucj0hMX19fSxsYz1hc3luYyBlPT57aWYoenQoKSlyZXR1cm4gV3QoKSxuZXcgUHJvbWlzZSgodCxyKT0+e1Z0KFwiaW5pdC1lcFwiLFt0LHJdKTtsZXQgbj17dHlwZTpcImluaXQtZXBcIixpbjp7ZXBOYW1lOmUsZW52OnZlfX07TGUucG9zdE1lc3NhZ2Uobil9KTthd2FpdCBJcih2ZSxlKX0sY2M9YXN5bmMgZT0+enQoKT8oV3QoKSxuZXcgUHJvbWlzZSgodCxyKT0+e1Z0KFwiY29weS1mcm9tXCIsW3Qscl0pO2xldCBuPXt0eXBlOlwiY29weS1mcm9tXCIsaW46e2J1ZmZlcjplfX07TGUucG9zdE1lc3NhZ2UobixbZS5idWZmZXJdKX0pKTpLdChlKSxwYz1hc3luYyhlLHQpPT57aWYoenQoKSl7aWYodD8ucHJlZmVycmVkT3V0cHV0TG9jYXRpb24pdGhyb3cgbmV3IEVycm9yKCdzZXNzaW9uIG9wdGlvbiBcInByZWZlcnJlZE91dHB1dExvY2F0aW9uXCIgaXMgbm90IHN1cHBvcnRlZCBmb3IgcHJveHkuJyk7cmV0dXJuIFd0KCksbmV3IFByb21pc2UoKHIsbik9PntWdChcImNyZWF0ZVwiLFtyLG5dKTtsZXQgbz17dHlwZTpcImNyZWF0ZVwiLGluOnttb2RlbDplLG9wdGlvbnM6ey4uLnR9fX0saT1bXTtlIGluc3RhbmNlb2YgVWludDhBcnJheSYmaS5wdXNoKGUuYnVmZmVyKSxMZS5wb3N0TWVzc2FnZShvLGkpfSl9ZWxzZSByZXR1cm4gQ3IoZSx0KX0sbWM9YXN5bmMgZT0+e2lmKHp0KCkpcmV0dXJuIFd0KCksbmV3IFByb21pc2UoKHQscik9PntWdChcInJlbGVhc2VcIixbdCxyXSk7bGV0IG49e3R5cGU6XCJyZWxlYXNlXCIsaW46ZX07TGUucG9zdE1lc3NhZ2Uobil9KTtBcihlKX0sZmM9YXN5bmMoZSx0LHIsbixvLGkpPT57aWYoenQoKSl7aWYoci5zb21lKGE9PmFbM10hPT1cImNwdVwiKSl0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCB0ZW5zb3Igb24gR1BVIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHByb3h5LlwiKTtpZihvLnNvbWUoYT0+YSkpdGhyb3cgbmV3IEVycm9yKFwicHJlLWFsbG9jYXRlZCBvdXRwdXQgdGVuc29yIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHByb3h5LlwiKTtyZXR1cm4gV3QoKSxuZXcgUHJvbWlzZSgoYSxkKT0+e1Z0KFwicnVuXCIsW2EsZF0pO2xldCBsPXIscD17dHlwZTpcInJ1blwiLGluOntzZXNzaW9uSWQ6ZSxpbnB1dEluZGljZXM6dCxpbnB1dHM6bCxvdXRwdXRJbmRpY2VzOm4sb3B0aW9uczppfX07TGUucG9zdE1lc3NhZ2UocCxQcihsKSl9KX1lbHNlIHJldHVybiBrcihlLHQscixuLG8saSl9LGhjPWFzeW5jIGU9PntpZih6dCgpKXJldHVybiBXdCgpLG5ldyBQcm9taXNlKCh0LHIpPT57VnQoXCJlbmQtcHJvZmlsaW5nXCIsW3Qscl0pO2xldCBuPXt0eXBlOlwiZW5kLXByb2ZpbGluZ1wiLGluOmV9O0xlLnBvc3RNZXNzYWdlKG4pfSk7RXIoZSl9fSk7dmFyIGdjLHlnLHBuLGJjPVUoKCk9PntcInVzZSBzdHJpY3RcIjtXZSgpO09vKCk7dGUoKTskcigpO1huKCk7Z2M9KGUsdCk9Pntzd2l0Y2goZS5sb2NhdGlvbil7Y2FzZVwiY3B1XCI6cmV0dXJuW2UudHlwZSxlLmRpbXMsZS5kYXRhLFwiY3B1XCJdO2Nhc2VcImdwdS1idWZmZXJcIjpyZXR1cm5bZS50eXBlLGUuZGltcyx7Z3B1QnVmZmVyOmUuZ3B1QnVmZmVyfSxcImdwdS1idWZmZXJcIl07Y2FzZVwibWwtdGVuc29yXCI6cmV0dXJuW2UudHlwZSxlLmRpbXMse21sVGVuc29yOmUubWxUZW5zb3J9LFwibWwtdGVuc29yXCJdO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGRhdGEgbG9jYXRpb246ICR7ZS5sb2NhdGlvbn0gZm9yICR7dCgpfWApfX0seWc9ZT0+e3N3aXRjaChlWzNdKXtjYXNlXCJjcHVcIjpyZXR1cm4gbmV3IEhlKGVbMF0sZVsyXSxlWzFdKTtjYXNlXCJncHUtYnVmZmVyXCI6e2xldCB0PWVbMF07aWYoIUJyKHQpKXRocm93IG5ldyBFcnJvcihgbm90IHN1cHBvcnRlZCBkYXRhIHR5cGU6ICR7dH0gZm9yIGRlc2VyaWFsaXppbmcgR1BVIHRlbnNvcmApO2xldHtncHVCdWZmZXI6cixkb3dubG9hZDpuLGRpc3Bvc2U6b309ZVsyXTtyZXR1cm4gSGUuZnJvbUdwdUJ1ZmZlcihyLHtkYXRhVHlwZTp0LGRpbXM6ZVsxXSxkb3dubG9hZDpuLGRpc3Bvc2U6b30pfWNhc2VcIm1sLXRlbnNvclwiOntsZXQgdD1lWzBdO2lmKCFNcih0KSl0aHJvdyBuZXcgRXJyb3IoYG5vdCBzdXBwb3J0ZWQgZGF0YSB0eXBlOiAke3R9IGZvciBkZXNlcmlhbGl6aW5nIE1MVGVuc29yIHRlbnNvcmApO2xldHttbFRlbnNvcjpyLGRvd25sb2FkOm4sZGlzcG9zZTpvfT1lWzJdO3JldHVybiBIZS5mcm9tTUxUZW5zb3Iocix7ZGF0YVR5cGU6dCxkaW1zOmVbMV0sZG93bmxvYWQ6bixkaXNwb3NlOm99KX1kZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW52YWxpZCBkYXRhIGxvY2F0aW9uOiAke2VbM119YCl9fSxwbj1jbGFzc3thc3luYyBmZXRjaE1vZGVsQW5kQ29weVRvV2FzbU1lbW9yeSh0KXtyZXR1cm4gY2MoYXdhaXQgUXQodCkpfWFzeW5jIGxvYWRNb2RlbCh0LHIpe1VlKCk7bGV0IG47dHlwZW9mIHQ9PVwic3RyaW5nXCI/ITE/bj1hd2FpdCBRdCh0KTpuPWF3YWl0IHRoaXMuZmV0Y2hNb2RlbEFuZENvcHlUb1dhc21NZW1vcnkodCk6bj10LFt0aGlzLnNlc3Npb25JZCx0aGlzLmlucHV0TmFtZXMsdGhpcy5vdXRwdXROYW1lc109YXdhaXQgcGMobixyKSxEZSgpfWFzeW5jIGRpc3Bvc2UoKXtyZXR1cm4gbWModGhpcy5zZXNzaW9uSWQpfWFzeW5jIHJ1bih0LHIsbil7VWUoKTtsZXQgbz1bXSxpPVtdO09iamVjdC5lbnRyaWVzKHQpLmZvckVhY2goaD0+e2xldCBfPWhbMF0seT1oWzFdLGc9dGhpcy5pbnB1dE5hbWVzLmluZGV4T2YoXyk7aWYoZz09PS0xKXRocm93IG5ldyBFcnJvcihgaW52YWxpZCBpbnB1dCAnJHtffSdgKTtvLnB1c2goeSksaS5wdXNoKGcpfSk7bGV0IGE9W10sZD1bXTtPYmplY3QuZW50cmllcyhyKS5mb3JFYWNoKGg9PntsZXQgXz1oWzBdLHk9aFsxXSxnPXRoaXMub3V0cHV0TmFtZXMuaW5kZXhPZihfKTtpZihnPT09LTEpdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIG91dHB1dCAnJHtffSdgKTthLnB1c2goeSksZC5wdXNoKGcpfSk7bGV0IGw9by5tYXAoKGgsXyk9PmdjKGgsKCk9PmBpbnB1dCBcIiR7dGhpcy5pbnB1dE5hbWVzW2lbX11dfVwiYCkpLHA9YS5tYXAoKGgsXyk9Pmg/Z2MoaCwoKT0+YG91dHB1dCBcIiR7dGhpcy5vdXRwdXROYW1lc1tkW19dXX1cImApOm51bGwpLG09YXdhaXQgZmModGhpcy5zZXNzaW9uSWQsaSxsLGQscCxuKSx1PXt9O2ZvcihsZXQgaD0wO2g8bS5sZW5ndGg7aCsrKXVbdGhpcy5vdXRwdXROYW1lc1tkW2hdXV09YVtoXT8/eWcobVtoXSk7cmV0dXJuIERlKCksdX1zdGFydFByb2ZpbGluZygpe31lbmRQcm9maWxpbmcoKXtoYyh0aGlzLnNlc3Npb25JZCl9fX0pO3ZhciBfYz17fTtGdChfYyx7T25ueHJ1bnRpbWVXZWJBc3NlbWJseUJhY2tlbmQ6KCk9Pm1uLGluaXRpYWxpemVGbGFnczooKT0+eWMsd2FzbUJhY2tlbmQ6KCk9Pl9nfSk7dmFyIHljLG1uLF9nLHdjPVUoKCk9PntcInVzZSBzdHJpY3RcIjtXZSgpO09vKCk7YmMoKTt5Yz0oKT0+e2lmKCh0eXBlb2YgdmUud2FzbS5pbml0VGltZW91dCE9XCJudW1iZXJcInx8dmUud2FzbS5pbml0VGltZW91dDwwKSYmKHZlLndhc20uaW5pdFRpbWVvdXQ9MCksdmUud2FzbS5zaW1kPT09ITEmJmNvbnNvbGUud2FybignRGVwcmVjYXRlZCBwcm9wZXJ0eSBcImVudi53YXNtLnNpbWRcIiBpcyBzZXQgdG8gZmFsc2UuIG5vbi1TSU1EIGJ1aWxkIGlzIG5vIGxvbmdlciBwcm92aWRlZCwgYW5kIHRoaXMgc2V0dGluZyB3aWxsIGJlIGlnbm9yZWQuJyksdHlwZW9mIHZlLndhc20ucHJveHkhPVwiYm9vbGVhblwiJiYodmUud2FzbS5wcm94eT0hMSksdHlwZW9mIHZlLndhc20udHJhY2UhPVwiYm9vbGVhblwiJiYodmUud2FzbS50cmFjZT0hMSksdHlwZW9mIHZlLndhc20ubnVtVGhyZWFkcyE9XCJudW1iZXJcInx8IU51bWJlci5pc0ludGVnZXIodmUud2FzbS5udW1UaHJlYWRzKXx8dmUud2FzbS5udW1UaHJlYWRzPD0wKWlmKHR5cGVvZiBzZWxmPFwidVwiJiYhc2VsZi5jcm9zc09yaWdpbklzb2xhdGVkKXZlLndhc20ubnVtVGhyZWFkcz0xO2Vsc2V7bGV0IGU9dHlwZW9mIG5hdmlnYXRvcj5cInVcIj9ObihcIm5vZGU6b3NcIikuY3B1cygpLmxlbmd0aDpuYXZpZ2F0b3IuaGFyZHdhcmVDb25jdXJyZW5jeTt2ZS53YXNtLm51bVRocmVhZHM9TWF0aC5taW4oNCxNYXRoLmNlaWwoKGV8fDEpLzIpKX19LG1uPWNsYXNze2FzeW5jIGluaXQodCl7eWMoKSxhd2FpdCBkYygpLGF3YWl0IGxjKHQpfWFzeW5jIGNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyKHQscil7bGV0IG49bmV3IHBuO3JldHVybiBhd2FpdCBuLmxvYWRNb2RlbCh0LHIpLFByb21pc2UucmVzb2x2ZShuKX19LF9nPW5ldyBtbn0pO1dlKCk7V2UoKTtXZSgpO3ZhciBDYT1cIjEuMjEuMC1kZXYuMjAyNTAxMTQtMjI4ZGQxNjg5M1wiO3ZhciAkMT1Gbjt7bGV0IGU9KHdjKCksYnIoX2MpKS53YXNtQmFja2VuZDtTdChcIndlYmdwdVwiLGUsNSksU3QoXCJ3ZWJublwiLGUsNSksU3QoXCJjcHVcIixlLDEwKSxTdChcIndhc21cIixlLDEwKX1PYmplY3QuZGVmaW5lUHJvcGVydHkodmUudmVyc2lvbnMsXCJ3ZWJcIix7dmFsdWU6Q2EsZW51bWVyYWJsZTohMH0pO2V4cG9ydHtGcCBhcyBJbmZlcmVuY2VTZXNzaW9uLHdyIGFzIFRSQUNFLFVlIGFzIFRSQUNFX0ZVTkNfQkVHSU4sRGUgYXMgVFJBQ0VfRlVOQ19FTkQsSGUgYXMgVGVuc29yLCQxIGFzIGRlZmF1bHQsdmUgYXMgZW52LFN0IGFzIHJlZ2lzdGVyQmFja2VuZH07XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG4vLyMgc291cmNlTWFwcGluZ1VSTD1vcnQud2ViZ3B1LmJ1bmRsZS5taW4ubWpzLm1hcFxuIl0sIm5hbWVzIjpbIlVuIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJWcCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIldwIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIkxwIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJObiIsImUiLCJyZXF1aXJlIiwiUHJveHkiLCJnZXQiLCJ0IiwiciIsImFwcGx5IiwiYXJndW1lbnRzIiwiRXJyb3IiLCJVIiwiRnQiLCJlbnVtZXJhYmxlIiwiR3AiLCJuIiwibyIsImNhbGwiLCJiciIsInZhbHVlIiwieXIiLCJ4dCIsIlN0IiwiSHAiLCJKaSIsIlZuIiwiTWFwIiwiaW5pdCIsImNyZWF0ZUluZmVyZW5jZVNlc3Npb25IYW5kbGVyIiwic2V0IiwiYmFja2VuZCIsInByaW9yaXR5IiwiaW5kZXhPZiIsInNwbGljZSIsImkiLCJsZW5ndGgiLCJwdXNoIiwiVHlwZUVycm9yIiwiaW5pdGlhbGl6ZWQiLCJhYm9ydGVkIiwiZXJyb3IiLCJpbml0UHJvbWlzZSIsImV4ZWN1dGlvblByb3ZpZGVycyIsIm1hcCIsImwiLCJuYW1lIiwiYSIsIlNldCIsInAiLCJlcnIiLCJhZGQiLCJqb2luIiwiaW5jbHVkZXMiLCJjb25zb2xlIiwid2FybiIsImQiLCJmaWx0ZXIiLCJoYXMiLCJSZWZsZWN0IiwiZWEiLCJ0YSIsInJhIiwibmEiLCJSZSIsIlduIiwid2FzbSIsIndlYmdsIiwid2ViZ3B1IiwidmVyc2lvbnMiLCJjb21tb24iLCJsb2dMZXZlbCIsInZlIiwib2EiLCJpYSIsImFhIiwic2EiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJPZmZzY3JlZW5DYW52YXMiLCJ3aWR0aCIsImRpbXMiLCJoZWlnaHQiLCJnZXRDb250ZXh0IiwidGVuc29yTGF5b3V0IiwiZm9ybWF0Iiwibm9ybSIsIm1lYW4iLCJiaWFzIiwibSIsInUiLCJoIiwiXyIsInkiLCJnIiwieCIsIiQiLCJkYXRhIiwidiIsIlMiLCJUIiwiZmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJ0b0RhdGFVUkwiLCJjcmVhdGVJbWFnZURhdGEiLCJBIiwiTG4iLCJ1YSIsImRhIiwibGEiLCJjYSIsInBhIiwibWEiLCJfciIsInRlbnNvckZvcm1hdCIsIkZsb2F0MzJBcnJheSIsInplIiwiSFRNTEltYWdlRWxlbWVudCIsIkltYWdlRGF0YSIsIkltYWdlQml0bWFwIiwiSFRNTENhbnZhc0VsZW1lbnQiLCJyZXNpemVkSGVpZ2h0IiwicmVzaXplZFdpZHRoIiwiZHJhd0ltYWdlIiwiZ2V0SW1hZ2VEYXRhIiwicHV0SW1hZ2VEYXRhIiwiUHJvbWlzZSIsIkltYWdlIiwiY3Jvc3NPcmlnaW4iLCJzcmMiLCJvbmxvYWQiLCJkb3dubG9hZCIsImRpc3Bvc2UiLCJsb2NhdGlvbiIsInR5cGUiLCJ0ZXh0dXJlIiwiZGF0YVR5cGUiLCJncHVCdWZmZXIiLCJtbFRlbnNvciIsIlR0IiwicXQiLCJmYSIsImhhIiwiZ2EiLCJVaW50OEFycmF5IiwiSW50OEFycmF5IiwiVWludDE2QXJyYXkiLCJJbnQxNkFycmF5IiwiSW50MzJBcnJheSIsIkZsb2F0NjRBcnJheSIsIlVpbnQzMkFycmF5IiwiQmlnSW50NjRBcnJheSIsImZyb20iLCJCaWdVaW50NjRBcnJheSIsIkZsb2F0MTZBcnJheSIsImJhIiwieWEiLCJfYSIsIk51bWJlciIsImlzU2FmZUludGVnZXIiLCJSYW5nZUVycm9yIiwiZnJvbUltYWdlIiwiZnJvbVRleHR1cmUiLCJmcm9tR3B1QnVmZmVyIiwiZnJvbU1MVGVuc29yIiwiZnJvbVBpbm5lZEJ1ZmZlciIsInRvSW1hZ2VEYXRhIiwiZW5zdXJlVmFsaWQiLCJjcHVEYXRhIiwiZGF0YUxvY2F0aW9uIiwiZ3B1VGV4dHVyZURhdGEiLCJncHVCdWZmZXJEYXRhIiwibWxUZW5zb3JEYXRhIiwiZ2V0RGF0YSIsImRvd25sb2FkZXIiLCJpc0Rvd25sb2FkaW5nIiwiZGlzcG9zZXIiLCJyZXNoYXBlIiwiY29uc3RydWN0b3IiLCJBcnJheSIsImlzQXJyYXkiLCJCaWdJbnQiLCJVaW50OENsYW1wZWRBcnJheSIsIk1hdGgiLCJjZWlsIiwic2l6ZSIsIkhlIiwiR24iLCJ3ciIsIndhIiwiVWUiLCJEZSIsIkhuIiwidHJhY2UiLCJ0aW1lU3RhbXAiLCJzdGFjayIsInNwbGl0IiwidHJpbSIsInZyIiwidmEiLCJydW4iLCJvdXRwdXROYW1lcyIsImlucHV0TmFtZXMiLCJoYW5kbGVyIiwicmVsZWFzZSIsImNyZWF0ZSIsIkFycmF5QnVmZmVyIiwiU2hhcmVkQXJyYXlCdWZmZXIiLCJieXRlTGVuZ3RoIiwic3RhcnRQcm9maWxpbmciLCJlbmRQcm9maWxpbmciLCJGcCIsIiRhIiwieGEiLCJTYSIsIlRhIiwiSWEiLCJGbiIsIkluZmVyZW5jZVNlc3Npb24iLCJUUkFDRSIsIlRSQUNFX0ZVTkNfQkVHSU4iLCJUUkFDRV9GVU5DX0VORCIsIlRlbnNvciIsImVudiIsInJlZ2lzdGVyQmFja2VuZCIsIldlIiwiJHIiLCJFYSIsImRlZmF1bHQiLCJxcCIsIkFhIiwia2EiLCJQYSIsImdsb2JhbFRoaXMiLCJxbiIsImd0IiwieHIiLCJzZWxmIiwib25tZXNzYWdlIiwiaW4iLCJTciIsInRoZW4iLCJUciIsInBvc3RNZXNzYWdlIiwiZXBOYW1lIiwiSXIiLCJidWZmZXIiLCJLdCIsIm91dCIsIm1vZGVsIiwib3B0aW9ucyIsIkNyIiwiQXIiLCJzZXNzaW9uSWQiLCJpbnB1dEluZGljZXMiLCJpbnB1dHMiLCJvdXRwdXRJbmRpY2VzIiwia3IiLCJmaWxsIiwic29tZSIsIlByIiwiRXIiLCJXb3JrZXIiLCJOZSIsIk9hIiwiS3AiLCJLbiIsInphIiwiRGEiLCJ1cmwiLCJzZSIsIkoiLCJ5ZSIsIm5lIiwiYmUiLCJPZSIsIiRlIiwibGUiLCJXIiwiR2UiLCJhc3NpZ24iLCJzIiwiYyIsImltcG9ydFNjcmlwdHMiLCJtb3VudEV4dGVybmFsRGF0YSIsInN0YXJ0c1dpdGgiLCJzdWJzdHJpbmciLCJGYiIsInVubW91bnRFeHRlcm5hbERhdGEiLCJXZWJBc3NlbWJseSIsIk1lbW9yeSIsImluaXRpYWwiLCJtYXhpbXVtIiwic2hhcmVkIiwiZiIsImIiLCJ3IiwiSSIsIk8iLCJYZSIsIkIiLCJMIiwiSCIsIlgiLCJFbiIsInJlc29sdmUiLCJyZWplY3QiLCJHYiIsImhjIiwiZXJyb3JzIiwiSGIiLCJmbHVzaCIsImFsbCIsIl9PcnRDcmVhdGVTZXNzaW9uIiwiX09ydFJ1biIsIl9PcnRSdW5XaXRoQmluZGluZyIsIl9PcnRCaW5kSW5wdXQiLCJqc2VwSW5pdCIsIlZiIiwiWmIiLCJPYiIsIlliIiwia2IiLCIkYiIsImNjIiwiV2IiLCJYYiIsImFjIiwianNlcFJlZ2lzdGVyQnVmZmVyIiwicmVnaXN0ZXJCdWZmZXIiLCJqc2VwR2V0QnVmZmVyIiwiZ2V0QnVmZmVyIiwianNlcENyZWF0ZURvd25sb2FkZXIiLCJjcmVhdGVEb3dubG9hZGVyIiwianNlcE9uQ3JlYXRlU2Vzc2lvbiIsIm9uQ3JlYXRlU2Vzc2lvbiIsImpzZXBPblJlbGVhc2VTZXNzaW9uIiwib25SZWxlYXNlU2Vzc2lvbiIsImpzZXBPblJ1blN0YXJ0Iiwib25SdW5TdGFydCIsImRjIiwidXBsb2FkIiwiYmMiLCJQYiIsImpzZXBFbnN1cmVUZW5zb3IiLCJlYyIsImpzZXBEb3dubG9hZFRlbnNvciIsImpzZXBSZWxlYXNlVGVuc29ySWQiLCJqc2VwUmVnaXN0ZXJNTENvbnRleHQiLCJyZWdpc3Rlck1MQ29udGV4dCIsImpzZXBDcmVhdGVNTFRlbnNvckRvd25sb2FkZXIiLCJjcmVhdGVNTFRlbnNvckRvd25sb2FkZXIiLCJqc2VwUmVnaXN0ZXJNTFRlbnNvciIsInJlZ2lzdGVyTUxUZW5zb3IiLCJqc2VwQ3JlYXRlTUxDb250ZXh0IiwiY3JlYXRlTUxDb250ZXh0IiwianNlcFJlZ2lzdGVyTUxDb25zdGFudCIsInJlZ2lzdGVyTUxDb25zdGFudCIsImsiLCJQIiwiaHJlZiIsImN1cnJlbnRTY3JpcHQiLCJzdWJzdHIiLCJyZXBsYWNlIiwibGFzdEluZGV4T2YiLCJYTUxIdHRwUmVxdWVzdCIsIm9wZW4iLCJyZXNwb25zZVR5cGUiLCJzZW5kIiwicmVzcG9uc2UiLCJzdGF0dXMiLCJvbmVycm9yIiwiRCIsIlIiLCJsb2ciLCJiaW5kIiwiRyIsIksiLCJqIiwiY21kIiwic3RhcnRXb3JrZXIiLCJoYW5kbGVycyIsInByb3h5IiwiTmIiLCJwYyIsImFyZ3MiLCJ3YXNtTWVtb3J5IiwiViIsIndhc21Nb2R1bGUiLCJEbiIsInB0aHJlYWRfcHRyIiwiQW4iLCJ4YyIsIkhvIiwiUSIsIldpIiwiU2MiLCJzdGFydF9yb3V0aW5lIiwiYXJnIiwiTXQiLCJociIsInRhcmdldCIsImlyIiwiTGkiLCJ3ZyIsImFsZXJ0IiwidGV4dCIsInJjIiwiaW5zdGFudGlhdGVXYXNtIiwiSW5zdGFuY2UiLCJObyIsIm9udW5oYW5kbGVkcmVqZWN0aW9uIiwicmVhc29uIiwid2FzbUJpbmFyeSIsIlkiLCJlZSIsInEiLCJoZSIsIndlIiwiSEVBUDgiLCJIRUFQMTYiLCJIRUFQVTgiLCJIRUFQVTE2IiwiSEVBUDMyIiwiSEVBUFUzMiIsIkhFQVBGMzIiLCJIRUFQRjY0IiwiSEVBUDY0IiwiSEVBUFU2NCIsIlllIiwiTHQiLCJmbiIsIkd0IiwiaG4iLCJIdCIsIkRvIiwiY2xlYXJJbnRlcnZhbCIsImN0IiwiUnVudGltZUVycm9yIiwiZ24iLCJCbyIsIk1vIiwiUm8iLCJVbyIsImZldGNoIiwiY3JlZGVudGlhbHMiLCJvayIsImFycmF5QnVmZmVyIiwiY2F0Y2giLCJpbnN0YW50aWF0ZSIsIiRjIiwidmMiLCJJYyIsImpvIiwiUW8iLCJxYSIsIlhvIiwiZWkiLCJ0aSIsInJpIiwibmkiLCJvaSIsImlpIiwiYWkiLCJaIiwic2kiLCJ1aSIsImRpIiwibGkiLCJDYyIsIkYiLCJrYyIsIkVjIiwiemMiLCJFIiwiRGMiLCJCYyIsIk1jIiwiUmMiLCJIYyIsIkZjIiwicWMiLCJLYyIsImpjIiwiWWMiLCJaYyIsImphIiwiUWMiLCJYYyIsIkJhIiwiSmMiLCJycCIsIm5wIiwiaXAiLCJJbiIsImFwIiwiZHAiLCJscCIsImNwIiwicHAiLCJtcCIsImZwIiwiaHAiLCJncCIsImJwIiwieXAiLCJfcCIsIndwIiwidnAiLCIkcCIsIlNpIiwiVGkiLCJ4cCIsIlNwIiwiVHAiLCJJcCIsIk0iLCJDcCIsIkFwIiwia3AiLCJFcCIsIkNpIiwieiIsIlBwIiwiTiIsInpwIiwiT3AiLCJEcCIsIkJwIiwiRWkiLCJQaSIsInZuIiwiQyIsInppIiwiT2kiLCJEaSIsIkJpIiwid24iLCJVaSIsIlVwIiwiYm4iLCJDZSIsInN1YmFycmF5Iiwid2FzbU9mZnNldENvbnZlcnRlciIsImFscGhhIiwiYmV0YSIsIm1pbiIsIm1heCIsInRvIiwia2VlcERpbXMiLCJub29wV2l0aEVtcHR5QXhlcyIsImF4ZXMiLCJwZXJtIiwiYmxvY2tzaXplIiwibW9kZSIsImNlIiwiZ2UiLCJkZSIsImF1dG9QYWQiLCJkaWxhdGlvbnMiLCJncm91cCIsImtlcm5lbFNoYXBlIiwicGFkcyIsInN0cmlkZXMiLCJ3SXNDb25zdCIsIm91dHB1dFBhZGRpbmciLCJvdXRwdXRTaGFwZSIsImFjdGl2YXRpb24iLCJhdXRvX3BhZCIsImNlaWxfbW9kZSIsImNvdW50X2luY2x1ZGVfcGFkIiwic3RvcmFnZV9vcmRlciIsImtlcm5lbF9zaGFwZSIsInRyYW5zQSIsInRyYW5zQiIsInNlbGVjdExhc3RJbmRleCIsImF4aXMiLCJudW1PdXRwdXRzIiwic3BsaXRTaXplcyIsImJhdGNoX2RpbXMiLCJhbnRpYWxpYXMiLCJjb29yZGluYXRlVHJhbnNmb3JtTW9kZSIsImN1YmljQ29lZmZBIiwiZXhjbHVkZU91dHNpZGUiLCJleHRyYXBvbGF0aW9uVmFsdWUiLCJrZWVwQXNwZWN0UmF0aW9Qb2xpY3kiLCJuZWFyZXN0TW9kZSIsInN0YXJ0cyIsImVuZHMiLCJlcHNpbG9uIiwiZXF1YXRpb24iLCJtb21lbnR1bSIsInNwYXRpYWwiLCJ0cmFpbmluZ01vZGUiLCJleGNsdXNpdmUiLCJyZXZlcnNlIiwiYmxvY2tTaXplIiwiYWxpZ25fY29ybmVycyIsInBhZGRpbmdfbW9kZSIsIm51bUhlYWRzIiwiaXNVbmlkaXJlY3Rpb25hbCIsIm1hc2tGaWx0ZXJWYWx1ZSIsInNjYWxlIiwiZG9Sb3RhcnkiLCJxa3ZIaWRkZW5TaXplcyIsInBhc3RQcmVzZW50U2hhcmVCdWZmZXIiLCJUZSIsIndfaXNfY29uc3QiLCJhY3RpdmF0aW9uX3BhcmFtcyIsImt2TnVtSGVhZHMiLCJzb2Z0Y2FwIiwicm90YXJ5SW50ZXJsZWF2ZWQiLCJzbW9vdGhTb2Z0bWF4IiwibG9jYWxXaW5kb3dTaXplIiwic2ltcGxpZmllZCIsImFjY3VyYWN5TGV2ZWwiLCJiaXRzIiwiaW50ZXJsZWF2ZWQiLCJyb3RhcnlFbWJlZGRpbmdEaW0iLCJnYXRoZXJBeGlzIiwicXVhbnRpemVBeGlzIiwiX2kiLCJ5biIsIm1lc3NhZ2UiLCJfbiIsInRlcm1pbmF0ZSIsIlZvIiwicHQiLCJxbyIsIkZvIiwicG9wIiwidnQiLCJaZSIsIkJiIiwiaWMiLCJSYiIsIm5jIiwid3QiLCJ4ZSIsIlJuIiwiTW4iLCJHaSIsImdyIiwiV28iLCJMbyIsIkdvIiwiQm4iLCJmb3JFYWNoIiwidGFyZ2V0VGhyZWFkIiwidHJhbnNmZXJMaXN0IiwidGhyZWFkIiwibG9hZGVkIiwidGhyZWFkSWQiLCJmaWxlbmFtZSIsImxpbmVubyIsIlVSTCIsIndvcmtlckRhdGEiLCJvciIsInNoaWZ0IiwiRmkiLCJxaSIsIlRjIiwiS2IiLCJLbyIsIllvIiwiVGV4dERlY29kZXIiLCJabyIsImRlY29kZSIsInNsaWNlIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiJG4iLCJjaGFyQ29kZUF0IiwiSm8iLCJPdCIsImNpIiwibXQiLCJRZSIsInhuIiwiU24iLCJBYyIsInN0IiwiVGIiLCJwaSIsImZyb21XaXJlVHlwZSIsInRvV2lyZVR5cGUiLCJ0b1N0cmluZyIsImFyZ1BhY2tBZHZhbmNlIiwiZnQiLCJyZWFkVmFsdWVGcm9tUG9pbnRlciIsIkViIiwiVG4iLCJ1dCIsIk1lIiwiVmUiLCJDbiIsIlBjIiwiT2MiLCJKZSIsImZyIiwibWkiLCJVYyIsIk5jIiwiVmMiLCJXYyIsIkxjIiwiR2MiLCJVYiIsImZpIiwiQXRvbWljcyIsIm9jIiwic3RvcmUiLCJIaSIsInNldFRpbWVvdXQiLCJrbiIsIk5wIiwiYXIiLCJWaSIsImhpIiwic3IiLCJodCIsImdpIiwidXIiLCJiaSIsInlpIiwiZXAiLCJ0cCIsIllpIiwiQnJvd3NlciIsIkxiIiwiU2IiLCJyZXN1bWUiLCJwYXVzZSIsIktpIiwiWmkiLCJkciIsIm9wIiwibHIiLCJ3aSIsIkZ1bmN0aW9uIiwic3AiLCJ1cCIsInZpIiwiTmFOIiwiRGF0ZSIsImdldFVUQ1NlY29uZHMiLCJnZXRVVENNaW51dGVzIiwiZ2V0VVRDSG91cnMiLCJnZXRVVENEYXRlIiwiZ2V0VVRDTW9udGgiLCJnZXRVVENGdWxsWWVhciIsImdldFVUQ0RheSIsImdldFRpbWUiLCJVVEMiLCJEdCIsIiRpIiwieGkiLCJnZXRTZWNvbmRzIiwiZ2V0TWludXRlcyIsImdldEhvdXJzIiwiZ2V0RGF0ZSIsImdldE1vbnRoIiwiZ2V0RnVsbFllYXIiLCJnZXREYXkiLCJnZXRUaW1lem9uZU9mZnNldCIsInNldFRpbWUiLCJnZXRZZWFyIiwiaXNOYU4iLCJ0b0xvY2FsZVRpbWVTdHJpbmciLCJob3VyMTIiLCJ0aW1lWm9uZU5hbWUiLCJQbiIsIklpIiwibm93IiwicGVyZm9ybWFuY2UiLCJ0aW1lT3JpZ2luIiwibmF2aWdhdG9yIiwiaGFyZHdhcmVDb25jdXJyZW5jeSIsImdyb3ciLCJjciIsIkJ0IiwiQWkiLCJRYiIsImZjIiwiem4iLCJPbiIsImtpIiwiVVNFUiIsIkxPR05BTUUiLCJQQVRIIiwiUFdEIiwiSE9NRSIsIkxBTkciLCJsYW5ndWFnZXMiLCJNcCIsIk1pIiwiUmkiLCJScCIsIlhpIiwiJHQiLCJDYiIsIkRiIiwic2V0RGF0ZSIsInNldE1vbnRoIiwic2V0RnVsbFllYXIiLCJsYyIsIkliIiwiTWIiLCJKYiIsInZiIiwic2MiLCJtYyIsIlJlZ0V4cCIsImZsb29yIiwiYWJzIiwibnVtVGhyZWFkcyIsInVuc2hpZnQiLCJOaSIsInByIiwiQmluZGluZ0Vycm9yIiwiSW50ZXJuYWxFcnJvciIsImNvdW50X2VtdmFsX2hhbmRsZXMiLCJleHBvcnRzIiwiZW50cmllcyIsImppIiwiRmliZXJzIiwidGMiLCJnYiIsImliIiwiZW1zY3JpcHRlbl9tYWluX3J1bnRpbWVfdGhyZWFkX2lkIiwidGIiLCJ1YiIsImpiIiwiQ2EiLCJsb2NhdGVGaWxlIiwiaW5zdGFudGlhdGVTdHJlYW1pbmciLCJpbnN0YW5jZSIsIm1vZHVsZSIsIl9PcnRJbml0IiwiRmEiLCJfT3J0R2V0TGFzdEVycm9yIiwiR2EiLCJfT3J0Q3JlYXRlU2Vzc2lvbk9wdGlvbnMiLCJIYSIsIl9PcnRBcHBlbmRFeGVjdXRpb25Qcm92aWRlciIsIl9PcnRBZGRGcmVlRGltZW5zaW9uT3ZlcnJpZGUiLCJKYSIsIl9PcnRBZGRTZXNzaW9uQ29uZmlnRW50cnkiLCJLYSIsIl9PcnRSZWxlYXNlU2Vzc2lvbk9wdGlvbnMiLCJMYSIsIk1hIiwiX09ydFJlbGVhc2VTZXNzaW9uIiwiTmEiLCJfT3J0R2V0SW5wdXRPdXRwdXRDb3VudCIsIl9PcnRHZXRJbnB1dE5hbWUiLCJfT3J0R2V0T3V0cHV0TmFtZSIsIlFhIiwiX09ydEZyZWUiLCJSYSIsIl9PcnRDcmVhdGVUZW5zb3IiLCJfT3J0R2V0VGVuc29yRGF0YSIsIl9PcnRSZWxlYXNlVGVuc29yIiwiVWEiLCJfT3J0Q3JlYXRlUnVuT3B0aW9ucyIsIlZhIiwiX09ydEFkZFJ1bkNvbmZpZ0VudHJ5IiwiV2EiLCJfT3J0UmVsZWFzZVJ1bk9wdGlvbnMiLCJYYSIsIl9PcnRDcmVhdGVCaW5kaW5nIiwiWWEiLCJaYSIsIl9PcnRCaW5kT3V0cHV0IiwiX09ydENsZWFyQm91bmRPdXRwdXRzIiwiX09ydFJlbGVhc2VCaW5kaW5nIiwiYWIiLCJiYiIsImNiIiwiX09ydEVuZFByb2ZpbGluZyIsImRiIiwiX0pzZXBPdXRwdXQiLCJlYiIsIl9Kc2VwR2V0Tm9kZU5hbWUiLCJmYiIsIm1yIiwiX2ZyZWUiLCJoYiIsIl9tYWxsb2MiLCJsYiIsIm1iIiwibmIiLCJvYiIsInBiIiwicWIiLCJyYiIsInNiIiwiZHluQ2FsbF9paSIsIndiIiwieGIiLCJ5YiIsInpiIiwiQWIiLCJRaSIsImNhbGxlZFJ1biIsIl9fX3N0YXJ0X2VtX2pzIiwiX19fc3RvcF9lbV9qcyIsInN0YWNrU2F2ZSIsInN0YWNrUmVzdG9yZSIsInN0YWNrQWxsb2MiLCJzZXRWYWx1ZSIsImVuZHNXaXRoIiwiZ2V0VmFsdWUiLCJVVEY4VG9TdHJpbmciLCJzdHJpbmdUb1VURjgiLCJsZW5ndGhCeXRlc1VURjgiLCJQVFJfU0laRSIsImpwIiwiam4iLCJZcCIsIlpwIiwiUXAiLCJvcmlnaW4iLCJibG9iIiwiY3JlYXRlT2JqZWN0VVJMIiwiWW4iLCJabiIsInpyIiwiWHAiLCJKcCIsIkllIiwiTWVzc2FnZUNoYW5uZWwiLCJwb3J0MSIsInZhbGlkYXRlIiwiaW5pdFRpbWVvdXQiLCJjcm9zc09yaWdpbklzb2xhdGVkIiwid2FzbVBhdGhzIiwibWpzIiwicmV2b2tlT2JqZWN0VVJMIiwicmFjZSIsImtlIiwianQiLCJwZSIsIk9yIiwibG9nU2V2ZXJpdHlMZXZlbCIsImlzSW50ZWdlciIsImxvZ1ZlcmJvc2l0eUxldmVsIiwidGFnIiwiZXh0cmEiLCJXZWFrU2V0IiwiZW0iLCJ0bSIsInJtIiwibm0iLCJzZXNzaW9uIiwidXNlX29ydF9tb2RlbF9ieXRlc19kaXJlY3RseSIsImVuYWJsZU1lbVBhdHRlcm4iLCJkZXZpY2VUeXBlIiwicHJlZmVycmVkTGF5b3V0IiwiZ3JhcGhPcHRpbWl6YXRpb25MZXZlbCIsImV4ZWN1dGlvbk1vZGUiLCJsb2dJZCIsIm9wdGltaXplZE1vZGVsRmlsZVBhdGgiLCJlbmFibGVDcHVNZW1BcmVuYSIsImVuYWJsZVByb2ZpbGluZyIsImVuYWJsZUdyYXBoQ2FwdHVyZSIsImZyZWVEaW1lbnNpb25PdmVycmlkZXMiLCJZdCIsImJ0IiwiQ3QiLCJEciIsIlp0IiwiQnIiLCJNciIsIlFuIiwidGUiLCJyZWR1Y2UiLCJRdCIsIlhuIiwicmVhZEZpbGUiLCJjb2RlIiwiY3JlYXRlUmVhZFN0cmVhbSIsIkJ1ZmZlciIsImNvbmNhdCIsImhlYWRlcnMiLCJwYXJzZUludCIsImJvZHkiLCJnZXRSZWFkZXIiLCJkb25lIiwicmVhZCIsIkJsb2IiLCJvbSIsImltIiwiUnIiLCJhbSIsInVlIiwiZXQiLCJ0b0lTT1N0cmluZyIsIlVyIiwiSm4iLCJOciIsImVvIiwic20iLCJ1bSIsIm5vIiwicm8iLCJkZXZpY2UiLCJjcmVhdGVCdWZmZXIiLCJ1c2FnZSIsIkdQVUJ1ZmZlclVzYWdlIiwiQ09QWV9EU1QiLCJNQVBfUkVBRCIsImdldENvbW1hbmRFbmNvZGVyIiwiZW5kQ29tcHV0ZVBhc3MiLCJjb3B5QnVmZmVyVG9CdWZmZXIiLCJtYXBBc3luYyIsIkdQVU1hcE1vZGUiLCJSRUFEIiwiZ2V0TWFwcGVkUmFuZ2UiLCJkZXN0cm95IiwiYnl0ZU9mZnNldCIsInN0b3JhZ2VDYWNoZSIsIm9yaWdpbmFsU2l6ZSIsIm1hcHBlZEF0Q3JlYXRpb24iLCJNQVBfV1JJVEUiLCJDT1BZX1NSQyIsInVubWFwIiwiY3JlYXRlQ29tbWFuZEVuY29kZXIiLCJncHVEYXRhIiwicXVldWUiLCJzdWJtaXQiLCJmaW5pc2giLCJtZW1jcHkiLCJyZWdpc3RlckV4dGVybmFsQnVmZmVyIiwiY2FwdHVyZWRDb21tYW5kTGlzdCIsImN1cnJlbnRTZXNzaW9uSWQiLCJpZCIsInVucmVnaXN0ZXJFeHRlcm5hbEJ1ZmZlciIsImRlbGV0ZSIsIlNUT1JBR0UiLCJVTklGT1JNIiwiZnJlZUJ1ZmZlcnMiLCJmcmVlVW5pZm9ybUJ1ZmZlcnMiLCJidWZmZXJzUGVuZGluZyIsInJlZnJlc2hQZW5kaW5nQnVmZmVycyIsInNlc3Npb25TdGF0dXMiLCJjYXB0dXJlZFBlbmRpbmdCdWZmZXJzIiwic2Vzc2lvbkNvdW50Iiwib28iLCJyZSIsIlNlIiwiY2FjaGVLZXkiLCJrZXkiLCJzb3J0IiwiaW8iLCJ0dCIsIkF0IiwiVnIiLCJlcyIsInRzIiwib2UiLCJjYWxjTWF0TXVsU2hhcGUiLCJjYWxjU2hhcGUiLCJpc1ZhbGlkQnJvYWRjYXN0IiwiZ2V0U2l6ZUZyb21EaW1lbnNpb25SYW5nZSIsImNvbnZlcnRTaGFwZSIsInNpemVGcm9tRGltZW5zaW9uIiwic2l6ZVRvRGltZW5zaW9uIiwiY29tcHV0ZVN0cmlkZXMiLCJub3JtYWxpemVBeGlzIiwibm9ybWFsaXplQXhlcyIsInNvcnRCYXNlZE9uUGVybSIsInBhZFNoYXBlIiwiYXJlRXF1YWwiLCJldmVyeSIsImFkanVzdFBvb2xBdHRyaWJ1dGVzIiwiYWRqdXN0UGFkc0Jhc2VkT25BdXRvUGFkIiwiYWRqdXN0UGFkQW5kUmV0dXJuU2hhcGUiLCJjb21wdXRlUG9vbE91dHB1dFNoYXBlIiwiY29tcHV0ZVNoYXBlSGVscGVyIiwiY29tcHV0ZUNvbnZPdXRwdXRTaGFwZSIsImdldFNoYXBlT2ZHZW1tUmVzdWx0Iiwia3QiLCJzbyIsIl9lIiwiRWUiLCJtZSIsInVvIiwiRXQiLCJGZSIsIldyIiwicnMiLCJMciIsImFvIiwibnMiLCJhZSIsImtleXMiLCJpbmRpY2VzIiwic3RvcmFnZSIsInRlbnNvciIsIm9mZnNldFRvSW5kaWNlcyIsImluZGljZXNUb09mZnNldCIsImJyb2FkY2FzdGVkSW5kaWNlc1RvT2Zmc2V0Iiwic2V0QnlJbmRpY2VzIiwiZ2V0QnlJbmRpY2VzIiwiaW5kaWNlc0dldCIsInJhbmsiLCJpbXBsIiwidmFsdWVzIiwiaW5kaWNlc1NldCIsInNldEJ5T2Zmc2V0IiwiZ2V0QnlPZmZzZXQiLCJzaGFwZSIsImd1YXJkQWdhaW5zdE91dE9mQm91bmRzV29ya2dyb3VwU2l6ZXMiLCJtYWluU3RhcnQiLCJsaW1pdHMiLCJtYXhDb21wdXRlV29ya2dyb3VwU2l6ZVgiLCJtYXhDb21wdXRlV29ya2dyb3VwU2l6ZVkiLCJtYXhDb21wdXRlV29ya2dyb3VwU2l6ZVoiLCJtYXhDb21wdXRlSW52b2NhdGlvbnNQZXJXb3JrZ3JvdXAiLCJub3JtYWxpemVkRGlzcGF0Y2hHcm91cCIsImFwcGVuZFZhcmlhYmxlVW5pZm9ybXMiLCJ1bmlmb3JtcyIsImRlY2xhcmVWYXJpYWJsZSIsInZhcmlhYmxlcyIsImRlY2xhcmVWYXJpYWJsZXMiLCJ2YXJpYWJsZUluZGV4IiwicmVnaXN0ZXJJbnRlcm5hbFZhcmlhYmxlIiwiaW50ZXJuYWxWYXJpYWJsZXMiLCJyZWdpc3RlckludGVybmFsVmFyaWFibGVzIiwicmVnaXN0ZXJVbmlmb3JtIiwicmVnaXN0ZXJVbmlmb3JtcyIsInVuaWZvcm1EZWNsYXJhdGlvbiIsImFkZGl0aW9uYWxJbXBsZW1lbnRhdGlvbnMiLCJ2YXJpYWJsZXNJbmZvIiwiZG0iLCJvcyIsImxtIiwiY20iLCJwbSIsIm1tIiwiUGUiLCJpcyIsImFzIiwiZHQiLCJuZXdTaGFwZSIsIm5ld1Blcm0iLCJzaGFkZXJDYWNoZSIsImlucHV0RGVwZW5kZW5jaWVzIiwiZ2V0UnVuRGF0YSIsIm91dHB1dHMiLCJkaXNwYXRjaEdyb3VwIiwicHJvZ3JhbVVuaWZvcm1zIiwiZ2V0U2hhZGVyU291cmNlIiwiaGludCIsImNvbXB1dGUiLCJmbSIsImhtIiwiZ20iLCJibSIsInltIiwiX20iLCJ3bSIsInZtIiwiJG0iLCJ4bSIsInJ0Iiwic3MiLCJ1cyIsImRzIiwibHMiLCJjcyIsInBzIiwibXMiLCJmcyIsImhzIiwiZ3MiLCJicyIsIkdyIiwic3VtIiwicHJvZCIsInN1bVNxdWFyZSIsImxvZ1N1bUV4cCIsImwxIiwibDIiLCJsb2dTdW0iLCJsbyIsIm50IiwiU20iLCJIciIsIm90IiwiVG0iLCJJbSIsIkNtIiwiQW0iLCJrbSIsIkVtIiwiUG0iLCJ6bSIsIk9tIiwiRG0iLCJpdCIsInlzIiwiX3MiLCJ3cyIsInZzIiwiJHMiLCJ4cyIsIlNzIiwiVHMiLCJJcyIsIkNzIiwiZ2V0QmlnSW50NjRBcnJheSIsIkFzIiwia3MiLCJFcyIsImNvIiwiUHMiLCJCbSIsInBvIiwiTW0iLCJSbSIsIlVtIiwiUnQiLCJObSIsInpzIiwiRnIiLCJiYXRjaFNpemUiLCJzZXF1ZW5jZUxlbmd0aCIsInBhc3RTZXF1ZW5jZUxlbmd0aCIsImt2U2VxdWVuY2VMZW5ndGgiLCJ0b3RhbFNlcXVlbmNlTGVuZ3RoIiwibWF4U2VxdWVuY2VMZW5ndGgiLCJpbnB1dEhpZGRlblNpemUiLCJoaWRkZW5TaXplIiwidkhpZGRlblNpemUiLCJoZWFkU2l6ZSIsInZIZWFkU2l6ZSIsIm1hc2tUeXBlIiwiYnJvYWRjYXN0UmVzUG9zQmlhcyIsInBhc3NQYXN0SW5LdiIsInFrdkZvcm1hdCIsIm5SZXBzIiwic3FydCIsImdwdURhdGFUeXBlIiwib3V0cHV0Q291bnQiLCJWbSIsIldtIiwiTG0iLCJPcyIsIkRzIiwidmFsaWRhdGVJbnB1dENvbnRlbnQiLCJHbSIsIkhtIiwiQnMiLCJNcyIsIkZtIiwiZmUiLCJScyIsIlVzIiwiTnMiLCJWcyIsIldzIiwiTHMiLCJHcyIsIkhzIiwiRnMiLCJxbSIsInFzIiwiS3MiLCJqcyIsIllzIiwiWHQiLCJacyIsInFyIiwiUXMiLCJYcyIsIkpzIiwiZXUiLCJ0dSIsInJ1IiwibnUiLCJvdSIsIml1IiwiYXUiLCJzdSIsInV1IiwiZHUiLCJsdSIsImN1IiwicHUiLCJtdSIsImZ1IiwibW8iLCJmbyIsImh1IiwiZ3UiLCJidSIsIkttIiwiam0iLCJ5dSIsIktyIiwiZ2V0RmxvYXQzMkFycmF5IiwiZ2V0VWludDE2QXJyYXkiLCJZbSIsIlptIiwid3UiLCJ2dSIsIlFtIiwiWG0iLCJhdCIsIiR1IiwieHUiLCJTdSIsIlR1IiwiSXUiLCJDdSIsIkF1Iiwia3UiLCJFdSIsIlB1IiwienUiLCJzY2FsYXIiLCJ2ZWN0b3IiLCJlZiIsInRmIiwicmYiLCJuZiIsIk91IiwiRHUiLCJCdSIsInFlIiwiS2UiLCJqZSIsImpyIiwieXQiLCJjbGlwTWF4IiwiY2xpcE1pbiIsIkFlIiwiTXUiLCJZciIsIlJ1IiwiVXUiLCJKdCIsIlpyIiwiUXIiLCJvZiIsImFmIiwiaG8iLCJOdSIsInNmIiwiZ28iLCJ1ZiIsImVyIiwiWHIiLCJkZiIsIlZ1IiwiV3UiLCJsZiIsIkx1IiwiSnIiLCJjZiIsIkd1IiwicGYiLCJIdSIsIkZ1IiwicXUiLCJ0cnVuYyIsInRvcCIsImJvdHRvbSIsImxlZnQiLCJyaWdodCIsImZyb250IiwiYmFjayIsInBhZEluZm8iLCJvdXREZXB0aCIsIm91dEhlaWdodCIsIm91dFdpZHRoIiwiZGF0YUZvcm1hdCIsImluRGVwdGgiLCJpbkhlaWdodCIsImluV2lkdGgiLCJpbkNoYW5uZWxzIiwib3V0Q2hhbm5lbHMiLCJzdHJpZGVEZXB0aCIsInN0cmlkZUhlaWdodCIsInN0cmlkZVdpZHRoIiwiZmlsdGVyRGVwdGgiLCJmaWx0ZXJIZWlnaHQiLCJmaWx0ZXJXaWR0aCIsImVmZmVjdGl2ZUZpbHRlckRlcHRoIiwiZWZmZWN0aXZlRmlsdGVySGVpZ2h0IiwiZWZmZWN0aXZlRmlsdGVyV2lkdGgiLCJkaWxhdGlvbkRlcHRoIiwiZGlsYXRpb25IZWlnaHQiLCJkaWxhdGlvbldpZHRoIiwiaW5TaGFwZSIsIm91dFNoYXBlIiwiZmlsdGVyU2hhcGUiLCJLdSIsImp1IiwiWXUiLCJtZiIsImJvIiwiZmYiLCJ5byIsIl9vIiwiWnUiLCJoZiIsImdmIiwid28iLCJRdSIsImtlcm5lbEN1c3RvbURhdGEiLCJ3VCIsImFkYXB0ZXJJbmZvIiwiaXNBcmNoaXRlY3R1cmUiLCJYdSIsIkp1IiwiYmYiLCJ5ZiIsIl9mIiwiZWQiLCJ0ZCIsIndmIiwicmQiLCJ2ZiIsIm5kIiwib2QiLCIkZiIsImFkIiwic2QiLCJnZXRJbnQzMkFycmF5IiwieGYiLCJTZiIsIlRmIiwidWQiLCJkZCIsImxkIiwidm8iLCJlbiIsImNkIiwiSWYiLCJDZiIsIiRvIiwieG8iLCJwZCIsIkFmIiwibWQiLCJmZCIsImhkIiwiYWRkU3ltYm9sIiwic3ltYm9sVG9JbmRpY2VzIiwiaW5wdXRJbmRleCIsInN5bWJvbFRvSW5mbyIsImRpbVZhbHVlIiwiY291bnQiLCJwcm9jZXNzVGVybSIsIm1hdGNoIiwiaGFzRWxsaXBzaXMiLCJlbGxpcHNpc0RpbXMiLCJsaHMiLCJvdXRwdXREaW1zIiwicmhzIiwia2YiLCJnZCIsIkVmIiwiUGYiLCJiZCIsInlkIiwiemYiLCJfZCIsIndkIiwiT2YiLCJEZiIsInZkIiwiJGQiLCJ4ZCIsIkJmIiwiU2QiLCJUZCIsIklkIiwiYmF0Y2hEaW1zIiwiTWYiLCJSZiIsIkNkIiwiQWQiLCJrZCIsIlVmIiwiTmYiLCJFZCIsIlBkIiwiemQiLCJWZiIsIldmIiwiT2QiLCJEZCIsIkJkIiwibHQiLCJfdCIsIlV0IiwiTnQiLCJMZiIsIkdmIiwiSGYiLCJGZiIsInFmIiwiS2YiLCJqZiIsIllmIiwiTWQiLCJSZCIsIlVkIiwiYWxpZ25Db3JuZXJzIiwicGFkZGluZ01vZGUiLCJCZSIsIlhmIiwiVmQiLCJOZCIsIkpmIiwidHIiLCJXZCIsIlNvIiwiZWgiLCJ0aCIsInJoIiwibmgiLCJUbyIsIkxkIiwiR2QiLCJJbyIsIm9oIiwiaWgiLCJIZCIsIkZkIiwicWQiLCJLZCIsImFoIiwic2giLCJqZCIsIllkIiwidWgiLCJkaCIsIlpkIiwiUWQiLCJsaCIsIlhkIiwiSmQiLCJjaCIsInBoIiwibWgiLCJlbCIsInRsIiwicmwiLCJpc1ZlbmRvciIsImZoIiwiaGgiLCJnaCIsImJoIiwieWgiLCJfaCIsIndoIiwidmgiLCJubCIsIm9sIiwidG4iLCJpbCIsImFsIiwic2wiLCJ1bCIsIiRoIiwieGgiLCJkbCIsImxsIiwiY2wiLCJwbCIsIm1sIiwiZmwiLCJobCIsImdsIiwiYmwiLCJ5bCIsIl9sIiwid2wiLCJ2bCIsImNlaWxNb2RlIiwiY291bnRJbmNsdWRlUGFkIiwic3RvcmFnZU9yZGVyIiwiVGgiLCJJaCIsIiRsIiwieGwiLCJTbCIsIkNoIiwiQWgiLCJUbCIsIklsIiwia2giLCJFaCIsIkNsIiwiQWwiLCJrbCIsInJlZHVjdGlvbiIsIlBoIiwiemgiLCJPaCIsIkRoIiwiQmgiLCJNaCIsIlJoIiwiVWgiLCJOaCIsIlZoIiwiV2giLCJFbCIsIkxoIiwiR2giLCJIaCIsIkZoIiwicWgiLCJQbCIsInpsIiwiT2wiLCJyb3VuZCIsIk1BWF9WQUxVRSIsIk1JTl9WQUxVRSIsImN1c3RvbURhdGFCdWZmZXIiLCJLaCIsImpoIiwiRGwiLCJCbCIsIlloIiwiWmgiLCJNbCIsIlJsIiwiUWgiLCJybiIsIlhoIiwiVWwiLCJKaCIsImVnIiwiTmwiLCJWbCIsIldsIiwic2lnbiIsInRnIiwicmciLCJMbCIsIkdsIiwiSGwiLCJGbCIsIm5nIiwib2ciLCJpZyIsInFsIiwiS2wiLCJhZyIsInNnIiwiamwiLCJZbCIsIlpsIiwiUWwiLCJubiIsIlhsIiwiZ2V0QXJ0aWZhY3QiLCJyZXBvIiwic2V0QXJ0aWZhY3QiLCJwcm9ncmFtSW5mbyIsImdldENvbXB1dGVQYXNzRW5jb2RlciIsIndyaXRlVGltZXN0YW1wIiwicGVuZGluZ0Rpc3BhdGNoTnVtYmVyIiwiYmluZGluZyIsInJlc291cmNlIiwiY3JlYXRlQmluZEdyb3VwIiwibGF5b3V0IiwiY29tcHV0ZVBpcGVsaW5lIiwiZ2V0QmluZEdyb3VwTGF5b3V0IiwibGFiZWwiLCJrZXJuZWxJZCIsImN1cnJlbnRLZXJuZWxJZCIsImJpbmRHcm91cCIsInNldFBpcGVsaW5lIiwic2V0QmluZEdyb3VwIiwiZGlzcGF0Y2hXb3JrZ3JvdXBzIiwibWF4RGlzcGF0Y2hOdW1iZXIiLCJxdWVyeVR5cGUiLCJidWlsZCIsImZlYXR1cmUiLCJleHRlbnNpb24iLCJmZWF0dXJlcyIsImNyZWF0ZVNoYWRlck1vZHVsZSIsImNyZWF0ZUNvbXB1dGVQaXBlbGluZSIsImVudHJ5UG9pbnQiLCJ1bmlmb3JtVmFyaWFibGVzSW5mbyIsIm5vcm1hbGl6ZURpc3BhdGNoR3JvdXBTaXplIiwibWF4Q29tcHV0ZVdvcmtncm91cHNQZXJEaW1lbnNpb24iLCJjYnJ0IiwiYXR0cmlidXRlc0JvdW5kIiwidWciLCJkZyIsIkNvIiwiQW8iLCJvbiIsIkpsIiwiYXJjaGl0ZWN0dXJlIiwidmVuZG9yIiwic3ViZ3JvdXBzU3VwcG9ydGVkIiwic3ViZ3JvdXBzRjE2U3VwcG9ydGVkIiwibWluU3ViZ3JvdXBTaXplIiwibWF4U3ViZ3JvdXBTaXplIiwic3ViZ3JvdXBTaXplUmFuZ2UiLCJjdXJyZW50S2VybmVsQ3VzdG9tRGF0YSIsImluaXRpYWxpemUiLCJyZXF1aXJlZExpbWl0cyIsIm1heENvbXB1dGVXb3JrZ3JvdXBTdG9yYWdlU2l6ZSIsIm1heFN0b3JhZ2VCdWZmZXJCaW5kaW5nU2l6ZSIsIm1heEJ1ZmZlclNpemUiLCJyZXF1aXJlZEZlYXR1cmVzIiwicmVxdWVzdERldmljZSIsImRldmljZUluZm8iLCJpbmZvIiwicmVxdWVzdEFkYXB0ZXJJbmZvIiwiZ3B1RGF0YU1hbmFnZXIiLCJwcm9ncmFtTWFuYWdlciIsImtlcm5lbHMiLCJrZXJuZWxQZXJzaXN0ZW50RGF0YSIsImRlYnVnIiwib251bmNhcHR1cmVkZXJyb3IiLCJHUFVWYWxpZGF0aW9uRXJyb3IiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsInNldFF1ZXJ5VHlwZSIsInF1ZXJ5U2V0IiwiY29tbWFuZEVuY29kZXIiLCJjb21wdXRlUGFzc0VuY29kZXIiLCJ0aW1lc3RhbXBXcml0ZXMiLCJiZWdpbm5pbmdPZlBhc3NXcml0ZUluZGV4IiwiZW5kT2ZQYXNzV3JpdGVJbmRleCIsImJlZ2luQ29tcHV0ZVBhc3MiLCJlbmQiLCJyZXNvbHZlUXVlcnlTZXQiLCJxdWVyeVJlc29sdmVCdWZmZXIiLCJwZW5kaW5nUXVlcmllcyIsInBlbmRpbmdLZXJuZWxzIiwia2VybmVsVHlwZSIsImtlcm5lbE5hbWUiLCJwcm9ncmFtTmFtZSIsImlucHV0VGVuc29yVmlld3MiLCJvdXRwdXRUZW5zb3JWaWV3cyIsInF1ZXJ5VGltZUJhc2UiLCJwcm9maWxpbmciLCJvbmRhdGEiLCJ2ZXJzaW9uIiwiaW5wdXRzTWV0YWRhdGEiLCJvdXRwdXRzTWV0YWRhdGEiLCJzdGFydFRpbWUiLCJlbmRUaW1lIiwidGVtcG9yYXJ5RGF0YSIsIndyaXRlQnVmZmVyIiwib2Zmc2V0IiwiY2FwdHVyZWRQZW5kaW5nS2VybmVscyIsImFsbG9jIiwiZnJlZSIsImNyZWF0ZUtlcm5lbCIsImtlcm5lbEVudHJ5IiwiYXR0cmlidXRlcyIsInJlbGVhc2VLZXJuZWwiLCJjb21wdXRlS2VybmVsIiwicHVzaEVycm9yU2NvcGUiLCJwb3BFcnJvclNjb3BlIiwic2Vzc2lvbkV4dGVybmFsRGF0YU1hcHBpbmciLCJ1bnJlZ2lzdGVyQnVmZmVycyIsImNyZWF0ZVF1ZXJ5U2V0IiwiUVVFUllfUkVTT0xWRSIsImNhcHR1cmVCZWdpbiIsImNhcHR1cmVFbmQiLCJyZXBsYXkiLCJsZyIsImNnIiwiYW4iLCJzbiIsImtvIiwidGVuc29yU2hhcGUiLCJ3cml0ZSIsIm1sQ29udGV4dCIsIndyaXRlVGVuc29yIiwicmVhZFRlbnNvciIsImNhblJldXNlVGVuc29yIiwiY29udGV4dCIsInRlbnNvcldyYXBwZXIiLCJ3cmFwcGVyIiwicmVsZWFzZVRlbnNvciIsInRlbnNvck1hbmFnZXIiLCJlbnN1cmVUZW5zb3IiLCJhY3RpdmVVcGxvYWQiLCJNTFRlbnNvclVzYWdlIiwiV1JJVEUiLCJnZXRDYWNoZWRUZW5zb3IiLCJyZXNlcnZlVGVuc29ySWQiLCJ0ZW5zb3JUcmFja2Vyc0J5SWQiLCJyZWxlYXNlVGVuc29ySWQiLCJjdXJyZW50Q29udGV4dCIsInJlbGVhc2VUZW5zb3JzRm9yU2Vzc2lvbiIsImZyZWVUZW5zb3JzIiwicmVnaXN0ZXJUZW5zb3IiLCJleHRlcm5hbFRlbnNvcnMiLCJjcmVhdGVUZW5zb3IiLCJkaW1lbnNpb25zIiwicmVhZGFibGUiLCJwZyIsInVuIiwiYWN0aXZlU2Vzc2lvbklkIiwiR1BVRGV2aWNlIiwibWxDb250ZXh0Q2FjaGUiLCJmaW5kSW5kZXgiLCJncHVEZXZpY2UiLCJjcmVhdGVDb250ZXh0IiwiZ2V0TUxDb250ZXh0IiwibWxDb250ZXh0QnlTZXNzaW9uSWQiLCJzZXNzaW9uSWRzQnlNTENvbnRleHQiLCJ1cGxvYWRUZW5zb3IiLCJzaG91bGRUcmFuc2ZlclRvTUxUZW5zb3IiLCJkb3dubG9hZFRlbnNvciIsImNvbnN0YW50IiwibWciLCJyciIsIkVvIiwiY3VzdG9tRGF0YU9mZnNldCIsImN1c3RvbURhdGFTaXplIiwib3V0cHV0Iiwib3BLZXJuZWxDb250ZXh0IiwiZmciLCJQdCIsImhnIiwidWMiLCJncHUiLCJhZGFwdGVyIiwicG93ZXJQcmVmZXJlbmNlIiwiZm9yY2VGYWxsYmFja0FkYXB0ZXIiLCJyZXF1ZXN0QWRhcHRlciIsImV4dGVybmFsRGF0YSIsInBhdGgiLCJwcmVmZXJyZWRPdXRwdXRMb2NhdGlvbiIsImhhbmRsZSIsIm91dHB1dFByZWZlcnJlZExvY2F0aW9ucyIsIm91dHB1dFByZWZlcnJlZExvY2F0aW9uc0VuY29kZWQiLCJ6dCIsIkxlIiwibnIiLCJsbiIsImNuIiwiZG4iLCJQbyIsInpvIiwiVnQiLCJXdCIsImJnIiwiT28iLCJnYyIsInlnIiwicG4iLCJmZXRjaE1vZGVsQW5kQ29weVRvV2FzbU1lbW9yeSIsImxvYWRNb2RlbCIsIl9jIiwiT25ueHJ1bnRpbWVXZWJBc3NlbWJseUJhY2tlbmQiLCJtbiIsImluaXRpYWxpemVGbGFncyIsInljIiwid2FzbUJhY2tlbmQiLCJfZyIsIndjIiwic2ltZCIsImNwdXMiLCIkMSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/onnxruntime-web/dist/ort.webgpu.bundle.min.mjs?4709\n"));

/***/ })

}]);